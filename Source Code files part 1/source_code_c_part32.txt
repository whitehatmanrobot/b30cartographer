    HWND hwndList = GetDlgItem(IDC_OBJECTLIST);
    ASSERT(hwndList != NULL);
    if( !hwndList ) return 0;

    // Display list of classes that aren't already used (i.e., not in m_vstrCurClasses)
    string_vector::iterator itStr;
    for( itStr = vstrAllObjects.begin(); itStr != vstrAllObjects.end(); itStr++ )
    {
        if( std::find(m_pvstrCurClasses->begin(), m_pvstrCurClasses->end(), *itStr) == m_pvstrCurClasses->end() )
        {
            LPCWSTR pszName = pNameMap ? 
                              pNameMap->GetAttributeDisplayName(itStr->c_str()) : itStr->c_str();

            int iPos = ListBox_AddString(hwndList, const_cast<LPWSTR>(pszName));
            ASSERT(iPos >= 0);

            ListBox_SetItemData(hwndList, iPos, (LPARAM*)itStr->c_str());
        }
    }

    return 0;
}

BOOL CObjSelectWizPage::OnSetActive()
{
    UpdateButtons();
    return TRUE;
}


LRESULT CObjSelectWizPage::OnObjectSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    UpdateButtons();
    return 0;
}


void CObjSelectWizPage::UpdateButtons()
{
    DWORD dwButtons = PSWIZB_BACK;
    if( ListBox_GetCurSel(GetDlgItem(IDC_OBJECTLIST)) >= 0 )
        dwButtons |= PSWIZB_NEXT;

    ::PropSheet_SetWizButtons(GetParent(), dwButtons);
}

LPCWSTR CObjSelectWizPage::GetSelectedClass()
{
    HWND hwndList = GetDlgItem(IDC_OBJECTLIST);
    ASSERT(hwndList != NULL);

    int iSel = ListBox_GetCurSel(hwndList);
    ASSERT(iSel >= 0);

    LPARAM lParam = ListBox_GetItemData(hwndList, iSel);
    ASSERT(lParam != LB_ERR);

    return reinterpret_cast<LPCWSTR>(lParam);
}


//////////////////////////////////////////////////////////////////////////////////////////
// CAddObjectWelcomePage

LRESULT CAddObjectWelcomePage::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if( !m_pWizard ) return 0;

    HFONT hfont = m_pWizard->GetWelcomeFont();
    if( hfont )
        ::SendMessage(GetDlgItem(IDC_WELCOME), WM_SETFONT, (WPARAM)hfont, (LPARAM)0);

    return 0;
}


BOOL CAddObjectWelcomePage::OnSetActive()
{
    ::PostMessage(GetParent(), PSM_SETTITLE, 0, (LPARAM)IDS_ADDOBJECT_WIZ); 
    ::PostMessage(GetParent(), PSM_SETWIZBUTTONS, (WPARAM)0, (LPARAM)PSWIZB_NEXT);

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////////
// CAddObjectCompletionPage

LRESULT CAddObjectCompletionPage::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if( !m_pWizard ) return 0;

    HFONT hfont = m_pWizard->GetWelcomeFont();
    if( hfont )
    {
        ::SendMessage(GetDlgItem(IDC_COMPLETION), WM_SETFONT, (WPARAM)hfont, (LPARAM)0);
    }

    return 0;
}

BOOL CAddObjectCompletionPage::OnSetActive()
{
    if( !m_pClassInfo ) return FALSE;

    const static TCHAR newline[] =  TEXT("\r\n");

    // Get class name table
    DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
    ASSERT( pNameMap );
    if( !pNameMap ) return FALSE;

    // "Allow query node to be created for object: <class name>"
    CString strOut;
    CString strTmp;
    strTmp.LoadString(IDS_OBJFINISH1);
    strOut += strTmp;
    strOut += pNameMap->GetAttributeDisplayName(m_pClassInfo->Name());
    strOut += newline;

    // if any menu items defined
    if( m_pClassInfo->Menus().size() > 0 )
    {
        // "Enable query nodes to use menu items:"    
        strTmp.LoadString(IDS_OBJFINISH2);
        strOut += strTmp;
        strOut += newline;

        menucmd_vector& vMenuCmds = m_pClassInfo->Menus();
        menucmd_vector::iterator itMenuCmd;

        // First add all root menu items that are not yet ref'd by the query node
        for( itMenuCmd = vMenuCmds.begin(); itMenuCmd != vMenuCmds.end(); ++itMenuCmd )
        {
            strOut += "    ";
            strOut += (*itMenuCmd)->Name();
            strOut += newline;
        }
    }

    // if any columns defined
    if( m_pClassInfo->Columns().size() > 0 )
    {
        strTmp.LoadString(IDS_OBJFINISH3);
        strOut += strTmp;
        strOut += newline;

        pNameMap = DisplayNames::GetMap(m_pClassInfo->Name());
        ASSERT(pNameMap != NULL);

        string_vector& vstrColumns = m_pClassInfo->Columns();
        string_vector::iterator itstrCol;

        for( itstrCol = vstrColumns.begin(); itstrCol != vstrColumns.end(); ++itstrCol )
        {
            strOut += "    ";
            strOut += pNameMap->GetAttributeDisplayName(itstrCol->c_str());
            strOut += newline;
        }
    }

    HWND hwndSetting = GetDlgItem(IDC_SETTINGS);
    if( !hwndSetting ) return FALSE;

    // Initially assume scroll bar is needed
    ::ShowScrollBar(hwndSetting, SB_VERT, TRUE);

    // display the text
    ::SetWindowText(hwndSetting, strOut);

    // now hide vertical scroll if we don't need it
    SCROLLINFO si = {0};
    si.cbSize = sizeof(SCROLLINFO);
    si.fMask  = SIF_ALL;
    ::GetScrollInfo(hwndSetting, SB_VERT, &si);

    if( si.nMax < si.nPage )
    {
        // Remove scroll bar and hide edge
        ::ModifyStyleEx( hwndSetting, WS_EX_CLIENTEDGE, 0, SWP_FRAMECHANGED );
        ::ShowScrollBar( hwndSetting, SB_VERT, FALSE );
    }
    else
    {
        // if scroll bar needed, display edge too
        ::ModifyStyleEx( hwndSetting, 0, WS_EX_CLIENTEDGE, SWP_FRAMECHANGED );
    }

    EnableDlgItem( m_hWnd, IDC_SETTINGS, FALSE );
    EnableDlgItem( m_hWnd, IDC_SETTINGS, TRUE  );

    ::PostMessage(GetParent(), PSM_SETWIZBUTTONS, (WPARAM)0, (LPARAM)PSWIZB_BACK|PSWIZB_FINISH);

    // enable edit field to handle first focus
    bFirstFocus = TRUE;

    return TRUE;
}


LRESULT CAddObjectCompletionPage::OnSetFocus( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    // on first focus, cancel the selection so the user doesn't see the entire field inverted
    if( bFirstFocus )
    {
        ::SendMessage(GetDlgItem(IDC_SETTINGS), EM_SETSEL, (WPARAM)0, (LPARAM)0);
        bFirstFocus = FALSE;   
    }

    return 0;
}



///////////////////////////////////////////////////////////////////////////////////////
// Non-member functions

HRESULT GetClassNameList(QueryObjVector& vObjects, tstring& strNames, LPCWSTR pszSeparator)
{
    if( vObjects.size() == 0 )
        return S_FALSE;

    DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
    ASSERT( pNameMap );
    if( !pNameMap ) return E_FAIL;

    QueryObjVector::iterator itQObj = vObjects.begin();
    strNames = pNameMap->GetAttributeDisplayName(itQObj->Name());

    for( itQObj++; itQObj != vObjects.end(); ++itQObj )
    {
        strNames += pszSeparator;
        strNames += pNameMap->GetAttributeDisplayName(itQObj->Name());
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\adminpackandwebpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      AdminPackAndWebPage.h
//
// Synopsis:  Defines the AdminPackAndWebPage that
//            asks the user if they want to install
//            the Admin Pack and the Web Admin tools
//
// History:   06/01/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "AdminPackAndWebPage.h"
#include "state.h"


static PCWSTR ADMIN_PACK_AND_WEB_PAGE_HELP = L"cys.chm::/cys_adminpack.htm";

AdminPackAndWebPage::AdminPackAndWebPage()
   :
   CYSWizardPage(
      IDD_ADMIN_PACK_AND_WEB_PAGE, 
      IDS_ADMIN_PACK_TITLE, 
      IDS_ADMIN_PACK_SUBTITLE, 
      ADMIN_PACK_AND_WEB_PAGE_HELP)
{
   LOG_CTOR(AdminPackAndWebPage);
}

   

AdminPackAndWebPage::~AdminPackAndWebPage()
{
   LOG_DTOR(AdminPackAndWebPage);
}


void
AdminPackAndWebPage::OnInit()
{
   LOG_FUNCTION(AdminPackAndWebPage::OnInit);

   Win::SetDlgItemText(
      hwnd, 
      IDC_TOO_LONG_STATIC,
      String::load(IDS_ADMIN_PACK_PAGE_TEXT));
}


bool
AdminPackAndWebPage::OnSetActive()
{
   LOG_FUNCTION(AdminPackAndWebPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}


int
AdminPackAndWebPage::Validate()
{
   LOG_FUNCTION(AdminPackAndWebPage::Validate);

   int nextPage = IDD_MILESTONE_PAGE;

   // Get the checkbox value to see if we should install
   // the Admin Pack

   InstallationUnitProvider::GetInstance().GetAdminPackInstallationUnit().SetInstallAdminPack(
      Win::Button_GetCheck(
         Win::GetDlgItem(
            hwnd,
            IDC_INSTALL_ADMINPACK_CHECK)));

   InstallationUnitProvider::GetInstance().GetSAKInstallationUnit().SetInstallWebAdmin(
      Win::Button_GetCheck(
         Win::GetDlgItem(
            hwnd,
            IDC_INSTALL_WEBADMIN_CHECK)));

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\adminpackandnaspage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      AdminPackAndNASPage.h
//
// Synopsis:  Declares the AdminPackAndNASPage that
//            asks the user if they want to install
//            the Admin Pack and Network Attached
//            Storage (NAS) admin tools
//
// History:   06/01/2001  JeffJon Created

#ifndef __CYS_ADMINPACKANDNASPAGE_H
#define __CYS_ADMINPACKANDNASPAGE_H

#include "CYSWizardPage.h"

class AdminPackAndNASPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      AdminPackAndNASPage();

      // Destructor

      virtual 
      ~AdminPackAndNASPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();

   private:

      // not defined: no copying allowed
      AdminPackAndNASPage(const AdminPackAndNASPage&);
      const AdminPackAndNASPage& operator=(const AdminPackAndNASPage&);

};


#endif // __CYS_ADMINPACKANDNASPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\adminpackandnaspage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      AdminPackAndNASPage.h
//
// Synopsis:  Defines the AdminPackAndNASPage that
//            asks the user if they want to install
//            the Admin Pack and Network Attached
//            Storage (NAS) admin tools
//
// History:   06/01/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "AdminPackAndNASPage.h"
#include "state.h"


static PCWSTR ADMIN_PACK_AND_NAS_PAGE_HELP = L"cys.chm::/cys_adminpack.htm";

AdminPackAndNASPage::AdminPackAndNASPage()
   :
   CYSWizardPage(
      IDD_ADMIN_PACK_AND_NAS_PAGE, 
      IDS_ADMIN_PACK_TITLE, 
      IDS_ADMIN_PACK_SUBTITLE, 
      ADMIN_PACK_AND_NAS_PAGE_HELP)
{
   LOG_CTOR(AdminPackAndNASPage);
}

   

AdminPackAndNASPage::~AdminPackAndNASPage()
{
   LOG_DTOR(AdminPackAndNASPage);
}


void
AdminPackAndNASPage::OnInit()
{
   LOG_FUNCTION(AdminPackAndNASPage::OnInit);

   Win::SetDlgItemText(
      hwnd, 
      IDC_TOO_LONG_STATIC,
      String::load(IDS_ADMIN_PACK_PAGE_TEXT));
}


bool
AdminPackAndNASPage::OnSetActive()
{
   LOG_FUNCTION(AdminPackAndNASPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}


int
AdminPackAndNASPage::Validate()
{
   LOG_FUNCTION(AdminPackAndNASPage::Validate);

   int nextPage = IDD_MILESTONE_PAGE;

   // Get the checkbox value to see if we should install
   // the Admin Pack

   InstallationUnitProvider::GetInstance().GetAdminPackInstallationUnit().SetInstallAdminPack(
      Win::Button_GetCheck(
         Win::GetDlgItem(
            hwnd,
            IDC_INSTALL_ADMINPACK_CHECK)));

   InstallationUnitProvider::GetInstance().GetSAKInstallationUnit().SetInstallNASAdmin(
      Win::Button_GetCheck(
         Win::GetDlgItem(
            hwnd,
            IDC_INSTALL_NASADMIN_CHECK)));

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\adminpackandwebpage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      AdminPackAndWebPage.h
//
// Synopsis:  Declares the AdminPackAndWebPage that
//            asks the user if they want to install
//            the Admin Pack and the Web Admin tools
//
// History:   06/01/2001  JeffJon Created

#ifndef __CYS_ADMINPACKANDWEBPAGE_H
#define __CYS_ADMINPACKANDWEBPAGE_H

#include "CYSWizardPage.h"

class AdminPackAndWebPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      AdminPackAndWebPage();

      // Destructor

      virtual 
      ~AdminPackAndWebPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();

   private:

      // not defined: no copying allowed
      AdminPackAndWebPage(const AdminPackAndWebPage&);
      const AdminPackAndWebPage& operator=(const AdminPackAndWebPage&);

};


#endif // __CYS_ADMINPACKANDWEBPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\adinstallationunit.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      ADInstallationUnit.h
//
// Synopsis:  Declares a ADInstallationUnit
//            This object has the knowledge for installing 
//            Active Directory
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_ADINSTALLATIONUNIT_H
#define __CYS_ADINSTALLATIONUNIT_H

#include "ExpressPathInstallationUnitBase.h"

extern PCWSTR CYS_DCPROMO_COMMAND_LINE;

class ADInstallationUnit : public ExpressPathInstallationUnitBase
{
   public:
      
      // Constructor

      ADInstallationUnit();

      // Destructor
      virtual
      ~ADInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      UnInstallReturnType
      UnInstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      InstallationReturnType
      ExpressPathInstall(HANDLE logfileHandle, HWND hwnd);

      virtual
      String
      GetServiceDescription();

      virtual
      bool
      GetMilestoneText(String& message);

      virtual
      bool
      GetUninstallMilestoneText(String& message);

      virtual
      void
      ServerRoleLinkSelected(int linkIndex, HWND hwnd);

      virtual
      void
      FinishLinkSelected(int inkIndex, HWND hwnd);

      virtual
      String
      GetFinishText();

      virtual
      bool
      DoInstallerCheck(HWND hwnd) const;

      // Data accessors

      void
      SetNewDomainDNSName(const String& newDomain);

      String
      GetNewDomainDNSName() const { return domain; }

      void
      SetNewDomainNetbiosName(const String& newNetbios);

      String
      GetNewDomainNetbiosName() const { return netbios; }

      void
      SetSafeModeAdminPassword(const String& newPassword);

      String
      GetSafeModeAdminPassword() const { return password; }

      bool
      SyncRestoreModePassword() const;

      String
      GetDCPromoPath() const;

   private:

      bool
      RegisterPasswordSyncDLL();

      bool
      CreateAnswerFileForDCPromo(String& answerFilePath);

      bool
      ReadConfigWizardRegkeys(String& configWizardResults) const;

      bool   isExpressPathInstall;
      bool   syncRestoreModePassword;
      String domain;
      String netbios;
      String password;
};

#endif // __CYS_ADINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\adinstallationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      ADInstallationUnit.cpp
//
// Synopsis:  Defines a ADInstallationUnit
//            This object has the knowledge for installing 
//            Active Directory
//
// History:   02/08/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"


extern PCWSTR CYS_DCPROMO_COMMAND_LINE = L"dcpromo.exe";

// Exit codes borrowed from DCPromo.cpp

enum DCPromoExitCodes
{
   // the operation failed.

   EXIT_CODE_UNSUCCESSFUL = 0,

   // the operation succeeded

   EXIT_CODE_SUCCESSFUL = 1,

   // the operation succeeded, and the user opted not to have the wizard
   // restart the machine, either manually or by specifying
   // RebootOnSuccess=NoAndNoPromptEither in the answerfile

   EXIT_CODE_SUCCESSFUL_NO_REBOOT = 2,

   // the operation failed, but the machine needs to be rebooted anyway

   EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT = 3
};

// Finish page help 
static PCWSTR CYS_AD_FINISH_PAGE_HELP = L"cys.chm::/ad_server_role.htm";
static PCWSTR CYS_AD_MILESTONE_HELP = L"cys.chm::/ad_server_role.htm#adsrvsummary";
static PCWSTR CYS_AD_AFTER_FINISH_HELP = L"cys.chm::/ad_server_role.htm#adsrvcompletion";

ADInstallationUnit::ADInstallationUnit() :
   syncRestoreModePassword(true),
   ExpressPathInstallationUnitBase(
      IDS_DOMAIN_CONTROLLER_TYPE, 
      IDS_DOMAIN_CONTROLLER_DESCRIPTION, 
      IDS_AD_FINISH_TITLE,
      IDS_AD_FINISH_UNINSTALL_TITLE,
      IDS_AD_FINISH_MESSAGE,
      IDS_AD_INSTALL_FAILED,
      IDS_AD_UNINSTALL_MESSAGE,
      IDS_AD_UNINSTALL_FAILED,
      IDS_AD_UNINSTALL_WARNING,
      IDS_AD_UNINSTALL_CHECKBOX,
      CYS_AD_FINISH_PAGE_HELP,
      CYS_AD_MILESTONE_HELP,
      CYS_AD_AFTER_FINISH_HELP,
      DC_SERVER)
{
   LOG_CTOR(ADInstallationUnit);
}


ADInstallationUnit::~ADInstallationUnit()
{
   LOG_DTOR(ADInstallationUnit);
}


InstallationReturnType 
ADInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(ADInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS_REBOOT;

   do
   {
      if (IsExpressPathInstall())
      {
         result = ExpressPathInstall(logfileHandle, hwnd);
         break;
      }

      // Write the heading to the log file

      CYS_APPEND_LOG(String::load(IDS_LOG_DOMAIN_CONTROLLER_HEADING));

      UpdateInstallationProgressText(hwnd, IDS_AD_PROGRESS);

      // Set the home regkey so that we go through post boot operations

      bool regkeyResult = SetRegKeyValue(
                             CYS_HOME_REGKEY, 
                             CYS_HOME_VALUE, 
                             CYS_HOME_REGKEY_DCPROMO_VALUE,
                             HKEY_LOCAL_MACHINE,
                             true);
      ASSERT(regkeyResult);

      // set the key so CYS has to run again

      regkeyResult = SetRegKeyValue(
                        CYS_HOME_REGKEY, 
                        CYS_HOME_REGKEY_MUST_RUN, 
                        CYS_HOME_RUN_KEY_RUN_AGAIN,
                        HKEY_LOCAL_MACHINE,
                        true);
      ASSERT(regkeyResult);

      // Run dcpromo.exe

      DWORD exitCode = 0;

      HRESULT hr = CreateAndWaitForProcess(
                      GetDCPromoPath(), 
                      String(), 
                      exitCode);

      if (FAILED(hr) ||
          exitCode == EXIT_CODE_UNSUCCESSFUL ||
          exitCode == EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT)
      {
         CYS_APPEND_LOG(String::load(IDS_LOG_DOMAIN_CONTROLLER_SERVER));
         CYS_APPEND_LOG(String::load(IDS_LOG_WIZARD_CANCELLED));

         if (exitCode == EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT)
         {
            result = INSTALL_FAILURE_NEEDS_REBOOT;
         }
         else
         {
            result = INSTALL_FAILURE;
         }
         break;
      }

      if (exitCode == EXIT_CODE_SUCCESSFUL_NO_REBOOT)
      {
         result = INSTALL_SUCCESS_NEEDS_REBOOT;
         break;
      }

   } while (false);

   if (result == INSTALL_FAILURE)
   {
      // Reset the regkeys so that the post reboot status page does not
      // run after reboot or logoff-logon

      bool regkeyResult = SetRegKeyValue(
                             CYS_HOME_REGKEY, 
                             CYS_HOME_VALUE, 
                             CYS_HOME_REGKEY_DEFAULT_VALUE,
                             HKEY_LOCAL_MACHINE,
                             true);
      ASSERT(regkeyResult);

      // Set the the first DC regkey

      regkeyResult = SetRegKeyValue(
                        CYS_HOME_REGKEY, 
                        CYS_FIRST_DC_VALUE, 
                        CYS_FIRST_DC_VALUE_UNSET,
                        HKEY_LOCAL_MACHINE,
                        true);
      ASSERT(regkeyResult);

      // set the key so CYS does not run after reboot

      regkeyResult = SetRegKeyValue(
                        CYS_HOME_REGKEY, 
                        CYS_HOME_REGKEY_MUST_RUN, 
                        CYS_HOME_RUN_KEY_DONT_RUN,
                        HKEY_LOCAL_MACHINE,
                        true);
      ASSERT(regkeyResult);

   }

   LOG_INSTALL_RETURN(result);

   return result;
}

UnInstallReturnType
ADInstallationUnit::UnInstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(ADInstallationUnit::UnInstallService);

   UnInstallReturnType result = UNINSTALL_SUCCESS_REBOOT;

   do
   {
      // Write the heading to the log file

      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_DOMAIN_CONTROLLER_HEADING));

      UpdateInstallationProgressText(hwnd, IDS_AD_UNINSTALL_PROGRESS);

      // Set the home regkey so that we go through post boot operations

      bool regkeyResult = SetRegKeyValue(
                             CYS_HOME_REGKEY, 
                             CYS_HOME_VALUE, 
                             CYS_HOME_REGKEY_DCDEMOTE_VALUE,
                             HKEY_LOCAL_MACHINE,
                             true);
      ASSERT(regkeyResult);

      // set the key so CYS has to run again

      regkeyResult = SetRegKeyValue(
                        CYS_HOME_REGKEY, 
                        CYS_HOME_REGKEY_MUST_RUN, 
                        CYS_HOME_RUN_KEY_RUN_AGAIN,
                        HKEY_LOCAL_MACHINE,
                        true);
      ASSERT(regkeyResult);

      // Run dcpromo.exe

      DWORD exitCode = 0;

      HRESULT hr = CreateAndWaitForProcess(
                      GetDCPromoPath(), 
                      String(), 
                      exitCode);

      if (FAILED(hr) ||
          exitCode == EXIT_CODE_UNSUCCESSFUL ||
          exitCode == EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT)
      {
         CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_DOMAIN_CONTROLLER_SERVER));
         CYS_APPEND_LOG(String::load(IDS_LOG_WIZARD_CANCELLED));

         if (exitCode == EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT)
         {
            result = UNINSTALL_FAILURE_NEEDS_REBOOT;
         }
         else
         {
            result = UNINSTALL_FAILURE;
         }
         break;
      }

      if (exitCode == EXIT_CODE_SUCCESSFUL_NO_REBOOT)
      {
         result = UNINSTALL_SUCCESS_NEEDS_REBOOT;
      }

   } while (false);

   if (result == UNINSTALL_FAILURE)
   {
      // Reset the regkeys so that the post reboot status page does not
      // run after reboot or logoff-logon

      bool regkeyResult = SetRegKeyValue(
                             CYS_HOME_REGKEY, 
                             CYS_HOME_VALUE, 
                             CYS_HOME_REGKEY_DEFAULT_VALUE,
                             HKEY_LOCAL_MACHINE,
                             true);
      ASSERT(regkeyResult);

      // Set the the first DC regkey

      regkeyResult = SetRegKeyValue(
                        CYS_HOME_REGKEY, 
                        CYS_FIRST_DC_VALUE, 
                        CYS_FIRST_DC_VALUE_UNSET,
                        HKEY_LOCAL_MACHINE,
                        true);
      ASSERT(regkeyResult);
   }
   LOG_UNINSTALL_RETURN(result);

   return result;
}


InstallationReturnType 
ADInstallationUnit::ExpressPathInstall(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(ADInstallationUnit::ExpressPathInstall);

   InstallationReturnType result = INSTALL_SUCCESS_REBOOT;

   // Set the rerun state to false since DCPromo requires a reboot

//   State::GetInstance().SetRerunWizard(false);

   UpdateInstallationProgressText(hwnd, IDS_AD_PROGRESS_EXPRESS);

   // All these regkeys need to be set before we launch DCPromo because DCPromo
   // will reboot the machine

   // First set the home regkey to FirstServer so that we finish up the installation
   // after reboot

   bool regkeyResult = SetRegKeyValue(
                          CYS_HOME_REGKEY, 
                          CYS_HOME_VALUE, 
                          CYS_HOME_REGKEY_FIRST_SERVER_VALUE,
                          HKEY_LOCAL_MACHINE,
                          true);
   ASSERT(regkeyResult);

   // Set the the first DC regkey

   regkeyResult = SetRegKeyValue(
                     CYS_HOME_REGKEY, 
                     CYS_FIRST_DC_VALUE, 
                     CYS_FIRST_DC_VALUE_SET,
                     HKEY_LOCAL_MACHINE,
                     true);
   ASSERT(regkeyResult);

   // set the key so CYS has to run again

   regkeyResult = SetRegKeyValue(
                     CYS_HOME_REGKEY, 
                     CYS_HOME_REGKEY_MUST_RUN, 
                     CYS_HOME_RUN_KEY_RUN_AGAIN,
                     HKEY_LOCAL_MACHINE,
                     true);
   ASSERT(regkeyResult);

   // set the key to let the reboot know what the domain DNS name is

   regkeyResult = SetRegKeyValue(
                     CYS_HOME_REGKEY,
                     CYS_HOME_REGKEY_DOMAINDNS,
                     GetNewDomainDNSName(),
                     HKEY_LOCAL_MACHINE,
                     true);

   ASSERT(regkeyResult);

   // set the key to let the reboot know what the IP address is

   regkeyResult = SetRegKeyValue(
                     CYS_HOME_REGKEY,
                     CYS_HOME_REGKEY_DOMAINIP,
                     InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().GetStaticIPAddressString(),
                     HKEY_LOCAL_MACHINE,
                     true);

   ASSERT(regkeyResult);

   do
   {
      // Register the dsrestore.dll which will sync the restore mode
      // password and the admin password

      if (SyncRestoreModePassword())
      {
         if (!RegisterPasswordSyncDLL())
         {
            // REVIEW_JEFFJON : ignore failures for now
//            result = INSTALL_FAILURE;
//            break;
         }
      }

      // Create answer file for DCPromo

      String answerFilePath;
      bool answerFileResult = CreateAnswerFileForDCPromo(answerFilePath);

      if (!answerFileResult)
      {
         ASSERT(answerFileResult);
         result = INSTALL_FAILURE;

         InstallationUnitProvider::GetInstance().
            GetExpressInstallationUnit().SetExpressRoleResult(
               ExpressInstallationUnit::EXPRESS_AD_FAILURE);

         CYS_APPEND_LOG(String::load(IDS_AD_EXPRESS_LOG_FAILURE));

         break;
      }

      // construct the command line and then call DCPromo

      String commandline = String::format(
                              L"/answer:%1",
                              answerFilePath.c_str());

      DWORD exitCode = 0;
      HRESULT hr = CreateAndWaitForProcess(
                      GetDCPromoPath(), 
                      commandline, 
                      exitCode);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to launch DCPromo: hr = %1!x!",
                hr));
         result = INSTALL_FAILURE;

         InstallationUnitProvider::GetInstance().
            GetExpressInstallationUnit().SetExpressRoleResult(
               ExpressInstallationUnit::EXPRESS_AD_FAILURE);

         CYS_APPEND_LOG(String::load(IDS_AD_EXPRESS_LOG_FAILURE));

         break;
      }

      if (exitCode == EXIT_CODE_UNSUCCESSFUL ||
          exitCode == EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT)
      {
         LOG(String::format(
                L"DCPromo failed: exitCode = %1!x!",
                exitCode));
         result = INSTALL_FAILURE;

         InstallationUnitProvider::GetInstance().
            GetExpressInstallationUnit().SetExpressRoleResult(
               ExpressInstallationUnit::EXPRESS_AD_FAILURE);

         CYS_APPEND_LOG(String::load(IDS_AD_EXPRESS_LOG_FAILURE));

         break;
      }

      // We can't do anything else here because DCPromo will reboot

   } while (false);

   if (result == INSTALL_FAILURE)
   {
      // Reset the regkeys so that the post reboot status page does not
      // run after reboot or logoff-logon

       regkeyResult = SetRegKeyValue(
                         CYS_HOME_REGKEY, 
                         CYS_HOME_VALUE, 
                         CYS_HOME_REGKEY_DEFAULT_VALUE,
                         HKEY_LOCAL_MACHINE,
                         true);
      ASSERT(regkeyResult);

      // Set the the first DC regkey

      regkeyResult = SetRegKeyValue(
                        CYS_HOME_REGKEY, 
                        CYS_FIRST_DC_VALUE, 
                        CYS_FIRST_DC_VALUE_UNSET,
                        HKEY_LOCAL_MACHINE,
                        true);
      ASSERT(regkeyResult);

      // set the key so CYS doesn't have to run again

      regkeyResult = SetRegKeyValue(
                        CYS_HOME_REGKEY, 
                        CYS_HOME_REGKEY_MUST_RUN, 
                        CYS_HOME_RUN_KEY_DONT_RUN,
                        HKEY_LOCAL_MACHINE,
                        true);
      ASSERT(regkeyResult);
   }

   LOG_INSTALL_RETURN(result);

   return result;
}


bool
ADInstallationUnit::RegisterPasswordSyncDLL()
{
   LOG_FUNCTION(ADInstallationUnit::RegisterPasswordSyncDLL);

   bool result = true;

   HINSTANCE dsrestore = 0;

   do
   {
      HRESULT hr =  Win::LoadLibrary(L"dsrestor.dll", dsrestore);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"LoadLibrary failed: hr = 0x%1!x!",
                hr));

         result = false;
         break;
      }

      FARPROC proc = 0;
      hr = Win::GetProcAddress(dsrestore, L"RegisterFilter", proc);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"GetProcAddress Failed: hr = 0x%1!x!",
                hr));

         result = false;
         break;
      }

      typedef HRESULT (*REGISTERFILTER)(void);

      REGISTERFILTER regFilter = reinterpret_cast<REGISTERFILTER>(proc);

      hr = regFilter();
      if (FAILED(hr))
      {
         LOG(String::format(
                L"RegisterFilter failed: hr = 0x%1!x!",
                hr));

         result = false;
         break;
      }

   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
ADInstallationUnit::CreateAnswerFileForDCPromo(String& answerFilePath)
{
   LOG_FUNCTION(ADInstallationUnit::CreateAnswerFileForDCPromo);

   bool result = true;

   String answerFileText = L"[DCInstall]\r\n";
   answerFileText += L"ReplicaOrNewDomain=Domain\r\n";
   answerFileText += L"TreeOrChild=Tree\r\n";
   answerFileText += L"CreateOrJoin=Create\r\n";
   answerFileText += L"DomainNetbiosName=";
   answerFileText += GetNewDomainNetbiosName();
   answerFileText += L"\r\n";
   answerFileText += L"NewDomainDNSName=";
   answerFileText += GetNewDomainDNSName();
   answerFileText += L"\r\n";
   answerFileText += L"DNSOnNetwork=No\r\n";
   answerFileText += L"DatabasePath=%systemroot%\\ntds\r\n";
   answerFileText += L"LogPath=%systemroot%\\ntds\r\n";
   answerFileText += L"SYSVOLPath=%systemroot%\\sysvol\r\n";
   answerFileText += L"SiteName=Default-First-Site\r\n";
   answerFileText += L"RebootOnSuccess=Yes\r\n";
   answerFileText += L"AutoConfigDNS=Yes\r\n";
   answerFileText += L"AllowAnonymousAccess=No\r\n";
   answerFileText += L"DisableCancelForDnsInstall=YES\r\n";

   String sysFolder = Win::GetSystemDirectory();
   answerFilePath = sysFolder + L"\\dcpromo.inf"; 

   // create the answer file for DCPromo

   LOG(String::format(
          L"Creating answer file at: %1",
          answerFilePath.c_str()));

   HRESULT hr = CreateTempFile(answerFilePath, answerFileText);
   if (FAILED(hr))
   {
      LOG(String::format(
             L"Failed to create answer file for DCPromo: hr = %1!x!",
             hr));
      result = false;
   }

   LOG_BOOL(result);
   return result;
}

String
ADInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(ADInstallationUnit::GetServiceDescription);

   unsigned int resourceID = static_cast<unsigned int>(-1);

   if (IsServiceInstalled())
   {
      resourceID = IDS_DOMAIN_CONTROLLER_DESCRIPTION_INSTALLED;
   }
   else
   {
      resourceID = descriptionID;
   }

   ASSERT(resourceID != static_cast<unsigned int>(-1));

   return String::load(resourceID);
}

bool
ADInstallationUnit::GetMilestoneText(String& message)
{
   LOG_FUNCTION(ADInstallationUnit::GetMilestoneText);

   message = String::load(IDS_DC_FINISH_TEXT);

   LOG_BOOL(true);
   return true;
}

bool
ADInstallationUnit::GetUninstallMilestoneText(String& message)
{
   LOG_FUNCTION(ADInstallationUnit::GetUninstallMilestoneText);

   message = String::load(IDS_AD_UNINSTALL_TEXT);

   LOG_BOOL(true);
   return true;
}

void
ADInstallationUnit::SetNewDomainDNSName(const String& newDomain)
{
   LOG_FUNCTION2(
      ADInstallationUnit::SetNewDomainDNSName,
      newDomain);

   domain = newDomain;
}

void
ADInstallationUnit::SetNewDomainNetbiosName(const String& newNetbios)
{
   LOG_FUNCTION2(
      ADInstallationUnit::SetNewDomainNetbiosName,
      newNetbios);

   netbios = newNetbios;
}


void
ADInstallationUnit::SetSafeModeAdminPassword(const String& newPassword)
{
   LOG_FUNCTION(ADInstallationUnit::SetSafeModeAdminPassword);

   password = newPassword;
}

bool
ADInstallationUnit::SyncRestoreModePassword() const
{
   LOG_FUNCTION(ADInstallationUnit::SyncRestoreModePassword);

   LOG_BOOL(syncRestoreModePassword);

   return syncRestoreModePassword;
}

void
ADInstallationUnit::ServerRoleLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      ADInstallationUnit::ServerRoleLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (IsServiceInstalled())
   {
      ASSERT(linkIndex == 0);

      LaunchMYS();
   }
   else
   {
      ASSERT(linkIndex == 0);

      LOG(L"Showing configuration help");

      ShowHelp(CYS_AD_FINISH_PAGE_HELP);
   }
}
  
void
ADInstallationUnit::FinishLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      ADInstallationUnit::FinishLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (installing)
   {
      if (IsServiceInstalled())
      {
         if (linkIndex == 0)
         {
            LOG("Showing after checklist");

            ShowHelp(CYS_AD_AFTER_FINISH_HELP);
         }
      }
      else
      {
         ASSERT(linkIndex == 0);

         HRESULT hr = MyCreateProcess(GetDCPromoPath(), String());
         ASSERT(SUCCEEDED(hr));
      }
   }
   else
   {
      ASSERT(linkIndex == 0);

      // launch DCPROMO

      HRESULT hr = MyCreateProcess(GetDCPromoPath(), String());
      ASSERT(SUCCEEDED(hr));
   }
}

String
ADInstallationUnit::GetFinishText()
{
   LOG_FUNCTION(ADInstallationUnit::GetFinishText);

   unsigned int messageID = finishMessageID;

   if (installing)
   {
      InstallationReturnType result = GetInstallResult();
      if (result == INSTALL_FAILURE ||
          result == INSTALL_NO_CHANGES ||
          result == INSTALL_CANCELLED)
      {
         messageID = finishInstallFailedMessageID;
      }
      else if (result == INSTALL_SUCCESS_NEEDS_REBOOT)
      {
         messageID = IDS_AD_FINISH_MESSAGE_NEEDS_REBOOT;
      }
      else if (result == INSTALL_FAILURE_NEEDS_REBOOT)
      {
         messageID = IDS_AD_INSTALL_FAILED_NEEDS_REBOOT;
      }
   }
   else
   {
      messageID = finishUninstallMessageID;

      UnInstallReturnType result = GetUnInstallResult();
      if (result == UNINSTALL_FAILURE ||
          result == UNINSTALL_NO_CHANGES ||
          result == UNINSTALL_CANCELLED)
      {
         messageID = finishUninstallFailedMessageID;
      }
      else if (result == UNINSTALL_SUCCESS_NEEDS_REBOOT)
      {
         messageID = IDS_AD_UNINSTALL_MESSAGE_NEEDS_REBOOT;
      }
      else if (result == UNINSTALL_FAILURE_NEEDS_REBOOT)
      {
         messageID = IDS_AD_UNINSTALL_FAILED_NEEDS_REBOOT;
      }
   }

   return String::load(messageID);
}

String
ADInstallationUnit::GetDCPromoPath() const
{
   LOG_FUNCTION(ADInstallationUnit::GetDCPromoPath);

   String result = Win::GetSystemDirectory();
   result = FS::AppendPath(result, CYS_DCPROMO_COMMAND_LINE);

   LOG(result);
   return result;
}

bool
ADInstallationUnit::DoInstallerCheck(HWND hwnd) const
{
   LOG_FUNCTION(ADInstallationUnit::DoInstallerCheck);

   bool result = State::GetInstance().IsDCPromoRunning();

   if (result)
   {
      LOG(L"DCPromo is running");

      popup.MessageBox(
         Win::GetParent(hwnd),
         IDS_DCPROMO_RUNNING2,
         MB_OK);
   }

   LOG_BOOL(result);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\adminpackinstallationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      AdminPackInstallationUnit.cpp
//
// Synopsis:  Defines a AdminPackInstallationUnit
//            This object has the knowledge for installing 
//            the Administration Tools Pack
//
// History:   06/01/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "state.h"

// Define the GUIDs used by the Server Appliance Kit COM object

#include <initguid.h>
DEFINE_GUID(CLSID_SaInstall,0x142B8185,0x53AE,0x45B3,0x88,0x8F,0xC9,0x83,0x5B,0x15,0x6C,0xA9);
DEFINE_GUID(IID_ISaInstall,0xF4DEDEF3,0x4D83,0x4516,0xBC,0x1E,0x10,0x3A,0x63,0xF5,0xF0,0x14);


AdminPackInstallationUnit::AdminPackInstallationUnit() :
   installAdminPack(false),
   installWebAdmin(false),
   installNASAdmin(false),
   InstallationUnit(
      IDS_ADMIN_PACK_TYPE, 
      IDS_ADMIN_PACK_DESCRIPTION, 
      IDS_PROGRESS_SUBTITLE,
      IDS_FINISH_TITLE,
      IDS_FINISH_MESSAGE,
      L"",
      L"",
      ADMINPACK_SERVER)
{
   LOG_CTOR(AdminPackInstallationUnit);
}


AdminPackInstallationUnit::~AdminPackInstallationUnit()
{
   LOG_DTOR(AdminPackInstallationUnit);
}


InstallationReturnType 
AdminPackInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(AdminPackInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   do
   {
      String computerName = State::GetInstance().GetComputerName();

      if (GetInstallNASAdmin())
      {
         // First check to see if IIS is installed and
         // install it if not
         
         WebInstallationUnit& webInstallationUnit =
            InstallationUnitProvider::GetInstance().GetWebInstallationUnit();

         if (!webInstallationUnit.IsServiceInstalled())
         {
            webInstallationUnit.InstallService(logfileHandle, hwnd);

            // Ignore the return value because the SAK installation
            // portion will actually provide the best error message
         }

         String logText;
         String errorMessage;

         result = InstallNASAdmin(errorMessage);
         if (result == INSTALL_FAILURE)
         {
            logText = String::format(
                         IDS_NAS_ADMIN_LOG_FAILED,
                         errorMessage.c_str());
         }
         else
         {
            if (errorMessage.empty())
            {
               logText = String::format(
                            IDS_NAS_ADMIN_LOG_SUCCESS,
                            computerName.c_str());
            }
            else
            {
               logText = String::format(
                            IDS_NAS_ADMIN_LOG_SUCCESS_WITH_MESSAGE,
                            errorMessage.c_str());
            }
         }
         CYS_APPEND_LOG(logText);

      }
   
      if (GetInstallWebAdmin())
      {
         
         // First check to see if IIS is installed and
         // install it if not
         
         WebInstallationUnit& webInstallationUnit =
            InstallationUnitProvider::GetInstance().GetWebInstallationUnit();

         if (!webInstallationUnit.IsServiceInstalled())
         {
            webInstallationUnit.InstallService(logfileHandle, hwnd);

            // Ignore the return value because the SAK installation
            // portion will actually provide the best error message
         }

         String logText;
         String errorMessage;

         result = InstallWebAdmin(errorMessage);
         if (result == INSTALL_FAILURE)
         {
            logText = String::format(
                         IDS_WEB_ADMIN_LOG_FAILED,
                         errorMessage.c_str());
         }
         else
         {
            logText = String::format(
                         IDS_WEB_ADMIN_LOG_SUCCESS,
                         computerName.c_str());
         }
         CYS_APPEND_LOG(logText);
      }

      if (GetInstallAdminPack())
      {
         InstallationReturnType adminPackResult = InstallAdminPack();
         if (adminPackResult == INSTALL_FAILURE)
         {
            CYS_APPEND_LOG(String::load(IDS_ADMIN_PACK_LOG_FAILED));
            result = adminPackResult;
         }
         else
         {
            CYS_APPEND_LOG(String::load(IDS_ADMIN_PACK_LOG_SUCCESS));
         }
      }
      
   } while (false);


   LOG_INSTALL_RETURN(result);

   return result;
}

InstallationReturnType
AdminPackInstallationUnit::InstallSAKUnit(SA_TYPE unitType, String& errorMessage)
{
   LOG_FUNCTION(AdminPackInstallationUnit::InstallSAKUnit);

   InstallationReturnType result = INSTALL_SUCCESS;
   
   errorMessage.erase();

   do
   {
      Win::WaitCursor wait;
   
      // Check to make sure we are not on 64bit

      if (State::GetInstance().Is64Bit())
      {
         ASSERT(!State::GetInstance().Is64Bit());

         result = INSTALL_FAILURE;
         break;
      }

      // Get the name of the source location of the install files

      String installLocation;
      DWORD productSKU = State::GetInstance().GetProductSKU();
      
      if (productSKU & CYS_SERVER)
      {
         installLocation = String::load(IDS_SERVER_CD);
      }
      else if (productSKU & CYS_ADVANCED_SERVER)
      {
         installLocation = String::load(IDS_ADVANCED_SERVER_CD);
      }
      else if (productSKU & CYS_DATACENTER_SERVER)
      {
         installLocation = String::load(IDS_DATACENTER_SERVER_CD);
      }
      else
      {
         installLocation = String::load(IDS_WINDOWS_CD);
      }

      // Get the Server Appliance COM object

      SmartInterface<ISaInstall> sakInstall;

      HRESULT hr = GetSAKObject(sakInstall);
      if (FAILED(hr))
      {
         // We failed the CoCreate on the SAK (Server Appliance Kit) COM object
         // Can't do anything without that!

         LOG(String::format(
                L"Failed to create the SAK (Server Appliance Kit) COM object: hr = 0x%1!x!",
                hr));

         result = INSTALL_FAILURE;
         break;
      }

      VARIANT_BOOL displayError = false;
      VARIANT_BOOL unattended = false;
      BSTR tempMessage = 0;
      hr = sakInstall->SAInstall(
              unitType,
              const_cast<WCHAR*>(installLocation.c_str()),
              displayError,
              unattended,
              &tempMessage);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to install the SAK unit: hr = 0x%1!x!",
                hr));

         if (tempMessage)
         {
            errorMessage = tempMessage;
            ::SysFreeString(tempMessage);
         }

         result = INSTALL_FAILURE;
         break;
      }

   } while (false);

   LOG_INSTALL_RETURN(result);
   return result;
}

InstallationReturnType
AdminPackInstallationUnit::InstallNASAdmin(String& errorMessage)
{
   LOG_FUNCTION(AdminPackInstallationUnit::InstallNASAdmin);

   InstallationReturnType result = InstallSAKUnit(NAS, errorMessage);

   LOG_INSTALL_RETURN(result);
   return result;
}

InstallationReturnType
AdminPackInstallationUnit::InstallWebAdmin(String& errorMessage)
{
   LOG_FUNCTION(AdminPackInstallationUnit::InstallWebAdmin);

   InstallationReturnType result = InstallSAKUnit(WEB, errorMessage );

   LOG_INSTALL_RETURN(result);
   return result;
}

InstallationReturnType
AdminPackInstallationUnit::InstallAdminPack()
{
   LOG_FUNCTION(AdminPackInstallationUnit::InstallAdminPack);

   InstallationReturnType result = INSTALL_SUCCESS;

   do
   {
      Win::WaitCursor wait;
   
      // The Admin Tools Pack msi file is located in the %windir%\system32
      // directory on all x86 Server SKUs
      // The "/i" parameter means install, the "/qn" means quite mode/no UI

      String sysFolder = Win::GetSystemDirectory();
      String adminpakPath = sysFolder + L"\\msiexec.exe /i " + sysFolder + L"\\adminpak.msi /qn";

      DWORD exitCode = 0;
      HRESULT hr = CreateAndWaitForProcess(adminpakPath, exitCode, true);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to launch Admin Pack install: hr = 0x%1!x!",
                hr));

         result = INSTALL_FAILURE;
         break;
      }

      if (exitCode != 0)
      {
         LOG(String::format(
                L"Failed to install Admin Tools Pack: exitCode = 0x%1!x!",
                exitCode));

         result = INSTALL_FAILURE;
         break;
      }

      LOG(String::format(
             L"Admin Pack returned with exitCode = 0x%1!x!",
             exitCode));

   } while (false);

   LOG_INSTALL_RETURN(result);
   return result;
}

bool
AdminPackInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(AdminPackInstallationUnit::IsServiceInstalled);

   bool result = false;

   // This should never be called...  
   // The caller should be checking each individual 
   // tools package instead.  For instance, GetAdminPackInstall(),
   // GetNASAdminInstall(), or GetWebAdminInstall()

   ASSERT(false);
   LOG_BOOL(result);
   return result;
}

String
AdminPackInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(AdminPackInstallationUnit::GetServiceDescription);

   // this should never be called.  AdminPack isn't a 
   // server role

   ASSERT(false);
   return L"";
}

bool
AdminPackInstallationUnit::GetMilestoneText(String& message)
{
   LOG_FUNCTION(AdminPackInstallationUnit::GetMilestoneText);

   bool result = false;

   if (GetInstallWebAdmin())
   {

      message += String::load(IDS_WEB_ADMIN_FINISH_TEXT);
      result = true;
   }

   if (GetInstallNASAdmin())
   {
      message += String::load(IDS_NAS_ADMIN_FINISH_TEXT);

      // If IIS isn't installed, add the text from the WebInstallationUnit
 
      WebInstallationUnit& webInstallationUnit =
         InstallationUnitProvider::GetInstance().GetWebInstallationUnit();

      if (!webInstallationUnit.IsServiceInstalled())
      {
         webInstallationUnit.GetMilestoneText(message);
      }
      result = true;
   }
   
   if (GetInstallAdminPack())
   {
      message += String::load(IDS_ADMIN_PACK_FINISH_TEXT);
      result = true;
   }

   LOG_BOOL(result);
   return result;
}

bool
AdminPackInstallationUnit::IsAdminPackInstalled()
{
   LOG_FUNCTION(AdminPackInstallationUnit::IsAdminPackInstalled);

   // Admin Tools Pack is no longer allowing itself to be installed
   // on server builds. By returning true here the UI will always
   // think its already install and never give the option.
   // NTRAID#NTBUG9-448167-2001/07/31-jeffjon

   bool result = true;
/*
   bool result = false;

   // Admin Tools Pack is installed if the registry key for
   // uninstalling is present

   RegistryKey key;
   HRESULT hr = key.Open(
                   HKEY_LOCAL_MACHINE,
                   CYS_ADMINPAK_SERVERED_REGKEY,
                   KEY_READ);

   if (SUCCEEDED(hr))
   {
      LOG(L"The Admin Pack uninstall key exists");
      result = true;
   }
   else
   {
      LOG(String::format(
             L"Failed to open Admin Pack uninstall key: hr = 0x%1!x!",
             hr));
   }
*/
   LOG_BOOL(result);
   return result;
}

void
AdminPackInstallationUnit::SetInstallAdminPack(bool install)
{
   LOG_FUNCTION2(
      AdminPackInstallationUnit::SetInstallAdminPack,
      install ? L"true" : L"false");

   installAdminPack = install;
}

bool
AdminPackInstallationUnit::GetInstallAdminPack() const
{
   LOG_FUNCTION(AdminPackInstallationUnit::GetInstallAdminPack);

   bool result = installAdminPack;

   LOG_BOOL(result);
   return result;
}

bool
AdminPackInstallationUnit::IsWebAdminInstalled()
{
   LOG_FUNCTION(AdminPackInstallationUnit::IsWebAdminInstalled);

   bool result = IsSAKUnitInstalled(WEB);
   LOG_BOOL(result);
   return result;
}

void
AdminPackInstallationUnit::SetInstallWebAdmin(bool install)
{
   LOG_FUNCTION2(
      AdminPackInstallationUnit::SetInstallWebAdmin,
      install ? L"true" : L"false");

   installWebAdmin = install;
}

bool
AdminPackInstallationUnit::GetInstallWebAdmin() const
{
   LOG_FUNCTION(AdminPackInstallationUnit::GetInstallWebAdmin);

   bool result = installWebAdmin;

   LOG_BOOL(result);
   return result;
}

bool
AdminPackInstallationUnit::IsNASAdminInstalled()
{
   LOG_FUNCTION(AdminPackInstallationUnit::IsNASAdminInstalled);

   bool result = IsSAKUnitInstalled(NAS);
   LOG_BOOL(result);
   return result;
}

bool
AdminPackInstallationUnit::IsSAKUnitInstalled(SA_TYPE unitType)
{
   LOG_FUNCTION2(
      AdminPackInstallationUnit::IsSAKUnitInstalled,
      String::format(L"type = %1!d!", (int) unitType));

   bool result = true;

   do
   {
      // Check to make sure we are not on 64bit

      if (State::GetInstance().Is64Bit())
      {
         result = false;
         break;
      }

      // Get the Server Appliance Kit COM object

      SmartInterface<ISaInstall> sakInstall;
      HRESULT hr = GetSAKObject(sakInstall);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to get the SAK COM object: hr = 0x%1!x!",
                hr));

         break;
      }

      // Check to see if NAS is already installed 

      VARIANT_BOOL saInstalled;
      hr = sakInstall->SAAlreadyInstalled(unitType, &saInstalled);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed call to SAAlreadyInstalled: hr = 0x%1!x!",
                hr));
         break;
      }

      if (!saInstalled)
      {
         result = false;
      }

   } while (false);

   LOG_BOOL(result);
   return result;
}

void
AdminPackInstallationUnit::SetInstallNASAdmin(bool install)
{
   LOG_FUNCTION2(
      AdminPackInstallationUnit::SetInstallNASAdmin,
      install ? L"true" : L"false");

   installNASAdmin = install;
}

bool
AdminPackInstallationUnit::GetInstallNASAdmin() const
{
   LOG_FUNCTION(AdminPackInstallationUnit::GetInstallNASAdmin);

   bool result = installNASAdmin;

   LOG_BOOL(result);
   return result;
}

HRESULT
AdminPackInstallationUnit::GetSAKObject(SmartInterface<ISaInstall>& sakInstall)
{
   LOG_FUNCTION(AdminPackInstallationUnit::GetSAKObject);

   HRESULT hr = S_OK;

   if (!sakInstallObject)
   {
      hr = sakInstallObject.AcquireViaCreateInstance(
              CLSID_SaInstall,
              0,
              CLSCTX_INPROC_SERVER);
   }

   ASSERT(sakInstallObject);
   sakInstall = sakInstallObject;

   LOG_HRESULT(hr);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\adminpackinstallationunit.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      AdminPackInstallationUnit.h
//
// Synopsis:  Declares a AdminPackInstallationUnit
//            This object has the knowledge for installing 
//            the Administration Tools Pack
//
// History:   06/01/2001  JeffJon Created

#ifndef __CYS_ADMINPACKINSTALLATIONUNIT_H
#define __CYS_ADMINPACKINSTALLATIONUNIT_H

#include "InstallationUnit.h"
#include "sainstallcom.h"

class AdminPackInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      AdminPackInstallationUnit();

      // Destructor
      virtual
      ~AdminPackInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      String
      GetServiceDescription();

      virtual
      bool
      GetMilestoneText(String& message);

      virtual
      void
      ServerRoleLinkSelected(int /*linkIndex*/, HWND /*hwnd*/) {};

      // data accessors

      // Admin Tools Pack

      bool
      IsAdminPackInstalled();

      void
      SetInstallAdminPack(bool install);

      bool
      GetInstallAdminPack() const;

      InstallationReturnType
      InstallAdminPack();

      // Web administration tools

      bool
      IsWebAdminInstalled();

      void
      SetInstallWebAdmin(bool install);

      bool
      GetInstallWebAdmin() const;

      InstallationReturnType
      InstallWebAdmin(String& errorMessage);

      // Network Attached Storage (NAS) Admin

      bool
      IsNASAdminInstalled();

      void
      SetInstallNASAdmin(bool install);

      bool
      GetInstallNASAdmin() const;

      InstallationReturnType
      InstallNASAdmin(String& errorMessage);

   private:

      InstallationReturnType
      InstallSAKUnit(
         SA_TYPE unitType,
         String& errorMessage);

      bool
      IsSAKUnitInstalled(SA_TYPE unitType);

      HRESULT
      GetSAKObject(SmartInterface<ISaInstall>& sakInstall);

      SmartInterface<ISaInstall> sakInstallObject;

      bool installAdminPack;
      bool installWebAdmin;
      bool installNASAdmin;

      // not defined: no copying allowed
      AdminPackInstallationUnit(const AdminPackInstallationUnit&);
      const AdminPackInstallationUnit& operator=(const AdminPackInstallationUnit&);
};

#endif // __CYS_ADMINPACKINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\adminpackonlypage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      AdminPackOnlyPage.h
//
// Synopsis:  Declares the AdminPackOnlypage that
//            asks the user if they want to install
//            the Admin Pack
//
// History:   06/01/2001  JeffJon Created

#ifndef __CYS_ADMINPACKONLYPAGE_H
#define __CYS_ADMINPACKONLYPAGE_H

#include "CYSWizardPage.h"


class AdminPackOnlyPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      AdminPackOnlyPage();

      // Destructor

      virtual 
      ~AdminPackOnlyPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();

   private:

      // not defined: no copying allowed
      AdminPackOnlyPage(const AdminPackOnlyPage&);
      const AdminPackOnlyPage& operator=(const AdminPackOnlyPage&);

};

#endif // __CYS_ADMINPACKONLYPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\beforebeginpage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      BeforeBeginPage.h
//
// Synopsis:  Declares the Before You Begin Page for the CYS
//            wizard.  This page tells the user what they need
//            to do before running CYS.
//
// History:   03/14/2001  JeffJon Created

#ifndef __CYS_BEFOREBEGINPAGE_H
#define __CYS_BEFOREBEGINPAGE_H

#include "CYSWizardPage.h"


class BeforeBeginPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      BeforeBeginPage();

      // Destructor

      virtual 
      ~BeforeBeginPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();

   private:

      void
      InitializeBulletedList();

      HFONT bulletFont;

      // not defined: no copying allowed
      BeforeBeginPage(const BeforeBeginPage&);
      const BeforeBeginPage& operator=(const BeforeBeginPage&);

};

#endif // __CYS_BEFOREBEGINPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\capslockballoontip.hpp ===
// Copyright (c) 2000-2001 Microsoft Corporation
//
// Caps lock warning Balloon tip window
//
// 7 Nov 2000 sburns (that would be election day)
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns



#ifndef CAPSLOCKBALLOONTIP_HPP_INCLUDED
#define CAPSLOCKBALLOONTIP_HPP_INCLUDED



// Class used to show a balloon-style tool tip window that complains to the
// user that caps lock is on.  Used by PasswordEditBox.

class CapsLockBalloonTip
{
   public:



   CapsLockBalloonTip();



   // destroys the tool tip window, if it still exists
      
   ~CapsLockBalloonTip();


   // Initialize the tool tip, but don't show it.
   // 
   // parentWindow - in, the parent window handle of the control to have the
   // tool tip.  (The password edit control window).
   
   HRESULT
   Init(HWND parentWindow);
   


   // Show or hide the tip window.
   //
   // notHidden - in, if true, show the window.  If false, hide it.

   void
   Show(bool notHidden);
   

   
   private:

   // not implemented: no copying allowed

   CapsLockBalloonTip(const CapsLockBalloonTip&);
   const CapsLockBalloonTip& operator=(const CapsLockBalloonTip&);

   String title;
   String text;
   bool   visible;
   HWND   tipWindow;
   HWND   parentWindow;
};



#endif   // CAPSLOCKBALLOONTIP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\adminpackonlypage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      AdminPackOnlyPage.h
//
// Synopsis:  Defines the AdminPackOnlypage that
//            asks the user if they want to install
//            the Admin Pack
//
// History:   06/01/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "AdminPackOnlyPage.h"
#include "state.h"


static PCWSTR ADMIN_PACK_ONLY_PAGE_HELP = L"cys.chm::/cys_adminpack.htm";

AdminPackOnlyPage::AdminPackOnlyPage()
   :
   CYSWizardPage(
      IDD_ADMIN_PACK_ONLY_PAGE, 
      IDS_ADMIN_PACK_TITLE, 
      IDS_ADMIN_PACK_SUBTITLE, 
      ADMIN_PACK_ONLY_PAGE_HELP)
{
   LOG_CTOR(AdminPackOnlyPage);
}

AdminPackOnlyPage::~AdminPackOnlyPage()
{
   LOG_DTOR(AdminPackOnlyPage);
}


void
AdminPackOnlyPage::OnInit()
{
   LOG_FUNCTION(AdminPackOnlyPage::OnInit);

   Win::SetDlgItemText(
      hwnd, 
      IDC_TOO_LONG_STATIC,
      String::load(IDS_ADMIN_PACK_PAGE_TEXT));
}


bool
AdminPackOnlyPage::OnSetActive()
{
   LOG_FUNCTION(AdminPackOnlyPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}


int
AdminPackOnlyPage::Validate()
{
   LOG_FUNCTION(AdminPackOnlyPage::Validate);

   int nextPage = IDD_MILESTONE_PAGE;

   // Get the checkbox value to see if we should install
   // the Admin Pack

   InstallationUnitProvider::GetInstance().GetAdminPackInstallationUnit().SetInstallAdminPack(
      Win::Button_GetCheck(
         Win::GetDlgItem(
            hwnd,
            IDC_INSTALL_ADMINPACK_CHECK)));

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\beforebeginpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      BeforeBeginPage.cpp
//
// Synopsis:  Defines the Before You Begin Page for the CYS
//            Wizard.  Tells the user what they should do
//            before running CYS.
//
// History:   03/14/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "BeforeBeginPage.h"
#include "NetDetectProgressDialog.h"

static PCWSTR BEFORE_BEGIN_PAGE_HELP = L"cys.chm::/prelim_steps.htm";

BeforeBeginPage::BeforeBeginPage()
   :
   bulletFont(0),
   CYSWizardPage(
      IDD_BEFORE_BEGIN_PAGE, 
      IDS_BEFORE_BEGIN_TITLE, 
      IDS_BEFORE_BEGIN_SUBTITLE, 
      BEFORE_BEGIN_PAGE_HELP)
{
   LOG_CTOR(BeforeBeginPage);
}

   

BeforeBeginPage::~BeforeBeginPage()
{
   LOG_DTOR(BeforeBeginPage);

   if (bulletFont)
   {
      HRESULT hr = Win::DeleteObject(bulletFont);
      ASSERT(SUCCEEDED(hr));
   }
}


void
BeforeBeginPage::OnInit()
{
   LOG_FUNCTION(BeforeBeginPage::OnInit);

   CYSWizardPage::OnInit();

   // Since this page can be started directly
   // we have to be sure to set the wizard title

   Win::PropSheet_SetTitle(
      Win::GetParent(hwnd),
      0,
      String::load(IDS_WIZARD_TITLE));

   InitializeBulletedList();
}

void
BeforeBeginPage::InitializeBulletedList()
{
   LOG_FUNCTION(BeforeBeginPage::InitializeBulletedList);

   bulletFont = CreateFont(
                   0,
                   0,
                   0,
                   0,
                   FW_NORMAL,
                   0,
                   0,
                   0,
                   SYMBOL_CHARSET,
                   OUT_CHARACTER_PRECIS,
                   CLIP_CHARACTER_PRECIS,
                   PROOF_QUALITY,
                   VARIABLE_PITCH|FF_DONTCARE,
                   L"Marlett");

   if (bulletFont)
   {
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET1), bulletFont, true);
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET2), bulletFont, true);
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET3), bulletFont, true);
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET4), bulletFont, true);
      Win::SetWindowFont(Win::GetDlgItem(hwnd, IDC_BULLET5), bulletFont, true);
   }
   else
   {
      LOG(String::format(
             L"Failed to create font for bullet list: hr = %1!x!",
             Win::GetLastErrorAsHresult()));
   }

}

bool
BeforeBeginPage::OnSetActive()
{
   LOG_FUNCTION(BeforeBeginPage::OnSetActive);

   if (State::GetInstance().GetStartPage() == 0)
   {
      Win::PropSheet_SetWizButtons(
         Win::GetParent(hwnd), 
         PSWIZB_NEXT | PSWIZB_BACK);
   }
   else
   {
      Win::PropSheet_SetWizButtons(
         Win::GetParent(hwnd), 
         PSWIZB_NEXT);
   }

   return true;
}

int
BeforeBeginPage::Validate()
{
   LOG_FUNCTION(BeforeBeginPage::Validate);

   // Gather the machine network and role information

   // Disable the wizard buttons until the operation finishes

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      0);

   Win::WaitCursor wait;

   State& state = State::GetInstance();

   if (!state.HasStateBeenRetrieved())
   {
      NetDetectProgressDialog dialog;
      dialog.ModalExecute(hwnd);

      if (dialog.ShouldCancel())
      {
         LOG(L"Cancelling wizard by user request");

         Win::PropSheet_PressButton(
            Win::GetParent(hwnd),
            PSBTN_CANCEL);

         // Done.

         return -1;
      }
   }

#ifdef TEST_EXPRESS_PATH

   LOG(L"Testing express path");
   int nextPage = IDD_DECISION_PAGE;

#else

   int nextPage = IDD_CUSTOM_SERVER_PAGE;
   
   do 
   {
      // If any of these conditions fail we don't give the user the
      // DecisionPage because we don't allow the Express Path
      //
      // 1.  Cannot be Datacenter
      // 2.  Must have at least one NIC that isn't a modem
      // 3.  Cannot be running as a remote session
      // 4.  Cannot be a member of a domain
      // 5.  Cannot be a Domain Controller
      // 6.  Cannot be a DNS server
      // 7.  Cannot be a DHCP server
      // 8.  RRAS is not configured
      // 9.  Must have at least one NTFS partition
      // 10. If there is only one NIC it cannot have obtained
      //       an IP lease from a DHCP server. (more than
      //       one NIC all of which obtain a lease is
      //       acceptable. We just won't install DHCP)
      // 11. Must not be a Certificate Server 
      //       (else dcpromo fails)

      if (state.GetProductSKU() == CYS_DATACENTER_SERVER)
      {
         LOG(L"Express path not available on DataCenter");
         break;
      }

      unsigned int nonModemNICCount = state.GetNonModemNICCount();
      if (nonModemNICCount == 0)
      {
         LOG(String::format(
                L"nonModemNICCount = %1!d!",
                nonModemNICCount));
         break;
      }

      if (state.IsRemoteSession())
      {
         LOG(L"Running in a remote session");
         break;
      }

      if (state.IsJoinedToDomain())
      {
         LOG(L"Computer is joined to a domain");
         break;
      }

      if (state.IsDC())
      {
         LOG(L"Computer is DC");
         break;
      }

      if (InstallationUnitProvider::GetInstance().
             GetDNSInstallationUnit().IsServiceInstalled())
      {
         LOG(L"Computer is DNS server");
         break;
      }

      if (InstallationUnitProvider::GetInstance().
             GetDHCPInstallationUnit().IsServiceInstalled())
      {
         LOG(L"Computer is DHCP server");
         break;
      }

      if (InstallationUnitProvider::GetInstance().
             GetRRASInstallationUnit().IsServiceInstalled())
      {
         LOG(L"Routing is already setup");
         break;
      }

      if (!state.HasNTFSDrive())
      {
         LOG(L"Computer does not have an NTFS partition.");
         break;
      }

      if (state.GetNICCount() == 1 &&
          state.IsDHCPServerAvailableOnAllNics())
      {
         LOG(L"Only 1 NIC and we found a DHCP server");
         break;
      }

      // NTRAID#NTBUG9-698719-2002/09/03-artm
      // AD installation is not available if Certificate Server is installed

      if (NTService(L"CertSvc").IsInstalled())
      {
         LOG(L"Certificate service is installed");
         break;
      }

      nextPage = IDD_DECISION_PAGE;

   } while (false);

   // Now that all the operations are complete,
   // re-enable the wizard buttons

   if (State::GetInstance().GetStartPage() == 0)
   {
      Win::PropSheet_SetWizButtons(
         Win::GetParent(hwnd), 
         PSWIZB_NEXT | PSWIZB_BACK);
   }
   else
   {
      Win::PropSheet_SetWizButtons(
         Win::GetParent(hwnd), 
         PSWIZB_NEXT);
   }

#endif // TEST_EXPRESS_PATH

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\capslockballoontip.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// Caps lock warning Balloon tip window
//
// 7 Nov 2000 sburns (that would be election day)
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns
//
// most of this is stolen and cleaned up from johnstep's common cred ui
// ds/win32/credui



#include "pch.h"
#include "CapsLockBalloonTip.hpp"
#include "resource.h"



CapsLockBalloonTip::CapsLockBalloonTip()
   :
   title(String::load(IDS_CAPS_LOCK_TIP_TITLE)),
   text(String::load(IDS_CAPS_LOCK_TIP_TEXT)),
   tipWindow(0),
   parentWindow(0),
   visible(false)
{
   LOG_CTOR(CapsLockBalloonTip);
   ASSERT(!title.empty());
   ASSERT(!text.empty());
}



CapsLockBalloonTip::~CapsLockBalloonTip()
{
   LOG_DTOR(CapsLockBalloonTip);

   if (Win::IsWindow(tipWindow))
   {
      Win::DestroyWindow(tipWindow);
      tipWindow = 0;
   }
}



HRESULT
CapsLockBalloonTip::Init(HWND parentWindow_)
{
   LOG_FUNCTION(CapsLockBalloonTip::Init);
   ASSERT(Win::IsWindow(parentWindow_));

   // should not call init on the same instance twice
   
   ASSERT(!parentWindow);
   ASSERT(!tipWindow);

   if (Win::IsWindow(tipWindow))
   {
      Win::DestroyWindow(tipWindow);
   }

   HRESULT hr = S_OK;

   do
   {
      hr = Win::CreateWindowEx(
         WS_EX_TOPMOST,
         TOOLTIPS_CLASS,
         L"",
         WS_POPUP | TTS_NOPREFIX | TTS_BALLOON,
         CW_USEDEFAULT,
         CW_USEDEFAULT,
         CW_USEDEFAULT,
         CW_USEDEFAULT,
         parentWindow_,
         0,
         0,
         tipWindow);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(tipWindow);
               
      parentWindow = parentWindow_;

      TOOLINFO info;
      ::ZeroMemory(&info, sizeof(info));

      // we want to specify the stem position, so we set TTF_TRACK.  We use
      // the HWND of the parent window as the tool id, because that if what
      // v.5 of comctl32 requires (or the balloon never appears).  This is
      // a bug that has been fixed in v.6, but until fusion manifests are
      // working properly, you can't get v.6
      //
      // (when manifests are working, then we could remove TTF_IDISHWND and
      // set uId to be some fixed integer)
      
      info.uFlags   = TTF_IDISHWND | TTF_TRACK;   
      info.hwnd     = parentWindow;
      info.uId      = reinterpret_cast<UINT_PTR>(parentWindow); 
      info.lpszText = const_cast<PWCHAR>(text.c_str());

      Win::ToolTip_AddTool(tipWindow, info);
      Win::ToolTip_SetTitle(tipWindow, TTI_WARNING, title);
   }
   while (0);

   return hr;
}



void
CapsLockBalloonTip::Show(bool notHidden)
{
//   LOG_FUNCTION(CapsLockBalloonTip::Show);

   TOOLINFO info;
   ::ZeroMemory(&info, sizeof info);

   // set these members the same as in the Init method, in order to
   // identify the proper tool.
   
   info.hwnd = parentWindow; 
   info.uId = reinterpret_cast<UINT_PTR>(parentWindow); 
   
   if (notHidden)
   {
      if (!visible && Win::IsWindowEnabled(parentWindow))
      {
         Win::SetFocus(parentWindow);

         RECT rect;
         Win::GetWindowRect(parentWindow, rect);

         Win::ToolTip_TrackPosition(
            tipWindow,

            // put the stem at the point 90% along the x axis
            
            rect.left + 90 * (rect.right - rect.left) / 100,

            // and 76% along the y axis of the edit control
            
            rect.top + 76 * (rect.bottom - rect.top) / 100);

         Win::ToolTip_TrackActivate(tipWindow, true, info);   

         visible = true;
      }
   }
   else
   {
      // hide the tip window
      
      if (visible)
      {
         Win::ToolTip_TrackActivate(tipWindow, false, info);   
         visible = false;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\customserverpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      CustomServerPage.cpp
//
// Synopsis:  Defines Custom Server Page for the CYS
//            Wizard
//
// History:   02/06/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "cys.h"
#include "InstallationUnitProvider.h"
#include "CustomServerPage.h"
#include "uiutil.h"

static PCWSTR CUSTOM_PAGE_HELP = L"cys.chm::/cys_topnode.htm";

CustomServerPage::CustomServerPage()
   :
   CYSWizardPage(
      IDD_CUSTOM_SERVER_PAGE, 
      IDS_CUSTOM_SERVER_TITLE, 
      IDS_CUSTOM_SERVER_SUBTITLE, 
      CUSTOM_PAGE_HELP)
{
   LOG_CTOR(CustomServerPage);
}

   

CustomServerPage::~CustomServerPage()
{
   LOG_DTOR(CustomServerPage);
}


void
CustomServerPage::OnInit()
{
   LOG_FUNCTION(CustomServerPage::OnInit);

   CYSWizardPage::OnInit();

   SetBoldFont(
      hwnd, 
      IDC_ROLE_STATIC);

   InitializeServerListView();
   FillServerTypeList();
}

void
CustomServerPage::InitializeServerListView()
{
   LOG_FUNCTION(CustomServerPage::InitializeServerListView);

   // Prepare a column

   HWND hwndBox = Win::GetDlgItem(hwnd, IDC_SERVER_TYPE_LIST);

   RECT rect;
   Win::GetClientRect(hwndBox, rect);

   // Get the width of a scroll bar

//   int scrollThumbWidth = ::GetSystemMetrics(SM_CXHTHUMB);

   // net width of listview

   int netWidth = rect.right /*- scrollThumbWidth*/ - ::GetSystemMetrics(SM_CXBORDER);

   // Set full row select

   Win::ListView_SetExtendedListViewStyle(
      hwndBox, 
      LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP/* | LVS_EX_GRIDLINES*/);

   // Get the size of the listview


   LVCOLUMN column;
   ZeroMemory(&column, sizeof(LVCOLUMN));

   column.mask = LVCF_WIDTH | LVCF_TEXT;

   // Use 80 percent of the width minus the scrollbar for the role and the rest for the status

   column.cx = static_cast<int>(netWidth * 0.75);

   String columnHeader = String::load(IDS_SERVER_ROLE_COLUMN_HEADER);
   column.pszText = const_cast<wchar_t*>(columnHeader.c_str());

   Win::ListView_InsertColumn(
      hwndBox,
      0,
      column);

   // Add the status column

   columnHeader = String::load(IDS_STATUS_COLUMN_HEADER);
   column.pszText = const_cast<wchar_t*>(columnHeader.c_str());

   column.cx = netWidth - column.cx;

   Win::ListView_InsertColumn(
      hwndBox,
      1,
      column);
}

void
CustomServerPage::FillServerTypeList()
{
   LOG_FUNCTION(CustomServerPage::FillServerTypeList);

   // Load the status strings

   String statusCompleted  = String::load(IDS_STATUS_COMPLETED);
   String statusNo         = String::load(IDS_STATUS_NO);

   // loop throught the table putting all the server 
   // types in the listbox

   HWND hwndBox = Win::GetDlgItem(hwnd, IDC_SERVER_TYPE_LIST);

   for (
      size_t index = 0; 
      index < GetServerRoleStatusTableElementCount(); 
      ++index)
   {
      InstallationUnit& installationUnit =
         InstallationUnitProvider::GetInstance().
            GetInstallationUnitForType(serverRoleStatusTable[index].role);

      InstallationStatus status =
         serverRoleStatusTable[index].Status();

      if (status != STATUS_NOT_AVAILABLE)
      {
         String serverTypeName = installationUnit.GetServiceName();
         

         LVITEM listItem;
         ZeroMemory(&listItem, sizeof(LVITEM));

         listItem.iItem = (int) index;
         listItem.mask = LVIF_TEXT | LVIF_PARAM;
         listItem.pszText = const_cast<wchar_t*>(serverTypeName.c_str());

         listItem.lParam = serverRoleStatusTable[index].role;

         int newItem = Win::ListView_InsertItem(
                           hwndBox, 
                           listItem);

         ASSERT(newItem >= 0);
         LOG(String::format(
                  L"New role inserted: %1 at index %2!d!",
                  serverTypeName.c_str(),
                  newItem));

         // if the service is installed fill the status column

         if (status == STATUS_COMPLETED ||
             status == STATUS_CONFIGURED)
         {
            Win::ListView_SetItemText(
               hwndBox,
               newItem,
               1,
               statusCompleted);
         }
         else
         {
            Win::ListView_SetItemText(
               hwndBox,
               newItem,
               1,
               statusNo);
         }
      }
   }

   // Set the focus of the first item so that the user can see 
   // the focus but don't select it

   Win::ListView_SetItemState(
      hwndBox,
      0,
      LVIS_FOCUSED,
      LVIS_FOCUSED);
}


bool
CustomServerPage::OnSetActive()
{
   LOG_FUNCTION(CustomServerPage::OnSetActive);

   SetDescriptionForSelection();

   // If log file is available then 
   // enable the link

   if (IsLogFilePresent())
   {
      Win::ShowWindow(
         Win::GetDlgItem(
            hwnd,
            IDC_LOG_STATIC),
         SW_SHOW);
   }
   else
   {
      Win::ShowWindow(
         Win::GetDlgItem(
            hwnd,
            IDC_LOG_STATIC),
         SW_HIDE);
   }

   // If there is a selection set the Next button as 
   // the default with focus. If not, then give the
   // list view the focus

   HWND hwndBox = Win::GetDlgItem(hwnd, IDC_SERVER_TYPE_LIST);

   int currentSelection = ListView_GetNextItem(hwndBox, -1, LVNI_SELECTED);

   if (currentSelection >= 0)
   {
      Win::PostMessage(
         Win::GetParent(hwnd),
         WM_NEXTDLGCTL,
         (WPARAM) Win::GetDlgItem(Win::GetParent(hwnd), Wizard::NEXT_BTN_ID),
         TRUE);
   }
   else
   {
      Win::PostMessage(
         Win::GetParent(hwnd),
         WM_NEXTDLGCTL,
         (WPARAM) hwndBox,
         TRUE);
   }

   return true;
}

InstallationUnit&
CustomServerPage::GetInstallationUnitFromSelection(int currentSelection)
{
   LOG_FUNCTION(CustomServerPage::GetInstallationUnitFromSelection);

   ASSERT(currentSelection >= 0);

   HWND hwndBox = Win::GetDlgItem(hwnd, IDC_SERVER_TYPE_LIST);

   // Now that we know the selection, find the installation type

   LVITEM item;
   ZeroMemory(&item, sizeof(item));

   item.iItem = currentSelection;
   item.mask = LVIF_PARAM;

   bool result = Win::ListView_GetItem(hwndBox, item);
   ASSERT(result);

   LPARAM value = item.lParam;

   LOG(String::format(
         L"Selection = %1!d!, type = %2!d!",
         currentSelection,
         value));

   return InstallationUnitProvider::GetInstance().GetInstallationUnitForType(
             (ServerRole)value);
}

void
CustomServerPage::SetDescriptionForSelection()
{
   LOG_FUNCTION(CustomServerPage::SetDescriptionForSelection);

   HWND hwndDescription = Win::GetDlgItem(hwnd, IDC_TYPE_DESCRIPTION_STATIC);
   HWND hwndBox = Win::GetDlgItem(hwnd, IDC_SERVER_TYPE_LIST);

   int currentSelection = ListView_GetNextItem(hwndBox, -1, LVNI_SELECTED);

   if (currentSelection >= 0)
   {
      InstallationUnit& installationUnit = GetInstallationUnitFromSelection(currentSelection);

      String serverTypeName = installationUnit.GetServiceName();
      Win::SetDlgItemText(hwnd, IDC_ROLE_STATIC, serverTypeName);

      String serverTypeDescription = installationUnit.GetServiceDescription();

      Win::SetWindowText(hwndDescription, serverTypeDescription);
      Win::ShowWindow(hwndDescription, SW_SHOW);
      Win::EnableWindow(hwndDescription, true);

      InstallationStatus status =
         installationUnit.GetStatus();

      // Set the status column

      if (status == STATUS_COMPLETED ||
          status == STATUS_CONFIGURED)
      {
         String statusCompleted = String::load(IDS_STATUS_COMPLETED);

         Win::ListView_SetItemText(
            hwndBox,
            currentSelection,
            1,
            statusCompleted);
      }
      else
      {
         String statusNo = String::load(IDS_STATUS_NO);

         Win::ListView_SetItemText(
            hwndBox,
            currentSelection,
            1,
            statusNo);
      }

      Win::PropSheet_SetWizButtons(
         Win::GetParent(hwnd), 
         PSWIZB_NEXT | PSWIZB_BACK);
   }
   else
   {
      // If no selection set the description text to blank
      // For some reason the SysLink control doesn't like
      // to be blank so I have to disable and hide the control
      // instead of just setting a blank string
      
      Win::EnableWindow(hwndDescription, false);
      Win::ShowWindow(hwndDescription, SW_HIDE);
      Win::SetDlgItemText(hwnd, IDC_ROLE_STATIC, L"");

      // Set the wizard buttons

      Win::PropSheet_SetWizButtons(
         Win::GetParent(hwnd), 
         PSWIZB_BACK);
   }
}


bool
CustomServerPage::OnNotify(
   HWND        /*windowFrom*/,
   UINT_PTR    controlIDFrom,
   UINT        code,
   LPARAM      lParam)
{
//   LOG_FUNCTION(CustomServerPage::OnCommand);
 
   bool result = false;

   if (IDC_SERVER_TYPE_LIST == controlIDFrom &&
       code == LVN_ITEMCHANGED)
   {
      LPNMLISTVIEW pnmv = reinterpret_cast<LPNMLISTVIEW>(lParam);
      if (pnmv && pnmv->uNewState & LVNI_SELECTED)
      {
         SetDescriptionForSelection();
         result = true;
      }
      else
      {
         // Check to see if we have something selected
         // and set the state of the Next button accordingly

         SetDescriptionForSelection();
         SetNextButtonState();
      }
   }
   else if (controlIDFrom == IDC_TYPE_DESCRIPTION_STATIC ||
            controlIDFrom == IDC_ADD_REMOVE_STATIC)
   {
      switch (code)
      {
         case NM_CLICK:
         case NM_RETURN:
         {
            if (controlIDFrom == IDC_TYPE_DESCRIPTION_STATIC)
            {
               HWND hwndBox = Win::GetDlgItem(hwnd, IDC_SERVER_TYPE_LIST);

               int currentSelection = ListView_GetNextItem(hwndBox, -1, LVNI_SELECTED);
               if (currentSelection >= 0)
               {
                  InstallationUnit& installationUnit = 
                     GetInstallationUnitFromSelection(currentSelection);

                  int linkIndex = LinkIndexFromNotifyLPARAM(lParam);
                  installationUnit.ServerRoleLinkSelected(linkIndex, hwnd);
               }
            }
            else
            {
               // launch the sysocmgr

               String fullPath =
                  String::format(
                     IDS_SYSOC_FULL_PATH,
                     Win::GetSystemDirectory().c_str());

               String infPath = 
                  Win::GetSystemWindowsDirectory() + L"\\inf\\sysoc.inf";

               String commandLine =
                  String::format(
                     L"/i:%1",
                     infPath.c_str());

               MyCreateProcess(fullPath, commandLine);
            }

            result = true;
         }
         default:
         {
            // do nothing
            
            break;
         }
      }
   }
   else if (controlIDFrom == IDC_LOG_STATIC)
   {
      switch (code)
      {
         case NM_CLICK:
         case NM_RETURN:
            {
               OpenLogFile();
            }
            break;

         default:
            break;
      }
   }

   return result;
}

void
CustomServerPage::SetNextButtonState()
{
   HWND hwndBox = Win::GetDlgItem(hwnd, IDC_SERVER_TYPE_LIST);
   int currentSelection = ListView_GetNextItem(hwndBox, -1, LVNI_SELECTED);

   // Set the wizard buttons

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      (currentSelection < 0) ? PSWIZB_BACK : PSWIZB_NEXT | PSWIZB_BACK);
}

int
CustomServerPage::Validate()
{
   LOG_FUNCTION(CustomServerPage::Validate);

   HWND hwndBox = Win::GetDlgItem(hwnd, IDC_SERVER_TYPE_LIST);

   int currentSelection = ListView_GetNextItem(hwndBox, -1, LVNI_SELECTED);

   ASSERT(currentSelection >= 0);

   // Now that we know the selection, find the installation type

   LVITEM item;
   ZeroMemory(&item, sizeof(item));

   item.iItem = currentSelection;
   item.mask = LVIF_PARAM;

   bool result = Win::ListView_GetItem(hwndBox, item);
   ASSERT(result);

   // set the current install to the selected installation unit

   InstallationUnit& currentInstallationUnit = 
      InstallationUnitProvider::GetInstance().SetCurrentInstallationUnit(
         static_cast<ServerRole>(item.lParam));

   // NTRAID#NTBUG-604592-2002/04/23-JeffJon-Key the action of the wizard
   // off the installation status at this point. The InstallationProgressPage
   // will call either CompletePath or UninstallService based on the value
   // that is set here.

   currentInstallationUnit.SetInstalling(
      currentInstallationUnit.IsServiceInstalled());

   int nextPage = currentInstallationUnit.GetWizardStart();

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\clusterinstallationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      ClusterInstallationUnit.cpp
//
// Synopsis:  Defines a ClusterInstallationUnit
//            This object has the knowledge for installing the
//            clustering service
//
// History:   02/09/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "ClusterInstallationUnit.h"

#include <clusapi.h>

// Finish page help 
static PCWSTR CYS_CLUSTER_FINISH_PAGE_HELP = L"cys.chm::/cys_configuring_cluster_server.htm";
static PCWSTR CYS_CLUSTER_AFTER_FINISH_HELP = L"cys.chm::/cys_after_cluster_server.htm";

ClusterInstallationUnit::ClusterInstallationUnit() :
   makeNewCluster(true),
   InstallationUnit(
      IDS_CLUSTER_SERVER_TYPE, 
      IDS_CLUSTER_SERVER_DESCRIPTION, 
      CYS_CLUSTER_FINISH_PAGE_HELP,
      CYS_CLUSTER_AFTER_FINISH_HELP,
      CLUSTERSERVER_INSTALL)
{
   LOG_CTOR(ClusterInstallationUnit);
}


ClusterInstallationUnit::~ClusterInstallationUnit()
{
   LOG_DTOR(ClusterInstallationUnit);
}


InstallationReturnType
ClusterInstallationUnit::InstallService(HANDLE logfileHandle, HWND /*hwnd*/)
{
   LOG_FUNCTION(ClusterInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   // Log heading

   CYS_APPEND_LOG(String::load(IDS_LOG_CLUSTER_HEADING));

   String commandLine;

   // Build the command line

   if (MakeNewCluster())
   {
      commandLine = L"cluster /Create /Wizard";
   }
   else
   {
      commandLine = L"cluster /Add /Wizard";
   }

   // Run the wizard

   DWORD exitCode = 0;
   HRESULT hr = CreateAndWaitForProcess(commandLine, exitCode);
   if (FAILED(hr))
   {
      // Failed to launch the wizard

      LOG(String::format(
             L"Failed to launch cluster wizard: hr = 0x%1!x!",
             hr));

      if (MakeNewCluster())
      {
         CYS_APPEND_LOG(String::load(IDS_CLUSTER_LOG_LAUNCH_FAILED_NEW_CLUSTER)); 
      }
      else
      {
         CYS_APPEND_LOG(String::load(IDS_CLUSTER_LOG_LAUNCH_FAILED_ADD_NODE)); 
      }
      
      result = INSTALL_FAILURE;
   }
   else if (SUCCEEDED(hr) &&
            exitCode == 0)
   {
      // Wizard was launched and completed successfully

      LOG(L"Cluster wizard launched and completed successfully");

      if (MakeNewCluster())
      {
         CYS_APPEND_LOG(String::load(IDS_CLUSTER_LOG_SUCCESS_NEW_CLUSTER));
      }
      else
      {
         CYS_APPEND_LOG(String::load(IDS_CLUSTER_LOG_SUCCESS_ADD_NODE));
      }

      result = INSTALL_SUCCESS;
   }
   else // if (SUCCEEDED(hr) && exitCode == ????<some exit code for cancelled>???
   {
      // Wizard was cancelled by the user

      LOG(L"Cluster wizard cancelled by user");

      if (MakeNewCluster())
      {
         CYS_APPEND_LOG(String::load(IDS_CLUSTER_LOG_CANCELLED_NEW_CLUSTER));
      }
      else
      {
         CYS_APPEND_LOG(String::load(IDS_CLUSTER_LOG_CANCELLED_ADD_NODE));
      }
      
      result = INSTALL_FAILURE;
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

bool
ClusterInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(ClusterInstallationUnit::IsServiceInstalled);

   bool result = false;

   DWORD clusterState = 0;
   DWORD err = ::GetNodeClusterState(0, &clusterState);
   if (err == ERROR_SUCCESS &&
       clusterState != ClusterStateNotConfigured)
   {
      result = true;
   }
   else
   {
      LOG(String::format(
             L"GetNodeClusterState returned err = %1!x!",
             err));
   }

   LOG_BOOL(result);

   return result;
}

bool
ClusterInstallationUnit::GetFinishText(String& message)
{
   LOG_FUNCTION(ClusterInstallationUnit::GetFinishText);

   if (MakeNewCluster())
   {
      message = String::load(IDS_CLUSTER_FINISH_TEXT_NEW_CLUSTER);
   }
   else
   {
      message = String::load(IDS_CLUSTER_FINISH_TEXT_EXISTING_CLUSTER);
   }

   LOG_BOOL(true);
   return true;
}

String
ClusterInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(ClusterInstallationUnit::GetServiceDescription);

   unsigned int descriptionID = IDS_CLUSTER_SERVER_DESCRIPTION;

   if (IsServiceInstalled())
   {
      descriptionID = IDS_CLUSTER_SERVER_DESCRIPTION_INSTALLED;
   }

   return String::load(descriptionID);
}

bool
ClusterInstallationUnit::MakeNewCluster() const
{
   LOG_FUNCTION(ClusterInstallationUnit::MakeNewCluster);
   
   return makeNewCluster;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\customserverpage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      CustomServerPage.h
//
// Synopsis:  Declares the Custom Server Page for the CYS
//            wizard
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_CUSTOMSERVERPAGE_H
#define __CYS_CUSTOMSERVERPAGE_H

#include "CYSWizardPage.h"


class CustomServerPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      CustomServerPage();

      // Destructor

      virtual 
      ~CustomServerPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // Message handlers
      
      virtual
      bool
      OnNotify(
         HWND        windowFrom,
         UINT_PTR    controlIDFrom,
         UINT        code,
         LPARAM      lParam);

      // CYSWizardPage overrides

      virtual
      int
      Validate();

      void
      InitializeServerListView();

      void
      FillServerTypeList();

      void
      SetDescriptionForSelection();

      void
      SetNextButtonState();

   private:

      void
      MakeRoleStaticBold();

      InstallationUnit&
      GetInstallationUnitFromSelection(
         int currentSelection);

      // not defined: no copying allowed
      CustomServerPage(const CustomServerPage&);
      const CustomServerPage& operator=(const CustomServerPage&);

};

#endif // __CYS_CUSTOMSERVERPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\cyswizardpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      CYSWizardPage.cpp
//
// Synopsis:  Defines the base class for the wizard
//            pages used for CYS.  It is a subclass
//            of WizardPage found in Burnslib
//
// History:   02/03/2001  JeffJon Created


#include "pch.h"

#include "resource.h"

#include "CYSWizardPage.h"


CYSWizardPage::CYSWizardPage(
   int    dialogResID,
   int    titleResID,
   int    subtitleResID,   
   PCWSTR pageHelpString,
   bool   hasHelp,
   bool   isInteriorPage)
   :
   WizardPage(dialogResID, titleResID, subtitleResID, isInteriorPage, hasHelp)
{
   LOG_CTOR(CYSWizardPage);

   if (hasHelp)
   {
      ASSERT(pageHelpString);
      if (pageHelpString)
      {
         helpString = pageHelpString;
      }
   }
}

   

CYSWizardPage::~CYSWizardPage()
{
   LOG_DTOR(CYSWizardPage);

}

void
CYSWizardPage::OnInit()
{
   LOG_FUNCTION(CYSWizardPage::OnInit);

   PropertyPage::OnInit();
}

bool
CYSWizardPage::OnWizNext()
{
   LOG_FUNCTION(CYSWizardPage::OnWizNext);

   GetWizard().SetNextPageID(hwnd, Validate());
   return true;
}

/* NTRAID#NTBUG9-337325-2001/03/15-jeffjon,
   The cancel confirmation has been removed
   due to negative user feedback.
*/
bool
CYSWizardPage::OnQueryCancel()
{
   LOG_FUNCTION(CYSWizardPage::OnQueryCancel);

   bool result = false;

   // set the rerun state to false so the wizard doesn't
   // just restart itself

//   State::GetInstance().SetRerunWizard(false);

   Win::SetWindowLongPtr(
      hwnd,
      DWLP_MSGRESULT,
      result ? TRUE : FALSE);

   return true;
}

HBRUSH
CYSWizardPage::OnCtlColorDlg(
   HDC   deviceContext,
   HWND  /*dialog*/)
{
   return GetBackgroundBrush(deviceContext);
}

HBRUSH
CYSWizardPage::OnCtlColorStatic(
   HDC   deviceContext,
   HWND  /*dialog*/)
{
   return GetBackgroundBrush(deviceContext);
}

HBRUSH
CYSWizardPage::OnCtlColorEdit(
   HDC   deviceContext,
   HWND  /*dialog*/)
{
   return GetBackgroundBrush(deviceContext);
}

HBRUSH
CYSWizardPage::OnCtlColorListbox(
   HDC   deviceContext,
   HWND  /*dialog*/)
{
   return GetBackgroundBrush(deviceContext);
}

HBRUSH
CYSWizardPage::OnCtlColorScrollbar(
   HDC   deviceContext,
   HWND  /*dialog*/)
{
   return GetBackgroundBrush(deviceContext);
}

HBRUSH
CYSWizardPage::GetBackgroundBrush(HDC deviceContext)
{
//   LOG_FUNCTION(CYSWizardPage::GetBackgroundBrush);

   ASSERT(deviceContext);
   if (deviceContext)
   {
      SetTextColor(deviceContext, GetSysColor(COLOR_WINDOWTEXT));
      SetBkColor(deviceContext, GetSysColor(COLOR_WINDOW));
   }

   return Win::GetSysColorBrush(COLOR_WINDOW);
}

bool
CYSWizardPage::OnHelp()
{
   LOG_FUNCTION(CYSWizardPage::OnHelp);

   // NTRAID#NTBUG9-497798-2001/11/20-JeffJon
   // Use null as the owner so that you can bring 
   // CYS to the foreground. If you use the page
   // as the owner help will stay in the foreground.

   ShowHelp(GetHelpString());

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\decisionpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      DecisionPage.cpp
//
// Synopsis:  Defines Decision Page for the CYS
//            Wizard.  This page lets the user choose
//            between the custom and express paths
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "DecisionPage.h"


static PCWSTR DECISION_PAGE_HELP = L"cys.chm::/cys_topnode.htm";

DecisionPage::DecisionPage()
   :
   CYSWizardPage(
      IDD_DECISION_PAGE, 
      IDS_DECISION_TITLE, 
      IDS_DECISION_SUBTITLE, 
      DECISION_PAGE_HELP)
{
   LOG_CTOR(DecisionPage);
}

   

DecisionPage::~DecisionPage()
{
   LOG_DTOR(DecisionPage);
}


void
DecisionPage::OnInit()
{
   LOG_FUNCTION(DecisionPage::OnInit);

   CYSWizardPage::OnInit();

   // Set the text that was too long for the resource

   String tooLongText;

   if (State::GetInstance().GetNICCount() > 1)
   {
      tooLongText = String::load(IDS_DECISION_EXPRESS_MULTIPLE_NICS);
   }
   else
   {
      tooLongText = String::load(IDS_DECISION_EXPRESS_TOO_LONG_TEXT);
   }

   Win::SetWindowText(
      Win::GetDlgItem(
         hwnd, 
         IDC_EXPRESS_TOO_LONG_STATIC), 
      tooLongText);

   // NTRAID#NTBUG9-511431-2002/1/14-JeffJon
   // Make the user choose which path to go down instead of providing a default

//   Win::Button_SetCheck(Win::GetDlgItem(hwnd, IDC_EXPRESS_RADIO), BST_CHECKED);
}

bool
DecisionPage::OnSetActive()
{
   LOG_FUNCTION(DecisionPage::OnSetActive);

   bool expressChecked = 
      Win::Button_GetCheck(
         Win::GetDlgItem(hwnd, IDC_EXPRESS_RADIO));

   bool customChecked =
      Win::Button_GetCheck(
         Win::GetDlgItem(hwnd, IDC_CUSTOM_RADIO));

   if (expressChecked ||
       customChecked)
   {
      LOG(L"Enabling next and back");

      Win::PropSheet_SetWizButtons(
         Win::GetParent(hwnd), 
         PSWIZB_NEXT | PSWIZB_BACK);
   }
   else
   {
      LOG(L"Enabling back");

      Win::PropSheet_SetWizButtons(
         Win::GetParent(hwnd), 
         PSWIZB_BACK);
   }

   return true;
}

bool
DecisionPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(DecisionPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_EXPRESS_RADIO:
      case IDC_CUSTOM_RADIO:
         if (code == BN_CLICKED)
         {
            bool expressChecked = 
               Win::Button_GetCheck(
                  Win::GetDlgItem(hwnd, IDC_EXPRESS_RADIO));

            bool customChecked =
               Win::Button_GetCheck(
                  Win::GetDlgItem(hwnd, IDC_CUSTOM_RADIO));

            if (expressChecked ||
               customChecked)
            {
               Win::PropSheet_SetWizButtons(
                  Win::GetParent(hwnd), 
                  PSWIZB_NEXT | PSWIZB_BACK);
            }
            else
            {
               Win::PropSheet_SetWizButtons(
                  Win::GetParent(hwnd), 
                  PSWIZB_BACK);
            }
         }
         break;

      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}

int
DecisionPage::Validate()
{
   LOG_FUNCTION(DecisionPage::Validate);

   int nextPage = -1;

   if (Win::Button_GetCheck(Win::GetDlgItem(hwnd, IDC_EXPRESS_RADIO)))
   {
      nextPage = IDD_AD_DOMAIN_NAME_PAGE;

      InstallationUnitProvider::GetInstance().SetCurrentInstallationUnit(EXPRESS_SERVER);

      // Make sure all the delegated installation units know we are in the
      // express path

      InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().SetExpressPathInstall(true);
      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().SetExpressPathInstall(true);
      InstallationUnitProvider::GetInstance().GetADInstallationUnit().SetExpressPathInstall(true);
      InstallationUnitProvider::GetInstance().GetRRASInstallationUnit().SetExpressPathInstall(true);
   }
   else if (Win::Button_GetCheck(Win::GetDlgItem(hwnd, IDC_CUSTOM_RADIO)))
   {
      // Make sure all the delegated installation units know we are no longer
      // in the express path (if we once were)

      InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().SetExpressPathInstall(false);
      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().SetExpressPathInstall(false);
      InstallationUnitProvider::GetInstance().GetADInstallationUnit().SetExpressPathInstall(false);
      InstallationUnitProvider::GetInstance().GetRRASInstallationUnit().SetExpressPathInstall(false);

      nextPage = IDD_CUSTOM_SERVER_PAGE;
   }
   else
   {
      ASSERT(false);
   }

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\cyswizardpage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      CYSWizardPage.h
//
// Synopsis:  Declares the base class for the wizard
//            pages used for CYS.  It is a subclass
//            of WizardPage found in Burnslib
//
// History:   02/03/2001  JeffJon Created

#ifndef __CYS_CYSWIZARDPAGE_H
#define __CYS_CYSWIZARDPAGE_H

// This brush is defined in cys.cpp and
// is created to override the default background
// window color. CYSWizardPage returns this from
// the OnCtlColor* virtual functions.

extern HBRUSH brush;

class CYSWizardPage : public WizardPage
{
   public:
      
      // Constructor
      
      CYSWizardPage(
         int    dialogResID,
         int    titleResID,
         int    subtitleResID,   
         PCWSTR pageHelpString = 0,
         bool   hasHelp = true,
         bool   isInteriorPage = true);

      // Destructor

      virtual ~CYSWizardPage();

      virtual
      void
      OnInit();

      virtual
      bool
      OnWizNext();

      virtual
      bool
      OnQueryCancel();

      virtual
      bool
      OnHelp();

      virtual
      HBRUSH
      OnCtlColorDlg(
         HDC   deviceContext,
         HWND  dialog);

      virtual
      HBRUSH
      OnCtlColorStatic(
         HDC   deviceContext,
         HWND  dialog);

      virtual
      HBRUSH
      OnCtlColorEdit(
         HDC   deviceContext,
         HWND  dialog);

      virtual
      HBRUSH
      OnCtlColorListbox(
         HDC   deviceContext,
         HWND  dialog);

      virtual
      HBRUSH
      OnCtlColorScrollbar(
         HDC   deviceContext,
         HWND  dialog);

   protected:

      virtual
      int
      Validate() = 0;

      const String
      GetHelpString() const { return helpString; }

      HBRUSH
      GetBackgroundBrush(HDC deviceContext);

   private:

      String helpString;

      // not defined: no copying allowed
      CYSWizardPage(const CYSWizardPage&);
      const CYSWizardPage& operator=(const CYSWizardPage&);
};

#endif // __CYS_CYSWIZARDPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\decisionpage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      DecisionPage.h
//
// Synopsis:  Declares the Decision Page for the CYS
//            wizard.  This page lets the user choose
//            between the express and custom paths.
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_DECISIONPAGE_H
#define __CYS_DECISIONPAGE_H

#include "CYSWizardPage.h"


class DecisionPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      DecisionPage();

      // Destructor

      virtual 
      ~DecisionPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      virtual
      bool
      OnSetActive();

      bool
      OnCommand(
         HWND        windowFrom,
         unsigned    controlIDFrom,
         unsigned    code);

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();

   private:

      // not defined: no copying allowed
      DecisionPage(const DecisionPage&);
      const DecisionPage& operator=(const DecisionPage&);

};

#endif // __CYS_DECISIONPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\cys.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      cys.cpp
//
// Synopsis:  Configure Your Server Wizard main
//
// History:   02/02/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"

// include the wizard pages
#include "BeforeBeginPage.h"
#include "CustomServerPage.h"
#include "DecisionPage.h"
#include "DnsForwarderPage.h"
#include "DomainPage.h"
#include "ExpressDHCPPage.h"
#include "ExpressDNSPage.h"
#include "ExpressRebootPage.h"
#include "FileServerPage.h"
#include "FinishPage.h"
#include "IndexingPage.h"
#include "InstallationProgressPage.h"
#include "MilestonePage.h"
#include "NetbiosPage.h"
#include "POP3Page.h"
#include "PrintServerPage.h"
#include "RemoteDesktopPage.h"
#include "UninstallMilestonePage.h"
#include "UninstallProgressPage.h"
#include "WebApplicationPage.h"
#include "WelcomePage.h"

#include "ExpressRebootPage.h"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;   // no context help available


// This is the name of a mutex that is used to see if CYS is running

const wchar_t* RUNTIME_NAME = L"cysui";

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER
      |  Log::OUTPUT_RUN_TIME;


// a system modal popup thingy
Popup popup(IDS_WIZARD_TITLE, true);

// this is the mutex that indicates that CYS is running.

HANDLE cysRunningMutex = INVALID_HANDLE_VALUE;

// This is a brush that is used to paint all the backgrounds. It
// needs to be created and deleted from inside main

HBRUSH brush = 0;

// these are the valid exit codes returned from the cys.exe process

enum ExitCode
{
   // the operation failed.

   EXIT_CODE_UNSUCCESSFUL = 0,

   // the operation succeeded

   EXIT_CODE_SUCCESSFUL = 1,

   // other exit codes can be added here...
};

enum StartPages
{
   CYS_WELCOME_PAGE = 0,
   CYS_BEFORE_BEGIN_PAGE,
   CYS_EXPRESS_REBOOT_PAGE,
   CYS_FINISH_PAGE
};


UINT
TerminalServerPostBoot()
{
   LOG_FUNCTION(TerminalServerPostBoot);

   UINT startPage = CYS_WELCOME_PAGE;

   InstallationUnitProvider::GetInstance().
      SetCurrentInstallationUnit(TERMINALSERVER_SERVER);

   // Create the log file

   bool logFileAvailable = false;
   String logName;
   HANDLE logfileHandle = AppendLogFile(
                             CYS_LOGFILE_NAME, 
                             logName);
   if (logfileHandle &&
       logfileHandle != INVALID_HANDLE_VALUE)
   {
      LOG(String::format(L"New log file was created: %1", logName.c_str()));
      logFileAvailable = true;
   }
   else
   {
      LOG(L"Unable to create the log file!!!");
      logFileAvailable = false;
   }

   // Prepare the finish dialog

   TerminalServerInstallationUnit& tsInstallationUnit =
      InstallationUnitProvider::GetInstance().GetTerminalServerInstallationUnit();

   // Make sure the installation unit knows we are doing an install

   tsInstallationUnit.SetInstalling(true);

   if (tsInstallationUnit.GetApplicationMode() == 1)
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_TERMINAL_SERVER_REBOOT_SUCCESS));

      tsInstallationUnit.SetInstallResult(INSTALL_SUCCESS);

      startPage = CYS_FINISH_PAGE;
   }
   else
   {
      // Failed to install Terminal Server

      CYS_APPEND_LOG(String::load(IDS_LOG_TERMINAL_SERVER_REBOOT_FAILED));

      tsInstallationUnit.SetInstallResult(INSTALL_FAILURE);

      startPage = CYS_FINISH_PAGE;
   }

   CYS_APPEND_LOG(L"\r\n");

   // Close the log file

   Win::CloseHandle(logfileHandle);

   LOG(String::format(
          L"startPage = %1!d!",
          startPage));

   return startPage;
}

UINT
TerminalServerUninstallPostBoot()
{
   LOG_FUNCTION(TerminalServerUninstallPostBoot);

   UINT startPage = CYS_WELCOME_PAGE;

   InstallationUnitProvider::GetInstance().
      SetCurrentInstallationUnit(TERMINALSERVER_SERVER);

   // Create the log file

   bool logFileAvailable = false;
   String logName;
   HANDLE logfileHandle = AppendLogFile(
                             CYS_LOGFILE_NAME, 
                             logName);
   if (logfileHandle &&
       logfileHandle != INVALID_HANDLE_VALUE)
   {
      LOG(String::format(L"New log file was created: %1", logName.c_str()));
      logFileAvailable = true;
   }
   else
   {
      LOG(L"Unable to create the log file!!!");
      logFileAvailable = false;
   }

   // Prepare the finish dialog

   TerminalServerInstallationUnit& tsInstallationUnit =
      InstallationUnitProvider::GetInstance().GetTerminalServerInstallationUnit();

   // Make sure the installation unit knows we are doing an uninstall

   tsInstallationUnit.SetInstalling(false);

   if (tsInstallationUnit.GetApplicationMode() == 0)
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_TERMINAL_SERVER_SUCCESS));

      tsInstallationUnit.SetUninstallResult(UNINSTALL_SUCCESS);

      startPage = CYS_FINISH_PAGE;
   }
   else
   {
      // Failed to uninstall Terminal Server

      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_TERMINAL_SERVER_FAILED));

      tsInstallationUnit.SetUninstallResult(UNINSTALL_FAILURE);

      startPage = CYS_FINISH_PAGE;
   }

   CYS_APPEND_LOG(L"\r\n");

   // Close the log file

   Win::CloseHandle(logfileHandle);

   LOG(String::format(
          L"startPage = %1!d!",
          startPage));

   return startPage;
}

UINT
FirstServerPostBoot()
{
   LOG_FUNCTION(FirstServerPostBoot);

   UINT startPage = CYS_EXPRESS_REBOOT_PAGE;

   InstallationUnitProvider::GetInstance().
      SetCurrentInstallationUnit(EXPRESS_SERVER);

   LOG(String::format(
          L"startPage = %1!d!",
          startPage));

   return startPage;
}

UINT
DCPromoPostBoot()
{
   LOG_FUNCTION(DCPromoPostBoot);

   UINT startPage = CYS_WELCOME_PAGE;

   InstallationUnitProvider::GetInstance().
      SetCurrentInstallationUnit(DC_SERVER);

   // Create the log file

   bool logFileAvailable = false;
   String logName;
   HANDLE logfileHandle = AppendLogFile(
                             CYS_LOGFILE_NAME, 
                             logName);
   if (logfileHandle &&
       logfileHandle != INVALID_HANDLE_VALUE)
   {
      LOG(String::format(L"New log file was created: %1", logName.c_str()));
      logFileAvailable = true;
   }
   else
   {
      LOG(L"Unable to create the log file!!!");
      logFileAvailable = false;
   }

   // Make sure the installation unit knows we are doing an install

   InstallationUnitProvider::GetInstance().
      GetCurrentInstallationUnit().SetInstalling(true);

   // Prepare the finish page

   if (State::GetInstance().IsDC())
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_DOMAIN_CONTROLLER_SUCCESS));

      InstallationUnitProvider::GetInstance().
         GetADInstallationUnit().SetInstallResult(INSTALL_SUCCESS);

      startPage = CYS_FINISH_PAGE;
   }
   else
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_DOMAIN_CONTROLLER_FAILED));

      InstallationUnitProvider::GetInstance().
         GetADInstallationUnit().SetInstallResult(INSTALL_FAILURE);

      startPage = CYS_FINISH_PAGE; 
   }
   CYS_APPEND_LOG(L"\r\n");

   // Close the log file

   Win::CloseHandle(logfileHandle);

   LOG(String::format(
          L"startPage = %1!d!",
          startPage));

   return startPage;
}

UINT
DCDemotePostBoot()
{
   LOG_FUNCTION(DCDemotePostBoot);

   UINT startPage = CYS_WELCOME_PAGE;

   InstallationUnitProvider::GetInstance().
      SetCurrentInstallationUnit(DC_SERVER);

   // Create the log file

   bool logFileAvailable = false;
   String logName;
   HANDLE logfileHandle = AppendLogFile(
                             CYS_LOGFILE_NAME, 
                             logName);
   if (logfileHandle &&
       logfileHandle != INVALID_HANDLE_VALUE)
   {
      LOG(String::format(L"New log file was created: %1", logName.c_str()));
      logFileAvailable = true;
   }
   else
   {
      LOG(L"Unable to create the log file!!!");
      logFileAvailable = false;
   }

   // Make sure the installation unit knows we are doing an uninstall

   InstallationUnitProvider::GetInstance().
      GetCurrentInstallationUnit().SetInstalling(false);

   // Prepare the finish page

   if (!State::GetInstance().IsDC())
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_DOMAIN_CONTROLLER_SUCCESS));

      InstallationUnitProvider::GetInstance().
         GetADInstallationUnit().SetUninstallResult(UNINSTALL_SUCCESS);

      startPage = CYS_FINISH_PAGE;
   }
   else
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_DOMAIN_CONTROLLER_FAILED));

      InstallationUnitProvider::GetInstance().
         GetADInstallationUnit().SetUninstallResult(UNINSTALL_FAILURE);

      startPage = CYS_FINISH_PAGE; 
   }
   CYS_APPEND_LOG(L"\r\n");

   // Close the log file

   Win::CloseHandle(logfileHandle);

   LOG(String::format(
          L"startPage = %1!d!",
          startPage));

   return startPage;
}

UINT
DoRebootOperations()
{
   LOG_FUNCTION(DoRebootOperations);

   UINT startPage = 0;

   // Check to see if we are in a reboot scenario

   String homeKeyValue;
   if (State::GetInstance().GetHomeRegkey(homeKeyValue))
   {
      // Now set the home regkey back to "home" so that we won't run
      // through these again. This has to be done before doing the
      // operation because the user could leave this dialog up
      // and cause a reboot (like demoting a DC) and then the
      // post reboot operations would run again

      if (homeKeyValue.icompare(CYS_HOME_REGKEY_DEFAULT_VALUE) != 0)
      {
         bool result = 
            State::GetInstance().SetHomeRegkey(CYS_HOME_REGKEY_DEFAULT_VALUE);

         ASSERT(result);
      }

      // Reset the must run key now that we have done the reboot stuff

      bool regkeyResult = SetRegKeyValue(
                             CYS_HOME_REGKEY, 
                             CYS_HOME_REGKEY_MUST_RUN, 
                             CYS_HOME_RUN_KEY_DONT_RUN,
                             HKEY_LOCAL_MACHINE,
                             true);
      ASSERT(regkeyResult);

      // Set the reboot scenario in the state object so that we know we
      // are running in that context

      State::GetInstance().SetRebootScenario(true);

      // Now run the post reboot operations if necessary

      if (homeKeyValue.icompare(CYS_HOME_REGKEY_TERMINAL_SERVER_VALUE) == 0)
      {
         startPage = TerminalServerPostBoot();
      }
      else if (homeKeyValue.icompare(CYS_HOME_REGKEY_UNINSTALL_TERMINAL_SERVER_VALUE) == 0)
      {
         startPage = TerminalServerUninstallPostBoot();
      }
      else if (homeKeyValue.icompare(CYS_HOME_REGKEY_FIRST_SERVER_VALUE) == 0)
      {
         startPage = FirstServerPostBoot();
      }
      else if (homeKeyValue.icompare(CYS_HOME_REGKEY_DCPROMO_VALUE) == 0)
      {
         startPage = DCPromoPostBoot();
      }
      else if (homeKeyValue.icompare(CYS_HOME_REGKEY_DCDEMOTE_VALUE) == 0)
      {
         startPage = DCDemotePostBoot();
      }
      else
      {
         // We are NOT running a reboot scenario

         State::GetInstance().SetRebootScenario(false);
      }
   }

   LOG(String::format(
          L"startPage = %1!d!",
          startPage));

   return startPage;
}

UINT
GetStartPageFromCommandLine()
{
   LOG_FUNCTION(GetStartPageFromCommandLine);

   UINT startPage = 0;

   StringVector args;
   int argc = Win::GetCommandLineArgs(std::back_inserter(args));

   if (argc > 1)
   {
      const String skipWelcome(L"/skipWelcome");

      for (
         StringVector::iterator itr = args.begin();
         itr != args.end();
         ++itr)
      {
         if (itr &&
             (*itr).icompare(skipWelcome) == 0)
         {
            startPage = 1;
            break;
         }
      }
   }

   LOG(String::format(
          L"startPage = %1!d!",
          startPage));

   return startPage;
}

UINT
GetStartPage()
{
   LOG_FUNCTION(GetStartPage);

   UINT startPage = 0;

   // First check for the reboot scenarios

   startPage = DoRebootOperations();
   if (startPage == 0)
   {
      // Now look at the commandline to see if any
      // switches were provided

      startPage = GetStartPageFromCommandLine();
   }
 
   LOG(String::format(
          L"startPage = %1!d!",
          startPage));

   return startPage;
}

// This is the DlgProc of the property sheet that we are subclassing. I need
// to hold on to it so I can call it if we don't handle the message in our
// replacement DlgProc.

static WNDPROC replacedSheetWndProc = 0;

// This is the DlgProc that we will use to replace the property sheet
// DlgProc. It handles the WM_CTLCOLORDLG message to paint the background
// color

LRESULT
ReplacementWndProc(
   HWND   hwnd,
   UINT   message,
   WPARAM wparam,
   LPARAM lparam)
{
   switch (message)
   {
      case WM_CTLCOLORDLG:
      case WM_CTLCOLORSTATIC:
      case WM_CTLCOLOREDIT:
      case WM_CTLCOLORLISTBOX:
      case WM_CTLCOLORSCROLLBAR:
         {
            HDC deviceContext = reinterpret_cast<HDC>(wparam);

            ASSERT(deviceContext);
            if (deviceContext)
            {
               SetTextColor(deviceContext, GetSysColor(COLOR_WINDOWTEXT));
               SetBkColor(deviceContext, GetSysColor(COLOR_WINDOW));
            }

            return 
               reinterpret_cast<LRESULT>(
                  Win::GetSysColorBrush(COLOR_WINDOW));
         }

      default:
         if (replacedSheetWndProc)
         {
            return ::CallWindowProc(
                      replacedSheetWndProc,
                      hwnd,
                      message,
                      wparam,
                      lparam);
         }
         break;
   }
   return 0;
}


// This callback function is called by the property sheet. During initialization
// I use this to subclass the property sheet, replacing their DlgProc with my
// own so that I can change the background color.

int 
CALLBACK 
SheetCallbackProc(
   HWND   hwnd,
   UINT   message,
   LPARAM /*lparam*/)
{
   LOG_FUNCTION(SheetCallbackProc);

   if (message == PSCB_INITIALIZED)
   {
      LONG_PTR ptr = 0;
      HRESULT hr = Win::GetWindowLongPtr(
                      hwnd,
                      GWLP_WNDPROC,
                      ptr);

      if (SUCCEEDED(hr))
      {
         replacedSheetWndProc = reinterpret_cast<WNDPROC>(ptr);

         hr = Win::SetWindowLongPtr(
                 hwnd,
                 GWLP_WNDPROC,
                 reinterpret_cast<LONG_PTR>(ReplacementWndProc));

         ASSERT(SUCCEEDED(hr));
      }
   }

   return 0;
}

ExitCode
RunWizard()
{
   LOG_FUNCTION(RunWizard);


   ExitCode exitCode = EXIT_CODE_SUCCESSFUL;

   UINT startPage = GetStartPage();
   
   State::GetInstance().SetStartPage(startPage);

   // Create the wizard and add all the pages

   Wizard wiz(
      IDS_WIZARD_TITLE,
      IDB_BANNER16,
      IDB_BANNER256,
      IDB_WATERMARK16,
      IDB_WATERMARK256);

   // NOTE: Do not change the order of the following
   // page additions. They are important for being able
   // to start the wizard at one of these pages directly.
   // The order of these pages cooresponds directly to 
   // the order of the StartPages enum above

   wiz.AddPage(new WelcomePage());        // CYS_WELCOME_PAGE
   wiz.AddPage(new BeforeBeginPage());    // CYS_BEFORE_BEGIN_PAGE
   wiz.AddPage(new ExpressRebootPage());  // CYS_EXPRESS_REBOOT_PAGE
   wiz.AddPage(new FinishPage());         // CYS_FINISH_PAGE

   //
   //
   //

   wiz.AddPage(new DecisionPage());
   wiz.AddPage(new CustomServerPage());
   wiz.AddPage(new ADDomainPage());
   wiz.AddPage(new NetbiosDomainPage());
   wiz.AddPage(new DNSForwarderPage());
   wiz.AddPage(new ExpressDNSPage());
   wiz.AddPage(new ExpressDHCPPage());
   wiz.AddPage(new PrintServerPage());
   wiz.AddPage(new FileServerPage());
   wiz.AddPage(new IndexingPage());
   wiz.AddPage(new MilestonePage());
   wiz.AddPage(new UninstallMilestonePage());
   wiz.AddPage(new InstallationProgressPage());
   wiz.AddPage(new UninstallProgressPage());
   wiz.AddPage(new WebApplicationPage());
   wiz.AddPage(new POP3Page());

   // Run the wizard
   switch (wiz.ModalExecute(
                  0, 
                  startPage,
                  SheetCallbackProc))
   {
      case -1:
      {
/*             popup.Error(
            Win::GetDesktopWindow(),
            E_FAIL,
            IDS_PROP_SHEET_FAILED);
         
*/       
         exitCode = EXIT_CODE_UNSUCCESSFUL;  
         break;
      }
      case ID_PSREBOOTSYSTEM:
      {
         // we can infer that if we are supposed to reboot, then the
         // operation was successful.

         exitCode = EXIT_CODE_SUCCESSFUL;

         break;
      }
      default:
      {
         // do nothing.
         break;
      }
   }

   return exitCode;
}

ExitCode
Start()
{
   LOG_FUNCTION(Start);

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;
   do
   {
      // Put any checks that should stop the wizard from running here...


      // User must be an Administrator

      bool isAdmin = ::IsCurrentUserAdministrator();
      if (!isAdmin)
      {
         LOG(L"Current user is not an Administrator");

         // Since the user is not an administrator
         // close the mutex so that a non-admin can't
         // leave this message box up and prevent
         // an administrator from running CYS

         Win::CloseHandle(cysRunningMutex);

         popup.MessageBox(
            Win::GetDesktopWindow(),
            IDS_NOT_ADMIN, 
            MB_OK);

//         State::GetInstance().SetRerunWizard(false);
         exitCode = EXIT_CODE_UNSUCCESSFUL;
         break;
      }

      // The Sys OC Manager cannot be running

      if (State::GetInstance().IsWindowsSetupRunning())
      {
         LOG(L"Windows setup is running");

         popup.MessageBox(
            Win::GetDesktopWindow(),
            IDS_WINDOWS_SETUP_RUNNING_DURING_CYS_STARTUP,
            MB_OK);

         exitCode = EXIT_CODE_UNSUCCESSFUL;
         break;
      }

      // Machine cannot be in the middle of a DC upgrade

      if (State::GetInstance().IsUpgradeState())
      {
         LOG(L"Machine needs to complete DC upgrade");

         String commandline = Win::GetCommandLine();

         // If we were launched from explorer then 
         // don't show the message, just exit silently

         if (commandline.find(EXPLORER_SWITCH) == String::npos)
         {
            popup.MessageBox(
               Win::GetDesktopWindow(),
               IDS_DC_UPGRADE_NOT_COMPLETE, 
               MB_OK);
         }

//         State::GetInstance().SetRerunWizard(false);
         exitCode = EXIT_CODE_UNSUCCESSFUL;
         break;
      }

      // Machine cannot have DCPROMO running or a reboot pending

      if (State::GetInstance().IsDCPromoRunning())
      {
         LOG(L"DCPROMO is running");

         popup.MessageBox(
            Win::GetDesktopWindow(),
            IDS_DCPROMO_RUNNING, 
            MB_OK);

//         State::GetInstance().SetRerunWizard(false);
         exitCode = EXIT_CODE_UNSUCCESSFUL;
         break;
      }
      else if (State::GetInstance().IsDCPromoPendingReboot())
      {
         LOG(L"DCPROMO was run, pending reboot");

         popup.MessageBox(
            Win::GetDesktopWindow(),
            IDS_DCPROMO_PENDING_REBOOT, 
            MB_OK);

//         State::GetInstance().SetRerunWizard(false);
         exitCode = EXIT_CODE_UNSUCCESSFUL;
         break;
      }
      
      DWORD productSKU = State::GetInstance().RetrieveProductSKU();
      if (CYS_UNSUPPORTED_SKU == productSKU)
      {
         LOG(L"Cannot run CYS on any SKU but servers");

         popup.MessageBox(
            Win::GetDesktopWindow(),
            IDS_SERVER_ONLY,
            MB_OK);

//         State::GetInstance().SetRerunWizard(false);
         exitCode = EXIT_CODE_UNSUCCESSFUL;
         break;
      }

      // The machine cannot be a member of a cluster

      if (IsClusterServer())
      {
         LOG(L"Machine is a member of a cluster");

         Win::CloseHandle(cysRunningMutex);

         popup.MessageBox(
            Win::GetDesktopWindow(),
            IDS_CLUSTER,
            MB_OK);

         exitCode = EXIT_CODE_UNSUCCESSFUL;
         break;
      }

      // We can run the wizard.  Yea!!!

      exitCode = RunWizard();
   }
   while (0);

   LOG(String::format(L"exitCode = %1!d!", static_cast<int>(exitCode)));
   
   return exitCode;
}

int WINAPI
WinMain(
   HINSTANCE   hInstance,
   HINSTANCE   /* hPrevInstance */ ,
   PSTR        /* lpszCmdLine */ ,
   int         /* nCmdShow */)
{
   hResourceModuleHandle = hInstance;

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;

   String mutexName = L"Global\\";
   mutexName += RUNTIME_NAME;

   HRESULT hr = Win::CreateMutex(0, true, mutexName, cysRunningMutex);
   if (hr == Win32ToHresult(ERROR_ALREADY_EXISTS))
   {
      // First close the handle so that the owner can reacquire if they
      // restart

      Win::CloseHandle(cysRunningMutex);

      // Now show the error message

      popup.MessageBox(
         Win::GetDesktopWindow(), 
         IDS_ALREADY_RUNNING, 
         MB_OK);
   }
   else
   {

      do
      {
         hr = ::CoInitialize(0);
         if (FAILED(hr))
         {
            ASSERT(SUCCEEDED(hr));
            break;
         }

         // Initialize the common controls so that we can use
         // animation in the NetDetectProgressDialog

         INITCOMMONCONTROLSEX commonControlsEx;
         commonControlsEx.dwSize = sizeof(commonControlsEx);      
         commonControlsEx.dwICC  = ICC_ANIMATE_CLASS;

         BOOL init = ::InitCommonControlsEx(&commonControlsEx);
         ASSERT(init);

         // For now there is no more rerunning CYS
//         do 
//         {
            exitCode = Start();

//         } while(State::GetInstance().RerunWizard());

         InstallationUnitProvider::Destroy();
         State::Destroy();

         CoUninitialize();
      } while(false);
   }

   if (brush)
   {
      // delete the background brush

      (void)Win::DeleteObject(brush);
   }

   return static_cast<int>(exitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\dhcpinstallationunit.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      DHCPInstallationUnit.h
//
// Synopsis:  Declares a DHCPInstallationUnit
//            This object has the knowledge for installing the
//            DHCP service
//
// History:   02/05/2001  JeffJon Created

#ifndef __CYS_DHCPINSTALLATIONUNIT_H
#define __CYS_DHCPINSTALLATIONUNIT_H

#include "NetworkInterface.h"
#include "resource.h"

#include "ExpressPathInstallationUnitBase.h"

extern PCWSTR CYS_DHCP_FINISH_PAGE_HELP;

class DHCPInstallationUnit : public ExpressPathInstallationUnitBase
{
   public:
      
      // Constructor

      DHCPInstallationUnit();

      // Destructor
      virtual
      ~DHCPInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      UnInstallReturnType
      UnInstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      GetMilestoneText(String& message);

      virtual
      String
      GetFinishText();

      virtual
      bool
      GetUninstallMilestoneText(String& message);

      InstallationReturnType
      ExpressPathInstall(HANDLE logfileHandle, HWND hwnd);

      virtual
      String
      GetServiceDescription();

      virtual
      void
      ServerRoleLinkSelected(int linkIndex, HWND hwnd);

      virtual
      void
      FinishLinkSelected(int inkIndex, HWND hwnd);

      // Other accessibly functions

      bool
      AuthorizeDHCPServer(const String& dnsName) const;

      // Data accessors

      void
      SetStartIPAddress(DWORD ipaddress);

      DWORD
      GetStartIPAddress(const NetworkInterface& nic);

      void
      SetEndIPAddress(DWORD ipaddress);

      DWORD
      GetEndIPAddress(const NetworkInterface& nic);

      String
      GetStartIPAddressString(const NetworkInterface& nic);

      String
      GetEndIPAddressString(const NetworkInterface& nic);

   protected:

      void
      CreateUnattendFileTextForExpressPath(
         const NetworkInterface& nic,
         String& unattendFileText);

   private:

      enum DHCPRoleResult
      {
         DHCP_SUCCESS,
         DHCP_INSTALL_FAILURE,
         DHCP_CONFIG_FAILURE
      };

      void
      CalculateScope(const NetworkInterface& nic);

      DHCPRoleResult dhcpRoleResult;

      bool  isExpressPathInstall;
      bool  scopeCalculated;

      DWORD startIPAddress;
      DWORD endIPAddress;

      unsigned int installedDescriptionID;
};

#endif // __CYS_DHCPINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\dhcpinstallationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      DHCPInstallationUnit.cpp
//
// Synopsis:  Defines a DHCPInstallationUnit
//            This object has the knowledge for installing the
//            DHCP service
//
// History:   02/05/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "DHCPInstallationUnit.h"
#include "InstallationUnitProvider.h"

// Finish page help 
extern PCWSTR CYS_DHCP_FINISH_PAGE_HELP = L"cys.chm::/dhcp_server_role.htm";
static PCWSTR CYS_DHCP_MILESTONE_HELP = L"cys.chm::/dhcp_server_role.htm#dhcpsrvsummary";
static PCWSTR CYS_DHCP_AFTER_FINISH_HELP = L"cys.chm::/dhcp_server_role.htm#dhcpsrvcompletion";

DHCPInstallationUnit::DHCPInstallationUnit() :
   startIPAddress(0),
   endIPAddress(0),
   scopeCalculated(false),
   dhcpRoleResult(DHCP_SUCCESS),
   installedDescriptionID(IDS_DHCP_SERVER_DESCRIPTION_INSTALLED),
   ExpressPathInstallationUnitBase(
      IDS_DHCP_SERVER_TYPE, 
      IDS_DHCP_SERVER_DESCRIPTION, 
      IDS_DHCP_FINISH_TITLE,
      IDS_DHCP_FINISH_UNINSTALL_TITLE,
      IDS_DHCP_FINISH_MESSAGE,
      IDS_DHCP_INSTALL_FAILED,
      IDS_DHCP_UNINSTALL_MESSAGE,
      IDS_DHCP_UNINSTALL_FAILED,
      IDS_DHCP_UNINSTALL_WARNING,
      IDS_DHCP_UNINSTALL_CHECKBOX,
      CYS_DHCP_FINISH_PAGE_HELP,
      CYS_DHCP_MILESTONE_HELP,
      CYS_DHCP_AFTER_FINISH_HELP,
      DHCP_SERVER)
{
   LOG_CTOR(DHCPInstallationUnit);
}


DHCPInstallationUnit::~DHCPInstallationUnit()
{
   LOG_DTOR(DHCPInstallationUnit);
}


InstallationReturnType
DHCPInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(DHCPInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   if (IsExpressPathInstall())
   {
      // This is an express path install.  It must be done special

      result = ExpressPathInstall(logfileHandle, hwnd);

      LOG_INSTALL_RETURN(result);
      return result;
   }

   dhcpRoleResult = DHCP_SUCCESS;

   // Log the DHCP header

   CYS_APPEND_LOG(String::load(IDS_LOG_DHCP_HEADER));

   UpdateInstallationProgressText(hwnd, IDS_DHCP_INSTALL_PROGRESS);

   String infFileText;
   String unattendFileText;

   CreateInfFileText(infFileText, IDS_DHCP_INF_WINDOW_TITLE);
   CreateUnattendFileText(unattendFileText, CYS_DHCP_SERVICE_NAME);

   // We are ignoring the ocmresult because it doesn't matter
   // with respect to whether the role is installed or not

   InstallServiceWithOcManager(infFileText, unattendFileText);
   
   if (IsServiceInstalled())
   {
      // Log the successful installation

      LOG(L"DHCP was installed successfully");
      CYS_APPEND_LOG(String::load(IDS_LOG_SERVER_START_DHCP));

      // Wait for the service to enter the running state

      NTService serviceObject(CYS_DHCP_SERVICE_NAME);

      HRESULT hr = serviceObject.WaitForServiceState(SERVICE_RUNNING);
      if (FAILED(hr))
      {
         // Remember where the failure happened

         dhcpRoleResult = DHCP_INSTALL_FAILURE;

         LOG(String::format(
                L"The DHCP service failed to start in a timely fashion: %1!x!",
                hr));

         CYS_APPEND_LOG(String::load(IDS_LOG_DHCP_WIZARD_ERROR));
         result = INSTALL_FAILURE;
      }
      else
      {
         // Run the DHCP Wizard
         
         String resultText;
         HRESULT unused = S_OK;

         UpdateInstallationProgressText(hwnd, IDS_DHCP_CONFIG_PROGRESS);
      
         if (ExecuteWizard(hwnd, CYS_DHCP_SERVICE_NAME, resultText, unused))
         {
            // Check to be sure the wizard finished completely

            String configWizardResults;
            bool regkeyResult = GetRegKeyValue(
                                 CYS_DHCP_DOMAIN_IP_REGKEY,
                                 CYS_DHCP_WIZARD_RESULT,
                                 configWizardResults,
                                 HKEY_CURRENT_USER);

            if (IsDhcpConfigured() &&
                (!regkeyResult ||
                 configWizardResults.empty()))
            {
               // The New Scope Wizard completed successfully
               
               LOG(L"DHCP installed and the New Scope Wizard completed successfully");
               CYS_APPEND_LOG(String::load(IDS_LOG_DHCP_COMPLETED_SUCCESSFULLY));
            }
            else if(regkeyResult &&
                  !configWizardResults.empty())
            {
               // Remember where the failure happened

               dhcpRoleResult = DHCP_CONFIG_FAILURE;

               LOG(L"DHCP was installed but the New Scope Wizard failed or was cancelled");

               // NTRAID#NTBUG9-704311-2002/09/16-artm  
               // Don't include failure string in free builds b/c it is not localized.
#if DBG == 1
               CYS_APPEND_LOG(
                  String::format(
                     IDS_LOG_DHCP_WIZARD_ERROR_FORMAT,
                     configWizardResults.c_str()));
#else
               CYS_APPEND_LOG(String::load(IDS_LOG_DHCP_WIZARD_ERROR));
#endif
      
               result = INSTALL_FAILURE;
            }
            else
            {
               // The New Scope Wizard did not finish successfully

               // Remember where the failure happened

               dhcpRoleResult = DHCP_CONFIG_FAILURE;

               LOG(L"DHCP installed successfully, but a problem occurred during the New Scope Wizard");

               CYS_APPEND_LOG(String::load(IDS_LOG_DHCP_WIZARD_ERROR));
               result = INSTALL_FAILURE;
            }

            // reset the regkey to make sure that if someone runs this path
            // again we don't still think the wizard was cancelled.

            SetRegKeyValue(
               CYS_DHCP_DOMAIN_IP_REGKEY,
               CYS_DHCP_WIZARD_RESULT,
               L"",
               HKEY_CURRENT_USER);

         }
         else
         {
            // Remember where the failure happened

            dhcpRoleResult = DHCP_CONFIG_FAILURE;

            // Log an error

            LOG(L"DHCP could not be installed.");

            if (!resultText.empty())
            {
               CYS_APPEND_LOG(resultText);
            }
            result = INSTALL_FAILURE;
         }
      }
   }
   else
   {
      // Remember where the failure happened

      dhcpRoleResult = DHCP_INSTALL_FAILURE;

      // Log the failure

      LOG(L"DHCP failed to install");

      CYS_APPEND_LOG(String::load(IDS_LOG_DHCP_SERVER_FAILED));

      result = INSTALL_FAILURE;
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

UnInstallReturnType
DHCPInstallationUnit::UnInstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(DHCPInstallationUnit::UnInstallService);

   UnInstallReturnType result = UNINSTALL_SUCCESS;

   // Log the DHCP header

   CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_DHCP_HEADER));

   UpdateInstallationProgressText(hwnd, IDS_UNINSTALL_DHCP_PROGRESS);

   String infFileText;
   String unattendFileText;

   CreateInfFileText(infFileText, IDS_DHCP_INF_WINDOW_TITLE);
   CreateUnattendFileText(unattendFileText, CYS_DHCP_SERVICE_NAME, false);

   // NTRAID#NTBUG9-736557-2002/11/13-JeffJon
   // Pass the /w switch to sysocmgr when uninstalling
   // so that if a situation occurs in which a reboot
   // is required, the user will be prompted.

   String additionalArgs = L"/w";

   // We are ignoring the ocmresult because it doesn't matter
   // with respect to whether the role is installed or not

   InstallServiceWithOcManager(
      infFileText, 
      unattendFileText,
      additionalArgs);

   // Wait for the service to enter the stopped state

   NTService serviceObject(CYS_DHCP_SERVICE_NAME);

   // ignore the returned value.  This is just to wait on the
   // service. Use the normal mechanism for determining success
   // or failure of the uninstall

   serviceObject.WaitForServiceState(SERVICE_STOPPED);

   if (IsServiceInstalled())
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_DHCP_FAILED));

      result = UNINSTALL_FAILURE;
   }
   else
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_DHCP_SUCCESS));
   }
   LOG_UNINSTALL_RETURN(result);

   return result;
}

InstallationReturnType
DHCPInstallationUnit::ExpressPathInstall(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(DHCPInstallationUnit::ExpressPathInstall);

   InstallationReturnType result = INSTALL_SUCCESS;

   String infFileText;
   String unattendFileText;
   String commandline;

   String netshPath = GetNetshPath();

   do
   {
      // We ignore if the NIC is found or not because the function will return
      // the first NIC if the correct NIC is not found.  We can then use this
      // to setup the network

      NetworkInterface* localNIC = 
         State::GetInstance().GetLocalNIC();

      if (!localNIC)
      {
         result = INSTALL_FAILURE;

         LOG(L"Failed to get local NIC");
 
         InstallationUnitProvider::GetInstance().
            GetExpressInstallationUnit().SetExpressRoleResult(
               ExpressInstallationUnit::EXPRESS_DHCP_INSTALL_FAILURE);

         CYS_APPEND_LOG(String::load(IDS_DHCP_EXPRESS_LOG_FAILURE));

         break;
      }

      // In the case where the public interface has a static IP address
      // and the private interface has a DHCP server (whether the NIC
      // has a static or dynamic address doesn't matter), we don't want
      // to install another DHCP server.  So we will just skip it.

      if (localNIC->IsDHCPAvailable())
      {
         LOG(L"DHCP is already on this NIC so don't install");

         if (!SetRegKeyValue(
                 CYS_FIRST_DC_REGKEY,
                 CYS_FIRST_DC_DHCP_SERVERED,
                 CYS_DHCP_NOT_SERVERED_VALUE,
                 HKEY_LOCAL_MACHINE,
                 true))
         {
            LOG(L"Failed to set the DHCP installed regkey");
         }

         CYS_APPEND_LOG(String::load(IDS_DHCP_EXPRESS_LOG_NOT_REQUIRED));
         break;
      }

      UpdateInstallationProgressText(hwnd, IDS_DHCP_INSTALL_PROGRESS);
   
      CreateInfFileText(infFileText, IDS_DHCP_INF_WINDOW_TITLE);
      CreateUnattendFileTextForExpressPath(*localNIC, unattendFileText);

      bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
      if (ocmResult &&
          !IsServiceInstalled())
      {
         result = INSTALL_FAILURE;

         LOG(L"DHCP installation failed");
 
         InstallationUnitProvider::GetInstance().
            GetExpressInstallationUnit().SetExpressRoleResult(
               ExpressInstallationUnit::EXPRESS_DHCP_INSTALL_FAILURE);

         CYS_APPEND_LOG(String::load(IDS_DHCP_EXPRESS_LOG_FAILURE));

         break;
      }
      else
      {
         if (!SetRegKeyValue(
                 CYS_FIRST_DC_REGKEY,
                 CYS_FIRST_DC_DHCP_SERVERED,
                 CYS_DHCP_SERVERED_VALUE,
                 HKEY_LOCAL_MACHINE,
                 true))
         {
            LOG(L"Failed to set the DHCP installed regkey");
         }

         HRESULT hr = S_OK;

         // Wait for the service to enter the running state

         NTService serviceObject(CYS_DHCP_SERVICE_NAME);

         hr = serviceObject.WaitForServiceState(SERVICE_RUNNING);
         if (FAILED(hr))
         {
            LOG(String::format(
                  L"The DHCP service failed to start in a timely fashion: %1!x!",
                  hr));

            result = INSTALL_FAILURE;

            InstallationUnitProvider::GetInstance().
               GetExpressInstallationUnit().SetExpressRoleResult(
                  ExpressInstallationUnit::EXPRESS_DHCP_INSTALL_FAILURE);

            CYS_APPEND_LOG(String::load(IDS_DHCP_EXPRESS_LOG_FAILURE));
   
            break;
         }

         CYS_APPEND_LOG(String::load(IDS_DHCP_EXPRESS_LOG_SUCCESS));

         UpdateInstallationProgressText(hwnd, IDS_DHCP_CONFIG_PROGRESS);
   
         DWORD exitCode = 0;

         String ipaddressString = 
            localNIC->GetStringIPAddress(0);

         String subnetMaskString =
            localNIC->GetStringSubnetMask(0);

         do
         {
            commandline = L"dhcp server add optiondef 6 \"DNS Servers\" IPADDRESS 1";
            
            hr = CreateAndWaitForProcess(
                    netshPath, 
                    commandline, 
                    exitCode, 
                    true);

            if (FAILED(hr))
            {
               LOG(String::format(
                      L"Failed to run DHCP options: hr = %1!x!",
                      hr));
               break;
            }

            if (exitCode != 1)
            {
               LOG(String::format(
                      L"Failed to run DHCP options: exitCode = %1!x!",
                      exitCode));

               // Don't break here.  The most likely error is that the option already
               // exists.  In which case continue to set the value
            }

            commandline = String::format(
                             L"dhcp server set optionvalue 6 IPADDRESS %1",
                             ipaddressString.c_str());

            exitCode = 0;
            hr = CreateAndWaitForProcess(
                    netshPath,
                    commandline, 
                    exitCode, 
                    true);

            if (FAILED(hr))
            {
               LOG(String::format(
                      L"Failed to run DHCP server IP address: hr = %1!x!",
                      hr));
               break;
            }

            if (exitCode != 1)
            {
               LOG(String::format(
                      L"Failed to run DHCP server IP address: exitCode = %1!x!",
                      exitCode));
               //break;
            }

         } while (false);


         // Set the subnet mask

         DWORD staticipaddress = 
            localNIC->GetIPAddress(0);

         DWORD subnetMask = 
            localNIC->GetSubnetMask(0);

         DWORD subnet = staticipaddress & subnetMask;

         String subnetString = IPAddressToString(subnet);

         commandline = String::format(
                          L"dhcp server 127.0.0.1 add scope %1 %2 Scope1",
                          subnetString.c_str(),
                          subnetMaskString.c_str());

         exitCode = 0;
         hr = CreateAndWaitForProcess(
                 netshPath,
                 commandline, 
                 exitCode, 
                 true);

         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to set DHCP address and subnet: hr = %1!x!",
                   hr));
            break;
         }

         if (exitCode != 1)
         {
            LOG(String::format(
                   L"Failed to create DHCP scope: exitCode = %1!x!",
                   exitCode));
            //break;
         }

         // Set the DHCP scopes

         String start = GetStartIPAddressString(*localNIC);
         String end = GetEndIPAddressString(*localNIC);

         commandline = String::format(
                          L"dhcp server 127.0.0.1 scope %1 add iprange %2 %3 both",
                          subnetString.c_str(),
                          start.c_str(),
                          end.c_str());

         // Set the start and end of the scope in regkeys so that they can 
         // be read after reboot

         if (!SetRegKeyValue(
                 CYS_FIRST_DC_REGKEY,
                 CYS_FIRST_DC_SCOPE_START,
                 start.c_str(),
                 HKEY_LOCAL_MACHINE,
                 true))
         {
            LOG(String::format(
                   L"Failed to set DHCP scope start regkey: hr = %1!x!",
                   hr));
         }

         if (!SetRegKeyValue(
                 CYS_FIRST_DC_REGKEY,
                 CYS_FIRST_DC_SCOPE_END,
                 end.c_str(),
                 HKEY_LOCAL_MACHINE,
                 true))
         {
            LOG(String::format(
                   L"Failed to set DHCP scope end regkey: hr = %1!x!",
                   hr));
         }

         exitCode = 0;
         hr = CreateAndWaitForProcess(
                 netshPath,
                 commandline, 
                 exitCode, 
                 true);

         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to set DHCP scope iprange: hr = %1!x!",
                   hr));
            break;
         }

         if (exitCode != 1)
         {
            LOG(String::format(
                   L"Failed to set DHCP scope iprange: exitCode = %1!x!",
                   exitCode));
            //break;
         }

         // Set an exception for the servers IP address if it falls within 
         // the scope

         if (staticipaddress >= GetStartIPAddress(*localNIC) &&
             staticipaddress <= GetEndIPAddress(*localNIC))
         {
            commandline = String::format(
                             L"dhcp server 127.0.0.1 scope %1 add excluderange %2 %2",
                             subnetString.c_str(),
                             ipaddressString.c_str());

            exitCode = 0;
            hr = CreateAndWaitForProcess(
                    netshPath,
                    commandline, 
                    exitCode, 
                    true);

            if (FAILED(hr))
            {
               LOG(String::format(
                      L"Failed to set server exclusion for DHCP scopes: hr = 0x%1!x!",
                      hr));
               break;
            }

            if (exitCode != 1)
            {
               LOG(String::format(
                      L"Failed to set server exclusion for DHCP scopes: exitCode = 0x%1!x!",
                      exitCode));
               //break;
            }
         }

         // Activate the scope

         commandline = String::format(
                          L"dhcp server 127.0.0.1 scope %1 set state 1",
                          subnetString.c_str());

         exitCode = 0;
         hr = CreateAndWaitForProcess(
                 netshPath,
                 commandline, 
                 exitCode, 
                 true);

         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to activate scope: hr = 0x%1!x!",
                   hr));
         }

         if (exitCode != 1)
         {
            LOG(String::format(
                   L"Failed to activate scope: exitCode = 0x%1!x!",
                   exitCode));
         }

         // Set the DHCP scope lease time

         commandline = L"dhcp server 127.0.0.1 add optiondef 51 \"Lease\" DWORD 0 comment=\"Client IP address lease time in seconds\" 0";

         exitCode = 0;
         hr = CreateAndWaitForProcess(
                 netshPath,
                 commandline, 
                 exitCode, 
                 true);

         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to set DHCP scope lease time: hr = %1!x!",
                   hr));
            break;
         }

         if (exitCode != 1)
         {
            LOG(String::format(
                   L"Failed to set DHCP scope lease time: exitCode = %1!x!",
                   exitCode));
         }

         // Set the DHCP scope lease time value

         commandline = String::format(
                          L"dhcp server 127.0.0.1 scope %1 set optionvalue 51 dword 874800",
                          subnetString.c_str());

         exitCode = 0;
         hr = CreateAndWaitForProcess(
                 netshPath,
                 commandline, 
                 exitCode, 
                 true);

         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to set DHCP scope lease time value: hr = %1!x!",
                   hr));
            break;
         }

         if (exitCode != 1)
         {
            LOG(String::format(
                   L"Failed to set DHCP scope lease time value: exitCode = %1!x!",
                   exitCode));
            //break;
         }

         // Set the default gateway to be handed out to clients.  This will allow 
         // for proper routing 

         if (InstallationUnitProvider::GetInstance().GetRRASInstallationUnit().IsRoutingOn())
         {
            commandline = 
               L"dhcp server 127.0.0.1 add optiondef 3 \"Router\" IPADDRESS "
               L"1 comment=\"Array of router addresses ordered by preference\" 0.0.0.0";

            exitCode = 0;
            hr = CreateAndWaitForProcess(
                    netshPath,
                    commandline, 
                    exitCode, 
                    true);

            // From CEdson - Ignore any failures because it probably just means that 
            // the option already exists in which case we can continue on

            commandline = 
               String::format(
                  L"dhcp server 127.0.0.1 set optionvalue 3 IPADDRESS \"%1\"",
                  ipaddressString.c_str());

            exitCode = 0;
            hr = CreateAndWaitForProcess(
                    netshPath,
                    commandline, 
                    exitCode, 
                    true);

            if (FAILED(hr))
            {
               LOG(String::format(
                      L"Failed to set DHCP default gateway: hr = %1!x!",
                      hr));
               break;
            }

            if (exitCode != 1)
            {
               LOG(String::format(
                      L"Failed to set DHCP default gateway: exitCode = %1!x!",
                      exitCode));
               //break;
            }
         }
      }
   } while (false);

   LOG_INSTALL_RETURN(result);

   return result;
}


void
DHCPInstallationUnit::CreateUnattendFileTextForExpressPath(
   const NetworkInterface& nic,
   String& unattendFileText)
{
   LOG_FUNCTION(DHCPInstallationUnit::CreateUnattendFileTextForExpressPath);

   // The DNS server IP

   DWORD staticipaddress = nic.GetIPAddress(0);

   DWORD subnetMask = nic.GetSubnetMask(0);

   DWORD subnet = staticipaddress & subnetMask;

   String subnetString = IPAddressToString(subnet);

   unattendFileText =  L"[NetOptionalComponents]\r\n";
   unattendFileText += L"DHCPServer=1\r\n";
   unattendFileText += L"[dhcpserver]\r\n";
   unattendFileText += L"Subnets=";
   unattendFileText += subnetString;
   unattendFileText += L"\r\n";

   // Add the DHCP scope

   unattendFileText += L"StartIP=";
   unattendFileText += GetStartIPAddressString(nic);
   unattendFileText += L"\r\n";
   unattendFileText += L"EndIp=";
   unattendFileText += GetEndIPAddressString(nic);
   unattendFileText += L"\r\n";

   // Add subnet mask

   String subnetMaskString = nic.GetStringSubnetMask(0);

   unattendFileText += L"SubnetMask=";
   unattendFileText += subnetMaskString;
   unattendFileText += L"\r\n";
   unattendFileText += L"LeaseDuration=874800\r\n";

   unattendFileText += String::format(
                          L"DnsServer=%1\r\n",
                          IPAddressToString(staticipaddress).c_str());

   // The domain name

   unattendFileText += String::format(
                          L"DomainName=%1\r\n",
                          InstallationUnitProvider::GetInstance().GetADInstallationUnit().GetNewDomainDNSName().c_str());

}

bool
DHCPInstallationUnit::GetMilestoneText(String& message)
{
   LOG_FUNCTION(DHCPInstallationUnit::GetMilestoneText);

   if (IsExpressPathInstall())
   {

   }
   else
   {
      message = String::load(IDS_DHCP_FINISH_TEXT);
   }

   LOG_BOOL(true);
   return true;
}

bool
DHCPInstallationUnit::GetUninstallMilestoneText(String& message)
{
   LOG_FUNCTION(DHCPInstallationUnit::GetUninstallMilestoneText);

   message = String::load(IDS_DHCP_UNINSTALL_TEXT);

   LOG_BOOL(true);
   return true;
}

bool
DHCPInstallationUnit::AuthorizeDHCPServer(const String& dnsName) const
{
   LOG_FUNCTION(DHCPInstallationUnit::AuthorizeDHCPServer);

   bool result = true;

   do
   {
      // Read the local NIC GUID from the registry

      NetworkInterface* localNIC = 
         State::GetInstance().GetLocalNICFromRegistry();

      if (!localNIC)
      {
         LOG(L"Failed to get the local NIC from registry");

         result = false;
         break;
      }

      // Authorize the DHCP scope

      String commandline;
      commandline = L"dhcp add server ";
      commandline += dnsName;
      commandline += L" ";
      commandline += localNIC->GetStringIPAddress(0);

      DWORD exitCode = 0;
      HRESULT hr = 
         CreateAndWaitForProcess(
            GetNetshPath(),
            commandline, 
            exitCode, 
            true);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to run DHCP authorization: hr = %1!x!",
                hr));
         result = false;
         break;
      }

      // Success code appears to be 0 for this one

      if (exitCode != 0)
      {
         result = false;
         break;
      }
   } while (false);

   LOG_BOOL(result);

   return result;
}



void
DHCPInstallationUnit::SetStartIPAddress(DWORD ipaddress)
{
   LOG_FUNCTION2(
      DHCPInstallationUnit::SetStartIPAddress,
      String::format(L"0x%1!x!", ipaddress));

   startIPAddress = ipaddress;

   // Scope is being set manually so lets not try to calculate it

   scopeCalculated = true;
}

void
DHCPInstallationUnit::SetEndIPAddress(DWORD ipaddress)
{
   LOG_FUNCTION2(
      DHCPInstallationUnit::SetEndIPAddress,
      String::format(L"0x%1!x!", ipaddress));

   endIPAddress = ipaddress;

   // Scope is being set manually so lets not try to calculate it

   scopeCalculated = true;
}

String
DHCPInstallationUnit::GetStartIPAddressString(const NetworkInterface& nic)
{
   LOG_FUNCTION(DHCPInstallationUnit::GetStartIPAddressString);

   CalculateScope(nic);

   String result = IPAddressToString(startIPAddress);

   LOG(result);
   return result;
}

String
DHCPInstallationUnit::GetEndIPAddressString(const NetworkInterface& nic)
{
   LOG_FUNCTION(DHCPInstallationUnit::GetEndIPAddressString);

   CalculateScope(nic);

   String result = IPAddressToString(endIPAddress);

   LOG(result);
   return result;
}

DWORD
DHCPInstallationUnit::GetStartIPAddress(const NetworkInterface& nic)
{
   LOG_FUNCTION(DHCPInstallationUnit::GetStartIPAddress);

   CalculateScope(nic);

   return startIPAddress;
}

DWORD
DHCPInstallationUnit::GetEndIPAddress(const NetworkInterface& nic)
{
   LOG_FUNCTION(DHCPInstallationUnit::GetEndIPAddress);

   CalculateScope(nic);

   return endIPAddress;
}

void
DHCPInstallationUnit::CalculateScope(const NetworkInterface& nic)
{
   LOG_FUNCTION(DHCPInstallationUnit::CalculateScope);

   if (!scopeCalculated)
   {
      DWORD staticIPAddress = nic.GetIPAddress(0);

      DWORD subnetMask = nic.GetSubnetMask(0);

      // We are allowing a buffer of 10 addresses that are not part of the scope
      // in case the user wants to add other machines (computers, routers, etc)
      // with static IP addresses

      startIPAddress = (subnetMask & staticIPAddress);
      endIPAddress = (subnetMask & staticIPAddress) | (~(subnetMask) - 1);

      if (startIPAddress + 10 < endIPAddress)
      {
         startIPAddress = startIPAddress + 10;
      }
      scopeCalculated = true;
   }

   LOG(String::format(
          L"Start: %1",
          IPAddressToString(startIPAddress).c_str()));

   LOG(String::format(
          L"End: %1",
          IPAddressToString(endIPAddress).c_str()));
}

String
DHCPInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(DHCPInstallationUnit::GetServiceDescription);

   String result;

   unsigned int resultID = descriptionID;

   if (GetStatus() == STATUS_COMPLETED)
   {
      resultID = installedDescriptionID;
   }

   result = String::load(resultID);

   ASSERT(!result.empty());

   return result;
}

void
DHCPInstallationUnit::ServerRoleLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      DHCPInstallationUnit::ServerRoleLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (IsServiceInstalled())
   {
      ASSERT(linkIndex == 0);

      LaunchMYS();
   }
   else
   {
      ASSERT(linkIndex == 0);

      LOG(L"Showing configuration help");

      ShowHelp(CYS_DHCP_FINISH_PAGE_HELP);
   }
}
  
void
DHCPInstallationUnit::FinishLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      DHCPInstallationUnit::FinishLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (installing)
   {
      if (linkIndex == 0 &&
          IsServiceInstalled())
      {
         // Installation was successful. Check to see
         // if there was a failure in configuration

         if (dhcpRoleResult == DHCP_CONFIG_FAILURE)
         {
            // Since there was a config failure just
            // point them to the snapin

            LOG(L"Launching DHCP snapin");

            LaunchMMCConsole(L"dhcpmgmt.msc");
         }
         else
         {
            // Offer the next steps document

            LOG("Showing after checklist");

            ShowHelp(CYS_DHCP_AFTER_FINISH_HELP);
         }
      }
      else if (linkIndex == 0)
      {
         // There was a failure

         LOG(L"Showing configuration help");

         ShowHelp(CYS_DHCP_FINISH_PAGE_HELP);
      }
   }
}

String
DHCPInstallationUnit::GetFinishText()
{
   LOG_FUNCTION(DHCPInstallationUnit::GetFinishText);

   unsigned int messageID = finishMessageID;

   if (installing)
   {
      InstallationReturnType result = GetInstallResult();
      if (result != INSTALL_SUCCESS &&
          result != INSTALL_SUCCESS_REBOOT &&
          result != INSTALL_SUCCESS_PROMPT_REBOOT)
      {
         if (dhcpRoleResult == DHCP_INSTALL_FAILURE)
         {
            messageID = finishInstallFailedMessageID;
         }
         else
         {
            messageID = IDS_DHCP_CONFIG_FAILED;
         }
      }
   }
   else
   {
      messageID = finishUninstallMessageID;

      UnInstallReturnType result = GetUnInstallResult();
      if (result != UNINSTALL_SUCCESS &&
          result != UNINSTALL_SUCCESS_REBOOT &&
          result != UNINSTALL_SUCCESS_PROMPT_REBOOT)
      {
         messageID = finishUninstallFailedMessageID;
      }
   }

   return String::load(messageID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\disconnectednicdialog.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      DisconnectedNICDialog.h
//
// Synopsis:  Declares the DisconnectedNICDialog class
//            which presents the user with options
//            to cancel or continue when disconnected
//            NICs are detected
//
// History:   09/27/2001  JeffJon Created

#ifndef __CYS_DISCONNECTEDNICDIALOG_H
#define __CYS_DISCONNECTEDNICDIALOG_H


class DisconnectedNICDialog : public Dialog
{
   public:

      // constructor 

      DisconnectedNICDialog();

      virtual
      void
      OnInit();

   protected:

      virtual
      bool
      OnCommand(
         HWND        windowFrom,
         unsigned    controlIdFrom,
         unsigned    code);

   private:

      // not defined: no copying allowed
      DisconnectedNICDialog(const DisconnectedNICDialog&);
      const DisconnectedNICDialog& operator=(const DisconnectedNICDialog&);
};



#endif // __CYS_DISCONNECTEDNICDIALOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\disconnectednicdialog.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      DisconnectedNICDialog.cpp
//
// Synopsis:  Defines the DisconnectedNICDialog class
//            which presents the user with options
//            to cancel or continue when disconnected
//            NICs are detected
//
// History:   09/27/2001  JeffJon Created


#include "pch.h"

#include "resource.h"
#include "DisconnectedNICDialog.h"

DWORD disconnectedNICDialogHelpMap[] =
{
   0, 0
};

DisconnectedNICDialog::DisconnectedNICDialog()
   : Dialog(IDD_DISCONNECTED_NIC_DIALOG, disconnectedNICDialogHelpMap)
{
   LOG_CTOR(DisconnectedNICDialog);
}

void
DisconnectedNICDialog::OnInit()
{
   LOG_FUNCTION(DisconnectedNICDialog::OnInit);

   Win::SetDlgItemText(
      hwnd,
      IDC_CAPTION_STATIC,
      String::load(IDS_DISCONNECT_NIC_STATIC_TEXT));
}

bool
DisconnectedNICDialog::OnCommand(
   HWND        /*windowFrom*/,
   unsigned    controlIdFrom,
   unsigned    code)
{
//   LOG_FUNCTION(DisconnectedNICDialog::OnCommand);

   bool result = false;

   if (BN_CLICKED == code)
   {
      Win::EndDialog(hwnd, controlIdFrom);
      result = true;
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\dnsforwarderpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      DomainPage.cpp
//
// Synopsis:  Defines the DNS forwarder page used in the 
//            Express path for the CYS Wizard
//
// History:   05/17/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "DnsForwarderPage.h"

static PCWSTR FORWARDER_PAGE_HELP = L"cys.chm::/typical_setup.htm#typicaldnsforwarder";

DNSForwarderPage::DNSForwarderPage()
   :
   CYSWizardPage(
      IDD_DNS_FORWARDER_PAGE, 
      IDS_DNS_FORWARDER_TITLE, 
      IDS_DNS_FORWARDER_SUBTITLE,
      FORWARDER_PAGE_HELP)
{
   LOG_CTOR(DNSForwarderPage);
}

   

DNSForwarderPage::~DNSForwarderPage()
{
   LOG_DTOR(DNSForwarderPage);
}


void
DNSForwarderPage::OnInit()
{
   LOG_FUNCTION(DNSForwarderPage::OnInit);

   CYSWizardPage::OnInit();

   Win::SetDlgItemText(
      hwnd,
      IDC_TOO_LONG_STATIC,
      IDS_FORWARDER_STATIC_TEXT);

   // Set the Yes radio by default

   Win::Button_SetCheck(
      Win::GetDlgItem(hwnd, IDC_YES_RADIO),
      BST_CHECKED);

   Win::Button_SetCheck(
      Win::GetDlgItem(hwnd, IDC_NO_RADIO),
      BST_UNCHECKED);
}

void
DNSForwarderPage::SetWizardButtons()
{
//   LOG_FUNCTION(DNSForwarderPage::SetWizardButtons);

   // NTRAID#NTBUG9-461109-2001/08/28-sburns

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   // NTRAID#NTBUG9-503691-2001/12/06-JeffJon
   // The Next button should only be enabled if the user
   // chose the No radio button or they have entered
   // an IP and chose the Yes radio button

   bool yesChecked = Win::Button_GetCheck(
                        Win::GetDlgItem(hwnd, IDC_YES_RADIO));

   if (yesChecked)
   {
      // Get the IP address from the control

      DWORD forwarder = 0;
      LRESULT forwarderResult = Win::SendMessage(
                                   Win::GetDlgItem(hwnd, IDC_FORWARDER_IPADDRESS),
                                   IPM_GETADDRESS,
                                   0,
                                   (LPARAM)&forwarder);
      
      if (!forwarderResult || forwarder == 0)
      {
         // User hasn't entered an IP address so disable the Next button

         Win::PropSheet_SetWizButtons(
            Win::GetParent(hwnd), 
            PSWIZB_BACK);
      }
   }
}

bool
DNSForwarderPage::OnSetActive()
{
   LOG_FUNCTION(DNSForwarderPage::OnSetActive);

   SetWizardButtons();

   return true;
}

bool
DNSForwarderPage::OnNotify(
   HWND        /*windowFrom*/,
   UINT_PTR    controlIDFrom,
   UINT        code,
   LPARAM      /*lParam*/)
{
//   LOG_FUNCTION(DNSForwarderPage::OnCommand);

   bool result = false;

   if (controlIDFrom == IDC_FORWARDER_IPADDRESS &&
       code == IPN_FIELDCHANGED)
   {
      SetWizardButtons();
   }
   return result;
}

bool
DNSForwarderPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(DNSForwarderPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_YES_RADIO:
         if (code == BN_CLICKED)
         {
            Win::EnableWindow(
               Win::GetDlgItem(hwnd, IDC_FORWARDER_IPADDRESS),
               true);

            SetWizardButtons();
         }
         break;

      case IDC_NO_RADIO:
         if (code == BN_CLICKED)
         {
            Win::EnableWindow(
               Win::GetDlgItem(hwnd, IDC_FORWARDER_IPADDRESS),
               false);

            SetWizardButtons();
         }
         break;

      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}


int
DNSForwarderPage::Validate()
{
   LOG_FUNCTION(DNSForwarderPage::Validate);

   int nextPage = IDD_MILESTONE_PAGE;

   if (Win::Button_GetCheck(
          Win::GetDlgItem(hwnd, IDC_YES_RADIO)))
   {
      // Get the IP address from the control

      LOG(L"User chose to forward queries");

      DWORD forwarder = 0;
      LRESULT forwarderResult = Win::SendMessage(
                                   Win::GetDlgItem(hwnd, IDC_FORWARDER_IPADDRESS),
                                   IPM_GETADDRESS,
                                   0,
                                   (LPARAM)&forwarder);
      
      if (!forwarderResult || forwarder == 0)
      {
         LOG(L"User didn't enter IP address so we will gripe at them");

         String message = String::load(IDS_FORWARDER_IPADDRESS_REQUIRED);
         popup.Gripe(hwnd, IDC_FORWARDER_IPADDRESS, message);
         nextPage = -1;
      }
      else
      {
         DWORD networkOrderForwarder = ConvertIPAddressOrder(forwarder);

         LOG(String::format(
                L"Setting new forwarder: 0x%1!x!",
                networkOrderForwarder));

         InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().SetForwarder(
            networkOrderForwarder);
      }
   }
   else
   {
      // Set an empty value so that we know it was set manually but they chose
      // not to forward

      LOG(L"User chose not to forward queries");

      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().SetForwarder(0);
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\dnsforwarderpage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      DnsForwarderPage.h
//
// Synopsis:  Declares the DNS forwarder page used in the 
//            Express path for the CYS Wizard
//
// History:   05/17/2001  JeffJon Created

#ifndef __CYS_DNSFORWARDERPAGE_H
#define __CYS_DNSFORWARDERPAGE_H

#include "CYSWizardPage.h"


class DNSForwarderPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      DNSForwarderPage();

      // Destructor

      virtual 
      ~DNSForwarderPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

      virtual
      bool
      OnCommand(
         HWND        windowFrom,
         unsigned    controlIDFrom,
         unsigned    code);

      virtual
      bool
      OnNotify(
         HWND        windowFrom,
         UINT_PTR    controlIDFrom,
         UINT        code,
         LPARAM      lParam);

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      void 
      SetWizardButtons();

      // not defined: no copying allowed
      DNSForwarderPage(const DNSForwarderPage&);
      const DNSForwarderPage& operator=(const DNSForwarderPage&);

};

#endif // __CYS_DNSFORWARDERPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\dnsinstallationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      DNSInstallationUnit.cpp
//
// Synopsis:  Defines a DNSInstallationUnit
//            This object has the knowledge for installing the
//            DNS service
//
// History:   02/05/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "DNSInstallationUnit.h"
#include "InstallationUnitProvider.h"
#include "NetworkInterface.h"

// Finish page help 
static PCWSTR CYS_DNS_FINISH_PAGE_HELP = L"cys.chm::/dns_server_role.htm";
static PCWSTR CYS_DNS_MILESTONE_HELP = L"cys.chm::/dns_server_role.htm#dnssrvsummary";
static PCWSTR CYS_DNS_AFTER_FINISH_HELP = L"cys.chm::/dns_server_role.htm#dnssrvcompletion";

DNSInstallationUnit::DNSInstallationUnit() :
   staticIPAddress(CYS_DEFAULT_IPADDRESS),
   subnetMask(CYS_DEFAULT_SUBNETMASK),
   forwarderIPAddress(0),
   manualForwarder(false),
   dnsRoleResult(DNS_SUCCESS),
   installedDescriptionID(IDS_DNS_SERVER_DESCRIPTION_INSTALLED),
   ExpressPathInstallationUnitBase(
      IDS_DNS_SERVER_TYPE, 
      IDS_DNS_SERVER_DESCRIPTION, 
      IDS_DNS_FINISH_TITLE,
      IDS_DNS_FINISH_UNINSTALL_TITLE,
      IDS_DNS_FINISH_MESSAGE,
      IDS_DNS_INSTALL_FAILED,
      IDS_DNS_UNINSTALL_MESSAGE,
      IDS_DNS_UNINSTALL_FAILED,
      IDS_DNS_UNINSTALL_WARNING,
      IDS_DNS_UNINSTALL_CHECKBOX,
      CYS_DNS_FINISH_PAGE_HELP,
      CYS_DNS_MILESTONE_HELP,
      CYS_DNS_AFTER_FINISH_HELP,
      DNS_SERVER)
{
   LOG_CTOR(DNSInstallationUnit);
}


DNSInstallationUnit::~DNSInstallationUnit()
{
   LOG_DTOR(DNSInstallationUnit);
}


InstallationReturnType
DNSInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(DNSInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   if (IsExpressPathInstall())
   {
      result = ExpressPathInstall(logfileHandle, hwnd);

      LOG_INSTALL_RETURN(result);
      return result;
   }

   dnsRoleResult = DNS_SUCCESS;

   // Log the DNS header

   CYS_APPEND_LOG(String::load(IDS_LOG_DNS_HEADER));

   UpdateInstallationProgressText(hwnd, IDS_DNS_INSTALL_PROGRESS);

   // Create the inf and unattend files that are used by the 
   // Optional Component Manager

   String infFileText;
   String unattendFileText;

   CreateInfFileText(infFileText, IDS_DNS_INF_WINDOW_TITLE);
   CreateUnattendFileText(unattendFileText, CYS_DNS_SERVICE_NAME);

   // Install the service through the Optional Component Manager

   String additionalArgs = L"/z:netoc_show_unattended_messages";

   // We are ignoring the ocmresult because it doesn't matter
   // with respect to whether the role is installed or not

   InstallServiceWithOcManager(
      infFileText, 
      unattendFileText,
      additionalArgs);

   if (IsServiceInstalled())
   {
      // Log the successful installation

      LOG(L"DNS was installed successfully");
      CYS_APPEND_LOG(String::load(IDS_LOG_SERVER_START_DNS));

      // Wait for the service to enter the running state

      NTService serviceObject(CYS_DNS_SERVICE_NAME);

      HRESULT hr = serviceObject.WaitForServiceState(SERVICE_RUNNING);
      if (FAILED(hr))
      {
         // This is a config failure because as far as we are concerned the
         // service was installed properly.

         dnsRoleResult = DNS_SERVICE_START_FAILURE;

         LOG(String::format(
               L"The DNS service failed to start in a timely fashion: %1!x!",
               hr));

         CYS_APPEND_LOG(String::load(IDS_LOG_DNS_SERVICE_TIMEOUT));
         result = INSTALL_FAILURE;
      }
      else
      {
         // Run the DNS Wizard
         
         UpdateInstallationProgressText(hwnd, IDS_DNS_CONFIG_PROGRESS);

         String resultText;
         HRESULT unused = S_OK;

         if (ExecuteWizard(hwnd, CYS_DNS_SERVICE_NAME, resultText, unused))
         {
            // Check to be sure the wizard finished completely

            String configWizardResults;

            if (ReadConfigWizardRegkeys(configWizardResults))
            {
               // The Configure DNS Server Wizard completed successfully
               
               LOG(L"The Configure DNS Server Wizard completed successfully");
               CYS_APPEND_LOG(String::load(IDS_LOG_DNS_COMPLETED_SUCCESSFULLY));
            }
            else
            {
               // The Configure DNS Server Wizard did not finish successfully

               dnsRoleResult = DNS_CONFIG_FAILURE;

               result = INSTALL_FAILURE;

               if (!configWizardResults.empty())
               {
                  // An error was returned via the regkey

                  LOG(String::format(
                     L"The Configure DNS Server Wizard returned the error: %1", 
                     configWizardResults.c_str()));

                  String formatString = String::load(IDS_LOG_DNS_WIZARD_ERROR);
                  CYS_APPEND_LOG(String::format(formatString, configWizardResults.c_str()));

               }
               else
               {
                  // The Configure DNS Server Wizard was cancelled by the user

                  LOG(L"The Configure DNS Server Wizard was cancelled by the user");

                  CYS_APPEND_LOG(String::load(IDS_LOG_DNS_WIZARD_CANCELLED));

               }
            }
         }
         else
         {
            dnsRoleResult = DNS_INSTALL_FAILURE;

            // Show an error

            LOG(L"DNS could not be installed.");

            if (!resultText.empty())
            {
               CYS_APPEND_LOG(resultText);
            }
         }
      }
   }
   else
   {
      dnsRoleResult = DNS_INSTALL_FAILURE;

      // Log the failure

      LOG(L"DNS failed to install");

      CYS_APPEND_LOG(String::load(IDS_LOG_DNS_SERVER_FAILED));

      result = INSTALL_FAILURE;
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

UnInstallReturnType
DNSInstallationUnit::UnInstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(DNSInstallationUnit::UnInstallService);

   UnInstallReturnType result = UNINSTALL_SUCCESS;

   // Log the DNS header

   CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_DNS_HEADER));

   UpdateInstallationProgressText(hwnd, IDS_DNS_UNINSTALL_PROGRESS);

   String infFileText;
   String unattendFileText;

   CreateInfFileText(infFileText, IDS_DNS_INF_WINDOW_TITLE);
   CreateUnattendFileText(unattendFileText, CYS_DNS_SERVICE_NAME, false);

   // NTRAID#NTBUG9-736557-2002/11/13-JeffJon
   // Pass the /w switch to sysocmgr when uninstalling
   // so that if a situation occurs in which a reboot
   // is required, the user will be prompted.

   String additionalArgs = L"/w";

   // We are ignoring the ocmresult because it doesn't matter
   // with respect to whether the role is installed or not

   InstallServiceWithOcManager(
      infFileText, 
      unattendFileText,
      additionalArgs);
   
   if (IsServiceInstalled())
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_DNS_FAILED));

      result = UNINSTALL_FAILURE;
   }
   else
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_DNS_SUCCESS));
   }

   LOG_UNINSTALL_RETURN(result);

   return result;
}

void
DNSInstallationUnit::SetForwardersForExpressPath()
{
   LOG_FUNCTION(DNSInstallationUnit::SetForwardersForExpressPath);

   // If the forwarders were set manually write them
   // to the registry so that we can set
   // a forwarder after the reboot
   // Note: this will write a zero entry if the user
   //       chose not to forward.  The code run after reboot
   //       needs to handle this properly

   if (IsManualForwarder())
   {
      if (!SetRegKeyValue(
               CYS_FIRST_DC_REGKEY,
               CYS_FIRST_DC_FORWARDER,
               forwarderIPAddress,
               HKEY_LOCAL_MACHINE,
               true))
      {
         LOG(L"Failed to set forwarder regkey");
      }
   }
   else
   {
      // Write the current DNS servers as forwarders to the registry
      // so that we don't have problems after the reboot

      IPAddressList forwarders;
      GetForwarders(forwarders);

      if (forwarders.empty())
      {
         LOG(L"No DNS servers set on any NIC");
      }
      else
      {
         // Format the IP addresses into a string for storage
         // in the registry
      
         String ipList;
         for (IPAddressList::iterator itr = forwarders.begin();
            itr != forwarders.end();
            ++itr)
         {
            if (!ipList.empty())
            {
               ipList += L" ";
            }

            ipList += String::format(
                        L"%1", 
                        IPAddressToString(*itr).c_str()); 
         }
         
         if (!SetRegKeyValue(
               CYS_FIRST_DC_REGKEY,
               CYS_FIRST_DC_AUTOFORWARDER,
               ipList,
               HKEY_LOCAL_MACHINE,
               true))
         {
            LOG(L"We failed to set the forwarders regkey.");
         }
      }
   }

}

InstallationReturnType
DNSInstallationUnit::ExpressPathInstall(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(DNSInstallationUnit::ExpressPathInstall);

   InstallationReturnType result = INSTALL_SUCCESS;

   do
   {
      String netshPath = GetNetshPath();

      String commandLine;
      HRESULT hr = S_OK;

      UpdateInstallationProgressText(hwnd, IDS_DNS_CLIENT_CONFIG_PROGRESS);

      // We ignore if the NIC is found or not because the function will return
      // the first NIC if the correct NIC is not found.  We can then use this
      // to setup the network

      NetworkInterface* nic = State::GetInstance().GetLocalNIC();

      if (!nic)
      {
         LOG(L"Couldn't find the NIC so fail");

         result = INSTALL_FAILURE;

         CYS_APPEND_LOG(
            String::load(IDS_EXPRESS_DNS_LOG_STATIC_IP_FAILED));

         InstallationUnitProvider::GetInstance().
            GetExpressInstallationUnit().SetExpressRoleResult(
               ExpressInstallationUnit::EXPRESS_DNS_FAILURE);
        break;
      }

      // set static IP address and subnet mask

      String friendlyName = 
         nic->GetFriendlyName(
            String::load(IDS_LOCAL_AREA_CONNECTION));

      if (nic->IsDHCPEnabled() ||
          nic->GetIPAddress(0) == 0)
      {
         // invoke netsh and wait for it to terminate

         String availableIPAddress = IPAddressToString(
                                        nic->GetNextAvailableIPAddress(
                                           CYS_DEFAULT_IPADDRESS,
                                           CYS_DEFAULT_SUBNETMASK));

         commandLine =
            String::format(
               L"interface ip set address "
               L"name=\"%1\" source=static addr=%2 mask=%3 gateway=none",
               friendlyName.c_str(),
               availableIPAddress.c_str(),
               CYS_DEFAULT_SUBNETMASK_STRING);

         DWORD exitCode1 = 0;
         hr = ::CreateAndWaitForProcess(
                 netshPath,
                 commandLine, 
                 exitCode1, 
                 true);

         if (FAILED(hr) || exitCode1)
         {
            LOG(String::format(
                   L"Failed to set the static IP address and subnet mask: exitCode = %1!x!",
                   exitCode1));
            result = INSTALL_FAILURE;

            CYS_APPEND_LOG(
               String::load(IDS_EXPRESS_DNS_LOG_STATIC_IP_FAILED));

            InstallationUnitProvider::GetInstance().
               GetExpressInstallationUnit().SetExpressRoleResult(
                  ExpressInstallationUnit::EXPRESS_DNS_FAILURE);

            break;
         }
         ASSERT(SUCCEEDED(hr));

         // NTRAID#NTBUG9-638337-2002/06/13-JeffJon
         // Now that the IP address was set, write it to a regkey so
         // that we can compare it to the IP address on reboot and
         // give a failure if they are different.

         if (!SetRegKeyValue(
                 CYS_FIRST_DC_REGKEY,
                 CYS_FIRST_DC_STATIC_IP,
                 availableIPAddress,
                 HKEY_LOCAL_MACHINE,
                 true))
         {
            LOG(L"Failed to set the static IP regkey");
         }

         CYS_APPEND_LOG(
            String::format(
               IDS_EXPRESS_IPADDRESS_SUCCESS,
               availableIPAddress.c_str()));

         CYS_APPEND_LOG(
            String::format(
               IDS_EXPRESS_SUBNETMASK_SUCCESS,
               CYS_DEFAULT_SUBNETMASK_STRING));

         // Set the IP address and subnet mask on the NetworkInterface object

         nic->SetIPAddress(
            StringToIPAddress(availableIPAddress), 
            availableIPAddress);

         nic->SetSubnetMask(
            CYS_DEFAULT_SUBNETMASK, 
            CYS_DEFAULT_SUBNETMASK_STRING);
      }   

      // NTRAID#NTBUG9-664171-2002/07/15-JeffJon
      // The forwarders must be read and set after setting the static
      // IP address or else we may be adding multiple entries for
      // the new static IP address in the forwarders list

      SetForwardersForExpressPath();

      // set DNS server address to same address as the private NIC of
      // local machine for all NICs. In most cases this will be 192.168.0.1
      // netsh does not allow the dns server address to be the loopback address.

      for (unsigned int nicIndex = 0; 
           nicIndex < State::GetInstance().GetNICCount(); 
           ++nicIndex)
      {
         NetworkInterface* currentNIC = State::GetInstance().GetNIC(nicIndex);

         if (!currentNIC)
         {
            continue;
         }

         // First check to be sure the IP address isn't already in the list

         bool okToAddDNSServer = true;

         IPAddressList dnsServers;
         currentNIC->GetDNSServers(dnsServers);

         for (IPAddressList::iterator itr = dnsServers.begin();
              itr != dnsServers.end();
              ++itr)
         {
            if (itr &&
                *itr == nic->GetIPAddress(0))
            {
               okToAddDNSServer = false;

               break;
            }
         }

         // Add the IP address to the DNS servers since it
         // isn't already in the list

         if (okToAddDNSServer)
         {
            String currentFriendlyName = 
               currentNIC->GetFriendlyName(
                  String::load(IDS_LOCAL_AREA_CONNECTION));

            commandLine =
               String::format(
                  L"interface ip set dns name=\"%1\" source=static addr=%2",
                  currentFriendlyName.c_str(),
                  nic->GetStringIPAddress(0).c_str());

            DWORD exitCode2 = 0;
            hr = ::CreateAndWaitForProcess(
                  netshPath,
                  commandLine, 
                  exitCode2, 
                  true);

            if (FAILED(hr) || exitCode2)
            {
               LOG(String::format(
                     L"Failed to set the preferred DNS server IP address: exitCode = %1!x!",
                     exitCode2));

               // This should really only be considered a failure for the "local" NIC

               if (currentFriendlyName.icompare(friendlyName) == 0)
               {
                  result = INSTALL_FAILURE;

                  InstallationUnitProvider::GetInstance().
                     GetExpressInstallationUnit().SetExpressRoleResult(
                        ExpressInstallationUnit::EXPRESS_DNS_FAILURE);
                  break;
               }
            }
         }
      }

      if (result != INSTALL_FAILURE)
      {
         CYS_APPEND_LOG(
            String::format(
               IDS_EXPRESS_DNSSERVER_SUCCESS,
               nic->GetStringIPAddress(0).c_str()));
      }

   } while (false);

   LOG_INSTALL_RETURN(result);

   return result;
}

bool
DNSInstallationUnit::ReadConfigWizardRegkeys(String& configWizardResults) const
{
   LOG_FUNCTION(DNSInstallationUnit::ReadConfigWizardRegkeys);

   bool result = false;

   do 
   {
      DWORD value = 0;
      result = GetRegKeyValue(
                  DNS_WIZARD_CONFIG_REGKEY, 
                  DNS_WIZARD_CONFIG_VALUE, 
                  value);

      if (result &&
          value != 0)
      {
         // The Configure DNS Server Wizard succeeded

         result = true;
         break;
      }

      // Since there was a failure (or the wizard was cancelled)
      // get the display string to log

      GetRegKeyValue(
         DNS_WIZARD_RESULT_REGKEY, 
         DNS_WIZARD_RESULT_VALUE, 
         configWizardResults);

   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
DNSInstallationUnit::GetMilestoneText(String& message)
{
   LOG_FUNCTION(DNSInstallationUnit::GetMilestoneText);

   message = String::load(IDS_DNS_FINISH_TEXT);

   LOG_BOOL(true);
   return true;
}

bool
DNSInstallationUnit::GetUninstallMilestoneText(String& message)
{
   LOG_FUNCTION(DNSInstallationUnit::GetUninstallMilestoneText);

   message = String::load(IDS_DNS_UNINSTALL_TEXT);

   LOG_BOOL(true);
   return true;
}

String
DNSInstallationUnit::GetUninstallWarningText()
{
   LOG_FUNCTION(DNSInstallationUnit::GetUninstallWarningText);

   unsigned int messageID = uninstallMilestoneWarningID;

   if (State::GetInstance().IsDC())
   {
      messageID = IDS_DNS_UNINSTALL_WARNING_ISDC;
   }

   return String::load(messageID);
}

void
DNSInstallationUnit::SetStaticIPAddress(DWORD ipaddress)
{
   LOG_FUNCTION2(
      DNSInstallationUnit::SetStaticIPAddress,
      IPAddressToString(ipaddress).c_str());

   staticIPAddress = ipaddress;
}

void
DNSInstallationUnit::SetSubnetMask(DWORD mask)
{
   LOG_FUNCTION2(
      DNSInstallationUnit::SetSubnetMask,
      IPAddressToString(mask).c_str());

   subnetMask = mask;
}

String
DNSInstallationUnit::GetStaticIPAddressString()
{
   LOG_FUNCTION(DNSInstallationUnit::GetStaticIPAddressString);

   String result = IPAddressToString(GetStaticIPAddress());

   LOG(result);
   return result;
}


String
DNSInstallationUnit::GetSubnetMaskString()
{
   LOG_FUNCTION(DNSInstallationUnit::GetSubnetMaskString);

   String result = IPAddressToString(GetSubnetMask());

   LOG(result);
   return result;
}

DWORD
DNSInstallationUnit::GetStaticIPAddress()
{
   LOG_FUNCTION(DNSInstallationUnit::GetStaticIPAddress);

   // Get the IP address from the NIC only if it
   // is a static IP address else use the default

   NetworkInterface* nic = State::GetInstance().GetNIC(0);
   if (nic &&
       !nic->IsDHCPEnabled())
   {
      staticIPAddress = nic->GetIPAddress(0);
   }

   return staticIPAddress;
}

DWORD
DNSInstallationUnit::GetSubnetMask()
{
   LOG_FUNCTION(DNSInstallationUnit::GetSubnetMask);

   // Get the subnet mask from the NIC only if it 
   // is a static IP address else use the default

   NetworkInterface* nic = State::GetInstance().GetNIC(0);
   if (nic &&
       !nic->IsDHCPEnabled())
   {
      subnetMask = nic->GetSubnetMask(0);
   }

   return subnetMask;
}

void
DNSInstallationUnit::SetForwarder(DWORD forwarderAddress)
{
   LOG_FUNCTION2(
      DNSInstallationUnit::SetForwarder,
      String::format(L"%1!x!", forwarderAddress));

   forwarderIPAddress = forwarderAddress;
   manualForwarder = true;
}

void
DNSInstallationUnit::GetForwarders(IPAddressList& forwarders) const
{
   LOG_FUNCTION(DNSInstallationUnit::GetForwarders);

   // clear out the list to start

   forwarders.clear();

   if (IsManualForwarder() &&
       forwarderIPAddress != 0)
   {
      DWORD forwarderInDisplayOrder = ConvertIPAddressOrder(forwarderIPAddress);

      LOG(
         String::format(
            L"Adding manual forwarder to list: %1",
            IPAddressToString(forwarderInDisplayOrder).c_str()));

      // Forwarder was assigned through the UI

      forwarders.push_back(forwarderIPAddress);
   }
   else if (IsManualForwarder() &&
            forwarderIPAddress == 0)
   {
      // The user chose not to forward

      LOG(L"User chose not to foward");

      // Do nothing. Need to check the list returned
      // to make sure there is a valid address
   }
   else
   {
      LOG(L"No user defined forwarder. Trying to detect through NICs");

      // No forwarder assigned through the UI so 
      // search the NICs

      for (unsigned int idx = 0; idx < State::GetInstance().GetNICCount(); ++idx)
      {
         NetworkInterface* nic = State::GetInstance().GetNIC(idx);

         // Add the DNS servers from this NIC

         if (nic)
         {
            nic->GetDNSServers(forwarders);
         }
      }

      // Make sure there are no forwarders that are the same as
      // the IP addresses of any of the NICs

      for (unsigned int idx = 0; idx < State::GetInstance().GetNICCount(); ++idx)
      {
         NetworkInterface* nic = State::GetInstance().GetNIC(idx);

         if (!nic)
         {
            continue;
         }

         for (DWORD ipidx = 0; ipidx < nic->GetIPAddressCount(); ++ipidx)
         {
            DWORD ipaddress = nic->GetIPAddress(ipidx);

            for (IPAddressList::iterator itr = forwarders.begin();
                 itr != forwarders.end();
                 ++itr)
            {
               if (ipaddress == *itr)
               {
                  // The forwarder matches a local IP address
                  // so remove it

                  LOG(String::format(
                         L"Can't put the local IP address in the forwarders list: %1",
                         IPAddressToString(*itr).c_str()));

                  forwarders.erase(itr);

                  break;
               }
            }

            if (forwarders.empty())
            {
               // It's possible that we removed the last forwarder
               // so break out if we did

               break;
            }
         }

         if (forwarders.empty())
         {
            // It's possible that we removed the last forwarder
            // so break out if we did

            break;
         }
      }
   }
}

bool
DNSInstallationUnit::IsManualForwarder() const
{
   LOG_FUNCTION(DNSInstallationUnit::IsManualForwarder);

   LOG_BOOL(manualForwarder);
   return manualForwarder;
}

String
DNSInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(DNSInstallationUnit::GetServiceDescription);

   String result;

   unsigned int resultID = descriptionID;

   if (GetStatus() == STATUS_COMPLETED)
   {
      resultID = installedDescriptionID;
   }

   result = String::load(resultID);

   ASSERT(!result.empty());

   return result;
}

void
DNSInstallationUnit::ServerRoleLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      DNSInstallationUnit::ServerRoleLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (IsServiceInstalled())
   {
      ASSERT(linkIndex == 0);

      LaunchMYS();
   }
   else
   {
      ASSERT(linkIndex == 0);

      LOG(L"Showing configuration help");

      ShowHelp(CYS_DNS_FINISH_PAGE_HELP);
   }
}
  
void
DNSInstallationUnit::FinishLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      DNSInstallationUnit::FinishLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (installing)
   {
      if (linkIndex == 0 &&
          IsServiceInstalled())
      {
         if (dnsRoleResult == DNS_SUCCESS)
         {
            LOG("Showing after checklist");

            ShowHelp(CYS_DNS_AFTER_FINISH_HELP);
         }
         else if (dnsRoleResult == DNS_SERVICE_START_FAILURE)
         {
            LOG(L"Launching Services console");

            LaunchMMCConsole(L"services.msc");
         }
         else
         {
            LOG(L"Launching DNS snapin");

            LaunchMMCConsole(L"dnsmgmt.msc");
         }
      }
      else
      {
         LOG(L"Showing configuration help");

         ShowHelp(CYS_DNS_FINISH_PAGE_HELP);
      }
   }
}

String
DNSInstallationUnit::GetFinishText()
{
   LOG_FUNCTION(DNSInstallationUnit::GetFinishText);

   unsigned int messageID = finishMessageID;

   if (installing)
   {
      InstallationReturnType result = GetInstallResult();
      if (result != INSTALL_SUCCESS &&
          result != INSTALL_SUCCESS_REBOOT &&
          result != INSTALL_SUCCESS_PROMPT_REBOOT)
      {
         if (dnsRoleResult == DNS_INSTALL_FAILURE)
         {
            messageID = finishInstallFailedMessageID;
         }
         else if (dnsRoleResult == DNS_SERVICE_START_FAILURE)
         {
            messageID = IDS_DNS_SERVICE_START_FAILED;
         }
         else
         {
            messageID = IDS_DNS_CONFIG_FAILED;
         }
      }
   }
   else
   {
      messageID = finishUninstallMessageID;

      UnInstallReturnType result = GetUnInstallResult();
      if (result != UNINSTALL_SUCCESS &&
          result != UNINSTALL_SUCCESS_REBOOT &&
          result != UNINSTALL_SUCCESS_PROMPT_REBOOT)
      {
         messageID = finishUninstallFailedMessageID;
      }
   }

   return String::load(messageID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\dnsinstallationunit.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      DNSInstallationUnit.h
//
// Synopsis:  Declares a DNSInstallationUnit
//            This object has the knowledge for installing the
//            DNS service
//
// History:   02/05/2001  JeffJon Created

#ifndef __CYS_DNSINSTALLATIONUNIT_H
#define __CYS_DNSINSTALLATIONUNIT_H

#include "NetworkInterface.h"
#include "ExpressPathInstallationUnitBase.h"

class DNSInstallationUnit : public ExpressPathInstallationUnitBase
{
   public:
      
      // Constructor

      DNSInstallationUnit();

      // Destructor
      virtual
      ~DNSInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      UnInstallReturnType
      UnInstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      InstallationReturnType 
      ExpressPathInstall(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      GetMilestoneText(String& message);

      virtual
      bool
      GetUninstallMilestoneText(String& message);

      virtual
      String
      GetUninstallWarningText();

      virtual
      String
      GetFinishText();

      virtual
      String
      GetServiceDescription();

      virtual
      void
      ServerRoleLinkSelected(int linkIndex, HWND hwnd);

      virtual
      void
      FinishLinkSelected(int inkIndex, HWND hwnd);

      void
      SetStaticIPAddress(DWORD ipaddress);

      DWORD
      GetStaticIPAddress();

      String
      GetStaticIPAddressString();

      void
      SetSubnetMask(DWORD mask);

      DWORD
      GetSubnetMask();

      String
      GetSubnetMaskString();

      void
      SetForwarder(DWORD forwarderAddress);

      void
      GetForwarders(IPAddressList& forwarders) const;

      bool
      IsManualForwarder() const;

   private:

      enum DNSRoleResult
      {
         DNS_SUCCESS,
         DNS_INSTALL_FAILURE,
         DNS_CONFIG_FAILURE,
         DNS_SERVICE_START_FAILURE
      };

      bool
      ReadConfigWizardRegkeys(String& configWizardResults) const;

      void
      SetForwardersForExpressPath();

      DNSRoleResult dnsRoleResult;

      // Express path members

      DWORD staticIPAddress;
      DWORD subnetMask;
      DWORD forwarderIPAddress;
      bool  manualForwarder;

      unsigned int installedDescriptionID;
};

#endif // __CYS_DNSINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\domainpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      DomainPage.cpp
//
// Synopsis:  Defines the new domain name page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "DomainPage.h"

static PCWSTR DOMAIN_PAGE_HELP = L"cys.chm::/typical_setup.htm#typicaldomainname";

ADDomainPage::ADDomainPage()
   :
   CYSWizardPage(
      IDD_AD_DOMAIN_NAME_PAGE, 
      IDS_AD_DOMAIN_TITLE, 
      IDS_AD_DOMAIN_SUBTITLE,
      DOMAIN_PAGE_HELP)
{
   LOG_CTOR(ADDomainPage);
}

   

ADDomainPage::~ADDomainPage()
{
   LOG_DTOR(ADDomainPage);
}


void
ADDomainPage::OnInit()
{
   LOG_FUNCTION(ADDomainPage::OnInit);

   CYSWizardPage::OnInit();

   // Set the default DNS domain name

   SetDefaultDNSName();
}

void
ADDomainPage::SetDefaultDNSName()
{
   LOG_FUNCTION(ADDomainPage::SetDefaultDNSName);

   // default to smallbusiness.local unless we can construct
   // the name from the RegisteredOrganization regkey

   String newDomainDNSName = L"smallbusiness.local";

   do
   {
      String organizationName;

      bool regResult = 
         GetRegKeyValue(
            CYS_ORGNAME_REGKEY, 
            CYS_ORGNAME_VALUE, 
            organizationName);

      if (!regResult || organizationName.empty())
      {
         // default back to smallbusiness.local

         LOG(L"Failed to read the orgname from registry so defaulting to smallbusiness.local");
         break;
      }

      String dnsName = String::format(IDS_EXPRESS_DNS_NAME_FORMAT, organizationName.c_str());

      DNSNameSyntaxError dnsNameError =
         ValidateDomainDnsNameSyntax(dnsName);

      if (dnsNameError == DNS_NAME_VALID ||
          dnsNameError == DNS_NAME_NON_RFC ||
          dnsNameError == DNS_NAME_NON_RFC_WITH_UNDERSCORE)
      {
         LOG(
            String::format(
               L"Name is either valid or non RFC: %1",
               dnsName.c_str()));

         newDomainDNSName = dnsName;
         break;
      }

      // since the name was invalid, try trimming
      // some illegal characters (note that space is included)

      static const String illegalDNSCharacters = L"\\ \'{|}~[]^`:;<>=?@!\"#$%^&()+/,*.";
      static const String emptyString = L"";

      organizationName = organizationName.replace_each_of(illegalDNSCharacters, emptyString);
      
      LOG(
         String::format(
            L"organization name after stripping: %1",
            organizationName.c_str()));

      dnsName = String::format(IDS_EXPRESS_DNS_NAME_FORMAT, organizationName.c_str());

      dnsNameError =
         ValidateDomainDnsNameSyntax(dnsName);

      if (dnsNameError == DNS_NAME_VALID ||
          dnsNameError == DNS_NAME_NON_RFC ||
          dnsNameError == DNS_NAME_NON_RFC_WITH_UNDERSCORE)
      {
         LOG(
            String::format(
               L"Stripped name is either valid or non RFC: %1",
               dnsName.c_str()));

         newDomainDNSName = dnsName;
         break;
      }

      // fall back to using smallbusiness.local
      LOG(L"All attempts to convert the organization name have failed.");

   } while (false);

   LOG(
      String::format(
         L"Using DNS name: %1",
         newDomainDNSName.c_str()));

   Win::SetDlgItemText(
      hwnd,
      IDC_DOMAIN,
      newDomainDNSName);

}


static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   int next =
         !Win::GetTrimmedDlgItemText(dialog, IDC_DOMAIN).empty()
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);
}

bool
ADDomainPage::OnSetActive()
{
   LOG_FUNCTION(ADDomainPage::OnSetActive);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DOMAIN),
      DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY);

   enable(hwnd);
   return true;
}


bool
ADDomainPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(ForestPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_DOMAIN:
      {
         if (code == EN_CHANGE)
         {
            enable(hwnd);
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}




int
ADDomainPage::Validate()
{
   LOG_FUNCTION(ADDomainPage::Validate);

   int nextPage = -1;

   do
   {
      String domain = Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN);
      LOG(String::format(L"domain = %1", domain.c_str()));

      if (!ValidateDomainDnsNameSyntax(hwnd, IDC_DOMAIN, popup))
      {
         nextPage = -1;
         break;
      }

      if (!ConfirmNetbiosLookingNameIsReallyDnsName(hwnd, IDC_DOMAIN, popup))
      {
         nextPage = -1;
         break;
      }

      // do this test last, as it is expensive

      if (!ForestValidateDomainDoesNotExist(hwnd, IDC_DOMAIN, popup))
      {
         nextPage = -1;
         break;
      }

      InstallationUnitProvider::GetInstance().GetADInstallationUnit().SetNewDomainDNSName(domain);
      nextPage = IDD_NETBIOS_NAME;
   } while(false);

   LOG(String::format(L"%1!d!", nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\domainpage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      DomainPage.h
//
// Synopsis:  Declares the new domain name page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_DOMAINPAGE_H
#define __CYS_DOMAINPAGE_H

#include "CYSWizardPage.h"


class ADDomainPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      ADDomainPage();

      // Destructor

      virtual 
      ~ADDomainPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

      virtual
      bool
      OnCommand(
         HWND        windowFrom,
         unsigned    controlIDFrom,
         unsigned    code);

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      void
      SetDefaultDNSName();

      // not defined: no copying allowed
      ADDomainPage(const ADDomainPage&);
      const ADDomainPage& operator=(const ADDomainPage&);

};

#endif // __CYS_DOMAINPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\expressdnspage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      ExpressDNSPage.h
//
// Synopsis:  Declares the express DNS page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_EXPRESSDNSPAGE_H
#define __CYS_EXPRESSDNSPAGE_H

#include "CYSWizardPage.h"

class ExpressDNSPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      ExpressDNSPage();

      // Destructor

      virtual 
      ~ExpressDNSPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // not defined: no copying allowed
      ExpressDNSPage(const ExpressDNSPage&);
      const ExpressDNSPage& operator=(const ExpressDNSPage&);

};

#endif // __CYS_EXPRESSDNSPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\expressdhcppage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      ExpressDHCPPage.cpp
//
// Synopsis:  Defines the express DHCP page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "ExpressDHCPPage.h"


static PCWSTR EXPRESSDHCP_PAGE_HELP = L"cys.chm::/typical_setup.htm";

ExpressDHCPPage::ExpressDHCPPage()
   :
   CYSWizardPage(
      IDD_EXPRESS_DHCP_PAGE, 
      IDS_EXPRESS_DHCP_TITLE, 
      IDS_EXPRESS_DHCP_SUBTITLE,
      EXPRESSDHCP_PAGE_HELP)
{
   LOG_CTOR(ExpressDHCPPage);
}

   

ExpressDHCPPage::~ExpressDHCPPage()
{
   LOG_DTOR(ExpressDHCPPage);
}


void
ExpressDHCPPage::OnInit()
{
   LOG_FUNCTION(ExpressDHCPPage::OnInit);

   CYSWizardPage::OnInit();
}


bool
ExpressDHCPPage::OnSetActive()
{
   LOG_FUNCTION(ExpressDHCPPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}


int
ExpressDHCPPage::Validate()
{
   LOG_FUNCTION(ExpressDHCPPage::Validate);

   int nextPage = -1;

   DWORD startAddress = 0;
   LRESULT startResult = Win::SendMessage(
                            Win::GetDlgItem(hwnd, IDC_START_IPADDRESS),
                            IPM_GETADDRESS,
                            0,
                            (LPARAM)&startAddress);

   DWORD endAddress = 0;
   LRESULT endResult = Win::SendMessage(
                          Win::GetDlgItem(hwnd, IDC_END_IPADDRESS),
                          IPM_GETADDRESS,
                          0,
                          (LPARAM)&endAddress);

   if (!startResult || !endResult)
   {
      String message = String::load(IDS_BOTH_IPADDRESS_REQUIRED);
      popup.Gripe(hwnd, IDC_START_IPADDRESS, message);
      nextPage = -1;
   }
   else
   {
      InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().SetStartIPAddress(startAddress);
      InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().SetEndIPAddress(endAddress);

      nextPage = IDD_MILESTONE_PAGE;
   }
   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\expressdhcppage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      ExpressDHCPPage.h
//
// Synopsis:  Declares the express DHCP page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_EXPRESSDHCPPAGE_H
#define __CYS_EXPRESSDHCPPAGE_H

#include "CYSWizardPage.h"

class ExpressDHCPPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      ExpressDHCPPage();

      // Destructor

      virtual 
      ~ExpressDHCPPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // not defined: no copying allowed
      ExpressDHCPPage(const ExpressDHCPPage&);
      const ExpressDHCPPage& operator=(const ExpressDHCPPage&);

};

#endif // __CYS_EXPRESSDHCPPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\expressdnspage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      ExpressDNSPage.cpp
//
// Synopsis:  Defines the express DNS page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "ExpressDNSPage.h"

static PCWSTR EXPRESSDNS_PAGE_HELP = L"cys.chm::/typical_setup.htm";

ExpressDNSPage::ExpressDNSPage()
   :
   CYSWizardPage(
      IDD_EXPRESS_DNS_PAGE, 
      IDS_EXPRESS_DNS_TITLE, 
      IDS_EXPRESS_DNS_SUBTITLE,
      EXPRESSDNS_PAGE_HELP)
{
   LOG_CTOR(ExpressDNSPage);
}

   

ExpressDNSPage::~ExpressDNSPage()
{
   LOG_DTOR(ExpressDNSPage);
}


void
ExpressDNSPage::OnInit()
{
   LOG_FUNCTION(ExpressDNSPage::OnInit);

   CYSWizardPage::OnInit();
}


bool
ExpressDNSPage::OnSetActive()
{
   LOG_FUNCTION(ExpressDNSPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   // Initialize the static IP address to 192.168.16.2

   
   Win::SendMessage(
      Win::GetDlgItem(hwnd, IDC_STATIC_IPADDRESS),
      IPM_SETADDRESS,
      0,
      MAKEIPADDRESS(192, 168, 16, 2));

   // Initialize the subnet mask to 255.255.255.0

   Win::SendMessage(
      Win::GetDlgItem(hwnd, IDC_MASK_IPADDRESS),
      IPM_SETADDRESS,
      0,
      MAKEIPADDRESS(255, 255, 255, 0));

   return true;
}


int
ExpressDNSPage::Validate()
{
   LOG_FUNCTION(ExpressDNSPage::Validate);

   int nextPage = -1;

   do
   {
      DWORD ipaddress = 0;
      LRESULT ipValidFields = Win::SendMessage(
                               Win::GetDlgItem(hwnd, IDC_STATIC_IPADDRESS),
                               IPM_GETADDRESS,
                               0,
                               (LPARAM)&ipaddress);

      if (ipValidFields <= 0)
      {
         String message = String::load(IDS_IPADDRESS_REQUIRED);
         popup.Gripe(hwnd, IDC_STATIC_IPADDRESS, message);
         nextPage = -1;
         break;
      }

      DWORD mask = 0;
      LRESULT maskValidFields = Win::SendMessage(
                                   Win::GetDlgItem(hwnd, IDC_MASK_IPADDRESS),
                                   IPM_GETADDRESS,
                                   0,
                                   (LPARAM)&mask);
      if (maskValidFields <= 0)
      {
         String message = String::load(IDS_MASK_REQUIRED);
         popup.Gripe(hwnd, IDC_MASK_IPADDRESS, message);
         nextPage = -1;
         break;
      }

      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().SetStaticIPAddress(ipaddress);
      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().SetSubnetMask(mask);

      nextPage = IDD_EXPRESS_DHCP_PAGE;

   } while (false);

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\executewizard.cpp ===
// Copyright (c) 2001-2001 Microsoft Corporation
//
// Implementation of ExecuteWizard
//
// 30 Mar 2000 sburns
// 05 Fed 2001 jeffjon  copied and modified to work with 
//                      a Win32 version of CYS



#include "pch.h"
#include "resource.h"



String
LaunchWrapperWizardExe(
   const String& fullPath,
   String&       commandLine, 
   unsigned      launchFailureResId,
   unsigned      failureResId,
   unsigned      successResId)
{
   LOG_FUNCTION2(LaunchWrapperWizardExe, fullPath);
   LOG(String::format(
          L"commandLine = %1",
          commandLine.c_str()));

   ASSERT(!fullPath.empty());
   ASSERT(launchFailureResId);
   ASSERT(failureResId);
   ASSERT(successResId);

   String result;
   do
   {
      DWORD exitCode = 0;
      HRESULT hr = CreateAndWaitForProcess(fullPath, commandLine, exitCode);
      if (FAILED(hr))
      {
         result = String::load(launchFailureResId);
         break;
      }

      // the exit codes from the wrapper wizards are HRESULTs.
      
      if (SUCCEEDED(static_cast<HRESULT>(exitCode)))
      {
         result = String::load(successResId);
         break;
      }

      result = String::load(failureResId);
   }
   while (0);

   LOG(result);

   return result;
}
   


// On success, returns the empty string.
// On failure, returns a failure message string for the CYS log.
   
String
LaunchPrintWizardExe(
   HWND          parent,
   const String& commandLine, 
   unsigned      launchFailureResId,
   unsigned      failureResId,
   unsigned      executeFailureResId,
   HRESULT&      hr)
{
   LOG_FUNCTION2(LaunchPrintWizardExe, commandLine);
   ASSERT(Win::IsWindow(parent));
   ASSERT(!commandLine.empty());
   ASSERT(launchFailureResId);
   ASSERT(failureResId);
   ASSERT(executeFailureResId);

   String result;
   HINSTANCE printui = 0;
   
   do
   {
      hr = Win::LoadLibrary(L"printui.dll", printui);
      if (FAILED(hr))
      {
         LOG("LoadLibrary Failed");
         
         result =
            String::format(
               failureResId,
               String::load(launchFailureResId).c_str(),
               hr,
               GetErrorMessage(hr).c_str());
         break;
      }
      
      FARPROC proc = 0;
      hr = Win::GetProcAddress(printui, L"PrintUIEntryW", proc);
      if (FAILED(hr))
      {
         LOG("GetProcAddress Failed");
         
         result =
            String::format(
               failureResId,
               String::load(launchFailureResId).c_str(),
               hr,
               GetErrorMessage(hr).c_str());
         break;
      }

      typedef DWORD (*PrintUIEntryW)(HWND, HINSTANCE, PCTSTR, UINT);      
      PrintUIEntryW uiproc = reinterpret_cast<PrintUIEntryW>(proc);

      DWORD err = 
         uiproc(
            parent, 
            Win::GetModuleHandle(),
            commandLine.c_str(),
            TRUE);

      hr = Win32ToHresult(err);
      if (FAILED(hr))
      {
         result =
            String::format(
               failureResId,
               String::load(executeFailureResId).c_str(),
               hr,
               GetErrorMessage(hr).c_str());
      }
   }
   while (0);

   if (printui)
   {
      HRESULT unused = Win::FreeLibrary(printui);
      ASSERT(SUCCEEDED(unused));
   }

   LOG_HRESULT(hr);
   LOG(result);

   return result;
}



// Return : True if the wizard was run, false if the serviceName was unknown
//          Other errors are propogated out through the hr parameter.  These
//          errors originate as exit codes from the wizards which are being
//          called

bool ExecuteWizard(
   HWND     parent,     
   PCWSTR   serviceName,
   String&  resultText, 
   HRESULT& hr)         
{
   LOG_FUNCTION2(
      ExecuteWizard,
      serviceName ? serviceName : L"(empty)");

   // some wizards, namely the printer wizard, like to have a parent window so
   // that they can run modally.
   // NTRAID#NTBUG9-706913-2002/09/23-sburns
  
   ASSERT(Win::IsWindow(parent));   

   resultText.erase();
   
   bool result = true;

   // This is ignored by most of the Installation Units
   // but can be used for determining success or cancellation by others

   hr = S_OK;

   do
   {
      if (!serviceName)
      {
         ASSERT(serviceName);
         break;
      }

      String service(serviceName);

      if (service.icompare(CYS_DNS_SERVICE_NAME) == 0)
      {
         // launch wrapper exe

         resultText =
            LaunchWrapperWizardExe(
               String::format(
                  IDS_LAUNCH_DNS_WIZARD_COMMAND_LINE,
                  Win::GetSystemDirectory().c_str()),
               String(),
               IDS_LAUNCH_DNS_WIZARD_FAILED,
               IDS_DNS_WIZARD_FAILED,
               IDS_DNS_WIZARD_SUCCEEDED);
      }
      else if (service.icompare(CYS_DHCP_SERVICE_NAME) == 0)
      {
         // launch wrapper exe

         resultText =
            LaunchWrapperWizardExe(
               String::format(
                  IDS_LAUNCH_DHCP_WIZARD_COMMAND_LINE,
                  Win::GetSystemDirectory().c_str()),
               String(),
               IDS_LAUNCH_DHCP_WIZARD_FAILED,
               IDS_DHCP_WIZARD_FAILED,
               IDS_DHCP_WIZARD_SUCCEEDED);
      }
      else if (service.icompare(CYS_RRAS_SERVICE_NAME) == 0)
      {
         // launch wrapper exe

         resultText =
            LaunchWrapperWizardExe(
               String::format(
                  IDS_LAUNCH_RRAS_WIZARD_COMMAND_LINE,
                  Win::GetSystemDirectory().c_str()),
               String(),
               IDS_LAUNCH_RRAS_WIZARD_FAILED,
               IDS_RRAS_WIZARD_FAILED,
               IDS_RRAS_WIZARD_SUCCEEDED);
      }
      else if (service.icompare(CYS_RRAS_UNINSTALL) == 0)
      {
         // launch wrapper exe

         resultText =
            LaunchWrapperWizardExe(
               String::format(
                  IDS_LAUNCH_RRAS_WIZARD_COMMAND_LINE,
                  Win::GetSystemDirectory().c_str()),
               String(L"/u"),
               IDS_LAUNCH_RRAS_WIZARD_FAILED,
               IDS_RRAS_WIZARD_FAILED,
               IDS_RRAS_WIZARD_SUCCEEDED);
      }
      else if (service.icompare(CYS_PRINTER_WIZARD_NAME) == 0)
      {
         resultText =
            LaunchPrintWizardExe(
               parent,
               L"/il /Wr",
               IDS_LAUNCH_PRINTER_WIZARD_FAILED,
               IDS_PRINTER_WIZARD_FAILED,
               IDS_EXECUTE_PRINTER_WIZARD_FAILED,
               hr);
      }
      else if (service.icompare(CYS_PRINTER_DRIVER_WIZARD_NAME) == 0)
      {
         resultText =
            LaunchPrintWizardExe(
               parent,
               L"/id /Wr",
               IDS_LAUNCH_PRINTER_DRIVER_WIZARD_FAILED,
               IDS_PRINTER_DRIVER_WIZARD_FAILED,
               IDS_EXECUTE_PRINTER_DRIVER_WIZARD_FAILED,
               hr);
      }
      else
      {
         LOG(String::format(
                L"Unknown wizard name: %1",
                service.c_str()));
         ASSERT(FALSE);
         result = false;
      }
   } while (false);

   LOG(resultText);
   LOG_HRESULT(hr);
   LOG_BOOL(result);
   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\expresspages.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\expresspages.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\expressinstallationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      ExpressInstallationUnit.cpp
//
// Synopsis:  Defines a ExpressInstallationUnit
//            This object has the knowledge for installing the
//            services for the express path.  AD, DNS, and DHCP
//
// History:   02/08/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "ExpressInstallationUnit.h"
#include "InstallationUnitProvider.h"
#include "smcyscom.h"

// Define the GUIDs used by the Server Management Console COM object

#include <initguid.h>
DEFINE_GUID(CLSID_SMCys,0x9436DA1F,0x7F32,0x43ac,0xA4,0x8C,0xF6,0xF8,0x13,0x88,0x2B,0xE8);

// Finish page help 
static PCWSTR CYS_EXPRESS_FINISH_PAGE_HELP   = L"cys.chm::/typical_setup.htm";
static PCWSTR CYS_EXPRESS_AFTER_FINISH_HELP  = L"cys.chm::/typical_setup.htm#typicalcompletion";
static PCWSTR CYS_TAPI_HELP                  = L"TAPIconcepts.chm::/sag_TAPIconcepts_150.htm";

const String ExpressInstallationUnit::expressRoleResultStrings[] =
{
   String(L"EXPRESS_SUCCESS"),
   String(L"EXPRESS_CANCELLED"),
   String(L"EXPRESS_RRAS_FAILURE"),
   String(L"EXPRESS_RRAS_CANCELLED"),
   String(L"EXPRESS_DNS_FAILURE"),
   String(L"EXPRESS_DHCP_INSTALL_FAILURE"),
   String(L"EXPRESS_DHCP_CONFIG_FAILURE"),
   String(L"EXPRESS_AD_FAILURE"),
   String(L"EXPRESS_DNS_SERVER_FAILURE"),
   String(L"EXPRESS_DNS_FORWARDER_FAILURE"),
   String(L"EXPRESS_DHCP_SCOPE_FAILURE"),
   String(L"EXPRESS_DHCP_ACTIVATION_FAILURE"),
   String(L"EXPRESS_TAPI_FAILURE")
};

ExpressInstallationUnit::ExpressInstallationUnit() :
   expressRoleResult(EXPRESS_SUCCESS),
   InstallationUnit(
      IDS_EXPRESS_PATH_TYPE, 
      IDS_EXPRESS_PATH_DESCRIPTION, 
      IDS_EXPRESS_FINISH_TITLE,
      0,
      IDS_EXPRESS_FINISH_MESSAGE,
      0,
      0,
      0,
      0,
      0,
      CYS_EXPRESS_FINISH_PAGE_HELP,
      CYS_EXPRESS_FINISH_PAGE_HELP,
      CYS_EXPRESS_AFTER_FINISH_HELP,
      EXPRESS_SERVER)
{
   LOG_CTOR(ExpressInstallationUnit);
}


ExpressInstallationUnit::~ExpressInstallationUnit()
{
   LOG_DTOR(ExpressInstallationUnit);
}


InstallationReturnType
ExpressInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(ExpressInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   do
   {
      // Log the First Server header

      CYS_APPEND_LOG(String::load(IDS_LOG_EXPRESS_HEADER));

      // Warn the user of a reboot during installation

      if (IDOK != Win::MessageBox(
                     hwnd,
                     String::load(IDS_CONFIRM_REBOOT),
                     String::load(IDS_WIZARD_TITLE),
                     MB_OKCANCEL))
      {
         CYS_APPEND_LOG(String::load(IDS_LOG_EXPRESS_CANCELLED));
         result = INSTALL_CANCELLED;

         SetExpressRoleResult(EXPRESS_CANCELLED);
         break;
      }

      // The order of the installation is extremely important. 
      //
      //    RRAS - must be installed first because they return the local NIC to us
      //           which is used in the other installation units
      //    DNS  - must be second because it sets the static IP address on the local
      //           NIC
      //    DHCP - must be third because it has to be installed prior to running 
      //           DCPromo which reboots the machine
      //    AD   - must be last because it reboots the machine

      // Install RRAS

      result = 
         InstallationUnitProvider::GetInstance().
            GetRRASInstallationUnit().InstallService(
               logfileHandle,
               hwnd);

      if (result != INSTALL_SUCCESS)
      {
         LOG(L"Failed to install routing and/or firewall");

         break;
      }

      // Install the server management console
      // REVIEW_JEFFJON : ignore the results for now
      InstallServerManagementConsole();

      // Call the DNS installation unit to set the static IP address and subnet mask

      result = InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().InstallService(
         logfileHandle, 
         hwnd);

      if (result != INSTALL_SUCCESS)
      {
         LOG(L"Failed to install static IP address and subnet mask");
         break;
      }

      // Install DHCP

      result = InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().InstallService(logfileHandle, hwnd);
      if (result != INSTALL_SUCCESS)
      {
         LOG(L"Failed to install DCHP");
         break;
      }

      result = InstallationUnitProvider::GetInstance().GetADInstallationUnit().InstallService(logfileHandle, hwnd);

   } while (false);

   LOG_INSTALL_RETURN(result);

   return result;
}

UnInstallReturnType
ExpressInstallationUnit::UnInstallService(HANDLE /*logfileHandle*/, HWND /*hwnd*/)
{
   LOG_FUNCTION(ExpressInstallationUnit::UnInstallService);

   UnInstallReturnType result = UNINSTALL_NO_CHANGES;

   // Shouldn't get here!
   ASSERT(false);

   LOG_UNINSTALL_RETURN(result);

   return result;
}

bool
ExpressInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(ExpressInstallationUnit:IsServiceInstalled);

   bool result = false;

   if (InstallationUnitProvider::GetInstance().
          GetDHCPInstallationUnit().IsServiceInstalled() ||
       InstallationUnitProvider::GetInstance().
          GetDNSInstallationUnit().IsServiceInstalled() ||
       InstallationUnitProvider::GetInstance().
         GetADInstallationUnit().IsServiceInstalled())
   {
      result = true;
   }

   LOG_BOOL(result);

   return result;
}

bool
ExpressInstallationUnit::GetMilestoneText(String& message)
{
   LOG_FUNCTION(ExpressInstallationUnit::GetMilestoneText);

//   ADInstallationUnit& adInstallationUnit =
//      InstallationUnitProvider::GetInstance().GetADInstallationUnit();

   DNSInstallationUnit& dnsInstallationUnit =
      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit();

//   DHCPInstallationUnit& dhcpInstallationUnit =
//      InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit();

   // Add the RRAS message if required

   if (InstallationUnitProvider::GetInstance().GetRRASInstallationUnit().ShouldRunRRASWizard())
   {
      message += String::load(IDS_EXPRESS_RRAS_FINISH_TEXT);
   }

   // Add "Install DHCP if required"

   message += String::load(IDS_EXPRESS_DHCP_TEXT);

   // Add "Install Active Directory and DNS"

   message += String::load(IDS_EXPRESS_FINISH_TEXT);


   // Add the create domain message

   message += String::format(
                 String::load(IDS_EXPRESS_FINISH_DOMAIN_NAME),
                 InstallationUnitProvider::GetInstance().GetADInstallationUnit().GetNewDomainDNSName().c_str());

   if (dnsInstallationUnit.IsManualForwarder())
   {
      IPAddressList forwardersList;
      dnsInstallationUnit.GetForwarders(forwardersList);

      if (!forwardersList.empty())
      {
         // There should only be one entry for manual forwarding

         DWORD forwarderInDisplayByteOrder = ConvertIPAddressOrder(forwardersList[0]);

         message += String::format(
                       String::load(IDS_EXPRESS_FINISH_DNS_FORWARDERS),
                       IPAddressToString(forwarderInDisplayByteOrder).c_str());
      }
   }

   LOG_BOOL(true);
   return true;
}  

HRESULT
ExpressInstallationUnit::DoTapiConfig(const String& dnsName)
{
   LOG_FUNCTION2(
      ExpressInstallationUnit::DoTapiConfig,
      dnsName);

   // Comments below taken from old HTA CYS

	/*
	// The TAPICFG is a straight command line utility where all the required parameters can be at once supplied 
	// in the command line arguments and there are no sub-menus to traverse. The /Directory switch takes the DNS
	// name of the NC to be created and the optional /Server switch takes the name of the domain controller on 
	// which the NC is to be created. If the /server switch is not specified, then the command assumes it is 
	// running on a DC and tries to create the NC locally.
	// NDNC (non-domain naming context) is a partition that is created on Active Directory and serves as a dynamic 
	// directory, where its used for temporary storage (depending on TTL) of objects pre-defined in the AD schema. 
	// Here in TAPI we use NDNC to store user and conference information dynamically on the server.
	*/

   HRESULT hr = S_OK;

   String fullPath = 
      FS::AppendPath(
         Win::GetSystemDirectory(),
         String::load(IDS_TAPI_CONFIG_EXE));

   String commandLine = String::format(IDS_TAPI_CONFIG_COMMAND_FORMAT, dnsName.c_str());

   DWORD exitCode = 0;
   hr = CreateAndWaitForProcess(
           fullPath,
           commandLine, 
           exitCode, 
           true);
   
   if (SUCCEEDED(hr) &&
       exitCode != 0)
   {
      LOG(String::format(L"Exit code = %1!x!", exitCode));
      hr = E_FAIL;
   }

   LOG(String::format(L"hr = %1!x!", hr));

   return hr;
}

void
ExpressInstallationUnit::InstallServerManagementConsole()
{
   LOG_FUNCTION(ExpressInstallationUnit::InstallServerManagementConsole);

   do
   {
      SmartInterface<ISMCys> smCYS;
      HRESULT hr = smCYS.AcquireViaCreateInstance(
                     CLSID_SMCys,
                     0,
                     CLSCTX_INPROC_SERVER);

      if (FAILED(hr))
      {
         LOG(String::format(
               L"Failed to create ISMCys COM object: hr = 0x%1!x!",
               hr));
         break;
      }

      String installLocation;
      DWORD productSKU = State::GetInstance().GetProductSKU();

      if (productSKU & CYS_SERVER)
      {
        installLocation = String::load(IDS_SERVER_CD);
      }
      else if (productSKU & CYS_ADVANCED_SERVER)
      {
        installLocation = String::load(IDS_ADVANCED_SERVER_CD);
      }
      else if (productSKU & CYS_DATACENTER_SERVER)
      {
        installLocation = String::load(IDS_DATACENTER_SERVER_CD);
      }
      else
      {
        installLocation = String::load(IDS_WINDOWS_CD);
      }

      hr = smCYS->Install( AutoBstr(installLocation.c_str()) );
      
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to install the Server Management Console: hr = 0x%1!x!",
                hr));
         break;
      }

      // Add the shortcut to the Start Menu

      String target = 
         Win::GetSystemDirectory() + L"\\administration\\servmgmt.msc";

      hr = 
         AddShortcutToAdminTools(
            target,
            IDS_SERVERMGMT_SHORTCUT_DESCRIPTION,
            IDS_SERVERMGMT_ADMIN_TOOLS_LINK);

   } while(false);

}

ExpressInstallationUnit::ExpressRoleResult
ExpressInstallationUnit::GetExpressRoleResult()
{ 
   LOG_FUNCTION(ExpressInstallationUnit::GetExpressRoleResult);

   LOG(expressRoleResultStrings[expressRoleResult]);

   return expressRoleResult; 
}


String
ExpressInstallationUnit::GetFinishText()
{
   LOG_FUNCTION(ExpressInstallationUnit::GetFinishText);

   unsigned int messageID = IDS_EXPRESS_FINISH_MESSAGE;

   if (installing)
   {
      InstallationReturnType result = GetInstallResult();
      if (result != INSTALL_SUCCESS)
      {
         ExpressRoleResult roleResult = GetExpressRoleResult();

         if (roleResult == EXPRESS_RRAS_CANCELLED)
         {
            messageID = IDS_EXPRESS_FINISH_RRAS_CANCELLED;
         }
         else if (roleResult == EXPRESS_RRAS_FAILURE)
         {
            messageID = IDS_EXPRESS_FINISH_RRAS_FAILURE;
         }
         else if (roleResult == EXPRESS_DNS_FAILURE)
         {
            messageID = IDS_EXPRESS_FINISH_DNS_FAILURE;
         }
         else if (roleResult == EXPRESS_DHCP_INSTALL_FAILURE)
         {
            messageID = IDS_EXPRESS_FINISH_DHCP_INSTALL_FAILURE;
         }
         else if (roleResult == EXPRESS_DHCP_CONFIG_FAILURE)
         {
            messageID = IDS_EXPRESS_FINISH_DHCP_CONFIG_FAILURE;
         }
         else if (roleResult == EXPRESS_AD_FAILURE)
         {
            messageID = IDS_EXPRESS_FINISH_AD_FAILURE;
         }
         else if (roleResult == EXPRESS_DNS_SERVER_FAILURE)
         {
            messageID = IDS_EXPRESS_DNS_SERVER_FAILURE;
         }
         else if (roleResult == EXPRESS_DNS_FORWARDER_FAILURE)
         {
            messageID = IDS_EXPRESS_DNS_FORWARDER_FAILURE;
         }
         else if (roleResult == EXPRESS_DHCP_SCOPE_FAILURE)
         {
            messageID = IDS_EXPRESS_DHCP_SCOPE_FAILURE;
         }
         else if (roleResult == EXPRESS_DHCP_ACTIVATION_FAILURE)
         {
            messageID = IDS_EXPRESS_DHCP_ACTIVATION_FAILURE;
         }
         else if (roleResult == EXPRESS_TAPI_FAILURE)
         {
            messageID = IDS_EXPRESS_TAPI_FAILURE;
         }
         else if (roleResult == EXPRESS_CANCELLED)
         {
            messageID = IDS_EXPRESS_CANCELLED;
         }
      }
   }

   return String::load(messageID);
}

void
ExpressInstallationUnit::FinishLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      ExpressInstallationUnit::FinishLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   // Currently we have only one link 
   
   ASSERT(linkIndex == 0);

   ExpressRoleResult result = GetExpressRoleResult();
   if (result == EXPRESS_SUCCESS)
   {
      LOG("Showing after checklist");

      ShowHelp(CYS_EXPRESS_AFTER_FINISH_HELP);
   }
   else if (result == EXPRESS_CANCELLED)
   {
      // Nothing???
   }
   else if (result == EXPRESS_RRAS_FAILURE ||
            result == EXPRESS_RRAS_CANCELLED)
   {
      LOG("Launch the RRAS snapin");

      LaunchMMCConsole(L"rrasmgmt.msc");
   }
   else if (result == EXPRESS_DNS_FAILURE ||
            result == EXPRESS_DHCP_CONFIG_FAILURE ||
            result == EXPRESS_DHCP_SCOPE_FAILURE  ||
            result == EXPRESS_DHCP_ACTIVATION_FAILURE)
   {
      LOG("Launch the DHCP snapin");

      LaunchMMCConsole(L"dhcpmgmt.msc");
   }
   else if (result == EXPRESS_DHCP_INSTALL_FAILURE)
   {
      LOG(L"Show DHCP configuration help");

      ShowHelp(CYS_DHCP_FINISH_PAGE_HELP);
   }
   else if (result == EXPRESS_AD_FAILURE)
   {
      LOG(L"Launch DCPROMO");

      HRESULT hr = 
         MyCreateProcess(
            InstallationUnitProvider::GetInstance().
               GetADInstallationUnit().GetDCPromoPath(), 
            String());

      ASSERT(SUCCEEDED(hr));
   }
   else if (result == EXPRESS_DNS_FORWARDER_FAILURE)
   {
      LOG(L"Launch DNS Manager");

      LaunchMMCConsole(L"dnsmgmt.msc");
   }
   else if (result == EXPRESS_TAPI_FAILURE)
   {
      LOG(L"Show TAPI help");

      ShowHelp(CYS_TAPI_HELP);
   }
   else
   {
      LOG("Showing after checklist");

      ShowHelp(CYS_EXPRESS_AFTER_FINISH_HELP);
   }
}

void
ExpressInstallationUnit::SetExpressRoleResult(
   ExpressRoleResult roleResult)
{
   LOG_FUNCTION(ExpressInstallationUnit::SetExpressRoleResult);

   expressRoleResult = roleResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\expressinstallationunit.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      ExpressInstallationUnit.h
//
// Synopsis:  Declares a ExpressInstallationUnit
//            This object has the knowledge for installing the
//            services for the express path: AD, DNS, and DHCP
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_EXPRESSINSTALLATIONUNIT_H
#define __CYS_EXPRESSINSTALLATIONUNIT_H

#include "InstallationUnit.h"

class ExpressInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      ExpressInstallationUnit();

      // Destructor
      virtual
      ~ExpressInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      UnInstallReturnType
      UnInstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      bool
      GetMilestoneText(String& message);

      virtual
      bool
      GetUninstallMilestoneText(String& /*message*/) { return false; }

      virtual
      String
      GetFinishText();

      virtual
      void
      ServerRoleLinkSelected(int /*linkIndex*/, HWND /*hwnd*/) {};

      virtual
      void
      FinishLinkSelected(int inkIndex, HWND hwnd);

      HRESULT
      DoTapiConfig(const String& dnsName);

      enum ExpressRoleResult
      {
         EXPRESS_SUCCESS,
         EXPRESS_CANCELLED,
         EXPRESS_RRAS_FAILURE,
         EXPRESS_RRAS_CANCELLED,
         EXPRESS_DNS_FAILURE,
         EXPRESS_DHCP_INSTALL_FAILURE,
         EXPRESS_DHCP_CONFIG_FAILURE,
         EXPRESS_AD_FAILURE,
         EXPRESS_DNS_SERVER_FAILURE,
         EXPRESS_DNS_FORWARDER_FAILURE,
         EXPRESS_DHCP_SCOPE_FAILURE,
         EXPRESS_DHCP_ACTIVATION_FAILURE,
         EXPRESS_TAPI_FAILURE
      };

      // Matching strings for role result for easy
      // logging

      static const String expressRoleResultStrings[];

      void
      SetExpressRoleResult(
         ExpressRoleResult roleResult);

      ExpressRoleResult
      GetExpressRoleResult();

   private:

      ExpressRoleResult expressRoleResult;

      void
      InstallServerManagementConsole();
};

#endif // __CYS_EXPRESSINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\expressrebootpage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      ExpressRebootPage.h
//
// Synopsis:  Declares the ExpressRebootPage that shows
//            the progress of the changes being made to
//            the server after the reboot fromt the
//            express path
//
// History:   05/11/2001  JeffJon Created

#ifndef __CYS_EXPRESSREBOOTPAGE_H
#define __CYS_EXPRESSREBOOTPAGE_H

#include "CYSWizardPage.h"


class ExpressRebootPage : public CYSWizardPage
{
   public:
      
      // These messages are sent to the page when an operation has finished.
      // The page will update the UI with the appropriate icons

      static const UINT CYS_OPERATION_FINISHED_SUCCESS;
      static const UINT CYS_OPERATION_FINISHED_FAILED;

      // These messages are sent to the page when all the operations have
      // completed.  An appropriate dialog will be shown

      static const UINT CYS_OPERATION_COMPLETE_SUCCESS;
      static const UINT CYS_OPERATION_COMPLETE_FAILED;

      // This enum can be used to index the array above.  The order must be identical
      // to the order in which the operations are processed

      typedef enum
      {
         CYS_OPERATION_SET_STATIC_IP = 0,
         CYS_OPERATION_SERVER_DHCP,
         CYS_OPERATION_SERVER_AD,
         CYS_OPERATION_SERVER_DNS,
         CYS_OPERATION_SET_DNS_FORWARDER,
         CYS_OPERATION_ACTIVATE_DHCP_SCOPE,
         CYS_OPERATION_AUTHORIZE_DHCP_SERVER,
         CYS_OPERATION_CREATE_TAPI_PARTITION,
         CYS_OPERATION_END
      } CYS_OPERATION_TYPES;

      typedef void (*ThreadProc) (ExpressRebootPage& page);

      // Constructor
      
      ExpressRebootPage();

      // Destructor

      virtual 
      ~ExpressRebootPage();

      // Accessors

      bool
      SetForwarder() const { return setForwarder; }

      bool
      WasDHCPInstallAttempted() const { return dhcpInstallAttempted; }

      // PropertyPage overrides

      virtual
      void
      OnInit();

      virtual
      bool
      OnSetActive();

      virtual
      bool
      OnMessage(
         UINT     message,
         WPARAM   wparam,
         LPARAM   lparam);

      virtual
      int
      Validate();

      String
      GetIPAddressString() const;

   private:

      void
      ClearOperationStates();

      typedef enum
      {
         // Neither the check nor the current operation
         // indicator will be shown for this state

         OPERATION_STATE_UNKNOWN = 0,

         // The check will be shown for this state

         OPERATION_STATE_FINISHED_SUCCESS,
         
         // The red minus will be shown for this state

         OPERATION_STATE_FINISHED_FAILED

      } OperationStateType;

      void
      SetOperationState(
         OperationStateType  state,
         CYS_OPERATION_TYPES checkID,
         CYS_OPERATION_TYPES currentID);

      void
      SetCancelState(bool enable) const;

      void
      SetDHCPStatics();

      bool dhcpInstallAttempted;
      bool setForwarder;
      bool threadDone;

      String ipaddressString;

      // not defined: no copying allowed
      ExpressRebootPage(const ExpressRebootPage&);
      const ExpressRebootPage& operator=(const ExpressRebootPage&);

};

#endif // __CYS_EXPRESSREBOOTPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\expresspathinstallationunitbase.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      ExpressPathInstallationUnitBase.h
//
// Synopsis:  Declares an ExpressPathInstallationUnitBase
//            An ExpressPathInstallationUnitBase represents a single
//            entity that can be installed through the Express path. 
//            (i.e. DHCP, DNS, etc.)
//
// History:   11/09/2001  JeffJon Created

#ifndef __CYS_EXPRESSPATHINSTALLATIONUNITBASE_H
#define __CYS_EXPRESSPATHINSTALLATIONUNITBASE_H

#include "pch.h"

#include "resource.h"
#include "InstallationUnit.h"


class ExpressPathInstallationUnitBase : public InstallationUnit
{
   public:

      // Constructor

      ExpressPathInstallationUnitBase(
         unsigned int serviceNameID,
         unsigned int serviceDescriptionID,
         unsigned int finishPageTitleID,
         unsigned int finishPageUninstallTitleID,
         unsigned int finishPageMessageID,
         unsigned int finishPageFailedMessageID,
         unsigned int finishPageUninstallMessageID,
         unsigned int finishPageUninstallFailedMessageID,
         unsigned int uninstallMilestonePageWarningID,
         unsigned int uninstallMilestonePageCheckboxID,
         const String finishPageHelpString,
         const String milestonePageHelpString,
         const String afterFinishHelpString,
         ServerRole newInstallType = NO_SERVER);

      virtual 
      InstallationReturnType 
      ExpressPathInstall(HANDLE logfileHandle, HWND hwnd) = 0;

      // Data accessors

      void
      SetExpressPathInstall(bool isExpressPath);

      bool IsExpressPathInstall() const;

   protected:

      String
      GetNetshPath() const;

   private:
   
      bool  isExpressPathInstall;
};


#endif // __CYS_EXPRESSPATHINSTALLATIONUNITBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\expresspathinstallationunitbase.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      ExpressPathInstallationUnitBase.cpp
//
// Synopsis:  Defines a ExpressPathInstallationUnitBase
//            This is the base class that all installation
//            units must derive from to be installable
//            through the Express path.
//
// History:   11/09/2001  JeffJon Created

#include "pch.h"
#include "ExpressPathInstallationUnitBase.h"

ExpressPathInstallationUnitBase::ExpressPathInstallationUnitBase(
   unsigned int serviceNameID,
   unsigned int serviceDescriptionID,
   unsigned int finishPageTitleID,
   unsigned int finishPageUninstallTitleID,
   unsigned int finishPageMessageID,
   unsigned int finishPageFailedMessageID,
   unsigned int finishPageUninstallMessageID,
   unsigned int finishPageUninstallFailedMessageID,
   unsigned int uninstallMilestonePageWarningID,
   unsigned int uninstallMilestonePageCheckboxID,
   const String finishPageHelpString,
   const String milestonePageHelpString,
   const String afterFinishHelpString,
   ServerRole newInstallType) :
      isExpressPathInstall(false),
      InstallationUnit(
         serviceNameID, 
         serviceDescriptionID, 
         finishPageTitleID,
         finishPageUninstallTitleID,
         finishPageMessageID,
         finishPageFailedMessageID,
         finishPageUninstallMessageID,
         finishPageUninstallFailedMessageID,
         uninstallMilestonePageWarningID,
         uninstallMilestonePageCheckboxID,
         finishPageHelpString,
         milestonePageHelpString,
         afterFinishHelpString,
         newInstallType)
{
   LOG_CTOR(ExpressPathInstallationUnitBase);
}

void
ExpressPathInstallationUnitBase::SetExpressPathInstall(bool isExpressPath)
{
   LOG_FUNCTION2(
      ExpressPathInstallationUnitBase::SetExpressPathInstall,
      (isExpressPath) ? L"true" : L"false");

   isExpressPathInstall = isExpressPath;
}


bool
ExpressPathInstallationUnitBase::IsExpressPathInstall() const
{
   LOG_FUNCTION(ExpressPathInstallationUnitBase::IsExpressPathInstall);

   return isExpressPathInstall;
}


String
ExpressPathInstallationUnitBase::GetNetshPath() const
{
   LOG_FUNCTION(ExpressPathInstallationUnitBase::GetNetshPath);

   String result = Win::GetSystemDirectory();
   result = FS::AppendPath(result, L"netsh.exe");

   LOG(result);
   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\expressrebootpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      ExpressRebootPage.cpp
//
// Synopsis:  Defines the ExpressRebootPage that shows
//            the progress of the changes being made to
//            the server after the reboot fromt the
//            express path
//
// History:   05/11/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "ExpressRebootPage.h"


// Private window messages for updating the UI status

// For these messages the WPARAM is the operation that finished, and 
// the LPARAM is the operation that is next

const UINT ExpressRebootPage::CYS_OPERATION_FINISHED_SUCCESS = WM_USER + 1001;
const UINT ExpressRebootPage::CYS_OPERATION_FINISHED_FAILED  = WM_USER + 1002;


const UINT ExpressRebootPage::CYS_OPERATION_COMPLETE_SUCCESS = WM_USER + 1003;
const UINT ExpressRebootPage::CYS_OPERATION_COMPLETE_FAILED  = WM_USER + 1004;


// This structure maps the four static controls that make up an operation
// together.  The pageProgress array must be in the order the operations
// will take place so that the page can update appropriately when
// an CYS_OPERATION_FINISHED_* message is sent back to the page

typedef struct _PageProgressStruct
{
   unsigned int currentIconControl;
   unsigned int checkIconControl;
   unsigned int errorIconControl;
   unsigned int staticIconControl;
} PageProgressStruct;

PageProgressStruct pageOperationProgress[] =
{
   { 
      IDC_IPADDRESS_CURRENT_STATIC,  
      IDC_IPADDRESS_CHECK_STATIC,
      IDC_IPADDRESS_ERROR_STATIC,
      IDC_IPADDRESS_STATIC
   },

   { 
      IDC_DHCP_CURRENT_STATIC,  
      IDC_DHCP_CHECK_STATIC,
      IDC_DHCP_ERROR_STATIC,
      IDC_DHCP_STATIC
   },

   { 
      IDC_AD_CURRENT_STATIC,  
      IDC_AD_CHECK_STATIC,
      IDC_AD_ERROR_STATIC,
      IDC_AD_STATIC
   },

   { 
      IDC_DNS_CURRENT_STATIC,  
      IDC_DNS_CHECK_STATIC,
      IDC_DNS_ERROR_STATIC,
      IDC_DNS_STATIC
   },

   { 
      IDC_FORWARDER_CURRENT_STATIC,  
      IDC_FORWARDER_CHECK_STATIC,
      IDC_FORWARDER_ERROR_STATIC,
      IDC_FORWARDER_STATIC
   },

   {
      IDC_DHCP_SCOPE_CURRENT_STATIC,
      IDC_DHCP_SCOPE_CHECK_STATIC,
      IDC_DHCP_SCOPE_ERROR_STATIC,
      IDC_DHCP_SCOPE_STATIC
   },

   { 
      IDC_AUTHORIZE_SCOPE_CURRENT_STATIC,  
      IDC_AUTHORIZE_SCOPE_CHECK_STATIC,
      IDC_AUTHORIZE_SCOPE_ERROR_STATIC,
      IDC_AUTHORIZE_SCOPE_STATIC
   },

   { 
      IDC_TAPI_CURRENT_STATIC,  
      IDC_TAPI_CHECK_STATIC,
      IDC_TAPI_ERROR_STATIC,
      IDC_TAPI_STATIC
   },
   
   { 0, 0, 0, 0 }
};

bool
SetDNSForwarder(HANDLE logfileHandle)
{
   LOG_FUNCTION(SetDNSForwarder);

   bool result = true;

   do
   {
      // First read the regky

      DWORD forwarder = 0;
      String autoForwarder;

      bool forwarderResult = GetRegKeyValue(
                                CYS_FIRST_DC_REGKEY,
                                CYS_FIRST_DC_FORWARDER,
                                forwarder);

      bool autoForwarderResult = GetRegKeyValue(
                                    CYS_FIRST_DC_REGKEY,
                                    CYS_FIRST_DC_AUTOFORWARDER,
                                    autoForwarder);

      if (forwarderResult &&
          forwarder != 0)
      {
         DWORD forwarderInDisplayOrder = ConvertIPAddressOrder(forwarder);

         LOG(String::format(
                L"Setting forwarder from forwarder regkey: %1",
                IPAddressToString(forwarderInDisplayOrder).c_str()));

         DNS_STATUS error = ::DnssrvResetForwarders(
                               L"localhost",
                               1,
                               &forwarder,
                               DNS_DEFAULT_FORWARD_TIMEOUT,
                               DNS_DEFAULT_SLAVE);

         if (error != 0)
         {
            LOG(String::format(
                   L"Failed to set the forwarder: error = 0x%1!x!",
                   error));

            CYS_APPEND_LOG(String::load(IDS_EXPRESS_REBOOT_FORWARDER_FAILED));

            result = false;
            break;
         }

         CYS_APPEND_LOG(
            String::format(
               IDS_EXPRESS_REBOOT_FORWARDER_SUCCEEDED,
               IPAddressToString(forwarderInDisplayOrder).c_str()));
      }
      else if (autoForwarderResult &&
               !autoForwarder.empty())
      {
         LOG(String::format(
                L"Setting forwarder from autoforwarder regkey: %1",
                autoForwarder.c_str()));

         // Now parse the forwarders string into a DWORD array

         StringList forwardersList;
         autoForwarder.tokenize(std::back_inserter(forwardersList));

         DWORD count = 0;
         DWORD* forwarderArray = StringIPListToDWORDArray(forwardersList, count);
         if (forwarderArray)
         {
            DNS_STATUS error = ::DnssrvResetForwarders(
                                 L"localhost",
                                 count,
                                 forwarderArray,
                                 DNS_DEFAULT_FORWARD_TIMEOUT,
                                 DNS_DEFAULT_SLAVE);

            // Delete the memory returned from StringIPListToDWORDArray

            delete[] forwarderArray;
            forwarderArray = 0;

            // Check for errors

            if (error != 0)
            {
               LOG(String::format(
                     L"Failed to set the forwarder: error = 0x%1!x!",
                     error));

               CYS_APPEND_LOG(String::load(IDS_EXPRESS_REBOOT_FORWARDER_FAILED));

               result = false;
               break;
            }
         }
      }
      else
      {
         // Since the regkey wasn't set that means we should try
         // to take the forwarders from the NICs defined server list

         IPAddressList forwarders;
         InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().GetForwarders(forwarders);

         if (forwarders.empty())
         {
            LOG(L"No DNS servers set on any NIC");

            CYS_APPEND_LOG(String::load(IDS_EXPRESS_REBOOT_FORWARDER_FAILED));

            result = false;
            break;
         }

         // This is an exception throwing new so there is no
         // reason to check for NULL

         DWORD forwardersCount = static_cast<DWORD>(forwarders.size());
         DWORD* forwardersArray = new DWORD[forwardersCount];

         // Copy the forwarders addresses into the array

         for (DWORD idx = 0; idx < forwardersCount; ++idx)
         {
            // The IP address must be in network order (d.c.b.a) not in the UI
            // order (a.b.c.d)

            forwardersArray[idx] = ConvertIPAddressOrder(forwarders[idx]);
         }

         // Now set the forwarders in the DNS server

         DNS_STATUS error = ::DnssrvResetForwarders(
                               L"localhost",
                               forwardersCount,
                               forwardersArray,
                               DNS_DEFAULT_FORWARD_TIMEOUT,
                               DNS_DEFAULT_SLAVE);

         // Delete the allocated array

         delete[] forwardersArray;
         forwardersArray = 0;

         // Check for errors

         if (error != 0)
         {
            LOG(String::format(
                   L"Failed to set the forwarders: error = 0x%1!x!",
                   error));

            CYS_APPEND_LOG(String::load(IDS_EXPRESS_REBOOT_FORWARDER_FAILED));

            result = false;
            break;
         }

         CYS_APPEND_LOG(
            String::format(
               IDS_EXPRESS_REBOOT_FORWARDER_SUCCEEDED,
               IPAddressToString(ConvertIPAddressOrder(forwardersArray[0])).c_str()));
      }

   } while (false);

   LOG_BOOL(result);
   return result;
}

void _cdecl
wrapperThreadProc(void* p)
{
   if (!p)
   {
      ASSERT(p);
      return;
   }

   bool result = true;

   ExpressRebootPage* page =
      reinterpret_cast<ExpressRebootPage*>(p);
   ASSERT(page);

   HWND hwnd = page->GetHWND();

   // Create the log file

   bool logFileAvailable = false;
   String logName;
   HANDLE logfileHandle = AppendLogFile(
                             CYS_LOGFILE_NAME, 
                             logName);
   if (logfileHandle &&
       logfileHandle != INVALID_HANDLE_VALUE)
   {
      LOG(String::format(L"New log file was created: %1", logName.c_str()));
      logFileAvailable = true;
   }
   else
   {
      LOG(L"Unable to create the log file!!!");
      logFileAvailable = false;
   }

   ExpressInstallationUnit& expressInstallationUnit =
      InstallationUnitProvider::GetInstance().GetExpressInstallationUnit();

   // NTRAID#NTBUG9-638337-2002/06/13-JeffJon
   // Need to compare the IP address that was written to the registry
   // to the current IP address to see if they are the same

   String currentIPAddress;
   
   NetworkInterface* localNIC = 
      State::GetInstance().GetLocalNICFromRegistry();

   if (localNIC)
   {
      // Set the static text for the IP Address

      currentIPAddress =
         localNIC->GetStringIPAddress(0);
   }

   String attemptedIPAddress = page->GetIPAddressString();

   if (attemptedIPAddress.icompare(currentIPAddress) == 0)
   {
      LOG(L"The current IP address and the IP address from the registry match");

      Win::SendMessage(
         hwnd, 
         ExpressRebootPage::CYS_OPERATION_FINISHED_SUCCESS,
         (WPARAM)ExpressRebootPage::CYS_OPERATION_SET_STATIC_IP,
         (LPARAM)ExpressRebootPage::CYS_OPERATION_SERVER_DHCP);
   }
   else
   {
      // Since the IP addresses didn't match we have to show the error
      // Most likely this was caused by another machine coming up on the
      // network with the same IP as we set before the reboot.

      LOG(L"Failed to set the static IP address.");

      Win::SendMessage(
         hwnd, 
         ExpressRebootPage::CYS_OPERATION_FINISHED_FAILED,
         (WPARAM)ExpressRebootPage::CYS_OPERATION_SET_STATIC_IP,
         (LPARAM)ExpressRebootPage::CYS_OPERATION_SERVER_DHCP);
   }

   if (!page->WasDHCPInstallAttempted() ||
       InstallationUnitProvider::GetInstance().
          GetDHCPInstallationUnit().IsServiceInstalled())
   {
      Win::SendMessage(
         hwnd, 
         ExpressRebootPage::CYS_OPERATION_FINISHED_SUCCESS,
         (WPARAM)ExpressRebootPage::CYS_OPERATION_SERVER_DHCP,
         (LPARAM)ExpressRebootPage::CYS_OPERATION_SERVER_AD);
   }
   else
   {
      Win::SendMessage(
         hwnd, 
         ExpressRebootPage::CYS_OPERATION_FINISHED_FAILED,
         (WPARAM)ExpressRebootPage::CYS_OPERATION_SERVER_DHCP,
         (LPARAM)ExpressRebootPage::CYS_OPERATION_SERVER_AD);

      if (result)
      {
         expressInstallationUnit.SetExpressRoleResult(
            ExpressInstallationUnit::EXPRESS_DHCP_INSTALL_FAILURE);
      }
      result = false;
   }

   // Verify the machine is a DC

   // Check to see if DCPromo was successful in making this a DC

   if (State::GetInstance().IsDC())
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_DCPROMO_REBOOT_SUCCEEDED));

      // Log the new domain name

      CYS_APPEND_LOG(String::load(IDS_EXPRESS_SERVER_AD));
      CYS_APPEND_LOG(
         String::format(
            IDS_EXPRESS_AD_DOMAIN_NAME,
            State::GetInstance().GetDomainDNSName().c_str()));

      CYS_APPEND_LOG(
         String::format(
            IDS_EXPRESS_AD_NETBIOS_NAME,
            State::GetInstance().GetDomainNetbiosName().c_str()));


      Win::SendMessage(
         hwnd, 
         ExpressRebootPage::CYS_OPERATION_FINISHED_SUCCESS,
         (WPARAM)ExpressRebootPage::CYS_OPERATION_SERVER_AD,
         (LPARAM)ExpressRebootPage::CYS_OPERATION_SERVER_DNS);
   }
   else
   {
      LOG(L"DCPromo failed on reboot");

      CYS_APPEND_LOG(String::load(IDS_LOG_DCPROMO_REBOOT_FAILED));

      Win::SendMessage(
         hwnd, 
         ExpressRebootPage::CYS_OPERATION_FINISHED_FAILED,
         (WPARAM)ExpressRebootPage::CYS_OPERATION_SERVER_AD,
         (LPARAM)ExpressRebootPage::CYS_OPERATION_SERVER_DNS);

      // Only override the role result if it hasn't already been set

      if (result)
      {
         expressInstallationUnit.SetExpressRoleResult(
            ExpressInstallationUnit::EXPRESS_AD_FAILURE);
      }
      result = false;
   }

   // DNS is now the current operation, check to see if it is installed

   if (InstallationUnitProvider::GetInstance().
          GetDNSInstallationUnit().IsServiceInstalled())
   {
      CYS_APPEND_LOG(String::load(IDS_EXPRESS_REBOOT_DNS_SERVER_SUCCEEDED));

      Win::SendMessage(
         hwnd, 
         ExpressRebootPage::CYS_OPERATION_FINISHED_SUCCESS,
         (WPARAM)ExpressRebootPage::CYS_OPERATION_SERVER_DNS,
         (LPARAM)ExpressRebootPage::CYS_OPERATION_SET_DNS_FORWARDER);

      if (page->SetForwarder())
      {
         // Now wait for the service to start before trying to set the forwarders

         NTService serviceObject(CYS_DNS_SERVICE_NAME);

         HRESULT hr = serviceObject.WaitForServiceState(SERVICE_RUNNING);

         if (SUCCEEDED(hr))
         {

            if (SetDNSForwarder(logfileHandle))
            {
               Win::SendMessage(
                  hwnd, 
                  ExpressRebootPage::CYS_OPERATION_FINISHED_SUCCESS,
                  (WPARAM)ExpressRebootPage::CYS_OPERATION_SET_DNS_FORWARDER,
                  (LPARAM)ExpressRebootPage::CYS_OPERATION_ACTIVATE_DHCP_SCOPE);
            }
            else
            {
               Win::SendMessage(
                  hwnd, 
                  ExpressRebootPage::CYS_OPERATION_FINISHED_FAILED,
                  (WPARAM)ExpressRebootPage::CYS_OPERATION_SET_DNS_FORWARDER,
                  (LPARAM)ExpressRebootPage::CYS_OPERATION_ACTIVATE_DHCP_SCOPE);

               expressInstallationUnit.SetExpressRoleResult(
                  ExpressInstallationUnit::EXPRESS_DNS_FORWARDER_FAILURE);

               result = false;
            }
         }
         else
         {
            LOG(L"The DNS service never started!");

            Win::SendMessage(
               hwnd, 
               ExpressRebootPage::CYS_OPERATION_FINISHED_FAILED,
               (WPARAM)ExpressRebootPage::CYS_OPERATION_SET_DNS_FORWARDER,
               (LPARAM)ExpressRebootPage::CYS_OPERATION_ACTIVATE_DHCP_SCOPE);

            expressInstallationUnit.SetExpressRoleResult(
               ExpressInstallationUnit::EXPRESS_DNS_FORWARDER_FAILURE);

            result = false;
         }
      }
      else
      {
         CYS_APPEND_LOG(String::load(IDS_EXPRESS_REBOOT_LOG_NO_FORWARDER));

         Win::SendMessage(
            hwnd, 
            ExpressRebootPage::CYS_OPERATION_FINISHED_SUCCESS,
            (WPARAM)ExpressRebootPage::CYS_OPERATION_SET_DNS_FORWARDER,
            (LPARAM)ExpressRebootPage::CYS_OPERATION_ACTIVATE_DHCP_SCOPE);
      }
   }
   else
   {
      CYS_APPEND_LOG(String::load(IDS_EXPRESS_REBOOT_DNS_SERVER_FAILED));

      Win::SendMessage(
         hwnd, 
         ExpressRebootPage::CYS_OPERATION_FINISHED_FAILED,
         (WPARAM)ExpressRebootPage::CYS_OPERATION_SERVER_DNS,
         (LPARAM)ExpressRebootPage::CYS_OPERATION_SET_DNS_FORWARDER);

      // If the DNS service isn't installed there is no way to set a
      // forwarder

      Win::SendMessage(
         hwnd, 
         ExpressRebootPage::CYS_OPERATION_FINISHED_FAILED,
         (WPARAM)ExpressRebootPage::CYS_OPERATION_SET_DNS_FORWARDER,
         (LPARAM)ExpressRebootPage::CYS_OPERATION_ACTIVATE_DHCP_SCOPE);

      // Only override the role result if it hasn't already been set

      if (result)
      {
         expressInstallationUnit.SetExpressRoleResult(
            ExpressInstallationUnit::EXPRESS_DNS_SERVER_FAILURE);
      }
      result = false;
   }

   // Verify DHCP scope activation

   Win::SendMessage(
      hwnd, 
      ExpressRebootPage::CYS_OPERATION_FINISHED_SUCCESS,
      (WPARAM)ExpressRebootPage::CYS_OPERATION_ACTIVATE_DHCP_SCOPE,
      (LPARAM)ExpressRebootPage::CYS_OPERATION_AUTHORIZE_DHCP_SERVER);

      // Authorize the DHCP server

   String dnsName = Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

   if (page->WasDHCPInstallAttempted())
   {
      if (InstallationUnitProvider::GetInstance().GetDHCPInstallationUnit().AuthorizeDHCPServer(dnsName))
      {
         LOG(L"DHCP server successfully authorized");

         CYS_APPEND_LOG(String::load(IDS_LOG_DHCP_AUTHORIZATION_SUCCEEDED));

         Win::SendMessage(
            hwnd, 
            ExpressRebootPage::CYS_OPERATION_FINISHED_SUCCESS,
            (WPARAM)ExpressRebootPage::CYS_OPERATION_AUTHORIZE_DHCP_SERVER,
            (LPARAM)ExpressRebootPage::CYS_OPERATION_CREATE_TAPI_PARTITION);
      }
      else
      {
         LOG(L"DHCP scope authorization failed");

         String failureMessage = String::load(IDS_LOG_DHCP_AUTHORIZATION_FAILED);
         CYS_APPEND_LOG(failureMessage);

         Win::SendMessage(
            hwnd, 
            ExpressRebootPage::CYS_OPERATION_FINISHED_FAILED,
            (WPARAM)ExpressRebootPage::CYS_OPERATION_AUTHORIZE_DHCP_SERVER,
            (LPARAM)ExpressRebootPage::CYS_OPERATION_CREATE_TAPI_PARTITION);

         // Only override the role result if it hasn't already been set

         if (result)
         {
            expressInstallationUnit.SetExpressRoleResult(
               ExpressInstallationUnit::EXPRESS_DHCP_ACTIVATION_FAILURE);
         }
         result = false;
      }
   }
   else
   {
      Win::SendMessage(
         hwnd, 
         ExpressRebootPage::CYS_OPERATION_FINISHED_SUCCESS,
         (WPARAM)ExpressRebootPage::CYS_OPERATION_AUTHORIZE_DHCP_SERVER,
         (LPARAM)ExpressRebootPage::CYS_OPERATION_CREATE_TAPI_PARTITION);
   }

   // Do TAPI config 

   HRESULT hr = 
      InstallationUnitProvider::GetInstance().
         GetExpressInstallationUnit().DoTapiConfig(
            State::GetInstance().GetDomainDNSName());
   if (SUCCEEDED(hr))
   {
      LOG(L"TAPI config succeeded");

      CYS_APPEND_LOG(String::load(IDS_LOG_TAPI_CONFIG_SUCCEEDED));
      CYS_APPEND_LOG(
         String::format(
            IDS_LOG_TAPI_CONFIG_SUCCEEDED_FORMAT,
            dnsName.c_str()));

      Win::SendMessage(
         hwnd, 
         ExpressRebootPage::CYS_OPERATION_FINISHED_SUCCESS,
         (WPARAM)ExpressRebootPage::CYS_OPERATION_CREATE_TAPI_PARTITION,
         (LPARAM)ExpressRebootPage::CYS_OPERATION_END);
   }
   else
   {
      LOG(L"TAPI config failed");

      CYS_APPEND_LOG(
         String::format(
            IDS_LOG_TAPI_CONFIG_FAILED_FORMAT,
            hr));

      Win::SendMessage(
         hwnd, 
         ExpressRebootPage::CYS_OPERATION_FINISHED_FAILED,
         (WPARAM)ExpressRebootPage::CYS_OPERATION_CREATE_TAPI_PARTITION,
         (LPARAM)ExpressRebootPage::CYS_OPERATION_END);

      // Only override the role result if it hasn't already been set

      if (result)
      {
         expressInstallationUnit.SetExpressRoleResult(
            ExpressInstallationUnit::EXPRESS_TAPI_FAILURE);
      }

      result = false;
   }

   // Close the log file

   Win::CloseHandle(logfileHandle);

   if (result)
   {
      Win::SendMessage(
         hwnd, 
         ExpressRebootPage::CYS_OPERATION_COMPLETE_SUCCESS,
         0,
         0);
   }
   else
   {
      Win::SendMessage(
         hwnd, 
         ExpressRebootPage::CYS_OPERATION_COMPLETE_FAILED,
         0,
         0);
   }
}
   
static PCWSTR EXPRESS_REBOOT_PAGE_HELP = L"cys.chm::/typical_setup.htm";

ExpressRebootPage::ExpressRebootPage()
   :
   dhcpInstallAttempted(true),
   setForwarder(true),
   threadDone(false),
   CYSWizardPage(
      IDD_EXPRESS_REBOOT_PAGE, 
      IDS_EXPRESS_REBOOT_TITLE,
      IDS_EXPRESS_REBOOT_SUBTITLE,
      EXPRESS_REBOOT_PAGE_HELP)
{
   LOG_CTOR(ExpressRebootPage);
}

   

ExpressRebootPage::~ExpressRebootPage()
{
   LOG_DTOR(ExpressRebootPage);
}


void
ExpressRebootPage::OnInit()
{
   LOG_FUNCTION(ExpressRebootPage::OnInit);

   CYSWizardPage::OnInit();

   // Since this page can be started directly
   // we have to be sure to set the wizard title

   Win::PropSheet_SetTitle(
      Win::GetParent(hwnd),
      0,
      String::load(IDS_WIZARD_TITLE));

   ClearOperationStates();

   Win::ShowWindow(
      Win::GetDlgItem(
         hwnd,
         IDC_EXPRESS_CONFIG_DONE_STATIC),
      false);

   // Set the range and step size for the progress bar

   Win::SendMessage(
      Win::GetDlgItem(hwnd, IDC_CONFIG_PROGRESS),
      PBM_SETRANGE,
      0,
      MAKELPARAM(CYS_OPERATION_SET_STATIC_IP, CYS_OPERATION_END));

   Win::SendMessage(
      Win::GetDlgItem(hwnd, IDC_CONFIG_PROGRESS),
      PBM_SETSTEP,
      (WPARAM)1,
      0);

   // Set the state object so that CYS doesn't run again

//   State::GetInstance().SetRerunWizard(false);

   // Initialize the state object so we can get the info to put
   // in the UI

   State::GetInstance().RetrieveMachineConfigurationInformation(
      0, 
      false,
      IDS_RETRIEVE_NIC_INFO,
      IDS_RETRIEVE_OS_INFO,
      IDS_LOCAL_AREA_CONNECTION,
      IDS_DETECTING_SETTINGS_FORMAT);

   // NTRAID#NTBUG9-638337-2002/06/13-JeffJon
   // We need to display the IP address that was written to the
   // registry before the reboot because the "local NIC" IP
   // address may have been changed if a machine was brought
   // up on the network with a duplicate IP address while we
   // were rebooting.

   if (!GetRegKeyValue(
           CYS_FIRST_DC_REGKEY,
           CYS_FIRST_DC_STATIC_IP,
           ipaddressString,
           HKEY_LOCAL_MACHINE))
   {
      LOG(L"Failed to read the regkey for the static IP address.");
   }

   String ipaddressStaticText = String::format(
                                   IDS_EXPRESS_REBOOT_IPADDRESS, 
                                   ipaddressString.c_str());

   Win::SetDlgItemText(
      hwnd, 
      IDC_IPADDRESS_STATIC, 
      ipaddressStaticText);

   // Set the static text for the DNS Forwarder

   String forwarderStaticText;
   String autoForwardersText;

   DWORD forwarder = 0;

   bool forwarderResult = GetRegKeyValue(
                             CYS_FIRST_DC_REGKEY,
                             CYS_FIRST_DC_FORWARDER,
                             forwarder);

   bool autoForwarderResult = GetRegKeyValue(
                                 CYS_FIRST_DC_REGKEY,
                                 CYS_FIRST_DC_AUTOFORWARDER,
                                 autoForwardersText);

   if (forwarderResult)
   {
      // We were able to read the fowarder regkey so the user
      // must have seen the DNS Forwarder page before the reboot

      if (forwarder != 0)
      {
         // The user entered an IP address on the DNS Forwarder page
         // before the reboot

         DWORD forwarderInDisplayOrder = ConvertIPAddressOrder(forwarder);

         forwarderStaticText = String::format(
                                    IDS_EXPRESS_REBOOT_FORWARDER,
                                    IPAddressToString(forwarderInDisplayOrder).c_str());

         LOG(String::format(
               L"Read forwarders from forwarder key: %1",
               forwarderStaticText.c_str()));
      }
      else
      {
         // The user chose not to forward when prompted on the DNS Forwarder
         // page before the reboot

         forwarderStaticText = String::load(IDS_EXPRESS_REBOOT_NO_FORWARDER);
         setForwarder = false;
      }
   }
   else if (autoForwarderResult &&
            !autoForwardersText.empty())
   {
      forwarderStaticText = String::format(
                                 IDS_EXPRESS_REBOOT_FORWARDER,
                                 autoForwardersText.c_str());

      LOG(String::format(
             L"Read forwarders from autoforwarder key: %1",
             autoForwardersText.c_str()));
   }
   else
   {
      LOG(L"Failed to read both the forwarders and autoforwarders key, using local NIC settings instead");

      // Get the DNS servers from the NICs

      IPAddressList forwarders;
      InstallationUnitProvider::GetInstance().GetDNSInstallationUnit().GetForwarders(forwarders);

      if (!forwarders.empty())
      {
         // Format the IP addresses into a string for display
         // each IP address is separated by a space
      
         String ipList;
         for (IPAddressList::iterator itr = forwarders.begin();
            itr != forwarders.end();
            ++itr)
         {
            if (!ipList.empty())
            {
               ipList += L" ";
            }

            ipList += String::format(
                        L"%1", 
                        IPAddressToString(*itr).c_str()); 
         }

         forwarderStaticText = String::format(
                                 IDS_EXPRESS_REBOOT_FORWARDER,
                                 ipList.c_str());
      }
      else
      {
         forwarderStaticText = String::load(IDS_EXPRESS_REBOOT_NO_FORWARDER);
         setForwarder = false;
      }
   }

   Win::SetDlgItemText(
      hwnd, 
      IDC_FORWARDER_STATIC, 
      forwarderStaticText);

   SetDHCPStatics();

   // Start up another thread that will perform the operations
   // and post messages back to the page to update the UI

   _beginthread(wrapperThreadProc, 0, this);
}

bool
ExpressRebootPage::OnSetActive()
{
   LOG_FUNCTION(ExpressRebootPage::OnSetActive);

   // Disable all the wizard buttons until the other
   // thread is finished

   if (threadDone)
   {
      Win::PropSheet_SetWizButtons(
         Win::GetParent(hwnd), 
         PSWIZB_NEXT);
   }
   else
   {
      Win::PropSheet_SetWizButtons(
         Win::GetParent(hwnd), 
         0);
   }

   // Disable the cancel button and the X in the upper
   // right corner

   SetCancelState(false);

   return true;
}

void
ExpressRebootPage::SetCancelState(bool enable) const
{
   LOG_FUNCTION(ExpressRebootPage::SetCancelState);

   // Set the state of the button

   Win::EnableWindow(
      Win::GetDlgItem(
         Win::GetParent(hwnd),
         IDCANCEL),
      enable);


   // Set the state of the X in the upper right corner

   HMENU menu = GetSystemMenu(GetParent(hwnd), FALSE);

   if (menu)
   {
      if (enable)
      {
         EnableMenuItem(
            menu,
            SC_CLOSE,
            MF_BYCOMMAND | MF_ENABLED);
      }
      else
      {
         EnableMenuItem(
            menu,
            SC_CLOSE,
            MF_BYCOMMAND | MF_GRAYED);
      }
   }
}

void
ExpressRebootPage::SetDHCPStatics()
{
   LOG_FUNCTION(ExpressRebootPage::SetDHCPStatics);

   DWORD dhcpInstalled = 0;
   bool regResult = GetRegKeyValue(
                       CYS_FIRST_DC_REGKEY,
                       CYS_FIRST_DC_DHCP_SERVERED,
                       dhcpInstalled,
                       HKEY_LOCAL_MACHINE);

   if (regResult && !dhcpInstalled)
   {
      dhcpInstallAttempted = false;

      // Set the static text so that users know we didn't install DHCP

      Win::SetDlgItemText(
         hwnd, 
         IDC_DHCP_STATIC, 
         String::load(IDS_EXPRESS_DHCP_NOT_REQUIRED));

      Win::SetDlgItemText(
         hwnd, 
         IDC_DHCP_SCOPE_STATIC, 
         String::load(IDS_EXPRESS_DHCP_SCOPE_NONE));

      Win::SetDlgItemText(
         hwnd, 
         IDC_AUTHORIZE_SCOPE_STATIC, 
         String::load(IDS_EXPRESS_DHCP_NO_AUTHORIZATION));
   }
   else
   {
      dhcpInstallAttempted = true;

      // Set the static text for the DHCP scopes to authorize

      String start;

      if (!GetRegKeyValue(
            CYS_FIRST_DC_REGKEY,
            CYS_FIRST_DC_SCOPE_START,
            start))

      {
         LOG(L"Failed to get the start scope regkey");
      }

      String end;

      if (!GetRegKeyValue(
            CYS_FIRST_DC_REGKEY,
            CYS_FIRST_DC_SCOPE_END,
            end))
      {
         LOG(L"Failed to get the end scope regkey");
      }

      String authorizedScopesText = String::format(
                                       IDS_EXPRESS_REBOOT_DHCP_SCOPE,
                                       start.c_str(),
                                       end.c_str());

      Win::SetDlgItemText(
         hwnd, 
         IDC_DHCP_SCOPE_STATIC, 
         authorizedScopesText);
   }
}

bool
ExpressRebootPage::OnMessage(
   UINT     message,
   WPARAM   wparam,
   LPARAM   lparam)
{
//   LOG_FUNCTION(ExpressRebootPage::OnMessage);

   bool result = false;

   CYS_OPERATION_TYPES finishedOperation = static_cast<CYS_OPERATION_TYPES>(wparam);
   CYS_OPERATION_TYPES nextOperation = static_cast<CYS_OPERATION_TYPES>(lparam);

   switch (message)
   {
      case CYS_OPERATION_FINISHED_SUCCESS:
         SetOperationState(
            OPERATION_STATE_FINISHED_SUCCESS,
            finishedOperation,
            nextOperation);

         result = true;
         break;

      case CYS_OPERATION_FINISHED_FAILED:
         SetOperationState(
            OPERATION_STATE_FINISHED_FAILED,
            finishedOperation,
            nextOperation);

         result = true;
         break;

      case CYS_OPERATION_COMPLETE_SUCCESS:
         {
            // enable the Next button

            Win::PropSheet_SetWizButtons(
               Win::GetParent(hwnd), 
               PSWIZB_NEXT);

            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd,
                  IDC_EXPRESS_CONFIG_DONE_STATIC),
               true);

            result = true;
            threadDone = true;

            InstallationUnitProvider::GetInstance().
               GetExpressInstallationUnit().SetInstallResult(INSTALL_SUCCESS);
         }
         break;

      case CYS_OPERATION_COMPLETE_FAILED:
         {
            // enable the Next button

            Win::PropSheet_SetWizButtons(
               Win::GetParent(hwnd), 
               PSWIZB_NEXT);

            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd,
                  IDC_EXPRESS_CONFIG_DONE_STATIC),
               true);

            result = true;
            threadDone = true;

            InstallationUnitProvider::GetInstance().
               GetExpressInstallationUnit().SetInstallResult(INSTALL_FAILURE);
         }
         break;

      default:
         result = 
            CYSWizardPage::OnMessage(
               message,
               wparam,
               lparam);
         break;
   }
   return result;
}

void
ExpressRebootPage::SetOperationState(
   OperationStateType  state,
   CYS_OPERATION_TYPES currentOperation,
   CYS_OPERATION_TYPES nextOperation)
{
   LOG_FUNCTION(ExpressRebootPage::SetOperationState);

   switch (state)
   {
      case OPERATION_STATE_UNKNOWN:
         if (currentOperation < CYS_OPERATION_END)
         {
            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[currentOperation].currentIconControl),
               SW_HIDE);

            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[currentOperation].checkIconControl),
               SW_HIDE);

            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[currentOperation].errorIconControl),
               SW_HIDE);
         }

         if (nextOperation < CYS_OPERATION_END)
         {
            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[nextOperation].currentIconControl),
               SW_HIDE);

            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[nextOperation].checkIconControl),
               SW_HIDE);

            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[nextOperation].errorIconControl),
               SW_HIDE);
         }
         break;

      case OPERATION_STATE_FINISHED_SUCCESS:
         if (currentOperation < CYS_OPERATION_END)
         {
            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[currentOperation].currentIconControl),
               SW_HIDE);

            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[currentOperation].errorIconControl),
               SW_HIDE);

            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[currentOperation].checkIconControl),
               SW_SHOW);
         }

         if (nextOperation < CYS_OPERATION_END)
         {
            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[nextOperation].checkIconControl),
               SW_HIDE);

            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[nextOperation].errorIconControl),
               SW_HIDE);

            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[nextOperation].currentIconControl),
               SW_SHOW);

         }

         // Update the progress bar

         Win::SendMessage(
            Win::GetDlgItem(hwnd, IDC_CONFIG_PROGRESS),
            PBM_STEPIT,
            0,
            0);

         break;

      case OPERATION_STATE_FINISHED_FAILED:
         if (currentOperation < CYS_OPERATION_END)
         {
            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[currentOperation].currentIconControl),
               SW_HIDE);

            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[currentOperation].checkIconControl),
               SW_HIDE);

            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[currentOperation].errorIconControl),
               SW_SHOW);
         }

         if (nextOperation < CYS_OPERATION_END)
         {
            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[nextOperation].checkIconControl),
               SW_HIDE);

            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[nextOperation].errorIconControl),
               SW_HIDE);

            Win::ShowWindow(
               Win::GetDlgItem(
                  hwnd, 
                  pageOperationProgress[nextOperation].currentIconControl),
               SW_SHOW);
         }
         
         // Update the progress bar

         Win::SendMessage(
            Win::GetDlgItem(hwnd, IDC_CONFIG_PROGRESS),
            PBM_STEPIT,
            0,
            0);

         break;

      default:
         // Right now I am not handling the CYS_OPERATION_COMPLETED_* messages

         break;
   }

}

void
ExpressRebootPage::ClearOperationStates()
{
   LOG_FUNCTION(ExpressRebootPage::ClearOperationStates);
   
   SetOperationState(
         OPERATION_STATE_UNKNOWN, 
         CYS_OPERATION_SET_STATIC_IP,
         CYS_OPERATION_SERVER_DHCP);

   SetOperationState(
         OPERATION_STATE_UNKNOWN, 
         CYS_OPERATION_SERVER_AD,
         CYS_OPERATION_SERVER_DNS);

   SetOperationState(
         OPERATION_STATE_UNKNOWN, 
         CYS_OPERATION_SET_DNS_FORWARDER,
         CYS_OPERATION_ACTIVATE_DHCP_SCOPE);
   
   SetOperationState(
         OPERATION_STATE_UNKNOWN,
         CYS_OPERATION_AUTHORIZE_DHCP_SERVER,
         CYS_OPERATION_CREATE_TAPI_PARTITION);
}

int
ExpressRebootPage::Validate()
{
   LOG_FUNCTION(ExpressRebootPage::Validate);

   int nextPage = IDD_FINISH_PAGE;

   return nextPage;
}

String
ExpressRebootPage::GetIPAddressString() const
{
   LOG_FUNCTION(ExpressRebootPage::GetIPAddressString);

   String result = ipaddressString;

   LOG(result);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\fileserverpage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      FileServerPage.h
//
// Synopsis:  Declares the File Server page
//            for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_FILESERVERPAGE_H
#define __CYS_FILESERVERPAGE_H

#include "CYSWizardPage.h"
#include "XBytes.h"

class FileServerPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      FileServerPage();

      // Destructor

      virtual 
      ~FileServerPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

      virtual
      bool
      OnCommand(
         HWND        windowFrom,
         unsigned    controlIDFrom,
         unsigned    code);

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


      void
      SetControlState();

   private:

      void
      UpdateQuotaControls(
         unsigned controlIDFrom,
         unsigned editboxID);

      XBytes quotaUIControls;
      XBytes warningUIControls;

      // not defined: no copying allowed
      FileServerPage(const FileServerPage&);
      const FileServerPage& operator=(const FileServerPage&);

};


#endif // __CYS_FILESERVERPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\fileserverpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      FileServerPage.cpp
//
// Synopsis:  Defines the File server page of the CYS wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "FileServerPage.h"
#include "xbytes.h"


static PCWSTR FILESERVER_PAGE_HELP = L"cys.chm::/file_server_role.htm#filesrvdiskquotas";

FileServerPage::FileServerPage()
   :
   CYSWizardPage(
      IDD_FILE_SERVER_PAGE, 
      IDS_FILE_SERVER_TITLE, 
      IDS_FILE_SERVER_SUBTITLE,
      FILESERVER_PAGE_HELP)
{
   LOG_CTOR(FileServerPage);
}

   

FileServerPage::~FileServerPage()
{
   LOG_DTOR(FileServerPage);
}


void
FileServerPage::OnInit()
{
   LOG_FUNCTION(FileServerPage::OnInit);

   CYSWizardPage::OnInit();

   // Hook up the editbox/combobox controls to their appropriate
   // XBytes class
   quotaUIControls.Initialize(
      hwnd, 
      IDC_SPACE_EDIT, 
      IDC_SPACE_COMBO, 
      0);

   warningUIControls.Initialize(
      hwnd,
      IDC_LEVEL_EDIT,
      IDC_LEVEL_COMBO,
      0);

   // unselect the "Set up default disk quotas" as the default

   Win::Button_SetCheck(
      Win::GetDlgItem(hwnd, IDC_DEFAULT_QUOTAS_CHECK),
      BST_UNCHECKED);

   SetControlState();
}


bool
FileServerPage::OnSetActive()
{
   LOG_FUNCTION(FileServerPage::OnSetActive);

   // Disable the controls based on the UI state

   SetControlState();

   return true;
}

bool
FileServerPage::OnCommand(
   HWND        /*windowFrom*/,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(FileServerPage::OnCommand);

   bool result = false;

   switch (controlIDFrom)
   {
      case IDC_DEFAULT_QUOTAS_CHECK:
         if (code == BN_CLICKED)
         {
            SetControlState();
         }
         break;

      case IDC_SPACE_COMBO:
         if (code == CBN_SELCHANGE)
         {
            quotaUIControls.OnComboNotifySelChange();
         }
         break;

      case IDC_LEVEL_COMBO:
         if (code == CBN_SELCHANGE)
         {
            warningUIControls.OnComboNotifySelChange();
         }
         break;

      case IDC_SPACE_EDIT:
         if (code == EN_UPDATE)
         {
            quotaUIControls.OnEditNotifyUpdate();
         }
         else if (code == EN_KILLFOCUS)
         {
            quotaUIControls.OnEditKillFocus();
         }
         break;

      case IDC_LEVEL_EDIT:
         if (code == EN_UPDATE)
         {
            warningUIControls.OnEditNotifyUpdate();
         }
         else if (code == EN_KILLFOCUS)
         {
            warningUIControls.OnEditKillFocus();
         }
         break;

      default:
         // do nothing
         break;
   }

   return result;
}

void
FileServerPage::SetControlState()
{
   LOG_FUNCTION(FileServerPage::SetControlState);

   bool settingQuotas = 
      Win::Button_GetCheck(
         Win::GetDlgItem(hwnd, IDC_DEFAULT_QUOTAS_CHECK));

   // enable or disable all the controls based on the Set up default quotas checkbox

   quotaUIControls.Enable(settingQuotas);
   warningUIControls.Enable(settingQuotas);

   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_SPACE_STATIC),        
      settingQuotas);

   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_LEVEL_STATIC),        
      settingQuotas);

   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_DENY_DISK_CHECK),     
      settingQuotas);

   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_EVENT_STATIC),        
      settingQuotas);

   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_DISK_SPACE_CHECK),    
      settingQuotas);

   Win::EnableWindow(
      Win::GetDlgItem(hwnd, IDC_WARNING_LEVEL_CHECK), 
      settingQuotas);

   if (!settingQuotas)
   {
      Win::Button_SetCheck(
         Win::GetDlgItem(hwnd, IDC_DENY_DISK_CHECK),
         BST_UNCHECKED);

      Win::Button_SetCheck(
         Win::GetDlgItem(hwnd, IDC_DISK_SPACE_CHECK),
         BST_UNCHECKED);

      Win::Button_SetCheck(
         Win::GetDlgItem(hwnd, IDC_WARNING_LEVEL_CHECK),
         BST_UNCHECKED);
   }

   // enable the next button if the user chose to set quotas
   // and there is something in the quota edit box

   bool spaceSet = quotaUIControls.GetBytes() > 0;

   bool enableNext = (settingQuotas && 
                      spaceSet) ||
                     !settingQuotas;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      enableNext ? PSWIZB_NEXT | PSWIZB_BACK : PSWIZB_BACK);
}


int
FileServerPage::Validate()
{
   LOG_FUNCTION(FileServerPage::Validate);

   int nextPage = -1;


   // Gather the UI data and set it in the installation unit

   FileInstallationUnit& fileInstallationUnit = 
      InstallationUnitProvider::GetInstance().GetFileInstallationUnit();

   if (Win::Button_GetCheck(
          Win::GetDlgItem(hwnd, IDC_DEFAULT_QUOTAS_CHECK)))
   {
      // We are setting the defaults

      fileInstallationUnit.SetDefaultQuotas(true);

      fileInstallationUnit.SetDenyUsersOverQuota(
         Win::Button_GetCheck(
            Win::GetDlgItem(hwnd, IDC_DENY_DISK_CHECK)));

      fileInstallationUnit.SetEventDiskSpaceLimit(
         Win::Button_GetCheck(
            Win::GetDlgItem(hwnd, IDC_DISK_SPACE_CHECK)));

      fileInstallationUnit.SetEventWarningLevel(
         Win::Button_GetCheck(
            Win::GetDlgItem(hwnd, IDC_WARNING_LEVEL_CHECK)));

      INT64 quotaValue = quotaUIControls.GetBytes();
      INT64 warningValue = warningUIControls.GetBytes();

      if (warningValue > quotaValue)
      {
         // Get the quota text and append the size

         String quotaString = 
            Win::GetDlgItemText(
               hwnd,
               IDC_SPACE_EDIT);

         quotaString += L" " +
            Win::ComboBox_GetCurText(
               Win::GetDlgItem(
                  hwnd,
                  IDC_SPACE_COMBO));

         // Get the warning text and append the size

         String warningString = 
            Win::GetDlgItemText(
               hwnd,
               IDC_LEVEL_EDIT);

         warningString += L" " +
            Win::ComboBox_GetCurText(
               Win::GetDlgItem(
                  hwnd,
                  IDC_LEVEL_COMBO));

         String warning = 
            String::format(
               IDS_FILE_WARNING_LARGER_THAN_QUOTA,
               warningString.c_str(),
               quotaString.c_str(),
               quotaString.c_str());

         if (IDYES == popup.MessageBox(
                         hwnd, 
                         warning, 
                         MB_ICONINFORMATION | MB_YESNO))
         {
            warningValue = quotaValue;
            warningUIControls.SetBytes(warningValue);
         }
      }

      fileInstallationUnit.SetSpaceQuotaValue(quotaValue);
      fileInstallationUnit.SetLevelQuotaValue(warningValue);


   }
   else
   {

      // The defaults will not be set

      fileInstallationUnit.SetDefaultQuotas(false);
   }

   nextPage = IDD_INDEXING_PAGE;

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\fileinstallationunit.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      FileInstallationUnit.h
//
// Synopsis:  Declares a FileInstallationUnit
//            This object has the knowledge for installing the
//            disk quotas and such
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_FILEINSTALLATIONUNIT_H
#define __CYS_FILEINSTALLATIONUNIT_H

#include "InstallationUnit.h"

class FileInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      FileInstallationUnit();

      // Destructor

      virtual
      ~FileInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      UnInstallReturnType
      UnInstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      InstallationReturnType
      CompletePath(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      GetMilestoneText(String& message);

      virtual
      bool
      GetUninstallMilestoneText(String& message);

      virtual
      String
      GetFinishText();

      virtual
      int
      GetWizardStart();

      virtual
      String
      GetServiceDescription();

      virtual
      void
      ServerRoleLinkSelected(int linkIndex, HWND hwnd);

      virtual
      void
      FinishLinkSelected(int inkIndex, HWND hwnd);

      void
      SetSpaceQuotaValue(LONGLONG value);

      LONGLONG
      GetSpaceQuotaValue() const { return spaceQuotaValue; }

      void
      SetLevelQuotaValue(LONGLONG value);

      LONGLONG
      GetLevelQuotaValue() const { return levelQuotaValue; }

      void
      SetDefaultQuotas(bool value);

      bool
      GetDefaultQuotas() const { return setDefaultQuotas; }

      void
      SetDenyUsersOverQuota(bool value);

      bool
      GetDenyUsersOverQuota() const { return denyUsersOverQuota; }

      void
      SetEventDiskSpaceLimit(bool value);

      bool
      GetEventDiskSpaceLimit() const { return eventDiskSpaceLimit;  }

      void
      SetEventWarningLevel(bool value);

      bool
      GetEventWarningLevel() const { return eventWarningLevel; }

      void
      SetInstallIndexingService(bool value);

      bool
      GetInstallIndexingService() const { return installIndexingService; }

   private:

      static const unsigned int FILE_SUCCESS                = 0x0;
      static const unsigned int FILE_QUOTA_FAILURE          = 0x1;
      static const unsigned int FILE_INDEXING_STOP_FAILURE  = 0x2;
      static const unsigned int FILE_INDEXING_START_FAILURE = 0x4;
      static const unsigned int FILE_NO_SHARES_FAILURE      = 0x8;

      bool
      RemoveSharedPublicFolders();

      bool
      RemoveFileManagementConsole();

      bool
      AreQuotasSet() const;

      bool
      IsFileServerConsolePresent() const;

      bool
      IsServerManagementConsolePresent() const;

      HRESULT
      GetStartMenuShortcutPath(String& startMenuShortcutPath) const;

      bool
      AddFileServerConsoleToStartMenu(HANDLE logfileHandle);

      HRESULT
      WriteDiskQuotas(HANDLE logfileHandle);

      bool
      AppendDiskQuotaText(String& message);

      bool
      AppendIndexingText(String& message);

      bool
      AppendAdminText(String& message);

      void
      RunSharedFoldersWizard(bool wait = false) const;

      LONGLONG       spaceQuotaValue;
      LONGLONG       levelQuotaValue;
      bool           setDefaultQuotas;
      bool           denyUsersOverQuota;
      bool           eventDiskSpaceLimit;
      bool           eventWarningLevel;
      bool           installIndexingService;

      unsigned int   fileRoleResult;
};

#endif // __CYS_FILEINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\fileinstallationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      FileInstallationUnit.cpp
//
// Synopsis:  Defines a FileInstallationUnit
//            This object has the knowledge for installing the
//            quotas on disk usage and such
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "FileInstallationUnit.h"
#include "InstallationUnitProvider.h"

#define INITGUIDS  // This has to be present so the the GUIDs defined
                   // in dskquota.h can be linked
#include <dskquota.h>

// Finish page help 
static PCWSTR CYS_FILE_FINISH_PAGE_HELP = L"cys.chm::/file_server_role.htm";
static PCWSTR CYS_FILE_MILESTONE_HELP = L"cys.chm::/file_server_role.htm#filesrvsummary";
static PCWSTR CYS_FILE_AFTER_FINISH_HELP = L"cys.chm::/file_server_role.htm#filesrvcompletion";

FileInstallationUnit::FileInstallationUnit() :
   spaceQuotaValue(0),
   levelQuotaValue(0),
   setDefaultQuotas(false),
   denyUsersOverQuota(false),
   eventDiskSpaceLimit(false),
   eventWarningLevel(false),
   fileRoleResult(FILE_SUCCESS),
   InstallationUnit(
      IDS_FILE_SERVER_TYPE, 
      IDS_FILE_SERVER_DESCRIPTION, 
      IDS_FILE_FINISH_TITLE,
      IDS_FILE_FINISH_UNINSTALL_TITLE,
      IDS_FILE_FINISH_MESSAGE,
      IDS_FILE_INSTALL_FAILED,
      IDS_FILE_UNINSTALL_MESSAGE,
      IDS_FILE_UNINSTALL_FAILED,
      IDS_FILE_UNINSTALL_WARNING,
      IDS_FILE_UNINSTALL_CHECKBOX,
      CYS_FILE_FINISH_PAGE_HELP,
      CYS_FILE_MILESTONE_HELP,
      CYS_FILE_AFTER_FINISH_HELP,
      FILESERVER_SERVER)
{
   LOG_CTOR(FileInstallationUnit);
}


FileInstallationUnit::~FileInstallationUnit()
{
   LOG_DTOR(FileInstallationUnit);
}

HRESULT
FileInstallationUnit::GetStartMenuShortcutPath(String& startMenuShortcutPath) const
{
   LOG_FUNCTION(FileInstallationUnit::GetStartMenuShortcutPath);

   HRESULT hr = S_OK;

   String startMenuPath;

   hr = GetAllUsersStartMenu(startMenuPath);
   if (SUCCEEDED(hr))
   {
      startMenuShortcutPath = 
         FS::AppendPath(
            startMenuPath,
            String::load(IDS_FILESERVER_ADMINTOOLS_LINK));

      LOG(String::format(
               L"Start Menu Link = %1",
               startMenuShortcutPath.c_str()));
   }

   LOG_HRESULT(hr);

   return hr;
}

bool
FileInstallationUnit::AddFileServerConsoleToStartMenu(HANDLE logfileHandle)
{
   LOG_FUNCTION(FileInstallationUnit::AddFileServerConsoleToStartMenu);

   bool result = false;

   // This actually adds the shortcut to both the start menu and 
   // the Administrative Tools menu

   String target = 
      Win::GetSystemDirectory() + L"\\filesvr.msc";

   HRESULT hr = 
      AddShortcutToAdminTools(
         target,
         IDS_FILE_CONSOLE_SHORTCUT_DESCRIPTION,
         IDS_FILESERVER_ADMINTOOLS_LINK);

   if (SUCCEEDED(hr))
   {
      result = true;
      CYS_APPEND_LOG(String::load(IDS_FILE_LOG_ADMIN_TOOLS));
   }


   LOG_BOOL(result);

   return result;
}

InstallationReturnType
FileInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(FileInstallationUnit::InstallService);

   CYS_APPEND_LOG(String::load(IDS_LOG_FILE_SERVER));

   InstallationReturnType result = INSTALL_SUCCESS;

   // Set the default disk quotas if chosen by the user

   if (setDefaultQuotas)
   {
      LOG(L"Setting default disk quotas");

      CYS_APPEND_LOG(String::load(IDS_LOG_FILE_SERVER_SET_QUOTAS));

      // Update the status text on the progress page

      UpdateInstallationProgressText(hwnd, IDS_FILE_MILESTONE_QUOTAS);

      // Now check to be sure the warning level is less than the 
      // quota level.  If its not, then log a warning

      LONGLONG quotaValue = GetSpaceQuotaValue();
      LONGLONG warningValue = GetLevelQuotaValue();

      if (warningValue > quotaValue)
      {
         CYS_APPEND_LOG(String::load(IDS_FILE_WARNING_LARGER_THAN_QUOTA));
      }

      HRESULT quotasResult = WriteDiskQuotas(logfileHandle);

      if (FAILED(quotasResult))
      {
         result = INSTALL_FAILURE;
      }
   }

   IndexingInstallationUnit& indexingInstallationUnit =
      InstallationUnitProvider::GetInstance().GetIndexingInstallationUnit();

   HRESULT indexingResult = S_OK;

   if (indexingInstallationUnit.IsServiceOn() &&
       !GetInstallIndexingService())
   {
      UpdateInstallationProgressText(hwnd, IDS_FILE_MILESTONE_INDEX_OFF);

      indexingResult = indexingInstallationUnit.StopService();
      if (SUCCEEDED(indexingResult))
      {
         LOG(L"Stop indexing service succeeded");

         CYS_APPEND_LOG(String::load(IDS_LOG_INDEXING_STOP_SUCCEEDED));
      }
      else
      {
         LOG(L"Stop indexing server failed");

         CYS_APPEND_LOG(String::load(IDS_LOG_INDEXING_STOP_FAILED));

         fileRoleResult |= FILE_INDEXING_STOP_FAILURE;

         result = INSTALL_FAILURE;
      }
   }
   else if (!indexingInstallationUnit.IsServiceOn() &&
            GetInstallIndexingService())
   {
      UpdateInstallationProgressText(hwnd, IDS_FILE_MILESTONE_INDEX_ON);

      indexingResult = indexingInstallationUnit.StartService(logfileHandle);
      if (SUCCEEDED(indexingResult))
      {
         LOG(L"Start indexing service succeeded");

         CYS_APPEND_LOG(String::load(IDS_LOG_INDEXING_START_SUCCEEDED));
      }
      else
      {
         LOG(L"Start indexing server failed");

         CYS_APPEND_LOG(String::load(IDS_LOG_INDEXING_START_FAILED));

         fileRoleResult |= FILE_INDEXING_START_FAILURE;

         result = INSTALL_FAILURE;
      }
   }

   // If not already present, add the filesvr.msc shortcut to 
   // the start menu

   if (!IsFileServerConsolePresent())
   {
      UpdateInstallationProgressText(hwnd, IDS_FILE_MILESTONE_INSTALL_FILE_CONSOLE);

      AddFileServerConsoleToStartMenu(logfileHandle);
   }

   // Run the shared folders wizard

   UpdateInstallationProgressText(hwnd, IDS_FILE_MILESTONE_RUN_SHARE_WIZARD);
   RunSharedFoldersWizard(true);

   // This checks to see if there was actually folder shared

   if (!IsServiceInstalled())
   {
      fileRoleResult |= FILE_NO_SHARES_FAILURE;
      result = INSTALL_FAILURE;

      CYS_APPEND_LOG(String::load(IDS_FILE_LOG_INSTALL_FAILURE));
   }
   else
   {
      // This overwrites the other failures because we are 
      // a file server if there is a share

      result = INSTALL_SUCCESS;

      CYS_APPEND_LOG(String::load(IDS_FILE_LOG_INSTALL_SUCCESS));
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

UnInstallReturnType
FileInstallationUnit::UnInstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(FileInstallationUnit::UnInstallService);

   UnInstallReturnType result = UNINSTALL_SUCCESS;

   CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_FILE_HEADER));

   do
   {
      UpdateInstallationProgressText(hwnd, IDS_UNINSTALL_SHARED_FOLDERS);

      if (!RemoveSharedPublicFolders())
      {
         LOG(L"Failed to remove shared folders");

         CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_FILE_SHARES_FAILURE));
   
         result = UNINSTALL_FAILURE;
         break;
      }

      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_FILE_SHARES));
      
      if (!RemoveFileManagementConsole())
      {
         // This should be a silent failure. Most likely the
         // shortcut wasn't there to remove

         LOG(L"Failed to remove file management console");
      }
   
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_FILE_CONSOLE));
      
   } while (false);
      
   LOG_UNINSTALL_RETURN(result);

   return result;
}

bool
FileInstallationUnit::RemoveFileManagementConsole()
{
   LOG_FUNCTION(FileInstallationUnit::RemoveFileManagementConsole);

   bool result = true;

   do
   {
      String adminToolsLinkPath;
      HRESULT hr = GetAdminToolsShortcutPath(
                      adminToolsLinkPath,
                      String::load(IDS_FILESERVER_ADMINTOOLS_LINK));

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to get the shortcut path for the file management console: hr = 0x%1!x!",
                hr));

         result = false;
         break;
      }

      ASSERT(!adminToolsLinkPath.empty());

      hr = Win::DeleteFile(adminToolsLinkPath);
      if (FAILED(hr))
      {
         LOG(String::format(
            L"Failed to delete the link: hr = 0x%1!x!",
            hr));

         result = false;
         break;
      }
    

   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
FileInstallationUnit::RemoveSharedPublicFolders()
{
   LOG_FUNCTION(FileInstallationUnit::RemoveSharedPublicFolders);

   bool result = true;

   SHARE_INFO_1* shareInfoArray = 0;
   NET_API_STATUS shareResult = 0;

   do
   {
      DWORD entriesRead = 0;
      DWORD totalEntries = 0;
      DWORD resumeHandle = 0;

      shareResult = NetShareEnum(
                       0,
                       1,
                       reinterpret_cast<BYTE**>(&shareInfoArray),
                       static_cast<DWORD>(-1),
                       &entriesRead,
                       &totalEntries,
                       &resumeHandle);

      if ((shareResult == ERROR_SUCCESS ||
           shareResult == ERROR_MORE_DATA) &&
          shareInfoArray)
      {
         for (
            DWORD index = 0;
            index < entriesRead;
            ++index)
         {
            // Look for only normal shares and ignore special shares
            // like C$, ADMIN$, and IPC$

            if (!IsSpecialShare(shareInfoArray[index]))
            {
               LOG(String::format(
                     L"Share found: %1",
                     shareInfoArray[index].shi1_netname));

               // Remove the share

               NET_API_STATUS shareRemovalStatus =
                  NetShareDel(
                     0,
                     shareInfoArray[index].shi1_netname,
                     0);

               if (shareRemovalStatus != NERR_Success)
               {
                  LOG(String::format(
                           L"Failed to remove the share %1 because 0x%2!x!",
                           shareInfoArray[index].shi1_netname,
                           shareRemovalStatus));

                  result = false;
                  break;
               }
            }
         }
      }
      else
      {
         LOG(String::format(
                L"NetShareEnum failed: result = %1!x!",
                shareResult));
         result = false;
      }

      if (shareInfoArray)
      {
         NetApiBufferFree(shareInfoArray);
         shareInfoArray = 0;
      }

      if (!result)
      {
         break;
      }
   } while(shareResult == ERROR_MORE_DATA);

   LOG_BOOL(result);

   return result;
}

InstallationReturnType
FileInstallationUnit::CompletePath(
   HANDLE logfileHandle,
   HWND   hwnd)
{
   LOG_FUNCTION(FileInstallationUnit::CompletePath);

   InstallationReturnType result = InstallService(logfileHandle, hwnd);

   LOG_INSTALL_RETURN(result);

   return result;
}

bool
FileInstallationUnit::AreQuotasSet() const
{
   LOG_FUNCTION(FileInstallationUnit::AreQuotasSet);

   bool result = false;

   // Check all NTFS partitions to see if quotas have been
   // turned on

   do
   {
      StringVector dl;
      HRESULT hr = FS::GetValidDrives(std::back_inserter(dl));
      if (FAILED(hr))
      {
         LOG(String::format(L"Failed to GetValidDrives: hr = %1!x!", hr));
         break;
      }

      // Loop through the list

      ASSERT(dl.size());
      for (
         StringVector::iterator i = dl.begin();
         i != dl.end();
         ++i)
      {
         // For each fixed drive that supports disk quotas read the state
         // and quota settings

         if (FS::GetFileSystemType(*i) == FS::NTFS5 &&
             Win::GetDriveType(*i) == DRIVE_FIXED )
         {
            // Create a Disk Quota Control
            // Multiple initializations of this object are not allowed so
            // I have to create a new instance each time through the loop

            SmartInterface<IDiskQuotaControl> diskQuotaControl;
            hr = diskQuotaControl.AcquireViaCreateInstance(
                    CLSID_DiskQuotaControl,
                    0,
                    CLSCTX_INPROC_SERVER,
                    IID_IDiskQuotaControl);

            if (FAILED(hr))
            {
               LOG(String::format(
                      L"Failed to create a disk quota control: hr = %1!x!",
                      hr));
               break;
            }

            hr = diskQuotaControl->Initialize(
                    i->c_str(),
                    TRUE);
            if (FAILED(hr))
            {
               LOG(String::format(
                      L"Failed to initialize disk quota COM object: hr = %1!x!",
                      hr));
               continue;
            }

            LOG(String::format(
                   L"Getting quota state on drive %1",
                   i->c_str()));

            // Check the quota state

            DWORD quotaState = 0;
            hr = diskQuotaControl->GetQuotaState(&quotaState);
            if (FAILED(hr))
            {
               LOG(String::format(
                      L"Failed to get quota state: hr = %1!x!",
                      hr));
               continue;
            }

            LOG(String::format(
                   L"Quota state = %1!x!",
                   quotaState));

            if (quotaState & DISKQUOTA_STATE_MASK)
            {
               // One of the state bits have been set which
               // means that it has been configured
               // Check to see if there is a value for the limit

               LONGLONG diskQuotaLimit;
               ZeroMemory(&diskQuotaLimit, sizeof(LONGLONG));

               hr = diskQuotaControl->GetDefaultQuotaLimit(&diskQuotaLimit);
               if (FAILED(hr))
               {
                  LOG(String::format(
                         L"Failed to get default quota limit: hr = %1!x!",
                         hr));
                  continue;
               }

               if (diskQuotaLimit > 0)
               {
                  LOG(L"Disk quota limit is greater than 0");
                  result = true;
                  break;
               }
            }
         }
      }
   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
FileInstallationUnit::AppendDiskQuotaText(String& message)
{
   LOG_FUNCTION(FileInstallationUnit::AppendDiskQuotaText);

   bool result = false;
   if (GetDefaultQuotas())
   {
      message += String::load(IDS_FILE_FINISH_DISK_QUOTAS);
      result = true;
   }

   LOG_BOOL(result);

   return result;
}

bool
FileInstallationUnit::AppendIndexingText(String& message)
{
   LOG_FUNCTION(FileInstallationUnit::AppendIndexingText);

   bool result = false;

   IndexingInstallationUnit& indexingInstallationUnit =
      InstallationUnitProvider::GetInstance().GetIndexingInstallationUnit();

   if (indexingInstallationUnit.IsServiceOn() &&
       !GetInstallIndexingService())
   {
      message += String::load(IDS_FILE_FINISH_INDEXING_OFF);
      result = true;
   }
   else if (!indexingInstallationUnit.IsServiceOn() &&
            GetInstallIndexingService())
   {
      message += String::load(IDS_FILE_FINISH_INDEXING_ON);
      result = true;
   }
   else
   {
      // nothing needs to be done since they are leaving it in the same state

      result = false;
   }

   LOG_BOOL(result);

   return result;
}

bool
FileInstallationUnit::AppendAdminText(String& message)
{
   LOG_FUNCTION(FileInstallationUnit::AppendAdminText);

   bool result = false;

   if (!IsServerManagementConsolePresent() &&
       !IsFileServerConsolePresent())
   {
      message += String::load(IDS_FILE_FINISH_SERVER_FSC);
      result = true;
   }

   LOG(message);
   LOG_BOOL(result);

   return result;
}

bool
FileInstallationUnit::GetMilestoneText(String& message)
{
   LOG_FUNCTION(FileInstallationUnit::GetMilestoneText);

   bool result = true;

   AppendDiskQuotaText(message);
   AppendIndexingText(message);
   AppendAdminText(message);

   message += String::load(IDS_FILE_SERVER_RUN_SHARE_WIZARD);

   LOG_BOOL(result);
   return result;
}

bool
FileInstallationUnit::GetUninstallMilestoneText(String& message)
{
   LOG_FUNCTION(FileInstallationUnit::GetUninstallMilestoneText);

   message = String::load(IDS_FILE_UNINSTALL_TEXT);

   LOG_BOOL(true);
   return true;
}


String
FileInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(FileInstallationUnit::GetServiceDescription);

   // Dynamically determine the string based on the availability
   // of services

   unsigned int resourceID = descriptionID;

   if (GetStatus() == STATUS_CONFIGURED)
   {
      resourceID = IDS_FILE_SERVER_DESCRIPTION_CONFIGURED;
   }
   description = String::load(resourceID);

   return description;
}


bool
FileInstallationUnit::IsFileServerConsolePresent() const
{
   LOG_FUNCTION(FileInstallationUnit::IsFileServerConsolePresent);

   bool result = false;

   String shortcutPath;
   HRESULT hr = GetAdminToolsShortcutPath(
                   shortcutPath,
                   String::load(IDS_FILESERVER_ADMINTOOLS_LINK));

   if (SUCCEEDED(hr))
   {
      result = FS::FileExists(shortcutPath);
   }

   LOG_BOOL(result);

   return result;
}

bool
FileInstallationUnit::IsServerManagementConsolePresent() const
{
   LOG_FUNCTION(FileInstallationUnit::IsServerManagementConsolePresent);

   bool result = false;

   String serverManagementConsole =
      Win::GetSystemDirectory() + L"\\administration\\servmgmt.msc";

   LOG(String::format(
          L"Server Management Console = %1",
          serverManagementConsole.c_str()));

   result = FS::FileExists(serverManagementConsole);

   LOG_BOOL(result);

   return result;
}

void
FileInstallationUnit::SetSpaceQuotaValue(LONGLONG value)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetSpaceQuotaValue,
      String::format(L"%1!I64d!", value));

   spaceQuotaValue = value;
}


void
FileInstallationUnit::SetLevelQuotaValue(LONGLONG value)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetLevelQuotaValue,
      String::format(L"%1!I64d!", value));

   levelQuotaValue = value;
}


void
FileInstallationUnit::SetDefaultQuotas(bool value)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetDefaultQuotas,
      value ? L"true" : L"false");

   setDefaultQuotas = value;
}


void
FileInstallationUnit::SetDenyUsersOverQuota(bool value)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetDenyUsersOverQuota,
      value ? L"true" : L"false");

   denyUsersOverQuota = value;
}


void
FileInstallationUnit::SetEventDiskSpaceLimit(bool value)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetEventDiskSpaceLimit,
      value ? L"true" : L"false");

   eventDiskSpaceLimit = value;
}


void
FileInstallationUnit::SetEventWarningLevel(bool value)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetEventWarningLevel,
      value ? L"true" : L"false");

   eventWarningLevel = value;
}

void
FileInstallationUnit::SetInstallIndexingService(bool value)
{
   LOG_FUNCTION2(
      FileInstallationUnit::SetInstallIndexingService,
      value ? L"true" : L"false");

   installIndexingService = value;
}


HRESULT
FileInstallationUnit::WriteDiskQuotas(HANDLE logfileHandle)
{
   LOG_FUNCTION(FileInstallationUnit::WriteDiskQuotas);

   HRESULT hr = S_OK;

   bool wasSomethingSet = false;

   do
   {
      DWORD logFlags = 0;
      logFlags |= eventDiskSpaceLimit ? DISKQUOTA_LOGFLAG_USER_LIMIT : 0;
      logFlags |= eventWarningLevel ? DISKQUOTA_LOGFLAG_USER_THRESHOLD : 0;

      DWORD quotaState = denyUsersOverQuota ? DISKQUOTA_STATE_ENFORCE : DISKQUOTA_STATE_TRACK;


      // Get a list of the valid drives

      StringVector dl;
      hr = FS::GetValidDrives(std::back_inserter(dl));
      if (FAILED(hr))
      {
         LOG(String::format(L"Failed to GetValidDrives: hr = %1!x!", hr));
         break;
      }

      // Loop through the list

      ASSERT(dl.size());
      for (
         StringVector::iterator i = dl.begin();
         i != dl.end();
         ++i)
      {
         // For each fixed drive that supports disk quotas set the new values

         if (FS::GetFileSystemType(*i) == FS::NTFS5 &&
             Win::GetDriveType(*i) == DRIVE_FIXED )
         {
            // Create a Disk Quota Control
            // Multiple initializations of this object are not allowed so
            // I have to create a new instance each time through the loop

            SmartInterface<IDiskQuotaControl> diskQuotaControl;
            hr = diskQuotaControl.AcquireViaCreateInstance(
                    CLSID_DiskQuotaControl,
                    0,
                    CLSCTX_INPROC_SERVER,
                    IID_IDiskQuotaControl);

            if (FAILED(hr))
            {
               LOG(String::format(
                      L"Failed to create a disk quota control: hr = %1!x!",
                      hr));
               break;
            }

            hr = diskQuotaControl->Initialize(
                    i->c_str(),
                    TRUE);
            if (FAILED(hr))
            {
               continue;
            }

            LOG(String::format(
                   L"Setting quotas on drive %1",
                   i->c_str()));

            // Turn on the disk quotas

            hr = diskQuotaControl->SetQuotaState(quotaState);
            if (SUCCEEDED(hr))
            {
               LOG(String::format(
                      L"Disk quota set on drive %1",
                      i->c_str()));

               CYS_APPEND_LOG(
                  String::format(
                     String::load(IDS_LOG_DISK_QUOTA_DRIVE_FORMAT),
                     i->c_str()));

               if(denyUsersOverQuota)
               {
                  LOG(L"Disk space denied to users exceeding limit");

                  CYS_APPEND_LOG(
                     String::format(
                        String::load(IDS_LOG_DISK_QUOTA_DENY_FORMAT),
                        spaceQuotaValue));
               }
               else
               {
                  LOG(L"Disk space is not denied to users exceeding limit");

                  CYS_APPEND_LOG(
                     String::format(
                        String::load(IDS_LOG_DISK_QUOTA_NOT_DENY_FORMAT),
                        spaceQuotaValue));
               }
               wasSomethingSet = true;
            }

            // Set the default quota limit

            hr = diskQuotaControl->SetDefaultQuotaLimit(spaceQuotaValue);
            if (SUCCEEDED(hr))
            {
               LOG(String::format(
                      L"Disk space limited to %1!I64d!",
                      spaceQuotaValue));

               CYS_APPEND_LOG(
                  String::format(
                     String::load(IDS_LOG_DISK_QUOTA_LIMIT_FORMAT),
                     spaceQuotaValue));

               wasSomethingSet = true;
            }

            // Set the warning level threshold

            hr = diskQuotaControl->SetDefaultQuotaThreshold(levelQuotaValue);
            if (SUCCEEDED(hr))
            {
               LOG(String::format(
                      L"Disk threshold set to %1!I64d!",
                      levelQuotaValue));

               CYS_APPEND_LOG(
                  String::format(
                     String::load(IDS_LOG_DISK_QUOTA_THRESHOLD_FORMAT),
                     levelQuotaValue));

               wasSomethingSet = true;
            }

            // Set the event flags

            hr = diskQuotaControl->SetQuotaLogFlags(logFlags);
            if (SUCCEEDED(hr))
            {
               if (eventDiskSpaceLimit)
               {
                  LOG(L"An event is logged when a user exceeds disk space limit");

                  CYS_APPEND_LOG(
                        String::load(IDS_LOG_DISK_QUOTA_LOG_LIMIT));
               }

               if (eventWarningLevel)
               {
            
                  LOG(L"An event is logged when a user exceeds the warning limit");

                  CYS_APPEND_LOG(
                        String::load(IDS_LOG_DISK_QUOTA_LOG_WARNING));
               }
               wasSomethingSet = true;
            }
         }
      }
   } while (false);

   if (FAILED(hr) && !wasSomethingSet)
   {
      CYS_APPEND_LOG(
         String::format(
            String::load(IDS_LOG_DISK_QUOTA_FAILED),
            hr));

      fileRoleResult |= FILE_QUOTA_FAILURE;
   }

   LOG(String::format(
          L"hr = %1!x!",
          hr));

   return hr;
}

int
FileInstallationUnit::GetWizardStart()
{
   LOG_FUNCTION(FileInstallationUnit::GetWizardStart);

   int nextPage = -1;

   bool installingRole = true;

   if (IsServiceInstalled())
   {
      nextPage = IDD_UNINSTALL_MILESTONE_PAGE;
      installingRole = false;
   }
   else
   {
      if (State::GetInstance().HasNTFSDrive() &&
          !AreQuotasSet())
      {
         nextPage = IDD_FILE_SERVER_PAGE;
      }
      else
      {
         nextPage = IDD_INDEXING_PAGE;
      }
   }

   SetInstalling(installingRole);

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}

void
FileInstallationUnit::ServerRoleLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      FileInstallationUnit::ServerRoleLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (IsServiceInstalled())
   {
      ASSERT(linkIndex == 0);

      LaunchMYS();
   }
   else
   {
      ASSERT(linkIndex == 0);

      LOG(L"Showing configuration help");

      ShowHelp(CYS_FILE_FINISH_PAGE_HELP);
   }
}
  
void
FileInstallationUnit::FinishLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      FileInstallationUnit::FinishLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (installing)
   {
      if (fileRoleResult & FILE_NO_SHARES_FAILURE)
      {
         if (fileRoleResult & FILE_QUOTA_FAILURE)
         {
            if (fileRoleResult & FILE_INDEXING_STOP_FAILURE ||
                fileRoleResult & FILE_INDEXING_START_FAILURE)
            {
               switch (linkIndex)
               {
                  case 0:
                     RunSharedFoldersWizard();
                     break;
                     
                  case 1:
                     LOG(L"Launch the file server management console");
                     LaunchMMCConsole(L"filesvr.msc");
                     break;

                  case 2:
                     LOG(L"Launch services snapin");
                     LaunchMMCConsole(L"services.msc");
                     break;

                  default:
                     ASSERT(false);
                     break;
               }
            }
            else
            {
               switch (linkIndex)
               {
                  case 0:
                     RunSharedFoldersWizard();
                     break;
                     
                  case 1:
                     LOG(L"Launch the file server management console");
                     LaunchMMCConsole(L"filesvr.msc");
                     break;

                  default:
                     ASSERT(false);
                     break;
               }
            }
         }
         else
         {
            if (fileRoleResult & FILE_INDEXING_STOP_FAILURE ||
                fileRoleResult & FILE_INDEXING_START_FAILURE)
            {
               switch (linkIndex)
               {
                  case 0:
                     RunSharedFoldersWizard();
                     break;
                     
                  case 1:
                     LOG(L"Launch services snapin");
                     LaunchMMCConsole(L"services.msc");
                     break;

                  default:
                     ASSERT(false);
                     break;
               }
            }
            else
            {
               ASSERT(linkIndex == 0);
               RunSharedFoldersWizard();
            }
         }
      }
      else
      {
         if (fileRoleResult & FILE_QUOTA_FAILURE)
         {
            if (fileRoleResult & FILE_INDEXING_STOP_FAILURE ||
                fileRoleResult & FILE_INDEXING_START_FAILURE)
            {
               switch (linkIndex)
               {
                  case 0:
                     LOG(L"Launch the file server management console");
                     LaunchMMCConsole(L"filesvr.msc");
                     break;

                  case 1:
                     LOG(L"Launch services snapin");
                     LaunchMMCConsole(L"services.msc");
                     break;

                  default:
                     ASSERT(false);
                     break;
               }
            }
            else
            {
               ASSERT(linkIndex == 0);
               LaunchMMCConsole(L"filesvr.msc");
            }
         }
         else
         {
            if (fileRoleResult & FILE_INDEXING_STOP_FAILURE ||
                fileRoleResult & FILE_INDEXING_START_FAILURE)
            {
               ASSERT(linkIndex == 0);
               LaunchMMCConsole(L"services.msc");
            }
            else
            {
               ASSERT(linkIndex == 0);
               LOG(L"Showing configuration help");

               ShowHelp(CYS_FILE_AFTER_FINISH_HELP);
            }
         }
      }
   }
   else
   {
      ASSERT(linkIndex == 0);

      LaunchMMCConsole(L"compmgmt.msc");
   }
}

String
FileInstallationUnit::GetFinishText()
{
   LOG_FUNCTION(FileInstallationUnit::GetFinishText);

   unsigned int messageID = finishMessageID;

   if (installing)
   {
      InstallationReturnType result = GetInstallResult();
      if (result != INSTALL_SUCCESS &&
          result != INSTALL_SUCCESS_REBOOT &&
          result != INSTALL_SUCCESS_PROMPT_REBOOT)
      {
         if (fileRoleResult & FILE_NO_SHARES_FAILURE)
         {
            if (fileRoleResult & FILE_QUOTA_FAILURE)
            {
               if (fileRoleResult & FILE_INDEXING_STOP_FAILURE)
               {
                  messageID = IDS_FILE_FINISH_NOSHARES_NOQUOTA_NOINDEXSTOP;
               }
               else if (fileRoleResult & FILE_INDEXING_START_FAILURE)
               {
                  messageID = IDS_FILE_FINISH_NOSHARES_NOQUOTA_NOINDEXSTART;
               }
               else
               {
                  messageID = IDS_FILE_FINISH_NOSHARES_NOQUOTA;
               }
            }
            else
            {
               if (fileRoleResult & FILE_INDEXING_STOP_FAILURE)
               {
                  messageID = IDS_FILE_FINISH_NOSHARES_NOINDEXSTOP;
               }
               else if (fileRoleResult & FILE_INDEXING_START_FAILURE)
               {
                  messageID = IDS_FILE_FINISH_NOSHARES_NOINDEXSTART;
               }
               else
               {
                  messageID = IDS_FILE_FINISH_NOSHARES;
               }
            }
         }
         else
         {
            if (fileRoleResult & FILE_QUOTA_FAILURE)
            {
               if (fileRoleResult & FILE_INDEXING_STOP_FAILURE)
               {
                  messageID = IDS_FILE_FINISH_NOQUOTA_NOINDEXSTOP;
               }
               else if (fileRoleResult & FILE_INDEXING_START_FAILURE)
               {
                  messageID = IDS_FILE_FINISH_NOQUOTA_NOINDEXSTART;
               }
               else
               {
                  messageID = IDS_FILE_FINISH_NOQUOTA;
               }
            }
            else
            {
               if (fileRoleResult & FILE_INDEXING_STOP_FAILURE)
               {
                  messageID = IDS_FILE_FINISH_NOINDEXSTOP;
               }
               else if (fileRoleResult & FILE_INDEXING_START_FAILURE)
               {
                  messageID = IDS_FILE_FINISH_NOINDEXSTART;
               }
               else
               {
                  messageID = IDS_FILE_INSTALL_FAILED;
               }
            }
         }
      }
   }
   else
   {
      messageID = finishUninstallMessageID;

      UnInstallReturnType result = GetUnInstallResult();
      if (result != UNINSTALL_SUCCESS &&
          result != UNINSTALL_SUCCESS_REBOOT &&
          result != UNINSTALL_SUCCESS_PROMPT_REBOOT)
      {
         messageID = finishUninstallFailedMessageID;
      }
   }

   return String::load(messageID);
}

void
FileInstallationUnit::RunSharedFoldersWizard(bool wait) const
{
   LOG_FUNCTION(FileInstallationUnit::RunSharedFoldersWizard);

   String fullPath = 
      FS::AppendPath(
         Win::GetSystemDirectory(),
         L"shrpubw.exe");

   if (wait)
   {
      DWORD exitCode = 0;

      CreateAndWaitForProcess(
         fullPath,
         String(),
         exitCode);
   }
   else
   {
      MyCreateProcess(
         fullPath,
         String());
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\finishpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      FinishPage.cpp
//
// Synopsis:  Defines the Finish Page for the CYS
//            wizard
//
// History:   02/03/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "uiutil.h"
#include "InstallationUnitProvider.h"
#include "FinishPage.h"

FinishPage::FinishPage()
   :
   WizardPage(
      IDD_FINISH_PAGE,

      // Title and subtitle are not needed on the finish page
      // so just set a bogus one that gives good logging spew
      IDS_FINISH_TITLE, 
      IDS_FINISH_SUBTITLE, 
      false, 
      true)
{
   LOG_CTOR(FinishPage);
}

   

FinishPage::~FinishPage()
{
   LOG_DTOR(FinishPage);
}


void
FinishPage::OnInit()
{
   LOG_FUNCTION(FinishPage::OnInit);

   // Since this page can be started directly
   // we have to be sure to set the wizard title

   Win::PropSheet_SetTitle(
      Win::GetParent(hwnd),
      0,
      String::load(IDS_WIZARD_TITLE));

   SetLargeFont(hwnd, IDC_BIG_BOLD_TITLE);

   // Back should never be enabled

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_FINISH);

   // Disable the cancel button because
   // there is nothing to cancel once you
   // get here

   Win::EnableWindow(
      Win::GetDlgItem(
         Win::GetParent(hwnd),
         IDCANCEL),
      false);

   // Disable the X in the top right corner

   HMENU menu = GetSystemMenu(GetParent(hwnd), FALSE);

   if (menu)
   {
      EnableMenuItem(
         menu,
         SC_CLOSE,
         MF_BYCOMMAND | MF_GRAYED);
   }

   // Get the current installation type

   InstallationUnit& currentInstallationUnit = 
      InstallationUnitProvider::GetInstance().GetCurrentInstallationUnit();

   // Get the finish text from the installation unit and put it in the finish box

   String finishTitle = 
      currentInstallationUnit.GetFinishTitle();
   
   Win::SetDlgItemText(
      hwnd, 
      IDC_BIG_BOLD_TITLE, 
      finishTitle);

   String message =
      currentInstallationUnit.GetFinishText();
   
   Win::SetDlgItemText(
      hwnd, 
      IDC_FINISH_MESSAGE, 
      message);
}

bool
FinishPage::OnSetActive()
{
   LOG_FUNCTION(FinishPage::OnSetActive);

   Win::PostMessage(
      Win::GetParent(hwnd),
      WM_NEXTDLGCTL,
      (WPARAM) Win::GetDlgItem(Win::GetParent(hwnd), Wizard::FINISH_BTN_ID),
      TRUE);

   return true;
}

bool
FinishPage::OnHelp()
{
   LOG_FUNCTION(FinishPage::OnHelp);

   InstallationUnit& currentInstallationUnit = 
      InstallationUnitProvider::GetInstance().GetCurrentInstallationUnit();

   String helpTag = 
      currentInstallationUnit.GetAfterFinishHelp();

   if (currentInstallationUnit.Installing())
   {
      InstallationReturnType result = currentInstallationUnit.GetInstallResult();
      if (result != INSTALL_SUCCESS &&
          result != INSTALL_SUCCESS_REBOOT &&
          result != INSTALL_SUCCESS_PROMPT_REBOOT)
      {
         helpTag = currentInstallationUnit.GetFinishHelp();
      }
   }
   else
   {
      helpTag = currentInstallationUnit.GetFinishHelp();

      UnInstallReturnType result = currentInstallationUnit.GetUnInstallResult();
      if (result == UNINSTALL_SUCCESS ||
          result == UNINSTALL_SUCCESS_REBOOT ||
          result == UNINSTALL_SUCCESS_PROMPT_REBOOT)
      {
         helpTag = L"cys.chm::/cys_topnode.htm";
      }
   }

   LOG(String::format(
          L"helpTag = %1",
          helpTag.c_str()));

   ShowHelp(helpTag);

   return true;
}

bool
FinishPage::OnWizFinish()
{
   LOG_FUNCTION(FinishPage::OnWizFinish);

   Win::WaitCursor wait;
   bool result = false;

   // Run the post install actions

   if (InstallationUnitProvider::GetInstance().GetCurrentInstallationUnit().Installing() ||
       (State::GetInstance().IsRebootScenario() &&
        State::GetInstance().ShouldRunMYS()))
   {
      InstallationUnitProvider::GetInstance().
         GetCurrentInstallationUnit().DoPostInstallAction(hwnd);
   }

   LOG_BOOL(result);
   Win::SetWindowLongPtr(hwnd, DWLP_MSGRESULT, result ? TRUE : FALSE);

   if (!result)
   {
      // clean up the InstallationUnits so that all the data must be re-read if
      // if CYS automatically restarts

      InstallationUnitProvider::GetInstance().Destroy();
   }

   return true;
}

bool
FinishPage::OnQueryCancel()
{
   LOG_FUNCTION(FinishPage::OnQueryCancel);

   bool result = false;

   // set the rerun state to false so the wizard doesn't
   // just restart itself

//   State::GetInstance().SetRerunWizard(false);

   Win::SetWindowLongPtr(
      hwnd,
      DWLP_MSGRESULT,
      result ? TRUE : FALSE);

   return true;
}

bool
FinishPage::OnNotify(
   HWND        /*windowFrom*/,
   UINT_PTR    controlIDFrom,
   UINT        code,
   LPARAM      lParam)
{
//   LOG_FUNCTION(FinishPage::OnCommand);
 
   bool result = false;

   if (controlIDFrom == IDC_FINISH_MESSAGE)
   {
      switch (code)
      {
         case NM_CLICK:
         case NM_RETURN:
         {
            int linkIndex = LinkIndexFromNotifyLPARAM(lParam);
            InstallationUnitProvider::GetInstance().
               GetCurrentInstallationUnit().FinishLinkSelected(linkIndex, hwnd);
         }
         default:
         {
            // do nothing
            
            break;
         }
      }
   }
   else if (controlIDFrom == IDC_LOG_STATIC)
   {
      switch (code)
      {
         case NM_CLICK:
         case NM_RETURN:
         {
            ::OpenLogFile();
         }
         default:
            break;
      }
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\finishpage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      FinishPage.h
//
// Synopsis:  Declares the Finish Page for the CYS
//            wizard
//
// History:   02/03/2001  JeffJon Created

#ifndef __CYS_FINISHPAGE_H
#define __CYS_FINISHPAGE_H


class FinishPage : public WizardPage
{
   public:
      
      // Constructor
      
      FinishPage();

      // Destructor

      virtual 
      ~FinishPage();


   protected:

      // Dialog overrides

      virtual
      void
      OnInit();

      virtual
      bool
      OnSetActive();

      // PropertyPage overrides

      virtual
      bool
      OnWizFinish();

      virtual
      bool
      OnHelp();

      virtual
      bool
      OnQueryCancel();

      bool
      OnNotify(
         HWND        windowFrom,
         UINT_PTR    controlIDFrom,
         UINT        code,
         LPARAM      lParam);

   private:

      void
      OpenLogFile(const String& logName);

      void
      TimeStampTheLog(HANDLE logfileHandle);

      // not defined: no copying allowed
      FinishPage(const FinishPage&);
      const FinishPage& operator=(const FinishPage&);

};

#endif // __CYS_FINISHPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\indexinginstallationunit.cpp ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      IndexingInstallationUnit.cpp
//
// Synopsis:  Defines a IndexingInstallationUnit
//            This object has the knowledge for installing the
//            indexing service
//
// History:   03/20/2002  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "IndexingInstallationUnit.h"
#include "InstallationUnitProvider.h"

#include <ciodm.h>

IndexingInstallationUnit::IndexingInstallationUnit() :
   InstallationUnit(
      0, 
      0, 
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      String(),
      String(),
      String(),
      INDEXING_SERVICE)
{
   LOG_CTOR(IndexingInstallationUnit);
}


IndexingInstallationUnit::~IndexingInstallationUnit()
{
   LOG_DTOR(IndexingInstallationUnit);
}

InstallationReturnType
IndexingInstallationUnit::InstallService(HANDLE /*logfileHandle*/, HWND /*hwnd*/)
{
   LOG_FUNCTION(IndexingInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   String unattendFileText;
   String infFileText;

   unattendFileText += L"[Components]\n";
   unattendFileText += L"indexsrv_system=ON\n";

   bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
   if (ocmResult &&
       IsServiceOn())
   {
      LOG(L"Indexing service installed successfully");
   }
   else
   {
      LOG(L"Failed to install the indexing service");

      result = INSTALL_FAILURE;
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

UnInstallReturnType
IndexingInstallationUnit::UnInstallService(HANDLE /*logfileHandle*/, HWND /*hwnd*/)
{
   LOG_FUNCTION(IndexingInstallationUnit::UnInstallService);

   UnInstallReturnType result = UNINSTALL_SUCCESS;

   LOG_UNINSTALL_RETURN(result);

   return result;
}


bool
IndexingInstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(IndexingInstallationUnit::IsServiceInstalled);

   bool result = false;

   // If we can instantiate the indexing server COM object
   // then the indexing service is installed

   do
   {
      CLSID clsid;
      HRESULT hr = CLSIDFromProgID( L"Microsoft.ISAdm", &clsid );
      if (FAILED(hr))
      {
         LOG(String::format(
                  L"Failed to get the CLSID from ProgID: hr = 0x%x",
                  hr));
         break;
      }

      SmartInterface<IAdminIndexServer> adminIndexServer;
      hr = adminIndexServer.AcquireViaCreateInstance(
               clsid,
               0,
               CLSCTX_INPROC_SERVER);

      if (SUCCEEDED(hr))
      {
         result = true;
      }
      else
      {
         LOG(String::format(
                L"Failed to CreateInstance the indexing COM object: hr = 0x%1!x!",
                hr));
      }

   } while (false);

   LOG_BOOL(result);

   return result;
}


HRESULT
IndexingInstallationUnit::StartService(HANDLE logfileHandle)
{
   LOG_FUNCTION(IndexingInstallationUnit::StartService);

   HRESULT hr = S_OK;
   
   do
   {
      if (!IsServiceInstalled())
      {
         InstallationReturnType installResult =
            InstallService(logfileHandle, 0);

         if (installResult != INSTALL_SUCCESS)
         {
            LOG(L"Failed to install the indexing service");
            hr = Win32ToHresult(ERROR_SERVICE_DOES_NOT_EXIST);
            break;
         }
      }

      // Since the Indexing service is no longer SERVICE_DEMAND_START we
      // we have to change the service config from SERVICE_DISABLED to
      // SERVICE_AUTO_START.

      hr = ChangeServiceConfigToAutoStart();
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to enable the indexing service: hr = 0x%1!x!",
                hr));
         break;
      }

      hr = ModifyIndexingService(true);
   } while (false);

   LOG_HRESULT(hr);

   return hr;
}

HRESULT
IndexingInstallationUnit::StopService()
{
   LOG_FUNCTION(IndexingInstallationUnit::StopService);

   HRESULT hr = S_OK;

   do
   {
      hr = ModifyIndexingService(false);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to stop the indexing service: hr = 0x%1!x!",
                hr));
         break;
      }

      // Set the indexing service to disabled so that it doesn't
      // start after a reboot

      hr = ChangeServiceConfigToDisabled();
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to disable the indexing service: hr = 0x%1!x!",
                hr));
         break;
      }

   } while (false);

   LOG_HRESULT(hr);

   return hr;
}

bool
IndexingInstallationUnit::IsServiceOn()
{
   LOG_FUNCTION(IndexingInstallationUnit::IsServiceOn);

   bool result = false;

   do
   {
      CLSID clsid;
      HRESULT hr = CLSIDFromProgID( L"Microsoft.ISAdm", &clsid );
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to get the CLSID from ProgID: hr = 0x%x",
                hr));
         break;
      }

      SmartInterface<IAdminIndexServer> adminIndexServer;
      hr = adminIndexServer.AcquireViaCreateInstance(
              clsid,
              0,
              CLSCTX_INPROC_SERVER);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to CoCreateInstance of IAdminIndexServer: hr = 0x%x",
                hr));
         break;
      }

      VARIANT_BOOL var;
      hr = adminIndexServer->IsRunning(&var);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to get running state: hr = 0x%x",
                hr));
         break;
      }
      
      LOG(String::format(
             L"var = 0x%1!x!",
             var));

      result = var ? true : false;

   } while (false);

   LOG_BOOL(result);

   return result;
}

HRESULT
IndexingInstallationUnit::ModifyIndexingService(bool turnOn)
{
   LOG_FUNCTION2(
      IndexingInstallationUnit::ModifyIndexingService,
      turnOn ? L"true" : L"false");

   HRESULT hr = S_OK;

   do
   {
      CLSID clsid;
      hr = CLSIDFromProgID( L"Microsoft.ISAdm", &clsid );
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to get the CLSID from ProgID: hr = 0x%x",
                hr));
         break;
      }

      SmartInterface<IAdminIndexServer> adminIndexServer;
      hr = adminIndexServer.AcquireViaCreateInstance(
              clsid,
              0,
              CLSCTX_INPROC_SERVER);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to CoCreateInstance of IAdminIndexServer: hr = 0x%x",
                hr));
         break;
      }

      if (turnOn)
      {
         hr = adminIndexServer->Start();
      }
      else
      {
         hr = adminIndexServer->Stop();
      }

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to start or stop indexing service: hr = 0x%x",
                hr));

         break;
      }

   } while (false);

   LOG(String::format(L"hr = %1!x!", hr));

   return hr;
}

HRESULT
IndexingInstallationUnit::ChangeServiceConfigToAutoStart()
{
   LOG_FUNCTION(IndexingInstallationUnit::ChangeServiceConfigToAutoStart);

   HRESULT hr = ChangeServiceStartType(SERVICE_AUTO_START);

   LOG_HRESULT(hr);
   return hr;
}

HRESULT
IndexingInstallationUnit::ChangeServiceConfigToDisabled()
{
   LOG_FUNCTION(IndexingInstallationUnit::ChangeServiceConfigToDisabled);

   HRESULT hr = ChangeServiceStartType(SERVICE_DISABLED);

   LOG_HRESULT(hr);
   return hr;
}

HRESULT
IndexingInstallationUnit::ChangeServiceStartType(DWORD startType)
{
   LOG_FUNCTION(IndexingInstallationUnit::ChangeServiceStartType);

   HRESULT hr = S_OK;

   SC_HANDLE handle = 0;
   SC_HANDLE serviceHandle = 0;

   do
   {

      // Open the service controller

      hr = 
         Win::OpenSCManager(
            L"", 
            GENERIC_READ | GENERIC_WRITE, 
            handle);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to open service controller: hr = 0x%1!x!",
                hr));
         break;
      }

      // The indexing service name

      static const String serviceName(L"cisvc");
      
      // Open the service

      hr = 
         Win::OpenService(
            handle, 
            serviceName, 
            SERVICE_CHANGE_CONFIG, 
            serviceHandle);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to open service %1: hr = 0x%2!x!",
                serviceName.c_str(),
                hr));
         break;
      }
     
      hr =
         Win::ChangeServiceConfig(
            serviceHandle,
            SERVICE_NO_CHANGE,
            startType,
            SERVICE_NO_CHANGE,
            L"",
            L"",
            0,
            L"",
            L"",
            EncryptedString(),
            L"");

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to change service config: hr = 0x%1!x!",
                hr));
         break;
      }

   } while(false);

   // Close the service handles if necessary

   if (serviceHandle)
   {
      Win::CloseServiceHandle(serviceHandle);
   }

   if (handle)
   {
      Win::CloseServiceHandle(handle);
   }

   LOG_HRESULT(hr);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\indexinginstallationunit.h ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      IndexingInstallationUnit.h
//
// Synopsis:  Declares a IndexingInstallationUnit
//            This object has the knowledge for installing the
//            indexing service
//
// History:   03/20/2002  JeffJon Created

#ifndef __CYS_INDEXINGINSTALLATIONUNIT_H
#define __CYS_INDEXINGINSTALLATIONUNIT_H

#include "InstallationUnit.h"

class IndexingInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      IndexingInstallationUnit();

      // Destructor

      virtual
      ~IndexingInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      UnInstallReturnType
      UnInstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      IsServiceInstalled();

      virtual
      bool
      GetMilestoneText(String& /*message*/) { return true; }

      virtual
      bool
      GetUninstallMilestoneText(String& /*message*/) { return true; }

      // Public methods

      HRESULT
      StartService(HANDLE logfileHandle);

      HRESULT
      StopService();

      bool
      IsServiceOn();

   private:
   
      HRESULT
      ChangeServiceConfigToAutoStart();

      HRESULT
      ChangeServiceConfigToDisabled();

      HRESULT
      ChangeServiceStartType(DWORD startType);

      HRESULT
      ModifyIndexingService(bool turnOn);
};

#endif // __CYS_FILEINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\indexingpage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      IndexingPage.h
//
// Synopsis:  Declares the Indexing page
//            for the CYS Wizard
//
// History:   02/09/2001  JeffJon Created

#ifndef __CYS_INDEXINGPAGE_H
#define __CYS_INDEXINGPAGE_H

#include "CYSWizardPage.h"


class IndexingPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      IndexingPage();

      // Destructor

      virtual 
      ~IndexingPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // not defined: no copying allowed
      IndexingPage(const IndexingPage&);
      const IndexingPage& operator=(const IndexingPage&);

};


#endif // __CYS_INDEXINGPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\installationprogresspage.h ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      InstallationProgressPage.h
//
// Synopsis:  Declares the Installation Progress Page for the CYS
//            wizard.  This page shows the progress of the installation
//            through a progress bar and changing text
//
// History:   01/16/2002  JeffJon Created

#ifndef __CYS_SERVERATIONPROGRESSPAGE_H
#define __CYS_SERVERATIONPROGRESSPAGE_H

#include "CYSWizardPage.h"


class InstallationProgressPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      InstallationProgressPage();

      // This constructor is used by the UninstallProgressPage

      InstallationProgressPage(
         int    dialogResID,
         int    titleResID,
         int    subtitleResID);  

      // Destructor

      virtual 
      ~InstallationProgressPage();

      // These messages are sent to the page when the 
      // installation has finished.

      static const UINT CYS_THREAD_SUCCESS;
      static const UINT CYS_THREAD_FAILED;
      static const UINT CYS_THREAD_USER_CANCEL;
      static const UINT CYS_PROGRESS_UPDATE;

      typedef void (*ThreadProc) (InstallationProgressPage& page);

      // Dialog overrides

      virtual
      void
      OnInit();

      virtual
      bool
      OnMessage(
         UINT     message,
         WPARAM   wparam,
         LPARAM   lparam);

      virtual
      bool
      OnQueryCancel();

      virtual
      bool
      OnSetActive();

      virtual
      bool
      OnKillActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();

   private:

      void
      SetCancelState(bool enable);

      // not defined: no copying allowed
      InstallationProgressPage(const InstallationProgressPage&);
      const InstallationProgressPage& operator=(const InstallationProgressPage&);

};

#endif // __CYS_SERVERATIONPROGRESSPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\indexingpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      IndexingPage.cpp
//
// Synopsis:  Defines the Indexing page of the CYS wizard
//
// History:   02/09/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "IndexingPage.h"

static PCWSTR INDEXING_PAGE_HELP = L"cys.chm::/file_server_role.htm#filesrvindexing";

IndexingPage::IndexingPage()
   :
   CYSWizardPage(
      IDD_INDEXING_PAGE, 
      IDS_INDEXING_TITLE, 
      IDS_INDEXING_SUBTITLE,
      INDEXING_PAGE_HELP)
{
   LOG_CTOR(IndexingPage);
}

   

IndexingPage::~IndexingPage()
{
   LOG_DTOR(IndexingPage);
}


void
IndexingPage::OnInit()
{
   LOG_FUNCTION(IndexingPage::OnInit);

   CYSWizardPage::OnInit();

   String staticText   = String::load(IDS_INDEX_PAGE_STATIC_SERVERED);

   IndexingInstallationUnit& indexingInstallationUnit =
      InstallationUnitProvider::GetInstance().GetIndexingInstallationUnit();

   if (!indexingInstallationUnit.IsServiceOn())
   {

      // The text is changed if the indexing service is off

      String yesRadioText = String::load(IDS_INDEXING_SERVICE_OFF_YES_RADIO);
      String noRadioText  = String::load(IDS_INDEXING_SERVICE_OFF_NO_RADIO);

      staticText = String::load(IDS_INDEX_PAGE_STATIC_NOT_SERVERED);

      Win::SetWindowText(
         Win::GetDlgItem(hwnd, IDC_YES_RADIO),
         yesRadioText);

      Win::SetWindowText(
         Win::GetDlgItem(hwnd, IDC_NO_RADIO),
         noRadioText);
   }

   Win::SetWindowText(
      Win::GetDlgItem(hwnd, IDC_INDEX_STATIC),
      staticText);

   // No is always the default button

   Win::Button_SetCheck(GetDlgItem(hwnd, IDC_NO_RADIO), BST_CHECKED);
}


bool
IndexingPage::OnSetActive()
{
   LOG_FUNCTION(IndexingPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}


int
IndexingPage::Validate()
{
   LOG_FUNCTION(IndexingPage::Validate);

   int nextPage = -1;

   InstallationUnitProvider::GetInstance().GetFileInstallationUnit().SetInstallIndexingService(
      Win::Button_GetCheck(
         Win::GetDlgItem(hwnd, IDC_YES_RADIO)));

   nextPage = IDD_MILESTONE_PAGE;

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\installationprogresspage.cpp ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      InstallationProgressPage.cpp
//
// Synopsis:  Defines the Installation Progress Page for the CYS
//            wizard.  This page shows the progress of the installation
//            through a progress bar and changing text
//
// History:   01/16/2002  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "InstallationProgressPage.h"

static PCWSTR PROGRESS_PAGE_HELP = L"cys.chm::/cys_topnode.htm";

InstallationProgressPage::InstallationProgressPage()
   :
   CYSWizardPage(
      IDD_PROGRESS_PAGE, 
      IDS_PROGRESS_TITLE, 
      IDS_PROGRESS_SUBTITLE, 
      0,
      false)
{
   LOG_CTOR(InstallationProgressPage);
}

InstallationProgressPage::InstallationProgressPage(
         int    dialogResID,
         int    titleResID,
         int    subtitleResID)
   :
   CYSWizardPage(
      dialogResID, 
      titleResID, 
      subtitleResID, 
      0,
      false)
{
   LOG_CTOR(InstallationProgressPage);
}
   

InstallationProgressPage::~InstallationProgressPage()
{
   LOG_DTOR(InstallationProgressPage);
}

void
TimeStampTheLog(HANDLE logfileHandle)
{
   LOG_FUNCTION(TimeStampTheLog);

   ASSERT(logfileHandle);

   SYSTEMTIME currentTime;
   ::ZeroMemory(&currentTime, sizeof(SYSTEMTIME));

   Win::GetLocalTime(currentTime);

   String date;
   HRESULT unused = Win::GetDateFormat(
                        currentTime,
                        date);
   ASSERT(SUCCEEDED(unused));

   String time;
   unused = Win::GetTimeFormat(
               currentTime,
               time);
   ASSERT(SUCCEEDED(unused));

   String logDate = String::format(
                       L"(%1 %2)\r\n",
                       date.c_str(),
                       time.c_str());

   CYS_APPEND_LOG(logDate);
}

// Private window messages for sending the state of the finished thread

const UINT InstallationProgressPage::CYS_THREAD_SUCCESS     = WM_USER + 1001;
const UINT InstallationProgressPage::CYS_THREAD_FAILED      = WM_USER + 1002;
const UINT InstallationProgressPage::CYS_THREAD_USER_CANCEL = WM_USER + 1003;
const UINT InstallationProgressPage::CYS_PROGRESS_UPDATE    = WM_USER + 1004;

void _cdecl
installationProc(void* p)
{
   if (!p)
   {
      ASSERT(p);
      return;
   }

   InstallationProgressPage* page =
      reinterpret_cast<InstallationProgressPage*>(p);

   if (!page)
   {
      ASSERT(page);
      return;
   }

   unsigned int finishMessage = InstallationProgressPage::CYS_THREAD_SUCCESS;
   
   // Initialize COM for this thread

   HRESULT hr = ::CoInitialize(0);
   if (FAILED(hr))
   {
      ASSERT(SUCCEEDED(hr));
      return;
   }

   // Open the log file and pass the handle to the installation unit

   // Create the log file

   bool logFileAvailable = false;
   String logName;
   HANDLE logfileHandle = AppendLogFile(
                             CYS_LOGFILE_NAME, 
                             logName);
   if (logfileHandle &&
       logfileHandle != INVALID_HANDLE_VALUE)
   {
      LOG(String::format(L"New log file was created: %1", logName.c_str()));
      logFileAvailable = true;

      // Time stamp the log

      TimeStampTheLog(logfileHandle);
   }
   else
   {
      LOG(L"Unable to create the log file!!!");
      logFileAvailable = false;
   }

   // Install the current Installation Unit.  This may be one or more services depending on the
   // path that was taken through the wizard

   InstallationUnit& installationUnit = 
      InstallationUnitProvider::GetInstance().GetCurrentInstallationUnit();

   // NTRAID#NTBUG-604592-2002/04/23-JeffJon-I am calling Installing here
   // instead of IsServiceInstalled so that we perform the action that
   // the user selected on the role selection page. The state of
   // IsServiceInstalled could have changed since they hit Next on that
   // page.

   if (!installationUnit.Installing())
   {
      UnInstallReturnType uninstallResult =
         installationUnit.UnInstallService(logfileHandle, page->GetHWND());

      // Set the uninstall result so that the finish page can read it

      installationUnit.SetUninstallResult(uninstallResult);

      if (UNINSTALL_SUCCESS == uninstallResult)
      {
         LOG(L"Service uninstalled successfully");
      }                                                           
      else if (UNINSTALL_NO_CHANGES == uninstallResult)
      {
         LOG(L"No changes");
         LOG(L"Not logging results");
      }
      else if (UNINSTALL_SUCCESS_REBOOT == uninstallResult)
      {
         LOG(L"Service uninstalled successfully");
         LOG(L"Not logging results because reboot was initiated");
      }
      else if (UNINSTALL_SUCCESS_PROMPT_REBOOT == uninstallResult)
      {
         LOG(L"Service uninstalled successfully");
         LOG(L"Prompting user to reboot");

         if (-1 == SetupPromptReboot(
                     0,
                     page->GetHWND(),
                     FALSE))
         {
            LOG(String::format(
                  L"Failed to reboot: hr = %1!x!",
                  Win::GetLastErrorAsHresult()));
         }

         // At this point the system should be shutting down
         // so don't do anything else

      }
      else
      {
         LOG(L"Service failed to uninstall");
      }

      // Add an additional line at the end of the log file
      // only if we are not rebooting.  All the reboot
      // scenarios require additional logging to the same
      // entry.

      if (uninstallResult != UNINSTALL_SUCCESS_REBOOT)
      {
         CYS_APPEND_LOG(L"\r\n");
      }

   }
   else
   {
      InstallationReturnType installResult =
         installationUnit.CompletePath(logfileHandle, page->GetHWND());

      // Set the installation result so that the finish
      // page can read it

      installationUnit.SetInstallResult(installResult);

      if (INSTALL_SUCCESS == installResult)
      {
         LOG(L"Service installed successfully");
      }                                                           
      else if (INSTALL_NO_CHANGES == installResult)
      {
         LOG(L"No changes");
         LOG(L"Not logging results");
      }
      else if (INSTALL_SUCCESS_REBOOT == installResult)
      {
         LOG(L"Service installed successfully");
         LOG(L"Not logging results because reboot was initiated");
      }
      else if (INSTALL_SUCCESS_PROMPT_REBOOT == installResult)
      {
         LOG(L"Service installed successfully");
         LOG(L"Prompting user to reboot");

         if (-1 == SetupPromptReboot(
                     0,
                     page->GetHWND(),
                     FALSE))
         {
            LOG(String::format(
                  L"Failed to reboot: hr = %1!x!",
                  Win::GetLastErrorAsHresult()));
         }

         // At this point the system should be shutting down
         // so don't do anything else

      }
      else
      {
         LOG(L"Service failed to install");
      }

      // Add an additional line at the end of the log file
      // only if we are not rebooting.  All the reboot
      // scenarios require additional logging to the same
      // entry.

      if (installResult != INSTALL_SUCCESS_REBOOT)
      {
         CYS_APPEND_LOG(L"\r\n");
      }
   }

   // Close the log file

   Win::CloseHandle(logfileHandle);

   Win::SendMessage(
      page->GetHWND(), 
      finishMessage,
      0,
      0);

   CoUninitialize();
}

void
InstallationProgressPage::OnInit()
{
   LOG_FUNCTION(InstallationProgressPage::OnInit);

   CYSWizardPage::OnInit();

   // Disable all the buttons on the page.  The
   // user shouldn't really be able to do anything on
   // this page.  Just sit back relax and watch the
   // installation happen.

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      0);

   SetCancelState(false);

   // Start up the animation

   Win::Animate_Open(
      Win::GetDlgItem(hwnd, IDC_ANIMATION),
      MAKEINTRESOURCE(IDR_PROGRESS_AVI));

   // Start up another thread that will perform the operations
   // and post messages back to the page to update the UI

   _beginthread(installationProc, 0, this);

}

bool
InstallationProgressPage::OnMessage(
   UINT     message,
   WPARAM   wparam,
   LPARAM   lparam)
{
//   LOG_FUNCTION(InstallationProgressPage::OnMessage);

   bool result = false;

   switch (message)
   {
      case CYS_PROGRESS_UPDATE:
         {
            String update = reinterpret_cast<PCWSTR>(wparam);

            Win::SetDlgItemText(
               hwnd,
               IDC_STEP_TEXT_STATIC,
               update);
         }
         break;

      case CYS_THREAD_USER_CANCEL:
//         shouldCancel = true;

         // fall through...

      case CYS_THREAD_SUCCESS:
      case CYS_THREAD_FAILED:
         {
            Win::Animate_Stop(Win::GetDlgItem(hwnd, IDC_ANIMATION));

            InstallationUnit& installationUnit =
               InstallationUnitProvider::GetInstance().
                  GetCurrentInstallationUnit();

            bool continueToNext = false;

            if (installationUnit.Installing())
            {
               InstallationReturnType installResult =
                  installationUnit.GetInstallResult();

               if (installResult != INSTALL_SUCCESS_REBOOT &&
                   installResult != INSTALL_SUCCESS_PROMPT_REBOOT)
               {
                  continueToNext = true;
               }
            }
            else
            {
               UnInstallReturnType uninstallResult =
                  installationUnit.GetUnInstallResult();

               if (uninstallResult != UNINSTALL_SUCCESS_REBOOT &&
                   uninstallResult != UNINSTALL_SUCCESS_PROMPT_REBOOT)
               {
                  continueToNext = true;
               }
            }

            if (continueToNext)
            {
               Win::PropSheet_PressButton(
                  Win::GetParent(hwnd),
                  PSBTN_NEXT);
            }

            result = true;
            break;
         }

      default:
         {
            result = 
               CYSWizardPage::OnMessage(
                  message,
                  wparam,
                  lparam);
            break;
         }
   }
   return result;
}

int
InstallationProgressPage::Validate()
{
   LOG_FUNCTION(InstallationProgressPage::Validate);

   int nextPage = IDD_FINISH_PAGE;

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}

bool
InstallationProgressPage::OnQueryCancel()
{
   LOG_FUNCTION(InstallationProgressPage::OnQueryCancel);

   // Don't allow cancel

   Win::SetWindowLongPtr(
      hwnd,
      DWLP_MSGRESULT,
      TRUE);

   return true;
}

bool
InstallationProgressPage::OnSetActive()
{
   LOG_FUNCTION(InstallationProgressPage::OnSetActive);

   SetCancelState(false);

   return true;
}

bool
InstallationProgressPage::OnKillActive()
{
   LOG_FUNCTION(InstallationProgressPage::OnKillActive);

   SetCancelState(true);

   return true;
}

void
InstallationProgressPage::SetCancelState(bool enable)
{
   LOG_FUNCTION(InstallationProgressPage::SetCancelState);

   // Set the state of the button

   Win::EnableWindow(
      Win::GetDlgItem(
         Win::GetParent(hwnd),
         IDCANCEL),
      enable);


   // Set the state of the X in the upper right corner

   HMENU menu = GetSystemMenu(GetParent(hwnd), FALSE);

   if (menu)
   {
      if (enable)
      {
         EnableMenuItem(
            menu,
            SC_CLOSE,
            MF_BYCOMMAND | MF_ENABLED);
      }
      else
      {
         EnableMenuItem(
            menu,
            SC_CLOSE,
            MF_BYCOMMAND | MF_GRAYED);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\installationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      InstallationUnit.cpp
//
// Synopsis:  Defines an InstallationUnit
//            An InstallationUnit represents a single
//            entity that can be installed. (i.e. DHCP, IIS, etc.)
//
// History:   02/03/2001  JeffJon Created

#include "pch.h"

#include "InstallationUnit.h"

// It should match the values in the InstallationReturnType
// The values of the enum are used to index this array

extern String installReturnTypeStrings[] =
{
   String(L"INSTALL_SUCCESS"),
   String(L"INSTALL_FAILURE"),
   String(L"INSTALL_SUCCESS_REBOOT"),
   String(L"INSTALL_SUCCESS_PROMPT_REBOOT"),
   String(L"INSTALL_SUCCESS_NEEDS_REBOOT"),
   String(L"INSTALL_FAILURE_NEEDS_REBOOT"),
   String(L"INSTALL_NO_CHANGES"),
   String(L"INSTALL_CANCELLED")
};

// It should match the values in the UnInstallReturnType
// The values of the enum are used to index this array

extern String uninstallReturnTypeStrings[] =
{
   String(L"UNINSTALL_SUCCESS"),
   String(L"UNINSTALL_FAILURE"),
   String(L"UNINSTALL_SUCCESS_REBOOT"), 
   String(L"UNINSTALL_SUCCESS_PROMPT_REBOOT"),
   String(L"UNINSTALL_SUCCESS_NEEDS_REBOOT"),
   String(L"UNINSTALL_FAILURE_NEEDS_REBOOT"),
   String(L"UNINSTALL_CANCELLED"),
   String(L"UNINSTALL_NO_CHANGES")
};

// Finish page help string

static PCWSTR FINISH_PAGE_HELP = L"cys.chm::/cys_topnode.htm";

InstallationUnit::InstallationUnit(unsigned int serviceNameID,
                                   unsigned int serviceDescriptionID,
                                   unsigned int finishPageTitleID,
                                   unsigned int finishPageUninstallTitleID,
                                   unsigned int finishPageMessageID,
                                   unsigned int finishPageInstallFailedMessageID,
                                   unsigned int finishPageUninstallMessageID,
                                   unsigned int finishPageUninstallFailedMessageID,
                                   unsigned int uninstallMilestonePageWarningID,
                                   unsigned int uninstallMilestonePageCheckboxID,
                                   const String finishPageHelpString,
                                   const String installMilestoneHelpString,
                                   const String afterFinishHelpString,
                                   ServerRole newInstallType) :
   nameID(serviceNameID),
   descriptionID(serviceDescriptionID),
   finishTitleID(finishPageTitleID),
   finishUninstallTitleID(finishPageUninstallTitleID),
   finishMessageID(finishPageMessageID),
   finishInstallFailedMessageID(finishPageInstallFailedMessageID),
   finishUninstallMessageID(finishPageUninstallMessageID),
   finishUninstallFailedMessageID(finishPageUninstallFailedMessageID),
   uninstallMilestoneWarningID(uninstallMilestonePageWarningID),
   uninstallMilestoneCheckboxID(uninstallMilestonePageCheckboxID),
   finishHelp(finishPageHelpString),
   milestoneHelp(installMilestoneHelpString),
   afterFinishHelp(afterFinishHelpString),
   role(newInstallType),
   name(),
   description(),
   installationResult(INSTALL_SUCCESS),
   uninstallResult(UNINSTALL_SUCCESS),
   installing(true)
{
}

String
InstallationUnit::GetServiceName()
{
   LOG_FUNCTION(InstallationUnit::GetServiceName);

   if (name.empty())
   {
      name = String::load(nameID);
   }

   return name;
}

String
InstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(InstallationUnit::GetServiceDescription);

   if (description.empty())
   {
      description = String::load(descriptionID);
   }

   return description;
}


String
InstallationUnit::GetFinishHelp()
{
   LOG_FUNCTION(InstallationUnit::GetFinishHelp);

   String result = finishHelp;

   LOG(result);

   return result;
}

String
InstallationUnit::GetMilestonePageHelp()
{
   LOG_FUNCTION(InstallationUnit::GetMilestonePageHelp);

   String result = milestoneHelp;

   LOG(result);

   return result;
}

String
InstallationUnit::GetAfterFinishHelp()
{
   LOG_FUNCTION(InstallationUnit::GetAfterFinishHelp);

   String result = afterFinishHelp;

   LOG(result);

   return result;
}

InstallationStatus
InstallationUnit::GetStatus()
{
   LOG_FUNCTION(InstallationUnit::GetStatus);

   InstallationStatus result = 
      GetInstallationStatusForServerRole(GetServerRole());

   LOG(statusStrings[result]);

   return result;
}

bool
InstallationUnit::IsServiceInstalled()
{
   LOG_FUNCTION(InstallationUnit::IsServiceInstalled);

   bool result = false;

   InstallationStatus status = GetInstallationStatusForServerRole(GetServerRole());
   if (status == STATUS_COMPLETED ||
       status == STATUS_CONFIGURED)
   {
      result = true;
   }

   LOG_BOOL(result);

   return result;
}

InstallationReturnType
InstallationUnit::CompletePath(
   HANDLE logfileHandle,
   HWND   hwnd)
{
   LOG_FUNCTION(InstallationUnit::CompletePath);

   return InstallService(logfileHandle, hwnd);
}

void
InstallationUnit::SetInstallResult(InstallationReturnType result)
{
   LOG_FUNCTION(InstallationUnit::SetInstallResult);

   LOG_INSTALL_RETURN(result);

   installationResult = result;
}

void
InstallationUnit::SetUninstallResult(UnInstallReturnType result)
{
   LOG_FUNCTION(InstallationUnit::SetUninstallResult);

   LOG_UNINSTALL_RETURN(result);

   uninstallResult = result;
}

InstallationReturnType
InstallationUnit::GetInstallResult() const
{
   LOG_FUNCTION(InstallationUnit::GetInstallResult);

   LOG_INSTALL_RETURN(installationResult);

   return installationResult;
}

UnInstallReturnType
InstallationUnit::GetUnInstallResult() const
{
   LOG_FUNCTION(InstallationUnit::GetUnInstallResult);

   LOG_UNINSTALL_RETURN(uninstallResult);

   return uninstallResult;
}

int
InstallationUnit::GetWizardStart()
{
   LOG_FUNCTION(InstallationUnit::GetWizardStart);

   int result = IDD_MILESTONE_PAGE;

   bool installingRole = true;
   if (IsServiceInstalled())
   {
      installingRole = false;
      result = IDD_UNINSTALL_MILESTONE_PAGE;
   }

   SetInstalling(installingRole);

   LOG(String::format(
          L"wizard start = %1!d!",
          result));

   return result;
}

void
InstallationUnit::UpdateInstallationProgressText(
   HWND hwnd,
   unsigned int messageID)
{
   LOG_FUNCTION(InstallationUnit::UpdateInstallationProgressText);

   SendMessage(
      hwnd, 
      InstallationProgressPage::CYS_PROGRESS_UPDATE, 
      (WPARAM)String::load(messageID).c_str(),
      0);
}

String
InstallationUnit::GetFinishTitle() 
{ 
   LOG_FUNCTION(InstallationUnit::GetFinishTitle);
   
   unsigned int titleID = finishTitleID;

   if (installing)
   {
      InstallationReturnType result = GetInstallResult();
      if (result != INSTALL_SUCCESS &&
          result != INSTALL_SUCCESS_REBOOT &&
          result != INSTALL_SUCCESS_PROMPT_REBOOT &&
          result != INSTALL_SUCCESS_NEEDS_REBOOT)
      {
         titleID = IDS_CANNOT_COMPLETE;
      }
   }
   else
   {
      titleID = finishUninstallTitleID;

      UnInstallReturnType result = GetUnInstallResult();
      if (result != UNINSTALL_SUCCESS &&
          result != UNINSTALL_SUCCESS_REBOOT &&
          result != UNINSTALL_SUCCESS_PROMPT_REBOOT &&
          result != UNINSTALL_SUCCESS_NEEDS_REBOOT)
      {
         titleID = IDS_CANNOT_COMPLETE;
      }
   }

   return String::load(titleID);
}

void
InstallationUnit::SetInstalling(bool installRole)
{
   LOG_FUNCTION(InstallationUnit::SetInstalling);
   LOG_BOOL(installRole);

   installing = installRole;
}

String
InstallationUnit::GetFinishText()
{
   LOG_FUNCTION(InstallationUnit::GetFinishText);

   unsigned int messageID = finishMessageID;

   if (installing)
   {
      InstallationReturnType result = GetInstallResult();
      if (result != INSTALL_SUCCESS &&
          result != INSTALL_SUCCESS_REBOOT &&
          result != INSTALL_SUCCESS_PROMPT_REBOOT)
      {
         messageID = finishInstallFailedMessageID;
      }
   }
   else
   {
      messageID = finishUninstallMessageID;

      UnInstallReturnType result = GetUnInstallResult();
      if (result != UNINSTALL_SUCCESS &&
          result != UNINSTALL_SUCCESS_REBOOT &&
          result != UNINSTALL_SUCCESS_PROMPT_REBOOT)
      {
         messageID = finishUninstallFailedMessageID;
      }
   }

   return String::load(messageID);
}

String
InstallationUnit::GetUninstallWarningText()
{
   LOG_FUNCTION(InstallationUnit::GetUninstallWarningText);

   return String::load(uninstallMilestoneWarningID);
}

String
InstallationUnit::GetUninstallCheckboxText()
{
   LOG_FUNCTION(InstallationUnit::GetUninstallCheckboxText);

   return String::load(uninstallMilestoneCheckboxID);
}


void
InstallationUnit::DoPostInstallAction(HWND)
{
   LOG_FUNCTION(InstallationUnit::DoPostInstallAction);

   if ((Installing() &&
        GetInstallResult() == INSTALL_SUCCESS) ||
        State::GetInstance().IsRebootScenario())
   {
      LaunchMYS();
   }
}

bool
InstallationUnit::DoInstallerCheck(HWND hwnd) const
{
   LOG_FUNCTION(InstallationUnit::DoInstallerCheck);

   bool result = State::GetInstance().IsWindowsSetupRunning();

   if (result)
   {
      LOG(L"Windows setup is running");

      popup.MessageBox(
         Win::GetParent(hwnd),
         IDS_WINDOWS_SETUP_RUNNING,
         MB_OK);
   }

   LOG_BOOL(result);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\installationunit.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      InstallationUnit.h
//
// Synopsis:  Declares an InstallationUnit
//            An InstallationUnit represents a single
//            entity that can be installed. (i.e. DHCP, IIS, etc.)
//
// History:   02/03/2001  JeffJon Created

#ifndef __CYS_SERVERATIONUNIT_H
#define __CYS_SERVERATIONUNIT_H

#include "pch.h"

#include "resource.h"
#include "InstallationProgressPage.h"

// These are the values that can be returned from
// InstallationUnit::InstallService()

typedef enum
{
   INSTALL_SUCCESS,
   INSTALL_FAILURE,

   // this means that there should be no 
   // logging and reboot is handled by DCPromo
   // or Terminal Services installation
   
   INSTALL_SUCCESS_REBOOT, 
   
   // this means that the finish page should
   // prompt the user to reboot

   INSTALL_SUCCESS_PROMPT_REBOOT,

   // this means that the operation requires
   // a reboot but the user chose not to reboot

   INSTALL_SUCCESS_NEEDS_REBOOT,

   // this means that the operation failed but
   // still requires a reboot and the user
   // chose not to reboot

   INSTALL_FAILURE_NEEDS_REBOOT,

   // No changes were selected while going
   // through the wizard

   INSTALL_NO_CHANGES,

   // Installation was cancelled

   INSTALL_CANCELLED

} InstallationReturnType;

// These are the values that can be returned from
// InstallationUnit::UnInstallService()

typedef enum
{
   UNINSTALL_SUCCESS,
   UNINSTALL_FAILURE,

   // this means that there should be no 
   // logging and reboot is handled by DCPromo
   // or Terminal Services installation
   
   UNINSTALL_SUCCESS_REBOOT, 
   
   // this means that the finish page should
   // prompt the user to reboot

   UNINSTALL_SUCCESS_PROMPT_REBOOT,

   // this means that the operation succeeded
   // and requires a reboot but the user chose
   // not to reboot

   UNINSTALL_SUCCESS_NEEDS_REBOOT,

   // this means that the operation failed
   // and requires a reboot but the user chose
   // not to reboot

   UNINSTALL_FAILURE_NEEDS_REBOOT,

   // Uninstall was cancelled

   UNINSTALL_CANCELLED,

   // Some installation units do not have
   // uninstalls (ie ExpressInstallationUnit)

   UNINSTALL_NO_CHANGES
} UnInstallReturnType;

// This array of strings if for the UI log debugging only
// It should match the values in the InstallationReturnType
// or UninstallReturnType
// above.  The values of the enums are used to index these arrays

extern String installReturnTypeStrings[];
extern String uninstallReturnTypeStrings[];

// These macros are used to make it easier to log the return value from
// the InstallService() and UnInstallService() methods.  It takes an
// InstallationReturnType or UnInstallReturnType and uses that to index
// the appropriate array of strings (installReturnTypeStrings or 
// uninstallReturnTypeStrings) to get a string that is then logged
// to the the UI debug logfile

#define LOG_INSTALL_RETURN(returnType)    LOG(installReturnTypeStrings[returnType]);
#define LOG_UNINSTALL_RETURN(returnType)  LOG(uninstallReturnTypeStrings[returnType]); 

class InstallationUnit
{
   public:

      // Constructor

      InstallationUnit(
         unsigned int serviceNameID,
         unsigned int serviceDescriptionID,
         unsigned int finishPageTitleID,
         unsigned int finishPageUninstallTitleID,
         unsigned int finishPageMessageID,
         unsigned int finishPageInstallFailedMessageID,
         unsigned int finishPageUninstallMessageID,
         unsigned int finishPageUninstallFailedMessageID,
         unsigned int uninstallMilestonePageWarningID,
         unsigned int uninstallMilestonePageCheckboxID,
         const String finishPageHelpString,
         const String installMilestoneHelpString,
         const String afterFinishHelpString,
         ServerRole newInstallType = NO_SERVER);

      // Destructor

      virtual
      ~InstallationUnit() {}


      // Installation virtual method

      virtual 
      InstallationReturnType 
      InstallService(HANDLE logfileHandle, HWND hwnd) = 0;

      virtual
      UnInstallReturnType
      UnInstallService(HANDLE logfileHandle, HWND hwnd) = 0;

      virtual
      InstallationReturnType
      CompletePath(HANDLE logfileHandle, HWND hwnd);

      void
      SetInstallResult(InstallationReturnType result);

      InstallationReturnType
      GetInstallResult() const;

      void
      SetUninstallResult(UnInstallReturnType result);

      UnInstallReturnType
      GetUnInstallResult() const;

      void
      SetInstalling(bool installRole);

      bool
      Installing() { return installing; }

      virtual
      void
      DoPostInstallAction(HWND);

      virtual
      InstallationStatus
      GetStatus();

      virtual
      bool
      IsServiceInstalled();

      // Return true if the installation unit will make some
      // changes during InstallService.  Return false if 
      // if it will not

      virtual
      bool
      GetMilestoneText(String& message) = 0;

      virtual
      bool
      GetUninstallMilestoneText(String& message) = 0;

      virtual
      String
      GetUninstallWarningText();

      virtual
      String
      GetUninstallCheckboxText();

      virtual
      String
      GetFinishText();

      virtual
      String
      GetFinishTitle();

      // Data accessors

      virtual
      String 
      GetServiceName(); 

      virtual
      String
      GetServiceDescription();

      virtual
      String
      GetFinishHelp();

      virtual
      String
      GetMilestonePageHelp();

      virtual
      String
      GetAfterFinishHelp();

      ServerRole
      GetServerRole() { return role; }

      virtual
      int
      GetWizardStart();

      // This is called from the CustomServerPage in response to 
      // a link in the description text being selected
      //
      //    linkIndex - the index of the link in the description
      //                as defined by the SysLink control
      //    hwnd      - HWND of the CustomServerPage

      virtual
      void
      ServerRoleLinkSelected(int /*linkIndex*/, HWND /*hwnd*/) {};

      // This is called from the FinishPage in response to 
      // a link in the message text being selected
      //
      //    linkIndex - the index of the link in the message
      //                as defined by the SysLink control
      //    hwnd      - HWND of the FinishPage

      virtual
      void
      FinishLinkSelected(int /*inkIndex*/, HWND /*hwnd*/) {};

      // This is called from the Milestone pages to see if the
      // installer is already running. The default behavior
      // is to check to see if the Windows Setup Wizard is
      // running and popup an error if it is. This function
      // will return true if the installer is already in use.
      // Override this function in the subclasses to check a
      // different installer (ie DCPromo.exe for the AD role)
      // or popup a different message.
      //
      //    hwnd - wizard page HWND

      virtual
      bool
      DoInstallerCheck(HWND hwnd) const;

   protected:

      void
      UpdateInstallationProgressText(
         HWND hwnd,
         unsigned int messageID);

      String name;
      String description;
      String finishHelp;
      String milestoneHelp;
      String afterFinishHelp;

      unsigned int nameID;
      unsigned int descriptionID;
      unsigned int finishTitleID;
      unsigned int finishUninstallTitleID;
      unsigned int finishMessageID;
      unsigned int finishInstallFailedMessageID;
      unsigned int finishUninstallMessageID;
      unsigned int finishUninstallFailedMessageID;
      unsigned int uninstallMilestoneWarningID;
      unsigned int uninstallMilestoneCheckboxID;

      bool installing;

   private:
      
      InstallationReturnType installationResult;
      UnInstallReturnType    uninstallResult;

      ServerRole role;
};


#endif // __CYS_SERVERATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\installationunitprovider.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      InstallationUnitProvider.cpp
//
// Synopsis:  Defines an InstallationUnitProvider
//            An InstallationUnitProvider manages the global
//            InstallationUnits for each service that can be
//            installed.
//
// History:   02/05/2001  JeffJon Created

#include "pch.h"

#include "InstallationUnitProvider.h"

static InstallationUnitProvider* installationUnitProvider = 0;

InstallationUnitProvider&
InstallationUnitProvider::GetInstance()
{
   if (!installationUnitProvider)
   {
      installationUnitProvider = new InstallationUnitProvider();

      installationUnitProvider->Init();
   }

   ASSERT(installationUnitProvider);

   return *installationUnitProvider;
}


InstallationUnitProvider::InstallationUnitProvider() :
   currentInstallationUnit(0),
   initialized(false)
{
   LOG_CTOR(InstallationUnitProvider);
}

InstallationUnitProvider::~InstallationUnitProvider()
{
   LOG_DTOR(InstallationUnitProvider);

   // Delete all the installation units

   for(
      InstallationUnitContainerType::iterator itr = 
         installationUnitContainer.begin();
      itr != installationUnitContainer.end();
      ++itr)
   {
      if ((*itr).second)
      {
         delete (*itr).second;
      }
   }

   installationUnitContainer.clear();
}
       
void
InstallationUnitProvider::Init()
{
   LOG_FUNCTION(InstallationUnitProvider::Init);

   if (!initialized)
   {
      // Create one of each type of installation unit

      installationUnitContainer.insert(
         std::make_pair(DHCP_SERVER, new DHCPInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(DNS_SERVER, new DNSInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(WINS_SERVER, new WINSInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(RRAS_SERVER, new RRASInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(TERMINALSERVER_SERVER, new TerminalServerInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(FILESERVER_SERVER, new FileInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(INDEXING_SERVICE, new IndexingInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(PRINTSERVER_SERVER, new PrintInstallationUnit())); 

      installationUnitContainer.insert(
         std::make_pair(MEDIASERVER_SERVER, new MediaInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(WEBAPP_SERVER, new WebInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(EXPRESS_SERVER, new ExpressInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(DC_SERVER, new ADInstallationUnit()));

      installationUnitContainer.insert(
         std::make_pair(POP3_SERVER, new POP3InstallationUnit()));

      // Mark as initialized

      initialized = true;
   }

}


void
InstallationUnitProvider::Destroy()
{
   LOG_FUNCTION(InstallationUnitProvider::Destroy);

   if (installationUnitProvider)
   {
      delete installationUnitProvider;
      installationUnitProvider = 0;
   }
}

InstallationUnit&
InstallationUnitProvider::SetCurrentInstallationUnit(
   ServerRole ServerRole)
{
   LOG_FUNCTION(InstallationUnitProvider::SetCurrentInstallationUnit);

   currentInstallationUnit = (*(installationUnitContainer.find(ServerRole))).second;

   ASSERT(currentInstallationUnit);

   return *currentInstallationUnit;
}


InstallationUnit&
InstallationUnitProvider::GetCurrentInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetCurrentInstallationUnit);

   ASSERT(currentInstallationUnit);

   return *currentInstallationUnit;
}

InstallationUnit&
InstallationUnitProvider::GetInstallationUnitForType(
   ServerRole ServerRole)
{
   LOG_FUNCTION(InstallationUnitProvider::GetInstallationUnitForType);

   InstallationUnit* result = 0;

   InstallationUnitContainerType::const_iterator itr = 
      installationUnitContainer.find(ServerRole);

   ASSERT(itr != installationUnitContainer.end());

   if (itr != installationUnitContainer.end())
   {
      result = (*itr).second;
   }

   ASSERT(result);
   return *result;
}

DHCPInstallationUnit&
InstallationUnitProvider::GetDHCPInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetDHCPInstallationUnit);

   DHCPInstallationUnit* dhcpInstallationUnit = 0;

   InstallationUnitContainerType::const_iterator itr = 
      installationUnitContainer.find(DHCP_SERVER);

   ASSERT(itr != installationUnitContainer.end());
   if (itr != installationUnitContainer.end())
   {
      dhcpInstallationUnit = dynamic_cast<DHCPInstallationUnit*>((*itr).second);
   }

   ASSERT(dhcpInstallationUnit);

   return *dhcpInstallationUnit;
}

DNSInstallationUnit&
InstallationUnitProvider::GetDNSInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetDNSInstallationUnit);

   DNSInstallationUnit* dnsInstallationUnit = 0;

   InstallationUnitContainerType::const_iterator itr = 
      installationUnitContainer.find(DNS_SERVER);

   ASSERT(itr != installationUnitContainer.end());
   if (itr != installationUnitContainer.end())
   {
      dnsInstallationUnit = dynamic_cast<DNSInstallationUnit*>((*itr).second);
   }

   ASSERT(dnsInstallationUnit);

   return *dnsInstallationUnit;
}

WINSInstallationUnit&
InstallationUnitProvider::GetWINSInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetWINSInstallationUnit);

   WINSInstallationUnit* winsInstallationUnit = 0;

   InstallationUnitContainerType::const_iterator itr = 
      installationUnitContainer.find(WINS_SERVER);

   ASSERT(itr != installationUnitContainer.end());
   if (itr != installationUnitContainer.end())
   {
      winsInstallationUnit = dynamic_cast<WINSInstallationUnit*>((*itr).second);
   }

   ASSERT(winsInstallationUnit);

   return *winsInstallationUnit;
}

RRASInstallationUnit&
InstallationUnitProvider::GetRRASInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetRRASInstallationUnit);

   RRASInstallationUnit* rrasInstallationUnit = 0;

   InstallationUnitContainerType::const_iterator itr = 
      installationUnitContainer.find(RRAS_SERVER);

   ASSERT(itr != installationUnitContainer.end());
   if (itr != installationUnitContainer.end())
   {
      rrasInstallationUnit = dynamic_cast<RRASInstallationUnit*>((*itr).second);
   }

   ASSERT(rrasInstallationUnit);

   return *rrasInstallationUnit;
}


TerminalServerInstallationUnit&
InstallationUnitProvider::GetTerminalServerInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetTerminalServerInstallationUnit);

   TerminalServerInstallationUnit* terminalServerInstallationUnit = 0;

   InstallationUnitContainerType::const_iterator itr = 
      installationUnitContainer.find(TERMINALSERVER_SERVER);

   ASSERT(itr != installationUnitContainer.end());
   if (itr != installationUnitContainer.end())
   {
      terminalServerInstallationUnit = 
         dynamic_cast<TerminalServerInstallationUnit*>((*itr).second);
   }

   ASSERT(terminalServerInstallationUnit);

   return *terminalServerInstallationUnit;
}

FileInstallationUnit&
InstallationUnitProvider::GetFileInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetFileInstallationUnit);

   FileInstallationUnit* fileInstallationUnit = 0;

   InstallationUnitContainerType::const_iterator itr = 
      installationUnitContainer.find(FILESERVER_SERVER);

   ASSERT(itr != installationUnitContainer.end());
   if (itr != installationUnitContainer.end())
   {
      fileInstallationUnit = 
         dynamic_cast<FileInstallationUnit*>((*itr).second);
   }

   ASSERT(fileInstallationUnit);

   return *fileInstallationUnit;
}

IndexingInstallationUnit&
InstallationUnitProvider::GetIndexingInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetIndexingInstallationUnit);

   IndexingInstallationUnit* indexingInstallationUnit = 0;

   InstallationUnitContainerType::const_iterator itr = 
      installationUnitContainer.find(INDEXING_SERVICE);

   ASSERT(itr != installationUnitContainer.end());
   if (itr != installationUnitContainer.end())
   {
      indexingInstallationUnit = 
         dynamic_cast<IndexingInstallationUnit*>((*itr).second);
   }

   ASSERT(indexingInstallationUnit);

   return *indexingInstallationUnit;
}

PrintInstallationUnit&
InstallationUnitProvider::GetPrintInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetPrintInstallationUnit);

   PrintInstallationUnit* printInstallationUnit = 0;

   InstallationUnitContainerType::const_iterator itr = 
      installationUnitContainer.find(PRINTSERVER_SERVER);

   ASSERT(itr != installationUnitContainer.end());
   if (itr != installationUnitContainer.end())
   {
      printInstallationUnit = 
         dynamic_cast<PrintInstallationUnit*>((*itr).second);
   }

   ASSERT(printInstallationUnit);

   return *printInstallationUnit;
}

MediaInstallationUnit&
InstallationUnitProvider::GetMediaInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetMediaInstallationUnit);

   MediaInstallationUnit* mediaInstallationUnit = 0;

   InstallationUnitContainerType::const_iterator itr = 
      installationUnitContainer.find(MEDIASERVER_SERVER);

   ASSERT(itr != installationUnitContainer.end());
   if (itr != installationUnitContainer.end())
   {
      mediaInstallationUnit = 
         dynamic_cast<MediaInstallationUnit*>((*itr).second);
   }

   ASSERT(mediaInstallationUnit);

   return *mediaInstallationUnit;
}

WebInstallationUnit&
InstallationUnitProvider::GetWebInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetWebInstallationUnit);

   WebInstallationUnit* webInstallationUnit = 0;

   InstallationUnitContainerType::const_iterator itr = 
      installationUnitContainer.find(WEBAPP_SERVER);

   ASSERT(itr != installationUnitContainer.end());
   if (itr != installationUnitContainer.end())
   {
      webInstallationUnit = 
         dynamic_cast<WebInstallationUnit*>((*itr).second);
   }

   ASSERT(webInstallationUnit);

   return *webInstallationUnit;
}

ExpressInstallationUnit&
InstallationUnitProvider::GetExpressInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetExpressInstallationUnit);

   ExpressInstallationUnit* expressInstallationUnit = 0;

   InstallationUnitContainerType::const_iterator itr = 
      installationUnitContainer.find(EXPRESS_SERVER);

   ASSERT(itr != installationUnitContainer.end());
   if (itr != installationUnitContainer.end())
   {
      expressInstallationUnit = 
         dynamic_cast<ExpressInstallationUnit*>((*itr).second);
   }

   ASSERT(expressInstallationUnit);

   return *expressInstallationUnit;
}


ADInstallationUnit&
InstallationUnitProvider::GetADInstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetADInstallationUnit);

   ADInstallationUnit* adInstallationUnit = 0;

   InstallationUnitContainerType::const_iterator itr = 
      installationUnitContainer.find(DC_SERVER);

   ASSERT(itr != installationUnitContainer.end());
   if (itr != installationUnitContainer.end())
   {
      adInstallationUnit = 
         dynamic_cast<ADInstallationUnit*>((*itr).second);
   }

   ASSERT(adInstallationUnit);

   return *adInstallationUnit;
}


POP3InstallationUnit&
InstallationUnitProvider::GetPOP3InstallationUnit()
{
   LOG_FUNCTION(InstallationUnitProvider::GetPOP3InstallationUnit);

   POP3InstallationUnit* pop3InstallationUnit = 0;

   InstallationUnitContainerType::const_iterator itr = 
      installationUnitContainer.find(POP3_SERVER);

   ASSERT(itr != installationUnitContainer.end());
   if (itr != installationUnitContainer.end())
   {
      pop3InstallationUnit = 
         dynamic_cast<POP3InstallationUnit*>((*itr).second);
   }

   ASSERT(pop3InstallationUnit);

   return *pop3InstallationUnit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\installationunitprovider.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      InstallationUnitProvider.h
//
// Synopsis:  Declares an InstallationUnitProvider
//            An InstallationUnitProvider manages the global
//            InstallationUnits for each service that can be
//            installed.
//
// History:   02/05/2001  JeffJon Created
//            12/17/2001  JeffJon Added the POP3InstallationUnit

#ifndef __CYS_SERVERATIONUNITPROVIDER_H
#define __CYS_SERVERATIONUNITPROVIDER_H

#include "InstallationUnit.h"
#include "ADInstallationUnit.h"
#include "DHCPInstallationUnit.h"
#include "DNSInstallationUnit.h"
#include "ExpressInstallationUnit.h"
#include "FileInstallationUnit.h"
#include "IndexingInstallationUnit.h"
#include "MediaInstallationUnit.h"
#include "POP3InstallationUnit.h"
#include "PrintInstallationUnit.h"
#include "RRASInstallationUnit.h"
#include "TerminalServerInstallationUnit.h"
#include "WebInstallationUnit.h"
#include "WINSInstallationUnit.h"

typedef 
   std::map<
      ServerRole, 
      InstallationUnit*,
      std::less<ServerRole>,
      Burnslib::Heap::Allocator<InstallationUnit*> >
   InstallationUnitContainerType;

class InstallationUnitProvider
{
   public:
      
      static
      InstallationUnitProvider&
      GetInstance();

      static
      void
      Destroy();

      InstallationUnit&
      GetCurrentInstallationUnit();

      InstallationUnit&
      SetCurrentInstallationUnit(ServerRole ServerRole);

      InstallationUnit&
      GetInstallationUnitForType(ServerRole ServerRole);

      DHCPInstallationUnit&
      GetDHCPInstallationUnit();

      DNSInstallationUnit&
      GetDNSInstallationUnit();

      WINSInstallationUnit&
      GetWINSInstallationUnit();

      RRASInstallationUnit&
      GetRRASInstallationUnit();

      TerminalServerInstallationUnit&
      GetTerminalServerInstallationUnit();

      FileInstallationUnit&
      GetFileInstallationUnit();

      IndexingInstallationUnit&
      GetIndexingInstallationUnit();

      PrintInstallationUnit&
      GetPrintInstallationUnit();

      MediaInstallationUnit&
      GetMediaInstallationUnit();

      WebInstallationUnit&
      GetWebInstallationUnit();

      ExpressInstallationUnit&
      GetExpressInstallationUnit();

      ADInstallationUnit&
      GetADInstallationUnit();

      POP3InstallationUnit&
      GetPOP3InstallationUnit();

   private:

      // Constructor

      InstallationUnitProvider();

      // Destructor

      ~InstallationUnitProvider();

      void
      Init();

      // The current installation unit

      InstallationUnit* currentInstallationUnit;

      // Container for installation units.  The map is keyed
      // by the ServerRole enum

      InstallationUnitContainerType installationUnitContainer;
      
      bool initialized;

      // not defined: no copying allowed
      InstallationUnitProvider(const InstallationUnitProvider&);
      const InstallationUnitProvider& operator=(const InstallationUnitProvider&);

};


#endif // __CYS_SERVERATIONUNITPROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\installservice.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// Implementation of IConfigureYourServer::InstallService
//
// 31 Mar 2000 sburns
// 05 Feb 2001 jeffjon  Copied and modified for use with a Win32 version of CYS



#include "pch.h"
#include "resource.h"


HRESULT
CreateTempFile(const String& name, const String& contents)
{
   LOG_FUNCTION2(createTempFile, name);
   ASSERT(!name.empty());
   ASSERT(!contents.empty());

   HRESULT hr = S_OK;
   HANDLE h = INVALID_HANDLE_VALUE;

   do
   {
      hr =
         FS::CreateFile(
            name,
            h,
            GENERIC_WRITE,
            0, 
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL);
      BREAK_ON_FAILED_HRESULT(hr);

      // NTRAID#NTBUG9-494875-2001/11/14-JeffJon
      // write to file with the Unicode BOM and end of file character.
      wchar_t unicodeBOM = (wchar_t)0xFEFF;

      hr = FS::Write(h, unicodeBOM + contents + L"\032");
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   Win::CloseHandle(h);

   return hr;
}



bool
InstallServiceWithOcManager(
   const String& infText,
   const String& unattendText,
   const String& additionalArgs)
{
   LOG_FUNCTION(InstallServiceWithOcManager);
   LOG(infText);
   LOG(unattendText);
   LOG(additionalArgs);
   ASSERT(!unattendText.empty());

   // infText may be empty

   bool result = false;
   HRESULT hr = S_OK;
   bool deleteInf = true;

   String sysFolder    = Win::GetSystemDirectory();
   String infPath      = sysFolder + L"\\cysinf.000"; 
   String unattendPath = sysFolder + L"\\cysunat.000";

   // create the inf and unattend files for the oc manager

   do
   {

      if (infText.empty())
      {
         // sysoc.inf is in %windir%\inf

         infPath = Win::GetSystemWindowsDirectory() + L"\\inf\\sysoc.inf";

         deleteInf = false;
      }
      else
      {
         hr = CreateTempFile(infPath, infText);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      hr = CreateTempFile(unattendPath, unattendText);
      BREAK_ON_FAILED_HRESULT(hr);

      String fullPath =
         String::format(
            IDS_SYSOC_FULL_PATH,
            sysFolder.c_str());

      String commandLine =
         String::format(
            IDS_SYSOC_COMMAND_LINE,
            infPath.c_str(),
            unattendPath.c_str());

      if (!additionalArgs.empty())
      {
         commandLine += L" " + additionalArgs;
      }

      DWORD exitCode = 0;
      hr = ::CreateAndWaitForProcess(fullPath, commandLine, exitCode);
      BREAK_ON_FAILED_HRESULT(hr);

      // @@ might have to wait for the service to become installed as per
      // service manager

      if (exitCode == ERROR_SUCCESS)
      {
         result = true;
         break;
      }
   }
   while (0);

   // Ignore errors from these deletions. The worst case is we
   // leave these temp files on the machine. Since the user doesn't
   // know we are creating them we wouldn't know what to do with
   // the errors anyway.
   
   HRESULT deleteHr = S_OK;

   if (deleteInf)
   {
      deleteHr = FS::DeleteFile(infPath);
      ASSERT(SUCCEEDED(deleteHr));
   }

   deleteHr = FS::DeleteFile(unattendPath);
   ASSERT(SUCCEEDED(deleteHr));

   LOG_BOOL(result);
   LOG_HRESULT(hr);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\mediainstallationunit.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      MediaInstallationUnit.h
//
// Synopsis:  Declares a MediaInstallationUnit
//            This object has the knowledge for installing the
//            Streaming media service
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_MEDIAINSTALLATIONUNIT_H
#define __CYS_MEDIAINSTALLATIONUNIT_H

#include "InstallationUnit.h"

class MediaInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      MediaInstallationUnit();

      // Destructor

      virtual
      ~MediaInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      UnInstallReturnType
      UnInstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      GetMilestoneText(String& message);

      virtual
      bool
      GetUninstallMilestoneText(String& message);

      virtual
      String
      GetServiceDescription();

      virtual
      void
      ServerRoleLinkSelected(int linkIndex, HWND hwnd);

      virtual
      void
      FinishLinkSelected(int inkIndex, HWND hwnd);
};

#endif // __CYS_MEDIAINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\milestonepage.h ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      MilestonePage.h
//
// Synopsis:  Declares the Milestone Page for the CYS
//            wizard
//
// History:   01/15/2002  JeffJon Created

#ifndef __CYS_MILESTONEPAGE_H
#define __CYS_MILESTONEPAGE_H

#include "CYSWizardPage.h"

class MilestonePage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      MilestonePage();

      // Destructor

      virtual 
      ~MilestonePage();


   protected:

      // Dialog overrides

      virtual
      void
      OnInit();

      bool
      OnCommand(
         HWND        windowFrom,
         unsigned    controlIDFrom,
         unsigned    code);

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

      virtual
      bool
      OnHelp();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();

   private:

      void
      OpenLogFile(const String& logName);

      void
      TimeStampTheLog(HANDLE logfileHandle);

      bool needKillSelection;

      // not defined: no copying allowed
      MilestonePage(const MilestonePage&);
      const MilestonePage& operator=(const MilestonePage&);

};

#endif // __CYS_MILESTONEPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\nasadminpage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      NASAdminPage.h
//
// Synopsis:  Declares the NASAdminPage that
//            asks the user if they want to install
//            the Network Attached Storage (NAS) 
//            admin tool
//
// History:   06/01/2001  JeffJon Created

#ifndef __CYS_NASADMINPAGE_H
#define __CYS_NASADMINPAGE_H

#include "CYSWizardPage.h"

class NASAdminPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      NASAdminPage();

      // Destructor

      virtual 
      ~NASAdminPage();


      // Dialog overrides

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();

   private:

      // not defined: no copying allowed
      NASAdminPage(const NASAdminPage&);
      const NASAdminPage& operator=(const NASAdminPage&);

};

#endif // __CYS_NASADMINPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\nasadminpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      NASAdminPage.h
//
// Synopsis:  Defines the NASAdminPage that
//            asks the user if they want to install
//            the Network Attached Storage (NAS) 
//            admin tool
//
// History:   06/01/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "NASAdminPage.h"
#include "state.h"


static PCWSTR NAS_ADMIN_PAGE_HELP = L"cys.chm::/cys_configuring_file_server.htm";

NASAdminPage::NASAdminPage()
   :
   CYSWizardPage(
      IDD_NAS_ADMIN_PAGE, 
      IDS_ADMIN_PACK_TITLE, 
      IDS_ADMIN_PACK_SUBTITLE, 
      NAS_ADMIN_PAGE_HELP)
{
   LOG_CTOR(NASAdminPage);
}

   

NASAdminPage::~NASAdminPage()
{
   LOG_DTOR(NASAdminPage);
}


bool
NASAdminPage::OnSetActive()
{
   LOG_FUNCTION(NASAdminPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   String staticText = String::load(IDS_NAS_STATIC_TEXT_IIS_INSTALLED);
   if (!InstallationUnitProvider::GetInstance().
           GetWebInstallationUnit().IsServiceInstalled())
   {
      staticText = String::load(IDS_NAS_STATIC_TEXT_NO_IIS);
   }

   Win::SetDlgItemText(
      hwnd,
      IDC_DYNAMIC_STATIC,
      staticText);

   return true;
}


int
NASAdminPage::Validate()
{
   LOG_FUNCTION(NASAdminPage::Validate);

   int nextPage = IDD_MILESTONE_PAGE;

   // Get the checkbox value to see if we should install
   // the NAS admin tools

   InstallationUnitProvider::GetInstance().GetSAKInstallationUnit().SetInstallNASAdmin(
      Win::Button_GetCheck(
         Win::GetDlgItem(
            hwnd,
            IDC_INSTALL_NASADMIN_CHECK)));

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\mediainstallationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      MediaInstallationUnit.cpp
//
// Synopsis:  Defines a MediaInstallationUnit
//            This object has the knowledge for installing the
//            Streaming media service
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "MediaInstallationUnit.h"


// Finish page help 
static PCWSTR CYS_MEDIA_FINISH_PAGE_HELP = L"cys.chm::/media_server_role.htm";
static PCWSTR CYS_MEDIA_MILESTONE_HELP = L"cys.chm::/media_server_role.htm#mediasrvsummary";
static PCWSTR CYS_MEDIA_AFTER_FINISH_HELP = L"cys.chm::/media_server_role.htm#mediasrvcompletion";

MediaInstallationUnit::MediaInstallationUnit() :
   InstallationUnit(
      IDS_MEDIA_SERVER_TYPE, 
      IDS_MEDIA_SERVER_DESCRIPTION, 
      IDS_MEDIA_FINISH_TITLE,
      IDS_MEDIA_FINISH_UNINSTALL_TITLE,
      IDS_MEDIA_FINISH_MESSAGE,
      IDS_MEDIA_INSTALL_FAILED,
      IDS_MEDIA_UNINSTALL_MESSAGE,
      IDS_MEDIA_UNINSTALL_FAILED,
      IDS_MEDIA_UNINSTALL_WARNING,
      IDS_MEDIA_UNINSTALL_CHECKBOX,
      CYS_MEDIA_FINISH_PAGE_HELP,
      CYS_MEDIA_MILESTONE_HELP,
      CYS_MEDIA_AFTER_FINISH_HELP,
      MEDIASERVER_SERVER)
{
   LOG_CTOR(MediaInstallationUnit);
}


MediaInstallationUnit::~MediaInstallationUnit()
{
   LOG_DTOR(MediaInstallationUnit);
}


InstallationReturnType
MediaInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(MediaInstallationUnit::InstallService);

   // Log heading
   CYS_APPEND_LOG(String::load(IDS_LOG_MEDIA_HEADING));

   UpdateInstallationProgressText(hwnd, IDS_MEDIA_INSTALL_PROGRESS);

   String unattendFileText;
   String infFileText;

   unattendFileText += L"[Components]\n";
   unattendFileText += L"WMS=ON\n";
   unattendFileText += L"WMS_admin_mmc=ON\n";

   // NTRAID#NTBUG9-461170-2001/08/28-sburns
   // unattendFileText += L"WMS_Admin_asp=ON\n";
   
   unattendFileText += L"WMS_SERVER=ON\n";

   InstallationReturnType result = INSTALL_SUCCESS;

   bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
   if (ocmResult &&
       IsServiceInstalled())
   {
      LOG(L"WMS was installed successfully");
      CYS_APPEND_LOG(String::load(IDS_LOG_SERVER_WMS_SUCCESS));
   }
   else
   {
      LOG(L"WMS was failed to install");
      CYS_APPEND_LOG(String::load(IDS_LOG_SERVER_WMS_FAILED));

      result = INSTALL_FAILURE;
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

UnInstallReturnType
MediaInstallationUnit::UnInstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(MediaInstallationUnit::UnInstallService);

   UnInstallReturnType result = UNINSTALL_SUCCESS;

   UpdateInstallationProgressText(hwnd, IDS_MEDIA_UNINSTALL_PROGRESS);

   // Log heading
   CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_MEDIA_HEADING));

   String unattendFileText;
   String infFileText;

   unattendFileText += L"[Components]\n";
   unattendFileText += L"WMS=OFF\n";
   unattendFileText += L"WMS_admin_mmc=OFF\n";
   unattendFileText += L"WMS_SERVER=OFF\n";

   // NTRAID#NTBUG9-736557-2002/11/12-JeffJon
   // The uninstall of the Media Server could cause
   // an unexpected reboot if the Media Server MMC
   // is open and the user chooses not to close it
   // when the uninstall warns them. If the /w
   // switch is passed to sysocmgr.exe then it
   // will prompt the user before rebooting.

   String additionalArgs = L"/w";

   bool ocmResult = 
      InstallServiceWithOcManager(
         infFileText, 
         unattendFileText, 
         additionalArgs);

   if (ocmResult &&
       !IsServiceInstalled())
   {
      LOG(L"WMS was uninstalled successfully");
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_SERVER_WMS_SUCCESS));
   }
   else
   {
      LOG(L"WMS was failed to uninstall");
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_SERVER_WMS_FAILED));

      result = UNINSTALL_FAILURE;
   }
   LOG_UNINSTALL_RETURN(result);

   return result;
}

bool
MediaInstallationUnit::GetMilestoneText(String& message)
{
   LOG_FUNCTION(MediaInstallationUnit::GetMilestoneText);

   message = String::load(IDS_MEDIA_FINISH_TEXT);

   LOG_BOOL(true);
   return true;
}

bool
MediaInstallationUnit::GetUninstallMilestoneText(String& message)
{
   LOG_FUNCTION(MediaInstallationUnit::GetUninstallMilestoneText);

   message = String::load(IDS_MEDIA_UNINSTALL_TEXT);

   LOG_BOOL(true);
   return true;
}

String
MediaInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(MediaInstallationUnit::GetServiceDescription);

   unsigned int resourceID = static_cast<unsigned int>(-1);
   if (IsServiceInstalled())
   {
      resourceID = IDS_MEDIA_SERVER_DESCRIPTION_INSTALLED;
   }
   else
   {
      resourceID = descriptionID;
   }

   ASSERT(resourceID != static_cast<unsigned int>(-1));

   return String::load(resourceID);
}

void
MediaInstallationUnit::ServerRoleLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      MediaInstallationUnit::ServerRoleLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (IsServiceInstalled())
   {
      ASSERT(linkIndex == 0);

      LaunchMYS();
   }
   else
   {
      ASSERT(linkIndex == 0);

      LOG(L"Showing configuration help");

      ShowHelp(CYS_MEDIA_FINISH_PAGE_HELP);
   }
}
  
void
MediaInstallationUnit::FinishLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      MediaInstallationUnit::FinishLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (installing)
   {
      if (linkIndex == 0 &&
          IsServiceInstalled())
      {
         LOG("Showing after checklist");

         ShowHelp(CYS_MEDIA_AFTER_FINISH_HELP);
      }
      else
      {
         LOG(L"Showing configuration help");

         ShowHelp(CYS_MEDIA_FINISH_PAGE_HELP);
      }
   }
   else
   {
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\milestonepage.cpp ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      MilestonePage.cpp
//
// Synopsis:  Defines the Milestone Page for the CYS
//            wizard
//
// History:   01/15/2002  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "MilestonePage.h"

static PCWSTR MILESTONE_PAGE_HELP = L"cys.chm::/cys_milestone.htm";

MilestonePage::MilestonePage()
   :
   needKillSelection(true),
   CYSWizardPage(
      IDD_MILESTONE_PAGE, 
      IDS_MILESTONE_TITLE, 
      IDS_MILESTONE_SUBTITLE, 
      MILESTONE_PAGE_HELP,
      true, 
      true)
{
   LOG_CTOR(MilestonePage);
}

   

MilestonePage::~MilestonePage()
{
   LOG_DTOR(MilestonePage);
}


void
MilestonePage::OnInit()
{
   LOG_FUNCTION(MilestonePage::OnInit);

   CYSWizardPage::OnInit();
}


bool
MilestonePage::OnSetActive()
{
   LOG_FUNCTION(MilestonePage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_NEXT | PSWIZB_BACK);

   // Get the finish text from the installation unit and put it in the finish box

   String message;

   bool changes =
      InstallationUnitProvider::GetInstance().GetCurrentInstallationUnit().GetMilestoneText(message);

   if (!changes)
   {
      message = String::load(IDS_FINISH_NO_CHANGES);
   }

   Win::SetDlgItemText(hwnd, IDC_MILESTONE_EDIT, message);

   if (!changes)
   {
      popup.MessageBox(
         hwnd,
         IDS_NO_CHANGES_MESSAGEBOX_TEXT,
         MB_OK | MB_ICONWARNING);
   }

   // Remove the selection of the edit box

   Win::SetFocus(
      Win::GetDlgItem(
         Win::GetParent(hwnd),
         Wizard::NEXT_BTN_ID));

   Win::Edit_SetSel(
      Win::GetDlgItem(
         hwnd,
         IDC_MILESTONE_EDIT),
      -1,
      0);

   // Set the focus to the Next button so that enter works

   Win::PostMessage(
      Win::GetParent(hwnd),
      WM_NEXTDLGCTL,
      (WPARAM) Win::GetDlgItem(Win::GetParent(hwnd), Wizard::NEXT_BTN_ID),
      TRUE);

   return true;
}

bool
MilestonePage::OnCommand(
   HWND        windowFrom,
   unsigned    controlIDFrom,
   unsigned    code)
{
   bool result = false;

   switch (controlIDFrom)
   {
      case IDC_MILESTONE_EDIT:
         if (code == EN_SETFOCUS &&
             needKillSelection)
         {
            Win::Edit_SetSel(windowFrom, -1, -1);
            needKillSelection = false;
         }
         break;

      default:
         break;
   }

   return result;
}

bool
MilestonePage::OnHelp()
{
   LOG_FUNCTION(MilestonePage::OnHelp);

   ShowHelp(
      InstallationUnitProvider::GetInstance().
         GetCurrentInstallationUnit().GetMilestonePageHelp());

   return true;
}

int
MilestonePage::Validate()
{
   LOG_FUNCTION(MilestonePage::Validate);

   Win::WaitCursor wait;
   int nextPage = -1;
   
   if (!InstallationUnitProvider::GetInstance().
           GetCurrentInstallationUnit().DoInstallerCheck(hwnd))
   {
      nextPage = IDD_PROGRESS_PAGE;

      // Set the subtitle of the progress page
      // since it is used both for installing and
      // uninstalling

      int pageIndex = 
         Win::PropSheet_IdToIndex(
            Win::GetParent(hwnd),
            IDD_PROGRESS_PAGE);

      LOG(String::format(
            L"pageIndex = %1!d!",
            pageIndex));

      Win::PropSheet_SetHeaderSubTitle(
         hwnd,
         pageIndex,
         String::load(IDS_PROGRESS_SUBTITLE));
   }

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\netbiospage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      NetbiosPage.h
//
// Synopsis:  Declares the new netbios name page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_NEBIOSPAGE_H
#define __CYS_NEBIOSPAGE_H

#include "CYSWizardPage.h"

class NetbiosDomainPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      NetbiosDomainPage();

      // Destructor

      virtual 
      ~NetbiosDomainPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

      bool
      OnCommand(
         HWND        windowFrom,
         unsigned    controlIDFrom,
         unsigned    code);

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // not defined: no copying allowed
      NetbiosDomainPage(const NetbiosDomainPage&);
      const NetbiosDomainPage& operator=(const NetbiosDomainPage&);

};




#endif // __CYS_NEBIOSPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\netdetectprogressdialog.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      NetDetectProgressDialog.h
//
// Synopsis:  Declares the NetDetectProgressDialog which 
//            gives a nice animation while detecting the 
//            network settings
//
// History:   06/13/2001  JeffJon Created

#ifndef __CYS_NETDETECTPROGRESSDIALOG_H
#define __CYS_NETDETECTPROGRESSDIALOG_H

#include "CYSWizardPage.h"


class NetDetectProgressDialog : public Dialog
{
   public:
      
      // These messages are sent to the dialog when the 
      // network detection has finished.

      static const UINT CYS_THREAD_SUCCESS;
      static const UINT CYS_THREAD_FAILED;
      static const UINT CYS_THREAD_USER_CANCEL;

      typedef void (*ThreadProc) (NetDetectProgressDialog& dialog);

      // Constructor
      
      NetDetectProgressDialog();

      // Destructor

      virtual 
      ~NetDetectProgressDialog();


      // Dialog overrides

      virtual
      void
      OnInit();

      virtual
      bool
      OnMessage(
         UINT     message,
         WPARAM   wparam,
         LPARAM   lparam);

      // Accessors

      bool
      ShouldCancel() { return shouldCancel; }

   private:

      bool shouldCancel;

      // not defined: no copying allowed
      NetDetectProgressDialog(const NetDetectProgressDialog&);
      const NetDetectProgressDialog& operator=(const NetDetectProgressDialog&);

};

#endif // __CYS_NETDETECTPROGRESSDIALOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\pch.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      pch.h
//
// Synopsis:  precompiled header for the 
//            Configure Your Server Wizard project
//
// History:   02/02/2001  JeffJon Created

#ifndef __CYS_PCH_H
#define __CYS_PCH_H


// Stuff from burnslib

#include <burnslib.hpp>
#include <ValidateDomainName.hpp>
#include <ValidateDomainName.h>

#include <process.h>
#include <iphlpapi.h>
#include <shlwapi.h>
#include <dsrolep.h>
#include <comdef.h>

extern "C"
{
   #include <dhcpapi.h>
   #include <mdhcsapi.h>
}

#include <netconp.h>

#include <shlobjp.h>
#include <shgina.h>

// DNS Server

#include <dnsrpc.h>

// Setup API - SetupPromptReboot

#include <setupapi.h>

// Winsock

#include <winsock2.h>

// File shares

#include <lmshare.h>

#include "cys.h"
#include "regkeys.h"
#include "common.h"
#include "state.h"


#endif // __CYS_PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\netbiospage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      NetbiosPage.cpp
//
// Synopsis:  Defines the new netbios name page used in the 
//            Express path for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "NetbiosPage.h"

static PCWSTR NETBIOS_PAGE_HELP = L"cys.chm::/typical_setup.htm#typicalnetbios";

NetbiosDomainPage::NetbiosDomainPage()
   :
   CYSWizardPage(
      IDD_NETBIOS_NAME, 
      IDS_NETBIOS_NAME_TITLE, 
      IDS_NETBIOS_NAME_SUBTITLE,
      NETBIOS_PAGE_HELP)
{
   LOG_CTOR(NetbiosDomainPage);
}

   

NetbiosDomainPage::~NetbiosDomainPage()
{
   LOG_DTOR(NetbiosDomainPage);
}


void
NetbiosDomainPage::OnInit()
{
   LOG_FUNCTION(NetbiosDomainPage::OnInit);

   CYSWizardPage::OnInit();

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_NETBIOS),
      MAX_NETBIOS_NAME_LENGTH);

}

static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   int next =
         !Win::GetTrimmedDlgItemText(dialog, IDC_NETBIOS).empty()
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);
}


HRESULT
MyDsRoleDnsNameToFlatName(
   const String&  domainDNSName,
   String&        result,
   bool&          nameWasTweaked)
{
   LOG_FUNCTION(MyDsRoleDnsNameToFlatName);
   ASSERT(!domainDNSName.empty());

   nameWasTweaked = false;
   result.erase();

   LOG(L"Calling DsRoleDnsNameToFlatName");
   LOG(               L"lpServer  : (null)");
   LOG(String::format(L"lpDnsName : %1", domainDNSName.c_str()));

   PWSTR flatName = 0;
   ULONG flags = 0;
   HRESULT hr =
      Win32ToHresult(
         ::DsRoleDnsNameToFlatName(
            0, // this server
            domainDNSName.c_str(),
            &flatName,
            &flags));

   LOG_HRESULT(hr);

   if (SUCCEEDED(hr) && flatName)
   {
      LOG(String::format(L"lpFlatName   : %1", flatName));
      LOG(String::format(L"lpStatusFlag : %1!X!", flags));

      result = flatName;
      if (result.length() > DNLEN)
      {
         result.resize(DNLEN);
      }
      ::DsRoleFreeMemory(flatName);

      // the name was tweaked if it is not the default.  338443

      nameWasTweaked = !(flags & DSROLE_FLATNAME_DEFAULT);
   }

   return hr;
}



// return true if the name generated has already been validated, false
// if not.

bool
GenerateDefaultNetbiosName(HWND parent)
{
   LOG_FUNCTION(GenerateDefaultNetbiosName);
   ASSERT(Win::IsWindow(parent));

   Win::CursorSetting cursor(IDC_WAIT);

   bool result = false;

   String dnsDomainName = 
      InstallationUnitProvider::GetInstance().GetADInstallationUnit().GetNewDomainDNSName();

   bool nameWasTweaked = false;
   String generatedName;
   HRESULT hr = 
      MyDsRoleDnsNameToFlatName(
         dnsDomainName,
         generatedName,
         nameWasTweaked);
   if (FAILED(hr))
   {
      // if the api call failed, the name could not have been validated.

      result = false;

      // fall back to just the first 15 characters of the first label

      generatedName =
         dnsDomainName.substr(0, min(DNLEN, dnsDomainName.find(L'.')));

      LOG(String::format(L"falling back to %1", generatedName.c_str()));
   }
   else
   {
      // the api validated the name for us.

      result = true;
   }

   generatedName.to_upper();

   if (generatedName.is_numeric())
   {
      // the generated name is all-numeric.  This is not allowed.  So we
      // toss it out.   368777 bis

      generatedName.erase();
      nameWasTweaked = false;
   }

   Win::SetDlgItemText(
      parent,
      IDC_NETBIOS,
      generatedName);

   // inform the user that the default NetBIOS name was adjusted due
   // to name collision on the network

   if (nameWasTweaked)
   {
      popup.Info(
         parent,
         String::format(
            IDS_GENERATED_NAME_WAS_TWEAKED,
            generatedName.c_str()));
   }

   return result;
}


bool
NetbiosDomainPage::OnSetActive()
{
   LOG_FUNCTION(NetbiosDomainPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   String dnsDomainName = 
      InstallationUnitProvider::GetInstance().GetADInstallationUnit().GetNewDomainDNSName();

   Win::SetDlgItemText(
      hwnd,
      IDC_DOMAIN_DNS_EDIT,
      dnsDomainName);

   // do this here instead of in init to regenerate a default name if the
   // user has not annointed one already.

   if (InstallationUnitProvider::GetInstance().GetADInstallationUnit().GetNewDomainNetbiosName().empty())
   {
      GenerateDefaultNetbiosName(hwnd);
   }
      
   enable(hwnd);

   return true;
}

bool
NetbiosDomainPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(NetbiosDomainPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_NETBIOS:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            enable(hwnd);
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}


int
NetbiosDomainPage::Validate()
{
   LOG_FUNCTION(NetbiosDomainPage::Validate);

   int nextPage = IDD_MILESTONE_PAGE;

   if (!ValidateDomainNetbiosName(hwnd, IDC_NETBIOS, popup))
   {
      nextPage = -1;
   }
   else
   {
      String netbiosName = Win::GetTrimmedDlgItemText(hwnd, IDC_NETBIOS);
      InstallationUnitProvider::GetInstance().GetADInstallationUnit().SetNewDomainNetbiosName(netbiosName);

      // If there is more than one NIC we need to offer the user routing
      // and firewall.  This also ensures we can distinguish between
      // the public and private NICs

      if (State::GetInstance().GetNICCount() > 1)
      {
         InstallationUnitProvider::GetInstance().
            GetRRASInstallationUnit().SetExpressPathValues(true);
      }

      // Check to see if there are any DNS servers configured 
      // on any of the interfaces.  If there are then we will just
      // use those.  If not we will ask the user to provide them
      // using the DNS Forwarders page.

      if (!State::GetInstance().HasDNSServerOnAnyNicToForwardTo())
      {
         nextPage = IDD_DNS_FORWARDER_PAGE;
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\netdetectprogressdialog.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      NetDetectProgressDialog.cpp
//
// Synopsis:  Defines the NetDetectProgressDialog which 
//            gives a nice animation while detecting the 
//            network settings
//
// History:   06/13/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "NetDetectProgressDialog.h"
#include "DisconnectedNICDialog.h"

// Private window messages for sending the state of the finished thread

const UINT NetDetectProgressDialog::CYS_THREAD_SUCCESS     = WM_USER + 1001;
const UINT NetDetectProgressDialog::CYS_THREAD_FAILED      = WM_USER + 1002;
const UINT NetDetectProgressDialog::CYS_THREAD_USER_CANCEL = WM_USER + 1003;

void _cdecl
netDetectThreadProc(void* p)
{
   if (!p)
   {
      ASSERT(p);
      return;
   }

   NetDetectProgressDialog* dialog =
      reinterpret_cast<NetDetectProgressDialog*>(p);

   if (!dialog)
   {
      ASSERT(dialog);
      return;
   }

   // Initialize COM for this thread

   HRESULT hr = ::CoInitialize(0);
   if (FAILED(hr))
   {
      ASSERT(SUCCEEDED(hr));
      return;
   }

   Win::WaitCursor wait;

   unsigned int finishMessage = NetDetectProgressDialog::CYS_THREAD_SUCCESS;

   HWND hwnd = dialog->GetHWND();

   // Gather the machine network and role information

   State& state = State::GetInstance();

   if (!state.HasStateBeenRetrieved())
   {
      bool isDNSServer = 
         InstallationUnitProvider::GetInstance().
            GetDNSInstallationUnit().IsServiceInstalled();

      bool isDHCPServer =
         InstallationUnitProvider::GetInstance().
            GetDHCPInstallationUnit().IsServiceInstalled();

      bool isRRASServer =
         InstallationUnitProvider::GetInstance().
            GetRRASInstallationUnit().IsServiceInstalled();

      bool doDHCPCheck = !isDNSServer && !isDHCPServer && !isRRASServer;

      if (!state.RetrieveMachineConfigurationInformation(
              Win::GetDlgItem(hwnd, IDC_STATUS_STATIC),
              doDHCPCheck,
              IDS_RETRIEVE_NIC_INFO,
              IDS_RETRIEVE_OS_INFO,
              IDS_LOCAL_AREA_CONNECTION,
              IDS_DETECTING_SETTINGS_FORMAT))
      {
         LOG(L"The machine configuration could not be retrieved.");
         ASSERT(false);

         finishMessage = NetDetectProgressDialog::CYS_THREAD_FAILED;
      }
   }

   if (finishMessage == NetDetectProgressDialog::CYS_THREAD_SUCCESS)
   {
      // check to make sure all interfaces are connected

      ASSERT(state.HasStateBeenRetrieved());

      for (unsigned int index = 0; index < state.GetNICCount(); ++index)
      {
         NetworkInterface* nic = state.GetNIC(index);

         if (!nic)
         {
            continue;
         }

         if (!nic->IsConnected())
         {
            // The NIC isn't connected so pop the warning
            // dialog and let the user determine whether to
            // continue or not

            DisconnectedNICDialog disconnectedNICDialog;
            if (IDCANCEL == disconnectedNICDialog.ModalExecute(hwnd))
            {
               // The user chose to cancel the wizard

               finishMessage = NetDetectProgressDialog::CYS_THREAD_USER_CANCEL;
            }
            break;
         }
      }
   }

   Win::SendMessage(
      hwnd, 
      finishMessage,
      0,
      0);

   CoUninitialize();
}
   

static const DWORD HELP_MAP[] =
{
   0, 0
};

NetDetectProgressDialog::NetDetectProgressDialog()
   :
   shouldCancel(false),
   Dialog(
      IDD_NET_DETECT_PROGRESS_DIALOG, 
      HELP_MAP) 
{
   LOG_CTOR(NetDetectProgressDialog);
}

   

NetDetectProgressDialog::~NetDetectProgressDialog()
{
   LOG_DTOR(NetDetectProgressDialog);
}


void
NetDetectProgressDialog::OnInit()
{
   LOG_FUNCTION(NetDetectProgressDialog::OnInit);

   // Start up the animation

   Win::Animate_Open(
      Win::GetDlgItem(hwnd, IDC_ANIMATION),
      MAKEINTRESOURCE(IDR_SEARCH_AVI));

   // Start up another thread that will perform the operations
   // and post messages back to the page to update the UI

   _beginthread(netDetectThreadProc, 0, this);
}


bool
NetDetectProgressDialog::OnMessage(
   UINT     message,
   WPARAM   /*wparam*/,
   LPARAM   /*lparam*/)
{
//   LOG_FUNCTION(NetDetectProgressDialog::OnMessage);

   bool result = false;

   switch (message)
   {
      case CYS_THREAD_USER_CANCEL:
         shouldCancel = true;

         // fall through...

      case CYS_THREAD_SUCCESS:
      case CYS_THREAD_FAILED:
         {
            Win::Animate_Stop(Win::GetDlgItem(hwnd, IDC_ANIMATION));
            HRESULT unused = Win::EndDialog(hwnd, message);

            ASSERT(SUCCEEDED(unused));

            result = true;
            break;
         }

      default:
         {
            // do nothing
            break;
         }
   }
   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\passwordeditbox.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation
//
// password edit control wrapper
//
// 6 Nov 2000 sburns
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns
//
// most of this is stolen from johnstep's common cred ui
// ds/win32/credui



#include "pch.h"
#include "PasswordEditBox.hpp"



PasswordEditBox::PasswordEditBox()
{
   LOG_CTOR(PasswordEditBox);
}



PasswordEditBox::~PasswordEditBox()
{
   LOG_DTOR(PasswordEditBox);
}



HRESULT
PasswordEditBox::Init(HWND editControl)
{
   LOG_FUNCTION(PasswordEditBox::Init);
   ASSERT(Win::GetClassName(editControl) == L"Edit");

//    By commenting out this code, we disable the subclassing and therefore
//    the caps lock warning bubble.  We do this because it appears that the
//    edit box common control now offers that same functionality.
//    NTRAID#NTBUG9-255537-2000/12/12-sburns to disable the code
//    NTRAID#NTBUG9-255568-2000/12/12-sburns to remove the code from the source
//    tree entirely.
//    
//    HRESULT hr = ControlSubclasser::Init(editControl);
//    if (SUCCEEDED(hr))
//    {
//       // set the options on the edit control
//       

   // NTRAID#NTBUG9-503798-2001/12/06-sburns

   Win::Edit_LimitText(editControl, PWLEN);
   
// 
//       // (could also set the password style bit here, if we wanted.)
// 
//       balloonTip.Init(hwnd);
//    }
// 
//    return hr;

   return S_OK;
}



bool
IsCapsLockOn()
{
//   LOG_FUNCTION(IsCapsLockOn);

   return (::GetKeyState(VK_CAPITAL) & 1) ? true : false;
}



LRESULT
PasswordEditBox::OnMessage(UINT message, WPARAM wparam, LPARAM lparam)
{
   // LOG_FUNCTION(PasswordEditBox::OnMessage);

   switch (message)
   {
      case WM_KEYDOWN:
      {

		  if (wparam == VK_CAPITAL)
         {
            // user pressed caps lock key

            balloonTip.Show(IsCapsLockOn());
         }
         else
         {
            // they hit some other key, so get rid of the tool tip
            
            balloonTip.Show(false);
         }

         break;
      }
      case WM_SETFOCUS:
      {
        // Make sure no one can steal the focus while a user is entering their
        // password

        ::LockSetForegroundWindow(LSFW_LOCK);

        balloonTip.Show(IsCapsLockOn());
       
        break;
      }
      case WM_PASTE:
      {
         balloonTip.Show(false);
         break;
      }
      case WM_KILLFOCUS:
      {
         balloonTip.Show(false);
         
        // Make sure other processes can set foreground window once again.

        ::LockSetForegroundWindow(LSFW_UNLOCK);

        break;
      }
   }

   return ControlSubclasser::OnMessage(message, wparam, lparam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\pop3installationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      POP3InstallationUnit.cpp
//
// Synopsis:  Defines a POP3InstallationUnit
//            This object has the knowledge for installing the
//            POP3 mail service
//
// History:   12/14/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "POP3InstallationUnit.h"

#include <initguid.h>
DEFINE_GUID(CLSID_P3Config,0x27AAC95F,0xCCC1,0x46F8,0xB4,0xBC,0xE5,0x92,0x25,0x27,0x55,0xA9);

// Finish page help 
static PCWSTR CYS_POP3_FINISH_PAGE_HELP = L"cys.chm::/mail_server_role.htm";
static PCWSTR CYS_POP3_MILESTONE_HELP = L"cys.chm::/mail_server_role.htm#mailsrvsummary";
static PCWSTR CYS_POP3_AFTER_FINISH_HELP = L"cys.chm::/mail_server_role.htm#mailsrvcompletion";

POP3InstallationUnit::POP3InstallationUnit() :
   authMethodIndex(0),
   pop3RoleResult(POP3_SUCCESS),
   InstallationUnit(
      IDS_POP3_SERVER_TYPE, 
      IDS_POP3_SERVER_DESCRIPTION, 
      IDS_POP3_FINISH_TITLE,
      IDS_POP3_FINISH_UNINSTALL_TITLE,
      IDS_POP3_FINISH_MESSAGE,
      IDS_POP3_INSTALL_FAILED,
      IDS_POP3_UNINSTALL_MESSAGE,
      IDS_POP3_UNINSTALL_FAILED,
      IDS_POP3_UNINSTALL_WARNING,
      IDS_POP3_UNINSTALL_CHECKBOX,
      CYS_POP3_FINISH_PAGE_HELP,
      CYS_POP3_MILESTONE_HELP,
      CYS_POP3_AFTER_FINISH_HELP,
      POP3_SERVER)
{
   LOG_CTOR(POP3InstallationUnit);
}


POP3InstallationUnit::~POP3InstallationUnit()
{
   LOG_DTOR(POP3InstallationUnit);
}


InstallationReturnType
POP3InstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(POP3InstallationUnit::InstallService);

   // Log heading
   CYS_APPEND_LOG(String::load(IDS_LOG_POP3_HEADING));

   UpdateInstallationProgressText(hwnd, IDS_POP3_PROGRESS);

   InstallationReturnType result = INSTALL_SUCCESS;

   String unattendFileText;
   String infFileText;

   unattendFileText += L"[Components]\n";
   unattendFileText += L"Pop3Srv=ON\n";
   unattendFileText += L"Pop3Service=ON\n";

   bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
   if (ocmResult &&
       IsServiceInstalled())
   {
      LOG(L"POP3 was installed successfully");
      CYS_APPEND_LOG(String::load(IDS_LOG_POP3_SERVER_SUCCESS));
   }
   else
   {
      LOG(L"POP3 failed to install");
      CYS_APPEND_LOG(String::load(IDS_LOG_POP3_SERVER_FAILURE));

      result = INSTALL_FAILURE;

      pop3RoleResult = POP3_INSTALL_FAILED;
   }

   if (result == INSTALL_SUCCESS)
   {
      // Now configure the service
      // This will set the role result if
      // there are any errors

      UpdateInstallationProgressText(hwnd, IDS_POP3_CONFIG_PROGRESS);
      ConfigurePOP3Service(logfileHandle);
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

HRESULT
POP3InstallationUnit::ConfigAuthMethod(
   SmartInterface<IP3Config>& p3Config,
   HANDLE logfileHandle)
{
   LOG_FUNCTION(POP3InstallationUnit::ConfigAuthMethod);

   HRESULT hr = S_OK;

   do
   {
      // Get the authentication methods that are available

      IAuthMethods* dumbPointer = 0;

      hr = 
         p3Config->get_Authentication(
            (IAuthMethods**)&dumbPointer);

      if (FAILED(hr) ||
          !dumbPointer)
      {
         LOG(
            String::format(
               L"Failed to get the authentication methods: hr = 0x%1!x!",
               hr));

         break;
      }

      SmartInterface<IAuthMethods> authMethods;
      authMethods.Acquire(dumbPointer);

      // Set the current authentication method

      VARIANT var;
      ::VariantInit(&var);
      V_VT(&var) = VT_I4;
      V_I4(&var) = GetAuthMethodIndex();

      hr = authMethods->put_CurrentAuthMethod(var);

      ::VariantClear(&var);

      if (FAILED(hr))
      {
         LOG(
            String::format(
               L"Failed to put the authentication method: hr = 0x%1!x!",
               hr));

         break;
      }

      // Now call save to commit the change

      hr = authMethods->Save();

      if (FAILED(hr))
      {
         LOG(
            String::format(
               L"Failed to save the auth method: hr = 0x%1!x!",
               hr));

         break;
      }

   } while (false);

   if (FAILED(hr) &&
       logfileHandle)
   {
      CYS_APPEND_LOG(
         String::format(
            IDS_LOG_POP3_AUTH_FAILURE, 
            GetErrorMessage(hr).c_str()));
   }

   LOG_HRESULT(hr);

   return hr;
}

HRESULT
POP3InstallationUnit::AddDomainName(
   SmartInterface<IP3Config>& p3Config,
   HANDLE logfileHandle)
{
   LOG_FUNCTION(POP3InstallationUnit::AddDomainName);

   HRESULT hr = S_OK;

   do
   {
      IP3Domains* dumbPointer = 0;

      hr = 
         p3Config->get_Domains(
            (IP3Domains**)&dumbPointer);

      if (FAILED(hr) ||
          !dumbPointer)
      {
         LOG(
            String::format(
               L"Failed to get the domains: hr = 0x%1!x!",
               hr));

         break;
      }

      SmartInterface<IP3Domains> p3Domains;
      p3Domains.Acquire(dumbPointer);

      // Now add the new domain name

      hr = p3Domains->Add(AutoBstr(GetDomainName().c_str()));

      if (FAILED(hr))
      {
         LOG(
            String::format(
               L"Failed to set the new domain name: hr = 0x%1!x!",
               hr));
         
         break;
      }

   } while (false);

   if (FAILED(hr) &&
       logfileHandle)
   {
      CYS_APPEND_LOG(
         String::format(
            IDS_LOG_POP3_DOMAIN_FAILURE, 
            GetErrorMessage(hr).c_str(),
            GetDomainName().c_str()));
   }

   LOG_HRESULT(hr);

   return hr;
}

void
POP3InstallationUnit::ConfigurePOP3Service(HANDLE logfileHandle)
{
   LOG_FUNCTION(POP3InstallationUnit::ConfigurePOP3Service);

   do
   {
      // First create the IP3Config COM object which will be used
      // by the other config functions

      SmartInterface<IP3Config> p3Config;

      HRESULT hr = GetP3Config(p3Config);

      if (FAILED(hr))
      {
         LOG(
            String::format(
               L"Failed to instantiate the IP3Config COM object: hr = 0x%1!x!",
               hr));

         pop3RoleResult = POP3_AUTH_METHOD_FAILED;

         CYS_APPEND_LOG(
            String::format(
               IDS_LOG_POP3_AUTH_FAILURE, 
               GetErrorMessage(hr).c_str()));

         break;
      }

      // The authentication method must be set before adding
      // a domain name

      hr = ConfigAuthMethod(p3Config, logfileHandle);
      if (FAILED(hr))
      {
         LOG(
            String::format(
               L"Failed to config auth method: hr = 0x%1!x!",
               hr));

         pop3RoleResult = POP3_AUTH_METHOD_FAILED;

         break;
      }

      // Now that the authentication method was set successfully
      // add the domain name

      hr = AddDomainName(p3Config, logfileHandle);
      if (FAILED(hr))
      {
         LOG(
            String::format(
               L"Failed to add the domain name: hr = 0x%1!x!",
               hr));

         pop3RoleResult = POP3_DOMAIN_NAME_FAILED;
         
         break;
      }
   } while (false);
}

UnInstallReturnType
POP3InstallationUnit::UnInstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(POP3InstallationUnit::UnInstallService);

   UnInstallReturnType result = UNINSTALL_SUCCESS;

   // Log heading
   CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_POP3_HEADING));

   UpdateInstallationProgressText(hwnd, IDS_UNINSTALL_POP3_PROGRESS);

   String unattendFileText;
   String infFileText;

   unattendFileText += L"[Components]\n";
   unattendFileText += L"iis_smtp=OFF\n";
   unattendFileText += L"Pop3Srv=OFF\n";
   unattendFileText += L"Pop3Service=OFF\n";

   // NTRAID#NTBUG9-736557-2002/11/13-JeffJon
   // Pass the /w switch to sysocmgr when uninstalling
   // so that if a situation occurs in which a reboot
   // is required, the user will be prompted.

   String additionalArgs = L"/w";

   bool ocmResult = 
      InstallServiceWithOcManager(
         infFileText, 
         unattendFileText,
         additionalArgs);

   if (ocmResult &&
       !IsServiceInstalled())
   {
      LOG(L"POP3 was uninstalled successfully");
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_POP3_SERVER_SUCCESS));
   }
   else
   {
      LOG(L"POP3 failed to uninstall");
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_POP3_SERVER_FAILURE));

      result = UNINSTALL_FAILURE;
   }

   LOG_UNINSTALL_RETURN(result);

   return result;
}

bool
POP3InstallationUnit::GetMilestoneText(String& message)
{
   LOG_FUNCTION(POP3InstallationUnit::GetMilestoneText);

   message = String::load(IDS_POP3_FINISH_TEXT);

   LOG_BOOL(true);
   return true;
}

bool
POP3InstallationUnit::GetUninstallMilestoneText(String& message)
{
   LOG_FUNCTION(POP3InstallationUnit::GetUninstallMilestoneText);

   message = String::load(IDS_POP3_UNINSTALL_TEXT);

   LOG_BOOL(true);
   return true;
}

String
POP3InstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(POP3InstallationUnit::GetServiceDescription);

   unsigned int resourceID = static_cast<unsigned int>(-1);
   if (IsServiceInstalled())
   {
      resourceID = IDS_POP3_SERVER_DESCRIPTION_INSTALLED;
   }
   else
   {
      resourceID = descriptionID;
   }

   ASSERT(resourceID != static_cast<unsigned int>(-1));

   return String::load(resourceID);
}

void
POP3InstallationUnit::ServerRoleLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      POP3InstallationUnit::ServerRoleLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (IsServiceInstalled())
   {
      ASSERT(linkIndex == 0);

      LaunchMYS();
   }
   else
   {
      ASSERT(linkIndex == 0);

      LOG(L"Showing configuration help");

      ShowHelp(CYS_POP3_FINISH_PAGE_HELP);
   }
}
  
void
POP3InstallationUnit::FinishLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      POP3InstallationUnit::FinishLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (linkIndex != 0)
   {
      LOG("Unexpected link index");
      ASSERT(linkIndex == 0);
      return;
   }

   if (installing)
   {
      if (GetPOP3RoleResult() == POP3_SUCCESS)
      {
         LOG("Showing after checklist");

         ShowHelp(CYS_POP3_AFTER_FINISH_HELP);
      }
      // NTRAID#NTBUG9-703593-2002/09/16-artm
      else if (GetPOP3RoleResult() == POP3_INSTALL_FAILED)
      {
         LOG("Showing configuration help");

         ShowHelp(CYS_POP3_FINISH_PAGE_HELP);
      }
      else
      {
         LOG("Opening the console");

         // First read the console file path from the registry

         String consolePath;

         if (GetRegKeyValue(
                CYS_POP3_REGKEY,
                CYS_POP3_CONSOLE,
                consolePath))
         {
            LaunchMMCConsole(L"p3server.msc", consolePath);
         }
         else
         {
            // if we couldn't read the console file path from
            // the registry just go ahead and assume its in
            // the system32 directory

            LaunchMMCConsole(L"p3server.msc");
         }
      }
   }
}

void
POP3InstallationUnit::SetDomainName(const String& domain)
{
   LOG_FUNCTION2(
      POP3InstallationUnit::SetDomainName,
      domain);

   domainName = domain;
}

String
POP3InstallationUnit::GetDomainName() const
{
   LOG_FUNCTION(POP3InstallationUnit::GetDomainName);

   String result = domainName;

   LOG(result);

   return result;
}

void
POP3InstallationUnit::SetAuthMethodIndex(int method)
{
   LOG_FUNCTION2(
      POP3InstallationUnit::SetAuthMethodIndex,
      String::format(
         L"%1!d!",
         method));

   authMethodIndex = method;
}

int
POP3InstallationUnit::GetAuthMethodIndex() const
{
   LOG_FUNCTION(POP3InstallationUnit::GetAuthMethodIndex);

   LOG(
      String::format(
         L"authMethodIndex = %1!d!",
         authMethodIndex));

   return authMethodIndex;
}

int
POP3InstallationUnit::GetWizardStart()
{
   LOG_FUNCTION(POP3InstallationUnit::GetWizardStart);

   int result = IDD_POP3_PAGE;

   bool installingRole = true;
   if (IsServiceInstalled())
   {
      installingRole = false;
      result = IDD_UNINSTALL_MILESTONE_PAGE;
   }

   SetInstalling(installingRole);

   LOG(String::format(
          L"wizard start = %1!d!",
          result));

   return result;
}

HRESULT
POP3InstallationUnit::GetP3Config(SmartInterface<IP3Config>& p3Config) const
{
   LOG_FUNCTION(POP3InstallationUnit::GetP3Config);

   HRESULT hr = 
      p3Config.AcquireViaCreateInstance(
      CLSID_P3Config,
      0,
      CLSCTX_INPROC_SERVER);

   LOG_HRESULT(hr);

   return hr;
}

unsigned int
POP3InstallationUnit::GetPOP3RoleResult() const
{
   LOG_FUNCTION(POP3InstallationUnit::GetPOP3RoleResult);

   LOG(
      String::format(
         L"pop3RoleResult = %1!d!",
         pop3RoleResult));

   return pop3RoleResult;
}

String
POP3InstallationUnit::GetFinishText()
{
   LOG_FUNCTION(POP3InstallationUnit::GetFinishText);

   unsigned int messageID = finishMessageID;

   if (installing)
   {
      unsigned int pop3RoleResult = GetPOP3RoleResult();

      if (pop3RoleResult == POP3_AUTH_METHOD_FAILED)
      {
         messageID = IDS_POP3_AUTH_METHOD_FAILED;
      }
      else if (pop3RoleResult == POP3_DOMAIN_NAME_FAILED)
      {
         messageID = IDS_POP3_DOMAIN_NAME_FAILED;
      }
      else if (pop3RoleResult == POP3_INSTALL_FAILED)
      {
         messageID = IDS_POP3_INSTALL_FAILED;
      }
      else
      {
         messageID = finishMessageID;
      }
   }
   else
   {
      messageID = finishUninstallMessageID;

      UnInstallReturnType result = GetUnInstallResult();
      if (result != UNINSTALL_SUCCESS &&
          result != UNINSTALL_SUCCESS_REBOOT &&
          result != UNINSTALL_SUCCESS_PROMPT_REBOOT)
      {
         messageID = finishUninstallFailedMessageID;
      }
   }

   return String::load(messageID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\passwordeditbox.hpp ===
// Copyright (c) 2000-2001 Microsoft Corporation
//
// password edit control wrapper
//
// 6 Nov 2000 sburns
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns



#ifndef PASSWORDEDITBOX_HPP_INCLUDED
#define PASSWORDEDITBOX_HPP_INCLUDED



#include "CapsLockBalloonTip.hpp"
#include "ControlSubclasser.hpp"



// Class for hooking the window proc of an edit control to add a balloon
// tooltip that is shown when the caps lock key is pressed.

class PasswordEditBox : public ControlSubclasser
{
   public:

   PasswordEditBox();

   virtual 
   ~PasswordEditBox();



   // subclasses the edit control, inits the balloon tip, and sets the text
   // limit appropriately.
   //
   // editControl - in, handle to the edit control to be hooked.  This must be
   // a handle to an edit control, or we fire an assertion.
   
   HRESULT
   Init(HWND editControl);



   // Invoked upon receipt of any window message.
   // 
   // message - in, the message code passed to the dialog window.
   // 
   // wparam - in, the WPARAM parameter accompanying the message.
   // 
   // lparam - in, the LPARAM parameter accompanying the message.
   
   LRESULT
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);
   


   private:

   // not implemented: no copying allowed

   PasswordEditBox(const PasswordEditBox&);
   const PasswordEditBox& operator=(const PasswordEditBox&);

   CapsLockBalloonTip balloonTip;        
};



#endif   // PASSWORDEDITBOX_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\pop3page.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      POP3Page.h
//
// Synopsis:  Declares the POP3 internal page
//            for the CYS Wizard
//
// History:   06/17/2002  JeffJon Created

#ifndef __CYS_POP3PAGE_H
#define __CYS_POP3PAGE_H

#include "CYSWizardPage.h"


class POP3Page : public CYSWizardPage
{
   public:
      
      // Constructor
      
      POP3Page();

      // Destructor

      virtual 
      ~POP3Page();


      // Dialog overrides

      virtual
      void
      OnInit();

      virtual
      bool
      OnSetActive();

      virtual
      bool
      OnCommand(
         HWND         windowFrom,
         unsigned int controlIDFrom,
         unsigned int code);

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      void
      SetButtonState();

      // Default authorization method index in combobox

      int defaultAuthMethodIndex;
      int ADIntegratedIndex;
      int localAccountsIndex;
      int passwordFilesIndex;

      // not defined: no copying allowed
      POP3Page(const POP3Page&);
      const POP3Page& operator=(const POP3Page&);

};


#endif // __CYS_POP3PAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\pop3installationunit.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      POP3InstallationUnit.h
//
// Synopsis:  Declares a POP3InstallationUnit
//            This object has the knowledge for installing the
//            POP3 mail service
//
// History:   12/14/2001  JeffJon Created

#ifndef __CYS_POP3INSTALLATIONUNIT_H
#define __CYS_POP3INSTALLATIONUNIT_H

#include "InstallationUnit.h"

#include <P3Admin.h>
#include <pop3auth.h>

class POP3InstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      POP3InstallationUnit();

      // Destructor

      virtual
      ~POP3InstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      UnInstallReturnType
      UnInstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      GetMilestoneText(String& message);

      virtual
      bool
      GetUninstallMilestoneText(String& message);

      virtual
      String
      GetServiceDescription();

      virtual
      String
      GetFinishText();

      virtual
      void
      ServerRoleLinkSelected(int linkIndex, HWND hwnd);

      virtual
      void
      FinishLinkSelected(int inkIndex, HWND hwnd);

      virtual
      int
      GetWizardStart();

      // Accessor functions

      void
      SetDomainName(const String& domain);

      String
      GetDomainName() const;

      void
      SetAuthMethodIndex(int method);

      int
      GetAuthMethodIndex() const;

      HRESULT
      GetP3Config(SmartInterface<IP3Config>& p3Config) const;

   private:

      HRESULT
      ConfigAuthMethod(
         SmartInterface<IP3Config>& p3Config,
         HANDLE logfileHandle);

      HRESULT
      AddDomainName(
         SmartInterface<IP3Config>& p3Config,
         HANDLE logfileHandle);

      void
      ConfigurePOP3Service(HANDLE logfileHandle);

      unsigned int
      GetPOP3RoleResult() const;

      static const unsigned int POP3_SUCCESS             = 0x00;
      static const unsigned int POP3_AUTH_METHOD_FAILED  = 0x01;
      static const unsigned int POP3_DOMAIN_NAME_FAILED  = 0x02;
      static const unsigned int POP3_INSTALL_FAILED      = 0x03;

      unsigned int   pop3RoleResult;

      String         domainName;
      int            authMethodIndex;
};

#endif // __CYS_POP3INSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\pop3page.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      POP3Page.cpp
//
// Synopsis:  Defines the POP3 internal page of the CYS wizard
//
// History:   06/17/2002  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "POP3Page.h"

static PCWSTR POP3_PAGE_HELP = L"cys.chm::/mail_server_role.htm#mailsrvoptions";

POP3Page::POP3Page()
   :
   defaultAuthMethodIndex(0),
   ADIntegratedIndex(CB_ERR),
   localAccountsIndex(CB_ERR),
   passwordFilesIndex(CB_ERR),
   CYSWizardPage(
      IDD_POP3_PAGE, 
      IDS_POP3_TITLE, 
      IDS_POP3_SUBTITLE,
      POP3_PAGE_HELP)
{
   LOG_CTOR(POP3Page);
}

   

POP3Page::~POP3Page()
{
   LOG_DTOR(POP3Page);
}


void
POP3Page::OnInit()
{
   LOG_FUNCTION(POP3Page::OnInit);

   CYSWizardPage::OnInit();

   bool isDC = State::GetInstance().IsDC();
   bool isJoinedToDomain = State::GetInstance().IsJoinedToDomain();

   // Add the strings to the combobox

   // The order of the insertion is extremely important so that
   // the combo box index matches the authentication method index
   // in the POP3 service.
   // - The SAM auth method needs to be added first if the local server
   //   isn't a DC
   // - AD integrated needs to be added next if the local server is a DC
   //   or is joined to a domain
   // - Hash (encrypted password files) needs to be added last

   if (!isDC)
   {
      localAccountsIndex =
         Win::ComboBox_AddString(
            Win::GetDlgItem(hwnd, IDC_AUTH_METHOD_COMBO),
            String::load(IDS_LOCAL_ACCOUNTS));

      if (localAccountsIndex == CB_ERR)
      {
         LOG(L"Failed to add local accounts string to combobox");
      }
   }

   if (isDC ||
       isJoinedToDomain)
   {
      ADIntegratedIndex =
         Win::ComboBox_AddString(
            Win::GetDlgItem(hwnd, IDC_AUTH_METHOD_COMBO),
            String::load(IDS_AD_INTEGRATED));

      if (ADIntegratedIndex == CB_ERR)
      {
         LOG(L"Failed to add AD integrated string to combobox");
      }
   }

   passwordFilesIndex =
      Win::ComboBox_AddString(
         Win::GetDlgItem(hwnd, IDC_AUTH_METHOD_COMBO),
         String::load(IDS_ENCRYPTED_PASSWORD_FILES));

   if (passwordFilesIndex == CB_ERR)
   {
      LOG(L"Failed to add encrypted password files string to combobox");
   }

   // Now figure out which one to select by default
   // If the machine is a DC or is joined to a domain
   // default to AD integrated authentication, else
   // default to local Windows accounts

   int defaultAuthMethodIndex = localAccountsIndex;

   if (State::GetInstance().IsDC() &&
       ADIntegratedIndex != CB_ERR)
   {
      defaultAuthMethodIndex = ADIntegratedIndex;
   }
   else
   {
      defaultAuthMethodIndex = localAccountsIndex;
   }

   // Make sure we have a valid default

   if (defaultAuthMethodIndex == CB_ERR)
   {
      defaultAuthMethodIndex = 0;
   }

   // Select the default

   Win::ComboBox_SetCurSel(
      Win::GetDlgItem(
         hwnd, 
         IDC_AUTH_METHOD_COMBO),
      defaultAuthMethodIndex);

   LOG(
      String::format(
         L"Defaulting combobox to: %1!d!",
         defaultAuthMethodIndex));


   // Set the limit text for the domain name page

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_EMAIL_DOMAIN_EDIT),
      DNS_MAX_NAME_LENGTH);

}

bool
POP3Page::OnSetActive()
{
   LOG_FUNCTION(POP3Page::OnSetActive);

   SetButtonState();

   return true;
}

void
POP3Page::SetButtonState()
{
   LOG_FUNCTION(POP3Page::SetButtonState);

   String emailDomainName =
      Win::GetDlgItemText(
         hwnd,
         IDC_EMAIL_DOMAIN_EDIT);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      (!emailDomainName.empty()) ? PSWIZB_NEXT | PSWIZB_BACK : PSWIZB_BACK);
}

bool
POP3Page::OnCommand(
   HWND         /*windowFrom*/,
   unsigned int controlIDFrom,
   unsigned int code)
{
   if (code == EN_CHANGE &&
       controlIDFrom == IDC_EMAIL_DOMAIN_EDIT)
   {
      SetButtonState();
   }

   return false;
}

int
POP3Page::Validate()
{
   LOG_FUNCTION(POP3Page::Validate);

   int nextPage = -1;

   do
   {
      String emailDomainName =
         Win::GetDlgItemText(
            hwnd,
            IDC_EMAIL_DOMAIN_EDIT);

      DNS_STATUS status = MyDnsValidateName(emailDomainName, DnsNameDomain);

      if (status != ERROR_SUCCESS)
      {
         String message =
            String::format(
               IDS_BAD_DNS_SYNTAX,
               emailDomainName.c_str(),
               DNS_MAX_NAME_LENGTH);

         popup.Gripe(hwnd, IDC_EMAIL_DOMAIN_EDIT, message);

         nextPage = -1;
         break;
      }

      POP3InstallationUnit& pop3InstallationUnit =
         InstallationUnitProvider::GetInstance().GetPOP3InstallationUnit();

      pop3InstallationUnit.SetDomainName(emailDomainName);

      int authIndex =
         Win::ComboBox_GetCurSel(
            Win::GetDlgItem(
               hwnd,
               IDC_AUTH_METHOD_COMBO));


      if (authIndex == CB_ERR)
      {
         LOG(L"Failed to get the selected index, reverting to default");
         ASSERT(authIndex != CB_ERR);

         authIndex = defaultAuthMethodIndex;
      }

      // Set the auth method in the installation unit
      // Since the auth method is a 1 based index and the
      // combo selection is a zero based index, add 1.

      pop3InstallationUnit.SetAuthMethodIndex(authIndex + 1);

      nextPage = IDD_MILESTONE_PAGE;
   } while (false);


   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\printinstallationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      PrintInstallationUnit.cpp
//
// Synopsis:  Defines a PrintInstallationUnit
//            This object has the knowledge for installing the
//            printer services
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "PrintInstallationUnit.h"


// Finish page help 
static PCWSTR CYS_PRINT_FINISH_PAGE_HELP = L"cys.chm::/print_server_role.htm";
static PCWSTR CYS_PRINT_MILESTONE_HELP = L"cys.chm::/print_server_role.htm#printsrvsummary";
static PCWSTR CYS_PRINT_AFTER_FINISH_HELP = L"cys.chm::/print_server_role.htm#printsrvcompletion";

PrintInstallationUnit::PrintInstallationUnit() :
   printRoleResult(PRINT_SUCCESS),
   forAllClients(false),
   InstallationUnit(
      IDS_PRINT_SERVER_TYPE, 
      IDS_PRINT_SERVER_DESCRIPTION, 
      IDS_PRINT_FINISH_TITLE,
      IDS_PRINT_FINISH_UNINSTALL_TITLE,
      IDS_PRINT_FINISH_MESSAGE,
      IDS_PRINT_SUCCESS_NO_SHARES,
      IDS_PRINT_UNINSTALL_MESSAGE,
      IDS_PRINT_UNINSTALL_FAILED,
      IDS_PRINT_UNINSTALL_WARNING,
      IDS_PRINT_UNINSTALL_CHECKBOX,
      CYS_PRINT_FINISH_PAGE_HELP,
      CYS_PRINT_MILESTONE_HELP,
      CYS_PRINT_AFTER_FINISH_HELP,
      PRINTSERVER_SERVER)
{
   LOG_CTOR(PrintInstallationUnit);
}


PrintInstallationUnit::~PrintInstallationUnit()
{
   LOG_DTOR(PrintInstallationUnit);
}


InstallationReturnType
PrintInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(PrintInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;
   printRoleResult = PRINT_SUCCESS;

   String resultText;

   // Always execute the Add Printer Wizard

   CYS_APPEND_LOG(String::load(IDS_PRINTER_WIZARD_CONFIG_LOG_TEXT));
   
   HRESULT hr = S_OK;

   UpdateInstallationProgressText(hwnd, IDS_PRINT_PROGRESS_PRINTER_WIZARD);

   if (ExecuteWizard(hwnd, CYS_PRINTER_WIZARD_NAME, resultText, hr))
   {
      // if there are shared printers, then we consider ourselves
      // successful.

      if (IsServiceInstalled())
      {
         CYS_APPEND_LOG(String::load(IDS_PRINT_SERVER_SUCCESSFUL));
      }
      else
      {
         if (SUCCEEDED(hr))
         {
            CYS_APPEND_LOG(String::load(IDS_PRINT_SERVER_UNSUCCESSFUL));
            result = INSTALL_FAILURE;
            printRoleResult = PRINT_WIZARD_RUN_NO_SHARES;
         }
         else
         {
            // The call to ExecuteWizard should have provided us with the
            // error message.
            
            ASSERT(!resultText.empty());
            CYS_APPEND_LOG(resultText);
            result = INSTALL_FAILURE;
            
            if (HRESULT_CODE(hr) == ERROR_CANCELLED)
            {
               printRoleResult = PRINT_WIZARD_CANCELLED;
            }
            else
            {
               printRoleResult = PRINT_FAILURE;
            }
         }
      }
   }
   else
   {
      // This should never be reached so assert if we get here
      ASSERT(false);

      LOG(L"Add Printer Wizard failed");
      result = INSTALL_FAILURE;

      printRoleResult = PRINT_FAILURE;
   }

   if (forAllClients)
   {
      // Now execute the Add Printer Driver Wizard

      UpdateInstallationProgressText(hwnd, IDS_PRINT_PROGRESS_DRIVERS_WIZARD);

      if (ExecuteWizard(hwnd, CYS_PRINTER_DRIVER_WIZARD_NAME, resultText, hr))
      {
         // NTRAID#NTBUG9-462079-2001/09/04-sburns
      
         if (SUCCEEDED(hr))
         {
            ASSERT(resultText.empty());
         
            CYS_APPEND_LOG(String::load(IDS_PRINTER_DRIVER_WIZARD_SUCCEEDED));
         }
         else
         {
            // The call to ExecuteWizard should have provided us with the
            // error message.
         
            ASSERT(!resultText.empty());
            CYS_APPEND_LOG(resultText);
         }
      }
      else
      {
         // This should never be reached so assert if we get here
         ASSERT(false);

         LOG(L"Add Printer Driver Wizard failed");
      }
   }

   CYS_APPEND_LOG(L"\r\n");   
   LOG_INSTALL_RETURN(result);

   return result;
}

HRESULT
PrintInstallationUnit::RemovePrinters(
   PRINTER_INFO_5& printerInfo)
{
   LOG_FUNCTION2(
      PrintInstallationUnit::RemovePrinters,
      printerInfo.pPrinterName);

   HRESULT hr = S_OK;

   do
   {
      HANDLE printerHandle = 0;

      // need to open the printer with admin access

      PRINTER_DEFAULTS defaults = { 0, 0, PRINTER_ALL_ACCESS };
      if (!OpenPrinter(
              printerInfo.pPrinterName,
              &printerHandle,
              &defaults))
      {
         hr = Win::GetLastErrorAsHresult();

         LOG(String::format(
                L"Failed to open printer: hr = 0x%1!x!",
                hr));
         break;
      }

      // Now that we were able to open the printer
      // delete it

      if (!DeletePrinter(printerHandle))
      {
         hr = Win::GetLastErrorAsHresult();

         LOG(String::format(
                L"SetPrinter failed: hr = 0x%1!x!",
                hr));

         break;
      }

   } while (false);

   LOG_HRESULT(hr);

   return hr;
}

UnInstallReturnType
PrintInstallationUnit::UnInstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(PrintInstallationUnit::UnInstallService);

   UnInstallReturnType result = UNINSTALL_SUCCESS;

   CYS_APPEND_LOG(String::load(IDS_LOG_PRINT_UNINSTALL_HEADER));
  
   UpdateInstallationProgressText(hwnd, IDS_UNINSTALL_PRINT_PROGRESS);

   // I am using level 5 here because it is the cheapest way to get
   // the printer attributes

   BYTE* printerInfo = 0;
   DWORD bytesNeeded = 0;
   DWORD numberOfPrinters = 0;
   DWORD error = 0;

   do
   {
      if (!EnumPrinters(
            PRINTER_ENUM_LOCAL | PRINTER_ENUM_SHARED,
            0,
            5,
            printerInfo,
            bytesNeeded,
            &bytesNeeded,
            &numberOfPrinters))
      {
         error = GetLastError();

         if (error == ERROR_INSUFFICIENT_BUFFER ||
             error == ERROR_INVALID_USER_BUFFER)
         {

            // The buffer isn't large enough so allocate
            // a new buffer and try again

            LOG(L"Reallocating buffer and trying again...");

            if (printerInfo)
            {
               delete[] printerInfo;
               printerInfo = 0;
            }

            printerInfo = new BYTE[bytesNeeded];
            if (!printerInfo)
            {
               LOG(L"Could not allocate printerInfo buffer!");
               break;
            }
            continue;
         }
         else
         {
            // Error occurred reading shared printers

            result = UNINSTALL_FAILURE;
            break;
         }
      }
      else
      {
         // Remove the sharing bit from all the shared printers

         LOG(String::format(
                L"Found %1!d! printers",
                numberOfPrinters));

         PRINTER_INFO_5* printerInfoArray = 
            reinterpret_cast<PRINTER_INFO_5*>(printerInfo);

         for (DWORD index = 0; index < numberOfPrinters; ++index)
         {
            HRESULT hr = 
               RemovePrinters(
                  printerInfoArray[index]);

            if (FAILED(hr))
            {
               result = UNINSTALL_FAILURE;
               break;
            }
         }

         if (printerInfo)
         {
            delete[] printerInfo;
            printerInfo = 0;
         }
         break;
      }
   } while (true);

   if (result == UNINSTALL_SUCCESS)
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_PRINT_SUCCESS));
   }
   else
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_PRINT_FAILURE));
   }

   CYS_APPEND_LOG(L"\r\n");   

   LOG_UNINSTALL_RETURN(result);

   return result;
}

bool
PrintInstallationUnit::GetMilestoneText(String& message)
{
   LOG_FUNCTION(PrintInstallationUnit::GetMilestoneText);

   if (forAllClients)
   {
      message += String::load(IDS_PRINT_FINISH_ALL_CLIENTS);
   }
   else
   {
      message += String::load(IDS_PRINT_FINISH_W2K_CLIENTS);
   }

   LOG_BOOL(true);
   return true;
}

bool
PrintInstallationUnit::GetUninstallMilestoneText(String& message)
{
   LOG_FUNCTION(PrintInstallationUnit::GetUninstallMilestoneText);

   message = String::load(IDS_PRINT_UNINSTALL_TEXT);

   LOG_BOOL(true);
   return true;
}

void
PrintInstallationUnit::SetClients(bool allclients)
{
   LOG_FUNCTION2(
      PrintInstallationUnit::SetClients,
      allclients ? L"true" : L"false");

   forAllClients = allclients;
}

int
PrintInstallationUnit::GetWizardStart()
{
   LOG_FUNCTION(PrintInstallationUnit::GetWizardStart);

   int wizardStart = IDD_PRINT_SERVER_PAGE;

   bool installingRole = true;

   if (IsServiceInstalled())
   {
      installingRole = false;
      wizardStart = IDD_UNINSTALL_MILESTONE_PAGE;
   }

   SetInstalling(installingRole);

   LOG(String::format(
          L"wizardStart = %1!d!",
          wizardStart));

   return wizardStart;
}

String
PrintInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(PrintInstallationUnit::GetServiceDescription);

   unsigned int description = descriptionID;

   if (IsServiceInstalled())
   {
      description = IDS_PRINT_SERVER_DESCRIPTION_INSTALLED;
   }

   return String::load(description);
}

void
PrintInstallationUnit::ServerRoleLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      PrintInstallationUnit::ServerRoleLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (IsServiceInstalled())
   {
      ASSERT(linkIndex == 0);

      LaunchMYS();
   }
   else
   {
      ASSERT(linkIndex == 0);

      LOG(L"Showing configuration help");

      ShowHelp(CYS_PRINT_FINISH_PAGE_HELP);
   }
}
  
String
PrintInstallationUnit::GetFinishText()
{
   LOG_FUNCTION(PrintInstallationUnit::GetFinishText);

   unsigned int messageID = finishMessageID;

   if (installing)
   {
      if (printRoleResult == PRINT_SUCCESS)
      {
         messageID = finishMessageID;
      }
      else if (printRoleResult == PRINT_FAILURE)
      {
         messageID = IDS_PRINT_INSTALL_FAILED;
      }
      else
      {
         messageID = finishInstallFailedMessageID;
      }
   }
   else
   {
      messageID = finishUninstallMessageID;
   }

   return String::load(messageID);
}

void
PrintInstallationUnit::FinishLinkSelected(int linkIndex, HWND hwnd)
{
   LOG_FUNCTION2(
      PrintInstallationUnit::FinishLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (installing)
   {
      if (linkIndex == 0 &&
          printRoleResult == PRINT_SUCCESS)
      {
         LOG("Showing after checklist");

         ShowHelp(CYS_PRINT_AFTER_FINISH_HELP);
      }
      else if (linkIndex == 0)
      {
         LOG("Running Add Printer Wizard");

         String unusedResult;
         HRESULT unusedHr = S_OK;
         ExecuteWizard(hwnd, CYS_PRINTER_WIZARD_NAME, unusedResult, unusedHr);

         // NTRAID#NTBUG9-603366-2002/06/03-JeffJon-Close down CYS so
         // that the user doesn't think they still failed even after
         // running through the wizard again successfully from this
         // link

         Win::PropSheet_PressButton(
            Win::GetParent(hwnd),
            PSBTN_FINISH);
      }
      else if (linkIndex == 1)
      {
         LOG(L"Opening Printers and Faxes");

         String fullPath = 
            FS::AppendPath(
               Win::GetSystemDirectory(),
               L"control.exe");

         String commandline = L"printers";

         MyCreateProcess(fullPath, commandline);

         // NTRAID#NTBUG9-603366-2002/06/03-JeffJon-Close down CYS so
         // that the user doesn't think they still failed even after
         // running through the wizard again successfully from this
         // link

         Win::PropSheet_PressButton(
            Win::GetParent(hwnd),
            PSBTN_FINISH);
      }
   }
   else
   {
      if (IsServiceInstalled())
      {
         // There was a failure

         // REVIEW_JEFFJON: From spec: ???
      }
   }
}

bool
PrintInstallationUnit::DoInstallerCheck(HWND /*hwnd*/) const
{
   LOG_FUNCTION(PrintInstallationUnit::DoInstallerCheck);

   // The printer wizards allow for more than one instance
   // to run at the same time

   bool result = false;

   LOG_BOOL(result);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\printinstallationunit.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      PrintInstallationUnit.h
//
// Synopsis:  Declares a PrintInstallationUnit
//            This object has the knowledge for installing the
//            shared printers
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_PRINTINSTALLATIONUNIT_H
#define __CYS_PRINTINSTALLATIONUNIT_H

#include "InstallationUnit.h"
#include "winspool.h"

class PrintInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      PrintInstallationUnit();

      // Destructor

      virtual
      ~PrintInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      UnInstallReturnType
      UnInstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      String
      GetServiceDescription();

      virtual
      bool
      GetMilestoneText(String& message);

      virtual
      bool
      GetUninstallMilestoneText(String& message);

      virtual
      String
      GetFinishText();

      virtual
      int
      GetWizardStart();

      virtual
      void
      ServerRoleLinkSelected(int linkIndex, HWND hwnd);

      virtual
      void
      FinishLinkSelected(int inkIndex, HWND hwnd);

      virtual
      bool
      DoInstallerCheck(HWND hwnd) const;

      void
      SetClients(bool allclients);

      bool
      ForAllClients() const { return forAllClients; }

   private:

      enum PrintRoleResult
      {
         PRINT_SUCCESS,
         PRINT_FAILURE,
         PRINT_WIZARD_RUN_NO_SHARES,
         PRINT_WIZARD_CANCELLED
      };

      HRESULT
      RemovePrinters(
         PRINTER_INFO_5& printerInfo);

      PrintRoleResult printRoleResult;

      bool  forAllClients;
};

#endif // __CYS_PRINTINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\printserverpage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      PrintServerPage.h
//
// Synopsis:  Declares the Print Server page
//            for the CYS Wizard
//
// History:   02/08/2001  JeffJon Created

#ifndef __CYS_PRINTSERVERPAGE_H
#define __CYS_PRINTSERVERPAGE_H

#include "CYSWizardPage.h"


class PrintServerPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      PrintServerPage();

      // Destructor

      virtual 
      ~PrintServerPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // not defined: no copying allowed
      PrintServerPage(const PrintServerPage&);
      const PrintServerPage& operator=(const PrintServerPage&);

};


#endif // __CYS_PRINTSERVERPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\printserverpage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      PrintServerPage.cpp
//
// Synopsis:  Defines the Printer page of the CYS wizard
//
// History:   02/08/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "PrintServerPage.h"

static PCWSTR PRINTSERVER_PAGE_HELP = L"cys.chm::/print_server_role.htm#printsrvprintersdrivers";

PrintServerPage::PrintServerPage()
   :
   CYSWizardPage(
      IDD_PRINT_SERVER_PAGE, 
      IDS_PRINT_SERVER_TITLE, 
      IDS_PRINT_SERVER_SUBTITLE,
      PRINTSERVER_PAGE_HELP)
{
   LOG_CTOR(PrintServerPage);
}

   

PrintServerPage::~PrintServerPage()
{
   LOG_DTOR(PrintServerPage);
}


void
PrintServerPage::OnInit()
{
   LOG_FUNCTION(PrintServerPage::OnInit);

   CYSWizardPage::OnInit();

   Win::Button_SetCheck(GetDlgItem(hwnd, IDC_W2K_RADIO), BST_CHECKED);
}


bool
PrintServerPage::OnSetActive()
{
   LOG_FUNCTION(PrintServerPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}


int
PrintServerPage::Validate()
{
   LOG_FUNCTION(PrintServerPage::Validate);

   int nextPage = -1;

   InstallationUnitProvider::GetInstance().GetPrintInstallationUnit().SetClients(
      Win::Button_GetCheck(Win::GetDlgItem(hwnd, IDC_ALL_RADIO)));

   nextPage = IDD_MILESTONE_PAGE;

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\remotedesktoppage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      RemoteDesktopPage.h
//
// Synopsis:  Defines the Remote Desktop page
//            for the CYS Wizard
//
// History:   12/18/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "RemoteDesktopPage.h"
#include "state.h"

static PCWSTR REMOTEDESKTOP_PAGE_HELP = L"cys.chm::/cys_configuring_remote_desktop_server.htm";

RemoteDesktopPage::RemoteDesktopPage()
   :
   CYSWizardPage(
      IDD_REMOTE_DESKTOP_PAGE, 
      IDS_REMOTE_DESKTOP_TITLE, 
      IDS_REMOTE_DESKTOP_SUBTITLE,
      REMOTEDESKTOP_PAGE_HELP)
{
   LOG_CTOR(RemoteDesktopPage);
}

   

RemoteDesktopPage::~RemoteDesktopPage()
{
   LOG_DTOR(RemoteDesktopPage);
}


void
RemoteDesktopPage::OnInit()
{
   LOG_FUNCTION(RemoteDesktopPage::OnInit);

}


bool
RemoteDesktopPage::OnSetActive()
{
   LOG_FUNCTION(RemoteDesktopPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}


int
RemoteDesktopPage::Validate()
{
   LOG_FUNCTION(RemoteDesktopPage::Validate);

   int nextPage = -1;

   InstallationUnitProvider::GetInstance().GetRemoteAdminInstallationUnit().SetEnableRemoteDesktop(
      Win::Button_GetCheck(
         Win::GetDlgItem(hwnd, IDC_ENABLE_REMOTE_DESKTOP_CHECK)));

   SAKInstallationUnit& sakInstall = 
      InstallationUnitProvider::GetInstance().GetSAKInstallationUnit();

   if (!State::GetInstance().Is64Bit() &&
       (!sakInstall.IsNASAdminInstalled() ||
        !sakInstall.IsWebAdminInstalled()))
   {
      nextPage = IDD_SAK_PAGE;
   }
   else
   {
      nextPage = IDD_MILESTONE_PAGE;
   }

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\remotedesktoppage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      RemoteDesktopPage.h
//
// Synopsis:  Declares the Remote Desktop page
//            for the CYS Wizard
//
// History:   12/18/2001  JeffJon Created

#ifndef __CYS_REMOTEDESKTOPPAGE_H
#define __CYS_REMOTEDESKTOPPAGE_H

#include "CYSWizardPage.h"


class RemoteDesktopPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      RemoteDesktopPage();

      // Destructor

      virtual 
      ~RemoteDesktopPage();


      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();


   private:

      // not defined: no copying allowed
      RemoteDesktopPage(const RemoteDesktopPage&);
      const RemoteDesktopPage& operator=(const RemoteDesktopPage&);

};


#endif // __CYS_REMOTEDESKTOPPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\spresource.h ===
// These resources define the values that will be returned from the SharePoint installation COM object
// These represent strings in resource.rc that are error messages specific to SharePoint installation
// Since these values are passed back to us we CANNOT CHANGE THESE VALUES or else we will be broken


// DO NOT CHANGE!!!!

#define IDS_SHAREPOINT_ERROR1           2000
#define IDS_SHAREPOINT_ERROR2           2001

// DO NOT CHANGE!!!!
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\smcyscom.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */
#pragma warning( disable: 4211 )  /* redefine extent to static */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0358 */
/* Compiler settings for smcyscom.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __smcyscom_h__
#define __smcyscom_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISMCys_FWD_DEFINED__
#define __ISMCys_FWD_DEFINED__
typedef interface ISMCys ISMCys;
#endif 	/* __ISMCys_FWD_DEFINED__ */


#ifndef __SMCys_FWD_DEFINED__
#define __SMCys_FWD_DEFINED__

#ifdef __cplusplus
typedef class SMCys SMCys;
#else
typedef struct SMCys SMCys;
#endif /* __cplusplus */

#endif 	/* __SMCys_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __ISMCys_INTERFACE_DEFINED__
#define __ISMCys_INTERFACE_DEFINED__

/* interface ISMCys */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISMCys;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61EC2B7B-CBD9-4ff7-B479-9F98F4054299")
    ISMCys : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Install( 
            BSTR bstrDiskName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISMCysVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISMCys * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISMCys * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISMCys * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISMCys * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISMCys * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISMCys * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISMCys * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Install )( 
            ISMCys * This,
            BSTR bstrDiskName);
        
        END_INTERFACE
    } ISMCysVtbl;

    interface ISMCys
    {
        CONST_VTBL struct ISMCysVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISMCys_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISMCys_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISMCys_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISMCys_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISMCys_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISMCys_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISMCys_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISMCys_Install(This,bstrDiskName)	\
    (This)->lpVtbl -> Install(This,bstrDiskName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISMCys_Install_Proxy( 
    ISMCys * This,
    BSTR bstrDiskName);


void __RPC_STUB ISMCys_Install_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISMCys_INTERFACE_DEFINED__ */



#ifndef __SMCysComLib_LIBRARY_DEFINED__
#define __SMCysComLib_LIBRARY_DEFINED__

/* library SMCysComLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_SMCysComLib;

EXTERN_C const CLSID CLSID_SMCys;

#ifdef __cplusplus

class DECLSPEC_UUID("9436DA1F-7F32-43ac-A48C-F6F813882BE8")
SMCys;
#endif
#endif /* __SMCysComLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\rrasinstallationunit.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      RRASInstallationUnit.h
//
// Synopsis:  Declares a RRASInstallationUnit
//            This object has the knowledge for installing the
//            RRAS service
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_RRASINSTALLATIONUNIT_H
#define __CYS_RRASINSTALLATIONUNIT_H

#include "ExpressPathInstallationUnitBase.h"

class RRASInstallationUnit : public ExpressPathInstallationUnitBase
{
   public:
      
      // Constructor

      RRASInstallationUnit();

      // Destructor

      virtual
      ~RRASInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      UnInstallReturnType
      UnInstallService(HANDLE logfileHandle, HWND hwnd);

      void
      SetExpressPathValues(
         bool runRRASWizard);

      virtual
      bool
      GetMilestoneText(String& message);

      virtual
      bool
      GetUninstallMilestoneText(String& message);

      virtual
      String
      GetServiceDescription();

      virtual
      void
      ServerRoleLinkSelected(int linkIndex, HWND hwnd);

      virtual
      void
      FinishLinkSelected(int inkIndex, HWND hwnd);

      String
      GetLocalNIC() const;

      bool
      ShouldRunRRASWizard() const;

      bool
      IsRoutingOn() const;

      InstallationReturnType
      ExpressPathInstall(HANDLE logfileHandle, HWND hwnd);

   private:

      // Used as the first parameter to the entry point to tell the
      // RRAS snapin to launch the wizard in the CYS Express path mode

      static const DWORD CYS_EXPRESS_RRAS = 1;

      // Function definition for the entry point into mprsnap.dll

      typedef HRESULT (APIENTRY * RRASSNAPPROC)(DWORD, PVOID *);

      HRESULT
      CallRRASWizard(const RRASSNAPPROC proc);

      bool  isExpressPathInstall;

      bool  rrasWizard;

      String localNIC;

      unsigned int installedDescriptionID;
};

#endif // __CYS_RRASINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\rrasinstallationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      RRASInstallationUnit.cpp
//
// Synopsis:  Defines a RRASInstallationUnit
//            This object has the knowledge for installing the
//            RRAS service
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "RRASInstallationUnit.h"
#include "InstallationUnitProvider.h"
#include "NetworkInterface.h"

// Finish page help 
static PCWSTR CYS_RRAS_FINISH_PAGE_HELP = L"cys.chm::/vpn_server_role.htm";
static PCWSTR CYS_RRAS_MILESTONE_HELP = L"cys.chm::/vpn_server_role.htm#vpnsrvsummary";
static PCWSTR CYS_RRAS_AFTER_FINISH_HELP = L"cys.chm::/vpn_server_role.htm#vpnsrvcompletion";

RRASInstallationUnit::RRASInstallationUnit() :
   rrasWizard(false),
   installedDescriptionID(IDS_RRAS_SERVER_DESCRIPTION_INSTALLED),
   ExpressPathInstallationUnitBase(
      IDS_RRAS_SERVER_TYPE, 
      IDS_RRAS_SERVER_DESCRIPTION2, 
      IDS_RRAS_FINISH_TITLE,
      IDS_RRAS_FINISH_UNINSTALL_TITLE,
      IDS_RRAS_FINISH_MESSAGE,
      IDS_RRAS_INSTALL_FAILED,
      IDS_RRAS_UNINSTALL_MESSAGE,
      IDS_RRAS_UNINSTALL_FAILED,
      IDS_RRAS_UNINSTALL_WARNING,
      IDS_RRAS_UNINSTALL_CHECKBOX,
      CYS_RRAS_FINISH_PAGE_HELP,
      CYS_RRAS_MILESTONE_HELP,
      CYS_RRAS_AFTER_FINISH_HELP,
      RRAS_SERVER)
{
   LOG_CTOR(RRASInstallationUnit);
}


RRASInstallationUnit::~RRASInstallationUnit()
{
   LOG_DTOR(RRASInstallationUnit);
}


InstallationReturnType
RRASInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(RRASInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   if (IsExpressPathInstall())
   {
      result = ExpressPathInstall(logfileHandle, hwnd);

      LOG_INSTALL_RETURN(result);
      return result;
   }

   // Run the RRAS Wizard
   
   CYS_APPEND_LOG(String::load(IDS_LOG_RRAS_HEADING));
   CYS_APPEND_LOG(String::load(IDS_LOG_RRAS));

   UpdateInstallationProgressText(hwnd, IDS_RRAS_PROGRESS);

   do
   {
      String resultText;
      HRESULT unused = S_OK;

      if (!ExecuteWizard(hwnd, CYS_RRAS_SERVICE_NAME, resultText, unused))
      {
         if (!resultText.empty())
         {
            CYS_APPEND_LOG(resultText);
         }

         result = INSTALL_FAILURE;
         break;
      }

      if (IsServiceInstalled())
      {
         // The RRAS Wizard completed successfully
      
         LOG(L"RRAS server wizard completed successfully");
         CYS_APPEND_LOG(String::load(IDS_LOG_RRAS_COMPLETED_SUCCESSFULLY));
      }
      else
      {
         // The Configure DHCP Server Wizard did not finish successfully


         LOG(L"The RRAS wizard failed to run");

         CYS_APPEND_LOG(String::load(IDS_LOG_RRAS_WIZARD_ERROR));

         result = INSTALL_FAILURE;
      }
   } while (false);

   LOG_INSTALL_RETURN(result);

   return result;
}

UnInstallReturnType
RRASInstallationUnit::UnInstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(RRASInstallationUnit::UnInstallService);

   UnInstallReturnType result = UNINSTALL_SUCCESS;

   // Run the RRAS Wizard
  
   CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_RRAS_HEADING));

   UpdateInstallationProgressText(hwnd, IDS_RRAS_UNINSTALL_PROGRESS);

   do
   {
      String resultText;
      HRESULT unused = S_OK;

      if (!ExecuteWizard(hwnd, CYS_RRAS_UNINSTALL, resultText, unused))
      {
         CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_RRAS_FAILED));

         result = UNINSTALL_FAILURE;
         break;
      }

      if (!IsServiceInstalled())
      {
         // The Disable RRAS completed successfully
      
         LOG(L"Disable RRAS server completed successfully");
         CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_RRAS_COMPLETED_SUCCESSFULLY));
      }
      else
      {
         // The Disable RRAS Server did not finish successfully

         CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_RRAS_FAILED));

         LOG(L"The RRAS wizard failed to run");

//         CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_RRAS_WIZARD_ERROR));

         result = UNINSTALL_FAILURE;
      }
   } while (false);

   LOG_UNINSTALL_RETURN(result);

   return result;
}

InstallationReturnType
RRASInstallationUnit::ExpressPathInstall(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(RRASInstallationUnit::ExpressPathInstall);

   InstallationReturnType result = INSTALL_SUCCESS;

   do
   {
      if (rrasWizard)
      {
         SafeDLL rrasDLL(L"mprsnap.dll");

         FARPROC proc = 0;
         HRESULT hr = rrasDLL.GetProcAddress(L"SetupWithCYS", proc);
         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to to GetProcAddress from mprsnap.dll: hr = 0x%1!x!",
                   hr));

            CYS_APPEND_LOG(String::format(
                              IDS_LOG_EXPRESS_RRAS_FAILED, 
                              GetErrorMessage(hr).c_str()));

            InstallationUnitProvider::GetInstance().
               GetExpressInstallationUnit().SetExpressRoleResult(
                  ExpressInstallationUnit::EXPRESS_RRAS_FAILURE);

            result = INSTALL_FAILURE;
            break;
         }

         UpdateInstallationProgressText(hwnd, IDS_RRAS_CONFIG_PROGRESS);

         RRASSNAPPROC rrasproc = reinterpret_cast<RRASSNAPPROC>(proc);
         hr = CallRRASWizard(rrasproc);
         if (ERROR_CANCELLED == HRESULT_CODE(hr))
         {
            LOG(L"The RRAS wizard was cancelled by the user");
            
            CYS_APPEND_LOG(String::load(IDS_LOG_EXPRESS_RRAS_CANCELLED));
   
            result = INSTALL_CANCELLED;

            InstallationUnitProvider::GetInstance().
               GetExpressInstallationUnit().SetExpressRoleResult(
                  ExpressInstallationUnit::EXPRESS_RRAS_CANCELLED);

            break;
         }
         else if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed during call to RRAS Wizard: hr = 0x%1!x!",
                   hr));
         
            CYS_APPEND_LOG(String::format(
                              IDS_LOG_EXPRESS_RRAS_FAILED, 
                              GetErrorMessage(hr).c_str()));

            result = INSTALL_FAILURE;

            InstallationUnitProvider::GetInstance().
               GetExpressInstallationUnit().SetExpressRoleResult(
                  ExpressInstallationUnit::EXPRESS_RRAS_FAILURE);

            break;
         }

         State::GetInstance().SetLocalNIC(localNIC, true);

         CYS_APPEND_LOG(String::load(IDS_LOG_EXPRESS_RRAS_SUCCESSFUL));
      }

   } while (false);

   LOG_INSTALL_RETURN(result);

   return result;
}

HRESULT
RRASInstallationUnit::CallRRASWizard(RRASSNAPPROC proc)
{
   LOG_FUNCTION(RRASInstallationUnit::CallRRASWizard);

   HRESULT hr = S_OK;

   do
   {
      wchar_t* guidString = 0;

      hr = proc(CYS_EXPRESS_RRAS, reinterpret_cast<void**>(&guidString));
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed during call to rrasproc: hr = 0x%1!x!",
                hr));

         break;
      }

      localNIC = guidString;

      HRESULT unused = Win::LocalFree(guidString);
      ASSERT(SUCCEEDED(unused));

      LOG(localNIC);
   } while (false);

   LOG_HRESULT(hr);
   return hr;
}

bool
RRASInstallationUnit::GetMilestoneText(String& message)
{
   LOG_FUNCTION(RRASInstallationUnit::GetMilestoneText);

   message = String::load(IDS_RRAS_FINISH_TEXT);

   LOG_BOOL(true);
   return true;
}

bool
RRASInstallationUnit::GetUninstallMilestoneText(String& message)
{
   LOG_FUNCTION(RRASInstallationUnit::GetUninstallMilestoneText);

   message = String::load(IDS_RRAS_UNINSTALL_TEXT);

   LOG_BOOL(true);
   return true;
}

void
RRASInstallationUnit::SetExpressPathValues(
   bool runRRASWizard)
{
   LOG_FUNCTION(RRASInstallationUnit::SetExpressPathValues);

   LOG(String::format(
          L"runRRASWizard = %1",
          runRRASWizard ? L"true" : L"false"));

   rrasWizard = runRRASWizard;

}

bool
RRASInstallationUnit::ShouldRunRRASWizard() const
{
   LOG_FUNCTION(RRASInstallationUnit::ShouldRunRRASWizard);

   LOG_BOOL(rrasWizard);
   return rrasWizard;
}

bool
RRASInstallationUnit::IsRoutingOn() const
{
   LOG_FUNCTION(RRASInstallationUnit::IsRoutingOn);

   return ShouldRunRRASWizard();
}

String
RRASInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(RRASInstallationUnit::GetServiceDescription);

   String result;

   unsigned int resultID = descriptionID;

   if (GetStatus() == STATUS_COMPLETED)
   {
      resultID = installedDescriptionID;
   }

   result = String::load(resultID);

   ASSERT(!result.empty());

   return result;
}

void
RRASInstallationUnit::ServerRoleLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      RRASInstallationUnit::ServerRoleLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (IsServiceInstalled())
   {
      ASSERT(linkIndex == 0);

      LaunchMYS();
   }
   else
   {
      ASSERT(linkIndex == 0);

      LOG(L"Showing configuration help");

      ShowHelp(CYS_RRAS_FINISH_PAGE_HELP);
   }
}
  
void
RRASInstallationUnit::FinishLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      RRASInstallationUnit::FinishLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (installing)
   {
      if (linkIndex == 0)
      {
         if (GetInstallResult() != INSTALL_SUCCESS)
         {
            // launch the snapin for success and failure

            LOG(L"Launching RRAS snapin");

            LaunchMMCConsole(L"rrasmgmt.msc");
         }
         else
         {
            LOG("Showing after checklist");

            ShowHelp(CYS_RRAS_AFTER_FINISH_HELP);
         }
      }
   }
   else
   {
      LOG(L"Launching RRAS snapin");

      LaunchMMCConsole(L"rrasmgmt.msc");
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\terminalserverinstallationunit.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      TerminalServerInstallationUnit.h
//
// Synopsis:  Declares a TerminalServerInstallationUnit
//            This object has the knowledge for installing the
//            Application service portion of Terminal Server
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_TERMINALSERVERINSTALLATIONUNIT_H
#define __CYS_TERMINALSERVERINSTALLATIONUNIT_H

#include "InstallationUnit.h"

class TerminalServerInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      TerminalServerInstallationUnit();

      // Destructor

      virtual
      ~TerminalServerInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      UnInstallReturnType
      UnInstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      String
      GetFinishText();

      virtual
      bool
      GetMilestoneText(String& message);

      virtual
      bool
      GetUninstallMilestoneText(String& message);

      virtual
      String
      GetServiceDescription();

      virtual
      void
      ServerRoleLinkSelected(int linkIndex, HWND hwnd);

      virtual
      void
      FinishLinkSelected(int linkIndex, HWND hwnd);

      // Terminal Server specific 

      DWORD
      GetApplicationMode();

      bool
      SetApplicationMode(DWORD mode) const;

      void
      SetInstallTS(bool install);

      bool
      GetInstallTS() const { return installTS; }

      bool
      IsRemoteDesktopEnabled() const;

      HRESULT
      EnableRemoteDesktop();

   private:

      DWORD applicationMode;

      bool installTS;
};

#endif // __CYS_TERMINALSERVERINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\terminalserverinstallationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      TerminalServerInstallationUnit.cpp
//
// Synopsis:  Defines a TerminalServerInstallationUnit
//            This object has the knowledge for installing the
//            Application services portions of Terminal Server
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "TerminalServerInstallationUnit.h"


// Finish page help 
static PCWSTR CYS_TS_FINISH_PAGE_HELP = L"cys.chm::/terminal_server_role.htm";
static PCWSTR CYS_TS_MILESTONE_HELP = L"cys.chm::/terminal_server_role.htm#termsrvsummary";
static PCWSTR CYS_TS_AFTER_FINISH_HELP = L"cys.chm::/terminal_server_role.htm#termsrvcompletion";
static PCWSTR CYS_TS_LICENSING_HELP   = L"cys.chm::/terminal_server_role.htm#termsrvlicensing";

TerminalServerInstallationUnit::TerminalServerInstallationUnit() :
   applicationMode(static_cast<DWORD>(-1)),
   installTS(true),
   InstallationUnit(
      IDS_TERMINAL_SERVER_TYPE, 
      IDS_TERMINAL_SERVER_DESCRIPTION,
      IDS_TS_FINISH_TITLE,
      IDS_TS_FINISH_UNINSTALL_TITLE,
      IDS_TS_FINISH_MESSAGE,
      IDS_TS_INSTALL_FAILED,
      IDS_TS_UNINSTALL_MESSAGE,
      IDS_TS_UNINSTALL_FAILED,
      IDS_TS_UNINSTALL_WARNING,
      IDS_TS_UNINSTALL_CHECKBOX,
      CYS_TS_FINISH_PAGE_HELP,
      CYS_TS_MILESTONE_HELP,
      CYS_TS_AFTER_FINISH_HELP,
      TERMINALSERVER_SERVER)
{
   LOG_CTOR(TerminalServerInstallationUnit);
}


TerminalServerInstallationUnit::~TerminalServerInstallationUnit()
{
   LOG_DTOR(TerminalServerInstallationUnit);
}


InstallationReturnType
TerminalServerInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(TerminalServerInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS_REBOOT;

   CYS_APPEND_LOG(String::load(IDS_LOG_TERMINAL_SERVER_CONFIGURE));

   UpdateInstallationProgressText(hwnd, IDS_TS_PROGRESS);

   if (installTS)
   {
      // OCManager will reboot so prompt the user now

      if (IDOK == Win::MessageBox(
                     hwnd,
                     String::load(IDS_CONFIRM_REBOOT),
                     String::load(IDS_WIZARD_TITLE),
                     MB_OKCANCEL))
      {
         // Setup TS using an unattend file

         String unattendFileText;
         String infFileText;

         unattendFileText += L"[Components]\n";
         unattendFileText += L"TerminalServer=ON";

         // IMPORTANT!!! The OCManager will reboot the machine
         // The log file and registry keys must be written before we launch
         // the OCManager or all will be lost

         String homeKeyValue = CYS_HOME_REGKEY_TERMINAL_SERVER_VALUE;
         State::GetInstance().SetHomeRegkey(homeKeyValue);

         // set the key so CYS has to run again

         bool regkeyResult = SetRegKeyValue(
                                CYS_HOME_REGKEY, 
                                CYS_HOME_REGKEY_MUST_RUN, 
                                CYS_HOME_RUN_KEY_RUN_AGAIN,
                                HKEY_LOCAL_MACHINE,
                                true);
         ASSERT(regkeyResult);

         // NTRAID#NTBUG9-478515-2001/10/09-jeffjon
         // Now set the state of the rerun to false so that the wizard
         // doesn't run again until after the reboot

//         State::GetInstance().SetRerunWizard(false);

         // The OCManager will reboot after installation so we don't want the finish
         // page to show the log or help

         result = INSTALL_SUCCESS_REBOOT;

         bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
         if (!ocmResult)
         {
            CYS_APPEND_LOG(String::load(IDS_LOG_TERMINAL_SERVER_SERVER_FAILED));
            result = INSTALL_FAILURE;

            // Reset the regkeys since the OCM didn't reboot the machine
            
            homeKeyValue = CYS_HOME_REGKEY_DEFAULT_VALUE;
            State::GetInstance().SetHomeRegkey(homeKeyValue);

            // set the key so CYS doesn't have to run again

            homeKeyValue = CYS_HOME_REGKEY_DEFAULT_VALUE;
            State::GetInstance().SetHomeRegkey(homeKeyValue);

            regkeyResult = 
               SetRegKeyValue(
                  CYS_HOME_REGKEY, 
                  CYS_HOME_REGKEY_MUST_RUN, 
                  CYS_HOME_RUN_KEY_DONT_RUN,
                  HKEY_LOCAL_MACHINE,
                  true);

            ASSERT(regkeyResult);
         }
      }
      else
      {
         // user aborted the installation

         CYS_APPEND_LOG(String::load(IDS_LOG_TERMINAL_SERVER_ABORTED));

         LOG(L"The installation was cancelled by the user when prompted for reboot.");
         result = INSTALL_CANCELLED;

         // Reset the regkeys since the OCM didn't reboot the machine
         
         String homeKeyValue = CYS_HOME_REGKEY_DEFAULT_VALUE;
         State::GetInstance().SetHomeRegkey(homeKeyValue);

         // set the key so CYS doesn't have to run again

         bool regkeyResult = 
            SetRegKeyValue(
               CYS_HOME_REGKEY, 
               CYS_HOME_REGKEY_MUST_RUN, 
               CYS_HOME_RUN_KEY_DONT_RUN,
               HKEY_LOCAL_MACHINE,
               true);

         ASSERT(regkeyResult);
      }
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

UnInstallReturnType
TerminalServerInstallationUnit::UnInstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(TerminalServerInstallationUnit::UnInstallService);

   UnInstallReturnType result = UNINSTALL_SUCCESS;

   CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_TERMINAL_SERVER_CONFIGURE));

   UpdateInstallationProgressText(hwnd, IDS_TS_UNINSTALL_PROGRESS);

   // OCManager will reboot so prompt the user now

   if (IDOK == Win::MessageBox(
                  hwnd,
                  String::load(IDS_CONFIRM_REBOOT),
                  String::load(IDS_WIZARD_TITLE),
                  MB_OKCANCEL))
   {
      // IMPORTANT!!! The OCManager will reboot the machine
      // The log file and registry keys must be written before we launch
      // the OCManager or all will be lost

      String homeKeyValue = CYS_HOME_REGKEY_UNINSTALL_TERMINAL_SERVER_VALUE;
      State::GetInstance().SetHomeRegkey(homeKeyValue);

      // set the key so CYS has to run again

      bool regkeyResult = SetRegKeyValue(
                           CYS_HOME_REGKEY, 
                           CYS_HOME_REGKEY_MUST_RUN, 
                           CYS_HOME_RUN_KEY_RUN_AGAIN,
                           HKEY_LOCAL_MACHINE,
                           true);
      ASSERT(regkeyResult);

      String unattendFileText;
      String infFileText;

      unattendFileText += L"[Components]\n";
      unattendFileText += L"TerminalServer=OFF";

      bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
      if (ocmResult && 
         !IsServiceInstalled())
      {
         LOG(L"The terminal server uninstall succeeded");

      }
      else
      {

         CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_TERMINAL_SERVER_ABORTED));

         LOG(L"The terminal server uninstall failed");
         result = UNINSTALL_FAILURE;

         // set the key so CYS has to doesn't run again

         homeKeyValue = CYS_HOME_REGKEY_DEFAULT_VALUE;
         State::GetInstance().SetHomeRegkey(homeKeyValue);


         regkeyResult = 
            SetRegKeyValue(
               CYS_HOME_REGKEY, 
               CYS_HOME_REGKEY_MUST_RUN, 
               CYS_HOME_RUN_KEY_DONT_RUN,
               HKEY_LOCAL_MACHINE,
               true);
         ASSERT(regkeyResult);

      }
   }
   else
   {
      LOG(L"User chose cancel from the reboot warning dialog");

      CYS_APPEND_LOG(String::load(IDS_LOG_TS_UNINSTALL_CANCEL_REBOOT));

      result = UNINSTALL_CANCELLED;
   }

   LOG_UNINSTALL_RETURN(result);

   return result;
}

bool
TerminalServerInstallationUnit::GetMilestoneText(String& message)
{
   LOG_FUNCTION(TerminalServerInstallationUnit::GetMilestoneText);

   if (installTS)
   {
      message += String::load(IDS_TERMINAL_SERVER_FINISH_SERVER_TS);
   }

   LOG_BOOL(installTS);
   return installTS;
}

bool
TerminalServerInstallationUnit::GetUninstallMilestoneText(String& message)
{
   LOG_FUNCTION(TerminalServerInstallationUnit::GetUninstallMilestoneText);

   message = String::load(IDS_TS_UNINSTALL_TEXT);

   LOG_BOOL(true);
   return true;
}

String
TerminalServerInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(TerminalServerInstallationUnit::GetServiceDescription);

   unsigned int resourceID = static_cast<unsigned int>(-1);

   if (IsServiceInstalled())
   {
      resourceID = IDS_TERMINAL_SERVER_DESCRIPTION_INSTALLED;
   }
   else
   {
      resourceID = descriptionID;
   }

   ASSERT(resourceID != static_cast<unsigned int>(-1));

   return String::load(resourceID);
}

String
TerminalServerInstallationUnit::GetFinishText()
{
   LOG_FUNCTION(TerminalServerInstallationUnit::GetFinishText);

   unsigned int messageID = IDS_TS_FINISH_MESSAGE;
   
   if (installing)
   {
      InstallationReturnType result = GetInstallResult();

      if (result == INSTALL_CANCELLED)
      {
         messageID = IDS_TS_FINISH_CANCELLED;
      }
      else if (result != INSTALL_SUCCESS &&
               result != INSTALL_SUCCESS_REBOOT &&
               result != INSTALL_SUCCESS_PROMPT_REBOOT)
      {
         messageID = finishInstallFailedMessageID;
      }
      else
      {
         messageID = IDS_TS_FINISH_MESSAGE;
      }
   }
   else
   {
      messageID = finishUninstallMessageID;

      UnInstallReturnType result = GetUnInstallResult();
      if (result == UNINSTALL_CANCELLED)
      {
         messageID = IDS_TS_UNINSTALL_FINISH_CANCELLED;
      }
      else if (result != UNINSTALL_SUCCESS &&
               result != UNINSTALL_SUCCESS_REBOOT &&
               result != UNINSTALL_SUCCESS_PROMPT_REBOOT)
      {
         messageID = finishUninstallFailedMessageID;
      }
   }

   return String::load(messageID);
}

DWORD
TerminalServerInstallationUnit::GetApplicationMode()
{
   LOG_FUNCTION(TerminalServerInstallationUnit::GetApplicationMode);

   DWORD result = static_cast<DWORD>(-1);

   if (applicationMode == static_cast<DWORD>(-1))
   {
      // Read the application mode from the registry

      bool keyResult = GetRegKeyValue(
                          CYS_APPLICATION_MODE_REGKEY, 
                          CYS_APPLICATION_MODE_VALUE, 
                          result);

      if (keyResult)
      {
         applicationMode = result;
      } 
   }

   result = applicationMode;

   LOG(String::format(L"Application mode = %1!d!", result));

   return result;
}

bool
TerminalServerInstallationUnit::SetApplicationMode(DWORD mode) const
{
   LOG_FUNCTION2(
      TerminalServerInstallationUnit::SetApplicationMode,
      String::format(L"%1!d!", mode));

   bool result = SetRegKeyValue(
                    CYS_APPLICATION_MODE_REGKEY, 
                    CYS_APPLICATION_MODE_VALUE, 
                    mode);
   ASSERT(result);

   return result;
}


void
TerminalServerInstallationUnit::SetInstallTS(bool install)
{
   LOG_FUNCTION2(
      TerminalServerInstallationUnit::SetInstallTS,
      install ? L"true" : L"false");

   installTS = install;
}

bool
TerminalServerInstallationUnit::IsRemoteDesktopEnabled() const
{
   LOG_FUNCTION(TerminalServerInstallationUnit::IsRemoteDesktopEnabled);

   bool result = false;

   do
   {
      SmartInterface<ILocalMachine> localMachine;
      HRESULT hr = localMachine.AcquireViaCreateInstance(
                      CLSID_ShellLocalMachine,
                      0,
                      CLSCTX_INPROC_SERVER,
                      IID_ILocalMachine);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"CoCreate on ILocalMachine failed: hr = %1!x!",
                hr));

         break;
      }

      VARIANT_BOOL isEnabled = FALSE;
      hr = localMachine->get_isRemoteConnectionsEnabled(&isEnabled);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed on call to get_isRemoteConnectionsEnabled: hr = %1!x!",
                hr));
      }

      result = isEnabled != 0;
   } while(false);

   LOG_BOOL(result);

   return result;
}

HRESULT
TerminalServerInstallationUnit::EnableRemoteDesktop()
{
   LOG_FUNCTION(TerminalServerInstallationUnit::EnableRemoteDesktop);

   HRESULT hr = S_OK;

   do
   {
      SmartInterface<ILocalMachine> localMachine;
      hr = localMachine.AcquireViaCreateInstance(
              CLSID_ShellLocalMachine,
              0,
              CLSCTX_INPROC_SERVER,
              IID_ILocalMachine);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"CoCreate on ILocalMachine failed: hr = %1!x!",
                hr));

         break;
      }

      VARIANT_BOOL enable = true;
      hr = localMachine->put_isRemoteConnectionsEnabled(enable);
      
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed on call to put_isRemoteConnectionsEnabled: hr = %1!x!",
                hr));
      }
   } while(false);

   LOG_HRESULT(hr);

   return hr;
}

void
TerminalServerInstallationUnit::ServerRoleLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      TerminalServerInstallationUnit::ServerRoleLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (IsServiceInstalled())
   {
      ASSERT(linkIndex == 0);

      LaunchMYS();
   }
   else
   {
      ASSERT(linkIndex == 0);

      LOG(L"Showing configuration help");

      ShowHelp(CYS_TS_FINISH_PAGE_HELP);
   }
}

void
TerminalServerInstallationUnit::FinishLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      TerminalServerInstallationUnit::FinishLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (installing)
   {
      if (linkIndex == 0)
      {
         if (IsServiceInstalled())
         {
            LOG("Showing TS licensing help");

            ShowHelp(CYS_TS_LICENSING_HELP);
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by cys.rc
//
#define IDS_WIZARD_SHORTCUT             1
#define IDS_ALREADY_RUNNING             2
#define IDS_BIG_BOLD_FONT_NAME          3
#define IDS_BIG_BOLD_FONT_SIZE          4
#define IDS_LOCAL_AREA_CONNECTION       5
#define IDS_INDEXING_SERVICE_OFF_YES_RADIO 6
#define IDS_INDEXING_SERVICE_OFF_NO_RADIO 7
#define IDS_CONFIRM_REBOOT              8
#define IDS_NOT_ADMIN                   9
#define IDS_DC_UPGRADE_NOT_COMPLETE     10
#define IDS_DCPROMO_RUNNING             11
#define IDS_DCPROMO_PENDING_REBOOT      12
#define IDS_EXPRESS_RRAS_FINISH_TEXT    13
#define IDS_SERVER_CD                   14
#define IDS_ADVANCED_SERVER_CD          15
#define IDS_DATACENTER_SERVER_CD        16
#define IDS_WINDOWS_CD                  17
#define IDS_POP3_SERVER_DESCRIPTION_SERVERED 18
#define IDS_POP3_SERVER_DESCRIPTION_INSTALLED 18
#define IDS_POP3_SERVER_TYPE            19
#define IDS_POP3_SERVER_DESCRIPTION     20
#define IDS_LOG_POP3_HEADING            21
#define IDS_LOG_POP3_SERVER_SUCCESS     22
#define IDS_LOG_POP3_SERVER_FAILURE     23
#define IDS_POP3_FINISH_TEXT            24
#define IDS_GENERATED_NAME_WAS_TWEAKED  25
#define IDS_PASSWORD_MISMATCH           26
#define IDS_IPADDRESS_REQUIRED          27
#define IDS_CAPS_LOCK_TIP_TITLE         28
#define IDS_CAPS_LOCK_TIP_TEXT          29
#define IDS_SYSOC_COMMAND_LINE          30
#define IDS_BOTH_IPADDRESS_REQUIRED     31
#define IDS_SYNC_RESTORE_PASSWORD_TITLE 32
#define IDS_SYNC_RESTORE_PASSWORD_SUBTITLE 33
#define IDS_TS_PAGE_REMOTE_DESKTOP      34
#define IDS_POP3_TITLE                  35
#define IDS_NOTS_NO_REMOTE_DESKTOP      36
#define IDS_POP3_SUBTITLE               37
#define IDS_MASK_REQUIRED               38
#define IDS_FAILED_SERVER               39
#define IDS_NO_CHANGES_MESSAGEBOX_TEXT  40
#define IDS_LOG_DHCP_HEADER             41
#define IDS_LOG_DNS_HEADER              42
#define IDS_LOG_EXPRESS_HEADER          43
#define IDS_LOG_RRAS_HEADING            44
#define IDS_LOG_WINS_HEADING            45
#define IDS_LOG_EXPRESS_RRAS_SUCCESSFUL 46
#define IDS_LOG_EXPRESS_RRAS_CANCELLED  47
#define IDS_LOG_EXPRESS_RRAS_CANCELED   47
#define IDS_LOG_EXPRESS_RRAS_FAILED     48
#define IDS_LOG_EXPRESS_CANCELED        49
#define IDS_NETWORK_SERVER_TYPE         50
#define IDS_NETWORK_SERVER_DESCRIPTION  51
#define IDS_TERMINAL_SERVER_TYPE        52
#define IDS_TERMINAL_SERVER_DESCRIPTION 53
#define IDS_FILE_SERVER_TYPE            54
#define IDS_FILE_SERVER_DESCRIPTION     55
#define IDS_PRINT_SERVER_TYPE           56
#define IDS_PRINT_SERVER_DESCRIPTION    57
#define IDS_SHARE_POINT_TYPE            58
#define IDS_DECISION_EXPRESS_MULTIPLE_NICS 58
#define IDS_SHARE_POINT_DESCRIPTION     59
#define IDS_FILE_MILESTONE_NO_CHANGES   59
#define IDS_MEDIA_SERVER_TYPE           60
#define IDS_MEDIA_SERVER_DESCRIPTION    61
#define IDS_WEB_SERVER_TYPE             62
#define IDS_WEB_SERVER_DESCRIPTION      63
#define IDS_DHCP_SERVER_TYPE            64
#define IDS_DHCP_SERVER_DESCRIPTION     65
#define IDS_DNS_SERVER_TYPE             66
#define IDS_DNS_SERVER_DESCRIPTION      67
#define IDS_WINS_SERVER_TYPE            68
#define IDS_WINS_SERVER_DESCRIPTION     69
#define IDS_RRAS_SERVER_TYPE            70
#define IDS_RRAS_SERVER_DESCRIPTION     71
#define IDS_FILE_FINISH_CONFIGURE       71
#define IDS_EXPRESS_PATH_TYPE           72
#define IDS_EXPRESS_PATH_DESCRIPTION    73
#define IDS_DOMAIN_CONTROLLER_TYPE      74
#define IDS_DOMAIN_CONTROLLER_DESCRIPTION 75
#define IDS_CLUSTER_SERVER_TYPE         76
#define IDS_SYSOC_FULL_PATH             76
#define IDS_CLUSTER_SERVER_DESCRIPTION  77
#define IDS_TAPI_CONFIG_COMMAND_FORMAT  77
#define IDS_WEB_DESCRIPTION_SERVERED    78
#define IDS_WEB_DESCRIPTION_INSTALLED   78
#define IDS_MEDIA_SERVER_DESCRIPTION_SERVERED 79
#define IDS_MEDIA_SERVER_DESCRIPTION_INSTALLED 79
#define IDS_TERMINAL_SERVER_DESCRIPTION_SERVERED 80
#define IDS_TERMINAL_SERVER_DESCRIPTION_INSTALLED 80
#define IDS_EXPRESS_CANCELLED           86
#define IDS_LOG_EXPRESS_CANCELLED       87
#define IDS_TAPI_CONFIG_EXE             88
#define IDS_FILE_SERVER_RUN_SHARE_WIZARD 89
#define IDS_FILE_FINISH_NOSHARES_NOQUOTA_NOINDEXSTOP 90
#define IDS_DOMAIN_CONTROLLER_DESCRIPTION_SERVERED 91
#define IDS_DOMAIN_CONTROLLER_DESCRIPTION_INSTALLED 91
#define IDS_NETWORK_SERVER_DESCRIPTION_SERVERED 92
#define IDS_EXPRESS_DNS_SERVER_FAILURE  92
#define IDS_CLUSTER_SERVER_DESCRIPTION_SERVERED 93
#define IDS_EXPRESS_DNS_FORWARDER_FAILURE 93
#define IDS_DNS_SERVER_DESCRIPTION_SERVERED 94
#define IDS_DNS_SERVER_DESCRIPTION_INSTALLED 94
#define IDS_DHCP_SERVER_DESCRIPTION_SERVERED 95
#define IDS_DHCP_SERVER_DESCRIPTION_INSTALLED 95
#define IDS_WINS_SERVER_DESCRIPTION_SERVERED 96
#define IDS_WINS_SERVER_DESCRIPTION_INSTALLED 96
#define IDS_RRAS_SERVER_DESCRIPTION_SERVERED 97
#define IDS_RRAS_SERVER_DESCRIPTION_INSTALLED 97
#define IDS_RRAS_SERVER_DESCRIPTION2    98
#define IDS_CLOSE                       99
#define IDS_WELCOME_TITLE               100
#define IDS_WELCOME_SUBTITLE            101
#define IDB_BANNER16                    101
#define IDS_FILE_FINISH_TITLE           102
#define IDB_WATERMARK16                 103
#define IDS_FINISH_TITLE                103
#define IDB_WATERMARK256                104
#define IDS_CUSTOM_SERVER_TITLE         104
#define IDB_BANNER256                   105
#define IDS_CUSTOM_SERVER_SUBTITLE      105
#define IDD_WELCOME_PAGE                106
#define IDS_NETWORK_SERVER_TITLE        106
#define IDD_FINISH_PAGE                 107
#define IDS_NETWORK_SERVER_SUBTITLE     107
#define IDD_CUSTOM_SERVER_PAGE          108
#define IDS_DECISION_TITLE              108
#define IDS_DECISION_SUBTITLE           109
#define IDS_AD_DOMAIN_TITLE             110
#define IDS_AD_DOMAIN_SUBTITLE          111
#define IDS_NETBIOS_NAME_TITLE          112
#define IDS_NETBIOS_NAME_SUBTITLE       113
#define IDS_EXPRESS_DNS_TITLE           114
#define IDS_EXPRESS_DNS_SUBTITLE        115
#define IDD_DECISION_PAGE               116
#define IDS_EXPRESS_DHCP_TITLE          116
#define IDD_AD_DOMAIN_NAME_PAGE         117
#define IDS_EXPRESS_DHCP_SUBTITLE       117
#define IDD_NETBIOS_NAME                118
#define IDS_RESTORE_PASSWORD_TITLE      118
#define IDC_NETBIOS                     119
#define IDS_RESTORE_PASSWORD_SUBTITLE   119
#define IDD_EXPRESS_DNS_PAGE            120
#define IDS_PRINT_SERVER_TITLE          120
#define IDD_EXPRESS_DHCP_PAGE           121
#define IDS_PRINT_SERVER_SUBTITLE       121
#define IDS_TERMINAL_SERVER_TITLE       122
#define IDS_TERMINAL_SERVER_SUBTITLE    123
#define IDC_PASSWORD                    124
#define IDS_SHARE_POINT_TITLE           124
#define IDS_FILE_FINISH_NOSHARES_NOQUOTA_NOINDEXSTART 124
#define IDC_CONFIRM                     125
#define IDS_SHARE_POINT_SUBTITLE        125
#define IDS_FILE_FINISH_NOSHARES_NOQUOTA 125
#define IDD_PRINT_SERVER_PAGE           126
#define IDS_FILE_SERVER_TITLE           126
#define IDS_FILE_SERVER_SUBTITLE        127
#define IDS_INDEXING_TITLE              128
#define IDD_FILE_SERVER_PAGE            129
#define IDS_INDEXING_SUBTITLE           129
#define IDD_INDEXING_PAGE               130
#define IDS_FILE_FINISH_DISK_QUOTAS     130
#define IDS_FILE_FINISH_INDEXING_ON     131
#define IDS_FILE_FINISH_INDEXING_OFF    132
#define IDD_BEFORE_BEGIN_PAGE           132
#define IDS_FINISH_NO_CHANGES           133
#define IDS_PRINT_FINISH_ALL_CLIENTS    134
#define IDD_CLUSTER_SERVER_PAGE         134
#define IDS_PRINT_FINISH_W2K_CLIENTS    135
#define IDI_CYS_ICON                    135
#define IDS_NIC_SELECTION_TITLE         136
#define IDS_NIC_SELECTION_SUBTITLE      137
#define IDI_SMALL_WARNING               137
#define IDS_BEFORE_BEGIN_TITLE          138
#define IDS_BEFORE_BEGIN_SUBTITLE       139
#define IDI_CHECK                       139
#define IDS_CLUSTER_TITLE               140
#define IDI_CURRENT_OPERATION2          140
#define IDS_FILE_FINISH_NOSHARES_NOINDEXSTOP 140
#define IDS_CLUSTER_SUBTITLE            141
#define IDI_ERROR_OPERATION             141
#define IDS_FILE_FINISH_NOSHARES_NOINDEXSTART 141
#define IDS_INDEX_PAGE_STATIC_SERVERED  142
#define IDD_DNS_FORWARDER_PAGE          142
#define IDS_INDEX_PAGE_STATIC_NOT_SERVERED 143
#define IDS_SERVER_ROLE_COLUMN_HEADER   144
#define IDS_STATUS_COLUMN_HEADER        145
#define IDS_STATUS_COMPLETED            146
#define IDS_EXPRESS_REBOOT_TITLE        147
#define IDS_EXPRESS_REBOOT_SUBTITLE     148
#define IDS_DNS_FORWARDER_TITLE         149
#define IDD_NET_DETECT_PROGRESS_DIALOG  149
#define IDS_DNS_FORWARDER_SUBTITLE      150
#define IDS_FORWARDER_STATIC_TEXT       151
#define IDD_DISCONNECTED_NIC_DIALOG     151
#define IDS_FORWARDER_IPADDRESS_REQUIRED 152
#define IDS_EXPRESS_RRAS_TITLE          153
#define IDS_EXPRESS_RRAS_SUBTITLE       154
#define IDD_SYNC_RESTORE_PASSWORD_PAGE  154
#define IDS_DECISION_EXPRESS_TOO_LONG_TEXT 155
#define IDD_MILESTONE_PAGE              155
#define IDD_PROGRESS_PAGE               157
#define IDS_EXPRESS_RRAS_TOO_LONG_TEXT_IN_AND_OUT 158
#define IDD_EXPRESS_REBOOT_PAGE         158
#define IDS_EXPRESS_RRAS_TOO_LONG_TEXT_OUT 159
#define IDS_EXPRESS_REBOOT_FORWARDER_FAILED 160
#define IDS_EXPRESS_REBOOT_FORWARDER_SUCCEEDED 161
#define IDS_EXPRESS_REBOOT_DNS_SERVER_FAILED 162
#define IDS_EXPRESS_REBOOT_DNS_SERVER_SUCCEEDED 163
#define IDS_LOG_DCPROMO_REBOOT_SUCCEEDED 164
#define IDS_EXPRESS_IPADDRESS_SUCCESS   165
#define IDS_EXPRESS_SUBNETMASK_SUCCESS  166
#define IDS_EXPRESS_DNSSERVER_SUCCESS   167
#define IDS_EXPRESS_SERVER_AD           168
#define IDS_EXPRESS_AD_DOMAIN_NAME      169
#define IDS_EXPRESS_AD_NETBIOS_NAME     170
#define IDS_SERVER_ONLY                 171
#define IDS_STATUS_CONFIGURED           172
#define IDS_LOG_FILE_SERVER_SUCCESS     173
#define IDS_FILE_FINISH_NOSHARES        176
#define IDS_FILE_FINISH_NOQUOTA_NOINDEXSTOP 177
#define IDS_FILE_FINISH_NOQUOTA_NOINDEXSTART 178
#define IDS_FILE_FINISH_NOQUOTA         179
#define IDS_FILE_FINISH_NOINDEXSTOP     180
#define IDS_FILE_FINISH_NOINDEXSTART    181
#define IDS_FINISH_SUBTITLE             182
#define IDS_WEBAPP_TITLE                183
#define IDS_EXPRESS_REBOOT_NO_FORWARDER 184
#define IDS_EXPRESS_REBOOT_LOG_NO_FORWARDER 185
#define IDS_DISK_SPACE_LIMIT_CONVERSION_ERROR 186
#define IDS_WARNING_LEVEL_CONVERSION_ERROR 187
#define IDS_LOG_RRAS_PORT_ERROR         188
#define IDS_CUSTOM_SERVER_SUBTITLE_JOINED 189
#define IDS_WEB_FINISH_DIALOG_TEXT_WITH_SAK 190
#define IDS_WEBAPP_SUBTITLE             190
#define IDS_FILESERVER_FINISH_DIALOG_TEXT_WITH_SAK 191
#define IDS_WEB_MILESTONE_FRONTPAGE     191
#define IDS_EXPRESS_DHCP_NOT_REQUIRED   192
#define IDS_EXPRESS_DHCP_SCOPE_NONE     193
#define IDS_EXPRESS_DHCP_NO_AUTHORIZATION 194
#define IDS_WIZARD_TITLE                197
#define IDS_STATUS_NO                   198
#define IDS_POP3_FINISH_DIALOG_TEXT     199
#define IDS_WEB_MILESTONE_ASPNET        199
#define IDC_BIG_BOLD_TITLE              200
#define IDS_DHCP_INF_WINDOW_TITLE       200
#define IDC_FINISH_MESSAGE              201
#define IDS_LAUNCH_DHCP_WIZARD_COMMAND_LINE 201
#define IDS_LAUNCH_DHCP_WIZARD_FAILED   202
#define IDS_DHCP_WIZARD_FAILED          203
#define IDS_DHCP_WIZARD_SUCCEEDED       204
#define IDS_LOG_DHCP_COMPLETED_SUCCESSFULLY 205
#define IDS_LOG_DHCP_WIZARD_ERROR       206
#define IDS_LOG_DHCP_SERVER_FAILED      207
#define IDS_LOG_SERVER_START_DHCP       208
#define IDS_LOG_DHCP_WIZARD_ERROR_FORMAT 209
#define IDS_MILESTONE_TITLE             210
#define IDS_MILESTONE_SUBTITLE          211
#define IDS_LOG_TERMINAL_SERVER_CONFIGURE 212
#define IDS_LOG_TERMINAL_SERVER_ABORTED 213
#define IDS_LOG_TERMINAL_SERVER_SERVER_FAILED 214
#define IDS_LOG_TERMINAL_SERVER_REBOOT_SUCCESS 215
#define IDS_LOG_TERMINAL_SERVER_REBOOT_FAILED 216
#define IDS_LOG_DCPROMO_REBOOT_FAILED   217
#define IDS_LOG_DHCP_AUTHORIZATION_SUCCEEDED 218
#define IDS_LOG_DHCP_AUTHORIZATION_FAILED 219
#define IDS_LOG_TAPI_CONFIG_SUCCEEDED   220
#define IDS_LOG_TAPI_CONFIG_SUCCEEDED_FORMAT 221
#define IDS_LOG_TAPI_CONFIG_FAILED_FORMAT 222
#define IDS_LOG_FILE_SERVER             223
#define IDS_LOG_FILE_SERVER_SET_QUOTAS  224
#define IDS_LOG_INDEXING_STOP_SUCCEEDED 225
#define IDS_LOG_INDEXING_STOP_FAILED    226
#define IDS_LOG_INDEXING_START_SUCCEEDED 227
#define IDS_LOG_INDEXING_START_FAILED   228
#define IDS_LOG_DISK_QUOTA_FAILED       229
#define IDS_LOG_DISK_QUOTA_DRIVE_FORMAT 230
#define IDS_LOG_DISK_QUOTA_LIMIT_FORMAT 231
#define IDS_LOG_DISK_QUOTA_THRESHOLD_FORMAT 232
#define IDS_LOG_DISK_QUOTA_DENY_FORMAT  233
#define IDS_LOG_DISK_QUOTA_NOT_DENY_FORMAT 234
#define IDS_LOG_DISK_QUOTA_LOG_LIMIT    235
#define IDS_LOG_DISK_QUOTA_LOG_WARNING  236
#define IDS_DHCP_EXPRESS_LOG_FAILURE    237
#define IDS_DHCP_EXPRESS_LOG_NOT_REQUIRED 238
#define IDS_DHCP_EXPRESS_LOG_SUCCESS    239
#define IDS_AD_EXPRESS_LOG_FAILURE      240
#define IDS_LOG_DNS_SERVICE_TIMEOUT     241
#define IDS_DNS_SERVICE_START_FAILED    242
#define IDS_LOG_TS_UNINSTALL_CANCEL_REBOOT 243
#define IDS_FILE_MILESTONE_RUN_SHARE_WIZARD 244
#define IDS_LOG_WEBAPP_FRONTPAGE_FAILED 245
#define IDS_DECISION_PAGE_TEXT          246
#define IDS_OPEN_LOG_FORMAT_STRING      247
#define IDS_FINISH_PAGE_FAILURE         249
#define IDS_PROGRESS_TITLE              250
#define IDS_PROGRESS_SUBTITLE           251
#define IDS_FINISH_MESSAGE              252
#define IDS_LOG_UNINSTALL_DOMAIN_CONTROLLER_HEADING 253
#define IDD_UNINSTALL_MILESTONE_PAGE    253
#define IDS_LOG_UNINSTALL_DHCP_HEADER   254
#define IDR_SEARCH_AVI                  254
#define IDS_LOG_UNINSTALL_DNS_HEADER    255
#define IDS_PRINT_SERVER_DESCRIPTION_INSTALLED 256
#define IDS_FILE_SERVER_DESCRIPTION_CONFIGURED_WITH_SAK 257
#define IDS_FILE_SERVER_DESCRIPTION_CONFIGURED 257
#define IDS_FILE_SERVER_DESCRIPTION_CONFIGURED_NO_SAK 258
#define IDS_EXPRESS_DHCP_SCOPE_FAILURE  258
#define IDS_FILE_MILESTONE_QUOTAS       259
#define IDS_FILE_MILESTONE_INDEX_OFF    260
#define IDS_FILE_MILESTONE_INDEX_ON     261
#define IDS_FILE_MILESTONE_INSTALL_FILE_CONSOLE 262
#define IDS_PRINT_PROGRESS_PRINTER_WIZARD 263
#define IDS_PRINT_PROGRESS_DRIVERS_WIZARD 264
#define IDS_PRINT_FINISH_TITLE          265
#define IDS_PRINT_FINISH_MESSAGE        266
#define IDS_CANNOT_COMPLETE             267
#define IDS_PRINT_INSTALL_FAILED        268
#define IDS_PRINT_UNINSTALL_MESSAGE     269
#define IDS_PRINT_UNINSTALL_FAILED      270
#define IDS_SP_FINISH_TITLE             271
#define IDS_LOG_WEBAPP_ASPNET_FAILED    271
#define IDS_SP_FINISH_MESSAGE           272
#define IDS_LOG_WEBAPP_DTC_FAILED       272
#define IDS_SP_INSTALL_FAILED           273
#define IDS_LOG_WEBAPP_PLUS_FAILED      273
#define IDS_SP_UNINSTALL_MESSAGE        274
#define IDS_WEBAPP_FINISH_OPTIONAL_FAILURE_HEADER 274
#define IDS_SP_UNINSTALL_FAILED         275
#define IDS_WEBAPP_FINISH_FRONTPAGE_FAILURE 275
#define IDS_WEB_FINISH_TITLE            276
#define IDS_WEB_FINISH_MESSAGE          277
#define IDS_WEB_INSTALL_FAILED          278
#define IDS_WEB_UNINSTALL_MESSAGE       279
#define IDS_WEB_UNINSTALL_FAILED        280
#define IDS_POP3_FINISH_TITLE           281
#define IDS_POP3_FINISH_MESSAGE         282
#define IDS_POP3_INSTALL_FAILED         283
#define IDS_POP3_UNINSTALL_MESSAGE      284
#define IDS_POP3_UNINSTALL_FAILED       285
#define IDS_TS_FINISH_TITLE             286
#define IDS_TS_FINISH_MESSAGE           287
#define IDS_TS_INSTALL_FAILED           288
#define IDS_TS_UNINSTALL_MESSAGE        289
#define IDS_TS_UNINSTALL_FAILED         290
#define IDS_RRAS_FINISH_TITLE           291
#define IDS_RRAS_FINISH_MESSAGE         292
#define IDS_RRAS_INSTALL_FAILED         293
#define IDS_RRAS_UNINSTALL_MESSAGE      294
#define IDS_RRAS_UNINSTALL_FAILED       295
#define IDS_AD_FINISH_TITLE             296
#define IDS_AD_FINISH_MESSAGE           297
#define IDS_AD_INSTALL_FAILED           298
#define IDS_AD_UNINSTALL_MESSAGE        299
#define IDS_DNS_INF_WINDOW_TITLE        300
#define IDS_LAUNCH_DNS_WIZARD_COMMAND_LINE 301
#define IDS_LAUNCH_DNS_WIZARD_FAILED    302
#define IDS_DNS_WIZARD_FAILED           303
#define IDS_DNS_WIZARD_SUCCEEDED        304
#define IDS_LOG_SERVER_START_DNS        305
#define IDS_LOG_DNS_COMPLETED_SUCCESSFULLY 306
#define IDS_LOG_DNS_WIZARD_ERROR        307
#define IDS_LOG_DNS_WIZARD_CANCELLED    308
#define IDS_LOG_WIZARD_CANCELLED        308
#define IDS_LOG_WIZARD_CANCELED         308
#define IDS_LOG_DNS_SERVER_FAILED       309
#define IDS_LOG_SERVER_WMS_SUCCESS      310
#define IDS_LOG_SERVER_WMS_FAILED       311
#define IDS_AD_UNINSTALL_FAILED         312
#define IDS_DNS_FINISH_TITLE            313
#define IDS_DNS_FINISH_MESSAGE          314
#define IDS_DNS_INSTALL_FAILED          315
#define IDS_DNS_UNINSTALL_MESSAGE       316
#define IDS_DNS_UNINSTALL_FAILED        317
#define IDS_DHCP_FINISH_TITLE           318
#define IDS_DHCP_FINISH_MESSAGE         319
#define IDS_DHCP_INSTALL_FAILED         320
#define IDS_DHCP_UNINSTALL_MESSAGE      321
#define IDS_DHCP_UNINSTALL_FAILED       322
#define IDS_WEBAPP_FINISH_ASPNET_FAILURE 324
#define IDS_WEBAPP_FINISH_DTC_FAILURE   325
#define IDS_WEBAPP_FINISH_COMPLUS_FAILURE 326
#define IDS_WEBAPP_FINISH_OPTIONAL_FAILURE_FOOTER 327
#define IDS_MEDIA_FINISH_TITLE          328
#define IDS_MEDIA_FINISH_MESSAGE        329
#define IDS_MEDIA_INSTALL_FAILED        330
#define IDS_MEDIA_UNINSTALL_MESSAGE     331
#define IDS_MEDIA_UNINSTALL_FAILED      332
#define IDS_WINS_FINISH_TITLE           333
#define IDS_WINS_FINISH_MESSAGE         334
#define IDS_WINS_INSTALL_FAILED         335
#define IDS_WINS_UNINSTALL_MESSAGE      336
#define IDS_WINS_UNINSTALL_FAILED       337
#define IDS_EXPRESS_FINISH_TITLE        338
#define IDS_EXPRESS_FINISH_MESSAGE      339
#define IDS_FILE_FINISH_MESSAGE         340
#define IDS_FILE_INSTALL_FAILED         341
#define IDS_FILE_UNINSTALL_MESSAGE      342
#define IDS_FILE_UNINSTALL_FAILED       343
#define IDS_FILE_FINISH_UNINSTALL_TITLE 344
#define IDS_PRINT_FINISH_UNINSTALL_TITLE 345
#define IDS_SP_FINISH_UNINSTALL_TITLE   346
#define IDS_WEB_SERVER_TYPE_64BIT       346
#define IDS_WEB_FINISH_UNINSTALL_TITLE  347
#define IDS_POP3_FINISH_UNINSTALL_TITLE 348
#define IDS_TS_FINISH_UNINSTALL_TITLE   349
#define IDS_RRAS_FINISH_UNINSTALL_TITLE 350
#define IDS_AD_FINISH_UNINSTALL_TITLE   351
#define IDS_DNS_FINISH_UNINSTALL_TITLE  352
#define IDS_DHCP_FINISH_UNINSTALL_TITLE 353
#define IDS_WEB_SERVER_DESCRIPTION_64BIT 354
#define IDS_MEDIA_FINISH_UNINSTALL_TITLE 355
#define IDS_WINS_FINISH_UNINSTALL_TITLE 356
#define IDS_WINS_PROGRESS               357
#define IDS_WINS_UNINSTALL_TEXT         358
#define IDS_FILE_UNINSTALL_WARNING      359
#define IDS_FILE_UNINSTALL_CHECKBOX     360
#define IDS_PRINT_UNINSTALL_WARNING     361
#define IDS_PRINT_UNINSTALL_CHECKBOX    362
#define IDS_SP_UNINSTALL_WARNING        363
#define IDS_WEB_UNINSTALL_TEXT_64BIT    363
#define IDS_SP_UNINSTALL_CHECKBOX       364
#define IDS_WEB_UNINSTALL_PROGRESS_64BIT 364
#define IDS_WEB_UNINSTALL_WARNING       365
#define IDS_WEB_UNINSTALL_CHECKBOX      366
#define IDS_POP3_UNINSTALL_WARNING      367
#define IDS_POP3_UNINSTALL_CHECKBOX     368
#define IDS_TS_UNINSTALL_WARNING        369
#define IDS_TS_UNINSTALL_CHECKBOX       370
#define IDS_RRAS_UNINSTALL_WARNING      371
#define IDS_RRAS_UNINSTALL_CHECKBOX     372
#define IDS_AD_UNINSTALL_WARNING        373
#define IDS_AD_UNINSTALL_CHECKBOX       374
#define IDS_DNS_UNINSTALL_WARNING       375
#define IDS_DNS_UNINSTALL_CHECKBOX      376
#define IDS_DHCP_UNINSTALL_WARNING      377
#define IDS_DHCP_UNINSTALL_CHECKBOX     378
#define IDS_TS_FINISH_CANCELLED         379
#define IDS_TS_UNINSTALL_FINISH_CANCELLED 380
#define IDS_MEDIA_UNINSTALL_WARNING     381
#define IDS_MEDIA_UNINSTALL_CHECKBOX    382
#define IDS_WINS_UNINSTALL_WARNING      383
#define IDS_WINS_UNINSTALL_CHECKBOX     384
#define IDS_LOG_UNINSTALL_WINS_HEADING  385
#define IDS_WINS_UNINSTALL_PROGRESS     386
#define IDS_LOG_SERVER_UNINSTALL_WINS_SUCCESS 387
#define IDS_LOG_UNINSTALL_WINS_SERVER_FAILED 388
#define IDS_MEDIA_INSTALL_PROGRESS      389
#define IDS_MEDIA_UNINSTALL_TEXT        390
#define IDS_MEDIA_UNINSTALL_PROGRESS    391
#define IDS_LOG_UNINSTALL_MEDIA_HEADING 392
#define IDS_LOG_UNINSTALL_SERVER_WMS_SUCCESS 393
#define IDS_LOG_UNINSTALL_SERVER_WMS_FAILED 394
#define IDS_FILE_LOG_INSTALL_SUCCESS    395
#define IDS_FILE_LOG_INSTALL_FAILURE    396
#define IDS_WINDOWS_SETUP_RUNNING_DURING_CYS_STARTUP 397
#define IDS_WINDOWS_SETUP_RUNNING       398
#define IDS_EXPRESS_DNS_LOG_STATIC_IP_FAILED 399
#define IDS_EXPRESS_DNS_NAME_FORMAT     400
#define IDS_LAUNCH_RRAS_WIZARD_COMMAND_LINE 401
#define IDS_LAUNCH_RRAS_WIZARD_FAILED   402
#define IDS_RRAS_WIZARD_FAILED          403
#define IDS_RRAS_WIZARD_SUCCEEDED       404
#define IDS_LOG_RRAS_COMPLETED_SUCCESSFULLY 405
#define IDS_LOG_RRAS_WIZARD_ERROR       406
#define IDS_LOG_SERVER_IIS_SUCCESS      407
#define IDS_LOG_SERVER_IIS_FAILED       408
#define IDS_LOG_RRAS                    409
#define IDS_FILE_WARNING_LARGER_THAN_QUOTA 410
#define IDS_LAUNCH_RRAS_UNINSTALL_COMMAND_LINE 411
#define IDS_DCPROMO_RUNNING2            411
#define IDS_DHCP_INSTALL_PROGRESS       412
#define IDS_DHCP_CONFIG_PROGRESS        413
#define IDS_DHCP_CONFIG_FAILED          414
#define IDS_DHCP_UNINSTALL_TEXT         415
#define IDS_UNINSTALL_DHCP_PROGRESS     416
#define IDS_LOG_UNINSTALL_DHCP_FAILED   417
#define IDS_LOG_UNINSTALL_DHCP_SUCCESS  418
#define IDS_DNS_INSTALL_PROGRESS        419
#define IDS_DNS_CONFIG_PROGRESS         420
#define IDS_DNS_CONFIG_FAILED           421
#define IDS_DNS_UNINSTALL_TEXT          422
#define IDS_DNS_UNINSTALL_WARNING_ISDC  423
#define IDS_DNS_UNINSTALL_PROGRESS      424
#define IDS_LOG_UNINSTALL_DNS_SUCCESS   425
#define IDS_LOG_UNINSTALL_DNS_FAILED    426
#define IDS_AD_PROGRESS                 427
#define IDS_AD_UNINSTALL_TEXT           428
#define IDS_AD_UNINSTALL_PROGRESS       429
#define IDS_LOG_UNINSTALL_DOMAIN_CONTROLLER_SUCCESS 430
#define IDS_LOG_UNINSTALL_DOMAIN_CONTROLLER_FAILED 431
#define IDS_RRAS_PROGRESS               432
#define IDS_RRAS_UNINSTALL_TEXT         433
#define IDS_RRAS_UNINSTALL_PROGRESS     434
#define IDS_LOG_UNINSTALL_RRAS_HEADING  435
#define IDS_LOG_UNINSTALL_RRAS_FAILED   436
#define IDS_LOG_UNINSTALL_RRAS_COMPLETED_SUCCESSFULLY 437
#define IDS_TS_PROGRESS                 438
#define IDS_TS_UNINSTALL_TEXT           439
#define IDS_TS_UNINSTALL_PROGRESS       440
#define IDS_LOG_UNINSTALL_TERMINAL_SERVER_CONFIGURE 441
#define IDS_LOG_UNINSTALL_TERMINAL_SERVER_ABORTED 442
#define IDS_POP3_PROGRESS               443
#define IDS_POP3_UNINSTALL_TEXT         444
#define IDS_UNINSTALL_POP3_PROGRESS     445
#define IDS_LOG_UNINSTALL_POP3_HEADING  446
#define IDS_LOG_UNINSTALL_POP3_SERVER_SUCCESS 447
#define IDS_LOG_UNINSTALL_POP3_SERVER_FAILURE 448
#define IDS_WEB_PROGRESS                450
#define IDS_WEB_FINISH_MESSAGE_SAK      451
#define IDS_AD_INTEGRATED               451
#define IDS_WEB_UNINSTALL_TEXT          452
#define IDS_WEB_UNINSTALL_WARNING_SHAPEPOINT_SAK 453
#define IDS_LOCAL_ACCOUNTS              453
#define IDS_WEB_UNINSTALL_WARNING_SHAPEPOINT 454
#define IDS_ENCRYPTED_PASSWORD_FILES    454
#define IDS_WEB_UNINSTALL_WARNING_SAK   455
#define IDS_WEB_UNINSTALL_PROGRESS      456
#define IDS_LOG_UNINSTALL_WEB_HEADING   457
#define IDR_AVI1                        457
#define IDR_PROGRESS_AVI                457
#define IDS_LOG_UNINSTALL_IIS_SUCCESS   458
#define IDD_UNINSTALL_PROGRESS_PAGE     458
#define IDS_LOG_UNINSTALL_IIS_FAILED    459
#define IDD_WEBAPP_PAGE                 460
#define IDS_POP3_CONFIG_PROGRESS        460
#define IDD_POP3_PAGE                   461
#define IDS_LOG_POP3_AUTH_FAILURE       461
#define IDS_LOG_POP3_DOMAIN_FAILURE     462
#define IDS_POP3_AUTH_METHOD_FAILED     463
#define IDS_PRINT_UNINSTALL_TEXT        464
#define IDS_UNINSTALL_PRINT_PROGRESS    465
#define IDS_LOG_PRINT_UNINSTALL_HEADER  466
#define IDS_LOG_UNINSTALL_PRINT_SUCCESS 467
#define IDS_LOG_UNINSTALL_PRINT_FAILURE 468
#define IDS_POP3_DOMAIN_NAME_FAILED     469
#define IDS_FILE_UNINSTALL_TEXT         472
#define IDS_UNINSTALL_SHARED_FOLDERS    473
#define IDS_LOG_UNINSTALL_FILE_HEADER   474
#define IDS_LOG_UNINSTALL_FILE_CONSOLE  475
#define IDS_LOG_UNINSTALL_FILE_SHARES   476
#define IDS_LOG_UNINSTALL_FILE_SHARES_FAILURE 477
#define IDS_CLUSTER                     478
#define IDS_LOG_UNINSTALL_TERMINAL_SERVER_SUCCESS 479
#define IDS_LOG_UNINSTALL_TERMINAL_SERVER_FAILED 480
#define IDS_UNINSTALL_PROGRESS_SUBTITLE 481
#define IDS_EXPRESS_FINISH_RRAS_CANCELLED 482
#define IDS_EXPRESS_FINISH_RRAS_FAILURE 483
#define IDS_EXPRESS_FINISH_DNS_FAILURE  484
#define IDS_EXPRESS_FINISH_DHCP_INSTALL_FAILURE 485
#define IDS_EXPRESS_FINISH_DHCP_CONFIG_FAILURE 486
#define IDS_EXPRESS_FINISH_AD_FAILURE   487
#define IDS_RRAS_CONFIG_PROGRESS        488
#define IDS_FILE_CONSOLE_SHORTCUT_DESCRIPTION 489
#define IDS_DNS_CLIENT_CONFIG_PROGRESS  490
#define IDS_AD_PROGRESS_EXPRESS         491
#define IDS_EXPRESS_DHCP_ACTIVATION_FAILURE 492
#define IDS_EXPRESS_TAPI_FAILURE        493
#define IDS_DISCONNECT_NIC_STATIC_TEXT  494
#define IDS_AD_FINISH_MESSAGE_NEEDS_REBOOT 495
#define IDS_AD_INSTALL_FAILED_NEEDS_REBOOT 496
#define IDS_AD_UNINSTALL_MESSAGE_NEEDS_REBOOT 497
#define IDS_AD_UNINSTALL_FAILED_NEEDS_REBOOT 498
#define IDS_PRINT_SUCCESS_NO_SHARES     499
#define IDS_PRINTER_WIZARD_CONFIG_LOG_TEXT 500
#define IDS_LAUNCH_PRINTER_WIZARD_FAILED 501
#define IDS_PRINTER_WIZARD_FAILED       502
#define IDS_SERVERMGMT_SHORTCUT_DESCRIPTION 503
#define IDS_PRINTER_DRIVER_WIZARD_FAILED 601
#define IDS_LAUNCH_PRINTER_DRIVER_WIZARD_FAILED 602
#define IDS_PRINTER_DRIVER_WIZARD_SUCCEEDED 603
#define IDS_PRINTER_WIZARD_CANCELLED    604
#define IDS_WINS_INF_WINDOW_TITLE       700
#define IDS_LOG_SERVER_WINS_SUCCESS     701
#define IDS_LOG_WINS_SERVER_FAILED      702
#define IDS_CLUSTER_LOG_LAUNCH_FAILED   706
#define IDS_CLUSTER_LOG_LAUNCH_FAILED_NEW_CLUSTER 706
#define IDS_CLUSTER_LOG_SUCCESS         707
#define IDS_CLUSTER_LOG_SUCCESS_NEW_CLUSTER 707
#define IDS_CLUSTER_LOG_CANCELLED       708
#define IDS_CLUSTER_LOG_CANCELLED_NEW_CLUSTER 708
#define IDS_CLUSTER_LOG_CANCELED_NEW_CLUSTER 708
#define IDS_LOG_WEB_HEADING             709
#define IDS_LOG_CLUSTER_HEADING         710
#define IDS_CLUSTER_LOG_SUCCESS_ADD_NODE 711
#define IDS_CLUSTER_LOG_CANCELLED_ADD_NODE 712
#define IDS_CLUSTER_LOG_CANCELED_ADD_NODE 712
#define IDS_CLUSTER_LOG_LAUNCH_FAILED_ADD_NODE 713
#define IDS_LOG_MEDIA_HEADING           714
#define IDS_LOG_DOMAIN_CONTROLLER_HEADING 715
#define IDS_LOG_DOMAIN_CONTROLLER_SERVER 716
#define IDS_LOG_DOMAIN_CONTROLLER_SUCCESS 717
#define IDS_LOG_DOMAIN_CONTROLLER_FAILED 718
#define IDS_WEB_ADMIN_LOG_FAILED        723
#define IDS_LOG_UNINSTALL_DOMAIN_CONTROLLER_SERVER 726
#define IDS_DHCP_FINISH_TEXT            801
#define IDS_DNS_FINISH_TEXT             802
#define IDS_MEDIA_FINISH_TEXT           804
#define IDS_RRAS_FINISH_TEXT            806
#define IDS_WEB_FINISH_TEXT             808
#define IDS_WINS_FINISH_TEXT            809
#define IDS_DC_FINISH_TEXT              810
#define IDS_CLUSTER_FINISH_TEXT         811
#define IDS_EXPRESS_FINISH_DNS_FORWARDERS 811
#define IDS_WEBAPP_MILESTONE_DTC        812
#define IDS_WEB_MILESTONE_DTC           812
#define IDS_TERMINAL_SERVER_FINISH_SERVER_TS 816
#define IDS_EXPRESS_FINISH_TEXT         817
#define IDS_EXPRESS_FINISH_DOMAIN_NAME  818
#define IDS_EXPRESS_FINISH_STATIC_IP    819
#define IDS_EXPRESS_FINISH_DHCP_SCOPE   820
#define IDS_EXPRESS_FINISH_TAPI         821
#define IDS_EXPRESS_DHCP_TEXT           825
#define IDS_FILESERVER_QUOTAS_SHAREPOINT 900
#define IDS_FILESERVER_QUOTAS_NO_SHAREPOINT_NO_NAS 901
#define IDS_FILESERVER_NO_QUOTAS_SHAREPOINT 902
#define IDS_FILESERVER_NO_QUOTAS_NO_SHAREPOINT 903
#define IDS_CLUSTER_FINISH_TEXT_NEW_CLUSTER 904
#define IDS_CLUSTER_FINISH_TEXT_EXISTING_CLUSTER 905
#define IDS_FILESERVER_QUOTAS_SHAREPOINT_NO_NAS 906
#define IDS_FILESERVER_QUOTAS_NO_SHAREPOINT 907
#define IDS_FILESERVER_NO_QUOTAS_NO_SHAREPOINT_NO_NAS 908
#define IDS_FILESERVER_NO_QUOTAS_SHAREPOINT_NO_NAS 909
#define IDS_FILESERVER_NTFS_NOSP_NOSMC_NOFSC_NOSHAREPRESENT 950
#define IDS_FILESERVER_NTFS_NOSP_NOSMC_SHAREPRESENT 951
#define IDS_FILESERVER_NTFS_NOSP_NOSMC_NOSHAREPRESENT 952
#define IDS_FILESERVER_NTFS_NOSP_SMC_SHAREPRESENT 953
#define IDS_FILESERVER_NTFS_NOSP_SMC_NOSHAREPRESENT 954
#define IDS_FILESERVER_NTFS_SP_NOSMC_NOFSC_NOSHAREPRESENT 955
#define IDS_FILESERVER_NTFS_SP_NOSMC_SHAREPRESENT 956
#define IDS_FILESERVER_NTFS_SP_NOSMC_NOSHAREPRESENT 957
#define IDS_FILESERVER_NTFS_SP_SMC_SHAREPRESENT 958
#define IDS_FILESERVER_NTFS_SP_SMC_NOSHAREPRESENT 959
#define IDS_FILESERVER_NONTFS_NOSP_NOSMC_NOFSC_NOSHAREPRESENT 960
#define IDS_FILESERVER_NONTFS_NOSP_NOSMC_SHAREPRESENT 961
#define IDS_FILESERVER_NONTFS_NOSP_NOSMC_NOSHAREPRESENT 962
#define IDS_FILESERVER_NONTFS_NOSP_SMC_SHAREPRESENT 963
#define IDS_FILESERVER_NONTFS_NOSP_SMC_NOSHAREPRESENT 964
#define IDS_FILESERVER_NONTFS_SP_NOSMC_NOFSC_NOSHAREPRESENT 965
#define IDS_FILESERVER_NONTFS_SP_NOSMC_SHAREPRESENT 966
#define IDS_FILESERVER_NONTFS_SP_NOSMC_NOSHAREPRESENT 967
#define IDS_FILESERVER_NONTFS_SP_SMC_SHAREPRESENT 968
#define IDS_FILESERVER_NONTFS_SP_SMC_NOSHAREPRESENT 969
#define IDS_FILESERVER_NTFS_NOSP_NOSMC_NOFSC_SHAREPRESENT 970
#define IDS_FILESERVER_NTFS_SP_NOSMC_NOFSC_SHAREPRESENT 971
#define IDS_FILESERVER_NONTFS_NOSP_NOSMC_NOFSC_SHAREPRESENT 972
#define IDS_FILESERVER_NONTFS_SP_NOSMC_NOFSC_SHAREPRESENT 973
#define IDS_FILE_FINISH_OPEN_SMC        974
#define IDS_FILE_FINISH_OPEN_FSC        975
#define IDS_FILE_FINISH_SERVER_FSC      976
#define IDS_FILE_FINISH_DIALOG_TEXT_SMC 977
#define IDS_FILE_FINISH_DIALOG_TEXT_FSC 978
#define IDC_SERVER_TYPE_LIST            1000
#define IDS_KB                          1000
#define IDC_TYPE_DESCRIPTION_STATIC     1001
#define IDS_MB                          1001
#define IDC_DHCP_CHECK                  1002
#define IDS_GB                          1002
#define IDC_DNS_CHECK                   1003
#define IDC_WINS_CHECK                  1004
#define IDC_RRAS_CHECK                  1005
#define IDC_EXPRESS_RADIO               1007
#define IDC_CUSTOM_RADIO                1008
#define IDC_DOMAIN                      1009
#define IDC_STATIC_IPADDRESS            1010
#define IDC_START_IPADDRESS             1011
#define IDC_END_IPADDRESS               1012
#define IDC_W2K_RADIO                   1013
#define IDC_ALL_RADIO                   1014
#define IDC_NO_RADIO                    1016
#define IDC_YES_RADIO                   1017
#define IDC_RERUN_CHECK                 1019
#define IDC_DEFAULT_QUOTAS_CHECK        1020
#define IDC_SPACE_EDIT                  1021
#define IDC_SPACE_COMBO                 1022
#define IDC_LEVEL_EDIT                  1023
#define IDC_LEVEL_COMBO                 1024
#define IDC_DENY_DISK_CHECK             1025
#define IDC_DISK_SPACE_CHECK            1026
#define IDC_WARNING_LEVEL_CHECK         1027
#define IDC_SPACE_STATIC                1030
#define IDC_LEVEL_STATIC                1031
#define IDC_EVENT_STATIC                1032
#define IDC_MASK_IPADDRESS              1033
#define IDC_NIC_LIST                    1034
#define IDC_BULLET1                     1035
#define IDC_BULLET2                     1036
#define IDC_BULLET3                     1037
#define IDC_BULLET4                     1038
#define IDC_BULLET5                     1039
#define IDC_DESC_STATIC                 1042
#define IDC_HELP_LIST_CHECK             1044
#define IDC_LOG_FILE_CHECK              1045
#define IDC_INDEX_STATIC                1048
#define IDS_DHCP_FINISH_DIALOG_TEXT     1050
#define IDC_IPADDRESS_CHECK_STATIC      1051
#define IDS_DNS_FINISH_DIALOG_TEXT      1051
#define IDC_IPADDRESS_ERROR_STATIC      1052
#define IDS_WINS_FINISH_DIALOG_TEXT     1052
#define IDS_RRAS_FINISH_DIALOG_TEXT     1053
#define IDS_TS_FINISH_DIALOG_TEXT       1054
#define IDS_AD_FINISH_DIALOG_TEXT       1056
#define IDS_CLUSTER_FINISH_DIALOG_TEXT  1057
#define IDS_WMS_FINISH_DIALOG_TEXT      1058
#define IDC_CONFIG_PROGRESS             1059
#define IDS_WEB_FINISH_DIALOG_TEXT      1059
#define IDC_DHCP_CHECK_STATIC           1060
#define IDS_EXPRESS_FINISH_DIALOG_TEXT  1060
#define IDC_AD_CHECK_STATIC             1061
#define IDC_DNS_CHECK_STATIC            1062
#define IDC_FORWARDER_CHECK_STATIC      1063
#define IDC_AUTHORIZE_SCOPE_CHECK_STATIC 1065
#define IDC_TAPI_CHECK_STATIC           1066
#define IDC_IPADDRESS_CURRENT_STATIC    1067
#define IDC_DHCP_CURRENT_STATIC         1068
#define IDC_AD_CURRENT_STATIC           1069
#define IDC_DNS_CURRENT_STATIC          1070
#define IDS_DETECTING_SETTINGS_FORMAT   1070
#define IDC_FORWARDER_CURRENT_STATIC    1071
#define IDS_RETRIEVE_OS_INFO            1071
#define IDS_RETRIEVE_NIC_INFO           1072
#define IDC_AUTHORIZE_SCOPE_CURRENT_STATIC 1073
#define IDC_TAPI_CURRENT_STATIC         1074
#define IDC_DHCP_ERROR_STATIC           1075
#define IDC_AD_ERROR_STATIC             1076
#define IDC_DNS_ERROR_STATIC            1077
#define IDC_FORWARDER_ERROR_STATIC      1078
#define IDC_AUTHORIZE_SCOPE_ERROR_STATIC 1080
#define IDC_TAPI_ERROR_STATIC           1081
#define IDC_IPADDRESS_STATIC            1082
#define IDC_DHCP_STATIC                 1083
#define IDC_AD_STATIC                   1084
#define IDC_DNS_STATIC                  1085
#define IDC_FORWARDER_STATIC            1086
#define IDC_AUTHORIZE_SCOPE_STATIC      1087
#define IDC_TAPI_STATIC                 1088
#define IDC_DOMAIN_DNS_EDIT             1089
#define IDC_TOO_LONG_STATIC             1090
#define IDC_DHCP_SCOPE_STATIC           1090
#define IDC_FORWARDER_IPADDRESS         1092
#define IDC_OUT_ONLY_RADIO              1094
#define IDC_BOTH_RADIO                  1095
#define IDC_EXPRESS_TOO_LONG_STATIC     1097
#define IDC_SERVER_ADMINPACK_CHECK      1098
#define IDC_SERVER_WEBADMIN_CHECK       1099
#define IDS_NIC_COLUMN                  1100
#define IDS_STATUS_COLUMN               1101
#define IDC_SERVER_NASADMIN_CHECK       1101
#define IDS_ADDRESS_COLUMN              1102
#define IDC_TOO_LONG_TEXT_IN_AND_OUT    1102
#define IDC_TOO_LONG_TEXT_OUT           1103
#define IDC_ANIMATION                   1105
#define IDC_DHCP_SCOPE_CHECK_STATIC     1106
#define IDC_DHCP_SCOPE_CURRENT_STATIC   1107
#define IDC_DHCP_SCOPE_ERROR_STATIC     1108
#define IDC_TOOLS_STATIC                1109
#define IDC_STATUS_STATIC               1110
#define IDC_FINISHED_STATIC             1111
#define IDC_DYNAMIC_STATIC              1112
#define IDC_CLOSE_BUTTON                1113
#define IDC_ENABLE_REMOTE_DESKTOP_CHECK 1114
#define IDC_ENABLE_NAS_CHECK            1115
#define IDC_ENABLE_WEB_CHECK            1116
#define IDC_REMOTE_DESKTOP_STATIC       1118
#define IDC_MILESTONE_EDIT              1119
#define IDC_STEP_TEXT_STATIC            1120
#define IDC_FINISH_STATIC               1122
#define IDC_FINISH_RERUN_STATIC         1123
#define IDC_EXPRESS_CONFIG_DONE_STATIC  1124
#define IDC_UNINSTALL_CHECK             1125
#define IDC_UNINSTALL_WARNING_STATIC    1126
#define IDC_LOG_STATIC                  1128
#define IDC_ROLE_STATIC                 1129
#define IDC_CAPTION_STATIC              1133
#define IDC_FRONT_PAGE_CHECK            1134
#define IDC_ASPNET_CHECK                1136
#define IDC_ADD_REMOVE_STATIC           1137
#define IDC_AUTH_METHOD_COMBO           1138
#define IDC_EMAIL_DOMAIN_EDIT           1139
#define IDS_EXPRESS_REBOOT_IPADDRESS    1200
#define IDS_EXPRESS_REBOOT_FORWARDER    1201
#define IDS_EXPRESS_REBOOT_DHCP_SCOPE   1203
#define IDS_EXECUTE_PRINTER_DRIVER_WIZARD_FAILED 1204
#define IDS_PRINT_SERVER_UNSUCCESSFUL   1205
#define IDS_PRINT_SERVER_SUCCESSFUL     1206
#define IDS_EXECUTE_PRINTER_WIZARD_FAILED 1207
#define IDS_CONFIGURE_WEB_SERVER        1208
#define IDS_LOG_IIS_ALREADY_SERVERED    1209
#define IDS_REMOTEADMIN_SERVER_TYPE     1250
#define IDS_REMOTEADMIN_SERVER_DESCRIPTION 1251
#define IDS_LOG_REMOTEADMIN_HEADING     1252
#define IDS_REMOTEADMIN_FINISH_TEXT_REMOTEADMIN 1253
#define IDS_REMOTEADMIN_FINISH_TEXT_NASADMIN 1254
#define IDS_REMOTEADMIN_FINISH_TEXT_WEBADMIN 1255
#define IDS_FILE_LOG_START_MENU         1256
#define IDS_FILE_LOG_ADMIN_TOOLS        1257
#define IDS_FILESERVER_ADMINTOOLS_LINK  1258
#define IDS_UNINSTALL_MILESTONE_TITLE   1259
#define IDS_UNINSTALL_MILESTONE_SUBTITLE 1260
#define IDS_SERVERMGMT_ADMIN_TOOLS_LINK 1261
#define IDS_REMOTEADMIN_TS_NAS_WEB      1300
#define IDS_REMOTEADMIN_TS_NAS_NOWEB    1301
#define IDS_REMOTEADMIN_TS_NONAS_WEB    1302
#define IDS_REMOTEADMIN_TS_NONAS_NOWEB  1303
#define IDS_REMOTEADMIN_NOTS_NAS_WEB    1304
#define IDS_REMOTEADMIN_NOTS_NAS_NOWEB  1305
#define IDS_REMOTEADMIN_NOTS_NONAS_WEB  1306
#define IDS_REMOTEADMIN_NOTS_NONAS_NOWEB 1307
#define IDS_REMOTEADMIN_LOG_ENABLE_REMOTEDESKTOP 1308
#define IDS_REMOTEADMIN_FINISH_DIALOG_REMOTEDESKTOP 1309
#define IDS_REMOTEADMIN_FINISH_DIALOG_SAK 1310
#define IDS_REMOTE_DESKTOP_TITLE        1311
#define IDS_REMOTE_DESKTOP_SUBTITLE     1312
#define IDS_SAK_TITLE                   1313
#define IDS_SAK_SUBTITLE                1314
#define IDS_ORDERKB                     3000
#define IDS_ORDERMB                     3001
#define IDS_ORDERGB                     3002
#define IDS_ORDERTB                     3003
#define IDS_ORDERPB                     3004
#define IDS_ORDEREB                     3005
#define IDS_NO_LIMIT                    3006
#define IDS_START_MENU_TOOLTIP          5000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        461
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1140
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\uninstallprogresspage.cpp ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      UninstallProgressPage.h
//
// Synopsis:  Defines the Uninstall Progress Page for the CYS
//            wizard.  This page shows the progress of the uninstall
//            through a progress bar and changing text
//
// History:   04/12/2002  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "UninstallProgressPage.h"

UninstallProgressPage::UninstallProgressPage()
   :
   InstallationProgressPage(
      IDD_UNINSTALL_PROGRESS_PAGE, 
      IDS_PROGRESS_TITLE, 
      IDS_UNINSTALL_PROGRESS_SUBTITLE)
{
   LOG_CTOR(UninstallProgressPage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\uiutil.cpp ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      uiutil.cpp
//
// Synopsis:  Commonly used UI functions
//
// History:   01/22/2002  JeffJon Created

#include "pch.h"

#include "resource.h"

// Creates the fonts for setLargeFonts().
// 
// hDialog - handle to a dialog to be used to retrieve a device
// context.
// 
// bigBoldFont - receives the handle of the big bold font created.

void
InitFonts(
   HWND     hDialog,
   HFONT&   bigBoldFont)
{
   ASSERT(Win::IsWindow(hDialog));

   HRESULT hr = S_OK;

   do
   {
      NONCLIENTMETRICS ncm;
      memset(&ncm, 0, sizeof(ncm));
      ncm.cbSize = sizeof(ncm);

      hr = Win::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
      BREAK_ON_FAILED_HRESULT(hr);

      LOGFONT bigBoldLogFont = ncm.lfMessageFont;
      bigBoldLogFont.lfWeight = FW_BOLD;

      String fontName = String::load(IDS_BIG_BOLD_FONT_NAME);

      // ensure null termination 260237

      memset(bigBoldLogFont.lfFaceName, 0, LF_FACESIZE * sizeof(TCHAR));
      size_t fnLen = fontName.length();
      fontName.copy(
         bigBoldLogFont.lfFaceName,

         // don't copy over the last null

         min(LF_FACESIZE - 1, fnLen));

      unsigned fontSize = 0;
      String::load(IDS_BIG_BOLD_FONT_SIZE).convert(fontSize);
      ASSERT(fontSize);
 
      HDC hdc = 0;
      hr = Win::GetDC(hDialog, hdc);
      BREAK_ON_FAILED_HRESULT(hr);

      bigBoldLogFont.lfHeight =
         - ::MulDiv(
            static_cast<int>(fontSize),
            Win::GetDeviceCaps(hdc, LOGPIXELSY),
            72);

      hr = Win::CreateFontIndirect(bigBoldLogFont, bigBoldFont);
      BREAK_ON_FAILED_HRESULT(hr);

      Win::ReleaseDC(hDialog, hdc);
   }
   while (0);
}

void
InitBoldFont(
   HWND     hDialog,
   HFONT&   boldFont)
{
   ASSERT(Win::IsWindow(hDialog));

   HRESULT hr = S_OK;

   do
   {
      NONCLIENTMETRICS ncm;
      memset(&ncm, 0, sizeof(ncm));
      ncm.cbSize = sizeof(ncm);

      hr = Win::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
      BREAK_ON_FAILED_HRESULT(hr);

      LOGFONT boldLogFont = ncm.lfMessageFont;
      boldLogFont.lfWeight = FW_BOLD;

      HDC hdc = 0;
      hr = Win::GetDC(hDialog, hdc);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = Win::CreateFontIndirect(boldLogFont, boldFont);
      BREAK_ON_FAILED_HRESULT(hr);

      Win::ReleaseDC(hDialog, hdc);
   }
   while (0);
}

void
SetControlFont(HWND parentDialog, int controlID, HFONT font)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(controlID);
   ASSERT(font);

   HWND control = Win::GetDlgItem(parentDialog, controlID);

   if (control)
   {
      Win::SetWindowFont(control, font, true);
   }
}



void
SetLargeFont(HWND dialog, int bigBoldResID)
{
   ASSERT(Win::IsWindow(dialog));
   ASSERT(bigBoldResID);

   static HFONT bigBoldFont = 0;
   if (!bigBoldFont)
   {
      InitFonts(dialog, bigBoldFont);
   }

   SetControlFont(dialog, bigBoldResID, bigBoldFont);
}

void
SetBoldFont(HWND dialog, int boldResID)
{
   ASSERT(Win::IsWindow(dialog));
   ASSERT(boldResID);

   static HFONT boldFont = 0;
   if (!boldFont)
   {
      InitBoldFont(dialog, boldFont);
   }

   SetControlFont(dialog, boldResID, boldFont);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\uninstallprogresspage.h ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      UninstallProgressPage.h
//
// Synopsis:  Declares the Uninstall Progress Page for the CYS
//            wizard.  This page shows the progress of the uninstall
//            through a progress bar and changing text
//
// History:   04/12/2002  JeffJon Created

#ifndef __CYS_UNINSTALLPROGRESSPAGE_H
#define __CYS_UNINSTALLPROGRESSPAGE_H

#include "InstallationProgressPage.h"


class UninstallProgressPage : public InstallationProgressPage
{
   public:
      
      // Constructor
      
      UninstallProgressPage();
};

#endif // __CYS_UNINSTALLPROGRESSPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\uiutil.h ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      uiutil.h
//
// Synopsis:  Commonly used UI functions
//
// History:   01/22/2002  JeffJon Created

// Sets the font of a given control in a dialog.
// 
// parentDialog - Dialog containing the control.
// 
// controlID - Res ID of the control for which the font will be
// changed.
// 
// font - handle to the new font for the control.

void
SetControlFont(HWND parentDialog, int controlID, HFONT font);



// Sets the font of a control to a large point bold font as per Wizard '97
// spec.
// 
// dialog - handle to the dialog that is the parent of the control
// 
// bigBoldResID - resource id of the control to change

void
SetLargeFont(HWND dialog, int bigBoldResID);

// Sets the font of a control to bold 
// 
// dialog - handle to the dialog that is the parent of the control
// 
// boldResID - resource id of the control to change

void
SetBoldFont(HWND dialog, int boldResID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\uninstallmilestonepage.h ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      UninstallMilestonePage.h
//
// Synopsis:  Declares the UninstallMilestone Page for the CYS
//            wizard
//
// History:   01/24/2002  JeffJon Created

#ifndef __CYS_UNINSTALLMILESTONEPAGE_H
#define __CYS_UNINSTALLMILESTONEPAGE_H

#include "CYSWizardPage.h"

class UninstallMilestonePage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      UninstallMilestonePage();

      // Destructor

      virtual 
      ~UninstallMilestonePage();


   protected:

      // Dialog overrides

      virtual
      void
      OnInit();

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

      bool
      OnCommand(
         HWND        windowFrom,
         unsigned    controlIDFrom,
         unsigned    code);

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();

   private:

      void
      OpenLogFile(const String& logName);

      void
      TimeStampTheLog(HANDLE logfileHandle);

      bool needKillSelection;

      // not defined: no copying allowed
      UninstallMilestonePage(const UninstallMilestonePage&);
      const UninstallMilestonePage& operator=(const UninstallMilestonePage&);

};

#endif // __CYS_UNINSTALLMILESTONEPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\webapplicationpage.cpp ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      WebApplicationPage.h
//
// Synopsis:  Defines the Web Application page
//            for the CYS Wizard
//
// History:   04/22/2002  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "WebApplicationPage.h"

static PCWSTR WEBAPP_PAGE_HELP = L"cys.chm::/web_server_role.htm#websrvoptions";

WebApplicationPage::WebApplicationPage()
   :
   CYSWizardPage(
      IDD_WEBAPP_PAGE, 
      IDS_WEBAPP_TITLE, 
      IDS_WEBAPP_SUBTITLE,
      WEBAPP_PAGE_HELP)
{
   LOG_CTOR(WebApplicationPage);
}

   

WebApplicationPage::~WebApplicationPage()
{
   LOG_DTOR(WebApplicationPage);
}


bool
WebApplicationPage::OnSetActive()
{
   LOG_FUNCTION(WebApplicationPage::OnSetActive);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd), 
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}


int
WebApplicationPage::Validate()
{
   LOG_FUNCTION(WebApplicationPage::Validate);

   int nextPage = IDD_MILESTONE_PAGE;

   // Retrieve the data from the UI

   WebInstallationUnit& webInstallationUnit = 
      InstallationUnitProvider::GetInstance().GetWebInstallationUnit();

   DWORD optionalComponents = webInstallationUnit.GetOptionalComponents();

   if (Win::IsDlgButtonChecked(hwnd, IDC_FRONT_PAGE_CHECK))
   {
      LOG(L"FrontPage Extensions checked");

      optionalComponents |= WebInstallationUnit::FRONTPAGE_EXTENSIONS_COMPONENT;
   }
   else
   {
      LOG(L"FrontPage Extensions unchecked");

      optionalComponents &= ~WebInstallationUnit::FRONTPAGE_EXTENSIONS_COMPONENT;
   }

   if (Win::IsDlgButtonChecked(hwnd, IDC_ASPNET_CHECK))
   {
      LOG(L"ASP.NET checked");

      optionalComponents |= WebInstallationUnit::ASPNET_COMPONENT;
   }
   else
   {
      LOG(L"ASP.NET unchecked");

      optionalComponents &= ~WebInstallationUnit::ASPNET_COMPONENT;
   }

   // Now set the option components for use in the rest of the installation

   webInstallationUnit.SetOptionalComponents(optionalComponents);

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\webapplicationpage.h ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      WebApplicationPage.h
//
// Synopsis:  Declares the Web Application page
//            for the CYS Wizard
//
// History:   04/22/2002  JeffJon Created

#ifndef __CYS_WEBAPPLICATIONPAGE_H
#define __CYS_WEBAPPLICATIONPAGE_H

#include "CYSWizardPage.h"


class WebApplicationPage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      WebApplicationPage();

      // Destructor

      virtual 
      ~WebApplicationPage();


      // Dialog overrides

      virtual
      bool
      OnSetActive();

   protected:

      // CYSWizardPage overrides

      virtual
      int
      Validate();

   private:

      // not defined: no copying allowed
      WebApplicationPage(const WebApplicationPage&);
      const WebApplicationPage& operator=(const WebApplicationPage&);

};


#endif // __CYS_WEBAPPLICATIONPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\uninstallmilestonepage.cpp ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      UninstallMilestonePage.cpp
//
// Synopsis:  Defines the UninstallMilestone Page for the CYS
//            wizard
//
// History:   01/24/2002  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "InstallationUnitProvider.h"
#include "UninstallMilestonePage.h"

static PCWSTR UNINSTALL_MILESTONE_PAGE_HELP = L"cys.chm::/remove_role.htm";

UninstallMilestonePage::UninstallMilestonePage()
   :
   needKillSelection(true),
   CYSWizardPage(
      IDD_UNINSTALL_MILESTONE_PAGE, 
      IDS_UNINSTALL_MILESTONE_TITLE, 
      IDS_UNINSTALL_MILESTONE_SUBTITLE, 
      UNINSTALL_MILESTONE_PAGE_HELP,
      true, 
      true)
{
   LOG_CTOR(UninstallMilestonePage);
}

   

UninstallMilestonePage::~UninstallMilestonePage()
{
   LOG_DTOR(UninstallMilestonePage);
}


void
UninstallMilestonePage::OnInit()
{
   LOG_FUNCTION(UninstallMilestonePage::OnInit);

   CYSWizardPage::OnInit();
}

bool
UninstallMilestonePage::OnCommand(
   HWND        windowFrom,
   unsigned    controlIDFrom,
   unsigned    code)
{
   bool result = false;

   switch (controlIDFrom)
   {
      case IDC_UNINSTALL_CHECK:
         if (code == BN_CLICKED)
         {
            bool checked = 
               Win::Button_GetCheck(
                  Win::GetDlgItem(hwnd, IDC_UNINSTALL_CHECK));

            Win::PropSheet_SetWizButtons(
               Win::GetParent(hwnd),
               (checked) ? PSWIZB_NEXT | PSWIZB_BACK : PSWIZB_BACK);
         }
         break;

      case IDC_MILESTONE_EDIT:
         if (code == EN_SETFOCUS &&
             needKillSelection)
         {
            Win::Edit_SetSel(windowFrom, -1, -1);
            needKillSelection = false;
         }
         break;

      default:
         break;
   }

   return result;
}

bool
UninstallMilestonePage::OnSetActive()
{
   LOG_FUNCTION(UninstallMilestonePage::OnSetActive);
   
   // Always clear the checkbox when returning to this page.
   // We want to force the user to select for uninstall

   Win::Button_SetCheck(
      Win::GetDlgItem(hwnd, IDC_UNINSTALL_CHECK),
      BST_UNCHECKED);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);


   InstallationUnit& currentInstallationUnit =
      InstallationUnitProvider::GetInstance().GetCurrentInstallationUnit();

   // Get the finish text from the installation unit and put it in the finish box

   String message;

   bool changes =
      currentInstallationUnit.GetUninstallMilestoneText(message);

   if (!changes)
   {
      message = String::load(IDS_FINISH_NO_CHANGES);
   }

   Win::SetDlgItemText(
      hwnd, 
      IDC_MILESTONE_EDIT, 
      message);


   String warning =
      currentInstallationUnit.GetUninstallWarningText();

   Win::SetDlgItemText(
      hwnd, 
      IDC_UNINSTALL_WARNING_STATIC, 
      warning);


   String checkboxText = 
      currentInstallationUnit.GetUninstallCheckboxText();

   Win::SetDlgItemText(
      hwnd, 
      IDC_UNINSTALL_CHECK, 
      checkboxText);

   if (!changes)
   {
      popup.MessageBox(
         hwnd,
         IDS_NO_CHANGES_MESSAGEBOX_TEXT,
         MB_OK | MB_ICONWARNING);
   }

   // Remove the selection of the edit box

   Win::Edit_SetSel(
      Win::GetDlgItem(
         hwnd,
         IDC_MILESTONE_EDIT),
      -1,
      0);

   Win::PostMessage(
      hwnd,
      WM_NEXTDLGCTL,
      (WPARAM) Win::GetDlgItem(hwnd, IDC_UNINSTALL_CHECK),
      TRUE);

   return true;
}

int
UninstallMilestonePage::Validate()
{
   LOG_FUNCTION(UninstallMilestonePage::Validate);

   Win::WaitCursor wait;
   int nextPage = -1;
   
   if (!InstallationUnitProvider::GetInstance().
           GetCurrentInstallationUnit().DoInstallerCheck(hwnd))
   {
      nextPage = IDD_UNINSTALL_PROGRESS_PAGE;
   }

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\winsinstallationunit.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      WINSInstallationUnit.h
//
// Synopsis:  Declares a WINSInstallationUnit
//            This object has the knowledge for installing the
//            WINS service
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_WINSINSTALLATIONUNIT_H
#define __CYS_WINSINSTALLATIONUNIT_H

#include "InstallationUnit.h"

class WINSInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      WINSInstallationUnit();

      // Destructor

      virtual
      ~WINSInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      UnInstallReturnType
      UnInstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      bool
      GetMilestoneText(String& message);

      virtual
      bool
      GetUninstallMilestoneText(String& message);

      virtual
      String
      GetServiceDescription();

      virtual
      void
      ServerRoleLinkSelected(int linkIndex, HWND hwnd);

      virtual
      void
      FinishLinkSelected(int inkIndex, HWND hwnd);

   private:

      unsigned int installedDescriptionID;
};

#endif // __CYS_WINSINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\welcomepage.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      WelcomePage.cpp
//
// Synopsis:  Defines Welcome Page for the CYS
//            Wizard
//
// History:   02/03/2001  JeffJon Created


#include "pch.h"
#include "resource.h"

#include "uiutil.h"
#include "InstallationUnitProvider.h"
#include "WelcomePage.h"

static PCWSTR WELCOME_PAGE_HELP = L"cys.chm::/choose_role.htm";

WelcomePage::WelcomePage()
   :
   CYSWizardPage(
      IDD_WELCOME_PAGE, 
      IDS_WELCOME_TITLE, 
      IDS_WELCOME_SUBTITLE, 
      WELCOME_PAGE_HELP, 
      true, 
      false)
{
   LOG_CTOR(WelcomePage);
}

   

WelcomePage::~WelcomePage()
{
   LOG_DTOR(WelcomePage);
}


void
WelcomePage::OnInit()
{
   LOG_FUNCTION(WelcomePage::OnInit);

   SetLargeFont(hwnd, IDC_BIG_BOLD_TITLE);

   Win::PropSheet_SetTitle(
      Win::GetParent(hwnd),     
      0,
      String::load(IDS_WIZARD_TITLE));

}

bool
WelcomePage::OnSetActive()
{
   LOG_FUNCTION(WelcomePage::OnSetActive);

   // Only Next and Cancel are available from the Welcome page

   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), PSWIZB_NEXT);

   // Set the focus to the Next button so that enter works

   Win::PostMessage(
      Win::GetParent(hwnd),
      WM_NEXTDLGCTL,
      (WPARAM) Win::GetDlgItem(Win::GetParent(hwnd), Wizard::NEXT_BTN_ID),
      TRUE);

   return true;
}

bool
WelcomePage::OnNotify(
   HWND        /*windowFrom*/,
   UINT_PTR    controlIDFrom,
   UINT        code,
   LPARAM      /*lParam*/)
{
//   LOG_FUNCTION(WelcomePage::OnCommand);
 
   bool result = false;

   if (controlIDFrom == IDC_FINISH_MESSAGE)
   {
      switch (code)
      {
         case NM_CLICK:
         case NM_RETURN:
         {
            ShowHelp(WELCOME_PAGE_HELP);
         }
         default:
         {
            // do nothing
            
            break;
         }
      }
   }

   return result;
}



int
WelcomePage::Validate()
{
   LOG_FUNCTION(WelcomePage::Validate);

   // Always show the Before You Begin pag

   int nextPage = IDD_BEFORE_BEGIN_PAGE;

   LOG(String::format(
          L"nextPage = %1!d!",
          nextPage));

   return nextPage;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\welcomepage.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      WelcomePage.h
//
// Synopsis:  Declares the Welcome Page for the CYS
//            wizard
//
// History:   02/03/2001  JeffJon Created

#ifndef __CYS_WELCOMEPAGE_H
#define __CYS_WELCOMEPAGE_H

#include "CYSWizardPage.h"


class WelcomePage : public CYSWizardPage
{
   public:
      
      // Constructor
      
      WelcomePage();

      // Destructor

      virtual 
      ~WelcomePage();


      // Dialog overrides

      virtual
      void
      OnInit();

      virtual
      HBRUSH
      OnCtlColorStatic(
         HDC   /*deviceContext*/,
         HWND  /*dialog*/) { return 0; }

      // PropertyPage overrides

      virtual
      bool
      OnSetActive();

      virtual
      bool
      OnNotify(
         HWND        windowFrom,
         UINT_PTR    controlIDFrom,
         UINT        code,
         LPARAM      lParam);

   protected:

      virtual
      int
      Validate();

   private:

      // not defined: no copying allowed
      WelcomePage(const WelcomePage&);
      const WelcomePage& operator=(const WelcomePage&);

};

#endif // __CYS_WELCOMEPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\webinstallationunit.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      WebInstallationUnit.h
//
// Synopsis:  Declares a WebInstallationUnit
//            This object has the knowledge for installing the
//            IIS service
//
// History:   02/06/2001  JeffJon Created

#ifndef __CYS_WEBINSTALLATIONUNIT_H
#define __CYS_WEBINSTALLATIONUNIT_H

#include "InstallationUnit.h"

extern PCWSTR CYS_SAK_HOWTO;

class WebInstallationUnit : public InstallationUnit
{
   public:
      
      // Constructor

      WebInstallationUnit();

      // Destructor

      virtual
      ~WebInstallationUnit();

      
      // Installation Unit overrides

      virtual
      InstallationReturnType
      InstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      UnInstallReturnType
      UnInstallService(HANDLE logfileHandle, HWND hwnd);

      virtual
      InstallationReturnType
      CompletePath(HANDLE logfileHandle, HWND hwnd);

      virtual
      String 
      GetServiceName(); 

      virtual
      String
      GetServiceDescription();

      virtual
      bool
      GetMilestoneText(String& message);

      virtual
      bool
      GetUninstallMilestoneText(String& message);

      virtual
      String
      GetUninstallWarningText();

      virtual
      String
      GetFinishText();

      virtual
      int
      GetWizardStart();

      virtual
      void
      ServerRoleLinkSelected(int linkIndex, HWND hwnd);

      virtual
      void
      FinishLinkSelected(int inkIndex, HWND hwnd);

      // Accessors

      void
      SetOptionalComponents(DWORD optional);

      DWORD
      GetOptionalComponents() const;

      // Optional Web Application components

      static const DWORD FRONTPAGE_EXTENSIONS_COMPONENT  = 0x1;
      static const DWORD ASPNET_COMPONENT                = 0x4;

      bool
      IsFTPInstalled() const;

      bool
      IsNNTPInstalled() const;

      bool
      IsSMTPInstalled() const;

   private:

      bool
      AreFrontPageExtensionsInstalled() const;

      bool
      IsASPNETInstalled() const;

      bool
      IsDTCInstalled() const;

      unsigned int
      GetWebAppRoleResult() const;

      // The optional components that will be installed

      DWORD optionalInstallComponents;

      // Installation status codes

      static const unsigned int WEBAPP_SUCCESS           = 0x00;
      static const unsigned int WEBAPP_IIS_FAILED        = 0x01;
      static const unsigned int WEBAPP_FRONTPAGE_FAILED  = 0x02;
      static const unsigned int WEBAPP_ASPNET_FAILED     = 0x08;

      unsigned int webAppRoleResult;
};

#endif // __CYS_WEBINSTALLATIONUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\webinstallationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      WebInstallationUnit.cpp
//
// Synopsis:  Defines a WebInstallationUnit
//            This object has the knowledge for installing the
//            IIS service
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "WebInstallationUnit.h"
#include "InstallationUnitProvider.h"

// Finish page help 
static PCWSTR CYS_WEB_FINISH_PAGE_HELP = L"cys.chm::/web_server_role.htm";
static PCWSTR CYS_WEB_MILESTONE_HELP = L"cys.chm::/web_server_role.htm#websrvsummary";
static PCWSTR CYS_WEB_AFTER_FINISH_HELP = L"cys.chm::/web_server_role.htm#websrvcompletion";

extern PCWSTR CYS_SAK_HOWTO = L"ntshowto.chm::/SAK_howto.htm";

WebInstallationUnit::WebInstallationUnit() :
   optionalInstallComponents(0),
   webAppRoleResult(WEBAPP_SUCCESS),
   InstallationUnit(
      IDS_WEB_SERVER_TYPE, 
      IDS_WEB_SERVER_DESCRIPTION, 
      IDS_WEB_FINISH_TITLE,
      IDS_WEB_FINISH_UNINSTALL_TITLE,
      IDS_WEB_FINISH_MESSAGE,
      IDS_WEB_INSTALL_FAILED,
      IDS_WEB_UNINSTALL_MESSAGE,
      IDS_WEB_UNINSTALL_FAILED,
      IDS_WEB_UNINSTALL_WARNING,
      IDS_WEB_UNINSTALL_CHECKBOX,
      CYS_WEB_FINISH_PAGE_HELP,
      CYS_WEB_MILESTONE_HELP,
      CYS_WEB_AFTER_FINISH_HELP,
      WEBAPP_SERVER)
{
   LOG_CTOR(WebInstallationUnit);
}


WebInstallationUnit::~WebInstallationUnit()
{
   LOG_DTOR(WebInstallationUnit);
}

String 
WebInstallationUnit::GetServiceName()
{
   LOG_FUNCTION(WebInstallationUnit::GetServiceName);

   if (name.empty())
   {
      if (State::GetInstance().Is64Bit())
      {
         name = String::load(IDS_WEB_SERVER_TYPE_64BIT);
      }
      else
      {
         name = String::load(IDS_WEB_SERVER_TYPE);
      }
   }

   return name;
}

InstallationReturnType
WebInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(WebInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   // Log heading

   // NTRAID#NTBUG9-487905-2001/11/05-JeffJon
   // Should only log the heading if this is the web server path
   // since this routine may be called for other paths

   InstallationUnit& currentInstallationUnit = 
      InstallationUnitProvider::GetInstance().GetCurrentInstallationUnit();

   if (currentInstallationUnit.GetServerRole() == WEBAPP_SERVER)
   {
      CYS_APPEND_LOG(String::load(IDS_LOG_WEB_HEADING));
   }

   UpdateInstallationProgressText(hwnd, IDS_WEB_PROGRESS);

   // Only install IIS if it's not already installed.
   // NTRAID#NTBUG9-463509-2001/09/06-sburns
   
   if (!IsServiceInstalledHelper(CYS_WEB_SERVICE_NAME))
   {
      String unattendFileText;
      String infFileText;

      // NTRAID#NTBUG9-482422-2001/10/29-JeffJon
      // New unattend settings from IIS team (ShantT)

      unattendFileText += L"[Components]\n";
      unattendFileText += L"iis_common=ON\n";
      unattendFileText += L"iis_inetmgr=ON\n";
      unattendFileText += L"iis_www=ON\n";
      unattendFileText += L"appsrv_console=ON\n";
      unattendFileText += L"complusnetwork=ON\n";
      unattendFileText += L"dtcnetwork=ON\n";

      // Add the optional components for the Web application server

      DWORD optionalComponents = GetOptionalComponents();

      bool installingFrontPage = false;
      if (optionalComponents & FRONTPAGE_EXTENSIONS_COMPONENT)
      {
         LOG(L"Adding FrontPage Extensions to unattend");

         unattendFileText += CYS_WEBAPP_FPSE_COMPONENT L"=ON\n";

         installingFrontPage = true;
      }
      
      bool installingASPNET = false;
      if (optionalComponents & ASPNET_COMPONENT)
      {
         LOG(L"Adding ASP.NET to unattend");

         unattendFileText += CYS_WEBAPP_ASPNET_COMPONENT L"=ON\n";

         installingASPNET = true;
      }

      bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
      if (ocmResult &&
          IsServiceInstalledHelper(CYS_WEB_SERVICE_NAME))
      {
         LOG(L"IIS was installed successfully");
         CYS_APPEND_LOG(String::load(IDS_LOG_SERVER_IIS_SUCCESS));

         if (installingFrontPage &&
             !AreFrontPageExtensionsInstalled())
         {
            webAppRoleResult |= WEBAPP_FRONTPAGE_FAILED;
            CYS_APPEND_LOG(String::load(IDS_LOG_WEBAPP_FRONTPAGE_FAILED));
         }
         
         if (installingASPNET &&
             !IsASPNETInstalled())
         {
            webAppRoleResult |= WEBAPP_ASPNET_FAILED;
            CYS_APPEND_LOG(String::load(IDS_LOG_WEBAPP_ASPNET_FAILED));
         }
      }
      else
      {
         LOG(L"IIS failed to install");
         CYS_APPEND_LOG(String::load(IDS_LOG_SERVER_IIS_FAILED));

         webAppRoleResult |= WEBAPP_IIS_FAILED;

         result = INSTALL_FAILURE;
      }
   }
   else
   {
      // IIS is already installed, the user must have gone thru the web path
      // and not checked the install web admin box.
      // NTRAID#NTBUG9-463508-2001/09/06-sburns

      LOG(L"IIS already installed");
      CYS_APPEND_LOG(String::load(IDS_LOG_IIS_ALREADY_SERVERED));
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

UnInstallReturnType
WebInstallationUnit::UnInstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(WebInstallationUnit::UnInstallService);

   UnInstallReturnType result = UNINSTALL_SUCCESS;

   CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_WEB_HEADING));

   if (State::GetInstance().Is64Bit())
   {
      UpdateInstallationProgressText(hwnd, IDS_WEB_UNINSTALL_PROGRESS_64BIT);
   }
   else
   {
      UpdateInstallationProgressText(hwnd, IDS_WEB_UNINSTALL_PROGRESS);
   }

   String unattendFileText;
   String infFileText;

   if (IsSMTPInstalled() ||
       IsFTPInstalled()  ||
       IsNNTPInstalled())
   {
      // NTRAID#NTBUG9-528499-2002/02/04-JeffJon
      // Don't uninstall iis_common if POP3 is installed.
      // POP3 uses SMTP which is part of the iis_common
      // component

      unattendFileText += L"[Components]\n";
      unattendFileText += L"iis_www=OFF\n";
   }
   else
   {
      unattendFileText += L"[Components]\n";
      unattendFileText += L"iis_www=OFF\n";
      unattendFileText += L"iis_common=OFF\n";
      unattendFileText += L"iis_inetmgr=OFF\n";
   }

   // Always uninstall the console, COM+, DTC, and
   // the BITS ISAPI components

   unattendFileText += L"complusnetwork=OFF\n";
   unattendFileText += L"dtcnetwork=OFF\n";
   unattendFileText += L"appsrv_console=OFF\n";
   unattendFileText += L"BITSServerExtensionsISAPI=OFF\n";

   // Always uninstall FPSE, and ASP.NET

   unattendFileText += CYS_WEBAPP_FPSE_COMPONENT L"=OFF\n";
   unattendFileText += CYS_WEBAPP_ASPNET_COMPONENT L"=OFF\n";

   // NTRAID#NTBUG9-736557-2002/11/13-JeffJon
   // Pass the /w switch to sysocmgr when uninstalling
   // so that if a situation occurs in which a reboot
   // is required, the user will be prompted.

   String additionalArgs = L"/w";

   bool ocmResult = 
      InstallServiceWithOcManager(
         infFileText, 
         unattendFileText,
         additionalArgs);

   if (ocmResult &&
       !IsServiceInstalledHelper(CYS_WEB_SERVICE_NAME))
   {
      LOG(L"IIS was uninstalled successfully");
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_IIS_SUCCESS));
   }
   else
   {
      LOG(L"IIS failed to uninstall");
      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_IIS_FAILED));

      result = UNINSTALL_FAILURE;
   }
   LOG_UNINSTALL_RETURN(result);

   return result;
}

InstallationReturnType
WebInstallationUnit::CompletePath(
   HANDLE logfileHandle,
   HWND   hwnd)
{
   LOG_FUNCTION(WebInstallationUnit::CompletePath);

   InstallationReturnType result = InstallService(logfileHandle, hwnd);

   LOG_INSTALL_RETURN(result);

   return result;
}

bool
WebInstallationUnit::GetMilestoneText(String& message)
{
   LOG_FUNCTION(WebInstallationUnit::GetMilestoneText);

   if (!IsServiceInstalled())
   {
      message += String::load(IDS_WEB_FINISH_TEXT);

      // Add DTC if not already installed

      if (!IsDTCInstalled())
      {
         message += String::load(IDS_WEB_MILESTONE_DTC);
      }

      // Add the optional components for the Web application server

      DWORD optionalComponents = GetOptionalComponents();

      if (optionalComponents & FRONTPAGE_EXTENSIONS_COMPONENT)
      {
         message += String::load(IDS_WEB_MILESTONE_FRONTPAGE);
      }
      
      if (optionalComponents & ASPNET_COMPONENT)
      {
         message += String::load(IDS_WEB_MILESTONE_ASPNET);
      }
   }
   else
   {
      // NTRAID#NTBUG9-463508-2001/09/06-sburns
            
      message = String::load(IDS_CONFIGURE_WEB_SERVER);
   }

   LOG_BOOL(true);
   return true;
}

bool
WebInstallationUnit::GetUninstallMilestoneText(String& message)
{
   LOG_FUNCTION(WebInstallationUnit::GetUninstallMilestoneText);

   if (State::GetInstance().Is64Bit())
   {
      message = String::load(IDS_WEB_UNINSTALL_TEXT_64BIT);
   }
   else
   {
      message = String::load(IDS_WEB_UNINSTALL_TEXT);
   }

   LOG_BOOL(true);
   return true;
}

String
WebInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(WebInstallationUnit::GetServiceDescription);

   unsigned int resourceID = static_cast<unsigned int>(-1);

   if (IsServiceInstalled())
   {
      resourceID = IDS_WEB_DESCRIPTION_INSTALLED;
   }
   else
   {
      if (State::GetInstance().Is64Bit())
      {
         resourceID = IDS_WEB_SERVER_DESCRIPTION_64BIT;
      }
      else
      {
         resourceID = IDS_WEB_SERVER_DESCRIPTION;
      }
   }

   ASSERT(resourceID != static_cast<unsigned int>(-1));

   String result = String::load(resourceID);
   LOG(result);
   return result;
}

int
WebInstallationUnit::GetWizardStart()
{
   LOG_FUNCTION(WebInstallationUnit::GetWizardStart);

   int result = IDD_WEBAPP_PAGE;

   bool installingRole = true;

   if (IsServiceInstalled())
   {
      installingRole = false;

      result = IDD_UNINSTALL_MILESTONE_PAGE;
   }
   else if (State::GetInstance().Is64Bit())
   {
      // ASP.NET is not available on
      // 64 bit so skip the optional components page

      result = IDD_MILESTONE_PAGE;
   }

   SetInstalling(installingRole);

   return result;
}

void
WebInstallationUnit::ServerRoleLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      WebInstallationUnit::ServerRoleLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (IsServiceInstalled())
   {
      ASSERT(linkIndex == 0);

      LaunchMYS();
   }
   else
   {
      ASSERT(linkIndex == 0);

      LOG(L"Showing configuration help");

      ShowHelp(CYS_WEB_FINISH_PAGE_HELP);
   }
}
  
void
WebInstallationUnit::FinishLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      WebInstallationUnit::FinishLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (installing)
   {
      if (IsServiceInstalled())
      {
         unsigned int roleResult = GetWebAppRoleResult();

         if (linkIndex == 0 &&
             (roleResult & WEBAPP_ASPNET_FAILED))
         {
            LOG(L"Launching Web Application Server console");

            String alternatePath = 
               FS::AppendPath(
                  Win::GetSystemDirectory(),
                  L"inetsrv");

            LaunchMMCConsole(L"appsrv.msc", alternatePath);
         }
         else
         {
            LOG(L"Showing after checklist");

            ShowHelp(CYS_WEB_AFTER_FINISH_HELP);
         }
      }
      else
      {
         LOG(L"Showing configuration help");

         ShowHelp(CYS_WEB_FINISH_PAGE_HELP);
      }
   }
}

String
WebInstallationUnit::GetFinishText()
{
   LOG_FUNCTION(WebInstallationUnit::GetFinishText);

   String message = String::load(finishMessageID);

   if (installing)
   {
      InstallationReturnType result = GetInstallResult();
      if (result == INSTALL_SUCCESS ||
          result == INSTALL_SUCCESS_REBOOT ||
          result == INSTALL_SUCCESS_PROMPT_REBOOT)
      {
         unsigned int roleResult = GetWebAppRoleResult();
         if (roleResult == WEBAPP_IIS_FAILED)
         {
            // should never get here because
            // if IIS failed to install result should
            // be INSTALL_FAILURE

            ASSERT(false);

            message = String::load(finishMessageID);
         }
         else
         {
            // Load the initial text and then append all
            // optional component errors to it

            message = String::load(IDS_WEBAPP_FINISH_OPTIONAL_FAILURE_HEADER);

            if (roleResult & WEBAPP_FRONTPAGE_FAILED)
            {
               message += String::load(IDS_WEBAPP_FINISH_FRONTPAGE_FAILURE);
            }
            
            if (roleResult & WEBAPP_ASPNET_FAILED)
            {
               message += String::load(IDS_WEBAPP_FINISH_ASPNET_FAILURE);
            }
            
            // Now tack on the footer

            message += String::load(IDS_WEBAPP_FINISH_OPTIONAL_FAILURE_FOOTER);
         }
      }
      else
      {
         message = String::load(finishInstallFailedMessageID);
      }
   }
   else
   {
      message = String::load(finishUninstallMessageID);

      UnInstallReturnType result = GetUnInstallResult();
      if (result != UNINSTALL_SUCCESS &&
          result != UNINSTALL_SUCCESS_REBOOT &&
          result != UNINSTALL_SUCCESS_PROMPT_REBOOT)
      {
         message = String::load(finishUninstallFailedMessageID);
      }
   }

   return message;
}

String
WebInstallationUnit::GetUninstallWarningText()
{
   LOG_FUNCTION(WebInstallationUnit::GetUninstallWarningText);

   unsigned int messageID = uninstallMilestoneWarningID;

   bool webSAKInstalled = IsSAKUnitInstalled(WEB);
   bool nasSAKInstalled = IsSAKUnitInstalled(NAS);

   if (webSAKInstalled ||
       nasSAKInstalled)
   {
      messageID = IDS_WEB_UNINSTALL_WARNING_SAK;
   }
   else
   {
      messageID = IDS_WEB_UNINSTALL_WARNING;
   }

   return String::load(messageID);
}

void
WebInstallationUnit::SetOptionalComponents(DWORD optionalComponents)
{
   LOG_FUNCTION2(
      WebInstallationUnit::SetOptionalComponents,
      String::format(L"0x%1!x!", optionalComponents));

   optionalInstallComponents = optionalComponents;
}

DWORD
WebInstallationUnit::GetOptionalComponents() const
{
   LOG_FUNCTION(WebInstallationUnit::GetOptionalComponents);

   LOG(
      String::format(
         L"optionalInstallComponents = 0x%1!08X!", 
         optionalInstallComponents));
 
   return optionalInstallComponents;
}

unsigned int
WebInstallationUnit::GetWebAppRoleResult() const
{
   LOG_FUNCTION(WebInstallationUnit::GetWebAppRoleResult);

   LOG(
      String::format(
         L"0x%1!x!",
         webAppRoleResult));

   return webAppRoleResult;
}

bool
WebInstallationUnit::AreFrontPageExtensionsInstalled() const
{
   LOG_FUNCTION(WebInstallationUnit::AreFrontPageExtensionsInstalled);

   bool result = false;

   DWORD value = 0;

   result = 
      GetRegKeyValue(
         CYS_WEBAPP_OCM_COMPONENTS, 
         CYS_WEBAPP_FPSE_COMPONENT, 
         value);

   LOG(
      String::format(
         L"regkey value = 0x%1!x!",
         value));

   result = result && value;

   LOG_BOOL(result);

   return result;
}

bool
WebInstallationUnit::IsASPNETInstalled() const
{
   LOG_FUNCTION(WebInstallationUnit::IsASPNETInstalled);

   bool result = false;

   DWORD value = 0;

   result = 
      GetRegKeyValue(
         CYS_WEBAPP_OCM_COMPONENTS, 
         CYS_WEBAPP_ASPNET_COMPONENT, 
         value);

   LOG(
      String::format(
         L"regkey value = 0x%1!x!",
         value));

   result = result && value;

   LOG_BOOL(result);

   return result;
}

bool
WebInstallationUnit::IsDTCInstalled() const
{
   LOG_FUNCTION(WebInstallationUnit::IsDTCInstalled);

   bool result = false;

   DWORD value = 0;

   result = 
      GetRegKeyValue(
         CYS_WEBAPP_OCM_COMPONENTS, 
         CYS_WEBAPP_DTC_COMPONENT, 
         value);

   LOG(
      String::format(
         L"regkey value = 0x%1!x!",
         value));

   result = result && value;

   LOG_BOOL(result);

   return result;
}

bool
WebInstallationUnit::IsFTPInstalled() const
{
   LOG_FUNCTION(WebInstallationUnit::IsFTPInstalled);

   bool result = false;

   DWORD value = 0;

   result = 
      GetRegKeyValue(
         CYS_WEBAPP_OCM_COMPONENTS, 
         CYS_IIS_FTP_COMPONENT, 
         value);

   LOG(
      String::format(
         L"regkey value = 0x%1!x!",
         value));

   result = result && value;

   LOG_BOOL(result);

   return result;
}

bool
WebInstallationUnit::IsNNTPInstalled() const
{
   LOG_FUNCTION(WebInstallationUnit::IsNNTPInstalled);

   bool result = false;

   DWORD value = 0;

   result = 
      GetRegKeyValue(
         CYS_WEBAPP_OCM_COMPONENTS, 
         CYS_IIS_NNTP_COMPONENT, 
         value);

   LOG(
      String::format(
         L"regkey value = 0x%1!x!",
         value));

   result = result && value;

   LOG_BOOL(result);

   return result;
}

bool
WebInstallationUnit::IsSMTPInstalled() const
{
   LOG_FUNCTION(WebInstallationUnit::IsSMTPInstalled);

   bool result = false;

   DWORD value = 0;

   result = 
      GetRegKeyValue(
         CYS_WEBAPP_OCM_COMPONENTS, 
         CYS_IIS_SMTP_COMPONENT, 
         value);

   LOG(
      String::format(
         L"regkey value = 0x%1!x!",
         value));

   result = result && value;

   LOG_BOOL(result);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\winsinstallationunit.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      WINSInstallationUnit.cpp
//
// Synopsis:  Defines a WINSInstallationUnit
//            This object has the knowledge for installing the
//            WINS service
//
// History:   02/06/2001  JeffJon Created

#include "pch.h"
#include "resource.h"

#include "WINSInstallationUnit.h"

// Finish page help 
static PCWSTR CYS_WINS_FINISH_PAGE_HELP = L"cys.chm::/wins_server_role.htm";
static PCWSTR CYS_WINS_MILESTONE_HELP = L"cys.chm::/wins_server_role.htm#winssrvsummary";
static PCWSTR CYS_WINS_AFTER_FINISH_HELP = L"cys.chm::/wins_server_role.htm#winssrvcompletion";

WINSInstallationUnit::WINSInstallationUnit() :
   installedDescriptionID(IDS_WINS_SERVER_DESCRIPTION_INSTALLED),
   InstallationUnit(
      IDS_WINS_SERVER_TYPE, 
      IDS_WINS_SERVER_DESCRIPTION, 
      IDS_WINS_FINISH_TITLE,
      IDS_WINS_FINISH_UNINSTALL_TITLE,
      IDS_WINS_FINISH_MESSAGE,
      IDS_WINS_INSTALL_FAILED,
      IDS_WINS_UNINSTALL_MESSAGE,
      IDS_WINS_UNINSTALL_FAILED,
      IDS_WINS_UNINSTALL_WARNING,
      IDS_WINS_UNINSTALL_CHECKBOX,
      CYS_WINS_FINISH_PAGE_HELP,
      CYS_WINS_MILESTONE_HELP,
      CYS_WINS_AFTER_FINISH_HELP,
      WINS_SERVER)
{
   LOG_CTOR(WINSInstallationUnit);
}


WINSInstallationUnit::~WINSInstallationUnit()
{
   LOG_DTOR(WINSInstallationUnit);
}


InstallationReturnType
WINSInstallationUnit::InstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(WINSInstallationUnit::InstallService);

   InstallationReturnType result = INSTALL_SUCCESS;

   // Log the WINS header

   CYS_APPEND_LOG(String::load(IDS_LOG_WINS_HEADING));

   UpdateInstallationProgressText(hwnd, IDS_WINS_PROGRESS);

   // Create the inf and unattend files that are used by the 
   // Optional Component Manager

   String infFileText;
   String unattendFileText;

   CreateInfFileText(infFileText, IDS_WINS_INF_WINDOW_TITLE);
   CreateUnattendFileText(unattendFileText, CYS_WINS_SERVICE_NAME);

   // Install the service through the Optional Component Manager

   bool ocmResult = InstallServiceWithOcManager(infFileText, unattendFileText);
   if (ocmResult &&
       IsServiceInstalled())
   {
      // Log the successful installation

      LOG(L"WINS was installed successfully");
      CYS_APPEND_LOG(String::load(IDS_LOG_SERVER_WINS_SUCCESS));

   }
   else
   {
      // Log the failure

      LOG(L"WINS failed to install");

      CYS_APPEND_LOG(String::load(IDS_LOG_WINS_SERVER_FAILED));

      result = INSTALL_FAILURE;
   }

   LOG_INSTALL_RETURN(result);

   return result;
}

UnInstallReturnType
WINSInstallationUnit::UnInstallService(HANDLE logfileHandle, HWND hwnd)
{
   LOG_FUNCTION(WINSInstallationUnit::UnInstallService);

   UnInstallReturnType result = UNINSTALL_SUCCESS;

   // Log the WINS header

   CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_WINS_HEADING));

   UpdateInstallationProgressText(hwnd, IDS_WINS_UNINSTALL_PROGRESS);

   // Create the inf and unattend files that are used by the 
   // Optional Component Manager

   String infFileText;
   String unattendFileText;

   CreateInfFileText(infFileText, IDS_WINS_INF_WINDOW_TITLE);
   CreateUnattendFileText(unattendFileText, CYS_WINS_SERVICE_NAME, false);

   // NTRAID#NTBUG9-736557-2002/11/13-JeffJon
   // Pass the /w switch to sysocmgr when uninstalling
   // so that if a situation occurs in which a reboot
   // is required, the user will be prompted.

   String additionalArgs = L"/w";

   // Install the service through the Optional Component Manager

   bool ocmResult = 
      InstallServiceWithOcManager(
         infFileText, 
         unattendFileText,
         additionalArgs);

   if (ocmResult &&
       !IsServiceInstalled())
   {
      // Log the successful uninstall

      LOG(L"WINS was uninstalled successfully");
      CYS_APPEND_LOG(String::load(IDS_LOG_SERVER_UNINSTALL_WINS_SUCCESS));

   }
   else
   {
      // Log the failure

      LOG(L"WINS failed to uninstall");

      CYS_APPEND_LOG(String::load(IDS_LOG_UNINSTALL_WINS_SERVER_FAILED));

      result = UNINSTALL_FAILURE;
   }
   LOG_UNINSTALL_RETURN(result);

   return result;
}

bool
WINSInstallationUnit::GetMilestoneText(String& message)
{
   LOG_FUNCTION(WINSInstallationUnit::GetMilestoneText);

   message = String::load(IDS_WINS_FINISH_TEXT);

   LOG_BOOL(true);
   return true;
}

bool
WINSInstallationUnit::GetUninstallMilestoneText(String& message)
{
   LOG_FUNCTION(WINSInstallationUnit::GetUninstallMilestoneText);

   message = String::load(IDS_WINS_UNINSTALL_TEXT);

   LOG_BOOL(true);
   return true;
}

String
WINSInstallationUnit::GetServiceDescription()
{
   LOG_FUNCTION(WINSInstallationUnit::GetServiceDescription);

   String result;

   unsigned int resultID = descriptionID;

   if (IsServiceInstalled())
   {
      resultID = installedDescriptionID;
   }

   result = String::load(resultID);

   ASSERT(!result.empty());

   return result;
}

void
WINSInstallationUnit::ServerRoleLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      WINSInstallationUnit::ServerRoleLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (IsServiceInstalled())
   {
      ASSERT(linkIndex == 0);

      LaunchMYS();
   }
   else
   {
      ASSERT(linkIndex == 0);

      LOG(L"Showing configuration help");

      ShowHelp(CYS_WINS_FINISH_PAGE_HELP);
   }
}
  
void
WINSInstallationUnit::FinishLinkSelected(int linkIndex, HWND /*hwnd*/)
{
   LOG_FUNCTION2(
      WINSInstallationUnit::FinishLinkSelected,
      String::format(
         L"linkIndex = %1!d!",
         linkIndex));

   if (installing)
   {
      if (linkIndex == 0 &&
          IsServiceInstalled())
      {
         LOG("Showing after checklist");

         ShowHelp(CYS_WINS_AFTER_FINISH_HELP);
      }
      else if (linkIndex == 0)
      {
         LOG(L"Showing configuration help");

         ShowHelp(CYS_WINS_FINISH_PAGE_HELP);
      }
   }
   else
   {
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\xbytes.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: xbytes.cpp

    Description: This module implements a class that coordinates the operation
        between the edit control and combo box used for entering byte values.
        The name "XBytes" is used because the control can represent
        KBytes, MBytes, GBytes etc.

        The cooperation between edit control and combo control is required
        so that the user can enter a byte value in the edit control then
        indicate it's order (KB, MB, GB...) using a selection from the combo box.

        A simple external interface is provided to initially set the
        object's byte value then retrieve the byte value when needed.  The
        object's client is also required to call two member functions when
        the parent dialog receives an EN_UPDATE notification and a CBN_SELCHANGE
        message.  The XBytes object handles all of the value scaling
        internally.

        NOTE: I experimented with adding a spin control to the edit control.
            I found that without some fancy intervention, the spin control
            didn't support fractional values (i.e. 2.5MB).  Decided to keep
            fractional values and ditch the spinner.  I think fractional
            values will be more useful to disk admins.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
    07/23/97    Added default ctor and CommonInit() function.        BrianAu
                Also added g_ForLoadingStaticStrings instance.
    11/01/01    Copied from BrianAu for use in CYS                   JeffJon
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"  // PCH
#pragma hdrstop

#include "resource.h"
#include "xbytes.h"

const TCHAR CH_NUL      = TEXT('\0');
const TCHAR CH_ZERO     = TEXT('0');
const INT MAX_EDIT_TEXT = 16;                     // Max chars in edit text.
const INT MAX_CMB_TEXT  = 10;                     // For "KB", "MB", "GB" etc.
const INT64 MAX_VALUE   = ((1i64 << 60) * 6i64);  // Max is 6EB.
const INT64 MIN_VALUE   = 1024i64;                // Min value is 1KB.
const INT64 DEFAULT_VALUE = ((1i64 << 20) * 5i64); // Default value is 5MB.
const LONGLONG NOLIMIT  = (LONGLONG)-1;

TCHAR XBytes::m_szNoLimit[];            // "No Limit" edit control text.

#define ARRAYSIZE(array) sizeof(array)/sizeof(array[0])

///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::XBytes

    Description: Constructor

    Arguments:
        hDlg - Handle to parent dialog.

        idCtlEdit - Control ID for edit control.

        idCtlCombo - Control ID for combo box control.

        CurrentBytes - Initial byte value.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
    10/15/96    Added m_MaxBytes member.                             BrianAu
    05/29/98    Removed m_MaxBytes member. Don't want to limit       BrianAu
                user's ability to enter a value larger than
                max disk space.
*/
///////////////////////////////////////////////////////////////////////////////
XBytes::XBytes(
    HWND hDlg,
    DWORD idCtlEdit,
    DWORD idCtlCombo,
    INT64 CurrentBytes
    ) : m_hDlg(hDlg),
        m_idCtlEdit(idCtlEdit),
        m_idCtlCombo(idCtlCombo),
        m_ValueBytes(0)
{
    CommonInit();

    LoadComboItems(MAXLONGLONG);        // Load options into combo.
    CurrentBytes = min(CurrentBytes, MAX_VALUE);
    if (NOLIMIT != CurrentBytes)
        CurrentBytes = max(CurrentBytes, DEFAULT_VALUE);

    SetBytes(CurrentBytes);             // Set "current bytes".
    //
    // Note: SetBytes() calls SetBestDisplay().
    //
}

//
// This constructor is sort of a hack.  Since the m_szNoLimit string
// is static, and since it is initialized in
// the constructor, at least one instance of XBytes must be created.
// There are cases where the static function FormatByteCountForDisplay
// may be useful when there is no need for an XBytes object.  The
// DiskQuota watchdog is just such an example.  If an XBytes object
// is not created, the two strings are not created and the function
// doesn't work correctly.  To fix this, I've defined a single global
// XBytes object constructed using this default constructor.  It's sole
// purpose is to load these static strings. [7/23/97 - brianau]
//
XBytes::XBytes(
    VOID
    ) : m_hDlg(NULL),
        m_idCtlEdit((DWORD)-1),
        m_idCtlCombo((DWORD)-1),
        m_ValueBytes(0)
{
    CommonInit();
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::Initialize

    Description: Initializes the XBytes class object so that the default
                 constructor can be used.  This is advantageous when using
                 the XBytes class as an embedded member of another window
                 class.

    Arguments:
        hDlg - Handle to parent dialog.

        idCtlEdit - Control ID for edit control.

        idCtlCombo - Control ID for combo box control.

        CurrentBytes - Initial byte value.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    11/01/01    Initial creation.                                    JeffJon
*/
///////////////////////////////////////////////////////////////////////////////
void
XBytes::Initialize(
    HWND hDlg,
    DWORD idCtlEdit,
    DWORD idCtlCombo,
    INT64 CurrentBytes)
{
   m_hDlg = hDlg;
   m_idCtlEdit = idCtlEdit;
   m_idCtlCombo = idCtlCombo;
   m_ValueBytes = 0;

   CommonInit();

   LoadComboItems(MAXLONGLONG);        // Load options into combo.
   CurrentBytes = min(CurrentBytes, MAX_VALUE);
   if (NOLIMIT != CurrentBytes)
   {
      CurrentBytes = max(CurrentBytes, DEFAULT_VALUE);
   }
   SetBytes(CurrentBytes);             // Set "current bytes".
   //
   // Note: SetBytes() calls SetBestDisplay().
   //
}

//
// Initialization common to both constructors.
//
VOID
XBytes::CommonInit(
    VOID
    )
{
    if (NULL != m_hDlg)
        SendMessage(m_hDlg, m_idCtlEdit, EM_LIMITTEXT, MAX_EDIT_TEXT);

    LoadStaticStrings();
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::SetBytes

    Description: Stores a new byte value and updates the display to the
        proper units (order).

    Arguments:
        ValueBytes - Value in bytes.
            If the value is NOLIMIT, the controls are disabled.
            Otherwise the controls are enabled.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::SetBytes(INT64 ValueBytes)
{
    if (NOLIMIT != ValueBytes)
        ValueBytes = max(MIN_VALUE, ValueBytes);

    ValueBytes = min(MAX_VALUE, ValueBytes);
    Store(ValueBytes, e_Byte);
    SetBestDisplay();
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::Enable

    Description: Enables/Disables the edit and combo controls.

    Arguments:
        bEnable - TRUE = Enable, FALSE = Disable.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/28/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::Enable(
    BOOL bEnable
    )
{
    EnableWindow(GetDlgItem(m_hDlg, m_idCtlCombo), bEnable);
    EnableWindow(GetDlgItem(m_hDlg, m_idCtlEdit), bEnable);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::IsEnabled

    Description: Returns the "enabled" state of the edit control.  As long
        as the client doesn't enable/disable the edit/combo controls
        individually, this represents the state of the control pair.
        By using only the SetBytes() method to control enabling/disabling,
        this is ensured.

    Arguments:
        bEnable - TRUE = Enable, FALSE = Disable.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/28/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
XBytes::IsEnabled(
    VOID
    )
{
    return IsWindowEnabled(GetDlgItem(m_hDlg, m_idCtlEdit));
}


bool
XBytes::UndoLastEdit(
    void
    )
{
    if (SendToEditCtl(EM_CANUNDO, 0, 0))
    {
        SendToEditCtl(EM_UNDO, 0, 0);
        SendToEditCtl(EM_EMPTYUNDOBUFFER, 0, 0);
        SendToEditCtl(EM_SETSEL, SendToEditCtl(EM_LINELENGTH, 0, 0), -1);
        return true;
    }
    return false;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::OnEditNotifyUpdate

    Description: Must be called whenever the parent window receives a
        EN_UPDATE notification for the edit control.  The function
        reads the current string in the edit control and tries to store it
        as a byte value.  If the store operation fails, the number is invalid
        and an alarm is sounded.

    Returns:
        Always returns FALSE.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
    10/15/96    Added check for too-large input.                     BrianAu
    10/22/96    Re-organized and added ValueInRange() function.      BrianAu
                This was to support value check/adjustment when
                user changes the combo-box setting (bug).
    02/26/97    Added EM_CANUNDO and EM_EMPTYUNDOBUFFER.             BrianAu
    05/29/98    Removed ValueInRange() function and replaced with    BrianAu
                check for negative number.
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
XBytes::OnEditNotifyUpdate(
    )
{
    TCHAR szEditText[MAX_PATH];
    bool bBeep = false;

    ASSERT((MAX_EDIT_TEXT < MAX_PATH));

    GetDlgItemText(m_hDlg, m_idCtlEdit, szEditText, ARRAYSIZE(szEditText));

    if (szEditText[0] != L'\0')
    {
      if (lstrlen(szEditText) > MAX_EDIT_TEXT)
      {
         szEditText[MAX_EDIT_TEXT] = TEXT('\0');
         SetDlgItemText(m_hDlg, m_idCtlEdit, szEditText);
      }

      if (0 != lstrcmpi(XBytes::m_szNoLimit, szEditText))
      {
         //
         // If text in edit control is not "No Limit", convert the text to
         // a number, verify that it is in range and store it.
         //
         if (Store(szEditText, (INT)GetOrderFromCombo()))
         {
               //
               // If number is negative, force it to the minimum.
               //
               if (0 > Fetch(NULL, e_Byte))
               {
                  SetBytes(MIN_VALUE);
                  bBeep = true;
               }

               SendToEditCtl(EM_EMPTYUNDOBUFFER, 0, 0);
         }
         else
         {
               bBeep = true;
               if (!UndoLastEdit())
               {
                  //
                  // Number must be too large for the selected order.
                  // Found that this can happen when first opening the disk quota UI
                  // after someone's set the value out of the range acceptable by
                  // the UI.  Remember, because we allow decimal values in the UI,
                  // the UI cannot accept values quite as large as the dskquota APIs.
                  // Beep the user and force the value to the largest acceptable
                  // value.
                  //
                  SetBytes(MAX_VALUE);
               }
         }
         if (bBeep)
         {
               //
               // Sound beep for either an invalid value or an out-of-range value.
               //
               MessageBeep(MB_OK);
         }
      }
    }

    return FALSE;
}


BOOL
XBytes::OnEditKillFocus(
    )
{
   TCHAR szEditText[MAX_EDIT_TEXT];
   bool bBeep = false;

   GetDlgItemText(m_hDlg, m_idCtlEdit, szEditText, ARRAYSIZE(szEditText));

   if (szEditText[0] != L'\0')
   {
      if (0 != lstrcmpi(XBytes::m_szNoLimit, szEditText))
      {
         INT64 value = Fetch(NULL, e_Byte);
         if (MIN_VALUE > value)
         {
               SetBytes(MIN_VALUE);
               bBeep = true;
         }
         else if (MAX_VALUE < value)
         {
               SetBytes(MAX_VALUE);
               bBeep = true;
         }
      }
   }
   else
   {
      SetBytes(MIN_VALUE);
      bBeep = true;
   }

   if (bBeep)
   {
      MessageBeep(MB_OK);
   }
   return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::OnComboNotifySelChange

    Description: Must be called whenever the parent window receives a
        CBM_SELCHANGE message for the combo box control.  The function
        scales the stored byte value to the new units.

    Returns:
        Always returns FALSE.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
    10/22/96    Modified to just call OnEditNotifyUpdate().          BrianAu
                Combo-box selection should have same value
                check/adjust behavior as edit control changes.
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
XBytes::OnComboNotifySelChange()
{
    TCHAR szEditText[MAX_EDIT_TEXT];
    bool bBeep = false;

    GetDlgItemText(m_hDlg, m_idCtlEdit, szEditText, ARRAYSIZE(szEditText));

    if (0 != lstrcmpi(XBytes::m_szNoLimit, szEditText))
    {
        //
        // If text in edit control is not "No Limit", convert the text to
        // a number, verify that it is in range and store it.
        //
        if (Store(szEditText, (INT)GetOrderFromCombo()))
        {
            //
            // If number is less than the minimum, force it to the minimum.
            //
            if (MIN_VALUE > Fetch(NULL, e_Byte))
            {
                SetBytes(MIN_VALUE);
                bBeep = true;
            }
        }
        else
        {
            //
            // Number must be too large for the selected order.
            // Beep the user and force the value to the largest acceptable
            // value.
            //
            SetBytes(MAX_VALUE);
            bBeep = true;
        }
        if (bBeep)
        {
            MessageBeep(MB_OK);
        }
    }
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::LoadComboItems

    Description: Initializes the combo box with its selections.
        [ "KB", "MB", "GB"... "PB" ].  The function only adds options that are
        reasonable for the size of the drive.  For example, if the drive
        is less than 1 GB in size, only KB and MB are displayed.

    Arguments:
        MaxBytes - Maximum bytes available on the drive (drive size).

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::LoadComboItems(
    INT64 MaxBytes
    )
{
    TCHAR szText[MAX_CMB_TEXT];
    INT idMsg = 0;
    INT order = e_Kilo;

    //
    // Find the string resource ID for the largest units possible.
    //
    // WARNING: This code assumes that the resource IDs for
    //          IDS_ORDERKB through IDS_ORDEREB are consecutive
    //          increasing integers.  Hence the following assertions.
    //
    ASSERT((IDS_ORDERMB == IDS_ORDERKB + 1));
    ASSERT((IDS_ORDERGB == IDS_ORDERKB + 2));
    ASSERT((IDS_ORDERTB == IDS_ORDERKB + 3));
    ASSERT((IDS_ORDERPB == IDS_ORDERKB + 4));
    ASSERT((IDS_ORDEREB == IDS_ORDERKB + 5));

    for (idMsg = IDS_ORDERKB; idMsg < IDS_ORDEREB; idMsg++)
    {
        if ((INT64)(1i64 << (10 * order++)) > MaxBytes)
        {
            idMsg--;
            break;
        }
    }

    //
    // idMsg is at largest units string we'll use.
    // Add strings to combo box.
    //
    while(idMsg >= IDS_ORDERKB)
    {
       if (LoadString(Win::GetModuleHandle(), idMsg, szText, ARRAYSIZE(szText)))
            SendToCombo(CB_INSERTSTRING, 0, (LPARAM)szText);
        idMsg--;
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::SetBestDisplay

    Description: Displays the byte value in the highest order that will
        produce a whole part of 3 digits or less.  That way you see
        "25.5" MB instead of "25500 KB".

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::SetBestDisplay(
    VOID
    )
{
    INT iOrder = e_Byte;
    TCHAR szValue[MAX_EDIT_TEXT];

    //
    // Display NOLIMIT as 0.  Edit and combo controls will be disabled
    // by property page code.  NOLIMIT is (-1).  Defined by NTFS.
    //
    if (NOLIMIT != m_ValueBytes)
    {
        //
        // Format the byte count for display.  Leave off the KB, MB... extension.
        // That part will be displayed in the combo box.
        //
        FormatByteCountForDisplay(m_ValueBytes, szValue, ARRAYSIZE(szValue), &iOrder);

        //
        // If value is 0, display MB units.  That's our default.
        //
        if (0 == m_ValueBytes)
            iOrder = e_Mega;

        //
        // Set the value string in the edit control and the order in the combo box.
        //
        SetOrderInCombo(iOrder);
        SetDlgItemText(m_hDlg,
                       m_idCtlEdit,
                       szValue);

        Enable(TRUE);
    }
    else
    {
        //
        // Set edit control to display "No Limit".
        //
        SetOrderInCombo(0);  // This will cause the combo to display nothing.
        SetDlgItemText(m_hDlg,
                       m_idCtlEdit,
                       m_szNoLimit);

        Enable(FALSE);
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::Store

    Description: Store a value in a given order as a byte count.

    Arguments:
        Value - Byte value in order xbOrder.

        xbOrder - Order of number in Value.
            One of set { e_Byte, e_Kilo, e_Mega ... e_Exa }

    Returns:
        TRUE    - Success.  Always returns TRUE.
                  Event though we're not returning anything useful, I want
                  the return type for both Store() methods to be the same.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
XBytes::Store(
    INT64 Value,
    INT xbOrder
    )
{
    ASSERT((VALID_ORDER(xbOrder)));

    m_ValueBytes = INT64(Value) << (10 * (xbOrder - e_Byte));
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::Store

    Description: Store a numeric string in a given order as a byte count.

    Arguments:
        pszSource - Numeric string.

        xbOrder - Order of number in pszSource.
            One of set { e_Byte, e_Kilo, e_Mega ... e_Exa }

    Returns:
        TRUE    - Success.
        FALSE   - Invalid number in string.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
XBytes::Store(
    LPCTSTR pszSource,
    INT xbOrder
    )
{
    TCHAR szValue[MAX_EDIT_TEXT];    // Temp buffer.
    TCHAR szDecimalSep[MAX_DECIMAL_SEP];
    LPTSTR pszValue = szValue;       // Pointer into temp buffer.
    LPTSTR pszDec   = szValue;       // Pointer to decimal part of temp buffer.
    BOOL bResult    = FALSE;
    INT64 WholePart = 0;
    INT64 FracPart  = 0;
    DWORD xbOrderX10 = xbOrder * 10; // Saves multiple computations.

    ASSERT((NULL != pszSource));
    ASSERT((VALID_ORDER(xbOrder)));

    GetLocaleInfo(LOCALE_USER_DEFAULT,
                  LOCALE_SDECIMAL,
                  szDecimalSep,
                  ARRAYSIZE(szDecimalSep));

    //
    // Local copy to party on.
    //
    lstrcpyn(szValue, pszSource, ARRAYSIZE(szValue));

    PWSTR oldLocale = _wsetlocale(LC_ALL, L"");

    //
    // Find the start of the decimal separator.
    //
    while(NULL != *pszDec && szDecimalSep[0] != *pszDec)
    {
       // This checks to make sure its a legal digit for the
       // locale

       if (!StrToInt64Ex(pszDec, STIF_DEFAULT, &WholePart) &&
           szDecimalSep[0] != *pszDec)
       {
          goto not_a_number;
       }
       pszDec++;
    }

    if (CH_NUL != *pszDec)
    {
        *pszDec = CH_NUL;      // Terminate the whole part.

        //
        // Skip over the decimal separator character(s).
        // Remember, separator is localized.
        //
        LPTSTR pszDecimalSep = &szDecimalSep[1];
        pszDec++;
        while(*pszDecimalSep && *pszDec && *pszDec == *pszDecimalSep)
        {
            pszDecimalSep++;
            pszDec++;
        }
    }
    else
        pszDec = NULL;          // No decimal pt found.


    //
    // Convert whole part to an integer.
    //

    BOOL converted = StrToInt64Ex(pszValue, STIF_DEFAULT, &WholePart);

    _wsetlocale(LC_ALL, oldLocale);

    if (!converted)
        goto not_a_number;
    //
    // Check to make sure the number entered will fit into a 64-bit int when
    // scaled up.
    // With the text entry field and order combo, users can specify numbers
    // that will overflow an __int64.  Can't let this happen.  Treat overflows
    // as invalid entry.  The (-1) accounts for the largest fractional part
    // that the user could enter.
    //
    if (WholePart > ((MAXLONGLONG >> xbOrderX10) - 1))
        goto not_a_number;

    //
    // Scale whole part according to order.
    //
    WholePart *= (1i64 << xbOrderX10);

    //
    // Convert fractional part to an integer.
    //
    if (NULL != pszDec &&
        pszDec[0] != L'\0')
    {
        //
        // Trim any trailing zero's first.
        //
        LPTSTR pszZero = pszDec + lstrlen(pszDec) - 1;
        while(pszZero >= pszDec && CH_ZERO == *pszZero)
            *pszZero-- = CH_NUL;

        // Check to make sure all characters are valid digits
        // for this locale

        oldLocale = _wsetlocale(LC_ALL, L"");

        PWSTR currentDecChar = pszDec;
        while (currentDecChar &&
               currentDecChar[0] != L'\0')
        {
           if (!StrToInt64Ex(currentDecChar, STIF_DEFAULT, &FracPart))
           {
              goto not_a_number;
           }
           ++currentDecChar;
        }

        //
        // Convert decimal portion of string to an integer.
        //


        converted = StrToInt64Ex(pszDec, STIF_DEFAULT, &FracPart);

        _wsetlocale(LC_ALL, oldLocale);

        if (!converted)
        {
            goto not_a_number;
        }

        //
        // Scale fractional part according to order.
        //
        FracPart *= (1i64 << xbOrderX10);

        DWORD dwDivisor = 1;
        while(pszZero-- >= pszDec)
            dwDivisor *= 10;

        //
        // Round up to the nearest muliple of the divisor to prevent
        // undesireable truncation during integer division we do below.
        //
        DWORD dwRemainder = (DWORD)(FracPart % dwDivisor);
        if (0 != dwRemainder)
            FracPart += dwDivisor - dwRemainder;

        FracPart /= dwDivisor;
    }

    m_ValueBytes = WholePart + FracPart;
    bResult = TRUE;

not_a_number:

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::Fetch

    Description: Retrieve the byte count from the object using a specified
        order (magnitude).  i.e. For 60.5 MB, the order is e_Mega, the decimal
        part is 5 and the returned value is 60.

    Arguments:
        pDecimal [optional] - Address of DWORD to receive the fractional part
            of the byte count.  May be NULL.

        xbOrder - Order desired for the returned value.  Must be from the
            enumeration set { e_Byte, e_Kilo, e_Mega ... e_Exa }

    Returns:
        Returns the whole part of the byte count.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT64
XBytes::Fetch(
    INT64 *pDecimal,
    INT xbOrder
    )
{
    return BytesToParts(m_ValueBytes, pDecimal, xbOrder);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::Fetch

    Description: Retrieve the byte count from the object and tell the caller
        what the best order is for display.  The logic used for "best order"
        is to use the first order that results in a 3-digit number.

    Arguments:
        pDecimal - Address of DWORD to receive the fractional part of the
            byte count.

        pxbOrder - Address of integer to receive the order of the number
            being returned.  The returned order is in the enumeration
            { e_Byte, e_Kilo, e_Mega ... e_Exa }

    Returns:
        Returns the whole part of the byte count.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
XBytes::Fetch(
    LPDWORD pDecimal,
    INT *pxbOrder
    )
{
    return BytesToParts(m_ValueBytes, pDecimal, pxbOrder);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::BytesToParts

    Description: Converts a byte value to it's whole and fractional parts
        for a given magnitude (order).  This is a static member function
        that can be used outside of the context of an XBytes object.

    Arguments:
        ValueBytes - Value to convert expressed in bytes.

        pDecimal [optional] - Address of variable to receive the fractional
            part.  May be NULL.

        xbOrder - Order that the parts are to represent.
            { e_Byte, e_Kilo, e_Mega ... e_Exa }

    Returns: Returns the whole part of the value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT64
XBytes::BytesToParts(
    INT64 ValueBytes,
    INT64 *pDecimal,
    INT xbOrder
    )
{
    INT64 Value = ValueBytes;
    UINT64 DecMask = 0;             // Start with a blank mask.
    DWORD dwOrderDeltaX10 = 10 * (xbOrder - e_Byte);

    ASSERT((VALID_ORDER(xbOrder)));

    //
    // Convert the value from order e_Byte to the order requested.
    // Also build a mask that can extract the decimal portion
    // from the original byte value.   The following 2 statements implement
    // this logic.
    //
    // for (INT i = e_Byte; i < xbOrder; i++)
    // {
    //     ValueBytes >>= 10;  // Divide byte value by 1024.
    //     DecMask <<= 10;     // Shift current mask bits 10 left.
    //     DecMask |= 0x3FF;   // OR in another 10 bits.
    // }
    //
    Value >>= dwOrderDeltaX10;
    DecMask = (1i64 << dwOrderDeltaX10) - 1;

    if (NULL != pDecimal)
    {
        //
        // Caller wants fractional part.
        // Extract fractional part from byte value and scale it to the
        // specified order.
        // Pseudocode:
        //      x   = value & mask
        //      pct = x / (2**order)    // ** = "raise to the power of".
        //      dec = 100 * pct
        //
        *pDecimal = (INT64)(100 * (ValueBytes & DecMask)) >> (10 * xbOrder);
    }

    return Value;
}


double
XBytes::ConvertFromBytes(
    INT64 ValueBytes,
    INT xbOrder
    )
{
    return (double)ValueBytes / (double)(10 * xbOrder);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::BytesToParts

    Description: Converts a byte value to it's whole and fractional parts.
        Determines the maximum magnitude (order) that will display the
        whole part in 3 digits or less.
        This is a static member function that can be used outside of the
        context of an XBytes object.

    Arguments:
        ValueBytes - Value to convert expressed in bytes.

        pDecimal [optional] - Address of variable to receive the fractional
            part.  May be NULL.

        pxbOrder - Address of variable to receive the determined order.
            { e_Byte, e_Kilo, e_Mega ... e_Exa }

    Returns: Returns the whole part of the value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
XBytes::BytesToParts(
    INT64 ValueBytes,
    LPDWORD pDecimal,
    INT *pxbOrder
    )
{
    INT64 Value   = 0;
    INT64 Decimal = 0;
    INT xbOrder   = e_Byte;

    ASSERT((NULL != pDecimal));
    ASSERT((NULL != pxbOrder));

    //
    // Determine the best order for display.
    //
    while(xbOrder <= MAX_ORDER)
    {
        Value = BytesToParts(ValueBytes, &Decimal, xbOrder);
        if (Value < (INT64)1000)
            break;
        xbOrder++;
    }

    //
    // Return the results.
    //
    *pxbOrder = xbOrder;
    *pDecimal = (DWORD)Decimal;  // Fetch() guarantees this cast is OK.

    return (DWORD)Value;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::FormatByteCountForDisplay

    Description: Given a byte count, this static method formats a character
        string with the 999.99XB number where "XB" is the maximum units
        that can display the whole part in 3 digits or less.

    Arguments:
        Bytes - Number of bytes to format.

        pszDest - Address of destination character buffer.

        cchDest - Size of destination buffer in characters.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::FormatByteCountForDisplay(
    INT64 Bytes,
    LPTSTR pszDest,
    UINT cchDest
    )
{
    INT Order         = XBytes::e_Byte;

    //
    // To avoid using a local temp buffer, the caller's buffer must be
    // large enough for final string.  "999.99 MB" plus NUL and some pad to
    // allow for possible multi-char decimal separators (localized).
    //
    ASSERT((NULL != pszDest));

    FormatByteCountForDisplay(Bytes, pszDest, cchDest, &Order);

    DWORD dwLen = lstrlen(pszDest);
    //
    // Insert a space between the number and the suffix (i.e. "99 MB").
    // dwLen is incremented to allow for the added space.
    //
    *(pszDest + dwLen++) = TEXT(' ');
    //
    // Append the suffix.
    //
    LoadString(Win::GetModuleHandle(), IDS_ORDERKB + Order - 1, pszDest + dwLen, cchDest - dwLen);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::FormatByteCountForDisplay

    Description: Given a byte count, this static method formats a character
        string with the 999.99 number and returns the enumerted value
        representing the order in *pOrder.  This function complements
        the one above for those callers not needing the "KB", "MB"...
        suffix.  In particular, our combo box.

    Arguments:
        Bytes - Number of bytes to format.

        pszDest - Address of destination character buffer.

        cchDest - Size of destination buffer in characters.

        pOrder - Address of variable to receive the enumerated order value.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::FormatByteCountForDisplay(
    INT64 Bytes,
    LPTSTR pszDest,
    UINT cchDest,
    INT *pOrder
    )
{
    ASSERT((NULL != pszDest));
    ASSERT((NULL != pOrder));

    DWORD dwWholePart = 0;
    DWORD dwFracPart  = 0;

    dwWholePart = BytesToParts(Bytes, &dwFracPart, pOrder);

    FormatForDisplay(pszDest, cchDest, dwWholePart, dwFracPart);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::FormatByteCountForDisplay

    Description: Given a byte count, and a specified order, this static method
        formats a character string with the 999.99 number in the specified
        order.

    Arguments:
        Bytes - Number of bytes to format.

        pszDest - Address of destination character buffer.

        cchDest - Size of destination buffer in characters.

        Order - Order of the value in the resultant string.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::FormatByteCountForDisplay(
    INT64 Bytes,
    LPTSTR pszDest,
    UINT cchDest,
    INT Order
    )
{
    LONGLONG llWholePart;
    LONGLONG llFracPart;

    ASSERT((NULL != pszDest));

    //
    // WARNING: This code assumes that the whole and fractional parts will
    //          each be less than 2^32.  I think a valid assumption for scaled
    //          quota information.
    //
    llWholePart = BytesToParts(Bytes, &llFracPart, Order);
    FormatForDisplay(pszDest, cchDest, (DWORD)llWholePart, (DWORD)llFracPart);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: XBytes::FormatForDisplay

    Description: Given a whole part and a fractional part, format a decimal
        number suitable for display in 999.99 format.  If the fractional
        part is 0, no decimal part is included.

    Arguments:
        pszDest - Address of destination character buffer.

        cchDest - Size of destination buffer in characters.

        dwWholePart - Whole part of the number.

        dwFracPart - Fractional part of the number.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
XBytes::FormatForDisplay(
    LPTSTR pszDest,
    UINT cchDest,
    DWORD dwWholePart,
    DWORD dwFracPart
    )
{
    ASSERT((NULL != pszDest));

    TCHAR szTemp[80];

    if (0 != dwFracPart)
    {
        TCHAR szFmt[] = TEXT("%d%s%02d");
        TCHAR szDecimalSep[MAX_DECIMAL_SEP];

        if ((dwFracPart >= 10) && (0 == (dwFracPart % 10)))
        {
            //
            // Whack off the trailing zero for display.
            //
            dwFracPart /= 10;
            szFmt[6] = TEXT('1');
        }

        GetLocaleInfo(LOCALE_USER_DEFAULT,
                      LOCALE_SDECIMAL,
                      szDecimalSep,
                      ARRAYSIZE(szDecimalSep));

        wsprintf(szTemp, szFmt, dwWholePart, szDecimalSep, dwFracPart);
    }
    else
        wsprintf(szTemp, TEXT("%d"), dwWholePart);

    lstrcpyn(pszDest, szTemp, cchDest);
}

//
// Load the static strings if they haven't been loaded.
//
VOID
XBytes::LoadStaticStrings(
    void
    )
{
    //
    // Initialize the "No Limit" text string for display in the
    // edit control.  This is the same string used in the details list
    // view columns.
    //
    if (TEXT('\0') == m_szNoLimit[0])
    {
        INT cchLoaded = LoadString(Win::GetModuleHandle(),
                                   IDS_NO_LIMIT,
                                   m_szNoLimit,
                                   ARRAYSIZE(m_szNoLimit));

        ASSERT((0 < cchLoaded));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\win32\xbytes.h ===
#ifndef _INC_DSKQUOTA_XBYTES_H
#define _INC_DSKQUOTA_XBYTES_H
///////////////////////////////////////////////////////////////////////////////
/*  File: xbytes.h

    Description: This module implements a class t  hat coordinates the operation
        between the edit control and combo box used for entering byte values.
        The name "XBytes" is used because the control can represent
        KBytes, MBytes, GBytes etc.

        The cooperation between edit control and combo control is required
        so that the user can enter a byte value in the edit control then
        indicate it's order (KB, MB, GB...) using a selection from the combo box.

        A simple external interface is provided to initially set the
        object's byte value then retrieve the byte value when needed.  The
        object's client is also required to call two member functions when
        the parent dialog receives an EN_UPDATE notification and a CBN_SELCHANGE
        message.  The XBytes object handles all of the value scaling
        internally.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/30/96    Initial creation.                                    BrianAu
    10/15/96    Added m_MaxBytes member.                             BrianAu
    10/22/96    Added ValueInRange() member.                         BrianAu
    05/29/98    Removed ValueInRange() and m_MaxBytes members.       BrianAu
    11/01/01    Copied from BrianAu for use in CYS                   JeffJon
*/
///////////////////////////////////////////////////////////////////////////////

const INT MAX_DECIMAL_SEP = 10;
const INT MAX_NOLIMIT_LEN = 80; // This should be plenty for localization.

#define MAX_ORDER         e_Exa
#define VALID_ORDER(ord)  ((ord) >= e_Byte && (ord) <= MAX_ORDER)


class XBytes
{
    private:
        INT64 m_ValueBytes;     // Byte value.
        HWND  m_hDlg;           // Parent dlg.
        DWORD m_idCtlEdit;      // Edit control.
        DWORD m_idCtlCombo;     // Combo control.
        static TCHAR m_szNoLimit[MAX_NOLIMIT_LEN];

        VOID CommonInit(VOID);

        inline BOOL IsCharNumeric(TCHAR ch)
            { return IsCharAlphaNumeric(ch) && !IsCharAlpha(ch); }
        //BOOL StrToInt(LPCTSTR pszValue, INT64 *pIntValue);

        inline INT_PTR SendToEditCtl(UINT message, WPARAM wParam, LPARAM lParam)
            { return SendMessage(GetDlgItem(m_hDlg, m_idCtlEdit), message, wParam, lParam); }
        inline INT_PTR SendToCombo(UINT message, WPARAM wParam, LPARAM lParam)
            { return SendMessage(GetDlgItem(m_hDlg, m_idCtlCombo), message, wParam, lParam); }

        inline INT_PTR GetOrderFromCombo(VOID)
            { return SendToCombo(CB_GETCURSEL, 0, 0) + 1; }
        inline INT_PTR SetOrderInCombo(INT iOrder)
            { return SendToCombo(CB_SETCURSEL, iOrder-1, 0); }

        VOID LoadComboItems(INT64 MaxBytes);
        VOID SetBestDisplay(VOID);

        BOOL Store(INT64 Value, INT xbOrder);
        BOOL Store(LPCTSTR pszValue, INT xbOrder);

        INT64 Fetch(INT64 *pDecimal, INT xbOrder);    // Fetch in requested order.
        DWORD Fetch(DWORD *pDecimal, INT *pxbOrder);  // Fetch in "best" order.

        bool UndoLastEdit(void);

        static VOID LoadStaticStrings(void);
        static VOID FormatForDisplay(LPTSTR pszDest,
                                     UINT cchDest,
                                     DWORD dwWholePart,
                                     DWORD dwFracPart);

    public:

        VOID Enable(BOOL bEnable);

        //
        // With the exception of e_Byte, these must match the order
        // of the IDS_ORDERKB, IDS_ORDERMB... string resource IDs.
        // There is no IDS_ORDERBYTE string resource.
        //
        enum {e_Byte, e_Kilo, e_Mega, e_Giga, e_Tera, e_Peta, e_Exa};

        XBytes(VOID);

        XBytes(HWND hDlg, DWORD idCtlEdit, DWORD idCtlCombo, INT64 CurrentBytes);

        void
        Initialize(
            HWND hDlg,
            DWORD idCtlEdit,
            DWORD idCtlCombo,
            INT64 CurrentBytes);

        static double ConvertFromBytes(INT64 ValueBytes, INT xbOrder);
        static INT64 BytesToParts(INT64 ValueBytes, INT64 *pDecimal, INT xbOrder);
        static DWORD BytesToParts(INT64 ValueBytes, LPDWORD pDecimal, INT *pxbOrder);
        static VOID FormatByteCountForDisplay(INT64 Bytes, LPTSTR pszDest, UINT cchDest);
        static VOID FormatByteCountForDisplay(INT64 Bytes, LPTSTR pszDest, UINT cchDest, INT *pOrder);
        static VOID FormatByteCountForDisplay(INT64 Bytes, LPTSTR pszDest, UINT cchDest, INT Order);

        INT64 GetBytes(VOID)
            { return Fetch(NULL, e_Byte); }

        VOID SetBytes(INT64 Value);

        //
        // EN_xxxx handlers.  Client must call this on EN_UPDATE.
        //
        BOOL OnEditNotifyUpdate();
        BOOL OnEditKillFocus();

        //
        // CBN_xxxx handlers. Client must call this on CBN_SELCHANGE.
        //
        BOOL OnComboNotifySelChange();

        BOOL IsEnabled(VOID);
};


#endif // _INC_DSKQUOTA_XBYTES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\wrappers\dhcp\misc.hpp ===
// Copyright (c) 2000 Microsoft Corp.
//
// random other stuff



#ifndef MISC_HPP_INCLUDED
#define MISC_HPP_INCLUDED



void
logMessage(const wchar_t* msg)
{
   if (msg)
   {
      ::OutputDebugString(L"dhcpwiz: ");
      ::OutputDebugString(msg);
      ::OutputDebugString(L"\n");
   }
}



void
logHresult(HRESULT hr)
{                                                              
   wchar_t buf[1024];                                          
   wsprintf(buf, L"HRESULT = 0x%08X\n", (hr));                 
   logMessage(buf);                               
}                                                              



#ifdef DBG

#define LOG_HRESULT(hr)    logHresult(hr)
#define LOG_MESSAGE(msg)   logMessage(msg)

#else

#define LOG_HRESULT(hr)
#define LOG_MESSAGE(msg)

#endif DBG



#define BREAK_ON_FAILED_HRESULT(hr,msg)                           \
   if (FAILED(hr))                                                \
   {                                                              \
      LOG_MESSAGE(msg);                                           \
      LOG_HRESULT(hr);                                            \
      break;                                                      \
   }



// A BSTR wrapper that frees itself upon destruction.
//
// From Box, D. Essential COM.  pp 80-81.  Addison-Wesley. ISBN 0-201-63446-5

class AutoBstr
{
   public:

   explicit         
   AutoBstr(const wchar_t* s)
      :
      bstr(::SysAllocString(s))
   {
      ASSERT(s);
   }

   ~AutoBstr()
   {
      ::SysFreeString(bstr);
      bstr = 0;
   }

   operator BSTR () const
   {
      return bstr;
   }

   private:

   BSTR bstr;
};


#endif   // MISC_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\wrappers\dhcp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        229
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1195
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\wrappers\dhcp\dhcpwiz.cpp ===
// Copyright (c) 2000 Microsoft Corp.
//
// launches dhcp wizard from the dhcp snapin using mmc automation



#include "headers.hxx"
#include "resource.h"
#include "smartptr.hpp"
#include "misc.hpp"



HINSTANCE hResourceModuleHandle = 0;



HRESULT
getContextMenu(const SmartInterface<View>& view, ContextMenu** dumbMenu)
{
   HRESULT hr = S_OK;

   _variant_t missingParam2(DISP_E_PARAMNOTFOUND, VT_ERROR);
   hr = view->get_ScopeNodeContextMenu(missingParam2, dumbMenu);

   return hr;
}



HRESULT
doIt()
{
   HRESULT hr = S_OK;

   do
   {
      hr = ::CoInitialize(0);
      BREAK_ON_FAILED_HRESULT(hr, L"CoInitialize failed.");

      SmartInterface<_Application> app(0);
      hr =
         app.AcquireViaCreateInstance(
            CLSID_Application,
            0,

            // we expect the object is out-of-proc, local server, but
            // we really don't care, so we'll take any implementation
            // available.

            CLSCTX_ALL);
      BREAK_ON_FAILED_HRESULT(hr, L"CoCreateInstance failed.");

      SmartInterface<Document> doc(0);
      Document* dumbDoc = 0;
      hr = app->get_Document(&dumbDoc);
      BREAK_ON_FAILED_HRESULT(hr, L"get_Document failed.");
      doc.Acquire(dumbDoc);

      SmartInterface<SnapIns> snapIns(0);
      SnapIns* dumbSnapIns = 0;
      hr = doc->get_SnapIns(&dumbSnapIns);
      BREAK_ON_FAILED_HRESULT(hr, L"get_SnapIns failed.");
      snapIns.Acquire(dumbSnapIns);

      static const wchar_t* DHCP_SNAPIN_CLSID =
         L"{90901AF6-7A31-11D0-97E0-00C04FC3357A}";

      SmartInterface<SnapIn> snapIn(0);
      SnapIn* dumbSnapIn = 0;
      _variant_t missingParam(DISP_E_PARAMNOTFOUND, VT_ERROR);
      _variant_t missingParam2(DISP_E_PARAMNOTFOUND, VT_ERROR);
      hr =
         snapIns->Add(AutoBstr(DHCP_SNAPIN_CLSID), missingParam, missingParam2, &dumbSnapIn);
      BREAK_ON_FAILED_HRESULT(hr, L"SnapIns::Add failed.  Is DHCP installed?");
      snapIn.Acquire(dumbSnapIn);

      SmartInterface<Views> views(0);
      Views* dumbViews = 0;
      hr = doc->get_Views(&dumbViews);
      BREAK_ON_FAILED_HRESULT(hr, L"get_Views failed.");
      views.Acquire(dumbViews);

      SmartInterface<View> view(0);
      View* dumbView = 0;
      hr = views->Item(1, &dumbView);
      BREAK_ON_FAILED_HRESULT(hr, L"Views::Item failed.");
      view.Acquire(dumbView);

      SmartInterface<ScopeNamespace> sn(0);
      ScopeNamespace* dumbSn = 0;
      hr = doc->get_ScopeNamespace(&dumbSn);
      BREAK_ON_FAILED_HRESULT(hr, L"get_ScopeNamespace failed.");
      sn.Acquire(dumbSn);

      SmartInterface<Node> rootnode(0);
      Node* dumbNode = 0;
      hr = sn->GetRoot(&dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetRoot failed.");
      rootnode.Acquire(dumbNode);

      SmartInterface<Node> child1(0);
      hr = sn->GetChild(rootnode, &dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetChild failed.");
      child1.Acquire(dumbNode);

      hr = view->put_ActiveScopeNode(child1);
      BREAK_ON_FAILED_HRESULT(hr, L"put_ActiveScopeNode failed.");

      // have to read back the child node we just put...

      hr = view->get_ActiveScopeNode(&dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetActiveScopeNode failed.");
      child1 = dumbNode;
      dumbNode->Release();
      dumbNode = 0;

      SmartInterface<Node> child2(0);
      hr = sn->GetChild(child1, &dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetChild failed.");
      child2.Acquire(dumbNode);

      hr = view->put_ActiveScopeNode(child2);
      BREAK_ON_FAILED_HRESULT(hr, L"put_ActiveScopeNode failed.");

      // excute new scope wizard menu item
      _variant_t missingParam3(DISP_E_PARAMNOTFOUND, VT_ERROR);

      hr = view->ExecuteScopeNodeMenuItem((BSTR)AutoBstr(L"_CREATE_NEW_SCOPE"), missingParam3);
      BREAK_ON_FAILED_HRESULT(hr, L"ExecuteScopeNodeMenuItem _CREATE_NEW_SCOPE failed");

      hr = doc->Close(FALSE);
      BREAK_ON_FAILED_HRESULT(hr, L"Close failed.");
   }
   while (0);

   return hr;
}



int WINAPI
WinMain(
   HINSTANCE   hInstance, 
   HINSTANCE   /* hPrevInstance */ ,
   LPSTR       /* lpszCmdLine */ ,
   int         /* nCmdShow */ )
{
   hResourceModuleHandle = hInstance;

   int exitCode = static_cast<int>(doIt());

   return exitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\wrappers\dns\dnswiz.cpp ===
// Copyright (c) 2000 Microsoft Corp.
//
// launches dns wizard from the dhcp snapin using mmc automation



#include "headers.hxx"
#include "resource.h"
#include "smartptr.hpp"
#include "misc.hpp"

//
// This is the language independent menu ID of the Configure a DNS Wizard
//
#define DNS_CONFIGE_WIZARD_MENU_ID L"_DNS_CONFIGURETOP"

HINSTANCE hResourceModuleHandle = 0;



HRESULT
getContextMenu(const SmartInterface<View>& view, ContextMenu** dumbMenu)
{
   HRESULT hr = S_OK;

   _variant_t missingParam2(DISP_E_PARAMNOTFOUND, VT_ERROR);
   hr = view->get_ScopeNodeContextMenu(missingParam2, dumbMenu);

   return hr;
}


HRESULT
doIt()
{
   HRESULT hr = S_OK;

   SmartInterface<Document> doc(0);
   do
   {
      hr = ::CoInitialize(0);
      BREAK_ON_FAILED_HRESULT(hr, L"CoInitialize failed.");

      SmartInterface<_Application> app(0);
      hr =
         app.AcquireViaCreateInstance(
            CLSID_Application,
            0,

            // we expect the object is out-of-proc, local server, but
            // we really don't care, so we'll take any implementation
            // available.

            CLSCTX_ALL);
      BREAK_ON_FAILED_HRESULT(hr, L"CoCreateInstance failed.");

      Document* dumbDoc = 0;
      hr = app->get_Document(&dumbDoc);
      BREAK_ON_FAILED_HRESULT(hr, L"get_Document failed.");
      doc.Acquire(dumbDoc);

      SmartInterface<SnapIns> snapIns(0);
      SnapIns* dumbSnapIns = 0;
      hr = doc->get_SnapIns(&dumbSnapIns);
      BREAK_ON_FAILED_HRESULT(hr, L"get_SnapIns failed.");
      snapIns.Acquire(dumbSnapIns);

      static const wchar_t* DNS_SNAPIN_CLSID =
         L"{2FAEBFA2-3F1A-11D0-8C65-00C04FD8FECB}";

      SmartInterface<SnapIn> snapIn(0);
      SnapIn* dumbSnapIn = 0;
      _variant_t missingParam(DISP_E_PARAMNOTFOUND, VT_ERROR);
      _variant_t missingParam2(DISP_E_PARAMNOTFOUND, VT_ERROR);
      hr =
         snapIns->Add(AutoBstr(DNS_SNAPIN_CLSID), missingParam, missingParam2, &dumbSnapIn);
      BREAK_ON_FAILED_HRESULT(hr, L"SnapIns::Add failed.  Is DNS installed?");
      snapIn.Acquire(dumbSnapIn);

      SmartInterface<Views> views(0);
      Views* dumbViews = 0;
      hr = doc->get_Views(&dumbViews);
      BREAK_ON_FAILED_HRESULT(hr, L"get_Views failed.");
      views.Acquire(dumbViews);

      SmartInterface<View> view(0);
      View* dumbView = 0;
      hr = views->Item(1, &dumbView);
      BREAK_ON_FAILED_HRESULT(hr, L"Views::Item failed.");
      view.Acquire(dumbView);

      // navigate thru the scope node namespace to find the node
      // for the computer

      SmartInterface<ScopeNamespace> sn(0);
      ScopeNamespace* dumbSn = 0;
      hr = doc->get_ScopeNamespace(&dumbSn);
      BREAK_ON_FAILED_HRESULT(hr, L"get_ScopeNamespace failed.");
      sn.Acquire(dumbSn);

      SmartInterface<Node> rootnode(0);
      Node* dumbNode = 0;
      hr = sn->GetRoot(&dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetRoot failed.");
      rootnode.Acquire(dumbNode);

      SmartInterface<Node> child1(0);
      hr = sn->GetChild(rootnode, &dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetChild failed.");
      child1.Acquire(dumbNode);

      hr = view->put_ActiveScopeNode(child1);
      BREAK_ON_FAILED_HRESULT(hr, L"put_ActiveScopeNode failed.");

      // have to read back the child node we just put...

      hr = view->get_ActiveScopeNode(&dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetActiveScopeNode failed.");
      child1 = dumbNode;
      dumbNode->Release();
      dumbNode = 0;

      SmartInterface<Node> child2(0);
      hr = sn->GetChild(child1, &dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetChild failed.");
      child2.Acquire(dumbNode);

      hr = view->put_ActiveScopeNode(child2);
      BREAK_ON_FAILED_HRESULT(hr, L"put_ActiveScopeNode failed.");

      _variant_t missingParam3(DISP_E_PARAMNOTFOUND, VT_ERROR);
      hr =
         view->ExecuteScopeNodeMenuItem(
            AutoBstr(DNS_CONFIGE_WIZARD_MENU_ID),
            missingParam3);
      BREAK_ON_FAILED_HRESULT(
         hr,
         L"ExecuteScopeNodeMenuItem " DNS_CONFIGE_WIZARD_MENU_ID L" failed");
   }
   while (0);

   // don't save the console file.
   if (doc)
   {
      doc->Close(FALSE);
   }

   return hr;
}



int WINAPI
WinMain(
   HINSTANCE   hInstance, 
   HINSTANCE   /* hPrevInstance */ ,
   LPSTR       /* lpszCmdLine */ ,
   int         /* nCmdShow */ )
{
   hResourceModuleHandle = hInstance;

   int exitCode = static_cast<int>(doIt());

   return exitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\wrappers\dhcp\smartptr.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Smart (Interface) pointer class
// 
// copied from admin\burnslib\inc\smartptr.hpp



#ifndef SMARTPTR_HPP_INCLUDED
#define SMARTPTR_HPP_INCLUDED



// Requires that T derive from IUnknown

template <class T>
class SmartInterface
{
   public:

   // need default ctor if we are to use STL containers to hold SmartInterfaces

   SmartInterface() : ptr(0)
   {
   }



   explicit
   SmartInterface(T* p)
   {
      // don't assert(p), since construction w/ 0 is legal.

      ptr = p;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   SmartInterface(const SmartInterface<T>& s)
   {
      // makes no sense to pass null pointers

      ASSERT(s.ptr);
      ptr = s.ptr;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   ~SmartInterface()
   {
      Relinquish();
   }



   // Aquire means "take over from a dumb pointer, but don't AddRef it."

   void
   Acquire(T* p)
   {
      ASSERT(!ptr);
      ptr = p;
   }



   HRESULT
   AcquireViaQueryInterface(IUnknown& i)
   {
      return AcquireViaQueryInterface(i, __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaQueryInterface(IUnknown& i, const IID& interfaceDesired)
   {
      ASSERT(!ptr);
      HRESULT hr = 
         i.QueryInterface(interfaceDesired, reinterpret_cast<void**>(&ptr));

      // don't assert success, since we might just be testing to see
      // if an interface is available.

      return hr;
   }



   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext)
   {
      return
         AcquireViaCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext,
      const IID&     interfaceDesired)
   {
      ASSERT(!ptr);

      HRESULT hr =
         ::CoCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            interfaceDesired,
            reinterpret_cast<void**>(&ptr));
      ASSERT(SUCCEEDED(hr));

      return hr;
   }



   void
   Relinquish()
   {
      if (ptr)
      {
         ptr->Release();
         ptr = 0;
      }
   }
      


   operator T*() const
   {
      return ptr;
   }



   // this allows SmartInterface instances to be passed as the first
   // parameter to AquireViaQueryInterface.  Note that this is a conversion
   // to IUnknown&, not IUnknown*.  An operator IUnknown* would be ambiguous
   // with respect to operator T*.

   operator IUnknown&() const
   {
      ASSERT(ptr);
      return *(static_cast<IUnknown*>(ptr));
   }



// don't appear to need this: less is better.
//    T&
//    operator*()
//    {
//       ASSERT(ptr);
//       return *ptr;
//    }



   T*
   operator->() const
   {
      ASSERT(ptr);
      return ptr;
   }



   T*
   operator=(T* rhs)
   {
      ASSERT(rhs);

      if (ptr != rhs)
      {
         Relinquish();
         ptr = rhs;
         if (ptr)
         {
            ptr->AddRef();
         }
      }

      return ptr;
   }



   // This is required by some STL container classes.

   const SmartInterface<T>&
   operator=(const SmartInterface<T>& rhs)
   {
      this->operator=(rhs.ptr);
      return *this;   
   }



   private:

   T* ptr;
};



#endif   // SMARTPTR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\wrappers\dns\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        229
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1195
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\wrappers\dns\misc.hpp ===
// Copyright (c) 2000 Microsoft Corp.
//
// random other stuff



#ifndef MISC_HPP_INCLUDED
#define MISC_HPP_INCLUDED



void
logMessage(const wchar_t* msg)
{
   if (msg)
   {
      ::OutputDebugString(L"dnswiz: ");
      ::OutputDebugString(msg);
      ::OutputDebugString(L"\n");
   }
}



void
logHresult(HRESULT hr)
{                                                              
   wchar_t buf[1024];                                          
   wsprintf(buf, L"HRESULT = 0x%08X\n", (hr));                 
   logMessage(buf);                               
}                                                              



#ifdef DBG

#define LOG_HRESULT(hr)    logHresult(hr)
#define LOG_MESSAGE(msg)   logMessage(msg)

#else

#define LOG_HRESULT(hr)
#define LOG_MESSAGE(msg)

#endif DBG



#define BREAK_ON_FAILED_HRESULT(hr,msg)                           \
   if (FAILED(hr))                                                \
   {                                                              \
      LOG_MESSAGE(msg);                                           \
      LOG_HRESULT(hr);                                            \
      break;                                                      \
   }



// A BSTR wrapper that frees itself upon destruction.
//
// From Box, D. Essential COM.  pp 80-81.  Addison-Wesley. ISBN 0-201-63446-5

class AutoBstr
{
   public:

   explicit         
   AutoBstr(const wchar_t* s)
      :
      bstr(::SysAllocString(s))
   {
      ASSERT(s);
   }

   ~AutoBstr()
   {
      ::SysFreeString(bstr);
      bstr = 0;
   }

   operator BSTR () const
   {
      return bstr;
   }

   private:

   BSTR bstr;
};


#endif   // MISC_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\wrappers\rras\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        229
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1195
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\wrappers\rras\smartptr.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Smart (Interface) pointer class
// 
// copied from admin\burnslib\inc\smartptr.hpp



#ifndef SMARTPTR_HPP_INCLUDED
#define SMARTPTR_HPP_INCLUDED



// Requires that T derive from IUnknown

template <class T>
class SmartInterface
{
   public:

   // need default ctor if we are to use STL containers to hold SmartInterfaces

   SmartInterface() : ptr(0)
   {
   }



   explicit
   SmartInterface(T* p)
   {
      // don't assert(p), since construction w/ 0 is legal.

      ptr = p;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   SmartInterface(const SmartInterface<T>& s)
   {
      // makes no sense to pass null pointers

      ASSERT(s.ptr);
      ptr = s.ptr;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   ~SmartInterface()
   {
      Relinquish();
   }



   // Aquire means "take over from a dumb pointer, but don't AddRef it."

   void
   Acquire(T* p)
   {
      ASSERT(!ptr);
      ptr = p;
   }



   HRESULT
   AcquireViaQueryInterface(IUnknown& i)
   {
      return AcquireViaQueryInterface(i, __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaQueryInterface(IUnknown& i, const IID& interfaceDesired)
   {
      ASSERT(!ptr);
      HRESULT hr = 
         i.QueryInterface(interfaceDesired, reinterpret_cast<void**>(&ptr));

      // don't assert success, since we might just be testing to see
      // if an interface is available.

      return hr;
   }



   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext)
   {
      return
         AcquireViaCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext,
      const IID&     interfaceDesired)
   {
      ASSERT(!ptr);

      HRESULT hr =
         ::CoCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            interfaceDesired,
            reinterpret_cast<void**>(&ptr));
      ASSERT(SUCCEEDED(hr));

      return hr;
   }



   void
   Relinquish()
   {
      if (ptr)
      {
         ptr->Release();
         ptr = 0;
      }
   }
      


   operator T*() const
   {
      return ptr;
   }



   // this allows SmartInterface instances to be passed as the first
   // parameter to AquireViaQueryInterface.  Note that this is a conversion
   // to IUnknown&, not IUnknown*.  An operator IUnknown* would be ambiguous
   // with respect to operator T*.

   operator IUnknown&() const
   {
      ASSERT(ptr);
      return *(static_cast<IUnknown*>(ptr));
   }



// don't appear to need this: less is better.
//    T&
//    operator*()
//    {
//       ASSERT(ptr);
//       return *ptr;
//    }



   T*
   operator->() const
   {
      ASSERT(ptr);
      return ptr;
   }



   T*
   operator=(T* rhs)
   {
      ASSERT(rhs);

      if (ptr != rhs)
      {
         Relinquish();
         ptr = rhs;
         if (ptr)
         {
            ptr->AddRef();
         }
      }

      return ptr;
   }



   // This is required by some STL container classes.

   const SmartInterface<T>&
   operator=(const SmartInterface<T>& rhs)
   {
      this->operator=(rhs.ptr);
      return *this;   
   }



   private:

   T* ptr;
};



#endif   // SMARTPTR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\wrappers\dns\smartptr.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Smart (Interface) pointer class
// 
// copied from admin\burnslib\inc\smartptr.hpp



#ifndef SMARTPTR_HPP_INCLUDED
#define SMARTPTR_HPP_INCLUDED



// Requires that T derive from IUnknown

template <class T>
class SmartInterface
{
   public:

   // need default ctor if we are to use STL containers to hold SmartInterfaces

   SmartInterface() : ptr(0)
   {
   }



   explicit
   SmartInterface(T* p)
   {
      // don't assert(p), since construction w/ 0 is legal.

      ptr = p;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   SmartInterface(const SmartInterface<T>& s)
   {
      // makes no sense to pass null pointers

      ASSERT(s.ptr);
      ptr = s.ptr;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   ~SmartInterface()
   {
      Relinquish();
   }



   // Aquire means "take over from a dumb pointer, but don't AddRef it."

   void
   Acquire(T* p)
   {
      ASSERT(!ptr);
      ptr = p;
   }



   HRESULT
   AcquireViaQueryInterface(IUnknown& i)
   {
      return AcquireViaQueryInterface(i, __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaQueryInterface(IUnknown& i, const IID& interfaceDesired)
   {
      ASSERT(!ptr);
      HRESULT hr = 
         i.QueryInterface(interfaceDesired, reinterpret_cast<void**>(&ptr));

      // don't assert success, since we might just be testing to see
      // if an interface is available.

      return hr;
   }



   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext)
   {
      return
         AcquireViaCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext,
      const IID&     interfaceDesired)
   {
      ASSERT(!ptr);

      HRESULT hr =
         ::CoCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            interfaceDesired,
            reinterpret_cast<void**>(&ptr));
      ASSERT(SUCCEEDED(hr));

      return hr;
   }



   void
   Relinquish()
   {
      if (ptr)
      {
         ptr->Release();
         ptr = 0;
      }
   }
      


   operator T*() const
   {
      return ptr;
   }



   // this allows SmartInterface instances to be passed as the first
   // parameter to AquireViaQueryInterface.  Note that this is a conversion
   // to IUnknown&, not IUnknown*.  An operator IUnknown* would be ambiguous
   // with respect to operator T*.

   operator IUnknown&() const
   {
      ASSERT(ptr);
      return *(static_cast<IUnknown*>(ptr));
   }



// don't appear to need this: less is better.
//    T&
//    operator*()
//    {
//       ASSERT(ptr);
//       return *ptr;
//    }



   T*
   operator->() const
   {
      ASSERT(ptr);
      return ptr;
   }



   T*
   operator=(T* rhs)
   {
      ASSERT(rhs);

      if (ptr != rhs)
      {
         Relinquish();
         ptr = rhs;
         if (ptr)
         {
            ptr->AddRef();
         }
      }

      return ptr;
   }



   // This is required by some STL container classes.

   const SmartInterface<T>&
   operator=(const SmartInterface<T>& rhs)
   {
      this->operator=(rhs.ptr);
      return *this;   
   }



   private:

   T* ptr;
};



#endif   // SMARTPTR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\make.inc ===
TESTDB_IDT=$(MSI_DATA_DIR)\testdb.idt
TESTCAB_IDT=$(MSI_DATA_DIR)\testcab.idt
TESTCAB_SRC=$(MSI_DATA_DIR)\testcab
TMPLDB_IDT=$(MSI_DATA_DIR)\template.idt
SIMPLE_IDT=$(MSI_DATA_DIR)\simple.idt
SCHEMA_MSM_IDT=$(MSI_DATA_DIR)\schemaMsm.idt
UISAMPLE_IDT=$(MSI_DATA_DIR)\uisample.idt
SEQUENCE_IDT=$(MSI_DATA_DIR)\sequence.idt
MINIMUM_IDT=$(MSI_DATA_DIR)\minimum.idt
MSISDK_IDT=$(MSI_DATA_DIR)\sdk.idt
TESTDB_IDT_BINARY=$(TESTDB_IDT)\Binary
WSHTOOLS=$(MSI_DIR)\src\msitools\scripts

BIN_DIR=$(MSI_DIR)\bin\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\wrappers\rras\misc.hpp ===
// Copyright (c) 2000 Microsoft Corp.
//
// random other stuff



#ifndef MISC_HPP_INCLUDED
#define MISC_HPP_INCLUDED



void
logMessage(const wchar_t* msg)
{
   if (msg)
   {
      ::OutputDebugString(L"rraswiz: ");
      ::OutputDebugString(msg);
      ::OutputDebugString(L"\n");
   }
}



void
logHresult(HRESULT hr)
{                                                              
   wchar_t buf[1024];                                          
   wsprintf(buf, L"HRESULT = 0x%08X\n", (hr));                 
   logMessage(buf);                               
}                                                              



#ifdef DBG

#define LOG_HRESULT(hr)    logHresult(hr)
#define LOG_MESSAGE(msg)   logMessage(msg)

#else

#define LOG_HRESULT(hr)
#define LOG_MESSAGE(msg)

#endif DBG



#define BREAK_ON_FAILED_HRESULT(hr,msg)                           \
   if (FAILED(hr))                                                \
   {                                                              \
      LOG_MESSAGE(msg);                                           \
      LOG_HRESULT(hr);                                            \
      break;                                                      \
   }



// A BSTR wrapper that frees itself upon destruction.
//
// From Box, D. Essential COM.  pp 80-81.  Addison-Wesley. ISBN 0-201-63446-5

class AutoBstr
{
   public:

   explicit         
   AutoBstr(const wchar_t* s)
      :
      bstr(::SysAllocString(s))
   {
      ASSERT(s);
   }

   ~AutoBstr()
   {
      ::SysFreeString(bstr);
      bstr = 0;
   }

   operator BSTR () const
   {
      return bstr;
   }

   private:

   BSTR bstr;
};


#endif   // MISC_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\wrappers\rras\rraswiz.cpp ===
// Copyright (c) 2000 Microsoft Corp.
//
// launches dns wizard from the dhcp snapin using mmc automation



#include "headers.hxx"
#include "resource.h"
#include "smartptr.hpp"
#include "misc.hpp"



HINSTANCE hResourceModuleHandle = 0;



HRESULT
getContextMenu(const SmartInterface<View>& view, ContextMenu** dumbMenu)
{
   HRESULT hr = S_OK;

   _variant_t missingParam2(DISP_E_PARAMNOTFOUND, VT_ERROR);
   hr = view->get_ScopeNodeContextMenu(missingParam2, dumbMenu);

   return hr;
}



inline
void
SafeStrncat(wchar_t* dest, const wchar_t* src, size_t bufmax)
{
   ASSERT(dest && src);

   if (dest && src)
   {
      wcsncat(dest, src, bufmax - wcslen(dest) - 1);
   }
}



HRESULT
doIt(bool install = true)
{
   HRESULT hr = S_OK;

   do
   {
      hr = ::CoInitialize(0);
      BREAK_ON_FAILED_HRESULT(hr, L"CoInitialize failed.");

      SmartInterface<_Application> app(0);
      hr =
         app.AcquireViaCreateInstance(
            CLSID_Application,
            0,

            // we expect the object is out-of-proc, local server, but
            // we really don't care, so we'll take any implementation
            // available.

            CLSCTX_ALL);
      BREAK_ON_FAILED_HRESULT(hr, L"CoCreateInstance failed.");

      wchar_t buf[MAX_PATH + 1];
      memset(buf, 0, (MAX_PATH + 1) * sizeof(wchar_t));

      UINT result = ::GetSystemDirectory(buf, MAX_PATH);
      ASSERT(result != 0 && result <= MAX_PATH);

      wchar_t mscPath[MAX_PATH + 1] = L"";
      SafeStrncat(mscPath, buf, MAX_PATH);
      SafeStrncat(mscPath, L"\\rrasmgmt.msc", MAX_PATH);

      hr = app->Load(AutoBstr(mscPath));
      BREAK_ON_FAILED_HRESULT(hr, L"Load failed.");

      SmartInterface<Document> doc(0);
      Document* dumbDoc = 0;
      hr = app->get_Document(&dumbDoc);
      BREAK_ON_FAILED_HRESULT(hr, L"get_Document failed.");
      doc.Acquire(dumbDoc);

      SmartInterface<Views> views(0);
      Views* dumbViews = 0;
      hr = doc->get_Views(&dumbViews);
      BREAK_ON_FAILED_HRESULT(hr, L"get_Views failed.");
      views.Acquire(dumbViews);

      SmartInterface<View> view(0);
      View* dumbView = 0;
      hr = views->Item(1, &dumbView);
      BREAK_ON_FAILED_HRESULT(hr, L"Views::Item failed.");
      view.Acquire(dumbView);

      SmartInterface<ScopeNamespace> sn(0);
      ScopeNamespace* dumbSn = 0;
      hr = doc->get_ScopeNamespace(&dumbSn);
      BREAK_ON_FAILED_HRESULT(hr, L"get_ScopeNamespace failed.");
      sn.Acquire(dumbSn);

      SmartInterface<Node> rootnode(0);
      Node* dumbNode = 0;
      hr = sn->GetRoot(&dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetRoot failed.");
      rootnode.Acquire(dumbNode);

      SmartInterface<Node> child1(0);
      hr = sn->GetChild(rootnode, &dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetChild failed.");
      child1.Acquire(dumbNode);

      hr = view->put_ActiveScopeNode(child1);
      BREAK_ON_FAILED_HRESULT(hr, L"put_ActiveScopeNode failed.");

      // have to read back the child node we just put...

      hr = view->get_ActiveScopeNode(&dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetActiveScopeNode failed.");
      child1 = dumbNode;
      dumbNode->Release();
      dumbNode = 0;

      SmartInterface<Node> child2(0);
      hr = sn->GetChild(child1, &dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetChild failed.");
      child2.Acquire(dumbNode);

      hr = view->put_ActiveScopeNode(child2);
      BREAK_ON_FAILED_HRESULT(hr, L"put_ActiveScopeNode failed.");

      // have to read back the child node we just put...

      hr = view->get_ActiveScopeNode(&dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetActiveScopeNode failed.");
      child2 = dumbNode;
      dumbNode->Release();
      dumbNode = 0;

      SmartInterface<Node> next(0);
      hr = sn->GetNext(child2, &dumbNode);
      BREAK_ON_FAILED_HRESULT(hr, L"GetNext failed.");
      next.Acquire(dumbNode);

      hr = view->put_ActiveScopeNode(next);
      BREAK_ON_FAILED_HRESULT(hr, L"put_ActiveScopeNode failed.");

      // excute configure server wizard menu item
      _variant_t missingParam2(DISP_E_PARAMNOTFOUND, VT_ERROR);

      if (install)
      {
         hr = view->ExecuteScopeNodeMenuItem((BSTR)AutoBstr(L"_CONFIGURE_RRAS_WIZARD_"), missingParam2);
         BREAK_ON_FAILED_HRESULT(hr, L"ExecuteScopeNodeMenuItem FIGURE_RRAS_WIZARD_ failed");
      }
      else
      {
         hr = view->ExecuteScopeNodeMenuItem((BSTR)AutoBstr(L"_DISABLE_RRAS_"), missingParam2);
         BREAK_ON_FAILED_HRESULT(hr, L"ExecuteScopeNodeMenuItem FIGURE_RRAS_WIZARD_ failed");
      }

      hr = doc->Close(FALSE);
      BREAK_ON_FAILED_HRESULT(hr, L"Close failed.");
   }
   while (0);

   return hr;
}



int WINAPI
WinMain(
   HINSTANCE   hInstance, 
   HINSTANCE   /* hPrevInstance */ ,
   LPSTR       /*lpszCmdLine*/,
   int         /* nCmdShow */ )
{
   hResourceModuleHandle = hInstance;

   bool install = true;

   int numArgs = 0;
   PWSTR* argv = CommandLineToArgvW(GetCommandLineW(), &numArgs);
   if (argv &&
       numArgs > 1)
   {
      for (int index = 0; index < numArgs; ++index)
      {
         if (argv[index] &&
             _wcsicmp(argv[index], L"/u") == 0)
         {
            install = false;
         }
      }

      GlobalFree(argv);
   }

   int exitCode = static_cast<int>(doIt(install));

   return exitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\basebld\makefile.inc ===
!include ..\make.inc

ALT_PROJECT_TARGET=instmsi\msitools

BaseAll: \
        $(BUILD_PACKAGEDIR)\simple.msi \
	$(BUILD_PACKAGEDIR)\testcab.msi \
	$(BUILD_PACKAGEDIR)\sequence.msi \
	$(BUILD_PACKAGEDIR)\minimum.msi \
	$(BUILD_PACKAGEDIR)\schema.msi \
        $(BUILD_PACKAGEDIR)\schema.msm

        
#-------------------------------------------------------------------------------
$(BUILD_PACKAGEDIR):
	md $(BUILD_PACKAGEDIR)
        
$(O)\error.idt: $(MSI_INTLDATA_DIR)\error.enu
	copy $(MSI_INTLDATA_DIR)\error.enu $(O)\error.idt
        
$(O)\actionte.idt: $(MSI_INTLDATA_DIR)\actionte.enu
        copy $(MSI_INTLDATA_DIR)\actionte.enu $(O)\actionte.idt


#-------------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\template.msi: $(BUILD_PACKAGEDIR)\schema.msi $(TMPLDB_IDT)\*.idt $(O)\error.idt $(O)\actionte.idt
	msidb.exe -i -f$(TMPLDB_IDT) -m$(BUILD_PACKAGEDIR)\schema.msi -c -d$@ *.idt
	msidb.exe -f$(MSI_DATA_DIR)\basebld\$(O) -i -d$@ error.idt actionte.idt


#-------------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\schema.msi: $(BUILD_PACKAGEDIR) $(SCHEMA_IDT)\*.idt
	msidb.exe -f$(SCHEMA_IDT) -c -d$@ *.idt

$(BUILD_PACKAGEDIR)\schema.msm: $(SCHEMA_MSM_IDT)\*.idt
	msidb.exe -f$(SCHEMA_MSM_IDT) -c -d$@ *.idt


#-------------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\simple.msi: $(SIMPLE_IDT)\*.idt $(O)\error.idt $(O)\actionte.idt
	msidb.exe -f$(SIMPLE_IDT) -c -d$@ *.idt
	msidb.exe -f$(TMPLDB_IDT) -i -d$@ binary.idt
	msidb.exe -f$(SCHEMA_IDT) -i -d$@ listbox.idt
	msidb.exe -f$(MSI_DATA_DIR)\basebld\$(O) -i -d$@ error.idt actionte.idt


#-----------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\testcab.msi: $(BUILD_PACKAGEDIR)\template.msi $(TESTCAB_IDT)\*.idt $(O)\error.idt
	msidb.exe -i -f$(TESTCAB_IDT) -m$(BUILD_PACKAGEDIR)\template.msi -c -d$@ *.idt
	msidb.exe -f$(MSI_DATA_DIR)\basebld\$(O) -i -d$@ error.idt
	msidb.exe -i -f$(TESTCAB_IDT)\validate -d$@ _validat.idt
	msidb.exe -d$@ -a$(TESTCAB_SRC)\msproj1.cab
	copy $(TESTCAB_SRC)\*.* $(BUILD_PACKAGEDIR)

#-----------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\sequence.msi: $(SEQUENCE_IDT)\*.idt
	msidb.exe -i -f$(SEQUENCE_IDT) -c -d$@ *.idt


#-----------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\minimum.msi: $(MINIMUM_IDT)\*.idt $(O)\error.idt $(SCHEMA_IDT)\_validat.idt
	msidb.exe -f$(MINIMUM_IDT) -c -d$@ *.idt
	msidb.exe -f$(SCHEMA_IDT) -i -d$@ _validat.idt
	msidb.exe -f$(MSI_DATA_DIR)\basebld\$(O) -i -d$@ error.idt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\evalmsm.idt\makefile.inc ===
EVALMSM_IDT=$(MSI_DATA_DIR)\evalmsm.idt\$(TARGET_DIRECTORY)

EvalcomMSM: \
	$(BUILD_PACKAGEDIR)\evalcom.msm \
	$(O)\evalcab.ddf

#-----------------------------------------------------------------------------

$(O)\evalcab.ddf: $(EVALMSM_IDT)\cab.ddf
        copy /y $(EVALMSM_IDT)\cab.ddf $@

#-----------------------------------------------------------------------------

$(O)\evalsig.idt: $(EVALMSM_IDT)\modulesi.tpl
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc $(EVALMSM_IDT)\modulesi.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@

#-----------------------------------------------------------------------------

$(BUILD_PACKAGEDIR)\evalcom.tmp: $(EVALMSM_IDT)\*.idt $(O)\evalsig.idt
	msidb.exe -i -c -f$(EVALMSM_IDT) -d$@ *.idt
	msidb.exe -i -f$(MSI_DATA_DIR)\evalmsm.idt\$(O) -d$@ evalsig.idt

#-----------------------------------------------------------------------------

$(BUILD_PACKAGEDIR)\evalcom.msm: $(BUILD_PACKAGEDIR)\evalcom.tmp $(EVALMSM_IDT)\external\*.idt
	copy /y $(BUILD_PACKAGEDIR)\evalcom.tmp $@
	msidb.exe -i -f$(EVALMSM_IDT)\external -d$@ *.idt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\appcompat\makefile.inc ===
ALT_PROJECT_TARGET=MsiShims
!if $(FREEBUILD)
MSI_APPCOMPAT_DIR=fre
!else
MSI_APPCOMPAT_DIR=chk
!endif
MSI_APPCOMPAT_COMMON_DIR=common
MSI_APPCOMPAT_FILES=\
    $(O)\msimain.sdb \
    $(O)\sdbapi.dll \
    $(O)\sdbapiu.dll

AppCompat: preprocess $(MSI_APPCOMPAT_FILES)
!if "$(PASS0ONLY)"==""
    @del /F /Q $(O)\* > nul
!endif

preprocess:
!if "$(PASS0ONLY)"=="1"
    @touch /F $(MSI_APPCOMPAT_DIR)\* > nul
    @touch /F $(MSI_APPCOMPAT_COMMON_DIR)\* > nul
    @copy /Y $(MSI_APPCOMPAT_DIR)\*.pdb $(O) > nul
!endif

$(O)\msimain.sdb: $(MSI_APPCOMPAT_COMMON_DIR)\$(@F)
    @copy /Y $(MSI_APPCOMPAT_COMMON_DIR)\$(@F) $(O) > nul
    $(BINPLACE_CMD)

$(O)\sdbapi.dll: $(MSI_APPCOMPAT_DIR)\$(@F)
    @copy /Y $(MSI_APPCOMPAT_DIR)\$(@F) $(O) > nul
    $(BINPLACE_CMD)

$(O)\sdbapiu.dll: $(MSI_APPCOMPAT_DIR)\$(@F)
    @copy /Y $(MSI_APPCOMPAT_DIR)\$(@F) $(O) > nul
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\instmsi\sources.inc ===
!INCLUDE ..\..\..\Src\MsiMake.inc
TARGETNAME=
TARGETTYPE=DYNLINK

!ifndef MAKEDLL
NTTARGETFILE0=InstMsi
!endif

SOURCES=
BINPLACE_PLACEFILE=..\placefil.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\instmsi\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\mergemsm.idt\makefile.inc ===
MMMSM_IDT=$(MSI_DATA_DIR)\mergemsm.idt\$(TARGET_DIRECTORY)

MergeModMSM: \
	$(BUILD_PACKAGEDIR)\mergemod.msm \
	$(O)\mergecab.ddf

#-----------------------------------------------------------------------------


$(O)\mergecab.ddf: $(MMMSM_IDT)\cab.ddf
        copy /y $(MMMSM_IDT)\cab.ddf $@

#-----------------------------------------------------------------------------

$(O)\mmsig.idt: $(MMMSM_IDT)\modulesi.tpl $(SDK_INC_PATH)\ntverp.h
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc$(MMMSM_IDT)\modulesi.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@

$(BUILD_PACKAGEDIR)\mergemod.tmp: $(MMMSM_IDT)\*.idt $(O)\mmsig.idt
	msidb.exe -i -c -f$(MMMSM_IDT) -d$@ *.idt
	msidb.exe -i -f$(MSI_DATA_DIR)\mergemsm.idt\$(O) -d$@ mmsig.idt

$(BUILD_PACKAGEDIR)\mergemod.msm: $(BUILD_PACKAGEDIR)\mergemod.tmp $(MMMSM_IDT)\external\*.idt
        copy /y $(BUILD_PACKAGEDIR)\mergemod.tmp $@
	msidb.exe -i -f$(MMMSM_IDT)\external -d$@ *.idt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\instmsi\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\instmsi\make.inc ===
!include ..\..\..\src\makever.inc

BIN_DIR=$(MSI_DIR)\bin\$(TARGET_DIRECTORY)
INSTMSI_DIR=$(MSI_DIR)\data\instmsi
IDT_DIR=$(INSTMSI_DIR)\$(MSI_SUBDIR)\$(O)


MSI_ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)

!if "$(MSI_BUILD_UNICODE)"=="1"
# the double slashes are needed to let SED do its trick without mis-interpreting the slashes as escaped characters
MSI_ALT_TARGET=
ALT_PROJECT_TARGET=InstMsi\unicode
!else
# the double slashes are needed to let SED do its trick without mis-interpreting the slashes as escaped characters
MSI_ALT_TARGET=\msiwin9x
ALT_PROJECT_TARGET=InstMsi\ansi
!endif

MSI_BASE_TREE=_NTPOSTBLD\$(MSI_ALT_TARGET)
MSI_REGSIP_DIR=$(MSI_ALT_TARGET)\.

MAKEFILE=..\make.inc

!if $(FREEBUILD)
VERSION=SHIP
!else
VERSION=DEBUG
!endif

InstMsi: $(MAKEFILE) $(O)\InstMsi.sed exception support $(O)\instmsi.mak $(O)\binary.idt  $(O)\instmsi.msi 
exception: $(O)\msi.cdf $(O)\msi.inf $(O)\mspatcha.cdf $(O)\mspatcha.inf
support: $(O)\cabinet.dll $(O)\imagehlp.dll $(O)\mspatcha.dll $(O)\riched20.dll $(O)\usp10.dll $(O)\msls31.dll $(O)\shfolder.dll $(O)\jdate2.exe

$(O)\instmsi.mak: $(INSTMSI_DIR)\$(@F)
	echo <<$@ >>NUL
MSI_BUILD_NUMBER=$(MSIRMJ).$(MSIRMM).$(MSIRUP).$(MSIRIN)
TARGET=$(ALT_PROJECT_TARGET)
REGSIP_DIR=$(MSI_REGSIP_DIR)
MSI_ALT_TARGET=$(MSI_ALT_TARGET)
MSI_BUILD_UNICODE=$(MSI_BUILD_UNICODE)
<<KEEP
	type $(INSTMSI_DIR)\$(@F) >> $@
	$(BINPLACE_CMD)

#UNICODE only support files
$(O)\msi.cdf $(O)\msi.inf : $(INSTMSI_DIR)\msi.cdf $(INSTMSI_DIR)\msi.inf
!if "$(MSI_BUILD_UNICODE)"=="1"
	copy $(INSTMSI_DIR)\$(@F) $@
	$(BINPLACE_CMD)
!endif

$(O)\mspatcha.cdf $(O)\mspatcha.inf : $(INSTMSI_DIR)\mspatcha.cdf $(INSTMSI_DIR)\mspatcha.inf
!if "$(MSI_BUILD_UNICODE)"=="1"
	copy $(INSTMSI_DIR)\$(@F) $@
	$(BINPLACE_CMD)
!endif

$(O)\binary.idt : $(INSTMSI_DIR)\binary.idt
	copy $(INSTMSI_DIR)\$(@F) $@
	$(BINPLACE_CMD)

$(O)\cabinet.dll $(O)\mspatcha.dll $(O)\usp10.dll $(O)\msls31.dll $(O)\shfolder.dll $(O)\riched20.dll:
	copy $(BIN_DIR)\$(@F) $@
	copy $(BIN_DIR)\$(@B).pdb $(O)\$(@B).pdb
	$(BINPLACE_CMD)

$(O)\imagehlp.dll:
	copy $(BIN_DIR)\$(@F) $@
	copy $(BIN_DIR)\imagehlp.pdb $(O)\$(@B).pdb
	$(BINPLACE_CMD)

$(O)\copymsi.msi: $(MAKEFILE) $(MSI_DATA_DIR)\msimsi\*.idt ..\intl\inst*.msi ..\instmsi.pl $(MSI_INTLDATA_DIR)\error.enu $(MSI_INTLDATA_DIR)\actionte.enu
	msidb.exe -c -f$(MSI_DATA_DIR)\msimsi -d$@ *.idt
!if "$(MSI_BUILD_UNICODE)"=="1"
	msidb.exe -f$(MSI_DATA_DIR)\msimsi\unicode -i -d$@ *.idt
!else
	msidb.exe -f$(MSI_DATA_DIR)\msimsi\ansi -i -d$@ *.idt
!endif
	copy $(MSI_INTLDATA_DIR)\error.enu $(O)\error.idt
	copy $(MSI_INTLDATA_DIR)\actionte.enu $(O)\actionte.idt
	msidb.exe -f$(IDT_DIR) -i -d$@ error.idt actionte.idt
	copy $@ $(O)\inst1033.msi  
	perl ..\instmsi.pl $@ Alpha,Intel ..\intl $(O)

$(O)\instmsi.msi: $(O)\copymsi.msi
	copy $(O)\copymsi.msi $@
	$(BINPLACE_CMD)

$(O)\jdate2.exe:
	copy $(INSTMSI_DIR)\jdate2.exe $@
	$(BINPLACE_CMD)

$(O)\InstMsi1.sed : $(MAKEFILE)
	echo <<$(O)\InstMsi1.sed >>NUL
[Version]
Class=IEXPRESS
SEDVersion=3
[SourceFiles]
MsiSourceFiles=$(MSI_BASE_TREE)
CommonFiles=_NTPOSTBLD
MsiSourceFilesDump=$(MSI_BASE_TREE)\msi_bins
InstmsiSourceFiles=_NTPOSTBLD\$(ALT_PROJECT_TARGET)
InstmsiSourceFilesDump=_NTPOSTBLD\$(ALT_PROJECT_TARGET)\msi_bins
ShimDllSourceFiles=_NTPOSTBLD\idw

<<KEEP

$(O)\InstMsi2.sed : $(MAKEFILE) 
	echo <<$(O)\InstMsi2.sed >>NUL
[Options]
CheckAdminRights=0
PackagePurpose=InstallApp
ShowInstallProgramWindow=0
HideExtractAnimation=1
UseLongFileName=0
InsideCompressed=0
CAB_FixedSize=0
CAB_ResvCodeSigning=0
RebootMode=N
InstallPrompt=
DisplayLicense=
PostInstallCmd=<None>
SourceFiles=SourceFiles
VersionInfo=VersionSection
AlwaysPropogateCmdExitCode=1
<<KEEP

$(O)\instmsi3.sed : $(MAKEFILE)
	echo <<$(O)\InstMsi3.sed >>NUL
[MsiSourceFiles]
!if "$(MSI_BUILD_UNICODE)"=="0"
msi.dll=
!endif
msiexec.exe=
msihnd.dll=
msisip.dll=

[CommonFiles]
msimsg.dll=
msimain.sdb=

[MsiSourceFilesDump]
msiinst.exe=

[InstmsiSourceFiles]
!if "$(MSI_BUILD_UNICODE)"=="1"
msi.dll=
msi.cat=
msi.inf=
mspatcha.inf=
mspatcha.cat=
!endif
riched20.dll=
usp10.dll=
msls31.dll=
shfolder.dll=
instmsi.msi=
imagehlp.dll=

[InstmsiSourceFilesDump]
cabinet.dll=
mspatcha.dll=

[ShimDllSourceFiles]
!if "$(MSI_BUILD_UNICODE)"=="0"
sdbapi.dll=
!else
sdbapiU.dll=
!endif

[VersionSection]
FromFile=msiexec.exe
OriginalFilename=Msi.dll,MsiHnd.dll,MsiExec.exe
InternalName=InstMsi.exe
FileDescription=Installer for the Windows Installer
#These come msiexec.exe now.
LegalCopyright=Copyright (c) Microsoft Corp. 2000
!if "$(MSI_BUILD_UNICODE)"=="1"
ProductName=Windows Installer - Unicode
!else
ProductName=Windows Installer
!endif
!if $(FREEBUILD)
FileFlags=0
!else
FileFlags=1
!endif
ProductVersion=$(MSIRMJ).$(MSIRMM).$(MSIRUP).$(MSIRIN)
FileVersion=$(MSIRMJ).$(MSIRMM).$(MSIRUP).$(MSIRIN)
<<KEEP

$(O)\instmsi.sed: $(O)\instmsi1.sed $(O)\instmsi2.sed $(O)\instmsi3.sed
	type $(O)\instmsi1.sed > $@
	type $(O)\instmsi3.sed >> $@
	type $(O)\instmsi2.sed >>$@
	echo FriendlyName=Installation of System Software Installer $(VERSION) >>$@
	echo TargetName=_NTPOSTBLD\$(ALT_PROJECT_TARGET)\InstMsi.exe >>$@
	echo AdminQuietInstCmd=msiinst.exe /i instmsi.msi REBOOT=REALLYSUPRESS MSIEXECREG=1 /m /q >>$@
	echo UserQuietInstCmd=msiinst.exe /i instmsi.msi REBOOT=REALLYSUPRESS MSIEXECREG=1 /m /q >>$@
	echo AppLaunched=msiinst.exe /i instmsi.msi MSIEXECREG=1 /m /qb+! >>$@
	$(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\msival2.idt\makefile.inc ===
!include ..\make.inc

MSIVAL2_IDT=$(MSI_DATA_DIR)\msival2.idt
MSIVAL2_PLATFORM_IDT=$(MSIVAL2_IDT)\$(TARGET_DIRECTORY)
EVALMSM_IDT=$(MSI_DATA_DIR)\evalmsm.idt\$(TARGET_DIRECTORY)

MsiVal2Msi: \
	$(BUILD_PACKAGEDIR)\msival2.msi \
	$(O)\msivlcab.ddf


$(O)\msivlcab.ddf: $(MSIVAL2_PLATFORM_IDT)\cab.ddf
	copy /y $(MSIVAL2_PLATFORM_IDT)\cab.ddf $@

#-----------------------------------------------------------------------------

$(O)\evalcom.msm: $(EVALMSM_IDT)\internal\*.idt $(BUILD_PACKAGEDIR)\evalcom.msm
	copy /y $(BUILD_PACKAGEDIR)\evalcom.msm $@
	msidb.exe -i -f$(EVALMSM_IDT)\internal -d$@ *.idt

#-----------------------------------------------------------------------------

$(O)\val2prop.idt: $(SDK_INC_PATH)\ntverp.h $(MSIVAL2_PLATFORM_IDT)\property.tpl
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc $(MSIVAL2_PLATFORM_IDT)\property.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@

$(O)\val2upgr.idt: $(SDK_INC_PATH)\ntverp.h $(MSIVAL2_PLATFORM_IDT)\upgrade.tpl
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc $(MSIVAL2_PLATFORM_IDT)\upgrade.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@


#-----------------------------------------------------------------------------

$(BUILD_PACKAGEDIR)\msival2.msi: $(BUILD_PACKAGEDIR)\uisample.msi $(O)\evalcom.msm  \
		$(MSIVAL2_IDT)\*.idt $(MSIVAL2_PLATFORM_IDT)\*.idt $(O)\val2prop.idt \
		$(O)\val2upgr.idt
 	msidb.exe -i -c -f$(MSIVAL2_IDT) -d$@ *.idt
	msidb.exe -i -f$(MSIVAL2_PLATFORM_IDT) -d$@ *.idt
	msidb.exe -i -f$(MSI_DATA_DIR)\msival2.idt\$(O) -d $@ val2prop.idt
	msidb.exe -i -f$(MSI_DATA_DIR)\msival2.idt\$(O) -d $@ val2upgr.idt
	msidb.exe -m$(BUILD_PACKAGEDIR)\uisample.msi -d$@
	msidb.exe -m$(O)\evalcom.msm -d$@
	msitran.exe -a $(MSIVAL2_IDT)\addlegal.mst $@
	CScript $(WSHTOOLS)\wisuminf.vbs $@ 11=Date 12=Date
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "UPDATE `Property` SET `Value`=0 WHERE `Property`='ShowUserRegistrationDlg'"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\msispy.idt\makefile.inc ===
SCHEMA_MSM_IDT=$(MSI_DATA_DIR)\schemaMsm.idt
SPYMSI_IDT=$(MSI_DATA_DIR)\msispy.idt
SPYMSI_PLATFORM_IDT=$(SPYMSI_IDT)\$(TARGET_DIRECTORY)

SpyMsi: \
	$(BUILD_PACKAGEDIR)\msispy.msi \
	$(O)\spycab.ddf

#-----------------------------------------------------------------------------

$(O)\spyprop.idt: $(SPYMSI_PLATFORM_IDT)\property.tpl $(SDK_INC_PATH)\ntverp.h
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc $(SPYMSI_PLATFORM_IDT)\property.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@

$(O)\spyupgr.idt: $(SPYMSI_PLATFORM_IDT)\upgrade.tpl $(SDK_INC_PATH)\ntverp.h
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc $(SPYMSI_PLATFORM_IDT)\upgrade.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@

#-----------------------------------------------------------------------------

$(BUILD_PACKAGEDIR)\msispy.msi: $(BUILD_PACKAGEDIR)\uisample.msi $(SPYMSI_IDT)\*.idt \
		$(SPYMSI_IDT)\addlegal.mst $(O)\spyprop.idt $(SPYMSI_PLATFORM_IDT)\*.idt \
		$(O)\spyupgr.idt
	msidb.exe -d$@ -c -f$(SPYMSI_PLATFORM_IDT) -i *.idt
	msidb.exe -d$@ -f$(SPYMSI_IDT)\$(O) -i spyprop.idt
	msidb.exe -d$@ -f$(SPYMSI_IDT)\$(O) -i spyupgr.idt
	msidb.exe -d$@ -f$(SPYMSI_IDT) -i *.idt
	msidb.exe -d$@ -m $(BUILD_PACKAGEDIR)\uisample.msi 
	msitran.exe -a $(SPYMSI_IDT)\addlegal.mst $@

#-----------------------------------------------------------------------------

$(O)\spycab.ddf: $(SPYMSI_PLATFORM_IDT)\spycab.ddf
	copy /Y $(SPYMSI_PLATFORM_IDT)\spycab.ddf $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\orca.idt\makefile.inc ===
!include ..\make.inc

SCHEMA_MSM_IDT=$(MSI_DATA_DIR)\schemaMsm.idt

MMMSM_IDT=$(MSI_DATA_DIR)\mergemsm.idt\$(TARGET_DIRECTORY)
EVALMSM_IDT=$(MSI_DATA_DIR)\evalmsm.idt\$(TARGET_DIRECTORY)

ORCA_IDT=$(MSI_DATA_DIR)\orca.idt
ORCA_PLATFORM_IDT=$(ORCA_IDT)\$(TARGET_DIRECTORY)
ORCA_IDT_ICON=$(ORCA_IDT)\icon


OrcaMsi: $(BUILD_PACKAGEDIR)\orca.msi \
	 $(BUILD_PACKAGEDIR)\orca.dat \
	 $(O)\orcacab.ddf

#-----------------------------------------------------------------------------

$(O)\evalcom.msm: $(EVALMSM_IDT)\internal\*.idt $(BUILD_PACKAGEDIR)\evalcom.tmp
	copy /y $(BUILD_PACKAGEDIR)\evalcom.tmp $@
	msidb.exe -i -f$(EVALMSM_IDT)\internal -d$@ *.idt

#-----------------------------------------------------------------------------

$(O)\mergemod.msm: $(MMMSM_IDT)\internal\*.idt $(BUILD_PACKAGEDIR)\mergemod.tmp
	copy /y $(BUILD_PACKAGEDIR)\mergemod.tmp $@
	msidb.exe -i -f$(MMMSM_IDT)\internal -d$@ *.idt

#-----------------------------------------------------------------------------

$(BUILD_PACKAGEDIR)\orca.dat: $(SCHEMA_IDT)\*.idt $(SCHEMA_MSM_IDT)\*.idt
	msidb.exe -c -i -f$(SCHEMA_IDT) -d$@ *.idt
	msidb.exe -c -i -f$(SCHEMA_IDT) -d$(O)\schema.msm *.idt
	msidb.exe -m $(O)\schema.msm -d $@

#-----------------------------------------------------------------------------

$(O)\orcacab.ddf: $(ORCA_PLATFORM_IDT)\cab.ddf
	copy /y $(ORCA_PLATFORM_IDT)\cab.ddf $@

#-----------------------------------------------------------------------------

$(O)\orcaprop.idt: $(ORCA_PLATFORM_IDT)\property.tpl $(SDK_INC_PATH)\ntverp.h
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc $(ORCA_PLATFORM_IDT)\property.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@

$(O)\orcaupgr.idt: $(ORCA_PLATFORM_IDT)\upgrade.tpl $(SDK_INC_PATH)\ntverp.h
	$(C_PREPROCESSOR_NAME) -I $(SDK_INC_PATH) /EP /Tc $(ORCA_PLATFORM_IDT)\upgrade.tpl | perl $(MSI_DATA_DIR)\idtproc.pl > $@

#-----------------------------------------------------------------------------

$(BUILD_PACKAGEDIR)\orca.msi: $(BUILD_PACKAGEDIR)\uisample.msi $(O)\mergemod.msm $(O)\evalcom.msm \
		$(ORCA_IDT)\*.idt $(ORCA_PLATFORM_IDT)\*.idt $(ORCA_IDT_ICON)\*.* $(O)\orcaprop.idt \
		$(O)\orcaupgr.idt
 	msidb.exe -i -c -f$(ORCA_IDT) -d$@ *.idt
	msidb.exe -i -f$(ORCA_PLATFORM_IDT) -d$@ *.idt
	msidb.exe -i -f$(MSI_DATA_DIR)\orca.idt\$(O) -d $@ orcaprop.idt
	msidb.exe -i -f$(MSI_DATA_DIR)\orca.idt\$(O) -d $@ orcaupgr.idt
	msidb.exe -m $(BUILD_PACKAGEDIR)\uisample.msi -d$@
	msidb.exe -m $(O)\evalcom.msm -d$@
	msidb.exe -m $(O)\mergemod.msm -d$@
	msitran.exe -a $(ORCA_IDT)\addlegal.mst $@
	CScript $(WSHTOOLS)\wisuminf.vbs $@ 11=Date 12=Date
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "UPDATE `Property` SET `Value`=0 WHERE `Property`='ShowUserRegistrationDlg'"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\sdk\layout.inc ===
# --------- DO NOT EDIT THIS FILE ------------ DO NOT EDIT THIS FILE ---------
# --------- DO NOT EDIT --- see layout.txt --- DO NOT EDIT -------------------
# --------- DO NOT EDIT THIS FILE ------------ DO NOT EDIT THIS FILE ---------
$(O)\sdkmake.inc : sdkmake.inc
	copy $** $@
	$(BINPLACE_CMD)
$(O)\sdkpost.mak : sdkpost.mak
	copy $** $@
	$(BINPLACE_CMD)
$(O)\msisdk.msi : $(BUILD_PACKAGEDIR)\msisdk.msi
	copy $** $@
	$(BINPLACE_CMD)
$(O)\ReadMe.txt : $(SDXROOT)\admin\darwin\src\sdk\ReadMe.txt
	copy $** $@
	$(BINPLACE_CMD)
$(O)\Redist.txt : $(SDXROOT)\admin\darwin\src\sdk\Redist.txt
	copy $** $@
	$(BINPLACE_CMD)
$(O)\License.rtf : $(SDXROOT)\admin\darwin\src\sdk\License.rtf
	copy $** $@
	$(BINPLACE_CMD)
$(O)\INSTLR1.ADM : $(SDXROOT)\admin\darwin\src\sdk\INSTLR1.ADM
	copy $** $@
	$(BINPLACE_CMD)
$(O)\instlr11.adm : $(SDXROOT)\admin\darwin\src\sdk\instlr11.adm
	copy $** $@
	$(BINPLACE_CMD)
$(O)\msi.h : $(SDXROOT)\public\sdk\inc\msi.h
	copy $** $@
	$(BINPLACE_CMD)
$(O)\msiquery.h : $(SDXROOT)\public\sdk\inc\msiquery.h
	copy $** $@
	$(BINPLACE_CMD)
$(O)\msidefs.h : $(SDXROOT)\public\sdk\inc\msidefs.h
	copy $** $@
	$(BINPLACE_CMD)
$(O)\patchwiz.h : $(SDXROOT)\admin\darwin\src\msitools\patchwiz\patchwiz.h
	copy $** $@
	$(BINPLACE_CMD)
$(O)\patchapi.h : $(SDXROOT)\public\sdk\inc\patchapi.h
	copy $** $@
	$(BINPLACE_CMD)
$(O)\Mergemod.h : $(SDXROOT)\admin\darwin\build\common\obj\i386\Mergemod.h
	copy $** $@
	$(BINPLACE_CMD)
$(O)\msi.lib : $(SDXROOT)\public\sdk\lib\i386\msi.lib
	copy $** $@
	$(BINPLACE_CMD)
$(O)\mspatchc.lib : $(SDXROOT)\public\sdk\lib\i386\mspatchc.lib
	copy $** $@
	$(BINPLACE_CMD)
$(O)\msi.chm : $(SDXROOT)\admin\darwin\doc\msi.chm
	copy $** $@
	$(BINPLACE_CMD)
$(O)\msi.chi : $(SDXROOT)\admin\darwin\doc\msi.chi
	copy $** $@
	$(BINPLACE_CMD)
$(O)\msitool.mak : $(SDXROOT)\admin\darwin\src\msitools\msitool.mak
	copy $** $@
	$(BINPLACE_CMD)
$(O)\darice.cub : $(SDXROOT)\admin\darwin\data\archive\cubes\110\darice.cub
	copy $** $@
	$(BINPLACE_CMD)
$(O)\logo.cub : $(SDXROOT)\admin\darwin\data\archive\cubes\110\logo.cub
	copy $** $@
	$(BINPLACE_CMD)
$(O)\mergemod.cub : $(SDXROOT)\admin\darwin\data\archive\cubes\110\mergemod.cub
	copy $** $@
	$(BINPLACE_CMD)
$(O)\darice.cub1 : $(SDXROOT)\admin\darwin\data\archive\cubes\120\darice.cub
	copy $** $@
	$(BINPLACE_CMD)
$(O)\logo.cub1 : $(SDXROOT)\admin\darwin\data\archive\cubes\120\logo.cub
	copy $** $@
	$(BINPLACE_CMD)
$(O)\mergemod.cub1 : $(SDXROOT)\admin\darwin\data\archive\cubes\120\mergemod.cub
	copy $** $@
	$(BINPLACE_CMD)
$(O)\preadme.txt : $(SDXROOT)\admin\darwin\src\sdk\preadme.txt
	copy $** $@
	$(BINPLACE_CMD)
$(O)\makecab.exe : $(SDXROOT)\admin\darwin\bin\i386\makecab.exe
	copy $** $@
	$(BINPLACE_CMD)
$(O)\TEMPLATE.PCP : $(SDXROOT)\admin\darwin\src\msitools\PatchWiz\TEMPLATE.PCP
	copy $** $@
	$(BINPLACE_CMD)
$(O)\EXAMPLE.PCP : $(SDXROOT)\admin\darwin\src\msitools\PatchWiz\EXAMPLE.PCP
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiReadMe.txt : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiReadMe.txt
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiCompon.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiCompon.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiDialog.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiDialog.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiDiffDb.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiDiffDb.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiExport.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiExport.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiFilVer.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiFilVer.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiFeatur.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiFeatur.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiGenXfm.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiGenXfm.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiImport.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiImport.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiLangId.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiLangId.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiLstPrd.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiLstPrd.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiLstScr.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiLstScr.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiLstXfm.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiLstXfm.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiMakCab.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiMakCab.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiMerge.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiMerge.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiPolicy.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiPolicy.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiRunSQL.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiRunSQL.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiStream.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiStream.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiSubStg.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiSubStg.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiSumInf.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiSumInf.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiTextIn.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiTextIn.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiToAnsi.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiToAnsi.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\WiUseXfm.vbs : $(SDXROOT)\admin\darwin\src\msitools\scripts\WiUseXfm.vbs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\tutorial.cpp : $(SDXROOT)\admin\darwin\src\samples\tutorial.dll\tutorial.cpp
	copy $** $@
	$(BINPLACE_CMD)
$(O)\tutorial.rc : $(SDXROOT)\admin\darwin\src\samples\tutorial.dll\tutorial.rc
	copy $** $@
	$(BINPLACE_CMD)
$(O)\tutorial.def : $(SDXROOT)\admin\darwin\src\samples\tutorial.dll\tutorial.def
	copy $** $@
	$(BINPLACE_CMD)
$(O)\makefile3 : $(SDXROOT)\admin\darwin\src\samples\tutorial.dll\SDKFiles\makefile
	copy $** $@
	$(BINPLACE_CMD)
$(O)\readme.txt3 : $(SDXROOT)\admin\darwin\src\samples\tutorial.dll\SDKFiles\readme.txt
	copy $** $@
	$(BINPLACE_CMD)
$(O)\process.cpp : $(SDXROOT)\admin\darwin\src\samples\process.dll\process.cpp
	copy $** $@
	$(BINPLACE_CMD)
$(O)\process.rc : $(SDXROOT)\admin\darwin\src\samples\process.dll\process.rc
	copy $** $@
	$(BINPLACE_CMD)
$(O)\process.def : $(SDXROOT)\admin\darwin\src\samples\process.dll\process.def
	copy $** $@
	$(BINPLACE_CMD)
$(O)\makefile4 : $(SDXROOT)\admin\darwin\src\samples\process.dll\SDKFiles\makefile
	copy $** $@
	$(BINPLACE_CMD)
$(O)\readme.txt4 : $(SDXROOT)\admin\darwin\src\samples\process.dll\SDKFiles\readme.txt
	copy $** $@
	$(BINPLACE_CMD)
$(O)\remove.cpp : $(SDXROOT)\admin\darwin\src\samples\remove.dll\remove.cpp
	copy $** $@
	$(BINPLACE_CMD)
$(O)\remove.rc : $(SDXROOT)\admin\darwin\src\samples\remove.dll\remove.rc
	copy $** $@
	$(BINPLACE_CMD)
$(O)\remove.def : $(SDXROOT)\admin\darwin\src\samples\remove.dll\remove.def
	copy $** $@
	$(BINPLACE_CMD)
$(O)\makefile5 : $(SDXROOT)\admin\darwin\src\samples\remove.dll\SDKFiles\makefile
	copy $** $@
	$(BINPLACE_CMD)
$(O)\readme.txt5 : $(SDXROOT)\admin\darwin\src\samples\remove.dll\SDKFiles\readme.txt
	copy $** $@
	$(BINPLACE_CMD)
$(O)\create.cpp : $(SDXROOT)\admin\darwin\src\samples\create.dll\create.cpp
	copy $** $@
	$(BINPLACE_CMD)
$(O)\create.rc : $(SDXROOT)\admin\darwin\src\samples\create.dll\create.rc
	copy $** $@
	$(BINPLACE_CMD)
$(O)\create.def : $(SDXROOT)\admin\darwin\src\samples\create.dll\create.def
	copy $** $@
	$(BINPLACE_CMD)
$(O)\makefile6 : $(SDXROOT)\admin\darwin\src\samples\create.dll\SDKFiles\makefile
	copy $** $@
	$(BINPLACE_CMD)
$(O)\readme.txt6 : $(SDXROOT)\admin\darwin\src\samples\create.dll\SDKFiles\readme.txt
	copy $** $@
	$(BINPLACE_CMD)
$(O)\msiloc.cpp : $(SDXROOT)\admin\darwin\src\msitools\msiloc\msiloc.cpp
	copy $** $@
	$(BINPLACE_CMD)
$(O)\msiloc.rc : $(SDXROOT)\admin\darwin\src\msitools\msiloc\msiloc.rc
	copy $** $@
	$(BINPLACE_CMD)
$(O)\Makefile7 : $(SDXROOT)\admin\darwin\src\msitools\msiloc\SDKFiles\Makefile
	copy $** $@
	$(BINPLACE_CMD)
$(O)\readme.txt7 : $(SDXROOT)\admin\darwin\src\msitools\msiloc\SDKFiles\readme.txt
	copy $** $@
	$(BINPLACE_CMD)
$(O)\setup.cpp : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setup.cpp
	copy $** $@
	$(BINPLACE_CMD)
$(O)\setupui.cpp : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setupui.cpp
	copy $** $@
	$(BINPLACE_CMD)
$(O)\upgrdmsi.cpp : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\upgrdmsi.cpp
	copy $** $@
	$(BINPLACE_CMD)
$(O)\utils.cpp : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\utils.cpp
	copy $** $@
	$(BINPLACE_CMD)
$(O)\vertrust.cpp : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\vertrust.cpp
	copy $** $@
	$(BINPLACE_CMD)
$(O)\common.h : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\common.h
	copy $** $@
	$(BINPLACE_CMD)
$(O)\resource.h : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\resource.h
	copy $** $@
	$(BINPLACE_CMD)
$(O)\setup.h : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setup.h
	copy $** $@
	$(BINPLACE_CMD)
$(O)\setupui.h : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setupui.h
	copy $** $@
	$(BINPLACE_CMD)
$(O)\setup.rc : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setup.rc
	copy $** $@
	$(BINPLACE_CMD)
$(O)\setup.ico : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\setup.ico
	copy $** $@
	$(BINPLACE_CMD)
$(O)\msistuff.cpp : $(SDXROOT)\admin\darwin\src\msitools\msistuff\msistuff.cpp
	copy $** $@
	$(BINPLACE_CMD)
$(O)\msistuff.rc : $(SDXROOT)\admin\darwin\src\msitools\msistuff\msistuff.rc
	copy $** $@
	$(BINPLACE_CMD)
$(O)\Makefile1 : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\SDKFiles\Makefile
	copy $** $@
	$(BINPLACE_CMD)
$(O)\ReadMe.htm1 : $(SDXROOT)\admin\darwin\src\msitools\setup.exe\SDKFiles\ReadMe.htm
	copy $** $@
	$(BINPLACE_CMD)
$(O)\Makefile2 : $(SDXROOT)\admin\darwin\src\msitools\msistuff\SDKFiles\Makefile
	copy $** $@
	$(BINPLACE_CMD)
$(O)\ReadMe.htm2 : $(SDXROOT)\admin\darwin\src\msitools\msistuff\SDKFiles\ReadMe.htm
	copy $** $@
	$(BINPLACE_CMD)
$(O)\dbreadme.txt : $(SDXROOT)\admin\darwin\src\sdk\dbreadme.txt
	copy $** $@
	$(BINPLACE_CMD)
$(O)\schema.msi : $(SDXROOT)\admin\darwin\build\packages\obj\i386\schema.msi
	copy $** $@
	$(BINPLACE_CMD)
$(O)\schema.msi1 : $(SDXROOT)\admin\darwin\data\archive\packages\100\schema.msi
	copy $** $@
	$(BINPLACE_CMD)
$(O)\schema.msi2 : $(SDXROOT)\admin\darwin\data\archive\packages\110\schema.msi
	copy $** $@
	$(BINPLACE_CMD)
$(O)\schema.msi3 : $(SDXROOT)\admin\darwin\data\archive\packages\120\schema.msi
	copy $** $@
	$(BINPLACE_CMD)
$(O)\sequence.msi : $(SDXROOT)\admin\darwin\build\packages\obj\i386\sequence.msi
	copy $** $@
	$(BINPLACE_CMD)
$(O)\sequence.msi1 : $(SDXROOT)\admin\darwin\data\archive\packages\100\sequence.msi
	copy $** $@
	$(BINPLACE_CMD)
$(O)\sequence.msi2 : $(SDXROOT)\admin\darwin\data\archive\packages\110\sequence.msi
	copy $** $@
	$(BINPLACE_CMD)
$(O)\sequence.msi3 : $(SDXROOT)\admin\darwin\data\archive\packages\120\sequence.msi
	copy $** $@
	$(BINPLACE_CMD)
$(O)\schema.msm : $(SDXROOT)\admin\darwin\build\packages\obj\i386\schema.msm
	copy $** $@
	$(BINPLACE_CMD)
$(O)\schema.msm1 : $(SDXROOT)\admin\darwin\data\archive\packages\110\schema.msm
	copy $** $@
	$(BINPLACE_CMD)
$(O)\schema.msm2 : $(SDXROOT)\admin\darwin\data\archive\packages\120\schema.msm
	copy $** $@
	$(BINPLACE_CMD)
$(O)\uisample.msi : $(SDXROOT)\admin\darwin\build\packages\obj\i386\uisample.msi
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.ara : $(SDXROOT)\admin\darwin\data\intl\error.ara
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.cat : $(SDXROOT)\admin\darwin\data\intl\error.cat
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.chs : $(SDXROOT)\admin\darwin\data\intl\error.chs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.cht : $(SDXROOT)\admin\darwin\data\intl\error.cht
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.csy : $(SDXROOT)\admin\darwin\data\intl\error.csy
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.dan : $(SDXROOT)\admin\darwin\data\intl\error.dan
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.deu : $(SDXROOT)\admin\darwin\data\intl\error.deu
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.ell : $(SDXROOT)\admin\darwin\data\intl\error.ell
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.enu : $(SDXROOT)\admin\darwin\data\intl\error.enu
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.esn : $(SDXROOT)\admin\darwin\data\intl\error.esn
	copy $** $@
	$(BINPLACE_CMD)
$(O)\Error.eti : $(SDXROOT)\admin\darwin\data\intl\Error.eti
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.euq : $(SDXROOT)\admin\darwin\data\intl\error.euq
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.fin : $(SDXROOT)\admin\darwin\data\intl\error.fin
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.fra : $(SDXROOT)\admin\darwin\data\intl\error.fra
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.heb : $(SDXROOT)\admin\darwin\data\intl\error.heb
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.hrv : $(SDXROOT)\admin\darwin\data\intl\error.hrv
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.hun : $(SDXROOT)\admin\darwin\data\intl\error.hun
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.idt : $(SDXROOT)\admin\darwin\data\intl\error.idt
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.ita : $(SDXROOT)\admin\darwin\data\intl\error.ita
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.jpn : $(SDXROOT)\admin\darwin\data\intl\error.jpn
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.kor : $(SDXROOT)\admin\darwin\data\intl\error.kor
	copy $** $@
	$(BINPLACE_CMD)
$(O)\Error.lth : $(SDXROOT)\admin\darwin\data\intl\Error.lth
	copy $** $@
	$(BINPLACE_CMD)
$(O)\Error.lvi : $(SDXROOT)\admin\darwin\data\intl\Error.lvi
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.nld : $(SDXROOT)\admin\darwin\data\intl\error.nld
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.nor : $(SDXROOT)\admin\darwin\data\intl\error.nor
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.plk : $(SDXROOT)\admin\darwin\data\intl\error.plk
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.ptb : $(SDXROOT)\admin\darwin\data\intl\error.ptb
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.ptg : $(SDXROOT)\admin\darwin\data\intl\error.ptg
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.rom : $(SDXROOT)\admin\darwin\data\intl\error.rom
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.rus : $(SDXROOT)\admin\darwin\data\intl\error.rus
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.sky : $(SDXROOT)\admin\darwin\data\intl\error.sky
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.slv : $(SDXROOT)\admin\darwin\data\intl\error.slv
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.sve : $(SDXROOT)\admin\darwin\data\intl\error.sve
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.tha : $(SDXROOT)\admin\darwin\data\intl\error.tha
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.trk : $(SDXROOT)\admin\darwin\data\intl\error.trk
	copy $** $@
	$(BINPLACE_CMD)
$(O)\error.vit : $(SDXROOT)\admin\darwin\data\intl\error.vit
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.ara : $(SDXROOT)\admin\darwin\data\intl\actionte.ara
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.cat : $(SDXROOT)\admin\darwin\data\intl\actionte.cat
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.chs : $(SDXROOT)\admin\darwin\data\intl\actionte.chs
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.cht : $(SDXROOT)\admin\darwin\data\intl\actionte.cht
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.csy : $(SDXROOT)\admin\darwin\data\intl\actionte.csy
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.dan : $(SDXROOT)\admin\darwin\data\intl\actionte.dan
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.deu : $(SDXROOT)\admin\darwin\data\intl\actionte.deu
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.ell : $(SDXROOT)\admin\darwin\data\intl\actionte.ell
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.enu : $(SDXROOT)\admin\darwin\data\intl\actionte.enu
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.esn : $(SDXROOT)\admin\darwin\data\intl\actionte.esn
	copy $** $@
	$(BINPLACE_CMD)
$(O)\ActionTe.eti : $(SDXROOT)\admin\darwin\data\intl\ActionTe.eti
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.euq : $(SDXROOT)\admin\darwin\data\intl\actionte.euq
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.fin : $(SDXROOT)\admin\darwin\data\intl\actionte.fin
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.fra : $(SDXROOT)\admin\darwin\data\intl\actionte.fra
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.heb : $(SDXROOT)\admin\darwin\data\intl\actionte.heb
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.hrv : $(SDXROOT)\admin\darwin\data\intl\actionte.hrv
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.hun : $(SDXROOT)\admin\darwin\data\intl\actionte.hun
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.idt : $(SDXROOT)\admin\darwin\data\intl\actionte.idt
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.ita : $(SDXROOT)\admin\darwin\data\intl\actionte.ita
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.jpn : $(SDXROOT)\admin\darwin\data\intl\actionte.jpn
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.kor : $(SDXROOT)\admin\darwin\data\intl\actionte.kor
	copy $** $@
	$(BINPLACE_CMD)
$(O)\ActionTe.lth : $(SDXROOT)\admin\darwin\data\intl\ActionTe.lth
	copy $** $@
	$(BINPLACE_CMD)
$(O)\ActionTe.lvi : $(SDXROOT)\admin\darwin\data\intl\ActionTe.lvi
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.nld : $(SDXROOT)\admin\darwin\data\intl\actionte.nld
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.nor : $(SDXROOT)\admin\darwin\data\intl\actionte.nor
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.plk : $(SDXROOT)\admin\darwin\data\intl\actionte.plk
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.ptb : $(SDXROOT)\admin\darwin\data\intl\actionte.ptb
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.ptg : $(SDXROOT)\admin\darwin\data\intl\actionte.ptg
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.rom : $(SDXROOT)\admin\darwin\data\intl\actionte.rom
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.rus : $(SDXROOT)\admin\darwin\data\intl\actionte.rus
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.sky : $(SDXROOT)\admin\darwin\data\intl\actionte.sky
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.slv : $(SDXROOT)\admin\darwin\data\intl\actionte.slv
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.sve : $(SDXROOT)\admin\darwin\data\intl\actionte.sve
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.tha : $(SDXROOT)\admin\darwin\data\intl\actionte.tha
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.trk : $(SDXROOT)\admin\darwin\data\intl\actionte.trk
	copy $** $@
	$(BINPLACE_CMD)
$(O)\actionte.vit : $(SDXROOT)\admin\darwin\data\intl\actionte.vit
	copy $** $@
	$(BINPLACE_CMD)
$(O)\schema.log : $(SDXROOT)\admin\darwin\data\schema.idt\schema.log
	copy $** $@
	$(BINPLACE_CMD)
layout : 	$(O)\sdkmake.inc \
	$(O)\sdkpost.mak \
	$(O)\msisdk.msi \
	$(O)\ReadMe.txt \
	$(O)\Redist.txt \
	$(O)\License.rtf \
	$(O)\INSTLR1.ADM \
	$(O)\instlr11.adm \
	$(O)\msi.h \
	$(O)\msiquery.h \
	$(O)\msidefs.h \
	$(O)\patchwiz.h \
	$(O)\patchapi.h \
	$(O)\Mergemod.h \
	$(O)\msi.lib \
	$(O)\mspatchc.lib \
	$(O)\msi.chm \
	$(O)\msi.chi \
	$(O)\msitool.mak \
	$(O)\darice.cub \
	$(O)\logo.cub \
	$(O)\mergemod.cub \
	$(O)\darice.cub1 \
	$(O)\logo.cub1 \
	$(O)\mergemod.cub1 \
	$(O)\preadme.txt \
	$(O)\makecab.exe \
	$(O)\TEMPLATE.PCP \
	$(O)\EXAMPLE.PCP \
	$(O)\WiReadMe.txt \
	$(O)\WiCompon.vbs \
	$(O)\WiDialog.vbs \
	$(O)\WiDiffDb.vbs \
	$(O)\WiExport.vbs \
	$(O)\WiFilVer.vbs \
	$(O)\WiFeatur.vbs \
	$(O)\WiGenXfm.vbs \
	$(O)\WiImport.vbs \
	$(O)\WiLangId.vbs \
	$(O)\WiLstPrd.vbs \
	$(O)\WiLstScr.vbs \
	$(O)\WiLstXfm.vbs \
	$(O)\WiMakCab.vbs \
	$(O)\WiMerge.vbs \
	$(O)\WiPolicy.vbs \
	$(O)\WiRunSQL.vbs \
	$(O)\WiStream.vbs \
	$(O)\WiSubStg.vbs \
	$(O)\WiSumInf.vbs \
	$(O)\WiTextIn.vbs \
	$(O)\WiToAnsi.vbs \
	$(O)\WiUseXfm.vbs \
	$(O)\tutorial.cpp \
	$(O)\tutorial.rc \
	$(O)\tutorial.def \
	$(O)\makefile3 \
	$(O)\readme.txt3 \
	$(O)\process.cpp \
	$(O)\process.rc \
	$(O)\process.def \
	$(O)\makefile4 \
	$(O)\readme.txt4 \
	$(O)\remove.cpp \
	$(O)\remove.rc \
	$(O)\remove.def \
	$(O)\makefile5 \
	$(O)\readme.txt5 \
	$(O)\create.cpp \
	$(O)\create.rc \
	$(O)\create.def \
	$(O)\makefile6 \
	$(O)\readme.txt6 \
	$(O)\msiloc.cpp \
	$(O)\msiloc.rc \
	$(O)\Makefile7 \
	$(O)\readme.txt7 \
	$(O)\setup.cpp \
	$(O)\setupui.cpp \
	$(O)\upgrdmsi.cpp \
	$(O)\utils.cpp \
	$(O)\vertrust.cpp \
	$(O)\common.h \
	$(O)\resource.h \
	$(O)\setup.h \
	$(O)\setupui.h \
	$(O)\setup.rc \
	$(O)\setup.ico \
	$(O)\msistuff.cpp \
	$(O)\msistuff.rc \
	$(O)\Makefile1 \
	$(O)\ReadMe.htm1 \
	$(O)\Makefile2 \
	$(O)\ReadMe.htm2 \
	$(O)\dbreadme.txt \
	$(O)\schema.msi \
	$(O)\schema.msi1 \
	$(O)\schema.msi2 \
	$(O)\schema.msi3 \
	$(O)\sequence.msi \
	$(O)\sequence.msi1 \
	$(O)\sequence.msi2 \
	$(O)\sequence.msi3 \
	$(O)\schema.msm \
	$(O)\schema.msm1 \
	$(O)\schema.msm2 \
	$(O)\uisample.msi \
	$(O)\error.ara \
	$(O)\error.cat \
	$(O)\error.chs \
	$(O)\error.cht \
	$(O)\error.csy \
	$(O)\error.dan \
	$(O)\error.deu \
	$(O)\error.ell \
	$(O)\error.enu \
	$(O)\error.esn \
	$(O)\Error.eti \
	$(O)\error.euq \
	$(O)\error.fin \
	$(O)\error.fra \
	$(O)\error.heb \
	$(O)\error.hrv \
	$(O)\error.hun \
	$(O)\error.idt \
	$(O)\error.ita \
	$(O)\error.jpn \
	$(O)\error.kor \
	$(O)\Error.lth \
	$(O)\Error.lvi \
	$(O)\error.nld \
	$(O)\error.nor \
	$(O)\error.plk \
	$(O)\error.ptb \
	$(O)\error.ptg \
	$(O)\error.rom \
	$(O)\error.rus \
	$(O)\error.sky \
	$(O)\error.slv \
	$(O)\error.sve \
	$(O)\error.tha \
	$(O)\error.trk \
	$(O)\error.vit \
	$(O)\actionte.ara \
	$(O)\actionte.cat \
	$(O)\actionte.chs \
	$(O)\actionte.cht \
	$(O)\actionte.csy \
	$(O)\actionte.dan \
	$(O)\actionte.deu \
	$(O)\actionte.ell \
	$(O)\actionte.enu \
	$(O)\actionte.esn \
	$(O)\ActionTe.eti \
	$(O)\actionte.euq \
	$(O)\actionte.fin \
	$(O)\actionte.fra \
	$(O)\actionte.heb \
	$(O)\actionte.hrv \
	$(O)\actionte.hun \
	$(O)\actionte.idt \
	$(O)\actionte.ita \
	$(O)\actionte.jpn \
	$(O)\actionte.kor \
	$(O)\ActionTe.lth \
	$(O)\ActionTe.lvi \
	$(O)\actionte.nld \
	$(O)\actionte.nor \
	$(O)\actionte.plk \
	$(O)\actionte.ptb \
	$(O)\actionte.ptg \
	$(O)\actionte.rom \
	$(O)\actionte.rus \
	$(O)\actionte.sky \
	$(O)\actionte.slv \
	$(O)\actionte.sve \
	$(O)\actionte.tha \
	$(O)\actionte.trk \
	$(O)\actionte.vit \
	$(O)\schema.log \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\sdk\makefile.inc ===
!include ..\make.inc

ALT_PROJECT_TARGET=instmsi\msitools

BaseAll: \
	$(BUILD_PACKAGEDIR)\msisdk.msi \
	layout \
	$(O)\sdkmake.inc
        
#-----------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\msisdk.msi: $(BUILD_PACKAGEDIR)\uisample.msi $(MSISDK_IDT)\*.idt
	echo BUILD_PACKAGEDIR=$(BUILD_PACKAGEDIR)
	msidb.exe -i -f$(MSISDK_IDT) -c -d$@ *.idt
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "DROP TABLE `InstallExecuteSequence`"
	CScript $(WSHTOOLS)\wimerge.vbs $@ $(BUILD_PACKAGEDIR)\uisample.msi
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "DROP TABLE `InstallExecuteSequence`"
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "DROP TABLE `AdminUISequence`"
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "DROP TABLE `AdminExecuteSequence`"
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "DROP TABLE `AdvtExecuteSequence`"
	CScript $(WSHTOOLS)\wirunsql.vbs $@ "UPDATE `Property` SET `Value`=0 WHERE `Property`='ShowUserRegistrationDlg'"
	CScript $(WSHTOOLS)\wiimport.vbs $@ $(MSISDK_IDT) installe.idt
	CScript $(WSHTOOLS)\witextin.vbs $@ Control LicenseAgreementDlg:AgreementText Text $(MSI_DIR)\src\sdk\license.rtf
	CScript $(WSHTOOLS)\wisuminf.vbs $@ 11=Date 12=Date


#-----------------------------------------------------------------------------
# the raw files must be binplaced into the _NTTREE.  Postbuild can't see the source tree
# and we're not supposed to copy thing directly into _NTTREE.
!INCLUDE "layout.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\sdk\sdkmake.inc ===
# --------- DO NOT EDIT THIS FILE ------------ DO NOT EDIT THIS FILE ---------
# --------- DO NOT EDIT --- see layout.txt --- DO NOT EDIT -------------------
# --------- DO NOT EDIT THIS FILE ------------ DO NOT EDIT THIS FILE ---------
sdk\LIB\patchwiz.lib : $(_NTPOSTBLD)\msiwin9x\patchwiz.lib
	if not exist sdk\LIB md sdk\LIB
	copy $** $@
sdk\WEB\MsiStuff.exe : $(_NTPOSTBLD)\MsiStuff.exe
	if not exist sdk\WEB md sdk\WEB
	copy $** $@
sdk\WEB\Setup.exe : $(_NTPOSTBLD)\msiwin9x\Setup.exe
	if not exist sdk\WEB md sdk\WEB
	copy $** $@
sdk\TOOLS\mergemod.dll : $(_NTPOSTBLD)\msi_bins\mergemod.dll
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\MsiMig.dll : $(_NTPOSTBLD)\msiwin9x\MsiMig.dll
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\MsiMig.exe : $(_NTPOSTBLD)\msiwin9x\MsiMig.exe
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\orca.msi : $(_NTPOSTBLD)\instmsi\msitools\temp\orca.msi
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\msival2.msi : $(_NTPOSTBLD)\instmsi\msitools\temp\msival2.msi
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\MsiCert.exe : $(_NTPOSTBLD)\msiwin9x\MsiCert.exe
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\msidb.exe : $(_NTPOSTBLD)\msiwin9X\mstools\msidb.exe
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\msifiler.exe : $(_NTPOSTBLD)\msiwin9x\mstools\msifiler.exe
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\MsiInfo.exe : $(_NTPOSTBLD)\msiwin9x\MsiInfo.exe
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\MsiMerg.exe : $(_NTPOSTBLD)\msiwin9x\msi_bins\MsiMerg.exe
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\msitran.exe : $(_NTPOSTBLD)\msiwin9x\msitran.exe
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\MsiZap.exe : $(_NTPOSTBLD)\msiwin9x\MsiZap.exe
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\wilogutl.exe : $(_NTPOSTBLD)\msiwin9x\wilogutl.exe
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\120\darice.cub : 1sdk\TOOLS\120\darice.cub1
	if not exist sdk\TOOLS\120 md sdk\TOOLS\120
	copy $** $@
sdk\TOOLS\120\logo.cub : 1sdk\TOOLS\120\logo.cub1
	if not exist sdk\TOOLS\120 md sdk\TOOLS\120
	copy $** $@
sdk\TOOLS\120\mergemod.cub : 1sdk\TOOLS\120\mergemod.cub1
	if not exist sdk\TOOLS\120 md sdk\TOOLS\120
	copy $** $@
sdk\TOOLS\mpatch.exe : $(_NTPOSTBLD)\idw\mpatch.exe
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\apatch.exe : $(_NTPOSTBLD)\idw\apatch.exe
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\mspatchc.dll : $(_NTPOSTBLD)\idw\mspatchc.dll
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\patchwiz.dll : $(_NTPOSTBLD)\msiwin9x\patchwiz.dll
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\TOOLS\MsiMsp.exe : $(_NTPOSTBLD)\msiwin9x\MsiMsp.exe
	if not exist sdk\TOOLS md sdk\TOOLS
	copy $** $@
sdk\SAMPLES\tutorial.dll\makefile : 3sdk\SAMPLES\tutorial.dll\makefile3
	if not exist sdk\SAMPLES\tutorial.dll md sdk\SAMPLES\tutorial.dll
	copy $** $@
sdk\SAMPLES\tutorial.dll\readme.txt : 3sdk\SAMPLES\tutorial.dll\readme.txt3
	if not exist sdk\SAMPLES\tutorial.dll md sdk\SAMPLES\tutorial.dll
	copy $** $@
sdk\SAMPLES\process.dll\makefile : 4sdk\SAMPLES\process.dll\makefile4
	if not exist sdk\SAMPLES\process.dll md sdk\SAMPLES\process.dll
	copy $** $@
sdk\SAMPLES\process.dll\readme.txt : 4sdk\SAMPLES\process.dll\readme.txt4
	if not exist sdk\SAMPLES\process.dll md sdk\SAMPLES\process.dll
	copy $** $@
sdk\SAMPLES\remove.dll\makefile : 5sdk\SAMPLES\remove.dll\makefile5
	if not exist sdk\SAMPLES\remove.dll md sdk\SAMPLES\remove.dll
	copy $** $@
sdk\SAMPLES\remove.dll\readme.txt : 5sdk\SAMPLES\remove.dll\readme.txt5
	if not exist sdk\SAMPLES\remove.dll md sdk\SAMPLES\remove.dll
	copy $** $@
sdk\SAMPLES\create.dll\makefile : 6sdk\SAMPLES\create.dll\makefile6
	if not exist sdk\SAMPLES\create.dll md sdk\SAMPLES\create.dll
	copy $** $@
sdk\SAMPLES\create.dll\readme.txt : 6sdk\SAMPLES\create.dll\readme.txt6
	if not exist sdk\SAMPLES\create.dll md sdk\SAMPLES\create.dll
	copy $** $@
sdk\SAMPLES\msiloc\Makefile : 7sdk\SAMPLES\msiloc\Makefile7
	if not exist sdk\SAMPLES\msiloc md sdk\SAMPLES\msiloc
	copy $** $@
sdk\SAMPLES\msiloc\readme.txt : 7sdk\SAMPLES\msiloc\readme.txt7
	if not exist sdk\SAMPLES\msiloc md sdk\SAMPLES\msiloc
	copy $** $@
sdk\SAMPLES\setup.exe\Makefile : 1sdk\SAMPLES\setup.exe\Makefile1
	if not exist sdk\SAMPLES\setup.exe md sdk\SAMPLES\setup.exe
	copy $** $@
sdk\SAMPLES\setup.exe\ReadMe.htm : 1sdk\SAMPLES\setup.exe\ReadMe.htm1
	if not exist sdk\SAMPLES\setup.exe md sdk\SAMPLES\setup.exe
	copy $** $@
sdk\SAMPLES\MsiStuff\Makefile : 2sdk\SAMPLES\MsiStuff\Makefile2
	if not exist sdk\SAMPLES\MsiStuff md sdk\SAMPLES\MsiStuff
	copy $** $@
sdk\SAMPLES\MsiStuff\ReadMe.htm : 2sdk\SAMPLES\MsiStuff\ReadMe.htm2
	if not exist sdk\SAMPLES\MsiStuff md sdk\SAMPLES\MsiStuff
	copy $** $@
sdk\DATABASE\100\schema.msi : 1sdk\DATABASE\100\schema.msi1
	if not exist sdk\DATABASE\100 md sdk\DATABASE\100
	copy $** $@
sdk\DATABASE\110\schema.msi : 2sdk\DATABASE\110\schema.msi2
	if not exist sdk\DATABASE\110 md sdk\DATABASE\110
	copy $** $@
sdk\DATABASE\120\schema.msi : 3sdk\DATABASE\120\schema.msi3
	if not exist sdk\DATABASE\120 md sdk\DATABASE\120
	copy $** $@
sdk\DATABASE\100\sequence.msi : 1sdk\DATABASE\100\sequence.msi1
	if not exist sdk\DATABASE\100 md sdk\DATABASE\100
	copy $** $@
sdk\DATABASE\110\sequence.msi : 2sdk\DATABASE\110\sequence.msi2
	if not exist sdk\DATABASE\110 md sdk\DATABASE\110
	copy $** $@
sdk\DATABASE\120\sequence.msi : 3sdk\DATABASE\120\sequence.msi3
	if not exist sdk\DATABASE\120 md sdk\DATABASE\120
	copy $** $@
sdk\DATABASE\110\schema.msm : 1sdk\DATABASE\110\schema.msm1
	if not exist sdk\DATABASE\110 md sdk\DATABASE\110
	copy $** $@
sdk\DATABASE\120\schema.msm : 2sdk\DATABASE\120\schema.msm2
	if not exist sdk\DATABASE\120 md sdk\DATABASE\120
	copy $** $@
sdklayout : 	sdk\LIB\patchwiz.lib \
	sdk\WEB\MsiStuff.exe \
	sdk\WEB\Setup.exe \
	sdk\TOOLS\mergemod.dll \
	sdk\TOOLS\MsiMig.dll \
	sdk\TOOLS\MsiMig.exe \
	sdk\TOOLS\orca.msi \
	sdk\TOOLS\msival2.msi \
	sdk\TOOLS\MsiCert.exe \
	sdk\TOOLS\msidb.exe \
	sdk\TOOLS\msifiler.exe \
	sdk\TOOLS\MsiInfo.exe \
	sdk\TOOLS\MsiMerg.exe \
	sdk\TOOLS\msitran.exe \
	sdk\TOOLS\MsiZap.exe \
	sdk\TOOLS\wilogutl.exe \
	sdk\TOOLS\120\darice.cub \
	sdk\TOOLS\120\logo.cub \
	sdk\TOOLS\120\mergemod.cub \
	sdk\TOOLS\mpatch.exe \
	sdk\TOOLS\apatch.exe \
	sdk\TOOLS\mspatchc.dll \
	sdk\TOOLS\patchwiz.dll \
	sdk\TOOLS\MsiMsp.exe \
	sdk\SAMPLES\tutorial.dll\makefile \
	sdk\SAMPLES\tutorial.dll\readme.txt \
	sdk\SAMPLES\process.dll\makefile \
	sdk\SAMPLES\process.dll\readme.txt \
	sdk\SAMPLES\remove.dll\makefile \
	sdk\SAMPLES\remove.dll\readme.txt \
	sdk\SAMPLES\create.dll\makefile \
	sdk\SAMPLES\create.dll\readme.txt \
	sdk\SAMPLES\msiloc\Makefile \
	sdk\SAMPLES\msiloc\readme.txt \
	sdk\SAMPLES\setup.exe\Makefile \
	sdk\SAMPLES\setup.exe\ReadMe.htm \
	sdk\SAMPLES\MsiStuff\Makefile \
	sdk\SAMPLES\MsiStuff\ReadMe.htm \
	sdk\DATABASE\100\schema.msi \
	sdk\DATABASE\110\schema.msi \
	sdk\DATABASE\120\schema.msi \
	sdk\DATABASE\100\sequence.msi \
	sdk\DATABASE\110\sequence.msi \
	sdk\DATABASE\120\sequence.msi \
	sdk\DATABASE\110\schema.msm \
	sdk\DATABASE\120\schema.msm \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\testdb.idt\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\testdb.idt\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\testdb.idt\sources.inc ===
!INCLUDE ..\..\..\Src\MsiMake.inc
TARGETNAME=
TARGETTYPE=DYNLINK

!if "$(MAKEDLL)"=="1"
NTTARGETFILE0=testdb
!endif

SOURCES=
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\testdb.idt\make.inc ===
!include ..\..\make.inc

testdb: \
        $(BUILD_PACKAGEDIR)\testdb.msi  \
        $(BUILD_PACKAGEDIR)\uitestdb.msi 

#-------------------------------------------------------------------------------
$(BUILD_PACKAGEDIR)\testdb.msi: $(TESTDB_IDT)\*.idt $(BUILD_PACKAGEDIR)\template.msi $(BUILD_PACKAGEDIR)\simple.msi
	if not exist $(BUILD_PACKAGEDIR) md $(BUILD_PACKAGEDIR)
	msidb.exe -d$@ -f$(TESTDB_IDT) -m$(BUILD_PACKAGEDIR)\template.msi -c -i *.idt
	msidb.exe -d$@ -f$(TESTDB_IDT) -r$(BUILD_PACKAGEDIR)\simple.msi 
!if "$(PLATFORM)" == "MERCED"
	echo $(TOOLBUILDDIR)\msiinfo.exe $@ /p "IA64;1033"
	$(TOOLBUILDDIR)\msiinfo.exe $@ /p "IA64;1033"
!endif

$(BUILD_PACKAGEDIR)\uitestdb.msi: $(TESTDB_IDT)\*.idt $(UISAMPLE_IDT)\*.idt $(SCHEMA_IDT)\_validat.idt $(BUILD_PACKAGEDIR)\uisample.msi $(BUILD_PACKAGEDIR)\simple.msi
	if not exist $(BUILD_PACKAGEDIR) md $(BUILD_PACKAGEDIR)
	msidb.exe -d$@ -f$(TESTDB_IDT) -m$(BUILD_PACKAGEDIR)\uisample.msi -c -i *.idt
	msidb.exe -d$@ -f$(TESTDB_IDT) -r$(BUILD_PACKAGEDIR)\simple.msi 
	msidb.exe -d$@ -f$(UISAMPLE_IDT) -i a*.idt bbcontro.idt billboar.idt c*.idt d*.idt e*.idt installu.idt l*.idt r*.idt t*.idt
	msidb.exe -i -f$(SCHEMA_IDT) -d$@ _validat.idt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\msimake.inc ===
MSI_C_DEFINES=-DSTRICT -D_WIN32_MSI=200 -D_WIN32_DCOM -DSTRSAFE_NO_DEPRECATE

!if !$(FREEBUILD)
MSI_C_DEFINES=$(MSI_C_DEFINES) -DDEBUG
USE_RTTI=1
# MSI_BROWSER_INFO=1
!endif

!if "$(MSI_BUILD_UNICODE)"=="1"
MSI_C_DEFINES=$(MSI_C_DEFINES) -DUNICODE -D_UNICODE
MSI_SUBDIR=unicode
!if "$(MSI_BUILD_LEGACY)"=="1"
MSI_LEGACY_SUBDIR=legacy
!endif
MSI_WINENTRY=wwinmain
MSI_ENTRY=wmain
!else
MSI_SUBDIR=ansi
ALT_PROJECT_TARGET=msiwin9x
MSI_WINENTRY=winmain
MSI_ENTRY=main
NO_NTDLL=1
!endif

386_STDCALL=0

DARWIN_ROOT=$(PROJECT_ROOT)\Darwin
BUILD_ROOT=Build
MSI_DIR=$(DARWIN_ROOT)

!if "$(MSI_BUILD_LEGACY)"=="1"
MSI_TARGETPATH=$(MSI_DIR)\$(BUILD_ROOT)\$(MSI_LEGACY_SUBDIR)
MSI_UNICODE_TARGETPATH=$(MSI_DIR)\$(BUILD_ROOT)\$(MSI_SUBDIR)
!else
MSI_TARGETPATH=$(MSI_DIR)\$(BUILD_ROOT)\$(MSI_SUBDIR)
!endif

MSI_BUILD_TARGET=$(MSI_TARGETPATH)\$(_OBJ_DIR)
!if "$(MSI_BUILD_LEGACY)"=="1"
MSI_UNICODE_BUILD_TARGET=$(MSI_UNICODE_TARGETPATH)\$(_OBJ_DIR)
!endif

TARGETPATH=$(MSI_BUILD_TARGET)

SRC_DIR=$(MSI_DIR)\src
INC_DIR=$(SRC_DIR)\inc
ENGINE_DIR=$(SRC_DIR)\Engine

MSI_LIB_PATH=$(MSI_DIR)\lib\$(TARGET_DIRECTORY)

IDL_DIR=$(SRC_DIR)\Idl
!if "$(MSI_BUILD_LEGACY)"=="1"
IDL_OBJDIR=$(IDL_DIR)\$(MSI_LEGACY_SUBDIR)\$(O)
!else
IDL_OBJDIR=$(IDL_DIR)\$(MSI_SUBDIR)\$(O)
!endif

RES_DIR=$(SRC_DIR)\Res
RES_OBJDIR=$(RES_DIR)\$(MSI_SUBDIR)\$(O)

AUTO_DIR=$(SRC_DIR)\Auto
AUTO_OBJDIR=$(AUTO_DIR)\$(MSI_SUBDIR)\$(O)

BUILD_DIR=$(MSI_TARGETPATH)\$(O)
COMMON_DIR=$(MSI_DIR)\$(BUILD_ROOT)\Common
TARGETPATH_COMMON=$(COMMON_DIR)\$(_OBJ_DIR)
BUILD_COMMONDIR=$(COMMON_DIR)\$(O)
BUILD_COMMONTOOLSDIR=$(BUILD_COMMONDIR)
BUILD_PACKAGEROOT=$(MSI_DIR)\$(BUILD_ROOT)\Packages
BUILD_PACKAGEDIR=$(BUILD_PACKAGEROOT)\$(O)
HELP_DIR=$(SRC_DIR)\Help

TOOLS_DIR=$(MSI_DIR)\Tools
TOOLS_INC_DIR=$(TOOLS_DIR)\inc
MSI_TOOLS_DIR=$(SRC_DIR)\MsiTools
MSI_BUILDTOOLS_DIR=$(SRC_DIR)\BuildTools
MSI_DATA_DIR=$(MSI_DIR)\Data
MSI_INTLDATA_DIR=$(MSI_DATA_DIR)\intl
SCHEMA_IDT=$(MSI_DATA_DIR)\schema.idt
MSI_BIN_PATH=$(MSI_DIR)\Bin

ICESRC=$(MSI_TOOLS_DIR)\iceman\ices

MSI_SPYDIR=$(MSI_TOOLS_DIR)\MsiSpy
MSI_SPYRES_DIR=$(MSI_SPYDIR)\SpyRes
MSI_SPYINC_DIR=$(MSI_SPYDIR)\SpyInc

MSI_CMDPARSE_DIR=$(MSI_TOOLS_DIR)\cmdparse

C_DEFINES=$(MSI_C_DEFINES)
USER_C_FLAGS=-J

INCLUDES=$(INCLUDES);$(COM_INC_PATH);$(WINDOWS_INC_PATH);$(TERMSRV_INC_PATH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\auto\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\data\uisample.idt\makefile.inc ===
UISAMPLE_IDT=$(MSI_DATA_DIR)\uisample.idt
SCHEMA_IDT=$(MSI_DATA_DIR)\schema.idt
MSI_INTLDATA_DIR=$(MSI_DATA_DIR)\intl

UISample: $(BUILD_PACKAGEDIR)\uisample.msi

$(O)\error.idt: $(MSI_INTLDATA_DIR)\error.enu
	copy $(MSI_INTLDATA_DIR)\error.enu $(O)\error.idt
        
$(O)\actionte.idt: $(MSI_INTLDATA_DIR)\actionte.enu
        copy $(MSI_INTLDATA_DIR)\actionte.enu $(O)\actionte.idt

$(BUILD_PACKAGEDIR)\uisample.msi: $(UISAMPLE_IDT)\*.idt $(SCHEMA_IDT)\_validat.idt $(O)\error.idt $(O)\actionte.idt
	if not exist $(BUILD_PACKAGEDIR) md $(BUILD_PACKAGEDIR)
	msidb.exe -i -f$(UISAMPLE_IDT) -c -d$@ *.idt
	msidb.exe -i -f$(SCHEMA_IDT) -d$@ _validat.idt
	msidb.exe -f $(UISAMPLE_IDT)\$(O) -i -d$@ error.idt actionte.idt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\auto\script.cpp ===
#include "script.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\auto\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\auto\sources.inc ===
!INCLUDE ..\..\MsiMake.inc
TARGETNAME=msiauto
TARGETTYPE=DYNLINK

NTTARGETFILE0=AutoRes

USE_NATIVE_EH=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\msiauto.def

USE_LIBCMT=1

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
        $(SDK_LIB_PATH)\strsafe.lib \
	$(AUTO_OBJDIR)\auto.res

INCLUDES=\
	$(INCLUDES);\
	$(INC_DIR);\
	$(IDL_OBJDIR);\
	$(HELP_DIR);\
	$(TOOLS_INC_DIR);\
	$(RES_OBJDIR);\
	$(ADMIN_INC_PATH)

SOURCES=..\autocom.cpp \
	..\autosrv.cpp \
	..\script.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\auto\autocom.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       autocom.cpp
//
//--------------------------------------------------------------------------

/* autocom.cpp

 Common automation implementation for install engine
 This is a separate DLL, not required for normal install
 Uses exception handling, must compile with -GX switch
____________________________________________________________________________*/

#include "common.h"  // must be first for precompiled headers to work

#define AUT  // local automation DLL function                 

#define AUTOMATION_HANDLING  // instantiate IDispatch implementation
#include "autocom.h"
#include "msiauto.hh"  // help context ID definitions

// definitions required for module.h, for entry points and registration
#ifdef DEBUG
# define CLSID_COUNT  2
#else
# define CLSID_COUNT  1
#endif
#define PROFILE_OUTPUT      "msisrvd.mea";
#define MODULE_TERMINATE    FreeLibraries
#define MODULE_CLSIDS       rgCLSID         // array of CLSIDs for module objects
#define MODULE_PROGIDS      rgszProgId      // ProgId array for this module
#define MODULE_DESCRIPTIONS rgszDescription // Registry description of objects
#define MODULE_FACTORIES    rgFactory       // factory functions for each CLSID
#define IDISPATCH_INSTANCE  // can return IDispatch from factory
#define REGISTER_TYPELIB    GUID_LIBID_MsiAuto  // type library to register from resource
#define TYPELIB_MAJOR_VERSION 1
#define TYPELIB_MINOR_VERSION 0
#include "module.h"   // self-reg and assert functions
#include "engine.h"   // to allow release of object pointers

// Asserts are not being used in this module, so we don't #define ASSERT_HANDLING

const GUID IID_IMsiEngine               = GUID_IID_IMsiEngine;
const GUID IID_IMsiHandler              = GUID_IID_IMsiHandler;
const GUID IID_IMsiConfigurationManager = GUID_IID_IMsiConfigurationManager;

#if defined(DEBUG)
const GUID CLSID_IMsiServices             = GUID_IID_IMsiServicesDebug;
const GUID CLSID_IMsiEngine               = GUID_IID_IMsiEngineDebug;
const GUID CLSID_IMsiHandler              = GUID_IID_IMsiHandlerDebug;
const GUID CLSID_IMsiConfigurationManager = GUID_IID_IMsiConfigManagerDebug;
#else // SHIP
const GUID CLSID_IMsiServices             = GUID_IID_IMsiServices;
const GUID CLSID_IMsiEngine               = GUID_IID_IMsiEngine;
const GUID CLSID_IMsiHandler              = GUID_IID_IMsiHandler;
const GUID CLSID_IMsiConfigurationManager = GUID_IID_IMsiConfigurationManager;
#endif
const GUID CLSID_IMsiMessage              = GUID_IID_IMsiMessage;
const GUID CLSID_IMsiExecute              = GUID_IID_IMsiExecute;
#ifdef CONFIGDB
const GUID CLSID_IMsiConfigurationDatabase= GUID_IID_IMsiConfigurationDatabase;
#endif

//____________________________________________________________________________
//
// COM objects produced by this module's class factories
//____________________________________________________________________________

const GUID rgCLSID[CLSID_COUNT] =
{  GUID_IID_IMsiAuto
#ifdef DEBUG
 , GUID_IID_IMsiAutoDebug
#endif
};

const ICHAR* rgszProgId[CLSID_COUNT] =
{  SZ_PROGID_IMsiAuto
#ifdef DEBUG
 , SZ_PROGID_IMsiAutoDebug
#endif
};

const ICHAR* rgszDescription[CLSID_COUNT] =
{  SZ_DESC_IMsiAuto
#ifdef DEBUG
 , SZ_DESC_IMsiAutoDebug
#endif
};

IUnknown* CreateAutomation();

ModuleFactory rgFactory[CLSID_COUNT] = 
{ CreateAutomation
#ifdef DEBUG
 , CreateAutomation
#endif
};

//____________________________________________________________________________
//
// Enumerated constants
//____________________________________________________________________________

/*O

typedef [helpcontext(50),helpstring("Installer enumerations")] enum
{
	// expanded to enumerate all opcodes, must be first definition in this enum
	#define MSIXO(op, type, args) [helpcontext(Operation_ixo##op), helpstring(#op)] ixo##op,
	#include "opcodes.h"

	[helpcontext(MsiData_Object),    helpstring("IMsiData interface")]     iidMsiData     = 0xC1001,
	[helpcontext(MsiString_Object),  helpstring("IMsiString interface")]   iidMsiString   = 0xC1002,
	[helpcontext(MsiRecord_Object),  helpstring("IMsiRecord interface")]   iidMsiRecord   = 0xC1003,
	[helpcontext(MsiVolume_Object),  helpstring("IMsiVolume interface")]   iidMsiVolume   = 0xC1004,
	[helpcontext(MsiPath_Object),    helpstring("IMsiPath interface")]     iidMsiPath     = 0xC1005,
	[helpcontext(MsiFileCopy_Object),helpstring("IMsiFileCopy interface")] iidMsiFileCopy = 0xC1006,
	[helpcontext(MsiRegKey_Object),  helpstring("IMsiRegKey interface")]   iidMsiRegKey   = 0xC1007,
	[helpcontext(MsiTable_Object),   helpstring("IMsiTable interface")]    iidMsiTable    = 0xC1008,
	[helpcontext(MsiCursor_Object),  helpstring("IMsiCursor interface")]   iidMsiCursor   = 0xC1009,
	[helpcontext(MsiAuto_Object),    helpstring("IMsiAuto interface")]     iidMsiAuto     = 0xC100A,
	[helpcontext(MsiServices_Object),helpstring("IMsiServices interface")] iidMsiServices = 0xC100B,
	[helpcontext(MsiView_Object),    helpstring("IMsiView interface")]     iidMsiView     = 0xC100C,
	[helpcontext(MsiDatabase_Object),helpstring("IMsiDatabase interface")] iidMsiDatabase = 0xC100D,
	[helpcontext(MsiEngine_Object),  helpstring("IMsiEngine interface")]   iidMsiEngine   = 0xC100E,
	[helpcontext(MsiHandler_Object), helpstring("IMsiHandler interface")]  iidMsiHandler  = 0xC100F,
	[helpcontext(MsiDialog_Object),  helpstring("IMsiDialog interface")]   iidMsiDialog   = 0xC1010,
	[helpcontext(MsiEvent_Object),   helpstring("IMsiEvent interface")]    iidMsiEvent    = 0xC1011,
	[helpcontext(MsiControl_Object), helpstring("IMsiControl  interface")] iidMsiControl  = 0xC1012,
	[helpcontext(MsiDialogHandler_Object), helpstring("IMsiDialogHandler interface")] iidMsiDialogHandler = 0xC1013,
	[helpcontext(MsiStorage_Object), helpstring("IMsiStorage interface")]  iidMsiStorage  = 0xC1014,
	[helpcontext(MsiStream_Object),  helpstring("IMsiStream interface")]   iidMsiStream   = 0xC1015,
	[helpcontext(MsiSummaryInfo_Object), helpstring("IMsiSummaryInfo interface")] iidMsiSummaryInfo = 0xC1016,
	[helpcontext(MsiMalloc_Object),  helpstring("IMsiMalloc interface")]   iidMsiMalloc   = 0xC1017,
	[helpcontext(MsiSelectionManager_Object),  helpstring("IMsiSelectionManager interface")] iidMsiSelectionManager   = 0xC1018,
	[helpcontext(MsiDirectoryManager_Object),  helpstring("IMsiDirectoryManager interface")] iidMsiDirectoryManager   = 0xC1019,
	[helpcontext(MsiCostAdjuster_Object),  helpstring("IMsiCostAdjuster interface")] iidMsiCostAdjuster = 0xC101A,
	[helpcontext(MsiConfigurationManager_Object),  helpstring("IMsiConfigurationManager interface")] iidMsiConfigurationManager = 0xC101B,
	[helpcontext(MsiServer_Object),  helpstring("IMsiServer Automation interface")]   iidMsiServerAuto   = 0xC103F,
	[helpcontext(MsiMessage_Object), helpstring("IMsiMessage interface")]  iidMsiMessage  = 0xC101D,
	[helpcontext(MsiExecute_Object), helpstring("IMsiExecute interface")]  iidMsiExecute  = 0xC101E,
#ifdef CONFIGDB
	[helpcontext(MsiExecute_Object), helpstring("IMsiExecute interface")]  iidMsiExecute  = 0xC101E,
#endif

	[helpstring("0")]  idtUnknown   = 0,
	[helpstring("1")]  idtAllDrives = 1,
	[helpstring("2")]  idtRemovable = 2,
	[helpstring("3")]  idtFixed     = 3,
	[helpstring("4")]  idtRemote    = 4,
	[helpstring("5")]  idtCDROM     = 5,
	[helpstring("6")]  idtRAMDisk   = 6,
	[helpstring("2")]  idtFloppy   =  2,

	[helpcontext(MsiEngine_EvaluateCondition),helpstring("0, EvaluateCondition: Expression evaluates to False")]
		iecFalse = 0,
	[helpcontext(MsiEngine_EvaluateCondition),helpstring("1, EvaluateCondition: Expression evaluates to True")]
		iecTrue  = 1,
	[helpcontext(MsiEngine_EvaluateCondition),helpstring("2, EvaluateCondition: No expression is given")]
		iecNone  = 2,
	[helpcontext(MsiEngine_EvaluateCondition),helpstring("3, EvaluateCondition: Syntax error in expression")]
		iecError = 3,

	[helpcontext(MsiEngine_SetMode),helpstring("1, Engine Mode: admin mode install, else product install")]
		iefAdmin           = 1,
	[helpcontext(MsiEngine_SetMode),helpstring("2, Engine Mode: advertise mode of install")]
		iefAdvertise       = 2,
	[helpcontext(MsiEngine_SetMode),helpstring("4, Engine Mode: maintenance mode database loaded")]
		iefMaintenance     = 4, 
	[helpcontext(MsiEngine_SetMode),helpstring("8, Engine Mode: rollback is enabled")]	
		iefRollbackEnabled = 8,
	[helpcontext(MsiEngine_SetMode),helpstring("16, Engine Mode: install marked as in-progress and other installs locked out")]
		iefServerLocked    = 16,
	[helpcontext(MsiEngine_SetMode),helpstring("64, Engine Mode: executing or spooling operations")]
		iefOperations      = 64,
	[helpcontext(MsiEngine_SetMode),helpstring("128, Engine Mode: source LongFileNames suppressed via PID_MSISOURCE summary property")]
		iefNoSourceLFN     = 128,
	[helpcontext(MsiEngine_SetMode),helpstring("256, Engine Mode: log file active at start of Install()")]
		iefLogEnabled      = 256,
	[helpcontext(MsiEngine_SetMode),helpstring("512, Engine Mode: reboot is needed")]
		iefReboot          = 512, 
	[helpcontext(MsiEngine_SetMode),helpstring("1024, Engine Mode: target LongFileNames suppressed via SHORTFILENAMES property")]
		iefSuppressLFN     = 1024,
	[helpcontext(MsiEngine_SetMode),helpstring("2048, Engine Mode: installing files from cabinets and files using Media table")]
		iefCabinet         = 2048,
	[helpcontext(MsiEngine_SetMode),helpstring("4096, Engine Mode: add files in use to FilesInUse table")]
		iefCompileFilesInUse = 4096,
	[helpcontext(MsiEngine_SetMode),helpstring("8192, Engine Mode: operating systems is Windows95, not Windows NT")]
	  iefWindows         = 8192,
	[helpcontext(MsiEngine_SetMode),helpstring("16384, Engine Mode: reboot is needed to continue installation")]
		iefRebootNow       = 16384,
	[helpcontext(MsiEngine_SetMode),helpstring("32768, Engine Mode:  operating system supports the new GPT stuff")]
		iefGPTSupport      = 32768,

	[helpcontext(MsiFileCopy_CopyTo),helpstring("1")] ictoSourceName     = 1,
	[helpcontext(MsiFileCopy_CopyTo),helpstring("2")] ictoDestName       = 2,
	[helpcontext(MsiFileCopy_CopyTo),helpstring("3")] ictoAttributes     = 3,
	[helpcontext(MsiFileCopy_CopyTo),helpstring("4")] ictoMacFileType    = 4,
	[helpcontext(MsiFileCopy_CopyTo),helpstring("5")] ictoMacCreator     = 5,
	[helpcontext(MsiFileCopy_CopyTo),helpstring("6")] ictoMacFinderFlags = 6,
  
	[helpcontext(MsiPath_CheckFileVersion),helpstring("0")]  icfvNoExistingFile  = 0,
	[helpcontext(MsiPath_CheckFileVersion),helpstring("1")]  icfvExistingLower   = 1,
	[helpcontext(MsiPath_CheckFileVersion),helpstring("2")]  icfvExistingEqual   = 2,
	[helpcontext(MsiPath_CheckFileVersion),helpstring("3")]  icfvExistingHigher  = 3,
	[helpcontext(MsiPath_CheckFileVersion),helpstring("4")]  icfvVersStringError = 4,

	[helpcontext(MsiPath_Compare),helpstring("0")]  ipcEqual       = 0,
	[helpcontext(MsiPath_Compare),helpstring("1")]  ipcChild       = 1,
	[helpcontext(MsiPath_Compare),helpstring("2")]  ipcParent      = 2,
	[helpcontext(MsiPath_Compare),helpstring("3")]  ipcNoRelation  = 3,

	[helpcontext(MsiPath_GetFileAttribute),helpstring("0")]  ifaArchive    = 0,
	[helpcontext(MsiPath_GetFileAttribute),helpstring("1")]  ifaDirectory  = 1,
	[helpcontext(MsiPath_GetFileAttribute),helpstring("2")]  ifaHidden     = 2,
	[helpcontext(MsiPath_GetFileAttribute),helpstring("3")]  ifaNormal     = 3,
	[helpcontext(MsiPath_GetFileAttribute),helpstring("4")]  ifaReadOnly   = 4,
	[helpcontext(MsiPath_GetFileAttribute),helpstring("5")]  ifaSystem     = 5,
	[helpcontext(MsiPath_GetFileAttribute),helpstring("6")]  ifaTemp       = 6,
	[helpcontext(MsiPath_GetFileAttribute),helpstring("7")]  ifaCompressed = 7,

	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("0")]  iclExistNoFile    = 0,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("1")]  iclExistNoLang    = 1,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("2")]  iclExistSubset    = 2,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("3")]  iclExistEqual     = 3,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("4")]  iclExistIntersect = 4,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("5")]  iclExistSuperset  = 5,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("6")]  iclExistNullSet   = 6,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("7")]  iclExistLangNeutral = 7,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("8")]  iclNewLangNeutral   = 8,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("9")]  iclExistLangSetError = 9,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("10")] iclNewLangSetError   = 10,
	[helpcontext(MsiPath_CheckLanguageIDs),helpstring("11")] iclLangStringError = 11,

	[helpcontext(MsiServices_CreateCopier),helpstring("0")] ictFileCopier          = 0,
	[helpcontext(MsiServices_CreateCopier),helpstring("1")] ictFileCabinetCopier   = 1,
	[helpcontext(MsiServices_CreateCopier),helpstring("2")] ictStreamCabinetCopier = 2,

	[helpcontext(MsiFilePatch_CanPatchFile),helpstring("0, Can patch file.")]  icpCanPatch       = 0,
	[helpcontext(MsiFilePatch_CanPatchFile),helpstring("1, Cannot patch file.")]  icpCannotPatch    = 1,
	[helpcontext(MsiFilePatch_CanPatchFile),helpstring("2, Patch unecessary, file up to date.")]  icpUpToDate       = 2,

	[helpcontext(MsiString_Extract),helpstring("0, Extract mode: First n characters")]
		iseFirst     = 0,
	[helpcontext(MsiString_Extract),helpstring("2, Extract mode: Up to character n")]
		iseUpto      = 2,
	[helpcontext(MsiString_Extract),helpstring("3, Extract mode: Up to and including character n")]
		iseIncluding = 2+1,
	[helpcontext(MsiString_Extract),helpstring("4, Extract mode: Last n characters")]
		iseLast      = 4,
	[helpcontext(MsiString_Extract),helpstring("6, Extract mode: After last character n")]
		iseAfter     = 2+4,
	[helpcontext(MsiString_Extract),helpstring("7, Extract mode: From last character n")]
		iseFrom      = 2+1+4,
	[helpcontext(MsiString_Extract),helpstring("8, Extract mode: First n characters, trim leading and trailing white space")]
		iseFirstTrim = 0+8,
	[helpcontext(MsiString_Extract),helpstring("10, Extract mode: Up to character n, trim leading and trailing white space")]
		iseUptoTrim  = 2+8,
	[helpcontext(MsiString_Extract),helpstring("11, Extract mode: Up to and including character n, trim leading and trailing white space")]
		iseIncludingTrim  = 2+1+8,
	[helpcontext(MsiString_Extract),helpstring("12, Extract mode: First n characters, trim leading and trailing white space")]
		iseLastTrim  = 4+8,
	[helpcontext(MsiString_Extract),helpstring("14, Extract mode: After character n, trim leading and trailing white space")]
		iseAfterTrim = 2+4+8,
	[helpcontext(MsiString_Extract),helpstring("15, Extract mode: From character n, trim leading and trailing white space")]
		iseFromTrim  = 2+1+4+8,

	[helpcontext(MsiString_Compare),helpstring("0, Compare mode: Entire string, case-sensitive")]
		iscExact  = 0,
	[helpcontext(MsiString_Compare),helpstring("1, Compare mode: Entire string, case-insensitive")]
		iscExactI = 1,
	[helpcontext(MsiString_Compare),helpstring("2, Compare mode: Match at start, case-sensitive")]
		iscStart  = 2,
	[helpcontext(MsiString_Compare),helpstring("3, Compare mode: Match at start, case-insensitive")]
		iscStartI = 3,
	[helpcontext(MsiString_Compare),helpstring("4, Compare mode: Match at end, case-sensitive")]
		iscEnd    = 4,
	[helpcontext(MsiString_Compare),helpstring("5, Compare mode: Match at end, case-insensitive")]
		iscEndI   = 5,
	[helpcontext(MsiString_Compare),helpstring("6, Compare mode: Match within, case-sensitive")]
		iscWithin = 2+4,
	[helpcontext(MsiString_Compare),helpstring("7, Compare mode: Match within, case-insensitive")]
		iscWithinI= 2+4+1,

  	[helpcontext(MsiServices_WriteIniFile),helpstring("0, write .INI file mode: Creates/Updates .INI entry")]
		iifIniAddLine = 0,
  	[helpcontext(MsiServices_WriteIniFile),helpstring("1, write .INI file mode: Creates .INI entry only if absent")]
		iifIniCreateLine = 1,
  	[helpcontext(MsiServices_WriteIniFile),helpstring("2, write .INI file mode: Deletes .INI entry")]
		iifIniRemoveLine = 2,
  	[helpcontext(MsiServices_WriteIniFile),helpstring("3, write .INI file mode: Creates/ Appends a new tag to a .INI entry")]
		iifIniAddTag = 3,
  	[helpcontext(MsiServices_WriteIniFile),helpstring("4, write .INI file mode: Deletes a tag from a .INI entry")]
		iifIniRemoveTag = 4,


	[helpcontext(MsiCursor_IntegerData),helpstring("Null integer value for MsiCursor data")]
		iMsiNullInteger  = 0x80000000,
	[helpcontext(MsiCursor_StringData),helpstring("Null string value for IMsiCursor data")]
		iMsiNullStringIndex = 0,
	[helpcontext(MsiTable_Object),helpstring("MsiTable: Maximum number of columns in a table")]
		iMsiMaxTableColumns = 32,

	[helpcontext(MsiDatabase_OpenView),helpstring("0, OpenView intent: No data access")]
		ivcNoData = 0,
	[helpcontext(MsiDatabase_OpenView),helpstring("1, OpenView intent: Fetch rows")]
		ivcFetch  = 1,
	[helpcontext(MsiDatabase_OpenView),helpstring("2, OpenView intent: Update rows")]
		ivcUpdate = 2,
	[helpcontext(MsiDatabase_OpenView),helpstring("4, OpenView intent: Insert rows")]
		ivcInsert = 4,
	[helpcontext(MsiDatabase_OpenView),helpstring("8, OpenView intent: Delete rows")]
		ivcDelete = 8,

	[helpcontext(MsiDatabase_UpdateState),helpstring("UpdateState: database open read-only, changes are not saved")]
		idsRead     = 0,
	[helpcontext(MsiDatabase_UpdateState),helpstring("UpdateState: database fully operational for read and write")]
		idsWrite    = 1,

	[helpcontext(MsiView_Modify),helpstring("MsiView.Modify action: refresh fetched data in current record")]
		irmRefresh = 0,
	[helpcontext(MsiView_Modify),helpstring("MsiView.Modify action: insert new record, fails if matching key exists")]
		irmInsert  = 1,
	[helpcontext(MsiView_Modify),helpstring("MsiView.Modify action: update existing non-key data of fetched record")]
		irmUpdate  = 2,
	[helpcontext(MsiView_Modify),helpstring("MsiView.Modify action: insert record, replacing any existing record")]
		irmAssign  = 3,
	[helpcontext(MsiView_Modify),helpstring("MsiView.Modify action: modify record, delete old if primary key edit")]
		irmReplace = 4,
	[helpcontext(MsiView_Modify),helpstring("MsiView.Modify action: fails if record with duplicate key not identical")]
		irmMerge   = 5,
	[helpcontext(MsiView_Modify),helpstring("MsiView.Modify action: remove row referenced by this record from table")]
		irmDelete  = 6,
	[helpcontext(MsiView_Modify), helpstring("MsiView.Modify action: insert temporary record")]
		irmInsertTemporary = 7,
	[helpcontext(MsiView_Modify), helpstring("MsiView.Modify action: validate a fetched record")]
		irmValidate = 8,
	[helpcontext(MsiView_Modify), helpstring("MsiView.Modify action: validate a new record")]
		irmValidateNew = 9,
	[helpcontext(MsiView_Modify), helpstring("MsiView.Modify action: validate a field(s) for incomplete query record")]
		irmValidateField = 10,
	[helpcontext(MsiView_Modify), helpstring("MsiView.Modify action: validate a fetched record before delete")]
		irmValidateDelete = 11,

	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: no error")]
		iveNoError = 0,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Duplicate Primary Key")]
		iveDuplicateKey = 1,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Not a nullable column")]
		iveRequired = 2,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Not a valid foreign key")]
		iveBadLink = 3,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Value exceeds MaxValue")]
		iveOverFlow = 4,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Value below MinValue")]
		iveUnderFlow = 5,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Value not a member of set")]
		iveNotInSet = 6,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid version string")]
		iveBadVersion = 7,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid case, must be all upper or all lower case")]
		iveBadCase = 8,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid GUID")]
		iveBadGuid = 9,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid wildcard or wildcard usage")]
		iveBadWildCard = 10,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid identifier")]
		iveBadIdentifier = 11,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid LangID")]
		iveBadLanguage = 12,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid filename")]
		iveBadFilename = 13,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid path")]
		iveBadPath = 14,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Bad condition string")]
		iveBadCondition = 15,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid format string")]
		iveBadFormatted = 16,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid template string")]
		iveBadTemplate = 17,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid DefaultDir string")]
		iveBadDefaultDir = 18,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid registry path")]
		iveBadRegPath = 19,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid CustomSource string")]
		iveBadCustomSource = 20,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid Property string")]
		iveBadProperty = 21,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: _Validation table doesn't have entry for column")]
		iveMissingData = 22,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Category string listed in _Validation table is not supported")]
		iveBadCategory = 23,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Table in KeyTable of _Validation table could not be found/loaded")]
		iveBadKeyTable = 24,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: value in MaxValue col of _Validation table is smaller than MinValue col value")]
		iveBadMaxMinValues = 25,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid Cabinet string")]
		iveBadCabinet = 26,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Invalid Shortcut Target string")]
		iveBadShortcut = 27,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: String Greater Than Length Allowed By Column Def")]
		iveStringOverflow = 28,
	[helpcontext(MsiView_GetError),helpstring("MsiView.GetError return value: Primary Keys Cannot Be Set To Be Localized")]
		iveBadLocalizeAttrib = 29,

	[helpcontext(MsiCursor_RowState),helpstring("RowState: persistent attribute for external use")]
		iraUserInfo     = 0,   
	[helpcontext(MsiCursor_RowState),helpstring("RowState: row will not normally be persisted if state is set")]
		iraTemporary    = 1,
	[helpcontext(MsiCursor_RowState),helpstring("RowState: row has been updated if set (not settable)")]
		iraModified     = 2,
	[helpcontext(MsiCursor_RowState),helpstring("RowState: row has been inserted (not settable)")]
		iraInserted     = 3,
	[helpcontext(MsiCursor_RowState),helpstring("RowState: attempt to merge with non-identical non-key data (not settable)")]
		iraMergeFailed  = 4,
	[helpcontext(MsiCursor_RowState),helpstring("RowState: row is not accessible until lock is released (not settable)")]
		iraLocked       = 7,

	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: table has persistent columns")]
		itsPermanent   = 0,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: temporary table, no persistent columns")]
		itsTemporary   = 1,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: table currently defined in system catalog")]
		itsTableExists = 2,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: table currently present in memory")]
		itsDataLoaded  = 3,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: user state flag reset, not used internally")]
		itsUserClear   = 4,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: user state flag set, not used internally")]
		itsUserSet     = 5,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: table has been transferred to output database")]
		itsOutputDb    = 6,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: unable to write table to database")]
		itsSaveError   = 7,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: table is not locked in memory")]
		itsUnlockTable = 8,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: table is locked in memory")]
		itsLockTable   = 9,
	[helpcontext(MsiDatabase_TableState),helpstring("GetTableState: table needs to be transformed when loaded")]
		itsTransform   = 10,

	[helpcontext(MsiDatabase_FindTable),helpstring("FindTable: Named table is not in database")]
		itsUnknown = 0,
//	[helpcontext(MsiDatabase_FindTable),helpstring("FindTable: table is temporary, not persistent")]
//		itsTemporary = 1,
	[helpcontext(MsiDatabase_FindTable),helpstring("FindTable: table exists in database, not loaded")]
		itsUnloaded = 2,
	[helpcontext(MsiDatabase_FindTable),helpstring("FindTable: table is loaded into memory")]
		itsLoaded = 3,
	[helpcontext(MsiDatabase_FindTable),helpstring("FindTable: table has been transferred to output database")]
		itsOutput = 6,
//	[helpcontext(MsiDatabase_FindTable),helpstring("FindTable: unable to write table to database")]
//		itsSaveError = 7,
//	[helpcontext(MsiDatabase_FindTable),helpstring("FindTable: table needs to have transform applied")]
//		itsTransform = 10,

	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: no errors suppressed")]
		iteNone = 0,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: suppress error: adding row that exists")]
		iteAddExistingRow = 1,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: suppress error: deleting row that doesn't exist")]
		iteDelNonExistingRow = 2,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: suppress error: adding table that exists")]
		iteAddExistingTable = 4,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: suppress error: deleting table that doesn't exist")]
		iteDelNonExistingTable = 8,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: suppress error: modifying a row that doesn't exist")]
		iteUpdNonExistingRow = 16,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: suppress error: changing the code page of a database")]
		iteChangeCodePage =    32,


   [helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: no validation")]
		itvNone = 0,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: transform language matches datbase default language")]
		itvLanguage = 1,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: transform product matches database product")]
		itvProduct = 2,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: transform platform matches database product")]
		itvPlatform = 4,
   [helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: use major version")]
		itvMajVer = 8,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: use minor version")]
		itvMinVer = 16,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: use update version")]
		itvUpdVer = 32,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: database version < transform version")]
		itvLess = 64,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: database version <= transform version")]
		itvLessOrEqual = 128,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: database version = transform version")]
		itvEqual = 256,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: database version >= transform version")]
		itvGreaterOrEqual = 512,
	[helpcontext(MsiDatabase_SetTransform),helpstring("SetTransform: validation: database version > transform version")]
		itvGreater = 1024,

	[helpcontext(MsiTable_ColumnType),helpstring("ColumnType: Column does not exist")]
		icdUndefined = -1,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn dataType: 32-bit integer, OBSOLETE")]
		icdInteger = 0,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn dataType: 32-bit integer")]
		icdLong    = 0x000,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn dataType: 16-bit integer")]
		icdShort   = 0x400,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn dataType: MsiData object or MsiStream")]
		icdObject  = 0x800,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn dataType: Database string index")]
		icdString  = 0xC00,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn columnType: Column will accept null values")]
		icdNullable = 0x1000,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn columnType: Column is component of primary key")]
		icdPrimaryKey = 0x2000,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn columnType: Column will not accept null values")]
		icdNoNulls = 0x0000,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn columnType: Column is saved in persistent database")]
		icdPersistent = 0x0100,
	[helpcontext(MsiTable_CreateColumn),helpstring("CreateColumn columnType: Column is temporary, in-memory only")]
		icdTemporary = 0x0000,
	[helpcontext(MsiTable_ColumnType),helpstring("ColumnType: for isolating the SQL column size from the column defintion")]
		icdSizeMask = 0x00FF,

	[helpcontext(MsiServices_CreateStorage),helpstring("CreateStorage: Read-only")]
		ismReadOnly = 0,
	[helpcontext(MsiServices_CreateStorage),helpstring("CreateStorage: Transacted mode, can rollback")]
		ismTransact = 1,
	[helpcontext(MsiServices_CreateStorage),helpstring("CreateStorage: Direct write, not transacted")]
		ismDirect   = 2,
	[helpcontext(MsiServices_CreateStorage),helpstring("CreateStorage: Create new storage file, transacted mode")]
		ismCreate   = 3,
	[helpcontext(MsiServices_CreateStorage),helpstring("CreateStorage: Create new storage file, direct mode")]
		ismCreateDirect = 4,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Uncompressed stream names (for downlevel compatibility)")]
		ismRawStreamNames = 16,

	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Read-only")]
		idoReadOnly = 0,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Transacted mode, can rollback")]
		idoTransact = 1,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Direct write, not transacted")]
		idoDirect   = 2,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Create new storage file, transacted mode")]
		idoCreate   = 3,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Create new storage file, direct mode")]
		idoCreateDirect = 4,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Opens an execution script for enumeration")]
		idoListScript = 5,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Uncompressed stream names (for downlevel compatibility)")]
		idoRawStreamNames = 16,
	[helpcontext(MsiServices_CreateDatabase),helpstring("CreateDatabase: Patch file, using different CLSID")]
		idoPatchFile = 32,

	[helpcontext(MsiServices_SupportLanguageId),helpstring("System doesn't support language")]
		isliNotSupported = 0,
	[helpcontext(MsiServices_SupportLanguageId),helpstring("Base language differs from current language")]
		isliLanguageMismatch = 1,
	[helpcontext(MsiServices_SupportLanguageId),helpstring("Base language matches, but dialect mismatched")]
		isliDialectMismatch = 2,
	[helpcontext(MsiServices_SupportLanguageId),helpstring("Base language matches, no dialect supplied")]
		isliLanguageOnlyMatch = 3,
	[helpcontext(MsiServices_SupportLanguageId),helpstring("Exact match, both language and dialect")]
		isliExactMatch = 4,

	[helpcontext(MsiHandler_Message),helpstring("MessageType: OBSOLETE - use imtFatalExit")]
		imtOutOfMemory = 0x00000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: fatal error, hang or out of memory")]
		imtFatalExit   = 0x00000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: error message,   [1] is error code")]
		imtError      =  0x01000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: warning message, [1] is error code, not fatal")]
		imtWarning    =  0x02000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: user request message")]
		imtUser       =  0x03000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: informative message, no action should be taken")]
		imtInfo       =  0x04000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: list of files in use that need to be replaced")]
		imtFilesInUse =  0x05000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: request to determine a valid source location")]
		imtResolveSource=0x06000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: out of disk space")]
		imtOutOfDiskSpace = 0x07000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: start of action, [1] action name, [2] description")]
		imtActionStart = 0x08000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: data associated with individual action item")]
		imtActionData  = 0x09000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: progress gauge info, [1] units so far, [2] total")]
		imtProgress    = 0x0A000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: UI control message")]
		imtCommonData =  0x0B000000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: Ok button")]
		imtOk               = 0,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: Ok, Cancel buttons")]
		imtOkCancel         = 1,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: Abort, Retry, Ignore buttons")]
		imtAbortRetryIgnore = 2,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: Yes, No, Cancel buttons")]
		imtYesNoCancel      = 3,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: Yes, No buttons")]
		imtYesNo            = 4,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: Retry, Cancel buttons")]
		imtRetryCancel      = 5,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: first button is default")]
		imtDefault1     = 0x000,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: second button is default")]
		imtDefault2     = 0x100,
	[helpcontext(MsiHandler_Message),helpstring("MessageType: third button is default")]
		imtDefault3     = 0x200,

	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: error occurred")]
		imsError  =  -1,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: no action taken")]
		imsNone   =  0,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: IDOK")]
		imsOk     =  1,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: IDCANCEL")]
		imsCancel =  2,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: IDABORT")]
  		imsAbort  =  3,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: IDRETRY")]
		imsRetry  =  4,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: IDIGNORE")]
		imsIgnore =  5,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: IDYES")]
		imsYes    =  6,
	[helpcontext(MsiHandler_Message),helpstring("Message Return Status: IDNO")]
		imsNo     =  7,

	[helpcontext(MsiMalloc_SetDebugFlags),helpstring("No memory debugging information")]  
		idbgmemNone   = 0,
	[helpcontext(MsiMalloc_SetDebugFlags),helpstring("Don't reuse freed blocks.")]
		idbgmemKeepMem = 1,
	[helpcontext(MsiMalloc_SetDebugFlags),helpstring("Log all allocations")]
		idbgmemLogAllocs = 2,
	[helpcontext(MsiMalloc_SetDebugFlags),helpstring("Check all blocks for corruption on each allocation.")]
		idbgmemCheckOnAlloc = 4,
	[helpcontext(MsiMalloc_SetDebugFlags),helpstring("Check all blocks for corruption on each Free.")]
		idbgmemCheckOnFree = 8,

	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: action not invoked")]
		iesNoAction       = 0,
	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: IDOK, completed actions successfully")]
		iesSuccess        = 1,
	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: IDCANCEL, user terminated prematurely, resume with next action")]
		iesUserExit       = 2,
	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: IDABORT, unrecoverable error occurred")]
		iesFailure        = 3,
	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: IDRETRY, sequence suspended, resume with same action")]
		iesSuspend        = 4,
	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: IDIGNORE, skip remaining actions")]
		iesFinished       = 5,
	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: calling sequence error, not in executable state")]
		iesWrongState     = 6,
	[helpcontext(MsiEngine_DoAction),helpstring("DoAction return status: invalid Action table record data")]
		iesBadActionData  = 7,

	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  initialization complete")]
		ieiSuccess             =  0,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  this engine object is already initialized")]
		ieiAlreadyInitialized  =  2,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  invalid command line syntax")]
		ieiCommandLineOption   =  3,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  an installation is already in progress")]
		ieiInstallInProgress   =  4,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  database could not be opened")]
		ieiDatabaseOpenFailed  =  5,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  incompatible database")]
		ieiDatabaseInvalid     =  6,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  installer version does not support database format")]
		ieiInstallerVersion    =  7,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  could not resolve source")]
		ieiSourceAbsent        =  8,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  could not initialize handler interface")]
		ieiHandlerInitFailed   = 10,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  could not open logfile in requested mode")]
		ieiLogOpenFailure      = 11,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  no acceptable language could be found")]
		ieiLanguageUnsupported = 12,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  no acceptable platform could be found")]
		ieiPlatformUnsupported = 13,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  database transform failed to merge")]
		ieiTransformFailed     = 14,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  digital signature rejected.")]
		ieiSignatureRejected   = 15,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  could not copy database to temp dir.")]
		ieiDatabaseCopyFailed   = 16,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  could not open patch package.")]
		ieiPatchPackageOpenFailed   = 17,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  patch package invalid.")]
		ieiPatchPackageInvalid   = 18,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  transform file not found.")]
		ieiTransformNotFound     = 19,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  patch package unsupported.")]
		ieiPatchPackageUnsupported   = 20,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  package rejected.")]
		ieiPackageRejected    = 21,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  product unknown.")]
		ieiProductUnknown     = 22,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  different user after reboot.")]
		ieiDiffUserAfterReboot = 23,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  product has been installed already w/ a different package")]
		ieiProductAlreadyInstalled = 24,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  can't do installations from a remote session on Hydra")]
		ieiTSRemoteInstallDisallowed = 25,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize Return Status:  patch cannot be applied to this product")]
		ieiNotValidPatchTarget = 26,



	[helpcontext(MsiEngine_Initialize),helpstring("Initialize UI Level: default, full interactive UI")]
		iuiFull    = 0,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize UI Level: progress and errors, no modeless dialogs (wizards)")]
		iuiReduced = 1,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize UI Level: progress and errors using engine default handler")]
		iuiBasic   = 2,
	[helpcontext(MsiEngine_Initialize),helpstring("Initialize UI Level: no UI")]
		iuiNone    = 3,

	[helpcontext(MsiConfigurationManager_RegisterComponent),helpstring("RegisterComponent: minimum version")]
		icmrcfMinVersion    = 1,
	[helpcontext(MsiConfigurationManager_RegisterComponent),helpstring("RegisterComponent: version")]	
	   icmrcfVersion       = 2,
	[helpcontext(MsiConfigurationManager_RegisterComponent),helpstring("RegisterComponent: registry key")]	
	   icmrcfRegKey        = 3,
	[helpcontext(MsiConfigurationManager_RegisterComponent),helpstring("RegisterComponent: cost")]	
	   icmrcfCost          = 4,
	[helpcontext(MsiConfigurationManager_RegisterComponent),helpstring("RegisterComponent: File")]	
	   icmrcfFile          = 5,

} Constants;

*/

//____________________________________________________________________________
//
// MsiAuto definitions
//____________________________________________________________________________

class CAutoInstall : public CAutoBase
{
 public:
	CAutoInstall();
	~CAutoInstall();
	IUnknown& GetInterface();
	void CreateServices(CAutoArgs& args);
	void CreateEngine(CAutoArgs& args);
	void CreateHandler(CAutoArgs& args);
	void CreateMessageHandler(CAutoArgs& args);
	void CreateConfigurationManager(CAutoArgs& args);
	void CreateExecutor(CAutoArgs& args);
#ifdef CONFIGDB
	void CreateConfigurationDatabase(CAutoArgs& args);
#endif
	void OpcodeName(CAutoArgs& args);
	void ShowAsserts(CAutoArgs& args);
	void SetDBCSSimulation(CAutoArgs& args);
	void AssertNoObjects(CAutoArgs& args);
	void SetRefTracking(CAutoArgs& args);
 private:
	IMsiServices* m_piServices;
	IMsiEngine*   m_piEngine;
	IMsiHandler*  m_piHandler;
};

//____________________________________________________________________________
//
// External DLL management
//____________________________________________________________________________

struct LibLink
{
	LibLink*  pNext;
	HDLLINSTANCE hInst;
};

static LibLink* qLibLink = 0;

HDLLINSTANCE GetLibrary(const ICHAR* szLibrary)
{
	HDLLINSTANCE hInst;
	hInst = WIN::LoadLibraryEx(szLibrary,0, LOAD_WITH_ALTERED_SEARCH_PATH);
	if (hInst == 0)
	{
		ICHAR rgchBuf[MAX_PATH];
		int cchName = WIN::GetModuleFileName(g_hInstance, rgchBuf, (sizeof(rgchBuf)/sizeof(ICHAR))-1);
		rgchBuf[(sizeof(rgchBuf)/sizeof(ICHAR))-1] = 0;
		ICHAR* pch = rgchBuf + cchName;
		while (*(--pch) != chDirSep)
			;
		StringCchCopy(pch+1, MAX_PATH - (pch+1 - rgchBuf), szLibrary);
		hInst = WIN::LoadLibraryEx(rgchBuf,0, LOAD_WITH_ALTERED_SEARCH_PATH);
		if (hInst == 0)
			return 0;
	}
	for (LibLink* pLink = qLibLink; pLink; pLink = pLink->pNext)
	{
		if (hInst == pLink->hInst)
		{
			WIN::FreeLibrary(hInst);
			return pLink->hInst;
		}
	}
	pLink = new LibLink;
	if ( ! pLink )
	{
		WIN::FreeLibrary(hInst);
		return 0;
	}
	pLink->pNext = qLibLink;
	pLink->hInst = hInst;
	qLibLink = pLink;
	return hInst;
}

void FreeLibraries()
{
	while (qLibLink)
	{
		LibLink* pLink = qLibLink;
		// should we call DllCanUnloadNow() on each DLL first?
		WIN::FreeLibrary(pLink->hInst);
		qLibLink = pLink->pNext;
		delete pLink;
	}
}

IUnknown& LoadObject(const ICHAR* szModule, const IID& riid)
{
	PDllGetClassObject fpFactory;
	IClassFactory* piClassFactory;
	IUnknown* piUnknown;
	HRESULT hrStat;
	HDLLINSTANCE hInst;
	if (!szModule || !szModule[0])  // no explicit path, use OLE to load the registered instance
	{
		IUnknown* piInstance;
		if (OLE::CoCreateInstance(riid, 0, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&piInstance) == NOERROR)
		{
			hrStat = piInstance->QueryInterface(riid, (void**)&piUnknown);
			piInstance->Release();
			if (hrStat == NOERROR)
				return *piUnknown;
		}
		throw axCreationFailed;
	}
	if ((hInst = AUT::GetLibrary(szModule)) == 0)
		throw axCreationFailed;
	fpFactory = (PDllGetClassObject)WIN::GetProcAddress(hInst, SzDllGetClassObject);
	if (!fpFactory)
		throw axCreationFailed;
	hrStat = (*fpFactory)(riid, IID_IClassFactory, (void**)&piClassFactory);
	if (hrStat != NOERROR)
		throw axCreationFailed;
	hrStat = piClassFactory->CreateInstance(0, riid, (void**)&piUnknown);
	piClassFactory->Release();
	if (hrStat != NOERROR)
		throw axCreationFailed;
	return *piUnknown;  // returns ownership of reference count
}

//____________________________________________________________________________
//
// CAutoInstall automation implementation
//____________________________________________________________________________

/*O
	[
		uuid(000C1060-0000-0000-C000-000000000046),  // IID_IMsiAuto
		helpcontext(MsiAuto_Object),helpstring("Automation object.")
	]
	dispinterface MsiAuto
	{
		properties:
		methods:
			[id(1),helpcontext(MsiAuto_CreateServices),helpstring("Loads the services library and creates an MsiServices object")]
					MsiServices* CreateServices([in] BSTR dll);
			[id(2),helpcontext(MsiAuto_CreateEngine),helpstring("Loads the engine library and creates an MsiEngine object")]
					MsiEngine* CreateEngine([in] BSTR dll);
			[id(3),helpcontext(MsiAuto_CreateHandler),helpstring("Loads the message handler library and creates an MsiHandler object")]
					MsiHandler* CreateHandler([in] BSTR dll);
			[id(4),helpcontext(MsiAuto_CreateMessageHandler),helpstring("Creates a simple MsiMessage object")]
					MsiMessage* CreateMessageHandler([in] BSTR dll);
			[id(5),helpcontext(MsiAuto_CreateConfigurationManager),helpstring("Loads the configuration manager and creates an MsiConfigurationManager object")]
					MsiConfigurationManager* CreateConfigurationManager([in] BSTR dll);
			[id(6),propget, helpcontext(MsiAuto_OpcodeName), helpstring("Return enumeration name for numeric opcode")]
					BSTR OpcodeName([in] int opcode);
			[id(7),helpcontext(MsiAuto_ShowAsserts),helpstring("In debug componente, sets asserts to show or not.")]
				    void ShowAsserts([in] long fShowAsserts);
			[id(8),helpcontext(MsiAuto_SetDBCSSimulation),helpstring("In debug services, enables DBCS using specified lead byte character.")]
				    void SetDBCSSimulation([in] int leadByte);
			[id(9),helpcontext(MsiAuto_AssertNoObjects),helpstring("In debug services, displays objects and ref count calls for those objects being tracked.")]
				    void AssertNoObjects();
			[id(10),helpcontext(MsiAuto_SetRefTracking),helpstring("In debug dlls, turns on reference count tracking for the given objects.")]
				    void SetRefTracking([in] long iid, [in] long fTrack);
			[id(11),helpcontext(MsiAuto_CreateExecutor),helpstring("Loads the engine library and creates an MsiExecute object")]
			       MsiExecute* CreateExecutor([in] BSTR dll);
#ifdef CONFIGDB
#define MsiAuto_CreateExecutor            1012
			[id(12),helpcontext(MsiAuto_CreateConfigurationDatabase),helpstring("Loads the engine library and creates an MsiConfigurationDatabase object")]
			       MsiExecute* CreateConfigurationDatabase([in] BSTR dll);
#endif
	};
*/

DispatchEntry<CAutoInstall> AutoInstallTable[] = {
	1, aafMethod, CAutoInstall::CreateServices,   TEXT("CreateServices,dll"),
	2, aafMethod, CAutoInstall::CreateEngine,     TEXT("CreateEngine,dll"),
	3, aafMethod, CAutoInstall::CreateHandler,    TEXT("CreateHandler,dll"),
	4, aafMethod, CAutoInstall::CreateMessageHandler,  TEXT("CreateMessageHandler,dll"),
	5, aafMethod, CAutoInstall::CreateConfigurationManager,  TEXT("CreateConfigurationManager,dll"),
	6, aafPropRO, CAutoInstall::OpcodeName,       TEXT("OpcodeName,opcode"),
	7, aafMethod, CAutoInstall::ShowAsserts,      TEXT("ShowAsserts,fShowAsserts"),
	8, aafMethod, CAutoInstall::SetDBCSSimulation,TEXT("SetDBCSSimulation,leadByte"),
	9, aafMethod, CAutoInstall::AssertNoObjects,  TEXT("AssertNoObjects"),
	10,aafMethod, CAutoInstall::SetRefTracking,   TEXT("SetRefTracking,iid,fTrack"),
	11,aafMethod, CAutoInstall::CreateExecutor,   TEXT("CreateExecutor,dll"),
#ifdef CONFIGDB
	12,aafMethod, CAutoInstall::CreateConfigurationDatabase, TEXT("CreateConfigurationDatabase,dll"),
#endif
};
const int AutoInstallCount = sizeof(AutoInstallTable)/sizeof(DispatchEntryBase);

IUnknown* CreateAutomation()
{
	return new CAutoInstall();
}

CAutoInstall::CAutoInstall()
 : CAutoBase(*AutoInstallTable, AutoInstallCount),
	m_piServices(0), m_piEngine(0), m_piHandler(0)
{
	g_cInstances++;
}

CAutoInstall::~CAutoInstall()
{
	if (m_piEngine)
		m_piEngine->Release();
	if (m_piHandler)
		m_piHandler->Release();
	if (m_piServices)
	{
		m_piServices->ClearAllCaches();
		m_piServices->Release();
	}
	g_cInstances--;
}

IUnknown& CAutoInstall::GetInterface()
{
	return g_NullInterface;  // no installer interface available
}

void CAutoInstall::CreateServices(CAutoArgs& args)
{
	const ICHAR* szName;
	if (args.Present(1))
		szName = args[1];
	else
		szName = 0;
	if (m_piServices)
		m_piServices->Release();
	m_piServices = &(IMsiServices&)AUT::LoadObject(szName, CLSID_IMsiServices);
	m_piServices->AddRef();
	args = AUT::CreateAutoServices(*m_piServices);
//	InitializeAssert(m_piServices);
}

void CAutoInstall::CreateEngine(CAutoArgs& args)
{
	const ICHAR* szName;
	if (args.Present(1))
		szName = args[1];
	else
		szName = 0;
	if (m_piEngine)
		m_piEngine->Release();
	m_piEngine = &(IMsiEngine&)AUT::LoadObject(szName, CLSID_IMsiEngine);
	m_piEngine->AddRef();
	args = AUT::CreateAutoEngine(*m_piEngine);
}

void CAutoInstall::CreateExecutor(CAutoArgs& args)
{
	const ICHAR* szName;
	if (args.Present(1))
		szName = args[1];
	else
		szName = 0;
	IMsiExecute& riExecute = (IMsiExecute&)AUT::LoadObject(szName, CLSID_IMsiExecute);
	args = AUT::CreateAutoExecute(riExecute);
}

#ifdef CONFIGDB
class IMsiConfigurationDatabase;
IDispatch* CreateAutoConfigurationDatabase(IMsiConfigurationDatabase& riExecute); // in autosrv.cpp

void CAutoInstall::CreateConfigurationDatabase(CAutoArgs& args)
{
	const ICHAR* szName;
	if (args.Present(1))
		szName = args[1];
	else
		szName = 0;
	IMsiConfigurationDatabase& riConfigDatabase = (IMsiConfigurationDatabase&)AUT::LoadObject(szName, CLSID_IMsiConfigurationDatabase);
	args = AUT::CreateAutoConfigurationDatabase(riConfigDatabase);
}
#endif

void CAutoInstall::CreateHandler(CAutoArgs& args)
{
	const ICHAR* szName;
	if (args.Present(1))
		szName = args[1];
	else
		szName = 0;
	if (m_piHandler)
		m_piHandler->Release();
	m_piHandler = &(IMsiHandler&)AUT::LoadObject(szName, CLSID_IMsiHandler);
	m_piHandler->AddRef();
	args = AUT::CreateAutoHandler(*m_piHandler);
}

void CAutoInstall::CreateMessageHandler(CAutoArgs& args)
{
	const ICHAR* szName;
	if (args.Present(1))
		szName = args[1];
	else
		szName = 0;
	IMsiMessage& riMessage = (IMsiMessage&)AUT::LoadObject(szName, CLSID_IMsiMessage);
	args = AUT::CreateAutoMessage(riMessage);
}

void CAutoInstall::CreateConfigurationManager(CAutoArgs& args)
{
	const ICHAR* szName;
	if (args.Present(1))
		szName = args[1];
	else
		szName = 0;
// The following would be used if the ConfigurationManager is a separate module
//	if (m_piConfigurationManager)
//		m_piConfigurationManager->Release();
//	m_piConfigurationManager = &(IMsiConfigurationManager&)AUT::LoadObject(szName, IID_IMsiConfigurationManager);
//	m_piConfigurationManager->AddRef();
//	args = AUT::CreateAutoConfigurationManager(*m_piConfigurationManager);
	IMsiConfigurationManager* piConfigurationManager = &(IMsiConfigurationManager&)AUT::LoadObject(szName, CLSID_IMsiConfigurationManager);
	args = AUT::CreateAutoConfigurationManager(*piConfigurationManager);
}

void CAutoInstall::ShowAsserts(CAutoArgs& args)
{
	Bool fShowAsserts = Bool(args[1]) ? fFalse : fTrue;  // invert logic
	IMsiDebug *piDebug;

	if (m_piEngine)
	{
		if (m_piEngine->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			piDebug->SetAssertFlag(fShowAsserts);
			piDebug->Release();
		}
	}
	
	if (m_piServices)
	{
		if (m_piServices->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			piDebug->SetAssertFlag(fShowAsserts);
			piDebug->Release();
		}
	}

	if (m_piHandler)
	{
		if (m_piHandler->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			piDebug->SetAssertFlag(fShowAsserts);
			piDebug->Release();
		}
	}
}

void CAutoInstall::SetDBCSSimulation(CAutoArgs& args)
{
	int chLeadByte = args[1];
	IMsiDebug *piDebug;
	if (m_piServices && m_piServices->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
	{
		piDebug->SetDBCSSimulation((char)chLeadByte);
		piDebug->Release();
	}
}

void CAutoInstall::AssertNoObjects(CAutoArgs& /* args */)
{
	IMsiDebug *piDebug;
	Bool fServices = fFalse;
	
	if (m_piServices)
	{
		if (m_piServices->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			fServices = fTrue;
			piDebug->AssertNoObjects();
			piDebug->Release();
		}
	}

	if (m_piEngine)
	{
		if (m_piEngine->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			piDebug->AssertNoObjects();
			piDebug->Release();
		}

		// If we don't have a services object in the auto object, try the
		// one in the engine object
		if (!fServices)
		{
			IMsiServices* piServices;
			piServices = m_piEngine->GetServices();
			if (piServices->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
			{
				fServices = fTrue;
				piDebug->AssertNoObjects();
				piDebug->Release();
			}
			piServices->Release();
		}
		
	}
	
	if (m_piHandler)
	{
		if (m_piHandler->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			piDebug->AssertNoObjects();
			piDebug->Release();
		}
	}
}

void CAutoInstall::SetRefTracking(CAutoArgs& args)
{
	IMsiDebug *piDebug;
	Bool fServices = fFalse;
	long iid = args[1];
	Bool fTrack = args[2];
	
	if (m_piServices)
	{
		if (m_piServices->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			fServices = fTrue;
			piDebug->SetRefTracking(iid, fTrack);
			piDebug->Release();
		}
	}

	if (m_piEngine)
	{
		if (m_piEngine->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			piDebug->SetRefTracking(iid, fTrack);
			piDebug->Release();
		}

		// If we don't have a services object in the auto object, try the
		// one in the engine object
		if (!fServices)
		{
			IMsiServices* piServices;
			piServices = m_piEngine->GetServices();
			if (piServices->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
			{
				fServices = fTrue;
				piDebug->SetRefTracking(iid, fTrack);
				piDebug->Release();
			}
			piServices->Release();
		}
		
	}
	
	if (m_piHandler)
	{
		if (m_piHandler->QueryInterface(IID_IMsiDebug, (void **)&piDebug) == NOERROR)
		{
			piDebug->SetRefTracking(iid, fTrack);
			piDebug->Release();
		}
	}
}

const ICHAR* const rgszOpcode[] = 
{
#define MSIXO(op,type,args) TEXT("ixo") TEXT(#op),
#include "opcodes.h"
};
void CAutoInstall::OpcodeName(CAutoArgs& args)
{
	unsigned int iOpcode = args[1];
	if (iOpcode >= sizeof(rgszOpcode)/sizeof(ICHAR*))
		throw MsiAuto_OpcodeName;
	args = rgszOpcode[iOpcode];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\auto\autosrv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       autosrv.cpp
//
//--------------------------------------------------------------------------

//
// File: autosrv.cpp
// Purpose: Automation wrappers for services classes
//____________________________________________________________________________
#include "common.h"    // must be first for precompiled headers to work
#include "autocom.h"   // automation server defines and implemetation
#include "msidspid.h"  // MSI dispatch IDs
#include "msiauto.hh"  // help context ID definitions
#include "engine.h"

#ifdef CONFIGDB // until moved into msidspid.h and msiauto.hh
#include "configdb.h"
#define DISPID_MsiConfigurationDatabase_InsertFile            1
#define DISPID_MsiConfigurationDatabase_RemoveFile            2
#define DISPID_MsiConfigurationDatabase_LookupFile            3
#define DISPID_MsiConfigurationDatabase_EnumClient            4
#define DISPID_MsiConfigurationDatabase_Commit                5
#define MsiConfigurationDatabase_Object                    3300
#define MsiConfigurationDatabase_InsertFile                3301
#define MsiConfigurationDatabase_RemoveFile                3302
#define MsiConfigurationDatabase_LookupFile                3303
#define MsiConfigurationDatabase_EnumClient                3304
#define MsiConfigurationDatabase_Commit                    3305
const GUID IID_IMsiConfigurationDatabase = GUID_IID_IMsiConfigurationDatabase;
#endif // CONFIGDB

extern const GUID IID_IMsiEngine;    // defined in autocom.cpp
extern const GUID IID_IMsiHandler;   // defined in autocom.cpp
extern const GUID IID_IMsiMessage;   // defined in autocom.cpp
extern const GUID IID_IMsiConfigurationManager;

int g_cServicesUsers = 0;

const GUID IID_IMsiString     = GUID_IID_IMsiString;
const GUID IID_IMsiRecord     = GUID_IID_IMsiRecord;
const GUID IID_IEnumMsiRecord = GUID_IID_IEnumMsiRecord;
const GUID IID_IMsiView       = GUID_IID_IMsiView;
const GUID IID_IMsiVolume     = GUID_IID_IMsiVolume;
const GUID IID_IEnumMsiVolume = GUID_IID_IEnumMsiVolume;
const GUID IID_IMsiPath       = GUID_IID_IMsiPath;
const GUID IID_IMsiFileCopy   = GUID_IID_IMsiFileCopy;
const GUID IID_IMsiDatabase   = GUID_IID_IMsiDatabase;
const GUID IID_IMsiRegKey     = GUID_IID_IMsiRegKey;
const GUID IID_IMsiTable      = GUID_IID_IMsiTable;
const GUID IID_IMsiCursor     = GUID_IID_IMsiCursor;
const GUID IID_IMsiStorage    = GUID_IID_IMsiStorage;
const GUID IID_IMsiStream     = GUID_IID_IMsiStream;
const GUID IID_IMsiMemoryStream = GUID_IID_IMsiStream;
const GUID IID_IMsiMalloc     = GUID_IID_IMsiMalloc;
const GUID IID_IMsiDebugMalloc= GUID_IID_IMsiDebugMalloc;
const GUID IID_IMsiSelectionManager = GUID_IID_IMsiSelectionManager;
const GUID IID_IMsiDirectoryManager = GUID_IID_IMsiDirectoryManager;
const GUID IID_IMsiDialogHandler = GUID_IID_IMsiDialogHandler;
const GUID IID_IMsiDialog     = GUID_IID_IMsiDialog;
const GUID IID_IMsiEvent      = GUID_IID_IMsiEvent;
const GUID IID_IMsiControl    = GUID_IID_IMsiControl;
const GUID IID_IMsiMessage    = GUID_IID_IMsiMessage;

//____________________________________________________________________________
//
// Automation wrapper class definitions
//____________________________________________________________________________

class CAutoServices : public CAutoBase
{
 public:
	CAutoServices(IMsiServices& riServices);
	~CAutoServices();
	IUnknown& GetInterface();
	void CreateString              (CAutoArgs& args);
	void CreateRecord              (CAutoArgs& args);
	void Property                  (CAutoArgs& args);
	void SetPlatformProperties     (CAutoArgs& args);
	void GetShellFolderPath        (CAutoArgs& args);
	void GetUserProfilePath        (CAutoArgs& args);
	void ExtractFileName           (CAutoArgs& args);
	void ValidateFileName          (CAutoArgs& args);
	void CreateLog                 (CAutoArgs& args);
	void WriteLog                  (CAutoArgs& args);
	void LoggingEnabled            (CAutoArgs& args);
	void CreateDatabase            (CAutoArgs& args);
	void CreateDatabaseFromStorage (CAutoArgs& args);
	void CreatePath                (CAutoArgs& args);
	void CreateVolume              (CAutoArgs& args);
	void CreateVolumeFromLabel     (CAutoArgs& args);
	void CreateCopier              (CAutoArgs& args);
	void CreatePatcher             (CAutoArgs& args);
	void ClearAllCaches            (CAutoArgs& args);
	void EnumDriveType             (CAutoArgs& args);
	void GetModuleUsage            (CAutoArgs& args);
	void CreateRegKey              (CAutoArgs& args);
	void RegisterFont              (CAutoArgs& args);
	void UnRegisterFont            (CAutoArgs& args);
	void WriteIniFile              (CAutoArgs& args);
	void ReadIniFile               (CAutoArgs& args);
	void GetLocalPath              (CAutoArgs& args);
	void GetAllocator              (CAutoArgs& args);
	void GetLangNamesFromLangIDString(CAutoArgs& args);
	void CreateStorage             (CAutoArgs& args);
	void GetUnhandledError         (CAutoArgs& args);
	void SupportLanguageId         (CAutoArgs& args);
	void CreateShortcut            (CAutoArgs& args);
	void RemoveShortcut            (CAutoArgs& args);
	void CreateFileStream          (CAutoArgs& args);
	void CreateMemoryStream        (CAutoArgs& args);
	void RegisterTypeLibrary       (CAutoArgs& args);
	void UnregisterTypeLibrary     (CAutoArgs& args);
	void CreateFilePath            (CAutoArgs& args);
	void RipFileNameFromPath       (CAutoArgs& args);
	void TestEmbeddedNullsInStrings(CAutoArgs& args);
 private:
	IMsiServices& m_riServices;
	IMsiDatabase* m_riDefaultDatabase; //!! not needed
 private: // eliminate warning
	void operator =(CAutoServices&){}
};

class CAutoData : public CAutoBase
{
 public:
	CAutoData(const IMsiData* piData);
	~CAutoData();
	IUnknown& GetInterface();
	void StringValue   (CAutoArgs& args);
	void IntegerValue  (CAutoArgs& args);
 private:
	const IMsiData* m_piData;
};

class CAutoString : public CAutoBase
{
 public:
	CAutoString(const IMsiString& riString);
	~CAutoString();
	IUnknown& GetInterface();
	void Value         (CAutoArgs& args);
	void IntegerValue  (CAutoArgs& args);
	void TextSize      (CAutoArgs& args);
	void CharacterCount(CAutoArgs& args);
	void IsDBCS        (CAutoArgs& args);
	void Compare       (CAutoArgs& args);
	void Append        (CAutoArgs& args);
	void Add           (CAutoArgs& args);
	void Extract       (CAutoArgs& args);
	void Remove        (CAutoArgs& args);
	void UpperCase     (CAutoArgs& args);
	void LowerCase     (CAutoArgs& args);
 private:
	const IMsiString* m_piString;
};

class CAutoRecord : public CAutoBase
{
 public:
	CAutoRecord(IMsiRecord& riRecord);
	~CAutoRecord();
	IUnknown& GetInterface();
	void Data       (CAutoArgs& args);
	void StringData (CAutoArgs& args);
	void IntegerData(CAutoArgs& args);
	void ObjectData (CAutoArgs& args);
	void FieldCount (CAutoArgs& args);
	void IsInteger  (CAutoArgs& args);
	void IsNull     (CAutoArgs& args);
	void IsChanged  (CAutoArgs& args);
	void TextSize   (CAutoArgs& args);
	void FormatText (CAutoArgs& args);
	void ClearData  (CAutoArgs& args);
	void ClearUpdate(CAutoArgs& args);
 private:
	IMsiRecord& m_riRecord;
 private: // suppress warning
	void operator =(CAutoRecord&){}
};

class CAutoVolume : public CAutoBase
{
 public:
	CAutoVolume(IMsiVolume& riVolume);
	~CAutoVolume();
	IUnknown& GetInterface();
	void Path          (CAutoArgs& args);
	void VolumeID      (CAutoArgs& args);
	void DriveType     (CAutoArgs& args);
	void SupportsLFN   (CAutoArgs& args);
	void FreeSpace     (CAutoArgs& args);
	void TotalSpace    (CAutoArgs& args);
	void ClusterSize   (CAutoArgs& args);
	void FileSystem    (CAutoArgs& args);
	void FileSystemFlags(CAutoArgs& args);
	void VolumeLabel   (CAutoArgs& args);
	void UNCServer     (CAutoArgs& args);
	void SerialNum     (CAutoArgs& args);
	void DiskNotInDrive(CAutoArgs& args);
 private:
	IMsiVolume& m_riVolume;
 private: // suppress warning
	void operator =(CAutoVolume&){}
};

class CAutoPath : public CAutoBase
{
 public:
	~CAutoPath();
	CAutoPath(IMsiPath& riPath);
	IUnknown& GetInterface();
	void Path            (CAutoArgs& args);
	void RelativePath    (CAutoArgs& args);
	void Volume          (CAutoArgs& args);
	void AppendPiece     (CAutoArgs& args);
	void ChopPiece       (CAutoArgs& args);
	void FileExists      (CAutoArgs& args);
	void GetFullFilePath (CAutoArgs& args);
	void GetFileAttribute(CAutoArgs& args);
	void SetFileAttribute(CAutoArgs& args);
	void Exists          (CAutoArgs& args);
	void FileSize        (CAutoArgs& args);
	void FileDate        (CAutoArgs& args);
	void RemoveFile      (CAutoArgs& args);
	void Create          (CAutoArgs& args);
	void Remove          (CAutoArgs& args);
	void Writable        (CAutoArgs& args);
	void FileWritable    (CAutoArgs& args);
	void FileInUse              (CAutoArgs& args);
	void ClusteredFileSize      (CAutoArgs& args);
	void GetFileVersionString   (CAutoArgs& args); 
	void CheckFileVersion       (CAutoArgs& args);
	void GetLangIDStringFromFile(CAutoArgs& args);
	void CheckLanguageIDs       (CAutoArgs& args);
	void Compare                (CAutoArgs& args);
	void Child                  (CAutoArgs& args);
	void TempFileName           (CAutoArgs& args);
	void EnsureExists           (CAutoArgs& args);
	void FindFile				(CAutoArgs& args);
	void SubFolders      		(CAutoArgs& args);
	void EndSubPath				(CAutoArgs& args);
	void GetImportModulesEnum   (CAutoArgs& args);
	void SetVolume              (CAutoArgs& args);
	void ComputeFileChecksum    (CAutoArgs& args);
	void GetFileOriginalChecksum(CAutoArgs& args);
	void BindImage              (CAutoArgs& args);
	void SupportsLFN            (CAutoArgs& args);
	void GetFullUNCFilePath     (CAutoArgs& args);
	void RipFileNameFromPath    (CAutoArgs& args);
	void GetSelfRelativeSD      (CAutoArgs& args);
 private:
	IMsiPath& m_riPath;
 private: // suppress warning
	void operator =(CAutoPath&){}
};

class CAutoFileCopy : public CAutoBase
{
 public:
	CAutoFileCopy(IMsiFileCopy& riFileCopy);
	~CAutoFileCopy();
	IUnknown& GetInterface();
	void CopyTo(CAutoArgs& args);
	void ChangeMedia(CAutoArgs& args);
 private:
	IMsiFileCopy& m_riFileCopy;
 private: // suppress warning
	void operator =(CAutoFileCopy&){}
};

class CAutoFilePatch : public CAutoBase
{
 public:
	CAutoFilePatch(IMsiFilePatch& riFilePatch);
	~CAutoFilePatch();
	IUnknown& GetInterface();
	void ApplyPatch(CAutoArgs& args);
	void ContinuePatch(CAutoArgs& args);
	void CancelPatch(CAutoArgs& args);
	void CanPatchFile(CAutoArgs& args);
 private:
	IMsiFilePatch& m_riFilePatch;
 private: // suppress warning
	void operator =(CAutoFilePatch&){}
};

class CAutoStorage : public CAutoBase
{
 public:
	CAutoStorage(IMsiStorage& riStorage);
	~CAutoStorage();
	IUnknown& GetInterface();
	void Class              (CAutoArgs& args);
	void OpenStream         (CAutoArgs& args);
	void OpenStorage        (CAutoArgs& args);
	void Streams            (CAutoArgs& args);
	void Storages           (CAutoArgs& args);
	void RemoveElement      (CAutoArgs& args);
	void RenameElement      (CAutoArgs& args);
	void Commit             (CAutoArgs& args);
	void Rollback           (CAutoArgs& args);
	void DeleteOnRelease    (CAutoArgs& args);
	void CreateSummaryInfo  (CAutoArgs& args);
	void CopyTo             (CAutoArgs& args);
	void Name               (CAutoArgs& args);
 private:
	IMsiStorage& m_riStorage;
 private: // suppress warning
	void operator =(CAutoStorage&){}
};

class CAutoStream : public CAutoBase
{
 public:
	CAutoStream(IMsiStream& riStream);
	~CAutoStream();
	IUnknown& GetInterface();
	void Length   (CAutoArgs& args);
	void Remaining(CAutoArgs& args);
	void Error    (CAutoArgs& args);
	void GetData  (CAutoArgs& args);
	void PutData  (CAutoArgs& args);
	void GetInt16 (CAutoArgs& args);
	void GetInt32 (CAutoArgs& args);
	void PutInt16 (CAutoArgs& args);
	void PutInt32 (CAutoArgs& args);
	void Reset    (CAutoArgs& args);
	void Seek     (CAutoArgs& args);
	void Clone    (CAutoArgs& args);
 private:
	IMsiStream& m_riStream;
 private: // suppress warning
	void operator =(CAutoStream&){}
};

class CAutoSummaryInfo : public CAutoBase
{
 public:
	CAutoSummaryInfo(IMsiSummaryInfo& riSummaryInfo);
	~CAutoSummaryInfo();
	IUnknown& GetInterface();
	void Property           (CAutoArgs& args);
	void PropertyCount      (CAutoArgs& args);
	void PropertyType       (CAutoArgs& args);
	void WritePropertyStream(CAutoArgs& args);
 private:
	IMsiSummaryInfo& m_riSummary;
 private: // suppress warning
	void operator =(CAutoSummaryInfo&){}
};

class CAutoDatabase : public CAutoBase
{
 public:
	CAutoDatabase(IMsiDatabase& riDatabase);
	~CAutoDatabase();
	IUnknown& GetInterface();
	void UpdateState         (CAutoArgs& args);
	void Storage             (CAutoArgs& args);
	void OpenView            (CAutoArgs& args);
	void GetPrimaryKeys      (CAutoArgs& args);
	void ImportTable         (CAutoArgs& args);
	void ExportTable         (CAutoArgs& args);
	void DropTable           (CAutoArgs& args);
	void FindTable           (CAutoArgs& args);
	void LoadTable           (CAutoArgs& args);
	void CreateTable         (CAutoArgs& args);
	void LockTable           (CAutoArgs& args);
	void GetCatalogTable     (CAutoArgs& args);
	void DecodeString        (CAutoArgs& args);
	void EncodeString        (CAutoArgs& args);
	void CreateTempTableName (CAutoArgs& args);
	void Commit              (CAutoArgs& args);
	void CreateOutputDatabase(CAutoArgs& args);
	void GenerateTransform   (CAutoArgs& args);
	void SetTransform        (CAutoArgs& args);
	void MergeDatabase       (CAutoArgs& args);
	void TableState          (CAutoArgs& args);
	void ANSICodePage        (CAutoArgs& args);
 private:
	IMsiDatabase& m_riDatabase;
 private: // suppress warning
	void operator =(CAutoDatabase&){}
};

class CAutoView : public CAutoBase
{
 public:
	CAutoView(IMsiView& riView);
	~CAutoView();
	IUnknown& GetInterface();
	void Execute       (CAutoArgs& args);
	void FieldCount    (CAutoArgs& args);
	void GetColumnNames(CAutoArgs& args);
	void GetColumnTypes(CAutoArgs& args);
	void Fetch         (CAutoArgs& args);
	void Modify        (CAutoArgs& args);
	void RowCount      (CAutoArgs& args);
	void Close         (CAutoArgs& args);
	void GetError      (CAutoArgs& args);
	void State         (CAutoArgs& args);
 private:
	IMsiView& m_riView;
 private: // suppress warning
	void operator =(CAutoView&){}
};

class CAutoTable : public CAutoBase
{
 public:
	CAutoTable(IMsiTable& riTable);
	~CAutoTable();
	IUnknown& GetInterface();
	void Database        (CAutoArgs& args);
	void RowCount        (CAutoArgs& args);
	void ColumnCount     (CAutoArgs& args);
	void PrimaryKeyCount (CAutoArgs& args);
	void ReadOnly        (CAutoArgs& args);
	void ColumnName      (CAutoArgs& args);
	void ColumnType      (CAutoArgs& args);
	void GetColumnIndex  (CAutoArgs& args);
	void CreateColumn    (CAutoArgs& args);
	void CreateCursor    (CAutoArgs& args);
	void LinkTree        (CAutoArgs& args);
 private:
	IMsiTable& m_riTable;
 private: // suppress warning
	void operator =(CAutoTable&){}
};

class CAutoCursor : public CAutoBase
{
 public:
	CAutoCursor(IMsiCursor& riCursor);
	~CAutoCursor();
	IUnknown& GetInterface();
	void Table          (CAutoArgs& args);
	void Filter         (CAutoArgs& args);
	void IntegerData    (CAutoArgs& args);
	void DateData       (CAutoArgs& args);
	void StringData     (CAutoArgs& args);
	void ObjectData     (CAutoArgs& args);
	void StreamData     (CAutoArgs& args);
	void PutNull        (CAutoArgs& args);
	void Reset          (CAutoArgs& args);
	void Next           (CAutoArgs& args);
	void Update         (CAutoArgs& args);
	void Insert         (CAutoArgs& args);
	void InsertTemporary(CAutoArgs& args);
	void Assign         (CAutoArgs& args);
	void Replace        (CAutoArgs& args);
	void Merge          (CAutoArgs& args);
	void Refresh        (CAutoArgs& args);
	void Delete         (CAutoArgs& args);
	void Seek           (CAutoArgs& args);
	void RowState       (CAutoArgs& args);
	void Validate       (CAutoArgs& args);
	void Moniker        (CAutoArgs& args);
 private:
	IMsiCursor& m_riCursor;
 private: // suppress warning
	void operator =(CAutoCursor&){}
};

class CAutoSelectionManager : public CAutoBase
{
 public:
	CAutoSelectionManager(IMsiSelectionManager& riSelectionManager);
	~CAutoSelectionManager();
	IUnknown& GetInterface();
	void LoadSelectionTables   (CAutoArgs& args);
	void ProcessConditionTable (CAutoArgs& args);
	void FeatureTable          (CAutoArgs& args);
	void ComponentTable        (CAutoArgs& args);
	void FreeSelectionTables   (CAutoArgs& args);
	void SetFeatureHandle      (CAutoArgs& args);
	void SetComponent          (CAutoArgs& args);
	void InitializeComponents  (CAutoArgs& args);
	void SetInstallLevel       (CAutoArgs& args);
	void GetVolumeCostTable    (CAutoArgs& args);
	void RecostDirectory       (CAutoArgs& args);
	void ConfigureFeature      (CAutoArgs& args);
	void GetFeatureCost        (CAutoArgs& args);
	void GetDescendentFeatureCost (CAutoArgs& args);
	void GetAncestryFeatureCost(CAutoArgs& args);
	void GetFeatureValidStates (CAutoArgs& args);
 private:
	IMsiSelectionManager& m_riSelectionManager;
 private: // suppress warning
	void operator =(CAutoSelectionManager&){}
};

class CAutoDirectoryManager : public CAutoBase
{
 public:
	CAutoDirectoryManager(IMsiDirectoryManager& riDirectoryManager);
	~CAutoDirectoryManager();
	IUnknown& GetInterface();
	void LoadDirectoryTable    (CAutoArgs& args);
	void DirectoryTable        (CAutoArgs& args);
	void FreeDirectoryTable    (CAutoArgs& args);
	void CreateTargetPaths     (CAutoArgs& args);
	void CreateSourcePaths     (CAutoArgs& args);
	void GetTargetPath         (CAutoArgs& args);
	void SetTargetPath         (CAutoArgs& args);
	void GetSourcePath         (CAutoArgs& args);
 private:
	IMsiDirectoryManager& m_riDirectoryManager;
 private: // suppress warning
	void operator =(CAutoDirectoryManager&){}
};

class CAutoServer : public CAutoBase
{
 public:
	CAutoServer(IMsiServer& riServer);
	CAutoServer(IMsiServer& riServer, DispatchEntry<CAutoBase>* pTable, int cDispId);
	~CAutoServer();
	IUnknown& GetInterface();
	void InstallFinalize     (CAutoArgs& args);
	void DoInstall           (CAutoArgs& args);
	void SetLastUsedSource   (CAutoArgs& args);
 private:
	IMsiServer& m_riServer;
 private: // suppress warning
	void operator =(CAutoServer&){}
};

class CAutoConfigurationManager : public CAutoServer
{
 public:
	CAutoConfigurationManager(IMsiConfigurationManager& riConfigurationManager);
	~CAutoConfigurationManager();
	IUnknown& GetInterface();
	void Services                    (CAutoArgs& args);
	void RegisterComponent           (CAutoArgs& args);
	void UnregisterComponent         (CAutoArgs& args);
	void RegisterFolder              (CAutoArgs& args);
	void IsFolderRemovable           (CAutoArgs& args);
	void UnregisterFolder            (CAutoArgs& args);
	void RegisterRollbackScript      (CAutoArgs& args);
	void UnregisterRollbackScript    (CAutoArgs& args);
	void RollbackScripts             (CAutoArgs& args);
	void RunScript                   (CAutoArgs& args);
 private:
	IMsiConfigurationManager& m_riConfigurationManager;
 private: // suppress warning
	void operator =(CAutoConfigurationManager&){}
};

class CAutoExecute : public CAutoBase
{
 public:
	CAutoExecute(IMsiExecute& riExecute);
	~CAutoExecute();
	IUnknown& GetInterface();
	void ExecuteRecord        (CAutoArgs& args);
	void RunScript            (CAutoArgs& args);
	void RemoveRollbackFiles  (CAutoArgs& args);
	void Rollback             (CAutoArgs& args);
	void RollbackFinalize     (CAutoArgs& args);
	void CreateScript         (CAutoArgs& args);
	void WriteScriptRecord    (CAutoArgs& args);
	void CloseScript          (CAutoArgs& args);
 private:
	IMsiExecute& m_riExecute;
	CScriptGenerate* m_pScript;
 private: // suppress warning
	void operator =(CAutoExecute&){}
};

class CAutoEngine : public CAutoBase
{
 public:
	CAutoEngine(IMsiEngine& riEngine);
	~CAutoEngine();
	IUnknown& GetInterface();
	void Services             (CAutoArgs& args);
	void ConfigurationServer  (CAutoArgs& args);
	void Handler              (CAutoArgs& args);
	void Database             (CAutoArgs& args);
	void Property             (CAutoArgs& args);
	void SelectionManager     (CAutoArgs& args);
	void DirectoryManager     (CAutoArgs& args);
	void Initialize           (CAutoArgs& args);
	void Terminate            (CAutoArgs& args);
	void DoAction             (CAutoArgs& args);
	void Sequence             (CAutoArgs& args);
	void Message              (CAutoArgs& args);
	void OpenView             (CAutoArgs& args);
	void ResolveFolderProperty(CAutoArgs& args);
	void FormatText           (CAutoArgs& args);
	void EvaluateCondition    (CAutoArgs& args);
	void SetMode              (CAutoArgs& args);
	void GetMode              (CAutoArgs& args);
	void ExecuteRecord        (CAutoArgs& args);
	void ValidateProductID    (CAutoArgs& args);
private:
	IMsiEngine& m_riEngine;
 private: // suppress warning
	void operator =(CAutoEngine&){}
};

class CAutoRegKey : public CAutoBase
{
 public:
	CAutoRegKey(IMsiRegKey& riRegKey);
	~CAutoRegKey();
	IUnknown& GetInterface();
	void RemoveValue  (CAutoArgs& args);
	void RemoveSubTree(CAutoArgs& args);
	void Value        (CAutoArgs& args);
	void Values       (CAutoArgs& args);
	void SubKeys      (CAutoArgs& args);
	void Exists       (CAutoArgs& args);
	void CreateChild  (CAutoArgs& args);
	void Key          (CAutoArgs& args);
	void ValueExists  (CAutoArgs& args);
	void GetSelfRelativeSD(CAutoArgs& args);
 private:
	IMsiRegKey& m_riRegKey;
 private: // suppress warning
	void operator =(CAutoRegKey&){}
};

class CAutoHandler : public CAutoBase
{
 public:
	CAutoHandler(IMsiHandler& riHandler);
	~CAutoHandler();
	IUnknown& GetInterface();
	void Message(CAutoArgs& args);
	void DoAction(CAutoArgs& args);
	void Break(CAutoArgs& args);
	void DialogHandler(CAutoArgs& args);
 private:
	IMsiHandler& m_riHandler;
 private: // suppress warning
	void operator =(CAutoHandler&){}
};

class CAutoDialogHandler : public CAutoBase
{
public:
	CAutoDialogHandler(IMsiDialogHandler& riHandler);
	~CAutoDialogHandler();
	IUnknown& GetInterface();
	void DialogCreate(CAutoArgs& args);
	void Dialog(CAutoArgs& args);
	void DialogFromWindow(CAutoArgs& args);
	void AddDialog(CAutoArgs& args);
	void RemoveDialog(CAutoArgs& args);
private:
	IMsiDialogHandler& m_riDialogHandler;
 private: // suppress warning
	void operator =(CAutoDialogHandler&){}
};


class CAutoDialog : public CAutoBase
{
 public:
	CAutoDialog(IMsiDialog& riDialog);
	~CAutoDialog();
	IUnknown& GetInterface();
	void StringValue(CAutoArgs& args);
	void IntegerValue(CAutoArgs& args);
	void Visible(CAutoArgs& args);
	void ControlCreate(CAutoArgs& args);
	void Attribute(CAutoArgs& args);
	void Control(CAutoArgs& args);
	void AddControl(CAutoArgs& args);
	void RemoveControl(CAutoArgs& args);
	void Execute(CAutoArgs& args);
	void Reset(CAutoArgs& args);
 	void EventAction(CAutoArgs& args);
	void Handler(CAutoArgs& args);
	void PropertyChanged(CAutoArgs& args);
	void FinishCreate(CAutoArgs& args);
	void HandleEvent(CAutoArgs& args);
 private:
	IMsiDialog& m_riDialog;
 private: // suppress warning
	void operator =(CAutoDialog&){}
};

class CAutoEvent : public CAutoBase
{
 public:
	CAutoEvent(IMsiEvent& riEvent);
	~CAutoEvent();
	IUnknown& GetInterface();
	void StringValue(CAutoArgs& args);
	void IntegerValue(CAutoArgs& args);
	void PropertyChanged(CAutoArgs& args);
	void ControlActivated(CAutoArgs& args);
	void RegisterControlEvent(CAutoArgs& args);
	void Handler(CAutoArgs& args);
	void PublishEvent(CAutoArgs& args);
	void Control(CAutoArgs& args);
	void Attribute(CAutoArgs& args);
	void EventAction(CAutoArgs& args);
	void SetFocus(CAutoArgs& args);
	void HandleEvent(CAutoArgs& args);
	void Engine(CAutoArgs& args);
	void Escape(CAutoArgs& args);
 private:
	IMsiEvent& m_riEvent;
 private: // suppress warning
	void operator =(CAutoEvent&){}
};

class CAutoControl : public CAutoBase
{
 public:
	CAutoControl(IMsiControl& riControl);
	~CAutoControl();
	IUnknown& GetInterface();
	void StringValue(CAutoArgs& args);
	void IntegerValue(CAutoArgs& args);
	void Attribute(CAutoArgs& args);
	void CanTakeFocus(CAutoArgs& args);
	void HandleEvent(CAutoArgs& args);
	void Undo(CAutoArgs& args);
	void SetPropertyInDatabase(CAutoArgs& args);
	void GetPropertyFromDatabase(CAutoArgs& args);
	void GetIndirectPropertyFromDatabase(CAutoArgs& args);
	void SetFocus(CAutoArgs& args);
	void Dialog(CAutoArgs& args);
	void WindowMessage(CAutoArgs& args);
 private:
	IMsiControl& m_riControl;
 private: // suppress warning
	void operator =(CAutoControl&){}
};

class CAutoMalloc : public CAutoBase
{
 public:
	CAutoMalloc(IMsiMalloc& riMalloc);
	~CAutoMalloc();
	IUnknown& GetInterface();
	void Alloc(CAutoArgs& args);
	void Realloc(CAutoArgs& args);
	void Free(CAutoArgs& args);
	void SetDebugFlags(CAutoArgs& args);
	void GetDebugFlags(CAutoArgs& args);
	void CheckAllBlocks(CAutoArgs& args);
	void FCheckBlock(CAutoArgs& args);
	void GetSizeOfBlock(CAutoArgs& args);
 private:
	IMsiMalloc& m_riMalloc;
 private: // suppress warning
	void operator =(CAutoMalloc&){}
};

class CAutoMessage : public CAutoBase
{
 public:
	CAutoMessage(IMsiMessage& riMessage);
	~CAutoMessage();
	IUnknown& GetInterface();
	void Message(CAutoArgs& args);
 private:
	IMsiMessage& m_riMessage;
 private: // suppress warning
	void operator =(CAutoMessage&){}
};

#ifdef CONFIGDB
class CAutoConfigurationDatabase : public CAutoBase
{
 public:
	CAutoConfigurationDatabase(IMsiConfigurationDatabase& riConfigurationDatabase);
	~CAutoConfigurationDatabase();
	IUnknown& GetInterface();
	void InsertFile(CAutoArgs& args);
	void RemoveFile(CAutoArgs& args);
	void LookupFile(CAutoArgs& args);
	void EnumClient(CAutoArgs& args);
	void Commit(CAutoArgs& args);
 private:
	IMsiConfigurationDatabase& m_riConfigurationDatabase;
 private: // suppress warning
	void operator =(CAutoConfigurationDatabase&){}
};
#endif //CONFIGDB
//____________________________________________________________________________
//
// Automation wrapper factory for this module, used by CAutoBase::GetInterface
//____________________________________________________________________________

IDispatch* CreateAutoObject(IUnknown& riUnknown, long iidLow)
{
	riUnknown.AddRef(); // constructors assume refcnt transferred
	switch (iidLow)
	{
	case iidMsiData    : return new CAutoData    ((const IMsiData   *)&riUnknown);
	case iidMsiString  : return new CAutoString  ((const IMsiString  &)riUnknown);
	case iidMsiRecord  : return new CAutoRecord  ((IMsiRecord  &)riUnknown);
	case iidMsiVolume  : return new CAutoVolume  ((IMsiVolume  &)riUnknown);
	case iidMsiPath    : return new CAutoPath    ((IMsiPath    &)riUnknown);
	case iidMsiFileCopy: return new CAutoFileCopy((IMsiFileCopy&)riUnknown);
	case iidMsiFilePatch: return new CAutoFilePatch((IMsiFilePatch&)riUnknown);
	case iidMsiRegKey  : return new CAutoRegKey  ((IMsiRegKey  &)riUnknown);
	case iidMsiTable   : return new CAutoTable   ((IMsiTable   &)riUnknown);
	case iidMsiCursor  : return new CAutoCursor  ((IMsiCursor  &)riUnknown);
	case iidMsiServices: return new CAutoServices((IMsiServices&)riUnknown);
	case iidMsiView    : return new CAutoView    ((IMsiView    &)riUnknown);
	case iidMsiDatabase: return new CAutoDatabase((IMsiDatabase&)riUnknown);
	case iidMsiEngine  : return new CAutoEngine  ((IMsiEngine  &)riUnknown);
	case iidMsiExecute : return new CAutoExecute ((IMsiExecute &)riUnknown);
	case iidMsiHandler : return new CAutoHandler ((IMsiHandler &)riUnknown);
	case iidMsiDialogHandler : return new CAutoDialogHandler ((IMsiDialogHandler &)riUnknown);
	case iidMsiDialog  : return new CAutoDialog  ((IMsiDialog  &)riUnknown);
	case iidMsiEvent   : return new CAutoEvent   ((IMsiEvent   &)riUnknown);
	case iidMsiControl : return new CAutoControl ((IMsiControl &)riUnknown);
	case iidMsiStorage : return new CAutoStorage ((IMsiStorage &)riUnknown);
	case iidMsiStream  : return new CAutoStream  ((IMsiStream  &)riUnknown);
	case iidMsiConfigurationManager: return new CAutoConfigurationManager((IMsiConfigurationManager&)riUnknown);
	case iidMsiDirectoryManager    : return new CAutoDirectoryManager    ((IMsiDirectoryManager    &)riUnknown);
	case iidMsiSelectionManager    : return new CAutoSelectionManager    ((IMsiSelectionManager    &)riUnknown);
	case iidMsiMessage : return new CAutoMessage((IMsiMessage &)riUnknown);
#ifdef CONFIGDB
	case iidMsiConfigurationDatabase : return new CAutoConfigurationDatabase((IMsiConfigurationDatabase&)riUnknown);
#endif
	default:   riUnknown.Release(); return 0;
	};
}

//____________________________________________________________________________
//
// Common methods and properties automation definitions
//____________________________________________________________________________
/*O

	[
		uuid(000C1040-0000-0000-C000-000000000046),  // IID_IMsiAutoBase
		helpcontext(MsiBase_Object),helpstring("Methods and properties common to all objects.")
	]
	dispinterface MsiBase
	{
		properties:
		methods:
			[id(1),propget,helpcontext(MsiBase_HasInterface),helpstring("True if object has interface.")]
				boolean HasInterface([in] long iid);
			[id(2),propget,helpcontext(MsiBase_RefCount),helpstring("Reference count of object.")]
				int RefCount();
			[id(3),propget,helpcontext(MsiBase_GetInterface),helpstring("Returns object containing requested interface.")]
				IDispatch* GetInterface([in] long iid);
	};
*/

//____________________________________________________________________________
//
// MsiServices automation definitions
//____________________________________________________________________________
/*O

	[
		uuid(000C104B-0000-0000-C000-000000000046),  // IID_IMsiAutoServices
		helpcontext(MsiServices_Object),helpstring("Services object.")
	]
	dispinterface MsiServices
	{
		properties:
		methods:
			[id(1), helpcontext(MsiServices_GetAllocator),helpstring("Returns the system MsiMalloc object.")]
				MsiMalloc*  GetAllocator();
			[id(2), helpcontext(MsiServices_CreateString),helpstring("Create an MsiString object containing an empty string.")]
				MsiRecord*  CreateString();
			[id(3), helpcontext(MsiServices_CreateRecord),helpstring("Create a MsiRecord object with a specified number of fields.")]
				MsiRecord*  CreateRecord([in] long Count);
			[id(4), helpcontext(MsiServices_SetPlatformProperties),helpstring("Set hardware and operating system properties.")]
				void SetPlatformProperties([in] MsiTable* table, [in] boolean allUsers);
			[id(5), helpcontext(MsiServices_CreateLog),helpstring("Opens the log file.")]
				void CreateLog([in] BSTR path, [in] boolean append);
			[id(6), helpcontext(MsiServices_WriteLog),helpstring("Writes a line to the log file.")]
				void WriteLog([in] BSTR text);
			[id(7), helpcontext(MsiServices_LoggingEnabled),helpstring("True if the log file is open.")]
				boolean LoggingEnabled();
			[id(8), helpcontext(MsiServices_CreateDatabase),helpstring("Opens a named database of specified kind.")]
				MsiDatabase* CreateDatabase([in] BSTR name, [in] long openMode);
			[id(9), helpcontext(MsiServices_CreateDatabaseFromStorage),helpstring("Opens an MSI database from an MsiStorage object.")]
				MsiDatabase* CreateDatabaseFromStorage([in] MsiStorage* storage, [in] boolean readOnly);
			[id(10), helpcontext(MsiServices_CreatePath),helpstring("Creates an MsiPath object based on the given path string.")]
				MsiPath* CreatePath([in] BSTR path);
			[id(11), helpcontext(MsiServices_CreateVolume),helpstring("Creates an MsiVolume object based on the given path string.")]
				MsiVolume* CreateVolume([in] BSTR path);
			[id(12), helpcontext(MsiServices_CreateCopier),helpstring("Creates an MsiFileCopy object for use in copying a file.")]
				MsiFileCopy* CreateCopier([in] long copierType,MsiStorage* storage);
			[id(13), helpcontext(MsiServices_ClearAllCaches),helpstring("Clears the list of cached volume objects and record objects from the services.")]
				void ClearAllCaches();
			[id(14), helpcontext(MsiServices_EnumDriveType),helpstring("Creates an EnumMsiVolume object, for use in enumerating volumes of a specified volume type.")]
				IEnumVARIANT* EnumDriveType([in]long driveType);
			[id(15), helpcontext(MsiServices_GetModuleUsage),helpstring("Enumerates the processes that use a file of the given name")]
				IEnumVARIANT* GetModuleUsage([in] BSTR fileName);
			[id(16), helpcontext(MsiServices_GetLocalPath),helpstring("Returns a string representing the full path of the installer's launch directory (Win) or the MsiService DLL's directory (Mac).")]
				BSTR GetLocalPath([in] BSTR file);
			[id(17), helpcontext(MsiServices_CreateRegKey), helpstring("Creates an MsiRegKey object")] 
				MsiRegKey*  CreateRegKey([in] BSTR value,[in] BSTR subKey);
			[id(18), helpcontext(MsiServices_RegisterFont),helpstring(".")]
				void RegisterFont([in] BSTR fontTitle, [in] BSTR fontFile, [in] MsiPath* path);
			[id(19), helpcontext(MsiServices_UnRegisterFont),helpstring(".")]
				void UnRegisterFont([in] BSTR fontTitle);                      
			[id(20), helpcontext(MsiServices_WriteIniFile), helpstring("Writes an entry to a .INI file")] 
				void WriteIniFile([in] MsiPath* path, [in] BSTR file,[in] BSTR section,[in] BSTR key,[in] BSTR value, long action);
			[id(21), helpcontext(MsiServices_ReadIniFile), helpstring("Reads an entry from a .INI file")] 
				BSTR ReadIniFile([in] MsiPath* path, [in] BSTR file,[in] BSTR section,[in] BSTR key, [in] long Field);
			[id(22), helpcontext(MsiServices_GetLangNamesFromLangIDString),helpstring("Given a string containing a comma-separated list of language identifiers, GetLangNamesFromLangIDString returns the full localized name of each specified language.")]
				int GetLangNamesFromLangIDString([in] BSTR langIDs, [in] MsiRecord* riLangRec, [in] int iFieldStart);
			[id(23), helpcontext(MsiServices_CreateStorage),helpstring("Creates an MsiStorage object from a file path.")]
				MsiStorage* CreateStorage(BSTR path, long openMode);
			[id(24), helpcontext(MsiServices_GetUnhandledError),helpstring("Returns any unhandled error as an MsiRecord object, clears unhandled error.")]
				MsiRecord* GetUnhandledError();
			[id(25), helpcontext(MsiServices_SupportLanguageId),helpstring("Compares a language ID against the current system or user language ID")]
				long SupportLanguageId([in] long languageId, [in] boolean systemDefault);
			[id(27), helpcontext(MsiServices_CreateVolumeFromLabel),helpstring("Creates an MsiVolume object based on the given volume label.")]
				MsiVolume* CreateVolumeFromLabel([in] BSTR label, [in] int driveType);
			[id(28), helpcontext(MsiServices_CreateShortcut),helpstring("Creates a shortcut to an existing file or path")]
				void CreateShortcut([in] MsiPath* shortcutPath, [in] BSTR shortcutName, [in] MsiPath* targetPath, [in] BSTR targetName, [in] MsiRecord* shortcutInfo);
			[id(29), helpcontext(MsiServices_RemoveShortcut),helpstring("Deletes a shortcut to a file or path")]
				void RemoveShortcut([in] MsiPath* shortcutPath, [in] BSTR shortcutName, [in] MsiPath* targetPath, [in] BSTR targetName);
			[id(34), helpcontext(MsiServices_ExtractFileName),helpstring("Extracts the appropriate file name from a short|long pair.")]
				BSTR ExtractFileName([in] BSTR namePair, [in] boolean longName);
			[id(35), helpcontext(MsiServices_ValidateFileName),helpstring("Validates a short or long file name.")]
				void ValidateFileName([in] BSTR fileName, [in] boolean longName);
			[id(36), helpcontext(MsiServices_CreateFileStream),helpstring("Creates a stream object on a given file.")]
				MsiStream* CreateFileStream([in] BSTR filepath, [in] boolean write);
			[id(37), helpcontext(MsiServices_CreateMemoryStream),helpstring("Creates a stream object on allocated memory.")]
				MsiStream* CreateMemoryStream([in] BSTR data);
			[id(38), helpcontext(MsiServices_RegisterTypeLibrary),helpstring("Registers a type library.")]
                void RegisterTypeLibrary([in] BSTR libId,[in] int locale,[in] BSTR path, [in] BSTR helpPath);
			[id(39), helpcontext(MsiServices_UnregisterTypeLibrary),helpstring("Unregisters a type library.")]
                void UnregisterTypeLibrary([in] BSTR libId,[in] int locale,[in] BSTR path);
			[id(40), helpcontext(MsiServices_GetShellFolderPath),helpstring("Returns the path of a shell folder.")]
				BSTR GetShellFolderPath([in] long folderId, [in] BSTR regValue);
			[id(41), helpcontext(MsiServices_GetUserProfilePath),helpstring("Returns the path of the user's profile folder.")]
				BSTR GetUserProfilePath(void);
			[id(42), helpcontext(MsiServices_CreateFilePath),helpstring("Creates an MsiPath object based on the given full path to a file.")]
				MsiPath* CreateFilePath([in] BSTR path);
			[id(43), helpcontext(MsiServices_RipFileNameFromPath),helpstring("Given a full path to a file, returns the filename.")]
				MsiPath* RipFileNameFromPath([in] BSTR path);
			[id(44), helpcontext(MsiServices_CreatePatcher),helpstring("Creates an MsiFilePatch object for use in patching a file.")]
				MsiFilePatch* CreatePatcher(void);
			[id(45)]
				Boolean TestEmbeddedNullsInStrings(void);
	};
*/

DispatchEntry<CAutoServices> AutoServicesTable[] = {
   1, aafMethod, CAutoServices::GetAllocator,   TEXT("GetAllocator"),
   2, aafMethod, CAutoServices::CreateString,   TEXT("CreateString"),
   3, aafMethod, CAutoServices::CreateRecord,   TEXT("CreateRecord,count"),
   4, aafMethod, CAutoServices::SetPlatformProperties,TEXT("SetPlatformProperties,table,allUsers"),
   5, aafMethod, CAutoServices::CreateLog,      TEXT("CreateLog,path,append"),
   6, aafMethod, CAutoServices::WriteLog,       TEXT("WriteLog,text"),
   7, aafPropRO, CAutoServices::LoggingEnabled, TEXT("LoggingEnabled"),
   8, aafMethod, CAutoServices::CreateDatabase, TEXT("CreateDatabase,name,openMode,tempArgForCompatibility"),
   9, aafMethod, CAutoServices::CreateDatabaseFromStorage, TEXT("CreateDatabaseFromStorage,storage,readOnly"),
  10, aafMethod, CAutoServices::CreatePath,     TEXT("CreatePath,path"),
  11, aafMethod, CAutoServices::CreateVolume,   TEXT("CreateVolume,path"),
  12, aafMethod, CAutoServices::CreateCopier,    TEXT("CreateCopier,copierType,storage"),
  13, aafMethod, CAutoServices::ClearAllCaches, TEXT("ClearAllCaches"),
  14, aafMethod, CAutoServices::EnumDriveType,  TEXT("EnumDriveType,driveType"),
  15, aafMethod, CAutoServices::GetModuleUsage, TEXT("GetModuleUsage,fileName"),
  16, aafMethod, CAutoServices::GetLocalPath,   TEXT("GetLocalPath,file"),
  17, aafMethod, CAutoServices::CreateRegKey,   TEXT("CreateRegKey,key,subkey"),
  18, aafMethod, CAutoServices::RegisterFont,   TEXT("RegisterFont,fontTitle,fontFile,path"),
  19, aafMethod, CAutoServices::UnRegisterFont, TEXT("UnRegisterFont,fontTitle"),
  20, aafMethod, CAutoServices::WriteIniFile, TEXT("WriteIniFile,path,file,section,key,value,action"),
  21, aafMethod, CAutoServices::ReadIniFile, TEXT("ReadIniFile,path,file,section,key,field"),
  22, aafMethod, CAutoServices::GetLangNamesFromLangIDString, TEXT("GetLangNamesFromLangIDString,langIDs,riLangRec,iFieldStart"),
  23, aafMethod, CAutoServices::CreateStorage, TEXT("CreateStorage,path,openMode"),
  24, aafMethod, CAutoServices::GetUnhandledError,TEXT("GetUnhandledError"),
  25, aafMethod, CAutoServices::SupportLanguageId,TEXT("SupportLanguageId,languageId,systemDefault"),
  27, aafMethod, CAutoServices::CreateVolumeFromLabel,   TEXT("CreateVolumeFromLabel,label,driveType"),
  28, aafMethod, CAutoServices::CreateShortcut, TEXT("CreateShortcut,shortcutPath,shortcutName,targetPath,targetName,shortcutInfo"),
  29, aafMethod, CAutoServices::RemoveShortcut, TEXT("RemoveShortcut,shortcutPath,shortcutName,targetPath,targetName"),
  34, aafMethod, CAutoServices::ExtractFileName, TEXT("ExtractFileName,namePair,longName"),
  35, aafMethod, CAutoServices::ValidateFileName, TEXT("ValidateFileName,fileName,longName"),
  36, aafMethod, CAutoServices::CreateFileStream, TEXT("CreateFileStream,filePath,write"),
  37, aafMethod, CAutoServices::CreateMemoryStream, TEXT("CreateMemoryStream,data"),
  38, aafMethod, CAutoServices::RegisterTypeLibrary, TEXT("RegisterTypeLibrary,libId,locale,path,helpPath"),
  39, aafMethod, CAutoServices::UnregisterTypeLibrary, TEXT("UnregisterTypeLibrary,libId,locale,path"),
  40, aafMethod, CAutoServices::GetShellFolderPath, TEXT("GetShellFolderPath,folderId,regValue"),
  41, aafMethod, CAutoServices::GetUserProfilePath, TEXT("GetUserProfilePath"),
  42, aafMethod, CAutoServices::CreateFilePath,     TEXT("CreateFilePath,path"),
  43, aafMethod, CAutoServices::RipFileNameFromPath,     TEXT("RipFileNameFromPath,path"),
  44, aafMethod, CAutoServices::CreatePatcher, TEXT("CreatePatcher"),
  45, aafMethod, CAutoServices::TestEmbeddedNullsInStrings, TEXT("TestEmbeddedNullsInStrings"),
};
const int AutoServicesCount = sizeof(AutoServicesTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiServices automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoServices(IMsiServices& riServices)
{
	return new CAutoServices(riServices);
}

CAutoServices::CAutoServices(IMsiServices& riServices)
 : CAutoBase(*AutoServicesTable, AutoServicesCount), m_riServices(riServices)
{

	if (g_cServicesUsers == 0)
	{
		g_piStringNull = &riServices.GetNullString();
		// Caller did an addref for the m_riServices member of CAutoServices
		// but here we are adding to the static and must do an extra increment
		s_piServices = &riServices;
		s_piServices->AddRef();
		MsiString::InitializeClass(riServices.GetNullString());
	}

	g_cServicesUsers++;
}

CAutoServices::~CAutoServices()
{
	if (--g_cServicesUsers == 0)
	{
		s_piServices->Release();
		s_piServices = 0;
	}
	m_riServices.Release();
}

IUnknown& CAutoServices::GetInterface()
{
	return m_riServices;
}

void CAutoServices::CreateString(CAutoArgs& args)
{
	args = new CAutoString(*g_piStringNull);
}

void CAutoServices::CreateRecord(CAutoArgs& args)
{
	args = new CAutoRecord(m_riServices.CreateRecord(args[1]));
}

void CAutoServices::SetPlatformProperties(CAutoArgs& args)
{
	if (!m_riServices.SetPlatformProperties((IMsiTable&)args[1].Object(IID_IMsiTable), (Bool)args[2], /* isppArchitecture = */ isppDefault, /* piFolderCacheTable = */ NULL))
		throw MsiServices_SetPlatformProperties;
}

void CAutoServices::CreateLog(CAutoArgs& args)
{
	if (!m_riServices.CreateLog(args[1], args[2]))
		throw MsiServices_CreateLog;
}

void CAutoServices::WriteLog(CAutoArgs& args)
{
	if (!m_riServices.WriteLog(args[1]))
		throw MsiServices_WriteLog;
}

void CAutoServices::LoggingEnabled(CAutoArgs& args)
{
	args = m_riServices.LoggingEnabled();
}

void CAutoServices::CreateDatabase(CAutoArgs& args)
{
	IMsiDatabase* piDatabase;
	idoEnum idoMode = (idoEnum)(int)args[2];
   IMsiRecord* piError = m_riServices.CreateDatabase(args[1], idoMode, piDatabase);
	if (piError)
		throw piError;
	args = new CAutoDatabase(*piDatabase);
}

void CAutoServices::CreateDatabaseFromStorage(CAutoArgs& args)
{
	IMsiDatabase* piDatabase;
	IMsiStorage& riStorage = (IMsiStorage&)args[1].Object(IID_IMsiStorage);
   IMsiRecord* piError = m_riServices.CreateDatabaseFromStorage(riStorage, args[2],
							   									piDatabase);
	if (piError)
		throw piError;
	args = new CAutoDatabase(*piDatabase);
}

void CAutoServices::CreatePath(CAutoArgs& args)
{
	IMsiPath* piPath;
	IMsiRecord* piRec = m_riServices.CreatePath(args[1], piPath);
	if (piRec)
		throw piRec;
	args = new CAutoPath(*piPath);
}

void CAutoServices::CreateFilePath(CAutoArgs& args)
{
	MsiString strFileName;
	IMsiPath* piPath;
	IMsiRecord* piRec = m_riServices.CreateFilePath(args[1], piPath, *&strFileName);
	if (piRec)
		throw piRec;
	args = new CAutoPath(*piPath);
}

void CAutoServices::RipFileNameFromPath(CAutoArgs& args)
{
	const IMsiString *piStr;
	PMsiPath pPath(0);
	IMsiRecord* piRec = m_riServices.CreateFilePath(args[1], *&pPath, piStr);
	if (piRec)
		throw piRec;
	args = piStr;
}

Bool Compare(const IMsiString& riString, const ICHAR* szString2, unsigned int cchString2)
{
	if (riString.TextSize() != (cchString2-1) || 0 != memcmp(riString.GetString(), szString2, cchString2*sizeof(ICHAR)))
		return fFalse;
	else
		return fTrue;
}

void CAutoServices::TestEmbeddedNullsInStrings(CAutoArgs& args)
{
	PMsiRecord pRec = &m_riServices.CreateRecord(4);
	const IMsiString* piStr = g_piStringNull;

	const ICHAR szText1[] = TEXT("String1\0String2\0");
	const ICHAR szText2[] = TEXT("\0String2\0");
	const ICHAR szText3[] = TEXT("String2\0");
	const ICHAR szText4[] = TEXT("String1\0String2");
	const ICHAR szText5[] = TEXT("String1");
	const ICHAR szText6[] = TEXT("String1\0");
	const ICHAR szText7[] = TEXT("\0");
	const ICHAR szText8[] = TEXT("");

	ICHAR* pch = piStr->AllocateString(sizeof(szText1)/sizeof(ICHAR) - 1, fFalse, piStr);
	memcpy(pch, szText1, sizeof(szText1));
	MsiString strNulls = *piStr;

	MsiString strTest;

	/////////////////////////
	strTest = strNulls;
	strTest.Remove(iseUpto, 0);
	if (!Compare(*strTest, szText2, sizeof(szText2)/sizeof(ICHAR)))
		goto FAILURE;
	/////////////////////////
	strTest = strNulls;
	strTest.Remove(iseIncluding, 0);
	if (!Compare(*strTest, szText3, sizeof(szText3)/sizeof(ICHAR)))
		goto FAILURE;
	/////////////////////////
	strTest = strNulls;
	strTest.Remove(iseFrom, 0);
	if (!Compare(*strTest, szText4, sizeof(szText4)/sizeof(ICHAR)))
		goto FAILURE;
	/////////////////////////
	strTest = strNulls;
	strTest.Remove(iseAfter, 0);
	if (!Compare(*strTest, szText1, sizeof(szText1)/sizeof(ICHAR)))
		goto FAILURE;
	/////////////////////////
	strTest = strNulls.Extract(iseUpto, 0);
	if (!Compare(*strTest, szText5, sizeof(szText5)/sizeof(ICHAR)))
		goto FAILURE;
	/////////////////////////
	strTest = strNulls.Extract(iseIncluding, 0);
	if (!Compare(*strTest, szText6, sizeof(szText6)/sizeof(ICHAR)))
		goto FAILURE;
	/////////////////////////
	strTest = strNulls.Extract(iseFrom, 0);
	if (!Compare(*strTest, szText7, sizeof(szText7)/sizeof(ICHAR)))
		goto FAILURE;
	/////////////////////////
	strTest = strNulls.Extract(iseAfter, 0);
	if (!Compare(*strTest, szText8, sizeof(szText8)/sizeof(ICHAR)))
		goto FAILURE;

	args = fTrue;
	return;

FAILURE:
	args = fFalse;
	return;
}

void CAutoServices::CreateVolume(CAutoArgs& args)
{
	IMsiVolume* piVol;
	IMsiRecord* piRec = m_riServices.CreateVolume(args[1], piVol);
	if (piRec)
		throw piRec;
	args = new CAutoVolume(*piVol);
}

void CAutoServices::CreateVolumeFromLabel(CAutoArgs& args)
{
	IMsiVolume* piVol;
	if (!m_riServices.CreateVolumeFromLabel(args[1], (idtEnum) (int) args[2], piVol))
		throw MsiServices_CreateVolumeFromLabel;
	args = new CAutoVolume(*piVol);
}

void CAutoServices::CreateCopier(CAutoArgs& args)
{
	IMsiStorage* piStorage = 0;
	if (args.Present(2))
		piStorage = (IMsiStorage*)args[2].ObjectPtr(IID_IMsiStorage);
	IMsiFileCopy* piFileCopy;
	IMsiRecord* piRec = m_riServices.CreateCopier((ictEnum)(int) args[1], piStorage, piFileCopy);
	if (piRec)
		throw piRec;
	args = new CAutoFileCopy(*piFileCopy);
}

void CAutoServices::CreatePatcher(CAutoArgs& args)
{
	IMsiFilePatch* piFilePatch;
	IMsiRecord* piRec = m_riServices.CreatePatcher(piFilePatch);
	if (piRec)
		throw piRec;
	args = new CAutoFilePatch(*piFilePatch);
}

void CAutoServices::EnumDriveType(CAutoArgs& args)
{
	args = m_riServices.EnumDriveType((idtEnum)(int)args[1]);
}

void CAutoServices::ClearAllCaches(CAutoArgs& /*args*/)
{
	m_riServices.ClearAllCaches();
}

void CAutoServices::GetModuleUsage(CAutoArgs& args)
{
	IEnumMsiRecord* piEnumRecord;
	IMsiRecord* piRec = m_riServices.GetModuleUsage(*MsiString(args[1].GetMsiString()), piEnumRecord);
	if (piRec)
		throw piRec;
	args = *piEnumRecord;
}

void CAutoServices::CreateRegKey(CAutoArgs& args)
{
	rrkEnum erRoot;

	if(!IStrCompI(args[1], TEXT("HKEY_CLASSES_ROOT")))
	{
		erRoot =  rrkClassesRoot;                      
	}
	else if(!IStrCompI(args[1], TEXT("HKEY_CURRENT_USER")))
	{
		erRoot =  rrkCurrentUser;                      
	}

	else if(!IStrCompI(args[1], TEXT("HKEY_LOCAL_MACHINE")))
	{
		erRoot =  rrkLocalMachine;                     
	}

	else if(!IStrCompI(args[1], TEXT("HKEY_USERS")))
	{
		erRoot = rrkUsers;                     
	}               
	else
	{
		// error
		IMsiRecord* piError = &m_riServices.CreateRecord(3);
		piError->SetInteger(1, imsgCreateKeyFailed);
		piError->SetString(2, args[1]);
		piError->SetInteger(3, 0);
		throw piError;
	}
	IMsiRegKey& riaRegKeyTmp = m_riServices.GetRootKey(erRoot, ibtCommon);
	IMsiRegKey& riRegKey = riaRegKeyTmp.CreateChild(args[2]);
	args = new CAutoRegKey(riRegKey);
	riaRegKeyTmp.Release();
}

void CAutoServices::RegisterFont(CAutoArgs& args)
{
	IMsiPath* piPath = 0;
	if(args.Present(3))
		piPath = (IMsiPath*)args[3].ObjectPtr(IID_IMsiPath);
	IMsiRecord* piRec = m_riServices.RegisterFont(args[1], args[2], piPath, false);
	if (piRec)
		throw piRec;
}

void CAutoServices::UnRegisterFont(CAutoArgs& args)
{
	IMsiRecord* piRec = m_riServices.UnRegisterFont(args[1]);      
	if (piRec)
		throw piRec;
}

void CAutoServices::WriteIniFile(CAutoArgs& args)
{
	IMsiRecord* piRec;
	IMsiPath* piPath = 0;
	
	if(args.Present(1))
	{
		CVariant& var = args[1];
		if (var.GetType() != VT_EMPTY)
			piPath =  (IMsiPath*)args[1].ObjectPtr(IID_IMsiPath);
	}


	if(args.Present(5))
	{
		piRec = m_riServices.WriteIniFile(  piPath,args[2],args[3],
											args[4],args[5],(iifIniMode)(int)args[6]);
	}
	else
	{
		piRec = m_riServices.WriteIniFile(  piPath,args[2],args[3],
											args[4], 0,(iifIniMode)(int)args[6]);
	}
	if (piRec)
		throw piRec;
}

void CAutoServices::ReadIniFile(CAutoArgs& args)
{
	const IMsiString* pValue;
	IMsiRecord* piRec;
	IMsiPath* piPath = 0;
	if(args.Present(1))
	{
		CVariant& var = args[1];
		if (var.GetType() != VT_EMPTY)
			piPath = (IMsiPath*)args[1].ObjectPtr(IID_IMsiPath);
	}
	unsigned int iField = ((args.Present(5)) ? args[5] : 0);
	piRec = m_riServices.ReadIniFile(piPath,args[2],args[3], args[4], iField, pValue);
	if (piRec)
		throw piRec;
	args = *pValue;
}

void CAutoServices::GetLocalPath(CAutoArgs& args)
{
	args = m_riServices.GetLocalPath(args.Present(1) ? args[1] : (const ICHAR*) 0);
}

void CAutoServices::GetAllocator(CAutoArgs& args)
{
	args = new CAutoMalloc(m_riServices.GetAllocator());
}

void CAutoServices::GetLangNamesFromLangIDString(CAutoArgs& args)
{
	//IMsiRecord* piRecord = &(IMsiRecord&)args[2].Object(IID_IMsiRecord);
	IMsiRecord& riRecord = (IMsiRecord&) args[2].Object(IID_IMsiRecord);
	args = m_riServices.GetLangNamesFromLangIDString(args[1],riRecord,args[3]);
}

void CAutoServices::CreateStorage(CAutoArgs& args)
{
	IMsiStorage* piStorage;
	IMsiRecord* piError = m_riServices.CreateStorage(args[1], (ismEnum)(int)args[2], piStorage);
	if (piError)
		throw piError;
	args = new CAutoStorage(*piStorage);
}

void CAutoServices::GetUnhandledError(CAutoArgs& args)
{
	IMsiRecord* piRec = m_riServices.GetUnhandledError();      
	if (piRec)
		args = new CAutoRecord(*piRec);
	else
		args = (IDispatch*)0;
}

void CAutoServices::SupportLanguageId(CAutoArgs& args)
{
	args = (int)m_riServices.SupportLanguageId(args[1], args[2]);
}

void CAutoServices::CreateShortcut(CAutoArgs& args)
{
	IMsiRecord* pirecShortcutInfo = 0;
	if(args.Present(5))
	{
		CVariant& var = args[5];
		if (var.GetType() != VT_EMPTY)
			pirecShortcutInfo = (IMsiRecord*)args[5].ObjectPtr(IID_IMsiRecord);
	}
	IMsiPath* piTargetPath = 0;
	CVariant& var = args[3];
	if (var.GetType() != VT_EMPTY)
		piTargetPath = (IMsiPath*)args[3].ObjectPtr(IID_IMsiPath);

	const ICHAR* pszTargetName=0;
	if(args.Present(4))
		pszTargetName = args[4];
	IMsiRecord* piError = m_riServices.CreateShortcut((IMsiPath&) args[1].Object(IID_IMsiPath), 
								*MsiString(args[2].GetMsiString()), piTargetPath,
								pszTargetName,pirecShortcutInfo, 0);
	if (piError)
		throw piError;
}

void CAutoServices::RemoveShortcut(CAutoArgs& args)
{
	IMsiPath* piTargetPath = 0;
	if(args.Present(3))
	{
		CVariant& var = args[3];
		if (var.GetType() != VT_EMPTY)
			piTargetPath = (IMsiPath*)args[3].ObjectPtr(IID_IMsiPath);
	}
	const ICHAR* pszTargetName=0;
	if(args.Present(4))
		pszTargetName = args[4];
	IMsiRecord* piError = m_riServices.RemoveShortcut((IMsiPath&)args[1].Object(IID_IMsiPath), 
								*MsiString(args[2].GetMsiString()), piTargetPath,pszTargetName);
	if (piError)
		throw piError;
}

void CAutoServices::GetShellFolderPath(CAutoArgs& args)
{
	const ICHAR* szRegValue = 0;
	if(args.Present(2))
		szRegValue = args[2];
	const IMsiString* pistr;
	IMsiRecord* piError = m_riServices.GetShellFolderPath(args[1],szRegValue,pistr);
	if(piError)
		throw piError;
	args = pistr;
}

void CAutoServices::GetUserProfilePath(CAutoArgs& args)
{
	args = m_riServices.GetUserProfilePath();
}

void CAutoServices::ExtractFileName(CAutoArgs& args)
{
	const IMsiString* pistr;
	IMsiRecord* piError = m_riServices.ExtractFileName(args[1],args[2],pistr);
	if(piError)
		throw piError;
	args = pistr;
}

void CAutoServices::ValidateFileName(CAutoArgs& args)
{
	IMsiRecord* piError = m_riServices.ValidateFileName(args[1],args[2]);
	if(piError)
		throw piError;
}

void CAutoServices::CreateFileStream(CAutoArgs& args)
{
	IMsiStream* piStream;
	IMsiRecord* piError = m_riServices.CreateFileStream(args[1],args[2],piStream);
	if(piError)
		throw piError;
	args = new CAutoStream(*piStream);
}

void CAutoServices::CreateMemoryStream(CAutoArgs& args)
{
	BSTR bstr;
	CVariant& var = args[1];
	if (var.GetType() == VT_BSTR)
		bstr = var.bstrVal;
	else if (var.GetType() == (VT_BYREF | VT_BSTR))
		bstr = *var.pbstrVal;
	else
		throw axInvalidType;

	int cchWide = OLE::SysStringLen(bstr);
	IMsiStream* piStream;
	char* pch = m_riServices.AllocateMemoryStream(cchWide * 2, piStream);
	if (pch == 0)
		throw MsiServices_CreateMemoryStream;   
	memcpy(pch, bstr, cchWide * 2);
	args = new CAutoStream(*piStream);
}

void CAutoServices::RegisterTypeLibrary(CAutoArgs& args)
{
	const ICHAR* szHelpPath = 0;
	if(args.Present(4))
		szHelpPath = args[4];
	IMsiRecord* piError = m_riServices.RegisterTypeLibrary(args[1],(int)args[2],args[3],
																			 szHelpPath,
																			 (ibtBinaryType)(int)args[5]);
	if(piError)
		throw piError;
}

void CAutoServices::UnregisterTypeLibrary(CAutoArgs& args)
{
	IMsiRecord* piError = m_riServices.UnregisterTypeLibrary(args[1],(int)args[2],args[3],
																				(ibtBinaryType)(int)args[4]);
	if(piError)
		throw piError;
}

//____________________________________________________________________________
//
// MsiRecord automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1043-0000-0000-C000-000000000046),  // IID_IMsiAutoRecord
		helpcontext(MsiRecord_Object),helpstring("Record object.")
	]
	dispinterface MsiRecord
	{
		properties:
		methods:
			[id(DISPID_MsiRecord_Data), propget, helpcontext(MsiRecord_Data), helpstring("The Variant value of the indexed field")]
				variant Data([in] unsigned long field);
			[id(DISPID_MsiRecord_Data), propput]
				void Data([in] unsigned long field, [in] variant value);
			[id(DISPID_MsiRecord_StringData), propget, helpcontext(MsiRecord_Data), helpstring("The string value of the indexed field")]
				BSTR StringData([in] unsigned long field);
			[id(DISPID_MsiRecord_StringData), propput]
				void StringData([in] unsigned long field, [in] BSTR value);
			[id(DISPID_MsiRecord_IntegerData), propget, helpcontext(MsiRecord_IntegerData), helpstring("The integer value of the indexed field")]
				long IntegerData([in] unsigned long field);
			[id(DISPID_MsiRecord_IntegerData), propput]
				void IntegerData([in] unsigned long field, [in] long value);
			[id(DISPID_MsiRecord_ObjectData), propget, helpcontext(MsiRecord_ObjectData), helpstring("The object contained in the indexed field")]
				MsiData* ObjectData([in] unsigned long field);
			[id(DISPID_MsiRecord_ObjectData), propput]
				void ObjectData([in] unsigned long field, [in] MsiData* value);
			[id(DISPID_MsiRecord_FieldCount), propget, helpcontext(MsiRecord_FieldCount), helpstring("Number of fields in record")]
				long FieldCount();
			[id(DISPID_MsiRecord_IsInteger), propget, helpcontext(MsiRecord_IsInteger), helpstring("True if indexed field contains integer type")]
				boolean IsInteger([in] unsigned long field);
			[id(DISPID_MsiRecord_IsNull), propget, helpcontext(MsiRecord_IsNull), helpstring("True if indexed field contains a null value")]
				boolean IsNull([in] unsigned long field);
			[id(DISPID_MsiRecord_IsChanged), propget, helpcontext(MsiRecord_IsChanged), helpstring("True if value of indexed field has be set")]
				boolean IsChanged([in] unsigned long field);
			[id(DISPID_MsiRecord_TextSize), propget, helpcontext(MsiRecord_TextSize), helpstring("Size of indexed field obtained as text")]
				BSTR TextSize([in] unsigned long field);
			[id(DISPID_MsiRecord_FormatText), helpcontext(MsiRecord_FormatText), helpstring("Format fields according to template in field 0")]
				BSTR FormatText([in] boolean showComments);
			[id(DISPID_MsiRecord_ClearData), helpcontext(MsiRecord_ClearData), helpstring("Clears all fields in record")]
				void ClearData();
			[id(DISPID_MsiRecord_ClearUpdate), helpcontext(MsiRecord_ClearUpdate), helpstring("Clears changed flags in record")]
				void ClearUpdate();
	};
*/

DispatchEntry<CAutoRecord> AutoRecordTable[] = {
  DISPID_MsiRecord_Data       , aafPropRW, CAutoRecord::Data,       TEXT("Data,field"),
  DISPID_MsiRecord_StringData , aafPropRW, CAutoRecord::StringData, TEXT("StringData,field"),
  DISPID_MsiRecord_IntegerData, aafPropRW, CAutoRecord::IntegerData,TEXT("IntegerData,field"),
  DISPID_MsiRecord_ObjectData , aafPropRW, CAutoRecord::ObjectData, TEXT("ObjectData,field"),
  DISPID_MsiRecord_FieldCount , aafPropRO, CAutoRecord::FieldCount, TEXT("FieldCount"),
  DISPID_MsiRecord_IsInteger  , aafPropRO, CAutoRecord::IsInteger,  TEXT("IsInteger,field"),
  DISPID_MsiRecord_IsNull     , aafPropRO, CAutoRecord::IsNull,     TEXT("IsNull,field"),
  DISPID_MsiRecord_IsChanged  , aafPropRO, CAutoRecord::IsChanged,  TEXT("IsChanged,field"),
  DISPID_MsiRecord_TextSize   , aafPropRO, CAutoRecord::TextSize,   TEXT("TextSize,field"),
  DISPID_MsiRecord_FormatText , aafMethod, CAutoRecord::FormatText, TEXT("FormatText,comments"),
  DISPID_MsiRecord_ClearData  , aafMethod, CAutoRecord::ClearData,  TEXT("ClearData"),
  DISPID_MsiRecord_ClearUpdate, aafMethod, CAutoRecord::ClearUpdate,TEXT("ClearUpdate"),
};
const int AutoRecordCount = sizeof(AutoRecordTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiRecord automation implementation
//____________________________________________________________________________

CAutoRecord::CAutoRecord(IMsiRecord& riRecord)
 : CAutoBase(*AutoRecordTable, AutoRecordCount), m_riRecord(riRecord)
{
	// s_piServices should be set -- you need an engine or services object to create a record
	g_cServicesUsers++;
}

CAutoRecord::~CAutoRecord()
{

	m_riRecord.Release();

	ReleaseStaticServices();

}

IUnknown& CAutoRecord::GetInterface()
{
	return m_riRecord;
}

void CAutoRecord::Data(CAutoArgs& args)
{
	unsigned int iField = args[1];
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		if (var.GetType() == VT_EMPTY)
			m_riRecord.SetNull(iField);
		else if (var.GetType() == VT_BSTR)
			m_riRecord.SetMsiString(iField, *MsiString(var.GetMsiString()));
//		else if (var.GetType() == VT_DATE || var.GetType() == VT_R8)
//			m_riRecord.SetTimeProperty(iField, var);
		else
			m_riRecord.SetInteger(iField, var);
	}
	else
	{
		if (m_riRecord.IsNull(iField))
			args = (varVoid)0;
		else if (m_riRecord.IsInteger(iField))
			args = m_riRecord.GetInteger(iField);
		else
		{
			const IMsiData* piData = m_riRecord.GetMsiData(iField);
			const IMsiString* piString;
			if (piData && piData->QueryInterface(IID_IMsiString, (void**)&piString) == NOERROR)
			{
				piData->Release();
				args = piString;
			}
			else
				args = new CAutoData(piData);
		}
	}
}

void CAutoRecord::StringData(CAutoArgs& args)
{
	unsigned int iField = args[1];
	if (!args.PropertySet())
		args = m_riRecord.GetMsiString(iField);
	else
	{
		CVariant& var = args[0];
		if (!(var.GetType() == VT_EMPTY ? m_riRecord.SetNull(iField)
													: m_riRecord.SetString(iField, var)))
			throw MsiRecord_StringData;
	}
}

void CAutoRecord::IntegerData(CAutoArgs& args)
{
	unsigned int iField = args[1];
	if (!args.PropertySet())
		args = m_riRecord.GetInteger(iField);
	else if (!m_riRecord.SetInteger(iField, args[0]))
		throw MsiRecord_IntegerData;
}

void CAutoRecord::ObjectData(CAutoArgs& args)
{
	unsigned int iField = args[1];
	if (!args.PropertySet())
		args = new CAutoData(m_riRecord.GetMsiData(iField));
	else
	{
		CVariant& var = args[0];
		if (!(var.GetType() == VT_EMPTY ? m_riRecord.SetNull(iField)
			: m_riRecord.SetMsiData(iField, (const IMsiData*)var.ObjectPtr(IID_IMsiData))))
			throw MsiRecord_ObjectData;
	}
}

void CAutoRecord::FieldCount(CAutoArgs& args)
{
	args = m_riRecord.GetFieldCount();
}

void CAutoRecord::IsInteger(CAutoArgs& args)
{
	args = m_riRecord.IsInteger(args[1]);
}

void CAutoRecord::IsNull(CAutoArgs& args)
{
	args = m_riRecord.IsNull(args[1]);
}

void CAutoRecord::IsChanged(CAutoArgs& args)
{
	args = m_riRecord.IsChanged(args[1]);
}

void CAutoRecord::TextSize(CAutoArgs& args)
{
	args = m_riRecord.GetTextSize(args[1]);
}

void CAutoRecord::FormatText(CAutoArgs& args)
{
	Bool fComments = args.Present(1) ? args[1] : fFalse;
	args = m_riRecord.FormatText(fComments);
}

void CAutoRecord::ClearData(CAutoArgs& /*args*/)
{
	m_riRecord.ClearData();
}

void CAutoRecord::ClearUpdate(CAutoArgs& /*args*/)
{
	m_riRecord.ClearUpdate();
}

//____________________________________________________________________________
//
// MsiStorage automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1054-0000-0000-C000-000000000046),  // IID_IMsiAutoStorage
		helpcontext(MsiStorage_Object),helpstring("Structured storage object.")
	]
	dispinterface MsiStorage
	{
		properties:
			[id(DISPID_MsiStorage_Class), helpcontext(MsiStorage_Class), helpstring("The CLSID associated with this storage")]
				BSTR Class;
			[id(DISPID_MsiStorage_Name),helpcontext(MsiStorage_Name),helpstring("The name of the storage")]
				BSTR Name;
		methods:
			[id(DISPID_MsiStorage_OpenStream),helpcontext(MsiStorage_OpenStream),helpstring("Opens a named stream within the storage.")]
					MsiStream* OpenStream(BSTR name, boolean fWrite);
			[id(DISPID_MsiStorage_OpenStorage),helpcontext(MsiStorage_OpenStorage),helpstring("Opens a child storage within the storage.")]
					MsiStorage* OpenStorage(BSTR name, long openMode);
			[id(DISPID_MsiStorage_Streams),helpcontext(MsiStorage_Streams),helpstring("Enumerates the names of all streams the storage.")]
					IEnumVARIANT* Streams();
			[id(DISPID_MsiStorage_Storages),helpcontext(MsiStorage_Storages),helpstring("Enumerates the names of all child storages.")]
					IEnumVARIANT* Storages();
			[id(DISPID_MsiStorage_RemoveElement),helpcontext(MsiStorage_RemoveElement),helpstring("Deletes a stream or child storage.")]
					void RemoveElement(BSTR name, boolean fStorage);
			[id(DISPID_MsiStorage_RenameElement),helpcontext(MsiStorage_RemoveElement),helpstring("Renames a stream or child storage.")]
					void RenameElement(BSTR oldName, BSTR newName, boolean fStorage);
			[id(DISPID_MsiStorage_Commit),helpcontext(MsiStorage_Commit),helpstring("Commits updates to persistent storage.")]
					void Commit();
			[id(DISPID_MsiStorage_Rollback),helpcontext(MsiStorage_Rollback),helpstring("Backs out updates to persistent storage.")]
					void Rollback();
			[id(DISPID_MsiStorage_DeleteOnRelease),helpcontext(MsiStorage_DeleteOnRelease),helpstring("Removes a file or substorage when object is destructed.")]
					boolean DeleteOnRelease();
			[id(DISPID_MsiStorage_CreateSummaryInfo),helpcontext(MsiStorage_CreateSummaryInfo),helpstring("Returns an MsiSummaryInfo object to read/write standard document properties.")]
					MsiSummaryInfo* CreateSummaryInfo(long maxProperties);
			[id(DISPID_MsiStorage_CopyTo),helpcontext(MsiStorage_CopyTo),helpstring("Copys a storage to the destination storage, optionally excluding elements")]
					void CopyTo(MsiStorage* destStorage, MsiRecord* excludedElements);
	};              
*/

DispatchEntry<CAutoStorage> AutoStorageTable[] = {
	DISPID_MsiStorage_Class            , aafPropRW, CAutoStorage::Class,              TEXT("Class"),
	DISPID_MsiStorage_OpenStream       , aafMethod, CAutoStorage::OpenStream,         TEXT("OpenStream,name,fWrite"),
	DISPID_MsiStorage_OpenStorage      , aafMethod, CAutoStorage::OpenStorage,        TEXT("OpenStorage,name,openMode"),
	DISPID_MsiStorage_Streams          , aafMethod, CAutoStorage::Streams,            TEXT("Streams"),
	DISPID_MsiStorage_Storages         , aafMethod, CAutoStorage::Storages,           TEXT("Storages"),
	DISPID_MsiStorage_RemoveElement    , aafMethod, CAutoStorage::RemoveElement,      TEXT("RemoveElement,name,fStorage"),
	DISPID_MsiStorage_RenameElement    , aafMethod, CAutoStorage::RenameElement,      TEXT("RenameElement,oldName,newName,fStorage"),
	DISPID_MsiStorage_Commit           , aafMethod, CAutoStorage::Commit,             TEXT("Commit"),
	DISPID_MsiStorage_Rollback         , aafMethod, CAutoStorage::Rollback,           TEXT("Rollback"),
	DISPID_MsiStorage_DeleteOnRelease  , aafMethod, CAutoStorage::DeleteOnRelease,    TEXT("DeleteOnRelease"),
	DISPID_MsiStorage_CreateSummaryInfo, aafMethod, CAutoStorage::CreateSummaryInfo,  TEXT("CreateSummaryInfo,maxProperties"),
	DISPID_MsiStorage_CopyTo           , aafMethod, CAutoStorage::CopyTo,             TEXT("CopyTo,destStorage,excludedElements"),
	DISPID_MsiStorage_Name             , aafPropRO, CAutoStorage::Name,               TEXT("Name,storage"),
};
const int AutoStorageCount = sizeof(AutoStorageTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiStorage automation implementation
//____________________________________________________________________________

CAutoStorage::CAutoStorage(IMsiStorage& riStorage)
 : CAutoBase(*AutoStorageTable, AutoStorageCount), m_riStorage(riStorage)
{
}

CAutoStorage::~CAutoStorage()
{
	m_riStorage.Release();
}

IUnknown& CAutoStorage::GetInterface()
{
	return m_riStorage;
}

void CAutoStorage::Class(CAutoArgs& args)
{
	GUID guid;
	OLECHAR rgwchGuid[40];
	if (!args.PropertySet())
	{
		if (!m_riStorage.GetClass(&guid))
			args = (varVoid)0;
		else
		{
			OLE::StringFromGUID2(guid, rgwchGuid, 40);
			args = rgwchGuid;
		}
	}
	else
	{
		if (OLE::IIDFromString((wchar_t*)(const wchar_t*)args[0], &guid) != NOERROR)
			throw MsiStorage_Class;
		IMsiRecord* piError = m_riStorage.SetClass(guid);
		if (piError)
			throw piError;
	}
}

void CAutoStorage::Name(CAutoArgs& args)
{
	IMsiRecord* piError = 0;
	const IMsiString* piName;

	if ((piError = m_riStorage.GetName(piName)) == 0)
	{
		args = piName->GetString();
		piName->Release();
	}
	else
	{
		piError->Release();
		args = (varVoid)0;
	}
}

void CAutoStorage::OpenStream(CAutoArgs& args)
{
	IMsiStream* piStream;
	IMsiRecord* piError = m_riStorage.OpenStream(args[1], args[2], piStream);
	if (piError)
		throw piError;
	args = new CAutoStream(*piStream);
}

void CAutoStorage::OpenStorage(CAutoArgs& args)
{
	IMsiStorage* piStorage;
	IMsiRecord* piError = m_riStorage.OpenStorage(args[1], (ismEnum)(int)args[2], piStorage);
	if (piError)
		throw piError;
	args = new CAutoStorage(*piStorage);
}

void CAutoStorage::Streams(CAutoArgs& args)
{
	IEnumMsiString* piEnum = m_riStorage.GetStreamEnumerator();
	if (!piEnum)
		throw MsiStorage_Streams;
	args = *piEnum;
}

void CAutoStorage::Storages(CAutoArgs& args)
{
	IEnumMsiString* piEnum = m_riStorage.GetStorageEnumerator();
	if (!piEnum)
		throw MsiStorage_Storages;
	args = *piEnum;
}

void CAutoStorage::RemoveElement(CAutoArgs& args)
{
	Bool fStorage = fFalse;
	if (args.Present(2))
		fStorage = args[2];
	IMsiRecord* piError = m_riStorage.RemoveElement(args[1], fStorage);
	if (piError)
		throw piError;
}

void CAutoStorage::RenameElement(CAutoArgs& args)
{
	Bool fStorage = fFalse;
	if (args.Present(3))
		fStorage = args[3];
	IMsiRecord* piError = m_riStorage.RenameElement(args[1], args[2], fStorage);
	if (piError)
		throw piError;
}

void CAutoStorage::Commit(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riStorage.Commit();
	if (piError)
		throw piError;
}

void CAutoStorage::Rollback(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riStorage.Rollback();
	if (piError)
		throw piError;
}

void CAutoStorage::DeleteOnRelease(CAutoArgs& args)
{
	args = m_riStorage.DeleteOnRelease(false);
}

void CAutoStorage::CreateSummaryInfo(CAutoArgs& args)
{
	IMsiSummaryInfo* piSummary;
	IMsiRecord* piError = m_riStorage.CreateSummaryInfo(args[1], piSummary);
	if (piError)
		throw piError;
	args =  new CAutoSummaryInfo(*piSummary);
}

void CAutoStorage::CopyTo(CAutoArgs& args)
{
	IMsiRecord* piExcluded = 0;

	if (args.Present(2))
		piExcluded = &(IMsiRecord&)args[2].Object(IID_IMsiRecord);

	IMsiRecord* piError = m_riStorage.CopyTo(
		(IMsiStorage&)args[1].Object(IID_IMsiStorage),
		piExcluded);

	if (piError)
		throw piError;
}

//____________________________________________________________________________
//
// MsiStream automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1055-0000-0000-C000-000000000046),  // IID_IMsiAutoStream
		helpcontext(MsiStream_Object),helpstring("Database view object.")
	]
	dispinterface MsiStream
	{
		properties:
		methods:
			[id(1) ,propget,helpcontext(MsiStream_Length),helpstring("Returns the size of the stream in bytes.")]
					long Length();
			[id(2) ,propget,helpcontext(MsiStream_Remaining),helpstring("Returns the number of bytes remaining in the stream.")]
					long Remaining();
			[id(3) ,propget,helpcontext(MsiStream_Error),helpstring("Returns a boolean indicating if a transfer error occurred.")]
					boolean Error();
			[id(4),helpcontext(MsiStream_GetData),helpstring("Copies the next count bytes into a string of that size and returns that string.")]
					BSTR GetData(long count);
			[id(5),helpcontext(MsiStream_PutData),helpstring("Copies all bytes from the string into the stream.")]
					void PutData(BSTR buffer);
			[id(6),helpcontext(MsiStream_GetInt16),helpstring("Returns the next 2 bytes as a short integer.")]
					short GetInt16();
			[id(7),helpcontext(MsiStream_GetInt32),helpstring("Returns the next 4 bytes as a long integer.")]
					long GetInt32();
			[id(8),helpcontext(MsiStream_PutInt16),helpstring("Writes the short integer into the next 2 bytes in the stream.")]
					void PutInt16(short value);
			[id(9),helpcontext(MsiStream_PutInt32),helpstring("Writes the long integer into the next 4 bytes in the stream.")]
					void PutInt32(long value);
			[id(10),helpcontext(MsiStream_Reset),helpstring("Resets the stream pointer to the start of stream.")]
					void Reset();
			[id(11),helpcontext(MsiStream_Seek),helpstring("Sets the stream pointer to a new location.")]
					void Seek(long position);
			[id(12),helpcontext(MsiStream_Clone),helpstring("Creates a clone of the stream object.")]
					MsiStream* Clone();
	};
*/

DispatchEntry<CAutoStream> AutoStreamTable[] = {
	1, aafPropRO, CAutoStream::Length,        TEXT("Length"),
	2, aafPropRO, CAutoStream::Remaining,     TEXT("Remaining"),
	3, aafPropRO, CAutoStream::Error,         TEXT("Error"),
	4, aafMethod, CAutoStream::GetData,       TEXT("GetData,count"),
	5, aafMethod, CAutoStream::PutData,       TEXT("PutData,buffer"),
	6, aafMethod, CAutoStream::GetInt16,      TEXT("GetInt16"),
	7, aafMethod, CAutoStream::GetInt32,      TEXT("GetInt32"),
	8, aafMethod, CAutoStream::PutInt16,      TEXT("PutInt16,value"),
	9, aafMethod, CAutoStream::PutInt32,      TEXT("PutInt32,value"),
	10, aafMethod, CAutoStream::Reset,        TEXT("Reset"),
	11, aafMethod, CAutoStream::Seek,         TEXT("Seek,position"),
	12, aafMethod, CAutoStream::Clone,        TEXT("Clone"),
};
const int AutoStreamCount = sizeof(AutoStreamTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiStream automation implementation
//____________________________________________________________________________

CAutoStream::CAutoStream(IMsiStream& riStream)
 : CAutoBase(*AutoStreamTable, AutoStreamCount), m_riStream(riStream)
{
}

CAutoStream::~CAutoStream()
{
	m_riStream.Release();
}

IUnknown& CAutoStream::GetInterface()
{
	return m_riStream;
}

void CAutoStream::Length(CAutoArgs& args)
{
	args = m_riStream.GetIntegerValue();
}

void CAutoStream::Remaining(CAutoArgs& args)
{
	args = (int)m_riStream.Remaining();
}

void CAutoStream::Error(CAutoArgs& args)
{
	args = m_riStream.Error();
}

void CAutoStream::GetData(CAutoArgs& args)
{
	int cb = args[1];
	if (cb > m_riStream.Remaining())
		cb = m_riStream.Remaining();
	const IMsiString* piStr = g_piStringNull;
#ifdef UNICODE
	CAPITempBuffer<char, 1024> rgchBuf;
	if (!rgchBuf.SetSize(cb))
		throw MsiStream_GetData;
	int cbRead = (int)m_riStream.GetData(rgchBuf, cb);
	int cch = WIN::MultiByteToWideChar(CP_ACP, 0, rgchBuf, cb, 0, 0); //!! should use m_iCodepage from database, but how?
	ICHAR* pch = piStr->AllocateString(cch, fFalse, piStr);
	WIN::MultiByteToWideChar(CP_ACP, 0, rgchBuf, cb, pch, cch);
#else
	ICHAR* pch = piStr->AllocateString(cb, fFalse, piStr);
	int cbRead = (int)m_riStream.GetData(pch, cb);
#endif
	args = piStr;
}

void CAutoStream::PutData(CAutoArgs& args)
{
	const IMsiString& riData = args[1].GetMsiString();
#ifdef UNICODE
	int cch = riData.TextSize();
	CAPITempBuffer<char, 1024> rgchBuf;
	unsigned int cb = WIN::WideCharToMultiByte(CP_ACP, 0, riData.GetString(), cch, 0, 0, 0, 0);
	if (!rgchBuf.SetSize(cb))
		throw MsiStream_PutData;
	WIN::WideCharToMultiByte(CP_ACP, 0, riData.GetString(), cch, rgchBuf, cb, 0, 0);
	m_riStream.PutData(rgchBuf, cb);
	riData.Release();
#else
	m_riStream.PutData((const ICHAR*)MsiString(riData), riData.TextSize());
#endif
}

void CAutoStream::GetInt16(CAutoArgs& args)
{
	args = m_riStream.GetInt16();
}

void CAutoStream::GetInt32(CAutoArgs& args)
{
	args = m_riStream.GetInt32();
}

void CAutoStream::PutInt16(CAutoArgs& args)
{
	m_riStream.PutInt16(args[1]);
}

void CAutoStream::PutInt32(CAutoArgs& args)
{
	m_riStream.PutInt32(args[1]);
}

void CAutoStream::Reset(CAutoArgs& /*args*/)
{
	m_riStream.Reset();
}

void CAutoStream::Seek(CAutoArgs& args)
{
	m_riStream.Seek(args[1]);
}

void CAutoStream::Clone(CAutoArgs& args)
{
	IMsiStream* piStream = m_riStream.Clone();
	if (piStream == 0)
		throw MsiStream_Clone;
	args = new CAutoStream(*piStream);
}

//____________________________________________________________________________
//
// MsiSummaryInfo automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1056-0000-0000-C000-000000000046),  // IID_IMsiAutoSummaryInfo
		helpcontext(MsiSummaryInfo_Object),helpstring("SummaryInformation stream property management.")
	]
	dispinterface MsiSummaryInfo
	{
		properties:
		methods:
			[id(0),propget, helpcontext(MsiSummaryInfo_Property),helpstring("Reads, writes, or deletes a specifed property from the stream.")]
				variant Property([in] long pid);
			[id(0),propput]
				void Property([in] long pid, [in] variant value);
			[id(1),propget,helpcontext(MsiSummaryInfo_PropertyCount),helpstring("The number of old and new properties currently in the object.")]
					long PropertyCount();
			[id(2),propget,helpcontext(MsiSummaryInfo_PropertyType),helpstring("The type of the property with the specified ID.")]
					long PropertyType([in] long pid);
			[id(3),helpcontext(MsiSummaryInfo_WritePropertyStream),helpstring("Generates the summary stream from the specified properties.")]
					void WritePropertyStream();
	};              
*/

DispatchEntry<CAutoSummaryInfo> AutoSummaryInfoTable[] = {
	0, aafPropRW, CAutoSummaryInfo::Property,           TEXT("Property,pid"),
	1, aafPropRO, CAutoSummaryInfo::PropertyCount,      TEXT("PropertyCount"),
	2, aafPropRO, CAutoSummaryInfo::PropertyType,       TEXT("PropertyType,pid"),
   3, aafMethod, CAutoSummaryInfo::WritePropertyStream,TEXT("WritePropertyStream"),
};
const int AutoSummaryInfoCount = sizeof(AutoSummaryInfoTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// MsiSummaryInfo automation implementation
//____________________________________________________________________________

CAutoSummaryInfo::CAutoSummaryInfo(IMsiSummaryInfo& riSummaryInfo)
 : CAutoBase(*AutoSummaryInfoTable, AutoSummaryInfoCount), m_riSummary(riSummaryInfo)
{
	// s_piServices should be set -- you need a services object to create an autosummary
	g_cServicesUsers++;
}

CAutoSummaryInfo::~CAutoSummaryInfo()
{
	m_riSummary.Release();
	ReleaseStaticServices();
}

IUnknown& CAutoSummaryInfo::GetInterface()
{
	return m_riSummary;
}

void CAutoSummaryInfo::Property(CAutoArgs& args)
{
	int iPID = args[1];
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		if (var.GetType() == VT_EMPTY)
			m_riSummary.RemoveProperty(iPID);
		else if (var.GetType() == VT_BSTR)
			m_riSummary.SetStringProperty(iPID, *MsiString(var.GetMsiString()));
		else if (var.GetType() == VT_DATE || var.GetType() == VT_R8)
			m_riSummary.SetTimeProperty(iPID, var);
		else
			m_riSummary.SetIntegerProperty(iPID, var);
	}
	else
	{
		int iType = m_riSummary.GetPropertyType(iPID);
		int i;
		MsiDate iDateTime;
		switch (iType)
		{
			case VT_EMPTY:
				args = (varVoid)0;
				break;
			case VT_I2:
				m_riSummary.GetIntegerProperty(iPID, i);
				args = short(i);
				break;
			case VT_I4:
				m_riSummary.GetIntegerProperty(iPID, i);
				args = i;
				break;
			case VT_LPSTR:
				args = m_riSummary.GetStringProperty(iPID);
				break;
			case VT_FILETIME:
				m_riSummary.GetTimeProperty(iPID, iDateTime);
				args = iDateTime;
				break;
			default:
				args = TEXT("[Unhandled property type]");
		};
	}
}

void CAutoSummaryInfo::PropertyCount(CAutoArgs& args)
{
	args = m_riSummary.GetPropertyCount();
}

void CAutoSummaryInfo::PropertyType(CAutoArgs& args)
{
	args = m_riSummary.GetPropertyType(args[1]);
}

void CAutoSummaryInfo::WritePropertyStream(CAutoArgs& /*args*/)
{
	if (!m_riSummary.WritePropertyStream())
		throw MsiSummaryInfo_WritePropertyStream;
}

//____________________________________________________________________________
//
// MsiDatabase automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C104D-0000-0000-C000-000000000046),  // IID_IMsiAutoDatabase
		helpcontext(MsiDatabase_Object),helpstring("Database object.")
	]
	dispinterface MsiDatabase
	{
		properties:
		methods:
			[id(1),propget, helpcontext(MsiDatabase_UpdateState),helpstring("The persistent state of the database, idsEnum")]
					long UpdateState();
			[id(2),propget, helpcontext(MsiDatabase_Storage),helpstring("The selected MsiStorage object, if present")]
					MsiStorage* Storage(long index);
			[id(3),helpcontext(MsiDatabase_OpenView),helpstring("Opens a view using an SQL query string")]
					MsiView* OpenView(BSTR sql, long intent);
			[id(4),helpcontext(MsiDatabase_GetPrimaryKeys),helpstring("Returns a record containing the table name and each primary key column name")]
					MsiRecord* GetPrimaryKeys(BSTR table);
			[id(5),helpcontext(MsiDatabase_ImportTable),helpstring("Imports an IDT format text file to the database, dropping any existing table")]
					void ImportTable(MsiPath* path, BSTR file);
			[id(6),helpcontext(MsiDatabase_ExportTable),helpstring("Exports the specified table to an IDT format text file")]
					void ExportTable(BSTR table, MsiPath* path, BSTR file);
			[id(7),helpcontext(MsiDatabase_DropTable),helpstring("Drops the specified table from the database")]
					void DropTable(BSTR table);
			[id(8),helpcontext(MsiDatabase_FindTable),helpstring("Returns the status for a table in the database")]
					long FindTable(BSTR table);
			[id(9),helpcontext(MsiDatabase_LoadTable),helpstring("Loads an existing table into memory")]
					MsiTable* LoadTable(BSTR table, long addColumns);
			[id(10),helpcontext(MsiDatabase_CreateTable),helpstring("Creates a temporary table in memory")]
					MsiTable* CreateTable(BSTR table, long initRows);
			[id(11),helpcontext(MsiDatabase_LockTable),helpstring("Hint to keep table loaded")]
					boolean LockTable(BSTR table, boolean lock);
			[id(12),helpcontext(MsiDatabase_GetCatalogTable),helpstring("Returns the database table catalog object")]
					MsiTable* GetCatalogTable(long table);
			[id(13),helpcontext(MsiDatabase_DecodeString),helpstring("Converts a string index to the actual string")]
					BSTR DecodeString(long index);
			[id(14),helpcontext(MsiDatabase_EncodeString),helpstring("Converts a string to its string index")]
					long EncodeString(BSTR text);
			[id(15),helpcontext(MsiDatabase_CreateTempTableName),helpstring("Creates a unique name for temporary table")]
					BSTR CreateTempTableName();
			[id(16),helpcontext(MsiDatabase_Commit),helpstring("Commits persistent updates to storage")]
					void Commit();
			[id(17),helpcontext(MsiDatabase_CreateOutputDatabase),helpstring("Establishes separate output database")]
					void CreateOutputDatabase(BSTR file, boolean saveTempRows);
			[id(18),helpcontext(MsiDatabase_GenerateTransform),helpstring("Generates a transform file")]
					void GenerateTransform(MsiDatabase* reference, MsiStorage* transform, long errorConditions, long validation);
			[id(19),helpcontext(MsiDatabase_SetTransform),helpstring("Sets a transform file")]
					void SetTransform(MsiStorage* transform, long errorConditions );
			[id(20),helpcontext(MsiDatabase_MergeDatabase),helpstring("Merges two databases into base database")]
					void MergeDatabase(MsiDatabase* reference, MsiTable* errorTable);
			[id(21),propget, helpcontext(MsiDatabase_TableState),helpstring("Returns an attribute for a table in the database")]
					boolean TableState(BSTR table, long state);
			[id(22),propget, helpcontext(MsiDatabase_ANSICodePage),helpstring("Returns the codepage of the database, 0 if neutral")]
					long ANSICodePage();
	};
*/

DispatchEntry<CAutoDatabase> AutoDatabaseTable[] = {
	1, aafPropRO, CAutoDatabase::UpdateState,    TEXT("UpdateState"),
	2, aafPropRO, CAutoDatabase::Storage,        TEXT("Storage,index"),
	3, aafMethod, CAutoDatabase::OpenView,       TEXT("OpenView,sql,intent"),
	4, aafMethod, CAutoDatabase::GetPrimaryKeys, TEXT("GetPrimaryKeys,table"),
	5, aafMethod, CAutoDatabase::ImportTable,    TEXT("ImportTable,path,file"),
	6, aafMethod, CAutoDatabase::ExportTable,    TEXT("ExportTable,table,path,file"),
	7, aafMethod, CAutoDatabase::DropTable,      TEXT("DropTable,table"),
	8, aafMethod, CAutoDatabase::FindTable,      TEXT("FindTable,table"),
	9, aafMethod, CAutoDatabase::LoadTable,      TEXT("LoadTable,table,addColumns"),
	10,aafMethod, CAutoDatabase::CreateTable,    TEXT("CreateTable,table,initRows"),
	11,aafMethod, CAutoDatabase::LockTable,      TEXT("LockTable,table,lock"),   
	12,aafMethod, CAutoDatabase::GetCatalogTable,TEXT("GetCatalogTable,table"),
	13,aafMethod, CAutoDatabase::DecodeString,   TEXT("DecodeString,index"),
	14,aafMethod, CAutoDatabase::EncodeString,   TEXT("EncodeString,text"),
	15,aafMethod, CAutoDatabase::CreateTempTableName, TEXT("CreateTempTableName"),
	16,aafMethod, CAutoDatabase::Commit,         TEXT("Commit"),
	17,aafMethod, CAutoDatabase::CreateOutputDatabase,TEXT("CreateOutputDatabase,file,saveTempRows"),
	18,aafMethod, CAutoDatabase::GenerateTransform,TEXT("GenerateTransform,reference,transform,errorConditions,validation"),
	19,aafMethod, CAutoDatabase::SetTransform,   TEXT("SetTransform,storage,errorConditions"),
	20,aafMethod, CAutoDatabase::MergeDatabase, TEXT("MergeDatabase,reference,errorTable"),
	21,aafPropRO, CAutoDatabase::TableState,    TEXT("TableState,table,state"),
	22,aafPropRO, CAutoDatabase::ANSICodePage,  TEXT("ANSICodePage"),
};
const int AutoDatabaseCount = sizeof(AutoDatabaseTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CAutoDatabase automation implementation
//____________________________________________________________________________

CAutoDatabase::CAutoDatabase(IMsiDatabase& riDatabase)
 : CAutoBase(*AutoDatabaseTable, AutoDatabaseCount),
	m_riDatabase(riDatabase)
{
}

CAutoDatabase::~CAutoDatabase()
{
	m_riDatabase.Release();
}

IUnknown& CAutoDatabase::GetInterface()
{
	return m_riDatabase;
}

void CAutoDatabase::UpdateState(CAutoArgs& args)
{
	args = (int)m_riDatabase.GetUpdateState();
}

void CAutoDatabase::Storage(CAutoArgs& args)
{
	IMsiStorage* piStorage = m_riDatabase.GetStorage(args[1]);
	if (piStorage)
		args = new CAutoStorage(*piStorage);
	else
		args = (IDispatch*)0;
}

void CAutoDatabase::OpenView(CAutoArgs& args)
{
	IMsiView* piView;
	IMsiRecord* piError = m_riDatabase.OpenView(args[1], (ivcEnum)(int)args[2], piView);
	if (piError)
		throw piError;
	args = new CAutoView(*piView);
}

void CAutoDatabase::GetPrimaryKeys(CAutoArgs& args)
{
	IMsiRecord* piRecord = m_riDatabase.GetPrimaryKeys(args[1]);
	if (!piRecord)
		args = (IDispatch*)0;
	else
		args = new CAutoRecord(*piRecord);
	return;
}

void CAutoDatabase::ExportTable(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDatabase.ExportTable(args[1], (IMsiPath&)args[2].Object(IID_IMsiPath), args[3]);
	if (piError)
		throw piError;
}

void CAutoDatabase::ImportTable(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDatabase.ImportTable((IMsiPath&)args[1].Object(IID_IMsiPath), args[2]);
	if (piError)
		throw piError;
}

void CAutoDatabase::DropTable(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDatabase.DropTable(args[1]);
	if (piError)
		throw piError;
}

void CAutoDatabase::FindTable(CAutoArgs& args)
{
	args = (int)m_riDatabase.FindTable(*MsiString(args[1].GetMsiString()));
}

void CAutoDatabase::TableState(CAutoArgs& args)
{
	args = (Bool)m_riDatabase.GetTableState((const ICHAR * )args[1],
													(itsEnum)(int)args[2]);
}

void CAutoDatabase::ANSICodePage(CAutoArgs& args)
{
	args = m_riDatabase.GetANSICodePage();
}

void CAutoDatabase::LoadTable(CAutoArgs& args)
{
	unsigned int cAddColumns = 0;
	if(args.Present(2))
		cAddColumns = args[2];
	IMsiTable* piTable;
	IMsiRecord* piError = m_riDatabase.LoadTable(*MsiString(args[1].GetMsiString()),
																cAddColumns, piTable);
	if (piError)
		throw piError;
	args = new CAutoTable(*piTable);
}

void CAutoDatabase::CreateTable(CAutoArgs& args)
{
	unsigned int cInitRows = 0;
	if(args.Present(2))
		cInitRows = args[2];
	IMsiTable* piTable;
	IMsiRecord* piError = m_riDatabase.CreateTable(*MsiString(args[1].GetMsiString()),
																  cInitRows, piTable);
	if (piError)
		throw piError;
	args = new CAutoTable(*piTable);
}

void CAutoDatabase::LockTable(CAutoArgs& args)
{
	args = m_riDatabase.LockTable(*MsiString(args[1].GetMsiString()), args[2]);
}

void CAutoDatabase::GetCatalogTable(CAutoArgs& args)
{
	IMsiTable* piTable = m_riDatabase.GetCatalogTable(args[1]);
	if (!piTable)
		throw MsiDatabase_GetCatalogTable;
	args = new CAutoTable(*piTable);
}

void CAutoDatabase::DecodeString(CAutoArgs& args)
{
	args = m_riDatabase.DecodeString(args[1]);
}

void CAutoDatabase::EncodeString(CAutoArgs& args)
{
	args = (int)m_riDatabase.EncodeString(*MsiString(args[1].GetMsiString()));
}

void CAutoDatabase::CreateTempTableName(CAutoArgs& args)
{
	args = m_riDatabase.CreateTempTableName();
}

void CAutoDatabase::Commit(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riDatabase.Commit();
	if (piError)
		throw piError;
}

void CAutoDatabase::CreateOutputDatabase(CAutoArgs& args)
{
	Bool fSaveTempRows = args.Present(2) ? args[2] : fFalse;
	IMsiRecord* piError = m_riDatabase.CreateOutputDatabase(args[1], fSaveTempRows);
	if (piError)
		throw piError;
}

void CAutoDatabase::GenerateTransform(CAutoArgs& args)
{
	CVariant& var = args[2];

	IMsiRecord* piError = m_riDatabase.GenerateTransform(
		(IMsiDatabase&)args[1].Object(IID_IMsiDatabase), 
		var.GetType() == VT_EMPTY ? 0 : (IMsiStorage*)var.ObjectPtr(IID_IMsiStorage),
   	args[3],
		args[4]);

	if (piError)
		throw piError;
}

void CAutoDatabase::SetTransform(CAutoArgs& args)
{
	IMsiRecord* piError = 
       m_riDatabase.SetTransform((IMsiStorage&)args[1].Object(IID_IMsiStorage),
                                 args[2]);
	if (piError)
		throw piError;
}

void CAutoDatabase::MergeDatabase(CAutoArgs& args)
{
	IMsiTable* piTable = NULL;
	if (args.Present(2))
		piTable = &(IMsiTable&)args[2].Object(IID_IMsiTable);
	IMsiRecord* piError =
		m_riDatabase.MergeDatabase((IMsiDatabase&)args[1].Object(IID_IMsiDatabase),
								   piTable);
	if (piError)
		throw piError;
}



//____________________________________________________________________________
//
// MsiView automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C104C-0000-0000-C000-000000000046),  // IID_IMsiAutoView
		helpcontext(MsiView_Object),helpstring("Database view object.")
	]
	dispinterface MsiView
	{
		properties:
		methods:
			[id(1),helpcontext(MsiView_Execute),helpstring("Accepts query parameters and executes the database query.")]
					void Execute(MsiRecord* record);
			[id(2) ,propget,helpcontext(MsiView_FieldCount),helpstring("Returns the number of columns fetched into MsiRecord fields.")]
					long FieldCount();
			[id(3),helpcontext(MsiView_Fetch),helpstring("Returns an MsiRecord object containing the requested column data if more rows are available.")]
					MsiRecord* Fetch();
			[id(4),helpcontext(MsiView_GetColumnNames),helpstring("Returns an MsiRecord object containing the columns names corresponding to the fetched record fields.")]
					MsiRecord* GetColumnNames();
			[id(5),helpcontext(MsiView_GetColumnTypes),helpstring("Returns an MsiRecord objects with text fields containing the data types of the columns.")]
					MsiRecord* GetColumnTypes();
			[id(6),helpcontext(MsiView_Modify),helpstring("Performs specified action on a MsiRecord object corresponding to a Database row.")]
					void Modify(MsiRecord* record, long action);
			[id(7),propget,helpcontext(MsiView_RowCount),helpstring("Returns the number of rows affected by MsiView.Execute.")]
					long RowCount();
			[id(8),helpcontext(MsiView_Close),helpstring("Terminates query execution and releases database resources.")]
					void Close();
			[id(9),helpcontext(MsiView_GetError),helpstring("Returns column name and error that occured")]
					BSTR GetError();
			[id(10),helpcontext(MsiView_State),helpstring("Returns the current cursor state of the view object")]
					long State();
	};              
*/

DispatchEntry<CAutoView> AutoViewTable[] = {
	1, aafMethod, CAutoView::Execute,       TEXT("Execute,record"),
	2, aafPropRO, CAutoView::FieldCount,    TEXT("FieldCount"),
	3, aafMethod, CAutoView::Fetch,         TEXT("Fetch"),
	4, aafMethod, CAutoView::GetColumnNames,TEXT("GetColumnNames"),
	5, aafMethod, CAutoView::GetColumnTypes,TEXT("GetColumnTypes"),
	6, aafMethod, CAutoView::Modify,        TEXT("Modify,record,action"),
	7, aafPropRO, CAutoView::RowCount,      TEXT("RowCount"),
	8, aafMethod, CAutoView::Close,         TEXT("Close"),
	9, aafMethod, CAutoView::GetError,		TEXT("GetError"),
	10,aafPropRO, CAutoView::State,         TEXT("State"),
};
const int AutoViewCount = sizeof(AutoViewTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiView automation implementation
//____________________________________________________________________________

CAutoView::CAutoView(IMsiView& riView)
 : CAutoBase(*AutoViewTable, AutoViewCount), m_riView(riView)
{
}

CAutoView::~CAutoView()
{
	m_riView.Release();
}

IUnknown& CAutoView::GetInterface()
{
	return m_riView;
}

void CAutoView::Execute(CAutoArgs& args)
{
	IMsiRecord* piRecord= args.Present(1) ? &(IMsiRecord&)args[1].Object(IID_IMsiRecord) : 0;
	IMsiRecord* piError = m_riView.Execute(piRecord);
	if (piError)
		throw piError;
	return;
}

void CAutoView::FieldCount(CAutoArgs& args)
{
	args = (int)m_riView.GetFieldCount();
}

void CAutoView::GetColumnNames(CAutoArgs& args)
{
	IMsiRecord* piRecord = m_riView.GetColumnNames();
	if (!piRecord)
		args = (IDispatch*)0;
	else
		args = new CAutoRecord(*piRecord);
	return;
}

void CAutoView::GetColumnTypes(CAutoArgs& args)
{
	IMsiRecord* piRecord = m_riView.GetColumnTypes();
	if (!piRecord)
		args = (IDispatch*)0;
	else
		args = new CAutoRecord(*piRecord);
	return;
}

void CAutoView::Fetch(CAutoArgs& args)
{
	IMsiRecord* piRecord = m_riView.Fetch();
	if (!piRecord)
		args = (IDispatch*)0;
	else
		args = new CAutoRecord(*piRecord);
	return;
}

void CAutoView::Modify(CAutoArgs& args)
{
	IMsiRecord* piError = m_riView.Modify((IMsiRecord&)args[1].Object(IID_IMsiRecord), (irmEnum)(int)args[2]);
	if (piError)
		throw piError;
}

void CAutoView::Close(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riView.Close();
	if (piError)
		throw piError;
}

void CAutoView::GetError(CAutoArgs& args)
{
	MsiString strCol;
	iveEnum iveReturn = m_riView.GetError(*&strCol);
	strCol += MsiChar(',');
	strCol += MsiChar(int(iveReturn));
	args = (const ICHAR*)strCol;
}

void CAutoView::RowCount(CAutoArgs& args)
{
	long lRowCount;
	IMsiRecord* piError = m_riView.GetRowCount(lRowCount);
	if (piError)
		throw piError;
	args = lRowCount;
}

void CAutoView::State(CAutoArgs& args)
{
	args = (int)m_riView.GetState();
}

//____________________________________________________________________________
//
// MsiData automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1041-0000-0000-C000-000000000046),  // IID_IMsiAutoData
		helpcontext(MsiData_Object),helpstring("Data value base object.")
	]
	dispinterface MsiData
	{
		properties:
			[id(0), helpcontext(MsiData_StringValue), helpstring("String value of the object")]
				BSTR StringValue;
		methods:
			[id(1), propget, helpcontext(MsiData_IntegerValue), helpstring("Integer value for object")]
				long IntegerValue();
	};
*/
  
DispatchEntry<CAutoData> AutoDataTable[] = {
	0, aafPropRO, CAutoData::StringValue,   TEXT("StringValue"),
	1, aafPropRO, CAutoData::IntegerValue,  TEXT("IntegerValue"),
};
const int AutoDataCount = sizeof(AutoDataTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CAutoData automation implementation
//____________________________________________________________________________

CAutoData::CAutoData(const IMsiData* piData)
 : CAutoBase(*AutoDataTable, AutoDataCount), m_piData(piData)
{
}

CAutoData::~CAutoData()
{
	if (m_piData)
		m_piData->Release();
}

IUnknown& CAutoData::GetInterface()
{
	if (m_piData)
		return *(IUnknown*)m_piData;
	else
		return g_NullInterface;
}

void CAutoData::StringValue(CAutoArgs& args)
{
	if (m_piData)
		args = m_piData->GetMsiStringValue();
	else
		args = (BSTR)0;
}

void CAutoData::IntegerValue(CAutoArgs& args)
{
	args = m_piData ? m_piData->GetIntegerValue() : iMsiNullInteger;
}

//____________________________________________________________________________
//
// MsiTable automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1048-0000-0000-C000-000000000046),  // IID_IMsiAutoDatabase
		helpcontext(MsiTable_Object),helpstring("Database low-level table object.")
	]
	dispinterface MsiTable
	{
		properties:
		methods:
			[id(1),propget,helpcontext(MsiTable_Database),helpstring("The MsiDatabase object that owns this table.")]
					MsiDatabase* Database();
			[id(2),propget,helpcontext(MsiTable_RowCount),helpstring("The number of rows of data currently in the table.")]
					long RowCount();
			[id(3),propget,helpcontext(MsiTable_ColumnCount),helpstring("The number of columns in the table.")]
					long ColumnCount();
			[id(4),propget,helpcontext(MsiTable_PrimaryKeyCount),helpstring("Returns the number of columns in the primary key.")]
					long PrimaryKeyCount();
			[id(5),propget,helpcontext(MsiTable_ReadOnly),helpstring("Returns True if the table is not updatable.")]
					boolean ReadOnly();
			[id(6),propget,helpcontext(MsiTable_ColumnName),helpstring("Returns the name string index of a column the table.")]
					long ColumnName(long column);
			[id(7),propget,helpcontext(MsiTable_ColumnType),helpstring("Returns the column definition of a column the table.")]
					long ColumnType(long column);
			[id(8),helpcontext(MsiTable_GetColumnIndex),helpstring("Returns the column index given a column name string index.")]
					long GetColumnIndex(long nameIndex);
			[id(9),helpcontext(MsiTable_CreateColumn),helpstring("Adds a column to a loaded or temporary table.")]
					long CreateColumn(long columnDef, BSTR name);
			[id(10),helpcontext(MsiTable_CreateCursor),helpstring("Returns an MsiCursor object in the reset state.")]
					MsiCursor* CreateCursor(boolean tree);
			[id(11),helpcontext(MsiTable_LinkTree),helpstring("Links the table in tree-traversal order.")]
					long LinkTree(long parentColumn);
	};
*/

DispatchEntry<CAutoTable> AutoTableTable[] = {
	1, aafPropRO, CAutoTable::Database,       TEXT("Database"),
	2, aafPropRO, CAutoTable::RowCount,       TEXT("RowCount"),
	3, aafPropRO, CAutoTable::ColumnCount,    TEXT("ColumnCount"),
	4, aafPropRO, CAutoTable::PrimaryKeyCount,TEXT("PrimaryKeyCount"),
	5, aafPropRO, CAutoTable::ReadOnly,       TEXT("ReadOnly"),
	6, aafPropRO, CAutoTable::ColumnName,     TEXT("ColumnName,column"),
	7, aafPropRO, CAutoTable::ColumnType,     TEXT("ColumnType,column"),
	8, aafMethod, CAutoTable::GetColumnIndex, TEXT("GetColumnIndex,nameIndex"),
	9, aafMethod, CAutoTable::CreateColumn,   TEXT("CreateColumn,columnDef,name"),
	10,aafMethod, CAutoTable::CreateCursor,   TEXT("CreateCursor,tree"),
	11,aafMethod, CAutoTable::LinkTree,       TEXT("LinkTree,parentColumn"),
};
const int AutoTableCount = sizeof(AutoTableTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiTable automation implementation
//____________________________________________________________________________

CAutoTable::CAutoTable(IMsiTable& riTable)
 : CAutoBase(*AutoTableTable, AutoTableCount), m_riTable(riTable)
{
}

CAutoTable::~CAutoTable()
{
	m_riTable.Release();
}

IUnknown& CAutoTable::GetInterface()
{
	return m_riTable;
}

void CAutoTable::Database(CAutoArgs& args)
{
	args = new CAutoDatabase(m_riTable.GetDatabase());
}

void CAutoTable::RowCount(CAutoArgs& args)
{
	args = (int)m_riTable.GetRowCount();
}

void CAutoTable::ColumnCount(CAutoArgs& args)
{
	args = (int)m_riTable.GetColumnCount();
}

void CAutoTable::PrimaryKeyCount(CAutoArgs& args)
{
	args = (int)m_riTable.GetPrimaryKeyCount();
}

void CAutoTable::ReadOnly(CAutoArgs& args)
{
	args = m_riTable.IsReadOnly();
}

void CAutoTable::ColumnName(CAutoArgs& args)
{
	args = (int)m_riTable.GetColumnName(args[1]);
}

void CAutoTable::ColumnType(CAutoArgs& args)
{
	int i = m_riTable.GetColumnType(args[1]);
	if (i == -1)
		throw MsiTable_ColumnType;
	args = i;
}

void CAutoTable::GetColumnIndex(CAutoArgs& args)
{
	args = (int)m_riTable.GetColumnIndex(args[1]);
}

void CAutoTable::CreateColumn(CAutoArgs& args)
{
	MsiString istrName;
	if(args.Present(2))
		istrName = args[2].GetMsiString();
	int iColumn = m_riTable.CreateColumn(args[1], *istrName);
	if (iColumn <= 0)
		throw MsiTable_CreateColumn;
	args = iColumn;
}

void CAutoTable::CreateCursor(CAutoArgs& args)
{
	Bool fTree = fFalse;
	if(args.Present(1))
		fTree = args[1];
	IMsiCursor* piCursor = m_riTable.CreateCursor(fTree);
	if (!piCursor)
		throw MsiTable_CreateCursor;
	args = new CAutoCursor(*piCursor);
}

void CAutoTable::LinkTree(CAutoArgs& args)
{
	args = m_riTable.LinkTree(args[1]);
}

//____________________________________________________________________________
//
// MsiCursor automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1049-0000-0000-C000-000000000046),  // IID_IMsiAutoCursor
		helpcontext(MsiCursor_Object),helpstring("Database table cursor object.")
	]
	dispinterface MsiCursor
	{
		properties:
			[id(2),helpcontext(MsiCursor_Filter),helpstring("Column filter bit mask used by Next method.")]
					long Filter;
		methods:
			[id(1),propget,helpcontext(MsiCursor_Table),helpstring("The table that owns this cursor.")]
					MsiTable* Table();
			[id(3),propget,helpcontext(MsiCursor_IntegerData),helpstring("Transfer column data as an integer.")]
					long IntegerData([in] long column);
			[id(3),propput]
					void IntegerData([in] long column, [in] long data);
			[id(4),propget,helpcontext(MsiCursor_StringData),helpstring("Transfer column data as string.")]
					BSTR StringData([in] long column);
			[id(4),propput]
					void StringData([in] long column, [in] BSTR data);
			[id(5),propget,helpcontext(MsiCursor_ObjectData),helpstring("Transfer column data as MsiData object.")]
					MsiData* ObjectData([in] long column);
			[id(5),propput]
					void     ObjectData([in] long column, [in] MsiData* data);
			[id(6),propget,helpcontext(MsiCursor_StreamData),helpstring("Transfer column data as MsiStream object.")]
					MsiData* StreamData([in] long column);
			[id(6),propput]
					void     StreamData([in] long column, [in] MsiData* data);
			[id(7),helpcontext(MsiCursor_PutNull),helpstring("Puts a null column value in the cursor.")]
					void PutNull([in] long column);
			[id(8),helpcontext(MsiCursor_Reset),helpstring("Resets cursor to before first row, clears data.")]
					void Reset();
			[id(9),helpcontext(MsiCursor_Next),helpstring("Advances cursor to next row.")]
					long Next();
			[id(10),helpcontext(MsiCursor_Update),helpstring("Update changed cursor data to table row.")]
					boolean Update();
			[id(11),helpcontext(MsiCursor_Insert),helpstring("Insert cursor data to new table row.")]
					boolean Insert();
			[id(12),helpcontext(MsiCursor_InsertTemporary),helpstring("Insert cursor data to new temporary row.")]
					boolean InsertTemporary();
			[id(13),helpcontext(MsiCursor_Assign),helpstring("Update or insert cursor data to table row.")]
					boolean Assign();
			[id(14),helpcontext(MsiCursor_Merge),helpstring("Inserts a new or matches an identical row.")]
					boolean Merge();
			[id(15),helpcontext(MsiCursor_Refresh),helpstring("Updates the cursor with current values from the table.")]
					boolean Refresh();
			[id(16),helpcontext(MsiCursor_Delete),helpstring("Delete current cursor row from table.")]
					boolean Delete();
			[id(17),helpcontext(MsiCursor_Seek),helpstring("Positions the cursor to the current primary key value.")]
					boolean Seek();
			[id(18),propget,helpcontext(MsiCursor_RowState),helpstring("Sets or gets a row attribute, iraEnum.")]
					boolean RowState([in] long attribute);
			[id(18),propput]
					void RowState([in] long attribute, [in] boolean data);
			[id(19),propget,helpcontext(MsiCursor_DateData),helpstring("Transfer column data as a Date.")]
					DATE DateData([in] long column);
			[id(19),propput]
					void DateData([in] long column, [in] DATE data);
			[id(20),helpcontext(MsiCursor_Validate),helpstring("Validate current cursor row or field.")]
					MsiRecord* Validate([in] MsiTable* table, [in] MsiCursor* cursor, [in] long column);
			[id(21),propget,helpcontext(MsiCursor_Moniker),helpstring("Get unique identifier for current cursor row.")]
					BSTR Moniker();
			[id(22),helpcontext(MsiCursor_Replace),helpstring("Update allowing change to primary key.")]
					boolean Replace();
		};
*/

DispatchEntry<CAutoCursor> AutoCursorTable[] = {
	1, aafPropRO, CAutoCursor::Table,       TEXT("Table"),
	2, aafPropRW, CAutoCursor::Filter,      TEXT("Filter"),
	3, aafPropRW, CAutoCursor::IntegerData, TEXT("IntegerData,column"),
	4, aafPropRW, CAutoCursor::StringData,  TEXT("StringData,column"),
	5, aafPropRW, CAutoCursor::ObjectData,  TEXT("ObjectData,column"),
	6, aafPropRW, CAutoCursor::StreamData,  TEXT("StreamData,column"),
	7, aafMethod, CAutoCursor::PutNull,     TEXT("PutNull"),
	8, aafMethod, CAutoCursor::Reset,       TEXT("Reset"),
	9, aafMethod, CAutoCursor::Next,        TEXT("Next"),
	10,aafMethod, CAutoCursor::Update,      TEXT("Update"),
	11,aafMethod, CAutoCursor::Insert,      TEXT("Insert"),
	12,aafMethod, CAutoCursor::InsertTemporary,TEXT("InsertTemporary"),
	13,aafMethod, CAutoCursor::Assign,      TEXT("Assign"),
	14,aafMethod, CAutoCursor::Merge,       TEXT("Merge"),
	15,aafMethod, CAutoCursor::Refresh,     TEXT("Refresh"),
	16,aafMethod, CAutoCursor::Delete,      TEXT("Delete"),
	17,aafMethod, CAutoCursor::Seek,        TEXT("Seek"),
	18,aafPropRW, CAutoCursor::RowState,    TEXT("RowState,attribute"),
	19,aafPropRW, CAutoCursor::DateData,    TEXT("DateData,column"),
	20,aafMethod, CAutoCursor::Validate,	TEXT("Validate, table, cursor, column"),
	21,aafPropRO, CAutoCursor::Moniker,     TEXT("Moniker"),
	22,aafMethod, CAutoCursor::Replace,     TEXT("Replace"),
};
const int AutoCursorCount = sizeof(AutoCursorTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiCursor automation implementation
//____________________________________________________________________________

CAutoCursor::CAutoCursor(IMsiCursor& riCursor)
 : CAutoBase(*AutoCursorTable, AutoCursorCount), m_riCursor(riCursor)
{
}

CAutoCursor::~CAutoCursor()
{
	m_riCursor.Release();
}

IUnknown& CAutoCursor::GetInterface()
{
	return m_riCursor;
}

void CAutoCursor::IntegerData(CAutoArgs& args)
{
	if (args.PropertySet())
	{
		if (!m_riCursor.PutInteger(args[1], args[0]))
			throw MsiCursor_IntegerData;
	}
	else
	{
		args = m_riCursor.GetInteger(args[1]);
	}
}

void CAutoCursor::DateData(CAutoArgs& args)
{
	PMsiTable pTable(&m_riCursor.GetTable()); 
	Bool fIntData = (!(pTable->GetColumnType(args[1]) & icdObject)) ? fTrue : fFalse;
	
	if (args.PropertySet())
	{
		if (fIntData)
		{
			if (!m_riCursor.PutInteger(args[1], int(MsiDate(args[0]))))
				throw MsiCursor_DateData;
		}
		else
		{
			if (!m_riCursor.PutString(args[1], *MsiString(int(MsiDate(args[0])))))
				throw MsiCursor_DateData;
		}
	}
	else
	{
		if (fIntData)
			args = MsiDate(m_riCursor.GetInteger(args[1]));
		else
			args = MsiDate(int(MsiString(m_riCursor.GetString(args[1]))));
	}
}

void CAutoCursor::StringData(CAutoArgs& args)
{
	if (args.PropertySet())
	{
		Bool fStat = m_riCursor.PutString(args[1], *MsiString(args[0].GetMsiString()));
		if (fStat == fFalse)
			throw MsiCursor_StringData;
	}
	else
	{
		args = m_riCursor.GetString(args[1]);
	}
}

void CAutoCursor::ObjectData(CAutoArgs& args)
{
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		if (!m_riCursor.PutMsiData(args[1], var.GetType() == VT_EMPTY ? 0 : (const IMsiData*)var.ObjectPtr(IID_IMsiData)))
			throw MsiCursor_ObjectData;
	}
	else
	{
		args = new CAutoData(m_riCursor.GetMsiData(args[1]));
	}
}

void CAutoCursor::StreamData(CAutoArgs& args)
{
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		if (!m_riCursor.PutStream(args[1], var.GetType() == VT_EMPTY ? 0
										: (IMsiStream*)var.ObjectPtr(IID_IMsiStream)))
			throw MsiCursor_StreamData;
	}
	else
	{
		IMsiStream* piStream = m_riCursor.GetStream(args[1]);
		if (piStream)
			args = new CAutoStream(*piStream);
		else
			args = (IDispatch*)0;
	}
}

void CAutoCursor::PutNull(CAutoArgs& args)
{
	if (!m_riCursor.PutNull(args[1]))
		throw MsiCursor_PutNull;
}

void CAutoCursor::Table(CAutoArgs& args)
{
	args = new CAutoTable(m_riCursor.GetTable());
}

void CAutoCursor::Reset(CAutoArgs& /*args*/)
{
	m_riCursor.Reset();
}

void CAutoCursor::Next(CAutoArgs& args)
{
	args = m_riCursor.Next();
}

void CAutoCursor::Filter(CAutoArgs& args)
{
	if (args.PropertySet())
		m_riCursor.SetFilter(args[0]);
	else
	{
		int iFilter = m_riCursor.SetFilter(0);
		m_riCursor.SetFilter(iFilter);
		args = iFilter;
	}
}

void CAutoCursor::Update(CAutoArgs& args)
{
	args = m_riCursor.Update();
}

void CAutoCursor::Insert(CAutoArgs& args)
{
	args = m_riCursor.Insert();
}

void CAutoCursor::InsertTemporary(CAutoArgs& args)
{
	args = m_riCursor.InsertTemporary();
}

void CAutoCursor::Assign(CAutoArgs& args)
{
	args = m_riCursor.Assign();
}

void CAutoCursor::Replace(CAutoArgs& args)
{
	args = m_riCursor.Replace();
}

void CAutoCursor::Delete(CAutoArgs& args)
{
	args = m_riCursor.Delete();
}

void CAutoCursor::Seek(CAutoArgs& args)
{
	args = m_riCursor.Seek();
}

void CAutoCursor::Merge(CAutoArgs& args)
{
	args = m_riCursor.Merge();
}

void CAutoCursor::Refresh(CAutoArgs& args)
{
	args = m_riCursor.Refresh();
}

void CAutoCursor::RowState(CAutoArgs& args)
{
	if (args.PropertySet())
		m_riCursor.SetRowState((iraEnum)(int)args[1], args[0]);
	else
		args = m_riCursor.GetRowState((iraEnum)(int)args[1]);
}

void CAutoCursor::Validate(CAutoArgs& args)
{
	IMsiRecord* piRecord = m_riCursor.Validate((IMsiTable&)args[1].Object(IID_IMsiTable), (IMsiCursor&)args[2].Object(IID_IMsiCursor), args[3]);
	if (!piRecord)
		args = (IDispatch*)0;
	else
		args = new CAutoRecord(*piRecord);
	return;
}

void CAutoCursor::Moniker(CAutoArgs& args)
{
	args = m_riCursor.GetMoniker();
}


//____________________________________________________________________________
//
// MsiSelectionManager automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1058-0000-0000-C000-000000000046),  // IID_IMsiAutoSelectionManager
		helpcontext(MsiSelectionManager_Object),helpstring("Selection Manager object.")
	]
	dispinterface MsiSelectionManager
	{
		properties:
		methods:
			[id(1),helpcontext(MsiSelectionManager_LoadSelectionTables),
				helpstring("Loads the Feature and Component tables into memory.")]
				void LoadSelectionTables();
			[id(2),propget,helpcontext(MsiSelectionManager_FeatureTable),
				helpstring("Returns Feature table object.")]
				MsiTable* FeatureTable();
			[id(3),helpcontext(MsiSelectionManager_ProcessConditionTable),
				helpstring("Sets install levels of all Feature table records based on a condition expression.")]
				void ProcessConditionTable();
			[id(4),propget,helpcontext(MsiSelectionManager_ComponentTable),
				helpstring("Returns Component table object.")]
				MsiTable* ComponentTable();
			[id(5),helpcontext(MsiSelectionManager_FreeSelectionTables),
				helpstring("Frees the Feature and Component tables from memory.")]
				boolean FreeSelectionTables();
			[id(6),helpcontext(MsiSelectionManager_SetFeatureHandle),
				helpstring("Sets an external handle into Feature table.")]
				void SetFeatureHandle([in] BSTR feature, [in] long handle);
			[id(7),helpcontext(MsiSelectionManager_SetComponent),
				helpstring("Sets a requested state for an item in the Component table.")]
				void SetComponent([in] BSTR component, [in] long state);
			[id(8),helpcontext(MsiSelectionManager_SetInstallLevel),
				helpstring("Sets the current install level, and updates all Feature table records accordingly.")]
				void SetInstallLevel([in] long iInstallLevel);
			[id(9),helpcontext(MsiSelectionManager_GetVolumeCostTable),
				helpstring("Returns the VolumeCost Table object.")]
				MsiTable* GetVolumeCostTable();
			[id(11),helpcontext(MsiSelectionManager_RecostDirectory),
				helpstring("Recalculates the dynamic cost of every component that references the specified directory.")]
				void RecostDirectory([in] BSTR directoryName, [in] MsiPath* oldPath);
			[id(13),helpcontext(MsiSelectionManager_InitializeComponents),
				helpstring("Initialize all components in the Component table.")]
				void InitializeComponents();
			[id(14),helpcontext(MsiSelectionManager_ConfigureFeature),
				helpstring("Sets the install state for one or all items in the Feature table.")]
				void ConfigureFeature([in] BSTR strFeature, [in] long state);
			[id(15),helpcontext(MsiSelectionManager_GetFeatureCost),
				helpstring("Returns the total amount of disk space required by a feature, NOT including that feature's children.")]
				void GetFeatureCost();
			[id(16),helpcontext(MsiSelectionManager_GetDescendentFeatureCost),
				helpstring("returns the total amount of disk space required by a feature, including that feature's children.")]
				void GetDescendentFeatureCost();
			[id(17),helpcontext(MsiSelectionManager_GetAncestryFeatureCost),
				helpstring("returns the total amount of disk space required by a feature, including that feature's parent feature(s).")]
				void GetAncestryFeatureCost();
			[id(18),helpcontext(MsiSelectionManager_GetFeatureValidStates),
				helpstring("Returns the valid Attributes options for a specified feature.")]
				void GetFeatureValidStates();
	};
*/

DispatchEntry<CAutoSelectionManager> AutoSelectionManagerTable[] = {
	1, aafMethod, CAutoSelectionManager::LoadSelectionTables,TEXT("LoadSelectionTables"),
	2, aafPropRO, CAutoSelectionManager::FeatureTable,TEXT("FeatureTable"),
	3, aafMethod, CAutoSelectionManager::ProcessConditionTable,TEXT("ProcessConditionTable"),
    4, aafPropRO, CAutoSelectionManager::ComponentTable,TEXT("ComponentTable"),
	5, aafMethod, CAutoSelectionManager::FreeSelectionTables,TEXT("FreeSelectionTables"),
	6, aafMethod, CAutoSelectionManager::SetFeatureHandle,TEXT("SetFeatureHandle,feature,handle"),
	7, aafMethod, CAutoSelectionManager::SetComponent,TEXT("SetComponent,component,state"),
	8, aafMethod, CAutoSelectionManager::SetInstallLevel,TEXT("SetInstallLevel,iInstallLevel"),
	9, aafMethod, CAutoSelectionManager::GetVolumeCostTable,TEXT("GetVolumeCostTable"),
   11, aafMethod, CAutoSelectionManager::RecostDirectory,TEXT("RecostDirectory,directoryName,oldPath"),
   13, aafMethod, CAutoSelectionManager::InitializeComponents,TEXT("InitializeComponents"),
   14, aafMethod, CAutoSelectionManager::ConfigureFeature,TEXT("ConfigureFeature"),
   15, aafMethod, CAutoSelectionManager::GetFeatureCost,TEXT("GetFeatureCost"),
   16, aafMethod, CAutoSelectionManager::GetDescendentFeatureCost,TEXT("GetDescendentFeatureCost"),
   17, aafMethod, CAutoSelectionManager::GetAncestryFeatureCost, TEXT("GetAncestryFeatureCost"),
   18, aafMethod, CAutoSelectionManager::GetFeatureValidStates,TEXT("GetFeatureValidStates"),
};
const int AutoSelectionManagerCount = sizeof(AutoSelectionManagerTable)/sizeof(DispatchEntryBase);


//____________________________________________________________________________
//
// CMsiSelectionManager automation implementation
//____________________________________________________________________________

CAutoSelectionManager::CAutoSelectionManager(IMsiSelectionManager& riSelectionManager)
 : CAutoBase(*AutoSelectionManagerTable, AutoSelectionManagerCount),
	m_riSelectionManager(riSelectionManager)
{
}

CAutoSelectionManager::~CAutoSelectionManager()
{
	m_riSelectionManager.Release();
}

IUnknown& CAutoSelectionManager::GetInterface()
{
	return m_riSelectionManager;
}

void CAutoSelectionManager::LoadSelectionTables(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riSelectionManager.LoadSelectionTables();
   if (piError)
      throw piError;
}

void CAutoSelectionManager::FreeSelectionTables(CAutoArgs& args)
{
	args = m_riSelectionManager.FreeSelectionTables();
}

void CAutoSelectionManager::FeatureTable(CAutoArgs& args)
{
	IMsiTable* piTable = m_riSelectionManager.GetFeatureTable();
	if (piTable)
		args = new CAutoTable(*piTable);
	else
		args = (IDispatch*)0;
}

void CAutoSelectionManager::ComponentTable(CAutoArgs& args)
{
	IMsiTable* piTable = m_riSelectionManager.GetComponentTable();
	if (piTable)
		args = new CAutoTable(*piTable);
	else
		args = (IDispatch*)0;
}

void CAutoSelectionManager::ProcessConditionTable(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riSelectionManager.ProcessConditionTable();
	if (piError)
      throw piError;
}


void CAutoSelectionManager::SetFeatureHandle(CAutoArgs& args)
{
	if (!(m_riSelectionManager.SetFeatureHandle(*MsiString(args[1].GetMsiString()), args[2])))
		throw MsiSelectionManager_SetFeatureHandle;
}

void CAutoSelectionManager::SetComponent(CAutoArgs& args)
{
	IMsiRecord* piError = m_riSelectionManager.SetComponentSz(args[1],(iisEnum) (int) args[2]);
	if (piError)
		throw piError;
}

void CAutoSelectionManager::InitializeComponents(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riSelectionManager.InitializeComponents();
	if (piError)
		throw piError;
}

void CAutoSelectionManager::SetInstallLevel(CAutoArgs& args)
{
	IMsiRecord* piError = m_riSelectionManager.SetInstallLevel(args[1]);
	if (piError)
		throw piError;
}

void CAutoSelectionManager::GetVolumeCostTable(CAutoArgs& args)
{
	IMsiTable* piTable = m_riSelectionManager.GetVolumeCostTable();
	if (piTable)
		args = new CAutoTable(*piTable);
	else
		args = (IDispatch*)0;
}

void CAutoSelectionManager::RecostDirectory(CAutoArgs& args)
{
	IMsiRecord* piError = m_riSelectionManager.RecostDirectory(*MsiString(args[1].GetMsiString()),
		(IMsiPath&)args[2].Object(IID_IMsiPath));
	if (piError)
		throw piError;
}


void CAutoSelectionManager::ConfigureFeature(CAutoArgs& args)
{
	IMsiRecord* piError = m_riSelectionManager.ConfigureFeature(*MsiString(args[1].GetMsiString()),(iisEnum)(int) args[2]);
	if (piError)
		throw piError;
}

void CAutoSelectionManager::GetFeatureCost(CAutoArgs& args)
{
	int iCost;
	IMsiRecord* piError = m_riSelectionManager.GetFeatureCost(*MsiString(args[1].GetMsiString()),(iisEnum)(int) args[2],iCost);
	if (piError)
		throw piError;
	args = iCost;
}

void CAutoSelectionManager::GetDescendentFeatureCost(CAutoArgs& args)
{
	int iCost;
	IMsiRecord* piError = m_riSelectionManager.GetDescendentFeatureCost(*MsiString(args[1].GetMsiString()),
		(iisEnum)(int) args[2],iCost);
	if (piError)
		throw piError;
	args = iCost;
}

void CAutoSelectionManager::GetAncestryFeatureCost(CAutoArgs& args)
{
	int iCost;
	IMsiRecord* piError = m_riSelectionManager.GetAncestryFeatureCost(*MsiString(args[1].GetMsiString()),
		(iisEnum)(int) args[2],iCost);
	if (piError)
		throw piError;
	args = iCost;
}

void CAutoSelectionManager::GetFeatureValidStates(CAutoArgs& args)
{
	int iValidStates;

	IMsiRecord* piError = m_riSelectionManager.GetFeatureValidStatesSz((const ICHAR *)args[1],iValidStates);
	if (piError)
		throw piError;
	args = iValidStates;
}


//____________________________________________________________________________
//
// MsiDirectoryManager automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1059-0000-0000-C000-000000000046),  // IID_IMsiAutoDirectoryManager
		helpcontext(MsiDirectoryManager_Object),helpstring("Directory Manager object.")
	]
	dispinterface MsiDirectoryManager
	{
		properties:
		methods:
			[id(1),helpcontext(MsiDirectoryManager_LoadDirectoryTable),helpstring("Load directory table into memory.")]
				void LoadDirectoryTable();
			[id(2),propget,helpcontext(MsiDirectoryManager_DirectoryTable),helpstring("Returns directory table object.")]
				MsiTable* DirectoryTable();
			[id(3),helpcontext(MsiDirectoryManager_FreeDirectoryTable),helpstring("Free directory table from memory.")]
				void FreeDirectoryTable();
			[id(4),helpcontext(MsiDirectoryManager_CreateTargetPaths),helpstring("Create target path objects.")]
				void CreateTargetPaths();
			[id(5),helpcontext(MsiDirectoryManager_CreateSourcePaths),helpstring("Create source path objects.")]
				void CreateSourcePaths();
			[id(6),helpcontext(MsiDirectoryManager_GetTargetPath),helpstring("Get a target path object.")]
				MsiPath* GetTargetPath([in] BSTR name);
			[id(7),helpcontext(MsiDirectoryManager_SetTargetPath),helpstring("Set new path for target path object.")]
				void SetTargetPath([in] BSTR name, [in] BSTR path, [in] boolean writecheck);
			[id(8),helpcontext(MsiDirectoryManager_GetSourcePath),helpstring("Get a source path object.")]
				MsiPath* GetSourcePath([in] BSTR name);
	};
*/

DispatchEntry<CAutoDirectoryManager> AutoDirectoryManagerTable[] = {
  1, aafMethod, CAutoDirectoryManager::LoadDirectoryTable,TEXT("LoadDirectoryTable"),
  2, aafPropRO, CAutoDirectoryManager::DirectoryTable,    TEXT("DirectoryTable"),
  3, aafMethod, CAutoDirectoryManager::FreeDirectoryTable,TEXT("FreeDirectoryTable"),
  4, aafMethod, CAutoDirectoryManager::CreateTargetPaths, TEXT("CreateTargetPaths"),
  5, aafMethod, CAutoDirectoryManager::CreateSourcePaths, TEXT("CreateSourcePaths"),
  6, aafMethod, CAutoDirectoryManager::GetTargetPath,     TEXT("GetTargetPath,name"),
  7, aafMethod, CAutoDirectoryManager::SetTargetPath,     TEXT("SetTargetPath,name,path,writecheck"),
  8, aafMethod, CAutoDirectoryManager::GetSourcePath,     TEXT("GetSourcePath,name"),
};
const int AutoDirectoryManagerCount = sizeof(AutoDirectoryManagerTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiDirectoryManager automation implementation
//____________________________________________________________________________

CAutoDirectoryManager::CAutoDirectoryManager(IMsiDirectoryManager& riDirectoryManager)
 : CAutoBase(*AutoDirectoryManagerTable, AutoDirectoryManagerCount),
	m_riDirectoryManager(riDirectoryManager)
{
}

CAutoDirectoryManager::~CAutoDirectoryManager()
{
	m_riDirectoryManager.Release();
}

IUnknown& CAutoDirectoryManager::GetInterface()
{
	return m_riDirectoryManager;
}

void CAutoDirectoryManager::LoadDirectoryTable(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riDirectoryManager.LoadDirectoryTable(0);
   if (piError)
      throw piError;
}

void CAutoDirectoryManager::DirectoryTable(CAutoArgs& args)
{
	IMsiTable* piTable = m_riDirectoryManager.GetDirectoryTable();
	if (piTable)
		args = new CAutoTable(*piTable);
	else
		args = (IDispatch*)0;
}

void CAutoDirectoryManager::FreeDirectoryTable(CAutoArgs& /*args*/)
{
	m_riDirectoryManager.FreeDirectoryTable();
}

void CAutoDirectoryManager::CreateTargetPaths(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riDirectoryManager.CreateTargetPaths();
   if (piError)
      throw piError;
}

void CAutoDirectoryManager::CreateSourcePaths(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riDirectoryManager.CreateSourcePaths();
   if (piError)
      throw piError;
}

void CAutoDirectoryManager::GetTargetPath(CAutoArgs& args)
{
	IMsiPath* piPath;
	IMsiRecord* piError = m_riDirectoryManager.GetTargetPath(*MsiString(args[1].GetMsiString()),piPath);
	if (piError)
		throw piError;
	args = piPath ? (IDispatch*)new CAutoPath(*piPath) : (IDispatch*)0;
}

void CAutoDirectoryManager::SetTargetPath(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDirectoryManager.SetTargetPath(*MsiString(args[1].GetMsiString()), 
		args[2], args.Present(3) ? (Bool)args[3] : fTrue);

   if (piError)
      throw piError;
}

void CAutoDirectoryManager::GetSourcePath(CAutoArgs& args)
{
	IMsiPath* piPath = 0;
	IMsiRecord* piError = m_riDirectoryManager.GetSourcePath(*MsiString(args[1].GetMsiString()),piPath);
	if (piError)
		throw piError;
	args = piPath ? (IDispatch*)new CAutoPath(*piPath) : (IDispatch*)0;
}

//____________________________________________________________________________
//
// MsiServer automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C105C-0000-0000-C000-000000000046),  // IID_IMsiAutoServer
		helpcontext(MsiServer_Object),helpstring("MsiServer object.")
	]
	dispinterface MsiServer
	{
		properties:
		methods:
			[id(DISPID_MsiConfigurationManager_InstallFinalize),helpcontext(MsiConfigurationManager_InstallFinalize),helpstring("Finalize install on server side, handle rollback")]
				long InstallFinalize([in] long state, [in] MsiMessage* message, [in] boolean userChangedDuringInstall);
			[id(DISPID_MsiConfigurationManager_SetLastUsedSource),helpcontext(MsiConfigurationManager_SetLastUsedSource),helpstring("Sets the last used source for a product")]
				void SetLastUsedSource([in] BSTR productKey, BSTR path, boolean addToList, boolean patch);
		   [id(DISPID_MsiConfigurationManager_DoInstall),helpcontext(MsiConfigurationManager_DoInstall),helpstring("Runs an install")]
				long DoInstall([in] long ireProductSpec, [in] BSTR strProduct, [in] BSTR strAction, [in] BSTR strCommandLine, [in] BSTR strLogFile, [in] long iLogMode, MsiMessage* message, [in] long iioOptions, [in] int dwPrivilegesMask);
  };
*/

DispatchEntry<CAutoServer> AutoServerTable[] = {
  DISPID_MsiConfigurationManager_InstallFinalize    , aafMethod, CAutoServer::InstallFinalize,    TEXT("InstallFinalize,state,messageHandler,userChangedDuringInstall"),
  DISPID_MsiConfigurationManager_SetLastUsedSource, aafMethod, CAutoServer::SetLastUsedSource,  TEXT("SetLastUsedSource,productKey,path,addToList,patch"),
  DISPID_MsiConfigurationManager_DoInstall, aafMethod, CAutoServer::DoInstall,  TEXT("DoInstall,ireProductSpec,product,action,commandline,logfile,logmode,flushEachLine,message,iioOptions,dwPrivilegesMask"),
};
const int AutoServerCount = sizeof(AutoServerTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiServer automation implementation, inherited by CMsiConfigurationManager
//____________________________________________________________________________

CAutoServer::CAutoServer(IMsiServer& riServer, DispatchEntry<CAutoBase>* pTable, int cDispId)
 : CAutoBase(pTable, cDispId)
 , m_riServer(riServer)
{
	riServer.AddRef();
}

CAutoServer::CAutoServer(IMsiServer& riServer)
 : CAutoBase(*AutoServerTable, AutoServerCount)
 , m_riServer(riServer)
{
	riServer.AddRef();
}

CAutoServer::~CAutoServer()
{
	m_riServer.Release();
}

IUnknown& CAutoServer::GetInterface()
{
	return m_riServer;
}

void CAutoServer::InstallFinalize(CAutoArgs& args)
{
	boolean fUserChangedDuringInstall = fFalse;
	
	if(args.Present(3))
		fUserChangedDuringInstall = args[3];

	args = (int)m_riServer.InstallFinalize((iesEnum)(int)args[1],
		(IMsiMessage&)args[2].Object(IID_IMsiMessage), fUserChangedDuringInstall);
}

void CAutoServer::DoInstall(CAutoArgs& args)
{
	args = (int)m_riServer.DoInstall((ireEnum)(int)args[1], args[2], args[3], args[4],args[5],args[6],args[7],
		(IMsiMessage&)args[8].Object(IID_IMsiMessage), (iioEnum)(int)args[9], (int)args[10]);
}


void CAutoServer::SetLastUsedSource(CAutoArgs& args)
{
	IMsiRecord* piError = m_riServer.SetLastUsedSource(args[1], args[2], args[3], args[4]);

	if (piError)
		throw piError;
}


//____________________________________________________________________________
//
// MsiConfigurationManager automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C105B-0000-0000-C000-000000000046),  // IID_IMsiAutoConfigurationManager
		helpcontext(MsiConfigurationManager_Object),helpstring("Configuration Manager object.")
	]
	dispinterface MsiConfigurationManager
	{
		properties:
		methods:
			[id(DISPID_MsiConfigurationManager_RunScript),helpcontext(MsiConfigurationManager_RunScript),helpstring("Runs a script")]
				long RunScript(BSTR scriptFile, MsiMessage* message, boolean rollbackEnabled, MsiDirectoryManager* dirmgr);
			[id(DISPID_MsiConfigurationManager_InstallFinalize),helpcontext(MsiConfigurationManager_InstallFinalize),helpstring("Finalize install on server side, handle rollback")]
				long InstallFinalize([in] long state, [in] MsiMessage* message, [in] boolean userChangedDuringInstall);
		   [id(DISPID_MsiConfigurationManager_DoInstall),helpcontext(MsiConfigurationManager_DoInstall),helpstring("Run an install")]
				long DoInstall([in] long ireProductSpec, [in] BSTR strProduct, [in] BSTR strAction, [in] BSTR strCommandLine, [in] BSTR strLogFile, [in] long iLogMode, MsiMessage* message, [in] long iioOptions, [in] int dwPrivilegesMask);

			[id(DISPID_MsiConfigurationManager_Services),propget,helpcontext(MsiConfigurationManager_Services),helpstring("The MsiServices object being used.")]
				MsiServices* Services();
			[id(DISPID_MsiConfigurationManager_RegisterComponent),helpcontext(MsiConfigurationManager_RegisterComponent),helpstring("Registers a component")]
				void RegisterComponent(BSTR productCode, BSTR componentCode, long state, BSTR keyPath, long disk, boolean sharedDllRefCount);
		   [id(DISPID_MsiConfigurationManager_UnregisterComponent),helpcontext(MsiConfigurationManager_UnregisterComponent),helpstring("Unregisters a component")]
				void UnregisterComponent(BSTR productCode, BSTR componentCode);
		   [id(DISPID_MsiConfigurationManager_RegisterFolder),helpcontext(MsiConfigurationManager_RegisterFolder),helpstring("Register a folder")]
				void RegisterFolder([in] MsiPath* folder, [in] boolean fExplicit);
		   [id(DISPID_MsiConfigurationManager_IsFolderRemovable),helpcontext(MsiConfigurationManager_IsFolderRemovable),helpstring("Returns true if the folder can be removed; false otherwise")]
				boolean IsFolderRemovable([in] MsiPath* folder, [in] boolean fExplicit);
  		   [id(DISPID_MsiConfigurationManager_UnregisterFolder),helpcontext(MsiConfigurationManager_UnregisterFolder),helpstring("Unregisters a folder")]
				void UnregisterFolder([in] MsiPath* folder);

		   [id(DISPID_MsiConfigurationManager_RegisterRollbackScript),helpcontext(MsiConfigurationManager_RegisterRollbackScript),helpstring("Registers a rollback script")]
				void RegisterRollbackScript([in] BSTR scriptFile);
		   [id(DISPID_MsiConfigurationManager_UnregisterRollbackScript),helpcontext(MsiConfigurationManager_UnregisterRollbackScript),helpstring("Unregisters a rollback script")]
				void UnregisterRollbackScript([in] BSTR scriptFile);
		   [id(DISPID_MsiConfigurationManager_RollbackScripts),helpcontext(MsiConfigurationManager_RollbackScripts),helpstring("Returns a collection of rollback scripts")]
				IEnumVARIANT* RollbackScripts([in] BSTR scriptFile, DATE date, boolean after);
		   [id(DISPID_MsiConfigurationManager_SetLastUsedSource),helpcontext(MsiConfigurationManager_SetLastUsedSource),helpstring("Sets the last used source for a product")]
				void SetLastUsedSource([in] BSTR productKey, BSTR path, boolean addToList, boolean patch);
	};
*/

DispatchEntry<CAutoConfigurationManager> AutoConfigurationManagerTable[] = {
  
  DISPID_MsiConfigurationManager_InstallFinalize    , aafMethod, CAutoServer::InstallFinalize,    TEXT("InstallFinalize,state,messageHandler,userChangedDuringInstall"),  
  DISPID_MsiConfigurationManager_SetLastUsedSource , aafMethod, CAutoServer::SetLastUsedSource,  TEXT("SetLastUsedSource,productKey,path,addToList,patch"),
  DISPID_MsiConfigurationManager_DoInstall         , aafMethod, CAutoServer::DoInstall,  TEXT("DoInstall,ireProductSpec,product,action,commandline,logfile,logmode,message,iioOptions,dwPrivilegesMask"),
  DISPID_MsiConfigurationManager_Services                    , aafPropRO, CAutoConfigurationManager::Services,                  TEXT("Services"),
  DISPID_MsiConfigurationManager_RegisterComponent           , aafMethod, CAutoConfigurationManager::RegisterComponent,         TEXT("RegisterComponent,productKey,componentCode,state,keyPath,disk,sharedDllRefCount"),
  DISPID_MsiConfigurationManager_UnregisterComponent         , aafMethod, CAutoConfigurationManager::UnregisterComponent,       TEXT("UnregisterComponent,productKey,componentCode"),
  DISPID_MsiConfigurationManager_RegisterFolder              , aafMethod, CAutoConfigurationManager::RegisterFolder,            TEXT("RegisterFolder,folder,fExplicit"),
  DISPID_MsiConfigurationManager_IsFolderRemovable           , aafMethod, CAutoConfigurationManager::IsFolderRemovable,         TEXT("IsFolderRemovable,folder,fExplicit"),
  DISPID_MsiConfigurationManager_UnregisterFolder            , aafMethod, CAutoConfigurationManager::UnregisterFolder,          TEXT("UnregisterFolder,folder"),
  DISPID_MsiConfigurationManager_RegisterRollbackScript      , aafMethod, CAutoConfigurationManager::RegisterRollbackScript,    TEXT("RegisterRollbackScript,scriptfile"),
  DISPID_MsiConfigurationManager_UnregisterRollbackScript    , aafMethod, CAutoConfigurationManager::UnregisterRollbackScript,  TEXT("UnregisterRollbackScript,scriptfile"),
  DISPID_MsiConfigurationManager_RollbackScripts             , aafMethod, CAutoConfigurationManager::RollbackScripts,           TEXT("RollbackScripts,date,after"),
  DISPID_MsiConfigurationManager_RunScript                   , aafMethod, CAutoConfigurationManager::RunScript,          TEXT("RunScript,scriptFile,messageHandler,rollbackEnabled,directoryManager"),
};
const int AutoConfigurationManagerCount = sizeof(AutoConfigurationManagerTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiConfigurationManager automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoConfigurationManager(IMsiConfigurationManager& riConfigurationManager)
{
	return new CAutoConfigurationManager(riConfigurationManager);
}

CAutoConfigurationManager::CAutoConfigurationManager(IMsiConfigurationManager& riConfigurationManager)
 : CAutoServer(riConfigurationManager, *AutoConfigurationManagerTable, AutoConfigurationManagerCount)
 , m_riConfigurationManager(riConfigurationManager)
{
	if (g_cServicesUsers == 0)
	{
		s_piServices = &riConfigurationManager.GetServices(); // services was AddRefed
		g_piStringNull = &s_piServices->GetNullString();
		MsiString::InitializeClass(s_piServices->GetNullString());
	}

	g_cServicesUsers++;
}

CAutoConfigurationManager::~CAutoConfigurationManager()
{
	m_riConfigurationManager.Release();
	ReleaseStaticServices();
}

IUnknown& CAutoConfigurationManager::GetInterface()
{
	return m_riConfigurationManager;
}

void CAutoConfigurationManager::Services(CAutoArgs& args)
{
	args = new CAutoServices(m_riConfigurationManager.GetServices());
}


void CAutoConfigurationManager::RegisterFolder(CAutoArgs& args)
{
	MsiString strComponent;

	IMsiRecord* piError = 
		m_riConfigurationManager.RegisterFolder((IMsiPath&)args[1].Object(IID_IMsiPath),
															 (Bool)args[2]);
		
	if (piError)
		throw piError;
}


void CAutoConfigurationManager::IsFolderRemovable(CAutoArgs& args)
{
	Bool fRemovable;

	IMsiRecord* piError = 
		m_riConfigurationManager.IsFolderRemovable((IMsiPath&)args[1].Object(IID_IMsiPath),
																(Bool)args[2],
																fRemovable);
		
	if (piError)
		throw piError;

	args = fRemovable;
}


void CAutoConfigurationManager::UnregisterFolder(CAutoArgs& args)
{
	IMsiRecord* piError = 
		m_riConfigurationManager.UnregisterFolder((IMsiPath&)args[1].Object(IID_IMsiPath));
		
	if (piError)
		throw piError;
}

void CAutoConfigurationManager::RunScript(CAutoArgs& args)
{
	IMsiDirectoryManager* piDirMgr = 0;
	if(args.Present(4))
		piDirMgr = (IMsiDirectoryManager*)args[4].ObjectPtr(IID_IMsiDirectoryManager);
	
	args = (int)m_riConfigurationManager.RunScript(MsiString(args[1].GetMsiString()), 
																  (IMsiMessage&)args[2].Object(IID_IMsiMessage),
																  piDirMgr,
																  args[3]);
}

void CAutoConfigurationManager::RegisterComponent(CAutoArgs& args)
{
	IMsiRecord* piError = 
		m_riConfigurationManager.RegisterComponent(*MsiString(args[1].GetMsiString()), // product key
													*MsiString(args[2].GetMsiString()), // component key
													(INSTALLSTATE)(int)args[3], // state
													*MsiString(args[4].GetMsiString()), // keypath
													args[5], // disk
													args[6]); // shareddll refcount
	if (piError)
		throw piError;
}

void CAutoConfigurationManager::UnregisterComponent(CAutoArgs& args)
{
	IMsiRecord* piError = 
		m_riConfigurationManager.UnregisterComponent(*MsiString(args[1].GetMsiString()),
													*MsiString(args[2].GetMsiString()));
																																
	if (piError)
		throw piError;
}


void CAutoConfigurationManager::RegisterRollbackScript(CAutoArgs& args)
{
	IMsiRecord* piError = 
		m_riConfigurationManager.RegisterRollbackScript(MsiString(args[1].GetMsiString()));
	
	if (piError)
		throw piError;
}

void CAutoConfigurationManager::UnregisterRollbackScript(CAutoArgs& args)
{
	IMsiRecord* piError = 
		m_riConfigurationManager.UnregisterRollbackScript(MsiString(args[1].GetMsiString()));
	
	if (piError)
		throw piError;
}

void CAutoConfigurationManager::RollbackScripts(CAutoArgs& args)
{
	IEnumMsiString* piEnum;
		
	IMsiRecord* piError = 
		m_riConfigurationManager.GetRollbackScriptEnumerator((MsiDate)args[1],
			(Bool)args[2], piEnum);
	
	if (piError)
		throw piError;
	
	args = *piEnum;
}

//____________________________________________________________________________
//
// MsiExecute automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C105E-0000-0000-C000-000000000046),  // IID_IMsiAutoExecute
		helpcontext(MsiExecute_Object),helpstring("Execute object.")
	]
	dispinterface MsiExecute
	{
		properties:
		methods:
			[id(1),helpcontext(MsiExecute_ExecuteRecord),helpstring("Execute an operation")]
				long ExecuteRecord([in] long opCode, [in] MsiRecord* params);
			[id(2),helpcontext(MsiExecute_RunScript),helpstring("Run a script")]
				long RunScript([in] BSTR script);
			[id(4),helpcontext(MsiExecute_RemoveRollbackFiles),helpstring("Remove all rollback files created before a certain time.")]
				void RemoveRollbackFiles([in] long time);
			[id(5),helpcontext(MsiExecute_Rollback),helpstring("Rollback all installations performed after a certain time.")]
				void Rollback([in] long time, [in] boolean userChangedDuringInstall);
			[id(7),helpcontext(MsiExecute_CreateScript),helpstring("Creates a script file")]
				boolean CreateScript([in] MsiStream* stream);
			[id(8),helpcontext(MsiExecute_WriteScriptRecord),helpstring("Writes an operation to the script file")]
				boolean WriteScriptRecord([in] long opCode, [in] MsiRecord* params);
			[id(9),helpcontext(MsiExecute_CloseScript),helpstring("Closes the current script file")]
				void CloseScript();

	};
*/

DispatchEntry<CAutoExecute> AutoExecuteTable[] = {
	1, aafMethod, CAutoExecute::ExecuteRecord,           TEXT("ExecuteRecord,opCode,paramaters"),
	2, aafMethod, CAutoExecute::RunScript,               TEXT("RunScript,script"),
	4, aafMethod, CAutoExecute::RemoveRollbackFiles,     TEXT("RemoveRollbackFiles,time"),
	5, aafMethod, CAutoExecute::Rollback,                TEXT("Rollback,time,userChanged"),
	6, aafMethod, CAutoExecute::RollbackFinalize,        TEXT("RollbackFinalize,state,time,userChanged"),
	7, aafMethod, CAutoExecute::CreateScript,            TEXT("CreateScript,script"),
	8, aafMethod, CAutoExecute::WriteScriptRecord,       TEXT("WriteScriptRecord,opcode,params"),
	9, aafMethod, CAutoExecute::CloseScript,             TEXT("CloseScript"),
};
const int AutoExecuteCount = sizeof(AutoExecuteTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiExecute automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoExecute(IMsiExecute& riExecute)
{
	return new CAutoExecute(riExecute);
}

CAutoExecute::CAutoExecute(IMsiExecute& riExecute)
 : CAutoBase(*AutoExecuteTable, AutoExecuteCount),
	m_riExecute(riExecute), m_pScript(0)
{
	if (g_cServicesUsers == 0)
	{
		s_piServices = &riExecute.GetServices(); // services was AddRefed
		g_piStringNull = &s_piServices->GetNullString();
		MsiString::InitializeClass(s_piServices->GetNullString());
	}

	g_cServicesUsers++;
}

CAutoExecute::~CAutoExecute()
{
	m_riExecute.Release();
	ReleaseStaticServices();
}

IUnknown& CAutoExecute::GetInterface()
{
	return m_riExecute;
}

void CAutoExecute::ExecuteRecord(CAutoArgs& args)
{
	args = (int) m_riExecute.ExecuteRecord((ixoEnum)(int)args[1], (IMsiRecord&)args[2].Object(IID_IMsiRecord));
}

void CAutoExecute::RunScript(CAutoArgs& args)
{
	args = (int) m_riExecute.RunScript(args[1], false);
}

void CAutoExecute::RemoveRollbackFiles(CAutoArgs& args)
{
	args = (int) m_riExecute.RemoveRollbackFiles((MsiDate)args[1]);
}

void CAutoExecute::Rollback(CAutoArgs& args)
{
	Bool fUserChangedDuringInstall = fFalse;
	if(args.Present(2))
		fUserChangedDuringInstall = args[2];
	args = (int) m_riExecute.Rollback((MsiDate)args[1], fUserChangedDuringInstall ? true : false);
}

void CAutoExecute::RollbackFinalize(CAutoArgs& args)
{
	Bool fUserChangedDuringInstall = fFalse;
	if(args.Present(3))
		fUserChangedDuringInstall = args[3];
	args = (int) m_riExecute.RollbackFinalize((iesEnum)(int)args[1],(MsiDate)args[2], fUserChangedDuringInstall ? true : false);
}

void CAutoExecute::CreateScript(CAutoArgs& args)
{
	if(m_pScript)
	{
		delete m_pScript;
		m_pScript = 0;
	}
	
	PMsiStream pStream(0);
	PMsiRecord pError = s_piServices->CreateFileStream(args[1], fTrue, *&pStream);
		
	if(!pError)
	{
		m_pScript = new CScriptGenerate(*pStream, 0, 0, istInstall, (isaEnum)0, *s_piServices);
	}

	if(m_pScript && !m_pScript->InitializeScript(PROCESSOR_ARCHITECTURE_INTEL))
	{
		delete m_pScript;
		m_pScript = 0;
	}

	args = m_pScript ? fTrue : fFalse;
}

void CAutoExecute::WriteScriptRecord(CAutoArgs& args)
{
	args = (Bool)(m_pScript ? m_pScript->WriteRecord((ixoEnum)(int)args[1], (IMsiRecord&)args[2].Object(IID_IMsiRecord), false) : fFalse);
}

void CAutoExecute::CloseScript(CAutoArgs& /*args*/)
{
	if(m_pScript)
		delete m_pScript;
	m_pScript = 0;
}

//____________________________________________________________________________
//
// MsiEngine automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C104E-0000-0000-C000-000000000046),  // IID_IMsiAutoEngine
		helpcontext(MsiEngine_Object),helpstring("Engine object.")
	]
	dispinterface MsiEngine
	{
		properties:
		methods:
			[id(DISPID_MsiEngine_Services),propget,helpcontext(MsiEngine_Services),helpstring("The MsiServices object used by the engine.")]
				MsiServices* Services();
			[id(DISPID_MsiEngine_ConfigurationServer),propget,helpcontext(MsiEngine_ConfigurationServer),helpstring("The MsiServer object used by the engine.")]
				MsiServer* ConfigurationServer();
			[id(DISPID_MsiEngine_Handler),propget,helpcontext(MsiEngine_Handler),helpstring("The MsiHandler object used by the engine.")]
				MsiHandler*  Handler();
			[id(DISPID_MsiEngine_Database),propget,helpcontext(MsiEngine_Database),helpstring("The MsiDatabase object used by the engine.")]
				MsiDatabase* Database();
			[id(DISPID_MsiEngine_Property),propget, helpcontext(MsiEngine_Property),helpstring("Property value indexed by name.")]
				variant Property([in] BSTR name);
			[id(DISPID_MsiEngine_Property),propput]
				void Property([in] BSTR name, [in] variant value);
			[id(DISPID_MsiEngine_SelectionManager),propget,helpcontext(MsiEngine_SelectionManager),helpstring("The Selection Manager used by the engine.")]
				MsiSelectionManager*  SelectionManager();
			[id(DISPID_MsiEngine_DirectoryManager),propget,helpcontext(MsiEngine_DirectoryManager),helpstring("The Directory Manager used by the engine.")]
				MsiDirectoryManager*  DirectoryManager();
			[id(DISPID_MsiEngine_Initialize),helpcontext(MsiEngine_Initialize),helpstring("Initialize engine and properties.")]
				long Initialize([in] BSTR database, [in] long uiLevel, [in] BSTR commandLine);
			[id(DISPID_MsiEngine_Terminate),helpcontext(MsiEngine_Terminate),helpstring("Shut down engine, release references, handler rollback.")]
				long Terminate([in] long state);
			[id(DISPID_MsiEngine_DoAction),helpcontext(MsiEngine_DoAction),helpstring("Execute a named action.")]
				long DoAction([in] BSTR action);
			[id(DISPID_MsiEngine_Sequence),helpcontext(MsiEngine_Sequence),helpstring("Sequence actions from the specified table.")]
				void Sequence([in] BSTR table);
			[id(DISPID_MsiEngine_Message),helpcontext(MsiEngine_Message),helpstring("Defer to MsiHandler object, logging as required.")]
				long Message([in] long kind, [in] MsiRecord* record);
			[id(DISPID_MsiEngine_OpenView),helpcontext(MsiEngine_OpenView),helpstring("Defer to current OpenView of MsiDatabase object.")]
				MsiView* OpenView([in] BSTR view, [in] long intent);
			[id(DISPID_MsiEngine_ResolveFolderProperty),helpcontext(MsiEngine_ResolveFolderProperty),helpstring("Force resolution of missing or partial source path.")]
				boolean ResolveFolderProperty([in] BSTR property);
			[id(DISPID_MsiEngine_FormatText), helpcontext(MsiEngine_FormatText),helpstring("Formats a string by resolving property names.")]
				BSTR FormatText([in] BSTR text);
			[id(DISPID_MsiEngine_EvaluateCondition), helpcontext(MsiEngine_EvaluateCondition),helpstring("Evaluates a condition expression.")]
				long EvaluateCondition([in] BSTR condition);
			[id(DISPID_MsiEngine_ExecuteRecord), helpcontext(MsiEngine_ExecuteRecord),helpstring("Executes an operation.")]
				long ExecuteRecord([in] long opCode, [in] MsiRecord* params);
			[id(DISPID_MsiEngine_ValidateProductID), helpcontext(MsiEngine_ValidateProductID),helpstring("Validates the Product ID.")]
				boolean ValidateProductID(boolean force);
			[id(DISPID_MsiEngine_GetMode), helpcontext(MsiEngine_GetMode), helpstring("Returns the engine's mode bits (ief*)")]
				unsigned long GetMode();
			[id(DISPID_MsiEngine_SetMode), helpcontext(MsiEngine_SetMode), helpstring("Sets an engine mode bit (ief*)")]
				void SetMode([in] unsigned long mode, [in] Boolean flag);
	};
*/

DispatchEntry<CAutoEngine> AutoEngineTable[] = {
	DISPID_MsiEngine_Services,              aafPropRO, CAutoEngine::Services,             TEXT("Services"),
	DISPID_MsiEngine_ConfigurationServer,   aafPropRO, CAutoEngine::ConfigurationServer,  TEXT("ConfigurationServer"),
	DISPID_MsiEngine_Handler,               aafPropRO, CAutoEngine::Handler,              TEXT("Handler"),
	DISPID_MsiEngine_Database,              aafPropRO, CAutoEngine::Database,             TEXT("Database"),
	DISPID_MsiEngine_Property,              aafPropRW, CAutoEngine::Property,             TEXT("Property,name"),
	DISPID_MsiEngine_SelectionManager,      aafPropRO, CAutoEngine::SelectionManager,     TEXT("SelectionManager"),
	DISPID_MsiEngine_DirectoryManager,      aafPropRO, CAutoEngine::DirectoryManager,     TEXT("DirectoryManager"),
	DISPID_MsiEngine_Initialize,            aafMethod, CAutoEngine::Initialize,           TEXT("Initialize,database,uiLevel,commandLine"),
	DISPID_MsiEngine_Terminate,             aafMethod, CAutoEngine::Terminate,            TEXT("Terminate,state"),
   DISPID_MsiEngine_DoAction,              aafMethod, CAutoEngine::DoAction,             TEXT("DoAction,action"),
   DISPID_MsiEngine_Sequence,              aafMethod, CAutoEngine::Sequence,             TEXT("Sequence,table"),
   DISPID_MsiEngine_Message,               aafMethod, CAutoEngine::Message,              TEXT("Message,kind,record"),
   DISPID_MsiEngine_OpenView,              aafMethod, CAutoEngine::OpenView,             TEXT("OpenView,view,intent"),
   DISPID_MsiEngine_ResolveFolderProperty, aafMethod, CAutoEngine::ResolveFolderProperty,TEXT("ResolveFolderProperty,property"),
   DISPID_MsiEngine_FormatText,            aafMethod, CAutoEngine::FormatText,           TEXT("FormatText,text"),
   DISPID_MsiEngine_EvaluateCondition,     aafMethod, CAutoEngine::EvaluateCondition,    TEXT("EvaluateCondition,condition"),
   DISPID_MsiEngine_ValidateProductID,     aafMethod, CAutoEngine::ValidateProductID,    TEXT("ValidateProductID,force"),
   DISPID_MsiEngine_ExecuteRecord,         aafMethod, CAutoEngine::ExecuteRecord,        TEXT("ExecuteRecord,opcode,parameters"),
	DISPID_MsiEngine_GetMode,               aafMethod, CAutoEngine::GetMode,              TEXT("GetMode"),
	DISPID_MsiEngine_SetMode,               aafMethod, CAutoEngine::SetMode,              TEXT("SetMode,mode,flag"),
};
const int AutoEngineCount = sizeof(AutoEngineTable)/sizeof(DispatchEntryBase);  

//____________________________________________________________________________
//
// CMsiEngine automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoEngine(IMsiEngine& riEngine)
{
	return new CAutoEngine(riEngine);
}

CAutoEngine::CAutoEngine(IMsiEngine& riEngine)
 : CAutoBase(*AutoEngineTable, AutoEngineCount), m_riEngine(riEngine)
{
	if (g_cServicesUsers == 0)
	{
		s_piServices = riEngine.GetServices(); // services was AddRefed
		g_piStringNull = &s_piServices->GetNullString();
		MsiString::InitializeClass(s_piServices->GetNullString());
	}
	g_cServicesUsers++;
}

CAutoEngine::~CAutoEngine()
{
	m_riEngine.Release();
	ReleaseStaticServices();
}

IUnknown& CAutoEngine::GetInterface()
{
	return m_riEngine;
}

void CAutoEngine::Services(CAutoArgs& args)
{
	args = new CAutoServices(*m_riEngine.GetServices());
}

void CAutoEngine::ConfigurationServer(CAutoArgs& args)
{
    IMsiServer * piServer = m_riEngine.GetConfigurationServer();

    if (!piServer)
        args = (IDispatch*) 0;
    else
        args = new CAutoServer(*piServer);	
}

void CAutoEngine::Handler(CAutoArgs& args)
{
	IMsiHandler* piHandler = m_riEngine.GetHandler();
	if (!piHandler)
		args = (IDispatch*)0;
	else
		args = new CAutoHandler(*piHandler);
}

void CAutoEngine::Database(CAutoArgs& args)
{
	IMsiDatabase* piDatabase = m_riEngine.GetDatabase();
	if (!piDatabase)
		args = (IDispatch*)0;
	else
		args = (IDispatch*)new CAutoDatabase(*piDatabase);
}

void CAutoEngine::Property(CAutoArgs& args)
{
	MsiString istrName(args[1].GetMsiString());
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		if (var.GetType() == VT_EMPTY)
			m_riEngine.SetProperty(*istrName, *g_piStringNull);
		else if (var.GetType() == VT_BSTR)
			m_riEngine.SetProperty(*istrName, *MsiString(var.GetMsiString()));
		else
			m_riEngine.SetPropertyInt(*istrName, var);
	}
	else
	{
		const IMsiString& riStr = m_riEngine.GetProperty(*istrName);
		if (riStr.TextSize())
			args = riStr;
		else
			riStr.Release();
	}
}

void CAutoEngine::SelectionManager(CAutoArgs& args)
{
	IMsiSelectionManager* piSelectionManager;
	if (m_riEngine.QueryInterface(IID_IMsiSelectionManager, (void**)&piSelectionManager)
			!= NOERROR)
		throw MsiEngine_SelectionManager;
	args = new CAutoSelectionManager(*piSelectionManager);
}

void CAutoEngine::DirectoryManager(CAutoArgs& args)
{
	IMsiDirectoryManager* piDirectoryManager;
	if (m_riEngine.QueryInterface(IID_IMsiDirectoryManager, (void**)&piDirectoryManager)
			!= NOERROR)
		throw MsiEngine_DirectoryManager;
	args = new CAutoDirectoryManager(*piDirectoryManager);
}

void CAutoEngine::Initialize(CAutoArgs& args)
{
	iuiEnum iuiLevel = args.Present(2) ? (iuiEnum)(int)args[2] : iuiBasic;
	const ICHAR* szCommandLine = args.Present(3) ? (const ICHAR*)args[3] : (const ICHAR*)0;
	const ICHAR* szProductCode = args.Present(4) ? (const ICHAR*)args[4] : (const ICHAR*)0;
	args = (int)m_riEngine.Initialize(args[1], iuiLevel, szCommandLine, szProductCode,(iioEnum)0);
}

void CAutoEngine::DoAction(CAutoArgs& args)
{
	args = (int)m_riEngine.DoAction(args[1]);
}

void CAutoEngine::Terminate(CAutoArgs& args)
{
	args = (int)m_riEngine.Terminate((iesEnum)(int)args[1]);
}

void CAutoEngine::Sequence(CAutoArgs& args)
{
	args = (int)m_riEngine.Sequence(args[1]);
}

void CAutoEngine::Message(CAutoArgs& args)
{
	IMsiRecord& riRecord = (IMsiRecord&)args[2].Object(IID_IMsiRecord);
	args = (int)m_riEngine.Message((imtEnum)(int)args[1], riRecord);
}

void CAutoEngine::OpenView(CAutoArgs& args)
{
	IMsiView* piView;
	IMsiRecord* piError = m_riEngine.OpenView(args[1], (ivcEnum)(int)args[2], piView);
   if (piError)
		throw piError;
	args = new CAutoView(*piView);
}

void CAutoEngine::ResolveFolderProperty(CAutoArgs& args)
{
	args = m_riEngine.ResolveFolderProperty(*MsiString(args[1].GetMsiString()));
}

void CAutoEngine::FormatText(CAutoArgs& args)
{
	args = m_riEngine.FormatText(*MsiString(args[1].GetMsiString()));
}

void CAutoEngine::EvaluateCondition(CAutoArgs& args)
{
	args = (int)m_riEngine.EvaluateCondition(args[1]);
}

void CAutoEngine::GetMode(CAutoArgs& args)
{
	args = (int)m_riEngine.GetMode();
}

void CAutoEngine::SetMode(CAutoArgs& args)
{
	m_riEngine.SetMode(args[1], args[2]);
}

void CAutoEngine::ExecuteRecord(CAutoArgs& args)
{
	args = (int)m_riEngine.ExecuteRecord((ixoEnum)(int)args[1], (IMsiRecord&)args[2].Object(IID_IMsiRecord));
}

void CAutoEngine::ValidateProductID(CAutoArgs& args)
{
	args = m_riEngine.ValidateProductID(((Bool)args[1]) == fTrue);
}


//____________________________________________________________________________
//
// MsiHandler automation definitions
//____________________________________________________________________________
/*O

	[
		uuid(000C104F-0000-0000-C000-000000000046),  // IID_IMsiAutoHandler
		helpcontext(MsiHandler_Object),helpstring("Message and UI handler object.")
	]
	dispinterface MsiHandler
	{
		properties:
		methods:
			[id(1), helpcontext(MsiHandler_Message),helpstring("Handles error, progress and other messages from the engine.")]
				long Message([in] long kind, [in] MsiRecord* record);
			[id(2), helpcontext(MsiHandler_DoAction),helpstring("Handles actions (starting wizards, custom actions, etc.)")]
				long DoAction([in] BSTR action);
			[id(3), helpcontext(MsiHandler_Break),helpstring("Break out of message loop and allow shut down.")] 
				void Break();

	};
*/

DispatchEntry<CAutoHandler> AutoHandlerTable[] = {
	1, aafMethod, CAutoHandler::Message,        TEXT("Message,kind,record"),
	2, aafMethod, CAutoHandler::DoAction,       TEXT("DoAction,action"),
	3, aafMethod, CAutoHandler::Break,          TEXT("Break"),
};
const int AutoHandlerCount = sizeof(AutoHandlerTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiHandler automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoHandler(IMsiHandler& riHandler)
{
	return new CAutoHandler(riHandler);
}

CAutoHandler::CAutoHandler(IMsiHandler& riHandler)
 : CAutoBase(*AutoHandlerTable, AutoHandlerCount), m_riHandler(riHandler)
{
}

CAutoHandler::~CAutoHandler()
{
	m_riHandler.Release();
}

IUnknown& CAutoHandler::GetInterface()
{
	return m_riHandler;
}

void CAutoHandler::Message(CAutoArgs& args)
{
	IMsiRecord& riRecord = (IMsiRecord&)args[2].Object(IID_IMsiRecord);
	args = (int)m_riHandler.Message((imtEnum)(int)args[1], riRecord);
}

void CAutoHandler::DoAction(CAutoArgs& args)
{
	args = (int)m_riHandler.DoAction(args[1]);
}

void CAutoHandler::Break(CAutoArgs& /*args*/)
{
	if(!m_riHandler.Break())
		throw MsiHandler_Break;
}


//____________________________________________________________________________
//
// MsiDialogHandler automation definitions
//____________________________________________________________________________
/*O

	[
		uuid(000C1053-0000-0000-C000-000000000046),  // IID_IMsiAutoDialogHandler
		helpcontext(MsiDialogHandler_Object),helpstring("Dialog handler object.")
	]
	dispinterface MsiDialogHandler
	{
		properties:
		methods:
			[id(1), helpcontext(MsiDialogHandler_DialogCreate),helpstring("Creates an empty dialog of the specified type.")] 
				MsiDialog* DialogCreate([in] BSTR type);
			[id(2), helpcontext(MsiDialogHandler_Dialog),helpstring("Returns the pointer to the dialog by name.")] 
				MsiDialog* Dialog([in] BSTR name); 
			[id(3), helpcontext(MsiDialogHandler_DialogFromWindow),helpstring("Returns the pointer to the dialog with the given window reference.")] 
				MsiDialog* DialogFromWindow([in] long window); 
			[id(4),helpcontext(MsiDialogHandler_AddDialog),helpstring("Adds a dialog to the list and creates the window using the record.")]
				void AddDialog([in] MsiDialog* dialog, [in] MsiDialog* parent, [in] MsiRecord* record, 
				[in] MsiTable* controleventtable,[in] MsiTable* controlconditiontable, [in] MsiTable* eventmappingtable);
			[id(5),helpcontext(MsiDialogHandler_RemoveDialog),helpstring("Removes a dialog from the list.")]
				void RemoveDialog([in] MsiDialog* dialog);
	};
*/

DispatchEntry<CAutoDialogHandler> AutoDialogHandlerTable[] = {
	1, aafMethod, CAutoDialogHandler::DialogCreate,   TEXT("DialogCreate,type"),
	2, aafPropRO, CAutoDialogHandler::Dialog,         TEXT("Dialog,name"),
	3, aafPropRO, CAutoDialogHandler::DialogFromWindow, TEXT("Dialog,window"),
	4, aafMethod, CAutoDialogHandler::AddDialog,      TEXT("AddDialog,dialog,parent,record,controleventtable,controlconditiontable,eventmappingtable"),
	5, aafMethod, CAutoDialogHandler::RemoveDialog,   TEXT("RemoveDialog,dialog"),
};
const int AutoDialogHandlerCount = sizeof(AutoDialogHandlerTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiDialogHandler automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoDialogHandler(IMsiDialogHandler& riHandler)
{
	return new CAutoDialogHandler(riHandler);
}

CAutoDialogHandler::CAutoDialogHandler(IMsiDialogHandler& riHandler)
 : CAutoBase(*AutoDialogHandlerTable, AutoDialogHandlerCount), m_riDialogHandler(riHandler)
{
}

CAutoDialogHandler::~CAutoDialogHandler()
{
	m_riDialogHandler.Release();
}

IUnknown& CAutoDialogHandler::GetInterface()
{
	return m_riDialogHandler;
}


void CAutoDialogHandler::DialogCreate(CAutoArgs& args)
{
	IMsiDialog* piDialog = m_riDialogHandler.DialogCreate(*MsiString(args[1].GetMsiString()));
	if (piDialog)
		args = new CAutoDialog(*piDialog);
	else
		throw MsiDialogHandler_DialogCreate;
}

void CAutoDialogHandler::Dialog(CAutoArgs& args)
{
	IMsiDialog* piDialog = m_riDialogHandler.GetDialog(*MsiString(args[1].GetMsiString()));
	if (piDialog)
		args = new CAutoDialog(*piDialog);
	else
		throw MsiDialogHandler_Dialog;
}

void CAutoDialogHandler::DialogFromWindow(CAutoArgs& args)
{
	IMsiDialog* piDialog = m_riDialogHandler.GetDialogFromWindow((LONG_PTR) args[1]);
	if (piDialog)
		args = new CAutoDialog(*piDialog);
	else
		throw MsiDialogHandler_DialogFromWindow;
}


void CAutoDialogHandler::AddDialog(CAutoArgs& args)
{
	IMsiDialog& riDialog = (IMsiDialog&)args[1].Object(IID_IMsiDialog);
	IMsiDialog* piParent = (IMsiDialog*)args[2].ObjectPtr(IID_IMsiDialog);
	IMsiRecord& riRecord = (IMsiRecord&)args[3].Object(IID_IMsiRecord);
	IMsiTable* riControlEventTable = (IMsiTable*)args[4].ObjectPtr(IID_IMsiTable);
	IMsiTable* riControlCondTable = (IMsiTable*)args[5].ObjectPtr(IID_IMsiTable);
	IMsiTable* riEventMapTable = (IMsiTable*)args[6].ObjectPtr(IID_IMsiTable);
	if (!m_riDialogHandler.AddDialog(riDialog, piParent, riRecord,riControlEventTable,riControlCondTable,riEventMapTable))
		throw MsiDialogHandler_AddDialog;
}

void CAutoDialogHandler::RemoveDialog(CAutoArgs& args)
{
	IMsiDialog*  piDialog = (IMsiDialog*)args[1].ObjectPtr(IID_IMsiDialog);
	if (!m_riDialogHandler.RemoveDialog(piDialog))
		throw MsiDialogHandler_RemoveDialog;
}

//____________________________________________________________________________
//
// MsiDialog automation definitions
//____________________________________________________________________________
/*O

	[	
		uuid(000C1050-0000-0000-C000-000000000046),  // IID_IMsiAutoDialog
		helpcontext(MsiDialog_Object),helpstring("Dialog object, interface towards the handler.")
	]
	dispinterface MsiDialog
	{
		properties:
		methods:
			[id(1), helpcontext(MsiDialog_Visible),helpstring("Turns the dialog window visible.")]
				void Visible([in] boolean show);
			[id(2), helpcontext(MsiDialog_ControlCreate),helpstring("Creates an empty control.")]
				MsiControl* ControlCreate([in] BSTR type);
			[id(3), helpcontext(MsiDialog_Attribute),helpstring("Sets/gets dialog attribute values.")]
				void Attribute([in] boolean	set, [in] BSTR attributename, MsiRecord* record);
			[id(4), helpcontext(MsiDialog_Control),helpstring("Return the pointer to the control by name.")]
				MsiControl* Control([in] BSTR name);
			[id(5), helpcontext(MsiDialog_AddControl),helpstring("Adds a control to the dialog.")]
				void AddControl([in] MsiControl* control, [in] MsiRecord* record);
			[id(6), helpcontext(MsiDialog_Execute),helpstring("Runs a modal dialog.")]
				void Execute();
			[id(7), helpcontext(MsiDialog_Reset), helpstring("Resets the dialog and restores the origianal values.")]
				void Reset();
			[id(8), helpcontext(MsiDialog_EventAction),helpstring("Performs the action on every subscriber of the event.")]
				void EventAction([in] BSTR eventname, [in] BSTR action);
			[id(9), helpcontext(MsiDialog_RemoveControl),helpstring("Removes a control from the dialog.")]
				void RemoveControl([in] MsiControl* control);
			[id(10), helpcontext(MsiDialog_StringValue), helpstring("String value of the dialog")]
				BSTR StringValue();
			[id(11), propget, helpcontext(MsiDialog_IntegerValue), helpstring("Integer value for dialog")]
				long IntegerValue();
			[id(12), helpcontext(MsiDialog_Handler),helpstring("Returns the DialogHandler used by the dialog.")]
				MsiDialogHandler* Handler();
			[id(13), helpcontext(MsiDialog_PropertyChanged),helpstring("Performs the actions in the ControlCondition table.")]
				void PropertyChanged([in] BSTR property, [in] BSTR control);
			[id(14), helpcontext(MsiDialog_FinishCreate),helpstring("Signals that all the controls are added to the dialog.")]
				void FinishCreate();
			[id(15), helpcontext(MsiDialog_HandleEvent),helpstring("Triggers a control event.")]
				void HandleEvent([in] BSTR eventname, [in] BSTR argument);
	};
*/

DispatchEntry<CAutoDialog> AutoDialogTable[] = {
	1, aafPropWO, CAutoDialog::Visible,        TEXT("Visible,show"),
	2, aafMethod, CAutoDialog::ControlCreate,  TEXT("ControlCreate,type"),
	3, aafMethod, CAutoDialog::Attribute,      TEXT("Attribute,set,attributename,record"),
	4, aafPropRO, CAutoDialog::Control,        TEXT("Control,name"),
	5, aafMethod, CAutoDialog::AddControl,     TEXT("AddControl,control,record"),
	6, aafMethod, CAutoDialog::Execute,        TEXT("Execute"),
	7, aafMethod, CAutoDialog::Reset,          TEXT("Reset"),
	8 ,aafMethod, CAutoDialog::EventAction,    TEXT("EventAction,eventname,action"),
	9, aafMethod, CAutoDialog::RemoveControl,  TEXT("RemoveControl,control"),
	10,aafPropRO, CAutoDialog::StringValue,    TEXT("StringValue"),
	11,aafPropRO, CAutoDialog::IntegerValue,   TEXT("IntegerValue"),
	12,aafPropRO, CAutoDialog::Handler,        TEXT("Handler"),
	13,aafMethod, CAutoDialog::PropertyChanged,TEXT("PropertyChanged,property,control"),
	14,aafMethod, CAutoDialog::FinishCreate,   TEXT("FinishCreate"),
	15,aafMethod, CAutoDialog::HandleEvent,    TEXT("HandleEvent, eventname, argument"),
};
const int AutoDialogCount = sizeof(AutoDialogTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiDialog automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoDialog(IMsiDialog& riDialog)
{
	return new CAutoDialog(riDialog);
}

CAutoDialog::CAutoDialog(IMsiDialog& riDialog)
 : CAutoBase(*AutoDialogTable, AutoDialogCount), m_riDialog(riDialog)
{
}

CAutoDialog::~CAutoDialog()
{
	m_riDialog.Release();
}

IUnknown& CAutoDialog::GetInterface()
{
	return m_riDialog;
}

void CAutoDialog::Visible(CAutoArgs& args)
{
	if(args.PropertySet())
	{
		IMsiRecord* piError = m_riDialog.WindowShow((Bool)(int)args[1]);
		if (piError)
			throw piError;
	}
}

void CAutoDialog::ControlCreate(CAutoArgs& args)
{
	IMsiControl* piControl = m_riDialog.ControlCreate(*MsiString(args[1].GetMsiString()));
	if (piControl)
		args = new CAutoControl(*piControl);
	else
		throw MsiDialog_ControlCreate;
}

void CAutoDialog::Attribute(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDialog.Attribute((Bool) (int)args[1], *MsiString(args[2].GetMsiString()),(IMsiRecord &) args[3].Object(IID_IMsiRecord));
	if (piError)
		throw piError;
}

void CAutoDialog::Control(CAutoArgs& args)
{
	IMsiControl* piControl;	
	IMsiRecord* piError =  m_riDialog.GetControl(*MsiString(args[1].GetMsiString()), piControl);
	if (piError)
		throw piError;
	args = new CAutoControl(*piControl);
}

void CAutoDialog::AddControl(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDialog.AddControl((IMsiControl*)args[1].ObjectPtr(IID_IMsiControl), (IMsiRecord&)args[2].Object(IID_IMsiRecord));
	if(piError)
		throw piError;
}

void CAutoDialog::FinishCreate(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riDialog.FinishCreate();
	if(piError)
		throw piError;
}

void CAutoDialog::RemoveControl(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDialog.RemoveControl((IMsiControl*)args[1].ObjectPtr(IID_IMsiControl));
	if(piError)
		throw piError;
}

void CAutoDialog::Handler(CAutoArgs& args)
{
	IMsiDialogHandler& riHandler=m_riDialog.GetHandler();
	args = new CAutoDialogHandler(riHandler);
}

void CAutoDialog::Execute(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riDialog.WindowShow(fTrue);
	if(piError)
		throw piError;
	piError = m_riDialog.Execute();
	if(piError)
		throw piError;
}

void CAutoDialog::Reset(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riDialog.Reset();
	if(piError)
		throw piError;
}

void CAutoDialog::EventAction(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDialog.EventActionSz((const ICHAR *)args[1], *MsiString(args[2].GetMsiString()));
	if(piError)
		throw piError;
}

void CAutoDialog::StringValue(CAutoArgs& args)
{
	args = m_riDialog.GetMsiStringValue();
}

void CAutoDialog::IntegerValue(CAutoArgs& args)
{
	args = m_riDialog.GetIntegerValue();
}

void CAutoDialog::PropertyChanged(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDialog.PropertyChanged(*MsiString(args[1].GetMsiString()), *MsiString(args[2].GetMsiString()));
	if(piError)
		throw piError;
}

void CAutoDialog::HandleEvent(CAutoArgs& args)
{
	IMsiRecord* piError = m_riDialog.HandleEvent(*MsiString(args[1].GetMsiString()), *MsiString(args[2].GetMsiString()));
	if(piError)
		throw piError;
}


		 

//____________________________________________________________________________
//
// MsiEvent automation definitions
//____________________________________________________________________________
/*O

	[	
		uuid(000C1051-0000-0000-C000-000000000046),  // IID_IMsiAutoEvent
		helpcontext(MsiEvent_Object),helpstring("Event object, the dialog's interface towards the controls.")
	]
	dispinterface MsiEvent
	{
		properties:
		methods:
			[id(1), helpcontext(MsiEvent_PropertyChanged),helpstring("Performs the actions in the ControlCondition table.")]
				void PropertyChanged([in] BSTR property, [in] BSTR control);
			[id(2), helpcontext(MsiEvent_ControlActivated),helpstring("Performs the events in the ControlEvents table.")]
				void ControlActivated([in] BSTR control);
			[id(3), helpcontext(MsiEvent_RegisterControlEvent),helpstring("Registers the publisher of an event.")]
				void RegisterControlEvent([in] BSTR control, [in] boolean toregister, [in] BSTR event);
			[id(4), helpcontext(MsiEvent_Handler),helpstring("Returns the DialogHandler used by the dialog.")]
				MsiDialogHandler* Handler();
			[id(5), helpcontext(MsiEvent_PublishEvent),helpstring("The publisher of an event sends notification to the subscribers.")]
				void PublishEvent([in] BSTR eventname, [in] MsiRecord* argument);
			[id(6), helpcontext(MsiEvent_Control),helpstring("Return the pointer to the control by name.")]
				MsiControl* Control([in] BSTR name);
			[id(7), helpcontext(MsiEvent_Attribute), helpstring("Sets/gets the dialog attribute.")]
				void Attribute([in] boolean set, [in] BSTR attributename, MsiRecord* record);
			[id(8), helpcontext(MsiEvent_EventAction),helpstring("Performs the action on every subscriber of the event.")]
				void EventAction([in] BSTR eventname, [in] BSTR action);
			[id(9), helpcontext(MsiEvent_SetFocus),helpstring("Sets the focus to a control.")]
				void SetFocus([in] BSTR control);
			[id(10), helpcontext(MsiEvent_StringValue), helpstring("String value of the event")]
				BSTR StringValue();
			[id(11), propget, helpcontext(MsiEvent_IntegerValue), helpstring("Integer value for event")]
				long IntegerValue();
			[id(12), helpcontext(MsiEvent_HandleEvent), helpstring("Triggers a control event")]
				void HandleEvent([in] BSTR eventname, [in] BSTR argument);
			[id(13),helpcontext(MsiEvent_Engine),helpstring("The MsiEngine object used by the event.")]
				MsiEngine* Engine();
			[id(14),helpcontext(MsiEvent_Escape),helpstring("Handles hitting the Escape key.")]
				void Escape();
	};
*/

DispatchEntry<CAutoEvent> AutoEventTable[] = {
	1, aafMethod, CAutoEvent::PropertyChanged,      TEXT("PropertyChanged,property,control"),
	2, aafMethod, CAutoEvent::ControlActivated,     TEXT("ControlActivated,control"),
	3, aafMethod, CAutoEvent::RegisterControlEvent, TEXT("RegisterControlEvent,control,toregister,event"),
	4, aafPropRO, CAutoEvent::Handler,              TEXT("Handler"),
	5, aafMethod, CAutoEvent::PublishEvent,         TEXT("PublishEvent,eventname,argument"),
	6, aafPropRO, CAutoEvent::Control,              TEXT("Control,name"),
	7, aafMethod, CAutoEvent::Attribute,            TEXT("Attribute,set,attributename,record"),
	8, aafMethod, CAutoEvent::EventAction,          TEXT("EventAction,eventname,action"),
	9, aafMethod, CAutoEvent::SetFocus,             TEXT("SetFocus, control"),
	10,aafPropRO, CAutoEvent::StringValue,          TEXT("StringValue"),
	11,aafPropRO, CAutoEvent::IntegerValue,         TEXT("IntegerValue"),
	12,aafMethod, CAutoEvent::HandleEvent,          TEXT("HandleEvent, eventname, argument"),
	13,aafPropRO, CAutoEvent::Engine,               TEXT("Engine"),

};
const int AutoEventCount = sizeof(AutoEventTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiEvent automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoEvent(IMsiEvent& riEvent)
{
	return new CAutoEvent(riEvent);
}

CAutoEvent::CAutoEvent(IMsiEvent& riEvent)
 : CAutoBase(*AutoEventTable, AutoEventCount), m_riEvent(riEvent)
{
}

CAutoEvent::~CAutoEvent()
{
	m_riEvent.Release();
}

IUnknown& CAutoEvent::GetInterface()
{
	return m_riEvent;
}

void CAutoEvent::PropertyChanged(CAutoArgs& args)
{
	IMsiRecord* piError = m_riEvent.PropertyChanged(*MsiString(args[1].GetMsiString()), *MsiString(args[2].GetMsiString()));
	if(piError)
		throw piError;
}

void CAutoEvent::ControlActivated(CAutoArgs& args)
{
	IMsiRecord* piError = m_riEvent.ControlActivated(*MsiString(args[1].GetMsiString()));
	if (piError)
		throw piError;
}

void CAutoEvent::RegisterControlEvent(CAutoArgs& args)
{
	IMsiRecord* piError = m_riEvent.RegisterControlEvent(*MsiString(args[1].GetMsiString()),(Bool)(int)args[2],(const ICHAR *)args[3]);
	if (piError)
		throw piError;
}

void CAutoEvent::Escape(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riEvent.Escape();
	if (piError)
		throw piError;
}

void CAutoEvent::Handler(CAutoArgs& args)
{
	IMsiDialogHandler& riHandler=m_riEvent.GetHandler();
	args = new CAutoDialogHandler(riHandler);
}

void CAutoEvent::PublishEvent(CAutoArgs& args)
{
	IMsiRecord* piError = m_riEvent.PublishEventSz(args[1],(IMsiRecord&)args[2].Object(IID_IMsiRecord));
	if(piError)
		throw piError;
}

void CAutoEvent::Control(CAutoArgs& args)
{
	IMsiControl* piControl;
	IMsiRecord* piError =  m_riEvent.GetControl(*MsiString(args[1].GetMsiString()), piControl);
	if (piError)
		throw piError;
	args = new CAutoControl(*piControl);
}

void CAutoEvent::Attribute(CAutoArgs& args)
{
	IMsiRecord* piError = m_riEvent.Attribute((Bool)(int) args[1], *MsiString(args[2].GetMsiString()),(IMsiRecord &) args[3].Object(IID_IMsiRecord));
	if (piError)
		throw piError;
}

void CAutoEvent::EventAction(CAutoArgs& args)
{
	IMsiRecord* piError = m_riEvent.EventActionSz((const ICHAR *)args[1], *MsiString(args[2].GetMsiString()));
	if(piError)
		throw piError;
}	

void CAutoEvent::SetFocus(CAutoArgs& args)
{
	IMsiRecord* piError =  m_riEvent.SetFocus(*MsiString(args[1].GetMsiString()));
	if (piError)
		throw piError;
}

void CAutoEvent::StringValue(CAutoArgs& args)
{
	args = ((IMsiDialog&)m_riEvent).GetMsiStringValue();
}

void CAutoEvent::IntegerValue(CAutoArgs& args)
{
	args = ((IMsiDialog&)m_riEvent).GetIntegerValue();
}

void CAutoEvent::HandleEvent(CAutoArgs& args)
{
	IMsiRecord* piError = m_riEvent.HandleEvent(*MsiString(args[1].GetMsiString()), *MsiString(args[2].GetMsiString()));
	if(piError)
		throw piError;
}

void CAutoEvent::Engine(CAutoArgs& args)
{
	IMsiEngine& riEngine=m_riEvent.GetEngine();
	args = new CAutoEngine(riEngine);
}




//____________________________________________________________________________
//
// MsiControl automation definitions
//____________________________________________________________________________
/*O

	[	
		uuid(000C1052-0000-0000-C000-000000000046),  // IID_IMsiAutoControl
		helpcontext(MsiControl_Object),helpstring("General interface of the controls.")
	]
	dispinterface MsiControl
	{
		properties:
		methods:
			[id(1), helpcontext(MsiControl_Attribute), helpstring("Sets/gets the control attribute.")]
				void Attribute([in] boolean set, [in] BSTR attributename, MsiRecord* record);
			[id(2), helpcontext(MsiControl_CanTakeFocus),helpstring("Returns a flag wheather the control can take focus.")]
				boolean CanTakeFocus();
			[id(3), helpcontext(MsiControl_HandleEvent),helpstring("Notification to the publisher of an event.")]
				void HandleEvent([in]BSTR eventname, [in] BSTR argument);
			[id(4), helpcontext(MsiControl_Undo),helpstring("Restore the original value of the property.")]
				void Undo();
			[id(5), helpcontext(MsiControl_SetPropertyInDatabase),helpstring("Store the control's property value in the database.")] 
				void SetPropertyInDatabase();
			[id(6), helpcontext(MsiControl_GetPropertyFromDatabase),helpstring("Fetches the property value from the database.")]
				void GetPropertyFromDatabase();
			[id(7), helpcontext(MsiControl_SetFocus),helpstring("Sets the focus on the control.")]
				void SetFocus();
			[id(8), helpcontext(MsiControl_Dialog),helpstring("Returns a pointer to the Event interface.")]
				MsiEvent* Dialog();
			[id(9), helpcontext(MsiControl_WindowMessage),helpstring("Handles the window message.")]
				boolean WindowMessage([in] long message, [in] long wParam, [in] long lParam);
			[id(10), helpcontext(MsiControl_StringValue), helpstring("String value of the control")]
				BSTR StringValue();
			[id(11), propget, helpcontext(MsiControl_IntegerValue), helpstring("Integer value for control")]
				long IntegerValue();
			[id(12), helpcontext(MsiControl_GetIndirectPropertyFromDatabase),helpstring("Fetches the indirect property value from the database.")]
				void GetIndirectPropertyFromDatabase();
	};
*/

DispatchEntry<CAutoControl> AutoControlTable[] = {
	1, aafMethod, CAutoControl::Attribute,     TEXT("Attribute,set,attributename,record"),
	2, aafPropRO, CAutoControl::CanTakeFocus,  TEXT("CanTakeFocus"),
	3, aafMethod, CAutoControl::HandleEvent,   TEXT("HandleEvent,eventname,argument"),
	4, aafMethod, CAutoControl::Undo,          TEXT("Undo"),
	5, aafMethod, CAutoControl::SetPropertyInDatabase,TEXT("SetPropertyInDatabase"),
	6, aafMethod, CAutoControl::GetPropertyFromDatabase,TEXT("GetPropertyFromDatabase"),
	7, aafMethod, CAutoControl::SetFocus,      TEXT("SetFocus"),
	8, aafPropRO, CAutoControl::Dialog,        TEXT("Dialog"),
	9, aafMethod, CAutoControl::WindowMessage, TEXT("WindowMessage,message,wParam,lParam"),
	10,aafPropRO, CAutoControl::StringValue,   TEXT("StringValue"),
	11,aafPropRO, CAutoControl::IntegerValue,  TEXT("IntegerValue"),
	12,aafMethod, CAutoControl::GetIndirectPropertyFromDatabase,TEXT("GetIndirectPropertyFromDatabase"),
};
const int AutoControlCount = sizeof(AutoControlTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiControl automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoControl(IMsiControl& riControl)
{
	return new CAutoControl(riControl);
}

CAutoControl::CAutoControl(IMsiControl& riControl)
 : CAutoBase(*AutoControlTable, AutoControlCount), m_riControl(riControl)
{
}

CAutoControl::~CAutoControl()
{
	m_riControl.Release();
}

IUnknown& CAutoControl::GetInterface()
{
	return m_riControl;
}

void CAutoControl::Attribute(CAutoArgs& args)
{
	IMsiRecord* piError = m_riControl.Attribute((Bool)(int) args[1], *MsiString(args[2].GetMsiString()),(IMsiRecord &) args[3].Object(IID_IMsiRecord));
	if (piError)
		throw piError;
}

void CAutoControl::CanTakeFocus(CAutoArgs& args)
{
	args = m_riControl.CanTakeFocus();
}

void CAutoControl::HandleEvent(CAutoArgs& args)
{
	IMsiRecord* piError = m_riControl.HandleEvent(*MsiString(args[1].GetMsiString()),*MsiString(args[2].GetMsiString()));
	if(piError)
		throw piError;
}

void CAutoControl::Undo(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riControl.Undo();
	if(piError)
		throw piError;
}

void CAutoControl::SetPropertyInDatabase(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riControl.SetPropertyInDatabase();
	if(piError)
		throw piError;
}

void CAutoControl::GetPropertyFromDatabase(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riControl.GetPropertyFromDatabase();
	if(piError)
		throw piError;
}

void CAutoControl::GetIndirectPropertyFromDatabase(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riControl.GetIndirectPropertyFromDatabase();
	if(piError)
		throw piError;
}

void CAutoControl::SetFocus(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riControl.SetFocus();
	if(piError)
		throw piError;
}

void CAutoControl::Dialog(CAutoArgs& args)
{
	IMsiEvent& riEvent = m_riControl.GetDialog();
	args = new CAutoEvent(riEvent);
}

void CAutoControl::WindowMessage(CAutoArgs& args)
{
	IMsiRecord* piError = m_riControl.WindowMessage((int) args[1], (long) args[2], (long) args[3]);
	if(piError)
		throw piError;
}

void CAutoControl::StringValue(CAutoArgs& args)
{
	args = m_riControl.GetMsiStringValue();
}

void CAutoControl::IntegerValue(CAutoArgs& args)
{
	args = m_riControl.GetIntegerValue();
}


//____________________________________________________________________________
//
// MsiVolume automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1044-0000-0000-C000-000000000046),  // IID_IMsiAutoVolume
		helpcontext(MsiVolume_Object),helpstring("Volume object.")
	]
	dispinterface MsiVolume
	{
		properties:
		methods:
			[id(0), propget,helpcontext(MsiVolume_Path), helpstring("Returns a string representing the path to the volume.")] long Path();
			[id(1), propget,helpcontext(MsiVolume_VolumeID), helpstring("Returns an integer representing the volume ID.")] long VolumeID();
			[id(2), propget,helpcontext(MsiVolume_DriveType), helpstring("Returns an enum value representing the volume's type.")] long DriveType();
			[id(3), propget,helpcontext(MsiVolume_SupportsLFN), helpstring("Returns a boolean indicating whether the volume supports long file names.")] boolean SupportsLFN();
			[id(4), propget,helpcontext(MsiVolume_FreeSpace), helpstring("Returns the amount of free space on the volume, in units of 512 bytes.")] long FreeSpace();
			[id(5), propget,helpcontext(MsiVolume_ClusterSize), helpstring("Returns the assigned size of each disk cluster on the volume.")] long ClusterSize();
			[id(6), propget,helpcontext(MsiVolume_FileSystem), helpstring("Returns a string representing the name of the volume's file system.")] BSTR FileSystem();
			[id(7), propget,helpcontext(MsiVolume_UNCServer), helpstring("Returns a string representing the UNC server name.")] BSTR UNCServer();
			[id(8), propget,helpcontext(MsiVolume_SerialNum), helpstring("Returns an integer representing volume's serial number.")] long SerialNum();
			[id(9), propget,helpcontext(MsiVolume_DiskNotInDrive), helpstring("Returns TRUE if the volume supports removable media, but no disk is in the drive.")] boolean DiskNotInDrive();
			[id(10), propget,helpcontext(MsiVolume_VolumeLabel), helpstring("Returns a string representing the volume's label.")] BSTR VolumeLabel();
			[id(11), propget,helpcontext(MsiVolume_TotalSpace), helpstring("Returns the total amount of space on the volume, in units of 512 bytes.")] long TotalSpace();
	};
*/

DispatchEntry<CAutoVolume> AutoVolumeTable[] = {
	0, aafPropRO, CAutoVolume::Path,           TEXT("Path"),
	1, aafPropRO, CAutoVolume::VolumeID,       TEXT("VolumeID"),
	2, aafPropRO, CAutoVolume::DriveType,      TEXT("DriveType"),
	3, aafPropRO, CAutoVolume::SupportsLFN,    TEXT("SupportsLFN"),
	4, aafPropRO, CAutoVolume::FreeSpace,      TEXT("FreeSpace"),
	5, aafPropRO, CAutoVolume::ClusterSize,    TEXT("ClusterSize"),
	6, aafPropRO, CAutoVolume::FileSystem,     TEXT("FileSystem"),
	7, aafPropRO, CAutoVolume::UNCServer,      TEXT("UNCServer"),
	8, aafPropRO, CAutoVolume::SerialNum,      TEXT("SerialNum"),
	9, aafPropRO, CAutoVolume::DiskNotInDrive, TEXT("DiskNotInDrive"),
	10, aafPropRO, CAutoVolume::VolumeLabel,   TEXT("VolumeLabel"),
	11, aafPropRO, CAutoVolume::TotalSpace,    TEXT("TotalSpace"),
	12, aafPropRO, CAutoVolume::FileSystemFlags, TEXT("FileSystemFlags"),
};
const int AutoVolumeCount = sizeof(AutoVolumeTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiVolume automation implementation
//____________________________________________________________________________

CAutoVolume::CAutoVolume(IMsiVolume& riVolume)
 : CAutoBase(*AutoVolumeTable, AutoVolumeCount), m_riVolume(riVolume)
{
}

CAutoVolume::~CAutoVolume()
{
	m_riVolume.Release();
}

IUnknown& CAutoVolume::GetInterface()
{
	return m_riVolume;
}

void CAutoVolume::DriveType(CAutoArgs& args)
{
	args = (long) m_riVolume.DriveType();
}

void CAutoVolume::Path(CAutoArgs& args)
{
	args = m_riVolume.GetPath();
}

void CAutoVolume::SupportsLFN(CAutoArgs& args)
{
	args = (Bool)m_riVolume.SupportsLFN();
}

void CAutoVolume::FreeSpace(CAutoArgs& args)
{
	args = (long)m_riVolume.FreeSpace();
}

void CAutoVolume::TotalSpace(CAutoArgs& args)
{
	args = (long)m_riVolume.TotalSpace();
}

void CAutoVolume::ClusterSize(CAutoArgs& args)
{
	args = (int)m_riVolume.ClusterSize();
}

void CAutoVolume::VolumeID(CAutoArgs& args)
{
	args = m_riVolume.VolumeID();
}

void CAutoVolume::FileSystem(CAutoArgs& args)
{
	args = m_riVolume.FileSystem();
}

void CAutoVolume::FileSystemFlags(CAutoArgs& args)
{
	args = (int) m_riVolume.FileSystemFlags();
}

void CAutoVolume::VolumeLabel(CAutoArgs& args)
{
	args = m_riVolume.VolumeLabel();
}

void CAutoVolume::UNCServer(CAutoArgs& args)
{
	args = m_riVolume.UNCServer();
}

void CAutoVolume::DiskNotInDrive(CAutoArgs& args)
{
	args = m_riVolume.DiskNotInDrive();
}

void CAutoVolume::SerialNum(CAutoArgs& args)
{
	args = m_riVolume.SerialNum();
}

//____________________________________________________________________________
//
// MsiMessage automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C105D-0000-0000-C000-000000000046),  // IID_IMsiAutoMessage
		helpcontext(MsiMessage_Object),helpstring("Message object.")
	]
	dispinterface MsiMessage
	{
		properties:
		methods:
			[id(1), helpcontext(MsiMessage_Message), helpstring("???")] long Message(long imt, MsiRecord* record);
	};
*/

DispatchEntry<CAutoMessage> AutoMessageTable[] = {
	1, aafMethod, CAutoMessage::Message,       TEXT("Message,imt,record"),
};
const int AutoMessageCount = sizeof(AutoMessageTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiMessage automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoMessage(IMsiMessage& riMessage)
{
	return new CAutoMessage(riMessage);
}

CAutoMessage::CAutoMessage(IMsiMessage& riMessage)
 : CAutoBase(*AutoMessageTable, AutoMessageCount), m_riMessage(riMessage)
{
}

CAutoMessage::~CAutoMessage()
{
	m_riMessage.Release();
}

IUnknown& CAutoMessage::GetInterface()
{
	return m_riMessage;
}

void CAutoMessage::Message(CAutoArgs& args)
{
	args = (long)m_riMessage.Message((imtEnum)(long)args[1], (IMsiRecord&)args[2].Object(IID_IMsiRecord));
}


//____________________________________________________________________________
//
// CAutoEnum<IEnumMsiVolume>, CEnumVARIANT<IEnumMsiVolume> implementation
//____________________________________________________________________________

DispatchEntry< CAutoEnum<IEnumMsiVolume> > AutoEnumMsiVolumeTable[] = {
	DISPID_NEWENUM, aafMethod, CAutoEnum<IEnumMsiVolume>::_NewEnum, TEXT("_NewEnum"),
};
const int AutoEnumMsiVolumeCount = sizeof(AutoEnumMsiVolumeTable)/sizeof(DispatchEntryBase);

void CAutoArgs::operator =(IEnumMsiVolume& riEnum)
{
	operator =(new CAutoEnum<IEnumMsiVolume>(riEnum, *AutoEnumMsiVolumeTable, AutoEnumMsiVolumeCount));
}

HRESULT CEnumVARIANT<IEnumMsiVolume>::Next(unsigned long cItem, VARIANT* rgvarRet,
													unsigned long* pcItemRet)
{
	HRESULT hrStat;
	IMsiVolume* piVol;
	unsigned long cRet;
	if (pcItemRet)
		*pcItemRet = 0;
	if (!rgvarRet)
		return S_FALSE;
	CVariant* pivar = GetCVariantPtr(rgvarRet);
	while (cItem--)
	{
		hrStat = m_riEnum.Next(1, &piVol, &cRet);
		if (cRet == 0)
			return S_FALSE;
		//!! is it necessary to call VariantInit? Why?
		*pivar = new CAutoVolume(*piVol);  // refcnt transferred to variant
		pivar++;
		if (pcItemRet)
			(*pcItemRet)++;
	}
	return S_OK;
}

//____________________________________________________________________________
//
// CAutoEnum<IEnumMsiRecord>, CEnumVARIANT<IEnumMsiRecord> implementation
//____________________________________________________________________________

DispatchEntry< CAutoEnum<IEnumMsiRecord> > AutoEnumMsiRecordTable[] = {
	DISPID_NEWENUM, aafMethod, CAutoEnum<IEnumMsiRecord>::_NewEnum, TEXT("_NewEnum"),
};
const int AutoEnumMsiRecordCount = sizeof(AutoEnumMsiRecordTable)/sizeof(DispatchEntryBase);

void CAutoArgs::operator =(IEnumMsiRecord& riEnum)
{
	operator =(new CAutoEnum<IEnumMsiRecord>(riEnum, *AutoEnumMsiRecordTable, AutoEnumMsiRecordCount));
}

HRESULT CEnumVARIANT<IEnumMsiRecord>::Next(unsigned long cItem, VARIANT* rgvarRet,
													unsigned long* pcItemRet)
{
	HRESULT hrStat;
	IMsiRecord* piRec;
	unsigned long cRet;
	if (pcItemRet)
		*pcItemRet = 0;
	if (!rgvarRet)
		return S_FALSE;
	CVariant* pivar = GetCVariantPtr(rgvarRet);
	while (cItem--)
	{
		hrStat = m_riEnum.Next(1, &piRec, &cRet);
		if (cRet == 0)
			return S_FALSE;
		//!! is it necessary to call VariantInit? Why?
		*pivar = new CAutoRecord(*piRec);  // refcnt transferred to variant
		pivar++;
		if (pcItemRet)
			(*pcItemRet)++;
	}
	return S_OK;
}

//____________________________________________________________________________
//
// MsiPath automation definitions
//____________________________________________________________________________
/*O

	[
		uuid(000C1045-0000-0000-C000-000000000046),  // IID_IMsiAutoPath
		helpcontext(MsiPath_Object),helpstring("Path object.")
	]
	dispinterface MsiPath
	{
		properties:
		methods:
			[id(0), propget,helpcontext(MsiPath_Path), helpstring("Returns a string representing the full path.")] BSTR Path();
			[id(1), propget,helpcontext(MsiPath_Volume), helpstring("Returns the MsiVolume object representing the root of this path.")] MsiVolume *Volume();
			[id(2),helpcontext(MsiPath_AppendPiece), helpstring("Appends the given string to the existing path.")] void AppendPiece([in] BSTR subDir);
			[id(3),helpcontext(MsiPath_ChopPiece), helpstring("Removes the last path segment of the path.")] void ChopPiece();
			[id(4),helpcontext(MsiPath_FileExists), helpstring("Returns a boolean indicating whether a file of the specified name exists in the directory associated with the path object.")] boolean FileExists([in] BSTR file);
			[id(5),helpcontext(MsiPath_GetFullFilePath), helpstring("Returns a string representing the full path of the specified file.")] BSTR GetFullFilePath([in] BSTR file);
			[id(7),helpcontext(MsiPath_GetFileAttribute), helpstring("Returns the boolean state of a specified file attribute.")] boolean GetFileAttribute([in] BSTR file, [in] long attribute);
			[id(8),helpcontext(MsiPath_SetFileAttribute), helpstring("Sets the boolean state of a specified file attribute.")] void SetFileAttribute([in] BSTR file, [in] long attribute, 
													[in] long state);
			[id(9), propget,helpcontext(MsiPath_Exists), helpstring("Returns a boolean indicating whether the directory tree associated with the path object currently exists on the associated volume.")] boolean Exists();
			[id(10),helpcontext(MsiPath_FileSize), helpstring("Retrieves the size, in bytes, of the specified file.")] long FileSize([in] BSTR file);
			[id(11),helpcontext(MsiPath_FileDate), helpstring("Retrieves the date and time that the specified file was created (Mac) or last written to (Windows).")] date FileDate([in] BSTR file);
			[id(12),helpcontext(MsiPath_RemoveFile), helpstring("Deletes a file existing in the directory associated with the MsiPath object..")] void RemoveFile([in] BSTR file);
			[id(13),helpcontext(MsiPath_EnsureExists), helpstring("Creates the directory tree associated with the path object.")] int EnsureExists();
			[id(14),helpcontext(MsiPath_Remove), helpstring("Attempts to delete the empty directory associated with the path object.")] void Remove();
			[id(15), propget,helpcontext(MsiPath_Writable), helpstring("Returns a boolean indicating whether the directory represented by the path is writable.")] boolean Writable();
			[id(16),helpcontext(MsiPath_FileWritable), helpstring("Returns a boolean indicating whether the specified file exists, AND that file can be opened for write-access.")] boolean FileWritable([in] BSTR file);
			[id(17),helpcontext(MsiPath_FileInUse), helpstring("Returns a boolean indicating whether the speciified file is in use by another process.")] boolean FileInUse([in] BSTR file);
			[id(19),helpcontext(MsiPath_ClusteredFileSize), helpstring("Rounds a file size to a multiple of the volume cluster size.")] long ClusteredFileSize([in] long size);
			[id(20),helpcontext(MsiPath_GetFileVersionString), helpstring("Returns a string representation of a file's version.")] BSTR GetFileVersionString([in] BSTR file);
			[id(21),helpcontext(MsiPath_CheckFileVersion), helpstring("Checks a file against supplied version and language strings.")] long CheckFileVersion([in] BSTR file, [in] BSTR version, [in] BSTR language, [in] MsiRecord* hash);
			[id(22),helpcontext(MsiPath_GetLangIDStringFromFile), helpstring("Returns a string containing a file's language identifiers as decimal numbers.")] BSTR GetLangIDStringFromFile([in] BSTR file);
			[id(23),helpcontext(MsiPath_CheckLanguageIDs), helpstring("Checks a file against a set of language IDs.")] long CheckLanguageIDs([in] BSTR file, [in] BSTR ids);
			[id(24),helpcontext(MsiPath_Compare), helpstring("Compares the object's path against another path object's path, to determine whether a parent/child relationship exists.")] long Compare([in] MsiPath* path);
			[id(25),helpcontext(MsiPath_Child), helpstring("Extracts the 'child' portion of the object's path, relative to the given 'parent' path object.")] BSTR Child([in] MsiPath* path);
			[id(26),helpcontext(MsiPath_TempFileName), helpstring("Creates a temporary file in this object's directory.")] BSTR TempFileName([in] BSTR prefix, [in] BSTR extension, [in] boolean fileNameOnly);
			[id(27),helpcontext(MsiPath_FindFile), helpstring("Searches for a file by the supplied filter in the directory.")] boolean FindFile(MsiRecord* record, [in] long depth);
			[id(28),helpcontext(MsiPath_SubFolders), helpstring("Enumerate the subdirectories in the directory.")] IEnumVARIANT* SubFolders(Boolean excludeHidden);
			[id(29),propget,helpcontext(MsiPath_EndSubPath), helpstring("Returns the last sub-path in the current path.")] BSTR EndSubPath();
			[id(31),helpcontext(MsiPath_GetImportModulesEnum), helpstring("Enumerate the import modules for a given module.")] IEnumVARIANT* GetImportModulesEnum(BSTR filename);
			[id(32),helpcontext(MsiPath_SetVolume), helpstring("Changes the MsiVolume object associated with the MsiPath object.")] void SetVolume([in] MsiVolume* volume);
			[id(33),helpcontext(MsiPath_ComputeFileChecksum), helpstring("Computes and returns the checksum of the specified file.")] void ComputeFileChecksum([in] BSTR filename);
			[id(34),helpcontext(MsiPath_GetFileOriginalChecksum), helpstring("Returns the original checksum of the specified file.")] void GetFileOriginalChecksum([in] BSTR filename);
			[id(35), helpcontext(MsiPath_BindImage),helpstring("Binds the executable IAT to the import functions from DLLS")] void BindImage([in] BSTR file, [in] BSTR dllPath);
			[id(36), propget,helpcontext(MsiPath_SupportsLFN), helpstring("Returns a boolean indicating whether the path supports long file names.")] boolean SupportsLFN();
			[id(37),helpcontext(MsiPath_GetFullUNCFilePath), helpstring("Returns a string representing the full UNC path of the specified file.")] BSTR GetFullUNCFilePath([in] BSTR file);
			[id(38), propget,helpcontext(MsiPath_RelativePath), helpstring("Returns a string representing the path without the volume.")] BSTR RelativePath();
			[id(39), propget,helpcontext(MsiPath_GetSelfRelativeSD), helpstring("Returns a stream representing the security descriptor of the path.")] MsiStream* GetSelfRelativeSD();
	}
*/

DispatchEntry<CAutoPath> AutoPathTable[] = {
	0,  aafPropRO, CAutoPath::Path,            TEXT("Path"),
	1,  aafPropRO, CAutoPath::Volume,          TEXT("Volume"),
	2,  aafMethod, CAutoPath::AppendPiece,     TEXT("AppendPiece,subDir"),
	3,  aafMethod, CAutoPath::ChopPiece,       TEXT("ChopPiece"),
	4,  aafMethod, CAutoPath::FileExists,      TEXT("FileExists,file"),
	5,  aafMethod, CAutoPath::GetFullFilePath, TEXT("GetFullFilePath,file"),
	7,  aafMethod, CAutoPath::GetFileAttribute,TEXT("GetFileAttribute,file,attribute"),
	8,  aafMethod, CAutoPath::SetFileAttribute,TEXT("SetFileAttribute,file,attribute,state"),
	9,  aafPropRO, CAutoPath::Exists,          TEXT("Exists"),
	10, aafMethod, CAutoPath::FileSize,        TEXT("FileSize,file"),
	11, aafMethod, CAutoPath::FileDate,        TEXT("FileDate,file"),
	12, aafMethod, CAutoPath::RemoveFile,      TEXT("RemoveFile,file"),
	13, aafMethod, CAutoPath::EnsureExists,    TEXT("EnsureExists"),
	14, aafMethod, CAutoPath::Remove,          TEXT("Remove"),
	15, aafPropRO, CAutoPath::Writable,        TEXT("Writable"),
	16, aafMethod, CAutoPath::FileWritable,    TEXT("FileWritable,file"),
	17, aafMethod, CAutoPath::FileInUse,       TEXT("FileInUse,file"),
	19, aafMethod, CAutoPath::ClusteredFileSize,      TEXT("ClusteredFileSize,size"),
	20, aafMethod, CAutoPath::GetFileVersionString,   TEXT("GetFileVersionString,file"),
	21, aafMethod, CAutoPath::CheckFileVersion,       TEXT("CheckFileVersion,file,version,language,hash,icfvResult"),
	22, aafMethod, CAutoPath::GetLangIDStringFromFile,TEXT("GetLangIDStringFromFile,file"),
	23, aafMethod, CAutoPath::CheckLanguageIDs,  TEXT("CheckLanguageIDs,file,ids"),
	24, aafMethod, CAutoPath::Compare,           TEXT("Compare,path"),
	25, aafMethod, CAutoPath::Child,             TEXT("Child,parent"),
	26, aafMethod, CAutoPath::TempFileName,      TEXT("TempFileName,prefix,extension,fileNameOnly"),
	27, aafMethod, CAutoPath::FindFile,          TEXT("FindFile,Filter,Depth"),
	28, aafMethod, CAutoPath::SubFolders,        TEXT("SubFolders,ExcludeHidden"),
	29, aafPropRO, CAutoPath::EndSubPath,		 TEXT("EndSubPath"),
	31, aafMethod, CAutoPath::GetImportModulesEnum,     TEXT("GetImportModulesEnum, file"),
	32, aafMethod, CAutoPath::SetVolume, TEXT("SetVolume, volume"),
	33, aafMethod, CAutoPath::ComputeFileChecksum, TEXT("ComputeFileChecksum, filename"),
	34, aafMethod, CAutoPath::GetFileOriginalChecksum, TEXT("GetFileOriginalChecksum, filename"),
	35, aafMethod, CAutoPath::BindImage, TEXT("BindImage, file, dllPath"),
	36, aafPropRO, CAutoPath::SupportsLFN,    TEXT("SupportsLFN"),
	37, aafMethod, CAutoPath::GetFullUNCFilePath, TEXT("GetFullUNCFilePath,file"),
	38, aafMethod, CAutoPath::RelativePath, TEXT("RelativePath"),
	39, aafMethod, CAutoPath::GetSelfRelativeSD, TEXT("GetSelfRelativeSD"),
};
const int AutoPathCount = sizeof(AutoPathTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CAutoPath automation implementation
//____________________________________________________________________________

CAutoPath::CAutoPath(IMsiPath& riPath)
 : CAutoBase(*AutoPathTable, AutoPathCount), m_riPath(riPath)
{
}

CAutoPath::~CAutoPath()
{
	m_riPath.Release();
}

IUnknown& CAutoPath::GetInterface()
{
	return m_riPath;
}

void CAutoPath::Path(CAutoArgs& args)
{
	args = m_riPath.GetPath();
}

void CAutoPath::RelativePath(CAutoArgs& args)
{
	args = m_riPath.GetRelativePath();
}

void CAutoPath::Volume(CAutoArgs& args)
{
	args = new CAutoVolume(m_riPath.GetVolume());
}

void CAutoPath::AppendPiece(CAutoArgs& args)
{
	IMsiRecord* piRec = m_riPath.AppendPiece(*MsiString(args[1].GetMsiString()));
	if (piRec)
		throw piRec;
}

void CAutoPath::ChopPiece(CAutoArgs& /*args*/)
{
	IMsiRecord* piRec = m_riPath.ChopPiece(); 
	if (piRec)
		throw piRec;
}

void CAutoPath::FileExists(CAutoArgs& args)
{
	Bool fExists;
	IMsiRecord* piRec = m_riPath.FileExists(args[1], fExists);
	if (piRec)
		throw piRec;
	args = fExists;
}

void CAutoPath::GetFullFilePath(CAutoArgs& args)
{
	const IMsiString *piStr;
	IMsiRecord* piRec = m_riPath.GetFullFilePath(args[1], piStr);
	if (piRec)
		throw piRec;
	args = piStr;
}

void CAutoPath::GetFullUNCFilePath(CAutoArgs& args)
{
	const IMsiString *piStr;
	IMsiRecord* piRec = m_riPath.GetFullUNCFilePath(args[1], piStr);
	if (piRec)
		throw piRec;
	args = piStr;
}

void CAutoPath::GetFileAttribute(CAutoArgs& args)
{
	int iAttrib = args[2];
	ifaEnum ifaAttrib = (ifaEnum) iAttrib;

	Bool fAttrib;
	IMsiRecord* piRec = m_riPath.GetFileAttribute(args[1], ifaAttrib, fAttrib);
	if (piRec)
		throw piRec;
	args = fAttrib;
}

void CAutoPath::SetFileAttribute(CAutoArgs& args)
{
	int iAttrib = args[2];
	ifaEnum ifaAttrib = (ifaEnum) iAttrib;
	IMsiRecord* piRec = m_riPath.SetFileAttribute(args[1], ifaAttrib, args[3]);
	if (piRec)
		throw piRec;
}

void CAutoPath::Exists(CAutoArgs& args)
{
	Bool fExists;
	IMsiRecord* piRec = m_riPath.Exists(fExists);
	if (piRec)
		throw piRec;
	args = fExists;
}

void CAutoPath::FileSize(CAutoArgs& args)
{
	unsigned int uiValue;
	IMsiRecord* piRec = m_riPath.FileSize(args[1], uiValue);
	if (piRec)
		throw piRec;
	args = (int)uiValue; //FIXmsh
}

void CAutoPath::FileDate(CAutoArgs& args)
{
	MsiDate adValue;
	IMsiRecord* piRec = m_riPath.FileDate(args[1], adValue);
	if (piRec)
		throw piRec;
	args = adValue;
}

void CAutoPath::RemoveFile(CAutoArgs& args)
{
	IMsiRecord* piRec = m_riPath.RemoveFile(args[1]);
	if (piRec)
		throw piRec;
}

void CAutoPath::Remove(CAutoArgs& /*args*/)
{
	IMsiRecord* piRec = m_riPath.Remove(0);
	if (piRec)
		throw piRec;
}

void CAutoPath::Writable(CAutoArgs& args)
{
	Bool fWritable;
	IMsiRecord* piRec = m_riPath.Writable(fWritable);
	if (piRec)
		throw piRec;
	args = fWritable;
}

void CAutoPath::FileWritable(CAutoArgs& args)
{
	Bool fWritable;
	IMsiRecord* piRec = m_riPath.FileWritable(args[1], fWritable);
	if (piRec)
		throw piRec;
	args = fWritable;
}

void CAutoPath::FileInUse(CAutoArgs& args)
{
	Bool fInUse;
	IMsiRecord* piRec = m_riPath.FileInUse(args[1], fInUse);
	if (piRec)
		throw piRec;
	args = fInUse;
}

void CAutoPath::ClusteredFileSize(CAutoArgs& args)
{
	unsigned int iSize;
	IMsiRecord* piRec = m_riPath.ClusteredFileSize(args[1], iSize);
	if (piRec)
		throw piRec;
	args = (int)iSize;
}

void CAutoPath::GetFileVersionString(CAutoArgs& args)
{
	const IMsiString* piStr;
	IMsiRecord* piRec = m_riPath.GetFileVersionString(args[1], piStr);
	if (piRec)
		throw piRec;
	args = piStr;
}

void CAutoPath::CheckFileVersion(CAutoArgs& args)
{
	icfvEnum icfvResult;

	MD5Hash hHash;
	MD5Hash* pHash = 0;
	if(args.Present(4))
	{
		IMsiRecord& riHashRecord = (IMsiRecord&) args[4].Object(IID_IMsiRecord);
		hHash.dwFileSize = riHashRecord.GetInteger(1);
		hHash.dwPart1    = riHashRecord.GetInteger(2);
		hHash.dwPart2    = riHashRecord.GetInteger(3);
		hHash.dwPart3    = riHashRecord.GetInteger(4);
		hHash.dwPart4    = riHashRecord.GetInteger(5);
	}
	
	IMsiRecord* piRec = m_riPath.CheckFileVersion(args[1], args[2], args[3], pHash, icfvResult, NULL);
	if (piRec)
		throw piRec;
	args = (long) icfvResult;
}

void CAutoPath::GetLangIDStringFromFile(CAutoArgs& args)
{
	const IMsiString* piStr;
	IMsiRecord* piRec = m_riPath.GetLangIDStringFromFile(args[1], piStr);
	if (piRec)
		throw piRec;
	args = piStr;
}

void CAutoPath::CheckLanguageIDs(CAutoArgs& args)
{
	iclEnum riclResult;
	IMsiRecord* piRec = m_riPath.CheckLanguageIDs(args[1], args[2], riclResult);
	if (piRec)
		throw piRec;
	args = (long) riclResult;
}

void CAutoPath::Compare(CAutoArgs& args)
{
	ipcEnum ipc;
	IMsiRecord* piRec = m_riPath.Compare((IMsiPath&)args[1].Object(IID_IMsiPath), ipc);
	if (piRec)
		throw piRec;

	args = (int)ipc;
	
}

void CAutoPath::Child(CAutoArgs& args)
{
	const IMsiString* piStr;
	IMsiRecord* piRec = m_riPath.Child((IMsiPath&)args[1].Object(IID_IMsiPath), piStr);
	if (piRec)
	   throw piRec;
	
	args = piStr;
}

void CAutoPath::TempFileName(CAutoArgs& args)
{
	const ICHAR* szPrefix = ((args.Present(1)) ? args[1] : (const ICHAR*)0);
	const ICHAR* szExtension = ((args.Present(2)) ? args[2] : (const ICHAR*)0);
	Bool fFileNameOnly = ((args.Present(3)) ? (Bool)(int)args[3] : fFalse);
	const IMsiString* piStr;
	IMsiRecord* piRec = m_riPath.TempFileName(szPrefix, szExtension, fFileNameOnly, piStr, 0);
	if (piRec)
	   throw piRec;
	
	args = piStr;
}

void CAutoPath::EnsureExists(CAutoArgs& args)
{
	int cCreatedFolders = 0;
	IMsiRecord* piRec = m_riPath.EnsureExists(&cCreatedFolders);
	if (piRec)
	   throw piRec;
	args = cCreatedFolders;
}

void CAutoPath::FindFile(CAutoArgs& args)
{
	Bool fFound;
	unsigned int iDepth = ((args.Present(2)) ? args[2] : 0);
	IMsiRecord* piRec = m_riPath.FindFile(*((IMsiRecord* )(args[1].ObjectPtr(IID_IMsiRecord))), iDepth, fFound);
	if (piRec)
	   throw piRec;
	args = fFound;
}

void CAutoPath::SubFolders(CAutoArgs& args)
{
	IEnumMsiString* piEnumStr;
	Bool fExcludeHidden = fFalse;
	if(args.Present(1))
		fExcludeHidden = args[1];

	IMsiRecord* piRec = m_riPath.GetSubFolderEnumerator(piEnumStr, fExcludeHidden);
	if (piRec)
	   throw piRec;
	args = *piEnumStr;
}

void CAutoPath::EndSubPath(CAutoArgs& args)
{
	args = m_riPath.GetEndSubPath();
}

void CAutoPath::GetImportModulesEnum(CAutoArgs& args)
{
	MsiString istrName(args[1].GetMsiString());
	IEnumMsiString* piEnumStr;
	IMsiRecord* piRec = m_riPath.GetImportModulesEnum(*istrName, piEnumStr);
	if (piRec)
	   throw piRec;
	args = *piEnumStr;
}

void CAutoPath::SetVolume(CAutoArgs& args)
{
	IMsiRecord* piRec = m_riPath.SetVolume((IMsiVolume&)args[1].Object(IID_IMsiVolume));
	if (piRec)
		throw piRec;
}

void CAutoPath::ComputeFileChecksum(CAutoArgs& args)
{
	DWORD dwHeaderSum,dwComputedSum;
	IMsiRecord* piRec = m_riPath.GetFileChecksum(args[1],&dwHeaderSum,&dwComputedSum);
	if (piRec)
		throw piRec;
	args = (int) dwComputedSum;
}

void CAutoPath::GetFileOriginalChecksum(CAutoArgs& args)
{
	DWORD dwHeaderSum,dwComputedSum;
	IMsiRecord* piRec = m_riPath.GetFileChecksum(args[1],&dwHeaderSum,&dwComputedSum);
	if (piRec)
		throw piRec;
	args = (int) dwHeaderSum;
}

void CAutoPath::BindImage(CAutoArgs& args)
{
	MsiString strDllPath;
	if(args.Present(2))
		strDllPath = (const ICHAR*)args[2];
	IMsiRecord* piError = m_riPath.BindImage(*MsiString(args[1].GetMsiString()), *strDllPath);
	if (piError)
		throw piError;
}

void CAutoPath::SupportsLFN(CAutoArgs& args)
{
	args = (Bool)m_riPath.SupportsLFN();
}

void CAutoPath::GetSelfRelativeSD(CAutoArgs& args)
{
	IMsiStream* piStream;
	IMsiRecord* piError = m_riPath.GetSelfRelativeSD(*&piStream);
	if(piError)
		throw piError;
	args = new CAutoStream(*piStream);
}
//____________________________________________________________________________
//
// MsiFileCopy automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C1046-0000-0000-C000-000000000046),  // IID_IMsiAutoFileCopy
		helpcontext(MsiFileCopy_Object),helpstring("File copier object.")
	]
	dispinterface MsiFileCopy
	{
		properties:
		methods:
			[id(1),helpcontext(MsiFileCopy_CopyTo), helpstring("Copies a file from a source path to the supplied target path.")]
				void CopyTo([in] MsiPath* srcPath, [in] MsiPath* destPath, [in] MsiRecord* paramRec);
			[id(2),helpcontext(MsiFileCopy_ChangeMedia), helpstring("Requests a media switch (e.g. from one disk and/or compression cabinet to another).")]
				void ChangeMedia([in] MsiPath* srcPath,[in] BSTR keyFileName,[in] boolean signatureRequired,[in] MsiStream* signatureCert,[in] MsiStream* signatureHash);
	}
*/

DispatchEntry<CAutoFileCopy> AutoCopyTable[] = {
	1, aafMethod, CAutoFileCopy::CopyTo, TEXT("CopyTo,srcPath,destPath,paramRec"),
	2, aafMethod, CAutoFileCopy::ChangeMedia, TEXT("ChangeMedia,srcPath,fileName,signatureRequired,signatureCert,signatureHash"),
};
const int AutoCopyCount = sizeof(AutoCopyTable)/sizeof(DispatchEntryBase);
			
//____________________________________________________________________________
//
// CAutoFileCopy automation implementation
//____________________________________________________________________________

CAutoFileCopy::CAutoFileCopy(IMsiFileCopy& riFileCopy)
 : CAutoBase(*AutoCopyTable, AutoCopyCount), m_riFileCopy(riFileCopy)
{
}

CAutoFileCopy::~CAutoFileCopy()
{
	m_riFileCopy.Release();
}

IUnknown& CAutoFileCopy::GetInterface()
{
	return m_riFileCopy;
}

void CAutoFileCopy::CopyTo(CAutoArgs& args)
{
	IMsiRecord* piErr = m_riFileCopy.CopyTo((IMsiPath&)args[1].Object(IID_IMsiPath),
											(IMsiPath&)args[2].Object(IID_IMsiPath),
											(IMsiRecord&)args[3].Object(IID_IMsiRecord));
	if (piErr)
		throw piErr;
}


void CAutoFileCopy::ChangeMedia(CAutoArgs& args)
{
	Bool fSignatureRequired = fFalse;
	IMsiStream* piSignatureCert = 0;
	IMsiStream* piSignatureHash = 0;
	if (args.Present(3))
	{
		fSignatureRequired = (Bool)args[3];
		if (args.Present(4))
		{
			CVariant& var = args[4];
			piSignatureCert = var.GetType() == VT_EMPTY ? 0 : (IMsiStream*)var.ObjectPtr(IID_IMsiStream);
		}
		if (args.Present(5))
		{
			CVariant& var = args[5];
			piSignatureHash = var.GetType() == VT_EMPTY ? 0 : (IMsiStream*)var.ObjectPtr(IID_IMsiStream);
		}
	}
	IMsiRecord* piErr = m_riFileCopy.ChangeMedia((IMsiPath&)args[1].Object(IID_IMsiPath),args[2],fSignatureRequired, piSignatureCert, piSignatureHash);
	if (piErr)
		throw piErr;
}

//____________________________________________________________________________
//
// MsiFilePatch automation definitions
//____________________________________________________________________________
/*O
	[
		uuid(000C105F-0000-0000-C000-000000000046),  // IID_IMsiAutoFilePatch
		helpcontext(MsiFilePatch_Object),helpstring("File patcher object.")
	]
	dispinterface MsiFilePatch
	{
		properties:
		methods:
			[id(1),helpcontext(MsiFilePatch_ApplyPatch), helpstring("Patches a file.")] void ApplyPatch([in] MsiPath* targetPath, [in] BSTR targetName, [in] MsiPath* patchPath, [in] BSTR patchName, [in] MsiPath* outputPath, [in] BSTR outputName, [in] long perTick);
			[id(2),helpcontext(MsiFilePatch_ContinuePatch), helpstring("Continues patch application started with ApplyPatch.")] void ContinuePatch();
			[id(3),helpcontext(MsiFilePatch_CanPatchFile), helpstring("Checks if a file can be patched.")] long CanPatchFile([in] MsiPath* targetPath, [in] BSTR targetName, [in] MsiPath* patchPath, [in] BSTR patchName);
			[id(4),helpcontext(MsiFilePatch_CancelPatch), helpstring("Cancels patch application started with ApplyPatch.")] void CancelPatch();
};
*/

DispatchEntry<CAutoFilePatch> AutoPatchTable[] = {
	1, aafMethod, CAutoFilePatch::ApplyPatch, TEXT("ApplyPatch,targetPath,targetName,patchPath,patchName,outputPath,outputName,perTick"),
	2, aafMethod, CAutoFilePatch::ContinuePatch, TEXT("ContinuePatch"),
	3, aafMethod, CAutoFilePatch::CanPatchFile, TEXT("CanPatchFile,targetPath,targetName,patchPath,patchName"),
	4, aafMethod, CAutoFilePatch::CancelPatch, TEXT("CancelPatch"),
};
const int AutoPatchCount = sizeof(AutoPatchTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CAutoFilePatch automation implementation
//____________________________________________________________________________

CAutoFilePatch::CAutoFilePatch(IMsiFilePatch& riFilePatch)
 : CAutoBase(*AutoPatchTable, AutoPatchCount), m_riFilePatch(riFilePatch)
{
}

CAutoFilePatch::~CAutoFilePatch()
{
	m_riFilePatch.Release();
}

IUnknown& CAutoFilePatch::GetInterface()
{
	return m_riFilePatch;
}

void CAutoFilePatch::ApplyPatch(CAutoArgs& args)
{
	IMsiRecord* piRecErr = 0;
	unsigned int cbPerTick = args.Present(7) ? (int)args[7] : 0;
	if((piRecErr = m_riFilePatch.ApplyPatch((IMsiPath&)args[1].Object(IID_IMsiPath), args[2],
														 (IMsiPath&)args[3].Object(IID_IMsiPath), args[4],
														 (IMsiPath&)args[5].Object(IID_IMsiPath), args[6],
														 cbPerTick)) != 0)
		throw(piRecErr);
}

void CAutoFilePatch::ContinuePatch(CAutoArgs& /*args*/)
{
	IMsiRecord* piRecErr = m_riFilePatch.ContinuePatch();
	if(piRecErr)
		throw(piRecErr);
}

void CAutoFilePatch::CancelPatch(CAutoArgs& /*args*/)
{
	IMsiRecord* piRecErr = m_riFilePatch.CancelPatch();
	if(piRecErr)
		throw(piRecErr);
}

void CAutoFilePatch::CanPatchFile(CAutoArgs& args)
{
	IMsiRecord* piRecErr = 0;
	icpEnum icp;
	if((piRecErr = m_riFilePatch.CanPatchFile((IMsiPath&)args[1].Object(IID_IMsiPath),args[2],
															(IMsiPath&)args[3].Object(IID_IMsiPath),args[4],
															icp)) != 0)
		throw(piRecErr);

	args = (int)icp;
}


//____________________________________________________________________________
//
// MsiRegKey automation definitions
//____________________________________________________________________________
/*O

	[
			 
		uuid(000C1047-0000-0000-C000-000000000046),  // IID_IMsiAutoRegKey
		helpcontext(MsiRegKey_Object),helpstring("Registry key object.")
	]
	dispinterface MsiRegKey
	{
		properties:
		methods:
			[id(1), helpcontext(MsiRegKey_RemoveValue), helpstring("Removes a named value of a registry key")] 
				void RemoveValue([in] BSTR valueName, [in] BSTR value);
			[id(3), helpcontext(MsiRegKey_RemoveSubTree), helpstring("Removes a subkey of a registry key and all its values and subkeys")] 
				void RemoveSubTree([in] BSTR keyName);
			[id(4), propget, helpcontext(MsiRegKey_Value), helpstring("The named value of a registry key")] 
				BSTR Value([in] BSTR valueName);
			[id(4), propput] 
				void Value([in] BSTR valueName, [in] BSTR value);
			[id(5), helpcontext(MsiRegKey_Values), helpstring("Returns an enumerator object containing all the value names of a registry key")] 
				IEnumVARIANT* Values();
			[id(6), helpcontext(MsiRegKey_SubKeys), helpstring("Returns an enumerator object containing all the subkeys of a registry key")] 
				IEnumVARIANT* SubKeys();
			[id(7), propget, helpcontext(MsiRegKey_Exists), helpstring("Returns registry key exist status, or forces create or delete")] 
				boolean Exists();
			[id(7), propput] 
				void Exists(boolean fFlag);
			[id(8), helpcontext(MsiRegKey_CreateChild), helpstring("Returns a new MsiRegKey object that is a subkey under the parent")] 
				MsiRegKey* CreateChild([in] BSTR subKey);
			[id(9), propget, helpcontext(MsiRegKey_Key), helpstring("The key name")] 
				BSTR Key();
			[id(10), propget, helpcontext(MsiRegKey_ValueExists), helpstring("Returns true if the value exists, false otherwise")] 
				boolean ValueExists(BSTR name);
			[id(11), propget, helpcontext(MsiRegKey_GetSelfRelativeSD), helpstring("Returns a stream object containing a security descriptor in self relative form.")]
				MsiStream* GetSelfRelativeSD();
	};
*/

DispatchEntry<CAutoRegKey> AutoRegKeyTable[] = {
	1, aafMethod, CAutoRegKey::RemoveValue,     TEXT("RemoveValue,valueName,value"),
	3, aafMethod, CAutoRegKey::RemoveSubTree,   TEXT("RemoveSubTree,subKey"),
	4, aafPropRW, CAutoRegKey::Value,           TEXT("Value,valueName"),
	5, aafMethod, CAutoRegKey::Values,          TEXT("Values"),
	6, aafMethod, CAutoRegKey::SubKeys,         TEXT("SubKeys"),
	7, aafPropRW, CAutoRegKey::Exists,          TEXT("Exists"),
	8, aafMethod, CAutoRegKey::CreateChild,     TEXT("CreateChild,SubKey"),
	9, aafPropRO, CAutoRegKey::Key,             TEXT("Key"),
	10, aafPropRO, CAutoRegKey::ValueExists,    TEXT("ValueExists,value"),
	11, aafPropRO, CAutoRegKey::GetSelfRelativeSD, TEXT("GetSelfRelativeSD"),
};        
const int AutoRegKeyCount = sizeof(AutoRegKeyTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CMsiRegKey automation implementation
//____________________________________________________________________________

CAutoRegKey::CAutoRegKey(IMsiRegKey& riRegKey)
 : CAutoBase(*AutoRegKeyTable, AutoRegKeyCount), m_riRegKey(riRegKey)
{
}

CAutoRegKey::~CAutoRegKey()
{
	m_riRegKey.Release();
}

IUnknown& CAutoRegKey::GetInterface()
{
	return m_riRegKey;
}

void CAutoRegKey::RemoveValue(CAutoArgs& args)
{
	IMsiRecord* piRec;
	const ICHAR* pszValueName = 0;
	const IMsiString* pistrValue = 0;
	if(args.Present(1))
		pszValueName = args[1];
	if(args.Present(2))
		pistrValue = &args[2].GetMsiString();
	piRec = m_riRegKey.RemoveValue(pszValueName, pistrValue);
	if(pistrValue)
		pistrValue->Release();
	if (piRec)
		throw piRec;
}

void CAutoRegKey::RemoveSubTree(CAutoArgs& args)
{
	IMsiRecord* piRec = m_riRegKey.RemoveSubTree(args[1]);              
	if (piRec)
		throw piRec;
}

void CAutoRegKey::Value(CAutoArgs& args)
{
	IMsiRecord* piRec;
	if (args.PropertySet())
	{
		MsiString strValue = args[0].GetMsiString();
		if(args.Present(1))
			piRec = m_riRegKey.SetValue(args[1], *strValue);
		else
			piRec = m_riRegKey.SetValue(0, *strValue);
		if (piRec)
			throw piRec;
   }
	else
	{
		const IMsiString* piStr;
		if(args.Present(1))
			piRec = m_riRegKey.GetValue(args[1], piStr);
		else
			piRec = m_riRegKey.GetValue(0, piStr);
		if (piRec)
			throw piRec;
		args = piStr;
	}
}

void CAutoRegKey::Values(CAutoArgs& args)
{
	IEnumMsiString* piEnumStr;
	m_riRegKey.GetValueEnumerator(piEnumStr);
	args = *piEnumStr;

}

void CAutoRegKey::SubKeys(CAutoArgs& args)
{
	IEnumMsiString* piEnumStr;
	m_riRegKey.GetSubKeyEnumerator(piEnumStr);
	args = *piEnumStr;
}

void CAutoRegKey::Exists(CAutoArgs& args)
{
	IMsiRecord* piRec;
	if (args.PropertySet())
	{
		Bool fCreate = args[0];
		if(fCreate == fTrue)
			piRec = m_riRegKey.Create();
		else
			piRec = m_riRegKey.Remove();
		if (piRec)
			throw piRec;
	}
	else
	{
		Bool fExists;
		IMsiRecord* piRec = m_riRegKey.Exists(fExists);
		if (piRec)
			throw piRec;
		args = fExists;
	}
}

void CAutoRegKey::ValueExists(CAutoArgs& args)
{
	Bool fExists;
	IMsiRecord* piRec = m_riRegKey.ValueExists(args[1], fExists);
	if (piRec)
		throw piRec;
	args = fExists;
}

void CAutoRegKey::Key(CAutoArgs& args)
{
	args = m_riRegKey.GetKey();
}

void CAutoRegKey::CreateChild(CAutoArgs& args)
{
	args = new CAutoRegKey(m_riRegKey.CreateChild(args[1]));
}

void CAutoRegKey::GetSelfRelativeSD(CAutoArgs& args)
{
	IMsiStream* piStream;
	IMsiRecord* piError = m_riRegKey.GetSelfRelativeSD(*&piStream);
	if(piError)
		throw piError;
	args = new CAutoStream(*piStream);
}

//____________________________________________________________________________
//
// MsiMalloc automation definitions
//
/*O
	[
			 
		uuid(000C1057-0000-0000-C000-000000000046),  // IID_IMsiAutoMalloc
		helpcontext(MsiMalloc_Object),helpstring("Memory Manager object.")
	]
	dispinterface MsiMalloc
	{
		properties:
		methods:
			[id(1), helpcontext(MsiMalloc_Alloc), helpstring("Allocates a block of memory")] 
			long Alloc([in] long byteCount);
			[id(2), helpcontext(MsiMalloc_Free), helpstring("Frees a block of memory allocated by MsiMalloc.Alloc")] 
			void Free([in] long memoryBlock);
			[id(3), helpcontext(MsiMalloc_SetDebugFlags), helpstring("Sets the MsiMalloc debug flags.")] 
			void SetDebugFlags([in] short grpfDebugFlags);
			[id(4), helpcontext(MsiMalloc_GetDebugFlags), helpstring("Gets the MsiMalloc debug flags.")] 
			short GetDebugFlags( );
			[id(5), helpcontext(MsiMalloc_CheckAllBlocks), helpstring("Checks all memory blocks for corruption.")]
			boolean CheckAllBlocks( );
			[id(6), helpcontext(MsiMalloc_FCheckBlock), helpstring("Checks a single block for corruption.")]
			boolean FCheckBlock( );
			[id(7), helpcontext(MsiMalloc_GetSizeOfBlock), helpstring("Returns the size of the allocated block.")]
			long GetSizeOfBlock( );
			
	};
*/

DispatchEntry<CAutoMalloc> AutoMallocTable[] = {
	1, aafMethod, CAutoMalloc::Alloc,   TEXT("Alloc,byteCount"),
	2, aafMethod, CAutoMalloc::Free,    TEXT("Free,memoryBlock"),
	3, aafMethod, CAutoMalloc::SetDebugFlags, TEXT("SetDebugFlags,grpfDebugFlags"),
	4, aafMethod, CAutoMalloc::GetDebugFlags, TEXT("GetDebugFlags"),
	5, aafMethod, CAutoMalloc::CheckAllBlocks, TEXT("CheckAllBlocks"),
	6, aafMethod, CAutoMalloc::FCheckBlock, TEXT("FCheckBlock,memoryBlock"),
	7, aafMethod, CAutoMalloc::GetSizeOfBlock, TEXT("GetSizeOfBlock,memoryBlock"),
};        
const int AutoMallocCount = sizeof(AutoMallocTable)/sizeof(DispatchEntryBase);

#ifdef CONFIGDB
//____________________________________________________________________________
//
// MsiConfigurationDatabase automation definitions
//____________________________________________________________________________
/*O
#define MsiConfigurationDatabase_Object                    3300
#define MsiConfigurationDatabase_InsertFile                3301
#define MsiConfigurationDatabase_RemoveFile                3302
#define MsiConfigurationDatabase_LookupFile                3303
#define MsiConfigurationDatabase_EnumClient                3304
#define MsiConfigurationDatabase_Commit                    3305
	[
		uuid(000C104A-0000-0000-C000-000000000046),  // IID_IMsiAutoConfigurationDatabase
		helpcontext(MsiConfigurationDatabase_Object),helpstring("Configuration database object.")
	]
	dispinterface MsiConfigurationDatabase
	{
		properties:
		methods:
			[id(1),helpcontext(MsiConfigurationDatabase_InsertFile), helpstring("Registers a file to a client.")]
			boolean InsertFile([in] BSTR folder, [in] BSTR path, [in] BSTR compId);
			[id(2),helpcontext(MsiConfigurationDatabase_RemoveFile), helpstring("Unregisters a file to a client.")]
			boolean RemoveFile([in] BSTR folder, [in] BSTR path, [in] BSTR compId);
			[id(3),helpcontext(MsiConfigurationDatabase_LookupFile), helpstring("Checks if file is registered.")]
			boolean LookupFile([in] BSTR folder, [in] BSTR path, [in] BSTR compId);
			[id(4),helpcontext(MsiConfigurationDatabase_EnumClient), helpstring("Returns a client for a file.")]
			BSTR EnumClient([in] BSTR folder, [in] BSTR path, [in] long index);
			[id(5),helpcontext(MsiConfigurationDatabase_Commit),     helpstring("Commits database updates.")]
			void Commit();
	};
*/

DispatchEntry<CAutoConfigurationDatabase> AutoConfigDatabaseTable[] = {
	1, aafMethod, CAutoConfigurationDatabase::InsertFile, TEXT("InsertFile,folder,file,compId"),
	2, aafMethod, CAutoConfigurationDatabase::RemoveFile, TEXT("RemoveFile,folder,file,compId"),
	3, aafMethod, CAutoConfigurationDatabase::LookupFile, TEXT("LookupFile,folder,file,compId"),
	4, aafMethod, CAutoConfigurationDatabase::EnumClient, TEXT("EnumClient,folder,file,index"),
	5, aafMethod, CAutoConfigurationDatabase::Commit,     TEXT("Commit"),
};
const int AutoConfigDatabaseCount = sizeof(AutoConfigDatabaseTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CAutoConfigurationDatabase automation implementation
//____________________________________________________________________________

IDispatch* CreateAutoConfigurationDatabase(IMsiConfigurationDatabase& riConfigDatabase)
{
	return new CAutoConfigurationDatabase(riConfigDatabase);
}

CAutoConfigurationDatabase::CAutoConfigurationDatabase(IMsiConfigurationDatabase& riConfigurationDatabase)
 : CAutoBase(*AutoConfigDatabaseTable, AutoConfigDatabaseCount), m_riConfigurationDatabase(riConfigurationDatabase)
{
}

CAutoConfigurationDatabase::~CAutoConfigurationDatabase()
{
	m_riConfigurationDatabase.Release();
}

IUnknown& CAutoConfigurationDatabase::GetInterface()
{
	return m_riConfigurationDatabase;
}

void CAutoConfigurationDatabase::InsertFile(CAutoArgs& args)
{
	icdrEnum icdr = m_riConfigurationDatabase.InsertFile(args[1], args[2], args[3]);
	if (icdr == icdrBadPath)
		throw MsiConfigurationDatabase_InsertFile;
	if (icdr == icdrCliented)
		args = fFalse;
	else
		args = fTrue;
}

void CAutoConfigurationDatabase::RemoveFile(CAutoArgs& args)
{
	icdrEnum icdr = m_riConfigurationDatabase.RemoveFile(args[1], args[2], args[3]);
	if (icdr == icdrOk)
		args = fTrue;
	else if (icdr == icdrMore)
		args = fFalse;
	else
		throw MsiConfigurationDatabase_RemoveFile;
}

void CAutoConfigurationDatabase::LookupFile(CAutoArgs& args)
{
	icdrEnum icdr = m_riConfigurationDatabase.LookupFile(args[1], args[2], args[3]);
	if (icdr == icdrOk)
		args = fTrue;
	else if (icdr == icdrNoFile)
		args = fFalse;
	else
		throw MsiConfigurationDatabase_LookupFile;
}

void CAutoConfigurationDatabase::EnumClient(CAutoArgs& args)
{
	ICHAR rgchBuf[100];
	icdrEnum icdr = m_riConfigurationDatabase.EnumClient(args[1], args[2], args[3], rgchBuf);
	if (icdr == icdrOk)
		args = fTrue;
	else if (icdr == icdrNoFile)
		args = fFalse;
	else
		throw MsiConfigurationDatabase_EnumClient;
}

void CAutoConfigurationDatabase::Commit(CAutoArgs& /*args*/)
{
	IMsiRecord* piError = m_riConfigurationDatabase.Commit();
	if(piError)
		throw piError;
}

#endif //CONFIGDB

//____________________________________________________________________________
//
// CMsiMalloc automation implementation
//____________________________________________________________________________

CAutoMalloc::CAutoMalloc(IMsiMalloc& riMalloc)
 : CAutoBase(*AutoMallocTable, AutoMallocCount), m_riMalloc(riMalloc)
{
}

CAutoMalloc::~CAutoMalloc()
{
	m_riMalloc.Release();
}

IUnknown& CAutoMalloc::GetInterface()
{
	return m_riMalloc;
}

void CAutoMalloc::Alloc(CAutoArgs& args)
{
	// We're going to treat the long returned as an opaque data long
	long lcb = args[1];

	args = m_riMalloc.Alloc(lcb);
}

void CAutoMalloc::Free(CAutoArgs& args)
{
	// We're going to treat the long passed in as an opaque data long
	long pv = args[1];

	m_riMalloc.Free((void *)(LONG_PTR)pv);			//!!merced: 4312 long to ptr
}

void CAutoMalloc::SetDebugFlags(CAutoArgs& args)
{
	IMsiDebugMalloc	*piDbgMalloc;
	int grpfDebugFlags = args[1];
	
	if (m_riMalloc.QueryInterface(IID_IMsiDebugMalloc, (void**)&piDbgMalloc) == NOERROR)
	{		
		piDbgMalloc->SetDebugFlags(grpfDebugFlags);
		piDbgMalloc->Release();
	}

}

void CAutoMalloc::GetDebugFlags(CAutoArgs& args)
{
	IMsiDebugMalloc	*piDbgMalloc;
	
	if (m_riMalloc.QueryInterface(IID_IMsiDebugMalloc, (void**)&piDbgMalloc) == NOERROR)
	{		
		args = piDbgMalloc->GetDebugFlags();
		piDbgMalloc->Release();
	}
	else
		args = 0;

}

void CAutoMalloc::CheckAllBlocks(CAutoArgs& args)
{
	IMsiDebugMalloc	*piDbgMalloc;
	
	if (m_riMalloc.QueryInterface(IID_IMsiDebugMalloc, (void**)&piDbgMalloc) == NOERROR)
	{		
		args = (Bool)piDbgMalloc->FCheckAllBlocks();
		piDbgMalloc->Release();
	}
	else
		args = fTrue;

}

void CAutoMalloc::FCheckBlock(CAutoArgs& args)
{
	// We're going to treat the long returned as an opaque data long for now
	long pv = args[1];
	IMsiDebugMalloc	*piDbgMalloc;

	if (m_riMalloc.QueryInterface(IID_IMsiDebugMalloc, (void**)&piDbgMalloc) == NOERROR)
	{		
		args = (Bool)piDbgMalloc->FCheckBlock((void *)(LONG_PTR)pv);			//!!merced: 4312 long to ptr
		piDbgMalloc->Release();
	}
	else
		args = fTrue;
}

void CAutoMalloc::GetSizeOfBlock(CAutoArgs& args)
{
	// We're going to treat the long returned as an opaque data long for now
	long pv = args[1];
	IMsiDebugMalloc	*piDbgMalloc;

	if (m_riMalloc.QueryInterface(IID_IMsiDebugMalloc, (void**)&piDbgMalloc) == NOERROR)
	{		
		args = (int)piDbgMalloc->GetSizeOfBlock((void *)(LONG_PTR)pv);			//!!merced: 4312 long to ptr
		piDbgMalloc->Release();
	}
	else
		args = 0;
}


//____________________________________________________________________________
//
// MsiString automation definitions
//
/*O
	[
		uuid(000C1042-0000-0000-C000-000000000046),  // IID_IMsiAutoString
		helpcontext(MsiString_Object),helpstring("String object.")
	]
	dispinterface MsiString
	{
		properties:
			[id(0), helpcontext(MsiString_Value), helpstring("String value of object.")]
				BSTR Value;
		methods:
			[id(1), propget, helpcontext(MsiString_IntegerValue), helpstring("Integer value of string object.")]
				long IntegerValue();
			[id(2), propget, helpcontext(MsiString_TextSize), helpstring("Character array size.")]
				long TextSize();
			[id(3), propget, helpcontext(MsiString_CharacterCount), helpstring("Number of displayed characters.")]
				long CharacterCount();
			[id(4), propget, helpcontext(MsiString_IsDBCS), helpstring("String contains double byte characters.")]
				long IsDBCS();
			[id(5), helpcontext(MsiString_Compare), helpstring("Compares string object with another string.")]
				long Compare([in] long mode, [in] BSTR text);
			[id(6), helpcontext(MsiString_Append), helpstring("Appends another string to string object.")]
				void Append([in] BSTR text);
			[id(7), helpcontext(MsiString_Add), helpstring("Adds another string and returns a new string object.")]
				MsiString* Add([in] BSTR text);
			[id(8), helpcontext(MsiString_Extract), helpstring("Extracts a portion of a string to a new string object.")]
				MsiString* Extract([in] long mode, [in] long limit);
			[id(9), helpcontext(MsiString_Remove), helpstring("Removes a portion of a string from the string object.")]
				boolean Remove([in] long mode, [in] long limit);
			[id(10), helpcontext(MsiString_UpperCase), helpstring("Converts characters to upper case.")]
				void UpperCase();
			[id(11), helpcontext(MsiString_LowerCase), helpstring("Converts characters to lower case.")]
				void LowerCase();
	};
*/
  
DispatchEntry<CAutoString> AutoStringTable[] = {
	0, aafPropRW, CAutoString::Value,         TEXT("Value"),
	1, aafPropRO, CAutoString::IntegerValue,  TEXT("IntegerValue"),
	2, aafPropRO, CAutoString::TextSize,      TEXT("TextSize"),
	3, aafPropRO, CAutoString::CharacterCount,TEXT("CharacterCount"),
	4, aafPropRO, CAutoString::IsDBCS,        TEXT("IsDBCS"),
	5, aafMethod, CAutoString::Compare,       TEXT("Compare,mode,text"),
	6, aafMethod, CAutoString::Append,        TEXT("Append,text"),
	7, aafMethod, CAutoString::Add,           TEXT("Add,text"),
	8, aafMethod, CAutoString::Extract,       TEXT("Extract,mode,limit"),
	9, aafMethod, CAutoString::Remove,        TEXT("Remove,mode,limit"),
  10, aafMethod, CAutoString::UpperCase,     TEXT("UpperCase"),
  11, aafMethod, CAutoString::LowerCase,     TEXT("LowerCase"),
};
const int AutoStringCount = sizeof(AutoStringTable)/sizeof(DispatchEntryBase);

//____________________________________________________________________________
//
// CAutoString automation implementation
//____________________________________________________________________________

CAutoString::CAutoString(const IMsiString& riString)
 : CAutoBase(*AutoStringTable, AutoStringCount), m_piString(&riString)
{

	g_cServicesUsers++;
}

CAutoString::~CAutoString()
{
	m_piString->Release();

	ReleaseStaticServices();
}

IUnknown& CAutoString::GetInterface()
{
	return *(IUnknown*)m_piString;
}

void CAutoString::Value(CAutoArgs& args)
{
	if (args.PropertySet())
      m_piString->SetString(args[0], m_piString);
	else
      args = m_piString->GetString();
}

void CAutoString::TextSize(CAutoArgs& args)
{
   args = m_piString->TextSize();
}

void CAutoString::IntegerValue(CAutoArgs& args)
{
   args = m_piString->GetIntegerValue();
}

void CAutoString::CharacterCount(CAutoArgs& args)
{
   args = m_piString->CharacterCount();
}

void CAutoString::IsDBCS(CAutoArgs& args)
{
   args = m_piString->IsDBCS();
}

void CAutoString::Compare(CAutoArgs& args)
{
   args = m_piString->Compare((iscEnum)(int)args[1], args[2]);
}

void CAutoString::Append(CAutoArgs& args)
{
	CVariant& var = args[1];
	if (var.GetType() == VT_EMPTY)
	   return;
	else if ((var.GetType() & ~VT_BYREF) == VT_DISPATCH)
      m_piString->AppendMsiString((const IMsiString&)var.Object(IID_IMsiString), m_piString);
   else
      m_piString->AppendString(var, m_piString);
}

void CAutoString::Add(CAutoArgs& args)
{
	CVariant& var = args[1];
	if (var.GetType() == VT_EMPTY)
   {
      AddRef();
	   args = this;
   }
	else if ((var.GetType() & ~VT_BYREF) == VT_DISPATCH)
      args = new CAutoString(m_piString->AddMsiString((const IMsiString&)var.Object(IID_IMsiString)));
   else
      args = new CAutoString(m_piString->AddString(var));
}

void CAutoString::Extract(CAutoArgs& args)
{
   args = new CAutoString(m_piString->Extract((iseEnum)(int)args[1], args[2]));
}

void CAutoString::Remove(CAutoArgs& args)
{
   args = m_piString->Remove((iseEnum)(int)args[1], args[2], m_piString);
}

void CAutoString::UpperCase(CAutoArgs& /*args*/)
{
   m_piString->UpperCase(m_piString);
}

void CAutoString::LowerCase(CAutoArgs& /*args*/)
{
   m_piString->LowerCase(m_piString);
}


// Handles releasing the static services pointer
void CAutoBase::ReleaseStaticServices()
{
	if (--g_cServicesUsers == 0)
	{
		s_piServices->Release();
		s_piServices = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\auto\make.inc ===
!INCLUDE ..\..\MsiMake.inc

AutoRes:$(AUTO_OBJDIR)\msiauto.hh \
        $(AUTO_OBJDIR)\auto.res \
	$(BUILD_COMMONDIR)\msiauto.hlp \
	$(BUILD_COMMONDIR)\msiauto.cnt \
	$(BUILD_COMMONDIR)\msitool.hlp \
	$(BUILD_COMMONDIR)\msitool.cnt \
	$(BUILD_COMMONDIR)\cabinet.dll
        
$(AUTO_OBJDIR)\auto.res: $(AUTO_DIR)\auto.rc $(INC_DIR)\version.h $(AUTO_OBJDIR)\msiauto.tlb
	rc $(C_DEFINES) -D_RC32 -Fo$*.res /I$(INC_DIR) /I$(SDK_INC_PATH) /I$(RES_OBJDIR) /I$(AUTO_OBJDIR) $(AUTO_DIR)\auto.rc

$(AUTO_OBJDIR)\msiauto.tlb : $(AUTO_OBJDIR)\msi.odl $(AUTO_OBJDIR)\msiauto.hh
#	mktyplib $(C_DEFINES) /tlb $@ /I$(INC_DIR) /I$(AUTO_OBJDIR) /w0 
	midl -char unsigned -ms_ext -c_ext $(C_DEFINES) -D__MKTYPLIB__  -tlb $@ /I$(INC_DIR) /I$(AUTO_OBJDIR) /I$(SDK_INC_PATH) -cpp_cmd $(MIDL_CPP) -mktyplib203 $(AUTO_OBJDIR)\msi.odl

ODLSRC = $(AUTO_DIR)\autocom.cpp $(AUTO_DIR)\autosrv.cpp

$(AUTO_OBJDIR)\msi.odl : $(ODLSRC)  
	makeodl.exe $(AUTO_OBJDIR)\msi.odl $(ODLSRC)

$(AUTO_OBJDIR)\msiauto.hh: $(HELP_DIR)\msiauto.hh $(INC_DIR)\opcodes.h
	cl /EP /TC $(INC_DIR)\opcodes.h > $(AUTO_OBJDIR)\opcodes.tmp
	$(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genhh.prl $(HELP_DIR)\msiauto.hh $(AUTO_OBJDIR)\opcodes.tmp > $@
	@del $(AUTO_OBJDIR)\opcodes.tmp

HELPAUTO =  $(HELP_DIR)\general.rtf \
				$(HELP_DIR)\objects.rtf \
				$(HELP_DIR)\services.rtf $(HELP_DIR)\database.rtf \
				$(HELP_DIR)\property.rtf \
				$(HELP_DIR)\handler.rtf $(HELP_DIR)\author.rtf \
				$(HELP_DIR)\path.rtf $(HELP_DIR)\suminfo.rtf\
				$(HELP_DIR)\transfrm.rtf $(HELP_DIR)\conman.rtf \
				$(HELP_DIR)\server.rtf \
				$(AUTO_OBJDIR)\errors.rtf

$(BUILD_COMMONDIR)\msiauto.hlp: $(HELP_DIR)\msiauto.hpj $(HELPAUTO) $(AUTO_OBJDIR)\msiauto.hh
	echo !@copy $** $(BUILD_COMMONDIR)
	!@copy $** $(BUILD_COMMONDIR)
	$(TOOLS_DIR)\echotmpl $(INC_DIR)\helpver.tpl $(INC_DIR)\version.h $(INC_DIR)\version.h > $(BUILD_COMMONDIR)\helpver.h
	hcrtf -o $@ -xn $(BUILD_COMMONDIR)\msiauto.hpj
	@type $(BUILD_COMMONDIR)\msiauto.err
	@del $(BUILD_COMMONDIR)\helpver.h
	@del $(BUILD_COMMONDIR)\*.hpj 
	@del $(BUILD_COMMONDIR)\*.rtf 
	@del $(BUILD_COMMONDIR)\*.hh
	$(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\chkhlp.prl $(BUILD_COMMONDIR)\msiauto.err
	@del $(BUILD_COMMONDIR)\msiauto.err

$(BUILD_COMMONDIR)\msiauto.cnt: $(HELP_DIR)\msiauto.cnt
	$(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\chkhlp.prl $(BUILD_COMMONDIR)\msiauto.err
	echo copy $** $@
	copy $** $@

$(AUTO_OBJDIR)\errors.rtf : 
	mkerrtbl.exe $@

HELPTOOL =  $(HELP_DIR)\msitool.rtf

$(BUILD_COMMONDIR)\msitool.hlp:: $(HELP_DIR)\msitool.hpj $(HELPTOOL) $(HELP_DIR)\msispy.hh
	echo !@copy $** $(BUILD_COMMONDIR)
	!@copy $** $(BUILD_COMMONDIR)
	$(TOOLS_DIR)\echotmpl $(INC_DIR)\helpver.tpl $(INC_DIR)\version.h $(INC_DIR)\version.h > $(BUILD_COMMONDIR)\helpver.h
	hcrtf -o $@ -xn $(BUILD_COMMONDIR)\msitool.hpj
	@del $(BUILD_COMMONDIR)\helpver.*
	@type $(BUILD_COMMONDIR)\msitool.err
	@del $(BUILD_COMMONDIR)\*.hpj 
	@del $(BUILD_COMMONDIR)\*.rtf 
	@del $(BUILD_COMMONDIR)\*.hh
	$(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\chkhlp.prl $(BUILD_COMMONDIR)\msitool.err
	@del $(BUILD_COMMONDIR)\msitool.err

$(BUILD_COMMONDIR)\msitool.cnt: $(HELP_DIR)\msitool.cnt
	$(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\chkhlp.prl $(BUILD_COMMONDIR)\msitool.err
	echo copy $** $@
	copy $** $@

$(BUILD_COMMONDIR)\cabinet.dll:
	copy $(TOOLS_DIR)\cabinet.dll $(BUILD_COMMONDIR)\cabinet.dll
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\appcompat.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 2001
//
//  File:       appcompat.cpp
//
//--------------------------------------------------------------------------

/* appcompat.cpp - MSI application compatibility features implementation
____________________________________________________________________________*/

#include "precomp.h"
#include "_engine.h"
#include "_msiutil.h"
#include "version.h"


#define PROPPREFIX           TEXT("MSIPROPERTY_")
#define PACKAGECODE          TEXT("PACKAGECODE")
#define APPLYPOINT           TEXT("APPLYPOINT")
#define MINMSIVERSION        TEXT("MINMSIVERSION")
#define SDBDOSSUBPATH        TEXT("\\apppatch\\msimain.sdb")
#define SDBNTFULLPATH        TEXT("\\SystemRoot\\AppPatch\\msimain.sdb")
#define MSIDBCELL            TEXT("MSIDBCELL")
#define MSIDBCELLPKS         TEXT("PRIMARYKEYS")
#define MSIDBCELLLOOKUPDATA  TEXT("LOOKUPDATA")
#define SHIMFLAGS            TEXT("SHIMFLAGS")

#define DEBUGMSG_AND_ASSERT(string)     \
        DEBUGMSG(string);                    \
        AssertSz(0, string);                 \


bool FCheckDatabaseCell(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trMatch, IMsiDatabase& riDatabase, const ICHAR* szTable);


inline SHIMDBNS::HSDB LocalSdbInitDatabase(DWORD dwFlags, LPCTSTR pszDatabasePath)
{
#ifdef UNICODE
        if(MinimumPlatformWindowsNT51())
                return APPHELP::SdbInitDatabase(dwFlags, pszDatabasePath);
        else
                return SDBAPIU::SdbInitDatabase(dwFlags, pszDatabasePath);
#else
        return SDBAPI::SdbInitDatabase(dwFlags, pszDatabasePath);
#endif
}

inline VOID LocalSdbReleaseDatabase(SHIMDBNS::HSDB hSDB)
{
#ifdef UNICODE
        if(MinimumPlatformWindowsNT51())
                return APPHELP::SdbReleaseDatabase(hSDB);
        else
                return SDBAPIU::SdbReleaseDatabase(hSDB);
#else
        return SDBAPI::SdbReleaseDatabase(hSDB);
#endif
}

inline SHIMDBNS::TAGREF LocalSdbFindFirstMsiPackage_Str(SHIMDBNS::HSDB hSDB, LPCTSTR lpszGuid, LPCTSTR lpszLocalDB, SHIMDBNS::PSDBMSIFINDINFO pFindInfo)
{
#ifdef UNICODE
        if(MinimumPlatformWindowsNT51())
                return APPHELP::SdbFindFirstMsiPackage_Str(hSDB, lpszGuid, lpszLocalDB, pFindInfo);
        else
                return SDBAPIU::SdbFindFirstMsiPackage_Str(hSDB, lpszGuid, lpszLocalDB, pFindInfo);
#else
        return SDBAPI::SdbFindFirstMsiPackage_Str(hSDB, lpszGuid, lpszLocalDB, pFindInfo);
#endif
}

inline SHIMDBNS::TAGREF LocalSdbFindNextMsiPackage(SHIMDBNS::HSDB hSDB, SHIMDBNS::PSDBMSIFINDINFO pFindInfo)
{
#ifdef UNICODE
        if(MinimumPlatformWindowsNT51())
                return APPHELP::SdbFindNextMsiPackage(hSDB, pFindInfo);
        else
                return SDBAPIU::SdbFindNextMsiPackage(hSDB, pFindInfo);
#else
        return SDBAPI::SdbFindNextMsiPackage(hSDB, pFindInfo);
#endif
}

inline DWORD LocalSdbQueryDataEx(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trExe, LPCTSTR lpszDataName, LPDWORD lpdwDataType, LPVOID lpBuffer, LPDWORD lpdwBufferSize, SHIMDBNS::TAGREF* ptrData)
{
#ifdef UNICODE
        if(MinimumPlatformWindowsNT51())
                return APPHELP::SdbQueryDataEx(hSDB, trExe, lpszDataName, lpdwDataType, lpBuffer, lpdwBufferSize, ptrData);
        else
                return SDBAPIU::SdbQueryDataEx(hSDB, trExe, lpszDataName, lpdwDataType, lpBuffer, lpdwBufferSize, ptrData);
#else
        return SDBAPI::SdbQueryDataEx(hSDB, trExe, lpszDataName, lpdwDataType, lpBuffer, lpdwBufferSize, ptrData);
#endif
}

inline DWORD LocalSdbEnumMsiTransforms(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trMatch, SHIMDBNS::TAGREF* ptrBuffer, DWORD* pdwBufferSize)
{
#ifdef UNICODE
        if(MinimumPlatformWindowsNT51())
                return APPHELP::SdbEnumMsiTransforms(hSDB, trMatch, ptrBuffer, pdwBufferSize);
        else
                return SDBAPIU::SdbEnumMsiTransforms(hSDB, trMatch, ptrBuffer, pdwBufferSize);
#else
        return SDBAPI::SdbEnumMsiTransforms(hSDB, trMatch, ptrBuffer, pdwBufferSize);
#endif
}

inline BOOL LocalSdbReadMsiTransformInfo(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trTransformRef, SHIMDBNS::PSDBMSITRANSFORMINFO pTransformInfo)
{
#ifdef UNICODE
        if(MinimumPlatformWindowsNT51())
                return APPHELP::SdbReadMsiTransformInfo(hSDB, trTransformRef, pTransformInfo);
        else
                return SDBAPIU::SdbReadMsiTransformInfo(hSDB, trTransformRef, pTransformInfo);
#else
        return SDBAPI::SdbReadMsiTransformInfo(hSDB, trTransformRef, pTransformInfo);
#endif
}

inline BOOL LocalSdbCreateMsiTransformFile(SHIMDBNS::HSDB hSDB, LPCTSTR lpszFileName, SHIMDBNS::PSDBMSITRANSFORMINFO pTransformInfo)
{
#ifdef UNICODE
        if(MinimumPlatformWindowsNT51())
                return APPHELP::SdbCreateMsiTransformFile(hSDB, lpszFileName, pTransformInfo);
        else
                return SDBAPIU::SdbCreateMsiTransformFile(hSDB, lpszFileName, pTransformInfo);
#else
        return SDBAPI::SdbCreateMsiTransformFile(hSDB, lpszFileName, pTransformInfo);
#endif
}

inline SHIMDBNS::TAGREF LocalSdbFindFirstTagRef(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trParent, SHIMDBNS::TAG tTag)
{
#ifdef UNICODE
        if(MinimumPlatformWindowsNT51())
                return APPHELP::SdbFindFirstTagRef(hSDB, trParent, tTag);
        else
                return SDBAPIU::SdbFindFirstTagRef(hSDB, trParent, tTag);
#else
        return SDBAPI::SdbFindFirstTagRef(hSDB, trParent, tTag);
#endif
}

inline SHIMDBNS::TAGREF LocalSdbFindNextTagRef(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trParent, SHIMDBNS::TAGREF trPrev)
{
#ifdef UNICODE
        if(MinimumPlatformWindowsNT51())
                return APPHELP::SdbFindNextTagRef(hSDB, trParent, trPrev);
        else
                return SDBAPIU::SdbFindNextTagRef(hSDB, trParent, trPrev);
#else
        return SDBAPI::SdbFindNextTagRef(hSDB, trParent, trPrev);
#endif
}

inline BOOL LocalSdbReadStringTagRef(SHIMDBNS::HSDB hSDB, SHIMDBNS::TAGREF trMatch, LPTSTR pwszBuffer, DWORD dwBufferSize)
{
#ifdef UNICODE
        if(MinimumPlatformWindowsNT51())
                return APPHELP::SdbReadStringTagRef(hSDB, trMatch, pwszBuffer, dwBufferSize);
        else
                return SDBAPIU::SdbReadStringTagRef(hSDB, trMatch, pwszBuffer, dwBufferSize);
#else
        return SDBAPI::SdbReadStringTagRef(hSDB, trMatch, pwszBuffer, dwBufferSize);
#endif
}


DWORD LocalSdbQueryData(SHIMDBNS::HSDB    hSDB,
                                                                SHIMDBNS::TAGREF  trMatch,
                                                                LPCTSTR szDataName,
                                                                LPDWORD pdwDataType,
                                                                CTempBufferRef<BYTE>& rgbBuffer,
                                                                SHIMDBNS::TAGREF* ptrData)
{
        Assert(pdwDataType);
        Assert(rgbBuffer.GetSize() >= 2);

        DWORD cbBuffer = rgbBuffer.GetSize();

        DWORD dwResult = LocalSdbQueryDataEx(hSDB, trMatch, szDataName, pdwDataType, (BYTE*)rgbBuffer, &cbBuffer, ptrData);

        if(ERROR_INSUFFICIENT_BUFFER == dwResult)
        {
                rgbBuffer.Resize(cbBuffer);
                dwResult = LocalSdbQueryDataEx(hSDB, trMatch, szDataName, pdwDataType, (BYTE*)rgbBuffer, &cbBuffer, ptrData);
        }

        if(*pdwDataType == REG_NONE) // in case buffer is treated as string, null first WCHAR
        {
                rgbBuffer[0] = 0;
                rgbBuffer[1] = 0;
        }

        return dwResult;
}

bool GetSdbDataNames(SHIMDBNS::HSDB hSDB,
                                                        SHIMDBNS::TAGREF trMatch,
                                                        CTempBufferRef<BYTE>& rgbBuffer)
{
        DWORD dwDataType = 0;
        DWORD dwStatus = LocalSdbQueryData(hSDB,
                                                                                                  trMatch,
                                                                                                  NULL,
                                                                                                  &dwDataType,
                                                                                                  rgbBuffer,
                                                                                                  NULL);

        if(dwStatus != ERROR_SUCCESS)
        {
                // no DATA tags, which may be fine
                return false;
        }
        else if(dwDataType != REG_MULTI_SZ)
        {
                DEBUGMSG_AND_ASSERT(TEXT("APPCOMPAT: SdbQueryData failed unexpectedly.  Sdb may be invalid."));
                return false;
        }

        return true;
}

int GetShimFlags(SHIMDBNS::HSDB hSDB,
                                                SHIMDBNS::TAGREF trMatch)
{
        DWORD dwDataType = 0;
        DWORD dwFlags = 0;

        CTempBuffer<BYTE, 256> rgbAttributeData;

        DWORD dwStatus = LocalSdbQueryData(hSDB,
                                                                 trMatch,
                                                                 SHIMFLAGS,
                                                                 &dwDataType,
                                                                 rgbAttributeData,
                                                                 NULL);

        if(dwStatus == ERROR_SUCCESS)
        {
                if(dwDataType == REG_DWORD)
                {
                        dwFlags = *((DWORD*)(BYTE*)rgbAttributeData);
                        DEBUGMSG2(TEXT("APPCOMPAT: %s: %d"), SHIMFLAGS, (const ICHAR*)(INT_PTR)dwFlags);
                }
                else
                {
                        DEBUGMSG1(TEXT("APPCOMPAT: found invalid '%s' entry.  Ignoring..."), SHIMFLAGS);
                }
        }

        return dwFlags;
}


bool FIsMatchingAppCompatEntry(SHIMDBNS::HSDB hSDB,
                                                                                 SHIMDBNS::TAGREF trMatch,
                                                                                 const IMsiString& ristrPackageCode,
                                                                                 iacpAppCompatTransformApplyPoint iacpApplyPoint,
                                                                                 IMsiEngine& riEngine,
                                                                                 IMsiDatabase& riDatabase)
{
        DWORD dwStatus = 0;
        DWORD dwDataType = 0;

        CTempBuffer<BYTE, 256> rgbAttributeData;

        // first, we check for the required DATA entries
        // 1) MINMSIVERSION tells us the minimum version of msi that should process this entry
        //              (if no version tag is supplied, assume there is no minimum version)

        dwStatus = LocalSdbQueryData(hSDB,
                                                                 trMatch,
                                                                 MINMSIVERSION,
                                                                 &dwDataType,
                                                                 rgbAttributeData,
                                                                 NULL);

        if(ERROR_SUCCESS == dwStatus && REG_SZ == dwDataType)
        {
                DWORD dwSdbMS = 0;
                DWORD dwSdbLS = 0;
                if(fFalse == ParseVersionString((ICHAR*)(BYTE*)rgbAttributeData, dwSdbMS, dwSdbLS))
                {
                        DEBUGMSG1(TEXT("APPCOMPAT: invalid minimum version string '%s' found."),
                                                 (ICHAR*)(BYTE*)rgbAttributeData);
                        return false;
                }

                DWORD dwMsiMS = (rmj << 16) + rmm;
                DWORD dwMsiLS = (rup << 16) + rin;

                if(dwMsiMS < dwSdbMS || (dwMsiMS == dwSdbMS && dwMsiLS < dwSdbLS))
                {
                        DEBUGMSG5(TEXT("APPCOMPAT: skipping this entry.  Minimum MSI version required: '%s'; current version: %d.%02d.%04d.%02d."),
                                                 (ICHAR*)(BYTE*)rgbAttributeData,
                                                 (const ICHAR*)(INT_PTR)rmj, (const ICHAR*)(INT_PTR)rmm, (const ICHAR*)(INT_PTR)rup, (const ICHAR*)(INT_PTR)rin);
                        return false;
                }
                // else valid version supplied that is equal to or older than current version
        }

        //      2) APPLYPOINT tells us where this entry should be processed
        //    (if it isn't the current applypoint we skip this entry)
        dwStatus = LocalSdbQueryData(hSDB,
                                                                 trMatch,
                                                                 APPLYPOINT,
                                                                 &dwDataType,
                                                                 rgbAttributeData,
                                                                 NULL);

        DWORD dwApplyPoint = iacpBeforeTransforms; // default value

        if(ERROR_SUCCESS == dwStatus && REG_DWORD == dwDataType)
        {
                dwApplyPoint = *((DWORD*)(BYTE*)rgbAttributeData);
        }

        if(dwApplyPoint != iacpApplyPoint)
        {
                DEBUGMSG(TEXT("APPCOMPAT: skipping transform because it should be applied at a different point of the install."));
                return false;
        }


        // now enumerate remaining optional data

        CTempBuffer<BYTE, 256> rgbDataNames;
        if(false == GetSdbDataNames(hSDB, trMatch, rgbDataNames))
                return true; // no remaining data to process

        bool fPackageCodeAttributeExists = false;
        bool fPackageCodeMatchFound      = false;

        for(ICHAR* pchName = (ICHAR*)(BYTE*)rgbDataNames; *pchName; pchName += lstrlen(pchName) + 1)
        {
                SHIMDBNS::TAGREF trData;
                dwStatus = LocalSdbQueryData(hSDB,
                                                                         trMatch,
                                                                         pchName,
                                                                         &dwDataType,
                                                                         rgbAttributeData,
                                                                         &trData);

                if(dwStatus != ERROR_SUCCESS)
                {
                        DEBUGMSG_AND_ASSERT(TEXT("APPCOMPAT: SdbQueryData failed unexpectedly.  Sdb may be invalid."));
                        return false;
                }
                else if(dwDataType == REG_SZ &&
                                  (0 == IStrCompI(pchName, MINMSIVERSION)))
                {
                        // handled this one above
                }
                else if(dwDataType == REG_DWORD &&
                                  (0 == IStrCompI(pchName, APPLYPOINT)))
                {
                        // handled this one above
                }
                else if(dwDataType == REG_DWORD &&
                                  (0 == IStrCompI(pchName, SHIMFLAGS)))
                {
                        // handle this one elsewhere
                }
                else if((REG_SZ == dwDataType || REG_NONE == dwDataType) &&
                                  0 == IStrNCompI(pchName, PROPPREFIX, (sizeof(PROPPREFIX)-1)/sizeof(ICHAR)))
                {
                        // this is a property name - check for a value match
                        MsiString strPropValue = riEngine.GetPropertyFromSz(pchName + (sizeof(PROPPREFIX)-1)/sizeof(ICHAR));

                        DEBUGMSG2(TEXT("APPCOMPAT: testing Property value.  Property: '%s'; expected value: '%s'"),
                                                 pchName + (sizeof(PROPPREFIX)-1)/sizeof(ICHAR),
                                                 (ICHAR*)(BYTE*)rgbAttributeData);

                        // compare works for missing property and REG_NONE data from SDB
                        if(0 == strPropValue.Compare(iscExact, (ICHAR*)(BYTE*)rgbAttributeData)) // case-insensitive compare
                        {
                                // not a match
                                DEBUGMSG3(TEXT("APPCOMPAT: mismatched attributes.  Property: '%s'; expected value: '%s'; true value: '%s'"),
                                                         pchName + (sizeof(PROPPREFIX)-1)/sizeof(ICHAR),
                                                         (ICHAR*)(BYTE*)rgbAttributeData,
                                                         (const ICHAR*)strPropValue);

                                return false;
                        }
                }
                else if(REG_SZ == dwDataType &&
                                  0 == IStrNCompI(pchName, PACKAGECODE, (sizeof(PACKAGECODE)-1)/sizeof(ICHAR)))
                {
                        fPackageCodeAttributeExists = true;

                        DEBUGMSG1(TEXT("APPCOMPAT: testing PackageCode.  Expected value: '%s'"),
                                                 (ICHAR*)(BYTE*)rgbAttributeData);

                        if(ristrPackageCode.Compare(iscExactI, (ICHAR*)(BYTE*)rgbAttributeData))
                        {
                                fPackageCodeMatchFound = true;
                        }
                }
                else if(REG_SZ == dwDataType &&
                                  0 == IStrNCompI(pchName, MSIDBCELL, (sizeof(MSIDBCELL)-1)/sizeof(ICHAR)))
                {
                        // db cell lookup

                        DEBUGMSG1(TEXT("APPCOMPAT: testing cell data in '%s' table."),
                                                 (ICHAR*)(BYTE*)rgbAttributeData);

                        if(false == FCheckDatabaseCell(hSDB, trData, riDatabase, (ICHAR*)(BYTE*)rgbAttributeData))
                        {
                                // if check failed, sub-function will do DEBUGMSG explaining why
                                return false;
                        }
                }
                else
                {
                        // don't understand this data tag - we'll just ignore it and move on
                        DEBUGMSG2(TEXT("APPCOMPAT: ignoring unknown data.  Data name: '%s', data type: %d"),
                                                 pchName, (const ICHAR*)(INT_PTR)dwDataType);
                }
        }

        if(fPackageCodeAttributeExists == true && fPackageCodeMatchFound == false)
        {
                // not a match
                DEBUGMSG1(TEXT("APPCOMPAT: PackageCode attribute(s) exist, but no matching PackageCode found.  Actual PackageCode: '%s'"),
                                         ristrPackageCode.GetString());

                return false;
        }

        return true;
}

enum ipcolColumnTypes
{
        ipcolPrimaryKeys,
        ipcolLookupColumns,
};

bool ProcessColumns(ipcolColumnTypes ipcolType,
                                                  SHIMDBNS::HSDB hSDB,
                                                  SHIMDBNS::TAGREF trMatch,
                                                  IMsiDatabase& riDatabase,
                                                  IMsiTable& riTable,
                                                  IMsiCursor& riCursor,
                                                  const ICHAR* szTable)
{
        DWORD dwStatus = 0;
        DWORD dwDataType = 0;
        CTempBuffer<BYTE, 256> rgbAttributeData;

        const ICHAR* szTagName = ipcolType == ipcolPrimaryKeys ? MSIDBCELLPKS : MSIDBCELLLOOKUPDATA;

        SHIMDBNS::TAGREF trData = 0;
        dwStatus = LocalSdbQueryData(hSDB,
                                                                 trMatch,
                                                                 szTagName,
                                                                 &dwDataType,
                                                                 rgbAttributeData,
                                                                 &trData);

        if(dwStatus != ERROR_SUCCESS || REG_NONE != dwDataType)
        {
                // the missing tag is only a failure in the PrimaryKeys case
                // the LookupData tag is optional
                if(ipcolType == ipcolPrimaryKeys)
                {
                        DEBUGMSG(TEXT("APPCOMPAT: database cell lookup failed.  Missing or invalid primary key data in appcompat database."));
                        return false;
                }
                else
                {
                        return true;
                }
        }

        CTempBuffer<BYTE, 256> rgbColumns;
        if(false == GetSdbDataNames(hSDB, trData, rgbColumns))
                return false;

        int iPKFilter = 0;

        for(ICHAR* pchColumn = (ICHAR*)(BYTE*)rgbColumns; *pchColumn; pchColumn += lstrlen(pchColumn) + 1)
        {
                CTempBuffer<BYTE, 256> rgbValue;
                DWORD dwDataType = 0;

                dwStatus = LocalSdbQueryData(hSDB,
                                                                         trData,
                                                                         pchColumn,
                                                                         &dwDataType,
                                                                         rgbValue,
                                                                         NULL);

                if(ERROR_SUCCESS != dwStatus)
                {
                        DEBUGMSG_AND_ASSERT(TEXT("APPCOMPAT: SdbQueryData failed unexpectedly.  Sdb may be invalid."));
                        return false;
                }

                // get column index
                int iColIndex = riTable.GetColumnIndex(riDatabase.EncodeStringSz(pchColumn));

                if(0 == iColIndex)
                {
                        // column doesn't exist in table
                        DEBUGMSG2(TEXT("APPCOMPAT: database cell lookup failed.  Column '%s' does not exist in table '%s'."),
                                                 pchColumn, szTable);
                        return false;
                }

                // load value into cursor
                bool fRes = false;
                if(ipcolType == ipcolPrimaryKeys)
                {
                        iPKFilter |= iColumnBit(iColIndex);

                        switch(dwDataType)
                        {
                        case REG_DWORD:
                                fRes = riCursor.PutInteger(iColIndex, *((DWORD*)(BYTE*)rgbValue)) ? true : false;
                                break;
                        case REG_SZ:
                                fRes = riCursor.PutString(iColIndex, *MsiString((ICHAR*)(BYTE*)rgbValue)) ? true : false;
                                break;
                        case REG_NONE:
                                fRes = riCursor.PutNull(iColIndex) ? true : false;
                                break;
                        default:
                                // unknown type for a primary key column
                                // can't just ignore unknown data in this case because this is a primary key column and not using it
                                // may cause unexpected results
                                DEBUGMSG3(TEXT("APPCOMPAT: database cell lookup failed.  Unknown data type %d specified for column '%s' in table '%s'."),
                                                         (const ICHAR*)(INT_PTR)dwDataType, pchColumn, szTable);
                                return false;
                        };

                        if(fRes == false)
                        {
                                // column can't take expected data type
                                DEBUGMSG2(TEXT("APPCOMPAT: database cell lookup failed.  Column '%s' in table '%s' does not accept the lookup data."),
                                                         pchColumn, szTable);
                                return false;
                        }
                }
                else
                {
                        // check for data in this row
                        switch(dwDataType)
                        {
                        case REG_NONE:
                                if(MsiString(riCursor.GetString(iColIndex)).TextSize() == 0)
                                        fRes = true;
                                break;
                        case REG_DWORD:
                                if(riCursor.GetInteger(iColIndex) == *((DWORD*)(BYTE*)rgbValue))
                                        fRes = true;
                                break;
                        case REG_SZ:
                                if(MsiString(riCursor.GetString(iColIndex)).Compare(iscExact, (ICHAR*)(BYTE*)rgbValue)) // case-sensitive compare
                                        fRes = true;
                                break;
                        default:
                                DEBUGMSG_AND_ASSERT(TEXT("APPCOMPAT: database cell lookup failed.  Unexpected cell lookup data in appcompat database."));
                                return false;
                        };

                        if(fRes == false)
                        {
                                DEBUGMSG1(TEXT("APPCOMPAT: database cell lookup failed.  Expected cell data does not exist in table '%s'."),
                                                         szTable);
                                return false;
                        }
                }
        }

        if(ipcolType == ipcolPrimaryKeys)
        {
                // set cursor filter
                if(0 == iPKFilter)
                {
                        DEBUGMSG(TEXT("APPCOMPAT: database cell lookup failed.  Missing primary key data in appcompat database."));
                        return false;
                }

                riCursor.SetFilter(iPKFilter);
        }

        return true;
}

bool FCheckDatabaseCell(SHIMDBNS::HSDB hSDB,
                                                                SHIMDBNS::TAGREF trMatch,
                                                                IMsiDatabase& riDatabase,
                                                                const ICHAR* szTable)
{
        PMsiRecord pError(0);
        PMsiTable pTable(0);
        DWORD dwStatus = 0;

        // STEP 1: load table and cursor
        if((pError = riDatabase.LoadTable(*MsiString(szTable), 0, *&pTable)))
        {
                DEBUGMSG1(TEXT("APPCOMPAT: database cell lookup failed.  Table '%s' does not exist"), szTable);
                return false;
        }

        PMsiCursor pCursor = pTable->CreateCursor(fFalse);
        if(pCursor == 0)
        {
                DEBUGMSG_AND_ASSERT(TEXT("APPCOMPAT: unexpected failure: couldn't create cursor object"));
                return false;
        }


        // STEP 2: read primary key values and populate cursor
        if(false == ProcessColumns(ipcolPrimaryKeys, hSDB, trMatch, riDatabase, *pTable, *pCursor, szTable))
                return false;


        // STEP 3: locate row in table
        if(fFalse == pCursor->Next())
        {
                DEBUGMSG1(TEXT("APPCOMPAT: database cell lookup failed.  Expected row does not exist in table '%s'."),
                                         szTable);
                return false;
        }


        // STEP 4 (optional): check lookup values in row
        if(false == ProcessColumns(ipcolLookupColumns, hSDB, trMatch, riDatabase, *pTable, *pCursor, szTable))
                return false;

        return true;
}

bool GetTransformTempDir(IMsiServices& riServices, IMsiPath*& rpiTempPath)
{
        MsiString strTempDir = GetTempDirectory();

        PMsiRecord pError = riServices.CreatePath(strTempDir, rpiTempPath);
        AssertRecordNR(pError);

        if(pError)
        {
                return false;
        }

        return true;
}

bool ApplyTransforms(SHIMDBNS::HSDB hSDB,
                                                        SHIMDBNS::TAGREF trMatch,
                                                        IMsiServices& riServices,
                                                        IMsiDatabase& riDatabase,
                                                        IMsiPath& riTempDir)
{
        if(riDatabase.GetUpdateState() != idsRead)
        {
                DEBUGMSG(TEXT("APPCOMPAT: cannot apply appcompat transforms - database is open read/write."));
                return true; // not a failure
        }

        SHIMDBNS::TAGREF trTransform = LocalSdbFindFirstTagRef(hSDB, trMatch, TAG_MSI_TRANSFORM_REF);

        while (trTransform != TAGREF_NULL)
        {
                SHIMDBNS::SDBMSITRANSFORMINFO MsiTransformInfo;

                BOOL bSuccess = LocalSdbReadMsiTransformInfo(hSDB, trTransform, &MsiTransformInfo);

                if(bSuccess)
                {
                        PMsiRecord pError(0);
                        MsiString strTransformPath;

                        // creating a file in our acl'ed folder, need to elevate this block
                        {
                                CElevate elevate;

                                pError = riTempDir.TempFileName(0, TEXT("mst"), fFalse, *&strTransformPath, 0); //?? need to secure this file?
                                if(pError)
                                {
                                        AssertRecordNR(pError);
                                        return false; // can't extract transforms if we can't get a temp file name
                                }

                                bSuccess = LocalSdbCreateMsiTransformFile(hSDB, (const ICHAR*)strTransformPath, &MsiTransformInfo);
                                if(FALSE == bSuccess)
                                {
                                        Debug(DWORD dwDebug = GetLastError());
                                        DEBUGMSG_AND_ASSERT(TEXT("APPCOMPAT: SdbCreateMsiTransformFile failed unexpectedly.  Sdb may be invalid."));
                                        return false;
                                }

                                // done elevating
                        }

                        // apply the transform
                        // NOTE: we aren't going to validate the transform using the transforms suminfo properties
                        // sufficient validation that this is the correct transform has been done above
                        PMsiStorage pTransStorage(0);

                        // don't call SAFER here - transform is from appcompat database and should be considered safe
                        pError = OpenAndValidateMsiStorageRec(strTransformPath, stTransform, riServices, *&pTransStorage, /* fCallSAFER = */ false, /* szFriendlyName = */ NULL, /* phSaferLevel = */ NULL);
                        if(pError)
                        {
                                AssertRecordNR(pError);
                                return false; // can't apply transform if we can't open it
                        }

                        AssertNonZero(pTransStorage->DeleteOnRelease(true));

                        DEBUGMSG1(TEXT("APPCOMPAT: applying appcompat transform '%s'."), (const ICHAR*)strTransformPath);
                        pError = riDatabase.SetTransform(*pTransStorage, iteAddExistingRow|iteDelNonExistingRow|iteAddExistingTable|iteDelNonExistingTable|iteUpdNonExistingRow);
                        if(pError)
                        {
                                AssertRecordNR(pError);
                                return false; // can't apply transform if we can't open it
                        }
                }
                else
                {
                        DEBUGMSG_AND_ASSERT(TEXT("APPCOMPAT: SdbCreateMsiTransformFile failed unexpectedly.  Sdb may be invalid."));
                        return false;
                }


                trTransform = LocalSdbFindNextTagRef(hSDB, trMatch, trTransform);
        }

        return true;
}


bool CMsiEngine::ApplyAppCompatTransforms(IMsiDatabase& riDatabase,
                                                                                                                const IMsiString& ristrProductCode,
                                                                                                                const IMsiString& ristrPackageCode,
                                                                                                                iacpAppCompatTransformApplyPoint iacpApplyPoint,
                                                                                                                iacsAppCompatShimFlags& iacsShimFlags,
#ifdef UNICODE
                                                                                                                bool fQuiet,
#else
                                                                                                                bool /*fQuiet*/,
#endif
                                                                                                                bool fProductCodeChanged,
                                                                                                                bool& fDontInstallPackage)
{
        class CCloseSDB
        {
         public:
                 CCloseSDB(SHIMDBNS::HSDB hSDB) : m_hSDB(hSDB) {}
                 ~CCloseSDB() { LocalSdbReleaseDatabase(m_hSDB); }
         protected:
                SHIMDBNS::HSDB m_hSDB;
        };

        iacsShimFlags = (iacsAppCompatShimFlags)0;
        fDontInstallPackage = false;

        // if the product code has changed (either from a major upgrade patch or a transform for a multi-language install)
        // then we reset m_fCAShimsEnabled and the guids and check for a reference to a shim in the new product
        if (fProductCodeChanged)
        {
                m_fCAShimsEnabled = false;
                memset(&m_guidAppCompatDB, 0, sizeof(m_guidAppCompatDB));
                memset(&m_guidAppCompatID, 0, sizeof(m_guidAppCompatID));
        }

        SHIMDBNS::HSDB hSDB;
        SHIMDBNS::SDBMSIFINDINFO MsiFindInfo;
        DWORD dwStatus = 0;

#ifndef UNICODE
        // construct path to msimain.sdb
        ICHAR rgchSdbPath[MAX_PATH];
        if(0 == (MsiGetWindowsDirectory(rgchSdbPath, sizeof(rgchSdbPath)/sizeof(ICHAR))))
        {
                DEBUGMSG(TEXT("APPCOMPAT: can't get path to Windows folder."));
                return false;
        }
        if ( FAILED(StringCchCat(rgchSdbPath, ARRAY_ELEMENTS(rgchSdbPath), SDBDOSSUBPATH)) )
                return false;

        hSDB = LocalSdbInitDatabase(HID_DATABASE_FULLPATH | HID_DOS_PATHS | SDB_DATABASE_MAIN_MSI, rgchSdbPath);
#else
        hSDB = LocalSdbInitDatabase(HID_DATABASE_FULLPATH | SDB_DATABASE_MAIN_MSI, SDBNTFULLPATH);
#endif

        if(NULL == hSDB)
        {
                DEBUGMSG(TEXT("APPCOMPAT: unable to initialize database."));
                return false;
        }

        CCloseSDB closeSDB(hSDB); // ensures that hSDB is closed before returning from fn

        DEBUGMSG1(TEXT("APPCOMPAT: looking for appcompat database entry with ProductCode '%s'."),
                                 ristrProductCode.GetString());

        SHIMDBNS::TAGREF trMatch = LocalSdbFindFirstMsiPackage_Str(hSDB,
                                                                                                         ristrProductCode.GetString(),
                                                                                                         NULL,
                                                                                                         &MsiFindInfo);

        if(TAGREF_NULL == trMatch)
        {
                DEBUGMSG(TEXT("APPCOMPAT: no matching ProductCode found in database."));
                return true;
        }

        PMsiPath pTempDir(0);
        do
        {
                ICHAR rgchTagName[255] = {0};

                SHIMDBNS::TAGREF trName = LocalSdbFindFirstTagRef(hSDB, trMatch, TAG_NAME);
                if (TAGREF_NULL != trName) {
                         LocalSdbReadStringTagRef(hSDB, trName, rgchTagName, 255);
                }

                DEBUGMSG1(TEXT("APPCOMPAT: matching ProductCode found in database.  Entry name: '%s'.  Testing other attributes..."),
                                         rgchTagName);

                // found a product code match
                // check other characteristics of this database entry to ensure it belongs to this package
                if(false == FIsMatchingAppCompatEntry(hSDB, trMatch, ristrPackageCode, iacpApplyPoint, *this, riDatabase))
                {
                        DEBUGMSG(TEXT("APPCOMPAT: found matching ProductCode in database, but other attributes do not match."));
                        continue;
                }

                DEBUGMSG(TEXT("APPCOMPAT: matching ProductCode found in database, and other attributes match.  Applying appcompat fix."));

                iacsShimFlags = (iacsAppCompatShimFlags)GetShimFlags(hSDB, trMatch);


                // check if this entry contains APPHELP info or custom action shims
                SHIMDBNS::MSIPACKAGEINFO sPackageInfo;
                memset(&sPackageInfo, 0, sizeof(sPackageInfo));

#ifdef UNICODE // NT-only code follows

                if(MinimumPlatformWindowsNT51())
                {
                        if (FALSE == APPHELP::SdbGetMsiPackageInformation(hSDB, trMatch, &sPackageInfo))
                        {
                                DEBUGMSG(TEXT("APPCOMPAT: SdbGetMsiPackageInformation failed unexpectedly."));
                        }
                        else
                        {
                                // if this entry contains apphelp info, make the apphelp call now
                                if(sPackageInfo.dwPackageFlags & MSI_PACKAGE_HAS_APPHELP)
                                {
                                        if(FALSE == APPHELP::ApphelpCheckMsiPackage(&(sPackageInfo.guidDatabaseID), &(sPackageInfo.guidID),
                                                                                                                                                          0, fQuiet ? TRUE : FALSE))
                                        {
                                                // shouldn't install this app
                                                DEBUGMSG(TEXT("APPCOMPAT: ApphelpCheckMsiPackage returned FALSE.  This product will not be installed due to application compatibility concerns."));
                                                fDontInstallPackage = true;
                                                return false;
                                        }
                                }

                                // look for at least one custom action entry. We only accept the first matching sdb entry with custom
                                // action shims. The AppCompat team has guaranteed that multiple matches will not exist even if multiple
                                // transform matches exist.

                                if (!m_fCAShimsEnabled)
                                {
                                        // no CA shims found yet. Search this match entry
                                        SHIMDBNS::TAGREF trCustomAction = LocalSdbFindFirstTagRef(hSDB, trMatch, TAG_MSI_CUSTOM_ACTION);
                                        if (trCustomAction != TAGREF_NULL)
                                        {
                                                memcpy(&m_guidAppCompatDB, &sPackageInfo.guidDatabaseID, sizeof(sPackageInfo.guidDatabaseID));
                                                memcpy(&m_guidAppCompatID, &sPackageInfo.guidID, sizeof(sPackageInfo.guidID));
                                                m_fCAShimsEnabled = true;
                                        }
                                }
                        }
                }
#endif //UNICODE

                if(pTempDir == 0 &&
                        false == GetTransformTempDir(m_riServices, *&pTempDir))
                {
                        AssertSz(0, TEXT("Failed to determine temp directory for appcompat transforms."));
                        DEBUGMSG(TEXT("APPCOMPAT: Failed to determine temp directory for appcompat transforms."));
                        return false; // need to be able to get our temp dir
                }

                if(false == ApplyTransforms(hSDB, trMatch, m_riServices, riDatabase, *pTempDir))
                {
                        AssertSz(0, TEXT("Failed to apply appcompat transform."));
                        DEBUGMSG(TEXT("APPCOMPAT: Failed to apply appcompat transform."));
                        continue;
                }
        }
        while (TAGREF_NULL != (trMatch = LocalSdbFindNextMsiPackage(hSDB, &MsiFindInfo)));

        return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\buildtools\makeodl\makeodl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       makeodl.cpp
//
//--------------------------------------------------------------------------

#include "common.h"   // to allow use of precompiled headers for windows.h
//#pragma warning(disable : 4201) // unnamed struct/unions, in Win32 headers
//#pragma warning(disable : 4514) // unreferenced inline function has been removed, in Win32 headers
//#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <version.h>
#pragma warning(default: 4201) // unnamed struct/unions, in Win32 headers

BOOL WriteLineToFile(HANDLE hFile, char* szBuffer);
BOOL ReadLineFromFile(HANDLE hFile, char* szBuffer, int cchBufSize, int* iBytesWritten);

const int iMajVer = 0;
const int iMinVer = 1;

int _cdecl main(int argc, char *argv[])
{
	char szInFile[MAX_PATH+1], szOutFile[MAX_PATH+1];

	char *pchInFile = szInFile;
	char *pchOutFile = szOutFile;

	if (argc < 2)
	{
		MessageBox(0, "Syntax: makeodl outfile infile",0,0);
		return 0;
	}
	
	HANDLE hOutFile = CreateFile(argv[1], GENERIC_WRITE, 0, 0, 
 	CREATE_ALWAYS, 0, 0);
	
	if (hOutFile == INVALID_HANDLE_VALUE)
	{
		fprintf(stderr, "Could not open output file \"%s\"\n", argv[1]);
		return 1;
	}
	
	const int iBufSize = 200;
	char szBuffer[iBufSize + 1];
	wsprintf(szBuffer, "// WARNING: Do not edit this file. It was generated by MAKEODL V%i.%i", iMajVer, iMinVer);
	WriteLineToFile(hOutFile, "//****************************************************************************************");
	WriteLineToFile(hOutFile, szBuffer);
	time_t curTime = time(NULL);
	tm* tmLocalTime = localtime(&curTime);
	strftime(szBuffer, iBufSize, "// Created: %d %b %Y %H:%M:%S", tmLocalTime);
	WriteLineToFile(hOutFile, szBuffer);
	WriteLineToFile(hOutFile, "//****************************************************************************************");
	WriteLineToFile(hOutFile, "#include <msiauto.hh>  // help context ID definitions");
	WriteLineToFile(hOutFile, "#include <msidspid.h>  // MSI dispatch IDs");
	WriteLineToFile(hOutFile, "[");
	WriteLineToFile(hOutFile, "\tuuid(000C107E-0000-0000-C000-000000000046), // LIBID_MsiAuto");
	WriteLineToFile(hOutFile, "\thelpfile(\"MsiAuto.HLP\"),");
	WriteLineToFile(hOutFile, "\thelpstring(\"Microsoft Windows installer 1.0 Internal Test Object Library\"),");
	WriteLineToFile(hOutFile, "\tlcid(0x0409),");
	WriteLineToFile(hOutFile, "\tversion(1.0000),");
	WriteLineToFile(hOutFile, "]");
	WriteLineToFile(hOutFile, "library Installer");
	WriteLineToFile(hOutFile, "{");
	WriteLineToFile(hOutFile, "\timportlib(\"stdole32.tlb\");");
	WriteLineToFile(hOutFile, "\t#define DISPID_NEWENUM -4");	
	

//=== PASS 1 ========================================
//
// Extract all "dispinterface ...." lines and create forward references out of them. 
// Generates some like this:
//
//    dispinterface MyFirstInterface;
//    dispinterface MySecondInterface;
// 	dispinterface MyThirdInterface;
//

	int iBytesRead;
	int cInFile = 2;
	while (cInFile < argc)
	{
		HANDLE hInFile = CreateFile(argv[cInFile], GENERIC_READ, FILE_SHARE_READ, 0, 
	 	OPEN_EXISTING, 0, 0);
	
		if (hInFile == INVALID_HANDLE_VALUE)
		{
			fprintf(stderr, "Could not open input file \"%s\"\n", argv[cInFile]);
			CloseHandle(hOutFile);
			DeleteFile(argv[1]);
			return 1;
		}
	
		const int cchBufSize = 300;
		char szBuffer[cchBufSize+1];	
		while (ReadLineFromFile(hInFile, szBuffer, cchBufSize, &iBytesRead))
		{
			if (strstr(szBuffer, "/*O"))
			{
				while (ReadLineFromFile(hInFile, szBuffer, cchBufSize, &iBytesRead) && !(strstr(szBuffer,"dispinterface")) &&
				 !(strstr(szBuffer,"*/")))
					;
				if ((iBytesRead!=0) && !(strstr(szBuffer,"*/")))  // !EOF && not end of comment
				{
					lstrcatA(szBuffer,";");
					WriteLineToFile(hOutFile, szBuffer);	
				}
					
			}
	
		}
		CloseHandle(hInFile);
		cInFile++;																				   
	}

//=== PASS 2 ======================================
//
// Extracts all information within ODL comments. 
//

	cInFile = 2;
	while (cInFile < argc)
	{
	
		HANDLE hInFile = CreateFile(argv[cInFile], GENERIC_READ, FILE_SHARE_READ, 0, 
	 	OPEN_EXISTING, 0, 0);
	
		if (hInFile == INVALID_HANDLE_VALUE)
		{
			fprintf(stderr, "Could not open input file \"%s\"\n", argv[cInFile]);
			CloseHandle(hOutFile);
			DeleteFile(argv[1]);
			return 1;
		}
	
		const int cchBufSize = 300;
		char szBuffer[cchBufSize+1];	
		while (ReadLineFromFile(hInFile, szBuffer, cchBufSize, &iBytesRead))
		{
			if (strstr(szBuffer, "/*O"))
			{
				while (ReadLineFromFile(hInFile, szBuffer, cchBufSize, &iBytesRead) && !(strstr(szBuffer,"*/")))
					WriteLineToFile(hOutFile, szBuffer);
			}
	
		}
		CloseHandle(hInFile);
		cInFile++;
	}
//=========================================

	WriteLineToFile(hOutFile, "}");	
	WriteLineToFile(hOutFile, "//****************************************************************************************");
	WriteLineToFile(hOutFile, "// End of MAKEODL generated file");
	WriteLineToFile(hOutFile, "//****************************************************************************************");

	CloseHandle(hOutFile);	
	return 0;
}


BOOL ReadLineFromFile(HANDLE hFile, char* szBuffer, int cchBufSize, int* iBytesRead)
{
	DWORD dwBytesRead;
	int cch=0;
	char ch;
	
	if (!hFile)
		return FALSE;

	while ( ReadFile(hFile, &ch, sizeof(char), &dwBytesRead, NULL) && dwBytesRead && (cch < cchBufSize))
	{
		*iBytesRead = dwBytesRead;
		if (ch == '\r')
		{
			szBuffer[cch] = '\0';			
			cch=0;
			return TRUE;
		}
		else if (ch == '\n')
		{
		}
		else
		{
			szBuffer[cch] = ch;
			cch++;
		}
	}
	return FALSE;
}

BOOL WriteLineToFile(HANDLE hFile, char* szBuffer)
{
	DWORD cchWritten;
	if (!WriteFile(hFile, szBuffer, lstrlenA(szBuffer), &cchWritten, NULL) || (lstrlenA(szBuffer) != cchWritten))
		return FALSE;
	if (!WriteFile(hFile, "\r\n", 2, &cchWritten, NULL) || (2 != cchWritten))
		return FALSE;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\action.cpp ===
/* action.cpp - action and message processing
   Copyright  1997 - 1999 Microsoft Corporation
____________________________________________________________________________*/

#include "precomp.h"
#include "_engine.h"
#include "_msiutil.h"  // CreateAndRunEngine
#include "_msinst.h"
#include "_srcmgmt.h"
#include "_camgr.h"
#include "resource.h"
#include "eventlog.h"
#include "version.h"  // rmj, rmm, rup, rin
#include "imagehlp.h"
#include "_autoapi.h"
#define _ACTION_CPP
#include "_service.h"

#define MsiHiddenWindowClass            TEXT("MsiHiddenWindow")

const GUID IID_IMsiHandler      = GUID_IID_IMsiHandler;
#ifdef DEBUG
const GUID IID_IMsiHandlerDebug = GUID_IID_IMsiHandlerDebug;
#endif //DEBUG


const int iDebugLogMessage = WM_USER+123;

int g_cFlushLines = 0;
CRITICAL_SECTION  g_csWriteLog;      // serialization of writes to the log file

class CMsiConfigurationManager;
extern iesEnum InstallFinalize(iesEnum iesState, CMsiConfigurationManager& riConman, IMsiMessage& riMessage, boolean fUserChangedDuringInstall);
extern Bool IsTerminalServerInstalled();

// global functions callable from services and engine
bool   CreateLog(const ICHAR* szFile, bool fAppend);
bool   LoggingEnabled();
bool   WriteLog(const ICHAR* szText);
void   HandleOutOfMemory();  // global function called by memory manager
void   MsiDisableTimeout()      { g_MessageContext.DisableTimeout(); }
void   MsiEnableTimeout()       { g_MessageContext.EnableTimeout(); }
void   MsiSuppressTimeout()     { g_MessageContext.SuppressTimeout(); }
HANDLE GetUserToken()           { return g_MessageContext.GetUserToken();}

// local functions defined in this module
UINT CloseMsiHandle(MSIHANDLE hAny, DWORD dwThreadId);
HINSTANCE MsiLoadLibrary(const ICHAR* szModuleName, Bool fDataOnly = fFalse);
bool LogRecord(IMsiRecord& riRecord);
void CopyStreamToString(IMsiStream& riStream, const IMsiString*& rpistrData); // assume file has ANSI data

typedef DWORD   (__stdcall *PThreadEntry)(void*);


//____________________________________________________________________________
//
// CBasicUI definition - internal default message handler, static non-COM object
//____________________________________________________________________________

const int cchMaxCaption       = 255;

class CBasicUI
{
 public:  // external methods
	imsEnum  Message(imtEnum imt, IMsiRecord& riRecord);
	imsEnum  FatalError(imtEnum imt, const ICHAR* szMessage);
	void     SetUserCancel(bool fCancel);
	bool     Initialize(HWND hwndParent, bool fQuiet, bool fHideDialog,
							bool fNoModalDialogs, bool fHideCancel, bool fUseUninstallBannerText, 
							bool fSourceResOnly);
	bool     Terminate();
	bool     IsInitialized();
	bool     SetCancelButtonText();
	bool     Quiet();
	bool     SourceResolutionDialogOnly();
	const ICHAR* GetCaption();
	void     SetDefaultCaption();
	HWND     GetWindow() { return m_hProgress ? m_hProgress : m_hwndParent; }
	LANGID   GetPackageLanguage();
	UINT     GetPackageCodepage();
	bool     Mirrored(UINT uiCodepage);
 private: // internal methods
	bool     CheckDialog();
	bool     CreateProgressDialog(int idDlg);
	imsEnum  SetProgressData(int iControl, const ICHAR* szData, bool fCheckDialog);
	imsEnum  SetProgressGauge(int iControl, int cSoFar, int cTotal);
	imsEnum  SetProgressTimeRemaining(IMsiRecord& riRecord);
	imsEnum  SetScriptInProgress(Bool fSet);
	imsEnum  FilesInUseDialog(IMsiRecord* piRecord);
 public:
	CBasicUI();
 protected:
	HFONT    m_hButtonFont;     // non-zero if font created
	UINT     m_iButtonCodepage; // codepage of last button font update
	HFONT    m_hTextFont;       // non-zero if font created
	UINT     m_iTextCodepage;   // codepage of last text font update
	UINT     m_iPackageLanguage; // lauguage of database strings
	UINT     m_iPackageCodepage; // codepage of database strings
 private:
	bool     m_fInitialized;
	bool     m_fProgressByData;
	int      m_iPerTick;
	int      m_iProgress;
	int      m_iProgressTotal;
	unsigned int m_uiStartTime;
	unsigned int m_uiLastReportTime;
	ICHAR    m_szCaption[cchMaxCaption+1];
	bool     m_fCaptionChanged;
	bool     m_fUserCancel; // the user hit the Cancel button on the minimal UI
	bool     m_fCancelVisible;
	bool     m_fNeverShowCancel;
	bool     m_fWindowVisible;
	bool     m_fQuiet;
	bool     m_fSourceResolutionOnly;
	bool     m_fHideDialog;
	bool     m_fNoModalDialogs;
	bool     m_fBiDi;      // right-to-left language, Arabic or Hebrew
	bool     m_fMirrored;  // mirroring change (only happens on Win2K and above, mirroring occurs with RTL languages)
	UINT     m_uiBannerText; // banner text for "preparing to <install|remove>..."
	HWND     m_hwndParent;
	HWND     m_hProgress;  // progress dialog handle
	int              m_cSoFarPrev;
	int              m_cTotalPrev;
	ProgressData::ipdEnum m_ipdDirection;
	ProgressData::ietEnum  m_ietEventType;
	IMsiRecord* m_piFilesInUseRecord;
};
inline bool CBasicUI::IsInitialized() {return m_fInitialized;}
inline bool CBasicUI::Quiet() {return m_fQuiet;}
inline bool CBasicUI::SourceResolutionDialogOnly() {return m_fSourceResolutionOnly;}
inline LANGID CBasicUI::GetPackageLanguage() {return (LANGID)m_iPackageLanguage;}
inline UINT   CBasicUI::GetPackageCodepage() {return m_iPackageCodepage;}

//____________________________________________________________________________
//
// CFilesInUseDialog definition
//____________________________________________________________________________

class CFilesInUseDialog : public CMsiMessageBox
{
 public:
	CFilesInUseDialog(const ICHAR* szMessage, const ICHAR* szCaption, IMsiRecord& m_riFileList);
   ~CFilesInUseDialog();
 private:
	bool InitSpecial();
	IMsiRecord&   m_riFileList;
	HFONT         m_hfontList;
};

//____________________________________________________________________________
//
// Message dispatching and processing, external to engine
//____________________________________________________________________________

// messages logged before UI called
const int iPreLogMask  = 1 << (imtInfo           >> imtShiftCount)
							  | 1 << (imtFatalExit      >> imtShiftCount)
							  | 1 << (imtActionStart    >> imtShiftCount)
							  | 1 << (imtActionData     >> imtShiftCount)
							  | 1 << (imtActionData     >> imtShiftCount);

// messages logged after UI called
const int iPostLogMask = 1 << (imtWarning        >> imtShiftCount)
							  | 1 << (imtError          >> imtShiftCount)
							  | 1 << (imtUser           >> imtShiftCount)
							  | 1 << (imtOutOfDiskSpace >> imtShiftCount);

// messages never sent to UI
const int iNoUIMask    = 1 << (imtInfo           >> imtShiftCount);

// messages requiring format string
const int iFormatMask  = 1 << (imtActionStart    >> imtShiftCount)
							  | 1 << (imtActionData     >> imtShiftCount);

// messages written to log
const int iLogMessages     = (1<<(imtFatalExit     >>imtShiftCount))
									+ (1<<(imtError         >>imtShiftCount))
									+ (1<<(imtWarning       >>imtShiftCount))
									+ (1<<(imtUser          >>imtShiftCount))
									+ (1<<(imtInfo          >>imtShiftCount))
									+ (1<<(imtCommonData    >>imtShiftCount))
									+ (1<<(imtActionStart   >>imtShiftCount))
									+ (1<<(imtActionData    >>imtShiftCount))
									+ (1<<(imtOutOfDiskSpace>>imtShiftCount));
									//  no imtProgress

// messages handled by dispatcher, all except for internal functions
const int iDispatchMessages= (1<<(imtFatalExit     >>imtShiftCount))
									+ (1<<(imtError         >>imtShiftCount))
									+ (1<<(imtWarning       >>imtShiftCount))
									+ (1<<(imtUser          >>imtShiftCount))
									+ (1<<(imtInfo          >>imtShiftCount))
									+ (1<<(imtFilesInUse    >>imtShiftCount))
									+ (1<<(imtCommonData    >>imtShiftCount))
									+ (1<<(imtActionStart   >>imtShiftCount))
									+ (1<<(imtActionData    >>imtShiftCount))
									+ (1<<(imtOutOfDiskSpace>>imtShiftCount))
									+ (1<<(imtProgress      >>imtShiftCount))
									+ (1<<(imtResolveSource >>imtShiftCount))
									+ (1<<(imtCustomServiceToClient >>imtShiftCount));

// messages which can set the cancel state
const int iSetCancelState  = (1<<(imtActionStart   >>imtShiftCount))
									+ (1<<(imtActionData    >>imtShiftCount))
									+ (1<<(imtProgress      >>imtShiftCount));

// messages which can reset the cancel state
const int iResetCancelState= (1<<(imtFatalExit     >>imtShiftCount))
									+ (1<<(imtError         >>imtShiftCount))
									+ (1<<(imtWarning       >>imtShiftCount))
									+ (1<<(imtUser          >>imtShiftCount))
									+ (1<<(imtFilesInUse    >>imtShiftCount))
									+ (1<<(imtOutOfDiskSpace>>imtShiftCount))
									+ (1<<(imtResolveSource >>imtShiftCount));

// message type codes used by fatal error messages, must all be unique, used to retrieve text

const int imtFatalOutOfMemory = imtInternalExit + imtOk + imtDefault1 + imtIconWarning;
const int imtFatalTimedOut    = imtInternalExit + imtRetryCancel + imtDefault2 + imtIconQuestion;
const int imtFatalException   = imtInternalExit + imtOk + imtDefault1 + imtIconError;
const int imtExceptionInfo    = imtInternalExit + imtOk + imtDefault1 + imtIconInfo;
const int imtDumpProperties   = imtInternalExit + imtYesNo;
const int imtExitThread       = imtInternalExit + imtRetryCancel + imtDefault2 + imtIconWarning;

const int imtForceLogInfo     = imtInfo + imtIconError;
const int iLogPropertyDump = (1 << (imtProgress>>imtShiftCount)); // no log progress info, use bit for property dump

// global, per-process  message handling objects
CBasicUI              g_BasicUI;         // simple UI handler
MsiUIMessageContext   g_MessageContext;  // message dispatcher/processor
extern IMsiRecord*    g_piNullRecord;
extern CMsiAPIMessage g_message;         // external UI handling/configuration
extern Bool    g_fLogAppend;
extern bool    g_fFlushEachLine;
CAPITempBuffer<ICHAR, 64>  g_szTimeRemaining;
CAPITempBuffer<ICHAR, 256> g_szFatalOutOfMemory;
CAPITempBuffer<ICHAR, 256> g_szFatalTimedOut;
CAPITempBuffer<ICHAR, 128> g_szFatalException;
CAPITempBuffer<ICHAR, 128> g_szBannerText;
CAPITempBuffer<ICHAR, 128> g_szScriptInProgress;
CAPITempBuffer<WCHAR, 1> g_rgchEnvironment;

extern CRITICAL_SECTION vcsHeap;
CActionThreadData* g_pActionThreadHead = 0;  // linked list of custom action threads

const int iWaitTick    = 50;  // event loop wait before UI refresh, in msec
const int cRetryLimit  = 10;  // number of timeout retries in quiet mode
int g_cWaitTimeout     =  0;  // default value is 20*iDefaultWaitTimeoutPolicy in msinst.cpp

CRITICAL_SECTION CProductContextCache::g_csCacheCriticalSection;
CAPITempBuffer<sProductContext ,20> CProductContextCache::g_rgProductContext;
int CProductContextCache::g_cProductCacheCount = 0;
#ifdef DEBUG
bool CProductContextCache::g_fInitialized = false;
#endif



IMsiRecord* MsiUIMessageContext::GetNoDataRecord()
{
	if (!m_pirecNoData)  // must delay creation until after allocator initialized
		m_pirecNoData = &ENG::CreateRecord(0);
	return m_pirecNoData;
}

//!! temp routine to determine if debugger is running the process, until we figure out how to do it right
bool IsDebuggerRunning()
{
	static int fDebuggerPresent = 2;
	if (g_fWin9X)
		return false;  // how do we tell?
	if (fDebuggerPresent == 2)
	{
		fDebuggerPresent = false;
		HINSTANCE hLib = WIN::LoadLibrary(TEXT("KERNEL32"));
		FARPROC pfEntry = WIN::GetProcAddress(hLib, "IsDebuggerPresent");  // NT only
		if (pfEntry)
			fDebuggerPresent = (int)(INT_PTR)(*pfEntry)();                  //--merced: added (INT_PTR)
	}
	return *(bool*)&fDebuggerPresent;
}

void  HandleOutOfMemory()  // global function called by memory manager
{
	imsEnum ims = g_MessageContext.Invoke(imtEnum(imtFatalOutOfMemory), 0);
	// extremely small window where this could possibly get blocked by EnterCriticalSection?
	if (ims == imsNone)
		RaiseException(STATUS_NO_MEMORY, EXCEPTION_NONCONTINUABLE, 0, NULL);
	return;
}

imsEnum MsiUIMessageContext::Invoke(imtEnum imt, IMsiRecord* piRecord)  // no memory allocation in this function!
{
	if(!IsInitialized())
		return imsNone;

	if (GetTestFlag('T'))
		return ProcessMessage(imt, piRecord);
	DWORD dwCurrentThread = MsiGetCurrentThreadId();
	if (dwCurrentThread == m_tidUIHandler)  //  calling from UI thread, allowed reentrancy, already in critical section
	{
		// However, progress messages from the UI thread are not allowed
		if (imtEnum(imt & ~(iInternalFlags)) == imtProgress)
			return imsNone;
		return ProcessMessage(imt, piRecord);
	}
	else if (MsiGetCurrentThreadId() == m_tidDisableMessages) // we're disabling messages for this thread; don't process this message
		return imsNone;

	WIN::EnterCriticalSection(&m_csDispatch);
	imsEnum imsReturn;
	if (m_pirecMessage)  m_pirecMessage->Release();  // should never happen
	m_imtMessage   = imt;
	if ((m_pirecMessage = piRecord) != 0) piRecord->AddRef();
	m_imsReturn    = imsInvalid;  // check for bogus event trigger
	WIN::SetEvent(m_hUIRequest);
	for (;;)   // event loop waiting on UI thread
	{
		DWORD dwWait = WIN::MsgWaitForMultipleObjects(1, &m_hUIReturn,
																	 FALSE, 30000, QS_ALLINPUT);
		if (dwWait == WAIT_OBJECT_0 + 1)  // window Msg
		{
			MSG msg;
			while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
			{
				if (!WIN::IsDialogMessage(GetCurrentWindow(), &msg))
				{
					WIN::TranslateMessage(&msg);
					WIN::DispatchMessage(&msg);
				}
			}
			continue;
		}
		if (dwWait == WAIT_FAILED)
		{
			AssertSz(0, "Wait Failed in Invoke");
			imsReturn = imsError;
			break;
		}
		if (dwWait == WAIT_TIMEOUT)
		{
			DEBUGMSGDO("Invoke wait timed out");
			continue;
		}
		if (m_imsReturn == imsInvalid || m_imsReturn == imsBusy)
		{
			DEBUGMSG("Invalid event trigger in Invoke"); //!!# temp for debug
			continue;
		}
		Assert(dwWait == WAIT_OBJECT_0);
		imsReturn = m_imsReturn;
		break;
	} // end event wait loop
	if (m_pirecMessage) m_pirecMessage->Release(), m_pirecMessage = 0;
	if (dwCurrentThread != m_tidUIHandler)
		WIN::LeaveCriticalSection(&m_csDispatch);
	return imsReturn;
}

HINSTANCE LoadSelfAgain(void)
{
	HINSTANCE hRet = NULL;
	ICHAR rgchBuf[MAX_PATH];
	
	// GetModuleFileName does not guarantee null termination if buffer is exactly the right size
	int cchName = GetModuleFileName(g_hInstance, rgchBuf, ARRAY_ELEMENTS(rgchBuf)-1);
	if (cchName == 0)
		return NULL;
	rgchBuf[ARRAY_ELEMENTS(rgchBuf)-1] = 0;
	hRet = LoadLibrary(rgchBuf);

	return hRet;
}

/*static*/ DWORD WINAPI MsiUIMessageContext::ChildUIThread(MsiUIMessageContext* This)  // runs only in UI thread
{
	if (This->m_iuiLevel == iuiNextEnum)  // UIPreview, FullUI, no Basic UI
		This->m_iuiLevel = iuiFull;     // must do this in UI thread
	else
	{
		bool fQuiet =  This->m_iuiLevel == iuiNone ||
							This->m_iuiLevel == iuiDefault;

		if(!g_BasicUI.Initialize(g_message.m_hwnd, fQuiet, This->m_fHideBasicUI,
										 This->m_fNoModalDialogs, This->m_fHideCancel, This->m_fUseUninstallBannerText,
										 This->m_fSourceResolutionOnly))
		{
			return ERROR_CREATE_FAILED; //!! what error?
		}
	}

	// initialize OLE on this thread
	if (false == This->m_fChildUIOleInitialized && SUCCEEDED(OLE32::CoInitialize(0)))
	{
		This->m_fChildUIOleInitialized = true;
	}

	HINSTANCE hSelf = LoadSelfAgain();
	DWORD dwReturn = NOERROR;
	int cTicks = 0;
	bool fContinue = true;
	while(fContinue)  // thread loops until main thread exits
	{
		DWORD dwWait = WAIT_FAILED;
		if ( This->m_hMainThread )
			dwWait = WIN::WaitForMultipleObjects(2, &This->m_hUIRequest, FALSE/*fWaitAll*/, iWaitTick);
		else
			dwWait = WIN::WaitForSingleObject(This->m_hUIRequest, iWaitTick);
		
		if (dwWait == WAIT_FAILED)
		{
			ICHAR rgchBuffer[MAX_PATH];
			dwReturn = WIN::GetLastError();
			StringCbPrintf(rgchBuffer, sizeof(rgchBuffer), TEXT("Wait Failed in ChildUIThread. GetLastError returned %d."), dwReturn);
			AssertSz(0, rgchBuffer);
			fContinue = false;
			continue;
		}
		if (dwWait == WAIT_TIMEOUT)  // main engine thread is hung
		{
			if (This->m_piClientMessage == 0)  // not remote UI
				This->ProcessMessage(imtProgress, g_piNullRecord);  // refresh UI
			if (This->m_cTimeoutDisable != 0)
				continue;
			if (++cTicks < g_cWaitTimeout)
				continue;
			DEBUGMSG("ChildUIThread wait timed out");
			//!! should we do anything here, as main thread is calling thread?
			cTicks = 0;
			continue;
		}
		if (dwWait == WAIT_OBJECT_0 + 1)
		{
			// main engine thread became signaled
			DWORD dwExitCode;
			if ( WIN::GetExitCodeThread(This->m_hMainThread, &dwExitCode) )
			{
				if ( dwExitCode != STILL_ACTIVE )
				{
					// the main engine thread is gone
					DEBUGMSG(TEXT("hMainThread is gone. ChildUIThread will finish as well."));
					fContinue = false;
				}
			}
			else
				DEBUGMSG1(TEXT("GetExitCodeThread returned %d in MsiUIMessageContext::ChildUIThread"),
							 (const ICHAR*)(INT_PTR)WIN::GetLastError());
			continue;
		}
		Assert(dwWait == WAIT_OBJECT_0);
		cTicks = 0;

		// else we were signaled with a message request
		if (This->m_imtMessage == imtInvalid)
		{
			DEBUGMSG("Invalid event trigger in ChildUIThread"); //!!# temp for debug
			continue;
		}
		else if(This->m_imtMessage == imtExitThread)
		{
			if(g_BasicUI.IsInitialized())
				g_BasicUI.Terminate();

			// uninitialize COM if necessary
			if (true == This->m_fChildUIOleInitialized)
			{
				OLE32::CoUninitialize();
				This->m_fChildUIOleInitialized = false;
			}

			This->m_imsReturn = imsNone;
			fContinue = false; // end of thread
		}
		else
		{
			Assert(!This->m_piClientMessage); // only here if called through MsiOpenProduct/Package
			This->m_imsReturn = imsBusy;      // to indicate processing in UI thread
			This->m_imsReturn = This->ProcessMessage(This->m_imtMessage,
														This->m_pirecMessage);
			This->m_imtMessage = imtInvalid;  // to detect invalid event triggers
		}
		WIN::SetEvent(This->m_hUIReturn);
	} // end message wait/process loop
	
	WIN::FreeLibraryAndExitThread(hSelf, dwReturn);
}


// Message processing and routing to external UI, handler, basic UI, and log
// Only called within UI thread, reentrant only for calls from the UI handler
// Due to reentrancy (from UI thread), m_imtMessage, m_piMessage, and m_imsReturn are be accessed
unsigned int SerializeStringIntoRecordStream(ICHAR* szString, ICHAR* rgchBuf, int cchBuf);

void GetWindowTitles(IMsiRecord *pInRecord, IMsiRecord **ppOutRecord);

imsEnum MsiUIMessageContext::ProcessMessage(imtEnum imt, IMsiRecord* piRecord)
{
	int iSuppressLog = imt & imtSuppressLog;
	int iForceQuietMessage = imt & imtForceQuietMessage;
	imt = imtEnum(imt & ~(iInternalFlags));
	imsEnum imsReturn = imsNone;
	int imsg = (unsigned)imt >> imtShiftCount;  // message header message
	int fMask = 1 << imsg;
	PMsiRecord pFilesInUse = NULL;

	if (fMask & iDispatchMessages)  // messages for UI and/or Log
	{
		if (m_fCancelPending && (fMask & iResetCancelState)) // cancel button pushed before modal dialog
		{
			m_fCancelPending = false;
			if (imt & 1)  // MB_OKCANCEL, MB_YESNOCANCEL, MB_RETRYCANCEL have low bit set, no others do
				return imsCancel;  // caller expected to process since cancel button appears
		}

		if (!piRecord)
			piRecord = GetNoDataRecord();  // dummy record in case none passed in

		if (m_piClientMessage)   // running on server, must forward messages to client
		{
			return m_piClientMessage->Message(imtEnum(imt|iForceQuietMessage), *piRecord);
		}
		else	// Running on client
		{
			Assert(scClient == g_scServerContext);
			if(imt == imtFilesInUse)
			{
				GetWindowTitles(piRecord, &pFilesInUse);	
				if (!pFilesInUse)
				{
					DEBUGMSG(TEXT("Window with Title could not be found for any of the Files-In-Use"));
					return imsNone;
				}
				else
				{
					piRecord = pFilesInUse;
				}
			}
			else if (imsg == imtCustomServiceToClient >> imtShiftCount)
			{
				imsReturn = imsNone;
#ifdef DEBUG
				CTempBuffer<ICHAR, 1> rgchAssert;
				*rgchAssert = 0;
#endif // DEBUG
				switch (piRecord->GetInteger(1))
				{
				case istcSHChangeNotify:
						if (piRecord->GetInteger(2) == SHCNE_EXTENDED_EVENT)
						{
							if (piRecord->GetFieldCount() == istcfSHChangeNotify)
							{
								SHChangeProductKeyAsIDList pkidl;
								SHChangeDWORDAsIDList dwidl;
								PMsiStream pFirstStream = (IMsiStream*)piRecord->GetMsiData(4);
								PMsiStream pSecondStream = (IMsiStream*)piRecord->GetMsiData(5);
								bool fError = false;
								if (!pFirstStream ||
									 pFirstStream->GetData((LPVOID)&pkidl, sizeof(pkidl)) != sizeof(pkidl))
								{
									Assert(0);
									fError = true;
								}
								if (!pSecondStream ||
									 pSecondStream->GetData((LPVOID)&dwidl, sizeof(dwidl)) != sizeof(dwidl))
								{
									Assert(0);
									fError = true;
								}
								if (!fError)
								{
									SHELL32::SHChangeNotify((LONG)piRecord->GetInteger(2),
																	(UINT)piRecord->GetInteger(3),
																	(LPCITEMIDLIST)&dwidl,
																	(LPCITEMIDLIST)&pkidl);
									imsReturn = imsOk;
								}
								else
									imsReturn = imsError;
							}
							else
							{
#ifdef DEBUG
								rgchAssert.Resize(256);
								StringCchPrintf(rgchAssert, rgchAssert.GetSize(),
													 TEXT("%u is an invalid number of fields for istcSHChangeNotify."),
													 piRecord->GetFieldCount());
#endif // DEBUG
								imsReturn = imsError;
							}
						}
						else
						{
							// for most of the calls the last two fields are null, so the
							// record gets passed over with less fields than istcfSHChangeNotify.
							SHELL32::SHChangeNotify((LONG)piRecord->GetInteger(2),
															(UINT)piRecord->GetInteger(3),
															(LPCVOID)piRecord->GetString(4),
															(LPCVOID)piRecord->GetString(5));
							imsReturn = imsOk;
						}
					break;
				default:
#ifdef DEBUG
					rgchAssert.Resize(256);
					StringCchPrintf(rgchAssert, rgchAssert.GetSize(),
										 TEXT("%s is an invalid selector for an imtCustomServiceToClient message."),
										 piRecord->GetString(0));
#endif // DEBUG
					imsReturn = imsError;
					break;
				}
#ifdef DEBUG
				if (*rgchAssert)
					AssertSz(0, rgchAssert);
#endif // DEBUG
				return imsReturn;
			}
		}

		if(iForceQuietMessage)
		{
			if(m_iuiLevel == iuiNone || m_iuiLevel == iuiBasic)
				return g_BasicUI.Message(imtEnum(imt|imtForceQuietMessage), *piRecord);
			else
				return imsNone;
		}

		if((imsg == (imtError >> imtShiftCount) || imsg == (imtWarning >> imtShiftCount))
			 && LoggingEnabled() == false)
		{
			// error or warning and no log - create a log on the fly
			InitializeLog(true); // ignore error
		}

		if ((iPreLogMask & fMask) && !iSuppressLog)  //!!?  && !piRecord->IsNull(0))
		{
			if ((g_dwLogMode & fMask) || (imt == imtForceLogInfo))
				ENG::LogRecord(*piRecord);
		}

		if ((g_message.m_iMessageFilter & fMask) && !((fMask & iFormatMask) && piRecord->IsNull(0)))
		{
			imsReturn = g_message.Message(imt, *piRecord);
		}

		if ((((!g_BasicUI.Quiet() && imsReturn == imsNone) || imsg == (imtCommonData >> imtShiftCount))  // external UI handled it, or it's CommonData
			|| (g_BasicUI.SourceResolutionDialogOnly() && (imsg == (imtResolveSource >> imtShiftCount)) && (imsReturn == imsNone))) // or resolve source and the sourceresonly flag
		 && !((fMask & iFormatMask) && piRecord->IsNull(0))) // missing required format template
		{
			if (m_piHandler)
				imsReturn = m_piHandler->Message(imt, *piRecord);

			if (imsReturn == imsNone || imsg == (imtCommonData >> imtShiftCount)) // always send CommonData to BasicUI
				imsReturn = g_BasicUI.Message(imt, *piRecord);
		}

		if ((iPostLogMask & fMask & g_dwLogMode) && !iSuppressLog)  //!!?  && !piRecord->IsNull(0))
		{
			ENG::LogRecord(*piRecord);
		}
		if (fMask & iSetCancelState)  // progress notification - process cancel state
		{
			if (m_fCancelPending)
				imsReturn = imsCancel, m_fCancelPending = false;  // return and clear cached cancel
#ifdef DEBUG
			if (imsReturn == imsCancel && piRecord != g_piNullRecord)
				m_fCancelReturned = true;  // save for possible assert at exit
#endif
		}  // if called from UI timer, m_fCancelPending will immediately get set again
	}
	else if (m_piClientMessage)   // running on server, must forward requests to client
	{
		switch(imsg)
		{
		case imtInternalExit   >> imtShiftCount:  // can't use allocated memory here
			switch (imt)
			{
			case imtExceptionInfo:
				{
					CTempBuffer<ICHAR,1> rgchSerializedRecord(ARRAY_ELEMENTS(m_rgchExceptionInfo));
					unsigned int cchExceptionInfo = SerializeStringIntoRecordStream(m_rgchExceptionInfo, rgchSerializedRecord, rgchSerializedRecord.GetSize());
					m_rgchExceptionInfo[0] = 0; // reset string to empty
					if (cchExceptionInfo)
					{
						HRESULT hres = IMsiMessage_MessageRemote_Proxy(m_piClientMessage, imt, cchExceptionInfo*sizeof(ICHAR), (char*)static_cast<ICHAR*>(rgchSerializedRecord), &imsReturn);
						if (FAILED(hres))
							return imsError;
					}
				}
				return imsReturn; //?? OK to return here?
			default:
				return m_piClientMessage->MessageNoRecord(imt);
			}
			break;
		case imtLoadHandler   >> imtShiftCount:
		case imtFreeHandler   >> imtShiftCount:
		case imtUpgradeRemoveScriptInProgress >> imtShiftCount:
		case imtUpgradeRemoveTimeRemaining    >> imtShiftCount:
			return imsNone;
		case imtShowDialog    >> imtShiftCount:
		case imtOutOfMemory   >> imtShiftCount:
		case imtTimeRemaining >> imtShiftCount:
		case imtScriptInProgress >> imtShiftCount:
		case imtTimedOut      >> imtShiftCount:
		case imtException     >> imtShiftCount:
		case imtBannerText    >> imtShiftCount:
			piRecord = GetNoDataRecord();
			piRecord->SetMsiString(0, *MsiString(m_szAction));  // not ref string, may be cached by record streamer
			break;
		default: AssertSz(0, "Unexpected message type in ProcessMessage");
		} // end switch(imsg)
		imsReturn = m_piClientMessage->Message(imt, *piRecord);
		piRecord->SetNull(0);
		m_szAction = 0;
	}
	else // function that must be called from this thread, piRecord not used
	{
		switch(imsg)
		{
		case imtInternalExit   >> imtShiftCount:
		{
			const ICHAR* szFatalError = TEXT("");
			switch(imt) // called locally from HandleOutOfMemory or event loop
			{
			// dump properties if logging or externalUI is available and interested
			case imtDumpProperties:     return ((g_dwLogMode & iLogPropertyDump)
											    || (g_message.m_iMessageFilter & (1<<( imtInfo>>imtShiftCount)) )) ? imsYes : imsNo;
			case imtFatalOutOfMemory: szFatalError = g_szFatalOutOfMemory; break;
			case imtFatalTimedOut:    szFatalError = g_szFatalTimedOut;    break;
			case imtFatalException:   szFatalError = g_szFatalException;   break;
			case imtExceptionInfo:
				if (*m_rgchExceptionInfo)
					szFatalError = m_rgchExceptionInfo;
				else if (m_szAction)
					szFatalError = m_szAction;
				break;
			}
			if (*szFatalError == 0)  // crash before initialization or coding error, should not happen unless debugging
				szFatalError = (imt == imtFatalTimedOut) ? TEXT("Install server not responding")
																	  : TEXT("Unexpected Termination");
			if (g_message.m_iMessageFilter & fMask)
				imsReturn = g_message.Message(imt, szFatalError);
			if ((1<<(imtFatalExit>>imtShiftCount)) & g_dwLogMode)
			{
				if (ENG::LoggingEnabled())
					ENG::WriteLog(szFatalError); //!! need to enable log if not already
			}
			if (imt == imtFatalTimedOut && g_BasicUI.Quiet() && ++m_iTimeoutRetry <= cRetryLimit)
					return imsRetry;   // allow retries if quiet mode
#ifdef DEBUG
			if (imsReturn == imsNone && !g_BasicUI.Quiet())
#else // SHIP
			if (imt != imtExceptionInfo && imsReturn == imsNone && !g_BasicUI.Quiet()) // don't display exception info in SHIP build
#endif
				imsReturn = g_BasicUI.FatalError(imt, szFatalError);
			return imsReturn;
		}

		case imtLoadHandler   >> imtShiftCount:
		{
			IMsiHandler* piHandler = 0;
#ifdef DEBUG
			const GUID& riid = IID_IMsiHandlerDebug;
#else
			const GUID& riid = IID_IMsiHandler;
#endif
			m_hinstHandler = ENG::MsiLoadLibrary(MSI_HANDLER_NAME);
			PDllGetClassObject fpFactory = (PDllGetClassObject)WIN::GetProcAddress(m_hinstHandler, SzDllGetClassObject);
			IClassFactory* piClassFactory;
			if (fpFactory && (*fpFactory)(riid, IID_IUnknown, (void**)&piClassFactory) == NOERROR)
			{
				piClassFactory->CreateInstance(0, riid, (void**)&piHandler);
				piClassFactory->Release();
			}
			if (!piHandler)
				return imsNone;
			Assert(m_piEngine);
			bool fMissingTables = false;
			Bool fHandlerOk = piHandler->Initialize(*m_piEngine, m_iuiLevel, g_message.m_hwnd, fMissingTables);
			m_piEngine = 0;  // temp for transfer only
			if (!fHandlerOk)
			{
				piHandler->Release(), piHandler = 0;

				if (fMissingTables) // if the initialization failed because of missing tables then we'll ignore the failure
					return imsOk;
				else
					return imsNone;
			}

			PMsiRecord pHideDialog(&CreateRecord(1));
			pHideDialog->SetInteger(1, icmtDialogHide);
			g_BasicUI.Message(imtCommonData, *pHideDialog);

			m_piHandler = piHandler;
			return imsOk;
		}
		case imtFreeHandler   >> imtShiftCount:
			if(m_piHandler)
			{
				m_piHandler->Terminate();   // break circular reference
				m_piHandler->Release();
				m_piHandler = 0;
			}
			return imsOk;
		case imtShowDialog    >> imtShiftCount:
			if (!m_piHandler || !m_szAction) // shouldn't happen
				return imsNone;
			if (g_message.m_iMessageFilter & (1 << (imtShowDialog>>imtShiftCount)))
				imsReturn = g_message.Message(imtShowDialog, m_szAction);
			if (imsReturn == imsNone)
				imsReturn = (imsEnum)m_piHandler->DoAction(m_szAction);
			break;
		case imtTimeRemaining >> imtShiftCount:
			if ( ! g_szTimeRemaining.SetSize(IStrLen(m_szAction) + 1) )
				return imsError;
			if(m_szAction)
				StringCchCopy(g_szTimeRemaining, g_szTimeRemaining.GetSize(), m_szAction);
			else
				g_szTimeRemaining[0] = 0;
			break;
		case imtScriptInProgress >> imtShiftCount:
			if ( ! g_szScriptInProgress.SetSize(IStrLen(m_szAction) + 1) ) 
				return imsError;
			if(m_szAction)
				StringCchCopy(g_szScriptInProgress, g_szScriptInProgress.GetSize(), m_szAction);
			else
				g_szScriptInProgress[0] = 0;
			break;
		case imtOutOfMemory   >> imtShiftCount:
			if ( ! g_szFatalOutOfMemory.SetSize(IStrLen(m_szAction) + 1) )
				return imsError;
			if(m_szAction)
				StringCchCopy(g_szFatalOutOfMemory, g_szFatalOutOfMemory.GetSize(), m_szAction);
			else
				g_szFatalOutOfMemory[0] = 0;
			break;
		case imtTimedOut      >> imtShiftCount:
			if ( ! g_szFatalTimedOut.SetSize(IStrLen(m_szAction) + 1) )
				return imsError;
			if(m_szAction)
				StringCchCopy(g_szFatalTimedOut, g_szFatalTimedOut.GetSize(), m_szAction);
			else
				g_szFatalTimedOut[0] = 0;
			break;
		case imtException     >> imtShiftCount:
			if ( ! g_szFatalException.SetSize(IStrLen(m_szAction) + 1) )
				return imsError;
			if(m_szAction)
				StringCchCopy(g_szFatalException, g_szFatalException.GetSize(), m_szAction);
			else
				g_szFatalException[0] = 0;
			break;
		case imtBannerText    >> imtShiftCount:
		{
			if ( ! g_szBannerText.SetSize(IStrLen(m_szAction) + 1) )
				return imsError;
			if(m_szAction)
				StringCchCopy(g_szBannerText, g_szBannerText.GetSize(), m_szAction);
			else
				g_szBannerText[0] = 0;
			break;
		}
		case imtUpgradeRemoveScriptInProgress >> imtShiftCount:
		case imtUpgradeRemoveTimeRemaining    >> imtShiftCount:
			// these strings are not cached - they are just used to replace other strings during upgrade uninstalls
			break;
		default: AssertSz(0, "Unexpected message type in ProcessMessage");
		} // end switch(imsg)
		m_szAction = 0;
	}  // end if message | function
	return imsReturn;
}

bool LoadCurrentUserKey(bool fSystem = false)
{
	if (!RunningAsLocalSystem())
		return true;

	// Make sure HKEY_CURRENT_USER is closed before remapping it.

	if (ERROR_SUCCESS != RegCloseKey(HKEY_CURRENT_USER))
	{
		Assert(0);
		return false;
	}

	if (!fSystem)
		AssertNonZero(StartImpersonating());

	// Access the registry to force HKEY_CURRENT_USER to be re-opened

	CElevate elevate(fSystem); // ensure that we're not impersonate if fSystem is set
	RegEnumKey(HKEY_CURRENT_USER, 0, NULL, 0);

	if (!fSystem)
		StopImpersonating();

	return true;
}

bool MsiUIMessageContext::Terminate(bool fFatalExit)
{
        // We need to terminate the thread before terminating the handler so we don't try to poke the
        // handler while it's in the process of shutting down
        //
        // must call other thread to shut down while we are still "initialized"
        // since Invoke checks for m_fInitialized
        if (m_hUIThread)
        {
                if(m_fInitialized) //kill the other thread, the civilized way
                        Invoke(imtEnum(imtExitThread), 0), WIN::CloseHandle(m_hUIThread), m_hUIThread = 0;
                else // Invoke is a noop if not m_fInitialized, no option but to be brutal
                        WIN::TerminateThread(m_hUIThread, 0), WIN::CloseHandle(m_hUIThread), m_hUIThread = 0;
        }

	// uninitialize OLE if already initialized
	if (true == m_fOleInitialized)
	{
		OLE32::CoUninitialize();
		m_fOleInitialized = false;
	}

	m_fInitialized = false; // must be first, now that we have disposed off the other thread
	m_fOEMInstall = false;
	if ( m_hSfcHandle ) {SFC::SfcClose(m_hSfcHandle); m_hSfcHandle = NULL;}
	SFC::Unbind();

	if ( m_hSaferLevel )
	{
		ADVAPI32::SaferCloseLevel(m_hSaferLevel);
		m_hSaferLevel = 0;
	}

	g_szBannerText.Destroy();
	g_szScriptInProgress.Destroy();
	g_szTimeRemaining.Destroy();
	g_szFatalOutOfMemory.Destroy();
	g_szFatalTimedOut.Destroy();
	g_szFatalException.Destroy();
	KillHiddenWindow();
	m_rgchExceptionInfo[0] = 0;

	if (g_scServerContext == scService)
	{
		CProductContextCache::Reset(); // reset product context cache
	}


	if (m_piHandlerSave) m_piHandler=m_piHandlerSave;m_piHandlerSave = 0;
	if (!fFatalExit)  // avoid freeing of objects when allocator is gone
	{
		if (m_pirecMessage)  m_pirecMessage->Release(),  m_pirecMessage  = 0;
		if (m_pirecNoData)   m_pirecNoData->Release(),   m_pirecNoData   = 0;
	}
	else
	{
		m_pirecMessage = 0;
		m_pirecNoData = 0;
		g_piSharedDllsRegKey = 0;
#ifdef _WIN64
		g_piSharedDllsRegKey32 = 0;
#endif
	}

        if (m_piHandler) m_piHandler->Terminate(fFatalExit), m_piHandler->Release(), m_piHandler = 0;
        if (m_piClientMessage) m_piClientMessage->Release(), m_piClientMessage = 0;
//      if (m_piServerSecurity) m_piServerSecurity->Release(), m_piServerSecurity = 0;
	if (m_hMainThread)   WIN::CloseHandle(m_hMainThread), m_hMainThread = 0;
	m_cTimeoutDisable = 0;
	if (g_message.m_iMessageFilter & (1 << (imtFreeHandler>>imtShiftCount))) g_message.Message(imtFreeHandler, (const ICHAR*)0);
	if(g_BasicUI.IsInitialized()) g_BasicUI.Terminate();
	if (m_hinstHandler)  WIN::FreeLibrary(m_hinstHandler), m_hinstHandler = 0;
	m_iuiLevel = (iuiEnum)iuiDefault;
	if (!GetTestFlag('X'))
		WIN::SetUnhandledExceptionFilter(m_tlefOld);
	WIN::CloseHandle(m_hUIRequest), m_hUIRequest = 0;
	WIN::CloseHandle(m_hUIReturn),  m_hUIReturn  = 0;

	extern CMsiConfigurationManager* g_piConfigManager;

	//!!future Hack! The message context shouldn't be cleaning up stuff in the global config manager.
	if (g_scServerContext == scService && g_piConfigManager)
		((IMsiConfigurationManager *)g_piConfigManager)->ShutdownCustomActionServer();

	m_tidMainThread      = 0;
	m_tidUIHandler       = 0;
	m_tidDisableMessages = 0;
	m_fHideBasicUI       = false;
	m_fNoModalDialogs    = false;
	m_fHideCancel        = false;
	m_fSourceResolutionOnly = false;
	m_fUseUninstallBannerText = false;


	if (fFatalExit)
	{
		MsiCloseAllSysHandles();
		FreeMsiMalloc(fTrue);
		// Need to set system to powerdown state so we don't leave ourselves with a machine that
		// might not go to sleep
		KERNEL32::SetThreadExecutionState(0);

		extern IMsiServices* g_piSharedServices;
		//
		// Clear out the volume list, but don't actually free
		// the memory (we've done that already)
		//
		DestroyMsiVolumeList(fTrue);

		if (g_piSharedServices != 0)
		{
			g_piSharedServices = 0;
			IMsiServices* piServices = ENG::LoadServices();

			//
			// Change the services that the global config manager knows about
			//
			if (piServices && g_piConfigManager)
				((IMsiConfigurationManager *)g_piConfigManager)->ChangeServices(*piServices);
			else if (piServices)
			{
				// free services to prevent leak
				ENG::FreeServices();
			}
		}
		else
			Assert(g_piConfigManager == 0);

	}
	else
	{
		if (m_piServices)
			ENG::FreeServices(), m_piServices=0;
	}


	if (m_csDispatch.OwningThread != INVALID_HANDLE_VALUE)
	{
		WIN::DeleteCriticalSection(&m_csDispatch);
		m_csDispatch.OwningThread = INVALID_HANDLE_VALUE;
	}

	if (m_hLogFile)
	{
		if(FDiagnosticModeSet(dmVerboseLogging) &&
			g_scServerContext == scClient )
		{
			ICHAR rgchLog[100];
			StringCchPrintf(rgchLog, ARRAY_ELEMENTS(rgchLog), TEXT("=== Verbose logging stopped: %s  %s ===\r\n"),
						((const IMsiString&)g_MsiStringDate).GetString(), ((const IMsiString&)g_MsiStringTime).GetString());
			WriteLog(rgchLog);
		}
		if(m_fLoggingFromPolicy)
		{
			// logging was triggered by policy, so we need to clear the log settings so we don't use the
			// same log for the next install session
			g_szLogFile[0] = 0;
			g_dwLogMode = 0;
		}
		WIN::CloseHandle(m_hLogFile);
		m_hLogFile = 0;
		g_cFlushLines = 0;
	}

	if (g_csWriteLog.OwningThread != INVALID_HANDLE_VALUE)
	{
		WIN::DeleteCriticalSection(&g_csWriteLog);
		g_csWriteLog.OwningThread = INVALID_HANDLE_VALUE;
	}

	m_fLoggingFromPolicy = false;

	if (g_rgchEnvironment[0])
		AssertNonZero(RestoreEnvironmentVariables());

	g_rgchEnvironment.Destroy(); // must be done after RestoreEnvironmentVariables
	g_rgchEnvironment[0] = 0;
	m_fCancelPending = false;
#ifdef DEBUG
	m_fCancelReturned = false;
#endif
	if (g_scServerContext == scService)
		AssertNonZero(LoadCurrentUserKey(true));

	m_iBusyLock = 0;

	// resets the stores user token, needs to be the very last thing we do
	// any operations later on better not want to use the user token or classes
	// like the CElevate class that rely on the user token
	SetUserToken(true);

	return true;
}  // free library at final destruction to avoid loss of constant referenced strings

// runs only in the service and:
// - if fToSet is true, makes the service to appear busy (only if not already).
// - if fToSet is false, makes the service to appear free (only if busy).

// WARNING: the call with false argument must happen in the same function
//          that does the call with the true argument and only if that call
//          returned ERROR_SUCCESS.

UINT MsiUIMessageContext::SetServiceInstalling(boolean fToSet)
 {
	if ( g_scServerContext == scService )
	{
		if ( fToSet )
		{
			if(TestAndSet(&m_iBusyLock) == true)
			{
				DEBUGMSG(TEXT("Message context already initialized, returning ERROR_INSTALL_ALREADY_RUNNING"));
				return ERROR_INSTALL_ALREADY_RUNNING;
			}
		}
		else
		{
			if ( m_iBusyLock != 1 )
			{
				DEBUGMSG(TEXT("Message context has not been initialized, returning ERROR_INSTALL_FAILURE"));
				return ERROR_INSTALL_FAILURE;
			}
			m_iBusyLock = 0;
		}
	}
	return ERROR_SUCCESS;
}

/*static*/ DWORD WINAPI MsiUIMessageContext::MainEngineThread(LPVOID pInstallData)
{
	DISPLAYACCOUNTNAME(TEXT("Beginning of MainEngineThread"));

#ifdef DEBUG
	HANDLE hToken = 0;
	ICHAR szAccount[300] = {0};
	OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
	GETACCOUNTNAMEFROMTOKEN(hToken, szAccount, (sizeof(szAccount)/sizeof(ICHAR)));
	DEBUGMSGV1(TEXT("MainEngineThread: Process token is for: %s"), szAccount);
	WIN::CloseHandle(hToken);
#endif

	CMainThreadData* pThreadData = (CMainThreadData*)pInstallData;
	DWORD iReturn;
	if (pThreadData->m_ireProductSpec == ireInstallFinalize)
	{
		PMsiMessage pMessage = new CMsiClientMessage();
		iReturn = (int)InstallFinalize(((CInstallFinalizeMainThreadData*)pInstallData)->m_iesState,
												 *((CInstallFinalizeMainThreadData*)pInstallData)->m_piConman,
												 *pMessage, fFalse /*fUserChangedDuringInstall*/);
	}
	else
	{
		iReturn = ENG::CreateAndRunEngine(((CEngineMainThreadData*)pInstallData)->m_ireProductSpec,
														 ((CEngineMainThreadData*)pInstallData)->m_szProduct,
														 ((CEngineMainThreadData*)pInstallData)->m_szAction,
														 ((CEngineMainThreadData*)pInstallData)->m_szCmdLine, 0,
														 ((CEngineMainThreadData*)pInstallData)->m_iioOptions);
	}

	DEBUGMSG1(TEXT("MainEngineThread is returning %d"), (const ICHAR*)(INT_PTR)iReturn);
	WIN::ExitThread(iReturn);
	return iReturn;  // never gets here, needed to compile
}

//!! remove this function when callers changed to call RunInstall directly

UINT RunEngine(ireEnum ireProductSpec,   // type of string specifying product
			   const ICHAR* szProduct,      // required, matches ireProductSpec
			   const ICHAR* szAction,       // optional, engine defaults to "INSTALL"
			   const ICHAR* szCommandLine,  // optional command line
				iuiEnum      iuiLevel,
				iioEnum      iioOptions)    // installation options

{
	// load services, required for MsiString use
	IMsiServices* piServices = ENG::LoadServices();
	if (!piServices)
	{
		DEBUGMSG(TEXT("Unable to load services"));
		return ERROR_FUNCTION_FAILED; //??
	}
	
	// this if block also scopes the MsiString usage
	if(szCommandLine && *szCommandLine)
	{
		MsiString strRemove;
		ProcessCommandLine(szCommandLine, 0, 0, 0, 0, 0, MsiString(*IPROPNAME_FEATUREREMOVE), &strRemove, fTrue, 0, 0);

		if (strRemove.Compare(iscExactI, IPROPVALUE_FEATURE_ALL))
			iuiLevel = iuiEnum(iuiLevel | iuiUseUninstallBannerText);
	}
	
	ENG::FreeServices();
	
	CEngineMainThreadData threadData(ireProductSpec, szProduct, szAction, szCommandLine, iioOptions);

	UINT ui = g_MessageContext.RunInstall(threadData, iuiLevel, 0);
	Assert(ui != ERROR_INSTALL_REBOOT && ui != ERROR_INSTALL_REBOOT_NOW);
	DEBUGMSG1(TEXT("RunEngine is returning: %u"), (const ICHAR*)(INT_PTR)ui);
	return ui;
}

void SetEngineInitialImpersonationCount();

UINT MsiUIMessageContext::SetUserToken(bool fReset, DWORD dwPrivilegesMask)
{
	if (m_hUserToken)
		WIN::CloseHandle(m_hUserToken), m_hUserToken = 0;

	if (fReset)
	{
		return ERROR_SUCCESS;
	}
	else if (g_scServerContext == scService)
	{
		CComPointer<IServerSecurity> pServerSecurity(0);
		HRESULT hRes = OLE32::CoGetCallContext(IID_IServerSecurity, (void**)&pServerSecurity);
		if (ERROR_SUCCESS != hRes)
		{
			AssertSz(0, "CoGetCallContext failed");
			return ERROR_INSTALL_SERVICE_FAILURE;
		}
		if (ERROR_SUCCESS != pServerSecurity->ImpersonateClient())
		{
			AssertSz(0, "ImpersonateClient failed");
			return ERROR_INSTALL_SERVICE_FAILURE;
		}
		if (!WIN::OpenThreadToken(WIN::GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_ADJUST_PRIVILEGES, TRUE, &m_hUserToken))
		{
			AssertSz(0, "Failed to get user token");
			return ERROR_INSTALL_SERVICE_FAILURE;
		}
		if (MinimumPlatformWindows2000()) 
		{
			DisablePrivilegesFromMap(m_hUserToken, dwPrivilegesMask);
		}
		pServerSecurity->RevertToSelf();  //! do we need/want to do this here?
	}
	else if (g_scServerContext == scClient)
	{
		if (RunningAsLocalSystem())
		{
			// if this fails then we're not impersonating 
			if (!WIN::OpenThreadToken(WIN::GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE, TRUE, &m_hUserToken))
			{
				DEBUGMSGV1(TEXT("Failed to open thread token (error %d): we're not impersonated"), (const ICHAR*)(INT_PTR)GetLastError());
				m_hUserToken = 0;
			}
			else
			{
				DEBUGMSGV("Opened thread token: we're impersonated");
				SetEngineInitialImpersonationCount();
			}
		}
	}

	return ERROR_SUCCESS;
}

// Initializes UI in current thread, creates main engine in new thread, handles messages
UINT MsiUIMessageContext::RunInstall(CMainThreadData& riThreadData,
												 iuiEnum iuiLevel,
												 IMsiMessage* piClientMessage,// optional client message handler
												 DWORD dwPrivilegesMask)
{

	LPEXCEPTION_POINTERS lpExceptionInfo = 0;

	__try
	{
		UINT iStat = Initialize(fFalse, iuiLevel, dwPrivilegesMask);  // UI runs in current thread
		if (iStat != NOERROR)
			return iStat;

		Assert(m_iBusyLock);

		CHandle hExecute;
		if ( g_scServerContext == scService )
		{
			// just so the _MsiExecute mutex is present for the duration of
			// an installation, even if the client dies.
			HANDLE hMutex = NULL;
			if ( FMutexExists(szMsiExecuteMutex, hMutex) && hMutex != NULL )
			{
				DEBUGMSG(TEXT("Grabbed execution mutex."));
				hExecute = hMutex;
			}
			else
				DEBUGMSG(TEXT("Failed to grab execution mutex."));
		}

	#ifdef DEBUG
		if (m_hUserToken)
		{
			ICHAR szAccount[400] = TEXT("");
			GETACCOUNTNAMEFROMTOKEN(m_hUserToken, szAccount, (sizeof(szAccount)/sizeof(ICHAR)));
			DEBUGMSGV1(TEXT("m_hUserToken's account (in MsiUIMessageContext::RunInstall): %s"), szAccount);
		}
		else
		{
			DEBUGMSGV(TEXT("m_hUserToken's account (in MsiUIMessageContext::RunInstall): NULL"));
		}
	#endif

		if (piClientMessage)
		{
			Assert(g_scServerContext == scServer || g_scServerContext == scService);
			m_piClientMessage = piClientMessage;
			piClientMessage->AddRef();  //!! need this? lifetime only within function
		}

		if (GetTestFlag('T'))
		{
			int iReturn = ENG::CreateAndRunEngine(((CEngineMainThreadData&)riThreadData).m_ireProductSpec,
															  ((CEngineMainThreadData&)riThreadData).m_szProduct,
															  ((CEngineMainThreadData&)riThreadData).m_szAction,
															  ((CEngineMainThreadData&)riThreadData).m_szCmdLine, 0,
															  ((CEngineMainThreadData&)riThreadData).m_iioOptions);
			Terminate(false);
			return iReturn;
		}
		DWORD iReturn = ERROR_SUCCESS;
		m_hMainThread = WIN::CreateThread((LPSECURITY_ATTRIBUTES)0, 4096*10,
													MainEngineThread, (LPVOID)&riThreadData, 0, &m_tidMainThread);
		if (!m_hMainThread)
		{
			AssertSz(0, TEXT("CreateThread for main engine thread failed"));
			Terminate(fTrue);
			return ERROR_CREATE_FAILED; //!! need another error here?
		}

		int cTicks = 0;
		m_iTimeoutRetry = 0;
		for(;;)  // event thread loops until main thread exits
		{
			DWORD dwWait;

			// we need to process messages for the hidden RPC window so we'll
			// use MsgWait
			dwWait = WIN::MsgWaitForMultipleObjects(2, &m_hUIRequest, FALSE, iWaitTick, QS_ALLINPUT);

			if (dwWait == WAIT_FAILED)
			{
				AssertSz(0, "Wait Failed in RunEngine");
				iReturn = WIN::GetLastError();
				break;
			}
			if (dwWait == WAIT_TIMEOUT)  // main engine thread is busy
			{
				if (m_piClientMessage == 0)  // not remote UI
				{
					if (ProcessMessage(imtProgress, g_piNullRecord) == imsCancel)  // refresh UI
						m_fCancelPending = true; // cache message until next real message
				}
				if(m_cTimeoutSuppress)
				{
					m_cTimeoutSuppress = 0;
					cTicks = 0;
					continue;
				}
				if (m_cTimeoutDisable || (++cTicks < g_cWaitTimeout))
					continue;
				DEBUGMSG("RunEngine wait timed out");
				if (!ENG::IsDebuggerRunning())
				{
					imsEnum ims = ProcessMessage(imtEnum(imtFatalTimedOut), 0);
					if (ims != imsRetry)
					{
						// Ensure that we're not doing memory manager operations
						// in the other thread. We're assuming that the memory
						// manager is "safe" and will never bring us down.

						EnterCriticalSection(&vcsHeap);
						WIN::TerminateThread(m_hMainThread, ERROR_OPERATION_ABORTED);
						LeaveCriticalSection(&vcsHeap);
						Terminate(fTrue);
						return ERROR_INSTALL_FAILURE;
					}
				}
				cTicks = 0;
				m_iTimeoutRetry = 0;
				continue;
			}
			else if (dwWait == WAIT_OBJECT_0 + 1) // main thread terminated or died
			{
				WIN::GetExitCodeThread(m_hMainThread, &iReturn);  // can't access member data, may be deleted
				switch (iReturn)
				{
					default:                 // normal exit
						Terminate(false);
						return iReturn;
					case ERROR_ARENA_TRASHED:      // engine thread crashed
						ProcessMessage(imtEnum(imtFatalException), 0);
						iReturn = ERROR_OPERATION_ABORTED;
						break;
					case ERROR_NOT_ENOUGH_MEMORY: // out of memory, already handled
						iReturn = ERROR_OUTOFMEMORY;
						break;
					case ERROR_OPERATION_ABORTED: // UI already handled
						break;
				}
				Terminate(fTrue);   // main thread is dead, can't free anything allocated there
				return iReturn;
			}
			else if (dwWait == WAIT_OBJECT_0 + 2)  // window Msg
			{
				MSG msg;
				while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
				{
					if (!WIN::IsDialogMessage(GetCurrentWindow(), &msg))
					{
						WIN::TranslateMessage(&msg);
						WIN::DispatchMessage(&msg);
					}
				}
				continue;
			}
			cTicks = 0;
			m_iTimeoutRetry = 0;

			// else we were signaled with a message request
			if (m_imtMessage == imtInvalid)
			{
				DEBUGMSG("Invalid event trigger in wait for engine thread"); //!!# temp for debug
				continue;
			}
			m_imsReturn = imsBusy;      // to indicate processing in UI thread
			m_imsReturn = ProcessMessage(m_imtMessage, m_pirecMessage);
			m_imtMessage = imtInvalid;  // to detect invalid event triggers
			WIN::SetEvent(m_hUIReturn);
		} // end message wait/process loop

		return NOERROR;
	}
	__except(lpExceptionInfo=GetExceptionInformation(),
			 (!lpExceptionInfo ||
			  lpExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT) ?
				EXCEPTION_CONTINUE_SEARCH : EXCEPTION_EXECUTE_HANDLER)
	{
		GenerateExceptionReport(lpExceptionInfo);
		DEBUGMSGE(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_EXCEPTION, g_MessageContext.m_rgchExceptionInfo);
		g_MessageContext.Invoke(imtEnum(imtExceptionInfo), 0);
		Terminate(fTrue);
		return ERROR_INSTALL_FAILURE;
	}
};

// Unhandled exception handler, enabled/disabled by Initialize/Terminate

DWORD g_tidDebugBreak = 0;

LONG WINAPI MsiUIMessageContext::ExceptionHandler(EXCEPTION_POINTERS* ExceptionInfo)
{
	DWORD tidCurrent = WIN::GetCurrentThreadId();
	if (tidCurrent == g_MessageContext.m_tidInitialize  // caller's thread, not ours
	 || (tidCurrent == g_tidDebugBreak && ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT))
	{
		g_tidDebugBreak = 0;
		return (*g_MessageContext.m_tlefOld)(ExceptionInfo);  // use original exception handler
	}

	GenerateExceptionReport(ExceptionInfo);
	DEBUGMSGE(EVENTLOG_ERROR_TYPE, EVENTLOG_TEMPLATE_EXCEPTION, g_MessageContext.m_rgchExceptionInfo);
	g_MessageContext.Invoke(imtEnum(imtExceptionInfo), 0);

	WIN::ExitThread(ERROR_ARENA_TRASHED);   // terminate our thread
	return ERROR_SUCCESS;                   // for compilation, never gets here
}

// Initialize message context and create child UI thread if engine is operating in the main thread
// Else the main engine thread is created afterwards, and no memory allocator may be available yet

UINT MsiUIMessageContext::Initialize(bool fCreateUIThread, iuiEnum iuiLevel, DWORD dwPrivilegesMask) // called only from main thread before any child threads
{
	class CTerminate
	{
	public:
		~CTerminate() { if (!g_MessageContext.IsInitialized()) g_MessageContext.Terminate(false); }
	};

	if(TestAndSet(&m_iBusyLock) == true)
	{
		DEBUGMSG(TEXT("Message context already initialized, returning ERROR_INSTALL_ALREADY_RUNNING"));
		return ERROR_INSTALL_ALREADY_RUNNING;
	}

	CTerminate terminate; // only terminate if we've made it past the TestAndSet
	
	UINT uiRes = SetUserToken(false, dwPrivilegesMask);
	if (ERROR_SUCCESS != uiRes)
		return uiRes;
	
	m_tidInitialize = WIN::GetCurrentThreadId();
	if (!GetTestFlag('X'))
		m_tlefOld = WIN::SetUnhandledExceptionFilter(MsiUIMessageContext::ExceptionHandler);

	m_hUIRequest = WIN::CreateEvent((LPSECURITY_ATTRIBUTES)0, FALSE/*autoreset*/, FALSE/*unsignaled*/, (LPCTSTR)0/*unnamed*/);
	m_hUIReturn  = WIN::CreateEvent((LPSECURITY_ATTRIBUTES)0, FALSE/*autoreset*/, FALSE/*unsignaled*/, (LPCTSTR)0/*unnamed*/);

/*remove*/      Assert(m_hUIRequest && m_hUIReturn);
	if (m_hUIRequest == 0 || m_hUIReturn == 0)
		return ERROR_CREATE_FAILED;
	WIN::InitializeCriticalSection(&m_csDispatch);
	if ((m_piServices = ENG::LoadServices()) == 0)
		return ERROR_CREATE_FAILED;

	m_fServicesAndCritSecInitialized = true;

	// set timeout value
	g_cWaitTimeout = GetIntegerPolicyValue(szWaitTimeoutValueName, fTrue)*20;
	Assert(g_cWaitTimeout);

	if ((int)iuiLevel & iuiHideBasicUI)
	{
		m_fHideBasicUI = true;
		iuiLevel = (iuiEnum)((int)iuiLevel & ~iuiHideBasicUI);
	}

	if ((int)iuiLevel & iuiNoModalDialogs)
	{
		m_fNoModalDialogs = true;
		iuiLevel = (iuiEnum)((int)iuiLevel & ~iuiNoModalDialogs);
	}

	if ((int)iuiLevel & iuiSourceResOnly)
	{
		m_fSourceResolutionOnly = true;
		iuiLevel = (iuiEnum)((int)iuiLevel & ~iuiSourceResOnly);
	}

	if ((int)iuiLevel & iuiUseUninstallBannerText)
	{
		m_fUseUninstallBannerText = true;
		iuiLevel = (iuiEnum)((int)iuiLevel & ~iuiUseUninstallBannerText);
	}
	
	if ((int)iuiLevel & iuiHideCancel)
	{
		m_fHideCancel = true;
		iuiLevel = (iuiEnum)((int)iuiLevel & ~iuiHideCancel);
	}

	m_iuiLevel = iuiLevel;  // could be set to iuiNextEnum if UIPreview mode
	if (fCreateUIThread)  // engine running in main thread so API functions can be called
	{
		if (GetTestFlag('T'))
		{
			m_tidUIHandler = WIN::GetCurrentThreadId();  // UI and main engine in same thread
			m_hUIThread = INVALID_HANDLE_VALUE;  // so that ChildUIThreadExists() works
		}
		else
		{
			m_hUIThread = WIN::CreateThread((LPSECURITY_ATTRIBUTES)0, 4096*10,
														(PThreadEntry)ChildUIThread, (LPVOID)this, 0, &m_tidUIHandler);
			AssertSz(m_hUIThread, TEXT("CreateThread for child UI thread failed"));
			if (!m_hUIThread)
			{
				return ERROR_CREATE_FAILED;
			}
		}
	}
	else // called from RunEngine, UI remains in this main thread
	{
		m_tidUIHandler = WIN::GetCurrentThreadId();
		if (m_iuiLevel == iuiNextEnum)  // UIPreview, FullUI, no Basic UI
			m_iuiLevel = iuiFull;     // must do this in UI thread
		else
		{
			bool fQuiet = m_iuiLevel == iuiNone ||
							  m_iuiLevel == iuiDefault;
			if(!g_BasicUI.Initialize(g_message.m_hwnd, fQuiet, m_fHideBasicUI,
											 m_fNoModalDialogs, m_fHideCancel, m_fUseUninstallBannerText, 
											 m_fSourceResolutionOnly))
			{
				return ERROR_CREATE_FAILED; //!! what error?
			}
		}
		
		// need to initialize OLE on this thread
		if (false == m_fOleInitialized && SUCCEEDED(OLE32::CoInitialize(0)))
		{
			m_fOleInitialized = true;
		}
	}

	if (g_message.m_iMessageFilter & (1 << (imtLoadHandler>>imtShiftCount)))
		g_message.Message(imtLoadHandler, (const ICHAR*)0);  //!! need to check return and disable starting dialog

	g_szScriptInProgress[0] = 0;
	g_szTimeRemaining[0] = 0;
	g_szFatalOutOfMemory[0] = 0;
	g_szFatalTimedOut[0] = 0;
	g_szFatalException[0] = 0;
	g_szBannerText[0] = 0;
	m_rgchExceptionInfo[0] = 0;

	if (g_scServerContext == scService)
	{
		// reset product context cache for every installation session
		CProductContextCache::Initialize();

		if (!LoadCurrentUserKey())
		{
			return ERROR_CREATE_FAILED; //?? correct error?
		}
	}

	if (!InitializeEnvironmentVariables())
	{
		return ERROR_CREATE_FAILED; //?? correct error?
	}

	if (!InitializeLog())
	{
		return ERROR_INSTALL_LOG_FAILURE;
	}

	if (!FCreateHiddenWindow())
	{
		AssertSz(fFalse, "Unable to create hidden window");
	}

	AssertSz(!m_hSfcHandle, TEXT("Windows File Protection handle should not be initialized!"));
	if ( MinimumPlatformWindows2000() && !m_hSfcHandle ) m_hSfcHandle = SFC::SfcConnectToServer(NULL);
	m_fInitialized = true; // must be last

	return NOERROR;
}

LONG_PTR CALLBACK HiddenWindowProc(HWND pWnd, unsigned int message, WPARAM wParam, LPARAM lParam)               //--merced: changed return type from long to LONG_PTR
{
	switch(message)
	{
		case WM_POWERBROADCAST:
			if (PBT_APMQUERYSUSPEND == wParam)
			{
				if (FTestNoPowerdown())
				{
					DEBUGMSGD("Hidden window Refusing Powerdown");
					return BROADCAST_QUERY_DENY;
				}
			}
			break;
		case WM_QUERYENDSESSION:
			if (FTestNoPowerdown())
			{
				DEBUGMSGD("Hidden window Refusing QueryEndSession");
				return FALSE;
			}
			break;
	}
	return DefWindowProc(pWnd, message, wParam, lParam);
}

HWND MsiUIMessageContext::GetCurrentWindow()
{
	return g_MessageContext.m_piHandler ? g_MessageContext.m_piHandler->GetTopWindow()
										: g_BasicUI.GetWindow();
}

const ICHAR* MsiUIMessageContext::GetWindowCaption()
{
	return g_BasicUI.GetCaption();
}

LANGID MsiUIMessageContext::GetCurrentUILanguage()
{
	return g_BasicUI.GetPackageLanguage();
}

bool MsiUIMessageContext::FCreateHiddenWindow()
{
	WNDCLASS wc;

	memset(&wc, 0, sizeof(wc));
	wc.style       = CS_DBLCLKS;
	wc.lpfnWndProc = HiddenWindowProc;
	wc.hInstance   = g_hInstance;
	wc.lpszClassName = MsiHiddenWindowClass;
	if (RegisterClass(&wc) == 0)
	{
		return false;
	}

	m_hwndHidden =  WIN::CreateWindowEx(0, MsiHiddenWindowClass,
						TEXT(""),
						WS_POPUP,                // Style
						CW_USEDEFAULT,                   // horizontal position
						CW_USEDEFAULT,                   // vertical position
						CW_USEDEFAULT,               // window width
						CW_USEDEFAULT,              // window height
						0,
						0,                      // hmenu
						g_hInstance,            // hinst
						0                       // lpvParam
						);

	return true;

}

void MsiUIMessageContext::KillHiddenWindow()
{

	if (m_hwndHidden)
	{
		WIN::DestroyWindow(m_hwndHidden);
		m_hwndHidden = 0;
	}

	UnregisterClass(MsiHiddenWindowClass, g_hInstance);

}

//____________________________________________________________________________
//
// Log handling
//____________________________________________________________________________

bool CreateLog(const ICHAR* szFile, bool fAppend)
{
	if (g_MessageContext.m_hLogFile)  // close any existing log file //!! is this what we want to do?
		CloseHandle(g_MessageContext.m_hLogFile);

	if (szFile)
		g_MessageContext.m_hLogFile = CreateFile(szFile, GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ,
										0, fAppend ? OPEN_ALWAYS : CREATE_ALWAYS,
										( FILE_ATTRIBUTE_NORMAL 
										| SECURITY_SQOS_PRESENT 
										| SECURITY_ANONYMOUS), 0);
	else
		g_MessageContext.m_hLogFile = INVALID_HANDLE_VALUE;
	if (g_MessageContext.m_hLogFile == INVALID_HANDLE_VALUE)
	{
		g_MessageContext.m_hLogFile = 0;
		return false;
	}

	DWORD fp = 0;
	if (fAppend && (fp = WIN::SetFilePointer(g_MessageContext.m_hLogFile, 0, NULL, FILE_END)) == 0xFFFFFFFF)
	{
		WIN::CloseHandle(g_MessageContext.m_hLogFile);
		g_MessageContext.m_hLogFile = 0;
		return false;
	}
#ifdef UNICODE
	else if (fp == 0)
	{
		const char rgUnicode[2] = { (char)0xff, (char)0xfe };
		DWORD dwBytesWritten;
		if (!WIN::WriteFile(g_MessageContext.m_hLogFile, rgUnicode, sizeof(rgUnicode), &dwBytesWritten, 0))
		{
			WIN::CloseHandle(g_MessageContext.m_hLogFile);
			g_MessageContext.m_hLogFile = 0;
			return false;
		}
	}
#endif //UNICODE
	WIN::InitializeCriticalSection(&g_csWriteLog);

	return true;
}

bool LoggingEnabled()
{
	return (g_MessageContext.m_hLogFile != 0);
}

/*

	The function below could seem a bit complicated so here is what it does:

	In the current logging functionality, both the client and the service write
	into the same physical log file - please note that these 2 are the only
	msiexec.exe processes that write directly into the log file.

	The critical sections:
	Within each of the 2 processes there could be multiple threads attempting
	to write into the log file at the same time.  To prevent this we've used
	a critical section in WriteLog, so within each process, only one thread
	can write into the log file at a time.

	Locking and unlocking sections of the log file:
	There is a chance that the other process will attempt to write into the
	log file at the same time with the current one and this will cause some
	information to get overwritten.  In order to prevent this, we set aside
	a portion past the current end of file, large enough for the data we want
	to write.  Then we lock this portion, we set the new end of file past it
	(so the other process can write past it without waiting for us), we write
	our data and unlock it.
	
*/	
	
bool WriteLog(const ICHAR* szText) // cannot allocate memory
{
	if (!g_MessageContext.m_hLogFile || !szText)
		return false;

	// the file pointers we set below are unique per file handler, so we
	// need to make sure that only one call to WriteLog is serviced at a
	// time.
	WIN::EnterCriticalSection(&g_csWriteLog);

	const ICHAR rgchLFCR[2] = {'\r','\n'};
	const int cMinLinesToFlush = 20;
	const int CHARS_PER_LINE = 255;
	size_t cchLen = IStrLen(szText);
	const size_t cLines = (cchLen / CHARS_PER_LINE) + ((cchLen % CHARS_PER_LINE) ? 1 : 0);
	const size_t cbText = cchLen * sizeof(ICHAR);
	const LONG cbToWrite = cbText + (cLines * sizeof(rgchLFCR)); // total number of bytes we'll be writing
	
	LARGE_INTEGER liNewEnd = {0};
	LARGE_INTEGER liCurrEnd = {0};
	bool fReturn = true;
	
	// lock cbToWrite bytes in the file, past its current end
	bool fLocked = false;
	bool fChunkReserved = false;
	size_t cAttempts = 30;

	do
	{
		// position ourselves to the end of the file + cbToWrite
		liNewEnd.LowPart = WIN::SetFilePointer(g_MessageContext.m_hLogFile, cbToWrite, &(liNewEnd.HighPart), FILE_END);
		if (INVALID_SET_FILE_POINTER == liNewEnd.LowPart && 0 == liNewEnd.HighPart)
		{
			//  we better return than to write in some random location in the log file
			Assert(0);
			fReturn = false;
			goto ExitWriteLog;
		}
		
		liCurrEnd.QuadPart = liNewEnd.QuadPart - cbToWrite;

		if ( WIN::LockFile(g_MessageContext.m_hLogFile, liCurrEnd.LowPart,
								 liCurrEnd.HighPart, cbToWrite, 0) )
		{
			fLocked = true;
			//
			// At this point, the end of file should not have changed. If it has,
			// then someone managed to lock the file change the end of file and
			// unlock it before our process had a chance to Lock the file, in which case
			// we must redo the steps above.
			liNewEnd.LowPart = WIN::SetFilePointer(g_MessageContext.m_hLogFile, cbToWrite, &(liNewEnd.HighPart), FILE_END);
			if (INVALID_SET_FILE_POINTER == liNewEnd.LowPart && 0 == liNewEnd.HighPart)
			{
				//  we better return than to write in some random location in the log file
				Assert(0);
				fReturn = false;
				goto ExitWriteLog;
			}
			
			if (liNewEnd.QuadPart - cbToWrite == liCurrEnd.QuadPart)
			{
				//
				// We are good to go. Set the new end of file, so other calls to 
				// WriteLog can lock and write simultaneously past this new end 
				// of the file.
				//

				if ( !WIN::SetEndOfFile(g_MessageContext.m_hLogFile) )
				{
					fReturn = false;
					goto ExitWriteLog;
				}

				else
				{
					fChunkReserved = true;
				}
			}
		}
		
		if (!fChunkReserved)
		{
			if (fLocked)
			{
				if (WIN::UnlockFile(g_MessageContext.m_hLogFile, liCurrEnd.LowPart,
										  liCurrEnd.HighPart, cbToWrite, 0))
				{
					fLocked = false;
				}
			}

			WIN::Sleep(100);  // sleep 100 ms each time for 30 iterations if we are not able to get ourselves a piece of the file.
		}
		
	} while ( --cAttempts && !fChunkReserved );
	
	if ( !fChunkReserved )
	{
		// we could not get a chunk of the file to write to.
		fReturn = false;
		goto ExitWriteLog;
	}

	// We now have a chunk of file all to ourselves.
	
	// So move back to the position where we need to start writing.
	liCurrEnd.LowPart = WIN::SetFilePointer(g_MessageContext.m_hLogFile, liCurrEnd.LowPart, &(liCurrEnd.HighPart), FILE_BEGIN);
	if ( liCurrEnd.LowPart == INVALID_SET_FILE_POINTER && 0 == liCurrEnd.HighPart)
	{
		fReturn = false;
		goto ExitWriteLog;
	}

	// write out szText into the file, in lines of CHARS_PER_LINE characters long.
	const ICHAR* pchText = szText;
	// static buffer OK, call is protected by g_csWriteLog critsec
	static ICHAR rgchTemp[CHARS_PER_LINE+1];

	do {
		const ICHAR *pchOutput = 0;
		size_t cbOutput = 0;

		if (cchLen > CHARS_PER_LINE)
		{
			IStrCopyLen(rgchTemp, pchText, CHARS_PER_LINE);
			cchLen -= CHARS_PER_LINE;
			pchText += CHARS_PER_LINE;
			pchOutput = rgchTemp;
			cbOutput = CHARS_PER_LINE;
		}
		else
		{
			pchOutput = pchText;
			cchLen = 0;
			cbOutput = IStrLen(pchOutput);
		}
		cbOutput *= sizeof(ICHAR);

		// write out pchOutput chunk into the file
		DWORD dwBytesWritten;
		if (!WIN::WriteFile(g_MessageContext.m_hLogFile, pchOutput, cbOutput, &dwBytesWritten, 0) ||
			 !WIN::WriteFile(g_MessageContext.m_hLogFile, rgchLFCR, sizeof(rgchLFCR), &dwBytesWritten, 0))
		{
			Assert(0);
			fReturn = false;
			goto ExitWriteLog;
		}

		if (g_cFlushLines <= 0)
		{
			WIN::FlushFileBuffers(g_MessageContext.m_hLogFile);
			g_cFlushLines = g_fFlushEachLine ? 0 : cMinLinesToFlush;
		}
		else
			g_cFlushLines--;

	} while (cchLen > 0);

ExitWriteLog:

	// unlock the file and return
	if ( fLocked )
		WIN::UnlockFile(g_MessageContext.m_hLogFile, liCurrEnd.LowPart,
							 liCurrEnd.HighPart, cbToWrite, 0);

	if ( !fReturn )
	{
		OutputDebugString(TEXT("Failed to write ["));
		OutputDebugString(szText);
		OutputDebugString(TEXT("] into the log file.\r\n"));
	}

	WIN::LeaveCriticalSection(&g_csWriteLog);
	return fReturn;
}

bool MsiUIMessageContext::InitializeLog(bool fDynamicLog)
{
	if (ENG::LoggingEnabled())
		return true;

	if (g_dwLogMode == 0 && g_scServerContext == scClient)
	{
		CAPITempBuffer<ICHAR, 25> rgchLogMode;
		GetStringPolicyValue(szLoggingValueName, fTrue, rgchLogMode);
		if ( (ICHAR *)rgchLogMode && *rgchLogMode)
		{
			DWORD dwMode = 0;

			const int iFlushBit = 1 << (cchLogModeCharsMax + lmaFlushEachLine);

			if (ERROR_SUCCESS == StringToModeBits(rgchLogMode, szLogChars, dwMode))
			{
				g_fFlushEachLine = false;

				if (dwMode & iFlushBit)
				{
					g_fFlushEachLine = true;
					dwMode &= ~iFlushBit;
				}

				g_dwLogMode = dwMode;
				fDynamicLog = fTrue;
			}
		}
	}

	if(fDynamicLog)
	{
		m_fLoggingFromPolicy = true; // tells us to stop using this log when the install is over

		// generate a log on the fly, need a name for log
		MsiString strFile;
		IMsiServices* piServices = ENG::LoadServices();
		MsiString strTempDir = ENG::GetTempDirectory();
		bool fError = false;
		{ // just so the PMsiPath and PMsiRecord objects are destroyed before freeing
                  // the services.
		PMsiPath pPath(0);
		PMsiRecord pError = piServices->CreatePath(strTempDir,*&pPath);

		if(!pError)
			pError = pPath->TempFileName(TEXT("MSI"),TEXT("LOG"),fFalse,*&strFile, 0);

		if(!pError)
		{
			strFile.CopyToBuf(g_szLogFile,sizeof(g_szLogFile)/sizeof(ICHAR)-1);
			if (g_dwLogMode == 0)
				g_dwLogMode = INSTALLLOGMODE_ERROR|INSTALLLOGMODE_WARNING;
		}
		if ( pError )
			fError = true;
		}
		ENG::FreeServices();

		if(fError)
			return false;
	}

	if (g_dwLogMode == 0) //!! is this right?
		return true;
	if (g_szLogFile == 0)   //!! we don't support routing log to external UI yet
		return false;

	if ( g_scServerContext == scClient &&
		  IStrCompI(g_szLogFile, TEXT("NUL")) ) // this is to avoid the regression in bug 768228
	{
		// we want to make sure that g_szLogFile contains a full path, because
		// otherwise we end up with two log files: one in the client's directory
		// and one in the service's, each of them containing parts of the log info.
		CAPITempBuffer<ICHAR, 1> rgchTemp;
		if (!rgchTemp.SetSize(MAX_PATH+1) || 
			!ExpandPath(g_szLogFile, rgchTemp) ||
			FAILED(StringCchCopy(g_szLogFile, ARRAY_ELEMENTS(g_szLogFile), rgchTemp)) )
		{
			*g_szLogFile = TEXT('\0');
			return false;
		}
	}

	if ((g_dwLogMode & (INSTALLLOGMODE_INFO|INSTALLLOGMODE_VERBOSE)) == INSTALLLOGMODE_VERBOSE)
	{
		// VERBOSE turns on INFO
		g_dwLogMode |= INSTALLLOGMODE_INFO;
	}

	if ((g_dwLogMode & (INSTALLLOGMODE_INFO|INSTALLLOGMODE_EXTRADEBUG)) == INSTALLLOGMODE_EXTRADEBUG)
	{
		// EXTRADEBUG turns on INFO
		g_dwLogMode |= INSTALLLOGMODE_INFO;
	}

	bool fAppend = false;
	bool fImpersonate = false;
	if ( g_scServerContext == scService )
	{
		fImpersonate = true;
		fAppend = true;
	}
	else
	{
		Assert(g_scServerContext == scClient);
		fAppend = g_fLogAppend ? true : false;
	}
	CImpersonate oImpersonate(fImpersonate);
	if (!ENG::CreateLog(g_szLogFile, fAppend))
		return false;
	m_iLogMode = g_dwLogMode & iLogMessages;
	SetDiagnosticMode(); // set mode again in case it was set before log mode set

	if(FDiagnosticModeSet(dmVerboseLogging) &&
		g_scServerContext == scClient )
	{
		ICHAR rgchModule[MAX_PATH];
		// GetModuleFileName does not guarantee null termination if buffer is exactly the right size
		int cchModule = GetModuleFileName(NULL, rgchModule, ARRAY_ELEMENTS(rgchModule)-1);
		if (cchModule == 0)
			return false;
		rgchModule[ARRAY_ELEMENTS(rgchModule)-1] = TEXT('\0');

#ifdef DEBUG
#define _debugflavor_ __TEXT("DEBUG")
#else
#define _debugflavor_ __TEXT("SHIP")
#endif

#ifdef UNICODE
#define _unicodeflavor_ __TEXT("UNICODE")
#else
#define _unicodeflavor_ __TEXT("ANSI")
#endif

		CTempBuffer<ICHAR,1> rgchLogEntry(MAX_PATH+200); // enough for module path plus text plus dates, etc...
		StringCchPrintf(rgchLogEntry, rgchLogEntry.GetSize(),
					TEXT("=== Verbose logging started: %s  %s  Build type: %s %s %d.%02d.%04d.%02d  Calling process: %s ==="),
					((const IMsiString&)g_MsiStringDate).GetString(), ((const IMsiString&)g_MsiStringTime).GetString(),
					_debugflavor_, _unicodeflavor_, rmj, rmm, rup, rin, rgchModule);

		WriteLog(rgchLogEntry); // DEBUGMSG doesn't work outside of MainEngineThread
	}

	return true;
}

bool LogRecord(IMsiRecord& riRecord)
{
	if (!ENG::LoggingEnabled())
		return true;  // else we must test at point of call
	MsiString istrData(riRecord.FormatText(fTrue));
	return ENG::WriteLog(istrData);
}

void GetHomeEnvironmentVariables(const IMsiString*& rpiProperties)
{
	MsiString strCommandLine;
	if (!g_fWin9X && (g_iMajorVersion < 5 || (g_iMajorVersion == 5 && g_iMinorVersion ==0))) // CreateEnvironmentBlock on NT4 and Win2k doesn't set these 2 variables
	{
		const ICHAR* rgszEnvVarsToPass[] = {
			TEXT("HOMEPATH"),
			TEXT("HOMEDRIVE"),
			TEXT("HOMESHARE"),
			0,
		};
		
		const ICHAR** szEnv = rgszEnvVarsToPass;
		do{
			CTempBuffer<ICHAR,1> rgchEnvVar(MAX_PATH+1);
			CTempBuffer<ICHAR,1> rgchTmp(1024);
			rgchEnvVar[0]='0';
			WIN::GetEnvironmentVariable(*szEnv, rgchEnvVar, rgchEnvVar.GetSize());
			if (SUCCEEDED(StringCchPrintf(rgchTmp, rgchTmp.GetSize(), TEXT(" %%%s=\"%s\""), *szEnv, static_cast<const ICHAR*>(rgchEnvVar))))
				strCommandLine += rgchTmp;
		}while(*(++szEnv));
	}
	strCommandLine.ReturnArg(rpiProperties);
}

void DumpEnvironment()
{
	DEBUGMSGV("START Environment block dump:");
	WCHAR* pchEnviron = GetEnvironmentStringsW();

	WCHAR* pch = pchEnviron;
	while (*pch)
	{
		DEBUGMSGV1(L"%s", pch);
		while (*pch++)
			;
	}
	DEBUGMSGV("END Environment block dump:");

	FreeEnvironmentStringsW(pchEnviron);
}

enum esceAction
{
	esceNormal, 
	esceSetAllToBlank,
	esceSkipPath
};

bool SetCurrentEnvironmentVariables(WCHAR* pchEnvironment, const esceAction eAction)
// Sets each environment variable in the block pchEnvironment into the
// current process' environment block by calling WIN::SetEnvironmentVariable
{
	WCHAR* pch = pchEnvironment;
	WCHAR* pchName;
	BOOL fStatus = TRUE;

	if (pch)
	{
		while (*pch)
		{
			// save pointer to beginning of name

			pchName = pch;

			// skip possible leading equals sign

			if (*pch == '=')
				pch++;

			// advance to equals sign separating name from value

			while (*pch != '=')
			{
				Assert(*pch != 0);
				pch++;
			}

			// null-terminate name, overwriting equals sign

			*pch++ = 0;

			// set the value. pchName now points to the name and pch points to the value

			if (esceSetAllToBlank == eAction)
			{
				AssertNonZero(fStatus = WIN::SetEnvironmentVariableW(pchName, 0));
#ifdef DEBUG
				if (GetTestFlag('V'))
					DEBUGMSGV2(L"Setting env var %s=%s", pchName, L"" );
#endif
			}
			else
			{
				if ((esceNormal == eAction) || ((esceSkipPath == eAction) && (CSTR_EQUAL != CompareStringW(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE, pchName, -1, L"PATH", -1))))
				{
					AssertNonZero(fStatus = WIN::SetEnvironmentVariableW(pchName, pch));
#ifdef DEBUG
					if (GetTestFlag('V'))
						DEBUGMSGV2(L"Setting env var %s=%s", pchName, pch);
#endif
				}
				else
				{
#ifdef DEBUG
					if (GetTestFlag('V'))
						DEBUGMSGV1(L"Skipping env var %s", pchName);
#endif
				}
			}

			if ( ! fStatus )
				return false;



			// advance over the value

			while (*pch++ != 0)
				;

			// we're now positioned at the next name, or at the block's null
			// terminator and we're ready to go again
		}
	}

	return true;
}

bool CopyEnvironmentBlock(CAPITempBufferRef<WCHAR>& rgchDest, WCHAR* pchEnvironment)
// Copies the environment block pchEnvironment into rgchDest
{
	WCHAR* pch = pchEnvironment;
	if (pch)
	{
		while (*pch != 0)
		{
			while (*pch++ != 0)
				;
		}
	}

	Assert(((pch - pchEnvironment) + 1) < INT_MAX);                 //--merced: we're typecasting to int32 below, it better be in range.
	if (rgchDest.SetSize((int)((pch - pchEnvironment) + 1)))
	{
		memcpy(rgchDest, pchEnvironment, rgchDest.GetSize() * sizeof(WCHAR));
		return true;
	}

	return false;
}

void RemoveBlankEnvironmentStrings()
{
	IMsiServices* piServices = ENG::LoadServices();
	if (!piServices)
	{
		Assert(0);
		return;
	}

	PMsiRegKey     pEnvironment(0);
	PMsiRegKey     pRoot(0);
	PEnumMsiString pValueEnum(0);
	PMsiRecord     pError(0);

	for (int c=0; c<2; c++)
	{
		if (c == 0)
		{
			// check machine environment
			pRoot = &piServices->GetRootKey(rrkLocalMachine, ibtCommon); // x86 and ia64 same
			pEnvironment = &pRoot->CreateChild(szMachineEnvironmentSubKey);
		}
		else
		{
			// check user environment; HKCU should already be set to the correct user

			pRoot = &piServices->GetRootKey(rrkCurrentUser, ibtCommon); // x86 and ia64 same
			pEnvironment = &pRoot->CreateChild(szUserEnvironmentSubKey);
		}

		AssertRecord(pEnvironment->GetValueEnumerator(*&pValueEnum));

		MsiString strValueName;
		MsiString strValue;

		if (pValueEnum)
		{
			while((pValueEnum->Next(1, &strValueName, 0)) == S_OK)
			{
				if ((pError = pEnvironment->GetValue(strValueName, *&strValue)) || strValue.TextSize())
					continue;

				// remove the blank environment variable

				AssertRecord(pEnvironment->RemoveValue(strValueName, 0));
			}
		}
	}

	ENG::FreeServices();
}

bool BlankCurrentEnvironment()
{
	CAPITempBuffer<WCHAR, 1> rgchEnvironment; // CopyEnvironmentBlock may resize

	WCHAR* pchCurrentEnvironment = WIN::GetEnvironmentStringsW();
	Assert(pchCurrentEnvironment);

	bool fResult = false;
	if ( pchCurrentEnvironment )
	{
		// SetCurrentEnvironmentVariables is intrusive (but restorative), so must make a copy
		if (CopyEnvironmentBlock(rgchEnvironment, pchCurrentEnvironment))
		{
			fResult = SetCurrentEnvironmentVariables(rgchEnvironment, esceSetAllToBlank);
		}
		else
		{
			DEBUGMSGV("Cannot copy environment block");
			Assert(0);
		}

        WIN::FreeEnvironmentStringsW(pchCurrentEnvironment);
	}

	return fResult;
}

bool MsiUIMessageContext::InitializeEnvironmentVariables()
// add the user's environment variables to our process' environment block
{

	// Only set the environment variables into our service. (our own process.)
	// Running in the normal client, these should already be set.
	// Running in the client under WinLogon will hose WinLogon's variables.

	if (g_scServerContext != scService)
	{
		return true;
	}

	DEBUGMSGV("Initializing environment variables");

	// If the user has blank environment strings then CreateEnvironmentBlock will fail.
	// We'll remove any blanks.

	RemoveBlankEnvironmentStrings();

	DEBUGMSGV("Refreshing system environment block for service");

	WCHAR *pchSystemEnvironment;
	if (USERENV::CreateEnvironmentBlock((void**)&pchSystemEnvironment, NULL, FALSE))
	{
		AssertNonZero(BlankCurrentEnvironment());

		// set each machine environment variable into the current process's environment block
		SetCurrentEnvironmentVariables(pchSystemEnvironment, esceNormal);

		// we're done with the block so destroy it
		USERENV::DestroyEnvironmentBlock(pchSystemEnvironment);
	}
	else
	{
		DEBUGMSGV("Could not refresh system environment");
		AssertSz(0, "Could not refresh system environment");
	}

#ifdef DEBUG
	if (GetTestFlag('V'))
	{
		DEBUGMSGV("Current environment block before setting user's environment variables");
		DumpEnvironment();
	}
#endif

	// create an environment block for the user

	WCHAR *pchUserEnvironment;
	if (!USERENV::CreateEnvironmentBlock((void**)&pchUserEnvironment, IsLocalSystemToken(g_MessageContext.GetUserToken()) ? 0 : g_MessageContext.GetUserToken(), TRUE))
	{

#ifdef DEBUG
		ICHAR rgchDebug[500] = {0};
		ICHAR rgchAccount[500] = {0};
		Assert(GetAccountNameFromToken(g_MessageContext.GetUserToken(), rgchAccount, (sizeof(rgchAccount)/sizeof(ICHAR))));
		StringCchPrintf(rgchDebug, ARRAY_ELEMENTS(rgchDebug),
					TEXT("CreateEnvironmentBlock failed. The most likely reason for this is ")
					TEXT("passing a LocalSystem token to it. The token passed to it was for the account: %s"),
					rgchAccount);
		AssertSz(0, rgchDebug);
#endif
		return false;
	}

	// save current environment variables so we can restore
	// them when the install is complete

	bool fCopy = false;
	WCHAR* pchEnvironment = WIN::GetEnvironmentStringsW();
	Assert(pchEnvironment);

	if ( pchEnvironment )
	{
		if ( CopyEnvironmentBlock(g_rgchEnvironment, pchEnvironment) )
		{
			// set each user environment variable into the current process's environment block

			fCopy = SetCurrentEnvironmentVariables(pchUserEnvironment, esceSkipPath);
		}

		// we don't need the environment string pointer anymore; we've copied the strings

		WIN::FreeEnvironmentStringsW(pchEnvironment);
	}

	// we're done with the block so destroy it
	USERENV::DestroyEnvironmentBlock(pchUserEnvironment);

	DEBUGMSG("Current environment block after setting user's environment variables");
	DumpEnvironment();

	// refresh test flags that are based on environment variables.
	SetTestFlags();

	return fCopy;
}

bool MsiUIMessageContext::RestoreEnvironmentVariables()
// remove the user's environment variables to our process' environment
// block, restoring the block to what it was when the install began
{
	// if we're not running as the service then there's nothing
	// to restore

	if (g_scServerContext != scService)
		return true;

	DEBUGMSG("Restoring environment variables");

	// set current environment variables to blank. need to copy the block
	// because SetCurrentEnvironmentVariable mucks with it

	AssertNonZero(BlankCurrentEnvironment());

	bool fCopy = false;
	// restore our original environment variables
	// even if the above failed we are best off attempting to set the old 
	// values on top

	if ( g_rgchEnvironment[0] )
		fCopy = SetCurrentEnvironmentVariables(g_rgchEnvironment, esceNormal);

#ifdef DEBUG
	if (GetTestFlag('V'))
	{
		DEBUGMSG("Current environment block after restoring original environment block");
		DumpEnvironment();
	}
#endif
	return fCopy;
}



//____________________________________________________________________________
//
// Engine message formatting
//____________________________________________________________________________

enum easEnum
{
	easAction = 1,   // non-localized name of action, use to find action
	easActionName,   // localized action name for execute record, ":", template
	easCondition,    // condition expression, action skipped if False
	easNextEnum,
	easActionTemplate = 3, // format template for ActionData record
};

const ICHAR sqlErrorMessage[] =
TEXT("SELECT `Message` FROM `Error` WHERE `Error` = ?");


imsEnum CMsiEngine::MessageNoRecord(imtEnum imt)
{
	return Message(imt, *g_piNullRecord);
}

bool ShouldGoToEventLog(imtEnum imt)
{
	int imsg = (unsigned)(imt & ~iInternalFlags) >> imtShiftCount;  // message header message

	if (imsg == (imtError >> imtShiftCount) ||
		(imsg == (imtOutOfDiskSpace >> imtShiftCount)) ||
		(imt & imtSendToEventLog))
	{
		return true;
	}
	else
	{
		return false;
	}
}

bool IsNotAnError(int iError) { return iError == idbgCreatedFont; }


struct DebugErrorString
{
	int iErrNum;
	const ICHAR* szString;
};

#define IShipError(a,b)
#define IDebugError(a,b,c) { (b), TEXT(c) },
DebugErrorString g_rgDebugErrors[] = {
#include "debugerr.h"
	{0, 0}
};

const int g_cDebugErrors = sizeof(g_rgDebugErrors)/sizeof(DebugErrorString);

#undef IShipError
#undef IDebugError

const IMsiString& GetDebugErrorString(int iError)
{
	// find the debug string in our global table
	// NOTE: we could do a fancy binary search here, but this function won't be called very often
	MsiString strRet;

	// 0th element is a debug error prefix
	for(int i = 1; i < g_cDebugErrors; i++)
	{
		if(iError == g_rgDebugErrors[i].iErrNum)
		{
			strRet = g_rgDebugErrors[0].szString;
			strRet += g_rgDebugErrors[i].szString;
		}
	}

	return strRet.Return();
}

imsEnum CMsiEngine::Message(imtEnum imt, IMsiRecord& riRecord)
{
	const IMsiString* pistrTemp;
	int iSuppressLog = 0;   // set to imtSuppressLog to disable logging of this message
	int imsg = (unsigned)(imt & ~iInternalFlags) >> imtShiftCount;  // message header message
	if (m_piParentEngine) // if nested install, route messages to parent engine
	{
		if (imsg == (imtCommonData  >> imtShiftCount))
			return imsOk;  //!! ignore nested parameters - keep parents' - for all paramters??
	}
	MsiString strMessageTemplate;

	imsEnum imsReturn = imsNone;
	if(m_scmScriptMode != scmRunScript)
	{
		if(imsg == (imtActionStart >> imtShiftCount))
		{
			// we are about to send an ActionStart message from an action, set the flag
			m_fDispatchedActionStart = fTrue;
		}
		else if(!m_fDispatchedActionStart && m_pCachedActionStart && !m_fInExecuteRecord &&
				  (imsg == imtActionData >> imtShiftCount))
		{
			// progress message from an action, need to dispatch ActionStart message
			m_scmScriptMode = scmIdleScript;
			imsReturn = Message(imtActionStart, *m_pCachedActionStart);
			m_fDispatchedActionStart = fTrue;
			if (imsReturn == imsCancel)
				return imsReturn;
		}
	}

	bool fOnlyOK = false;
	MsiString strDebugErrorTemplate;
	switch(imsg)
	{
	case imtCommonData  >> imtShiftCount: // [1] == icmtLangId: [2] LANGID  [3] codepage
												     // [1] == icmtCaption: [2] caption
												     // [1] == icmtCancel: [2] enable/disable cancel button
		if(riRecord.GetInteger(1) == icmtCaption)
		{
			// need to format string
			riRecord.SetMsiString(2, *MsiString(FormatText(*MsiString(riRecord.GetMsiString(2)))));
		}
		pistrTemp = m_rgpiMessageHeader[imsg];
		if (pistrTemp)
		{
			strMessageTemplate = TEXT("{{");
			strMessageTemplate += *pistrTemp;
			strMessageTemplate += TEXT("}}");
		}
		else
			strMessageTemplate = TEXT("{{[1]:[2] [3]}}");
		break;

	case imtInfo        >> imtShiftCount: // informative message, no action should be taken
	case imtWarning        >> imtShiftCount: // warning message, field[1] is error, not fatal
	case imtError          >> imtShiftCount: // error message, field[1] is error
	case imtUser           >> imtShiftCount: // request message
	case imtFatalExit      >> imtShiftCount: // fatal exit message from server to client
	case imtOutOfDiskSpace >> imtShiftCount:
	{
		int iError = riRecord.GetInteger(1);
		if (iError >= imsgStart) // ignore messages out of range
		{
			MsiString istrMessage = riRecord.GetMsiString(0);
			if (istrMessage.TextSize() == 0)
			{
				istrMessage = GetErrorTableString(iError);
				if ( istrMessage.TextSize() == 0 )
				{
					// don't have an error string - need to display on an "OK" button
					// and return imsNone below
					fOnlyOK = true;
					imt = imtEnum(imt & imtTypeMask);

					if (iError >= idbgBase && !IsNotAnError(iError))
					{
						strDebugErrorTemplate = GetDebugErrorString(iError);
						imsg = imsgDebugError;
					}
					else if (m_rgpiMessageHeader[imsgDefaultError])
					{
						istrMessage = *m_rgpiMessageHeader[imsgDefaultError];
						istrMessage.Return();  // AddRef
					}
				}
			}
			pistrTemp = m_rgpiMessageHeader[imsg];
			if (pistrTemp)
				strMessageTemplate = *pistrTemp, pistrTemp->AddRef();
			strMessageTemplate += istrMessage;
		}
		break;
	}
	case imtActionStart >> imtShiftCount: // start of action, field[1] is action name
		m_fProgressByData = false;
		if(m_istrLogActions.TextSize())
		{
			// check if we should enable logging for this Action
			MsiString strAction = riRecord.GetMsiString(easAction);
			MsiString strDelimPreAction = MsiString(MsiString(*TEXT(";")) + strAction);
			MsiString strDelimPostAction = MsiString(strAction + MsiString(*TEXT(";")));
			MsiString strDelimPrePostAction = strDelimPreAction + MsiString(*TEXT(";"));
			if(m_istrLogActions.Compare(iscExactI, strAction) ||
				m_istrLogActions.Compare(iscStartI, strDelimPostAction) ||
				m_istrLogActions.Compare(iscEndI, strDelimPreAction) ||
				m_istrLogActions.Compare(iscWithinI, strDelimPrePostAction))
			{
				m_fLogAction = fTrue;
			}
			else
			{
				m_fLogAction = fFalse;
				iSuppressLog = imtSuppressLog;
			}
		}
		if (m_piActionDataFormat)
			m_piActionDataFormat->Release(), m_piActionDataFormat = 0;
		if (m_piActionDataLogFormat)
			m_piActionDataLogFormat->Release(), m_piActionDataLogFormat = 0;
		pistrTemp = m_rgpiMessageHeader[imsgActionStart];
		if (pistrTemp)
			strMessageTemplate = *pistrTemp, pistrTemp->AddRef();
		if (!riRecord.IsNull(easActionTemplate))
		{
			//!! should be a more efficient way of doing this
			MsiString strFormat = TEXT("{{");
			strFormat += MsiString(riRecord.GetMsiString(easAction));
			strFormat += TEXT(": }}");
			strFormat += MsiString(riRecord.GetMsiString(easActionTemplate));
			m_piActionDataFormat = strFormat, m_piActionDataFormat->AddRef();
		}

		{
		MsiString strDescription = riRecord.GetMsiString(2);
		riRecord.SetMsiString(2, *MsiString(FormatText(*strDescription)));
		}
		break;
	case imtActionData >> imtShiftCount:  // data associated with individual action item
		// set data format template
		if (m_piActionDataFormat)
			strMessageTemplate = *m_piActionDataFormat, m_piActionDataFormat->AddRef();
		if (!m_fLogAction)   // selectively logging actions, suppress data from other actions
			iSuppressLog = imtSuppressLog;
		// trigger progress if data record driven
		if (m_fProgressByData)
		{
			using namespace ProgressData;
			PMsiRecord pRecord = &m_riServices.CreateRecord(3);
			pRecord->SetInteger(imdSubclass, iscProgressReport);
			pRecord->SetInteger(imdIncrement, 0);
			imsReturn = Message(imtProgress, *pRecord);
			if(imsReturn == imsCancel || imsReturn == imsAbort)  // cancel button hit
				return imsReturn;
		}
		break;
	case imtProgress >> imtShiftCount:    // progress gauge info, field[1] is units of 1/1024
		if (riRecord.GetInteger(ProgressData::imdSubclass) == ProgressData::iscActionInfo)
			m_fProgressByData = riRecord.GetInteger(ProgressData::imdType) != 0;
		else if (riRecord.GetInteger(ProgressData::imdSubclass) == ProgressData::iscProgressAddition)
			m_iProgressTotal += riRecord.GetInteger(ProgressData::imdProgressTotal);
		break;
	};

	if (strDebugErrorTemplate.TextSize())
	{
		Assert(riRecord.IsNull(0));
		riRecord.SetMsiString(0, *MsiString(FormatText(*strDebugErrorTemplate)));
		g_MessageContext.Invoke(imtInfo, &riRecord); // ignore return
		riRecord.SetNull(0);
	}

	if (!strMessageTemplate.TextSize())  // no template supplied above
		strMessageTemplate = riRecord.GetMsiString(0); // check if record has a template
	if (strMessageTemplate.TextSize())
		riRecord.SetMsiString(0, *MsiString(FormatText(*strMessageTemplate)));

	imsReturn = g_MessageContext.Invoke(imtEnum(imt | iSuppressLog), &riRecord);
	if(fOnlyOK)
	{
		// buttons changed to just OK, need to change return type to imsNone as caller must handle
		// that value
		imsReturn = imsNone;
	}

	if ( ShouldGoToEventLog(imt) )
	{
		int iError = riRecord.GetInteger(1);

		if ( iError != iMsiStringBadInteger )
		{
			int iEventId = iError >= idbgBase ? EVENTLOG_TEMPLATE_ERROR_5 : 
			             (!iError ? EVENTLOG_TEMPLATE_ERROR_5 : 
                                    EVENTLOG_ERROR_OFFSET + iError);
			ReportToEventLog(EVENTLOG_ERROR_TYPE,
								  iEventId,
								  riRecord);
		}
		else
		{
			ReportToEventLog(EVENTLOG_ERROR_TYPE,
								  EVENTLOG_TEMPLATE_EXCEPTION,
								  riRecord);
		}
	}

	return imsReturn;
}

// Only send this message once every 150 milliseconds
const unsigned int lTickMin = 150;

imsEnum CMsiEngine::ActionProgress()
{

	DWORD lTickCur;

	if (((int)(m_lTickNextProgress - (lTickCur = GetTickCount()))) > 0)
		return imsOk;

	m_lTickNextProgress = lTickCur + lTickMin;

	if (!m_pActionProgressRec)
	{
		using namespace ProgressData;
		m_pActionProgressRec = &m_riServices.CreateRecord(2);
		AssertNonZero(m_pActionProgressRec->SetInteger(imdSubclass, iscProgressReport));
		AssertNonZero(m_pActionProgressRec->SetInteger(imdIncrement, 0));
	}

	return Message(imtProgress, *m_pActionProgressRec);
}


// LoadLibrary which first looks in this DLL's directory

extern HINSTANCE g_hInstance;

HINSTANCE MsiLoadLibrary(const ICHAR* szModuleName, Bool fDataOnly)
{
	ICHAR rgchPath[MAX_PATH] = {0};   // load full path first in this directory
	int cch = WIN::GetModuleFileName(g_hInstance, rgchPath, (sizeof(rgchPath)/sizeof(ICHAR))-1);
	rgchPath[(sizeof(rgchPath)/sizeof(ICHAR))-1] = 0;
	ICHAR* pch = rgchPath + cch;
	while (*(pch = WIN::CharPrev(rgchPath, pch)) != chDirSep)
		cch--;
	StringCchCopy(pch + 1, ARRAY_ELEMENTS(rgchPath) - cch, szModuleName);
	HINSTANCE hInstance = WIN::LoadLibraryEx(rgchPath, 0,
									fDataOnly ? LOAD_LIBRARY_AS_DATAFILE : 0);
	if (!hInstance)
		hInstance = WIN::LoadLibraryEx(szModuleName, 0,     // probably in system
									fDataOnly ? LOAD_LIBRARY_AS_DATAFILE : 0);
	return hInstance;
}

int GetInstallerMessage(UINT iError, ICHAR* rgchBuf, int cchBuf)
{
	DWORD cchMsg = WIN::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, iError, 0, rgchBuf, cchBuf, 0);
	if (cchMsg == 0)  // message not in system message file
	{
		if (g_hInstance != 0)
			if (MsiLoadString(g_hInstance, iError, rgchBuf, cchBuf, 0))
				cchMsg = IStrLen(rgchBuf);
	}
	else if (cchMsg >= 2)
		cchMsg -= 2; // remove CR/LF
	rgchBuf[cchMsg] = 0;
	return cchMsg;
}

const int cchMessageBuffer = 512;

const IMsiString& GetInstallerMessage(UINT iError)
{
	CTempBuffer<ICHAR,1> rgchBuffer(cchMessageBuffer);
	int cchMsg = GetInstallerMessage(iError, rgchBuffer, rgchBuffer.GetSize());
	const IMsiString* pistr = &g_MsiStringNull;
	if (cchMsg)
		pistr->SetString(rgchBuffer, pistr);
	return *pistr;
}

imsEnum CMsiEngine::LoadHandler()
{
	if (m_piParentEngine)
		return imsNone;
	g_MessageContext.m_piEngine = this;
	imsEnum ims = g_MessageContext.Invoke(imtLoadHandler, 0);
	return ims;
}

void CMsiEngine::ReleaseHandler(void)
{
	if (!m_piParentEngine)
		g_MessageContext.Invoke(imtFreeHandler, 0);
}

CMsiCustomActionManager* CMsiEngine::GetCustomActionManager()
{
	AssertSz(g_scServerContext != scService, TEXT("Wrong context for engine's custom action manager"));

	CMsiCustomActionManager* pManager = NULL;
	EnterCriticalSection(&m_csCreateProxy);

	// always use the CA Manager from the parent install
	if (m_piParentEngine)
	{
		pManager = m_piParentEngine->GetCustomActionManager();
	}
	else
	{
		// the engine only stores the custom action manager on the client side
		// in the service, the configuration manager is responsible for holding the custom action manager
		// the client cannot create elevated custom action servers, so it does not have to worry about 
		// remapping HKCU
		if (!m_pCustomActionManager)
			m_pCustomActionManager = new CMsiCustomActionManager(/* fRemapHKCU */ false);

		pManager = m_pCustomActionManager;
	}
	LeaveCriticalSection(&m_csCreateProxy);
	return pManager;
}

UINT CMsiEngine::ShutdownCustomActionServer()
{
	EnterCriticalSection(&m_csCreateProxy);
	if (m_pCustomActionManager)
	{
		m_pCustomActionManager->ShutdownCustomActionServer();
		delete m_pCustomActionManager;
		m_pCustomActionManager = 0;
	}
	LeaveCriticalSection(&m_csCreateProxy);
	return ERROR_SUCCESS;
};


IMsiHandler* CMsiEngine::GetHandler() //!!# drop this function?
{
	if (m_piParentEngine)
		return 0;
	if (g_MessageContext.m_piHandler)
		g_MessageContext.m_piHandler->AddRef();
	return g_MessageContext.m_piHandler;
}

//____________________________________________________________________________
//
// Action definitions
//____________________________________________________________________________

// scripting engine definitions
#undef  DEFINE_GUID  // force GUID initialization
#define DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
	const GUID name = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#include <activscp.h> // ActiveScript Interfaces and IIDs
const GUID IID_VBScript = {0xb54f3741L,0x5b07,0x11cf,{0xa4,0xb0,0x00,0xaa,0x00,0x4a,0x55,0xe8}};
const GUID IID_JScript  = {0xf414c260L,0x6ac0,0x11cf,{0xb6,0xd1,0x00,0xaa,0x00,0xbb,0xbb,0x58}};

const ICHAR sqlCustomAction[] =
	TEXT("SELECT `Action`,`Type`,`Source`,`Target`, NULL FROM `CustomAction` WHERE `Action` = '%s'");
enum icolCustomAction
{
	icolAction = 1,
	icolActionType,
	icolSource,
	icolTarget,
	icolContextData, // scheduled execution record only, not in table
}; // NOTE: Assumption made that columns in execution record are identical to table query

const ICHAR sqlCustomActionFile[] =
	TEXT("SELECT `FileName`, `Directory_` FROM `File`,`Component` WHERE `File`='%s' AND `Component_`=`Component`");

const ICHAR sqlCustomActionBinary[] =
	TEXT("SELECT `Data` FROM `Binary` WHERE `Name`='%s'");

//____________________________________________________________________________
//
// CScriptSite definition - client for scripting engine
//____________________________________________________________________________

class CScriptSite : public IActiveScriptSite, public IActiveScriptSiteWindow
{
 public:  // external methods
	friend CScriptSite* CreateScriptSite(const IID& riidLanguage, IDispatch* piHost, HWND hwndParent, LANGID langid);
	friend void DestroyScriptSite(CScriptSite*& rpiScriptSite);
	HRESULT ParseScript(const TCHAR* szFile, int cchScriptMax);
	HRESULT CallScriptFunction(const TCHAR* szFunction);
	HRESULT GetIntegerResult(int& riResult);
//      HRESULT GetStringResult(const WCHAR*& rszResult); // pointer valid until next CallScriptFunction
	HRESULT      GetErrorCode();
	const TCHAR* GetErrorObjName();
	const TCHAR* GetErrorObjDesc();
	const TCHAR* GetErrorSourceLine();
	int          GetErrorLineNumber();
	int          GetErrorColumnNumber();
	void    ClearError();  // release error strings
 private: // IUnknown virtual methods implemented
	HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj);
	ULONG   __stdcall AddRef();
	ULONG   __stdcall Release();
 private: // IActiveScriptSite virtual methods implemented
	HRESULT __stdcall GetLCID(LCID* plcid);
	HRESULT __stdcall GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown** ppiunkItem, ITypeInfo** ppti);
	HRESULT __stdcall GetDocVersionString(BSTR* pszVersion);
	HRESULT __stdcall OnScriptTerminate(const VARIANT* pvarResult, const EXCEPINFO* pexcepinfo);
	HRESULT __stdcall OnStateChange(SCRIPTSTATE ssScriptState);
	HRESULT __stdcall OnScriptError(IActiveScriptError* pscripterror);
	HRESULT __stdcall OnEnterScript();
	HRESULT __stdcall OnLeaveScript();
 private: // IActiveScriptSiteWindow virtual methods implemented
	HRESULT __stdcall GetWindow(HWND* phwnd);
	HRESULT __stdcall EnableModeless(BOOL fEnable);
 private: // internal methods
	CScriptSite(HWND hwndParent, LANGID langid);
  ~CScriptSite();
	HRESULT AttachScriptEngine(const IID& iidLanguage, IDispatch* piHost);
	HRESULT CloseScriptEngine();
	void    SaveErrorString(const TCHAR*& rszSave, BSTR szData);
 private: // internal data
	int         m_iRefCnt;
	SCRIPTSTATE m_ssScriptState;
	HWND        m_hwnd;
	LANGID      m_langid;
	int         m_iCodePage;
	bool        m_fCoInitialized;
	IActiveScript*      m_piScriptEngine;
	IActiveScriptParse* m_piScriptParse;
	IDispatch*          m_piHost;
	VARIANT     m_varResult;
 private: // set by OnScriptError callback
	HRESULT       m_hrError;
	const TCHAR*  m_szErrorObj;
	const TCHAR*  m_szErrorDesc;
	const TCHAR*  m_szSourceLine;
	ULONG         m_iErrorLine;
	LONG          m_iErrorColumn;
};
inline HRESULT      CScriptSite::GetErrorCode()         {return m_hrError;}
inline const TCHAR* CScriptSite::GetErrorObjName()      {return m_szErrorObj;}
inline const TCHAR* CScriptSite::GetErrorObjDesc()      {return m_szErrorDesc;}
inline const TCHAR* CScriptSite::GetErrorSourceLine()   {return m_szSourceLine;}
inline int          CScriptSite::GetErrorLineNumber()   {return m_iErrorLine;}
inline int          CScriptSite::GetErrorColumnNumber() {return m_iErrorColumn;}

//____________________________________________________________________________
//
//  Custom action thread management
//____________________________________________________________________________

// class holding data required for cleanup after custom action termination

class CActionThreadData
{
public:
	CActionThreadData(IMsiMessage& riMessage, CMsiEngine* piEngine, const ICHAR* szAction, int icaFlags,
					  const IMsiString* pistrActionEndLogTemplate, bool fRunScriptElevated, bool fAppCompat,
					  const GUID* pguidAppCompatDB, const GUID* pguidAppCompatID);
  ~CActionThreadData();
	void InitializeRemoteDLL(const IMsiString& ristrLibrary, const IMsiString& ristrEntry, MSIHANDLE hInstall);
	void InitializeRemoteScript(const IMsiString& ristrSource, const IMsiString& ristrTarget, MSIHANDLE hInstall);
	Bool InitializeDLL(const IMsiString& ristrLibrary, const IMsiString& ristrEntry, MSIHANDLE hInstall);
	void InitializeEXE(const IMsiString& ristrPath, const IMsiString& ristrCommandLine);
	void InitializeInstall(const IMsiString& ristrProduct, const IMsiString& ristrCommandLine,iioEnum iioOptions);
	Bool CreateTempFile(IMsiStream& riStream, const IMsiString*& rpiPath);
	iesEnum RunThread();
	MsiString           m_strAction;   // name of action
	int                 m_icaFlags;    // custom action type flags
	HANDLE              m_hThread;     // thread handle that called action
	MSIHANDLE           m_hMsi;        // MSI engine handle to close
	DWORD               m_dwThreadId;  // thread ID of handle creator
	DWORD               m_dwRunThreadId; // ID of actualy thread being run
	HINSTANCE           m_hLib;        // DLL handle for DLL action
	PCustomActionEntry  m_pfEntry;     // DLL entry point address
	const IMsiString*   m_pistrTemp;   // temporary file to delete
	const IMsiString*   m_pistrProduct;// product for nested install, source for EXE action
	const IMsiString*   m_pistrCmdLine;// command line for EXE action or nested install
	const IMsiString*   m_pistrActionEndLogTemplate; // template for action end log message
	CMsiEngine*         m_piEngine;    // engine calling this custom action - NULL if called from script
	IMsiMessage&        m_riMessage;   // progress message handler, client engine or server proxy
	CActionThreadData*  m_pNext;       // next in linked list of active actions
	PThreadEntry        m_pfThread;    // thread entry point
	iioEnum             m_iioOptions;  // options for nested install
	bool                m_fDisableMessages; // set if the custom action is a DLL action called from the UI thread
	bool                m_fElevationEnabled; // if false, CAs will always impersonate, even if marked to elevate
	DWORD               m_dwLaunchingThread; // thread invoking the action
	bool                m_fAppCompat;  // true if this package has potential custom action app compat shims
	GUID                m_guidAppCompatDB; 
	GUID                m_guidAppCompatID;
};

DWORD WINAPI CustomDllThread(CActionThreadData* pActionData);
DWORD WINAPI CustomRemoteDllThread(CActionThreadData* pActionData);
DWORD WINAPI CustomExeThread(CActionThreadData* pActionData);
DWORD WINAPI NestedInstallThread(CActionThreadData* pActionData);
DWORD WINAPI CustomRemoteScriptThread(CActionThreadData* pActionData);

CActionThreadData::CActionThreadData(IMsiMessage& riMessage, CMsiEngine* piEngine, const ICHAR* szAction,
				     int icaFlags, const IMsiString* pistrActionEndLogTemplate,
					 bool fElevationEnabled, bool fAppCompat, 
					 const GUID* pguidAppCompatDB, const GUID* pguidAppCompatID)
    : m_riMessage(riMessage), m_piEngine(piEngine), m_strAction(szAction)
	, m_icaFlags(icaFlags), m_pistrActionEndLogTemplate(pistrActionEndLogTemplate)
	, m_pistrTemp(0), m_pistrCmdLine(0), m_pistrProduct(0)
	, m_hMsi(0), m_hLib(0), m_hThread(0), m_iioOptions((iioEnum)0), m_fDisableMessages(false)
	, m_fElevationEnabled(fElevationEnabled), m_fAppCompat(fAppCompat)
{
	// don't hold ref to m_piEngine - will stay around longer than thread
	ENG::InsertInCustomActionList(this);
	if(m_pistrActionEndLogTemplate)
		m_pistrActionEndLogTemplate->AddRef();
	if (fAppCompat && pguidAppCompatDB)
		memcpy(&m_guidAppCompatDB, pguidAppCompatDB, sizeof(m_guidAppCompatDB));
	else
		memset(&m_guidAppCompatDB, 0, sizeof(m_guidAppCompatDB));
	if (fAppCompat && pguidAppCompatID)
		memcpy(&m_guidAppCompatID, pguidAppCompatID, sizeof(m_guidAppCompatID));
	else
		memset(&m_guidAppCompatID, 0, sizeof(m_guidAppCompatID));
	m_dwLaunchingThread = MsiGetCurrentThreadId();
}

CActionThreadData::~CActionThreadData()
{
	if ((m_icaFlags & icaTypeMask) == icaDll)
	{
		if (m_hLib)
			AssertNonZero(WIN::FreeLibrary(m_hLib));
		AssertZero(CloseMsiHandle(m_hMsi, m_dwThreadId));

		// only Win9X needs to close the handles here. On WindowsNT/2000, the actions are
		// run in a different process, and must be closed based on the thread Id in the
		// remote process
		UINT cHandles = 0;
		if (m_dwRunThreadId && g_fWin9X && ((cHandles = CheckAllHandlesClosed(true, m_dwRunThreadId)) != 0))
		{
			// if messages were disabled for this action, we certainly can't post one now.
			if (!m_fDisableMessages)
				m_riMessage.Message(imtInfo, *PMsiRecord(::PostError(Imsg(idbgCustomActionLeakedHandle), *m_strAction, cHandles)));
		}
	}

	if (m_pistrTemp)   // temp file created from Binary table stream
	{
		CElevate elevate; // elevate to remove file in %windows%\msi folder

		BOOL fDeleted = WIN::DeleteFile(m_pistrTemp->GetString());
		if (!fDeleted && (m_icaFlags & (icaTypeMask | icaAsync | icaContinue)) != (icaExe | icaAsync | icaContinue))
		{

			WIN::Sleep(100);  //!! need wait here, as EXE doesn't appear to be deletable for a while
			AssertNonZero(WIN::DeleteFile(m_pistrTemp->GetString())); // not much we can do if this fails
		}
		m_pistrTemp->Release();
	}
	if(m_pistrActionEndLogTemplate)
		m_pistrActionEndLogTemplate->Release();
	RemoveFromCustomActionList(this);
}

void CActionThreadData::InitializeRemoteDLL(const IMsiString& ristrLibrary, const IMsiString& ristrEntry, MSIHANDLE hInstall)
{
	(m_pistrCmdLine = &ristrLibrary)->AddRef();
	(m_pistrProduct = &ristrEntry)->AddRef();
	m_pfThread = (PThreadEntry)CustomRemoteDllThread;
	m_hMsi = hInstall;

	// store thread to free handle from custom action's thread. This
	// could be called via a DoAction() call in another custom action, so
	// we must handle thread impersonation.
	m_dwThreadId = WIN::MsiGetCurrentThreadId();
}

void CActionThreadData::InitializeRemoteScript(const IMsiString& ristrSource, const IMsiString& ristrTarget, MSIHANDLE hInstall)
{
	(m_pistrCmdLine = &ristrSource)->AddRef();
	(m_pistrProduct = &ristrTarget)->AddRef();
	m_pfThread = (PThreadEntry)CustomRemoteScriptThread;

	// special case, ownership of m_hMSI transfers to the automation object
	m_hMsi = hInstall;

	// store thread to free handle from custom action's thread. This
	// could be called via a DoAction() call in another custom action, so
	// we must handle thread impersonation.
	m_dwThreadId = WIN::MsiGetCurrentThreadId();
}

Bool CActionThreadData::InitializeDLL(const IMsiString& ristrLibrary, const IMsiString& ristrEntry, MSIHANDLE hInstall)
{
    // this function should never run on NT/2000. Every DLL should be run out-of-proc
    AssertSz(g_fWin9X, TEXT("Running in-proc DLL on NT."));

    g_MessageContext.DisableTimeout();
    UINT uiErrorMode = WIN::SetErrorMode(SEM_FAILCRITICALERRORS);
    m_hLib = WIN::LoadLibrary(ristrLibrary.GetString());
    WIN::SetErrorMode(uiErrorMode);
    if (m_hLib != 0)
    {
#ifdef UNICODE
		char rgchEntry[260];
		rgchEntry[0] = 0;
		if(WIN::WideCharToMultiByte(CP_ACP, 0, ristrEntry.GetString(), -1, rgchEntry, sizeof(rgchEntry), 0, 0))
		{
			m_pfEntry = (PCustomActionEntry)WIN::GetProcAddress(m_hLib, rgchEntry);
		}
		else
		{
			m_pfEntry = NULL;
		}
#else
		m_pfEntry = (PCustomActionEntry)WIN::GetProcAddress(m_hLib, ristrEntry.GetString());
#endif
	}
	g_MessageContext.EnableTimeout();
	if (!m_hLib || !m_pfEntry)
	{
		::MsiCloseHandle(hInstall);
		return fFalse;
	}
	m_hMsi = hInstall;

	// store thread to free handle from custom action's thread. This
	// could be called via a DoAction() call in another custom action, so
	// we must handle thread impersonation.
	m_dwThreadId = WIN::MsiGetCurrentThreadId();
	m_pfThread = (PThreadEntry)CustomDllThread;
	return fTrue;
}

void CActionThreadData::InitializeEXE(const IMsiString& ristrPath, const IMsiString& ristrCommandLine)
{
	(m_pistrCmdLine = &ristrCommandLine)->AddRef();
	(m_pistrProduct = &ristrPath)->AddRef();
	m_pfThread = (PThreadEntry)CustomExeThread;
}

void CActionThreadData::InitializeInstall(const IMsiString& ristrProduct, const IMsiString& ristrCommandLine,
														iioEnum iioOptions)
{
	(m_pistrProduct = &ristrProduct)->AddRef();
	m_pistrCmdLine = &ristrCommandLine;   // refcnt bumped by FormatText result
	m_pfThread = (PThreadEntry)NestedInstallThread;
	m_iioOptions = iioOptions;
}

Bool CActionThreadData::CreateTempFile(IMsiStream& riStream, const IMsiString*& rpiPath)
{
	//?? Do we have an impersonation problem here if we're running this on the server and the temp
	//?? directory is on the server? - malcolmh

	CElevate elevate; // elevate in case creating file in %windows%\msi
	CTempBuffer<ICHAR,1> rgchTempPath(MAX_PATH);

	// this file must be secured, to prevent someone else from tampering with the bits.
	// it will be possible for someone else to read it (to allow impersonation,) and
	// potentially run it, but only with their permissions.
	HANDLE hTempFile = INVALID_HANDLE_VALUE;

	if (RunningAsLocalSystem())
	{
		hTempFile = OpenSecuredTempFile(/*fHidden*/ false, rgchTempPath);
	}
	else
	{
		MsiString strTempFolder = ENG::GetTempDirectory();

		//!! SECURITY:  This needs to be secured to the user, so that another
		// user may not slide in new bits.
		if (WIN::GetTempFileName(strTempFolder, TEXT("MSI"), 0, rgchTempPath) == 0)
			return fFalse; //!! should never happen except permission error

		hTempFile = WIN::CreateFile(rgchTempPath, GENERIC_WRITE, FILE_SHARE_READ, 0,
				TRUNCATE_EXISTING,  (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS),
				0);    // INVALID_HANDLE_VALUE will fail at WriteFile
	}

	CTempBuffer<char,1> rgbBuffer(512);
	int cbWrite;
	do
	{
		cbWrite = riStream.GetData(rgbBuffer, rgbBuffer.GetSize());
		DWORD cbWritten;
		if (cbWrite && !WIN::WriteFile(hTempFile, rgbBuffer, cbWrite, &cbWritten, 0))
			cbWrite = -1; // force failure, exit loop, test below
	} while (cbWrite == rgbBuffer.GetSize());
	if (hTempFile != INVALID_HANDLE_VALUE)
		WIN::CloseHandle(hTempFile); // LoadLibrary fails if handle left open
	if (cbWrite == -1)  // failure creating temp file
		return fFalse;
	MsiString istrPath(static_cast<ICHAR*>(rgchTempPath));
	(m_pistrTemp = istrPath)->AddRef();
	istrPath.ReturnArg(rpiPath);
	return fTrue;
}

iesEnum CActionThreadData::RunThread()
{
	int icaFlags = m_icaFlags;  // need to make copy in case this object deleted
	Bool fAsync = icaFlags & icaAsync ? fTrue : fFalse;

	// Disable messages for synchronous DLL custom actions called from the UI thread. These
	// are typically invoked via the DoAction ControlEvent. If we allow messages through
	// then we'll block in Invoke's critical section and we'll be hung.

	if (fAsync == fFalse)
	{
		if (g_MessageContext.IsUIThread())
			m_fDisableMessages = true;
	}

	HANDLE hThread = m_hThread = WIN::CreateThread((LPSECURITY_ATTRIBUTES)0, 4096*10,
											m_pfThread, (LPVOID)this, 0, &m_dwRunThreadId);
	AssertSz(m_hThread, TEXT("CreateThread for custom action failed"));
	if (!m_hThread)
		return iesFailure;
	
	DWORD iWait = WAIT_OBJECT_0;
	DWORD iReturn = ERROR_SUCCESS;

	IMsiMessage& riMessage = m_riMessage; // cache, thread may delete this object
	if (fAsync == fFalse)
	{
		if (GetTestFlag('T')) // old code before UI refresh put into engine wait loops
		{
			do
			{
				iWait = WIN::WaitForSingleObject(hThread, 20);
				g_MessageContext.Invoke(imtProgress, g_piNullRecord);  // refresh UI
			} while (iWait == WAIT_TIMEOUT);  // allow messages to be processed in main thread
		}
		else  // UI handles timeout in separate thread
		{
			g_MessageContext.DisableTimeout();
			for(;;)
			{
				iWait = WIN::MsgWaitForMultipleObjects(1, &hThread, FALSE, INFINITE, QS_ALLINPUT);
				if (iWait == WAIT_OBJECT_0 + 1)  // window Msg
				{
					MSG msg;
					while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
					{
						WIN::TranslateMessage(&msg);
						WIN::DispatchMessage(&msg);
					}
					continue;
				}
				else break;
			}
			g_MessageContext.EnableTimeout();
		}

		WIN::GetExitCodeThread(hThread, &iReturn);  // can't access member data, may be deleted
		WIN::CloseHandle(hThread);  // still running if async, else pThreadData deleted
	}
	// NOTE: nested installs always have icaNoTranslate set
	if(icaFlags & icaNoTranslate)
		return (iesEnum)iReturn;// return the result as is

	switch (iReturn)
	{
	case ERROR_FUNCTION_NOT_CALLED:  return iesNoAction;
	case ERROR_SUCCESS:              return fAsync ? (iesEnum)iesNotDoneYet : iesSuccess;
	case ERROR_INSTALL_USEREXIT:     return iesUserExit;
	case ERROR_INSTALL_FAILURE:      return iesFailure;
	case ERROR_INSTALL_SUSPEND:      return iesSuspend;
	case ERROR_MORE_DATA:            return iesFinished; // for backwards compatibility, maps to same value as ERROR_NO_MORE_ITEMS
	case ERROR_NO_MORE_ITEMS:        return iesFinished;
	case ERROR_INVALID_HANDLE_STATE: return iesWrongState;
	case ERROR_ARENA_TRASHED:        return iesBadActionData;
	case ERROR_CREATE_FAILED:        return (iesEnum)iesExeLoadFailed; // error will be posted on return
	case ERROR_INSTALL_REBOOT_NOW:   return (iesEnum)iesRebootNow;
	case ERROR_INSTALL_REBOOT:                 return (iesEnum)iesReboot;
	case ERROR_SUCCESS_REBOOT_REQUIRED: return (iesEnum)iesRebootRejected;
	case ERROR_DLL_NOT_FOUND:        return (iesEnum)iesDLLLoadFailed;
	case ERROR_INVALID_DLL:          return (iesEnum)iesDLLLoadFailed;
	case ERROR_INSTALL_SERVICE_FAILURE: return (iesEnum)iesServiceConnectionFailed;
	default:                         return iesFailure;
	}
}

Bool ThreadLogActionEnd(CActionThreadData* pActionData, DWORD iReturn)
{
	if(pActionData->m_icaFlags & icaAsync)
	{
		// log action end
		PMsiRecord pLogRecord = &ENG::CreateRecord(2);
		if(pActionData->m_pistrActionEndLogTemplate)
			AssertNonZero(pLogRecord->SetMsiString(0,*(pActionData->m_pistrActionEndLogTemplate)));
		AssertNonZero(pLogRecord->SetMsiString(1,*(pActionData->m_strAction)));
		AssertNonZero(pLogRecord->SetInteger(2,iReturn));
		pActionData->m_riMessage.Message(imtInfo,*pLogRecord);
	}
	return fTrue;
}

DWORD WINAPI NestedInstallThread(CActionThreadData* pActionData)
{
	ireEnum ireProductSpec;
	// only substorage and product code nested installs are supported
	switch (pActionData->m_icaFlags & icaSourceMask)
	{
	case icaBinaryData: ireProductSpec = ireSubStorage;  break; // database in substorage
	case icaDirectory:  ireProductSpec = ireProductCode; break; // product code, advertised or installed
	case icaSourceFile: ireProductSpec = irePackagePath; break; // relative to install source root
	default: AssertSz(0, "Invalid nested install type"); // fall through
	case icaProperty:   ireProductSpec = irePackagePath; break; // already resolved to property
	}

	DWORD iReturn = CreateAndRunEngine(ireProductSpec, pActionData->m_pistrProduct->GetString(), 0,
															pActionData->m_pistrCmdLine->GetString(),
															pActionData->m_piEngine,
															pActionData->m_iioOptions);
	pActionData->m_pistrProduct->Release();
	pActionData->m_pistrCmdLine->Release();

	AssertNonZero(ThreadLogActionEnd(pActionData,iReturn));

	// if "ignore error" bit is set - change non-success codes to success
	Assert(iReturn != ERROR_SUCCESS_REBOOT_INITIATED);
	if ((pActionData->m_icaFlags & icaContinue) != 0 &&
		 iReturn != ERROR_SUCCESS &&
		 iReturn != ERROR_INSTALL_USEREXIT &&
		 iReturn != ERROR_INSTALL_REBOOT &&
		 iReturn != ERROR_INSTALL_REBOOT_NOW &&
		 iReturn != ERROR_SUCCESS_REBOOT_REQUIRED)
	{
		iReturn = ERROR_SUCCESS;
	}
	else if (iReturn == ERROR_FILE_NOT_FOUND)
		iReturn = ERROR_CREATE_FAILED;  // force error message
	AssertSz(!(pActionData->m_icaFlags & icaAsync), "Invalid nested install type");
	delete pActionData;
	WIN::ExitThread(iReturn);
	return iReturn;  // never gets here, needed to compile
}

// GetCustomActionManager tracks down the custom action manager that is appropriate
// for this process. In the service it gets the global ConfigMgr object and asks
// it for the object. In the client, it takes the provided engine pointer and
// retrieves the object from it.
CMsiCustomActionManager *GetCustomActionManager(IMsiEngine *piEngine)
{
	CMsiCustomActionManager* pCustomActionManager = NULL;
	if (g_scServerContext == scService)
	{
		// in the service, the manager lives in the ConfigManager because there isn't
		// necessarily an engine
		IMsiConfigurationManager *piConfigMgr = CreateConfigurationManager();
		if (piConfigMgr)
		{
			pCustomActionManager = piConfigMgr->GetCustomActionManager();
			piConfigMgr->Release();
		}
	}
	else
	{
		Assert(piEngine);
		if (piEngine)
			pCustomActionManager = piEngine->GetCustomActionManager();
	}
	return pCustomActionManager;
}

int CustomRemoteScriptAction(bool fScriptElevate, int icaFlags, IMsiEngine* piEngine, IDispatch* piDispatch, const IMsiString& istrSource, const IMsiString& istrTarget, bool fDisableMessages, DWORD dwLaunchingThread, IMsiRecord** piMSIResult);
DWORD WINAPI CustomRemoteScriptThread(CActionThreadData* pActionData)
{
	// This function calls ExitThread. No smart COM pointers allowed on stack!
	Assert(!g_fWin9X);

	// Custom Action remote script threads MUST have COM initialized in a MTA mode, otherwise
	// COM dispatches incoming automation calls to other threads and the LRPC security checks
	// against the CA server PID start to fail.
	OLE32::CoInitializeEx(0, COINIT_MULTITHREADED);

	// create a dispatch interface for the engine, ownership of handle transfers to to automation object
 	IDispatch* piDispatch = ENG::CreateAutoEngineEx(pActionData->m_hMsi, pActionData->m_dwLaunchingThread);
	Assert(piDispatch);
	if (!piDispatch)
		return ERROR_INSTALL_FAILURE;

	// if the automation layer was successfully created, ownership of the handle passes to the 
	// automation object.
	pActionData->m_hMsi = 0;
		
	PMsiRecord piError = 0;

	// the action can elevate only if it in the service, elevated, and the script
	// is elevated.
	bool fElevate = (g_scServerContext == scService) && (pActionData->m_fElevationEnabled) && (pActionData->m_icaFlags & icaNoImpersonate) && (pActionData->m_icaFlags & icaInScript);

	iesEnum iesStatus = static_cast<iesEnum>(CustomRemoteScriptAction(fElevate, pActionData->m_icaFlags, 
			(IMsiEngine*)pActionData->m_piEngine, piDispatch, *pActionData->m_pistrCmdLine, *pActionData->m_pistrProduct, \
			pActionData->m_fDisableMessages, pActionData->m_dwLaunchingThread, &piError));

	if (piError)
	{
		piError->SetString(2, pActionData->m_strAction);
		if ((pActionData->m_icaFlags & icaContinue) != 0)
		{
			// error in script with continue bit set. Log message
			DEBUGMSGV1(TEXT("Note: %s"),MsiString(piError->FormatText(fTrue)));
			if (!pActionData->m_fDisableMessages)
				pActionData->m_riMessage.Message(imtInfo, *piError);
			iesStatus = iesSuccess;
		}
		else
		{
			// error in script without continue bit. Post error and fail.
			if (!pActionData->m_fDisableMessages)
				pActionData->m_riMessage.Message(imtEnum(imtError | imtSendToEventLog), *piError);
			iesStatus = iesFailure;
		}
	}
	else
	{
		// no error
		iesStatus = (pActionData->m_icaFlags & icaContinue) != 0 ? iesSuccess : iesStatus;
	}

	piDispatch->Release();

	// delete ActionData if CA is synchronous - if async it will be cleaned up by WaitForCustomActionThreads
	pActionData->m_pistrCmdLine->Release();
	pActionData->m_pistrProduct->Release();
	if (!(pActionData->m_icaFlags & icaAsync))
		delete pActionData;

	DWORD iReturn = 0;
	switch (iesStatus)
	{
	case iesNoAction: iReturn = ERROR_FUNCTION_NOT_CALLED; break;
	case iesSuccess:  iReturn = ERROR_SUCCESS; break;
	case iesUserExit: iReturn = ERROR_INSTALL_USEREXIT; break;
	case iesFailure:  iReturn = ERROR_INSTALL_FAILURE; break;
	case iesSuspend:  iReturn = ERROR_INSTALL_SUSPEND; break;
	case iesFinished: iReturn = ERROR_NO_MORE_ITEMS; break; 
	default:          iReturn = ERROR_INSTALL_FAILURE; break;
	}
	OLE32::CoUninitialize();
	return iReturn;
}

DWORD WINAPI CustomRemoteDllThread(CActionThreadData* pActionData)
{
	// This function calls ExitThread. No smart COM pointers allowed on stack!

	DWORD iReturn = ERROR_SUCCESS;
	icacCustomActionContext icacContext = icac32Impersonated;

	// the action can elevate only if it in the service, elevated, and the script
	// is elevated.
	bool fElevate = (g_scServerContext == scService) && (pActionData->m_fElevationEnabled) && (pActionData->m_icaFlags & icaNoImpersonate) && (pActionData->m_icaFlags & icaInScript);

	// determine custom action platform (64/32bit). No need to check on non-64 systems
	bool fIs64Bit = false;
	if (g_fWinNT64)
	{
		PMsiPath pPath = 0;
		PMsiRecord piError = 0;
		MsiString strPath = 0;
		MsiString strFilename = 0;
		IMsiServices* piServices = LoadServices();

		// split DLL path into path/file
		if ((piError = SplitPath(pActionData->m_pistrCmdLine->GetString(), &strPath, &strFilename)) == 0)
		{
			if(!piServices)
			{
				DEBUGMSG(TEXT("Failed to Load Services"));
				iReturn = ERROR_INSTALL_SERVICE_FAILURE;
			}
			else if ((piError = piServices->CreatePath(strPath,*&pPath)) == 0)
			{
				piError = pPath->IsPE64Bit(strFilename, fIs64Bit);
			}
		}
		if (piError)
			iReturn = ERROR_DLL_NOT_FOUND;

		if(piServices)
			FreeServices();
	}

	if (iReturn == ERROR_SUCCESS)
	{
		if (fIs64Bit)
		{
			//!!future - should fail if not running on 64bit machine
			icacContext = fElevate ? icac64Elevated : icac64Impersonated;
		}
		else
		{
			icacContext = fElevate ? icac32Elevated : icac32Impersonated;
		}

		// Custom Action remote threads MUST have COM initialized in a MTA mode, otherwise
		// we would need to marshall the RemoteAPI interface over to this thread before
		// passing it to the client process.
		OLE32::CoInitializeEx(0, COINIT_MULTITHREADED);

		// find the custom action manager to run the action
		CMsiCustomActionManager *pCustomActionManager = GetCustomActionManager(pActionData->m_piEngine);

		if (pCustomActionManager)
		{
			DEBUGMSG2(TEXT("Invoking remote custom action. DLL: %s, Entrypoint: %s"), pActionData->m_pistrCmdLine->GetString(), pActionData->m_pistrProduct->GetString());

			if (ERROR_SUCCESS != pCustomActionManager->RunCustomAction(icacContext, pActionData->m_pistrCmdLine->GetString(),
				pActionData->m_pistrProduct->GetString(), pActionData->m_hMsi, ((pActionData->m_icaFlags & icaDebugBreak) != 0), pActionData->m_fDisableMessages,
				pActionData->m_fAppCompat, &pActionData->m_guidAppCompatDB, &pActionData->m_guidAppCompatID, pActionData->m_riMessage, pActionData->m_strAction, &iReturn))
				iReturn = ERROR_INSTALL_SERVICE_FAILURE;
		}
		else
		{
			DEBUGMSG(TEXT("Failed to get custom action manager."));
			iReturn = ERROR_INSTALL_SERVICE_FAILURE;
		}

		OLE32::CoUninitialize();
	}

	pActionData->m_pistrCmdLine->Release();
	pActionData->m_pistrProduct->Release();

	AssertNonZero(ThreadLogActionEnd(pActionData,iReturn));

	if ((pActionData->m_icaFlags & icaContinue) != 0)
		iReturn = ERROR_SUCCESS;
	else if (iReturn == ERROR_FILE_NOT_FOUND)
		iReturn = ERROR_DLL_NOT_FOUND;  // force error message

	// delete ActionData if CA is synchronous - if async it will be cleaned up by WaitForCustomActionThreads
	if (!(pActionData->m_icaFlags & icaAsync))
		delete pActionData;

	WIN::ExitThread(iReturn);
	return 0;  // never gets here, needed to compile
}


DWORD CallCustomDllEntrypoint(PCustomActionEntry pfEntry, bool fDebugBreak, MSIHANDLE hInstall, const ICHAR* szAction)
{
	if (fDebugBreak)
		WIN::DebugBreak();  // handle with debugger or JIT
	// do not put code in here between DebugBreak and custom action entry

#if _X86_
	int iOldEsp = 0;  // on the stack to handle multi-threading, OK even if regs change, as compare will fail
	int iNewEsp = 0;
	__asm   mov iOldEsp, esp
#endif

	DWORD iReturn = (*pfEntry)(hInstall);

#if _X86_
	__asm   mov iNewEsp, esp
	if (iNewEsp != iOldEsp)
	{
		// do not declare any local variables in this frame

		// try restoring the stack 
		__asm   mov esp, iOldEsp

		// the action name cannot be trusted in ship builds. If the stack is corrupt, the pointer
		// could be invalid.
		DEBUGMSG(TEXT("Possible stack corruption. Custom action may not be declared __stdcall."));
#ifdef DEBUG
		ICHAR rgchError[1024];

		StringCchPrintf(rgchError, ARRAY_ELEMENTS(rgchError), TEXT("Possible stack corruption. Diff in bytes (%d) iOldEsp=0x%x iNewWsp=0x%x Custom action %s may not be declared __stdcall."), iOldEsp-iNewEsp, iOldEsp, iNewEsp, szAction);
		AssertSz(fFalse, rgchError);
#else
		szAction; // prevent compiler from complaining
#endif
	}
#else
	szAction; // prevent compiler from complaining
#endif

   	// map the return values from a custom action to an "approved" value
	switch (iReturn)
	{
	// the following are the approved custom action return values, documented in the SDK
	case ERROR_FUNCTION_NOT_CALLED:
	case ERROR_SUCCESS:
	case ERROR_INSTALL_USEREXIT:
	case ERROR_INSTALL_FAILURE:
	case ERROR_NO_MORE_ITEMS:
		break;
	// ERROR_MORE_DATA was removed from documentation, but it was documented as valid at one point
	// so we have to allow it
	case ERROR_MORE_DATA:
		break;
	// _SUSPEND doesn't really have a useful meaning as a CA return value, but it was documented as valid
	// in the MSI 1.0  SDK so we have to allow it
	case ERROR_INSTALL_SUSPEND:
		break;
	default:
		DEBUGMSG2(TEXT("Custom Action %s returned unexpected value %d. Converted to ERROR_INSTALL_FAILURE."), szAction, reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(iReturn)));
		iReturn = ERROR_INSTALL_FAILURE;
	}

	return iReturn;
}

DWORD WINAPI CustomDllThread(CActionThreadData* pActionData)
{
    // this function should never run on NT/2000. Every DLL should be run out-of-proc
    AssertSz(g_fWin9X, TEXT("Running in-proc DLL on NT."));

	// This function calls ExitThread. No smart COM pointers allowed on stack!

	if((g_scServerContext == scService) && (!pActionData->m_fElevationEnabled || !(pActionData->m_icaFlags & icaInScript) || !(pActionData->m_icaFlags & icaNoImpersonate)))
		AssertNonZero(StartImpersonating());

	if ((pActionData->m_icaFlags & icaDebugBreak) != 0)
		g_tidDebugBreak = WIN::MsiGetCurrentThreadId(); // flag our breakpoint

	if (pActionData->m_fDisableMessages)
		g_MessageContext.DisableThreadMessages(WIN::GetCurrentThreadId());

	DWORD iReturn = CallCustomDllEntrypoint(pActionData->m_pfEntry,
										    (pActionData->m_icaFlags & icaDebugBreak) != 0,
											pActionData->m_hMsi,
											(const ICHAR*)pActionData->m_strAction);
	if (pActionData->m_fDisableMessages)
		g_MessageContext.EnableMessages();

	if((g_scServerContext == scService) && (!pActionData->m_fElevationEnabled || !(pActionData->m_icaFlags & icaInScript) || !(pActionData->m_icaFlags & icaNoImpersonate)))
		StopImpersonating();

	AssertNonZero(ThreadLogActionEnd(pActionData,iReturn));
	if ((pActionData->m_icaFlags & icaContinue) != 0)
		iReturn = ERROR_SUCCESS;

	// delete ActionData if CA is synchronous - if async it will be cleaned up by WaitForCustomActionThreads
	if (!(pActionData->m_icaFlags & icaAsync))
		delete pActionData;

	WIN::ExitThread(iReturn);
	return iReturn;  // never gets here, needed to compile
}

DWORD WINAPI CustomExeThread(CActionThreadData* pActionData)
{
	PROCESS_INFORMATION pi;
	memset(&pi, 0, sizeof(pi));
	
	STARTUPINFO si;
	memset(&si, 0, sizeof(si));
	si.cb        = sizeof(si);
	DWORD iReturn = ERROR_SUCCESS;
	DWORD dwWait = WAIT_OBJECT_0;
	BOOL fCreate = FALSE;
	bool fImpersonated = 0;
	const ICHAR* szWorkingDir = 0;

	// environment for child EXE. NULL (to inherit from parent) unless app compat fix requires additions
	VOID* pvChildEnvironment = NULL;

	int cbCommandArgs = pActionData->m_pistrCmdLine->TextSize();
	int cbLocation    = pActionData->m_pistrProduct->TextSize();
	int cbCommandLine = cbCommandArgs;
	if ((pActionData->m_icaFlags & icaSourceMask) != icaDirectory)
		cbCommandLine += (cbLocation + 3);  // room for quotes and separator
	CTempBuffer<ICHAR, 1> szCommandLine(cbCommandLine+1);
	ICHAR* pch = szCommandLine;
	size_t cchLen = szCommandLine.GetSize();
	if ( ! pch )
		goto CustomExeThreadExit;
	if ((pActionData->m_icaFlags & icaSourceMask) != icaDirectory)
	{
		*pch++ = '"';
		// szCommandLine had been sized correctly above, so there's no need
		// to check success here
		StringCchCopy(pch, cchLen-1, pActionData->m_pistrProduct->GetString());
		pch += cbLocation;
		*pch++ = '"';
		cchLen -= (2 + cbLocation);
		if (cbCommandArgs)
		{
			*pch++ = ' ';
			cchLen--;
		}
	}
	else
		szWorkingDir = pActionData->m_pistrProduct->GetString();
	// szCommandLine had been sized correctly above, so there's no need
	// to check success here
	StringCchCopy(pch, cchLen, pActionData->m_pistrCmdLine->GetString());

	if (g_scServerContext == scService)
	{
		fImpersonated = StartImpersonating();
		AssertNonZero(fImpersonated);
	}

	if (pActionData->m_icaFlags & icaDebugBreak)
		WIN::DebugBreak();

	// always clone the environment on Win2K and greater as TS does not correctly handle inheritance 
	// of the block when creating processes across sessions, and it might also be used for appcompat
	if (MinimumPlatformWindows2000())
	{
		if (STATUS_SUCCESS != NTDLL::RtlCreateEnvironment(TRUE, &pvChildEnvironment))
			goto CustomExeThreadExit;
	}

	// check AppCompat information for custom actions
	if (pActionData->m_fAppCompat && MinimumPlatformWindowsNT51())
	{
		// app compat team claims no compat layer strings longer than MAX_PATH and at most two strings
		// so the buffer will start with enough space for those strings.
		CTempBuffer<WCHAR, 1> rgchEnvironment(2*MAX_PATH+3);
		DWORD cchEnvironment = rgchEnvironment.GetSize();

		if (!APPHELP::ApphelpFixMsiPackageExe(&pActionData->m_guidAppCompatDB, &pActionData->m_guidAppCompatID, pActionData->m_strAction, rgchEnvironment, &cchEnvironment))
		{
			// error or no-op, ensure environment is empty
			StringCchCopy(rgchEnvironment, rgchEnvironment.GetSize(), TEXT(""));
		}
		else
		{
			// the AppHelp API will return success even if the buffer is too small. 
			if (cchEnvironment > rgchEnvironment.GetSize())
			{
				rgchEnvironment.SetSize(cchEnvironment);
				if (!APPHELP::ApphelpFixMsiPackageExe(&pActionData->m_guidAppCompatDB, &pActionData->m_guidAppCompatID, pActionData->m_strAction, rgchEnvironment, &cchEnvironment))
				{
					// error or no-op, ensure environment is empty
					StringCchCopy(rgchEnvironment, rgchEnvironment.GetSize(), TEXT(""));
				}
			}
		}


		// clone the current environment into a new environment block
		if (IStrLen(rgchEnvironment) != 0)
		{
			// set each name and value into the environment block
			WCHAR* pchName = rgchEnvironment;
			while (*pchName)
			{
				WCHAR* pchValue = wcschr(pchName, L'=');
				if (pchValue)
				{
					// null terminate the name and increment the pointer to the beginning of the value
					*(pchValue++) = L'\0';
	
					// set the value into the new environment
					UNICODE_STRING strName;
					UNICODE_STRING strValue;

					// RtlInitUnicodeString returns void, so there is no way to detect that we can't latebind
					// to the function (which would leave the structures uninitialized.) As a backup, we zero
					// the structure.
					memset(&strValue, 0, sizeof(UNICODE_STRING));
					memset(&strName, 0, sizeof(UNICODE_STRING));

					NTDLL::RtlInitUnicodeString(&strName, pchName);
					NTDLL::RtlInitUnicodeString(&strValue, pchValue);
					if (STATUS_SUCCESS != NTDLL::RtlSetEnvironmentVariable(&pvChildEnvironment, &strName, &strValue))
					{
						DEBUGMSGV1(TEXT("Failed to apply app compat flags to environment for custom action %s."), pActionData->m_strAction);
						goto CustomExeThreadExit;
					}

					// increment to the next name=value pair, one char past the terminating NULL of the value
					pchName = pchValue; 
					while (*pchName)
						pchName++;
					pchName++;
				}
				else
				{
					// for garbage possibility
					break;
				}
			}
		}
	}

	// set STARTUPINFO.lpDesktop to WinSta0\Default. When combined with the TS sessionID from the
	// token, this places any UI on the visible desktop of the appropriate session.
	si.lpDesktop=TEXT("WinSta0\\Default");

	// We can't do SetErrorMode(0) here, as other threads will be affected and will Assert
	// if in the service, and either not set to run elevated, not in the script, or set to impersonate
	if((g_scServerContext == scService) && (!pActionData->m_fElevationEnabled || (!(pActionData->m_icaFlags & icaInScript) || !(pActionData->m_icaFlags & icaNoImpersonate))))
	{
		HANDLE hTokenPrimary = INVALID_HANDLE_VALUE;
		if (g_MessageContext.GetUserToken())
		{
			// create a primary token for use with CreateProcessAsUser
			ADVAPI32::DuplicateTokenEx(g_MessageContext.GetUserToken(), 0, 0, SecurityAnonymous, TokenPrimary, &hTokenPrimary);

			//
			// SAFER: must mark token inert on Whistler
			//

			if (MinimumPlatformWindowsNT51())
			{
				// SaferComputeTokenFromLevelwill take hTokenTemp and modify the token to include the SANDBOX_INERT flag
				// The modified token is output as hTokenPrimary.
				HANDLE hTokenTemp = hTokenPrimary;
				hTokenPrimary = INVALID_HANDLE_VALUE;
				if (hTokenTemp != INVALID_HANDLE_VALUE && !ADVAPI32::SaferComputeTokenFromLevel(g_MessageContext.m_hSaferLevel, hTokenTemp, &hTokenPrimary, SAFER_TOKEN_MAKE_INERT, 0))
				{
					DEBUGMSG1(TEXT("SaferComputeTokenFromLevel failed with last error = %d"), reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(GetLastError())));
					hTokenPrimary = INVALID_HANDLE_VALUE;
				}
				if (hTokenTemp != INVALID_HANDLE_VALUE)
				{
					WIN::CloseHandle(hTokenTemp);
					hTokenTemp = INVALID_HANDLE_VALUE;
				}
			}

			if (hTokenPrimary != INVALID_HANDLE_VALUE)
			{
				UINT uiErrorMode = WIN::SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);
				fCreate = ADVAPI32::CreateProcessAsUser(hTokenPrimary, 0, szCommandLine,
									(LPSECURITY_ATTRIBUTES)0, (LPSECURITY_ATTRIBUTES)0, FALSE,
									NORMAL_PRIORITY_CLASS | (pvChildEnvironment ? CREATE_UNICODE_ENVIRONMENT : 0), pvChildEnvironment, 
									szWorkingDir, (LPSTARTUPINFO)&si, (LPPROCESS_INFORMATION)&pi);
				WIN::SetErrorMode(uiErrorMode);
				WIN::CloseHandle(hTokenPrimary);
			}
		}
	}
	else
	{
		// in the service, we need to ensure that the process runs using the correct session information
		if (g_scServerContext == scService && (g_iMajorVersion > 4))
		{
			HANDLE hTokenUser = g_MessageContext.GetUserToken();
			HANDLE hTokenPrimary = 0;
			HANDLE hTokenService = 0;
			bool fTryCreate = false;

			{
				//
				// SAFER: no need to mark inert since this is the local_system token and local_system is not subject to SAFER
				//

				CElevate elevate(true);
				// work with a duplicate of our process token so we don't make any permanent changes
				if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hTokenService) && hTokenService)
				{
					if (ADVAPI32::DuplicateTokenEx(hTokenService, MAXIMUM_ALLOWED, 0, SecurityAnonymous, TokenPrimary, &hTokenPrimary) && hTokenPrimary)
					{
						DWORD dwSessionId = 0;
						DWORD cbResult = 0;

						// grab the session ID from the users token and place it in the duplicate service token
						if (GetTokenInformation(hTokenUser, (TOKEN_INFORMATION_CLASS)TokenSessionId, &dwSessionId, sizeof(DWORD), &cbResult) &&
							SetTokenInformation(hTokenPrimary, (TOKEN_INFORMATION_CLASS)TokenSessionId, &dwSessionId, sizeof(DWORD)))
						{
							fTryCreate = true;
						}
					}
				}
			}

			if (fTryCreate)
			{
				UINT uiErrorMode = WIN::SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);
				fCreate = ADVAPI32::CreateProcessAsUser(hTokenPrimary, 0, szCommandLine,
						(LPSECURITY_ATTRIBUTES)0, (LPSECURITY_ATTRIBUTES)0, FALSE,
						NORMAL_PRIORITY_CLASS | CREATE_SUSPENDED | (pvChildEnvironment ? CREATE_UNICODE_ENVIRONMENT : 0), 
						pvChildEnvironment, szWorkingDir, (LPSTARTUPINFO)&si, (LPPROCESS_INFORMATION)&pi);
				WIN::SetErrorMode(uiErrorMode);
			}
			if (hTokenPrimary)
				WIN::CloseHandle(hTokenPrimary);
			if (hTokenService)
				WIN::CloseHandle(hTokenService);
		}
		else
		{
			//
			// SAFER: need to mark INERT on Whistler since this is user token
			//

			if (MinimumPlatformWindowsNT51())
			{
				// SaferComputeTokenFromLevelwill modify the token based upon the supplied safer level and include the SANDBOX_INERT
				// flag such that subsequent safer checks do not occur.  Because installs only proceed on fully trusted safer levels, the
				// supplied token will only be modified by inclusion of the inert flag.  Note that passing in 0 for the InToken will use the
				// thread token if present, otherwise it uses the process token
				HANDLE hTokenInert = INVALID_HANDLE_VALUE;
				if (!ADVAPI32::SaferComputeTokenFromLevel(g_MessageContext.m_hSaferLevel, /*InToken = */0, &hTokenInert, SAFER_TOKEN_MAKE_INERT, 0))
				{
					DEBUGMSG1(TEXT("SaferComputeTokenFromLevel failed with last error = %d"), reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(GetLastError())));
					hTokenInert = INVALID_HANDLE_VALUE;
				}

				if (hTokenInert != INVALID_HANDLE_VALUE)
				{
					// create a primary token for use with CreateProcessAsUser
					HANDLE hTokenPrimaryDup = INVALID_HANDLE_VALUE;
					if (ADVAPI32::DuplicateTokenEx(hTokenInert, 0, 0, SecurityAnonymous, TokenPrimary, &hTokenPrimaryDup))
					{
						// create the process
						UINT uiErrorMode = WIN::SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);
						fCreate = ADVAPI32::CreateProcessAsUser(hTokenPrimaryDup, 0, szCommandLine, (LPSECURITY_ATTRIBUTES)0, (LPSECURITY_ATTRIBUTES)0, FALSE,
							NORMAL_PRIORITY_CLASS | CREATE_SUSPENDED | (pvChildEnvironment ? CREATE_UNICODE_ENVIRONMENT : 0), pvChildEnvironment, szWorkingDir, 
							(LPSTARTUPINFO)&si, (LPPROCESS_INFORMATION)&pi);
						WIN::SetErrorMode(uiErrorMode);
						WIN::CloseHandle(hTokenPrimaryDup);
					}
					WIN::CloseHandle(hTokenInert);
				}
			}
			else
			{
				// only from the client can we just call createprocess
				UINT uiErrorMode = WIN::SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);
				fCreate = WIN::CreateProcess(0, szCommandLine,
					(LPSECURITY_ATTRIBUTES)0, (LPSECURITY_ATTRIBUTES)0, FALSE,
					NORMAL_PRIORITY_CLASS | CREATE_SUSPENDED | (pvChildEnvironment ? CREATE_UNICODE_ENVIRONMENT : 0), 
					pvChildEnvironment, szWorkingDir, (LPSTARTUPINFO)&si, (LPPROCESS_INFORMATION)&pi);
				WIN::SetErrorMode(uiErrorMode);
			}
		}

		if (fCreate)
		{
			// must elevate for access to the process
			CElevate elevate(true);

			if ((pActionData->m_icaFlags & icaSetThreadToken) != 0)
			{
				// can't always check error codes here. If on a TS machine, there is a race
				// condition with the new process due to a bug in creating suspended processes
				// accross TS sessions. In that case, this function could fail becasue the child
				// process has already exited.
				if (!SetThreadToken(&pi.hThread, GetUserToken()) && !IsTerminalServerInstalled())
				{
					// process running as wrong user. 
					TerminateProcess(pi.hProcess, -1);
					pActionData->m_pistrCmdLine->Release();
					pActionData->m_pistrProduct->Release();
					goto CustomExeThreadExit;
				};
			}
			AssertNonZero(1 == ResumeThread(pi.hThread));
		}
	}

CustomExeThreadExit:
	pActionData->m_pistrCmdLine->Release();
	pActionData->m_pistrProduct->Release();

	// free the cloned environment
	if (pvChildEnvironment)
	{
		NTDLL::RtlDestroyEnvironment(pvChildEnvironment);
		pvChildEnvironment=NULL;
	}

	if (!fCreate)
		iReturn = ERROR_CREATE_FAILED; // to force specific error message when returning to engine
	else
	{
		WIN::CloseHandle(pi.hThread);  // don't need this
		if (!(pActionData->m_icaFlags & icaAsync)   // wait here if synchronous
		 || (!(pActionData->m_icaFlags & icaContinue) // no wait if async return ignored
		  && !((pActionData->m_icaFlags & (icaInScript | icaRollback)) == (icaInScript | icaRollback))))
		{
			for(;;)
			{
				dwWait = WIN::MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT);
				if (dwWait == WAIT_OBJECT_0 + 1)  // window Msg
				{
					MSG msg;
					while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
					{
						WIN::TranslateMessage(&msg);
						WIN::DispatchMessage(&msg);
					}
					continue;
				}
				else break;
			}
			if ((pActionData->m_icaFlags & icaContinue) == 0)  // need to check exit code unless ignore
				WIN::GetExitCodeProcess(pi.hProcess, &iReturn);
		}
		WIN::CloseHandle(pi.hProcess);
		if (dwWait == WAIT_FAILED || (!(pActionData->m_icaFlags & icaNoTranslate) && iReturn != ERROR_SUCCESS))
			iReturn = ERROR_INSTALL_FAILURE;  // any non-zero return from an EXE assumed to be an error
	}
	AssertNonZero(ThreadLogActionEnd(pActionData,iReturn));

	// delete ActionData if CA is synchronous - if async it will be cleaned up by WaitForCustomActionThreads
	if (!(pActionData->m_icaFlags & icaAsync))
		delete pActionData;

	if (fImpersonated)
		StopImpersonating();

	return iReturn;
}

void WaitForCustomActionThreads(IMsiEngine* piEngine, Bool fTerminate, IMsiMessage& /*riMessage*/)
{
	CActionThreadData*  pActionThreadData;

	EnterCriticalSection(&vcsHeap);
	CActionThreadData** ppActionThreadHead = &g_pActionThreadHead;
	while((pActionThreadData = *ppActionThreadHead) != 0)
	{
		//
		// See if this is one that we care about
		//
		if (pActionThreadData->m_piEngine != piEngine)
		{
			ppActionThreadHead = &pActionThreadData->m_pNext;
			continue;
		}

		HANDLE hThread = pActionThreadData->m_hThread;
		if (!hThread)  // thread never created, just clear data
			delete pActionThreadData; // will unlink
		else if (fTerminate || (pActionThreadData->m_icaFlags & icaContinue)==0)
		{
			//
			// While waiting for this to finish, we don't want to be in a critical section
			//
			LeaveCriticalSection(&vcsHeap);
			DWORD iWait;
			if (GetTestFlag('T')) // old code before UI refresh put into engine wait loops
			{
				do
				{
					iWait = WIN::WaitForSingleObject(hThread, 20);
					g_MessageContext.Invoke(imtProgress, g_piNullRecord);  // refresh UI
				} while (iWait == WAIT_TIMEOUT);  // allow messages to be processed in main thread
			}
			else  // UI in separate thread
			{
				g_MessageContext.DisableTimeout();
				iWait = WIN::WaitForSingleObject(hThread, INFINITE);
				g_MessageContext.EnableTimeout();
			}

			// synchronous CAs clean themselves up - async CAs are cleaned up here
			delete pActionThreadData;
			WIN::CloseHandle(hThread);
			EnterCriticalSection(&vcsHeap);
			//
			// Now we have to restart at the beginning however (the list may have been changed on us)
			//
			ppActionThreadHead = &g_pActionThreadHead;
		}
		else  // wait for thread at engine terminate
			ppActionThreadHead = &pActionThreadData->m_pNext;
	}
	LeaveCriticalSection(&vcsHeap);
}


void CopyStreamToString(IMsiStream& riStream, const IMsiString*& rpistrData)
{
	int cbStream = riStream.GetIntegerValue();  // script data is ANSI in file
	rpistrData = &g_MsiStringNull;
	if(!cbStream) // empty stream
		return;
#ifdef UNICODE
	char* rgbBuf = new char[cbStream];
	if ( rgbBuf )
	{
		int cbRead = riStream.GetData(rgbBuf, cbStream);
		Assert (cbRead == cbStream);
		int cch = WIN::MultiByteToWideChar(CP_ACP, 0, rgbBuf, cbRead, 0, 0);
		WCHAR* pch = SRV::AllocateString(cch, fFalse, rpistrData);
		if ( pch )
			WIN::MultiByteToWideChar(CP_ACP, 0, rgbBuf, cbRead, pch, cch);
		delete [] rgbBuf;
	}
#else
	// JScript or VBScript could have DBCS characters, especially with UI or property values
	// we can't tell prior to copying the stream, so instead we default to fDBCS = fTrue in the ANSI
	// build and take the performance hit to guarantee that DBCS is supported.
	// We actually never do string manipulations on this since we pass it directly to the scripting
	// engine for compilation.  In that case, this could seem *unnecessary*, but better safe than sorry
	char* pch = SRV::AllocateString(cbStream, /*fDBCS=*/fTrue, rpistrData);
	if ( pch )
	{
		int cbRead = riStream.GetData(pch, cbStream);
		Assert (cbRead == cbStream);
	}
#endif
}

//____________________________________________________________________________
//
//  Error handling
//____________________________________________________________________________

IMsiRecord* PostScriptError(IErrorCode imsg, const ICHAR* szAction, CScriptSite* pScriptSite)
{
	IMsiRecord* piError = &ENG::CreateRecord(8);
	ISetErrorCode(piError, imsg);
	piError->SetString(2, szAction);
	if (pScriptSite && pScriptSite->GetErrorCode() != S_OK)
	{
		piError->SetInteger(3, pScriptSite->GetErrorCode());
		piError->SetString (4, pScriptSite->GetErrorObjName());
		piError->SetString (5, pScriptSite->GetErrorObjDesc());
		piError->SetInteger(6, pScriptSite->GetErrorLineNumber());
		piError->SetInteger(7, pScriptSite->GetErrorColumnNumber());
		piError->SetString (8, pScriptSite->GetErrorSourceLine());
	}
	return piError;
}

//____________________________________________________________________________
//
//  DoAction method
//____________________________________________________________________________

iesEnum CMsiEngine::DoAction(const ICHAR* szAction)
{
	if (!m_fInitialized)
		return iesWrongState;

	// no action specified, check "Action" property, else do default action
	MsiString istrTopAction;
	if (!szAction || !*szAction)
	{
		istrTopAction = GetPropertyFromSz(IPROPNAME_ACTION);
		istrTopAction.UpperCase();
		szAction = istrTopAction;
		Assert(szAction);  // should never return a null pointer
		if (!*szAction)
		{
			szAction = szDefaultAction;
			SetProperty(*MsiString(*IPROPNAME_ACTION), *MsiString(*szDefaultAction));
		}
	}

	DEBUGMSG1(TEXT("Doing action: %s"), szAction);

	PMsiRecord pOldCachedActionStart = m_pCachedActionStart;

	// generate action start record, should never fail, doesn't hurt if it does
	MsiString strDescription, strTemplate;
	GetActionText(szAction, *&strDescription, *&strTemplate); // ignore failure
	m_pCachedActionStart = &m_riServices.CreateRecord(3);
	AssertNonZero(m_pCachedActionStart->SetString(1,szAction));
	AssertNonZero(m_pCachedActionStart->SetMsiString(2,*strDescription));
	AssertNonZero(m_pCachedActionStart->SetMsiString(3,*strTemplate));

	m_fExecutedActionStart = fFalse; // need to write action start to script before next op
												// in ExecuteRecord()

	m_fDispatchedActionStart = fFalse; // need to dispatch action start before next
												  // progress message in Message()

	// log action start if necessary
	if(m_rgpiMessageHeader[imsgActionStarted])
	{
		if(!m_pActionStartLogRec)
		{
			m_pActionStartLogRec = &m_riServices.CreateRecord(2);
		}
		AssertNonZero(m_pActionStartLogRec->SetMsiString(0,*m_rgpiMessageHeader[imsgActionStarted]));
		AssertNonZero(m_pActionStartLogRec->SetString(1,szAction));
		Message(imtInfo,*m_pActionStartLogRec);
	}

	// run action
	iesEnum iesReturn = FindAndRunAction(szAction);

	if (iesReturn == iesActionNotFound)
	{
		PMsiRecord pError = &m_riServices.CreateRecord(2);
		pError->SetInteger(1, idbgMissingAction);
		pError->SetString(2, szAction);
		Message(imtInfo, *pError);
		iesReturn = iesNoAction;
	}

	if((int)iesReturn == iesNotDoneYet)
	{
		iesReturn = iesSuccess; // don't log action end
	}
	else
	{
		if(m_rgpiMessageHeader[imsgActionEnded])
		{
			Assert(m_pActionStartLogRec); // should have been created above
			if(m_pActionStartLogRec)
			{
				AssertNonZero(m_pActionStartLogRec->SetMsiString(0,*m_rgpiMessageHeader[imsgActionEnded]));
				AssertNonZero(m_pActionStartLogRec->SetString(1,szAction));
				AssertNonZero(m_pActionStartLogRec->SetInteger(2,iesReturn));
				Message(imtInfo,*m_pActionStartLogRec);
			}
		}
	}

	AssertSz(!(g_MessageContext.WasCancelReturned() && (iesReturn == iesNoAction || iesReturn == iesSuccess)), TEXT("Unprocessed Cancel button"));

	// put back old cached action start record
	m_pCachedActionStart = pOldCachedActionStart;
	m_fExecutedActionStart = fFalse; // need to write action start to script before next op
	m_fDispatchedActionStart = fFalse; // need to dispatch action start before next progress message

	return iesReturn;
}

iesEnum CMsiEngine::RunNestedInstall(const IMsiString& ristrProduct,
												 Bool fProductCode, // else package path
												 const ICHAR* szAction,
												 const IMsiString& ristrCommandLine,
												 iioEnum iioOptions,
												 bool fIgnoreFailure)
{
	int icaFlags = fProductCode ? icaDirectory : icaProperty;

	if(fIgnoreFailure)
		icaFlags |= icaContinue;

	return RunNestedInstallCustomAction(ristrProduct,ristrCommandLine,szAction,
													icaFlags, iioOptions);
}

iesEnum CMsiEngine::RunNestedInstallCustomAction(const IMsiString& ristrProduct,
																 const IMsiString& ristrCommandLine,
																 const ICHAR* szAction,
																 int icaFlags,
																 iioEnum iioOptions)
{
	if((GetMode() & iefRollbackEnabled) == 0)
		iioOptions = (iioEnum)(iioOptions | iioDisableRollback);

	// don't translate error code for nested installs - we will do the remapping here
	icaFlags |= icaNoTranslate;

	CActionThreadData* pThreadData = new CActionThreadData(*this, this, szAction, icaFlags,
							   m_rgpiMessageHeader[imsgActionEnded], m_fRunScriptElevated, /*fAppCompat=*/false, NULL, NULL);
	int iError; 
	iesEnum iesReturn = iesSuccess;

	if ( pThreadData )
	{
		pThreadData->InitializeInstall(ristrProduct, FormatText(ristrCommandLine), iioOptions);
		// action end log handled by RunThread

		iError = pThreadData->RunThread();
	}
	else
		iError = ERROR_OUTOFMEMORY;

	// handle special return codes from custom action
	if (iError == ERROR_INSTALL_REBOOT)  // reboot required at end of install
	{
		SetMode(iefReboot, fTrue);
		iesReturn = iesSuccess;
	}
	else if (iError == ERROR_INSTALL_REBOOT_NOW)  // reboot required before completing install
	{
		SetMode(iefReboot, fTrue);
		SetMode(iefRebootNow, fTrue);
		iesReturn = iesSuspend;
	}
	else if (iError == ERROR_SUCCESS_REBOOT_REQUIRED)  // reboot required but suppressed or rejected by user
	{
		SetMode(iefRebootRejected, fTrue);
		iesReturn = iesSuccess;
	}
	else if (iError == ERROR_INSTALL_USEREXIT)
	{
		iesReturn = iesUserExit;
	}
	else if (iError == ERROR_INSTALL_SUSPEND)
	{
		iesReturn = iesSuspend;
	}
	else if (iError == ERROR_INSTALL_FAILURE)
	{
		// failure and message displayed by nested install
		iesReturn = iesFailure;
	}
	else if (iError == ERROR_SUCCESS)
	{
		iesReturn = iesSuccess;
	}
	else // some initialization error - display error message
	{
		// we'll ignore the "product not found" error when uninstalling a product during an upgrade
		if((iioOptions & iioUpgrade) && iError == ERROR_UNKNOWN_PRODUCT)
		{
			DEBUGMSG(TEXT("Ignoring failure to remove product during upgrade - product already uninstalled."));
			iesReturn = iesSuccess;
		}
		else
		{
			MsiString strProductName = GetPropertyFromSz(IPROPNAME_PRODUCTNAME); // parent's product name
			IErrorCode imsg;
			if(iioOptions & iioUpgrade)
				imsg = Imsg(imsgUpgradeRemovalInitError);
			else
				imsg = Imsg(imsgNestedInstallInitError);

			PMsiRecord precError(PostError(imsg, *strProductName, iError));
			iesReturn = FatalError(*precError);
		}
	}
	return iesReturn;
}

// script actions also must run through the CA server if they are impersonated, but because they don't run asynchronously
// there is no need for a bunch of fancy thread work to run the script.

// RunScript action actually creates the Site, runs the script, and posts error messages. It does not handle
// continue flags, etc.
HRESULT RunScriptAction(int icaType, IDispatch* piDispatch, MsiString istrSource, MsiString istrTarget, LANGID iLangId, HWND hWnd, int& iScriptResult, IMsiRecord** piMSIResult)
{
	MsiString szAction;
	iScriptResult = 0;

	CScriptSite* piScriptSite = CreateScriptSite(icaType == icaJScript ? IID_JScript : IID_VBScript, piDispatch, hWnd, iLangId);
	if (piScriptSite)  // successfully created scripting session
	{
		HRESULT hRes = piScriptSite->ParseScript(istrSource, istrSource.TextSize());
		if (hRes == S_OK)
		{
			if (istrTarget.TextSize() != 0)  // function specified to call
			{
				hRes = piScriptSite->CallScriptFunction(istrTarget);
				piScriptSite->GetIntegerResult(iScriptResult);
			}
		}
		if (hRes != S_OK)
			*piMSIResult = PostScriptError(Imsg(imsgCustomActionScriptFailed), szAction, piScriptSite);
	}
	else if (icaType == icaVBScript)
		*piMSIResult = PostScriptError(Imsg(idbgCustomActionNoVBScriptEngine), szAction, 0);
	else // (icaType == icaJScript)
		*piMSIResult = PostScriptError(Imsg(idbgCustomActionNoJScriptEngine), szAction, 0);
	DestroyScriptSite(piScriptSite);

	// filter script return values the approved set
	switch (iScriptResult)
	{
	// the following 5 values are documented as valid return values
	case iesSuccess:
	case iesUserExit:
	case iesNoAction:
	case iesFailure:
	case iesFinished:
		break;
	// iesSuspend is equivalent to INSTALL_SUSPEND, meaning that we don't really know
	// what to do with it (but it was documented, so must be "supported")
	case iesSuspend:
		break;
	default:
		DEBUGMSG2(TEXT("Script custom action %s returned unexpected value %d. Converted to IDABORT."), szAction, reinterpret_cast<ICHAR*>(static_cast<INT_PTR>(iScriptResult)));
		iScriptResult = iesFailure;
		break;
	}

	return S_OK;
}

// CustomRemoteScriptAction create the custom action server and passes the script to the process to run,
// unmarshals the resulting error record (if any) and handles internal failures. If asynch actions are
// ever allowed, this code should be in CustomRemoteScriptThread.
int CustomRemoteScriptAction(bool fScriptElevate, int icaFlags, IMsiEngine* piEngine, IDispatch* piDispatch, const IMsiString& istrSource, const IMsiString& istrTarget, bool fDisableMessages, DWORD dwLaunchingThread, IMsiRecord** piMSIResult)
{
	g_MessageContext.DisableTimeout();
	int iReturn =0;
	*piMSIResult = 0;

	icacCustomActionContext icacContext = icac32Impersonated;
	bool fElevate = (g_scServerContext == scService) && fScriptElevate && (icaFlags & icaNoImpersonate) && (icaFlags & icaInScript);

        // determine custom action platform (64/32bit). It isn't possible to just "look" at the script like
        // it is with DLL actions, so the author must explicitly mark if an action is 64bit.
        if (ica64BitScript & icaFlags)
        {
                //!! Need to figure out how to handle scripts
                //!!future - should fail if not running on 64bit machine
                icacContext = fElevate ? icac64Elevated : icac64Impersonated;
        }
        else
        {
                icacContext = fElevate ? icac32Elevated : icac32Impersonated;
        }

	CMsiCustomActionManager *pCustomActionManager = GetCustomActionManager(piEngine);

	if (pCustomActionManager)
	{
		HRESULT hRes = pCustomActionManager->RunScriptAction(icacContext, icaFlags & icaTypeMask, piDispatch,
			istrSource.GetString(), istrTarget.GetString(), g_BasicUI.GetPackageLanguage(), fDisableMessages, dwLaunchingThread, &iReturn, piMSIResult);
		if (hRes != S_OK)
		{
			// problem marshaling
			DEBUGMSGV(TEXT("Failed to marshal script action."));
			iReturn = iesFailure;
		}
	}
	else
	{
		DEBUGMSG(TEXT("Failed to get custom action manager."));
		iReturn = iesFailure;
	}
	g_MessageContext.EnableTimeout();
	return iReturn;
}

// class CViewAndStreamRelease is used for FindAndRunAction to ensure that
// the stream and view pointers are released in the correct order
// (stream before view).  Acts as a CComPointer.  Also enables
// use of original stream and views.  No releases need to be used
// as this class will take care of it.
//NOTE:  we always want the stream to be released before the view

class CViewAndStreamRelease
{
private:
	IMsiStream** m_ppiStream;
	IMsiView**   m_ppiView;
public:
	CViewAndStreamRelease(IMsiStream** ppiStream, IMsiView** ppiView): m_ppiStream(ppiStream), m_ppiView(ppiView){}
	~CViewAndStreamRelease();
	void ReleaseAll();
};
inline CViewAndStreamRelease::~CViewAndStreamRelease()
{if (*m_ppiStream) (*m_ppiStream)->Release(); if (*m_ppiView) (*m_ppiView)->Release();}

inline void CViewAndStreamRelease::ReleaseAll()
{
	if (*m_ppiStream)
	{
		(*m_ppiStream)->Release();
		*m_ppiStream = 0;
	}
	if (*m_ppiView)
	{
		(*m_ppiView)->Release();
		*m_ppiView = 0;
	}
}

iesEnum CMsiEngine::FindAndRunAction(const ICHAR* szAction)
{
	// scan for built-in action, and execute it and return if found
	iesEnum iesReturn;
	const CActionEntry* pAction = CActionEntry::Find(szAction);
	if (pAction && pAction->m_pfAction)
	{
		// only execute the action if we're not in a restricted engine OR we're in a restricted engine and the action is safe
		if (!m_fRestrictedEngine || pAction->m_fSafeInRestrictedEngine)
		{
			return (*(pAction->m_pfAction))(*this);
		}
		else
		{
			DEBUGMSG1(TEXT("Action '%s' is not permitted in a restricted engine."), szAction);
			return iesNoAction;
		}
	}

	// query CustomAction table to check if it is a custom action
	PMsiRecord precAction(m_fCustomActionTable ? FetchSingleRow(sqlCustomAction, szAction) : 0);
	if (precAction == 0)  // if not a custom action, then sent it to the UI handler
	{
		if (m_piParentEngine || !g_MessageContext.IsHandlerLoaded()) // no need for (g_scServerContext != scClient), as handler can't be loaded if not client
			return iesNoAction; // actions can't be executed in this context

		g_MessageContext.m_szAction = szAction;
		iesReturn = (iesEnum)g_MessageContext.Invoke(imtShowDialog, 0);
		if (iesReturn == iesNoAction) // if Handler didn't find action, action doesn't exist
			iesReturn = (iesEnum)iesActionNotFound;
		return iesReturn;
	}

	// get custom action parameters and decode type
	MsiString istrSource(precAction->GetMsiString(icolSource));
	MsiString istrTarget(precAction->GetMsiString(icolTarget));
	int icaFlags  = precAction->GetInteger(icolActionType);
	int icaType   = icaFlags & icaTypeMask;
	int icaSource = icaFlags & icaSourceMask;

	// determine if action may run on both client and server and resolve execution
	int iPassFlags = icaFlags & icaPassMask;
	if ((iPassFlags == icaFirstSequence  && (m_fMode & iefSecondSequence))
	 || (iPassFlags == icaOncePerProcess && g_scServerContext == scClient && (m_fMode & iefSecondSequence))
	 || (iPassFlags == icaClientRepeat   && (g_scServerContext != scClient || !(m_fMode & iefSecondSequence))))
	{
		LPCSTR szOption = NULL;
		switch (iPassFlags)
		{
		case icaFirstSequence: szOption = "msidbCustomActionTypeFirstSequence"; break;
		case icaOncePerProcess: szOption = "msidbCustomActionTypeOncePerProcess"; break;
		case icaClientRepeat: szOption = "msidbCustomActionTypeClientRepeat"; break;
		default: szOption = "unknown scheduling"; break;
		}
		DEBUGMSGV1("Skipping action due to %s option.", szOption);
		return iesNoAction;
	}

	// check for property or directory assignment, fast execution and return
	if (icaType == icaTextData)
	{
		MsiString istrValue = FormatText(*istrTarget);
		switch (icaFlags & (icaSourceMask | icaInScript | icaContinue | icaAsync))
		{
		case icaProperty:
			SetProperty(*istrSource, *istrValue);
			break;
		case icaDirectory:
		{
			PMsiRecord pError = SetTargetPath(*istrSource, istrValue, fFalse);
			if (pError)
			{
				if (pError->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return FatalError(*pError);
			}
			break;
		}
		case icaSourceFile: // "error message" custom action - simply put up an error message and
								  // return "failure"
		{
			PMsiRecord pErrorMsgRec = &CreateRecord(1);

			int iError = istrValue;
			if(iError != iMsiStringBadInteger)
			{
				// source is an integer - grab the string from the Error table
				AssertNonZero(pErrorMsgRec->SetMsiString(0, *MsiString(GetErrorTableString(iError))));
			}
			else
			{
				// target is a string that we will use
				AssertNonZero(pErrorMsgRec->SetMsiString(0, *istrValue));
			}

			Message(imtEnum(imtError|imtSendToEventLog), *pErrorMsgRec);  // same message type used by LaunchConditions action
			return iesFailure;
		}
		default: // icaBinaryData, icaSourceFile OR invalid flags: icaInScript/Continue/Async
			return FatalError(*PMsiRecord(PostError(Imsg(idbgInvalidCustomActionType), szAction)));
		}
		return iesSuccess;
	}

	// DLL, Script, EXE, and Nested Install custom actions cannot execute in a restricted engine
	if (m_fRestrictedEngine)
	{
		DEBUGMSG1(TEXT("Action '%s' is not permitted in a restricted engine."), szAction);
		return iesNoAction;
	}

	// check for property reference, set istrSource to property value
	if (icaSource == icaProperty)
	{
		istrSource = MsiString(GetProperty(*istrSource));
	}

	// check for nested install, source data processed specially
	if (icaType == icaInstall)
	{
		// for nested installs, only valid types are "substorage", "product code" and "relative path"
		// async is not allowed
		// no pass flags (rollback, commit, runonce, etc...) are allowed
		if ((icaSource == icaProperty) || (icaFlags & icaAsync) || (iPassFlags != 0))
		{
			return FatalError(*PMsiRecord(PostError(Imsg(idbgInvalidCustomActionType), szAction)));  //!! new message?
		}

		CMsiEngine* piEngine = 0;
		PMsiDatabase pDatabase(0);
		if (icaSource == icaSourceFile)
		{
			PMsiRecord pError(0);
			MsiString istrTemp = istrSource;
			if ((pError = ENG::GetSourcedir(*this, *&istrSource)) != 0)
			{
				if (pError->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return FatalError(*pError);
			}

			istrSource += istrTemp;
		}
		return RunNestedInstallCustomAction(*istrSource,*istrTarget,szAction,icaFlags,iioChild);
	}

	// If we are installing on Hydra5 in a per-machine install, set the icaNoImpersonate flag.
	// Running the CA elevated will cause the CAs HKCU reg writes to go to .Default. This
	// enables the hydra registry propogation system. Security issues are equivalent to
	// a machine deployment scenario.
	if (g_iMajorVersion >= 5 && IsTerminalServerInstalled() && MsiString(GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize())
	{
		if (!(icaFlags & icaNoImpersonate) && (icaFlags & icaInScript) && !(icaFlags & icaTSAware))
		{
			DEBUGMSG("Not impersonating action for per-machine TS install.");
			icaFlags |= icaNoImpersonate;
		}
	}

	// check for stream in binary table, set pStream to data stream
	IMsiStream* piStream = 0; // we want to control its release.  Must be before the view
	IMsiView* piView = 0; // DO NOT release.  ViewAndStreamRelease ensures released in correct order.  View must be released after stream
	CViewAndStreamRelease ViewAndStreamRelease(&piStream, &piView); // ensures releases are in correct order
	if (icaSource == icaBinaryData)
	{
		ICHAR rgchQueryBuf[256] = {0};  // large enough for any query string
		StringCchPrintf(rgchQueryBuf, ARRAY_ELEMENTS(rgchQueryBuf), sqlCustomActionBinary, (const ICHAR*)istrSource); // faster than parameterized query
		PMsiRecord precError(OpenView(rgchQueryBuf, ivcFetch, piView));
		if (precError != 0
		|| (precError = piView->Execute(0)) != 0)
		{
			AssertSz(0, MsiString(precError->FormatText(fFalse)));
			return FatalError(*PMsiRecord(PostError(Imsg(idbgCustomActionNotInBinaryTable), szAction))); //?? is this right return
		}
		IMsiRecord* pirecBinary = piView->Fetch();
		if (pirecBinary)
		{
			piStream = (IMsiStream*)pirecBinary->GetMsiData(1);
			pirecBinary->Release();
		}
		if (!piStream)
			return FatalError(*PMsiRecord(PostError(Imsg(idbgCustomActionNotInBinaryTable), szAction)));
	}

	// check for reference to installed file, set istrSource to full file path
	if (icaSource == icaSourceFile)
	{
		MsiString strFile = istrSource;
		PMsiRecord pError = GetFileInstalledLocation(*strFile,*&istrSource);
		if(pError)
			return FatalError(*pError); //!! do we want to do something else?
	}

	// check for script data, execute script, and return
	if (icaType == icaJScript || icaType == icaVBScript)
	{
		// scripts have never supported async calls. For appcompat reasons, can't generate an
		// error, so just strip the bit out if it is set.
		icaType &= ~icaAsync;

		iesEnum iesStatus = iesSuccess;
		if (icaSource == icaDirectory)  // Source column ignored, should be empty
		{
			istrSource = istrTarget;  // can't use FormatText, removes template markers
			istrTarget = (const ICHAR*)0;
		}
		else if (icaSource == icaBinaryData)  // piStream already initialized
			::CopyStreamToString(*piStream, *&istrSource);

		if ((icaFlags & icaInScript) == 0)  // execute if not scheduled
		{
			if (icaSource == icaSourceFile)
			{
				PMsiRecord pError = ::CreateFileStream(istrSource, fFalse, *&piStream);
				if (pError)
				{
					if ((icaFlags & icaContinue) != 0)
						return Message(imtInfo, *pError), iesSuccess;
					else
						return FatalError(*pError);
				}
				::CopyStreamToString(*piStream, *&istrSource);
			}
			// release stream so that if this custom action calls other custom actions (via MsiDoAction) and they
			// live in the same DLL, they can still be accessed
			ViewAndStreamRelease.ReleaseAll();


            // if the script action is running on NT/2000, we need to run it through the custom action server
            PMsiRecord piError = 0;
            int iResult = 0;
			MSIHANDLE hEngine = ENG::CreateMsiHandle((IMsiEngine*)this, iidMsiEngine);
			AddRef();   // CreateMsiHandle grabs the ref count

			// initialize thread data object for script custom action
			CActionThreadData* pThreadData = new CActionThreadData(*this, this, szAction, icaFlags,
				m_rgpiMessageHeader[imsgActionEnded], m_fRunScriptElevated, this->m_fCAShimsEnabled, &this->m_guidAppCompatDB, &this->m_guidAppCompatID);
			if ( ! pThreadData )
			{
				MsiCloseHandle(hEngine);
				return iesFailure;
			}

			pThreadData->InitializeRemoteScript(*istrSource, *istrTarget, hEngine);

			// execute the script
			iesReturn = pThreadData->RunThread();

			return iesReturn;
        }
    }
    else if (icaType == icaDll)
    {
		if (icaSource == icaDirectory || icaSource == icaProperty   // unsupported for existing DLLs, security issue
			|| (icaFlags & (icaAsync | icaInScript | icaRollback)) == (icaAsync | icaInScript | icaRollback))   // asyncronous call during rollback not supported
			return FatalError(*PMsiRecord(PostError(Imsg(idbgInvalidCustomActionType), szAction)));
    }
    else if (icaType == icaExe)
    {
		if (icaSource == icaDirectory && istrSource.TextSize()) // if Directory table reference, use for working directory
		{
			PMsiPath pTarget(0);
			PMsiRecord pError = GetTargetPath(*istrSource, *&pTarget);
			if (pError)
				return FatalError(*pError);
			istrSource = pTarget->GetPath();
		}
		istrTarget = FormatText(*istrTarget);  // format any parameterized command-line args
    }
    else
		return iesBadActionData;  // unknown custom action type

	// check if debug break set for this action
	if (IsAdmin())
	{
		MsiString istrBreak = GetPropertyFromSz(TEXT("%MsiBreak"));
		if (istrBreak.Compare(iscExact, szAction) == 1)
			icaFlags |= icaDebugBreak;
	}

	if (icaFlags & icaInScript)  // update and queue execute if deferred
	{
		if (icaType != icaJScript && icaType != icaVBScript && icaSource == icaBinaryData)
			precAction->SetMsiData(icolSource, piStream);
		else
			precAction->SetMsiString(icolSource, *istrSource);
		precAction->SetMsiString(icolTarget, *istrTarget);
		precAction->SetInteger(icolActionType, icaFlags);
		precAction->SetMsiString(icolContextData, *MsiString(GetPropertyFromSz(szAction)));
		iesReturn = ExecuteRecord(ixoCustomActionSchedule, *precAction);
		return iesReturn;
	}

	// initialize thread data object for EXE or DLL custom action
	CActionThreadData* pThreadData = new CActionThreadData(*this, this, szAction, icaFlags,
							m_rgpiMessageHeader[imsgActionEnded], m_fRunScriptElevated, this->m_fCAShimsEnabled, &this->m_guidAppCompatDB, &this->m_guidAppCompatID);
	if ( ! pThreadData )
		return iesFailure;

	// if Binary table stream, create temp file for DLL or EXE
	if (icaSource == icaBinaryData)
	{
		while (!pThreadData->CreateTempFile(*piStream, *&istrSource))
		{
			if(false == PostScriptWriteError(*this))
			{
				delete pThreadData;
				return iesFailure;
			}
			piStream->Reset();
		}
		// release stream so that if this custom action calls other custom actions (via MsiDoAction) and they
		// live in the same DLL, they can still be accessed
		ViewAndStreamRelease.ReleaseAll();
	}

	// create a separate thread for launching the custom action and cleaning up afterwards
	if (icaType == icaDll)
	{
		AddRef();  // CreateMsiHandle does not AddRef();

		Bool fRet = fTrue;

        // for security reasons, all DLL CAs run remoted when on Win2000 or NT4
        if (!g_fWin9X)
        {
            pThreadData->InitializeRemoteDLL(*istrSource, *istrTarget, ENG::CreateMsiHandle((IMsiEngine*)this, iidMsiEngine));
        }
        else
        {
            fRet = pThreadData->InitializeDLL(*istrSource, *istrTarget, ENG::CreateMsiHandle((IMsiEngine*)this, iidMsiEngine));
        }


		if (!fRet)
		{
			delete pThreadData;
			PMsiRecord precError(PostError(Imsg(imsgCustomActionLoadLibrary), *MsiString(szAction),
													 *istrTarget, *istrSource));
			if ((icaFlags & icaContinue) != 0)
				return Message(imtInfo, *precError), iesSuccess;
			else
				return FatalError(*precError);
		}

		// ownership of pThreadData transfers to the thread using the data.
		iesReturn = pThreadData->RunThread();

		// check for problems creating the CA server.
		if (iesReturn == iesServiceConnectionFailed)
			return FatalError(*PMsiRecord(PostError(Imsg(imsgServiceConnectionFailure))));

		if (iesReturn == iesBadActionData)  // crashes always fatal
			return FatalError(*PMsiRecord(PostError(Imsg(idbgCustomActionDied), szAction)));

		if (iesReturn == iesDLLLoadFailed)
		{
			PMsiRecord precError(PostError(Imsg(imsgCustomActionLoadLibrary), *MsiString(szAction),
													 *istrTarget, *istrSource));
			if ((icaFlags & icaContinue) != 0)
				return Message(imtInfo, *precError), iesSuccess;
			else
				return FatalError(*precError);
		}

		if ((icaFlags & icaContinue) != 0)
			return iesSuccess;
		return iesReturn;
	}
	else // (icaType == icaExe)
	{
		pThreadData->InitializeEXE(*istrSource, *istrTarget);
		iesReturn = pThreadData->RunThread();
		if (iesReturn != iesSuccess && iesReturn != iesNotDoneYet)     // EXE returned non-zero result and return not ignored
		{
			IErrorCode imsg = (iesReturn == iesExeLoadFailed ? Imsg(imsgCustomActionCreateExe)
															 : Imsg(imsgCustomActionExeFailed));
			PMsiRecord precError(PostError(imsg, *MsiString(szAction), *istrSource, *istrTarget));
			if ((icaFlags & icaContinue) != 0)
				return Message(imtInfo, *precError), iesSuccess;
			else
				return FatalError(*precError);
		}
		return iesReturn;
	}
}

iesEnum ScheduledCustomAction(IMsiRecord& riParams, const IMsiString& ristrProductCode,
				LANGID langid, IMsiMessage& riMessage, bool fRunScriptElevated, bool fAppCompatEnabled, 
				const GUID* guidAppCompatDB, const GUID* guidAppCompatID)
{
	// get custom action parameters and decode type
	int icaFlags  = riParams.GetInteger(icolActionType);
	if (icaFlags & icaRollback)
		icaFlags |= icaContinue;  // force UI suppression and termination if during rollback
	int icaType   = icaFlags & icaTypeMask;
	int icaSource = icaFlags & icaSourceMask;
	const ICHAR* szAction = riParams.GetString(icolAction);
	MsiString istrTarget(riParams.GetMsiString(icolTarget));
	MsiString istrSource;
	MsiString istrContext(riParams.GetMsiString(icolContextData));
	iesEnum iesStatus = iesSuccess;

	if (icaType == icaJScript || icaType == icaVBScript)
	{
		IErrorCode iecError = 0;  // integer in SHIP, string in DEBUG
		istrSource = riParams.GetMsiString(icolSource);
		if (icaSource == icaSourceFile)
		{
			PMsiStream pStream(0);
			PMsiRecord pError = ::CreateFileStream(istrSource, fFalse, *&pStream);
			if (pError)
			{
				riMessage.Message((icaFlags & icaContinue) != 0 ? imtInfo : imtError, *pError);
				return (icaFlags & icaContinue) != 0 ? iesSuccess : iesFailure;
			}
			::CopyStreamToString(*pStream, *&istrSource);
		}

		// if not on Win9X, scripts run via the custom action server.
		PMsiRecord piError = 0;
		int iResult = 0;

		// create context handle. Handle refcount transfered to automation object when created
		MSIHANDLE hContext = ENG::CreateCustomActionContext(icaFlags, *istrContext, ristrProductCode, langid, riMessage);

		// initialize thread data object for script custom action
		CActionThreadData* pThreadData = new CActionThreadData(riMessage, 0, szAction, icaFlags, 0, fRunScriptElevated, fAppCompatEnabled, guidAppCompatDB, guidAppCompatID);
		if ( ! pThreadData )
		{
			MsiCloseHandle(hContext);
			return iesFailure;
		}

		// set custom action thread to script state with script arguments
		pThreadData->InitializeRemoteScript(*istrSource, *istrTarget, hContext);

		// execute the script, transfers ownership of handle to automation object.
		iesEnum iesReturn = pThreadData->RunThread();

		return iesReturn;
	}

	CActionThreadData* pThreadData = new CActionThreadData(riMessage, 0, szAction, icaFlags, 0, fRunScriptElevated, fAppCompatEnabled, guidAppCompatDB, guidAppCompatID);
	if ( ! pThreadData )
		return iesFailure;

	if (icaSource == icaBinaryData)
	{
		PMsiStream pStream = (IMsiStream*)riParams.GetMsiData(icolSource); //!! should use QueryInterface?
		if (!pStream)
		{
			riMessage.Message((icaFlags & icaContinue) != 0 ? imtInfo : imtError,
					*PMsiRecord(::PostError(Imsg(idbgCustomActionNotInBinaryTable), szAction)));
			return (icaFlags & icaContinue) != 0 ? iesSuccess : iesFailure;
		}

		Assert(pStream);
		g_MessageContext.DisableTimeout();
		Bool fRet = pThreadData->CreateTempFile(*pStream, *&istrSource);
		g_MessageContext.EnableTimeout();
		if (!fRet)
		{
			delete pThreadData;
			return (icaFlags & icaContinue) != 0 ? iesSuccess : iesFailure;
		}
	}
	else
		istrSource = riParams.GetMsiString(icolSource);

	if (riMessage.Message(imtProgress, *g_piNullRecord) == imsCancel)
	{
		if (!(icaFlags & icaRollback))
			return iesUserExit;
	}

	if (icaType == icaDll)
	{
		Bool fRet = fTrue;

        // for security reasons, all DLLs run remoted on NT4 or Win2000
        if (!g_fWin9X)
        {
            pThreadData->InitializeRemoteDLL(*istrSource, *istrTarget,
                            ENG::CreateCustomActionContext(icaFlags, *istrContext,
                            ristrProductCode, langid, riMessage));
        }
        else
        {
            fRet = pThreadData->InitializeDLL(*istrSource, *istrTarget,
                                ENG::CreateCustomActionContext(icaFlags, *istrContext,
                                ristrProductCode, langid, riMessage));
        }

		if (!fRet)
		{
			delete pThreadData;
			riMessage.Message((icaFlags & icaContinue) != 0 ? imtInfo : imtError,
					*PMsiRecord(::PostError(Imsg(imsgCustomActionLoadLibrary), szAction, (const ICHAR*)istrTarget, (const ICHAR*)istrSource)));
			return (icaFlags & icaContinue) != 0 ? iesSuccess : iesFailure;
		}
	}
	else // (icaType == icaExe)
	{
		pThreadData->InitializeEXE(*istrSource, *istrTarget);
	}
	iesStatus = pThreadData->RunThread();
	if(icaFlags & icaNoTranslate)   // handle call for running self-reg from MsiExec
		return iesStatus;  // return the result as is
	if (iesStatus == iesNotDoneYet)     // EXE still running, we can ignore that here
		iesStatus = iesSuccess;

	// display error for exes only - dlls handle own errors
	if (iesStatus != iesSuccess)
	{
		if (icaType == icaDll && iesStatus == iesDLLLoadFailed)
		{
			riMessage.Message((icaFlags & icaContinue) != 0 ? imtInfo : imtError,
				*PMsiRecord(::PostError(Imsg(imsgCustomActionLoadLibrary), szAction,
										 (const ICHAR*)istrTarget, (const ICHAR*)istrSource)));
			iesStatus = iesFailure;
		}

		if(icaType == icaExe)
		{
			IErrorCode imsg = (iesStatus == iesExeLoadFailed ? Imsg(imsgCustomActionCreateExe)
															 : Imsg(imsgCustomActionExeFailed));
			riMessage.Message((icaFlags & icaContinue) != 0 ? imtInfo : imtError,
					*PMsiRecord(::PostError(imsg, szAction, (const ICHAR*)istrSource, (const ICHAR*)istrTarget)));

			if(iesStatus == iesExeLoadFailed)
				iesStatus = iesFailure;

		}
		if(icaFlags & icaContinue)
			iesStatus = iesSuccess;
	}
	return iesStatus;
}

//____________________________________________________________________________
//
// CMsiEngine local methods related to action processing
//____________________________________________________________________________

Bool CMsiEngine::GetActionText(const ICHAR* szAction, const IMsiString*& rpistrDescription,
										 const IMsiString*& rpistrTemplate)
{
	if(!szAction || *szAction == 0)
		return fFalse;

	MsiString strTemp(TEXT(""));
	strTemp.ReturnArg(rpistrTemplate);
	strTemp.ReturnArg(rpistrDescription);

	bool fLookupDll = false;
	if (!m_piActionTextCursor)
	{
		PMsiTable pActionTextTable(0);
		PMsiRecord pError(0);
		if((pError = m_piDatabase->LoadTable(*MsiString(*TEXT("ActionText")),0,*&pActionTextTable)) != 0)
			fLookupDll = true;
		else
		{
			m_piActionTextCursor = pActionTextTable->CreateCursor(fFalse);
			m_piActionTextCursor->SetFilter(iColumnBit(1));
		}
	}
	if ( !fLookupDll )
	{
		AssertNonZero(m_piActionTextCursor->PutString(1,*MsiString(szAction)));
		if( !m_piActionTextCursor->Next() )
			fLookupDll = true;
		else
		{
			rpistrDescription = &m_piActionTextCursor->GetString(2);
			rpistrTemplate = &m_piActionTextCursor->GetString(3);
		}
		m_piActionTextCursor->Reset();
	}
	if ( !fLookupDll )
		return fTrue;

	//  the action text hasn't been found in the table; I look it up in the message DLL.
	HMODULE hLib = WIN::LoadLibraryEx(MSI_MESSAGES_NAME, NULL,
												 LOAD_LIBRARY_AS_DATAFILE);
	if ( hLib )
	{
		WORD wLanguage = (WORD)GetPropertyInt(*MsiString(IPROPNAME_INSTALLLANGUAGE));
		int iRetry = (wLanguage == 0) ? 1 : 0;
		bool fEndLoop = false;

		while ( !fEndLoop )
		{
			if ( !MsiSwitchLanguage(iRetry, wLanguage) )
			{
				fEndLoop = true;        //  we've run out of languages
				continue;
			}

			HRSRC   hRsrc;
			HGLOBAL hGlobal;
			CHAR* szText;

			if ( (hRsrc = FindResourceEx(hLib, RT_RCDATA, (LPCTSTR)szAction, wLanguage)) != 0
				  && (hGlobal = LoadResource(hLib, hRsrc)) != 0
				  && (szText = (CHAR*)LockResource(hGlobal)) != 0
				  && *szText != 0 )
			{
				CTempBuffer<ICHAR, 1> szBuffer(MAX_PATH);
				int cch = 0;
#ifdef UNICODE
				unsigned int iCodePage = MsiGetCodepage(wLanguage);
				cch = WIN::MultiByteToWideChar(iCodePage, 0, szText, -1, 0, 0);
				if ( cch )
				{
					szBuffer.SetSize(cch);
					AssertNonZero(WIN::MultiByteToWideChar(iCodePage, 0, szText, -1,
																		szBuffer, cch));
				}
#else
				cch = IStrLen(szText);
				if ( cch )
				{
					szBuffer.SetSize(cch+1);
					StringCchCopy(szBuffer, szBuffer.GetSize(), szText);
				}
#endif // UNICODE
				if ( cch )
				{
					ICHAR * pchTab = IStrChr(szBuffer, TEXT('\t'));
					MsiString strTemp;
					if ( pchTab )
					{
						*pchTab = 0;
						strTemp = pchTab+1;
						strTemp.ReturnArg(rpistrTemplate);
					}
					else
						AssertSz(0, TEXT("Tab character should be present in ActionText generated string!"));
					strTemp = (ICHAR*)szBuffer;
					strTemp.ReturnArg(rpistrDescription);
				}
				fEndLoop = (rpistrDescription->TextSize() || rpistrTemplate->TextSize());

			}       // if find & load resource

		}       // while ( !fEndLoop )
		AssertNonZero(WIN::FreeLibrary(hLib));

	}       // if ( hLib )

	return (rpistrDescription->TextSize() || rpistrTemplate->TextSize()) ? fTrue : fFalse;
}

IMsiRecord* CMsiEngine::FetchSingleRow(const ICHAR* szQuery, const ICHAR* szValue)
{
	AssertSz(szQuery && *szQuery, TEXT("Bad szQuery argument in CMsiEngine::FetchSingleRow"));
	AssertSz(szValue, TEXT("Bad szValue argument in CMsiEngine::FetchSingleRow"));
	//  I assume that in the case the combined string is larger than MAX_PATH chars
	//  szValue is replaced only once in szQuery.
	CTempBuffer<ICHAR, 1> rgchQueryBuf(IStrLen(szQuery) + IStrLen(szValue) + 1);
	StringCchPrintf(rgchQueryBuf, rgchQueryBuf.GetSize(), szQuery, szValue); // faster than parameterized query
	PMsiView pView(0);
	PMsiRecord precError(OpenView(rgchQueryBuf, ivcFetch, *&pView));
	if (precError != 0
	|| (precError = pView->Execute(0)) != 0)
	{
		AssertSz(0, MsiString(precError->FormatText(fFalse)));
		return 0;
	}
	return pView->Fetch();
}

IMsiRecord* CMsiEngine::GetFileInstalledLocation(const IMsiString& ristrFile,
												 const IMsiString*& rpistrFilePath, bool fUseRequestedComponentState, bool *pfSourceResolutionAttempted)
{
	PMsiTable pFileTable(0);
	IMsiRecord* piError = 0;

	piError = LoadFileTable(0, *&pFileTable);

	if (piError)
		return piError;

	PMsiCursor pFileCursor = pFileTable->CreateCursor(fFalse);

	pFileCursor->SetFilter(iColumnBit(m_mpeftCol[ieftKey]));
	pFileCursor->PutString(m_mpeftCol[ieftKey], ristrFile);

	if (!pFileCursor->Next())
		return PostError(Imsg(idbgBadFile),ristrFile);

	MsiStringId idComponent = pFileCursor->GetInteger(m_mpeftCol[ieftComponent]);

	if (!m_piComponentTable)
		return PostError(Imsg(idbgSelMgrNotInitialized),0);

	PMsiCursor pComponentCursor = m_piComponentTable->CreateCursor(fFalse);
	if (!pComponentCursor)
		return PostError(Imsg(imsgOutOfMemory));

	pComponentCursor->SetFilter(iColumnBit(m_colComponentKey));
	pComponentCursor->PutInteger(m_colComponentKey, idComponent);

	if (!pComponentCursor->Next())
		return PostError(Imsg(idbgBadComponent),*MsiString(m_piDatabase->DecodeString(idComponent)));

	PMsiPath pPath(0);
	int iefLFN = iefSuppressLFN;

	iisEnum iisState = (iisEnum)pComponentCursor->GetInteger(m_colComponentAction);
	if(iisState == iMsiNullInteger && fUseRequestedComponentState)
		iisState = (iisEnum)pComponentCursor->GetInteger(m_colComponentActionRequest);
	if(iisState == iisAbsent || iisState == iisFileAbsent || iisState == iisHKCRFileAbsent || iisState == iisHKCRAbsent || iisState == iMsiNullInteger)
	{
		// If the action state is Absent or the state is not changing, we should get the Installed
		// state to cover the cases where the state is not chaning, or the file is schedule for
		// removal (In this case the caller/Custom Action should be conditioned properly to use this
		// information before the file is removed).
		iisState = (iisEnum)pComponentCursor->GetInteger(m_colComponentInstalled);
	}

	if(iisState == iisAbsent || iisState == iisFileAbsent || iisState == iisHKCRFileAbsent || iisState == iisHKCRAbsent || iisState == iMsiNullInteger)
	{
		return PostError(Imsg(idbgFileNotMarkedForInstall),ristrFile);
	}
	else if(iisState == iisSource)
	{
		if (pfSourceResolutionAttempted)
			*pfSourceResolutionAttempted = true;

		if((piError = GetSourcePath(*MsiString(pComponentCursor->GetString(m_colComponentDir)),*&pPath)) != 0)
			return piError;
		iefLFN = iefNoSourceLFN;
	}
	else if(iisState == iisLocal)
	{
		if((piError = GetTargetPath(*MsiString(pComponentCursor->GetString(m_colComponentDir)),*&pPath)) != 0)
			return piError;
		iefLFN = iefSuppressLFN;
	}
	else
		AssertSz(0, "Invalid component action state in GetFileInstalledLocation");

	Bool fLFN = ((GetMode() & iefLFN) == 0 && pPath->SupportsLFN()) ? fTrue : fFalse;
	MsiString strFileName;
	if((piError = m_riServices.ExtractFileName(MsiString(pFileCursor->GetString(m_mpeftCol[ieftName])),fLFN,*&strFileName)) != 0 ||
		(piError = pPath->GetFullFilePath(strFileName, rpistrFilePath)) != 0)
	{
		return piError;
	}

	return 0;
}

/*----------------------------------------------------------------------------
  CMsiEngine::Sequence() - overall action sequencer
 [1] = Name of action, used for lookup in engine, handler, CustomAction table
 [2] = (optional) Localized text for action, separated with a ':' from:
       (optional) Localized action data record format template string
 [3] = Condition expression, action called only if result is fTrue
 [4] = Sequence number, negative numbers reserved for exit actions:
       -1 for iesSuccess, -2 for iesUserExit, -3 for iesFailure

  Note: this function may be called recursively! As such, it should not do
  anything that may break during recursion.
----------------------------------------------------------------------------*/

const ICHAR sqlActionsTemplate[] =
TEXT("SELECT `Action`,NULL,`Condition` FROM `%s` WHERE `Sequence` > 0 ORDER BY `Sequence`");

const ICHAR sqlFinalTemplate[] =
TEXT("SELECT `Action`,NULL,`Condition` FROM `%s` WHERE `Sequence` = ?");

iesEnum CMsiEngine::Sequence(const ICHAR* szTable)
{
	if (m_fInitialized == fFalse)
		return iesWrongState;

	m_cSequenceLevels++; // must decrement before we return

	// Open Action table and begin sequencing
	// Does not return to install host until completion or abort

	ICHAR sqlActions[sizeof(sqlActionsTemplate)/sizeof(ICHAR) + 3*32];

	PMsiView pSequenceView(0);
	StringCchPrintf(sqlActions, ARRAY_ELEMENTS(sqlActions), sqlActionsTemplate, szTable);

	// nothing to do.
	if (!m_piDatabase->FindTable(*MsiString(*szTable)))
		return(m_cSequenceLevels--, iesSuccess);

	PMsiRecord Error(m_piDatabase->OpenView(sqlActions, ivcFetch, *&pSequenceView));
	if (Error)
		return (m_cSequenceLevels--, FatalError(*Error));
	Error = pSequenceView->Execute(0);
	if (Error)
		return (m_cSequenceLevels--, FatalError(*Error));
	iesEnum iesReturn = iesSuccess;  // status to return to caller
	iesEnum iesAction = iesSuccess;  // result of previous action
	const ICHAR* szAction = 0;       //!! watch out, this is used after the record to which it points is out of scope
	m_issSegment = issPreExecution;
	while (iesReturn == iesSuccess)
	{
		iesReturn = iesAction;
		if (iesReturn != iesSuccess)
		{
			if(m_cSequenceLevels-1 == m_cExecutionPhaseSequenceLevel)
			{
				// User may elect to abort if rollback fails
				iesEnum iesEndTrans = EndTransaction(iesReturn);
				Assert(iesEndTrans == iesSuccess || iesEndTrans == iesUserExit || iesEndTrans == iesFailure);
			}

			if(m_cSequenceLevels == 1)  // one final pass to process terminate action
			{
				ENG::WaitForCustomActionThreads(this, fFalse, *this); // wait for async custom actions, except if icaContinue

				if (iesReturn == iesBadActionData)  // currently no exit dialog (custom action not found, or bad expression)
				{
					iesReturn = iesFailure;  // should be an exit dialog for this
					Error = PostError(Imsg(idbgBadActionData), szAction);
					Message(imtError, *Error);
				}

				// display the final confirmation dialog if necessary
				if(m_fEndDialog && !m_piParentEngine &&
					(
						// successful completion with no pending reboot prompt
						((iesReturn == iesSuccess || iesReturn == iesFinished) &&
						 ((GetMode() & (iefReboot|iefRebootNow)) == 0))

						||

						// failure
						(iesReturn == iesFailure)
				  ))
				{
					Error = PostError(iesReturn == iesFailure ? Imsg(imsgInstallFailed) : Imsg(imsgInstallSucceeded));
					Message(imtEnum(imtUser|imtForceQuietMessage), *Error);
				}

				pSequenceView->Close();
				StringCchPrintf(sqlActions, ARRAY_ELEMENTS(sqlActions), sqlFinalTemplate, szTable);
				Error = m_piDatabase->OpenView(sqlActions, ivcFetch, *&pSequenceView);
				if (Error)
				{
					m_issSegment = issNotSequenced;
					return (m_cSequenceLevels--, FatalError(*Error));
				}
				PMsiRecord Param = &m_riServices.CreateRecord(1);
				Param->SetInteger(1, iesReturn == iesFinished ? -iesSuccess : -iesReturn);
				AssertRecord(pSequenceView->Execute(Param));
			}
			else
				break;
		}
		PMsiRecord pSequenceRecord(pSequenceView->Fetch());
		if (!pSequenceRecord)
		{
			if (iesReturn != iesSuccess)    // terminate action not found
				break;
			iesAction = iesFinished;
			continue;
		}
		szAction = pSequenceRecord->GetString(easAction);
		if (!szAction)  // should never happen, since easAction is primary key
			continue;
		iecEnum iecStat = EvaluateCondition(pSequenceRecord->GetString(easCondition));

		if (iecStat == iecError)
		{
			iesAction = iesBadActionData;
			continue;
		}
		if (iecStat == iecFalse)
		{
			DEBUGMSG1(TEXT("Skipping action: %s (condition is false)"), szAction);
			continue;
		}
		// else continue if iecTrue or iecNone

		// nothing set before the call to DoAction should be depended upon after the call
		// - DoAction may possibly call Sequence
		iesAction = DoAction(szAction);
		if(iesAction == iesNoAction)
			iesAction = iesSuccess;

	}
	m_cSequenceLevels--;
	m_issSegment = issNotSequenced;
	return iesReturn == iesFinished ? iesSuccess : iesReturn; //JDELO
}

//______________________________________________________________________________
//
// CScriptSite implementation
//______________________________________________________________________________

const WCHAR g_szHostItemName[] = L"Session";

// temporary logging for development use
BOOL g_fLogCalls = FALSE;
const WCHAR*  g_szErrorContext = L"";        // normally a static string, never freed
const WCHAR*  g_szErrorContextString = L"";  // only valid during call to SetContext
int           g_iErrorContextInt = 0x80000000L;

void SetContextInt(int iContext)
{
	g_iErrorContextInt = iContext;
}
void SetContextString(const WCHAR* szContext)
{
	g_szErrorContextString = szContext;
}
void SetContext(const WCHAR* szContext)
{
	g_szErrorContext = szContext;
	if (g_fLogCalls)
	{
//              if (g_iErrorContextInt == 0x80000000L)
//                      wprintf(L"%s %s\n", g_szErrorContext, g_szErrorContextString);
//              else
//                      wprintf(L"%s %s 0x%X\n", g_szErrorContext, g_szErrorContextString, g_iErrorContextInt);
	}
	g_iErrorContextInt = 0x80000000L;
	g_szErrorContextString = L"";
}

HRESULT __stdcall CScriptSite::QueryInterface(const IID& riid, void** ppvObj)
{
	if (!ppvObj)
		return E_INVALIDARG;
	SetContextInt(riid.Data1);
	*ppvObj = 0L;
	if (riid == IID_IUnknown || riid == IID_IActiveScriptSite)
		*ppvObj = (IActiveScriptSite*)this;
	else if (riid == IID_IActiveScriptSiteWindow)
		*ppvObj = (IActiveScriptSiteWindow*)this;
	else
	{
		SetContext(L"QueryInterface failed");
		return E_NOINTERFACE;
	}
	SetContext(L"QueryInterface succeeded");
	AddRef();
	return S_OK;
}

ULONG CScriptSite::AddRef()
{
	return ++m_iRefCnt;
}

ULONG CScriptSite::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

HRESULT __stdcall CScriptSite::GetLCID(LCID* plcid)
{
	SetContext(L"GetLCID");
	*plcid = m_langid;
	return S_OK;
}

HRESULT __stdcall CScriptSite::GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown **ppiunk, ITypeInfo **ppiTypeInfo)
{
	SetContextString(g_szHostItemName);
	SetContextInt(dwReturnMask);
	SetContext(L"GetItemInfo");
	if (lstrcmpiW(pstrName, g_szHostItemName) != 0)
			return TYPE_E_ELEMENTNOTFOUND;
	if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
		return E_NOTIMPL;
	if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
	{
		if (!ppiunk)
			return E_INVALIDARG;
		(*ppiunk = m_piHost)->AddRef();
	}
	if (ppiTypeInfo)
		*ppiTypeInfo = 0;  // scripting engines don't use this even if we do set it
	return S_OK;
}

HRESULT __stdcall CScriptSite::GetDocVersionString(BSTR* /* pszVersion */)
{
	SetContext(L"GetDocVersionString");
	return E_NOTIMPL;
}

HRESULT __stdcall CScriptSite::OnScriptTerminate(const VARIANT* /*pvarResult*/, const EXCEPINFO* /*pexcepinfo*/)
{  // never appears to be called from VBScript of JScript
	SetContext(L"OnScriptTerminate");
	return S_OK;
}

HRESULT __stdcall CScriptSite::OnStateChange(SCRIPTSTATE ssScriptState)
{
	SetContextInt(ssScriptState);
	SetContext(L"OnStateChange");
	m_ssScriptState = ssScriptState;
	return S_OK;
}

HRESULT __stdcall CScriptSite::OnScriptError(IActiveScriptError *pierror)
{
	SetContext(L"OnScriptError");
	ClearError();
	if (pierror)
	{
		DWORD iContext = 0;
		const WCHAR* szErrorObj = L"Unknown";
		const WCHAR* szErrorDesc = L"(no info)";
		EXCEPINFO excepinfo;
		if (pierror->GetExceptionInfo(&excepinfo) == S_OK)
		{
			m_hrError = excepinfo.scode ? excepinfo.scode : TYPE_E_IOERROR;
			SaveErrorString(m_szErrorObj, excepinfo.bstrSource);
			SaveErrorString(m_szErrorDesc, excepinfo.bstrDescription);
			if (excepinfo.bstrHelpFile)
				OLEAUT32::SysFreeString(excepinfo.bstrHelpFile);
		}
		else  // should never occur
			m_hrError = E_ABORT;
		BSTR bstrSourceLine = 0;
		pierror->GetSourceLineText(&bstrSourceLine);
		SaveErrorString(m_szSourceLine, bstrSourceLine);
		if (pierror->GetSourcePosition(&iContext, &m_iErrorLine, &m_iErrorColumn) == S_OK)
		{
			m_iErrorColumn++;
			m_iErrorLine++;
		}
		else
			m_iErrorColumn = m_iErrorLine = 0;
	}
	return S_OK;  // return S_FALSE to keep running script in debugger, if available, S_OK to keep running regardless
}  // JD: Does not seem to matter what is returned here. Execution stops in all cases.

HRESULT __stdcall CScriptSite::OnEnterScript()
{
	return S_OK;
}

HRESULT __stdcall CScriptSite::OnLeaveScript()
{
	return S_OK;
}

HRESULT __stdcall CScriptSite::GetWindow(HWND *phwnd)
{
	SetContext(L"GetWindow");
	*phwnd = m_hwnd;
//      *phwnd = WIN::GetDesktopWindow();
	return S_OK;
}

HRESULT __stdcall CScriptSite::EnableModeless(BOOL fEnable)
{
	SetContextInt(fEnable);
	SetContext(L"EnableModeless");
//      return WIN::EnableWindow(m_hwnd, fEnable) ? S_OK : E_FAIL;
	return S_OK;
}

extern CMsiCustomAction* g_pCustomActionContext;
CScriptSite* CreateScriptSite(const IID& riidLanguage, IDispatch* piHost,
										HWND hwndParent, LANGID langid)
{
	// if on Win2K or higher, do not create the scripting engine if a per-user scripting 
	// engine is registered. Doing so would load an untrusted DLL into the CA server 
	// process and provide an avenue of attack to the service.
	if (MinimumPlatformWindows2000() && g_pCustomActionContext)
	{
		// only perform check if CA context is impersonated. Elevated contexts will not
		// load per-user scripting engines.
		icacCustomActionContext icacCurrentContext = g_pCustomActionContext->GetServerContext();
		if ((icacCurrentContext == icac32Impersonated) || (icacCurrentContext == icac64Impersonated))
		{
			// Fail to safe - assume that the per-user key exists.
			Bool fExists = fTrue;
			IMsiServices* piServices = LoadServices();

			WCHAR szCLSID[cchGUID+1];
			if (OLE32::StringFromGUID2(riidLanguage, szCLSID, ARRAY_ELEMENTS(szCLSID)))
			{
				// block also provides scope for all objects requiring services
				MsiString strKey = L"Software\\Classes\\CLSID\\";
				strKey += szCLSID;

				// open HKCU and create regkey object on expected registration key.
				// CreateChild is just object constructor, won't actually create key.
				PMsiRegKey pKey(NULL);
#ifdef _WIN64
				PMsiRegKey pRoot(&(piServices->GetRootKey(rrkCurrentUser, ibt64bit)));
#else // !_WIN64
				// always read from 32bit hive even on 64bit machines for 32bit process
				PMsiRegKey pRoot(&(piServices->GetRootKey(rrkCurrentUser, ibt32bit)));
#endif // _WIN64
				if (pRoot)
				{
					pKey = &pRoot->CreateChild(strKey);
				}
				if (pKey)
				{
					// errors from Exists() are ignored, as the default is to fail
					// by assuming the key exists.
					PMsiRecord pErr = pKey->Exists(fExists);
				}
			}
			FreeServices();

			// if the registry key exists, creating the scripting engine is not
			// allowed.
			if (fExists)
			{
				DEBUGMSGV("Per-User registration of script engine found. Rejecting unsecure script implementation.");
				return NULL;
			}
		}		
	}

	SetContext(L"CreateScriptSite");
	CScriptSite* piScriptSite = new CScriptSite(hwndParent, langid);
	if (piScriptSite == 0)
		return 0;
	HRESULT hr = piScriptSite->AttachScriptEngine(riidLanguage, piHost);
	if (hr != S_OK)
		DestroyScriptSite(piScriptSite);
	return piScriptSite;
}

void DestroyScriptSite(CScriptSite*& rpiScriptSite)
{
	if (rpiScriptSite == 0)
		return;
	HRESULT hr = rpiScriptSite->CloseScriptEngine();
	if (hr == S_OK)
	{
		rpiScriptSite->Release();
		rpiScriptSite = 0;
	}
}

CScriptSite::CScriptSite(HWND hwndParent, LANGID langid)
	: m_piScriptEngine(0), m_piScriptParse(0), m_piHost(0)
	, m_szErrorObj(0), m_szErrorDesc(0), m_szSourceLine(0)
	, m_hwnd(hwndParent), m_langid(langid), m_iRefCnt(1)
	, m_ssScriptState(SCRIPTSTATE_UNINITIALIZED)
	, m_fCoInitialized(false)
{
	m_varResult.vt = VT_EMPTY;
}

CScriptSite::~CScriptSite()
{
	SetContext(L"CScriptSite Destructor");
	if (m_piScriptParse) m_piScriptParse->Release();
	if (m_piScriptEngine) m_piScriptEngine->Release();
	if (m_piHost) m_piHost->Release();
	if (m_varResult.vt != VT_EMPTY)
		OLEAUT32::VariantClear(&m_varResult);
	if (m_fCoInitialized)
		OLE32::CoUninitialize();
}

void CScriptSite::ClearError()
{
	m_hrError = S_OK;
#ifdef UNICODE
	if (m_szErrorObj)   OLEAUT32::SysFreeString(m_szErrorObj),   m_szErrorObj = 0;
	if (m_szErrorDesc)  OLEAUT32::SysFreeString(m_szErrorDesc),  m_szErrorDesc = 0;
	if (m_szSourceLine) OLEAUT32::SysFreeString(m_szSourceLine), m_szSourceLine = 0;
#else
	if (m_szErrorObj)   delete const_cast<TCHAR*>(m_szErrorObj),   m_szErrorObj = 0;
	if (m_szErrorDesc)  delete const_cast<TCHAR*>(m_szErrorDesc),  m_szErrorDesc = 0;
	if (m_szSourceLine) delete const_cast<TCHAR*>(m_szSourceLine), m_szSourceLine = 0;
#endif
}

HRESULT CScriptSite::AttachScriptEngine(const IID& iidLanguage, IDispatch* piHost)
{
	SetContext(L"Create Script Engine");
	HRESULT hr = OLE32::CoCreateInstance(iidLanguage, 0, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void **)&m_piScriptEngine);
	if (hr == CO_E_NOTINITIALIZED)  // probably called early on from the UI thread
	{
		OLE32::CoInitialize(0);   // initialize OLE and try again
		m_fCoInitialized = true;
		hr = OLE32::CoCreateInstance(iidLanguage, 0, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void **)&m_piScriptEngine);
	}
	if (hr == S_OK)
	{
		SetContext(L"Get Script Parser");
		hr = m_piScriptEngine->QueryInterface(IID_IActiveScriptParse, (void **)&m_piScriptParse);
	}
	if (hr == S_OK)
	{
		if (!piHost)
		{
			hr = E_FAIL;
		}
		else
		{
			(m_piHost = piHost)->AddRef();  // need to do this before AddNamedItem to support callback GetItemInfo
			SetContext(L"SetScriptSite");
			hr = m_piScriptEngine->SetScriptSite(this);
		}
	}
	if (hr == S_OK)
	{
		SetContext(L"IActiveScriptParse::InitNew");
		hr = m_piScriptParse->InitNew();
	}
	if (hr == S_OK)
	{
		SetContext(L"AddNamedItem: Session");
		hr = m_piScriptEngine->AddNamedItem(g_szHostItemName, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);
	}
	return hr;
}

HRESULT CScriptSite::ParseScript(const TCHAR* szScript, int cchScriptMax)
{
	SetContext(L"ParseScript");
#ifdef UNICODE
	cchScriptMax;
	HRESULT hr = m_piScriptParse->ParseScriptText(szScript, g_szHostItemName, 0, 0, (DWORD)0, 0, 0L, 0, 0);
#else
	WCHAR* wszScript = new WCHAR[cchScriptMax+1];
	if ( ! wszScript )
		return E_OUTOFMEMORY;
	AssertNonZero(WIN::MultiByteToWideChar(CP_ACP, 0, szScript, -1, wszScript, cchScriptMax+1));
	HRESULT hr = m_piScriptParse->ParseScriptText(wszScript, g_szHostItemName, 0, 0, (DWORD)0, 0, 0L, 0, 0);
#endif
	if (hr == S_OK && m_ssScriptState != SCRIPTSTATE_STARTED)
	{
		SetContext(L"Start script execution");
		m_ssScriptState = SCRIPTSTATE_STARTED; // not set by engine, prevent getting here on recursion
		m_hrError = S_OK;
		hr = m_piScriptEngine->SetScriptState(SCRIPTSTATE_CONNECTED);
		SetContext(L"Script parsed");
		if (hr == S_OK)  // SetScriptState normally succeeds, error set by OnScriptError() callback
			hr = m_hrError;
		m_piScriptEngine->GetScriptState(&m_ssScriptState);
	}
#ifndef UNICODE
	delete [] wszScript;
#endif
	return hr;
}

HRESULT CScriptSite::CallScriptFunction(const TCHAR* szFunction)
{
#ifdef UNICODE
	OLECHAR* szName = const_cast<OLECHAR*>(szFunction);  // prototype non-const
#else
	OLECHAR rgchBuf[100];
	OLECHAR* szName = rgchBuf;
	AssertNonZero(WIN::MultiByteToWideChar(CP_ACP, 0, szFunction, -1, rgchBuf, sizeof(rgchBuf)/sizeof(OLECHAR)));
#endif
	if (m_ssScriptState != SCRIPTSTATE_CONNECTED)
		return E_UNEXPECTED;  // wrong calling sequence
	SetContext(L"GetScriptDispatch");
	if (m_varResult.vt != VT_EMPTY)
		OLEAUT32::VariantClear(&m_varResult);
	IDispatch* piDispatch;
	HRESULT hr = m_piScriptEngine->GetScriptDispatch(g_szHostItemName, &piDispatch);
//      HRESULT hr = m_piScriptEngine->GetScriptDispatch(0, &piDispatch);
	if (hr != S_OK)
		return hr;
	DISPID dispid;
	SetContextString(szName);
	SetContext(L"GetIDsOfNames");
	hr = piDispatch->GetIDsOfNames(GUID_NULL, &szName, 1, 0, &dispid);
	if (hr != S_OK)
	{
		SetContext(L"GetIDsOfNames(0) failed, trying lcid,");
		hr = piDispatch->GetIDsOfNames(GUID_NULL, &szName, 1, m_langid, &dispid);
		if (hr != S_OK)
		{
			piDispatch->Release();
			return hr;
		}
	}
	SetContext(L"Invoke Script Function");
	unsigned int cArgs = 0;
	DISPPARAMS dispparams = {(VARIANT*)0, (DISPID*)0, cArgs, (unsigned int)0};
	m_hrError = S_OK;
	hr = piDispatch->Invoke(dispid, GUID_NULL, m_langid, DISPATCH_METHOD, &dispparams, &m_varResult, 0, 0);
	piDispatch->Release();
	if (m_hrError != S_OK)  // if error set by OnScriptError() callback
	{
		SetContext(L"Script Function Failed");
		hr = m_hrError;
	}
	return hr;
}

HRESULT CScriptSite::GetIntegerResult(int& riResult)
{
	if (m_varResult.vt == VT_EMPTY)
		return DISP_E_PARAMNOTFOUND;
	HRESULT hr = OLEAUT32::VariantChangeType(&m_varResult, &m_varResult, 0, VT_I4);
	riResult = (hr == S_OK ? m_varResult.lVal : 0);
	return hr;
}

void CScriptSite::SaveErrorString(const TCHAR*& rszSave, BSTR szData)
{
	if (rszSave)
#if UNICODE
		OLEAUT32::SysFreeString(rszSave);
	rszSave = szData;
#else
		delete const_cast<TCHAR*>(rszSave);
	if (szData && *szData)
	{
		unsigned int cb = WIN::WideCharToMultiByte(CP_ACP, 0, szData, -1, 0, 0, 0, 0);
		rszSave = new TCHAR[cb];
		if ( rszSave )
			WIN::WideCharToMultiByte(CP_ACP, 0, szData, -1, const_cast<TCHAR*>(rszSave), cb, 0, 0);
		OLEAUT32::SysFreeString(szData);
	}
	else
		rszSave = 0;
#endif
}

HRESULT CScriptSite::CloseScriptEngine()
{
	SetContext(L"CloseScriptEngine");
	ClearError();
	if (m_piScriptEngine == 0)
		return S_OK;
	return m_piScriptEngine->Close();
}

//____________________________________________________________________________
//
// MessageHandler factory
//____________________________________________________________________________

IUnknown* CreateMessageHandler()
{
	CMsiClientMessage* piMessage = 0;
	if (g_MessageContext.Initialize(fFalse, iuiNone) == NOERROR)
	{
		piMessage = new CMsiClientMessage();
		piMessage->m_fMessageContextInitialized = true;
	}
	return piMessage;
}

//____________________________________________________________________________
//
// Basic UI implementation - simple UI handler
//     Note: cannot use MsiString wrapper objects or Asserts - no MsiServices
//____________________________________________________________________________

CBasicUI::CBasicUI()  // global object, called per-process at DLL load
 : m_fInitialized(false)
 , m_hProgress(0), m_hButtonFont(0), m_iButtonCodepage(0), m_hTextFont(0), m_iTextCodepage(0)
 , m_iPerTick(0), m_iProgress(0), m_iProgressTotal(0), m_fProgressByData(false)
 , m_fCancelVisible(true), m_fNeverShowCancel(false), m_fWindowVisible(false)
 , m_uiStartTime(0), m_uiLastReportTime(0), m_fCaptionChanged(true)
 , m_fHideDialog(false), m_fQuiet(false), m_fBiDi(false), m_fMirrored(false)
 , m_uiBannerText(0), m_iPackageLanguage(0), m_iPackageCodepage(0), m_fUserCancel(false)
{
	m_ipdDirection = ProgressData::ipdForward;
	m_szCaption[0] = 0;
	m_cTotalPrev = 0;
	m_cSoFarPrev = 0;
}

bool CBasicUI::Initialize(HWND hwndParent, bool fQuiet, bool fHideDialog, bool fNoModalDialogs, bool fHideCancel, bool fUseUninstallBannerText, bool fSourceResOnly)
{
	if (m_fInitialized)
		return false;
	m_hwndParent       = hwndParent;
	m_fQuiet           = fQuiet;
	m_fSourceResolutionOnly = (fQuiet && fSourceResOnly);
	m_fHideDialog      = fHideDialog;
	m_fNoModalDialogs  = fNoModalDialogs;
	m_fNeverShowCancel = fHideCancel;
	m_fCancelVisible   = ! fHideCancel;
	m_fUserCancel      = false;

	INITCOMMONCONTROLSEX iccData = {sizeof(INITCOMMONCONTROLSEX), ICC_PROGRESS_CLASS};
	COMCTL32::InitCommonControlsEx(&iccData);

	SetDefaultCaption();
	m_fCaptionChanged = true;
	ICHAR rgchBuf[256] = {0};    // room for "Setup is starting..." message

	m_uiBannerText = IDS_PREPARING_TO_INSTALL;
	if(fUseUninstallBannerText)
		m_uiBannerText = IDS_PREPARING_TO_UNINSTALL;

	m_iPackageCodepage = MsiLoadString(g_hInstance, m_uiBannerText, rgchBuf, sizeof(rgchBuf)/sizeof(ICHAR), GetPackageLanguage());
	Assert(m_iPackageCodepage != 0);

	if(!fQuiet && !fHideDialog)
		SetProgressData(imtActionStart >> imtShiftCount, rgchBuf, true);
	//!! detect errors here?
	m_fInitialized = true;
	return true;
}

//
// The Windows installer title is always in the system codepage
//
void CBasicUI::SetDefaultCaption()
{
	AssertNonZero(MsiLoadString(g_hInstance, IDS_WINDOWS_INSTALLER_TITLE, m_szCaption, sizeof(m_szCaption)/sizeof(ICHAR), 0) != 0);
}

const ICHAR* CBasicUI::GetCaption()
{
	if (m_szCaption[0] == 0)
		SetDefaultCaption();

	return m_szCaption;
}

bool CBasicUI::Terminate()
{
	if (!m_fInitialized)
		return false;
	if (m_hProgress)
		WIN::DestroyWindow(m_hProgress), m_hProgress = 0;
	MsiDestroyFont(m_hButtonFont);
	COMCTL32::Unbind();
	m_fBiDi = false;
	m_fMirrored = false;
	m_uiBannerText = 0;
	m_iButtonCodepage = 0;
	m_iPackageLanguage = 0;
	MsiDestroyFont(m_hTextFont);
	m_iTextCodepage = 0;
	m_fCancelVisible = true;
	m_fNeverShowCancel = false;
	m_fWindowVisible = false;
	m_fQuiet = false;
	m_szCaption[0] = 0;
	m_fCaptionChanged = true;
	m_fInitialized = false;
	m_cTotalPrev = 0;
	m_cSoFarPrev = 0;
	m_fUserCancel = false;
	return true;
}

void CBasicUI::SetUserCancel(bool fCancel)
{
	if (fCancel)
	{
		// show that we have recognized that the user cancelled the install
		// by greying out the cancel button (i.e. disabling)
		HWND hButton = WIN::GetDlgItem(m_hProgress, IDC_BASIC_CANCEL);
		EnableWindow(hButton, /* bEnable = */ FALSE);

		// change banner text to indicate user cancel
		CTempBuffer<ICHAR,1> rgchBuf(512);
		rgchBuf[0] = 0;
		AssertNonZero(MsiLoadString(g_hInstance, IDS_CANCELING_INSTALL, rgchBuf, rgchBuf.GetSize(), GetPackageLanguage()));
		if ( g_szBannerText.SetSize(IStrLen(rgchBuf) + 1) )
			StringCchCopy(g_szBannerText, g_szBannerText.GetSize(), rgchBuf);
		SetProgressData(imtActionStart >> imtShiftCount, g_szBannerText, true);
	}

	// set m_fUserCancel last to make sure it is set to the "user-cancelled" state
	m_fUserCancel = fCancel;
}

imsEnum CBasicUI::FatalError(imtEnum imt, const ICHAR* szMessage)
{
	return (imsEnum)MsiMessageBox(0, szMessage, 0, (imt & ~imtTypeMask) | MB_TASKMODAL, GetPackageCodepage(), GetPackageLanguage());
}

imsEnum CBasicUI::Message(imtEnum imt, IMsiRecord& riRecord)
{
	int iForceQuietMessage = imt & imtForceQuietMessage;
	imt = imtEnum(imt & ~(iInternalFlags));

	int iError = riRecord.GetInteger(1);
	int iMsgBox = imt & ~imtTypeMask;
	UINT uiType = 0;

	switch(imt >> imtShiftCount)
	{
	case imtCommonData  >> imtShiftCount: // language ID, for cacheing by IMsiMessage impl.
	{
		if(iError == (int)icmtLangId)
		{
			if (!riRecord.IsNull(3))  // should always be present unless we are executing an old script
				m_iPackageCodepage = riRecord.GetInteger(3);
			UINT iLangId = riRecord.GetInteger(2);
			if (iLangId != m_iPackageLanguage)
			{
				m_iPackageLanguage = iLangId;
				AssertNonZero(SetCancelButtonText());
			}
		}
		else if(iError == (int)icmtCaption)
		{
			if (!riRecord.IsNull(2))
			{
				IStrCopyLen(m_szCaption, riRecord.GetString(2), cchMaxCaption);
				m_fCaptionChanged = true;
			}
		}
		else if(iError == (int)icmtCancelShow)
		{
			m_fCancelVisible = m_fNeverShowCancel ? false : riRecord.GetInteger(2) != 0;
			if (m_hProgress)
				WIN::ShowWindow(WIN::GetDlgItem(m_hProgress, IDC_BASIC_CANCEL), m_fCancelVisible ? SW_SHOW : SW_HIDE);
			//!! IVAN, fill in the blanks here
		}
		else if (iError == (int)icmtDialogHide)
		{
			WIN::ShowWindow(m_hProgress, SW_HIDE);
			// cannot destroy window, else custom actions don't work 0> WIN::DestroyWindow(m_hProgress), m_hProgress = 0;
			m_fWindowVisible = false;
		}
		return imsOk;
	}
	case imtFatalExit      >> imtShiftCount: // fatal exit, only from server to client
	case imtOutOfDiskSpace >> imtShiftCount:
	case imtError          >> imtShiftCount: // error message, field[1] is error
		if (!(iMsgBox & MB_ICONMASK))
		{
			// set icon if none was provided
			uiType = MB_ICONEXCLAMATION;
		}
		// fall through
	case imtWarning        >> imtShiftCount: // warning message, field[1] is error, not fatal
		if ( 0 == uiType && !(iMsgBox & MB_ICONMASK))
		{
			// set icon if none was provided
			uiType = MB_ICONINFORMATION;
		}
		// fall through
	case imtUser           >> imtShiftCount: // request message
	{
		if (m_fNoModalDialogs && !iForceQuietMessage)
			return imsNone;

		const IMsiString& riString = riRecord.FormatText(fFalse);
		unsigned int uiBreakStartTime = GetTickCount();
		imsEnum ims = (imsEnum)MsiMessageBox(0, riString.GetString(), 0, uiType | iMsgBox | MB_TASKMODAL, GetPackageCodepage(), GetPackageLanguage());
		m_uiStartTime += GetTickCount() - uiBreakStartTime;
		riString.Release();
		return ims;
	}
	case imtFilesInUse >> imtShiftCount:
	{
		if (m_fNoModalDialogs)
			return imsNone;

		imsEnum ims = FilesInUseDialog(&riRecord);
		switch (ims)
		{
			case imsRetry:  return imsRetry;
			case imsIgnore: return imsIgnore;
			default: return imsCancel;  // imsNone if dialog failed in creation
		}
	}

	case imtActionStart >> imtShiftCount: // start of action, field[1] is action name
	{
		return SetProgressData(imtActionStart >> imtShiftCount, g_szBannerText, true);
		/*imsEnum imsReturn;
		imsReturn = SetProgressData(imtActionStart >> imtShiftCount, riRecord.GetString(2));
		if (imsReturn != imsOk)
			return imsReturn;
		imsReturn = SetProgressData(imtActionData  >> imtShiftCount, 0);
		if (imsReturn != imsOk)
			return imsReturn;
		return SetProgressData(imtProgress    >> imtShiftCount, 0);*/
	}
	case imtActionData  >> imtShiftCount: // data associated with individual action item
	{
		if (riRecord.IsNull(0))
			return imsNone;
		return SetProgressData(0, 0, true);
	}
	case imtProgress    >> imtShiftCount: // progress gauge info, field[1] is units of 1/1024
	{
		using namespace ProgressData;
		switch (riRecord.GetInteger(imdSubclass))
		{
		case iscProgressAddition:
			return imsOk;
		case iMsiNullInteger:  // no progess, used to keep UI alive when running in other thread/process
			return SetProgressData(0, 0, true);
		case iscMasterReset: // Master reset
		{
			m_iProgressTotal = riRecord.GetInteger(imdProgressTotal);
			m_ipdDirection = (ipdEnum) riRecord.GetInteger(imdDirection);
			m_iProgress = m_ipdDirection == ipdForward ? 0 : m_iProgressTotal;
			m_fProgressByData = false;
			m_uiStartTime = 0;
			m_uiLastReportTime = 0;

			// If previous event type was ScriptInProgress, finish off the
			// progress bar; otherwise, reset it.
			imsEnum imsReturn;
			if (m_ietEventType == ietScriptInProgress)
				imsReturn = SetProgressGauge(imtProgress >> imtShiftCount, m_iProgressTotal, m_iProgressTotal);
			else
				imsReturn = SetProgressGauge(imtProgress >> imtShiftCount, m_iProgress, m_iProgressTotal);

			// If the new event type is ScriptInProgress, throw up the
			// ScriptInProgress information string
			m_ietEventType = (ietEnum) riRecord.GetInteger(imdEventType);
			if (m_ietEventType == ietScriptInProgress)
				imsReturn = SetScriptInProgress(fTrue);

			return imsReturn;
		}
		case iscActionInfo: // Action init
			m_iPerTick = riRecord.GetInteger(imdPerTick);
			m_fProgressByData = riRecord.GetInteger(imdType) != 0;
			return imsOk;
		case iscProgressReport: // Reporting actual progress
			{
				if (m_iProgressTotal == 0)
					return imsOk;

				if (m_uiStartTime == 0)
				{
					m_uiStartTime = GetTickCount();
					m_uiLastReportTime = m_uiStartTime;
					imsEnum imsReturn = imsOk;
					if (m_ietEventType != ietScriptInProgress)
						imsReturn = SetScriptInProgress(fFalse);
					return imsReturn;
				}
				int iSign = m_ipdDirection == ipdForward ? 1 : -1;
				if (m_fProgressByData)
					m_iProgress += (m_iPerTick * iSign);
				else
					m_iProgress += riRecord.GetInteger(imdIncrement) * iSign;

				imsEnum imsReturn = SetProgressGauge(imtProgress >> imtShiftCount, m_iProgress, m_iProgressTotal);
				if (imsReturn != imsOk)
					return imsReturn;

				if (m_ietEventType == ietTimeRemaining)
				{
					// Report time remaining (in seconds)
					int iBytesSoFar = m_ipdDirection == ipdForward ? m_iProgress : m_iProgressTotal - m_iProgress;
					int iBytesRemaining = m_iProgressTotal - iBytesSoFar;
					if (iBytesRemaining < 0) iBytesRemaining = 0;
					int iBytesPerSec = MulDiv(iBytesSoFar, 1000, GetTickCount() - m_uiStartTime);
					if (iBytesPerSec == 0) iBytesPerSec = 1;
					int iSecsRemaining = iBytesRemaining / iBytesPerSec;

					int iReportInterval = iSecsRemaining > 60 ? 15000 : 1000;
					if (iBytesSoFar > 0 && (GetTickCount() - m_uiLastReportTime > iReportInterval))
					{
						m_uiLastReportTime = GetTickCount();
						AssertNonZero(riRecord.SetInteger(1, iSecsRemaining));
						imsReturn = SetProgressTimeRemaining(riRecord);
					}
				}
				return imsReturn;
			}

		default:
			Assert(0);
			return imsNone;
		}
	}
	case imtResolveSource >> imtShiftCount:
	{
		if (m_fNoModalDialogs)
			return imsNone;

		return PromptUserForSource(riRecord);
	}

	default:
		return imsNone;
	};

}


imsEnum CBasicUI::SetScriptInProgress(Bool fSet)
{
	imsEnum imsReturn = SetProgressData(IDC_BASIC_PROGRESSTIME, fSet ? g_szScriptInProgress : TEXT(""), true);
	HWND hTimeRemaining = WIN::GetDlgItem(m_hProgress, IDC_BASIC_PROGRESSTIME);
	WIN::SendMessage(hTimeRemaining, WM_SETREDRAW, fTrue, 0L);
	AssertNonZero(WIN::InvalidateRect(hTimeRemaining, 0, fTrue));
	return imsReturn;
}


imsEnum CBasicUI::SetProgressTimeRemaining(IMsiRecord& riRecord)
{
	// Used to call CheckDialog here. Since SetProgressTimeRemaining is always
	// called after SetProgressGauge and it checks the dialog, we don't need to here.
	int iSecsRemaining = riRecord.GetInteger(1);
	Assert(iSecsRemaining != iMsiStringBadInteger);
	iSecsRemaining < 60 ? AssertNonZero(riRecord.SetNull(1)) : AssertNonZero(riRecord.SetInteger(1, iSecsRemaining / 60));
	iSecsRemaining >= 60 ? AssertNonZero(riRecord.SetNull(2)) : AssertNonZero(riRecord.SetInteger(2, iSecsRemaining % 60));
	AssertNonZero(riRecord.SetMsiString(0, *MsiString(*g_szTimeRemaining)));  // string reference for efficiency here
	MsiString strFormatted;
	if(!riRecord.IsNull(0))
	{
		strFormatted = riRecord.FormatText(fFalse);
		riRecord.SetNull(0);  // insure that string reference is not passed back to caller
	}
	imsEnum imsStatus = SetProgressData(IDC_BASIC_PROGRESSTIME, strFormatted, true);
	if (imsStatus != imsOk)
		return imsStatus; // could return imsError or imsCancel
	HWND hTimeRemaining = WIN::GetDlgItem(m_hProgress, IDC_BASIC_PROGRESSTIME);
	WIN::SendMessage(hTimeRemaining, WM_SETREDRAW, fTrue, 0L);
	AssertNonZero(WIN::InvalidateRect(hTimeRemaining, 0, fTrue));
	return imsOk;
}

INT_PTR CALLBACK ProgressProc(HWND hDlg, unsigned int msg, WPARAM wParam, LPARAM /*lParam*/)
{
	if (msg == WM_INITDIALOG)
	{
		//lParam;
		return fTrue;
	}
	else if (msg == WM_COMMAND && wParam == IDCANCEL)
	{
		HWND hButton = WIN::GetDlgItem(hDlg, IDC_BASIC_CANCEL);
		if ( hButton && WIN::IsWindowVisible(hButton) &&
			  WIN::IsWindowEnabled(hButton) )
			g_BasicUI.SetUserCancel(true);
		return fTrue;
	}
	else if (msg == WM_SETCURSOR)
	{
		// Always display WAIT cursor if mouse not over Cancel button
		if ((HWND) wParam != WIN::GetDlgItem(hDlg, IDC_BASIC_CANCEL))
		{
			SetCursor(LoadCursor(0, MAKEINTRESOURCE(IDC_WAIT)));
			return fTrue;
		}
	}
	else if (msg == WM_CLOSE)
	{
	}

	return fFalse;
}

extern void MoveButton(HWND hDlg, HWND hBtn, LONG x, LONG y);  // in msiutil.cpp, used by MsiMessageBox

bool CBasicUI::Mirrored(UINT uiCodepage)
{
	// mirrored if BiDi and on Windows 2000 or greater
	if ((uiCodepage == 1256 || uiCodepage == 1255) && MinimumPlatformWindows2000())
		return true;
	return false;
}

bool CBasicUI::SetCancelButtonText()
{
	if (m_hProgress == 0)
		return true;   // not initialized yet, can this happen?
	ICHAR rgchBuf[40];
	UINT iCodepage = MsiLoadString(g_hInstance, IDS_CANCEL, rgchBuf, sizeof(rgchBuf)/sizeof(ICHAR), GetPackageLanguage());
	if (iCodepage == 0)
		return false;
	if (iCodepage != m_iButtonCodepage)  // codepage changed, need to create new font
	{
		MsiDestroyFont(m_hButtonFont);
		m_hButtonFont = MsiCreateFont(iCodepage);
		m_iButtonCodepage = iCodepage;

		bool fBiDi = (iCodepage == 1256 || iCodepage == 1255);
		bool fMirrored = Mirrored(iCodepage);

		// if our mirrored state is changing, then we need to re-create the dialog (note, this is only applicable on Windows 2000 and greater)
		if (fMirrored != m_fMirrored)
		{
			HWND hwndOld = m_hProgress;
			WIN::DestroyWindow(hwndOld);
			if (!CreateProgressDialog(fMirrored ? IDD_PROGRESSMIRRORED : IDD_PROGRESS))
				return false;
			if (m_fWindowVisible)
			{
				m_fWindowVisible = false; // turn off temporarily
				m_fCaptionChanged = true; // new dialog created, so must reload caption
				if (!CheckDialog())
					return false;
			}

			// RTL reading order is handled automatically by mirroring, so we shouldn't have to change it
			m_fMirrored = fMirrored;
		}
		else if (!fMirrored && fBiDi != m_fBiDi)  // right-to-left change
		{
			HWND  hwndButton = GetDlgItem(m_hProgress, IDC_BASIC_CANCEL);
			HWND  hwndGauge  = GetDlgItem(m_hProgress, IDC_BASIC_PROGRESSBAR);
			RECT  rcButton;
			RECT  rcGauge;
			WIN::GetWindowRect(hwndButton, &rcButton);
			WIN::GetWindowRect(hwndGauge,  &rcGauge);
			MoveButton(m_hProgress, hwndButton, fBiDi ? rcGauge.left : rcButton.left + rcGauge.right - rcButton.right, rcButton.top);
			MoveButton(m_hProgress, hwndGauge,  fBiDi ? rcGauge.left + rcButton.right - rcGauge.right : rcButton.left, rcGauge.top);
			LONG iExStyle = WIN::GetWindowLong(hwndButton, GWL_EXSTYLE);
			WIN::SetWindowLong(hwndButton, GWL_EXSTYLE, iExStyle ^ WS_EX_RTLREADING);
			m_fBiDi = fBiDi;
		}
	}
	if (m_hButtonFont)
		WIN::SendDlgItemMessage(m_hProgress, IDC_BASIC_CANCEL, WM_SETFONT, (WPARAM)m_hButtonFont, MAKELPARAM(TRUE, 0));
	AssertNonZero(WIN::SetDlgItemText(m_hProgress, IDC_BASIC_CANCEL, rgchBuf));

	// update banner text w/ new text for new language
	ICHAR rgchBannerText[cchMaxCaption + 1];
	AssertNonZero(MsiLoadString(g_hInstance, m_uiBannerText, rgchBannerText, sizeof(rgchBannerText)/sizeof(ICHAR), GetPackageLanguage()));
	if(!m_fQuiet && !m_fHideDialog)
		SetProgressData(imtActionStart >> imtShiftCount, rgchBannerText, m_fWindowVisible);

	return true;
}

bool GetScreenCenterCoord(HWND hDlg, int& iDialogLeft, int& iDialogTop,
								  int& iDialogWidth, int& iDialogHeight)
{
	RECT rcDialog;
	if ( !WIN::GetWindowRect(hDlg, &rcDialog) )
		return false;

	RECT rcScreen;
	if ( !WIN::SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, 0) )
	{
		rcScreen.left = 0;
		rcScreen.top = 0;
		rcScreen.right = WIN::GetSystemMetrics(SM_CXSCREEN);
		rcScreen.bottom = WIN::GetSystemMetrics(SM_CYSCREEN);
	}
	iDialogWidth = rcDialog.right - rcDialog.left;
	iDialogHeight = rcDialog.bottom - rcDialog.top;
	iDialogLeft = rcScreen.left + (rcScreen.right - rcScreen.left - iDialogWidth)/2;
	iDialogTop = rcScreen.top + (rcScreen.bottom - rcScreen.top - iDialogHeight)/2;

	return true;
}

bool CBasicUI::CreateProgressDialog(int idDlg)
{
	int iDialogLeft, iDialogTop;
	int iDialogWidth, iDialogHeight;

	if (IDD_PROGRESSMIRRORED == idDlg)
		m_fMirrored = true;

	m_hProgress = WIN::CreateDialogParam(g_hInstance, MAKEINTRESOURCE(idDlg), m_hwndParent, ProgressProc, (LPARAM)this);
	if (!m_hProgress)
		return false;

	AssertNonZero(::GetScreenCenterCoord(m_hProgress, iDialogLeft, iDialogTop, iDialogWidth, iDialogHeight));
	AssertNonZero(WIN::MoveWindow(m_hProgress, iDialogLeft, iDialogTop, iDialogWidth, iDialogHeight, fTrue));
	WIN::SetFocus(WIN::GetDlgItem(m_hProgress, IDC_BASIC_PROGRESSBAR));
	WIN::ShowWindow(WIN::GetDlgItem(m_hProgress, IDC_BASIC_CANCEL), m_fCancelVisible ? SW_SHOW : SW_HIDE);
	WIN::SetForegroundWindow(m_hProgress);

	HICON hIcon = (HICON) WIN::LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_INSTALLER));
	if (hIcon)
		WIN::SendMessage(m_hProgress, WM_SETICON, ICON_BIG, (LPARAM)hIcon);

	return true;
}

bool CBasicUI::CheckDialog()
{
	int iDialogLeft, iDialogTop;
	int iDialogWidth, iDialogHeight;

	if (!m_hProgress)
	{
		int idDlg = IDD_PROGRESS;

		// need to determine if we should create the mirrored progress dialog -- only applicable with BiDi languages on
		// Windows2000 or greater systems
		UINT uiCodepage = GetPackageCodepage();
		if (0 == uiCodepage)
		{
			// neutral, so use user's
			uiCodepage = MsiGetCodepage((WORD)MsiGetDefaultUILangID());
		}

		if (Mirrored(uiCodepage))
		{
			// create mirrored progress dialog (only on Win2K and greater)
			idDlg = IDD_PROGRESSMIRRORED;
		}

		if (!CreateProgressDialog(idDlg))
			return false;

		AssertNonZero(SetCancelButtonText());
	}

	if (!m_fWindowVisible && !m_fQuiet && !m_fHideDialog &&
				::GetScreenCenterCoord(m_hProgress, iDialogLeft, iDialogTop, iDialogWidth, iDialogHeight))
	{
		AssertNonZero(WIN::SetWindowPos(m_hProgress, HWND_TOP,
												  iDialogLeft, iDialogTop, iDialogWidth, iDialogHeight,
												  SWP_SHOWWINDOW));
		m_fWindowVisible = true;
	}

	if (m_fCaptionChanged && *m_szCaption)
	{
		m_fCaptionChanged = false;
		WIN::SetWindowText(m_hProgress, m_szCaption);
	}

	WIN::ShowWindow(WIN::GetDlgItem(m_hProgress, IDC_BASIC_CANCEL), m_fCancelVisible ? SW_SHOW : SW_HIDE);
	return true;
}

imsEnum CBasicUI::SetProgressData(int iControl, const ICHAR* szData, bool fCheckDialog)
{
	if (iControl && (WIN::GetDlgItem(m_hProgress, iControl) || !m_hProgress))
	{
		Assert(szData);
		if (fCheckDialog && !CheckDialog())
			return imsError;

		ICHAR rgchCurrText[cchMaxCaption + 1];
		WIN::GetDlgItemText(m_hProgress, iControl,rgchCurrText,cchMaxCaption);
		if (IStrComp(szData, rgchCurrText) != 0)
		{
			int iTextCodepage = m_iPackageCodepage ? m_iPackageCodepage : ::MsiGetCodepage(m_iPackageLanguage);
			if (iTextCodepage != m_iTextCodepage)  // codepage changed, need to create new font
			{
				MsiDestroyFont(m_hTextFont);
				m_hTextFont = MsiCreateFont(iTextCodepage);
				m_iTextCodepage = iTextCodepage;
			}
			HWND hwndText = GetDlgItem(m_hProgress, iControl);
			bool fBiDi = (m_iTextCodepage == 1256 || m_iTextCodepage == 1255);
			LONG iStyle   = WIN::GetWindowLong(hwndText, GWL_STYLE);
			LONG iExStyle = WIN::GetWindowLong(hwndText, GWL_EXSTYLE);
			if (fBiDi)
			{
				// on mirrored dialog, left justification is correct because everything has already been adjusted to display properly
				if (!m_fMirrored)
				{
					iStyle |= SS_RIGHT;
					iExStyle |= (WS_EX_RIGHT | WS_EX_RTLREADING);
				}
				// mirroring is a dialog change, so we don't have to worry about text switching
			}
			else
			{
				if (!m_fMirrored)
				{
					iStyle &= ~SS_RIGHT;
					iExStyle &= ~(WS_EX_RIGHT | WS_EX_RTLREADING);
				}
				// mirroring is a dialog change, so we don't have to worry about text switching
			}
			WIN::SetWindowLong(hwndText, GWL_STYLE, iStyle);
			WIN::SetWindowLong(hwndText, GWL_EXSTYLE, iExStyle);
			if (m_hTextFont)
				SendDlgItemMessage(m_hProgress, iControl, WM_SETFONT, (WPARAM)m_hTextFont, MAKELPARAM(TRUE, 0));
			AssertNonZero(WIN::SetDlgItemText(m_hProgress, iControl, szData));
		}
	}
	MSG msg;
	while (WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		if (!WIN::IsDialogMessage(m_hProgress, &msg))
		{
			WIN::TranslateMessage(&msg);
			WIN::DispatchMessage(&msg);
		}
	}
	if (m_fUserCancel)
	{
		return imsCancel;
	}
	return imsOk;
}

imsEnum CBasicUI::SetProgressGauge(int iControl, int cSoFar, int cTotal)
{
	if (!CheckDialog())
		return imsError;
	HWND hWnd = WIN::GetDlgItem(m_hProgress, iControl);
	WIN::ShowWindow(hWnd, SW_SHOW);
	int cDiff = cSoFar - m_cSoFarPrev;
	if (cDiff < 0)
		cDiff = -cDiff;

	// Only change the progress gauge if we've actually made some visible progress
	if (m_cTotalPrev != cTotal || cDiff > cTotal/0x100)
	{
		m_cTotalPrev = cTotal;
		m_cSoFarPrev = cSoFar;
		while (cTotal > 0xFFFF)  // the control can take at most a 16 bit integer, so we have to scale the values
		{
			// We can afford to scale down by a bunch because we assume that the granularity
			// of the control is smaller that 0xFFF. We could probably be more aggressive here
			cTotal >>= 8;
			cSoFar >>= 8;
		}

		WIN::SendMessage(hWnd, PBM_SETRANGE, 0, MAKELPARAM(0, cTotal));
		WIN::SendMessage(hWnd, PBM_SETPOS, cSoFar, 0);
	}
	MSG msg;
	while (WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
	{
		if (!WIN::IsDialogMessage(m_hProgress, &msg))
		{
			WIN::TranslateMessage(&msg);
			WIN::DispatchMessage(&msg);
		}
	}
	if (m_fUserCancel)
	{
		return imsCancel;
	}
	return imsOk;
}

//____________________________________________________________________________
//
// CFilesInUseDialog implementation
//____________________________________________________________________________

imsEnum CBasicUI::FilesInUseDialog(IMsiRecord* piRecord)
{
	if (piRecord == 0)
		return imsNone;
	CFilesInUseDialog msgbox(piRecord->GetString(0), m_szCaption, *piRecord);

	// must use mirrored dialog on Win2K or above for Arabic and Hebrew languages
	UINT uiCodepage = g_BasicUI.GetPackageCodepage();
	if (Mirrored(uiCodepage))
		return (imsEnum)msgbox.Execute(0, IDD_FILESINUSEMIRRORED, 0);
	return (imsEnum)msgbox.Execute(0, IDD_FILESINUSE, 0);
}

CFilesInUseDialog::CFilesInUseDialog(const ICHAR* szMessage, const ICHAR* szCaption, IMsiRecord& riFileList)
 : CMsiMessageBox(szMessage, szCaption, 0, 1, IDCANCEL, IDRETRY, IDIGNORE, g_BasicUI.GetPackageCodepage(), g_BasicUI.GetPackageLanguage())
 , m_riFileList(riFileList), m_hfontList(0)
{
}

CFilesInUseDialog::~CFilesInUseDialog()
{
	MsiDestroyFont(m_hfontList);
}

bool CFilesInUseDialog::InitSpecial()
{
	// We need to display file names as they would appear to the user with system tools
	UINT iListCodepage = MsiGetSystemDataCodepage();  // need to display paths correctly
	HFONT hfontList = m_hfontText;   // optimize if same codepage as text from database
	if (iListCodepage != m_iCodepage) // database codepage different that text data
		hfontList = m_hfontList = MsiCreateFont(iListCodepage);
	SetControlText(IDC_FILESINUSELIST, hfontList, (const ICHAR*)0);

	HWND hWndListBox = WIN::GetDlgItem(m_hDlg, IDC_FILESINUSELIST);
	Assert(hWndListBox);
	HDC hDCListBox = WIN::GetDC(hWndListBox);
	Assert(hDCListBox);
	TEXTMETRIC tm;
	memset(&tm, 0, sizeof(tm));
	AssertNonZero(WIN::GetTextMetrics(hDCListBox, (LPTEXTMETRIC)&tm));
	HFONT hFontOld = (HFONT)WIN::SelectObject(hDCListBox, hfontList);
	Assert(hFontOld);
	WIN::SendMessage(hWndListBox, WM_SETREDRAW, false, 0L);
	WPARAM dwMaxExtent = 0;

	int iFieldIndex = 1;
	while (!m_riFileList.IsNull(iFieldIndex))
	{
		MsiString strProcessName(m_riFileList.GetMsiString(iFieldIndex++));  //!! not used?
		MsiString strProcessTitle(m_riFileList.GetMsiString(iFieldIndex++));

		// catch duplicate window titles - most likely these are the same window
		if(LB_ERR == WIN::SendDlgItemMessage(m_hDlg, IDC_FILESINUSELIST, LB_FINDSTRINGEXACT, 0, (LPARAM) (const ICHAR*) strProcessTitle))
		{
			WIN::SendDlgItemMessage(m_hDlg, IDC_FILESINUSELIST, LB_ADDSTRING, 0, (LPARAM) (const ICHAR*) strProcessTitle);
			SIZE size;
			size.cx = size.cy = 0;
			AssertNonZero(WIN::GetTextExtentPoint32(hDCListBox, (const ICHAR*)strProcessTitle,
																 strProcessTitle.TextSize(), &size));
			if ( size.cx + tm.tmAveCharWidth > dwMaxExtent )
				dwMaxExtent = size.cx + tm.tmAveCharWidth;
		}
	}
	WIN::SendMessage(hWndListBox, LB_SETHORIZONTALEXTENT, dwMaxExtent, 0L);
	WIN::SelectObject(hDCListBox, hFontOld);
	WIN::ReleaseDC(hWndListBox, hDCListBox);
	WIN::SendMessage(hWndListBox, WM_SETREDRAW, true, 0L);
	AssertNonZero(WIN::InvalidateRect(hWndListBox, 0, true));

	AdjustButtons();  // to allow switching of buttons for BiDi
	return true;
}

//____________________________________________________________________________


//
// Add and remove items from the action thread list
//
void InsertInCustomActionList(CActionThreadData* pData)
{
	EnterCriticalSection(&vcsHeap);

	pData->m_pNext = g_pActionThreadHead;
	g_pActionThreadHead = pData;

	LeaveCriticalSection(&vcsHeap);
}

void RemoveFromCustomActionList(CActionThreadData* pData)
{
	Debug(bool fFound = false);

	EnterCriticalSection(&vcsHeap);

	CActionThreadData** ppList = &g_pActionThreadHead;

	for ( ; *ppList; ppList = &(*ppList)->m_pNext)
	{
		if (*ppList == pData)
		{
			*ppList = pData->m_pNext;  // unlink from chain
			Debug(fFound = true);
			break;
		}
	}

	LeaveCriticalSection(&vcsHeap);

	Assert(fFound);
}

bool FIsCustomActionThread(DWORD dwThreadId)
{
	bool fFound = false;

	EnterCriticalSection(&vcsHeap);

	CActionThreadData* pList = g_pActionThreadHead;

	for ( ; pList; pList = pList->m_pNext)
	{
		if (pList->m_dwThreadId == dwThreadId)
		{
			fFound = true;
			break;
		}
	}

	LeaveCriticalSection(&vcsHeap);

	return fFound;

}

void GetWindowTitles(IMsiRecord *pInRecord, IMsiRecord **ppOutRecord)
{
	if(!pInRecord || !ppOutRecord)
		return;

	*ppOutRecord = NULL;

	unsigned int iInSize = pInRecord->GetFieldCount();
	if(!iInSize) 
		return;
	
	PMsiRecord pFilesInUse = NULL;
	CTempBuffer<ICHAR,1> szTitle(256); // enough for  window title
	const ICHAR *szPtr = NULL;

	{
	IMsiServices* piServices = ENG::LoadServices();
	if(!piServices)
		return;
	pFilesInUse = &piServices->CreateRecord(iInSize);
	ENG::FreeServices();	
	}

	if(!pFilesInUse)
		return;
	
	// Copy the description
	pFilesInUse->SetMsiString(0, *MsiString(pInRecord->GetMsiString(0)));	

	int j = 1;
	for(unsigned int i=1;  i < iInSize; i+=2)	// skip first record
	{
		DWORD iPid = pInRecord->GetInteger(i+1);
		if(!iPid || iPid == iMsiNullInteger)
		{
			szPtr = pInRecord->GetString(i+1);
			if(!szPtr)
			{
				DEBUGMSG(TEXT("GetWindowTitle: FilesInUse record has 0 for ProcessID - Unexpected"));
				continue;
			}
		}
		
		if(!szPtr)
		{
			HWND hWnd = CDetectApps::GetMainWindow(iPid);
			if(hWnd == 0)
			{
				DEBUGMSGV1(TEXT("file In Use: -%s- Window could not be found."), pInRecord->GetString(i));
				continue;
			}
	
			int iLen = GetWindowText(hWnd, szTitle, 255);
			if(!iLen)
			{
				DEBUGMSGV1(TEXT("file In Use: -%s- Window has no title."), pInRecord->GetString(i));
				continue;
			}
			szTitle[iLen] = 0;
			szPtr = szTitle;
		}
			
		Assert(szPtr);
		pFilesInUse->SetMsiString(j++, *MsiString(pInRecord->GetMsiString(i)));	
		pFilesInUse->SetString(j++, szPtr);	
	} 

	if(j > 1)	 // Atleast one window  with title is found
	{
		while(j < iInSize)
		{
			pFilesInUse->SetString(j++, TEXT(""));	// clear up the columns
			pFilesInUse->SetString(j++, TEXT(""));	
		}
		*ppOutRecord = pFilesInUse;
		(*ppOutRecord)->AddRef();
	}	

	
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\autoapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       autoapi.cpp
//
//--------------------------------------------------------------------------

#include "precomp.h"  // GUID definitions

#define TYPELIB_MAJOR_VERSION 1  // released version, not rmj
#define TYPELIB_MINOR_VERSION 0  // released version, not rmm

# include <commctrl.h>
# include <shlobj.h>
  class IMsiServices;
# include "imemory.h"
# define IMSIMALLOC_DEFINED
#include <olectl.h>   // SELFREG_E_*
#include <tchar.h>
#include "msiquery.h"
#include "version.h"
#include "AutoApi.h"  // dispatch IDs, help context IDs
#include "_msinst.h"  // policy defs
#include "_camgr.h"   // custom action manager for remote call validation
#include "msip.h"
#undef  DEFINE_GUID  // allow selective GUID initialization
#define DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
		const GUID name = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#include <objsafe.h>
#include "_autoapi.h"
#define OLE
#define W32
#define MSI
#define INITGUID
#define LATEBIND_TYPEDEF
#include "latebind.h"
#define LATEBIND_VECTREF
#include "latebind.h"
#include "_msiutil.h"
bool GetTestFlag(int chTest);

// non-public API functions
extern "C"
{
UINT __stdcall MsiGetFeatureParentW(LPCWSTR szProduct, LPCWSTR szFeature, LPWSTR lpParentBuf);
UINT __stdcall MsiGetQualifierDescriptionW(LPCWSTR szComponent, LPCWSTR szQualifier, LPWSTR lpDescription, DWORD *pcchDescription);
}

const GUID IID_IMsiApiInstall     = MSGUID(iidMsiApiInstall);
#ifdef DEBUG
const GUID IID_IMsiApiInstallDebug= MSGUID(iidMsiApiInstallDebug);
#endif
const GUID IID_IMsiSystemAccess   = MSGUID(iidMsiSystemAccess);
const GUID IID_IMsiApiTypeLib     = MSGUID(iidMsiApiTypeLib);
const GUID IID_IMsiApiEngine      = MSGUID(iidMsiApiEngine);
const GUID IID_IMsiApiUIPreview   = MSGUID(iidMsiApiUIPreview);
const GUID IID_IMsiApiDatabase    = MSGUID(iidMsiApiDatabase);
const GUID IID_IMsiApiView        = MSGUID(iidMsiApiView);
const GUID IID_IMsiApiRecord      = MSGUID(iidMsiApiRecord);
const GUID IID_IMsiApiSummaryInfo = MSGUID(iidMsiApiSummaryInfo);
const GUID IID_IMsiApiFeatureInfo = MSGUID(iidMsiApiFeatureInfo);
const GUID IID_IMsiApiCollection  = MSGUID(iidMsiApiCollection);
const GUID IID_IMsiRecordCollection = MSGUID(iidMsiRecordCollection);
const GUID IID_IEnumVARIANT       = MSGUID(iidEnumVARIANT);
#define ERROR_SOURCE_NAME L"Msi API Error"


//____________________________________________________________________________
//
// Global data
//____________________________________________________________________________

extern HINSTANCE g_hInstance;
extern long g_cInstances;
extern bool g_fWin9X;
extern bool g_fWinNT64;

//____________________________________________________________________________
//
// CAutoArgs definition, access to automation variant arguments
// operator[] returns CVariant& argument 1 to n, 0 for property value
//____________________________________________________________________________

inline Bool CAutoArgs::PropertySet()
{
	return (m_wFlags & DISPATCH_PROPERTYPUT) ? fTrue : fFalse;
}

inline unsigned int CAutoArgs::GetLastArg()
{
	return m_iLastArg;
}

inline CVariant* CAutoArgs::ResultVariant()
{
	return m_pvResult;
}

// sole function is to force template instantiation for VC4.0, never called
inline DISPID GetEntryDispId(DispatchEntryBase* pTable)
{
	return pTable->dispid;
}

//____________________________________________________________________________
//
// External COM access class for system use
//____________________________________________________________________________

class IMsiSystemAccess : public IUnknown
{
 public:
	virtual UINT __stdcall ProvideComponentFromDescriptor(
				const OLECHAR* szDescriptor,     // product,feature,component info
				OLECHAR*       pchPathBuf,       // returned path, NULL if not desired
				DWORD*         pcchPathBuf,      // in/out buffer character count
				DWORD*         pcchArgsOffset)=0;// returned offset of args in descriptor
	virtual UINT __stdcall ProvideComponentFromDescriptorA(
				const char*    szDescriptor,     // product,feature,component info
				char*          pchPathBuf,       // returned path, NULL if not desired
				DWORD*         pcchPathBuf,      // in/out buffer character count
				DWORD*         pcchArgsOffset)=0;// returned offset of args in descriptor
};

class CMsiSystemAccess : public IMsiSystemAccess  // class private to this module
{
 public:   // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	UINT __stdcall ProvideComponentFromDescriptor(
				const OLECHAR* szDescriptor,     // product,feature,component info
				OLECHAR*       pchPathBuf,       // returned path, NULL if not desired
				DWORD*         pcchPathBuf,      // in/out buffer character count
				DWORD*         pcchArgsOffset);  // returned offset of args in descriptor
	UINT __stdcall ProvideComponentFromDescriptorA(
				const char*    szDescriptor,     // product,feature,component info
				char*          pchPathBuf,       // returned path, NULL if not desired
				DWORD*         pcchPathBuf,      // in/out buffer character count
				DWORD*         pcchArgsOffset);  // returned offset of args in descriptor
 public:  // constructor
	CMsiSystemAccess() : m_iRefCnt(1)  { g_cInstances++; }
  ~CMsiSystemAccess()                 { g_cInstances--; }
	void *operator new(size_t cb)   { return W32::GlobalAlloc(GMEM_FIXED, cb); }  // keep local cache
	void operator delete(void * pv) { W32::GlobalFree(pv); }
 protected:
	int         m_iRefCnt;
};

class CInstallerFactory : public IClassFactory
{
 public: // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT       __stdcall CreateInstance(IUnknown* pUnkOuter, const IID& riid,
														void** ppvObject);
	HRESULT       __stdcall LockServer(BOOL fLock);
};
CInstallerFactory g_InstallerFactory;

//____________________________________________________________________________
//
// External COM access class implementation
//____________________________________________________________________________

HRESULT CInstallerFactory::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IClassFactory)
		return (*ppvObj = this, NOERROR);
	else
		return (*ppvObj = 0, E_NOINTERFACE);
}
unsigned long CInstallerFactory::AddRef()
{
	return 1;
}
unsigned long CInstallerFactory::Release()
{
	return 1;
}
HRESULT CInstallerFactory::CreateInstance(IUnknown* pUnkOuter, const IID& riid,
													void** ppvObject)
{
	if (pUnkOuter)
		return CLASS_E_NOAGGREGATION;
	if (!(riid == IID_IUnknown || riid == IID_IMsiSystemAccess))
		return E_NOINTERFACE;
	if (!ppvObject)
		return E_INVALIDARG;
	*ppvObject = (void*)new CMsiSystemAccess();
	if (!(*ppvObject))
		return E_OUTOFMEMORY;
	return NOERROR;
}
HRESULT CInstallerFactory::LockServer(BOOL fLock)
{
   if (fLock)
	  g_cInstances++;
   else if (g_cInstances)
		g_cInstances--;
	return NOERROR;
}

HRESULT CMsiSystemAccess::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IMsiSystemAccess)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	else
	{
		*ppvObj = 0;
		return E_NOINTERFACE;
	}
}

unsigned long CMsiSystemAccess::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiSystemAccess::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;              // need to delete before MsiCloseHandle
	return 0;
}

UINT CMsiSystemAccess::ProvideComponentFromDescriptor(
				const OLECHAR* szDescriptor,     // product,feature,component info
				OLECHAR*       pchPathBuf,       // returned path, NULL if not desired
				DWORD*         pcchPathBuf,      // in/out buffer character count
				DWORD*         pcchArgsOffset)   // returned offset of args in descriptor
{
	return MsiProvideComponentFromDescriptorW(szDescriptor, pchPathBuf, pcchPathBuf, pcchArgsOffset);
}

UINT CMsiSystemAccess::ProvideComponentFromDescriptorA(
				const char*    szDescriptor,     // product,feature,component info
				char*          pchPathBuf,       // returned path, NULL if not desired
				DWORD*         pcchPathBuf,      // in/out buffer character count
				DWORD*         pcchArgsOffset)   // returned offset of args in descriptor
{
	return MsiProvideComponentFromDescriptorA(szDescriptor, pchPathBuf, pcchPathBuf, pcchArgsOffset);
}

//____________________________________________________________________________
//
// CVariant inline function definitions
//____________________________________________________________________________

inline int CVariant::GetType()
{
	return vt;
}

inline Bool CVariant::IsRef()
{
	return (vt & VT_BYREF) ? fTrue : fFalse;
}

inline Bool CVariant::IsNull()
{
	return (vt & 0xFF) == VT_NULL ? fTrue : fFalse;
}

inline Bool CVariant::IsString()
{
	return (vt & 0xFF) == VT_BSTR ? fTrue : fFalse;
}

inline Bool CVariant::IsNumeric()
{
	switch (vt & 0xFF)
	{
	case VT_I2: case VT_I4: case VT_R8: case VT_R4: return fTrue;
	default: return fFalse;
	}
}

//____________________________________________________________________________
//
// Class factory definition, factory used temporarily to bootstrap first handle
//____________________________________________________________________________

class CAutoApiFactory : public IClassFactory
{
 public: // implemented virtual functions
	HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long __stdcall AddRef();
	unsigned long __stdcall Release();
	HRESULT       __stdcall CreateInstance(IUnknown* pUnkOuter, const IID& riid,
														void** ppvObject);
	HRESULT       __stdcall LockServer(BOOL fLock);
};
CAutoApiFactory g_AutoInstallFactory;

//____________________________________________________________________________
//
// CAutoArgs implementation
//____________________________________________________________________________

CAutoArgs::CAutoArgs(DISPPARAMS* pdispparms, VARIANT* pvarResult, WORD wFlags)
{
	m_cArgs = pdispparms->cArgs;
	m_cNamed = pdispparms->cNamedArgs;
	m_rgiNamed = pdispparms->rgdispidNamedArgs;
	m_rgvArgs = (CVariant*)pdispparms->rgvarg;
	m_pvResult= (CVariant*)pvarResult;
	m_wFlags = wFlags;
	if (pvarResult != 0 && pvarResult->vt != VT_EMPTY)
		OLEAUT32::VariantClear(pvarResult);
}

CVariant g_varEmpty;

CVariant& CAutoArgs::operator [](unsigned int iArg)
{
//  if (iArg > m_cArgs) // || (iArg ==0 && (wFlags & DISPATCH_PROPERTYPUT))
//      throw axMissingArg;
	int ivarArgs = m_cArgs - iArg;            // get index if unnamed parameter
	if (iArg == 0 || iArg > m_cArgs-m_cNamed) // SET value or named or error
	{
		iArg = iArg==0 ? DISPID_PROPERTYPUT : iArg - 1;  // values are 0-based
		for (ivarArgs = m_cNamed; --ivarArgs >= 0; )
			if (m_rgiNamed[ivarArgs] == iArg)
				break;
	}
	if (ivarArgs < 0)  // loop termination above without match
	{
		g_varEmpty.vt = VT_EMPTY;
		return g_varEmpty;
	}
	m_iLastArg = ivarArgs;
	CVariant* pvarRet = &m_rgvArgs[ivarArgs];
	if (pvarRet->GetType() == VT_VARIANT+VT_BYREF)
		pvarRet = (CVariant*)pvarRet->pvarVal;
	return *pvarRet;
}

Bool CAutoArgs::Present(unsigned int iArg)
{
	int ivarArgs = m_cArgs - iArg;            // get index if unnamed parameter
	if (iArg == 0 || iArg > m_cArgs-m_cNamed) // SET value or named or error
	{
		for (ivarArgs = m_cNamed; --ivarArgs >= 0; )
			if (m_rgiNamed[ivarArgs] == iArg-1)
				break;
	}
	if (ivarArgs < 0)
		return fFalse;
	CVariant& rvar = m_rgvArgs[ivarArgs];
	if (rvar.GetType() == VT_EMPTY)
		return fFalse;
	if (rvar.GetType() == VT_VARIANT+VT_BYREF && rvar.pvarVal->vt == VT_EMPTY)
		return fFalse;
	return fTrue;
}

//____________________________________________________________________________
//
// CAutoArgs return value assignment functions implementation
//____________________________________________________________________________

inline DISPERR CAutoArgs::Assign(enum varVoid)
{
	if (m_pvResult)
		m_pvResult->vt = VT_EMPTY;
	return S_OK;
}

inline DISPERR CAutoArgs::Assign(unsigned int i) {return Assign(int(i));}
inline DISPERR CAutoArgs::Assign(long i) {return Assign(int(i));}
inline DISPERR CAutoArgs::Assign(unsigned long i) {return Assign(int(i));}
inline DISPERR CAutoArgs::Assign(unsigned short i) {return Assign(int(unsigned int(i)));}

DISPERR CAutoArgs::Assign(int i)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_I4;
		m_pvResult->lVal = i;
	}
	return S_OK;
}

DISPERR CAutoArgs::Assign(Bool f)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_BOOL;
		//m_pvResult->boolVal = short(f == fFalse ? 0 : -1);
		V_BOOL(m_pvResult) = short(f == fFalse ? 0 : -1);
	}
	return S_OK;
}

DISPERR CAutoArgs::Assign(FILETIME& rft)
{
	if (m_pvResult)
	{
		SYSTEMTIME stime;
		m_pvResult->vt = VT_DATE;
		if (!W32::FileTimeToSystemTime(&rft, &stime))
			return DISP_E_TYPEMISMATCH;
		if (!OLEAUT32::SystemTimeToVariantTime(&stime, &m_pvResult->date))
			return DISP_E_TYPEMISMATCH;
	}
	return S_OK;
}

DISPERR CAutoArgs::Assign(DATE& rdate)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_DATE;
		m_pvResult->date = rdate;
	}
	return S_OK;
}

DISPERR CAutoArgs::Assign(short i)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_I2;
		m_pvResult->iVal = i;
	}
	return S_OK;
}

DISPERR CAutoArgs::Assign(IDispatch* pi)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_DISPATCH;
		m_pvResult->pdispVal = pi;  // reference count already bumped
	}
	else if(pi)
		pi->Release();
	return S_OK;
}

DISPERR CAutoArgs::Assign(const char* sz)
{
	if (m_pvResult)
	{
		BSTR bstr = 0;
		if (sz != 0)
		{
			int cchWide = W32::MultiByteToWideChar(CP_ACP, 0, sz, -1, 0, 0);
			bstr = OLEAUT32::SysAllocStringLen(0, cchWide - 1); // null added by API
			W32::MultiByteToWideChar(CP_ACP, 0, sz, -1, bstr, cchWide);
		}
		m_pvResult->vt = VT_BSTR;
		m_pvResult->bstrVal = bstr;
	}
	return S_OK;
}

DISPERR CAutoArgs::Assign(const wchar_t* wsz)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_BSTR;
		m_pvResult->bstrVal = OLEAUT32::SysAllocString(wsz);
	}
	return S_OK;
}

DISPERR CAutoArgs::Assign(IEnumVARIANT& ri)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_UNKNOWN; // no defined type for IEnumVARIANT
		m_pvResult->punkVal = &ri;  // reference count already bumped
	}
	else
		ri.Release();
	return S_OK;
}

DISPERR CAutoArgs::Assign(void* pv)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_I4;
		m_pvResult->lVal = (long)(LONG_PTR)pv;          //!!merced: 4311 ptr to long
	}
	return S_OK;
}

DISPERR CAutoArgs::ReturnBSTR(BSTR bstr)
{
	if (m_pvResult)
	{
		m_pvResult->vt = VT_BSTR;
		m_pvResult->bstrVal = bstr;
	}
	return S_OK;
}

//____________________________________________________________________________
//
// CVariant access functions implementation
//____________________________________________________________________________

DISPERR CVariant::GetInt(int& ri)
{
	switch (vt)
	{
	case VT_R8:              OLEAUT32::VarI4FromR8(dblVal, (long*)&ri); break;
	case VT_R8 | VT_BYREF:   OLEAUT32::VarI4FromR8(*pdblVal, (long*)&ri); break;
	case VT_I4:              ri = lVal;   break;
	case VT_I4 | VT_BYREF:   ri = *plVal; break;
	case VT_I2:              ri = iVal;   break;
	case VT_I2 | VT_BYREF:   ri = *piVal; break;
	case VT_BOOL:            ri = V_BOOL(this) ? TRUE : FALSE; break;
	case VT_BOOL | VT_BYREF: ri = *V_BOOLREF(this) ? TRUE : FALSE; break;
	default: return DISP_E_TYPEMISMATCH;
	}
	return S_OK;
}
inline DISPERR CVariant::GetInt(unsigned int& ri)  {return GetInt((int&)ri);}
inline DISPERR CVariant::GetInt(unsigned long& ri) {return GetInt((int&)ri);}

DISPERR CVariant::GetBool(Bool& rf)
{
	int i;
	HRESULT hr = GetInt(i);
	if (hr == S_OK)
		rf = i ? fTrue : fFalse;
	return hr;
}

DISPERR CVariant::GetString(const wchar_t*& rsz)
{
	if (vt == VT_EMPTY)
		rsz = 0;
	if (vt == VT_BSTR)
		rsz = bstrVal;
	else if (vt == (VT_BYREF | VT_BSTR))
		rsz = *pbstrVal;
	else
		return DISP_E_TYPEMISMATCH;
	return S_OK;
}

DISPERR CVariant::GetDispatch(IDispatch*& rpiDispatch)
{
	if (vt == VT_EMPTY)
		rpiDispatch = 0;
	if (vt == VT_DISPATCH)
		rpiDispatch = pdispVal;
	else if (vt == (VT_BYREF | VT_DISPATCH))
		rpiDispatch = *ppdispVal;
	else
		return DISP_E_TYPEMISMATCH;
	if (rpiDispatch)
		rpiDispatch->AddRef();
	return S_OK;
}

MSIHANDLE CVariant::GetHandle(const IID& riid)
{
	IUnknown* piUnknown = NULL;
	MSIHANDLE hMSI = 0;

	if (vt == VT_DISPATCH || vt == VT_UNKNOWN)
		piUnknown = punkVal;
	else if (vt == (VT_BYREF | VT_DISPATCH) || vt == (VT_BYREF | VT_UNKNOWN))
		piUnknown = *ppunkVal;
	else
		piUnknown = 0;
	if (piUnknown == 0)
		return MSI_NULL_HANDLE;

	// verify that the object is the right type (meaning that it implements
	// the right underlying interface)
	IUnknown* piUnknown2 = NULL;
	if (piUnknown->QueryInterface(riid, (void**)&piUnknown2) != NOERROR)
		return MSI_INVALID_HANDLE;
	piUnknown2->Release();

	// get a dispatch interface pointer
	IDispatch* piDispatch = NULL;
	if (piUnknown->QueryInterface(IID_IDispatch, (void**)&piDispatch) != NOERROR)
		return MSI_INVALID_HANDLE;

	// create the DISPPARMS structure containing the arguments
	VARIANTARG vArg;
	VARIANTARG vRet;
	DISPPARAMS args;
	OLEAUT32::VariantInit(&vRet);
	OLEAUT32::VariantInit(&vArg);	
	args.rgvarg = &vArg;
	args.rgdispidNamedArgs = NULL;
	args.cArgs = 0;
	args.cNamedArgs = 0;

	// determine the dispatch ID for the hidden GetHandle method
	int iDispatchId = 0;
	if (riid == IID_IMsiApiRecord)
	{
		iDispatchId = DISPID_MsiRecord_GetHandle;
	}
	else if (riid == IID_IMsiApiDatabase)
	{
		iDispatchId = DISPID_MsiDatabase_GetHandle;
	}
	else
	{
		AssertSz(0, "Calling GetHandle dispatch on invalid automation object.");
		piDispatch->Release();
		return MSI_INVALID_HANDLE;
	}

	// invoke the call, resulting handle is retrieved from vRet
	HRESULT hRes = piDispatch->Invoke(iDispatchId, IID_NULL, GetUserDefaultLCID(), DISPATCH_PROPERTYGET, &args, &vRet, NULL, NULL);
	hMSI = vRet.lVal;
	piDispatch->Release();

	if (hRes != S_OK)
		return MSI_INVALID_HANDLE;
	return hMSI;
}

//____________________________________________________________________________
//
// CAutoBase implementation, common implementation for IDispatch
//____________________________________________________________________________

CAutoBase::CAutoBase(DispatchEntry<CAutoBase>* pTable, int cDispId, const IID& riid, MSIHANDLE hMsi)
 : m_pTable(pTable)
 , m_cDispId(cDispId)
 , m_hMsi(hMsi)
 , m_riid(riid)
{
	m_iRefCnt = 1;
   g_cInstances++;
}

HRESULT CAutoBase::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IDispatch || riid == m_riid)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	else
	{
		*ppvObj = 0;
		return E_NOINTERFACE;
	}
}

unsigned long CAutoBase::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CAutoBase::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	MSIHANDLE hMsi = m_hMsi;  // save handle before object destroyed
	delete this;              // need to delete before MsiCloseHandle
	g_cInstances--;
	MsiCloseHandle(hMsi);     // may remove memory allocator
	return 0;
}

HRESULT CAutoBase::GetTypeInfoCount(unsigned int *pcTinfo)
{
	*pcTinfo = 0;
	return NOERROR;
}

HRESULT CAutoBase::GetTypeInfo(unsigned int /*itinfo*/, LCID /*lcid*/, ITypeInfo** ppi)
{
	*ppi = 0;
	return E_NOINTERFACE;
}

HRESULT CAutoBase::GetIDsOfNames(const IID&, OLECHAR** rgszNames, unsigned int cNames,
												LCID /*lcid*/, DISPID* rgDispId)
{
	if (cNames == 0 || rgszNames == 0 || rgDispId == 0)
		return E_INVALIDARG;

	unsigned int cErr = cNames;
	DispatchEntryBase* pTable = m_pTable;
	int cEntry = m_cDispId;
	*rgDispId = DISPID_UNKNOWN;
	for (; --cEntry >= 0; pTable++)
	{
		wchar_t* pchName = pTable->sz;
		for (OLECHAR* pchIn = *rgszNames; *pchIn; pchIn++, pchName++)
		{
			if ((*pchIn ^ *pchName) & ~0x20)
				break;
		}
		if (*pchIn == 0 && *pchName < '0')
		{
			*rgDispId++ = pTable->dispid;
			cErr--;
			while(--cNames != 0)
			{
				rgszNames++;
				*rgDispId = DISPID_UNKNOWN;
				wchar_t* pch = pchName;
				for (DISPID dispid = 0; *pch != 0; dispid++)
				{
					if (*pch != 0)
						pch++;
					for (pchIn = *rgszNames; *pchIn; pchIn++, pch++)
					{
						if ((*pchIn ^ *pch) & ~0x20)
							break;
					}
					if (*pchIn == 0 && *pchName < '0')
					{
						*rgDispId++ = dispid;
						cErr--;
						break;
					}
					while (*pch >= '0')
						pch++;
				}
			}
			break;
		}
	}
	return cErr ? DISP_E_UNKNOWNNAME : NOERROR;
}

// external function used to authenticate remote calls 
CMsiCustomActionManager *GetCustomActionManager(IMsiEngine *piEngine);

HRESULT CAutoBase::Invoke(DISPID dispid, const IID&, LCID /*lcid*/, WORD wFlags,
										DISPPARAMS* pdispparams, VARIANT* pvarResult,
										EXCEPINFO* pExceptInfo, unsigned int* /*puArgErr*/)
{
	bool fImpersonate = true;

	// if running in the service, automation calls must be coming from a CA server and thus
	// must be validated against running actions and the PID validated. In the client, the calls
	// could also be coming in-proc, and thus validation can not be performed (since the client
	// is not secure and never trusted anyway, this is not critical). On failure, the invoke call
	// returns DISP_E_UNKNOWNINTERFACE, since there is no standard dispatch error for access denied.
	if (g_scServerContext == scService)
	{
		CMsiCustomActionManager* pCustomActionManager = ::GetCustomActionManager(NULL);
		if (!pCustomActionManager)
			return DISP_E_UNKNOWNINTERFACE;
        
		icacCustomActionContext icacContext = icac32Impersonated;
		if (!pCustomActionManager->FindAndValidateContextFromCallerPID(&icacContext))
			return DISP_E_UNKNOWNINTERFACE;

		fImpersonate = ((icacContext == icac32Impersonated) || (icacContext == icac64Impersonated));
	}

	CImpersonate impersonate(fImpersonate);

	DispatchEntryBase* pTable = m_pTable;
	int cEntry = m_cDispId;
	while (pTable->dispid != dispid)
	{
		pTable++;
		if (--cEntry == 0)
				return DISP_E_MEMBERNOTFOUND;
	}

	if ((wFlags & pTable->aaf) == 0)
		return DISP_E_MEMBERNOTFOUND;

	if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
		pvarResult = 0;

	CAutoArgs Args(pdispparams, pvarResult, wFlags);
	HRESULT hr = (this->*(pTable->pmf))(Args);
	if (hr != S_OK && (hr & 0xFFFF8000) != 0x80020000)  // pass DISP_E error through
	{
		if ((hr & 0x80000000) == 0)
		{
			switch (hr)
			{
			case ERROR_INVALID_HANDLE:       hr = DISP_E_UNKNOWNINTERFACE;
			case ERROR_INVALID_HANDLE_STATE: hr = TYPE_E_INVALIDSTATE;
			default:                          hr = E_FAIL;
			}
		}
		if (pExceptInfo)
		{
			pExceptInfo->wCode = 1000; //!! ? what should we give?
			pExceptInfo->wReserved = 0;
			pExceptInfo->bstrSource = OLEAUT32::SysAllocString(ERROR_SOURCE_NAME);
			pExceptInfo->bstrDescription = OLEAUT32::SysAllocString(pTable->sz);
			pExceptInfo->bstrHelpFile = OLEAUT32::SysAllocString(L"Msi.chm");
			pExceptInfo->dwHelpContext =  pTable->helpid;
			pExceptInfo->pfnDeferredFillIn = 0;
			pExceptInfo->scode = hr;
			hr = DISP_E_EXCEPTION;
		}
	}
	return hr;
}

MSIHANDLE CAutoBase::GetHandle()
{
	return m_hMsi;
}

//____________________________________________________________________________
//
// CObjectSafety implementation
//____________________________________________________________________________

HRESULT CObjectSafety::QueryInterface(const IID& riid, void** ppvObj)
{
	return This->QueryInterface(riid, ppvObj);
}

unsigned long CObjectSafety::AddRef()
{
	return This->AddRef();
}

unsigned long CObjectSafety::Release()
{
	return This->Release();
}

HRESULT CObjectSafety::GetInterfaceSafetyOptions(const IID& riid, DWORD* pdwSupportedOptions, DWORD* pdwEnabledOptions)
{
	if (!pdwSupportedOptions || !pdwEnabledOptions)
		return E_POINTER;
	DWORD options = 0;
	if (::GetIntegerPolicyValue(szSafeForScripting, fTrue) == 1)
		options = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	*pdwSupportedOptions = options;
	*pdwEnabledOptions = 0;
	if (riid == IID_IDispatch) // Client wants to know if object is safe for scripting
	{       
		*pdwEnabledOptions = options;
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}   
}


HRESULT CObjectSafety::SetInterfaceSafetyOptions(const IID& riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
	if (riid == IID_IDispatch) // Client asking if it's safe to call through IDispatch
	{
		if (::GetIntegerPolicyValue(szSafeForScripting, fTrue) == 1 && INTERFACESAFE_FOR_UNTRUSTED_CALLER == dwOptionSetMask && INTERFACESAFE_FOR_UNTRUSTED_CALLER == dwEnabledOptions)
			return S_OK;
		else
			return E_FAIL;
	}
	else
	{
		return E_FAIL;
	}
}

//____________________________________________________________________________
//
// CEnumVARIANTRECORD implementation
//____________________________________________________________________________

CEnumVARIANTRECORD::CEnumVARIANTRECORD(CEnumBuffer& rBuffer)
	: m_rBuffer(rBuffer)
{
	m_iRefCnt = 1;
	rBuffer.iRefCnt++;
	m_cItems = rBuffer.cItems;
	CEnumVARIANTRECORD::Reset();
}

CEnumVARIANTRECORD::~CEnumVARIANTRECORD()
{
	if (--m_rBuffer.iRefCnt <= 0)
	{
		if ( m_cItems )
		{
			VolumeCost** ppstVol = (VolumeCost**)(&m_rBuffer+1);
			for ( int i=0; i < m_cItems; i++ )
				delete *(ppstVol+i);
		}
		delete &m_rBuffer;
	}
}

HRESULT CEnumVARIANTRECORD::QueryInterface(const GUID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IEnumVARIANT)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CEnumVARIANTRECORD::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CEnumVARIANTRECORD::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

HRESULT CEnumVARIANTRECORD::Skip(unsigned long cItem)
{
	while (cItem--)
	{
		if (m_iItem >= m_cItems)
			return S_FALSE;
		m_iItem++;
	}
	return S_OK;
}

HRESULT CEnumVARIANTRECORD::Reset()
{
	m_iItem = 0;
	return S_OK;
}

HRESULT CEnumVARIANTRECORD::Clone(IEnumVARIANT** ppiRet)
{
	*ppiRet = new CEnumVARIANTRECORD(m_rBuffer);
	return S_OK;
}

unsigned long CEnumVARIANTRECORD::Count()
{
	return m_cItems;
}

HRESULT CEnumVARIANTRECORD::ReturnItem(int iItem, VARIANT* pvarRet)
{
	if (pvarRet)
		pvarRet->vt = VT_EMPTY;

	if ( iItem >= m_cItems )
		return DISP_E_BADINDEX;

	MSIHANDLE hRec;
	hRec = MsiCreateRecord(3);
	if ( !hRec )
		return S_FALSE;

	VolumeCost* pstVol = *((VolumeCost**)(&m_rBuffer+1) + iItem);
	if ( MsiRecordSetStringW(hRec, 1, pstVol->m_szDrive) != ERROR_SUCCESS ||
		  MsiRecordSetInteger(hRec, 2, pstVol->m_iCost) != ERROR_SUCCESS   ||
		  MsiRecordSetInteger(hRec, 3, pstVol->m_iTempCost) != ERROR_SUCCESS )
	{
		MsiCloseHandle(hRec);
		return S_FALSE;
	}
	pvarRet->vt = VT_DISPATCH;
	pvarRet->pdispVal = new CAutoRecord(hRec);
	return S_OK;
}

HRESULT CEnumVARIANTRECORD::Next(unsigned long cItem, VARIANT* rgvarRet, unsigned long* pcItemRet)
{
	if (pcItemRet)
		*pcItemRet = 0;
	if (!rgvarRet)
		return S_FALSE;
	while (cItem--)
	{
		HRESULT hRes = ReturnItem(m_iItem, rgvarRet);
		if ( hRes != S_OK )
			return hRes;
		m_iItem++;
		rgvarRet++;
		if (pcItemRet)
			(*pcItemRet)++;
	}
	return S_OK;
}

HRESULT CEnumVARIANTRECORD::Item(unsigned long iIndex, VARIANT* pvarRet)
{
	if (pvarRet)
		return ReturnItem(iIndex, pvarRet);
	else
		return S_FALSE;
}

//____________________________________________________________________________
//
// CEnumVARIANTBSTR implementation
//____________________________________________________________________________

CEnumVARIANTBSTR::CEnumVARIANTBSTR(CEnumBuffer& rBuffer)
	: m_rBuffer(rBuffer)
{
	m_iRefCnt = 1;
	rBuffer.iRefCnt++;
	m_cItems = rBuffer.cItems;
	CEnumVARIANTBSTR::Reset();
}

CEnumVARIANTBSTR::~CEnumVARIANTBSTR()
{
	if (-- m_rBuffer.iRefCnt <= 0)
		delete &m_rBuffer;
}

HRESULT CEnumVARIANTBSTR::QueryInterface(const GUID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IEnumVARIANT)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CEnumVARIANTBSTR::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CEnumVARIANTBSTR::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
	return 0;
}

HRESULT CEnumVARIANTBSTR::Skip(unsigned long cItem)
{
	while (cItem--)
	{
		if (m_iItem >= m_cItems)
			return S_FALSE;
		int cch = *m_pchNext++;
		m_pchNext += cch;
		m_iItem++;
	}
	return S_OK;
}

HRESULT CEnumVARIANTBSTR::Reset()
{
	m_iItem = m_iLastItem = 0;
	m_pchNext = m_pchLastItem = (WCHAR*)(&m_rBuffer + 1);
	return S_OK;
}

HRESULT CEnumVARIANTBSTR::Clone(IEnumVARIANT** ppiRet)
{
	*ppiRet = new CEnumVARIANTBSTR(m_rBuffer);
	return S_OK;
}

HRESULT CEnumVARIANTBSTR::Next(unsigned long cItem, VARIANT* rgvarRet, unsigned long* pcItemRet)
{
	if (pcItemRet)
		*pcItemRet = 0;
	if (!rgvarRet)
		return S_FALSE;
	while (cItem--)
	{
		if (m_iItem >= m_cItems)
			return S_FALSE;
		int cch = *m_pchNext++;
		rgvarRet->vt = VT_BSTR;
		rgvarRet->bstrVal = OLEAUT32::SysAllocStringLen(m_pchNext, cch);
		m_pchNext += cch;
		m_iItem++;
		rgvarRet++;
		if (pcItemRet)
			(*pcItemRet)++;
	}
	return S_OK;
}

unsigned long CEnumVARIANTBSTR::Count()
{
	return m_cItems;
}

HRESULT CEnumVARIANTBSTR::Item(unsigned long iIndex, VARIANT* pvarRet)
{
	if (iIndex >= m_cItems)
	{
		if (pvarRet)
			pvarRet->vt = VT_EMPTY;
		return DISP_E_BADINDEX;
	}
	if (iIndex < m_iLastItem)
	{
		m_iLastItem = 0;
		m_pchLastItem = (WCHAR*)(&m_rBuffer + 1);
	}
	while (m_iLastItem != iIndex)
	{
		int cch = *m_pchLastItem++;
		m_pchLastItem += cch;
		m_iLastItem++;
	}
	if (pvarRet)
	{
		pvarRet->vt = VT_BSTR;
		pvarRet->bstrVal = OLEAUT32::SysAllocStringLen(m_pchLastItem + 1, *m_pchLastItem);
	}
	return S_OK;
}

//____________________________________________________________________________
//
// CAutoCollection implementation
//____________________________________________________________________________

DispatchEntry<CAutoCollection> AutoEnumVARIANTTable[] = {
	DISPID_NEWENUM,             0, aafMethod, CAutoCollection::_NewEnum, L"_NewEnum",
	DISPID_VALUE,               0, aafPropRO, CAutoCollection::Item    , L"Item,Index",
	DISPID_MsiCollection_Count, 0, aafPropRO, CAutoCollection::Count   , L"Count",
};
const int AutoEnumVARIANTCount = sizeof(AutoEnumVARIANTTable)/sizeof(DispatchEntryBase);

CAutoCollection::CAutoCollection(IMsiCollection& riEnum, const IID& riid)
	: CAutoBase(*AutoEnumVARIANTTable, AutoEnumVARIANTCount, riid, 0)
	, m_riEnum(riEnum)
{
}

unsigned long CAutoCollection::Release()
{
	if (m_iRefCnt == 1)
		m_riEnum.Release();
	return CAutoBase::Release();
}

DISPERR CAutoCollection::_NewEnum(CAutoArgs& args)
{
	m_riEnum.AddRef();
	return args.Assign(m_riEnum);
}

DISPERR CAutoCollection::Item(CAutoArgs& args)
{
	unsigned int iIndex;
	DISPERR iErr = args[1].GetInt(iIndex);
	if (iErr)
		return iErr;
	return m_riEnum.Item(iIndex, args.ResultVariant());
}

DISPERR CAutoCollection::Count(CAutoArgs& args)
{
	return args.Assign(m_riEnum.Count());
}

DISPERR CreateAutoEnum(CAutoArgs& args, DISPID dispid, const WCHAR* szParent)
{
	CEnumBuffer* pBuffer = 0;
	int cbBuffer = sizeof(CEnumBuffer);
	WCHAR rgchTemp[1024];
	WCHAR* pchTempEnd = rgchTemp + sizeof(rgchTemp)/sizeof(WCHAR);
	WCHAR* pchTemp = rgchTemp;
	int cItems = 0;
	int iIndex = 0;
	UINT iStat;
	do
	{
		Assert(pchTempEnd - pchTemp <= UINT_MAX);       //--merced: 64-bit ptr subtraction may lead to values too big for cchTemp
		DWORD cchTemp = (DWORD) (pchTempEnd - pchTemp);

		switch (dispid)
		{
		case DISPID_MsiInstall_Products:
			if (cchTemp < STRING_GUID_CHARS+2)  // room for size + data + null
				iStat = ERROR_MORE_DATA;
			else
				iStat = MsiEnumProductsW(iIndex, pchTemp+1);
			cchTemp = STRING_GUID_CHARS;
			break;
		case DISPID_MsiInstall_Features:
			if (cchTemp < MAX_FEATURE_CHARS+2)  // room for size + data + null
				iStat = ERROR_MORE_DATA;
			else
			{
				iStat = MsiEnumFeaturesW(szParent, iIndex, pchTemp+1, 0);
				while (iStat == ERROR_MORE_DATA)
				{
					// skip corrupt features whose name is greater than MAX_FEATURE_CHAR
					iIndex++;
					iStat = MsiEnumFeaturesW(szParent, iIndex, pchTemp+1, 0);
				}
			}
			if (iStat == NOERROR)
				cchTemp = lstrlenW(pchTemp + 1);
			break;
		case DISPID_MsiInstall_Components:
			if (cchTemp < STRING_GUID_CHARS+2)  // room for size + data + null
				iStat = ERROR_MORE_DATA;
			else
				iStat = MsiEnumComponentsW(iIndex, pchTemp+1);
			cchTemp = STRING_GUID_CHARS;
			break;
		case DISPID_MsiInstall_ComponentQualifiers:
			iStat = MsiEnumComponentQualifiersW(szParent, iIndex, pchTemp+1, &cchTemp, 0, 0);
			break;
		case DISPID_MsiInstall_ComponentClients:
			if (cchTemp < STRING_GUID_CHARS+2)  // room for size + data + null
				iStat = ERROR_MORE_DATA;
			else
				iStat = MsiEnumClientsW(szParent, iIndex, pchTemp+1);
			cchTemp = STRING_GUID_CHARS;
			break;
		case DISPID_MsiInstall_Patches:
		{
			if (cchTemp < STRING_GUID_CHARS+2)  // room for size + data + null
				iStat = ERROR_MORE_DATA;
			else
			{
                CTempBuffer<WCHAR, 128> bTransforms;
                DWORD dwSize = bTransforms.GetSize();
                int iRetry = 0;
                do
                    iStat = MsiEnumPatchesW(szParent, iIndex, pchTemp+1,
                                                    bTransforms, &dwSize);
                while (iStat == ERROR_MORE_DATA && ++iRetry < 2 && (bTransforms.SetSize(++dwSize), true));
			}
			cchTemp = STRING_GUID_CHARS;  // transforms are left out here
			break;
		}
		case DISPID_MsiInstall_RelatedProducts:
			if (cchTemp < STRING_GUID_CHARS+2)  // room for size + data + null
				iStat = ERROR_MORE_DATA;
			else
				iStat = MsiEnumRelatedProductsW(szParent, 0, iIndex, pchTemp+1);
			cchTemp = STRING_GUID_CHARS;
			break;
		default:
			Assert(0);
			return DISP_E_BADCALLEE;
		}
		if (iStat == NOERROR)
		{
			*pchTemp++ = (unsigned short)cchTemp;
			pchTemp += cchTemp;
			iIndex++;
			cItems++;
		}
		else if (iStat == ERROR_MORE_DATA || iStat == ERROR_NO_MORE_ITEMS)
		{
			CEnumBuffer* pOldBuffer = pBuffer;
			int cbOld = cbBuffer;
			Assert((char*)pchTemp - (char*)rgchTemp <= INT_MAX);    //--merced: 64-bit ptr subtraction may lead to values too big for cbNew
			int cbNew = (int)((char*)pchTemp - (char*)rgchTemp);
			cbBuffer = cbOld + cbNew;
			pBuffer = (CEnumBuffer*)new char[cbBuffer];
			if ( ! pBuffer )
			{
				delete [] pOldBuffer;
				return E_OUTOFMEMORY;
			}
			if (pOldBuffer == 0)
			{
				pBuffer->iRefCnt = 0;
				pBuffer->cItems = 0;
			}
			else
			{
				memcpy(pBuffer, pOldBuffer, cbOld);
				delete [] pOldBuffer;
			}
			memcpy((char*)pBuffer + (INT_PTR)cbOld, rgchTemp, cbNew);       //--merced: added (INT_PTR)
			pBuffer->cItems += cItems; cItems = 0;
			pBuffer->cbSize = cbBuffer;
			pchTemp = rgchTemp;
		}
		else
		{
			delete [] pBuffer;
			return HRESULT_FROM_WIN32(iStat);
		}
	} while(iStat != ERROR_NO_MORE_ITEMS);
	IMsiCollection* piEnum = new CEnumVARIANTBSTR(*pBuffer);
	return args.Assign(new CAutoCollection(*piEnum, IID_IMsiApiCollection));
}

//____________________________________________________________________________
//
// CAutoInstall implementation
//____________________________________________________________________________

DispatchEntry<CAutoInstall> AutoInstallTable[] = {
  DISPID_MsiInstall_OpenPackage ,       HELPID_MsiInstall_OpenPackage ,       aafMethod, CAutoInstall::OpenPackage,        L"OpenPackage,PackagePath,Options",
  DISPID_MsiInstall_OpenProduct ,       HELPID_MsiInstall_OpenProduct ,       aafMethod, CAutoInstall::OpenProduct,        L"OpenProduct,ProductCode",
  DISPID_MsiInstall_OpenDatabase,       HELPID_MsiInstall_OpenDatabase,       aafMethod, CAutoInstall::OpenDatabase,       L"OpenDatabase,DatabasePath,OpenMode",
  DISPID_MsiInstall_CreateRecord,       HELPID_MsiInstall_CreateRecord,       aafMethod, CAutoInstall::CreateRecord,       L"CreateRecord,Count",
  DISPID_MsiInstall_SummaryInformation, HELPID_MsiInstall_SummaryInformation, aafPropRO, CAutoInstall::SummaryInformation, L"SummaryInformation,DatabasePath,UpdateCount",
  DISPID_MsiInstall_UILevel,            HELPID_MsiInstall_UILevel,            aafPropRW, CAutoInstall::UILevel,            L"UILevel",
  DISPID_MsiInstall_EnableLog,          HELPID_MsiInstall_EnableLog,          aafMethod, CAutoInstall::EnableLog,          L"EnableLog,LogMode,LogFile",
  DISPID_MsiInstall_InstallProduct,     HELPID_MsiInstall_InstallProduct,     aafMethod, CAutoInstall::InstallProduct,     L"InstallProduct,PackagePath,PropertyValues",
  DISPID_MsiInstall_Version,            HELPID_MsiInstall_Version,            aafPropRO, CAutoInstall::Version,            L"Version",
  DISPID_MsiInstall_LastErrorRecord  ,  HELPID_MsiInstall_LastErrorRecord,    aafPropRO, CAutoInstall::LastErrorRecord,    L"LastErrorRecord",
  DISPID_MsiInstall_RegistryValue,      HELPID_MsiInstall_RegistryValue,      aafMethod, CAutoInstall::RegistryValue,      L"RegistryValue,Root,Key,Value",
  DISPID_MsiInstall_FileAttributes,     HELPID_MsiInstall_FileAttributes,     aafMethod, CAutoInstall::FileAttributes,     L"FileAttributes,FilePath",
  DISPID_MsiInstall_FileSize,           HELPID_MsiInstall_FileSize,           aafMethod, CAutoInstall::FileSize,           L"FileSize,FilePath",
  DISPID_MsiInstall_FileVersion,        HELPID_MsiInstall_FileVersion,        aafMethod, CAutoInstall::FileVersion,        L"FileVersion,FilePath,Language",
  DISPID_MsiInstall_Environment,        HELPID_MsiInstall_Environment,        aafPropRW, CAutoInstall::Environment,        L"Environment,Variable",
  DISPID_MsiInstall_ProductState      , HELPID_MsiInstall_ProductState      , aafPropRO, CAutoInstall::ProductState      , L"ProductState,Product",
  DISPID_MsiInstall_ProductInfo       , HELPID_MsiInstall_ProductInfo       , aafPropRO, CAutoInstall::ProductInfo       , L"ProductInfo,Product,Attribute",
  DISPID_MsiInstall_ConfigureProduct  , HELPID_MsiInstall_ConfigureProduct  , aafMethod, CAutoInstall::ConfigureProduct  , L"ConfigureProduct,Product,InstallLevel,InstallState",
  DISPID_MsiInstall_ReinstallProduct  , HELPID_MsiInstall_ReinstallProduct  , aafMethod, CAutoInstall::ReinstallProduct  , L"ReinstallProduct,Product,ReinstallMode",
  DISPID_MsiInstall_CollectUserInfo   , HELPID_MsiInstall_CollectUserInfo   , aafMethod, CAutoInstall::CollectUserInfo   , L"CollectUserInfo",
  DISPID_MsiInstall_ApplyPatch        , HELPID_MsiInstall_ApplyPatch        , aafMethod, CAutoInstall::ApplyPatch        , L"ApplyPatch,PatchPackage,InstallPackage,InstallType,CommandLine",
  DISPID_MsiInstall_FeatureParent     , HELPID_MsiInstall_FeatureParent     , aafPropRO, CAutoInstall::FeatureParent     , L"FeatureParent,Product,Feature",
  DISPID_MsiInstall_FeatureState      , HELPID_MsiInstall_FeatureState      , aafPropRO, CAutoInstall::FeatureState      , L"FeatureState,Product,Feature",
  DISPID_MsiInstall_UseFeature        , HELPID_MsiInstall_UseFeature        , aafMethod, CAutoInstall::UseFeature        , L"UseFeature,Product,Feature",
  DISPID_MsiInstall_FeatureUsageCount , HELPID_MsiInstall_FeatureUsageCount , aafPropRO, CAutoInstall::FeatureUsageCount , L"FeatureUsageCount,Product,Feature",
  DISPID_MsiInstall_FeatureUsageDate  , HELPID_MsiInstall_FeatureUsageDate  , aafPropRO, CAutoInstall::FeatureUsageDate  , L"FeatureUsageDate,Product,Feature",
  DISPID_MsiInstall_ConfigureFeature  , HELPID_MsiInstall_ConfigureFeature  , aafMethod, CAutoInstall::ConfigureFeature  , L"ConfigureFeature,Product,Feature,InstallState",
  DISPID_MsiInstall_ReinstallFeature  , HELPID_MsiInstall_ReinstallFeature  , aafMethod, CAutoInstall::ReinstallFeature  , L"ReinstallFeature,Product,Feature,ReinstallMode",
  DISPID_MsiInstall_ProvideComponent  , HELPID_MsiInstall_ProvideComponent  , aafMethod, CAutoInstall::ProvideComponent  , L"ProvideComponent,Product,Feature,Component,InstallMode",
  DISPID_MsiInstall_ComponentPath     , HELPID_MsiInstall_ComponentPath     , aafPropRO, CAutoInstall::ComponentPath     , L"ComponentPath,Product,Component",
  DISPID_MsiInstall_ProvideQualifiedComponent, HELPID_MsiInstall_ProvideQualifiedComponent, aafMethod, CAutoInstall::ProvideQualifiedComponent, L"ProvideQualifiedComponent,Category,Qualifier,InstallMode",
  DISPID_MsiInstall_QualifierDescription, HELPID_MsiInstall_QualifierDescription, aafPropRO, CAutoInstall::QualifierDescription, L"QualifierDescription,Category,Qualifier",
  DISPID_MsiInstall_ComponentQualifiers,HELPID_MsiInstall_ComponentQualifiers,aafPropRO, CAutoInstall::ComponentQualifiers,L"ComponentQualifiers",
  DISPID_MsiInstall_Products,           HELPID_MsiInstall_Products,           aafPropRO, CAutoInstall::Products,           L"Products",
  DISPID_MsiInstall_Features,           HELPID_MsiInstall_Features,           aafPropRO, CAutoInstall::Features,           L"Features,Product",
  DISPID_MsiInstall_Components,         HELPID_MsiInstall_Components,         aafPropRO, CAutoInstall::Components,         L"Components",
  DISPID_MsiInstall_ComponentClients,   HELPID_MsiInstall_ComponentClients,   aafPropRO, CAutoInstall::ComponentClients,   L"ComponentClients,Product",
  DISPID_MsiInstall_Patches,            HELPID_MsiInstall_Patches,            aafPropRO, CAutoInstall::Patches,            L"Patches,Product",
  DISPID_MsiInstall_RelatedProducts,    HELPID_MsiInstall_RelatedProducts,    aafPropRO, CAutoInstall::RelatedProducts,    L"RelatedProducts,UpgradeCode",
  DISPID_MsiInstall_PatchInfo,          HELPID_MsiInstall_PatchInfo,          aafPropRO, CAutoInstall::PatchInfo,          L"PatchInfo,Patch,Attribute",
  DISPID_MsiInstall_PatchTransforms,    HELPID_MsiInstall_PatchTransforms,    aafPropRO, CAutoInstall::PatchTransforms,    L"PatchTransforms,Product,Patch",
  DISPID_MsiInstall_AddSource,          HELPID_MsiInstall_AddSource,          aafMethod, CAutoInstall::AddSource,          L"AddSource,Product,User,Source",
  DISPID_MsiInstall_ClearSourceList,    HELPID_MsiInstall_ClearSourceList,    aafMethod, CAutoInstall::ClearSourceList,    L"ClearSourceList,Product,User",
  DISPID_MsiInstall_ForceSourceListResolution, HELPID_MsiInstall_ForceSourceListResolution, aafMethod, CAutoInstall::ForceSourceListResolution, L"ForceSourceListResolution,Product,User",
  DISPID_MsiInstall_GetShortcutTarget,  HELPID_MsiInstall_GetShortcutTarget,  aafPropRO, CAutoInstall::GetShortcutTarget,  L"ShortcutTarget",
  DISPID_MsiInstall_FileHash,           HELPID_MsiInstall_FileHash,           aafMethod, CAutoInstall::FileHash,           L"FileHash,FilePath,Options",
  DISPID_MsiInstall_FileSignatureInfo,  HELPID_MsiInstall_FileSignatureInfo,  aafMethod, CAutoInstall::FileSignatureInfo,  L"FileSignatureInfo,FilePath,Options,Format",
};
const int AutoInstallCount = sizeof(AutoInstallTable)/sizeof(DispatchEntryBase);

HRESULT CAutoInstall::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IObjectSafety)
	{
		*ppvObj = &m_ObjectSafety;
		AddRef();
		return S_OK;
	}
	return CAutoBase::QueryInterface(riid, ppvObj);
}

CAutoInstall::CAutoInstall(MSIHANDLE hBase)
 : CAutoBase(*AutoInstallTable, AutoInstallCount, IID_IMsiApiInstall, hBase)
{
	m_ObjectSafety.This = this;
}

MSIHANDLE CreateMsiHandle(IUnknown* pi, int iid);
void RedirectMsiHandle(MSIHANDLE h, IUnknown& riunk);

CAutoInstall* CreateAutoInstall()
{
	MSIHANDLE hBase;
	hBase = ::CreateMsiHandle(&g_AutoInstallFactory, 0);
	if (hBase == 0)   // can't allocate memory
		return 0;
	return new CAutoInstall(hBase);
}

IDispatch* CreateAutoInstallDispatch()
{
	return static_cast<IDispatch*>(CreateAutoInstall());
}

DISPERR CAutoInstall::OpenPackage(CAutoArgs& args)
{
	MSIHANDLE hEngine;
	const WCHAR* szPath;
	WCHAR rgchBuf[20];
	DISPERR iErr;

	DWORD dwOptions = 0;
	if (args.Present(2) && (iErr = args[2].GetInt((int&)dwOptions)) != S_OK)
		return iErr;

   if ((iErr = args[1].GetString(szPath)) != S_OK)
	{
		MSIHANDLE h = args[1].GetHandle(IID_IMsiApiDatabase);
		if (h == MSI_NULL_HANDLE || h == MSI_INVALID_HANDLE)
			return iErr;
#ifdef UNICODE
		W32::StringCchPrintfW(rgchBuf, (sizeof(rgchBuf)/sizeof(WCHAR)), L"#%i", h);
#else
		char rgchTemp[20];
		W32::StringCchPrintfA(rgchTemp, sizeof(rgchTemp), "#%i", h);
		W32::MultiByteToWideChar(CP_ACP, 0, rgchTemp, -1, rgchBuf, sizeof(rgchBuf)/sizeof(WCHAR));
#endif
		szPath = rgchBuf;
	}
	if ((iErr = MsiOpenPackageExW(szPath, dwOptions, &hEngine)) == NOERROR)
		args.Assign(new CAutoEngine(hEngine, this, 0));
	return iErr;
}

DISPERR CAutoInstall::OpenProduct(CAutoArgs& args)
{
	MSIHANDLE hEngine;
	const WCHAR* szProduct;
	DISPERR iErr;
	if ((iErr = args[1].GetString(szProduct)) == S_OK
	 && (iErr = MsiOpenProductW(szProduct, &hEngine)) == NOERROR)
		args.Assign(new CAutoEngine(hEngine, this, 0));
	return iErr;
}

DISPERR CAutoInstall::OpenDatabase(CAutoArgs& args)
{
	DISPERR iErr;
	LPCWSTR szPath;
	if ((iErr = args[1].GetString(szPath)) != S_OK)
		return iErr;
	CVariant& var = args[2];
	UINT iDataType = var.GetType();
	LPCWSTR szPersist;
	int i;      
	if ((iErr = var.GetInt(i)) == S_OK)
		szPersist = (LPCWSTR)(INT_PTR)i;        //--merced: added (INT_PTR) to avoid warning 4312
	else if ((iErr = var.GetString(szPersist)) != S_OK)
		return iErr;
	MSIHANDLE hDatabase;
	if ((iErr = MsiOpenDatabaseW(szPath, szPersist, &hDatabase)) == NOERROR)
		args.Assign(new CAutoDatabase(hDatabase));
	if (iErr == ERROR_INVALID_PARAMETER)  // let API function do arg validation
		return DISP_E_BADINDEX;
	return iErr;
}

DISPERR CAutoInstall::CreateRecord(CAutoArgs& args)
{
	int cFields;
	DISPERR iErr = args[1].GetInt(cFields);
	if (iErr)
		return iErr;
	if (cFields < 0 || cFields > MSIRECORD_MAXFIELDS)
		return E_INVALIDARG;
   MSIHANDLE hRecord = MsiCreateRecord(cFields);
	if (hRecord == 0)
		return DISP_E_TYPEMISMATCH;
	return args.Assign(new CAutoRecord(hRecord));
}

DISPERR CAutoInstall::SummaryInformation(CAutoArgs& args)
{
	DISPERR iErr;
	LPCWSTR szPath;
	MSIHANDLE hSummaryInfo;
	UINT cUpdate = 0;
	if ((iErr = args[1].GetString(szPath)) != S_OK)
		return iErr;
	if (args.Present(2) && (iErr = args[2].GetInt((int&)cUpdate)) != S_OK)
		return iErr;
	if ((iErr = MsiGetSummaryInformationW(0, szPath, cUpdate, &hSummaryInfo)) == S_OK)
		args.Assign(new CAutoSummaryInfo(hSummaryInfo));
	return iErr;
}

DISPERR CAutoInstall::UILevel(CAutoArgs& args)
{
	DISPERR iErr;
	if (args.PropertySet())
	{
		INSTALLUILEVEL eUI;
		if ((iErr = args[0].GetInt((int&)eUI)) != S_OK)
			return iErr;
		if (MsiSetInternalUI(eUI, 0) == INSTALLUILEVEL_NOCHANGE)
			return DISP_E_BADINDEX;
	}
	else
		args.Assign((int)MsiSetInternalUI(INSTALLUILEVEL_NOCHANGE, 0));
	return S_OK;
}

DISPERR CAutoInstall::EnableLog(CAutoArgs& args)
{
	DISPERR iErr;
	LPCWSTR szLogMode = NULL;
	LPCWSTR szLogFile;
	if ((iErr = args[1].GetString(szLogMode)) != S_OK
	||  (iErr = args[2].GetString(szLogFile)) != S_OK)
		return iErr;

	BOOL fAppend = FALSE;
	WCHAR ch;
	const ICHAR* pchLogChars = szLogChars;
	DWORD dwLogMode = 0;
	if ( szLogMode )
	{
		while ((ch = *szLogMode++) != 0)
		{
			if (ch == TEXT(' '))
				continue;
			if (ch == TEXT('*'))
			{
				dwLogMode |= ((1 << (sizeof(szLogChars)/sizeof(*szLogChars) - 1)) - 1) & ~INSTALLLOGMODE_VERBOSE;
				continue;
			}
			if (ch == TEXT('+'))
			{
				fAppend = TRUE;
				continue;
			}
			if (ch >= TEXT('A') && ch <= TEXT('Z'))
				ch += (TEXT('a') - TEXT('A'));
			for (const ICHAR* pch = szLogChars; *pch != ch; pch++)
				if (*pch == 0)
					return DISP_E_BADINDEX;
			dwLogMode |= (1 << (pch - szLogChars));
		}
	}
   return MsiEnableLogW(dwLogMode, szLogFile, fAppend);
}

DISPERR CAutoInstall::InstallProduct(CAutoArgs& args)
{
	DISPERR iErr;
	LPCWSTR szProperties = 0;
	LPCWSTR szPath;
	WCHAR rgchBuf[20];
	if ((iErr = args[1].GetString(szPath)) != S_OK)
	{
		MSIHANDLE h = args[1].GetHandle(IID_IMsiApiDatabase);
		if (h == MSI_NULL_HANDLE || h == MSI_INVALID_HANDLE)
			return iErr;
#ifdef UNICODE
		W32::StringCchPrintfW(rgchBuf, (sizeof(rgchBuf)/sizeof(WCHAR)), L"#%i", h);
#else
		char rgchTemp[20];
		W32::StringCchPrintfA(rgchTemp, sizeof(rgchTemp), "#%i", h);
		W32::MultiByteToWideChar(CP_ACP, 0, rgchTemp, -1, rgchBuf, sizeof(rgchBuf)/sizeof(WCHAR));
#endif
		szPath = rgchBuf;
	}
	if (args.Present(2) && (iErr = args[2].GetString(szProperties)) != S_OK)
		return iErr;
   return MsiInstallProductW(szPath, szProperties);
}

DISPERR CAutoInstall::Version(CAutoArgs& args)
{
	TCHAR rgchBuf[20];
	W32::StringCchPrintf(rgchBuf, (sizeof(rgchBuf)/sizeof(TCHAR)), TEXT("%i.%i.%i.%i"), rmj, rmm, rup, rin);
	return args.Assign(rgchBuf);
}
	
DISPERR CAutoInstall::LastErrorRecord(CAutoArgs& args)
{
	MSIHANDLE h = MsiGetLastErrorRecord();
	return args.Assign((IDispatch*)(h ? new CAutoRecord(h) : 0));
}

DISPERR CAutoInstall::ProductState(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	if ((iErr = args[1].GetString(szProduct)) != S_OK)
		return iErr;
	return args.Assign((long)MsiQueryProductStateW(szProduct));
}

DISPERR CAutoInstall::ProductInfo(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szAttribute;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szAttribute)) != S_OK)
		return iErr;
	CTempBuffer<WCHAR, 128> bResult;
	DWORD dwSize = bResult.GetSize();
	do
		iErr = MsiGetProductInfoW(szProduct, szAttribute, bResult, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bResult.SetSize(++dwSize), true));
	if (iErr != ERROR_SUCCESS)
		return iErr;

	return args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoInstall::PatchInfo(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szPatchName;
	const WCHAR* szAttribute;
	if ((iErr = args[1].GetString(szPatchName)) != S_OK
	 || (iErr = args[2].GetString(szAttribute)) != S_OK)
		return iErr;

	CTempBuffer<WCHAR, 128> bResult;
	DWORD dwSize = bResult.GetSize();
	int iRetry = 0;
	do
		iErr = MsiGetPatchInfoW(szPatchName, szAttribute, bResult, &dwSize);
	while (iErr == ERROR_MORE_DATA && ++iRetry < 2 && (bResult.SetSize(++dwSize), true));

	return iErr != ERROR_SUCCESS ? iErr : args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoInstall::PatchTransforms(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szArgPatch;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szArgPatch)) != S_OK)
		return iErr;

	CTempBuffer<WCHAR, 128> bTransforms;
	DWORD dwSize = bTransforms.GetSize();
	CTempBuffer<WCHAR, STRING_GUID_CHARS+1> szPatch;
	int iIndex = 0;
	do
	{
		int iRetry = 0;
		do
			iErr = MsiEnumPatchesW(szProduct, iIndex, szPatch,
										  bTransforms, &dwSize);
		while (iErr == ERROR_MORE_DATA && ++iRetry < 2 && (bTransforms.SetSize(++dwSize), true));
		if ( iErr == ERROR_SUCCESS && !lstrcmpW(szArgPatch, szPatch) )
		{
			// we're on the right patch
			return args.Assign((const WCHAR* )bTransforms);
		}
		iIndex++;
	}
	while ( iErr == ERROR_SUCCESS );

	return iErr;
}

DISPERR CAutoInstall::AddSource(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szUser;
	const WCHAR* szSource;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szUser)) != S_OK
	 || (iErr = args[3].GetString(szSource)) != S_OK)
		return iErr;

	return MsiSourceListAddSourceW(szProduct, szUser, 0, szSource);
}

DISPERR CAutoInstall::ClearSourceList(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szUser;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szUser)) != S_OK)
		return iErr;

	return MsiSourceListClearAllW(szProduct, szUser, 0);
}

DISPERR CAutoInstall::ForceSourceListResolution(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szUser;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szUser)) != S_OK)
		return iErr;

	return MsiSourceListForceResolutionW(szProduct, szUser, 0);
}

DISPERR CAutoInstall::ConfigureProduct(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	int          iInstallLevel;
	INSTALLSTATE eInstallState;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetInt(iInstallLevel)) != S_OK
	 || (iErr = args[3].GetInt((int&)eInstallState)) != S_OK)
		return iErr;
	return MsiConfigureProductW(szProduct, iInstallLevel, eInstallState);
}

DISPERR CAutoInstall::ReinstallProduct(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	int          iReinstallMode;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetInt(iReinstallMode)) != S_OK)
		return iErr;
	return MsiReinstallProductW(szProduct, iReinstallMode);
}

DISPERR CAutoInstall::CollectUserInfo(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	if ((iErr = args[1].GetString(szProduct)) != S_OK)
		return iErr;
	return MsiCollectUserInfoW(szProduct);
}

DISPERR CAutoInstall::ApplyPatch(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szPatchPackage;
	const WCHAR* szInstallPackage;
	int          iInstallType;
	const WCHAR* szCommandLine;
	if ((iErr = args[1].GetString(szPatchPackage)) != S_OK
	 || (iErr = args[2].GetString(szInstallPackage)) != S_OK
	 || (iErr = args[3].GetInt(iInstallType)) != S_OK
	 || (iErr = args[4].GetString(szCommandLine)) != S_OK)
		return iErr;
	return MsiApplyPatchW(szPatchPackage, szInstallPackage, (INSTALLTYPE)iInstallType, szCommandLine);
}

DISPERR CAutoInstall::FeatureParent(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK)
		return iErr;
	WCHAR szParent[MAX_FEATURE_CHARS+1 + 100];
	if ((iErr = MsiGetFeatureParentW(szProduct, szFeature, szParent)) != NOERROR)
		return iErr;
	return args.Assign(szParent);
}

DISPERR CAutoInstall::FeatureState(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK)
		return iErr;
	return args.Assign((int)MsiQueryFeatureStateW(szProduct, szFeature));
}

DISPERR CAutoInstall::UseFeature(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	INSTALLMODE iInstallMode = INSTALLMODE_DEFAULT;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK
	 || (args.Present(3) && (iErr = args[3].GetInt((int&)iInstallMode)) != S_OK))
		return iErr;
	return args.Assign((int)MsiUseFeatureExW(szProduct, szFeature, iInstallMode, 0));
}

DISPERR CAutoInstall::FeatureUsageCount(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK)
		return iErr;
	DWORD iUseCount;
	if ((iErr = MsiGetFeatureUsageW(szProduct, szFeature, &iUseCount, 0)) != NOERROR)
		return iErr;
	return args.Assign(iUseCount);
}

DISPERR CAutoInstall::FeatureUsageDate(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK)
		return iErr;
	WORD iDate;
	if ((iErr = MsiGetFeatureUsageW(szProduct, szFeature, 0, &iDate)) != NOERROR)
		return iErr;
	DATE date = 0;
	if (iDate != 0)
		OLEAUT32::DosDateTimeToVariantTime(iDate, 0, &date);
	return args.Assign(date);
}

DISPERR CAutoInstall::ConfigureFeature(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	INSTALLSTATE eInstallState;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK
	 || (iErr = args[3].GetInt((int&)eInstallState)) != S_OK)
		return iErr;
	return MsiConfigureFeatureW(szProduct, szFeature, eInstallState);
}

DISPERR CAutoInstall::ReinstallFeature(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	int          iReinstallMode;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK
	 || (iErr = args[3].GetInt(iReinstallMode)) != S_OK)
		return iErr;
	return MsiReinstallFeatureW(szProduct, szFeature, iReinstallMode);
}

DISPERR CAutoInstall::ProvideComponent(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szFeature;
	const WCHAR* szComponent;
	int          iInstallMode;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szFeature)) != S_OK
	 || (iErr = args[3].GetString(szComponent)) != S_OK
	 || (iErr = args[4].GetInt(iInstallMode)) != S_OK)
		return iErr;
	CTempBuffer<WCHAR, MAX_PATH> bResult;
	DWORD dwSize = bResult.GetSize();
	do
		iErr = MsiProvideComponentW(szProduct, szFeature, szComponent, iInstallMode, bResult, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bResult.SetSize(++dwSize), true));
	if (iErr != NOERROR)
		return iErr;
	return args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoInstall::ComponentPath(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProduct;
	const WCHAR* szComponent;
	if ((iErr = args[1].GetString(szProduct)) != S_OK
	 || (iErr = args[2].GetString(szComponent)) != S_OK)
		return iErr;
	INSTALLSTATE iState;
	CTempBuffer<WCHAR, MAX_PATH> bResult;
	DWORD dwSize = bResult.GetSize();
	do
		iState = MsiGetComponentPathW(szProduct, szComponent, bResult, &dwSize);
	while (iState == INSTALLSTATE_MOREDATA && (bResult.SetSize(++dwSize), true));
	if (iState != INSTALLSTATE_LOCAL && iState != INSTALLSTATE_SOURCE)
		return args.Assign(fVoid);
	return args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoInstall::ProvideQualifiedComponent(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szCategory;
	const WCHAR* szQualifier;
	int          iInstallMode;
	if ((iErr = args[1].GetString(szCategory)) != S_OK
	 || (iErr = args[2].GetString(szQualifier)) != S_OK
	 || (iErr = args[3].GetInt(iInstallMode)) != S_OK)
		return iErr;
	CTempBuffer<WCHAR, MAX_PATH> bResult;
	DWORD dwSize = bResult.GetSize();
	do
		iErr = MsiProvideQualifiedComponentW(szCategory, szQualifier, iInstallMode, bResult, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bResult.SetSize(++dwSize), true));
	if (iErr != NOERROR)
		return iErr;
	return args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoInstall::QualifierDescription(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szCategory;
	const WCHAR* szQualifier;
	if ((iErr = args[1].GetString(szCategory)) != S_OK
	 || (iErr = args[2].GetString(szQualifier)) != S_OK)
		return iErr;
	CTempBuffer<WCHAR, 128> bResult;
	DWORD dwSize = bResult.GetSize();
	do
		iErr = MsiGetQualifierDescriptionW(szCategory, szQualifier, bResult, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bResult.SetSize(++dwSize), true));
	if (iErr != NOERROR)
		return iErr;
	return args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoInstall::GetShortcutTarget(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szShortcutTarget;

	WCHAR szProductCode[cchProductCode+1];
	WCHAR szFeatureId[cchMaxFeatureName+1];
	WCHAR szComponentCode[cchComponentId+1];

	if ((iErr = args[1].GetString(szShortcutTarget)) != S_OK)
		return iErr;
	
	iErr = MsiGetShortcutTargetW(szShortcutTarget, szProductCode, szFeatureId, szComponentCode);
	if (iErr != ERROR_SUCCESS)
		return iErr;

	MSIHANDLE pRec = MsiCreateRecord(3);
	MsiRecordSetStringW(pRec, 1, szProductCode);
	MsiRecordSetStringW(pRec, 2, szFeatureId);
	MsiRecordSetStringW(pRec, 3, szComponentCode);

	return args.Assign(new CAutoRecord(pRec));
}

DISPERR CAutoInstall::ComponentQualifiers(CAutoArgs& args)
{
	const WCHAR* szCategory;
	DISPERR iErr;
	if ((iErr = args[1].GetString(szCategory)) != S_OK)
		return iErr;
	return CreateAutoEnum(args, DISPID_MsiInstall_ComponentQualifiers, szCategory);
}

DISPERR CAutoInstall::Products(CAutoArgs& args)
{
	return CreateAutoEnum(args, DISPID_MsiInstall_Products, 0);
}

DISPERR CAutoInstall::Features(CAutoArgs& args)
{
	const WCHAR* szProduct;
	DISPERR iErr;
	if ((iErr = args[1].GetString(szProduct)) != S_OK)
		return iErr;
	return CreateAutoEnum(args, DISPID_MsiInstall_Features, szProduct);
}

DISPERR CAutoInstall::Components(CAutoArgs& args)
{
	return CreateAutoEnum(args, DISPID_MsiInstall_Components, 0);
}

DISPERR CAutoInstall::ComponentClients(CAutoArgs& args)
{
	const WCHAR* szProduct;
	DISPERR iErr;
	if ((iErr = args[1].GetString(szProduct)) != S_OK)
		return iErr;
	return CreateAutoEnum(args, DISPID_MsiInstall_ComponentClients, szProduct);
}

DISPERR CAutoInstall::Patches(CAutoArgs& args)
{
	const WCHAR* szProduct;
	DISPERR iErr;
	if ((iErr = args[1].GetString(szProduct)) != S_OK)
		return iErr;

	return CreateAutoEnum(args, DISPID_MsiInstall_Patches, szProduct);
}

DISPERR CAutoInstall::RelatedProducts(CAutoArgs& args)
{
	const WCHAR* szUpgradeCode;
	DISPERR iErr;
	if ((iErr = args[1].GetString(szUpgradeCode)) != S_OK)
		return iErr;

	return CreateAutoEnum(args, DISPID_MsiInstall_RelatedProducts, szUpgradeCode);
}

// Non-installer functions to access system properties

DISPERR CAutoInstall::RegistryValue(CAutoArgs& args)
{
	enum rvEnum
	{
		rvGetValue   = 0,
		rvKeyPresent = 1,
		rvEnumValue  = 2,
		rvEnumKey    = 3,
		rvGetClass   = 4,
	};
	DISPERR iErr;
	int iRoot = 0;
	bool fCloseRoot = false;
	HKEY hkeyRoot;
	HKEY hkey;
	const WCHAR* szKey;
	int iValueName = 0x80000000L;
	const WCHAR* szValue = 0; //L"";
	BYTE  rgbValBuf[MAX_PATH];
	BYTE* pbVal;
	WCHAR rgchExpandBuf[MAX_PATH*2];
	DWORD iValueType;
	unsigned long cbData;
	DWORD cchData;
	rvEnum rvType = rvKeyPresent; // default to key detect, arg missing
	CVariant& var1 = args[1];
	if (var1.IsNumeric())
	{
		var1.GetInt(iRoot);
		if ((iRoot & 0x7FFFFFF0) != 0)
			return DISP_E_BADINDEX;
		hkeyRoot = (HKEY)(INT_PTR)(iRoot | (1<<31));            //!!merced: 4312 int to hkey
	}
	else
	{
		const WCHAR* szMachine;
		if ((iErr = var1.GetString(szMachine)) != S_OK)
			return iErr;
		if ( !szMachine )
			return E_INVALIDARG;
		TCHAR szServer[MAX_PATH];
		szServer[0] = szServer[1] = chRegSep;
		TCHAR* pch = szServer + 2;
		size_t cchServer = ARRAY_ELEMENTS(szServer) - 2;
		while (*szMachine != 0 && cchServer != 0)
		{
			*pch++ = (TCHAR)*szMachine++;
			cchServer--;
		}
		if ( cchServer == 0 )
			// the machine name is too long
			return E_INVALIDARG;
		*pch = 0;
		if ((iErr = W32::RegConnectRegistry(szServer, HKEY_LOCAL_MACHINE, &hkeyRoot)) != ERROR_SUCCESS)
			return iErr;
		fCloseRoot = true;
	}
	if ((iErr = args[2].GetString(szKey)) != S_OK)
	{
		if (fCloseRoot)
			W32::RegCloseKey(hkeyRoot);
		return iErr;
	}
	if (args.Present(3))
	{
		CVariant& var3 = args[3];
		rvType = rvGetValue;
		if (var3.IsNull())
			szValue = 0;
		else if (var3.IsNumeric())
		{
			var3.GetInt(iValueName);
			if (iValueName == 0)
				rvType = rvGetClass;
			else if (iValueName > 0)
			{
				rvType = rvEnumValue;
				iValueName--;
			}
			else
			{
				rvType = rvEnumKey;
				iValueName = ~iValueName;
			}
		}
		else if ((iErr = var3.GetString(szValue)) != S_OK)
		{
			if (fCloseRoot)
				W32::RegCloseKey(hkeyRoot);
			return iErr;
		}
	}
#ifndef UNICODE
	char rgbBuf[256];
	if (g_fWin9X)
	{
		char* pchKey = (char*)rgbBuf;
		unsigned int cb = W32::WideCharToMultiByte(CP_ACP, 0, szKey, -1, 0, 0, 0, 0);
		if (cb > sizeof(rgbBuf))
			pchKey = new char[cb];
		if ( ! pchKey )
			return E_OUTOFMEMORY;
		W32::WideCharToMultiByte(CP_ACP, 0, szKey, -1, pchKey, cb, 0, 0);
		iErr = W32::RegOpenKeyExA(hkeyRoot, pchKey, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkey);
		if (pchKey != rgbBuf)
			delete [] pchKey;
	}
	else
#endif
		iErr = W32::RegOpenKeyExW(hkeyRoot, szKey, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkey);
	if (fCloseRoot)
		W32::RegCloseKey(hkeyRoot);
	if (rvType == rvKeyPresent)
	{
		if (iErr == ERROR_SUCCESS)
		{
			args.Assign(fTrue);
			RegCloseKey(hkey);
		}
		else
			args.Assign(fFalse);
		return S_OK;
	}
	if (iErr != ERROR_SUCCESS)
		return DISP_E_BADINDEX;
	pbVal = rgbValBuf;
	Bool fDataInBuf = fFalse;
	const WCHAR* szReturn = 0;
#ifndef UNICODE
	if (g_fWin9X)
		cchData = sizeof(rgbValBuf)/sizeof(char);
	else
#endif
		cchData = sizeof(rgbValBuf)/sizeof(WCHAR);
	if (rvType == rvGetClass)
	{
		do
		{
#ifndef UNICODE
			if (g_fWin9X)
				iErr = W32::RegQueryInfoKeyA(hkey, (char*)pbVal, &cchData, 0, 0, 0, 0, 0 ,0, 0, 0, 0);
			else
#endif
				iErr = W32::RegQueryInfoKeyW(hkey, (WCHAR*)pbVal, &cchData, 0, 0, 0, 0, 0 ,0, 0, 0, 0);
		} while (iErr == ERROR_MORE_DATA && pbVal == rgbValBuf && (pbVal = (BYTE*)new char[cchData]) != 0);
		if (iErr != ERROR_SUCCESS)
		{
			if (cchData == 0)  // internal OS error, ignore if no class data: ERROR_INSUFFICIENT_BUFFER
				*((WCHAR*)(pbVal)) = 0;
			else
			{
				if (pbVal != rgbValBuf)
					delete [] pbVal;
				RegCloseKey(hkey);
				return DISP_E_BADINDEX;
			}
		}
		fDataInBuf = fTrue;
   }
	else if (rvType == rvEnumValue)
	{
#ifndef UNICODE
		if (g_fWin9X)
		{
			do
			{
				iErr = W32::RegEnumValueA(hkey, iValueName, (char*)rgbValBuf, &cchData, 0, &iValueType, 0, 0);
			} while (iErr == ERROR_MORE_DATA && pbVal == rgbValBuf && (pbVal = (BYTE*)new char[cchData]) != 0);
		}
		else
#endif
		{
			do
			{
				iErr = W32::RegEnumValueW(hkey, iValueName, (WCHAR*)pbVal, &cchData, 0, &iValueType, 0, 0);
			} while (iErr == ERROR_MORE_DATA && pbVal == rgbValBuf && (pbVal = (BYTE*)new WCHAR[cchData]) != 0);
		}
		if (iErr == ERROR_NO_MORE_ITEMS)
			args.Assign(fVoid);
		else if (iErr != ERROR_SUCCESS)
		{
			if (pbVal != rgbValBuf)
				delete [] pbVal;
			RegCloseKey(hkey);
			return iErr;
		}
		else
			fDataInBuf = fTrue;
   }
	else if (rvType == rvEnumKey)
	{
#ifndef UNICODE
		if (g_fWin9X)
			iErr = W32::RegEnumKeyExA(hkey, iValueName, (char*)rgbValBuf, &cchData, 0, 0, 0, 0);
		else
#endif
			iErr = W32::RegEnumKeyExW(hkey, iValueName, (WCHAR*)rgbValBuf, &cchData, 0, 0, 0, 0);
		if (iErr == ERROR_NO_MORE_ITEMS)
			args.Assign(fVoid);
		else if (iErr != ERROR_SUCCESS)
		{
			RegCloseKey(hkey);
			return iErr; // shouldn't happen
		}
		else
			fDataInBuf = fTrue;
	}
	else // rvType == rvGetValue
	{
		cbData = sizeof(rgbValBuf);
#ifndef UNICODE
		if (g_fWin9X)
		{
			char* pchValue = (char*)rgbBuf;
			unsigned int cb = W32::WideCharToMultiByte(CP_ACP, 0, szValue, -1, 0, 0, 0, 0);
			if (cb > sizeof(rgbBuf))
				pchValue = new char[cb];
			W32::WideCharToMultiByte(CP_ACP, 0, szValue, -1, pchValue, cb, 0, 0);
			do
			{
				iErr = W32::RegQueryValueExA(hkey, pchValue, 0, &iValueType, pbVal, &cbData);
			} while (iErr == ERROR_MORE_DATA && pbVal == rgbValBuf && (pbVal = new BYTE[cbData]) != 0);
			if (pchValue != rgbBuf)
				delete [] pchValue;
		}
		else
#endif
		{
			do
			{
				iErr = W32::RegQueryValueExW(hkey, szValue, 0, &iValueType, pbVal, &cbData);
			} while (iErr == ERROR_MORE_DATA && pbVal == rgbValBuf && (pbVal = new BYTE[cbData]) != 0);
		}
		if (iErr != ERROR_SUCCESS)
		{
			if (szValue != 0)
			{
				if (pbVal != rgbValBuf)
					delete [] pbVal;
				RegCloseKey(hkey);
				return DISP_E_BADINDEX;
			}
			else
				iValueType = REG_NONE;
		}
		switch(iValueType)
		{
		case REG_EXPAND_SZ:
		{
			WCHAR* szExpand = rgchExpandBuf;
#ifndef UNICODE
			if (g_fWin9X)
			{
				cchData = sizeof(rgchExpandBuf);
				do
				{
					cchData = W32::ExpandEnvironmentStringsA((const char*)pbVal, (char*)szExpand, cchData);
				} while (cchData > sizeof(rgchExpandBuf) && szExpand == rgchExpandBuf && (szExpand = (WCHAR*)new char[cchData]) != 0);
			}
			else
#endif
			{
				cchData = sizeof(rgchExpandBuf)/sizeof(WCHAR);
				do
				{
					cchData = W32::ExpandEnvironmentStringsW((const WCHAR*)pbVal, szExpand, cchData);
				} while (cchData > sizeof(rgchExpandBuf)/sizeof(WCHAR) && szExpand == rgchExpandBuf && (szExpand = new WCHAR[cchData]) != 0);
			}
			if (pbVal != rgbValBuf)
				delete [] pbVal;
			pbVal = (BYTE*)szExpand;
			fDataInBuf = fTrue;
			break;
		}
		case REG_MULTI_SZ:
#ifndef UNICODE
			if (g_fWin9X)
			{
				int cch = cbData;
				for (char* pch = (char*)pbVal; cch-- > 2; pch++)
					if (*pch == 0)
						*pch = '\n';
			}
			else
#endif
			{
				int cch = cbData/sizeof(WCHAR);
				for (WCHAR* pch = (WCHAR*)pbVal; cch-- > 2; pch++)
					if (*pch == 0)
						*pch = '\n';
			}
			fDataInBuf = fTrue;
			break;
		case REG_NONE:                       args.Assign(fVoid); break;
		case REG_DWORD:                      args.Assign(*(int*)pbVal); break; // same as REG_DWORD_LITTLE_ENDIAN
		case REG_SZ:                         fDataInBuf = fTrue; break;
		case REG_RESOURCE_LIST:              szReturn = L"(REG_RESOURCE_LIST)"; break;
		case REG_RESOURCE_REQUIREMENTS_LIST: szReturn = L"(REG_RESOURCE_REQUIREMENTS_LIST)"; break;
		case REG_FULL_RESOURCE_DESCRIPTOR:   szReturn = L"(REG_FULL_RESOURCE_DESCRIPTOR)"; break;
		case REG_LINK:                       szReturn = L"(REG_LINK)"; break;
		case REG_DWORD_BIG_ENDIAN:           szReturn = L"(REG_DWORD_BIG_ENDIAN)"; break;
		case REG_BINARY:                     szReturn = L"(REG_BINARY)"; break;
		default:                             szReturn = L"(REG_??)"; break;
		}
	}
	if (fDataInBuf)
	{
#ifndef UNICODE
		if (g_fWin9X)
			args.Assign((char*)pbVal);
		else
#endif
			args.Assign((WCHAR*)pbVal);
	}
	else if (szReturn != 0)
		args.Assign(szReturn);
	if (pbVal != rgbValBuf && pbVal != (BYTE*)rgchExpandBuf)
		delete [] pbVal;
	RegCloseKey(hkey);
	return S_OK;
}

DISPERR CAutoInstall::FileAttributes(CAutoArgs& args)
{
	DISPERR iErr;
	int iAttr;
	const WCHAR* szPath;
	if ((iErr = args[1].GetString(szPath)) != S_OK)
		return iErr;

	if (!szPath)
		return E_FAIL;

#ifndef UNICODE
	if (g_fWin9X)
	{
		char rgchPath[1024];
		W32::WideCharToMultiByte(CP_ACP, 0, szPath, -1, rgchPath, sizeof(rgchPath), 0, 0);
		iAttr = W32::GetFileAttributesA(rgchPath);
	}
	else
#endif
		iAttr = W32::GetFileAttributesW(szPath);
	args.Assign(iAttr);
	return S_OK;
}

DISPERR CAutoInstall::FileSize(CAutoArgs& args)
{
	// get the path out of the passed in parameter
	DISPERR iErr;
	const WCHAR* szPath;
	if ((iErr = args[1].GetString(szPath)) != S_OK)
		return iErr;

	if (!szPath)
		return E_FAIL;

	// open the file specified
	HANDLE hFile;
#ifndef UNICODE
	if (g_fWin9X)
	{
		char rgchPath[1024];
		W32::WideCharToMultiByte(CP_ACP, 0, szPath, -1, rgchPath, sizeof(rgchPath), 0, 0);
		hFile = W32::CreateFileA(rgchPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
				(FILE_ATTRIBUTE_NORMAL | (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), NULL);
	}
	else
#endif
	{
		hFile = W32::CreateFileW(szPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
				(FILE_ATTRIBUTE_NORMAL | (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			DWORD dwType = GetFileType(hFile);
			if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
			{
				W32::CloseHandle(hFile);
				hFile = INVALID_HANDLE_VALUE;
				SetLastError(ERROR_OPEN_FAILED);
			}
		}
	}
	
	// if failed to open the file bail
	if (hFile == INVALID_HANDLE_VALUE)
		return W32::GetLastError();

	// get the file size and close the file
	DWORD cbFile = W32::GetFileSize(hFile, 0);
	DWORD dwError = W32::GetLastError();
	W32::CloseHandle(hFile);

	// if there was an error reading the file size bail
	if (cbFile == 0xFFFFFFFF)
		return dwError;

	// return the file size
	args.Assign(cbFile);
	return S_OK;
}   // end of FileSize

DISPERR CAutoInstall::FileVersion(CAutoArgs& args)
{
	// get the path out of the passed in parameter
	DISPERR iErr;
	WCHAR* szPath;
	if ((iErr = args[1].GetString(szPath)) != S_OK)
		return iErr;
	Bool fLang = fFalse;    
	CTempBuffer<WCHAR, 128> bResult;
	DWORD dwSize = bResult.GetSize();
	if (args.Present(2) && (iErr = args[2].GetBool(fLang)) != S_OK)
		return iErr;
	do
		if (fLang)
			iErr = MsiGetFileVersionW(szPath, 0, 0, bResult, &dwSize);
		else
			iErr = MsiGetFileVersionW(szPath, bResult, &dwSize, 0, 0);
	while (iErr == ERROR_MORE_DATA && (bResult.SetSize(++dwSize), true));
	if (iErr == NOERROR)
		args.Assign((const WCHAR* )bResult);
	else if (iErr != ERROR_FILE_INVALID)
		return iErr;
	return S_OK;
}   // end of FileVersion

DISPERR CAutoInstall::FileHash(CAutoArgs& args)
{
	// get the path out of the passed in parameter
	DISPERR iErr;
	WCHAR* szPath;
	DWORD dwOptions = 0;
	DWORD dwPart    = 0;

	if ((iErr = args[1].GetString(szPath)) != S_OK)
		return iErr;

	if ((iErr = args[2].GetInt(dwOptions)) != S_OK)
		return iErr;

	MSIFILEHASHINFO sHash;
	memset(&sHash, 0, sizeof(sHash));
	BOOL fHashSet = FALSE;

	sHash.dwFileHashInfoSize = sizeof(MSIFILEHASHINFO);
	iErr = MsiGetFileHashW(szPath, dwOptions, &sHash);

	if (iErr != NOERROR)
		return iErr;
	
	MSIHANDLE pRec = MsiCreateRecord(4);

	if (pRec == 0)
		return DISP_E_TYPEMISMATCH;

	MsiRecordSetInteger(pRec, 1, sHash.dwData[0]);
	MsiRecordSetInteger(pRec, 2, sHash.dwData[1]);
	MsiRecordSetInteger(pRec, 3, sHash.dwData[2]);
	MsiRecordSetInteger(pRec, 4, sHash.dwData[3]);
	return args.Assign(new CAutoRecord(pRec));

}   // end of FileHash

DISPERR CAutoInstall::FileSignatureInfo(CAutoArgs& args)
{
	// get the path out of the passed in parameter
	DISPERR iErr = S_OK;
	WCHAR* szPath = NULL;
	DWORD  dwOptions = 0;
	unsigned int uiFormat = 0;
	unsigned int cb       = 0;

	if ((iErr = args[1].GetString(szPath)) != S_OK)
		return iErr;

	if ((iErr = args[2].GetInt(dwOptions)) != S_OK)
		return iErr;

	if ((iErr = args[3].GetInt(uiFormat)) != S_OK)
		return iErr;

	PCCERT_CONTEXT pcCert = NULL;
	CTempBuffer<BYTE, 256> bHash;
	HRESULT hr = S_OK;
	DWORD dwSize = 0;

	switch (uiFormat)
	{
	case 0: // certificate
		{
			hr = MsiGetFileSignatureInformationW(szPath, dwOptions, &pcCert, NULL, NULL);
			if (pcCert)
				dwSize = pcCert->cbCertEncoded;
			break;
		}
	case 1: // hash
		{
			dwSize = bHash.GetSize();
			
			do
			{
				hr = MsiGetFileSignatureInformationW(szPath, dwOptions, &pcCert, bHash, &dwSize);
			}
			while (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA) && (bHash.SetSize(++dwSize), true));
			
			break;
		}
	default: // shouldn't be here!
		return E_INVALIDARG;
	}

	if (S_OK != hr || !pcCert || !pcCert->pbCertEncoded)
		return HRESULT_FROM_WIN32(hr);

	SAFEARRAYBOUND saBound[1];
	saBound[0].lLbound = 0;
	saBound[0].cElements = dwSize;

	VARIANT *pvar = args.ResultVariant();
	pvar->vt = VT_UI1 | VT_ARRAY;
	pvar->parray = OLEAUT32::SafeArrayCreate(VT_UI1, 1, saBound);
	if (!pvar->parray)
	{
		CRYPT32::CertFreeCertificateContext(pcCert);
		return E_OUTOFMEMORY; // allocation failed
	}

	unsigned char FAR *pc = NULL;   
	if (S_OK != (hr = OLEAUT32::SafeArrayAccessData(pvar->parray, (void HUGEP* FAR*)&pc)) || !pc)
	{
		CRYPT32::CertFreeCertificateContext(pcCert);
		return (!pc) ? E_FAIL : hr;
	}
	memcpy(pc, (uiFormat == 0) ? pcCert->pbCertEncoded : bHash, dwSize);
	if (S_OK != (hr = OLEAUT32::SafeArrayUnaccessData(pvar->parray)))
	{
		CRYPT32::CertFreeCertificateContext(pcCert);
		return hr;
	}

	// must release certificate context
	if (pcCert)
		CRYPT32::CertFreeCertificateContext(pcCert);

	return S_OK;

}   // end of FileSignatureInfo

DISPERR CAutoInstall::Environment(CAutoArgs& args)
{
	DISPERR iErr;
	CTempBuffer<WCHAR, 1024> rgchBuf;
	rgchBuf[0] = 0;
	const WCHAR* szName;
	const WCHAR* szValue = 0;
	if ((iErr = args[1].GetString(szName)) != S_OK)
		return iErr;
	if (args.PropertySet() && args[0].GetType() != VT_EMPTY && (iErr = args[0].GetString(szValue)) != S_OK)
		return iErr;
#ifndef UNICODE
	if (g_fWin9X)
	{
		WCHAR rgchBuf9x[1024] = {0};
		char rgchName[256];
		W32::WideCharToMultiByte(CP_ACP, 0, szName, -1, rgchName, sizeof(rgchName), 0, 0);
		if (args.PropertySet())
		{
			W32::WideCharToMultiByte(CP_ACP, 0, szValue, -1, (char*)rgchBuf9x, sizeof(rgchBuf9x), 0, 0);
			if (!W32::SetEnvironmentVariableA(rgchName, (char*)rgchBuf9x))
				return DISP_E_BADINDEX;
		}
		else
		{
			W32::GetEnvironmentVariableA(rgchName, (char*)rgchBuf9x, sizeof(rgchBuf9x));
			args.Assign((char*)rgchBuf9x);
		}
	}
	else
#endif
	{
		if (args.PropertySet())
		{
			if (!W32::SetEnvironmentVariableW(szName, szValue))
				return DISP_E_BADINDEX;
		}
		else
		{
			DWORD dwRetSize = W32::GetEnvironmentVariableW(szName, rgchBuf, rgchBuf.GetSize());
			if (dwRetSize >= rgchBuf.GetSize())
			{
				rgchBuf.SetSize(dwRetSize);
				if (! (WCHAR*) rgchBuf)
				{
					return E_OUTOFMEMORY;
				}
				rgchBuf[0] = 0;
				dwRetSize = W32::GetEnvironmentVariableW(szName, rgchBuf, rgchBuf.GetSize());
			}
			// if dwRetSize == 0, then no environment variable -- return blank buffer
			args.Assign((const WCHAR*)rgchBuf);
		}
	}
	return S_OK;
}

//____________________________________________________________________________
//
// CAutoRecord automation implementation
//____________________________________________________________________________

DispatchEntry<CAutoRecord> AutoRecordTable[] = {
  DISPID_MsiRecord_FieldCount , HELPID_MsiRecord_FieldCount , aafPropRO, CAutoRecord::FieldCount, L"FieldCount",
  DISPID_MsiRecord_StringData , HELPID_MsiRecord_StringData , aafPropRW, CAutoRecord::StringData, L"StringData,Field",
  DISPID_MsiRecord_IntegerData, HELPID_MsiRecord_IntegerData, aafPropRW, CAutoRecord::IntegerData,L"IntegerData,Field",
  DISPID_MsiRecord_SetStream  , HELPID_MsiRecord_SetStream  , aafMethod, CAutoRecord::SetStream,  L"SetStream,Field,FilePath",
  DISPID_MsiRecord_ReadStream , HELPID_MsiRecord_ReadStream , aafMethod, CAutoRecord::ReadStream, L"ReadStream,Field,Length,Format",
  DISPID_MsiRecord_DataSize   , HELPID_MsiRecord_DataSize   , aafPropRO, CAutoRecord::DataSize,   L"DataSize,Field",
  DISPID_MsiRecord_IsNull     , HELPID_MsiRecord_IsNull     , aafPropRO, CAutoRecord::IsNull,     L"IsNull,Field",
  DISPID_MsiRecord_ClearData  , HELPID_MsiRecord_ClearData  , aafMethod, CAutoRecord::ClearData,  L"ClearData",
  DISPID_MsiRecord_FormatText , HELPID_MsiRecord_FormatText , aafMethod, CAutoRecord::FormatText, L"FormatText",
//DISPID_MsiRecord_SetNull    , HELPID_MsiRecord_SetNull    , aafMethod, CAutoRecord::SetNull,    L"SetNull,Field",
  DISPID_MsiRecord_GetHandle  , 0                           , aafPropRO, CAutoRecord::GetHandle,  L"",
};
const int AutoRecordCount = sizeof(AutoRecordTable)/sizeof(DispatchEntryBase);

CAutoRecord::CAutoRecord(MSIHANDLE hRecord)
 : CAutoBase(*AutoRecordTable, AutoRecordCount, IID_IMsiApiRecord, hRecord)
{
}

DISPERR CAutoRecord::StringData(CAutoArgs& args)
{
	DISPERR iErr;
	unsigned int iField;
	if ((iErr = args[1].GetInt(iField)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		const WCHAR* szData = 0;
		if (var.GetType()!=VT_EMPTY && (iErr = var.GetString(szData)) != S_OK)
			return iErr;
		return MsiRecordSetStringW(m_hMsi, iField, szData);
	}
	else
	{
		CTempBuffer<WCHAR, 1024> bValue;
		DWORD dwSize = bValue.GetSize();
		do
			iErr = MsiRecordGetStringW(m_hMsi, iField, bValue, &dwSize);
		while (iErr == ERROR_MORE_DATA && (bValue.SetSize(++dwSize), true));
		return iErr == S_OK ? args.Assign((const WCHAR* )bValue) : iErr;
	}
}

DISPERR CAutoRecord::IntegerData(CAutoArgs& args)
{
	DISPERR iErr;
	unsigned int iField;
	int iValue;
	if ((iErr = args[1].GetInt(iField)) != S_OK)
		return iErr;
	if (!args.PropertySet())
		return args.Assign(MsiRecordGetInteger(m_hMsi, iField));
	else if ((iErr = args[0].GetInt(iValue)) != S_OK)
		return iErr;
	else
		return MsiRecordSetInteger(m_hMsi, iField, iValue);
}

DISPERR CAutoRecord::SetStream(CAutoArgs& args)
{
	DISPERR iErr;
	unsigned int iField;
	const WCHAR* szData;
	if ((iErr = args[1].GetInt(iField)) != S_OK)
		return iErr;
	if (!args.Present(2) || args[2].IsNull())
		szData = 0;  // request to reset stream
	else if ((iErr = args[2].GetString(szData)) != S_OK)
		return iErr;
	return MsiRecordSetStreamW(m_hMsi, iField, szData);
}

DISPERR CAutoRecord::ReadStream(CAutoArgs& args)
{
	DISPERR iErr;
	unsigned int iField;
	unsigned int cb;
	unsigned int iFormat;
	if ((iErr = args[1].GetInt(iField)) != S_OK
	||  (iErr = args[2].GetInt(cb)) != S_OK
	||  (iErr = args[3].GetInt(iFormat)) != S_OK)
		return iErr;
	unsigned long cbData = cb;
	char* rgbBuffer = 0;
	char* pch;
	BSTR bstr = 0;
	int iData = 0;
	if (iFormat > 3)
		return DISP_E_BADINDEX;
	if (MsiRecordIsNull(m_hMsi, iField))
		return S_OK;   // null or non-existent field, variant is cleared to Empty
	// check errors and get remaining count, may resize count smaller, no data transfer
	if ((iErr = MsiRecordReadStream(m_hMsi, iField, 0, &cbData)) != ERROR_SUCCESS)
		return iErr;
	if (cbData == 0)
		return S_OK;   // no more bytes, variant is cleared to Empty
	if (cbData > cb)  // if more bytes available than requested
		cbData = cb;   // restore original count
	OLECHAR* pwch;
	int cwch;
	switch (iFormat)
	{
	case 0:
		if (cbData > 4)
			return DISP_E_BADINDEX;
		pch = (char*)&iData;
		MsiRecordReadStream(m_hMsi, iField, (char*)&iData, &cbData);  // assumes Intel byte ordering
		return args.Assign(iData);
	case 1:
		rgbBuffer = new char[cbData];  //FUTURE optimize to local buffer if not large
		if (!rgbBuffer)
			return E_OUTOFMEMORY;
		MsiRecordReadStream(m_hMsi, iField, rgbBuffer, &cbData);
		bstr = OLEAUT32::SysAllocStringLen(0, cbData);
		if (!bstr)
			return E_OUTOFMEMORY;
		for (pwch = bstr, pch = rgbBuffer, cb = cbData; cb--; )
			*pwch++ = *pch++;
		*pwch = 0;
		delete [] rgbBuffer;
		return args.ReturnBSTR(bstr);
	case 2:
		rgbBuffer = new char[cbData];
		if (!rgbBuffer)
			return E_OUTOFMEMORY;
		MsiRecordReadStream(m_hMsi, iField, rgbBuffer, &cbData);
		cwch = W32::MultiByteToWideChar(CP_ACP, 0, rgbBuffer, cbData, 0, 0);
		bstr = OLEAUT32::SysAllocStringLen(0, cwch);
		if (!bstr)
			return E_OUTOFMEMORY;
		W32::MultiByteToWideChar(CP_ACP, 0, rgbBuffer, cbData, bstr, cwch);
		bstr[cwch] = 0;
		delete [] rgbBuffer;
		return args.ReturnBSTR(bstr);
	case 3:
		bstr = OLEAUT32::SysAllocStringLen(0, (cbData+1)/2);
		if (!bstr)
			return E_OUTOFMEMORY;
		MsiRecordReadStream(m_hMsi, iField, (char*)bstr, &cbData);
		if (cbData & 1)      // if odd byte count, pad last wide char
			((char*)bstr)[cbData] = 0;
		return args.ReturnBSTR(bstr);
	default: return E_FAIL; // can't happen
	}
}

DISPERR CAutoRecord::FieldCount(CAutoArgs& args)
{
	return args.Assign(MsiRecordGetFieldCount(m_hMsi));
}

DISPERR CAutoRecord::IsNull(CAutoArgs& args)
{
	DISPERR iErr;
	unsigned int iField;
	if ((iErr = args[1].GetInt(iField)) != S_OK)
		return iErr;
	return args.Assign((Bool)MsiRecordIsNull(m_hMsi, iField));
}

DISPERR CAutoRecord::DataSize(CAutoArgs& args)
{
	DISPERR iErr;
	unsigned int iField;
	if ((iErr = args[1].GetInt(iField)) != S_OK)
		return iErr;
	return args.Assign(MsiRecordDataSize(m_hMsi, iField));
}

DISPERR CAutoRecord::ClearData(CAutoArgs& /*args*/)
{
	return MsiRecordClearData(m_hMsi);
}

DISPERR CAutoRecord::FormatText(CAutoArgs& args)
{
	CTempBuffer<WCHAR, MAX_PATH> bResult;
	DWORD dwSize = bResult.GetSize();
	DISPERR iErr;
	do
		iErr = MsiFormatRecordW(0, m_hMsi, bResult, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bResult.SetSize(++dwSize), true));
	if (iErr != ERROR_SUCCESS)
		return iErr;
	return args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoRecord::GetHandle(CAutoArgs& args)
{
	return args.Assign((long)CAutoBase::GetHandle());
}


//____________________________________________________________________________
//
// CAutoDatabase implementation
//____________________________________________________________________________

DispatchEntry<CAutoDatabase> AutoDatabaseTable[] = {
  DISPID_MsiDatabase_DatabaseState     , HELPID_MsiDatabase_DatabaseState     , aafPropRO, CAutoDatabase::DatabaseState,      L"DatabaseState",
  DISPID_MsiDatabase_SummaryInformation, HELPID_MsiDatabase_SummaryInformation, aafPropRO, CAutoDatabase::SummaryInformation, L"SummaryInformation,UpdateCount",
  DISPID_MsiDatabase_OpenView          , HELPID_MsiDatabase_OpenView          , aafMethod, CAutoDatabase::OpenView,           L"OpenView,Sql",
  DISPID_MsiDatabase_Commit            , HELPID_MsiDatabase_Commit            , aafMethod, CAutoDatabase::Commit,             L"Commit",
  DISPID_MsiDatabase_PrimaryKeys       , HELPID_MsiDatabase_PrimaryKeys       , aafMethod, CAutoDatabase::PrimaryKeys,        L"PrimaryKeys,Table",
  DISPID_MsiDatabase_Import            , HELPID_MsiDatabase_Import            , aafMethod, CAutoDatabase::Import,             L"Import,Folder,File",
  DISPID_MsiDatabase_Export            , HELPID_MsiDatabase_Export            , aafMethod, CAutoDatabase::Export,             L"Export,Table,Folder,File",
  DISPID_MsiDatabase_Merge             , HELPID_MsiDatabase_Merge             , aafMethod, CAutoDatabase::Merge,              L"Merge,Database,ErrorTable",
  DISPID_MsiDatabase_GenerateTransform , HELPID_MsiDatabase_GenerateTransform , aafMethod, CAutoDatabase::GenerateTransform,  L"GenerateTransform,ReferenceDatabase,TransformFile",
  DISPID_MsiDatabase_ApplyTransform    , HELPID_MsiDatabase_ApplyTransform    , aafMethod, CAutoDatabase::ApplyTransform,     L"ApplyTransform,TransformFile,ErrorConditions",
  DISPID_MsiDatabase_EnableUIPreview   , HELPID_MsiDatabase_EnableUIPreview   , aafMethod, CAutoDatabase::EnableUIPreview,    L"EnableUIPreview",
  DISPID_MsiDatabase_TablePersistent   , HELPID_MsiDatabase_TablePersistent   , aafPropRO, CAutoDatabase::TablePersistent,    L"TablePersistent,Table",
  DISPID_MsiDatabase_CreateTransformSummaryInfo , HELPID_MsiDatabase_CreateTransformSummaryInfo , aafMethod, CAutoDatabase::CreateTransformSummaryInfo,  L"CreateTransformSummaryInfo,ReferenceDatabase,TransformFile,ErrorConditions,Validation",
  DISPID_MsiDatabase_GetHandle         , 0                                    , aafPropRO, CAutoDatabase::GetHandle,  L"",
};
const int AutoDatabaseCount = sizeof(AutoDatabaseTable)/sizeof(DispatchEntryBase);

CAutoDatabase::CAutoDatabase(MSIHANDLE hDatabase)
 : CAutoBase(*AutoDatabaseTable, AutoDatabaseCount, IID_IMsiApiDatabase, hDatabase)
{
}

DISPERR CAutoDatabase::OpenView(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szQuery;
	if ((iErr = args[1].GetString(szQuery)) != S_OK)
		return iErr;
	MSIHANDLE hView;
	if ((iErr = MsiDatabaseOpenViewW(m_hMsi, szQuery, &hView)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(new CAutoView(hView));
}

DISPERR CAutoDatabase::PrimaryKeys(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szTable;
	if ((iErr = args[1].GetString(szTable)) != S_OK)
		return iErr;
	MSIHANDLE hRecord;
	if ((iErr = MsiDatabaseGetPrimaryKeysW(m_hMsi, szTable, &hRecord)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(new CAutoRecord(hRecord));
}

DISPERR CAutoDatabase::Import(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szFolder;
	const WCHAR* szFile;
	if ((iErr = args[1].GetString(szFolder)) != S_OK
	||  (iErr = args[2].GetString(szFile)) != S_OK)
		return iErr;
	return MsiDatabaseImportW(m_hMsi, szFolder, szFile);
}

DISPERR CAutoDatabase::Export(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szTable;
	const WCHAR* szFolder;
	const WCHAR* szFile;
	if ((iErr = args[1].GetString(szTable)) != S_OK
	||  (iErr = args[2].GetString(szFolder)) != S_OK
	||  (iErr = args[3].GetString(szFile)) != S_OK)
		return iErr;
	return MsiDatabaseExportW(m_hMsi, szTable, szFolder, szFile);
}

DISPERR CAutoDatabase::Merge(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szTable = 0;
	if (args.Present(2) && (iErr = args[2].GetString(szTable)) != S_OK)
		return iErr;
	iErr = MsiDatabaseMergeW(m_hMsi, args[1].GetHandle(IID_IMsiApiDatabase), szTable);
	if (iErr == ERROR_FUNCTION_FAILED) // merge completed, but conflicts were found
		return args.Assign(fTrue);
	else if (iErr == ERROR_SUCCESS)    // no conflicts found
		return args.Assign(fFalse);
	else                               // other error, such as schema mismatch
		return iErr;
}

DISPERR CAutoDatabase::GenerateTransform(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szTransformFile = 0;
	if (args.Present(2) && (iErr = args[2].GetString(szTransformFile)) != S_OK)
		return iErr;
	iErr = MsiDatabaseGenerateTransformW(m_hMsi, args[1].GetHandle(IID_IMsiApiDatabase), szTransformFile, 0, 0);
	if (iErr == NOERROR)
		return args.Assign(fTrue);
	if (iErr == ERROR_NO_DATA)
		return args.Assign(fFalse);
	return iErr;
}

DISPERR CAutoDatabase::CreateTransformSummaryInfo(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szTransformFile;
	int iErrorConditions;
	int iValidation;
	if ((iErr = args[2].GetString(szTransformFile)) != S_OK
	||  (iErr = args[3].GetInt(iErrorConditions)) != S_OK
	||  (iErr = args[4].GetInt(iValidation)) != S_OK)
		return iErr;
	return MsiCreateTransformSummaryInfoW(m_hMsi, args[1].GetHandle(IID_IMsiApiDatabase), szTransformFile, iErrorConditions, iValidation);
}

DISPERR CAutoDatabase::ApplyTransform(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szTransformFile;
	int iErrorConditions;
	if ((iErr = args[1].GetString(szTransformFile)) != S_OK
	||  (iErr = args[2].GetInt(iErrorConditions)) != S_OK)
		return iErr;
	return MsiDatabaseApplyTransformW(m_hMsi, szTransformFile, iErrorConditions);
}

DISPERR CAutoDatabase::Commit(CAutoArgs& /*args*/)
{
	return MsiDatabaseCommit(m_hMsi);
}

DISPERR CAutoDatabase::DatabaseState(CAutoArgs& args)
{
	return args.Assign((int)MsiGetDatabaseState(m_hMsi));
}

DISPERR CAutoDatabase::SummaryInformation(CAutoArgs& args)
{
	DISPERR iErr;
	MSIHANDLE hSummaryInfo;
	UINT cUpdate = 0;
	if (args.Present(1) && (iErr = args[1].GetInt(cUpdate)) != S_OK)
		return iErr;
	if ((iErr = MsiGetSummaryInformationW(m_hMsi, 0, cUpdate, &hSummaryInfo)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(new CAutoSummaryInfo(hSummaryInfo));
}

DISPERR CAutoDatabase::EnableUIPreview(CAutoArgs& args)
{
	DISPERR iErr;
	MSIHANDLE hPreview;
	if ((iErr = MsiEnableUIPreview(m_hMsi, &hPreview)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(new CAutoUIPreview(hPreview));
}

DISPERR CAutoDatabase::TablePersistent(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szTable;
	if ((iErr = args[1].GetString(szTable)) != S_OK)
		return iErr;
	return args.Assign((int)MsiDatabaseIsTablePersistentW(m_hMsi, szTable));
}

DISPERR CAutoDatabase::GetHandle(CAutoArgs& args)
{
	return args.Assign((long)CAutoBase::GetHandle());
}

//____________________________________________________________________________
//
// CAutoView automation implementation
//____________________________________________________________________________

DispatchEntry<CAutoView> AutoViewTable[] = {
  DISPID_MsiView_Execute   , HELPID_MsiView_Execute   , aafMethod, CAutoView::Execute ,  L"Execute,Params",
  DISPID_MsiView_Fetch     , HELPID_MsiView_Fetch     , aafMethod, CAutoView::Fetch   ,  L"Fetch",
  DISPID_MsiView_Modify    , HELPID_MsiView_Modify    , aafMethod, CAutoView::Modify  ,  L"Modify,Mode,Record",
  DISPID_MsiView_ColumnInfo, HELPID_MsiView_ColumnInfo, aafPropRO, CAutoView::ColumnInfo,L"ColumnInfo,Info",
  DISPID_MsiView_Close     , HELPID_MsiView_Close     , aafMethod, CAutoView::Close   ,  L"Close",
  DISPID_MsiView_GetError  , HELPID_MsiView_GetError  , aafMethod, CAutoView::GetError,  L"GetError",
};
const int AutoViewCount = sizeof(AutoViewTable)/sizeof(DispatchEntryBase);

CAutoView::CAutoView(MSIHANDLE hView)
 : CAutoBase(*AutoViewTable, AutoViewCount, IID_IMsiApiView, hView)
{
}

DISPERR CAutoView::Execute(CAutoArgs& args)
{
	MSIHANDLE hRecord = 0;
	if (args.Present(1))
		hRecord = args[1].GetHandle(IID_IMsiApiRecord);
	return MsiViewExecute(m_hMsi, hRecord);
}

DISPERR CAutoView::Fetch(CAutoArgs& args)
{
	MSIHANDLE hRecord;
	IDispatch* piDispatch;
	DISPERR iErr = MsiViewFetch(m_hMsi, &hRecord);
	if (iErr == ERROR_NO_MORE_ITEMS)
		piDispatch = 0;
	else if (iErr == ERROR_SUCCESS)
		piDispatch = new CAutoRecord(hRecord);
	else
		return iErr;
	return args.Assign(piDispatch);
}

DISPERR CAutoView::Modify(CAutoArgs& args)
{
	DISPERR iErr;
	int iMode;
	if ((iErr = args[1].GetInt(iMode)) != S_OK)
		return iErr;
	return MsiViewModify(m_hMsi, (MSIMODIFY)iMode, args[2].GetHandle(IID_IMsiApiRecord));
}

DISPERR CAutoView::ColumnInfo(CAutoArgs& args)
{
	DISPERR iErr;
	int iMode;
	MSIHANDLE hRecord;
	if ((iErr = args[1].GetInt(iMode)) != S_OK
	||  (iErr = MsiViewGetColumnInfo(m_hMsi, (MSICOLINFO)iMode, &hRecord)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(new CAutoRecord(hRecord));
}

DISPERR CAutoView::Close(CAutoArgs& /*args*/)
{
	return MsiViewClose(m_hMsi);
}

const int cchColumnNameMax = 64;
DISPERR CAutoView::GetError(CAutoArgs& args)
{
	CTempBuffer<WCHAR, cchColumnNameMax+2> bColumn;
	DWORD dwSize = bColumn.GetSize();
	MSIDBERROR iError;
	do
	{
		dwSize-= 2;// extra work to pack two digits into buffer
		iError = MsiViewGetErrorW(m_hMsi, (WCHAR*)bColumn + 2, &dwSize);
		dwSize += 2; // in case of overflow, need extra space for digits
	} while (iError == MSIDBERROR_MOREDATA && (bColumn.SetSize(++dwSize), true));
	if (iError == MSIDBERROR_FUNCTIONERROR)
		return E_FAIL;
	if (iError == MSIDBERROR_INVALIDARG)
		return DISP_E_BADINDEX;
	bColumn[0] = (WCHAR)(iError/10 + '0');
	bColumn[1] = (WCHAR)(iError%10 + '0');
	return args.Assign((const WCHAR* )bColumn);
}

//____________________________________________________________________________
//
// CAutoSummaryInfo automation implementation
//____________________________________________________________________________

DispatchEntry<CAutoSummaryInfo> AutoSummaryInfoTable[] = {
  DISPID_MsiSummaryInfo_Property     , HELPID_MsiSummaryInfo_Property     , aafPropRW, CAutoSummaryInfo::Property,      L"Property,Pid",
  DISPID_MsiSummaryInfo_PropertyCount, HELPID_MsiSummaryInfo_PropertyCount, aafPropRO, CAutoSummaryInfo::PropertyCount, L"PropertyCount",
  DISPID_MsiSummaryInfo_Persist      , HELPID_MsiSummaryInfo_Persist      , aafMethod, CAutoSummaryInfo::Persist,       L"Persist",
};
const int AutoSummaryInfoCount = sizeof(AutoSummaryInfoTable)/sizeof(DispatchEntryBase);

CAutoSummaryInfo::CAutoSummaryInfo(MSIHANDLE hSummaryInfo)
 : CAutoBase(*AutoSummaryInfoTable, AutoSummaryInfoCount, IID_IMsiApiSummaryInfo, hSummaryInfo)
{
}

static DISPERR VariantTimeToFileTime(double vtime, FILETIME* pfiletime)
{
	SYSTEMTIME stime;
	FILETIME ftime;
	if (!OLEAUT32::VariantTimeToSystemTime(vtime, &stime)
	||   !W32::SystemTimeToFileTime(&stime, &ftime)
	||   !W32::LocalFileTimeToFileTime(&ftime, pfiletime))
		return DISP_E_TYPEMISMATCH;
	return S_OK;
}

static DISPERR FileTimeToVariantTime(FILETIME* pfiletime, double* pvtime)
{
	SYSTEMTIME stime;
	FILETIME ftime;
	if (!W32::FileTimeToLocalFileTime(pfiletime, &ftime)
	||   !W32::FileTimeToSystemTime(&ftime, &stime)
	||   !OLEAUT32::SystemTimeToVariantTime(&stime, pvtime))
		return DISP_E_TYPEMISMATCH;
	return S_OK;
}

DISPERR CAutoSummaryInfo::Property(CAutoArgs& args)
{
	DISPERR iErr;
	UINT iProperty;
	if ((iErr = args[1].GetInt(iProperty)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		UINT iDataType = var.GetType();
		int  iValue = 0;
		FILETIME ftValue;
		WCHAR* szValue = NULL;
		switch (iDataType)
		{
		case VT_EMPTY:           break;
		case VT_I4:              iValue = var.lVal;       break;
		case VT_I4 | VT_BYREF:   iValue = *var.plVal;     break;
		case VT_I2:              iValue = var.iVal;       iDataType = VT_I4;    break;
		case VT_I2 | VT_BYREF:   iValue = *var.piVal;     iDataType = VT_I4;    break;
		case VT_BSTR:            szValue = var.bstrVal;   iDataType = VT_LPSTR; break;
		case VT_BSTR | VT_BYREF: szValue = *var.pbstrVal; iDataType = VT_LPSTR; break;
		case VT_R8:
		case VT_DATE:            VariantTimeToFileTime(var.dblVal, &ftValue);   iDataType = VT_FILETIME; break;
		case VT_R8 | VT_BYREF:
		case VT_DATE | VT_BYREF: VariantTimeToFileTime(*var.pdblVal, &ftValue); iDataType = VT_FILETIME; break;
		default: return DISP_E_TYPEMISMATCH;
		};
		return MsiSummaryInfoSetPropertyW(m_hMsi, iProperty, iDataType, iValue, &ftValue, szValue);
	}
	else
	{
		UINT iDataType;
		FILETIME ftValue;
		double vtime;
		int iValue;

		CTempBuffer<WCHAR, MAX_PATH> bValue;
		DWORD dwSize = bValue.GetSize();
		do
			iErr = MsiSummaryInfoGetPropertyW(m_hMsi, iProperty, &iDataType, &iValue, &ftValue, bValue, &dwSize);
		while (iErr == ERROR_MORE_DATA && (bValue.SetSize(++dwSize), true));
		if (iErr != ERROR_SUCCESS)
			return iErr;

		switch (iDataType)
		{
		case VT_I2:
		case VT_I4:       return args.Assign(iValue);
		case VT_LPSTR:    return args.Assign((const WCHAR* )bValue);
		case VT_FILETIME: FileTimeToVariantTime(&ftValue, &vtime); return args.Assign(vtime);
		case VT_EMPTY:    return S_OK;   // variant already set to VT_EMPTY;
		default:          return E_FAIL; // shouldn't happen
		};
	}
}

DISPERR CAutoSummaryInfo::PropertyCount(CAutoArgs& args)
{
	DISPERR iErr;
	UINT cProperties;
	if ((iErr = MsiSummaryInfoGetPropertyCount(m_hMsi, &cProperties)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(cProperties);
}

DISPERR CAutoSummaryInfo::Persist(CAutoArgs& /*args*/)
{
	return MsiSummaryInfoPersist(m_hMsi);
}

//____________________________________________________________________________
//
// CAutoEngine automation implementation
//____________________________________________________________________________

DispatchEntry<CAutoEngine> AutoEngineTable[] = {
  DISPID_MsiEngine_Application          , HELPID_MsiEngine_Application          , aafPropRO, CAutoEngine::Application          , L"Installer",
  DISPID_MsiEngine_Property             , HELPID_MsiEngine_Property             , aafPropRW, CAutoEngine::Property             , L"Property,Name",
  DISPID_MsiEngine_Language             , HELPID_MsiEngine_Language             , aafPropRO, CAutoEngine::Language             , L"Language",
  DISPID_MsiEngine_Mode                 , HELPID_MsiEngine_Mode                 , aafPropRW, CAutoEngine::Mode                 , L"Mode,Flag",
  DISPID_MsiEngine_Database             , HELPID_MsiEngine_Database             , aafPropRO, CAutoEngine::Database             , L"Database",
  DISPID_MsiEngine_SourcePath           , HELPID_MsiEngine_SourcePath           , aafPropRO, CAutoEngine::SourcePath           , L"SourcePath,Folder",
  DISPID_MsiEngine_TargetPath           , HELPID_MsiEngine_TargetPath           , aafPropRW, CAutoEngine::TargetPath           , L"TargetPath,Folder",
  DISPID_MsiEngine_DoAction             , HELPID_MsiEngine_DoAction             , aafMethod, CAutoEngine::DoAction             , L"DoAction,Action",
  DISPID_MsiEngine_Sequence             , HELPID_MsiEngine_Sequence             , aafMethod, CAutoEngine::Sequence             , L"Sequence,Table,Mode",
  DISPID_MsiEngine_EvaluateCondition    , HELPID_MsiEngine_EvaluateCondition    , aafMethod, CAutoEngine::EvaluateCondition    , L"EvaluateCondition,Expression",
  DISPID_MsiEngine_FormatRecord         , HELPID_MsiEngine_FormatRecord         , aafMethod, CAutoEngine::FormatRecord         , L"FormatRecord,Record",
  DISPID_MsiEngine_Message              , HELPID_MsiEngine_Message              , aafMethod, CAutoEngine::Message              , L"Message,Kind,Record",
  DISPID_MsiEngine_FeatureCurrentState  , HELPID_MsiEngine_FeatureCurrentState  , aafPropRO, CAutoEngine::FeatureCurrentState  , L"FeatureCurrentState,Feature",
  DISPID_MsiEngine_FeatureRequestState  , HELPID_MsiEngine_FeatureRequestState  , aafPropRW, CAutoEngine::FeatureRequestState  , L"FeatureRequestState,Feature",
  DISPID_MsiEngine_FeatureValidStates   , HELPID_MsiEngine_FeatureValidStates   , aafPropRO, CAutoEngine::FeatureValidStates   , L"FeatureValidStates,Feature",
  DISPID_MsiEngine_FeatureCost          , HELPID_MsiEngine_FeatureCost          , aafPropRO, CAutoEngine::FeatureCost          , L"FeatureCost,Feature,CostTree,State",
  DISPID_MsiEngine_ComponentCurrentState, HELPID_MsiEngine_ComponentCurrentState, aafPropRO, CAutoEngine::ComponentCurrentState, L"ComponentCurrentState,Component",
  DISPID_MsiEngine_ComponentRequestState, HELPID_MsiEngine_ComponentRequestState, aafPropRW, CAutoEngine::ComponentRequestState, L"ComponentRequestState,Component",
  DISPID_MsiEngine_SetInstallLevel      , HELPID_MsiEngine_SetInstallLevel      , aafMethod, CAutoEngine::SetInstallLevel      , L"SetInstallLevel,Level",
  DISPID_MsiEngine_VerifyDiskSpace      , HELPID_MsiEngine_VerifyDiskSpace      , aafPropRO, CAutoEngine::VerifyDiskSpace      , L"VerifyDiskSpace",
  DISPID_MsiEngine_ProductProperty      , HELPID_MsiEngine_ProductProperty      , aafPropRO, CAutoEngine::ProductProperty      , L"ProductProperty,Property",
  DISPID_MsiEngine_FeatureInfo          , HELPID_MsiEngine_FeatureInfo          , aafPropRO, CAutoEngine::FeatureInfo          , L"FeatureInfo,Feature",
  DISPID_MsiEngine_ComponentCosts       , HELPID_MsiEngine_ComponentCosts       , aafPropRO, CAutoEngine::ComponentCosts       , L"ComponentCosts,Component,State",
};
const int AutoEngineCount = sizeof(AutoEngineTable)/sizeof(DispatchEntryBase);

IDispatch* CreateAutoEngine(MSIHANDLE hEngine)
{
	return CreateAutoEngineEx(hEngine, 0);
}

IDispatch* CreateAutoEngineEx(MSIHANDLE hEngine, DWORD dwThreadId)
{
	CAutoInstall* piInstaller = CreateAutoInstall();
	CAutoEngine*  piAutoEngine = new CAutoEngine(hEngine, piInstaller, dwThreadId);
	piInstaller->Release();
	return piAutoEngine;
}

CAutoEngine::CAutoEngine(MSIHANDLE hEngine, CAutoInstall* piInstaller, DWORD dwThreadId)
 : m_piInstaller(piInstaller), m_dwThreadId(dwThreadId)
 , CAutoBase(*AutoEngineTable, AutoEngineCount, IID_IMsiApiEngine, hEngine)
{
	piInstaller->AddRef();
}

unsigned long CAutoEngine::Release()
{
	if (m_iRefCnt == 1)
		m_piInstaller->Release();
	return CAutoBase::Release();
}

DISPERR CAutoEngine::Application(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	m_piInstaller->AddRef();
	return args.Assign(m_piInstaller);
}

DISPERR CAutoEngine::Property(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szProperty;
	if ((iErr = args[1].GetString(szProperty)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		const WCHAR* szValue = 0;
		if (var.GetType() != VT_EMPTY && (iErr = var.GetString(szValue)) != S_OK)
			return iErr;
		return MsiSetPropertyW(m_hMsi, szProperty, szValue);
	}
	else
	{
		CTempBuffer<WCHAR, 1024> bValue;
		DWORD dwSize = bValue.GetSize();
		UINT iStat;
		do
			iStat = MsiGetPropertyW(m_hMsi, szProperty, bValue, &dwSize);
		while (iStat == ERROR_MORE_DATA  && (bValue.SetSize(++dwSize), true));
		if (iStat != ERROR_SUCCESS)
			return iStat;
		return args.Assign((const WCHAR* )bValue);
	}
}

DISPERR CAutoEngine::Language(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	return args.Assign(MsiGetLanguage(m_hMsi));
}

DISPERR CAutoEngine::Mode(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	int iMode;
	if ((iErr = args[1].GetInt(iMode)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		Bool fSet;
		if ((iErr = args[0].GetBool(fSet)) != S_OK)
			return iErr;
		return MsiSetMode(m_hMsi, (MSIRUNMODE)iMode, fSet);
	}
	else
	{
		return args.Assign((Bool)MsiGetMode(m_hMsi, (MSIRUNMODE)iMode));
	}
}

DISPERR CAutoEngine::Database(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	MSIHANDLE hDatabase = MsiGetActiveDatabase(m_hMsi);
	if (hDatabase == 0)
		return E_FAIL; //FUTURE could use different error code?
	return args.Assign(new CAutoDatabase(hDatabase));
}

DISPERR CAutoEngine::SourcePath(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	CTempBuffer<WCHAR, MAX_PATH> bPath;
	DWORD dwSize = bPath.GetSize();
	const WCHAR* szDir;
	if ((iErr = args[1].GetString(szDir)) != S_OK)
		return iErr;
	do
		iErr = MsiGetSourcePathW(m_hMsi, szDir, bPath, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bPath.SetSize(++dwSize), true));
	if (iErr != ERROR_SUCCESS)
		return iErr;
	return args.Assign((const WCHAR* )bPath);
}

DISPERR CAutoEngine::TargetPath(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szDir;
	if ((iErr = args[1].GetString(szDir)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		const WCHAR* szPath;
		if ((iErr = args[0].GetString(szPath)) != S_OK)
			return iErr;
		return MsiSetTargetPathW(m_hMsi, szDir, szPath);
	}
	else
	{
		CTempBuffer<WCHAR, MAX_PATH> bPath;
		DWORD dwSize = bPath.GetSize();
		do
			iErr = MsiGetTargetPathW(m_hMsi, szDir, bPath, &dwSize);
		while (iErr == ERROR_MORE_DATA && (bPath.SetSize(++dwSize), true));
		if (iErr != ERROR_SUCCESS)
			return iErr;
		return args.Assign((const WCHAR* )bPath);
	}
}

// constant returned when none of the ies error codes apply. Trapped by automation layer
// and never returned to user
const int iesCallError = -1;

iesEnum MapErrorReturnToAction(UINT iRet)
{
	switch (iRet)
	{
	case ERROR_FUNCTION_NOT_CALLED:    return iesNoAction;
	case ERROR_SUCCESS:                return iesSuccess;
	case ERROR_INSTALL_USEREXIT:       return iesUserExit;
	case ERROR_INSTALL_FAILURE:        return iesFailure;
	case ERROR_INSTALL_SUSPEND:        return iesSuspend;
	case ERROR_MORE_DATA:              return iesFinished;
	case ERROR_INVALID_HANDLE_STATE:   return iesWrongState;
	case ERROR_INVALID_DATA:           return iesBadActionData;
	default:                           return (iesEnum)iesCallError;
	}
}

DISPERR CAutoEngine::DoAction(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szAction;
	if ((iErr = args[1].GetString(szAction)) != S_OK)
		return iErr;
	iesEnum ies = MapErrorReturnToAction(MsiDoActionW(m_hMsi, szAction));
	return ies == iesCallError ? E_FAIL : args.Assign((int)ies);
}

DISPERR CAutoEngine::Sequence(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szTable;
	if ((iErr = args[1].GetString(szTable)) != S_OK)
		return iErr;
	int iSequence = 0;
	if (args.Present(2) && (iErr = args[2].GetInt(iSequence)) != S_OK)  // reserved integer argument
		return iErr;
	iesEnum ies = MapErrorReturnToAction(MsiSequenceW(m_hMsi, szTable, iSequence));
	return ies == iesCallError ? E_FAIL : args.Assign((int)ies);
}

DISPERR CAutoEngine::EvaluateCondition(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szExpr;
	if ((iErr = args[1].GetString(szExpr)) != S_OK)
		return iErr;
	return args.Assign((int)MsiEvaluateConditionW(m_hMsi, szExpr));
}

DISPERR CAutoEngine::FormatRecord(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	CTempBuffer<WCHAR, MAX_PATH> bResult;
	DWORD dwSize = bResult.GetSize();
	DISPERR iErr;
	do
		iErr = MsiFormatRecordW(m_hMsi, args[1].GetHandle(IID_IMsiApiRecord), bResult, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bResult.SetSize(++dwSize), true));
	if (iErr != ERROR_SUCCESS)
		return iErr;
	return args.Assign((const WCHAR* )bResult);
}

DISPERR CAutoEngine::Message(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	int iType;
	if ((iErr = args[1].GetInt(iType)) != S_OK)
		return iErr;
	int iStat = MsiProcessMessage(m_hMsi, (INSTALLMESSAGE)iType, args[2].GetHandle(IID_IMsiApiRecord));
	if (iStat < 0)
		return E_FAIL;
	return args.Assign(iStat);
}

DISPERR CAutoEngine::FeatureCurrentState(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szFeature)) != S_OK)
		return iErr;
	INSTALLSTATE iInstalled;
	INSTALLSTATE iAction;
	if ((iErr = MsiGetFeatureStateW(m_hMsi, szFeature, &iInstalled, &iAction)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign((int)iInstalled);
}

DISPERR CAutoEngine::FeatureRequestState(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szFeature)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		int iState;
		if ((iErr = args[0].GetInt(iState)) != S_OK)
			return iErr;
		return MsiSetFeatureStateW(m_hMsi, szFeature, (INSTALLSTATE)iState);
	}
	else
	{
		INSTALLSTATE iInstalled;
		INSTALLSTATE iAction;
		if ((iErr = MsiGetFeatureStateW(m_hMsi, szFeature, &iInstalled, &iAction)) != ERROR_SUCCESS)
			return iErr;
		return args.Assign((int)iAction);
	}
}

DISPERR CAutoEngine::FeatureValidStates(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szFeature)) != S_OK)
		return iErr;
	DWORD dwInstallStates;
	if ((iErr = MsiGetFeatureValidStatesW(m_hMsi, szFeature, &dwInstallStates)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(dwInstallStates);
}

DISPERR CAutoEngine::FeatureCost(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szFeature;
	int iCostTree;
	int iState;
	if ((iErr = args[1].GetString(szFeature)) != S_OK
	||  (iErr = args[2].GetInt(iCostTree)) != S_OK
	||  (iErr = args[3].GetInt(iState)) != S_OK)
		return iErr;
	int iCost;
	if ((iErr = MsiGetFeatureCostW(m_hMsi, szFeature, (MSICOSTTREE)iCostTree, (INSTALLSTATE)iState, &iCost)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign(iCost);
}

DISPERR CAutoEngine::ComponentCosts(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szComponent;
	int iState;
	if ((iErr = args[1].GetString(szComponent)) != S_OK
	 || (iErr = args[2].GetInt(iState)) != S_OK)
		return iErr;

	CTempBuffer<VolumeCost*, 10> rgVolumes;
	int cVolumes = 0;
	UINT uRes = ERROR_SUCCESS;
	CTempBuffer<WCHAR, MAX_PATH> bVolume;

	iErr = S_OK;

	for (DWORD dwIndex = 0; uRes == ERROR_SUCCESS; dwIndex++)
	{
		int iCost, iTempCost;

		DWORD dwSize = bVolume.GetSize();
		int iRetry = 0;
		do
			uRes = MsiEnumComponentCostsW(m_hMsi, szComponent, dwIndex,
													(INSTALLSTATE)iState,
													bVolume, &dwSize,
													&iCost, &iTempCost);
		while ( uRes == ERROR_MORE_DATA && ++iRetry < 2 && (bVolume.SetSize(++dwSize), true) );
		if ( uRes != ERROR_SUCCESS )
			break;

		VolumeCost* pstVol = new VolumeCost(bVolume, bVolume.GetSize(), iCost, iTempCost);
		if ( !pstVol || (*bVolume && !pstVol->m_szDrive) )
		{
			iErr = E_OUTOFMEMORY;
			goto Error;
		}
		if ( cVolumes == rgVolumes.GetSize() )
			rgVolumes.Resize(cVolumes+5);
		rgVolumes[cVolumes++] = pstVol;
	}
	if ( uRes == ERROR_NO_MORE_ITEMS )
	{
		int iSize = cVolumes * sizeof(VolumeCost*);
		int cbBuffer = sizeof(CEnumBuffer) + iSize;
		CEnumBuffer* pBuffer = (CEnumBuffer*)new char[cbBuffer];
		if ( !pBuffer )
		{
			iErr = E_OUTOFMEMORY;
			goto Error;
		}
		memcpy((char*)pBuffer + sizeof(CEnumBuffer), (void*)(VolumeCost**)rgVolumes, iSize);
		pBuffer->iRefCnt = 0;
		pBuffer->cItems = cVolumes;
		pBuffer->cbSize = cbBuffer;
		IMsiCollection* piEnum = new CEnumVARIANTRECORD(*pBuffer);
		return args.Assign(new CAutoCollection(*piEnum, IID_IMsiRecordCollection));
	}

Error:
	for ( int i=0; i < cVolumes; i++ )
		delete rgVolumes[i];

	return iErr == S_OK ? E_FAIL : iErr;
}

DISPERR CAutoEngine::ComponentCurrentState(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szComponent;
	if ((iErr = args[1].GetString(szComponent)) != S_OK)
		return iErr;
	INSTALLSTATE iInstalled;
	INSTALLSTATE iAction;
	if ((iErr = MsiGetComponentStateW(m_hMsi, szComponent, &iInstalled, &iAction)) != ERROR_SUCCESS)
		return iErr;
	return args.Assign((int)iInstalled);
}

DISPERR CAutoEngine::ComponentRequestState(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szComponent;
	if ((iErr = args[1].GetString(szComponent)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		int iState;
		if ((iErr = args[0].GetInt(iState)) != S_OK)
			return iErr;
		return MsiSetComponentStateW(m_hMsi, szComponent, (INSTALLSTATE)iState);
	}
	else
	{
		INSTALLSTATE iInstalled;
		INSTALLSTATE iAction;
		if ((iErr = MsiGetComponentStateW(m_hMsi, szComponent, &iInstalled, &iAction)) != ERROR_SUCCESS)
			return iErr;
		return args.Assign((int)iAction);
	}
}

DISPERR CAutoEngine::SetInstallLevel(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	int iLevel;
	if ((iErr = args[1].GetInt(iLevel)) != S_OK)
		return iErr;
	return MsiSetInstallLevel(m_hMsi, iLevel);
}

DISPERR CAutoEngine::VerifyDiskSpace(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	UINT iStat;
	Bool fStat;
	switch (iStat = MsiVerifyDiskSpace(m_hMsi))
	{
	case ERROR_SUCCESS:   fStat = fTrue; break;
	case ERROR_DISK_FULL: fStat = fFalse; break;
	default:              return iStat;
	}
	return args.Assign(fStat);
}

DISPERR CAutoEngine::ProductProperty(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szProperty;
	if ((iErr = args[1].GetString(szProperty)) != S_OK)
		return iErr;
	CTempBuffer<WCHAR, 256> bValue;
	DWORD dwSize = bValue.GetSize();
	do
		iErr = MsiGetProductPropertyW(m_hMsi, szProperty, bValue, &dwSize);
	while (iErr == ERROR_MORE_DATA && (bValue.SetSize(++dwSize), true));
	if (iErr != ERROR_SUCCESS)
		return iErr;
	return args.Assign((const WCHAR* )bValue);
}

DISPERR CAutoEngine::FeatureInfo(CAutoArgs& args)
{
	CClientThreadImpersonate ThreadImpersonate(m_dwThreadId);

	DISPERR iErr;
	const WCHAR* szFeature;
	if ((iErr = args[1].GetString(szFeature)) != S_OK)
		return iErr;
	CAutoFeatureInfo* pInfo = new CAutoFeatureInfo();
	if ( ! pInfo )
		return E_OUTOFMEMORY;
	if (!pInfo->Initialize(m_hMsi, szFeature))
	{
		pInfo->Release();
		return DISP_E_BADINDEX;
	}
	return args.Assign(pInfo);
}

//____________________________________________________________________________
//
// CAutoFeatureInfo automation implementation
//____________________________________________________________________________

DispatchEntry<CAutoFeatureInfo> AutoFeatureInfoTable[] = {
  DISPID_MsiFeatureInfo_Title      , HELPID_MsiFeatureInfo_Title      , aafPropRO, CAutoFeatureInfo::Title      , L"Title",
  DISPID_MsiFeatureInfo_Description, HELPID_MsiFeatureInfo_Description, aafPropRO, CAutoFeatureInfo::Description, L"Description",
  DISPID_MsiFeatureInfo_Attributes , HELPID_MsiFeatureInfo_Attributes , aafPropRW, CAutoFeatureInfo::Attributes , L"Attributes",
};
const int AutoFeatureInfoCount = sizeof(AutoFeatureInfoTable)/sizeof(DispatchEntryBase);

CAutoFeatureInfo::CAutoFeatureInfo()
	: CAutoBase(*AutoFeatureInfoTable, AutoFeatureInfoCount, IID_IUnknown, (MSIHANDLE)0)
{
}

bool CAutoFeatureInfo::Initialize(MSIHANDLE hProduct, const WCHAR* szFeature)
{
	m_hProduct = hProduct;
	if ( FAILED(StringCchCopyW(m_szFeature, ARRAY_ELEMENTS(m_szFeature), szFeature)) )
	{
		*m_szFeature = 0;
		Assert(false);
	}
	DWORD cchTitleBuf = sizeof(m_szTitle)/sizeof(WCHAR);
	DWORD cchHelpBuf  = sizeof(m_szDescription)/sizeof(WCHAR);
	UINT iStat = MsiGetFeatureInfoW(hProduct, szFeature, &m_iAttributes, m_szTitle, &cchTitleBuf, m_szDescription, &cchHelpBuf);
	return iStat == ERROR_SUCCESS || iStat == ERROR_MORE_DATA; // ignore truncation, should never happen due to schema limitations
}

DISPERR CAutoFeatureInfo::Title(CAutoArgs& args)
{
	return args.Assign(m_szTitle);
}

DISPERR CAutoFeatureInfo::Description(CAutoArgs& args)
{
	return args.Assign(m_szDescription);
}

DISPERR CAutoFeatureInfo::Attributes(CAutoArgs& args)
{
	if ( args.PropertySet() )
	{
		if ( *m_szFeature == 0 )
			return E_INVALIDARG;

		DISPERR iErr;
		DWORD dwValue;
		if ((iErr = args[0].GetInt((int&)dwValue)) != S_OK)
			return iErr;
		return MsiSetFeatureAttributesW(m_hProduct, m_szFeature, dwValue);
	}
	else
		return args.Assign(m_iAttributes);
}

//____________________________________________________________________________
//
// CAutoUIPreview automation implementation
//____________________________________________________________________________

DispatchEntry<CAutoUIPreview> AutoUIPreviewTable[] = {
  DISPID_MsiUIPreview_Property     , HELPID_MsiEngine_Property        , aafPropRW, CAutoUIPreview::Property,      L"Property,Name",
  DISPID_MsiUIPreview_ViewDialog   , HELPID_MsiUIPreview_ViewDialog   , aafMethod, CAutoUIPreview::ViewDialog,    L"ViewDialog,Dialog",
  DISPID_MsiUIPreview_ViewBillboard, HELPID_MsiUIPreview_ViewBillboard, aafMethod, CAutoUIPreview::ViewBillboard, L"ViewBillboard,Control,Billboard",
};
const int AutoUIPreviewCount = sizeof(AutoUIPreviewTable)/sizeof(DispatchEntryBase);

CAutoUIPreview::CAutoUIPreview(MSIHANDLE hUIPreview)
 : CAutoBase(*AutoUIPreviewTable, AutoUIPreviewCount, IID_IMsiApiUIPreview, hUIPreview)
{
}

DISPERR CAutoUIPreview::Property(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szProperty;
	if ((iErr = args[1].GetString(szProperty)) != S_OK)
		return iErr;
	if (args.PropertySet())
	{
		CVariant& var = args[0];
		const WCHAR* szValue = 0;
		if (var.GetType() != VT_EMPTY && (iErr = var.GetString(szValue)) != S_OK)
			return iErr;
		return MsiSetPropertyW(m_hMsi, szProperty, szValue);
	}
	else
	{
		CTempBuffer<WCHAR, 1024> bValue;
		DWORD dwSize = bValue.GetSize();
		UINT iStat;
		do
			iStat = MsiGetPropertyW(m_hMsi, szProperty, bValue, &dwSize);
		while (iStat == ERROR_MORE_DATA && (bValue.SetSize(++dwSize), true));
		if (iStat != ERROR_SUCCESS)
			return iStat;
		return args.Assign((const WCHAR* )bValue);
	}
}

DISPERR CAutoUIPreview::ViewDialog(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szDialog;
	if ((iErr = args[1].GetString(szDialog)) != S_OK)
		return iErr;
	return MsiPreviewDialogW(m_hMsi, szDialog);
}

DISPERR CAutoUIPreview::ViewBillboard(CAutoArgs& args)
{
	DISPERR iErr;
	const WCHAR* szControl;
	const WCHAR* szBillboard;
	if ((iErr = args[1].GetString(szControl)) != S_OK
	||  (iErr = args[2].GetString(szBillboard)) != S_OK)
		return iErr;
	return MsiPreviewBillboardW(m_hMsi, szControl, szBillboard);
}

//____________________________________________________________________________
//
// DLL management
//____________________________________________________________________________

extern "C" HRESULT __stdcall DllRegisterServerTest();
extern "C" HRESULT __stdcall DllUnregisterServerTest();
extern "C" HRESULT __stdcall DllGetClassObjectTest(const GUID& clsid, const IID& iid, void** ppvRet);

HRESULT CAutoApiFactory::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IClassFactory)
		return (*ppvObj = this, NOERROR);
	else
		return (*ppvObj = 0, E_NOINTERFACE);
}
unsigned long CAutoApiFactory::AddRef()
{
	return 1;
}
unsigned long CAutoApiFactory::Release()
{
	return 1;
}

extern CMsiCustomAction* g_pCustomActionContext;
HRESULT CAutoApiFactory::CreateInstance(IUnknown* pUnkOuter, const IID& riid,
													void** ppvObject)
{
	if (pUnkOuter)
		return CLASS_E_NOAGGREGATION;
	if (!(riid == IID_IUnknown || riid == IID_IMsiApiInstall || riid == IID_IDispatch))
		return E_NOINTERFACE;
    
#ifdef UNICODE
	if (g_pCustomActionContext)
	{
		if (S_OK != g_pCustomActionContext->GetInstallerObject(reinterpret_cast<IDispatch**>(ppvObject)))
			return E_OUTOFMEMORY;
	}
	else
#endif // UNICODE
		*ppvObject = (void*)::CreateAutoInstall();

	if (!(*ppvObject))
		return E_OUTOFMEMORY;
	return NOERROR;
}
HRESULT CAutoApiFactory::LockServer(BOOL fLock)
{
   if (fLock)
	  g_cInstances++;
   else if (g_cInstances)
		g_cInstances--;
	return NOERROR;
}

extern "C" HRESULT __stdcall
DllGetClassObject(const GUID& clsid, const IID& iid, void** ppvRet)
{
	if (!ppvRet)
		return E_INVALIDARG;
	*ppvRet = 0;
	HRESULT hres;
	
	hres = DllGetClassObjectTest(clsid, iid, ppvRet);
	if (hres == NOERROR)
		return hres;

	if (!(iid == IID_IUnknown || iid == IID_IClassFactory))
		return E_NOINTERFACE;
	if (clsid == IID_IMsiSystemAccess)
	{
		*ppvRet = (void*)&g_InstallerFactory;
		return NOERROR;
	}
#ifdef DEBUG
	if (clsid == IID_IMsiApiInstall || clsid == IID_IMsiApiInstallDebug)
#else
	if (clsid == IID_IMsiApiInstall)
#endif
	{
		*ppvRet = (void*)&g_AutoInstallFactory;
		return NOERROR;
	}
	return E_FAIL;
}

static TCHAR szRegFilePath[MAX_PATH];
static TCHAR szRegCLSIDAuto[40];  // buffer for string form of CLSID
static TCHAR szRegCLSIDMessage[40];  // buffer for string form of CLSID
static TCHAR szRegLIBID[40];  // buffer for string form of LIBID
static TCHAR szRegDllVersionString [100]; // buffer for string form of dll version.

static const TCHAR szRegProgId[]          = TEXT("WindowsInstaller.Installer");
static const TCHAR szRegProgIdMessage[]   = TEXT("WindowsInstaller.Message");
static const TCHAR szRegDescription[] = TEXT("Microsoft Windows Installer");
static const TCHAR szRegDescriptionMessage[] = TEXT("Microsoft Windows Installer Message RPC");

#ifdef DEBUG
static TCHAR szRegCLSIDDebug[40];  // buffer for string form of CLSID
static const TCHAR szRegProgIdDebug[]      = TEXT("WindowsInstaller.Debug");
static const TCHAR szRegDescriptionDebug[] = TEXT("Microsoft Windows Installer - Debug");
#endif
static TCHAR szRegCLSIDPriv[40];

static const TCHAR* rgszRegData[] = {
	TEXT("CLSID\\%s\\InprocServer32"),  szRegCLSIDAuto, szRegFilePath,                      TEXT("ThreadingModel"), TEXT("Apartment"),
	TEXT("CLSID\\%s\\InprocHandler32"), szRegCLSIDAuto, TEXT("ole32.dll"),                  NULL, NULL,
	TEXT("CLSID\\%s\\ProgId"),          szRegCLSIDAuto, szRegProgId,                        NULL, NULL,
	TEXT("CLSID\\%s\\TypeLib"),         szRegCLSIDAuto, szRegLIBID,                         NULL, NULL,
	TEXT("CLSID\\%s"),                  szRegCLSIDAuto, szRegDescription,                   NULL, NULL,
	TEXT("%s\\CLSID"),                  szRegProgId,    szRegCLSIDAuto,                     NULL, NULL,
	TEXT("%s"),                         szRegProgId,    szRegDescription,                   NULL, NULL,
	TEXT("CLSID\\%s\\InprocServer32"),  szRegCLSIDPriv, szRegFilePath,                      TEXT("ThreadingModel"), TEXT("Apartment"),
	TEXT("CLSID\\%s"),                  szRegCLSIDPriv, TEXT(""),                           NULL, NULL,

	TEXT("%s\\CLSID"),                  szRegProgIdMessage,  szRegCLSIDMessage,             NULL, NULL,
	TEXT("%s"),                         szRegProgIdMessage,  szRegDescriptionMessage,       NULL, NULL,
	TEXT("CLSID\\%s\\ProgId"),          szRegCLSIDMessage,   szRegProgIdMessage,            NULL, NULL,
	TEXT("CLSID\\%s"),                  szRegCLSIDMessage,   szRegDescriptionMessage,       NULL, NULL,
	TEXT("CLSID\\%s\\DllVersion"),      szRegCLSIDMessage,	 szRegDllVersionString,         NULL, NULL,

#ifdef DEBUG
	TEXT("CLSID\\%s\\InprocServer32"),  szRegCLSIDDebug, szRegFilePath,                     TEXT("ThreadingModel"), TEXT("Apartment"),
	TEXT("CLSID\\%s\\InprocHandler32"), szRegCLSIDDebug, TEXT("ole32.dll"),                 NULL, NULL,
	TEXT("CLSID\\%s\\ProgId"),          szRegCLSIDDebug, szRegProgIdDebug,                  NULL, NULL,
	TEXT("CLSID\\%s\\TypeLib"),         szRegCLSIDDebug, szRegLIBID,                        NULL, NULL,
	TEXT("CLSID\\%s"),                  szRegCLSIDDebug, szRegDescriptionDebug,             NULL, NULL,
	TEXT("%s\\CLSID"),                  szRegProgIdDebug, szRegCLSIDDebug,                  NULL, NULL,
	TEXT("%s"),                         szRegProgIdDebug, szRegDescriptionDebug,            NULL, NULL,
#endif
	0
};

extern "C" HRESULT __stdcall ProxyDllRegisterServer();
extern "C" HRESULT __stdcall ProxyDllUnregisterServer();
void UnRegisterOldInfo(void);

static const TCHAR szEventLogRegKey[] = TEXT("System\\CurrentControlSet\\Services\\EventLog\\Application\\MsiInstaller");
static const TCHAR szEventLogFileValue[] = TEXT("EventMessageFile");
static const TCHAR szEventLogTypesValue[] = TEXT("TypesSupported");
extern void GetVersionInfo(int* piMajorVersion, int* piMinorVersion, int* piWindowsBuild, bool* pfWin9X, bool* pfWinNT64);
extern "C" HRESULT __stdcall DllGetVersion (DLLVERSIONINFO * pVerInfo);

HRESULT __stdcall
DllRegisterServer()
{
	DLLVERSIONINFO	verInfo;

	HRESULT hRes = 0;
	size_t cchRegFilePath = sizeof(szRegFilePath)/sizeof(TCHAR);
	szRegFilePath[cchRegFilePath-1] = TEXT('\0');
	int cchFilePath = W32::GetModuleFileName(g_hInstance, szRegFilePath, cchRegFilePath);
	if ( szRegFilePath[cchRegFilePath-1] != TEXT('\0') )
		// the '\0' character we've set got overwritten => we're having with a buffer overflow
		return E_FAIL;

#ifdef UNICODE
	bool fWin9X = false;
#else
	bool fWin9X = true;
#endif
	GetVersionInfo(0, 0, 0, &fWin9X, 0);
	if (cchFilePath > 0 && !fWin9X)
	{   // Register the location of the MSI Event Log message file
		HKEY hkey;
		if (MsiRegCreate64bitKey(HKEY_LOCAL_MACHINE, szEventLogRegKey, 0, 0, 0, KEY_READ|KEY_WRITE, 0, &hkey, 0) == ERROR_SUCCESS)
		{
			DWORD dwTypesSupported = 7;
			W32::RegSetValueEx(hkey, szEventLogFileValue, 0, REG_SZ, (CONST BYTE*)szRegFilePath, (lstrlen(szRegFilePath)+1)*sizeof(TCHAR));
			W32::RegSetValueEx(hkey, szEventLogTypesValue, 0, REG_DWORD, (CONST BYTE*)&dwTypesSupported, sizeof(DWORD));
			W32::RegCloseKey(hkey);
		}
	}
	int cErr = (ProxyDllRegisterServer() == S_OK ? 0 : 1);
	StringCchPrintf(szRegCLSIDAuto, (sizeof(szRegCLSIDAuto)/sizeof(TCHAR)),      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiApiInstall);
	StringCchPrintf(szRegCLSIDMessage, (sizeof(szRegCLSIDMessage)/sizeof(TCHAR)),   TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiMessage);
	verInfo.cbSize = sizeof (DLLVERSIONINFO);
	DllGetVersion (&verInfo);
	StringCchPrintf (szRegDllVersionString, (sizeof(szRegDllVersionString)/sizeof(TCHAR)), TEXT("%d.%d.%d"), verInfo.dwMajorVersion, verInfo.dwMinorVersion, verInfo.dwBuildNumber);
#ifdef DEBUG
	StringCchPrintf(szRegCLSIDDebug, (sizeof(szRegCLSIDDebug)/sizeof(TCHAR)), TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiApiInstallDebug);
#endif
	StringCchPrintf(szRegCLSIDPriv, (sizeof(szRegCLSIDPriv)/sizeof(TCHAR)),      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiSystemAccess);
	StringCchPrintf(szRegLIBID, (sizeof(szRegLIBID)/sizeof(TCHAR)),      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiApiTypeLib);
	const TCHAR** psz = rgszRegData;
	while (*psz)
	{
		if ((*(psz+1) != 0) && (*(psz+2) != 0)) // handle NULL ProgID
		{
			TCHAR szRegKey[80];
			const TCHAR* szTemplate = *psz++;
			StringCchPrintf(szRegKey, ARRAY_ELEMENTS(szRegKey), szTemplate, *psz++);
			HKEY hkey;
			hkey = 0;
			if (RegCreateKeyAPI(HKEY_CLASSES_ROOT, szRegKey, 0, 0, 0,
									  KEY_READ|KEY_WRITE, 0, &hkey, 0) != ERROR_SUCCESS
			 || W32::RegSetValueEx(hkey, 0, 0, REG_SZ, (CONST BYTE*)*psz, (lstrlen(*psz)+1)*sizeof(TCHAR)) != ERROR_SUCCESS)
				cErr++;
			psz++;

			if (hkey && *psz)
			{
				if (W32::RegSetValueEx(hkey, (*psz), 0, REG_SZ, (CONST BYTE*)*(psz+1), (lstrlen(*(psz+1))+1)*sizeof(TCHAR)) != ERROR_SUCCESS)
				cErr++;
			}
			psz+=2;
			if (hkey)
				W32::RegCloseKey(hkey);
		}
	}
	if (GetTestFlag('r') && DllRegisterServerTest() != NOERROR)
		cErr++;
	if (cErr)
		return SELFREG_E_CLASS;
#ifdef UNICODE
	OLECHAR *szTypeLibPath = szRegFilePath;
#else
	OLECHAR szTypeLibPath[MAX_PATH];
	W32::MultiByteToWideChar(CP_ACP, 0, szRegFilePath, cchFilePath+1, szTypeLibPath, MAX_PATH);
#endif
	ITypeLib* piTypeLib = 0;
	HRESULT hres = OLEAUT32::LoadTypeLib(szTypeLibPath, &piTypeLib);
	if (hres == TYPE_E_INVDATAREAD)  // ignore if Win95 virgin OLEAUT32.DLL, different typelib format
		return S_OK;
	if (hres != S_OK)
		return SELFREG_E_TYPELIB;
	hres = OLEAUT32::RegisterTypeLib(piTypeLib, szTypeLibPath, 0);
	piTypeLib->Release();
	if (hres != S_OK)
		return SELFREG_E_TYPELIB;
//NT4,Win95+new OLEAUT32 only: if (OLEAUT32::LoadTypeLibEx(szTypeLibPath, REGKIND_REGISTER, &piTypeLib) != S_OK)
	return NOERROR;
}

HRESULT __stdcall
DllUnregisterServer()
{
	TCHAR szRegKey[80];
	int cErr = 0;

#ifdef UNICODE
	bool fWin9X = false;
#else
	bool fWin9X = true;
#endif
	GetVersionInfo(0, 0, 0, &fWin9X, 0);
	if (!fWin9X)
	{
		// Delete Event log registration
		W32::RegDeleteKey(HKEY_LOCAL_MACHINE, szEventLogRegKey);
	}

	HRESULT hr = ProxyDllUnregisterServer();
	if (hr != S_OK && hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
		cErr ++;

	// unregister keys under CLSID and ProgId
	StringCchPrintf(szRegCLSIDAuto, (sizeof(szRegCLSIDAuto)/sizeof(TCHAR)),      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiApiInstall);
	StringCchPrintf(szRegCLSIDMessage, (sizeof(szRegCLSIDMessage)/sizeof(TCHAR)),   TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiMessage);
#ifdef DEBUG
	StringCchPrintf(szRegCLSIDDebug, (sizeof(szRegCLSIDDebug)/sizeof(TCHAR)), TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiApiInstallDebug);
#endif
	StringCchPrintf(szRegCLSIDPriv, (sizeof(szRegCLSIDPriv)/sizeof(TCHAR)),      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiSystemAccess);
	StringCchPrintf(szRegLIBID, (sizeof(szRegLIBID)/sizeof(TCHAR)),      TEXT("{%08lX-0000-0000-C000-000000000046}"), iidMsiApiTypeLib);
	const TCHAR** psz = rgszRegData;
	while (*psz)
	{
		if ((*(psz+1) != 0) && (*(psz+2) != 0)) // handle NULL ProgID
		{
			const TCHAR* szTemplate = *psz++;
			StringCchPrintf(szRegKey, ARRAY_ELEMENTS(szRegKey), szTemplate, *psz++);
			long lResult = W32::RegDeleteKey(HKEY_CLASSES_ROOT, szRegKey);
			if((ERROR_KEY_DELETED != lResult) &&
				(ERROR_FILE_NOT_FOUND != lResult) && (ERROR_SUCCESS != lResult))
			{
				if (ERROR_ACCESS_DENIED == lResult)
				{
					DWORD cSubKeys;
					HKEY hKey;
					
					lResult = RegOpenKeyAPI(HKEY_CLASSES_ROOT, szRegKey, 0, KEY_READ, &hKey);
					if (lResult == ERROR_SUCCESS)
					{
						lResult = RegQueryInfoKey(hKey, NULL, NULL, NULL, &cSubKeys, NULL,
										NULL, NULL, NULL, NULL, NULL, NULL);
						if (lResult != ERROR_SUCCESS || cSubKeys == 0)
							cErr++;
						RegCloseKey(hKey);
					}
					else                                                
						cErr++;
				}
				else
					cErr++;
			}
			psz+= 3;
		}
	}
	OLEAUT32::UnRegisterTypeLib(IID_IMsiApiTypeLib, TYPELIB_MAJOR_VERSION, TYPELIB_MINOR_VERSION, 0x0409, SYS_WIN32);
	if (GetTestFlag('r') && DllUnregisterServerTest() != NOERROR)
		cErr++;
	return cErr ? SELFREG_E_CLASS : NOERROR;
}

//____________________________________________________________________________
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\buildtools\mkerrtbl\mkerrtbl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       mkerrtbl.cpp
//
//--------------------------------------------------------------------------

#include "common.h"   // to allow use of precompiled headers for windows.h
//#define WIN32_LEAN_AND_MEAN  // omit stuff we don't need, to make builds fast
//#define INC_OLE2    // IUnknown
//#pragma warning(disable : 4201) // unnamed struct/unions, in Win32 headers
//#pragma warning(disable : 4514) // inline function not used, no possible to fix
//#include <windows.h>

#undef IError
#define IError(a,b,c) { (b), c, #a },  // override normal error definition
#include <msidefs.h>

struct MsiErrorEntry 
{
	int iErr;
	const char* szFmt;
	const char* szName;
};

#define ERRORTABLE  // read only IError(...) lines
MsiErrorEntry rgErrors[] = { {0,0,0},
#include "services.h"  // includes: database.h, path.h, regkey.h
#include "iconfig.h"
#include "engine.h"
#include "handler.h"
};

int cErrors = sizeof(rgErrors)/sizeof(MsiErrorEntry);

char szTxtHeader[] = "Windows installer Error and Debug Messages\r\n\r\n";
char szTxtFormat[] = "%4i %-30s %s\r\n";
char szTxtFooter[] = "";
char szIdtHeader[] = "Error\tMessage\r\n" "i2\tL255\r\n" "Error\tError\r\n";
char szIdtFormat[] = "%i\t%s\r\n";
char szIdtFooter[] = "";
char szRcHeader[]  = "/* Auto-generated error strings, DO NOT EDIT! */\nSTRINGTABLE {\r\n";
char szRcFormat[]  = "\t%i, \"%s\"\r\n";
char szRcFooter[]  = "}\r\n";
char szRHeader[]   = "/* Auto-generated error strings, DO NOT EDIT! */\r\n";
char szRFormat[]   = "resource 'STR ' (%i) {\"%s\"};\r\n";
char szRFooter[]   = "";
char szRtfHeader[] = "{\\rtf1\\ansi {\\fonttbl{\\f0\\fswiss Helv;}"
							"{\\f1\\fmodern Courier New;}} {\\colortbl;} \\fs20\r\n"
							"#{\\footnote Msi_Errors}\r\n${\\footnote Msi Errors}\r\n"
							"\\pard\\f0\\cf1\\sb90{\\li-150\\fi150\\brdrb\\fs24\\b\r\n"
							"Windows installer Errors\r\n\\par}\\li180\r\n"
							"\\trowd\\trgaph108\\trleft108 \\cellx1200\\cellx4400\\cellx9030\r\n"
							"\\intbl{\\b Error #\\cell Constant\\cell Message\\cell }\\row\r\n";
char szRtfFormat[] = "\\intbl %4i \\cell %-30s \\cell %s \\cell \\row\r\n";
char szRtfFooter[] = "\\page}";
char szInfoHeader[] = "PropertyId	Value\r\n" "i2	l255\r\n" "_SummaryInformation	PropertyId\r\n"
"1	1252\r\n"
"2	Debug Error table transform\r\n"
"4	Microsoft Corporation\r\n"
"5	Installer,MSI,Transform\r\n"
"6	Replaces ship messages with debug messages\r\n"
"7	;1033\r\n"
"14	100\r\n" // minimum version - means minimum version of debug error transform will always be 100
"16	49\r\n"
"18	Windows installer\r\n"
"19	2\r\n";

char szError[] = "Must specify a target file name, either *.txt, *.idt, *.rc, *.r, or *.rtf\n";

int _cdecl main(int argc, char *argv[])
{
	char* szExt = "";
	char* szHeader;
	char* szFormat;
	char* szFooter;
	Bool fName = fFalse;
	int iLimit = idbgBase;
	DWORD cbWrite;
	HANDLE hFile;
	if (argc >= 2)
		szExt = argv[1];
	int cbArg = lstrlenA(szExt);
	szExt += cbArg;
	while (cbArg-- && *(--szExt) != '.')
		;
	if (lstrcmpi(szExt, ".txt") == 0)
	{
		fName    = fTrue;
		iLimit   = 9999;
		szHeader = szTxtHeader;
		szFormat = szTxtFormat;
		szFooter = szTxtFooter;
	}
	else if (lstrcmpi(szExt, ".idt") == 0)  // Error.idt
	{
		szHeader = szIdtHeader;
		szFormat = szIdtFormat;
		szFooter = szIdtFooter;
		if ((szExt[-1] | 32) == 'i')         // ErrorSI.idt
		{
			szHeader = szInfoHeader;
			cErrors = 0;
		}
		if ((szExt[-1] | 32) == 'd')         // ErrorD.idt
			iLimit   = 9999;
	}
	else if (lstrcmpi(szExt, ".rc") == 0)
	{
		szHeader = szRcHeader;
		szFormat = szRcFormat;
		szFooter = szRcFooter;
	}
	else if (lstrcmpi(szExt, ".r") == 0)
	{
		szHeader = szRHeader;
		szFormat = szRFormat;
		szFooter = szRFooter;
	}
	else if (lstrcmpi(szExt, ".rtf") == 0)
	{
		fName    = fTrue;
		iLimit   = 9999;
		szHeader = szRtfHeader;
		szFormat = szRtfFormat;
		szFooter = szRtfFooter;
	}
	else
	{
		hFile = ::GetStdHandle(STD_OUTPUT_HANDLE);
		::WriteFile(hFile, szError, sizeof(szError), &cbWrite, 0);
		return 1;
	}
	hFile = ::CreateFile(argv[1], GENERIC_WRITE, FILE_SHARE_READ,
									0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	::WriteFile(hFile, szHeader, lstrlenA(szHeader), &cbWrite, 0);

	for(int iError = 2; iError < cErrors; iError++) // sort by error code
      for (int i = iError; i && rgErrors[i].iErr < rgErrors[i-1].iErr; i--)
      {
         rgErrors[0].iErr     = rgErrors[i].iErr;
         rgErrors[0].szFmt    = rgErrors[i].szFmt;
         rgErrors[0].szName   = rgErrors[i].szName;
         rgErrors[i].iErr     = rgErrors[i-1].iErr;
         rgErrors[i].szFmt    = rgErrors[i-1].szFmt;
         rgErrors[i].szName   = rgErrors[i-1].szName;
         rgErrors[i-1].iErr   = rgErrors[0].iErr;
         rgErrors[i-1].szFmt  = rgErrors[0].szFmt;
         rgErrors[i-1].szName = rgErrors[0].szName;
      }

	for(int c=1; c < cErrors; c++)
	{
		char szBuf[1024];
		int iError = rgErrors[c].iErr;
		if (iError >= iLimit)
			break;
		if (fName)
			cbWrite = wsprintf(szBuf, szFormat, iError, rgErrors[c].szName, rgErrors[c].szFmt);
		else
			cbWrite = wsprintf(szBuf, szFormat, iError, rgErrors[c].szFmt);
		::WriteFile(hFile, szBuf, cbWrite, &cbWrite, 0);
	}
	::WriteFile(hFile, szFooter, lstrlenA(szFooter), &cbWrite, 0);
	::CloseHandle(hFile);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\callback.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       callback.cpp
//
//--------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////
// callback.cpp -- contains all the FDI callbacks for the FDI server
//                 and some additional miscellaneous routines
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// #defines and #includes
////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "database.h"
#include "_databas.h"
#include <io.h>
#include <sys\stat.h>

#include "callback.h"
#include "fdisvr.h"
#include "path.h"
#include "notify.h"
#include "_assert.h"


// log assembly errors
IMsiRecord* PostAssemblyError(const ICHAR* szComponentId, HRESULT hResult, const ICHAR* szInterface, const ICHAR* szFunction, const ICHAR* szAssemblyName);

////////////////////////////////////////////////////////////////////////////
// Global/Shared data
////////////////////////////////////////////////////////////////////////////

extern FDIShared*           g_pFDIs;			// Defined in fdisvr.cpp
extern ERF					g_erf;				// Defined in fdisvr.cpp
extern FDIServerResponse	g_fdirCallbackError;	// Defined in fdisvr.cpp
extern HANDLE               g_hCurDestFile;     // Defined in fdisvr.cpp
extern IStream* g_pDestFile;

// For events
extern HANDLE g_hCallbackInterfaceEvent;
extern HANDLE g_hCallbackServerEvent;

extern HANDLE g_hInterfaceInterfaceEvent;
extern HANDLE g_hInterfaceServerEvent;

////////////////////////////////////////////////////////////////////////////
// Private data
////////////////////////////////////////////////////////////////////////////
#define MAX_SEEK_COUNT		4	// Supported number of independent seek pointers
static icbtEnum	s_icbtCurrCabType = icbtNextEnum;	// Start with unknown type

static IMsiStream*	s_piStream[MAX_SEEK_COUNT + 1];
static int          s_iNextStream = 0;

static int OpenFileCabinet(const ICHAR* pszCabName, int oflag, int pmode);
static int OpenStreamCabinet(const ICHAR* pszCabName, int oflag, int pmode);
static UINT ReadStreamCabinet(INT_PTR hf, void* pv, UINT cb);
static int CloseStreamCabinet(INT_PTR hf);
static int SeekStreamCabinet(INT_PTR hf, long dist, int seektype);

Bool StartFdiImpersonating(bool fNonWrapperCall)
{
	bool fSuccess = true;
	if (fNonWrapperCall && g_pFDIs->fServerIsImpersonated)
		return ToBool(fSuccess);

	if (g_pFDIs->hImpersonationToken != INVALID_HANDLE_VALUE)
		fSuccess = StartImpersonating();
	Assert(fSuccess);

	return ToBool(fSuccess);
}

void StopFdiImpersonating(bool fNonWrapperCall)
{
	if (fNonWrapperCall && g_pFDIs->fServerIsImpersonated)
		return;

	if (g_pFDIs->hImpersonationToken != INVALID_HANDLE_VALUE)
		StopImpersonating();
}

/* W A I T  C O M M A N D */
/*----------------------------------------------------------------------------
%%Function: WaitCommand

Waits for, and then returns, a FDI server command from the FDI Interface.
The fdir parameter tells WaitCommand what value to return to FDI Interface
as the command result.
----------------------------------------------------------------------------*/
FDIServerCommand WaitCommand(FDIServerResponse fdir)
{
	// Initialize shared data with our response
	g_pFDIs->fdic = fdicNoCommand;
	g_pFDIs->fdir = fdir;

	if (g_hCallbackServerEvent == NULL)
	{
		if(!DuplicateHandle(GetCurrentProcess(), g_hInterfaceServerEvent, 
							GetCurrentProcess(), &g_hCallbackServerEvent, 
							0, 0, DUPLICATE_SAME_ACCESS))
			return fdicNoCommand;
		else
			MsiRegisterSysHandle(g_hCallbackServerEvent);
	}
	if (g_hCallbackInterfaceEvent == NULL)
	{
		if(!DuplicateHandle(GetCurrentProcess(), g_hInterfaceInterfaceEvent, 
							GetCurrentProcess(), &g_hCallbackInterfaceEvent, 
							0, 0, DUPLICATE_SAME_ACCESS))
			return fdicNoCommand;
		else
			MsiRegisterSysHandle(g_hCallbackInterfaceEvent);
	}
	
	SetEvent(g_hCallbackServerEvent);	
	DWORD dw = WaitForSingleObject(g_hCallbackInterfaceEvent, INFINITE);


	// If we just received an extract file command we take special note,
	// so later on, during error checking, we know whether we were in the
	// middle of extracting a file
	if (g_pFDIs->fdic == fdicExtractFile) g_pFDIs->fPendingExtract = 1;

	// Clear any callback errors (we just received a command and haven't
	// done any processing yet, so there can't be any call back errors, can
	// there?)
	g_fdirCallbackError = fdirNoResponse;
	return g_pFDIs->fdic;
}

/* H A N D L E  E R R O R */
/*----------------------------------------------------------------------------
	%%Function: HandleError

	Based on the value of fdicCallbackError and the error returned from
	FDI in g_erf.erfOper, puts a suitable error response into g_pFDIs->fdir
----------------------------------------------------------------------------*/
// A little #define to make our switch statement a little more compact and easy
// to read
#define ErrorCase(x,y) \
case x: { \
	g_pFDIs->fdir = y; \
	break; \
}
void HandleError()
{
	if (g_fdirCallbackError == fdirNoResponse || 
		g_fdirCallbackError == fdirSuccessfulCompletion)
	{
		switch(g_erf.erfOper)
		{
			ErrorCase(FDIERROR_CABINET_NOT_FOUND,		fdirCabinetNotFound)
			ErrorCase(FDIERROR_NOT_A_CABINET,			fdirNotACabinet)
			ErrorCase(FDIERROR_UNKNOWN_CABINET_VERSION, fdirUnknownCabinetVersion)
			ErrorCase(FDIERROR_CORRUPT_CABINET,			fdirCorruptCabinet)
			ErrorCase(FDIERROR_ALLOC_FAIL,				fdirNotEnoughMemory)
			ErrorCase(FDIERROR_BAD_COMPR_TYPE,			fdirBadCompressionType)
			ErrorCase(FDIERROR_MDI_FAIL,				fdirMDIFail)
			ErrorCase(FDIERROR_TARGET_FILE,				fdirTargetFile)
			ErrorCase(FDIERROR_RESERVE_MISMATCH,		fdirReserveMismatch)
			ErrorCase(FDIERROR_WRONG_CABINET,			fdirWrongCabinet)
			ErrorCase(FDIERROR_USER_ABORT,				fdirUserAbort)
			ErrorCase(FDIERROR_NONE,					fdirSuccessfulCompletion)
			default:
			{
				NotifyUser("FDI Server: Unknown FDI error type!");
				g_pFDIs->fdir = fdirUnknownFDIError;
				break;
			}
		}
	}
	else g_pFDIs->fdir = g_fdirCallbackError;	// return more specific error
}
#undef ERRORCASE

////////////////////////////////////////////////////////////////////////////
// FDI Callbacks
////////////////////////////////////////////////////////////////////////////	
	
/* F N A L L O C */
/*----------------------------------------------------------------------------
	%%Function: FNALLOC

	FDI memory allocation callback. Must emulate "malloc". 
----------------------------------------------------------------------------*/
FNALLOC(pfnalloc)
{
	char *pc = new char[cb];
	if (!pc)
	{
		NotifyUser("FDI Server:Failure in pfnalloc");
	}
	return pc;
}

/* F N F R E E  */
/*----------------------------------------------------------------------------
	%%Function: FNFREE

	FDI memory freeing callback. Must emulate "free".
----------------------------------------------------------------------------*/
FNFREE(pfnfree)
{
	delete [] pv;
}

/* P F N  O P E N */
/*----------------------------------------------------------------------------
	%%Function: pfnopen

	FDI file open callback. Must emulate "_open".
----------------------------------------------------------------------------*/
// May Need to modify this to support the full semantics of _open
INT_PTR FAR DIAMONDAPI pfnopen(char FAR *pszFile, int oflag, int pmode)
{
// Okay, this function is a hack.  Instead of emulating _open with all of its
// myriad flag combinations, we handle only one case (the case that FDI calls us
// for).  If, at some future time, FDI should pass us different file creation/access
// flags, we will need to change this code to handle that.
// ****NOTE********************************************************************
// * There is one case where FDI calls us with different flags, and that is   *
// * when there is not enough memory for the decompressor.  In this case, FDI *
// * will attempt to create a spillfile "*" that is temporarily used for      *
// * decompression. If this ever happens, performance will be dog slow, so I'm*
// * not currently supporting it in this function.                            *
// ****************************************************************************

	if ((oflag != (/*_O_BINARY*/ 0x8000 | /*_O_RDONLY*/ 0x0000)) || (pmode != (_S_IREAD | _S_IWRITE)))
	{
		// Crash and burn horribly
		NotifyUser("FDI Server: Unexpected access flags in pfnopen()");
		return 0;
	}

	int iReturn = -1;
	CConvertString rgchConvertFile(pszFile);
	if (g_pFDIs->icbtCabinetType == icbtFileCabinet)
		iReturn = OpenFileCabinet(rgchConvertFile, oflag, pmode);

	else if (g_pFDIs->icbtCabinetType == icbtStreamCabinet)
		iReturn = OpenStreamCabinet(rgchConvertFile, oflag, pmode);

	if (iReturn == -1)
		g_fdirCallbackError = fdirCabinetNotFound;

	return iReturn;
}


int OpenFileCabinet(const ICHAR* pszCabFileName, int /*oflag*/, int /*pmode*/)
/*----------------------------------------------------------------------------
Called from pfnopen - Opens a standard file-based cabinet.

Returns:
-1 if the cabinet file cannot be found and opened, otherwise, a handle to the
opened file.
----------------------------------------------------------------------------*/
{
	if ( ! pszCabFileName )
		return -1;
	s_icbtCurrCabType = icbtFileCabinet;
	Bool fImpersonate = (	(g_pFDIs->iCabDriveType == DRIVE_REMOTE)
						||	(g_pFDIs->iCabDriveType == DRIVE_REMOVABLE)
						|| 	(g_pFDIs->iCabDriveType == DRIVE_CDROM)
						) ? fTrue : fFalse;
	if (fImpersonate)
		AssertNonZero(StartFdiImpersonating());
	HANDLE hf;
	hf = CreateFile(pszCabFileName,		// file name
				   GENERIC_READ,    // we want to read
				   FILE_SHARE_READ, // we'll let people share this
				   NULL,			     // ignore security
				   OPEN_EXISTING,	  // must already exist
				   0L,				  // don't care about attributes
				   NULL);			  // no template file
	if (hf != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(hf);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), pszCabFileName);
			WIN::CloseHandle(hf);
			hf = INVALID_HANDLE_VALUE;
			SetLastError(ERROR_OPEN_FAILED);
		}
	}

	if (fImpersonate)
		StopFdiImpersonating();

	if (hf != INVALID_HANDLE_VALUE)
		MsiRegisterSysHandle(hf);

	Assert((INT_PTR)hf <= INT_MAX);		//--merced: need to ensure that hf is in the 32-bit range, else we can't pass it out as an int.
	return (int)HandleToLong(hf);		//--merced: okay to typecast since hf will be in the 32-bit range.
}


int OpenStreamCabinet(const ICHAR* pszCabFileName, int /*oflag*/, int /*pmode*/)
/*----------------------------------------------------------------------------
Called from pfnopen - Opens a cabinet stored in a stream within an IMsiStorage
container.

Returns:
-1 if the cabinet stream cannot be found and opened, otherwise, a pointer to
the IMsiStream object.
----------------------------------------------------------------------------*/
{
	s_icbtCurrCabType = icbtStreamCabinet;
	Assert(g_pFDIs->piStorage);
	IMsiStorage* piStorage = g_pFDIs->piStorage;
	IMsiStream* piStream;
	if (s_iNextStream == 0)
	{
		PMsiRecord pErrRec = piStorage->OpenStream(pszCabFileName, fFalse,piStream);
		if (pErrRec)
			return -1;
	}
	else
	{
		piStream = s_piStream[s_iNextStream]->Clone();
		if (!piStream)
			return -1;
	}
	s_iNextStream++;
	if(s_iNextStream > MAX_SEEK_COUNT)
	{
		DEBUGMSG(TEXT("ERROR:Static limit 4 on number of simultaneous opens on stream cabinet reached"));
		return -1;
	}
	s_piStream[s_iNextStream] = piStream;
#ifdef USE_OBJECT_POOL
	return PutObjectData(piStream);
#else
	Assert((INT_PTR)piStream <= INT_MAX);		//!!merced: need to ensure that piStream is in the 32-bit range, else we can't pass it out as an int.
	return (int)HandleToLong(piStream);			//!!merced: this may not be okay since we just create it!
#endif
}


/* P F N  R E A D */
/*----------------------------------------------------------------------------
	%%Function: pfnread

	FDI file read callback. Must emulate "_read".
----------------------------------------------------------------------------*/
UINT FAR DIAMONDAPI pfnread(INT_PTR hf, void FAR *pv, UINT cb)
{
	if (s_icbtCurrCabType == icbtStreamCabinet)
	{
		for (;;)
		{
			int cbActual = ReadStreamCabinet(hf, pv, cb);
			if (cbActual == 0)
			{
				FDIServerCommand fdic = WaitCommand(fdirStreamReadError);
				if (fdic == fdicCancel)
				{
					g_fdirCallbackError = fdirUserAbort;
					return 0;
				}
				else
					continue;
			}
			return cbActual;
		}
	}
	else
	{
		AssertFDI(s_icbtCurrCabType == icbtFileCabinet);
		DWORD cbRead;

		for (;;)
		{
			UINT iCurrMode = WIN::SetErrorMode(SEM_FAILCRITICALERRORS);
			Bool fReadSuccess = ToBool(ReadFile((HANDLE)hf, pv, cb, &cbRead, NULL));
			DWORD dwLastError = WIN::GetLastError();
			WIN::SetErrorMode(iCurrMode);

			if (!fReadSuccess)
			{
				 if (dwLastError == ERROR_NOT_READY || dwLastError == ERROR_GEN_FAILURE)
					 g_fdirCallbackError = fdirDriveNotReady;
				 else if (NET_ERROR(dwLastError))
				 {
					 g_fdirCallbackError = fdirNetError;
					 return 0;
				 }		
				 else
					 g_fdirCallbackError = fdirCabinetReadError;

				FDIServerCommand fdic = WaitCommand(g_fdirCallbackError);
				if ((fdic == fdicCancel) || (fdic == fdicOpenCabinet))
				{
					// Opening another cabinet in the middle of a read
					// is basically the same as cancelling.  There might have
					// been some sort of error, so let the caller know they
					// need to start over.
					g_fdirCallbackError = fdirUserAbort;
					return 0;
				}
				else
					continue;
			}
			break;
		}

		return cbRead;
	}
}


UINT ReadStreamCabinet(INT_PTR hf, void* pv, UINT cb)
/*----------------------------------------------------------------------------
Called from pfnread - Reads data from a cabinet that has been stored as a
stream within our host database.

Returns: the actual count of bytes copied to the caller's buffer.
----------------------------------------------------------------------------*/
{
#ifdef USE_OBJECT_POOL
	IMsiStream* piStream = (IMsiStream*)GetObjectData((int)hf);
#else
	IMsiStream* piStream = (IMsiStream*) hf;
#endif
	int iRemaining = piStream->Remaining();
	cb = (iRemaining < (int)cb) ? iRemaining : cb;
	return piStream->GetData(pv,cb);
}


/* P F N  W R I T E */
/*----------------------------------------------------------------------------
	%%Function: pfnwrite

	FDI file write callback. Must emulate "_write".  Writes data to our new
	decompressed target file.

	This function writes data in g_pFDIs->cbNotification size blocks,
	returning an fdirNotification message after each such block.
----------------------------------------------------------------------------*/

UINT FAR DIAMONDAPI pfnwrite(INT_PTR hf, void FAR *pv, UINT cb)
{
	unsigned long cbWritten;
	UINT          cbToNextNotification;
	BOOL          fEnd;
	UINT          cbLeft = cb;
	FDIServerCommand fdic;
	while (cbLeft)
	{
		// Get count of bytes to next notification - if cbNotification is 0,
		// we want to send no notifications.
		if (g_pFDIs->cbNotification == 0)
			cbToNextNotification = cbLeft + 1;
		else
			cbToNextNotification = g_pFDIs->cbNotification - g_pFDIs->cbNotifyPending;
		// If this count is less than the number we have left, 
		// then use that number instead
		UINT cbBytesToWrite;
		fEnd = cbLeft < cbToNextNotification;
		if (fEnd)
			cbBytesToWrite = cbLeft;
		else
			cbBytesToWrite = cbToNextNotification;
		// Write a piece out

		for (;;)
		{
			if(g_pFDIs->piASM)
			{
				IStream* piStream = (IStream*) hf;
				HRESULT hr = piStream->Write(pv, cbBytesToWrite, &cbWritten);
				if(!SUCCEEDED(hr))
				{
					g_fdirCallbackError = fdirErrorWritingFile;
					FDIServerCommand fdic = WaitCommand(g_fdirCallbackError);
					if (fdic == fdicCancel)
					{
						g_fdirCallbackError = fdirUserAbort;
						return 0;
					}
					else
						continue;
				}
			}
			else
			{
				BOOL fWriteOK = WriteFile((HANDLE)hf, pv, cbBytesToWrite, &cbWritten, NULL);
				if (!fWriteOK)
				{
					DWORD dwLastError = GetLastError();
					if (dwLastError == ERROR_DISK_FULL)
						g_fdirCallbackError = fdirDiskFull;
					else if (NET_ERROR(dwLastError))
					{
						 g_fdirCallbackError = fdirNetError;
						 return 0;
					}		
					else
						g_fdirCallbackError = fdirErrorWritingFile;

					FDIServerCommand fdic = WaitCommand(g_fdirCallbackError);
					if (fdic == fdicCancel)
					{
						g_fdirCallbackError = fdirUserAbort;
						return 0;
					}
					else
						continue;
				}
			}
			break;
		}

		// Update counts, pointers
		pv = (char *)pv + cbWritten;
		cbLeft -= cbWritten;
		g_pFDIs->cbNotifyPending += cbWritten;

		if (!fEnd)
		{
			g_pFDIs->cbNotifyPending -= g_pFDIs->cbNotification;
			fdic = WaitCommand(fdirNotification);
			if (fdic == fdicClose)
			{
				g_fdirCallbackError = fdirClose;
				return 0;
			}
			else if (fdic != fdicContinue)
			{
				NotifyUser("FDI Server: Not allowed to continue after notification in pfnwrite");
				return 0;
			}
		}
	}
	return cb; 
}

/* P F N  C L O S E */
/*----------------------------------------------------------------------------
	%%Function: pfnclose

	FDI file close callback. Must emulate "_close".
----------------------------------------------------------------------------*/
int FAR DIAMONDAPI pfnclose(INT_PTR hf)
{
	if(g_pFDIs->piASM)
	{
		IStream* piStream = (IStream*) hf;
		if(g_pDestFile == piStream)
		{
			piStream->Release();
			return 0;
		}
	}
	else
	{
		// pfnclose can also be called to close the destination file if an
		// error occurred when writing to it, so check for that now.
		Assert((INT_PTR)g_hCurDestFile <= INT_MAX);				//--merced: g_hCurDestFile better fit into an int, else we can't typecast below.
		if (hf == (int) HandleToLong(g_hCurDestFile))			//--merced: okay to typecast
		{
			int f = MsiCloseSysHandle((HANDLE) hf);
			f &= ToBool(WIN::DeleteFile(g_pFDIs->achFileDestinationPath));
			return f;
		}
	}

	if (s_icbtCurrCabType == icbtStreamCabinet)
		return CloseStreamCabinet(hf);

	AssertFDI(s_icbtCurrCabType == icbtFileCabinet || s_icbtCurrCabType == icbtNextEnum);
	s_icbtCurrCabType = icbtNextEnum;

	// Returns 0 if unsuccessful
	return !MsiCloseSysHandle((HANDLE)hf);
}


int CloseStreamCabinet(INT_PTR hf)
/*----------------------------------------------------------------------------
Called from pfnclose - releases the cabinet stream.

Returns: 0 if the stream was released successfully.
----------------------------------------------------------------------------*/
{
#ifdef USE_OBJECT_POOL
	IMsiStream* piStream = (IMsiStream*)GetObjectData((int)hf);
#else
	IMsiStream* piStream = (IMsiStream*) hf;
#endif
	piStream->Release();
	if (--s_iNextStream == 0)
		s_icbtCurrCabType = icbtNextEnum;
	return 0;
}


/* P F N  S E E K */
/*----------------------------------------------------------------------------
	%%Function: pfnseek

	FDI file seek callback. Must emulate "_lseek".
----------------------------------------------------------------------------*/
long FAR DIAMONDAPI pfnseek(INT_PTR hf, long dist, int seektype)
{
	if (s_icbtCurrCabType == icbtStreamCabinet)
		return SeekStreamCabinet(hf, dist, seektype);

	AssertFDI(s_icbtCurrCabType == icbtFileCabinet);
	DWORD dwMoveMethod;

	switch (seektype)
	{
		case 0 /* SEEK_SET */ :
		{
			dwMoveMethod = FILE_BEGIN;
			break;
		}
		case 1 /* SEEK_CUR */ :
		{
			dwMoveMethod = FILE_CURRENT;
			break;
		}
		case 2 /* SEEK_END */ :
		{
			dwMoveMethod = FILE_END;
			break;
		}
		default :
		{
			AssertFDI(0);
			return -1;
		}
	}
	// SetFilePointer returns -1 if it fails (this will cause FDI to quit with an
	// FDIERROR_USER_ABORT error. (Unless this happens while working on a cabinet,
	// in which case FDI returns FDIERROR_CORRUPT_CABINET)
	int fpos = SetFilePointer((HANDLE) hf, dist, NULL, dwMoveMethod);
	return fpos;
}


int SeekStreamCabinet(INT_PTR hf, long dist, int seektype)
/*----------------------------------------------------------------------------
Called from pfnseek - seeks to a specific spot within the stream.
Returns:
-1 if the seek fails, otherwise the current seek position. IMsiStream
----------------------------------------------------------------------------*/
{
#ifdef USE_OBJECT_POOL
	IMsiStream* piStream = (IMsiStream*)GetObjectData((int)hf);
#else
	IMsiStream* piStream = (IMsiStream*) hf;
#endif
	int iByteCount = piStream->GetIntegerValue();
	int iRemaining = piStream->Remaining();
	int iSeek;
	switch (seektype)
	{
		case 0 /* SEEK_SET */ :
			iSeek = dist;
			break;
		case 1 /* SEEK_CUR */ :
			iSeek = iByteCount - iRemaining + dist;
			break;
		case 2 /* SEEK_END */ :
			iSeek = iByteCount - dist;
			break;
		default :
			NotifyUser("FDI Server:unknown seektype in pfnseek");
			return -1;
			break;
	}
	if (iSeek < 0 || iSeek > iByteCount)
		return -1;
	else
	{
		piStream->Seek(iSeek);
		return iSeek;
	}
}



/* C A B I N E T  I N F O */
/*----------------------------------------------------------------------------
	%%Function: CabinetInfo

	Called when we receive a fdintCABINET_INFO notification.
----------------------------------------------------------------------------*/
int CabinetInfo(PFDINOTIFICATION /*pfdin*/)
{
	// We actually get access to some cabinet info through p->,
	// but don't need to do anything with it.
	return 0;  // Do nothing
}

/* C R E A T E  D E S T I N A T I O N  F I L E */
/*----------------------------------------------------------------------------
	%%Function: CreateDestinationFile

	Creates and opens the file specified by g_pFDIs->achFileDestinationPath and 
	g_pFDIs->achFileSourceName. Returns a handle to the file. 
----------------------------------------------------------------------------*/
INT_PTR CreateDestinationFile()
{
	if(g_pFDIs->piASM)
	{
		IStream* piDestFile;
		for(;;)
		{			
#ifdef UNICODE
			HRESULT hr = (g_pFDIs->piASM)->CreateStream(0, g_pFDIs->achFileDestinationPath, g_pFDIs->fManifest ? STREAM_FORMAT_COMPLIB_MANIFEST : 0, 0, &piDestFile, NULL);
#else
			void ConvertMultiSzToWideChar(const IMsiString& ristrFileNames, CTempBufferRef<WCHAR>& rgch);// from execute.cpp
			CTempBuffer<WCHAR, MAX_PATH>  rgchDestPath;
			MsiString strDestPath = *g_pFDIs->achFileDestinationPath;
			ConvertMultiSzToWideChar(*strDestPath, rgchDestPath);
			HRESULT hr = (g_pFDIs->piASM)->CreateStream(0, rgchDestPath, g_pFDIs->fManifest ? STREAM_FORMAT_COMPLIB_MANIFEST : 0, 0, &piDestFile, NULL);
#endif
			if(!SUCCEEDED(hr))
			{
				g_fdirCallbackError = fdirCannotCreateTargetFile;

				FDIServerCommand fdic = WaitCommand(g_fdirCallbackError);
				if (fdic == fdicCancel)
				{
					g_fdirCallbackError = fdirUserAbort;
					return INT_PTR(INVALID_HANDLE_VALUE);
				}
				else if (fdic == fdicIgnore)
				{
					// Acknowledge that we've successfully ignored this file,
					// and call WaitCommand to await further instructions
					g_fdirCallbackError = fdirUserIgnore;
					fdic = WaitCommand(fdirSuccessfulCompletion);
					return 0;
				}
				else
					continue;
			}
			else
				break;
		}
		return INT_PTR(g_pDestFile = piDestFile);
	}
	else
	{
		// Try to create the file
		HANDLE hf;
		for(;;)
		{


			bool fImpersonate = (g_pFDIs->iDestDriveType == DRIVE_REMOTE);
			if (fImpersonate)
				AssertNonZero(StartFdiImpersonating());

			hf = MsiCreateFileWithUserAccessCheck(g_pFDIs->achFileDestinationPath,	// file name
									g_pFDIs->pSecurityAttributes,   // do NOT ignore security						
									g_pFDIs->fileAttributes.attr,	// required file attributes
									fImpersonate);

			int iLastError = WIN::GetLastError();
			if (fImpersonate)
				StopFdiImpersonating();
			
			// If this doesn't work, then we probably don't have write permission to that file,
			// because we know the MsiCabinetCopier object already made sure any existing
			// destination file was not READ_ONLY, HIDDEN, etc.
			if (hf != INVALID_HANDLE_VALUE)
			{
				MsiRegisterSysHandle(hf);
				break;
			}
			else
			{
				if (iLastError == ERROR_ACCESS_DENIED)
				{
					if (fImpersonate)
						AssertNonZero(StartFdiImpersonating());
					DWORD dwAttr = MsiGetFileAttributes(g_pFDIs->achFileDestinationPath);
					if (fImpersonate)
						StopFdiImpersonating();
					if (dwAttr != 0xFFFFFFFF && (dwAttr & FILE_ATTRIBUTE_DIRECTORY))
						g_fdirCallbackError = fdirDirErrorCreatingTargetFile;
					else
						g_fdirCallbackError = fdirCannotCreateTargetFile;
				}
				else
					g_fdirCallbackError = fdirCannotCreateTargetFile;

				FDIServerCommand fdic = WaitCommand(g_fdirCallbackError);
				if (fdic == fdicCancel)
				{
					g_fdirCallbackError = fdirUserAbort;
					break;
				}
				else if (fdic == fdicIgnore)
				{
					// Acknowledge that we've successfully ignored this file,
					// and call WaitCommand to await further instructions
					g_fdirCallbackError = fdirUserIgnore;
					fdic = WaitCommand(fdirSuccessfulCompletion);
					hf = 0; // Tells FDI to continue, ignoring the current file
					break;
				}
				else
					continue;
			}
		}

		//!! eugend: in the future we'll have to replace the three lines below
		// with:  return INT_PTR(g_hCurDestFile = hf);
		// This is so because on Win64 pointers (and implicitly HANDLEs)
		// are 64-bit and what we're doing below is that we truncate them to 32-bit
		// values before returning them.  We didn't crash so far on Win64 because
		// the handle values returned by CreateFile fit into 32-bits.
		Assert((INT_PTR)hf <= INT_MAX);		//--merced: need to ensure that hf is in the 32-bit range, else we can't pass it out as an int.
		g_hCurDestFile = hf;
		return (int)HandleToLong(hf);		//--merced: okay to typecast since hf will be in the 32-bit range.
	}
}
	

/* C O P Y  F I L E */
/*----------------------------------------------------------------------------
	%%Function: CopyFile
	Called when we receive a fdintCOPY_FILE notification. 
	
	  The following FDI interface requests, and CopyFile's responses are possible:
	
	FDIi:      extract the file "pfdin->psz1"
	CopyFile:  create and return a handle to the destination file. 
	
	FDIi:      extract a file other than "pfdin->psz1"
	CopyFile:  return 0, indicating we don't want that file extracted.
	
	FDIi:      close
	CopyFile:  return -1, indicating we want to abort
	
	FDIi:      open cabinet, or no command pending
	CopyFile:  wait for a command. If it's ExtractFile, then call CopyFile again,
	           otherwise, return -1, indicated we want to abort.
----------------------------------------------------------------------------*/
INT_PTR CopyFile(PFDINOTIFICATION pfdin)
{
	switch(g_pFDIs->fdic)
	{
		case fdicNoCommand: // No command, so we wait for one
		case fdicOpenCabinet:
		{
			// If the last command was fdicOpenCabinet, then this must
			// be the first CopyFile notification after opening a cabinet
			for(;;)
			{
				switch (WaitCommand(fdirSuccessfulCompletion))
				{
					case fdicOpenCabinet:
					{
						g_fdirCallbackError = fdirNeedNextCabinet;
						return -1; // Break out of current cabinet, go on to next
					}
					case fdicExtractFile:
					{
						return CopyFile(pfdin);
					}
					case fdicClose:
					{
						g_fdirCallbackError = fdirClose;
						return -1;
					}
					case fdicContinue:
					{
						g_fdirCallbackError = fdirIllegalCommand;
						return -1;
					}
					case fdicIgnore:
						continue;
					case fdicCancel:
					{
						g_fdirCallbackError = fdirUserAbort;
						return -1;
					}
					default:
					{
						NotifyUser("FDI Server: Unknown command type");
						g_fdirCallbackError = fdirIllegalCommand;
						return -1;
					}
				}
			}
		}
		case fdicClose:
		{
			return -1;
		}
		case fdicExtractFile:
		{
			// If the file we've been asked to extract by the FDI Interface object
			// is the same as the one FDI has, then create the destination file

			if (!IStrCompI(CConvertString(pfdin->psz1), g_pFDIs->achFileSourceName))
			{
				return CreateDestinationFile();
			}
			else
			{
				// Nope, this is not the file we want
				return 0;
			}
		}
		default:
		{
			NotifyUser("FDI Server: Unknown command type");
			g_fdirCallbackError = fdirIllegalCommand;
			return -1;
		}
	}
}


/* C L O S E  F I L E  I N F O */
/*----------------------------------------------------------------------------
	%%Function: CloseFileInfo

	Called when we receive the fdintCLOSE_FILE_INFO notification.
	
	Closes the specified (pfdin->hf) file handle.

	Sets the file Date/Time using the values passed in through 
	FDI_Interface::ExtractFile(..).  If datetime==0, then it uses the
	values from the cabinet.
----------------------------------------------------------------------------*/
int CloseFileInfo(PFDINOTIFICATION pfdin)
{
	// Here we set the file date, time and attributes
	FILETIME ftLocalUTC;
	BOOL     rc;

	// Make sure we have something to close!
	if ((HANDLE)pfdin->hf == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	if(g_pFDIs->piASM)
	{
		IStream* piStream = (IStream*) pfdin->hf;
		HRESULT hr = piStream->Commit(0);
		piStream->Release();
		if(!SUCCEEDED(hr))
		{
			// capture assembly error in verbose log
			PMsiRecord pError(PostAssemblyError(TEXT(""), hr, TEXT("IStream"), TEXT("Commit"), TEXT("")));
			return FALSE;
		}
	}
	else
	{
		rc = DosDateTimeToFileTime(pfdin->date,
											pfdin->time,
											&ftLocalUTC);

		// Per bug 9225, convert from local to universal time first, then set file date/time
		// Also, set the last acccessed time to the current time, same as for non-compressed files
		FILETIME ftUTC, ftCurrentUTC;
		rc &= LocalFileTimeToFileTime(&ftLocalUTC, &ftUTC);
		GetSystemTimeAsFileTime(&ftCurrentUTC);
		// Set the file date/time
		rc &= SetFileTime((HANDLE)pfdin->hf,&ftUTC,&ftCurrentUTC,&ftUTC);
		// Close the file
		rc &= MsiCloseSysHandle((HANDLE)pfdin->hf);

		if (!rc)  // Couldn't set one or more attribs -- or couldn't close file
		{
			g_fdirCallbackError = fdirCannotSetAttributes;
			return FALSE;
		}
	}
	g_pFDIs->fdic = fdicNoCommand;
	g_pFDIs->fPendingExtract = 0;
	return TRUE;
}

/* P A R T I A L  F I L E */
/*----------------------------------------------------------------------------
	%%Function: PartialFile

	Called when we receive the fdintPARTIAL_FILE notification.
	
	This call only happens when a file is split across cabinets
----------------------------------------------------------------------------*/
int PartialFile(PFDINOTIFICATION /*pfdin*/)
{
	return 0; //Yes, just continue; no special processing necessary
}


/* N E X T  C A B I N E T */
/*----------------------------------------------------------------------------
	%%Function: NextCabinet

	Called when we receive the fdintNEXT_CABINET notification.
	
	Reponds to the FDI interface that a new cabinet is needed. If the interface
	commands the server to continue, then 0 is returned. If the interface issues
	any other command, -1 is returned, aborting the extraction.
----------------------------------------------------------------------------*/
int NextCabinet(PFDINOTIFICATION pfdin)
{
	const ICHAR * psz1convert = CConvertString(pfdin->psz1);
	const ICHAR * psz2convert = CConvertString(pfdin->psz2);
	const ICHAR * psz3convert = CConvertString(pfdin->psz3);

	if ( ! psz1convert || ! psz2convert || ! psz3convert )
		return -1;

	// Set up shared data
	ASSERT_IF_FAILED(StringCchCopy(g_pFDIs->achCabinetName, ARRAY_ELEMENTS(g_pFDIs->achCabinetName), psz1convert));
	ASSERT_IF_FAILED(StringCchCopy(g_pFDIs->achCabinetPath, ARRAY_ELEMENTS(g_pFDIs->achCabinetPath), psz3convert));
	ASSERT_IF_FAILED(StringCchCopy(g_pFDIs->achDiskName, ARRAY_ELEMENTS(g_pFDIs->achDiskName), psz2convert));

	switch(WaitCommand(fdirNeedNextCabinet))
	{
		case fdicOpenCabinet:
		{
			// FDIInterface returns from the fdirNeedNextCabinet message with
			// the path of the new cabinet.  Give that path back to FDI.  And
			// in case the cabinet name in the Media table is different than
			// that stored in the cabinet file, give our name back to FDI too.
			ASSERT_IF_FAILED(StringCchCopyA(pfdin->psz1,
													  FDIShared_BUFSIZE,  // ARRAY_ELEMENTS(g_pFDIs->achCabinetName).  I'm not certain is right, but at least it will get StringCchCopyA going
													  CConvertString(g_pFDIs->achCabinetName)));
			ASSERT_IF_FAILED(StringCchCopyA(pfdin->psz3,
													  256,  // I've got this piece of info from fdi.h
													  CConvertString(g_pFDIs->achCabinetPath)));
			if (WaitCommand(fdirSuccessfulCompletion) == fdicContinue)
			{
				return 0;
			}
			else
			{
				g_fdirCallbackError = fdirIllegalCommand;
				return -1;
			}
		}
		case fdicClose:
		{
			g_fdirCallbackError = fdirClose;
			return -1;
		}
		case fdicExtractFile:
		{
			g_fdirCallbackError = fdirIllegalCommand;
			return -1;
		}
		case fdicContinue:
		{
			g_fdirCallbackError = fdirIllegalCommand;
			return -1;
		}
		default:
		{
			NotifyUser("FDI Server: Unknown command in NextCabinet()");
			g_fdirCallbackError = fdirIllegalCommand;
			return -1;
		}
	}
}


/* F N  F D I  N O T I F Y */
/*----------------------------------------------------------------------------
	%%Function: FNFDINOTIFY

	Dispatches FDI notifications to the appropriate functions.
----------------------------------------------------------------------------*/
FNFDINOTIFY(fdinotify)
{
	switch(fdint)
	{
		case fdintCABINET_INFO :
		{
			//NotifyUser("FDI Server: Received fdintCABINET_INFO notification");
			return CabinetInfo(pfdin);
		}
		case fdintCOPY_FILE :	
		{
			//NotifyUser("FDI Server: Received fdintCOPY_FILE notification");
			return CopyFile(pfdin);
		}
		case fdintCLOSE_FILE_INFO :
		{
			//NotifyUser("FDI Server: Received fdintCLOSE_FILE_INFO notification");
			return CloseFileInfo(pfdin);
		}
		case fdintPARTIAL_FILE :
		{
			//NotifyUser("FDI Server: Received fdintPARTIAL_FILE notification");
			return PartialFile(pfdin);
		}
		case fdintNEXT_CABINET :
		{
			//NotifyUser("FDI Server: Received fdintNEXT_CABINET notification");
			return NextCabinet(pfdin);
		}
		case fdintENUMERATE:
			// Not specifically supporting enumeration - return anything but -1
			// to continue normally
			return 0;
		default:
		{
			NotifyUser("FDI Server: unknown command received by fdinotify");
			g_fdirCallbackError = fdirIllegalCommand;
			return -1;
		}
	}
}

/* F N  F D I  D E C R Y P T*/
/*----------------------------------------------------------------------------
	%%Function: FNFDIDECRYPT
	
	We don't do any decryption yet.  But when we do, this is the routine
	to put all the decryption stuff in.
----------------------------------------------------------------------------*/
FNFDIDECRYPT(fdidecrypt)
{
	&pfdid; // This is here to avoid the unused argument warning.
			// It comes from the expansion of the macro in the
			// declaration.

	NotifyUser("FDI Server: Decryption not implemented yet!");
	g_fdirCallbackError = fdirDecryptionNotSupported;
	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\camgr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       camgr.cpp
//
//--------------------------------------------------------------------------

// The Custom Action Manager is responsible for complete management of remote servers, 
// actions running on them, and API calls coming from them. It manages the lifetime of
// the API thread, stores interface ponters to remote processes based on context, and
// determines the correct way to create CA servers (based on context and client/server)
//!! future: in an ideal world, even inproc actions would run through the mananger so
//!!   that all actions are managed at a single location.

#include "precomp.h" 
#include "_camgr.h"
#include "_msiutil.h"
#include "_engine.h"
#include "_autoapi.h"

CMsiCustomActionManager::CMsiCustomActionManager(bool fRemapHKCU) :
	m_fRemapHKCU(fRemapHKCU), m_piGIT(0), m_hRemoteAPIEvent(0), m_dwRemoteAPIThread(0), m_hRemoteAPIThread(0), m_pRemoteAPI(0), m_hCreateEvent(0), m_icacCreateContext(icacFirst)
{
	InitializeCriticalSection(&m_csCreateProxy);
	for (int i=0; i<icacNext; i++)
	{
		m_CustomActionInfo[i].dwServerProcess = 0;
		m_CustomActionInfo[i].hServerProcess = 0;
		m_CustomActionInfo[i].dwGITCookie = 0;
	}
};

CMsiCustomActionManager::~CMsiCustomActionManager()
{
	// we should never have a custom action server this late, but if for
	// some reason we do, kill it with extreme prejudice.
	for (int icacContext=icacFirst; icacContext < icacNext; icacContext++)
	{
		if (m_CustomActionInfo[icacContext].hServerProcess)
		{
			TerminateProcess(m_CustomActionInfo[icacContext].hServerProcess, 0);
			CloseHandle(m_CustomActionInfo[icacContext].hServerProcess);
			m_CustomActionInfo[icacContext].hServerProcess = 0;
			m_CustomActionInfo[icacContext].dwServerProcess = 0;
		}
	}

	// if we've got a GIT, release it.
	if (m_piGIT)
	{
		m_piGIT->Release();
		m_piGIT = 0;
	}
	DeleteCriticalSection(&m_csCreateProxy);
}


///////////////////////////////////////////////////////////////////////
// verifies that the HKCU remapping flag for elevated servers matches
// the requested stase. If not, it shuts down the elevated servers and
// refreshes the desired state. Returns true if the state was already
// correct, false otherwise.
bool CMsiCustomActionManager::EnsureHKCUKeyMappingState(bool fRemapHKCU)
{
	if (m_fRemapHKCU == fRemapHKCU)
		return true;

	EnterCriticalSection(&m_csCreateProxy);
	m_fRemapHKCU = fRemapHKCU;
	ShutdownSpecificCustomActionServer(icac32Elevated);
#ifdef WIN64
	ShutdownSpecificCustomActionServer(icac64Elevated);
#endif
	LeaveCriticalSection(&m_csCreateProxy);
	return false;
}


// RunCustomAction runs the specified DLL and entry point in the specified context,
// creating a custom action server if necessary. This function may connect to the service
// if called from the client. 
HRESULT CMsiCustomActionManager::RunCustomAction(icacCustomActionContext icacContext,
		const ICHAR* szPath, const ICHAR* szEntryPoint, MSIHANDLE hInstall, 
		bool fDebugBreak, bool fDisableMessages, bool fAppCompat, const GUID* pguidAppCompatDB, const GUID* pguidAppCompatID,
		IMsiMessage& riMessage, const ICHAR* szAction, unsigned long* pulRet)
{
	// GetCustomActionInterface will create the server if needed and return
	// an AddRef-ed interface pointer.
	PMsiCustomAction piAction = GetCustomActionInterface(true, icacContext);

	if (piAction)
	{
		// remote ThreadId is used to disable message processing during a 
		// synchronous custom action (to avoid deadlock in UI handler)
		DWORD dwRemoteThreadId = 0;

		// increment context action refcount to enable API handler for this 
		// context
		if (m_pRemoteAPI)
			m_pRemoteAPI->BeginAction(icacContext);

		// set-up the remote process for the DLL action. The thread to run
		// the action is created in a suspended state and initialized.
		if (ERROR_SUCCESS == piAction->PrepareDLLCustomAction(szAction, szPath, szEntryPoint, hInstall, 
			fDebugBreak, fAppCompat, pguidAppCompatDB, pguidAppCompatID, &dwRemoteThreadId))
		{
			// disable thread messages to the UI handler from the remote thread
			if (fDisableMessages)
				g_MessageContext.DisableThreadMessages(dwRemoteThreadId);

			// if in the client, pass rights to the foreground to the CA server. 
			if (g_scServerContext == scClient)
				USER32::AllowSetForegroundWindow(m_CustomActionInfo[icacContext].dwServerProcess);

			// re-enable the remote thread to run the action
			piAction->RunDLLCustomAction(dwRemoteThreadId, pulRet);

			// re-enable messages from all threads
			if (fDisableMessages)
				g_MessageContext.EnableMessages();

			// check that all handles are closed based on the thread Id in the
			// remote process
			UINT cHandles = 0;
			if ((cHandles = CheckAllHandlesClosed(true, dwRemoteThreadId)) != 0)
			{
				// if messages are disabled for this action, leaked handle notification
				// must also be disabled.
				if (!fDisableMessages)
					riMessage.Message(imtInfo, *PMsiRecord(::PostError(Imsg(idbgCustomActionLeakedHandle), szAction, cHandles)));
			}

			piAction->FinishDLLCustomAction(dwRemoteThreadId);
		}

		// decrement context action refcount to disable the API handler for this 
		// context. This prevents "stale" threads from misbehaving.
		if (m_pRemoteAPI)
			m_pRemoteAPI->EndAction(icacContext);

		return ERROR_SUCCESS;
	}
	return ERROR_FUNCTION_FAILED;
}

#define NO_CA_POINTER { \
	const ICHAR rgchMsg[] = TEXT("Failed to get IMsiCustomAction*"); \
	AssertSz(0, rgchMsg); \
	DEBUGMSG(rgchMsg); \
}
#define GET_CA_POINTER  \
	PMsiCustomAction piAction = NULL; \
	piAction = GetCustomActionInterface(true, \
													IsImpersonating(false) ? icac32Impersonated : icac32Elevated);


HRESULT CMsiCustomActionManager::QueryPathOfRegTypeLib(REFGUID guid,
										unsigned short wVerMajor, unsigned short wVerMinor,
										LCID lcid, OLECHAR *lpszPathName, int cchPath)
{
	GET_CA_POINTER
	if (piAction)
		return piAction->QueryPathOfRegTypeLib(guid, wVerMajor, wVerMinor, lcid,
															lpszPathName, cchPath);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

HRESULT
CMsiCustomActionManager::ProcessTypeLibrary(const OLECHAR* szLibID, LCID lcidLocale, 
											const OLECHAR* szTypeLib, const OLECHAR* szHelpPath, 
											int fRemove, int *fInfoMismatch)
{
	GET_CA_POINTER
	if (piAction)
		return piAction->ProcessTypeLibrary(szLibID, lcidLocale, szTypeLib, szHelpPath, 
														fRemove, fInfoMismatch);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLInstallDriverEx(int cDrvLen, const ICHAR* szDriver,
														  const ICHAR* szPathIn, ICHAR* szPathOut,
														  WORD cbPathOutMax, WORD* pcbPathOut,
														  WORD fRequest, DWORD* pdwUsageCount)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLInstallDriverEx(cDrvLen, szDriver, szPathIn, szPathOut,
													cbPathOutMax, pcbPathOut, fRequest, pdwUsageCount);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLConfigDriver(WORD fRequest,
										const ICHAR* szDriver, const ICHAR* szArgs,
										ICHAR* szMsg, WORD cbMsgMax, WORD* pcbMsgOut)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLConfigDriver(fRequest, szDriver, szArgs,
															szMsg, cbMsgMax, pcbMsgOut);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLRemoveDriver(const ICHAR* szDriver, int fRemoveDSN,
										DWORD* pdwUsageCount)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLRemoveDriver(szDriver, fRemoveDSN, pdwUsageCount);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLInstallTranslatorEx(int cTranLen, const ICHAR* szTranslator,
																const ICHAR* szPathIn, ICHAR* szPathOut,
																WORD cbPathOutMax, WORD* pcbPathOut,
																WORD fRequest, DWORD* pdwUsageCount)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLInstallTranslatorEx(cTranLen, szTranslator,
													szPathIn, szPathOut, cbPathOutMax, pcbPathOut,
													fRequest, pdwUsageCount);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLRemoveTranslator(const ICHAR* szTranslator, DWORD* pdwUsageCount)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLRemoveTranslator(szTranslator, pdwUsageCount);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLConfigDataSource(WORD fRequest,
										const ICHAR* szDriver, const ICHAR* szAttributes,
										DWORD cbAttrSize)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLConfigDataSource(fRequest, szDriver,
													szAttributes, cbAttrSize);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLInstallDriverManager(ICHAR* szPath, WORD cbPathMax,
																 WORD* pcbPathOut)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLInstallDriverManager(szPath, cbPathMax, pcbPathOut);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

BOOL
CMsiCustomActionManager::SQLRemoveDriverManager(DWORD* pdwUsageCount)
{
	GET_CA_POINTER
	if (piAction)
		return (BOOL)piAction->SQLRemoveDriverManager(pdwUsageCount);
	else
	{
		NO_CA_POINTER
		return E_NOINTERFACE;
	}
}

short
CMsiCustomActionManager::SQLInstallerError(WORD iError, DWORD* pfErrorCode,
														 ICHAR* szErrorMsg, WORD cbErrorMsgMax,
														 WORD* pcbErrorMsg)
{
	GET_CA_POINTER
	if (piAction)
		return (short)piAction->SQLInstallerError(iError, pfErrorCode, szErrorMsg,
													cbErrorMsgMax, pcbErrorMsg);
	else
	{
		NO_CA_POINTER
		return -3;  // none of the documented return values
	}
}

extern IMsiRecord* UnserializeRecord(IMsiServices& riServices, int cbSize, char *pData);

// RunScriptAction takes the specified script and runs it in the specified context, 
// creating a custom action server if necessory. This function may connect to the service
// if called from the client. The IDispatch interface is from an engine (or for deferred
// actions, a generated pseudo-context).
HRESULT CMsiCustomActionManager::RunScriptAction(icacCustomActionContext icacContext,
	int icaType, IDispatch* piDispatch, const ICHAR* szSource, const ICHAR *szTarget, 
	LANGID iLangId, bool fDisableMessages, DWORD dwLaunchingThread, int* iScriptResult, IMsiRecord **piMsiRec)
{
	Assert(piMsiRec && szSource && szTarget && piDispatch && iScriptResult);
	
	// GetCustomActionInterface will create the server if needed and return
	// an AddRef-ed interface pointer.
	PMsiCustomAction piAction = GetCustomActionInterface(true, icacContext);

	if (piAction)
	{
		char *pchRecord = 0;
		int pcb = 0;

		m_pRemoteAPI->BeginAction(icacContext);

		// disable thread messages to the UI handler from the remote thread
		if (fDisableMessages)
			g_MessageContext.DisableThreadMessages(dwLaunchingThread);

		// if in the client, pass rights to the foreground to the CA server. 
		if (g_scServerContext == scClient)
			USER32::AllowSetForegroundWindow(m_CustomActionInfo[icacContext].dwServerProcess);

		HRESULT hRes = piAction->RunScriptAction(icaType, piDispatch, szSource, szTarget, iLangId, iScriptResult, &pcb, &pchRecord);

		// re-enable messages from all threads
		if (fDisableMessages)
			g_MessageContext.EnableMessages();

		m_pRemoteAPI->EndAction(icacContext);
		
		if (hRes != S_OK)
		{
			// problem marshaling
			DEBUGMSGV(TEXT("Failed to marshal script action."));
			return E_FAIL;
		}
		else
		{
			// marshaling was OK. Unserialize record with potential error information
			IMsiServices* piServices = ENG::LoadServices();
			*piMsiRec = UnserializeRecord(*piServices, pcb, pchRecord);
			OLE32::CoTaskMemFree(pchRecord);	
			ENG::FreeServices();
		}
	}
	else
	{
		// problem obtaining custom action interface
		DEBUGMSGV(TEXT("Failed to obtain custom action interface"));
		return E_FAIL;
	}
	return ERROR_SUCCESS;
}

bool CMsiCustomActionManager::MsgWaitForThreadOrEvent()
{
	HANDLE rghWaitArray[2] = {m_hRemoteAPIThread, m_hRemoteAPIEvent};
	for(;;)
	{
		DWORD iWait = WIN::MsgWaitForMultipleObjects(2, rghWaitArray, FALSE, INFINITE, QS_ALLINPUT);
		if (iWait == WAIT_OBJECT_0 + 2)  
		{		
			// window message, need to pump until the queue is clear
			MSG msg;
			while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
			{
				WIN::TranslateMessage(&msg);
				WIN::DispatchMessage(&msg);
			}
			continue;
		}
		else if (iWait == WAIT_OBJECT_0 + 1)
		{
			// m_hRemoteAPIEvent was signaled, we are ready
			return true;
		}
		else if (iWait == WAIT_OBJECT_0)
		{
			// because the thread is first in the wait array, WAIT_OBJECT_0 means the 
			// thread died before it could get anywhere
			return false;
		}
		else if (iWait == 0xFFFFFFFF) // should be the same on 64bit;
		{
			// error
			AssertSz(0, "Error in MsgWait");
			return false;
		}
	}
}
	
// checks for an interface with the appropriate context in the GIT. If one exists, returns it (the act of
// retrieving from the GIT AddRefs the interface). Otherwise, calls the service to create the appropriate
// interface function.
IMsiCustomAction *CMsiCustomActionManager::GetCustomActionInterface(bool fCreate, icacCustomActionContext icacDesiredContext)
{
	// creation and destruction of any proxy interface must be atomic
	EnterCriticalSection(&m_csCreateProxy);
	IMsiCustomAction *piCustomAction = NULL;

	// if in the service and the client token is actually system, then a request for an impersonated context maps
	// to a request for the elevated context. Since impersonated and elevated servers are the same, we consolidate
	// the 4 servers into 2.
	if (g_scServerContext == scService)
	{
		// don't close this handle, it belongs to the message context
		HANDLE hUserToken = GetUserToken();

		if (hUserToken && IsLocalSystemToken(hUserToken) && !TokenIsUniqueSystemToken(hUserToken))
		{
			if (icacDesiredContext == icac32Impersonated)
			{
				icacDesiredContext = icac32Elevated;
			}
			else if (icacDesiredContext == icac64Impersonated)
			{
				icacDesiredContext = icac64Elevated;
			}
		}
	}

	// ensure that we have a GIT pointer. Only one GIT exists per process, but can have multiple
	// interface to it. This interface is inherently thread safe without marshaling.
	if (!m_piGIT)
	{
		if (S_OK != OLE32::CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&m_piGIT))
		{
			LeaveCriticalSection(&m_csCreateProxy);
			return NULL;
		}
	}
 
	// We can lose connection with the CA server in 5 ways: We could lose our GIT cookie, lose the data at that cookie,
	// lose the process handle, the process could die, or the object in the CA server could be destroyed, 
	// if any of that has happened, we are lost and need to kill the CA server and regenerate everything
	bool fConnectionValid = true;
	if (!m_CustomActionInfo[icacDesiredContext].dwGITCookie ||
	    !m_CustomActionInfo[icacDesiredContext].hServerProcess || 
		WAIT_OBJECT_0 == WaitForSingleObject(m_CustomActionInfo[icacDesiredContext].hServerProcess, 0))
		fConnectionValid = false;
	else
	{	
		// if successful, this calls AddRef() on the interface
		if (S_OK != m_piGIT->GetInterfaceFromGlobal(m_CustomActionInfo[icacDesiredContext].dwGITCookie, IID_IMsiCustomAction, reinterpret_cast<void **>(&piCustomAction)))
			fConnectionValid = false;
		
		if (fConnectionValid && FAILED(SetMinProxyBlanketIfAnonymousImpLevel(piCustomAction)))
			fConnectionValid = false;

 		// verify the returned proxy still points to a valid object in the server process
		if (fConnectionValid && !OLE32::CoIsHandlerConnected(piCustomAction))
			fConnectionValid = false;
	}

	// if the connection is busted, clean up the custom action server state. Note that the RemoteAPI object is 
	// possibly still valid.
	if (!fConnectionValid)
	{
		// release the invalid custom action interface
		if (piCustomAction)
		{
			piCustomAction->Release();
			piCustomAction = NULL;
		}

		if (m_CustomActionInfo[icacDesiredContext].dwGITCookie || m_CustomActionInfo[icacDesiredContext].hServerProcess)
		{
			// if either the cookie or process exists, we think we should have a connection but don't.
			// otherwise we think this is a first-time creation
			DEBUGMSGV(TEXT("Lost connection to custom action server process. Attempting to regenerate."));
		}
		
		// clean up GIT data
		if (m_CustomActionInfo[icacDesiredContext].dwGITCookie)
		{
			m_piGIT->RevokeInterfaceFromGlobal(m_CustomActionInfo[icacDesiredContext].dwGITCookie);
			m_CustomActionInfo[icacDesiredContext].dwGITCookie = 0;
		}

		// kill process
		if (m_CustomActionInfo[icacDesiredContext].hServerProcess)
		{
			// the handle could be open but the process dead. Terminate the process if its still running
			if (WAIT_TIMEOUT == WaitForSingleObject(m_CustomActionInfo[icacDesiredContext].hServerProcess, 0))
				TerminateProcess(m_CustomActionInfo[icacDesiredContext].hServerProcess, 0);

			// once its guaranteed that the process is gone, close the handle
			CloseHandle(m_CustomActionInfo[icacDesiredContext].hServerProcess);
			m_CustomActionInfo[icacDesiredContext].hServerProcess = 0;
		}

		// verify ProcessID is 0
		m_CustomActionInfo[icacDesiredContext].dwServerProcess = 0;

		// if fCreate is false, there is no need to do anything else
		if (!fCreate)
		{
			LeaveCriticalSection(&m_csCreateProxy);			
			return NULL;
		}
			
		// now we need to create a remote MSI handler if one doesn't exist. Because we will be passing an 
		// interface to this object across to the CA server process, we need to carefully manage its lifetime. 
		// We can't call CoUnitialize on the apartment owning the object, so the object is created in its own 
		// thread because this thread could be STA meaning thread==apartment.
		if (!m_hRemoteAPIThread)
		{
			m_hRemoteAPIEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
			m_hRemoteAPIThread = WIN::CreateThread((LPSECURITY_ATTRIBUTES)0, 4096*10,
								(LPTHREAD_START_ROUTINE)CustomActionManagerThread, (LPVOID)this, 0, &m_dwRemoteAPIThread);
			if (!m_hRemoteAPIThread)
			{
				LeaveCriticalSection(&m_csCreateProxy);
				return NULL;
			}
			
			// its unclear if we need to pump messages here, but since we're on a thread that 
			// could have COM running, the assumption is that we do.
			if (!MsgWaitForThreadOrEvent())
			{
				LeaveCriticalSection(&m_csCreateProxy);
				return NULL;
			}
		}

		// Signal CreateEvent to waken the manager thread and let it know to create 
		// the proxy
		m_icacCreateContext = icacDesiredContext;
		if(!SetEvent(m_hCreateEvent))
		{
			m_piGIT->RevokeInterfaceFromGlobal(m_CustomActionInfo[icacDesiredContext].dwGITCookie);
			m_CustomActionInfo[icacDesiredContext].dwGITCookie = 0;
			LeaveCriticalSection(&m_csCreateProxy);
			return NULL;
		}

		// then wait for the manager thread to signal the RemoteAPIEvent to signify that
		// the proxy is ready or that the creation has failed. Its not clear if we 
		// need to pump messages here, but since we're on a thread that could have COM
		// running, the assumption is that we do.
		if (!MsgWaitForThreadOrEvent())
		{
			LeaveCriticalSection(&m_csCreateProxy);
			return NULL;
		}

		// when the thread comes back, the interface might be ready in the GIT. If there
		// was a problem creating the server, the GIT entry will be missing or empty
		// we don't bother checking that the process is still running or that the proxy
		// is still connected, because nobody should be talking to the process right now but us.
		// both of of those failures are non-fixable and will just cause a falure return 
		// from the actual invocation call
		if (m_CustomActionInfo[icacDesiredContext].dwGITCookie && m_CustomActionInfo[icacDesiredContext].hServerProcess)
			m_piGIT->GetInterfaceFromGlobal(m_CustomActionInfo[icacDesiredContext].dwGITCookie, IID_IMsiCustomAction, reinterpret_cast<void **>(&piCustomAction));
		
		if (piCustomAction)
		{
			if (FAILED(SetMinProxyBlanketIfAnonymousImpLevel(piCustomAction)))
			{
				m_piGIT->RevokeInterfaceFromGlobal(m_CustomActionInfo[icacDesiredContext].dwGITCookie);
				m_CustomActionInfo[icacDesiredContext].dwGITCookie = 0;
				LeaveCriticalSection(&m_csCreateProxy);
				return NULL;
			}
		}
	}

	LeaveCriticalSection(&m_csCreateProxy);
	return piCustomAction;
}


void CMsiCustomActionManager::ShutdownSpecificCustomActionServer(icacCustomActionContext iContext)
{
	// get a connection to the CA server, but DO NOT create one if it doesn't exist (since we're just
	// going to shut it down). If successful, calls AddRef() on the returned interface
	PMsiCustomAction piCustomAction = GetCustomActionInterface(/*fCreate=*/false, iContext);

	// revoke the interface from the GIT
	if (m_CustomActionInfo[iContext].dwGITCookie)
	{
		m_piGIT->RevokeInterfaceFromGlobal(m_CustomActionInfo[iContext].dwGITCookie);
		m_CustomActionInfo[iContext].dwGITCookie = 0;
	}

	if (piCustomAction)
	{
		// should we call DisconnectObject on the RemoteAPI first or just kill the process?
		unsigned long ulRet = 0;
		piCustomAction->PrepareDLLCustomAction(0, 0, 0, 0, false, false, NULL, NULL, &ulRet); 
	}

	if (m_CustomActionInfo[iContext].hServerProcess)
	{
		CloseHandle(m_CustomActionInfo[iContext].hServerProcess);
		m_CustomActionInfo[iContext].hServerProcess = 0;
	}

	m_CustomActionInfo[iContext].dwServerProcess = 0;
}

// For perf reasons, the custom action server will not shut down until told, even if it has 
// no objects currently running. Thus freeing the custom action server consists of two parts, 
// cleaning up our internal state so the service knows to create a new custom action server
// for the next custom action, PLUS telling the existing custom action server to destroy itself.
// once all running custom actions have finished.
UINT CMsiCustomActionManager::ShutdownCustomActionServer()
{
	// we can't tell the CA server to shutdown while another thread is trying to
	// connect to it. Shutdown and creation operation must be atomic.
	EnterCriticalSection(&m_csCreateProxy);

	for (int iContext=icacFirst; iContext < icacNext; iContext++)
	{
		ShutdownSpecificCustomActionServer(static_cast<icacCustomActionContext>(iContext));
	}

	// destroy the manager thread and remoteAPI
	if (m_pRemoteAPI)
	{
		// grab the interface pointer 
		IMsiRemoteAPI *pRemoteAPI = m_pRemoteAPI;
		m_pRemoteAPI=NULL;
		DWORD dwRes = OLE32::CoDisconnectObject(pRemoteAPI, 0);

		// release the initial refcount on the RemoteAPI object.
		// this triggers the manager thread to exit
		pRemoteAPI->Release();
		
		// wait for the manager/API thread to exit. Must pump messages
		HANDLE rghWaitArray[1] = {m_hRemoteAPIThread};
		for(;;)
		{
			DWORD iWait = WIN::MsgWaitForMultipleObjects(1, rghWaitArray, FALSE, INFINITE, QS_ALLINPUT);
			if (iWait == WAIT_OBJECT_0 + 1)  // window Msg
			{		
				MSG msg;
				while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
				{
					WIN::TranslateMessage(&msg);
					WIN::DispatchMessage(&msg);
				}
				continue;
			}
			else
				// either thread signaled or error
				break;
		}
		WIN::CloseHandle(m_hRemoteAPIThread);
		m_hRemoteAPIThread = 0;
	}

	LeaveCriticalSection(&m_csCreateProxy);
	return ERROR_SUCCESS;
}

// this function is called only from the manager thread. If you use m_csCreateProxy in this function
// you will deadlock.
DWORD WINAPI CMsiCustomActionManager::CreateAndRegisterInterface(icacCustomActionContext icacDesiredContext)
{
	// the server creation process generates a cookie which is then returned to this object
	// for use in the RemoteAPI interface.
	unsigned char rgchCookie[iRemoteAPICookieSize];
	int cchCookieSize = iRemoteAPICookieSize;

	IMsiCustomAction* piCustomAction = 0;
	
	// ensure that interactive users have SYNCHRONIZE access to this process handle. 
	// Since this is the way that the CA Server watches for its client termination, 
	// we need to explicitly grant SYNCHRONIZE access to the user so the CA server 
	// won't feel orphaned and exit immediately.
	if (icacDesiredContext == icac32Impersonated || icacDesiredContext == icac64Impersonated)
	{
		// if unable to set process rights to enable SYNCHRONIZE, try opening the handle to
		// see if the process already grants the rights by chance
		CImpersonate impersonate;

		HANDLE hProcess = OpenProcess(SYNCHRONIZE, /*fInherit*/FALSE, GetCurrentProcessId());
		if (!hProcess)
		{
			if (!SetInteractiveSynchronizeRights(true))
				return false;
		}
		else
			CloseHandle(hProcess);
	}

	if (g_scServerContext == scService)
	{
		// the service can directly create a custom action server by calling the configuration manager
		// interface to create the proxy.
		PMsiConfigurationManager piConfigMgr = CreateConfigurationManager();
		{
			CImpersonate impersonate(fTrue);
			
			// thread token must be desired user token before calling this function
			piCustomAction = piConfigMgr->CreateCustomActionProxy(icacDesiredContext, GetCurrentProcessId(), m_pRemoteAPI, NULL, 0,
				rgchCookie, &cchCookieSize, &m_CustomActionInfo[icacDesiredContext].hServerProcess, &m_CustomActionInfo[icacDesiredContext].dwServerProcess, false, m_fRemapHKCU);
		}
	}
	else
	{
		m_CustomActionInfo[icacDesiredContext].dwServerProcess = 0;
		m_CustomActionInfo[icacDesiredContext].dwGITCookie = 0;

		// grab the current environment for use in the custom action server, then determine its size for
		// marshaling purposes
		WCHAR* pvEnvironment = reinterpret_cast<WCHAR*>(KERNEL32::GetEnvironmentStringsW());
		WCHAR* pchEnvironment = pvEnvironment;
		do {
			// scan for the end of the string
			while (*pchEnvironment != '\0')				
				pchEnvironment++;

			// move past null 
			pchEnvironment++;
		}
		while (*pchEnvironment != '\0');

		// enable all privileges in the current thread token
		DWORD dwPrivileges = 0;
		HANDLE hToken = INVALID_HANDLE_VALUE;

		// On Win2000+, manipulate the cloaking token to ensure that privileges are correctly passed to the 
		// custom action server. 
		bool fThreadToken = false;
		HANDLE hTokenDup = INVALID_HANDLE_VALUE;
		if (MinimumPlatformWindows2000())
		{
			// determine whether to work with the process or thread token.
			if (!OpenThreadToken(GetCurrentThread(), TOKEN_DUPLICATE, FALSE, &hToken))
			{           
				// if OpenThreadToken failed due to the fact that there was no thread token, use the process token
				if (GetLastError() == ERROR_NO_TOKEN)
				{
					OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hToken);
				}
			}
			else
				fThreadToken = true;
	
			// make a copy of whatever token we're using so we don't modify the actual process token
			if (hToken != INVALID_HANDLE_VALUE)
			{
				if (!ADVAPI32::DuplicateTokenEx(hToken, TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES | TOKEN_IMPERSONATE, 0, SecurityImpersonation, TokenImpersonation, &hTokenDup))
				{
					hTokenDup = INVALID_HANDLE_VALUE;
				}
				if (!EnableAndMapDisabledPrivileges(hTokenDup, dwPrivileges))
				{
					CloseHandle(hTokenDup);
					hTokenDup = INVALID_HANDLE_VALUE;
				}
			}
	
			// if any of the token manipulation failed, creation of the CA server will fail.
			if (hTokenDup == INVALID_HANDLE_VALUE)
			{
				if (hToken != INVALID_HANDLE_VALUE)
					CloseHandle(hToken);
				KERNEL32::FreeEnvironmentStringsW(pvEnvironment);
				return false;
			}

			// set the new token into the thread. 
			if (!SetThreadToken(NULL, hTokenDup))
			{
				AssertSz(0, "SetThreadToken failed");
				CloseHandle(hTokenDup);
				if (hToken != INVALID_HANDLE_VALUE)
					CloseHandle(hToken);
				KERNEL32::FreeEnvironmentStringsW(pvEnvironment);
				return false;
			};
			CloseHandle(hTokenDup);
			hTokenDup = INVALID_HANDLE_VALUE;
		}

		// we do not handle cases where the environment is greater than can fit in a DWORD 
		// (only possible on 64bit machines)
		size_t sizeEnvironment = pchEnvironment - pvEnvironment + 1;
#ifdef WIN64
		if (sizeEnvironment > _UI32_MAX)
		{
			DEBUGMSGV("Could not launch custom action server, environment block is too large");
			if (hToken != INVALID_HANDLE_VALUE)
				CloseHandle(hToken);
			KERNEL32::FreeEnvironmentStringsW(pvEnvironment);
			return false;
		}
#endif
		DWORD cchEnvironment = static_cast<DWORD>(sizeEnvironment);

		// client connects to service for broker work. It must provide the RemoteAPI interface, the desired
		// context (elevated not allowed), and the current ProcessId
		PMsiServer piServer = ENG::CreateMsiServer(); 
		if (piServer)
		{
			DEBUGMSGV("Connected to service for CA interface.");
			DWORD dwProcId = 0;
			cchCookieSize = iRemoteAPICookieSize;
			if ((ERROR_SUCCESS == piServer->CreateCustomActionServer(icacDesiredContext, GetCurrentProcessId(), m_pRemoteAPI, pvEnvironment, cchEnvironment, dwPrivileges, rgchCookie, &cchCookieSize, &piCustomAction, &dwProcId)) && piCustomAction)
			{
				m_CustomActionInfo[icacDesiredContext].hServerProcess = OpenProcess(SYNCHRONIZE, /*fInherit*/FALSE, dwProcId);

				// even if opening the handle works, the process could have died and a new proecss been created with
				// the same process id, and we actually have a handle to the impostor. To detect this, we ensure that 
				// the handler is still connected.
				if (!m_CustomActionInfo[icacDesiredContext].hServerProcess || !OLE32::CoIsHandlerConnected(piCustomAction))
				{
					// clear out the interface pointer to generate failure below
					piCustomAction->Release();
					piCustomAction = NULL;
				}

				// if some strange cookie size comes back, something went wrong.
				if (cchCookieSize != iRemoteAPICookieSize)
				{
					// clear out the interface pointer to generate failure below
					piCustomAction->Release();
					piCustomAction = NULL;
				}

				m_CustomActionInfo[icacDesiredContext].dwServerProcess = dwProcId;
			}
		}

		KERNEL32::FreeEnvironmentStringsW(pvEnvironment);

		if (MinimumPlatformWindows2000())
		{
			Assert(hToken != INVALID_HANDLE_VALUE);
			if (!SetThreadToken(NULL, fThreadToken ? hToken : NULL))
			{
				AssertSz(0, "SetThreadToken failed");
				CloseHandle(hToken);
				CloseHandle(m_CustomActionInfo[icacDesiredContext].hServerProcess);
				m_CustomActionInfo[icacDesiredContext].hServerProcess = 0;
				m_CustomActionInfo[icacDesiredContext].dwServerProcess = 0;
				if (g_scServerContext == scService)
					ExitProcess(-1);
				return false;
			}

			CloseHandle(hToken);
			hToken = INVALID_HANDLE_VALUE;
		}
	}

	// register the new interface in the GIT
	if (!piCustomAction || (S_OK != m_piGIT->RegisterInterfaceInGlobal(piCustomAction, IID_IMsiCustomAction, &m_CustomActionInfo[icacDesiredContext].dwGITCookie)))
	{
		CloseHandle(m_CustomActionInfo[icacDesiredContext].hServerProcess);
		m_CustomActionInfo[icacDesiredContext].hServerProcess = 0;
		m_CustomActionInfo[icacDesiredContext].dwServerProcess = 0;
		return false;
	}

	// finally register the cookie for this context in the RemoteAPI handler. The RemoteAPI can now
	// accept calls in this context (once the action count on that context is incremented)
	return m_pRemoteAPI->SetCookieAndPid(icacDesiredContext, rgchCookie, m_CustomActionInfo[icacDesiredContext].dwServerProcess);
}

DWORD WINAPI CMsiCustomActionManager::CustomActionManagerThread(CMsiCustomActionManager *pThis)
{
	// This function calls ExitThread. No smart COM pointers allowed on stack!

	// The RemoteAPI object MUST be created in an MTA, or any incoming 
	// calls on it will be serialized through this thread. That is bad
	// for remote calls such as "DoAction" which could be re-entrant
	// in their API calls, as well as for asynchronous actions.
	HRESULT hresCoInit = OLE32::CoInitializeEx(0, COINIT_MULTITHREADED);

	// create the object, initial refcount is 1
	pThis->m_pRemoteAPI = new CMsiRemoteAPI();

	// create an unnamed event to wait on. (non-inheritable, auto-reset, initially unsignaled)
	pThis->m_hCreateEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	// signal the event to waken the main thread
	SetEvent(pThis->m_hRemoteAPIEvent);

	// wait until its time to quit or the thread is activated to do something
	HANDLE rghWaitArray[1] = {pThis->m_hCreateEvent};
	for(;;)
	{
		DWORD iWait = WIN::MsgWaitForMultipleObjects(1, rghWaitArray, FALSE, INFINITE, QS_ALLINPUT);
		if (iWait == WAIT_OBJECT_0 + 1)  
		{		
			// window message, need to pump until the queue is clear
			MSG msg;
			bool fBreak = false;
			
			while ( WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE) )
			{
				if (msg.message == WM_QUIT)
				{
					fBreak = true;
					break;
				}
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
			if (fBreak)
				break;
		}
		else if (iWait == WAIT_OBJECT_0)
		{
			// signal to create a custom action server of a specific type
			pThis->CreateAndRegisterInterface(pThis->m_icacCreateContext);

			// set event to let other thread know we are done
			SetEvent(pThis->m_hRemoteAPIEvent);
		}
		else if (iWait == 0xFFFFFFFF) //!! what is this on 64bit;
		{
			DEBUGMSGV("Error in CA Manager thread.");
			// error
			break;
		}
		else if (iWait == WAIT_TIMEOUT)
		{
			// our current wait period is forever, but if that changes, this could happen.
			DEBUGMSGV("Timeout in CA Manager thread.");
			break;
		} 
	}

	CloseHandle(pThis->m_hCreateEvent);
	CloseHandle(pThis->m_hRemoteAPIEvent);
	pThis->m_hCreateEvent = 0;
	pThis->m_hRemoteAPIEvent = 0;
	
	pThis->m_pRemoteAPI = NULL;	
	if(SUCCEEDED(hresCoInit))
		OLE32::CoUninitialize();

	DEBUGMSG("Custom Action Manager thread ending.");
	WIN::ExitThread(0);
	return 0;  // never gets here, needed to compile
}

bool CMsiCustomActionManager::FindAndValidateContextFromCallerPID(icacCustomActionContext *picacContext) const
{
	// validate arguments
	if (!picacContext)
		return false;

	if (!m_pRemoteAPI)
		return false;

	return m_pRemoteAPI->FindAndValidateContextFromCallerPID(picacContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\client.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       client.cpp
//
//--------------------------------------------------------------------------

/* client.cpp - DCOM access to install server, WIN only
____________________________________________________________________________*/

#include "precomp.h"
#include "_engine.h"
#include "msidspid.h"
#include "vertrust.h" // iauthEnum
#include "iconfig.h"  // icmruf
#include "rpcdce.h"    // RPC_C_AUTH*
#include "proxy.h"
#include "eventlog.h"

const GUID IID_IMsiServerProxy          = GUID_IID_IMsiServerProxy;
const GUID IID_IDispatch                = GUID_IID_IDispatch;


extern IMsiServices* g_piSharedServices;
IMsiRecord* UnserializeRecord(IMsiServices& riServices, int cbSize, char *pData);

extern int  g_iMajorVersion;

extern "C" HRESULT __stdcall DllGetVersion (DLLVERSIONINFO * pverInfo);

//____________________________________________________________________________
//
// CMsiServerProxy - proxy client for IMsiServer
//____________________________________________________________________________

class CMsiServerProxy : public IMsiServer
{
 public:
	HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
	unsigned long   __stdcall AddRef();
	unsigned long   __stdcall Release();

	iesEnum         __stdcall RunScript(const ICHAR* szScriptFile, IMsiMessage& riMessage, boolean fRollbackEnabled);
	iesEnum         __stdcall InstallFinalize(iesEnum iesState, IMsiMessage& riMessage, boolean fUserChangedDuringInstall);
	boolean         __stdcall Reboot();

	IMsiRecord*     __stdcall LocateComponent(const IMsiString& riComponentCode, IMsiRecord*& rpiRec);
	IMsiRecord*     __stdcall SetLastUsedSource(const ICHAR* szProductCode, const ICHAR* szPath, boolean fAddToList, boolean fPatch);
	int             __stdcall DoInstall(ireEnum ireProductCode, const ICHAR* szProduct, const ICHAR* szAction, const ICHAR* szCommandLine,
													const ICHAR* szLogFile, int iLogMode, boolean fFlushEachLine, IMsiMessage& riMessage, iioEnum iioOptions, const DWORD dwPrivilegesMask=0);
	boolean         __stdcall IsServiceInstalling();
	IMsiRecord*     __stdcall RegisterUser(const ICHAR* szProductCode, const ICHAR* szUserName,
															 const ICHAR* szCompany, const ICHAR* szProductID);
	IMsiRecord*     __stdcall RemoveRunOnceEntry(const ICHAR* szEntry);
	boolean         __stdcall CleanupTempPackages(IMsiMessage& riMessage, boolean fCheckServiceBusy);
	unsigned int    __stdcall SourceListClearByType(const ICHAR* szProductCode, const ICHAR* szUserName, enum isrcEnum isrcType);
	unsigned int    __stdcall SourceListAddSource(const ICHAR* szProductCode, const ICHAR* szUserName, enum isrcEnum isrcType, const ICHAR* szSource);
	unsigned int    __stdcall SourceListClearLastUsed(const ICHAR* szProductCode, const ICHAR* szUserName);
	unsigned int    __stdcall RegisterCustomActionServer(icacCustomActionContext* picacContext, const unsigned char *rgchCookie, const int cbCookie, IMsiCustomAction* piCustomAction, unsigned long *pdwProcessId, IMsiRemoteAPI **piRemoteAPI, DWORD* pdwPrivileges);
	unsigned int    __stdcall CreateCustomActionServer(const icacCustomActionContext icacContext, const unsigned long dwClientProcessId, IMsiRemoteAPI *piRemoteAPI, const WCHAR* pvEnvironment, DWORD cchEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *cbCookie, IMsiCustomAction **piCustomAction, unsigned long *dwServerProcessId);

 public:  // constructor
 	void *operator new(size_t cb) { return AllocSpc(cb); }
	void operator delete(void * pv) { FreeSpc(pv); }
	CMsiServerProxy(IMsiServices& riServices, IMsiServer& riServer);
 protected:
	~CMsiServerProxy();  // protected to prevent creation on stack
 private:
	IMsiServer&		m_riServer;
	IMsiServices&	m_riServices;
	int				m_iRefCnt;
	DWORD			m_dwPrivilegesMask;
	
};

#define EOAC_STATIC_CLOAKING 0x20 // From NT5 headers

bool FCheckProxyInfo(void);


CMsiServerProxy::CMsiServerProxy(IMsiServices& riServices, IMsiServer& riServer)
	: m_riServer(riServer), 
		m_riServices(riServices), 
		m_dwPrivilegesMask(0),
		m_iRefCnt(1)

{
//	SetAllocator(&riServices);

	// The remainder of the constructor sets the proxy's security to allow 
	// the server to impersonate the client.

	riServer.AddRef();
	riServices.AddRef();

	if (g_fWin9X)
	{
		AssertSz(fFalse, "Trying to create ServerProxy on win9x");
		return;
	}
	
	if (!FCheckProxyInfo())
	{
		AssertSz(fFalse, "Registered MSI.DLL is not the one being used. You will have problems with proxies.");
		return;
	}
	
		

	const DWORD iImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
	DWORD iCapabilities   = 0;

	if (g_iMajorVersion >= 5)
	{
		iCapabilities = EOAC_STATIC_CLOAKING;
		DEBUGMSGV("Cloaking enabled.");
	}
	AssertNonZero(StartImpersonating()); // need to impersonate so that the proxy picks up the impersonation token if we're cloaking
    HANDLE hToken = INVALID_HANDLE_VALUE;
	bool fProcessToken = false;

	if (MinimumPlatformWindows2000())
	{
		DEBUGMSG("Attempting to enable all disabled priveleges before calling Install on Server");
		{
		HANDLE hOldToken = INVALID_HANDLE_VALUE;	
		if (!WIN::OpenThreadToken(WIN::GetCurrentThread(), TOKEN_DUPLICATE, TRUE, &hOldToken))
		{
			DWORD dw;
			if((dw = GetLastError()) != ERROR_NO_TOKEN)
			{
				AssertSz(fFalse, "Error in reading thread token");
				return;
			}

		    if(!WIN::OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hOldToken))
			{
				AssertSz(fFalse, "Failed to read token");
				return;
			}
			fProcessToken = true;
		}
		if (!ADVAPI32::DuplicateTokenEx(hOldToken, TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES | TOKEN_IMPERSONATE, 0, SecurityImpersonation, TokenImpersonation, &hToken))
		{
			Assert(fFalse);
			CloseHandle(hOldToken);
			return;
		}
		CloseHandle(hOldToken);
		}
			
		if(EnableAndMapDisabledPrivileges(hToken, m_dwPrivilegesMask))
		{
			if(!SetThreadToken(NULL, hToken))
			{
				AssertSz(fFalse, "Failed to setThreadToken");
				CloseHandle(hToken);
				return;
			}
#ifdef DEBUG
			{
			ICHAR buff[16];
			StringCchPrintf(buff, 16, TEXT("0x%x"), m_dwPrivilegesMask);
			DEBUGMSG1(TEXT("EnableAndMapDisabled privileges set dwPrivileges =%s"), buff);
			}
#endif
		}
		else
		{
			AssertSz(fFalse, "Enable privileges failed");
			CloseHandle(hToken);
			return;
		}
	}

	HRESULT hRes = OLE32::CoSetProxyBlanket(&riServer, RPC_C_AUTHN_WINNT,
		RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
		iImpLevel, NULL, iCapabilities);

	if(hToken != INVALID_HANDLE_VALUE)
	{
		if(fProcessToken)
			SetThreadToken(NULL, NULL);
		else 
		{
			DisablePrivilegesFromMap(hToken, m_dwPrivilegesMask);
			if(!SetThreadToken(NULL, hToken))
			{
				AssertSz(fFalse, "Failed to setThreadToken");
				CloseHandle(hToken);
				return;
			}
		}
        CloseHandle(hToken);
	}
	
	StopImpersonating();

	if (hRes != S_OK)
	{
		DEBUGMSG1(TEXT("SetProxyBlanket failed with: 0x%X"), (const ICHAR*)(INT_PTR)hRes);
		return; //!! What to do here; not much we can do, but we're gonna fail down the line
	}

}

CMsiServerProxy::~CMsiServerProxy()
{

	m_riServer.Release();
	m_riServices.Release();

}

HRESULT CMsiServerProxy::QueryInterface(const IID& riid, void** ppvObj)
{
	if (ppvObj == NULL)
		return E_INVALIDARG;
	if (riid == IID_IUnknown || riid == IID_IMsiServer || riid == IID_IMsiServerProxy)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	else
	{
		*ppvObj = 0;
		return E_NOINTERFACE;
	}
}

unsigned long CMsiServerProxy::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiServerProxy::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;
	delete this;
//	ReleaseAllocator();
	ENG::FreeServices();
	return 0;
}

iesEnum CMsiServerProxy::InstallFinalize(iesEnum iesState, IMsiMessage& riMessage, boolean fUserChangedDuringInstall)
{
	HRESULT hres;
	iesEnum iesRet;
	
	hres = IMsiServer_InstallFinalizeRemote_Proxy(&m_riServer, iesState, &riMessage, fUserChangedDuringInstall, &iesRet);

	if (FAILED(hres))
		return iesFailure;
		
	return iesRet;
}

boolean CMsiServerProxy::Reboot()
{
	HRESULT hres;
	boolean fRet;
	
	hres = IMsiServer_RebootRemote_Proxy(&m_riServer, &fRet);

	if (FAILED(hres))
		return fFalse;
		
	return fRet;
}

boolean CMsiServerProxy::IsServiceInstalling()
{
	HRESULT hres;
	boolean fRet;
	
	hres = IMsiServer_IsServiceInstallingRemote_Proxy(&m_riServer, &fRet);

	if (FAILED(hres))
		return fFalse;
		
	return fRet;
}

int __stdcall CMsiServerProxy::DoInstall(ireEnum ireProductCode, const ICHAR* szProduct, const ICHAR* szAction, const ICHAR* szCommandLine,
													  const ICHAR* szLogFile, int iLogMode, boolean fFlushEachLine, IMsiMessage& riMessage, iioEnum iioOptions, const DWORD)
{
	HRESULT hres;
	int retVal;
	
	g_MessageContext.DisableTimeout();  // server will handle timeouts over there
	Assert(szProduct != 0);
	hres = IMsiServer_DoInstallRemote_Proxy(&m_riServer, ireProductCode, szProduct, szAction, szCommandLine, szLogFile, iLogMode, fFlushEachLine, &riMessage, iioOptions, m_dwPrivilegesMask, &retVal);
	g_MessageContext.EnableTimeout();

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;

	return retVal;
	
}

IMsiRecord* CMsiServerProxy::SetLastUsedSource(const ICHAR* szProductCode, const ICHAR* szPath, boolean fAddToList, boolean fPatch)
{
	HRESULT hres;
	int cb;
	char *precStream;
	IMsiRecord *piRec;
	
	Assert(szProductCode != 0);
	Assert(szPath != 0);
	hres = IMsiServer_SetLastUsedSourceRemote_Proxy(&m_riServer, szProductCode, szPath, fAddToList, fPatch, &cb, &precStream);

	if (FAILED(hres))
		return PostError(Imsg(idbgMarshalingFailed), hres);

	piRec = UnserializeRecord(m_riServices, cb, precStream);
	OLE32::CoTaskMemFree(precStream);	
	
	return piRec;
}

IMsiRecord* CMsiServerProxy::RegisterUser(const ICHAR* szProductKey, const ICHAR* szUserName,
														const ICHAR* szCompany, const ICHAR* szProductID)
{
	HRESULT hres;
	int cb;
	char *precStream;
	IMsiRecord *piRec;
	
	Assert(szProductKey != 0);
	hres = IMsiServer_RegisterUserRemote_Proxy(&m_riServer, szProductKey, szUserName, szCompany,
														  szProductID, &cb, &precStream);

	if (FAILED(hres))
		return PostError(Imsg(idbgMarshalingFailed), hres);

	piRec = UnserializeRecord(m_riServices, cb, precStream);
	OLE32::CoTaskMemFree(precStream);	
	
	return piRec;
}

IMsiRecord* CMsiServerProxy::RemoveRunOnceEntry(const ICHAR* szEntry)
{
	HRESULT hres;
	int cb;
	char *precStream;
	IMsiRecord *piRec;
	
	hres = IMsiServer_RemoveRunOnceEntryRemote_Proxy(&m_riServer, szEntry, &cb, &precStream);

	if (FAILED(hres))
		return PostError(Imsg(idbgMarshalingFailed), hres);

	piRec = UnserializeRecord(m_riServices, cb, precStream);
	OLE32::CoTaskMemFree(precStream);	
	
	return piRec;
}

boolean CMsiServerProxy::CleanupTempPackages(IMsiMessage& riMessage, boolean fCheckServiceBusy)
{
	HRESULT hres;
	boolean fRet;
	
	hres = IMsiServer_CleanupTempPackagesRemote_Proxy(&m_riServer, &riMessage,
																	  fCheckServiceBusy, &fRet);

	if (FAILED(hres))
		return fFalse;
		
	return fRet;
}

unsigned int CMsiServerProxy::SourceListClearByType(const ICHAR* szProductCode, const ICHAR* szUserName, enum isrcEnum isrcType)
{
	HRESULT hres;
	unsigned int retval;
	hres = IMsiServer_SourceListClearByTypeRemote_Proxy(&m_riServer, szProductCode, szUserName, isrcType, &retval);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
	
	return retval;
}

unsigned int CMsiServerProxy::SourceListAddSource(const ICHAR* szProductCode, const ICHAR* szUserName, enum isrcEnum isrcType, const ICHAR* szSource)
{
	HRESULT hres;
	unsigned int retval;
	hres = IMsiServer_SourceListAddSourceRemote_Proxy(&m_riServer, szProductCode, szUserName, isrcType, szSource, &retval);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
	
	return retval;
}

unsigned int CMsiServerProxy::SourceListClearLastUsed(const ICHAR* szProductCode, const ICHAR* szUserName)
{
	HRESULT hres;
	unsigned int retval;
	hres = IMsiServer_SourceListClearLastUsedRemote_Proxy(&m_riServer, szProductCode, szUserName, &retval);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
	
	return retval;
}

unsigned int CMsiServerProxy::RegisterCustomActionServer(icacCustomActionContext* picacContext, const unsigned char *rgchCookie, const int cbCookie, IMsiCustomAction* piCustomAction, unsigned long *pdwProcessId, IMsiRemoteAPI **piRemoteAPI, DWORD* pdwPrivileges)
{
	HRESULT hres;
	unsigned int retval;
	hres = IMsiServer_RegisterCustomActionServerRemote_Proxy(&m_riServer, picacContext, rgchCookie, cbCookie, piCustomAction, pdwProcessId, piRemoteAPI, pdwPrivileges, &retval);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
	
	return retval;
}

unsigned int CMsiServerProxy::CreateCustomActionServer(const icacCustomActionContext icacContext, const unsigned long dwClientProcessId, IMsiRemoteAPI *piRemoteAPI, const WCHAR* pvEnvironment, DWORD cchEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *cbCookie, IMsiCustomAction **piCustomAction, unsigned long *pdwServerProcessId)
{
	HRESULT hres;
	unsigned int retval;
	hres = IMsiServer_CreateCustomActionServerRemote_Proxy(&m_riServer, icacContext, dwClientProcessId, piRemoteAPI, pvEnvironment, cchEnvironment, dwPrivileges, rgchCookie, cbCookie, piCustomAction, pdwServerProcessId, &retval);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
	
	return retval;
}

char *SerializeRecord(IMsiRecord *piRecord, IMsiServices* piServices, int* pcb);


iesEnum STDMETHODCALLTYPE IMsiServer_InstallFinalize_Proxy(IMsiServer* piServer, iesEnum iesState, IMsiMessage& riMessage, boolean fUserChangedDuringInstall)
{
	HRESULT hres;
	iesEnum iesRet;
	
	hres = IMsiServer_InstallFinalizeRemote_Proxy(piServer, iesState, &riMessage, fUserChangedDuringInstall, &iesRet);
	if (FAILED(hres))
		return iesFailure;
		
	return iesRet;
}

int STDMETHODCALLTYPE IMsiServer_DoInstall_Proxy(IMsiServer* piServer, ireEnum ireProductCode, const ICHAR* szProduct, const ICHAR* szAction, const ICHAR* szCommandLine,
																 const ICHAR* szLogFile, int iLogMode, boolean fFlushEachLine, IMsiMessage& riMessage, iioEnum iioOptions, const DWORD dwPrivilegesMask)
{
	HRESULT hres;
	int retVal;
	
	hres = IMsiServer_DoInstallRemote_Proxy(piServer, ireProductCode, szProduct, szAction, szCommandLine, szLogFile, iLogMode, fFlushEachLine, &riMessage, iioOptions, dwPrivilegesMask, &retVal);
	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
		
	return retVal;
	
}

boolean STDMETHODCALLTYPE IMsiServer_Reboot_Proxy(IMsiServer* piServer)
{
	HRESULT hres;
	boolean retVal;
	
	hres = IMsiServer_RebootRemote_Proxy(piServer, &retVal);
	if (FAILED(hres))
		return false;

	return retVal;
}

boolean STDMETHODCALLTYPE IMsiServer_IsServiceInstalling_Proxy(IMsiServer* piServer)
{
	HRESULT hres;
	boolean retVal;
	
	hres = IMsiServer_IsServiceInstallingRemote_Proxy(piServer, &retVal);
	if (FAILED(hres))
		return false;

	return retVal;
}

IMsiRecord* STDMETHODCALLTYPE IMsiServer_SetLastUsedSource_Proxy(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szPath, boolean fAddToList, boolean fPatch)
{
	HRESULT hres;
	int cb;
	char *precStream;
	IMsiRecord* piRec;
	
	hres = IMsiServer_SetLastUsedSourceRemote_Proxy(piServer, szProductCode, szPath, fAddToList, fPatch, &cb, &precStream);

	if (FAILED(hres))
		return 0;

	if (g_piSharedServices == 0)
	{
		Assert(fFalse);
		return 0;
	}
		
		
	piRec = UnserializeRecord(*g_piSharedServices, cb, precStream);

	return piRec;
}

IMsiRecord* STDMETHODCALLTYPE IMsiServer_RegisterUser_Proxy(IMsiServer* piServer, const ICHAR* szProductKey,
																					 const ICHAR* szUserName, const ICHAR* szCompany,
																					 const ICHAR* szProductID)
{
	HRESULT hres;
	int cb;
	char *precStream;
	IMsiRecord* piRec;
	
	hres = IMsiServer_RegisterUserRemote_Proxy(piServer, szProductKey, szUserName, szCompany, szProductID, &cb, &precStream);

	if (FAILED(hres))
		return 0;

	if (g_piSharedServices == 0)
	{
		Assert(fFalse);
		return 0;
	}
		
		
	piRec = UnserializeRecord(*g_piSharedServices, cb, precStream);

	return piRec;
}

IMsiRecord* STDMETHODCALLTYPE IMsiServer_RemoveRunOnceEntry_Proxy(IMsiServer* piServer, const ICHAR* szEntry)
{
	HRESULT hres;
	int cb;
	char *precStream;
	IMsiRecord* piRec;
	
	hres = IMsiServer_RemoveRunOnceEntryRemote_Proxy(piServer, szEntry, &cb, &precStream);

	if (FAILED(hres))
		return 0;

	if (g_piSharedServices == 0)
	{
		Assert(fFalse);
		return 0;
	}
		
		
	piRec = UnserializeRecord(*g_piSharedServices, cb, precStream);

	return piRec;
}

boolean STDMETHODCALLTYPE IMsiServer_CleanupTempPackages_Proxy(IMsiServer* piServer, IMsiMessage& riMessage, boolean fCheckServiceBusy)
{
	HRESULT hres;
	boolean retVal;
	
	hres = IMsiServer_CleanupTempPackagesRemote_Proxy(piServer, &riMessage, fCheckServiceBusy, &retVal);
	if (FAILED(hres))
		return false;

	return retVal;


}

unsigned int STDMETHODCALLTYPE IMsiServer_SourceListClearByType_Proxy(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szUserName, isrcEnum isrcType)
{
	HRESULT hres;
	unsigned int retVal;
	
	hres = IMsiServer_SourceListClearByTypeRemote_Proxy(piServer, szProductCode, szUserName, isrcType, &retVal);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
		
	return retVal;
}


unsigned int STDMETHODCALLTYPE IMsiServer_SourceListAddSource_Proxy(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szUserName, isrcEnum isrcType, const ICHAR* szSource)
{
	HRESULT hres;
	unsigned int retVal;
	
	hres = IMsiServer_SourceListAddSourceRemote_Proxy(piServer, szProductCode, szUserName, isrcType, szSource, &retVal);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
		
	return retVal;
}

unsigned int STDMETHODCALLTYPE IMsiServer_SourceListClearLastUsed_Proxy(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szUserName)
{
	HRESULT hres;
	unsigned int retVal;
	
	hres = IMsiServer_SourceListClearLastUsedRemote_Proxy(piServer, szProductCode, szUserName, &retVal);

	if (FAILED(hres))
		return ERROR_INSTALL_SERVICE_FAILURE;
		
	return retVal;
}

unsigned int STDMETHODCALLTYPE IMsiServer_RegisterCustomActionServer_Proxy(IMsiServer* piServer, icacCustomActionContext* picacContext, const unsigned char *rgchCookie, const int cbCookie, IMsiCustomAction* piCustomAction, unsigned long *pdwProcessId, IMsiRemoteAPI **piRemoteAPI, DWORD *pdwPrivileges)
{
	HRESULT hRes;
	unsigned int retVal;
	hRes = IMsiServer_RegisterCustomActionServerRemote_Proxy(piServer, picacContext, rgchCookie, cbCookie, piCustomAction, pdwProcessId, piRemoteAPI, pdwPrivileges, &retVal);

	if (FAILED(hRes))
		return ERROR_INSTALL_SERVICE_FAILURE;

	return retVal;
}

unsigned int STDMETHODCALLTYPE IMsiServer_CreateCustomActionServer_Proxy(IMsiServer* piServer, const icacCustomActionContext icacContext, const unsigned long dwClientProcessId, IMsiRemoteAPI *piRemoteAPI, const WCHAR* pvEnvironment, DWORD cchEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *cbCookie, IMsiCustomAction **piCustomAction, unsigned long *pdwServerProcessId)
{
	HRESULT hRes;
	unsigned int retVal;
	hRes = IMsiServer_CreateCustomActionServerRemote_Proxy(piServer, icacContext, dwClientProcessId, piRemoteAPI, pvEnvironment, cchEnvironment, dwPrivileges, rgchCookie, cbCookie, piCustomAction, pdwServerProcessId, &retVal);

	if (FAILED(hRes))
		return ERROR_INSTALL_SERVICE_FAILURE;

	return retVal;
}

IMsiMessage *g_piMessage = 0;

HRESULT STDMETHODCALLTYPE IMsiServer_InstallFinalize_Stub(IMsiServer* piServer, iesEnum iesState, IMsiMessage * piMessage, boolean fUserChangedDuringInstall, iesEnum* piesRet)
{
	CResetImpersonationInfo impReset;
	*piesRet = piServer->InstallFinalize(iesState, *piMessage, fUserChangedDuringInstall);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_DoInstall_Stub(IMsiServer* piServer, ireEnum ireProductCode, const ICHAR* szProduct, const ICHAR* szAction, const ICHAR* szCommandLine,
																	 const ICHAR* szLogFile, int iLogMode, boolean fFlushEachLine, IMsiMessage * piMessage, iioEnum iioOptions, const DWORD dwPrivilegesMask, int *retVal)
{
	CResetImpersonationInfo impReset;
	*retVal = piServer->DoInstall(ireProductCode, szProduct, szAction, szCommandLine, szLogFile, iLogMode, fFlushEachLine, *piMessage, iioOptions, dwPrivilegesMask);
	return S_OK;	
}

HRESULT STDMETHODCALLTYPE IMsiServer_Reboot_Stub(IMsiServer* piServer, boolean * pretVal)
{
	CResetImpersonationInfo impReset;
	{
		// set impersonation on this thread to COM impersonation
		CCoImpersonate impersonate;
	
		*pretVal = piServer->Reboot();
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_IsServiceInstalling_Stub(IMsiServer* piServer, boolean * pretVal)
{
	boolean fRet = false;
	if ( piServer )
	{
		CResetImpersonationInfo impReset;
		{
			// set impersonation on this thread to COM impersonation
			CCoImpersonate impersonate;

			fRet = piServer->IsServiceInstalling();
		}
	}
	else
		return E_INVALIDARG;

	if ( pretVal )
		*pretVal = fRet;
	
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_SetLastUsedSource_Stub(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szPath, boolean fAddToList, boolean fPatch, int* pcb, char **pprecStream)
{
	CResetImpersonationInfo impReset;
	PMsiRecord piRec(0);

	piRec = piServer->SetLastUsedSource(szProductCode, szPath, fAddToList, fPatch);
	
	// REVIEW not sure if this is the right failure to return or not.
	if (g_piSharedServices == 0)
		return HRESULT_FROM_WIN32(RPC_S_CALL_FAILED);
		
	*pprecStream = SerializeRecord(piRec, g_piSharedServices, pcb);
	
	return S_OK;

}

HRESULT STDMETHODCALLTYPE IMsiServer_RegisterUser_Stub(IMsiServer* piServer, const ICHAR* szProductKey,
																			  const ICHAR* szUserName, const ICHAR* szCompany,
																			  const ICHAR* szProductID,
																			  int* pcb, char **pprecStream)
{
	CResetImpersonationInfo impReset;
	CCoImpersonate impersonate;
	PMsiRecord piRec(0);

	piRec = piServer->RegisterUser(szProductKey, szUserName, szCompany, szProductID);
	
	// REVIEW not sure if this is the right failure to return or not.
	if (g_piSharedServices == 0)
		return HRESULT_FROM_WIN32(RPC_S_CALL_FAILED);
		
	*pprecStream = SerializeRecord(piRec, g_piSharedServices, pcb);
	
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_RemoveRunOnceEntry_Stub(IMsiServer* piServer, const ICHAR* szEntry,
																				 int* pcb, char **pprecStream)
{
	CResetImpersonationInfo impReset;
	PMsiRecord piRec(0);

	piRec = piServer->RemoveRunOnceEntry(szEntry);
	
	// REVIEW not sure if this is the right failure to return or not.
	if (g_piSharedServices == 0)
		return HRESULT_FROM_WIN32(RPC_S_CALL_FAILED);
		
	*pprecStream = SerializeRecord(piRec, g_piSharedServices, pcb);
	
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_CleanupTempPackages_Stub(IMsiServer* piServer, IMsiMessage * piMessage, boolean fCheckServiceBusy, boolean * pretVal)
{
	if (!piServer)
		return E_INVALIDARG;

	CResetImpersonationInfo impReset;
	boolean fRet = piServer->CleanupTempPackages(*piMessage, fCheckServiceBusy);
	if (pretVal)
		*pretVal = fRet;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_SourceListClearByType_Stub(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szUserName, enum isrcEnum isrcType, unsigned int * pretVal)
{
	CResetImpersonationInfo impReset;
	*pretVal = piServer->SourceListClearByType(szProductCode, szUserName, isrcType);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_SourceListAddSource_Stub(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szUserName, enum isrcEnum isrcType, const ICHAR* szSource, unsigned int * pretVal)
{
	CResetImpersonationInfo impReset;
	*pretVal = piServer->SourceListAddSource(szProductCode, szUserName, isrcType, szSource);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_SourceListClearLastUsed_Stub(IMsiServer* piServer, const ICHAR* szProductCode, const ICHAR* szUserName, unsigned int * pretVal)
{
	CResetImpersonationInfo impReset;
	*pretVal = piServer->SourceListClearLastUsed(szProductCode, szUserName);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_RegisterCustomActionServer_Stub(IMsiServer* piServer, icacCustomActionContext* picacContext, const unsigned char *rgchCookie, const int cbCookie, IMsiCustomAction* piCustomAction, unsigned long *pdwProcessId, IMsiRemoteAPI **piRemoteAPI, DWORD *pdwPrivileges, unsigned int *pretVal)
{
	CResetImpersonationInfo impReset;
	if (!picacContext)
		return E_FAIL;
	*pretVal = piServer->RegisterCustomActionServer(picacContext, rgchCookie, cbCookie, piCustomAction, pdwProcessId, piRemoteAPI, pdwPrivileges);
	return S_OK;
}

HRESULT STDMETHODCALLTYPE IMsiServer_CreateCustomActionServer_Stub(IMsiServer* piServer, const icacCustomActionContext icacContext, const unsigned long dwClientProcessId, IMsiRemoteAPI *piRemoteAPI, const WCHAR* pvEnvironment, DWORD cchEnvironment, DWORD dwPrivileges, unsigned char *rgchCookie, int *cbCookie, IMsiCustomAction **piCustomAction, unsigned long *pdwServerProcessId, unsigned int *pretVal)
{
	CResetImpersonationInfo impReset;
	*pretVal = piServer->CreateCustomActionServer(icacContext, dwClientProcessId, piRemoteAPI, pvEnvironment, cchEnvironment, dwPrivileges, rgchCookie, cbCookie, piCustomAction, pdwServerProcessId);
	return S_OK;
}



imsEnum STDMETHODCALLTYPE IMsiMessage_Message_Proxy(IMsiMessage *piMessage, imtEnum imt, IMsiRecord& riRecord)
{
	HRESULT hres;
	imsEnum imsRet;
	char *pchRecord;
	int cb;
	
	// REVIEW not sure if this is the right failure to return or not.
	if (g_piSharedServices == 0)
		return imsError;
	pchRecord = SerializeRecord(&riRecord, g_piSharedServices, &cb);
	
	hres = IMsiMessage_MessageRemote_Proxy(piMessage, imt, cb, pchRecord, &imsRet);

	OLE32::CoTaskMemFree(pchRecord);
	
	if (FAILED(hres))
		return imsError;

	return imsRet;
}


HRESULT STDMETHODCALLTYPE IMsiMessage_Message_Stub(IMsiMessage *piMessage, imtEnum imt, int cb, char *pchRecord, imsEnum* pims) 
{
	PMsiRecord piRec(0);
	
	if (g_piSharedServices == 0)
		return HRESULT_FROM_WIN32(RPC_S_CALL_FAILED);
		
	piRec = UnserializeRecord(*g_piSharedServices, cb, pchRecord);

	*pims = piMessage->Message(imt, *piRec);
	return S_OK;
}

imsEnum STDMETHODCALLTYPE IMsiMessage_MessageNoRecord_Proxy(IMsiMessage *piMessage, imtEnum imt)
{
	HRESULT hres;
	imsEnum imsRet;
	
	hres = IMsiMessage_MessageNoRecordRemote_Proxy(piMessage, imt, &imsRet);

	if (FAILED(hres))
		return imsError;

	return imsRet;
}

HRESULT STDMETHODCALLTYPE IMsiMessage_MessageNoRecord_Stub(IMsiMessage *piMessage, imtEnum imt, imsEnum* pims) 
{
	*pims = piMessage->MessageNoRecord(imt);
	return S_OK;
}

char *SerializeRecord(IMsiRecord *piRecord, IMsiServices* piServices, int* pcb)
{
	int cbData;
	
	*pcb = 0;
	if (piRecord != 0)
	{
		PMsiStream piStream(0);

		piServices->AllocateMemoryStream(512, *&piStream);

		piServices->FWriteScriptRecordMsg(ixoFullRecord, *piStream, *piRecord);

		cbData = piStream->GetIntegerValue() - piStream->Remaining();
		
		// We need to find a better way that doesn't cause the extra memory allocation
		piStream->Reset();
		char *pch = (char *)OLE32::CoTaskMemAlloc(cbData);
		if (pch == 0)
			return 0;
		piStream->GetData(pch, cbData);
		*pcb = cbData;
		return pch;
	}
	
	return 0;

}

IMsiRecord* UnserializeRecord(IMsiServices& riServices, int cbSize, char *pData)
{
	PMsiStream piStream(0);
	char *pch;
	IMsiRecord *piRec = 0;

	if (cbSize == 0)
		return 0;
	// Create the returned record
	pch = pData;
	piStream = riServices.CreateStreamOnMemory(pch, cbSize);

	piRec = riServices.ReadScriptRecordMsg(*piStream);

	return piRec;
}

IMsiServer* CreateMsiServerProxyFromRemote(IMsiServer& riDispatch)
{
	
	IMsiServices* piServices = ENG::LoadServices();
	if (piServices == 0)
		return 0;
	IMsiServer* piServer = 0;
	//
	// see if the proxy information is correct
	//
	if (FCheckProxyInfo())
	{
		piServer = new CMsiServerProxy(*piServices, riDispatch);
	}
	else
	{
		DEBUGMSGE(EVENTLOG_ERROR_TYPE,
					 EVENTLOG_TEMPLATE_INCORRECT_PROXY_REGISTRATION,
					 TEXT("(NULL)"));
	}
	if (piServer == 0)
		ENG::FreeServices();
	return piServer;
}

bool FCheckProxyInfo()
{
	ICHAR rgchKey[MAX_PATH];
	ICHAR szDllVersion [MAX_PATH];
	DLLVERSIONINFO verInfo;
	unsigned char rgchDllVersion[MAX_PATH];
	DWORD cbLen;
	DWORD type;
	HKEY hkey;


	const GUID IID_IMsiMessageRPCClass	= GUID_IID_IMsiMessageRPCClass;
	extern HINSTANCE g_hInstance;

	StringCchPrintf(rgchKey, (sizeof(rgchKey)/sizeof(ICHAR)), TEXT("CLSID\\{%08lX-0000-0000-C000-000000000046}\\DllVersion"), IID_IMsiMessage.Data1);

	cbLen = sizeof(rgchDllVersion);
	
	if (MsiRegOpen64bitKey(HKEY_CLASSES_ROOT, rgchKey, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
	{
		DWORD hres = REG::RegQueryValueEx(hkey, NULL, NULL, &type, rgchDllVersion, &cbLen);
		REG::RegCloseKey(hkey);

		if (hres == ERROR_SUCCESS)
		{
			verInfo.cbSize = sizeof (DLLVERSIONINFO);
			DllGetVersion (&verInfo);
			StringCchPrintf (szDllVersion, (sizeof(szDllVersion)/sizeof(ICHAR)), TEXT("%d.%d.%d"), verInfo.dwMajorVersion, verInfo.dwMinorVersion, verInfo.dwBuildNumber);
			if (!IStrCompI(szDllVersion, (ICHAR *)rgchDllVersion))
			{
				return true;
			}	
		}
	}

	return false;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\comadmin.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       comadmin.c
//
//--------------------------------------------------------------------------

/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0158 */
/* at Tue Feb 09 15:34:51 1999
 */
/* Compiler settings for comadmin.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ICOMAdminCatalog = {0xDD662187,0xDFC2,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


const IID IID_ICatalogObject = {0x6eb22871,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID IID_ICatalogCollection = {0x6eb22872,0x8a19,0x11d0,{0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29}};


const IID LIBID_COMAdmin = {0xF618C513,0xDFB8,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


const CLSID CLSID_COMAdminCatalog = {0xF618C514,0xDFB8,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


const CLSID CLSID_COMAdminCatalogObject = {0xF618C515,0xDFB8,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


const CLSID CLSID_COMAdminCatalogCollection = {0xF618C516,0xDFB8,0x11d1,{0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\complus.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ComPlus.cpp
//
//--------------------------------------------------------------------------

/* complus.cpp - COM+ actions and execution
____________________________________________________________________________*/
#include "precomp.h" 
#include "_execute.h"
#include "comadmin.h"
#include "comadmin.c"

// Forward declarations.
HRESULT GetSafeArrayOfCLSIDs(LPOLESTR	i_szComponentCLSID,	SAFEARRAY** o_paCLSIDs);
HRESULT RemoveApplicationIfExists(ICOMAdminCatalog *pIAdminCatalog, BSTR &bstrAppID);
static BSTR AllocBSTR(const TCHAR* sz);

// SQL Queries.
const ICHAR sqlRegisterComPlus[]    = TEXT("SELECT `ComponentId`,  `FileName`, `Component`.`Directory_`, `ExpType`, `Component`.`Action`, `Component`.`Installed`  FROM `Complus`, `Component`, `File` WHERE `Complus`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND (`Action` = 1 OR `Action` = 2)");
const ICHAR sqlUnregisterComPlus[]    = TEXT("SELECT `ComponentId`,  `FileName`, `Component`.`Directory_`, `ExpType`, `Component`.`Action`, `Component`.`Installed`  FROM `Complus`, `Component`, `File` WHERE `Complus`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND `Action` = 0");

enum atApplicationType{
	atClient = 0x00000020,
	atServer = 0x00000040,
};

#define fIMPORT_APP_APL		0x00010000

// Actions.
iesEnum ProcessComPlusInfo(IMsiEngine& riEngine, int fRemove)
{
	enum cpiComPlusInfo{
		cpiAppID = 1,
		cpiAplName,
		cpiAppDir,
		cpiAppType,
		cpiComponentAction,
		cpiComponentInstalled,
	};

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiView piView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;

	using namespace IxoComPlusRegister;

	const ICHAR* szQuery = (fRemove != fFalse) ? sqlRegisterComPlus : sqlUnregisterComPlus;

	// Execute the query to get the apl file name.
	if((pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) || (pError = piView->Execute(0)))
	{
		// If any tables are missing, not an error - just nothing to do
		if (pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		return riEngine.FatalError(*pError);
	}
	
	while(piRec = piView->Fetch())
	{
		MsiString strFileName, strFullPath, strPath, strInstallUsers;
		PMsiPath piPath(0);

		PMsiRecord piComPlusRec = &piServices->CreateRecord(Args);
	
		// Get the appid, apptype, aplname.
		AssertNonZero(piComPlusRec->SetMsiString(AppID, *MsiString(piRec->GetMsiString(cpiAppID))));
		AssertNonZero(piComPlusRec->SetInteger(AppType, piRec->GetInteger(cpiAppType)));
		strFileName = piRec->GetMsiString(cpiAplName);

		iisEnum iisState = (iisEnum)piRec->GetInteger(cpiComponentAction);
		if(iisState == iisAbsent)
			iisState = (iisEnum)piRec->GetInteger(cpiComponentInstalled);
		if(iisState == iisSource)
		{
			pError = piDirectoryMgr->GetSourcePath(*MsiString(piRec->GetMsiString(cpiAppDir)), *&piPath);
		}
		else
		{
			pError = piDirectoryMgr->GetTargetPath(*MsiString(piRec->GetString(cpiAppDir)), *&piPath);
		}

		if(pError)
		{
			if (pError->GetInteger(1) == imsgUser)
				return iesUserExit;
			else
				return riEngine.FatalError(*pError);
		}

		if(pError = piPath->GetFullFilePath(strFileName, *&strFullPath))
		{
			return riEngine.FatalError(*pError);
		}

		AssertNonZero(piComPlusRec->SetMsiString(AplFileName, *strFullPath));
		strPath = piPath->GetPath();
		AssertNonZero(piComPlusRec->SetMsiString(AppDir, *strPath));
		AssertNonZero(piComPlusRec->SetMsiString(InstallUsers, *MsiString(riEngine.GetProperty(*MsiString(*TEXT("INSTALLUSERS"))))));
		AssertNonZero(piComPlusRec->SetMsiString(RSN, *MsiString(riEngine.GetProperty(*MsiString(*TEXT("REMOTESERVERNAME"))))));
		if ((iesRet = riEngine.ExecuteRecord((fRemove != fFalse) ? ixoComPlusRegister : ixoComPlusUnregister, *piComPlusRec)) != iesSuccess)
			return iesRet;
	}

	return iesSuccess;
}

iesEnum RegisterComPlus(IMsiEngine& riEngine)
{
	return ProcessComPlusInfo(riEngine, fTrue);
}

iesEnum UnregisterComPlus(IMsiEngine& riEngine)
{
	return ProcessComPlusInfo(riEngine, fFalse);
}

// Executions.
iesEnum CMsiOpExecute::ixfComPlusRegister(IMsiRecord& riParams) 
{ 
	CComPointer<ICOMAdminCatalog> pIAdminCatalog(0);
	BSTR		bstrAppFile=NULL;
	BSTR		bstrAppDir=NULL;
	BSTR		bstrAppID=NULL;
	BSTR		bstrRSN=NULL;
	LONG		lOptions= fIMPORT_APP_APL;
	LONG		lAppType=0;
	iesEnum		iesReturn=iesSuccess;
	HRESULT		hr=S_OK;

	using namespace IxoComPlusRegister;

	lAppType                  = riParams.GetInteger(AppType);
	MsiString strInstallUsers = riParams.GetMsiString(InstallUsers);
	MsiString strAppFile      = riParams.GetMsiString(AplFileName);
	MsiString strAppDir       = riParams.GetMsiString(AppDir);
	MsiString strAppID        = riParams.GetMsiString(AppID);
	MsiString strRSN          = riParams.GetMsiString(RSN);

	IMsiRecord& riActionData = GetSharedRecord(4); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strAppID));
	AssertNonZero(riActionData.SetInteger(2, lAppType));
	AssertNonZero(riActionData.SetMsiString(3, *strInstallUsers));
	AssertNonZero(riActionData.SetMsiString(4, *strRSN));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	CImpersonate impersonate(fTrue);

	hr = OLE32::CoCreateInstance(CLSID_COMAdminCatalog, NULL, CLSCTX_SERVER, IID_ICOMAdminCatalog, (void**) &pIAdminCatalog);
	if (FAILED(hr)) 
	{
		// We can't perform a server install, if the machine doesn't have
		// COM+ installed on it.
		if (!(lAppType & atClient))
		{
			return FatalError(*PMsiRecord(PostError(Imsg(imsgComPlusNotInstalled))));
		}
		else
		{
			return iesSuccess;
		}
	}

	if (strInstallUsers.Compare(iscExactI, TEXT("TRUE")))
		lOptions |= COMAdminInstallUsers;

	bstrAppFile = ::AllocBSTR(strAppFile);

	bstrAppDir = ::AllocBSTR(strAppDir);
	
	bstrAppID = ::AllocBSTR(strAppID);

	bstrRSN = ::AllocBSTR(strRSN);

	if (!bstrAppFile || !bstrAppDir || !bstrAppID || !bstrRSN)
	{
		return FatalError(*PMsiRecord(PostError(Imsg(imsgOutOfMemory))));
	}
	
	// Install the app.
	hr = pIAdminCatalog->InstallApplication(bstrAppFile, bstrAppDir, lOptions, NULL, NULL, !(lAppType & atClient) ? NULL : bstrRSN);
	OLEAUT32::SysFreeString(bstrAppFile);
	OLEAUT32::SysFreeString(bstrAppDir);
	OLEAUT32::SysFreeString(bstrAppID);
	OLEAUT32::SysFreeString(bstrRSN);
	if (FAILED(hr))
	{
		// dispatch an informational error with extra logging info
		DispatchError(imtInfo, Imsg(idbgComPlusInstallFailed), (const ICHAR*)strAppFile, hr);

		// return fatal error
		return FatalError(*PMsiRecord(PostError(Imsg(imsgComPlusCantInstallApp))));
	}

	if (!RollbackRecord(ixoComPlusUnregister,riParams))
		iesReturn = iesFailure;

	return iesReturn; 
}

iesEnum CMsiOpExecute::ixfComPlusUnregister(IMsiRecord& riParams) 
{ 
	CComPointer<ICOMAdminCatalog> pIAdminCatalog(0);
	BSTR		bstrAppFile=NULL;
	BSTR		bstrAppID=NULL;
	LONG		lAppType = 0;
	iesEnum		iesReturn=iesSuccess;
	HRESULT		hr=S_OK;

	using namespace IxoComPlusRegister;

	lAppType = riParams.GetInteger(AppType);
	MsiString strAppFile = riParams.GetMsiString(AplFileName);
	MsiString strAppID = riParams.GetMsiString(AppID);

	IMsiRecord& riActionData = GetSharedRecord(2); // don't change ref count - shared record
	AssertNonZero(riActionData.SetMsiString(1, *strAppID));
	AssertNonZero(riActionData.SetInteger(2, lAppType));
	if(Message(imtActionData, riActionData) == imsCancel)
		return iesUserExit;

	hr = OLE32::CoCreateInstance(CLSID_COMAdminCatalog, NULL, CLSCTX_SERVER, IID_ICOMAdminCatalog, (void**) &pIAdminCatalog);
	if (FAILED(hr)) 
	{
		// We can't perform a server or qc client install, if the machine doesn't have
		// COM+ installed on it.
		if (!(lAppType & atClient))
		{
			return FatalError(*PMsiRecord(PostError(Imsg(imsgComPlusNotInstalled))));
		}
		else
		{
			return iesSuccess;
		}
	}

	bstrAppFile = ::AllocBSTR(strAppFile);

	bstrAppID = ::AllocBSTR(strAppID);
	if (!bstrAppFile || !bstrAppID)
	{
		return FatalError(*PMsiRecord(PostError(Imsg(imsgOutOfMemory))));
	}


	Bool fRetry = fTrue, fSuccess = fFalse;
	while(fRetry)  // retry loop
	{
		hr = RemoveApplicationIfExists(pIAdminCatalog, bstrAppID);
		if (FAILED(hr))
		{
			switch (DispatchError(imtEnum(imtError+imtAbortRetryIgnore+imtDefault3), Imsg(imsgComPlusCantRemoveApp)))
			{
			case imsAbort: iesReturn = iesFailure; fRetry = fFalse; break;
			case imsRetry: continue;
			default:       iesReturn = iesSuccess; fRetry = fFalse;
			};
		}
		else
		{
			iesReturn = iesSuccess;
			fSuccess = fTrue;
			fRetry = fFalse;
		}
	}

	OLEAUT32::SysFreeString(bstrAppFile);
	OLEAUT32::SysFreeString(bstrAppID);

	// If we did remove the app and something goes wrong, we would need to reinstall 
	// the application we just removed.
	if (hr == S_OK)
	{
		if (!RollbackRecord(ixoComPlusRegister,riParams))
			iesReturn = iesFailure;
	}

	return iesReturn; 
}

//*****************************************************************************
HRESULT RemoveApplicationIfExists(ICOMAdminCatalog *pIAdminCatalog, BSTR &bstrAppID)
{
	CComPointer<ICatalogCollection> pIAppCollection(0);
	BSTR		bstrCollection =NULL;
    SAFEARRAY*  aCLSIDs = NULL;
	long		lChanges;
	HRESULT		hr=S_OK;

	if ((bstrCollection = OLEAUT32::SysAllocString(L"Applications")) == NULL)
		return E_OUTOFMEMORY;

	hr = pIAdminCatalog->GetCollection(bstrCollection, (IDispatch **) &pIAppCollection);
	OLEAUT32::SysFreeString(bstrCollection);
	if (FAILED(hr))
		return hr;

	// Populate the collection with the item to be deleted.
	hr = GetSafeArrayOfCLSIDs(bstrAppID, &aCLSIDs);
	if (FAILED(hr))
		return hr;
	hr = pIAppCollection->PopulateByKey(aCLSIDs);
	OLEAUT32::SafeArrayDestroy(aCLSIDs);
	if (FAILED(hr))
		return hr;

	// Remove the one and only element from the collection. If there doesn't exist one
	// we can safely continue.
	if (pIAppCollection->Remove(0) == S_OK)
	{
		hr = pIAppCollection->SaveChanges(&lChanges);
		if(FAILED (hr))
			return hr;
		hr = S_OK;
	}
	else
	{
		hr = S_FALSE;
	}

	return hr; 
}

static BSTR AllocBSTR(const TCHAR* sz)
{
#ifndef UNICODE
	if (sz == 0)
		return 0;
	int cchWide = WIN::MultiByteToWideChar(CP_ACP, 0, sz, -1, 0, 0) - 1;
	BSTR bstr = OLEAUT32::SysAllocStringLen(0, cchWide); // null added by API
	WIN::MultiByteToWideChar(CP_ACP, 0, sz, -1, bstr, cchWide);
	bstr[cchWide] = 0; // API function does not null terminate
	return bstr;
#else if
	return OLEAUT32::SysAllocString(sz);
#endif

}

//*****************************************************************************
//*****************************************************************************
HRESULT GetSafeArrayOfCLSIDs(
	LPOLESTR	i_szComponentCLSID,
	SAFEARRAY** o_paCLSIDs)
{
    SAFEARRAY*          aCLSIDs = NULL;
    SAFEARRAYBOUND      rgsaBound[1];
    LONG                Indices[1];
    VARIANT             varT;
    HRESULT             hr = NOERROR;

   
    // PopulateByKey is expecting a SAFEARRAY parameter input,
    // Create a one element SAFEARRAY, the one element of the SAFEARRAY contains
    // the packageID.
    rgsaBound[0].cElements = 1;
    rgsaBound[0].lLbound = 0;
    aCLSIDs = OLEAUT32::SafeArrayCreate(VT_VARIANT, 1, rgsaBound);

    if (aCLSIDs)
    {
        Indices[0] = 0;

		OLEAUT32::VariantInit(&varT);
        varT.vt = VT_BSTR;
        varT.bstrVal = OLEAUT32::SysAllocString(i_szComponentCLSID);
        hr = OLEAUT32::SafeArrayPutElement(aCLSIDs, Indices, &varT);
        OLEAUT32::VariantClear(&varT);

        if (FAILED(hr))
		{       
			OLEAUT32::SafeArrayDestroy(aCLSIDs);
            aCLSIDs = NULL;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	*o_paCLSIDs = aCLSIDs;
    return hr;
}



iesEnum CMsiOpExecute::ixfComPlusRegisterMetaOnly(IMsiRecord& /*riParams*/) { return iesNoAction; }
iesEnum CMsiOpExecute::ixfComPlusUnregisterMetaOnly(IMsiRecord& /*riParams*/) { return iesNoAction; }
iesEnum CMsiOpExecute::ixfComPlusCommit(IMsiRecord& /*riParams*/) { return iesNoAction; }
iesEnum CMsiOpExecute::ixfComPlusRollback(IMsiRecord& /*riParams*/) { return iesNoAction; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\copy.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       copy.cpp
//
//--------------------------------------------------------------------------

/*  copy.cpp - IMsiFileCopy implementation
____________________________________________________________________________*/

#include "precomp.h" 
#include "services.h"
#include "_service.h"
#include "path.h"
#include <accctrl.h>

// log assembly errors
IMsiRecord* PostAssemblyError(const ICHAR* szComponentId, HRESULT hResult, const ICHAR* szInterface, const ICHAR* szFunction, const ICHAR* szAssemblyName);

// The diamond files use _DEBUG instead of DEBUG, so we have to include this
// define here.
#ifdef DEBUG
#ifndef _DEBUG
     #define _DEBUG
#endif
#endif

#include "intrface.h"

#ifdef WIN
//#include <lzexpand.h>
#endif //WIN

const int cbCopyBufferSize = 64*1024;

DWORD GetFileLastWriteTime(const ICHAR* szSrcFile, FILETIME& rftLastWrite)
{
	BOOL fStat = FALSE;
	bool fImpersonate = GetImpersonationFromPath(szSrcFile);

	CImpersonate impersonate(fImpersonate ? fTrue : fFalse);

	if (fImpersonate)
		MsiDisableTimeout();

	DWORD dwLastError = ERROR_SUCCESS;
	HANDLE hSrcFile = WIN::CreateFile(szSrcFile, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);		
	if (hSrcFile != INVALID_HANDLE_VALUE)
	{
		fStat = WIN::GetFileTime(hSrcFile, NULL, NULL, &rftLastWrite);
		if ( !fStat )
			dwLastError = GetLastError();
		WIN::CloseHandle(hSrcFile);
	}
	else
		dwLastError = GetLastError();

	if (fImpersonate)
		MsiEnableTimeout();

	if (fStat == FALSE)
		return dwLastError;
	else
		return NO_ERROR;
}

DWORD MsiSetFileTime(HANDLE hDestFile, FILETIME* pftLastWrite, bool fImpersonate)
{
	// Sets the CreationTime, LastAccessTime, and LastWriteTime values for the
	// file referenced by the given open file handle, as follows:
	//
	// If pftLastWrite points to a valid FILETIME structure, the CreationTime and
	// LastWriteTime values are set to *pftLastWrite, and LastAccessTime is set to
	// the current system time.
	//
	// If pftLastWrite is a NULL pointer, all three values will be set to the 
	// current system time.
	//
	DWORD dwResult = NO_ERROR;
	FILETIME ftLastWrite, ftLastAccess;

	CImpersonate impersonate(fImpersonate ? fTrue : fFalse);

	WIN::GetSystemTimeAsFileTime(&ftLastAccess);

	if (pftLastWrite == 0)
		ftLastWrite = ftLastAccess;
	else
		ftLastWrite = * pftLastWrite;

	BOOL fResult = WIN::SetFileTime(hDestFile, &ftLastWrite, &ftLastAccess, &ftLastWrite);

	if (!fResult)
		return GetLastError();

	return NO_ERROR;
}

DWORD MsiSetFileTime(const ICHAR* szDestFile, FILETIME* pftLastWrite)
{
	bool fImpersonate = GetImpersonationFromPath(szDestFile);

	CImpersonate impersonate(fImpersonate ? fTrue : fFalse);

	if (fImpersonate)
		MsiDisableTimeout();

	HANDLE hDestFile = WIN::CreateFile(szDestFile, GENERIC_WRITE, 0, 0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);
	DWORD dwLastError = ERROR_SUCCESS;
	if (hDestFile == INVALID_HANDLE_VALUE)
		dwLastError = GetLastError();

	if (fImpersonate)
		MsiEnableTimeout();

	if (hDestFile == INVALID_HANDLE_VALUE)
		return dwLastError;

	DWORD dwResult = MsiSetFileTime(hDestFile, pftLastWrite, fImpersonate);
	WIN::CloseHandle(hDestFile);
	return dwResult;
}


DWORD MsiSyncFileTimes(HANDLE hSrcFile, HANDLE hDestFile, bool fImpersonate)
{
	// Synchronizes the CreationTime, LastAccessTime, and LastWriteTime values
	// between the given files, as follows:
	//
	// If hSrcFile represents a valid file handle, CreationTime and LastWriteTime
	// of hDestFile will be set to that of hSrcFile, and LastAccessTime of 
	// hDestFile will be set to the current system time.
	//
	// If hSrcFile is INVALID_HANDLE_VALUE, CreationTime, LastAccessTime, and 
	// LastWriteTime of hDestFile will all be set to the current system time.
	//
	FILETIME ftLastWrite;
	BOOL fValidSource = FALSE;

	CImpersonate impersonate(fImpersonate ? fTrue : fFalse);
	
	if (hSrcFile != INVALID_HANDLE_VALUE)
	{
		if (WIN::GetFileTime(hSrcFile,NULL,NULL,&ftLastWrite) == FALSE)
			return GetLastError();
		fValidSource = TRUE;
	}

	// no open source handle, hDestFile must be a new 0-length file, so
	// pass NULL pointer for pftLastWrite
	return MsiSetFileTime(hDestFile, fValidSource ? &ftLastWrite : 0, fImpersonate);
}

//____________________________________________________________________________
//
// CMsiFileCopy definition
//____________________________________________________________________________

class CMsiFileCopy : public IMsiFileCopy  // class private to this module
{
 public:   // implemented virtual functions
	virtual HRESULT       __stdcall QueryInterface(const IID& riid, void** ppvObj);
	virtual unsigned long __stdcall AddRef();
	virtual unsigned long __stdcall Release();
	virtual IMsiRecord*   __stdcall CopyTo(IMsiPath& riSourcePath, IMsiPath& riDestPath, IMsiRecord& rirecCopyInfo);
	virtual IMsiRecord*   __stdcall ChangeMedia(IMsiPath& riMediaPath, const ICHAR* szKeyFile, Bool fSignatureRequired, IMsiStream* piSignatureCert, IMsiStream* piSignatureHash);
	virtual int           __stdcall SetNotification(int cbNotification, int cbSoFar);
	virtual IMsiRecord*   __stdcall InitCopy(IMsiStorage* piStorage);
	virtual IMsiRecord*	  __stdcall CopyTo(IMsiPath& riSourcePath, IAssemblyCacheItem& riDestASM, bool fManifest, IMsiRecord& rirecCopyInfo);
 public:  // constructor
	 CMsiFileCopy(IMsiServices *piServices);
 protected: // local state
    virtual ~CMsiFileCopy();  // prevent creation on stack
	IMsiRecord*    EndCopy(bool fError);
	IMsiRecord*    CheckSpaceAvailable(IMsiPath& riDestPath, IMsiRecord& rirecCopyInfo);
	virtual IMsiRecord*    _CopyTo(IMsiPath& riSourcePath, IMsiPath* piDestPath, IAssemblyCacheItem* piDestASM, bool fManifest, IMsiRecord& rirecCopyInfo);
	IMsiRecord* ValidateDestination();
	IMsiRecord* OpenSource();
	IMsiRecord* OpenDestination();
	IMsiRecord* WriteFileBits(char* szBuf, unsigned long cbRead);
	int            m_iRefCnt;
	IMsiServices*  m_piServices;
	PMsiPath       m_pDestPath;
	PMsiRecord     m_precCopyInfo;
	int            m_cbSoFar;
	int            m_cbNotification;
	HANDLE         m_hDestFile;
	HANDLE         m_hSrcFile;
	MsiString      m_strDestFullPath;
	MsiString      m_strSourceFullPath;
	bool           m_fDisableTimeout;
	char*          m_szCopyBuffer;
	PAssemblyCacheItem m_pDestASM;
	PStream        m_pDestFile;
	PMsiPath       m_pSourcePath;
	bool           m_fManifest;

};


//____________________________________________________________________________
//
// CMsiCabinetCopy definition
//____________________________________________________________________________


class CMsiCabinetCopy : public CMsiFileCopy  // class private to this module
{
 public:   // implemented virtual functions
	virtual IMsiRecord*   __stdcall ChangeMedia(IMsiPath& riMediaPath, const ICHAR* szKeyFile, Bool fSignatureRequired, IMsiStream* piSignatureCert, IMsiStream* piSignatureHash);
	virtual int           __stdcall SetNotification(int cbNotification, int cbSoFar);
	IMsiRecord*   __stdcall InitCopy(IMsiStorage* piStorage);
 public:  // constructor
	 CMsiCabinetCopy(IMsiServices *piServices, icbtEnum icbtCabinetType);
 protected: // local state
    ~CMsiCabinetCopy();   // prevent creation on stack
	IMsiRecord*    PostCabinetError(IMsiPath& riMediaPath, const ICHAR* szKeyFile, FDIInterfaceError iErr, HRESULT hr);
	virtual IMsiRecord*    _CopyTo(IMsiPath& riSourcePath, IMsiPath* piDestPath, IAssemblyCacheItem* piDestASM, bool fManifest, IMsiRecord& rirecCopyInfo);
	IMsiRecord*    EndCopy();
	MsiString      m_strCabinet;
	FDI_Interface  m_fdii;
	FDIServerResponse  m_fdisResponse;
	icbtEnum       m_icbtCabinetType;
	IMsiStorage*   m_piStorage;
	PMsiPath       m_pMediaPath;
	MsiString      m_strMediaFileName;

	// digital signature information
	IMsiStream*    m_piSignatureCert;
	IMsiStream*    m_piSignatureHash;
	Bool           m_fSignatureRequired;
};

IMsiRecord* CreateMsiFileCopy(ictEnum ictCopierType, IMsiServices* piServices, 
							  IMsiStorage* piStorage, IMsiFileCopy*& rpacopy)
{
	CMsiFileCopy* pCopy;
	IMsiRecord* precErr;

	if (ictCopierType == ictFileCopier)
	{
		pCopy = new CMsiFileCopy(piServices);
	}
	else if (ictCopierType == ictFileCabinetCopier)
	{
		pCopy = new CMsiCabinetCopy(piServices,icbtFileCabinet);
	}
	else if (ictCopierType == ictStreamCabinetCopier)
	{
		pCopy = new CMsiCabinetCopy(piServices,icbtStreamCabinet);
	}
	else
	{
		precErr = &piServices->CreateRecord(1);
		ISetErrorCode(precErr, Imsg(idbgErrorBadCreateCopierEnum));
		return precErr;
	}

	precErr = pCopy->InitCopy(piStorage);
	if (precErr)
	{
		pCopy->Release();
		return precErr; 
	}
	else
	{
		rpacopy = pCopy;
		return NULL;
	}
}


IMsiRecord* CMsiFileCopy::CheckSpaceAvailable(IMsiPath& riDestPath, IMsiRecord& rirecCopyInfo)
/*----------------------------------------------------------------------
If despite all our costing measures we don't have enough space to install
the file specified by our parameters, this function will detect that,
and return an error record.  Returns 0 if everything's fine.
------------------------------------------------------------------------*/
{
 	unsigned int iSpaceRequired = 0;
	IMsiRecord* piRec = riDestPath.ClusteredFileSize(rirecCopyInfo.GetInteger(IxoFileCopyCore::FileSize),iSpaceRequired);
	if (piRec)
		return piRec;

	unsigned int iExistingSize = 0;
	piRec = riDestPath.FileSize(rirecCopyInfo.GetString(IxoFileCopyCore::DestName), iExistingSize);
	if (piRec)
	{
		if (piRec->GetInteger(1) == idbgFileDoesNotExist)
		{
			piRec->Release();
		}
		else
			return piRec;
	}
	else
	{
		piRec = riDestPath.ClusteredFileSize(iExistingSize,iExistingSize);
		if (piRec)
			return piRec;
		if(iSpaceRequired <= iExistingSize)
			return 0; // no extra space required
		else
			iSpaceRequired -= iExistingSize;
	}

	PMsiVolume pDestVolume(&(riDestPath.GetVolume()));
	UINT64 iSpaceAvail = pDestVolume->FreeSpace();
	if ((UINT64)iSpaceRequired >= iSpaceAvail)
		return PostError(Imsg(imsgDiskFull), (const ICHAR*) m_strDestFullPath);

	return 0;
}


//____________________________________________________________________________
//
// CMsiFileCopy implementation
//____________________________________________________________________________

CMsiFileCopy::CMsiFileCopy(IMsiServices *piServices)
 : m_piServices(piServices), m_precCopyInfo(0), m_pDestPath(0), m_cbSoFar(0), m_cbNotification(0),
   m_hDestFile(INVALID_HANDLE_VALUE), m_hSrcFile(INVALID_HANDLE_VALUE), m_szCopyBuffer(0),
   m_pDestASM(0), m_pDestFile(0), m_pSourcePath(0) 
{
	m_iRefCnt = 1;
	m_piServices->AddRef();
	//assert(piServices);
}

int CMsiFileCopy::SetNotification(int cbNotification, int cbSoFar)
{
	m_cbNotification = cbNotification;
	int cbResidual = m_cbSoFar;
	m_cbSoFar = cbSoFar;
	return cbResidual;
}

IMsiRecord* CMsiFileCopy::InitCopy(IMsiStorage* /* piStorage */)
{
	m_szCopyBuffer = new char[cbCopyBufferSize];
	m_cbSoFar = 0;
	return 0;
}

CMsiFileCopy::~CMsiFileCopy()
{
	PMsiRecord pRecErr = EndCopy(true);
	if (m_szCopyBuffer)
		delete [] m_szCopyBuffer;
}


HRESULT CMsiFileCopy::QueryInterface(const IID& riid, void** ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IMsiFileCopy)
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CMsiFileCopy::AddRef()
{
	return ++m_iRefCnt;
}

unsigned long CMsiFileCopy::Release()
{
	if (--m_iRefCnt != 0)
		return m_iRefCnt;

	IMsiServices* piServices = m_piServices;
	delete this;
	piServices->Release();
	return 0;
}

IMsiRecord* CMsiFileCopy::EndCopy(bool fError)
{
	Bool fCloseError = fFalse;
	HRESULT hr = ERROR_SUCCESS;
	if (m_pDestPath) // file copy in progress
	{
		bool fDeleteFile = fError && m_hDestFile != INVALID_HANDLE_VALUE;
		
		Bool fSetTimeError = fFalse;
		DWORD dwSetTimeError = 0;
		if(fError == false)
		{
			// set file times for new file

			// per bug 7887, we set both the creation and last modified dates of the new file
			// to the modified dates of the source file.  this is to ensure both dates are
			// identical for newly installed files
			PMsiVolume pDestVolume(&m_pDestPath->GetVolume());
			bool fImpersonateDest = FVolumeRequiresImpersonation(*pDestVolume);
			dwSetTimeError = MsiSyncFileTimes(m_hSrcFile, m_hDestFile, fImpersonateDest);
			if (dwSetTimeError != NO_ERROR)
				fSetTimeError = fTrue;
		}

		if (m_hSrcFile != INVALID_HANDLE_VALUE && !MsiCloseSysHandle(m_hSrcFile))
			fCloseError = fTrue;
		m_hSrcFile = INVALID_HANDLE_VALUE;
		
		if (m_hDestFile != INVALID_HANDLE_VALUE && !MsiCloseSysHandle(m_hDestFile))
			fCloseError = fTrue;
		m_hDestFile = INVALID_HANDLE_VALUE;
		
		IMsiRecord* piError = 0;
		if(fDeleteFile)
		{
			piError = m_pDestPath->RemoveFile(m_precCopyInfo->GetString(IxoFileCopyCore::DestName));
		}

		if(piError)
			return piError;
		if (fSetTimeError)
			return PostError(Imsg(idbgErrorSettingFileTime), dwSetTimeError, m_strDestFullPath);
		if (fCloseError)
			return PostError(Imsg(idbgErrorClosingFile));
	}
	else if(m_pDestASM) // fusion file copy in progress
	{
		if(fError == false)
		{
			// commit the file stream
			Assert(m_pDestFile);
			hr = m_pDestFile->Commit(0);
			if(!SUCCEEDED(hr))
				fCloseError = fTrue;
		}

		if (m_hSrcFile != INVALID_HANDLE_VALUE && !MsiCloseSysHandle(m_hSrcFile))
			fCloseError = fTrue;
		m_hSrcFile = INVALID_HANDLE_VALUE;

		if (fCloseError)
		{
			// capture assembly error in verbose log
			PMsiRecord pError(PostAssemblyError(TEXT(""), hr, TEXT("IStream"), TEXT("Commit"), TEXT("")));
			return PostError(Imsg(idbgErrorClosingFile));
		}
	}
	m_pDestPath = 0; // release
	m_pDestASM = 0;// release
	m_pDestFile = 0;// release
	m_pSourcePath = 0;// release
	m_precCopyInfo = 0; // release
	m_cbSoFar = 0;
	return 0;
}

IMsiRecord* CMsiFileCopy::ChangeMedia(IMsiPath& /*riMediaPath*/, const ICHAR* /*szKeyFile*/, Bool /*fSignatureRequired*/, IMsiStream* /*piSignatureCert*/, IMsiStream* /*piSignatureHash*/)
//-----------------------------------
{
	return 0; 
}


IMsiRecord* CMsiFileCopy::ValidateDestination()
{
	if(m_pDestASM)
	{
		// there is no destination validation to be performed
		return 0;
	}

	Assert(m_pDestPath);

	IMsiRecord* piRec = 0;
	Bool fDirExists = fFalse;
	if ((piRec = m_pDestPath->Exists(fDirExists)) != 0)
	{
		int iError = piRec->GetInteger(1);
		if (iError == idbgErrorGettingFileAttrib)
		{
			piRec->Release();
			return PostError(Imsg(imsgPathNotAccessible), (const ICHAR*) MsiString(m_pDestPath->GetPath()));
		}
		else
			return piRec;
	}
	if(!fDirExists)
		return PostError(Imsg(idbgDirDoesNotExist), (const ICHAR*) MsiString(m_pDestPath->GetPath()));
		
	// If despite all our costing measures we don't have enough space to install, detect it
	// now, before creating the destination file and trying to write to it.
	piRec = CheckSpaceAvailable(*m_pDestPath, *m_precCopyInfo);
	if (piRec)
		return piRec;

	// If an existing file is in our way, make sure it doesn't have read-only,
	// hidden, or system attributes.
	piRec = m_pDestPath->EnsureOverwrite(m_precCopyInfo->GetString(IxoFileCopyCore::DestName), 0);
	if (piRec)
		return piRec;
	return 0;
}

IMsiRecord* CMsiFileCopy::OpenSource()
{
	IMsiRecord* piRec = 0;
	m_hSrcFile = INVALID_HANDLE_VALUE;

	PMsiVolume pSourceVolume(&(m_pSourcePath->GetVolume()));
	bool fImpersonate = FVolumeRequiresImpersonation(*pSourceVolume);

	// check if absent source file = zero-length target file
	int iCopyAttributes = m_precCopyInfo->GetInteger(IxoFileCopyCore::Attributes);
	if ((iCopyAttributes & (ictfaNoncompressed | ictfaCompressed))
							  == (ictfaNoncompressed | ictfaCompressed))
	{
		iCopyAttributes &= ~ictfaCopyACL;
		// set back the attributes
		m_precCopyInfo->SetInteger(IxoFileCopyCore::Attributes, iCopyAttributes);
	}
	else
	{
		if (fImpersonate)
			StartImpersonating();

		m_fDisableTimeout = false;

		if (fImpersonate)
			m_fDisableTimeout = true;

		// current error mode should include SEM_FAILCRITICALERRORS at this point to
		// prevent unnecessary pop-ups from the OS
	
		if (m_fDisableTimeout)
			MsiDisableTimeout();

		m_hSrcFile = CreateFile(m_strSourceFullPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);
	
		if (m_hSrcFile != INVALID_HANDLE_VALUE)
		{
			DWORD dwType = GetFileType(m_hSrcFile);
			if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
			{
				DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), m_strSourceFullPath);
				WIN::CloseHandle(m_hSrcFile);
				m_hSrcFile = INVALID_HANDLE_VALUE;
				SetLastError(ERROR_OPEN_FAILED);
			}
		}
		DWORD dwLastError = WIN::GetLastError();

		if (m_fDisableTimeout)
			MsiEnableTimeout();

		if (fImpersonate)
			StopImpersonating();

		if(m_hSrcFile == INVALID_HANDLE_VALUE)
		{
			if (dwLastError == ERROR_NOT_READY || dwLastError == ERROR_GEN_FAILURE) 
				return PostError(Imsg(idbgDriveNotReady));
			else if (dwLastError == ERROR_FILE_NOT_FOUND)
				return PostError(Imsg(imsgErrorSourceFileNotFound), (const ICHAR*) m_strSourceFullPath);
			else if (dwLastError == ERROR_SHARING_VIOLATION)
				return PostError(Imsg(imsgSharingViolation), (const ICHAR*) m_strSourceFullPath);
			else if (NET_ERROR(dwLastError))
				return PostError(Imsg(imsgNetErrorReadingFromFile), (const ICHAR*) m_strSourceFullPath);
			else
				return PostError(Imsg(imsgErrorOpeningFileForRead), dwLastError, m_strSourceFullPath);
		}
		MsiRegisterSysHandle(m_hSrcFile);
	}
	return 0;
}

HANDLE MsiCreateFileWithUserAccessCheck(const ICHAR* szDestFullPath, 
								 /*dwDesiredAccess calculated internally,*/ 
								 PSECURITY_ATTRIBUTES pSecurityAttributes,
								 DWORD dwFlagsAndAttributes,
								 bool fImpersonateDest)
{

	if (g_fWin9X || (0 == pSecurityAttributes))
	{
		HANDLE hFile = CreateFile(szDestFullPath, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, (dwFlagsAndAttributes|(SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), 0);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			DWORD dwType = GetFileType(hFile);
			if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
			{
				DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), szDestFullPath);
				WIN::CloseHandle(hFile);
				hFile = INVALID_HANDLE_VALUE;
				SetLastError(ERROR_OPEN_FAILED);
			}
		}
		return hFile;
	}
	if(!WIN::IsValidSecurityDescriptor(
					pSecurityAttributes->lpSecurityDescriptor))
	{
		return INVALID_HANDLE_VALUE;
	}

	HANDLE hDestFile = INVALID_HANDLE_VALUE;
	// We need to create the file initially w/o elevating, to determine whether the user really has
	// access to create the file. If we can't open it with all of the rights that we need then we'll
	// have to open it for GENERIC_WRITE and then re-open it below when we're elevated. The presumption
	// is that if the user has permission to write the file then in general the first call will succeed.

	bool	fReopenFile      = false;
	DWORD	dwDesiredAccess  = GENERIC_WRITE | WRITE_DAC | WRITE_OWNER;

	//FUTURE: generally only the local system has the ability to modify system auditing 
	// and we won't assume that our local system is trusted remotely.  It might, but it's
	// not something we support.
	if (RunningAsLocalSystem() && !fImpersonateDest) dwDesiredAccess |= ACCESS_SYSTEM_SECURITY;

	hDestFile = CreateFile(szDestFullPath, dwDesiredAccess, 0, 0, CREATE_ALWAYS, (dwFlagsAndAttributes|(SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), 0);
	
	if (hDestFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwType = GetFileType(hDestFile);
		if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
		{
			DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), szDestFullPath);
			WIN::CloseHandle(hDestFile);
			hDestFile = INVALID_HANDLE_VALUE;
			SetLastError(ERROR_OPEN_FAILED);
		}
	}
	DWORD dwRet = GetLastError();
	if (hDestFile == INVALID_HANDLE_VALUE && 
				(dwRet == ERROR_ACCESS_DENIED || dwRet == ERROR_PRIVILEGE_NOT_HELD))
	{
		fReopenFile = true;
		hDestFile = CreateFile(szDestFullPath, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);

		if (hDestFile != INVALID_HANDLE_VALUE)
		{
			DWORD dwType = GetFileType(hDestFile);
			if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
			{
				DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), szDestFullPath);
				WIN::CloseHandle(hDestFile);
				hDestFile = INVALID_HANDLE_VALUE;
				SetLastError(ERROR_OPEN_FAILED);
			}
		}
	}

	if (hDestFile != INVALID_HANDLE_VALUE)
	{
		// user can basically open file, so now elevate, re-open, and apply the attributes and security descriptor
		CElevate elevate;

		if (fReopenFile)
		{
			WIN::CloseHandle(hDestFile);
			hDestFile = CreateFile(szDestFullPath, dwDesiredAccess, 0, 0, OPEN_ALWAYS, (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS), 0);
			AssertNonZero(WIN::SetFileAttributes(szDestFullPath, dwFlagsAndAttributes));
		}

		if (hDestFile != INVALID_HANDLE_VALUE)
		{
			// required to write *different* owner information.
			CRefCountedTokenPrivileges cPrivs(itkpSD_WRITE);

			SECURITY_INFORMATION si = GetSecurityInformation(pSecurityAttributes->lpSecurityDescriptor);
			if (!SetUserObjectSecurity(hDestFile, &si, pSecurityAttributes->lpSecurityDescriptor))
			{
				int iLastError = WIN::GetLastError();
				WIN::CloseHandle(hDestFile);
				hDestFile = INVALID_HANDLE_VALUE;
				WIN::SetLastError(iLastError);
			}
		}
	}

	return hDestFile;
}


IMsiRecord* CMsiFileCopy::OpenDestination()
{
	IMsiRecord* piRec = 0;
	int iCopyAttributes = m_precCopyInfo->GetInteger(IxoFileCopyCore::Attributes);
	if(m_pDestPath)
	{
		m_hDestFile = INVALID_HANDLE_VALUE;

		CTempBuffer<char, 1> rgchFileSD(3*1024);
		DWORD cbFileSD = 3*1024;
		BOOL fFileSD = FALSE;

		PMsiVolume pDestVolume(&m_pDestPath->GetVolume());
		bool fDestSupportsACLs   =   (pDestVolume->FileSystemFlags() & FS_PERSISTENT_ACLS) != 0;

		if (iCopyAttributes & ictfaCopyACL)
		{
			bool fSourceSupportsACLs =   (PMsiVolume(&m_pSourcePath->GetVolume())->FileSystemFlags() & FS_PERSISTENT_ACLS) != 0;
			PMsiVolume pSourceVolume(&(m_pSourcePath->GetVolume()));
			bool fImpersonateSource = FVolumeRequiresImpersonation(*pSourceVolume);
			
			if (fSourceSupportsACLs && fDestSupportsACLs && !g_fWin9X && !fImpersonateSource && m_precCopyInfo->IsNull(IxoFileCopyCore::SecurityDescriptor))
			{
				CElevate elevate; // so we can always read the security info
				fFileSD = TRUE;

				DEBUGMSGV("Using source file security for destination.");

				if (!ADVAPI32::GetFileSecurity((const ICHAR*)m_strSourceFullPath, 
							OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION|DACL_SECURITY_INFORMATION|SACL_SECURITY_INFORMATION, 
							(PSECURITY_DESCRIPTOR) rgchFileSD, cbFileSD, &cbFileSD))
				{
					DWORD dwLastError = WIN::GetLastError();
					BOOL fRet = FALSE;
					if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
					{
						rgchFileSD.SetSize(cbFileSD);
						if(cbFileSD <= rgchFileSD.GetSize())
						{
							fRet = ADVAPI32::GetFileSecurity((const ICHAR*)m_strSourceFullPath, 
							OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION|DACL_SECURITY_INFORMATION|SACL_SECURITY_INFORMATION, 
							(PSECURITY_DESCRIPTOR) rgchFileSD, cbFileSD, &cbFileSD);
						}
					}
					if (!fRet)
					{
						return PostError(Imsg(imsgGetFileSecurity), GetLastError(), m_strSourceFullPath);
					}
				}
			}
		}


		int iLastError = ERROR_SUCCESS;
		// Ok (for the moment at least), we've got enough space. Create the destination file.
		int fCreateAttributes = iCopyAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
		bool fImpersonateDest = FVolumeRequiresImpersonation(*pDestVolume);
		if (fImpersonateDest)
			StartImpersonating();

		if (fImpersonateDest)
			m_fDisableTimeout = true;

		if (!fDestSupportsACLs || (m_precCopyInfo->IsNull(IxoFileCopyCore::SecurityDescriptor) && !fFileSD))
		{
			if (m_fDisableTimeout)
				MsiDisableTimeout();

			m_hDestFile = CreateFile(m_strDestFullPath, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, (fCreateAttributes|(SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)), 0);
			if (m_hDestFile != INVALID_HANDLE_VALUE)
			{
				DWORD dwType = GetFileType(m_hDestFile);
				if((FILE_TYPE_PIPE == dwType) || (FILE_TYPE_CHAR == dwType))
				{
					DEBUGMSG1(TEXT("Error: This is not a valid file, hence failing to create: %s"), m_strDestFullPath);
					WIN::CloseHandle(m_hDestFile);
					m_hDestFile = INVALID_HANDLE_VALUE;
					SetLastError(ERROR_OPEN_FAILED);
				}
			}
			if (m_hDestFile == INVALID_HANDLE_VALUE)
			{
				iLastError = WIN::GetLastError();
			}

			if (m_fDisableTimeout)
				MsiEnableTimeout();
		}
		else // either the source file has a security descriptor or we have one to put on the destination
		{
			SECURITY_ATTRIBUTES sa;		
			CTempBuffer<char, cbDefaultSD> rgchSD;
			char* pchSD = 0;  // points to the actual descriptor we'll finally put on the file.

			if (!m_precCopyInfo->IsNull(IxoFileCopyCore::SecurityDescriptor))
			{
				DEBUGMSGV("File will have security applied from OpCode.");
				PMsiStream pSD((IMsiStream*)m_precCopyInfo->GetMsiData(IxoFileCopyCore::SecurityDescriptor));

				//const int cbDefaultSD = 512;
				
				pSD->Reset();

				int cbSD = pSD->GetIntegerValue();
				if (cbDefaultSD < cbSD)
					rgchSD.SetSize(cbSD);

				pchSD = rgchSD; // SetSize can change ultimate pointer.


				// Self Relative Security Descriptor
				pSD->GetData(rgchSD, cbSD);
				AssertNonZero(WIN::IsValidSecurityDescriptor(rgchSD));
				AssertNonZero(WIN::IsValidSecurityDescriptor(pchSD));
			}
			else // use the descriptor that was on the source file
			{
				pchSD = rgchFileSD;
			}

			// Add the security descriptor to the sa structure
			sa.nLength = sizeof(SECURITY_ATTRIBUTES);
			sa.lpSecurityDescriptor = pchSD;
			sa.bInheritHandle = FALSE;

			if (m_fDisableTimeout)
				MsiDisableTimeout();

			Assert(WIN::IsValidSecurityDescriptor(pchSD));

			m_hDestFile = MsiCreateFileWithUserAccessCheck((const ICHAR*) m_strDestFullPath, &sa, fCreateAttributes, fImpersonateDest);
			if (m_hDestFile == INVALID_HANDLE_VALUE)
			{
				iLastError = WIN::GetLastError();
			}

			if (m_fDisableTimeout)
				MsiEnableTimeout();
		}

		if (fImpersonateDest)
			StopImpersonating();

		if (m_hDestFile == INVALID_HANDLE_VALUE)
		{
			if (iLastError == ERROR_ACCESS_DENIED)
			{
				if (fImpersonateDest) StartImpersonating();
				DWORD dwAttr = MsiGetFileAttributes(m_strDestFullPath);
				if (fImpersonateDest) StopImpersonating();
				if (dwAttr != 0xFFFFFFFF && dwAttr & FILE_ATTRIBUTE_DIRECTORY)
					return PostError(Imsg(imsgDirErrorOpeningFileForWrite), (const ICHAR*) m_strDestFullPath);
			}
			return PostError(Imsg(imsgErrorOpeningFileForWrite), iLastError, m_strDestFullPath);
		}
		MsiRegisterSysHandle(m_hDestFile);
	}
	else
	{
		MsiString strDestName = m_precCopyInfo->GetMsiString(IxoFileCopyCore::DestName);
		Assert(m_pDestASM);
		HRESULT hr = m_pDestASM->CreateStream(0, strDestName, m_fManifest ? STREAM_FORMAT_COMPLIB_MANIFEST : 0, 0, &m_pDestFile, NULL);
		if(!SUCCEEDED(hr))
			return PostError(Imsg(imsgErrorOpeningFileForWrite), HRESULT_CODE(hr), strDestName);
	}
	return 0;
}

IMsiRecord* CMsiFileCopy::WriteFileBits(char* szBuf, unsigned long cbRead)
{
	unsigned long cbWritten;
	int iLastError = ERROR_SUCCESS;
	if(m_pDestPath)
	{
		Assert(m_hDestFile != INVALID_HANDLE_VALUE);
		if (WriteFile(m_hDestFile, szBuf, cbRead, &cbWritten, 0))
			return 0;
		iLastError = GetLastError();
	}
	else
	{
		Assert(m_pDestFile);
		HRESULT hr = m_pDestFile->Write(szBuf, cbRead, &cbWritten);
		if(SUCCEEDED(hr))
			return 0;
		iLastError = HRESULT_CODE(hr);
	}
	if (iLastError == ERROR_DISK_FULL)
		return PostError(Imsg(imsgDiskFull), (const ICHAR*) m_strDestFullPath);
	else
		return PostError(Imsg(imsgErrorWritingToFile), (const ICHAR*) m_strDestFullPath);
}

IMsiRecord* CMsiFileCopy::_CopyTo(IMsiPath& riSourcePath, IMsiPath* piDestPath, IAssemblyCacheItem* piDestASM, bool fManifest, IMsiRecord& rirecCopyInfo)
//------------------------------
{
	int iCopyAttributes = rirecCopyInfo.GetInteger(IxoFileCopyCore::Attributes);
	if (iCopyAttributes & ictfaCancel)
	{
		return PostRecord(Imsg(idbgUserAbort));		
	}

	if (iCopyAttributes & ictfaIgnore)
	{
		return PostRecord(Imsg(idbgUserIgnore));
	}

	if (iCopyAttributes & ictfaFailure)
	{
		return PostRecord(Imsg(idbgUserFailure));
	}

	IMsiRecord* piRec;
	if (iCopyAttributes & ictfaRestart)
	{
		piRec = EndCopy(true);
		if (piRec)
			return piRec;

		iCopyAttributes &= (~ictfaRestart);
		rirecCopyInfo.SetInteger(IxoFileCopyCore::Attributes, iCopyAttributes);
	}

	if (!m_pDestPath && !m_pDestASM)  // no copy in progress
	{
		if (rirecCopyInfo.IsNull(IxoFileCopyCore::SourceName))
			return PostError(Imsg(idbgFileKeyIsNull));

		if (rirecCopyInfo.IsNull(IxoFileCopyCore::DestName))
			return PostError(Imsg(idbgFileNameIsNull));

		MsiString strSourceName = rirecCopyInfo.GetString(IxoFileCopyCore::SourceName);
		// m_strSourceFullPath is saved for error requirements later
		if((piRec = riSourcePath.GetFullFilePath(strSourceName, *&m_strSourceFullPath)) != 0)
			return piRec;
	
		MsiString strDestName = rirecCopyInfo.GetMsiString(IxoFileCopyCore::DestName);
		// m_strDestFullPath is saved for error requirements later
		if(piDestPath)
		{
			if((piRec = piDestPath->GetFullFilePath(strDestName, *&m_strDestFullPath)) != 0)
				return piRec;
		}
		else
		{
			// simply use the file name only
			m_strDestFullPath = strDestName;
		}


		m_pDestPath = piDestPath;
		if(piDestPath)
			m_pDestPath->AddRef();
		m_pDestASM = piDestASM;
		if(piDestASM)
			m_pDestASM->AddRef();
		m_fManifest = fManifest;

		m_precCopyInfo = &rirecCopyInfo;
		m_precCopyInfo->AddRef();

		m_pSourcePath = &riSourcePath;
		m_pSourcePath->AddRef();

		if ((piRec = ValidateDestination()) != 0)
		{
			PMsiRecord(EndCopy(true));
			return piRec;
		}

		if ((piRec = OpenSource()) != 0)
		{
			PMsiRecord(EndCopy(true));
			return piRec;	 
		}

		if ((piRec = OpenDestination()) != 0)
		{
			PMsiRecord(EndCopy(true));
			return piRec;
		}				
	}
	else // copy in progress
	{
		if((m_pDestPath && !piDestPath) || (m_pDestASM && !piDestASM))
			return PostError(Imsg(idbgCopyResumedWithDifferentInfo));

		if(m_pDestPath)
		{
			if(!piDestPath)
				return PostError(Imsg(idbgCopyResumedWithDifferentInfo));

			ipcEnum ipc;
			if((piRec = piDestPath->Compare(*m_pDestPath, ipc)) != 0)
				return piRec;
			
			if(ipc != ipcEqual)
				return PostError(Imsg(idbgCopyResumedWithDifferentInfo));
		}
		else
		{
			if(!piDestASM || m_pDestASM != piDestASM)
				return PostError(Imsg(idbgCopyResumedWithDifferentInfo));
		}
		
		MsiString strOldDest(m_precCopyInfo->GetMsiString(IxoFileCopyCore::DestName));
		MsiString strNewDest(rirecCopyInfo.GetMsiString(IxoFileCopyCore::DestName));

		if (strOldDest.Compare(iscExact, strNewDest) == 0)
			return PostError(Imsg(idbgCopyResumedWithDifferentInfo));
		
	}

	if (m_hSrcFile == INVALID_HANDLE_VALUE) // no source file, 0 length
		return EndCopy(false);

	for(;;)
	{
		unsigned long cbToCopy = cbCopyBufferSize;
		if (m_cbNotification && (m_cbNotification - m_cbSoFar) < cbToCopy)
			cbToCopy = m_cbNotification - m_cbSoFar;

		unsigned long cbRead;
		// current error mode should include SEM_FAILCRITICALERRORS at this point to
		// prevent unnecessary pop-ups from the OS

		if (m_fDisableTimeout)
			MsiDisableTimeout();

		Bool fRead = ToBool(ReadFile(m_hSrcFile, m_szCopyBuffer, cbToCopy, &cbRead, 0));
		DWORD dwLastError = ERROR_SUCCESS;
		if ( !fRead )
			dwLastError = GetLastError();

		if (m_fDisableTimeout)
			MsiEnableTimeout();

		if (!fRead)
		{
			if (dwLastError == ERROR_NOT_READY || dwLastError == ERROR_GEN_FAILURE) 
				return PostError(Imsg(idbgDriveNotReady));
			else if (NET_ERROR(dwLastError))
				return PostError(Imsg(imsgNetErrorReadingFromFile), (const ICHAR*) m_strSourceFullPath);
			else
				return PostError(Imsg(imsgErrorReadingFromFile), (const ICHAR*) m_strSourceFullPath, dwLastError);
		}
		if (cbRead)
		{
			if((piRec = WriteFileBits(m_szCopyBuffer, cbRead)) != 0)
				return piRec;
		}
		m_cbSoFar += cbRead;
		if (cbRead < cbToCopy) //EOF
			return EndCopy(false);

		if (m_cbNotification && m_cbSoFar >= m_cbNotification)
		{
			m_cbSoFar -= m_cbNotification;
			return PostRecord(Imsg(idbgCopyNotify), m_cbNotification);
		}
	}

}

IMsiRecord* CMsiFileCopy::CopyTo(IMsiPath& riSourcePath, IAssemblyCacheItem& riDestASM, bool fManifest, IMsiRecord& rirecCopyInfo)
{
	return _CopyTo(riSourcePath, 0, &riDestASM, fManifest, rirecCopyInfo);

}

IMsiRecord* CMsiFileCopy::CopyTo(IMsiPath& riSourcePath, IMsiPath& riDestPath, IMsiRecord& rirecCopyInfo)
{
	return _CopyTo(riSourcePath, &riDestPath, 0, false, rirecCopyInfo);
}

//____________________________________________________________________________
//
// CMsiCabinetCopy implementation
//____________________________________________________________________________

inline CMsiCabinetCopy::CMsiCabinetCopy(IMsiServices *piServices, icbtEnum icbtCabinetType) : CMsiFileCopy(piServices), m_pMediaPath(0), m_piSignatureCert(0), m_piSignatureHash(0)
{
	m_icbtCabinetType = icbtCabinetType;
	m_piStorage = 0;
	m_fSignatureRequired = fFalse; // init to false
}

IMsiRecord* CMsiCabinetCopy::InitCopy(IMsiStorage* piStorage)
{
	CMsiFileCopy::InitCopy(piStorage);
	FDIInterfaceError fdiiErr;
	
	fdiiErr = m_fdii.Init(m_piServices, piStorage);
	if (fdiiErr != ifdiServerLaunched)
		return PostError(Imsg(idbgErrorInitializingFDI));

	if (piStorage && !m_piStorage)
	{
		m_piStorage = piStorage;
		m_piStorage->AddRef();
	}
	return NULL;
}

CMsiCabinetCopy::~CMsiCabinetCopy()
{
	FDIServerResponse fdiResponse = m_fdii.Done();

	// Can get CabinetReadError as response if user aborted as a result of a cabinet read error, and cabinet still not accessible
	AssertNonZero(fdiResponse == fdirSuccessfulCompletion || fdiResponse == fdirClose || fdiResponse == fdirCabinetReadError);
	PMsiRecord pRecErr = EndCopy();
	if (m_piSignatureCert)
		m_piSignatureCert->Release();
	if (m_piSignatureHash)
		m_piSignatureHash->Release();
	if (m_piStorage)
		m_piStorage->Release();

}

IMsiRecord* CMsiCabinetCopy::PostCabinetError(IMsiPath& riMediaPath, const ICHAR* szKeyFile, FDIInterfaceError iErr, HRESULT hr)
{
	MsiString strFullPath;
	PMsiRecord pErrRec(riMediaPath.GetFullFilePath(szKeyFile,*&strFullPath));
	switch (iErr) 
	{
	case ifdiMissingSignature:
		return PostError(Imsg(imsgCABSignatureMissing), (const ICHAR*) strFullPath);
	case ifdiBadSignature: // includes WVT return code
		return PostError(Imsg(imsgCABSignatureRejected), (const ICHAR*) strFullPath, HRESULT_CODE(hr));
	case ifdiNetError:
		return PostError(Imsg(imsgNetErrorOpeningCabinet), (const ICHAR*) strFullPath);
	case ifdiCorruptCabinet:
		return PostError(Imsg(imsgCorruptCabinet), (const ICHAR*) strFullPath);
	default:
		return PostError(Imsg(imsgErrorOpeningCabinet), (const ICHAR*) strFullPath);
	}
}

IMsiRecord* CMsiCabinetCopy::ChangeMedia(IMsiPath& riMediaPath, const ICHAR* szKeyFile, Bool fSignatureRequired, IMsiStream* piSignatureCert, IMsiStream* piSignatureHash)
{
	// set up signature information
	m_fSignatureRequired = fSignatureRequired;
	if (m_piSignatureCert)
	{
		m_piSignatureCert->Release(); // release old
		m_piSignatureCert = 0;
	}
	m_piSignatureCert = piSignatureCert;
	if (piSignatureCert)
		piSignatureCert->AddRef();

	if (m_piSignatureHash)
	{
		m_piSignatureHash->Release(); // release old
		m_piSignatureHash = 0;
	}
	m_piSignatureHash = piSignatureHash;
	if (piSignatureHash)
		piSignatureHash->AddRef();
	HRESULT hrWVT = S_OK; // init to no error

	if (m_icbtCabinetType == icbtFileCabinet)
	{
		Bool fExists = fFalse;
		IMsiRecord* piRec = riMediaPath.FileExists(szKeyFile,fExists);
		if (piRec)
			return piRec;
		else if (!fExists)
			return PostCabinetError(riMediaPath,szKeyFile, ifdiErrorOpeningCabinet, hrWVT);
	}
	
	PMsiVolume pCabVolume = &riMediaPath.GetVolume();
	int iCabDrivetype = pCabVolume->DriveType();
	FDIInterfaceError fdiiErr = m_fdii.OpenCabinet(szKeyFile,MsiString(riMediaPath.GetPath()),m_icbtCabinetType, iCabDrivetype, 
		m_fSignatureRequired, m_piSignatureCert, m_piSignatureHash, hrWVT);

	if (fdiiErr == ifdiDriveNotReady)
		return PostError(Imsg(idbgDriveNotReady));
	else if (fdiiErr != ifdiNoError)
	{
		switch (m_icbtCabinetType)
		{
			case icbtStreamCabinet:
				return PostError(Imsg(idbgStreamCabinetError), szKeyFile);
			default:
				return PostCabinetError(riMediaPath, szKeyFile, fdiiErr, hrWVT);
		}
	}
	m_strCabinet = szKeyFile;
	if (m_pMediaPath != &riMediaPath)
	{
		m_pMediaPath = &riMediaPath;
		m_pMediaPath->AddRef();
	}
	return 0;
}


int CMsiCabinetCopy::SetNotification(int cbNotification, int cbPending)
{
	return m_fdii.SetNotification(cbNotification, cbPending);
}


IMsiRecord* CMsiCabinetCopy::_CopyTo(IMsiPath& /*riSourcePath*/, IMsiPath* piDestPath, IAssemblyCacheItem* piDestASM, bool fManifest, IMsiRecord& rirecCopyInfo)
{
	IMsiRecord* piRec;
	MsiString astrSrcFile;
	MsiString astrDestFile;
	FDIServerResponse fdisResp;

	int iCopyAttributes = rirecCopyInfo.GetInteger(IxoFileCopyCore::Attributes);

	if (iCopyAttributes & ictfaRestart)
	{
		iCopyAttributes &= (~ictfaRestart);
		rirecCopyInfo.SetInteger(IxoFileCopyCore::Attributes, iCopyAttributes);
		if ((piRec = EndCopy()) != 0)
			return piRec;

		if ((piRec = ChangeMedia(*m_pMediaPath, m_strCabinet, m_fSignatureRequired, m_piSignatureCert, m_piSignatureHash)) != 0)
			return piRec;
	}


	if ((iCopyAttributes & ictfaCancel) || (iCopyAttributes & ictfaFailure))
	{
		fdisResp = m_fdii.SendCommand(fdicCancel);
		if (iCopyAttributes & ictfaFailure)
		{
			return PostRecord(Imsg(idbgUserFailure));
		}
	}
	else if (iCopyAttributes & ictfaIgnore)
	{
		fdisResp = m_fdii.SendCommand(fdicIgnore);
	}
	else if (!m_pDestPath && !m_pDestASM)  // no copy in progress
	{
		if (rirecCopyInfo.IsNull(IxoFileCopyCore::SourceName))
			return PostError(Imsg(idbgFileKeyIsNull));
		if (rirecCopyInfo.IsNull(IxoFileCopyCore::DestName))
			return PostError(Imsg(idbgFileNameIsNull));

		MsiString strDestName = rirecCopyInfo.GetMsiString(IxoFileCopyCore::DestName);

		int iDestDriveType;

		if(piDestPath)
		{
			// m_strDestFullPath is saved for error requirements later
			if((piRec = piDestPath->GetFullFilePath(strDestName, *&m_strDestFullPath)) != 0)
				return piRec;

			PMsiVolume pDestVolume = &piDestPath->GetVolume();
			iDestDriveType = pDestVolume->DriveType();
		}
		else
		{
			// simply use the file name only
			m_strDestFullPath = strDestName;
			//!! need to get drive type of fusion assembly
			iDestDriveType = DRIVE_FIXED;
		}

		m_pDestPath = piDestPath;
		if(piDestPath)
			m_pDestPath->AddRef();
		m_pDestASM = piDestASM;
		if(piDestASM)
			m_pDestASM->AddRef();
		m_fManifest = fManifest;

		m_precCopyInfo = &rirecCopyInfo;
		m_precCopyInfo->AddRef();

		if ((piRec = ValidateDestination()) != 0)
			return piRec;		
		

		FileAttributes Attributes;
		CSecurityDescription cSecurityDescription(PMsiStream((IMsiStream*)m_precCopyInfo->GetMsiData(IxoFileCopyCore::SecurityDescriptor)));

		Attributes.attr = rirecCopyInfo.GetInteger(IxoFileCopyCore::Attributes) & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
		if(piDestPath)
			fdisResp = m_fdii.ExtractFile(rirecCopyInfo.GetString(IxoFileCopyCore::SourceName), 0, false, m_strDestFullPath, &Attributes, iDestDriveType, cSecurityDescription);
		else
		{
			Assert(piDestASM);
			fdisResp = m_fdii.ExtractFile(rirecCopyInfo.GetString(IxoFileCopyCore::SourceName), piDestASM, fManifest, m_strDestFullPath, &Attributes, DRIVE_FIXED, cSecurityDescription);
		}
	}
	else // copy in progress
	{
		if((m_pDestPath && !piDestPath) || (m_pDestASM && !piDestASM))
			return PostError(Imsg(idbgCopyResumedWithDifferentInfo));

		if(m_pDestPath)
		{
			if(!piDestPath)
				return PostError(Imsg(idbgCopyResumedWithDifferentInfo));

			ipcEnum ipc;
			if((piRec = piDestPath->Compare(*m_pDestPath, ipc)) != 0)
				return piRec;
			
			if(ipc != ipcEqual)
				return PostError(Imsg(idbgCopyResumedWithDifferentInfo));
		}
		else
		{
			if(!piDestASM || m_pDestASM != piDestASM)
				return PostError(Imsg(idbgCopyResumedWithDifferentInfo));
		}
		
		MsiString strOldDest(m_precCopyInfo->GetMsiString(IxoFileCopyCore::DestName));
		MsiString strNewDest(rirecCopyInfo.GetMsiString(IxoFileCopyCore::DestName));

		if (strOldDest.Compare(iscExact, strNewDest) == 0)
			return PostError(Imsg(idbgCopyResumedWithDifferentInfo));
		
		fdisResp = m_fdii.SendCommand(fdicContinue);
	}

	//!! add target file name to appropriate errors
	switch(fdisResp)
	{
		case fdirNetError:
			return PostError(Imsg(imsgNetErrorReadingFromFile), (const ICHAR*) m_strCabinet);
		case fdirDirErrorCreatingTargetFile:
			return PostError(Imsg(imsgDirErrorOpeningFileForWrite), (const ICHAR*) m_strDestFullPath);
		case fdirCannotCreateTargetFile:
			// this value can come from a couple of locations, and it's not clear
			// what really went wrong - used to be a debug message.
			EndCopy();
			return PostError(Imsg(imsgErrorWritingToFile), (const ICHAR*) m_strDestFullPath);
		case fdirDiskFull:
			return PostError(Imsg(imsgDiskFull), (const ICHAR*) m_strDestFullPath);
		case fdirErrorWritingFile:
		case fdirTargetFile:
			return PostError(Imsg(imsgErrorWritingToFile), (const ICHAR*) m_strDestFullPath);
		case fdirCabinetReadError:
			return PostError(Imsg(imsgErrorReadingFromFile), (const ICHAR*) m_strDestFullPath, 0);
		case fdirNotification:
			return PostError(Imsg(idbgCopyNotify));
		case fdirFileNotFound:          //File table sequence problem
		case fdirNoCabinetOpen:
			EndCopy();
			return PostError(Imsg(imsgFileNotInCabinet),*MsiString(rirecCopyInfo.GetMsiString(IxoFileCopyCore::SourceName)),
				*m_strCabinet);
		case fdirSuccessfulCompletion:  //File copy successful
			return EndCopy();
		case fdirNeedNextCabinet:
			return PostRecord(Imsg(idbgNeedNextCabinet));
		case fdirCannotBreakExtractInProgress:
		case fdirUserAbort:
			return PostError(Imsg(idbgUserAbort));
		case fdirUserIgnore:
			return PostError(Imsg(idbgUserIgnore));
		case fdirNoResponse:
			Assert(0);
		case fdirCabinetNotFound:
			EndCopy();
			return PostError(Imsg(idbgCabinetNotFound));
		case fdirNotACabinet:           //Cabinet signature not found
			EndCopy();
			return PostError(Imsg(idbgNotACabinet));
		case fdirUnknownCabinetVersion: //we can't handle cabinets w/ this version number
		case fdirBadCompressionType:    // or compression type
			EndCopy();
			return PostError(Imsg(idbgCannotHandleCabinet));
		case fdirCorruptCabinet:
		case fdirReserveMismatch:
		case fdirMDIFail:  //decompressor failed...possibly due to bad data
			EndCopy();
			return PostError(Imsg(imsgCorruptCabinet), (const ICHAR*) m_strCabinet);
		case fdirCannotSetAttributes:
			EndCopy();
			return PostError(Imsg(idbgCannotSetAttributes));
		case fdirServerDied:
			EndCopy();
			return PostError(Imsg(idbgFDICannotCreateTargetFile));
		case fdirDriveNotReady:
			return PostError(Imsg(idbgDriveNotReady));
		case fdirStreamReadError:
			return PostError(Imsg(idbgStreamReadError));
		case fdirMissingSignature:
			EndCopy();
			return PostError(Imsg(imsgCABSignatureMissing), (const ICHAR*) m_strCabinet);
		case fdirBadSignature: // includes WVT return code
			EndCopy();
			return PostError(Imsg(imsgCABSignatureRejected), (const ICHAR*) m_strCabinet, HRESULT_CODE(m_fdii.RetrieveWVTReturnCode()));
		default:  // in case we forgot any cases
			EndCopy();
			return PostError(Imsg(idbgFDIServerError));
	}
}

IMsiRecord* CMsiCabinetCopy::EndCopy()
{
	if (m_pDestPath) // file copy in progress
	{
		m_pDestPath = 0; // release
		m_precCopyInfo = 0; // release
	}
	else if(m_pDestASM) // fusion file copy in progress
	{
		m_pDestASM = 0;// release
		m_precCopyInfo = 0; // release
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\coreactn.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       coreactn.cpp
//
//--------------------------------------------------------------------------

/* coreactn.cpp - core install actions
____________________________________________________________________________*/
#include "precomp.h" 
#include "_engine.h"
#include "path.h"
#include "_assert.h"
#include "_msinst.h"
#include "_msiutil.h"
#include "_srcmgmt.h"
#include "tables.h"

#ifdef MAC
#include "macutil.h"
#endif

# include "shlobj.h" // shell folder locations

//!! ugly hopefully temp code for feature publish
enum pfiStates{
	pfiRemove,// feature not known
	pfiAbsent,// feature known but absent
	pfiAvailable,// feature known and available
};
//____________________________________________________________________________
//
// General utility functions
//____________________________________________________________________________

MsiDate GetCurrentDateTime()
{
	unsigned short usDOSDate = 0x21, usDOSTime = 0;
	FILETIME ft;
	SYSTEMTIME st;
	::GetLocalTime(&st);
	::SystemTimeToFileTime(&st, &ft);
	::FileTimeToDosDateTime(&ft, &usDOSDate, &usDOSTime);
	return (MsiDate)((usDOSDate << 16) | usDOSTime);
}


// function that checks if we have only one feature in the product AND/ OR if we have only one component in the feature
int GetDarwinDescriptorOptimizationFlag(IMsiEngine& riEngine, const IMsiString& ristrFeature)
{
	int iOptimization = 0;// no optimization by default

	PMsiSelectionManager pSelectionManager(riEngine,IID_IMsiSelectionManager);
	PMsiTable pFeatureTable = pSelectionManager->GetFeatureTable();
	Assert(pFeatureTable);
	Assert(pFeatureTable->GetRowCount());
	if(pFeatureTable->GetRowCount() == 1)
	{
		// we have 1 feature
		iOptimization |= ofSingleFeature;
	}

	PMsiTable pFeatureComponentsTable = pSelectionManager->GetFeatureComponentsTable();
	Assert(pFeatureComponentsTable);
	PMsiCursor pFeatureComponentsCursor(pFeatureComponentsTable->CreateCursor(fFalse));
	pFeatureComponentsCursor->SetFilter(1); // on the Feature column
	pFeatureComponentsCursor->PutString(1, ristrFeature);
	AssertNonZero(pFeatureComponentsCursor->Next()); // we must have atleast 1 component
	if(!pFeatureComponentsCursor->Next())
	{
		// we have 1 component to that feature
		iOptimization |= ofSingleComponent;
	}
	return iOptimization;
}		

// function that gets the component string as possibly a multi_sz with optimizer bits as a string appended to
const IMsiString& GetComponentWithDarwinDescriptorOptimizationFlag(IMsiEngine& riEngine, const IMsiString& ristrFeature, const IMsiString&  ristrComponentId)
{
	MsiString strComponentId;
	ristrComponentId.AddRef();
	strComponentId = ristrComponentId; // default
	int iOptimization = GetDarwinDescriptorOptimizationFlag(riEngine, ristrFeature);
	if(iOptimization)
	{
		strComponentId = strComponentId + MsiString(MsiChar(0));
		strComponentId = strComponentId + MsiString(iOptimization);
	}
	return strComponentId.Return();

}

Bool GetClientInformation(IMsiServices& riServices, const ICHAR* szProduct, const ICHAR* szClient, const IMsiString*& rpiRelativePackagePath, const IMsiString*& rpiDiskId)
{
	MsiString strClients;
	AssertRecord(GetProductClients(riServices, szProduct, *&strClients));
	while (strClients.TextSize())
	{
		if(*(const ICHAR*)strClients)
		{
			MsiString strProduct = strClients.Extract(iseUpto, ';');

			if(strProduct.Compare(iscExactI, szClient))
			{
				strClients.Remove(iseIncluding, ';');
				strProduct = strClients.Extract(iseUpto, ';');
				strProduct.ReturnArg(rpiRelativePackagePath);
				strClients.Remove(iseIncluding, ';');
				strClients.ReturnArg(rpiDiskId);
				return fTrue;
			}
		}
		if (!strClients.Remove(iseIncluding, '\0'))
			break;
	}

	return fFalse;
}

Bool ProductHasBeenPublished(IMsiServices& riServices, const ICHAR* szProduct, const ICHAR* szClient = 0)
{
	ICHAR rgchBuf[2];
	DWORD cchBuf = sizeof(rgchBuf)/sizeof(ICHAR);
	int iRet = MSI::MsiGetProductInfo(szProduct, INSTALLPROPERTY_PRODUCTNAME, rgchBuf, &cchBuf);
	if (iRet == ERROR_UNKNOWN_PRODUCT)
		return fFalse;
	else if ((iRet == ERROR_SUCCESS) && (rgchBuf[0] == 0))
		return fFalse;
	else if(!szClient)
		return fTrue;

	// are we already registered as a client of the product
	MsiString strClients;
	if(!szClient[0]) // parent install
		szClient = szSelfClientToken;

	MsiString strDummy1, strDummy2;
	return GetClientInformation(riServices, szProduct, szClient, *&strDummy1, *&strDummy2);
}

//____________________________________________________________________________
//
// Top level actions, generally invoke MsiEngine::Sequence
//
//    Calling DoAction(0) uses the upper-cased value of the ACTION property
//    Therefore, only upper-case action names are accessible via command line
//____________________________________________________________________________

iesEnum RunUIOrExecuteSequence(IMsiEngine& riEngine, const ICHAR* szAction, 
												const ICHAR* szUISequence, const ICHAR* szExecuteSequence)
{
	iesEnum iesRet;
	INSTALLUILEVEL iui = (INSTALLUILEVEL)riEngine.GetPropertyInt(*MsiString(*IPROPNAME_UILEVEL));

	if ((riEngine.GetMode() & iefSecondSequence) ||
		 (g_scServerContext != scClient))
	{
		DEBUGMSG("Running ExecuteSequence");
		iesRet = riEngine.Sequence(szExecuteSequence);
	}
	else 
	{
		// Determine whether we have a non-empty UI sequence table
		bool fPopulatedUISequence = false;
		PMsiDatabase pDatabase = riEngine.GetDatabase();
		PMsiTable pUISequenceTable(0);
		PMsiRecord pError = pDatabase->LoadTable(*MsiString(szUISequence), 0, *&pUISequenceTable);
		if (pError == 0)
		{
			if (pUISequenceTable->GetRowCount())
				fPopulatedUISequence = true;
		}
		else
			Assert(pError->GetInteger(1) == idbgDbTableUndefined);

		DEBUGMSG2(TEXT("UI Sequence table '%s' is %s."), szUISequence, fPopulatedUISequence ? TEXT("present and populated") : TEXT("missing or empty"));


		if(g_scServerContext == scClient && (iui == INSTALLUILEVEL_NONE || iui == INSTALLUILEVEL_BASIC || !fPopulatedUISequence))
		{
			if (g_fWin9X)
			{
				DEBUGMSG("Running ExecuteSequence from client");
				iesRet = riEngine.RunExecutionPhase(szExecuteSequence, true);
			}
			else
			{
				DEBUGMSG("In client but switching to server to run ExecuteSequence");
				iesRet = riEngine.RunExecutionPhase(szAction,false);
			}
		}
		else
		{
			DEBUGMSG("Running UISequence");
			AssertNonZero(riEngine.SetProperty(*MsiString(*IPROPNAME_EXECUTEACTION), *MsiString(szAction)));
			Assert(iui == INSTALLUILEVEL_REDUCED || iui == INSTALLUILEVEL_FULL);
			Assert(g_scServerContext == scClient);
			iesRet = riEngine.Sequence(szUISequence);
		}
	}
	return iesRet;
}

/*---------------------------------------------------------------------------
	Install action
---------------------------------------------------------------------------*/

iesEnum Install(IMsiEngine& riEngine)
{
	return RunUIOrExecuteSequence(riEngine, IACTIONNAME_INSTALL, TEXT("InstallUISequence"), TEXT("InstallExecuteSequence"));
}


/*---------------------------------------------------------------------------
	Admin action
---------------------------------------------------------------------------*/

iesEnum Admin(IMsiEngine& riEngine)
{
	if( !(riEngine.GetMode() & iefAdmin) )
	{
		AssertSz(0,"Admin action called when iefAdmin mode bit not set");
		return iesNoAction;
	}

	return RunUIOrExecuteSequence(riEngine, IACTIONNAME_ADMIN, TEXT("AdminUISequence"), TEXT("AdminExecuteSequence"));
}

/*---------------------------------------------------------------------------
	Advertise action
---------------------------------------------------------------------------*/

iesEnum Advertise(IMsiEngine& riEngine)
{
	if(!(riEngine.GetMode() & iefAdvertise))
	{
		AssertSz(0,"Advertise action called when iefAdvertise mode bit not set");
		return iesNoAction;
	}
	return RunUIOrExecuteSequence(riEngine, IACTIONNAME_ADVERTISE, TEXT("AdvtUISequence"), TEXT("AdvtExecuteSequence"));
}

/*---------------------------------------------------------------------------
	Sequence action
---------------------------------------------------------------------------*/

iesEnum Sequence(IMsiEngine& riEngine)
{
	MsiString istrTable = riEngine.GetPropertyFromSz(IPROPNAME_SEQUENCE);
	if (istrTable.TextSize() == 0)
		return iesNoAction;
	return riEngine.Sequence(istrTable);
}

/*---------------------------------------------------------------------------
	Execute action
---------------------------------------------------------------------------*/
iesEnum ExecuteAction(IMsiEngine& riEngine)
{
	// drop fusion and mscoree, if loaded from client side
	// this will allow us to possibly replace/delete file in system32, in service
	FUSION::Unbind();
	MSCOREE::Unbind();

	// set iefSecondSequence in case execute sequence is run in THIS engine
	// set SECONDSEQUENCE property to communicate to server engine
	riEngine.SetMode(iefSecondSequence, fTrue); //?? Do we have to worry about nested Execute action calls here?
	AssertNonZero(riEngine.SetProperty(*MsiString(*IPROPNAME_SECONDSEQUENCE),*MsiString(TEXT("1"))));

	MsiString strExecuteAction = riEngine.GetPropertyFromSz(IPROPNAME_EXECUTEACTION);
	iesEnum iesRet = riEngine.RunExecutionPhase(strExecuteAction,false);
	
	// reset second sequence indicators
	riEngine.SetMode(iefSecondSequence, fFalse);
	AssertNonZero(riEngine.SetProperty(*MsiString(*IPROPNAME_SECONDSEQUENCE),g_MsiStringNull));
	return iesRet;
}

//____________________________________________________________________________
//
// Standard actions, generally called from MsiEngine::Sequence
//____________________________________________________________________________

/*---------------------------------------------------------------------------
	LaunchConditions action
---------------------------------------------------------------------------*/
static const ICHAR sqlLaunchCondition[] =
TEXT("SELECT `Condition`, `Description` FROM `LaunchCondition`");

iesEnum LaunchConditions(IMsiEngine& riEngine)
{
	enum lfnEnum
	{
		lfnCondition = 1,
		lfnDescription,
		lfnNextEnum
	};

	PMsiServices pServices(riEngine.GetServices());

	PMsiView View(0);
	PMsiRecord pRecErr(riEngine.OpenView(sqlLaunchCondition, ivcFetch, *&View));
	if (!pRecErr)
	{
		pRecErr = View->Execute(0);
		if (!pRecErr)
		{
			for(;;)
			{
				PMsiRecord Record(View->Fetch());
				if (!Record)
					break;
				Assert(Record->GetFieldCount() >= lfnNextEnum-1);
				iecEnum iec = riEngine.EvaluateCondition(Record->GetString(lfnCondition));
				if (iec == iecFalse)
				{
					pRecErr = &CreateRecord(2);
					AssertNonZero(pRecErr->SetMsiString(0, *MsiString(Record->GetMsiString(lfnDescription))));
					pRecErr->SetInteger(1, 0);
					riEngine.Message(imtEnum(imtError|imtSendToEventLog), *pRecErr);
					return iesFailure;

				}
				// We ignore iecError or iecNone - bad conditional statements are caught by validation
			}
		}
		else
			return riEngine.FatalError(*pRecErr);
	}
	else if(pRecErr->GetInteger(1) == idbgDbQueryUnknownTable)
		return iesNoAction;
	else
		return riEngine.FatalError(*pRecErr);

	return iesSuccess;
}

/*---------------------------------------------------------------------------
	CostInitialize action
---------------------------------------------------------------------------*/
const ICHAR szFileTable[]             = TEXT("File");
const ICHAR szColFileState[]          = TEXT("State");
const ICHAR szColTempFileAttributes[] = TEXT("TempAttributes");

iesEnum CostInitialize(IMsiEngine& riEngine)
{
	if ((riEngine.GetMode() & iefSecondSequence) && g_scServerContext == scClient)
	{
		DEBUGMSG("Skipping CostInitialize: action already run in this engine.");
		return iesNoAction;
	}

	PMsiRecord pError(0);
	PMsiServices pServices = riEngine.GetServices();
	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;

	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiSelectionManager pSelectionMgr(riEngine, IID_IMsiSelectionManager);
	Assert(pDirectoryMgr != 0 && pSelectionMgr != 0);

	
	// Initialize DirectoryManager
	// ----------------------------

	// insure that ROOTDRIVE property exists
	MsiString istrRootDrive(riEngine.GetPropertyFromSz(IPROPNAME_ROOTDRIVE));
	PMsiPath pRootDrive(0);
	if (!istrRootDrive.TextSize())
	{
		PMsiVolume pVolume(0);
		Bool fWritable;
		for(int i = (riEngine.GetMode() & iefAdmin) ? 0 : 1;i<3;i++)
		{
			idtEnum idtType;
			if(i==0)
				idtType = idtRemote;
			else if(i==1)
				idtType = idtFixed;
			else
				idtType = idtRemovable;

			PEnumMsiVolume pVolEnum = &pServices->EnumDriveType(idtType);
			for (UINT64 iMax = 0; pVolEnum->Next(1, &pVolume, 0)==S_OK; )
			{
				// check if volume is writable
				PMsiPath pPath(0);
				AssertRecord(pServices->CreatePath(MsiString(pVolume->GetPath()),*&pPath));

				// test writability by creating a folder at the root of the drive
				// NOTE: we used to test writability by creating a file, but some drives may be acl'ed to allow
				// folder creation but not file creation.  Folder creation is good enough for us.
				if(pPath)
				{
					MsiString strFolderName;
					pError = pPath->CreateTempFolder(TEXT("MSI"), 0, fTrue, 0, *&strFolderName);

					// if we created the folder, try to remove it.  if we can't remove, consider the folder to be
					// unwritable
					if(pError == 0 && strFolderName.TextSize())
					{
						AssertRecord(pPath->AppendPiece(*strFolderName));
						pError = pPath->Remove(0);
						AssertRecord(pPath->ChopPiece());
						if(pError == 0)
						{
							UINT64 iSize;
							if(idtType == idtRemote)
							{
								pRootDrive = pPath;
								break; // pick first writable remote drive found
							}
							else if ((iSize = pVolume->FreeSpace()) > iMax)
							{
								pRootDrive = pPath;
								iMax = iSize;
							}
						}
					}
				}
			}
			if(pRootDrive)
				break;
		}
		if(pRootDrive == 0)
		{
			// set to drive containing windows folder
			if((pError = pServices->CreatePath(MsiString(riEngine.GetPropertyFromSz(IPROPNAME_WINDOWS_VOLUME)), *&pRootDrive)) != 0)
				return riEngine.FatalError(*pError);
		}

		// Bug 6911 - changed from GetFullUNCFilePath to avoid problems with 3rd-party networks (PCNFS) that
		// can't handle UNC paths.  (Even for LANMAN paths, we didn't really want to be converting from 
		// drive letter to UNC).  Note that this is an issue only for Admin installs, since that's the
		// only time ROOTDRIVE defaults to a network volume.
		if((pError = pRootDrive->GetFullFilePath(0,*&istrRootDrive)) != 0)
			return riEngine.FatalError(*pError);

		riEngine.SetProperty(*MsiString(*IPROPNAME_ROOTDRIVE), *istrRootDrive);
	}
	else
	{
		if((pError = pServices->CreatePath(istrRootDrive, *&pRootDrive)) != 0)
			return riEngine.FatalError(*pError);
		istrRootDrive = pRootDrive->GetPath();
		riEngine.SetProperty(*MsiString(*IPROPNAME_ROOTDRIVE), *istrRootDrive);
	}

	if ((pError = pDirectoryMgr->LoadDirectoryTable(0)))
		return riEngine.FatalError(*pError);

	// resolve only source sub-paths.  full source paths aren't resolved
	// until someone calls GetSourcePath (at which point the user may be
	// prompted for the source)
	if ((pError = pDirectoryMgr->ResolveSourceSubPaths()))
	{
		if (pError->GetInteger(1) == imsgUser)
			return iesUserExit;
		else
			return riEngine.FatalError(*pError);
	}

	// Initialize Selection Manager
	// -----------------------------
	if ((pError = pSelectionMgr->LoadSelectionTables()))
	{
		// OK if Feature or Component tables not present
		if (pError->GetInteger(1) != idbgDbTableUndefined)
			return riEngine.FatalError(*pError);
	}

	// Add the "State" column to the file table (if it exists), so we can
	// record the results of costing (e.g. version checking) for each file.
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	IMsiTable* piFileTable;
	pError = pDatabase->LoadTable(*MsiString(*szFileTable), 1, piFileTable);
	if (pError)
	{
		if (pError->GetInteger(1) != idbgDbTableUndefined)
			return riEngine.FatalError(*pError);
	}
	else
	{
		int colFileState = piFileTable->CreateColumn(icdLong + icdNullable, *MsiString(*szColFileState));
		int colTempFileAttributes = piFileTable->CreateColumn(icdLong + icdNullable, *MsiString(*szColTempFileAttributes));
		AssertNonZero(colFileState && colTempFileAttributes);
		AssertNonZero(pDatabase->LockTable(*MsiString(*szFileTable),fTrue));
		piFileTable->Release();
	}

	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;

	return iesSuccess;
}



/*---------------------------------------------------------------------------
	CostFinalize action
---------------------------------------------------------------------------*/
iesEnum CostFinalize(IMsiEngine& riEngine)
{
	if ((riEngine.GetMode() & iefSecondSequence) && g_scServerContext == scClient)
	{
		DEBUGMSG("Skipping CostFinalize: action already run in this engine.");
		return iesNoAction;
	}

	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;

	Bool fAdmin = riEngine.GetMode() & iefAdmin ? fTrue : fFalse;
	PMsiSelectionManager pSelectionMgr(riEngine, IID_IMsiSelectionManager);
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	Assert(pDirectoryMgr != 0 && pSelectionMgr != 0);

	PMsiRecord pErrRec(0);
	Bool fSelectionManagerActive = fTrue;
	if ((pErrRec = pSelectionMgr->InitializeComponents()))
	{
		int iError = pErrRec->GetInteger(1);
		if (iError == idbgSelMgrNotInitialized)
			fSelectionManagerActive = fFalse;
		else if (iError == imsgUser)
			return iesUserExit;
		else
			return riEngine.FatalError(*pErrRec);
	}

	// Finish initialization of Directory Manager
	// ------------------------------------------
	if ((pErrRec = pDirectoryMgr->CreateTargetPaths()))
	{
		if (pErrRec->GetInteger(1) == imsgUser)
			return iesUserExit;
		else
			return riEngine.FatalError(*pErrRec);
	}

	// Finish initialization of Selection Manager
	// ------------------------------------------
	if (fSelectionManagerActive)
	{
		// Used to call ProcessConditionTable here - now it is called
		// internally by InitializeComponents

		if(fAdmin)
		{
			if((pErrRec = pSelectionMgr->SetAllFeaturesLocal()))
			{
				if (pErrRec->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return riEngine.FatalError(*pErrRec);
			}
		}
		else
		{
			if ((pErrRec = pSelectionMgr->SetInstallLevel(0)))
			{
				if (pErrRec->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return riEngine.FatalError(*pErrRec);
			}
		}
	}

	if(riEngine.ActionProgress() == imsCancel)
		return iesUserExit;

	return iesSuccess;
}


/*---------------------------------------------------------------------------
	ScheduleReboot action - sets the mode bit to indicate reboot at the end
---------------------------------------------------------------------------*/

iesEnum ScheduleReboot(IMsiEngine& riEngine)
{
	riEngine.SetMode(iefReboot, fTrue);
	return iesSuccess;
}


/*---------------------------------------------------------------------------
	ForceReboot action - sets the mode bits and the regkey to force reboot right away
---------------------------------------------------------------------------*/

iesEnum ForceReboot(IMsiEngine& riEngine)
{
	PMsiServices pServices(riEngine.GetServices());
	PMsiRecord pRecErr(0);

	MsiString strProduct;          // package path or product code
	MsiString strRunOnceValueName; // packed product code or package name - must be < 32 chars (minus "!" prefix)
	
	MsiString strProductKey = riEngine.GetProductKey();
	
	if(strProductKey.TextSize())
	{
		// set strProduct
		if(MsiString(riEngine.GetPropertyFromSz(IPROPNAME_PRODUCTTOBEREGISTERED)).TextSize())
		{
			// product is or will be registered when we reboot
			// use product code on RunOnce command line
			strProduct = strProductKey;
		}

		// set strRunOnceValueName
		strRunOnceValueName = MsiString(GetPackedGUID(strProductKey)).Extract(iseFirst,30);
	}

	if(strProduct.TextSize() == 0 || strRunOnceValueName.TextSize() == 0)
	{
		// product will not be registered when we reboot
		// use package path on RunOnce command line
		MsiString strDbFullFilePath = riEngine.GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE);
		if(PathType(strDbFullFilePath) != iptFull)
		{
			pRecErr = PostError(Imsg(idbgPropValueNotFullPath),*MsiString(*IPROPNAME_ORIGINALDATABASE),*strDbFullFilePath);
			return riEngine.FatalError(*pRecErr);
		}
		PMsiPath pDbPath(0);
		MsiString strDbName(0);
		pRecErr = pServices->CreateFilePath(strDbFullFilePath,*&pDbPath,*&strDbName);
		if(pRecErr)
			return riEngine.FatalError(*pRecErr);
		
		if(strProduct.TextSize() == 0)
		{
			// use UNC path to package
			pRecErr = pDbPath->GetFullUNCFilePath(strDbName,*&strProduct);
			if(pRecErr)
				return riEngine.FatalError(*pRecErr);
		}

		if(strRunOnceValueName.TextSize() == 0)
			strRunOnceValueName = strDbName.Extract(iseFirst,30);
	}

	Assert(strProduct.TextSize());
	Assert(strRunOnceValueName.TextSize());

	// pre-pend value name with "!" on Whistler
	// this is necessary for the Shell to run the RunOnce command as a non-admin
	if(MinimumPlatformWindowsNT51())
	{
		MsiString strTemp = strRunOnceValueName;
		strRunOnceValueName = TEXT("!");
		strRunOnceValueName += strTemp;
	}

	MsiString strTransforms         = riEngine.GetProperty(*MsiString(*IPROPNAME_TRANSFORMS));
	MsiString strTransformsAtSource = riEngine.GetProperty(*MsiString(*IPROPNAME_TRANSFORMSATSOURCE));
	MsiString strTransformsSecure   = riEngine.GetProperty(*MsiString(*IPROPNAME_TRANSFORMSSECURE));
	
	//!! all of these +='s are horribly inefficient - should do something else
	MsiString strCommandLine = TEXT("/");
	strCommandLine += MsiChar(INSTALL_PACKAGE_OPTION);
	strCommandLine += TEXT(" \"");
	strCommandLine += strProduct;
	strCommandLine += TEXT("\" ") IPROPNAME_AFTERREBOOT TEXT("=1 ") IPROPNAME_RUNONCEENTRY TEXT("=\"");
	strCommandLine += strRunOnceValueName;
	strCommandLine += TEXT("\" /");
	strCommandLine += MsiChar(QUIET_OPTION);
	
	ICHAR chUILevel = 0;
	iuiEnum iui;

	if (g_scServerContext == scClient)
		iui = g_MessageContext.GetUILevel();
	else
		iui = (iuiEnum)riEngine.GetPropertyInt(*MsiString(*IPROPNAME_CLIENTUILEVEL)); 
	
	switch (iui)
	{
		case iuiNone:     chUILevel = 'N';   break;
		case iuiBasic:    chUILevel = 'B';   break;
		case iuiReduced:  chUILevel = 'R';   break;
		default:          // fall through
		case iuiFull:     chUILevel = 'F';   break;
	}

	strCommandLine += MsiChar(chUILevel);
	strCommandLine += TEXT(" ");

	if(strTransforms.TextSize())
	{
		strCommandLine += IPROPNAME_TRANSFORMS TEXT("=\"");
		strCommandLine += strTransforms;
		strCommandLine += TEXT("\" ");
	}
	if(strTransformsAtSource.TextSize())
	{
		strCommandLine += IPROPNAME_TRANSFORMSATSOURCE TEXT("=1 ");
	}
	
	if (strTransformsSecure.TextSize())
	{
		strCommandLine += IPROPNAME_TRANSFORMSSECURE TEXT("=1 ");
	}

	if(g_szLogFile && *g_szLogFile)
	{
		strCommandLine += TEXT("/");
		strCommandLine += MsiChar(LOG_OPTION);
		ICHAR rgchLogMode[sizeof(szLogChars)/sizeof(ICHAR) + 1] = {0};
		if(ModeBitsToString(g_dwLogMode, szLogChars, rgchLogMode) == ERROR_SUCCESS)
		{
			ASSERT_IF_FAILED(StringCchCat(rgchLogMode, ARRAY_ELEMENTS(rgchLogMode), TEXT("+")));
			if (g_fFlushEachLine)
				ASSERT_IF_FAILED(StringCchCat(rgchLogMode, ARRAY_ELEMENTS(rgchLogMode), TEXT("!")));
			strCommandLine += rgchLogMode;
		}
	
		strCommandLine += TEXT(" \"");
		strCommandLine += g_szLogFile;
		strCommandLine += TEXT("\"");
	}
	iesEnum iesRet = iesNoAction;
	PMsiRecord pParams = &pServices->CreateRecord(IxoRegAddRunOnceEntry::Args);
	AssertNonZero(pParams->SetMsiString(IxoRegAddRunOnceEntry::Name, *strRunOnceValueName));
	AssertNonZero(pParams->SetMsiString(IxoRegAddRunOnceEntry::Command,*strCommandLine));
	if((iesRet = riEngine.ExecuteRecord(ixoRegAddRunOnceEntry, *pParams)) != iesSuccess)
		return iesRet;

	// call RunScript to run any spooled operations now before we reboot
	iesRet = riEngine.RunScript(false);
	if(iesRet == iesSuccess || iesRet == iesNoAction || iesRet == iesFinished)
		iesRet = iesSuspend;

	// update the InProgress information to reflect that the in-progress install contained a ForceReboot
	// (we don't put this property in the RunOnce key because that value is volatile - the InProgress information is not)
	PMsiRecord pInProgressInfo = &(pServices->CreateRecord(ipiEnumCount));
	AssertNonZero(pInProgressInfo->SetString(ipiAfterReboot, IPROPNAME_AFTERREBOOT TEXT("=1")));
	pRecErr = UpdateInProgressInstallInfo(*pServices, *pInProgressInfo);
	if(pRecErr)
	{
		AssertRecordNR(pRecErr); // ignore failure
		pRecErr = 0;
	}
	
	riEngine.SetMode(iefReboot, fTrue);
	riEngine.SetMode(iefRebootNow, fTrue);

	// Sequence will end transaction - will not unlock server if iesRet == iesSuspend
	return iesRet;
}

//____________________________________________________________________________
//
// Product registration actions, will be move to another file after development
//____________________________________________________________________________

/*---------------------------------------------------------------------------
	CollectUserInfo action - puts up UI to collect user information on 
	first run, then registers this info
---------------------------------------------------------------------------*/

iesEnum CollectUserInfo(IMsiEngine& riEngine)
{
	iesEnum iesReturn = riEngine.DoAction(IACTIONNAME_FIRSTRUN);
	if (iesReturn != iesSuccess)
		return iesReturn;

	return riEngine.RegisterUser(true);
}

/*---------------------------------------------------------------------------
	ValidatePID action - validates the PIDKEY value agains the PIDTemplate
	value and sets the ProductID property appropriately
---------------------------------------------------------------------------*/

iesEnum ValidateProductID(IMsiEngine& riEngine)
{
	riEngine.ValidateProductID(false);
	// always return success from this action - true pid validation (and failure upon invalidation)
	// is performed in the UI or during first-run.  If this is to be done during the install, a custom
	// action can do it
	return iesSuccess;
}

enum iuoEnum
{
	iuoVersionGreater  = 0x1,
	iuoVersionLessThan = 0x2,
	iuoVersionEqual    = 0x4,
};

bool CompareUpgradeVersions(unsigned int iVersion1, unsigned int iVersion2, unsigned int iOperator)
{
	// iOperator & iuoVersionGreater:  hit if iVersion1 > iVersion2
	// iOperator & iuoVersionLessThan: hit if iVersion1 < iVersion2
	// iOperator & iuoVersionEqual:    hit if iVersion1 = iVersion2

	iuoEnum iuoVersionCompare;
	if(iVersion1 == iVersion2)
		iuoVersionCompare = iuoVersionEqual;
	else if(iVersion1 > iVersion2)
		iuoVersionCompare = iuoVersionGreater;
	else
		iuoVersionCompare = iuoVersionLessThan;

	return (iuoVersionCompare & iOperator) ? true : false;
}

#ifdef DEBUG
void DumpTable(IMsiEngine& riEngine, const ICHAR* szTable)
{
	PMsiRecord pError(0);
	
	DEBUGMSG1(TEXT("Beginning dump of table: %s"), szTable);
	
	ICHAR szQuery[256];
	ASSERT_IF_FAILED(StringCchPrintf(szQuery, ARRAY_ELEMENTS(szQuery),
												TEXT("SELECT * FROM `%s`"), szTable));
	
	PMsiView pView(0);
	pError = riEngine.OpenView(szQuery, ivcFetch, *&pView);

	if(!pError)
		pError = pView->Execute(0);

	if(!pError)
	{
		PMsiRecord pFetchRecord(0);

		while(pFetchRecord = pView->Fetch())
		{
			DEBUGMSG(MsiString(pFetchRecord->FormatText(fTrue)));
		}
	}

	DEBUGMSG1(TEXT("Ending dump of table: %s"), szTable);
}
#endif //DEBUG

/*---------------------------------------------------------------------------
	FindRelatedProducts action - searches for products specified in Upgrade
	table and sets appropriate properties
---------------------------------------------------------------------------*/

const ICHAR sqlFindRelatedProducts[] =
TEXT("SELECT `UpgradeCode`,`VersionMin`,`VersionMax`,`Language`,`Attributes`,`ActionProperty` FROM `Upgrade`");

const ICHAR sqlOldUpgradeTableSchema[] = 
TEXT("SELECT `UpgradeCode`, `ProductVersion`, `Operator`, `Features`, `Property` FROM `Upgrade`");

enum qfrpEnum
{
	qfrpUpgradeCode = 1,
	qfrpMinVersion,
	qfrpMaxVersion,
	qfrpLanguages,
	qfrpAttributes,
	qfrpActionProperty,
};

iesEnum FindRelatedProducts(IMsiEngine& riEngine)
{
	if(riEngine.GetMode() & iefSecondSequence)
	{
		DEBUGMSG(TEXT("Skipping FindRelatedProducts action: already done on client side"));
		return iesNoAction;
	}

	if(riEngine.GetMode() & iefMaintenance)
	{
		DEBUGMSG(TEXT("Skipping FindRelatedProducts action: not run in maintenance mode"));
		return iesNoAction;
	}

	if ( g_MessageContext.IsOEMInstall() )
	{
		DEBUGMSG(TEXT("Skipping FindRelatedProducts action: not run in OEM mode"));
		return iesNoAction;
	}

	PMsiRecord pError(0);
	PMsiServices pServices(riEngine.GetServices());

	PMsiView pUpgradeView(0);
	if((pError = riEngine.OpenView(sqlFindRelatedProducts, ivcFetch, *&pUpgradeView)) ||
		(pError = pUpgradeView->Execute(0)))
	{
		// If any tables are missing, not an error - just nothing to do
		if (pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		else if(pError->GetInteger(1) == idbgDbQueryUnknownColumn) // might be the older schema that we dont support
		{
			if(!PMsiRecord(riEngine.OpenView(sqlOldUpgradeTableSchema, ivcFetch, *&pUpgradeView)))
			{
				// matches old schema, noop
				DEBUGMSG(TEXT("Skipping FindRelatedProducts action: database does not support upgrade logic"));
				return iesNoAction;
			}
		}
		return riEngine.FatalError(*pError);
	}
	
	MsiString strProductCode = riEngine.GetProductKey();
	Assert(strProductCode.TextSize());
	MsiString strUpgradingProductCode = riEngine.GetPropertyFromSz(IPROPNAME_UPGRADINGPRODUCTCODE);
	
	bool fNewInstallPerMachine = MsiString(riEngine.GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? true : false;
	
	PMsiRecord pActionData = &::CreateRecord(1);
	PMsiRecord pFetchRecord(0);
	while(pFetchRecord = pUpgradeView->Fetch())
	{
		const ICHAR* szUpgradeCode = pFetchRecord->GetString(qfrpUpgradeCode);
		int iOperator = pFetchRecord->GetInteger(qfrpAttributes);
		Assert(iOperator != iMsiStringBadInteger);

		const int cMaxLangs = 255;
		unsigned short rgwLangID[cMaxLangs];
		int iLangCount = 0;
		if(!pFetchRecord->IsNull(qfrpLanguages))
		{
			AssertNonZero(GetLangIDArrayFromIDString(pFetchRecord->GetString(qfrpLanguages), rgwLangID, cMaxLangs, iLangCount));
		}

		int iIndex = 0;
		ICHAR rgchProductKey[cchProductCode + 1];
		while(ERROR_SUCCESS == MsiEnumRelatedProducts(szUpgradeCode, 0, iIndex, rgchProductKey))
		{
			iIndex++;
			
			if(strProductCode.Compare(iscExactI, rgchProductKey) ||        // can't upgrade over same product code
				strUpgradingProductCode.Compare(iscExactI, rgchProductKey)) // can't upgrade over product that's upgrading over us
			{
				continue;
			}

			// check assignment type of existing app - only a "hit" if its the same as the current
			// per-user or per-machine install type
			// NOTE: we miss the case where we are installing per-machine and the existing install is both
			// per-machine and per-user.  in this case we don't detect a per-machine app.  this is a known
			// limitation
			CTempBuffer<ICHAR, 15> rgchAssignmentType;
			if((GetProductInfo(rgchProductKey, INSTALLPROPERTY_ASSIGNMENTTYPE, rgchAssignmentType)) == fFalse)
			{
				DEBUGMSG1(TEXT("FindRelatedProducts: could not read ASSIGNMENTTYPE info for product '%s'.  Skipping..."), rgchProductKey);
				continue;
			}

			// current assignment type should be same as existing assignment type
			bool fExistingInstallPerMachine = (MsiString(*(ICHAR* )rgchAssignmentType) == 1);
			if(fNewInstallPerMachine != fExistingInstallPerMachine)
			{
				DEBUGMSG3(TEXT("FindRelatedProducts: current install is per-%s.  Related install for product '%s' is per-%s.  Skipping..."),
							 fNewInstallPerMachine ? TEXT("machine") : TEXT("user"), rgchProductKey,
							 fExistingInstallPerMachine ? TEXT("machine") : TEXT("user"));
				continue;
			}

			CTempBuffer<ICHAR, 15> rgchProductVersion;
			if((GetProductInfo(rgchProductKey,INSTALLPROPERTY_VERSION,rgchProductVersion)) == fFalse)
			{
				DEBUGMSG1(TEXT("FindRelatedProducts: could not read VERSION info for product '%s'.  Skipping..."), rgchProductKey);
				continue;
			}

			CTempBuffer<ICHAR, 15> rgchProductLanguage;
			if((GetProductInfo(rgchProductKey,INSTALLPROPERTY_LANGUAGE,rgchProductLanguage)) == fFalse)
			{
				DEBUGMSG1(TEXT("FindRelatedProducts: could not read LANGUAGE info for product '%s'.  Skipping..."), rgchProductKey);
				continue;
			}

			unsigned int iProductVersion = MsiString((ICHAR*)rgchProductVersion);
			Assert((int)iProductVersion != (int)iMsiStringBadInteger);

			int iProductLanguage = MsiString((ICHAR*)rgchProductLanguage);
			Assert(iProductLanguage != iMsiStringBadInteger);

			bool fHit = true;
			
			// check min version
			if(pFetchRecord->IsNull(qfrpMinVersion) == fFalse)
			{
				MsiString strMinUpgradeVersion = pFetchRecord->GetString(qfrpMinVersion);
				unsigned int iLowerUpgradeVersion = ProductVersionStringToInt(strMinUpgradeVersion);
				int iLowerOperator = iuoVersionGreater | ((iOperator & msidbUpgradeAttributesVersionMinInclusive) ? iuoVersionEqual : 0);

				if(CompareUpgradeVersions(iProductVersion, iLowerUpgradeVersion, iLowerOperator) == false)
					fHit = false;
			}

			// check max version
			if(fHit && pFetchRecord->IsNull(qfrpMaxVersion) == fFalse)
			{
				MsiString strMaxUpgradeVersion = pFetchRecord->GetString(qfrpMaxVersion);
				unsigned int iUpperUpgradeVersion = ProductVersionStringToInt(strMaxUpgradeVersion);
				int iUpperOperator = iuoVersionLessThan | ((iOperator & msidbUpgradeAttributesVersionMaxInclusive) ? iuoVersionEqual : 0);

				if(CompareUpgradeVersions(iProductVersion, iUpperUpgradeVersion, iUpperOperator) == false)
					fHit = false;
			}

			// check language
			if(fHit && iLangCount)
			{
				if(iOperator & msidbUpgradeAttributesLanguagesExclusive)
				{
					// set from table defines languages that aren't a hit
					// so if this language is in the set, we don't have a hit
					fHit = true;
				}
				else
				{
					// set from table defines lanauges that are a hit
					// so if this language is in the set, we have a hit
					fHit = false;
				}

				for (int iLangIndex = 0; iLangIndex < iLangCount; iLangIndex++)
				{
					if (rgwLangID[iLangIndex] == iProductLanguage)
					{
						fHit = !fHit; // if inclusive, we found a hit lang, if exclusive we found a non-hit
						break;
					}
				}
			}

			if(fHit)
			{
				// send action data message for each product found
				AssertNonZero(pActionData->SetString(1, rgchProductKey)); //?? get product name instead?				
				if(riEngine.Message(imtActionData, *pActionData) == imsCancel)
					return iesUserExit;

				// set property to indicate a product was found
				MsiString strProperty = pFetchRecord->GetString(qfrpActionProperty);
				MsiString strPropValue = riEngine.GetProperty(*strProperty);
				if(strPropValue.TextSize())
					strPropValue += TEXT(";");
				strPropValue += rgchProductKey;
				AssertNonZero(riEngine.SetProperty(*strProperty, *strPropValue));

				if(iOperator & msidbUpgradeAttributesMigrateFeatures)
				{
					strPropValue = riEngine.GetPropertyFromSz(IPROPNAME_MIGRATE);
					if(strPropValue.TextSize())
						strPropValue += TEXT(";");
					strPropValue += rgchProductKey;
					AssertNonZero(riEngine.SetProperty(*MsiString(*IPROPNAME_MIGRATE),*strPropValue));
				}
			}
		}
	}

	return iesSuccess;
}

const ICHAR sqlFeatures[] = TEXT("SELECT `Feature` FROM `Feature`");

iesEnum MigrateFeatureStates(IMsiEngine& riEngine)
{
	if(riEngine.GetMode() & iefSecondSequence)
	{
		DEBUGMSG(TEXT("Skipping MigrateFeatureStates action: already done on client side"));
		return iesNoAction;
	}
	
	if(riEngine.GetMode() & iefMaintenance)
	{
		DEBUGMSG(TEXT("Skipping MigrateFeatureStates action: not run in maintenance mode"));
		return iesNoAction;
	}

	if(MsiString(riEngine.GetPropertyFromSz(IPROPNAME_PRESELECTED)).TextSize())
	{
		DEBUGMSG(TEXT("Skipping MigrateFeatureStates action: feature settings already made"));
		return iesNoAction;
	}

	MsiString strMigratePropName(*IPROPNAME_MIGRATE);
	MsiString strMigratePropValue = riEngine.GetProperty(*strMigratePropName);
	if(!strMigratePropValue.TextSize())
		return iesNoAction;

	DEBUGMSG1(TEXT("Migrating feature settings from product(s) '%s'"),strMigratePropValue);
	PMsiRecord pError(0);

	// might be multiple product codes in property value
	// set up "multi-sz" to process each quickly
	CTempBuffer<ICHAR, cchGUID + 2> rgchMigrateCodes;
	if(strMigratePropValue.TextSize() + 2 > rgchMigrateCodes.GetSize())
		rgchMigrateCodes.SetSize(strMigratePropValue.TextSize() + 2);

	ASSERT_IF_FAILED(StringCchCopy(rgchMigrateCodes, rgchMigrateCodes.GetSize(), (const ICHAR*)strMigratePropValue));
	int cCodes = 0;
	ICHAR* pch = rgchMigrateCodes;
	ICHAR* pchStart = pch; // pointer to start of product code
	for(; *pch; pch++)
	{
		if(*pch == ';')
		{
			if(pch - pchStart != cchGUID)
			{
				pError = PostError(Imsg(idbgInvalidPropValue),*strMigratePropName,*strMigratePropValue);
				return riEngine.FatalError(*pError);
			}
			*pch = 0;
			pchStart = pch+1;
		}
	}
	if(pch != pchStart && (pch - pchStart != cchGUID))
	{
		pError = PostError(Imsg(idbgInvalidPropValue),*strMigratePropName,*strMigratePropValue);
		return riEngine.FatalError(*pError);
	}
	*(pch+1) = 0; // end with double-null

	
	PMsiSelectionManager pSelectionManager(riEngine,IID_IMsiSelectionManager);
	PMsiTable pFeatureTable = pSelectionManager->GetFeatureTable();
	if(pFeatureTable == 0)
	{
		pError = PostError(Imsg(idbgNotInitializedToMigrateSettings));
		return riEngine.FatalError(*pError);
	}

	PMsiCursor pFeatureCursor = pFeatureTable->CreateCursor(fTrue); // feature table always tree-linked

	while(pFeatureCursor->Next())
	{
		MsiString strFeature = pFeatureCursor->GetString(1);

		const ICHAR *szProductCode = rgchMigrateCodes;
		iisEnum iisState = iisNextEnum;
		
		do
		{
			INSTALLSTATE isINSTALLSTATE = MsiQueryFeatureState(szProductCode,strFeature);
			
			switch(isINSTALLSTATE)
			{
			case INSTALLSTATE_LOCAL:
				iisState = iisLocal;
				break;

			case INSTALLSTATE_SOURCE:
				if(iisState == iisNextEnum || iisState == iisAbsent || iisState == iisAdvertise)
					iisState = iisSource;
				break;

			case INSTALLSTATE_ADVERTISED:
				if(iisState == iisNextEnum || iisState == iisAbsent)
					iisState = iisAdvertise;
				break;

			case INSTALLSTATE_ABSENT:
				if(iisState == iisNextEnum)
					iisState = iisAbsent;
				break;

			default:
	#ifdef DEBUG
				ICHAR rgchDebug[256];
				ASSERT_IF_FAILED(StringCchPrintf(rgchDebug, ARRAY_ELEMENTS(rgchDebug),
									 TEXT("Unexpected return from MsiQueryFeatureState(%s,%s): %d"),
									 szProductCode,(const ICHAR*)strFeature,isINSTALLSTATE));
				AssertSz(0,rgchDebug);
	#endif //DEBUG
				// fall through
			case INSTALLSTATE_UNKNOWN:
				break; // feature not in other product
			}
		}
		while(iisState != iisLocal && *(szProductCode += (cchGUID+1)) != 0);

		if(iisState != iisNextEnum)
		{
			const ICHAR szState[][12] = {TEXT("Absent"),TEXT("Local"),TEXT("Source"),TEXT("Reinstall"),
												 TEXT("Advertise"),TEXT("Current"),TEXT("FileAbsent"),TEXT("Null")};

			DEBUGMSGV2(TEXT("MigrateFeatureStates: based on existing product, setting feature '%s' to '%s' state."),
						  strFeature, szState[iisState]);
			pError = pSelectionManager->ConfigureFeature(*strFeature,iisState);
			if(pError)
				return riEngine.FatalError(*pError);
		}
	}

	return iesSuccess;
}

/*---------------------------------------------------------------------------
	RemoveExistingProducts action - Removes existing products
---------------------------------------------------------------------------*/

const ICHAR sqlUpgradeUninstall[] =
TEXT("SELECT `Attributes`, `ActionProperty`, `Remove` FROM `Upgrade`");

enum iqbiEnum
{
	iqbiAttributes = 1,
	iqbiActionProperty,
	iqbiRemove,
};

iesEnum ResolveSource(IMsiEngine& riEngine); // action used by RemoveExistingProducts
iesEnum GetForeignSourceList(IMsiEngine& riEngine, const IMsiString& ristrProduct,
									  const IMsiString*& rpistrForeignSourceList);

iesEnum RemoveExistingProducts(IMsiEngine& riEngine)
{
	if((riEngine.GetMode() & iefMaintenance) || !FFeaturesInstalled(riEngine))
	{
		// performing an uninstall, or not installing anything.  REP is a no-op in this case.
		DEBUGMSG(TEXT("Skipping RemoveExistingProducts action: current configuration is maintenance mode or an uninstall"));
		return iesNoAction;
	}

	if(riEngine.GetMode() & iefOperations)
	{
		// since each uninstall must run in its own script, REP may not be run while a script is currently
		// being spooled
		PMsiRecord pError = PostError(Imsg(idbgRemoveExistingProductsSequenceError));
		return riEngine.FatalError(*pError);
	}


	PMsiRecord pError(0);
	PMsiServices pServices(riEngine.GetServices());

	PMsiView pUpgradeView(0);
	if((pError = riEngine.OpenView(sqlUpgradeUninstall, ivcFetch, *&pUpgradeView)) ||
		(pError = pUpgradeView->Execute(0)))
	{
		// If any tables are missing, not an error - just nothing to do
		if (pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		else if(pError->GetInteger(1) == idbgDbQueryUnknownColumn) // might be the older schema that we dont support
		{
			if(!PMsiRecord(riEngine.OpenView(sqlOldUpgradeTableSchema, ivcFetch, *&pUpgradeView)))
			{
				// matches old schema, noop
				DEBUGMSG(TEXT("Skipping RemoveExistingProducts action: database does not support upgrade logic"));
				return iesNoAction;
			}
		}
		return riEngine.FatalError(*pError);
	}
	
	MsiString strNewProductKey = riEngine.GetProductKey();

	MsiString strPatchedProductCode = riEngine.GetPropertyFromSz(IPROPNAME_PATCHEDPRODUCTCODE);

	// don't return until end-of-function
	
	// set current message headers to those used during upgrade uninstalls
	AssertNonZero(riEngine.LoadUpgradeUninstallMessageHeaders(PMsiDatabase(riEngine.GetDatabase()),true) == ieiSuccess);

	PMsiRecord pActionData = &::CreateRecord(2);
	PMsiRecord pFetchRecord(0);
	iesEnum iesRet = iesSuccess;
	while((pFetchRecord = pUpgradeView->Fetch()) != 0 && (iesRet == iesSuccess || iesRet == iesNoAction))
	{
		int iOperator = pFetchRecord->GetInteger(iqbiAttributes);
		Assert(iOperator != iMsiStringBadInteger);
		if(iOperator & msidbUpgradeAttributesOnlyDetect)
			continue;
		
		MsiString strCommandLine;
		if(strNewProductKey.TextSize())
		{
			strCommandLine = IPROPNAME_UPGRADINGPRODUCTCODE TEXT("=");
			strCommandLine += strNewProductKey;
			strCommandLine += TEXT(" ");
		}

		MsiString strFeatures = pFetchRecord->GetMsiString(iqbiRemove);
		if(!strFeatures.TextSize())
		{
			// no authored string - default to ALL
			strFeatures = IPROPVALUE_FEATURE_ALL;
		}
		else
		{
			strFeatures = riEngine.FormatText(*strFeatures); // formatted column

			// if string formats to nothing, it means we don't want to remove anything
			// note that this is different than the case above when nothing in the column means remove everything
			if(!strFeatures.TextSize())
				continue;
		}

		strCommandLine += IPROPNAME_FEATUREREMOVE TEXT("=");
		strCommandLine += strFeatures;
		
		MsiString strPropValue = riEngine.GetProperty(*MsiString(pFetchRecord->GetMsiString(iqbiActionProperty)));
		if(!strPropValue.TextSize())
			continue;

		while(strPropValue.TextSize())
		{
			MsiString strProductKey = strPropValue.Extract(iseUpto,';');

			if(strProductKey.TextSize())
			{
				
				// if we are patching over this product we may need to do some source handling
				if(strProductKey.Compare(iscExactI, strPatchedProductCode))
				{
					// we may be removing the old product before the new product has been installed

					// need to make sure source is resolved for new product - call ResolveSource action to do this
					if((iesRet == ResolveSource(riEngine)) != iesSuccess)
						break;

					// need to save old source list to be registered for new product
					MsiString strPatchedProductSourceList = riEngine.GetPropertyFromSz(IPROPNAME_PATCHEDPRODUCTSOURCELIST);
					if(strPatchedProductSourceList.TextSize() == 0)
					{
						// source list not saved yet
						if ((iesRet = GetForeignSourceList(riEngine, *strProductKey, *&strPatchedProductSourceList)) != iesSuccess)
							break;
					
						AssertNonZero(riEngine.SetProperty(*MsiString(IPROPNAME_PATCHEDPRODUCTSOURCELIST),
																	  *strPatchedProductSourceList));
					}
				}
				
				// send action data message for each product found
				AssertNonZero(pActionData->SetMsiString(1, *strProductKey)); //?? get product name instead?				
				AssertNonZero(pActionData->SetMsiString(2, *strCommandLine));
				if(riEngine.Message(imtActionData, *pActionData) == imsCancel)
					break;

				bool fIgnoreFailure = (iOperator & msidbUpgradeAttributesIgnoreRemoveFailure) ? true : false;
				iesRet = riEngine.RunNestedInstall(*strProductKey,fTrue,0,*strCommandLine,iioUpgrade,fIgnoreFailure);
				Assert((riEngine.GetMode() & iefOperations) == 0); // uninstall shouldn't have merged script ops
				if(iesRet == iesUserExit)
					break;
			}

			strPropValue.Remove(iseFirst,strProductKey.TextSize());
			if((*(const ICHAR*)strPropValue == ';'))
				strPropValue.Remove(iseFirst, 1);
		}	
	}

	// reset current message headers
	AssertNonZero(riEngine.LoadUpgradeUninstallMessageHeaders(PMsiDatabase(riEngine.GetDatabase()),false) == ieiSuccess);

	return iesRet;
}

/*---------------------------------------------------------------------------
	RegisterProduct action - registers product with configuration managager
---------------------------------------------------------------------------*/

iesEnum RegisterProduct(IMsiEngine& riEngine)
{
	return riEngine.RegisterProduct();
}

/*---------------------------------------------------------------------------
	RegisterUser action - registers user info with configuration managager
---------------------------------------------------------------------------*/

iesEnum RegisterUser(IMsiEngine& riEngine)
{
	if (riEngine.GetMode() & iefMaintenance)
		return iesNoAction;
	// initialization of UserName and OrgName moved to Engine::Initialize
	return riEngine.RegisterUser(false);
}

/*---------------------------------------------------------------------------
	Install* actions - handle starting and stopping transactions, and
	running scripts.
---------------------------------------------------------------------------*/

iesEnum InstallFinalize(IMsiEngine& riEngine)
{
	// if any temp files need to be cleaned up, send that opcode along
	iesEnum iesRet = riEngine.CleanupTempFilesViaOpcode();
	if (iesSuccess != iesRet)
		return iesRet;

	iesRet = riEngine.RunScript(false);
	if(iesRet == iesSuccess || iesRet == iesNoAction)
		AssertNonZero(riEngine.EndTransaction(iesRet) == iesSuccess); // rollback cleanup shouldn't fail
	// else we do it in Sequence
	return iesRet;
}

iesEnum InstallInitialize(IMsiEngine& riEngine)
{
	//  Adding the temporary BinaryType column into Component table
	//  NOTE: a better spot for this is the InstallValidate action
	//        but that action can be conditionalized out and this is critical work
	
	PMsiRecord pErrRec(0);
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiTable pTable(0);
	pErrRec = pDatabase->LoadTable(*MsiString(*sztblComponent), 1, *&pTable);
	if ( pErrRec )
	{
		Assert(0);
		return iesFailure;
	}
	pTable->CreateColumn(icdShort+icdTemporary, *MsiString(*sztblComponent_colBinaryType));
	int iColAttributes = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colAttributes));
	int iColBinaryType = pTable->GetColumnIndex(pDatabase->EncodeStringSz(sztblComponent_colBinaryType));
	PMsiCursor pCursor(pTable->CreateCursor(fFalse));
	pCursor->SetFilter(0);
	while ( pCursor->Next() )
	{
		int iAttrib = pCursor->GetInteger(iColAttributes);
		Assert(iAttrib != iMsiNullInteger);
		ibtBinaryType iType = (iAttrib & msidbComponentAttributes64bit) == msidbComponentAttributes64bit ? ibt64bit : ibt32bit;
		Debug(const ICHAR* pszDebug = (const ICHAR*)MsiString(pCursor->GetString(pTable->GetColumnIndex(pDatabase->EncodeStringSz(TEXT("Component")))));)
		AssertNonZero(pCursor->PutInteger(iColBinaryType, (int)iType));
		AssertNonZero(pCursor->Update());
	}
	
	// check if the product is being completely uninstalled, and if so whether that operation is safe
	if (!riEngine.FSafeForFullUninstall(iremThis))
	{
		pErrRec = PostError(Imsg(imsgUserUninstallDisallowed));
		return riEngine.FatalError(*pErrRec);
	}

	return riEngine.BeginTransaction();
}

iesEnum InstallExecute(IMsiEngine& riEngine)
{
	return riEngine.RunScript(true);
}

iesEnum InstallExecuteAgain(IMsiEngine& riEngine)
{
	return riEngine.RunScript(true);
}

iesEnum DisableRollback(IMsiEngine& riEngine)
{
	PMsiSelectionManager pSelectionManager(riEngine,IID_IMsiSelectionManager);
	pSelectionManager->EnableRollback(fFalse);

	return iesSuccess;
}

const ICHAR sqlRegisterClassInfo30[]             = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, null, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlRegisterClassInfoFirstAdvt30[]    = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, null, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3 OR `Feature`.`Action` = `Feature`.`Installed`) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlUnregisterClassInfo30[]           = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, null, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND (`Feature`.`Action` = 0 OR (`Feature`.`Action` = 4 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlRegisterClassInfoGPT30[]          = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, null, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags` FROM `Class`, `Component`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Feature`.`Action` = 4");

const ICHAR sqlRegisterClassInfo[]             = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, `Class`.`Attributes`, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlRegisterClassInfoFirstAdvt[]    = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, `Class`.`Attributes`, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3 OR `Feature`.`Action` = `Feature`.`Installed`) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlUnregisterClassInfo[]           = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, `Class`.`Attributes`, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Class`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND (`Feature`.`Action` = 0 OR (`Feature`.`Action` = 4 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlRegisterClassInfoGPT[]          = TEXT("SELECT `BinaryType`, `CLSID`, `ProgId_Default`, `Class`.`Description`, `Context`, `Feature_`, `ComponentId`, `Component`, `Class`.`Attributes`, `AppId_`, `FileTypeMask`, `Icon_`, `IconIndex`, `DefInprocHandler`, `Argument`, `Component`.`RuntimeFlags` FROM `Class`, `Component`, `Feature` WHERE `Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND `Feature`.`Action` = 4");

// Keyed off the foreign key from the Register/UnregisterClassInfo.   Same query for both register and unregister,
// choosing to do it is based on the Class conditions.
const ICHAR sqlAppIdInfo[]       = TEXT("SELECT `RemoteServerName`, `LocalService`, `ServiceParameters`, `DllSurrogate`, `ActivateAtStorage`, `RunAsInteractiveUser` FROM AppId WHERE AppId = ?");

const ICHAR sqlClassInfoVIProgId[]    = TEXT("SELECT `ProgId` FROM `ProgId` WHERE `ProgId_Parent` = ?");

iesEnum ProcessClassInfo(IMsiEngine& riEngine, int fRemove)
{
	enum cliClassInfo{
		cliBinaryType = 1,
		cliCLSID, 
		cliProgId,
		cliDescription, 
		cliContext,
		cliFeature,
		cliComponentId,
		cliComponent,
		cliInsertable,
		cliAttributes = cliInsertable,
		cliAppId,
		cliFileTypeMask,
		cliIconName,
		cliIconIndex,
		cliDefInprocHandler,
		cliArgument,
		cliComponentRuntimeFlags,
		cliFileName,
		cliDirectory,
		cliComponentAction,
		cliComponentInstalled,
		cliFeatureAction,
	};

	enum caiAppIdInfo{
		caiRemoteServerName = 1,
		caiLocalService,
		caiServiceParameters,
		caiDllSurrogate,
		caiActivateAtStorage,
		caiRunAsInteractiveUser,
	};

	using namespace IxoRegClassInfoRegister;

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiView piView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;
	int fMode = riEngine.GetMode();

	bool fADVTFlag = false;
	if(!fRemove && !(fMode & iefAdvertise))
	{
		MsiString strProductCode = riEngine.GetProductKey();
		CTempBuffer<ICHAR, 15> rgchADVTFlags;
		Bool fProductHasBeenPublished = ProductHasBeenPublished(*piServices, strProductCode);
		if(fProductHasBeenPublished && GetProductInfo(strProductCode,INSTALLPROPERTY_ADVTFLAGS,rgchADVTFlags))
		{
			int iADVTFlagsExisting = MsiString(*(ICHAR* )rgchADVTFlags);

			//!! backward compatibility 
			if(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_APPINFO_OLD)
				iADVTFlagsExisting = (iADVTFlagsExisting & ~SCRIPTFLAGS_REGDATA_APPINFO_OLD) | SCRIPTFLAGS_REGDATA_APPINFO;

			fADVTFlag = (iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_CLASSINFO) ? false : true;
		}
	}

	const ICHAR* szQuery = (fMode & iefAdvertise) ? sqlRegisterClassInfoGPT   : (fRemove == fFalse) ? (fADVTFlag ? sqlRegisterClassInfoFirstAdvt   : sqlRegisterClassInfo  ) : sqlUnregisterClassInfo;

	if((pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)))
	{
		// If any tables are missing, not an error - just nothing to do
		if (pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		else // possibly old database version without Attributes column
		{
			// compatibility with 0.30, 1.0, 1.01 databases
			szQuery = (fMode & iefAdvertise) ? sqlRegisterClassInfoGPT30 : (fRemove == fFalse) ? (fADVTFlag ? sqlRegisterClassInfoFirstAdvt30 : sqlRegisterClassInfo30) : sqlUnregisterClassInfo30;
			pError = riEngine.OpenView(szQuery, ivcFetch, *&piView);  // try again with old query
		}
	}
	if (pError != 0 || (pError = piView->Execute(0)))
		return riEngine.FatalError(*pError);
	
	PMsiView pView1(0);
	PMsiView piViewAppId(0);

	while(piRec = piView->Fetch())
	{
		Assert(piRec->GetInteger(cliComponentRuntimeFlags) != iMsiNullInteger);
		if(!fRemove && (piRec->GetInteger(cliComponentRuntimeFlags) & bfComponentDisabled))
			continue; // skip publishing for disabled "primary" components

		// skip the entry if component is a Win32 assembly AND SXS support is present on the machine
		// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
		// Win32 assemblies, hence there is no need to separately check the SXS support here
		iatAssemblyType iatAssemblyType;
		MsiString strAssemblyName;
		if((pError = riEngine.GetAssemblyInfo(*MsiString(piRec->GetMsiString(cliComponent)), iatAssemblyType, &strAssemblyName, 0)) != 0)
			return riEngine.FatalError(*pError);

		if(iatWin32Assembly == iatAssemblyType || iatWin32AssemblyPvt == iatAssemblyType)
		{
			DEBUGMSG1(TEXT("skipping class registration for component %s as it is a Win32 assembly."), piRec->GetString(cliComponent));
			continue;// skip processing this component
		}

		PMsiRecord pClassInfoRec = &piServices->CreateRecord(Args);
		PMsiRecord pAppIdInfoRec(0);

		MsiString strCLSID(piRec->GetMsiString(cliCLSID));
		pClassInfoRec->SetMsiString(ClsId, *strCLSID);
		if(!piRec->IsNull(cliProgId))
		{
			pClassInfoRec->SetMsiString(ProgId, *MsiString(piRec->GetMsiString(cliProgId)));

			// get the version independant progid, if any
			PMsiRecord pRecProgId = &piServices->CreateRecord(1);
			pRecProgId->SetMsiString(1, *MsiString(piRec->GetMsiString(cliProgId)));
			if (pView1 == 0)
			{
				if (pError = riEngine.OpenView(sqlClassInfoVIProgId, ivcFetch, *&pView1))
					return riEngine.FatalError(*pError);
			}
			
			if (pError = pView1->Execute(pRecProgId))
			{
				// did not find anything
				return riEngine.FatalError(*pError);
			}
			if(pRecProgId = pView1->Fetch())
			{
				// we have a VIProgId
				pClassInfoRec->SetMsiString(VIProgId, *MsiString(pRecProgId->GetMsiString(1)));
			}
		}

		pClassInfoRec->SetMsiString(Description, *MsiString(piRec->GetMsiString(cliDescription)));
		pClassInfoRec->SetMsiString(Context, *MsiString(piRec->GetMsiString(cliContext)));
		if(((fMode & iefAdvertise) || !fRemove || piRec->GetInteger(cliFeatureAction) != iisAdvertise))
		{
			MsiString strFeature = piRec->GetMsiString(cliFeature);
			MsiString strComponentId = piRec->GetMsiString(cliComponentId);
			MsiString strComponentWithOptFlags = GetComponentWithDarwinDescriptorOptimizationFlag(riEngine, *strFeature, *strComponentId);
			pClassInfoRec->SetMsiString(Feature, *strFeature);
			pClassInfoRec->SetMsiString(Component, *strComponentWithOptFlags);
		}
		int iAttributes = piRec->GetInteger(cliAttributes);  // was cliInsertable in versions <= 28
		iisEnum iisState = (iisEnum)piRec->GetInteger(cliComponentAction);
 
		// AppId 
		MsiString strAppId(piRec->GetMsiString(cliAppId));

		// We'll always let the Class info write the AppId info as well.  This gives us the CLSID\AppId link.
		pClassInfoRec->SetMsiString(AppID, *strAppId);

		{
			using namespace IxoRegAppIdInfoRegister;

			if (!(fMode & iefAdvertise) && (iisState != iMsiNullInteger) && strAppId.TextSize()) // don't advertise AppId info
			{
				PMsiRecord piAppIdFetch(0);

				if (piViewAppId == 0)
				{
					if((pError = riEngine.OpenView(sqlAppIdInfo, ivcFetch, *&piViewAppId)))
					{					
						// Ignore missing table error; continue with the rest of the class processing below
						if (pError->GetInteger(1) != idbgDbQueryUnknownTable)
							return riEngine.FatalError(*pError);
					}
				}
					
				if (piViewAppId != 0)
				{
					pAppIdInfoRec = &piServices->CreateRecord(IxoRegAppIdInfoRegister::Args);
					pAppIdInfoRec->SetMsiString(1, *strAppId);
										
					if((pError = piViewAppId->Execute(pAppIdInfoRec)))
						return riEngine.FatalError(*pError);

					piAppIdFetch = piViewAppId->Fetch();
					if (piAppIdFetch)
					{
						// fill in the record.

						//!! format text, check types, REG_MULTI_SZ...
						//YACC???
						pAppIdInfoRec->SetMsiString(AppId, *strAppId);
						pAppIdInfoRec->SetMsiString(IxoRegAppIdInfoRegister::ClsId, *strCLSID);
						pAppIdInfoRec->SetMsiString(RemoteServerName, *MsiString(riEngine.FormatText(*MsiString(piAppIdFetch->GetMsiString(caiRemoteServerName)))));
						pAppIdInfoRec->SetMsiString(LocalService, *MsiString(riEngine.FormatText(*MsiString(piAppIdFetch->GetMsiString(caiLocalService)))));
						pAppIdInfoRec->SetMsiString(ServiceParameters, *MsiString(riEngine.FormatText(*MsiString(piAppIdFetch->GetMsiString(caiServiceParameters)))));
						pAppIdInfoRec->SetMsiString(DllSurrogate, *MsiString(riEngine.FormatText(*MsiString(piAppIdFetch->GetMsiString(caiDllSurrogate)))));
						pAppIdInfoRec->SetInteger(ActivateAtStorage, piAppIdFetch->GetInteger(caiActivateAtStorage));
						pAppIdInfoRec->SetInteger(RunAsInteractiveUser, piAppIdFetch->GetInteger(caiRunAsInteractiveUser));
					}
				}
			}
		}

		pClassInfoRec->SetMsiString(FileTypeMask, *MsiString(piRec->GetMsiString(cliFileTypeMask)));
		if(!piRec->IsNull(cliIconName))
			pClassInfoRec->SetMsiString(Icon, *MsiString(piRec->GetMsiString(cliIconName)));
		if(!piRec->IsNull(cliIconIndex))
			pClassInfoRec->SetInteger(IconIndex, piRec->GetInteger(cliIconIndex));
		pClassInfoRec->SetMsiString(DefInprocHandler, *MsiString(piRec->GetMsiString(cliDefInprocHandler)));
		//YACC???
		pClassInfoRec->SetMsiString(Argument, *MsiString(riEngine.FormatText(*MsiString(piRec->GetMsiString(cliArgument)))));
		
		if(!(fMode & iefAdvertise))
		{
			if(fADVTFlag && iisState == iMsiNullInteger)
			{
				iisEnum iisStateInstalled = (iisEnum)piRec->GetInteger(cliComponentInstalled);
				if(iisStateInstalled == iisAbsent)
					iisStateInstalled = (iisEnum)iMsiNullInteger;
				iisState = iisStateInstalled;
			}

			if(iisState != iMsiNullInteger)
			{
				MsiString strFileName, strFullPath;
				PMsiPath piPath(0);
				Bool fLFN;
				if(iisState == iisAbsent || iisState == iisFileAbsent || iisState == iisHKCRFileAbsent || iisState == iisHKCRAbsent)
					strFullPath = *szNonEmptyPath; // token string to cause removal of the filename registration
				else 
				{
					// use key file
					if(iAttributes & msidbClassAttributesRelativePath)
						fLFN = (fMode & iefSuppressLFN) == 0 ? fTrue : fFalse;  // assume LFN support on PATH
					else if(iisState == iisSource)
					{
						if(pError = piDirectoryMgr->GetSourcePath(*MsiString(piRec->GetMsiString(cliDirectory)), *&piPath))
						{
							if (pError->GetInteger(1) == imsgUser)
								return iesUserExit;
							else
								return riEngine.FatalError(*pError);
						}
						fLFN = (fMode & iefNoSourceLFN) == 0 && piPath->SupportsLFN() ? fTrue : fFalse;
					}
					else 
					{
						Assert(iisState == iisLocal);
						if(pError = piDirectoryMgr->GetTargetPath(*MsiString(piRec->GetString(cliDirectory)), *&piPath))
						{
							return riEngine.FatalError(*pError);
						}
						fLFN = (fMode & iefSuppressLFN) == 0 && piPath->SupportsLFN() ? fTrue : fFalse;
					}
					if(pError = piServices->ExtractFileName(piRec->GetString(cliFileName),fLFN,*&strFileName))
						return riEngine.FatalError(*pError);
					if (!piPath)  // relative path requested
						strFullPath = strFileName;
					else if(pError = piPath->GetFullFilePath(strFileName, *&strFullPath))
					{
						return riEngine.FatalError(*pError);
					}
				}
				pClassInfoRec->SetMsiString(FileName, *strFullPath);
			}
		}

		if(iatAssemblyType == iatURTAssembly || iatAssemblyType == iatURTAssemblyPvt)
		{
			// COM classic <-> COM+ interop : register assembly name, codebase
			pClassInfoRec->SetMsiString(AssemblyName, *strAssemblyName);
			pClassInfoRec->SetInteger(AssemblyType, iatAssemblyType);

		}

		if ( (ibtBinaryType)piRec->GetInteger(cliBinaryType) == ibt64bit )
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegClassInfoRegister64 : ixoRegClassInfoUnregister64, *pClassInfoRec);
		else
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegClassInfoRegister : ixoRegClassInfoUnregister, *pClassInfoRec);
		if (iesRet != iesSuccess)
			return iesRet;

		if (pAppIdInfoRec)
		{
			if ( (ibtBinaryType)piRec->GetInteger(cliBinaryType) == ibt64bit )
				iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegAppIdInfoRegister64 : ixoRegAppIdInfoUnregister64, *pAppIdInfoRec);
			else
				iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegAppIdInfoRegister : ixoRegAppIdInfoUnregister, *pAppIdInfoRec);
			if (iesRet != iesSuccess)
				return iesRet;
		}

	}
	return iesSuccess;
}


const ICHAR sqlRegisterProgIdInfo[] =    TEXT("SELECT DISTINCT `BinaryType`, `ProgId`, `Class_`, `ProgId`.`Description`, `ProgId`.`Icon_`, `ProgId`.`IconIndex`, null, `Component`.`RuntimeFlags`, `Component`.`Component` FROM `ProgId`, `Class`, `Feature`, `Component` WHERE `ProgId`.`Class_` = `Class`.`CLSID` AND `Class`.`Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlRegisterProgIdInfoFirstAdvt[] =    TEXT("SELECT DISTINCT `BinaryType`, `ProgId`, `Class_`, `ProgId`.`Description`, `ProgId`.`Icon_`, `ProgId`.`IconIndex`, null, `Component`.`RuntimeFlags` , `Component`.`Component` FROM `ProgId`, `Class`, `Feature`, `Component` WHERE `ProgId`.`Class_` = `Class`.`CLSID` AND `Class`.`Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3 OR `Feature`.`Action` = `Feature`.`Installed`) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlUnregisterProgIdInfo[] =  TEXT("SELECT DISTINCT `BinaryType`, `ProgId`, `Class_`, `ProgId`.`Description`, `ProgId`.`Icon_`, `ProgId`.`IconIndex`, null, `Component`.`RuntimeFlags` , `Component`.`Component` FROM `ProgId`, `Class`, `Feature`, `Component` WHERE `ProgId`.`Class_` = `Class`.`CLSID` AND `Class`.`Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND (`Feature`.`Action` = 0 OR (`Feature`.`Action` = 4 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlRegisterProgIdInfoGPT[] = TEXT("SELECT DISTINCT `BinaryType`, `ProgId`, `Class_`, `ProgId`.`Description`, `ProgId`.`Icon_`, `ProgId`.`IconIndex`, null, `Component`.`RuntimeFlags` , `Component`.`Component` FROM `ProgId`, `Class`, `Feature`, `Component` WHERE `ProgId`.`Class_` = `Class`.`CLSID` AND `Class`.`Feature_` = `Feature` AND `Class`.`Component_` = `Component` AND (`Feature`.`Action` = 4)");

const ICHAR sqlProgIdInfoVIProgId[] =    TEXT("SELECT `ProgId`, `Description` FROM `ProgId` WHERE `ProgId_Parent` = ?");
const ICHAR sqlProgIdInfoExtension[] =   TEXT("SELECT `Extension`.`Extension` FROM `Extension` WHERE `Extension`.`ProgId_` = ?");
iesEnum ProcessProgIdInfo(IMsiEngine& riEngine, int fRemove)
{
	enum piiProgIdInfo{
		piiBinaryType = 1,
		piiProgId,
		piiCLSID, 
		piiDescription,
		piiIcon,
		piiIconIndex,
		piiInsertable,
		piiComponentRuntimeFlags,
		piiComponent,
	};

	using namespace IxoRegProgIdInfoRegister;

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiView piView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;
	int fMode = riEngine.GetMode();

	bool fADVTFlag = false;
	if(!fRemove && !(fMode & iefAdvertise))
	{
		MsiString strProductCode = riEngine.GetProductKey();
		CTempBuffer<ICHAR, 15> rgchADVTFlags;
		Bool fProductHasBeenPublished = ProductHasBeenPublished(*piServices, strProductCode);
		if(fProductHasBeenPublished && GetProductInfo(strProductCode,INSTALLPROPERTY_ADVTFLAGS,rgchADVTFlags))
		{
			int iADVTFlagsExisting = MsiString(*(ICHAR* )rgchADVTFlags);

			//!! backward compatibility 
			if(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_APPINFO_OLD)
				iADVTFlagsExisting = (iADVTFlagsExisting & ~SCRIPTFLAGS_REGDATA_APPINFO_OLD) | SCRIPTFLAGS_REGDATA_APPINFO;

			fADVTFlag = ((iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_CLASSINFO) && (iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_EXTENSIONINFO))? false : true;
		}
	}

	const ICHAR* szQuery;
	szQuery = (fMode & iefAdvertise) ? sqlRegisterProgIdInfoGPT   : (fRemove == fFalse) ? (fADVTFlag ? sqlRegisterProgIdInfoFirstAdvt   : sqlRegisterProgIdInfo  ) : sqlUnregisterProgIdInfo  ;


	if(	(pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) ||
		(pError = piView->Execute(0)))
	{
		if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pError);
		else
			return iesNoAction;
	}
	
	PMsiView pView1(0);
	PMsiView pViewExt(0);
	
	while(piRec = piView->Fetch())
	{

		Assert(piRec->GetInteger(piiComponentRuntimeFlags) != iMsiNullInteger);
		if(!fRemove && (piRec->GetInteger(piiComponentRuntimeFlags) & bfComponentDisabled))
			continue; // skip publishing for disabled "primary" components

		// skip the entry if component is a Win32 assembly AND SXS support is present on the machine
		// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
		// Win32 assemblies, hence there is no need to separately check the SXS support here
		iatAssemblyType iatAssemblyType;
		if((pError = riEngine.GetAssemblyInfo(*MsiString(piRec->GetMsiString(piiComponent)), iatAssemblyType, 0, 0)) != 0)
			return riEngine.FatalError(*pError);

		if(iatWin32Assembly == iatAssemblyType || iatWin32AssemblyPvt == iatAssemblyType)
		{
			DEBUGMSG1(TEXT("skipping progid registration for component %s as it is a Win32 assembly."), piRec->GetString(piiComponent));
			continue;// skip processing this component
		}


		PMsiRecord pProgIdInfoRec = &piServices->CreateRecord(Args);

		pProgIdInfoRec->SetMsiString(ProgId, *MsiString(piRec->GetMsiString(piiProgId)));
		if(!piRec->IsNull(piiCLSID))
			pProgIdInfoRec->SetMsiString(ClsId, *MsiString(piRec->GetMsiString(piiCLSID)));
		pProgIdInfoRec->SetMsiString(Description, *MsiString(piRec->GetMsiString(piiDescription)));
		if(!piRec->IsNull(piiIcon))
			pProgIdInfoRec->SetMsiString(Icon, *MsiString(piRec->GetMsiString(piiIcon)));
		if(!piRec->IsNull(piiIconIndex))
			pProgIdInfoRec->SetInteger(IconIndex, piRec->GetInteger(piiIconIndex));
		int iInsertable = piRec->GetInteger(piiInsertable);
		if(iInsertable != iMsiNullInteger)
			pProgIdInfoRec->SetInteger(Insertable, iInsertable);

		// get the version independant progid, if any
		PMsiRecord pRecProgId = &piServices->CreateRecord(1);
		pRecProgId->SetMsiString(1, *MsiString(piRec->GetMsiString(piiProgId)));
		if (pView1 == 0)
		{
			if (pError = riEngine.OpenView(sqlProgIdInfoVIProgId, ivcFetch, *&pView1))
				return riEngine.FatalError(*pError);
		}
				
		if(pError = pView1->Execute(pRecProgId))
		{
			return riEngine.FatalError(*pError);
		}
		if(pRecProgId = pView1->Fetch())
		{
			// we have a VIProgId
			pProgIdInfoRec->SetMsiString(VIProgId, *MsiString(pRecProgId->GetMsiString(1)));
			pProgIdInfoRec->SetMsiString(VIProgIdDescription, *MsiString(pRecProgId->GetMsiString(2)));
		}

		// get the extension association, if any
		pRecProgId = &piServices->CreateRecord(1);
		pRecProgId->SetMsiString(1, *MsiString(piRec->GetMsiString(piiProgId)));

		if (pViewExt == 0)
		{
			if (pError = riEngine.OpenView(sqlProgIdInfoExtension, ivcFetch, *&pViewExt))
				return riEngine.FatalError(*pError);
		}
			
		if(pError = pViewExt->Execute(pRecProgId))
		{
			return riEngine.FatalError(*pError);
		}
		if(pRecProgId = pViewExt->Fetch())
		{
			// we have a Extension
			pProgIdInfoRec->SetMsiString(Extension, *MsiString(pRecProgId->GetMsiString(1)));
		}

		if ( (ibtBinaryType)piRec->GetInteger(piiBinaryType) == ibt64bit )
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegProgIdInfoRegister64 : ixoRegProgIdInfoUnregister64, *pProgIdInfoRec);
		else
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegProgIdInfoRegister : ixoRegProgIdInfoUnregister, *pProgIdInfoRec);
		if (iesRet != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}


const ICHAR sqlRegisterProgIdInfoExt[] =    TEXT("SELECT `BinaryType`, `ProgId`, `Class_`, `Extension`.`Extension`, `ProgId`.`Description`, `Icon_`, `IconIndex`, null, `Component`.`RuntimeFlags`, `Component`.`Component`  FROM `ProgId`, `Extension`, `Feature`, `Component` WHERE `ProgId`.`Class_` = null AND `ProgId`.`ProgId` = `Extension`.`ProgId_` AND `Extension`.`Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlRegisterProgIdInfoExtFirstAdvt[] =    TEXT("SELECT `BinaryType`, `ProgId`, `Class_`, `Extension`.`Extension`, `ProgId`.`Description`, `Icon_`, `IconIndex`, null, `Component`.`RuntimeFlags`, `Component`.`Component`  FROM `ProgId`, `Extension`, `Feature`, `Component` WHERE `ProgId`.`Class_` = null AND `ProgId`.`ProgId` = `Extension`.`ProgId_` AND `Extension`.`Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3 OR `Feature`.`Action` = `Feature`.`Installed`) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlUnregisterProgIdInfoExt[] =  TEXT("SELECT `BinaryType`, `ProgId`, `Class_`, `Extension`.`Extension`, `ProgId`.`Description`, `Icon_`, `IconIndex`, null, `Component`.`RuntimeFlags`, `Component`.`Component`  FROM `ProgId`, `Extension`, `Feature`, `Component` WHERE `ProgId`.`Class_` = null AND `ProgId`.`ProgId` = `Extension`.`ProgId_` AND `Extension`.`Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND (`Feature`.`Action` = 0 OR  (`Feature`.`Action` = 4 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlRegisterProgIdInfoExtGPT[] = TEXT("SELECT `BinaryType`, `ProgId`, `Class_`, `Extension`.`Extension`, `ProgId`.`Description`, `Icon_`, `IconIndex`, null, `Component`.`RuntimeFlags`, `Component`.`Component`  FROM `ProgId`, `Extension`, `Feature`, `Component` WHERE `ProgId`.`Class_` = null AND `ProgId`.`ProgId` = `Extension`.`ProgId_` AND `Extension`.`Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND (`Feature`.`Action` = 4)");
const ICHAR sqlProgIdInfoExtVIProgId[] = TEXT("SELECT `ProgId`, `Description` FROM `ProgId` WHERE `ProgId_Parent` = ?");
iesEnum ProcessProgIdInfoExt(IMsiEngine& riEngine, int fRemove)
{
	enum piiProgIdInfo{
		piiBinaryType = 1,
		piiProgId,
		piiCLSID, 
		piiExtension,
		piiDescription,
		piiIcon,
		piiIconIndex,
		piiInsertable,
		piiComponentRuntimeFlags,
		piiComponent
	};

	using namespace IxoRegProgIdInfoRegister;

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiView piView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;
	int fMode = riEngine.GetMode();

	bool fADVTFlag = false;
	if(!fRemove && !(fMode & iefAdvertise))
	{
		MsiString strProductCode = riEngine.GetProductKey();
		CTempBuffer<ICHAR, 15> rgchADVTFlags;
		Bool fProductHasBeenPublished = ProductHasBeenPublished(*piServices, strProductCode);
		if(fProductHasBeenPublished && GetProductInfo(strProductCode,INSTALLPROPERTY_ADVTFLAGS,rgchADVTFlags))
		{
			int iADVTFlagsExisting = MsiString(*(ICHAR* )rgchADVTFlags);

			//!! backward compatibility 
			if(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_APPINFO_OLD)
				iADVTFlagsExisting = (iADVTFlagsExisting & ~SCRIPTFLAGS_REGDATA_APPINFO_OLD) | SCRIPTFLAGS_REGDATA_APPINFO;

			fADVTFlag = ((iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_CLASSINFO) && (iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_EXTENSIONINFO))? false : true;
		}
	}

	const ICHAR* szQuery = (fMode & iefAdvertise) ? sqlRegisterProgIdInfoExtGPT : (fRemove == fFalse) ? (fADVTFlag ? sqlRegisterProgIdInfoExtFirstAdvt : sqlRegisterProgIdInfoExt) : sqlUnregisterProgIdInfoExt;
	if(	(pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) ||
		(pError = piView->Execute(0)))
	{
		if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pError);
		else
			return iesNoAction;
	}
	PMsiView pView1(0);
	while(piRec = piView->Fetch())
	{

		Assert(piRec->GetInteger(piiComponentRuntimeFlags) != iMsiNullInteger);
		if(!fRemove && (piRec->GetInteger(piiComponentRuntimeFlags) & bfComponentDisabled))
			continue; // skip publishing for disabled "primary" components

		// skip the entry if component is a Win32 assembly AND SXS support is present on the machine
		// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
		// Win32 assemblies, hence there is no need to separately check the SXS support here
		iatAssemblyType iatAssemblyType;
		if((pError = riEngine.GetAssemblyInfo(*MsiString(piRec->GetMsiString(piiComponent)), iatAssemblyType, 0, 0)) != 0)
			return riEngine.FatalError(*pError);

		if(iatWin32Assembly == iatAssemblyType || iatWin32AssemblyPvt == iatAssemblyType)
		{
			DEBUGMSG1(TEXT("skipping progid registration for component %s as it is a Win32 assembly."), piRec->GetString(piiComponent));
			continue;// skip processing this component
		}

		PMsiRecord pProgIdInfoRec = &piServices->CreateRecord(Args);

		pProgIdInfoRec->SetMsiString(ProgId, *MsiString(piRec->GetMsiString(piiProgId)));
		if(!piRec->IsNull(piiCLSID))
			pProgIdInfoRec->SetMsiString(ClsId, *MsiString(piRec->GetMsiString(piiCLSID)));
		if(!piRec->IsNull(piiExtension))
			pProgIdInfoRec->SetMsiString(Extension, *MsiString(piRec->GetMsiString(piiExtension)));
		pProgIdInfoRec->SetMsiString(Description, *MsiString(piRec->GetMsiString(piiDescription)));
		if(!piRec->IsNull(piiIcon))
			pProgIdInfoRec->SetMsiString(Icon, *MsiString(piRec->GetMsiString(piiIcon)));
		if(!piRec->IsNull(piiIconIndex))
			pProgIdInfoRec->SetInteger(IconIndex, piRec->GetInteger(piiIconIndex));
		if(!piRec->IsNull(piiInsertable))
			pProgIdInfoRec->SetMsiString(Insertable, *MsiString(piRec->GetMsiString(piiInsertable)));

		// get the version independant progid, if any
		PMsiRecord pRecProgId = &piServices->CreateRecord(1);
		pRecProgId->SetMsiString(1, *MsiString(piRec->GetMsiString(piiProgId)));

		if (pView1 == 0)
		{
			if (pError = riEngine.OpenView(sqlProgIdInfoExtVIProgId, ivcFetch, *&pView1))
				return riEngine.FatalError(*pError);
		}
				
		if (pError = pView1->Execute(pRecProgId))
		{
			return riEngine.FatalError(*pError);
		}
		if(pRecProgId = pView1->Fetch())
		{
			// we have a VIProgId
			pProgIdInfoRec->SetMsiString(VIProgId, *MsiString(pRecProgId->GetMsiString(1)));
			pProgIdInfoRec->SetMsiString(VIProgIdDescription, *MsiString(pRecProgId->GetMsiString(2)));
		}

		if ( (ibtBinaryType)piRec->GetInteger(piiBinaryType) == ibt64bit )
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegProgIdInfoRegister64 : ixoRegProgIdInfoUnregister64, *pProgIdInfoRec);
		else
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegProgIdInfoRegister : ixoRegProgIdInfoUnregister, *pProgIdInfoRec);
		if (iesRet != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}

const ICHAR sqlRegisterTypeLibraryInfo[] =    TEXT("SELECT `LibID`, `TypeLib`.`Version`, `TypeLib`.`Language`, `TypeLib`.`Directory_`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `BinaryType`, `Component`.`Component` FROM `TypeLib`, `Component`, `File` WHERE `TypeLib`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND (`Component`.`Action`=1 OR `Component`.`Action`=2)");
const ICHAR sqlUnregisterTypeLibraryInfo[] =  TEXT("SELECT `LibID`, `TypeLib`.`Version`, `TypeLib`.`Language`, `TypeLib`.`Directory_`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `BinaryType`, `Component`.`Component` FROM `TypeLib`, `Component`, `File` WHERE `TypeLib`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND (`Component`.`Action`=0)");
iesEnum ProcessTypeLibraryInfo(IMsiEngine& riEngine, int fRemove)
{
	enum tliTypeLibInfo{
		tliLibID = 1,
		tliVersion,
		tliLanguage,
		tliHelpDirectory,
		tliFileName,
		tliDirectory,
		tliComponentAction,
		tliComponentInstalled,
		tliBinaryType,
		tliComponent,
	};

	using namespace IxoTypeLibraryRegister;

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiView piView(0);
	PMsiView piEnumExtView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;

	int fMode = riEngine.GetMode();

	if(fMode & iefAdvertise)
		return iesNoAction;// we dont do advertisement of type libraries any more

	const ICHAR* szQuery = (fRemove == fFalse) ? sqlRegisterTypeLibraryInfo : sqlUnregisterTypeLibraryInfo;
	if((pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) != 0)
	{
		if(pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction; // no typelib table so no typelibs to register
		else
			return riEngine.FatalError(*pError);
	}
	if((pError= piView->Execute(0)) != 0)
	{
		return riEngine.FatalError(*pError);
	}
	while(piRec = piView->Fetch())
	{
		// skip the entry if component is a Win32 assembly AND SXS support is present on the machine
		// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
		// Win32 assemblies, hence there is no need to separately check the SXS support here
		iatAssemblyType iatAssemblyType;
		if((pError = riEngine.GetAssemblyInfo(*MsiString(piRec->GetMsiString(tliComponent)), iatAssemblyType, 0, 0)) != 0)
			return riEngine.FatalError(*pError);

		if(iatWin32Assembly == iatAssemblyType || iatWin32AssemblyPvt == iatAssemblyType)
		{
			DEBUGMSG1(TEXT("skipping type library registration for component %s as it is a Win32 assembly."), piRec->GetString(tliComponent));
			continue;// skip processing this component
		}

		PMsiRecord pTypeLibRec = &piServices->CreateRecord(Args);

		pTypeLibRec->SetMsiString(LibID, *MsiString(piRec->GetMsiString(tliLibID)));
		pTypeLibRec->SetInteger(Version, piRec->GetInteger(tliVersion));
		pTypeLibRec->SetInteger(Language, piRec->GetInteger(tliLanguage));
		if(!piRec->IsNull(tliHelpDirectory))
		{
			PMsiPath piHelpPath(0);
			PMsiRecord pError = piDirectoryMgr->GetTargetPath(*MsiString(piRec->GetMsiString(tliHelpDirectory)),*&piHelpPath);
			if(pError)
				return riEngine.FatalError(*pError);
			AssertNonZero(pTypeLibRec->SetMsiString(HelpPath, *MsiString(piHelpPath->GetPath())));
		}

		// use key file
		PMsiPath piPath(0);
		int iefLFN;
		iisEnum iisState = (iisEnum)piRec->GetInteger(tliComponentAction);
		if(iisState == iisAbsent)
			iisState = (iisEnum)piRec->GetInteger(tliComponentInstalled);
		if(iisState == iisSource)
		{
			if(pError = piDirectoryMgr->GetSourcePath(*MsiString(piRec->GetMsiString(tliDirectory)), *&piPath))
			{
				if (pError->GetInteger(1) == imsgUser)
					return iesUserExit;
				else
					return riEngine.FatalError(*pError);
			}
			iefLFN = iefNoSourceLFN;
		}
		else
		{
			if(pError = piDirectoryMgr->GetTargetPath(*MsiString(piRec->GetString(tliDirectory)), *&piPath))
			{
				return riEngine.FatalError(*pError);
			}
			iefLFN = iefSuppressLFN;
		}
		MsiString strFileName, strFullPath;
		Bool fLFN = (fMode & iefLFN) == 0 && piPath->SupportsLFN() ? fTrue : fFalse;
		if(pError = piServices->ExtractFileName(piRec->GetString(tliFileName),fLFN,*&strFileName))
			return riEngine.FatalError(*pError);
		if(pError = piPath->GetFullFilePath(strFileName, *&strFullPath))
		{
			return riEngine.FatalError(*pError);
		}
		pTypeLibRec->SetMsiString(FilePath, *strFullPath);
		pTypeLibRec->SetInteger(BinaryType, piRec->GetInteger(tliBinaryType));
		if ((iesRet = riEngine.ExecuteRecord((fRemove == fFalse)?ixoTypeLibraryRegister:ixoTypeLibraryUnregister, *pTypeLibRec)) != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}


const ICHAR sqlRegisterMIMEInfoExtension[] =    TEXT("SELECT `BinaryType`, `ContentType`, `Extension`.`Extension`, `MIME`.`CLSID`, `Component`.`RuntimeFlags`, `Component`.`Component` FROM `MIME`, `Extension`, `Feature`, `Component` WHERE `MIME`.`Extension_` = `Extension`.`Extension` AND `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlRegisterMIMEInfoExtensionFirstAdvt[] =    TEXT("SELECT `BinaryType`, `ContentType`, `Extension`.`Extension`, `MIME`.`CLSID`, `Component`.`RuntimeFlags`, `Component`.`Component` FROM `MIME`, `Extension`, `Feature`, `Component` WHERE `MIME`.`Extension_` = `Extension`.`Extension` AND `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3 OR `Feature`.`Action` = `Feature`.`Installed`) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlUnregisterMIMEInfoExtension[] =  TEXT("SELECT `BinaryType`, `ContentType`, `Extension`.`Extension`, `MIME`.`CLSID`, `Component`.`RuntimeFlags`, `Component`.`Component` FROM `MIME`, `Extension`, `Feature`, `Component` WHERE `MIME`.`Extension_` = `Extension`.`Extension` AND `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND (`Feature`.`Action` = 0 OR (`Feature`.`Action` = 4 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlRegisterMIMEInfoExtensionGPT[] = TEXT("SELECT `BinaryType`, `ContentType`, `Extension`.`Extension`, `MIME`.`CLSID`, `Component`.`RuntimeFlags`, `Component`.`Component` FROM `MIME`, `Extension`, `Feature`, `Component` WHERE `MIME`.`Extension_` = `Extension`.`Extension` AND `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND `Feature`.`Action` = 4");
iesEnum ProcessMIMEInfo(IMsiEngine& riEngine, int fRemove)
{
	enum rmiMimeInfo{
		rmiBinaryType = 1,
		rmiContentType,
		rmiExtension,
		rmiCLSID,
		rmiComponentRuntimeFlags,
		rmiComponent,
	};
	using namespace IxoRegMIMEInfoRegister;

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiView piView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;
	int fMode = riEngine.GetMode();
	Bool fSuppressLFN = fMode & iefSuppressLFN ? fTrue : fFalse;

	bool fADVTFlag = false;
	if(!fRemove && !(fMode & iefAdvertise))
	{
		MsiString strProductCode = riEngine.GetProductKey();
		CTempBuffer<ICHAR, 15> rgchADVTFlags;
		Bool fProductHasBeenPublished = ProductHasBeenPublished(*piServices, strProductCode);
		if(fProductHasBeenPublished && GetProductInfo(strProductCode,INSTALLPROPERTY_ADVTFLAGS,rgchADVTFlags))
		{
			int iADVTFlagsExisting = MsiString(*(ICHAR* )rgchADVTFlags);

			//!! backward compatibility 
			if(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_APPINFO_OLD)
				iADVTFlagsExisting = (iADVTFlagsExisting & ~SCRIPTFLAGS_REGDATA_APPINFO_OLD) | SCRIPTFLAGS_REGDATA_APPINFO;

			fADVTFlag = ((iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_CLASSINFO) && (iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_EXTENSIONINFO))? false : true;
		}
	}

	const ICHAR* szQuery = (fMode & iefAdvertise) ? sqlRegisterMIMEInfoExtensionGPT : (fRemove == fFalse) ? (fADVTFlag ? sqlRegisterMIMEInfoExtensionFirstAdvt : sqlRegisterMIMEInfoExtension) : sqlUnregisterMIMEInfoExtension;
	if(	(pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) ||
		(pError = piView->Execute(0)))
	{
		if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pError);
		else
			return iesNoAction;
	}
	PMsiRecord piMIMERec = &piServices->CreateRecord(Args);
	while(piRec = piView->Fetch())
	{
		Assert(piRec->GetInteger(rmiComponentRuntimeFlags) != iMsiNullInteger);
		if(!fRemove && (piRec->GetInteger(rmiComponentRuntimeFlags) & bfComponentDisabled))
			continue; // skip publishing for disabled "primary" components

		// skip the entry if component is a Win32 assembly AND SXS support is present on the machine
		// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
		// Win32 assemblies, hence there is no need to separately check the SXS support here
		iatAssemblyType iatAssemblyType;
		if((pError = riEngine.GetAssemblyInfo(*MsiString(piRec->GetMsiString(rmiComponent)), iatAssemblyType, 0, 0)) != 0)
			return riEngine.FatalError(*pError);

		if(iatWin32Assembly == iatAssemblyType || iatWin32AssemblyPvt == iatAssemblyType)
		{
			DEBUGMSG1(TEXT("skipping MIME registration for component %s as it is a Win32 assembly."), piRec->GetString(rmiComponent));
			continue;// skip processing this component
		}

		piMIMERec->SetMsiString(ContentType, *MsiString(piRec->GetMsiString(rmiContentType)));
		piMIMERec->SetMsiString(Extension, *MsiString(piRec->GetMsiString(rmiExtension)));
		piMIMERec->SetMsiString(ClsId, *MsiString(piRec->GetMsiString(rmiCLSID)));
		if ( (ibtBinaryType)piRec->GetInteger(rmiBinaryType) == ibt64bit )
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegMIMEInfoRegister64 : ixoRegMIMEInfoUnregister64, *piMIMERec);
		else
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegMIMEInfoRegister : ixoRegMIMEInfoUnregister, *piMIMERec);
		if (iesRet != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}


const ICHAR sqlRegisterExtensionExInfo[] =  TEXT("SELECT `Verb`, `Command`, `Argument`, `Sequence` FROM `Verb` WHERE `Extension_` = ? ORDER BY `Sequence`");

const ICHAR sqlRegisterExtensionInfo[] =          TEXT("SELECT `Extension`, `BinaryType`, `ProgId_`, null, null, `MIME_`, `Feature_`, `ComponentId`, `Component`.`RuntimeFlags`, `Component`.`Component`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Extension`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlRegisterExtensionInfoFirstAdvt[] = TEXT("SELECT `Extension`, `BinaryType`, `ProgId_`, null, null, `MIME_`, `Feature_`, `ComponentId`, `Component`.`RuntimeFlags`, `Component`.`Component`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Extension`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3 OR `Feature`.`Action` = `Feature`.`Installed`) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND ((`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4))))");
const ICHAR sqlUnregisterExtensionInfo[] =        TEXT("SELECT `Extension`, `BinaryType`, `ProgId_`, null, null, `MIME_`, `Feature_`, `ComponentId`, `Component`.`RuntimeFlags`, `Component`.`Component`, `FileName`, `Component`.`Directory_`, `Component`.`Action`, `Component`.`Installed`, `Feature`.`Action` FROM `Extension`, `Component`, `File`, `Feature` WHERE `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND (`Feature`.`Action` = 0 OR (`Feature`.`Action` = 4 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlRegisterExtensionInfoGPT[] =       TEXT("SELECT `Extension`, `BinaryType`, `ProgId_`, null, null, `MIME_`, `Feature_`, `ComponentId`, `Component`.`RuntimeFlags`, `Component`.`Component` FROM `Extension`, `Component`, `Feature` WHERE `Feature_` = `Feature` AND `Extension`.`Component_` = `Component` AND `Feature`.`Action` = 4");

iesEnum ProcessExtensionInfo(IMsiEngine& riEngine, int fRemove)
{
	enum reiExtensionInfo{
		reiExtension = 1,
		reiBinaryType,
		reiProgId,
		reiShellNew,
		reiShellNewValue,
		reiMIME,
		reiFeature,
		reiComponentId,
		reiComponentRuntimeFlags,
		reiComponent,
		reiFileName,
		reiDirectory,
		reiComponentAction,
		reiComponentInstalled,
		reiFeatureAction,
	};

	enum rviVerbInfo{
		rviVerb = 1,
		rviCommand,
		rviArgument,
		rviSequence,
	};

	using namespace IxoRegExtensionInfoRegister;

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiView piView(0);
	PMsiView piEnumExtView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;
	int fMode = riEngine.GetMode();
	Bool fSuppressLFN = fMode & iefSuppressLFN ? fTrue : fFalse;

	bool fADVTFlag = false;
	if(!fRemove && !(fMode & iefAdvertise))
	{
		MsiString strProductCode = riEngine.GetProductKey();
		CTempBuffer<ICHAR, 15> rgchADVTFlags;
		Bool fProductHasBeenPublished = ProductHasBeenPublished(*piServices, strProductCode);
		if(fProductHasBeenPublished && GetProductInfo(strProductCode,INSTALLPROPERTY_ADVTFLAGS,rgchADVTFlags))
		{
			int iADVTFlagsExisting = MsiString(*(ICHAR* )rgchADVTFlags);

			//!! backward compatibility 
			if(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_APPINFO_OLD)
				iADVTFlagsExisting = (iADVTFlagsExisting & ~SCRIPTFLAGS_REGDATA_APPINFO_OLD) | SCRIPTFLAGS_REGDATA_APPINFO;

			fADVTFlag = (iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_EXTENSIONINFO)? false : true;
		}
	}

	const ICHAR* szQuery = 0;
	
	szQuery = (fMode & iefAdvertise) ? sqlRegisterExtensionInfoGPT   : (fRemove == fFalse) ? (fADVTFlag ? sqlRegisterExtensionInfoFirstAdvt   : sqlRegisterExtensionInfo)   : sqlUnregisterExtensionInfo;

	if(	(pError = riEngine.OpenView(szQuery, ivcFetch, *&piEnumExtView)) ||
		(pError= piEnumExtView->Execute(0)))
	{
		// If any tables are missing, not an error - just nothing to do
		if (pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		return riEngine.FatalError(*pError);
	}
	PMsiRecord piExtensionRec(0);
	while(piRec = piEnumExtView->Fetch())
	{
		Assert(piRec->GetInteger(reiComponentRuntimeFlags) != iMsiNullInteger);
		if(!fRemove && (piRec->GetInteger(reiComponentRuntimeFlags) & bfComponentDisabled))
			continue; // skip publishing for disabled "primary" components

		// skip the entry if component is a Win32 assembly AND SXS support is present on the machine
		// NOTE: on systems that do not support sxs (!= Whistler) the GetAssemblyInfo fn ignores 
		// Win32 assemblies, hence there is no need to separately check the SXS support here
		iatAssemblyType iatAssemblyType;
		if((pError = riEngine.GetAssemblyInfo(*MsiString(piRec->GetMsiString(reiComponent)), iatAssemblyType, 0, 0)) != 0)
			return riEngine.FatalError(*pError);

		if(iatWin32Assembly == iatAssemblyType || iatWin32AssemblyPvt == iatAssemblyType)
		{
			DEBUGMSG1(TEXT("skipping extension registration for component %s as it is a Win32 assembly."), piRec->GetString(reiComponent));
			continue;// skip processing this component
		}

		long lRowCount;

		if (piView == 0)
		{
			if (pError = riEngine.OpenView(sqlRegisterExtensionExInfo, ivcFetch, *&piView))
				return riEngine.FatalError(*pError);
		}

		if ((pError= piView->Execute(piRec)) ||
			(pError = piView->GetRowCount(lRowCount)))
		{
			return riEngine.FatalError(*pError);
		}
		piExtensionRec = &piServices->CreateRecord(lRowCount*3 + Args);
		piExtensionRec->SetMsiString(Extension, *MsiString(piRec->GetMsiString(reiExtension)));
		piExtensionRec->SetMsiString(ProgId, *MsiString(piRec->GetMsiString(reiProgId)));
		piExtensionRec->SetMsiString(ShellNew, *MsiString(piRec->GetMsiString(reiShellNew)));
		piExtensionRec->SetMsiString(ShellNewValue, *MsiString(piRec->GetMsiString(reiShellNewValue)));
		piExtensionRec->SetMsiString(ContentType, *MsiString(piRec->GetMsiString(reiMIME)));

		if(((fMode & iefAdvertise) || !fRemove || piRec->GetInteger(reiFeatureAction) != iisAdvertise))
		{
			MsiString strFeature = piRec->GetMsiString(reiFeature);
			MsiString strComponentId = piRec->GetMsiString(reiComponentId);
			MsiString strComponentWithOptFlags = GetComponentWithDarwinDescriptorOptimizationFlag(riEngine, *strFeature, *strComponentId);
			piExtensionRec->SetMsiString(Feature, *strFeature);
			piExtensionRec->SetMsiString(Component, *strComponentWithOptFlags);
		}
		iisEnum iisState = (iisEnum)piRec->GetInteger(reiComponentAction);

		if(!(fMode & iefAdvertise))
		{
			if(fADVTFlag && iisState == iMsiNullInteger)
			{
				iisEnum iisStateInstalled = (iisEnum)piRec->GetInteger(reiComponentInstalled);
				if(iisStateInstalled == iisAbsent)
					iisStateInstalled = (iisEnum)iMsiNullInteger;
				iisState = iisStateInstalled;
			}
			if(iisState != iMsiNullInteger)
			{
				MsiString strFileName, strFullPath;
				PMsiPath piPath(0);
				int iefLFN;
				if(iisState == iisAbsent || iisState == iisFileAbsent || iisState == iisHKCRFileAbsent || iisState == iisHKCRAbsent)
					strFullPath = *szNonEmptyPath; // token string to cause removal of the filename registration
				else
				{
					// use key file
					if(iisState == iisSource)
					{
						if(pError = piDirectoryMgr->GetSourcePath(*MsiString(piRec->GetMsiString(reiDirectory)), *&piPath))
						{
							if (pError->GetInteger(1) == imsgUser)
								return iesUserExit;
							else
								return riEngine.FatalError(*pError);
						}
						iefLFN = iefNoSourceLFN;
					}
					else
					{
						if(pError = piDirectoryMgr->GetTargetPath(*MsiString(piRec->GetString(reiDirectory)), *&piPath))
						{
							return riEngine.FatalError(*pError);
						}
						iefLFN = iefSuppressLFN;
					}
					Bool fLFN = (fMode & iefLFN) == 0 && piPath->SupportsLFN() ? fTrue : fFalse;
					if(pError = piServices->ExtractFileName(piRec->GetString(reiFileName),fLFN,*&strFileName))
						return riEngine.FatalError(*pError);
					if(pError = piPath->GetFullFilePath(strFileName, *&strFullPath))
					{
						return riEngine.FatalError(*pError);
					}
				}
				piExtensionRec->SetMsiString(FileName, *strFullPath);
			}
		}
		int cCount = Args + 1;
		int iOrder = 0;
		PMsiRecord piExtensionExInfo(0);
		while(piExtensionExInfo = piView->Fetch())
		{
			piExtensionRec->SetMsiString(cCount++, *MsiString(piExtensionExInfo->GetMsiString(rviVerb)));
			piExtensionRec->SetMsiString(cCount++, *MsiString(piExtensionExInfo->GetMsiString(rviCommand)));
			//YACC???
			piExtensionRec->SetMsiString(cCount++, *MsiString(riEngine.FormatText(*MsiString(piExtensionExInfo->GetMsiString(rviArgument)))));
			if(!piExtensionExInfo->IsNull(rviSequence))
				iOrder ++;
		}
		if(iOrder)
			piExtensionRec->SetInteger(Order, iOrder);
		if ( (ibtBinaryType)piRec->GetInteger(reiBinaryType) == ibt64bit )
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegExtensionInfoRegister64 : ixoRegExtensionInfoUnregister64, *piExtensionRec);
		else
			iesRet = riEngine.ExecuteRecord((fRemove == fFalse) ? ixoRegExtensionInfoRegister : ixoRegExtensionInfoUnregister, *piExtensionRec);
		if (iesRet != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}

IMsiRecord* FindMatchingShellFolder(IMsiEngine& riEngine, IMsiPath& riPath, Bool fAllUsers, bool& rfMatch, int& riFolderId, int& rcchShellFolder)
//------------------------------------------------------------------------------------------------------------------------------
{
	// initialize return args, 1st time value is for "match not found"
	rfMatch = false;
	riFolderId = -1;
	rcchShellFolder = 0;

	IMsiRecord* piError = 0;

	// loop thru the shell folders twice, once for ALL-USERS, 2nd for Per-User
	// we'll go by the AllUsers value first just to optimize this since it is rarer that
	// the folder locations have changed (via an ALLUSERS property value change in the UI sequence)
	const ShellFolder* pShellFolder = 0;
	for (int i=0; i<2; i++)
	{
		if (i == 0)
		{
			pShellFolder = fAllUsers ? rgAllUsersProfileShellFolders : rgPersonalProfileShellFolders;
		}
		else if (i == 1)
		{
			// use opposite shell folders of ALLUSERS property value
			pShellFolder = fAllUsers ? rgPersonalProfileShellFolders : rgAllUsersProfileShellFolders;
		}

		for (; pShellFolder->iFolderId >= 0; pShellFolder++)
		{
			//!! the folders need to be listed in the correct sequence for this to work
			PMsiPath piShellPath(0);

			// grap shell folder path from the FolderCache table
			if ((piError = riEngine.GetFolderCachePath(pShellFolder->iFolderId, *&piShellPath)) != 0)
			{
				if (idbgCacheFolderPropertyNotDefined == piError->GetInteger(1))
				{
					// that folder is not defined
					piError->Release();
					continue;
				}
				return piError;
			}

			ipcEnum ipc;
			if ((piError = piShellPath->Compare(riPath, ipc)) != 0)
				return piError;
			if((ipc == ipcEqual) || (ipc == ipcChild))
			{
				// we have a hit, if this is pass 0, then we are using the correct shell folder;
				// otherwise, we need to use the alternate folder matching the found folder
				rfMatch = true;
				riFolderId = (i==0) ? pShellFolder->iFolderId : pShellFolder->iAlternateFolderId;
				MsiString strShellPath = piShellPath->GetPath();
				rcchShellFolder = strShellPath.CharacterCount();
				return 0;
			}
		}
	}

	return 0;
}

const ICHAR sqlCreateShortcutsGPT[] = TEXT("SELECT `Name`, null, null, `Arguments`, `WkDir`, `Icon_`, `IconIndex`, `Hotkey`, `ShowCmd`, `Shortcut`.`Description`, `Shortcut`.`Directory_`, `Component`.`RuntimeFlags`, null, `Target`, `ComponentId` From `Shortcut`, `Feature`, `Component`")
TEXT(" WHERE `Target` = `Feature` AND `Shortcut`.`Component_` = `Component` AND `Feature`.`Action` = 4");
const ICHAR sqlCreateShortcuts[] =    TEXT("SELECT  `Name`, `FileName`, `Component`.`Directory_`, `Arguments`, `WkDir`, `Icon_`, `IconIndex`, `Hotkey`, `ShowCmd`, `Shortcut`.`Description`, `Shortcut`.`Directory_`, `Component`.`RuntimeFlags`, `Component`.`Action`, `Target`, `ComponentId`, `Feature`.`Action`, `Component`.`Installed` From `Shortcut`, `Feature`, `Component`, `File`")
TEXT(" WHERE `Target` = `Feature` AND `Shortcut`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND")
TEXT(" ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");
const ICHAR sqlCreateShortcutsFirstAdvt[] =    TEXT("SELECT  `Name`, `FileName`, `Component`.`Directory_`, `Arguments`, `WkDir`, `Icon_`, `IconIndex`, `Hotkey`, `ShowCmd`, `Shortcut`.`Description`, `Shortcut`.`Directory_`, `Component`.`RuntimeFlags`, `Component`.`Action`, `Target`, `ComponentId`, `Feature`.`Action`, `Component`.`Installed` From `Shortcut`, `Feature`, `Component`, `File`")
TEXT(" WHERE `Target` = `Feature` AND `Shortcut`.`Component_` = `Component` AND `Component`.`KeyPath` = `File`.`File` AND")
TEXT(" ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3  OR `Feature`.`Action` = `Feature`.`Installed`) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)) OR (`Feature`.`Action` = NULL AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2) AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");
const ICHAR sqlCreateShortcutsNonAdvt[] =    TEXT("SELECT  `Name`, `Target`, null, `Arguments`, `WkDir`, `Icon_`,")
TEXT(" `IconIndex`, `Hotkey`, `ShowCmd`, `Shortcut`.`Description`, `Shortcut`.`Directory_`, `Component`.`RuntimeFlags` From `Shortcut`, `Component` WHERE `Shortcut`.`Component_` = `Component`")
TEXT(" AND (`Component`.`Action` = 1 OR `Component`.`Action` = 2)");
const ICHAR sqlRemoveShortcuts[] =    TEXT("SELECT  `Name`, null, `Shortcut`.`Directory_`, `Component`.`RuntimeFlags`, `Feature`.`Action`, `Component`.`Action` From  `Shortcut`, `Feature`, `Component` WHERE `Target` = `Feature` AND `Shortcut`.`Component_` = `Component` AND (`Feature`.`Action` = 0 OR (`Feature`.`Action` = 4 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)) OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlRemoveShortcutsNonAdvt[] = TEXT("SELECT  `Name`, `Target`, `Shortcut`.`Directory_`, `Component`.`RuntimeFlags`  From  `Shortcut`, `Component` WHERE `Shortcut`.`Component_` = `Component` AND `Component`.`Action` = 0");
iesEnum ProcessShortcutInfo(IMsiEngine& riEngine, int fRemove, Bool fAdvertisable = fTrue)
{
	enum irsShortcutInfo{
		irsName = 1,
		irsFileName,
		irsTargetDirectory,
		irsArguments,
		irsWkDir,
		irsIcon,
		irsIconIndex,
		irsHotkey,
		irsShowCmd,
		irsDescription,
		irsDirectory,
		irsComponentRuntimeFlags,
		irsComponentAction,
		irsFeature,
		irsComponent,
		irsFeatureAction,
		irsComponentInstalled,
	};

	enum iusShortcutInfo{
		iusName = 1,
		iusTarget,
		iusDirectory,
		iusComponentRuntimeFlags,
		iusFeatureAction,
		iusComponentAction,
	};

	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiView piView(0);
	PMsiRecord piRec(0);
	PMsiRecord pError(0);
	iesEnum iesRet;
	int fMode = riEngine.GetMode();

	bool fADVTFlag = false;
	if(!fRemove && !(fMode & iefAdvertise))
	{
		MsiString strProductCode = riEngine.GetProductKey();
		CTempBuffer<ICHAR, 15> rgchADVTFlags;
		Bool fProductHasBeenPublished = ProductHasBeenPublished(*piServices, strProductCode);
		if(fProductHasBeenPublished && GetProductInfo(strProductCode,INSTALLPROPERTY_ADVTFLAGS,rgchADVTFlags))
			fADVTFlag = (MsiString(*(ICHAR* )rgchADVTFlags) & SCRIPTFLAGS_SHORTCUTS) ? false : true;
	}

	MsiString strDisableAdvertiseShortcuts = riEngine.GetPropertyFromSz(IPROPNAME_DISABLEADVTSHORTCUTS);
	bool fCreateADVTShortcuts =  !strDisableAdvertiseShortcuts.TextSize() && ((fMode & iefGPTSupport) || g_fSmartShell == fTrue);

	const ICHAR* szQuery = (fMode & iefAdvertise) ? sqlCreateShortcutsGPT : ((fAdvertisable == fTrue) ? ((fRemove == fFalse) ? (fADVTFlag ? sqlCreateShortcutsFirstAdvt : sqlCreateShortcuts) : sqlRemoveShortcuts) : ((fRemove == fFalse) ? sqlCreateShortcutsNonAdvt : sqlRemoveShortcutsNonAdvt));
	if(	(pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) ||
		(pError = piView->Execute(0)))
	{
		// If any tables are missing, not an error - just nothing to do
		if (pError->GetInteger(1) == idbgDbQueryUnknownTable)
			return iesNoAction;
		return riEngine.FatalError(*pError);
	}

	MsiString strPrevFolder;
	PMsiRecord piShortcutRec(0);
	while(piRec = piView->Fetch())
	{
		if(!fRemove && (piRec->GetInteger(irsComponentRuntimeFlags) & bfComponentDisabled))
			continue; // skip publishing for disabled "primary" components


		MsiString strFolder;
		if(fRemove == fFalse)
			strFolder = piRec->GetMsiString(irsDirectory);
		else
			strFolder = piRec->GetMsiString(iusDirectory);

		// is strFolder a folder or subfolder of one of the Shell Folders
		PMsiPath piPath(0);
		PMsiPath piShellPath(0);
		if((pError = piDirectoryMgr->GetTargetPath(*strFolder,*&piPath))!=0)
			return riEngine.FatalError(*pError);
		// set to the default
		strFolder = piPath->GetPath();


		// find correct ShellFolder
		Bool fAllUsers = MsiString(riEngine.GetPropertyFromSz(IPROPNAME_ALLUSERS)).TextSize() ? fTrue : fFalse;
		bool fMatchingShellFolderFound = false;
		int iShellFolderId = -1;
		int cchShellFolderPath = 0;
		if ((pError = FindMatchingShellFolder(riEngine, *piPath, fAllUsers, fMatchingShellFolderFound, iShellFolderId, cchShellFolderPath)) != 0)
			return riEngine.FatalError(*pError);

		if (fMatchingShellFolderFound)
		{
			strFolder = iShellFolderId;
			MsiString strPath = piPath->GetPath();
			strPath.Remove(iseFirst, cchShellFolderPath);
			if (strPath.TextSize())
			{
				strFolder += MsiChar(chDirSep);
				strFolder += strPath;
			}
		}
		else if (fMode & iefAdvertise)
		{
			continue;// we cannot advertise shortcuts that do not fall startmenu, desktop, ...
		}

		if(!strPrevFolder.Compare(iscExact, strFolder))
		{
			using namespace IxoSetTargetFolder;
			PMsiRecord pSTFParams = &piServices->CreateRecord(Args); 
			AssertNonZero(pSTFParams->SetMsiString(IxoSetTargetFolder::Folder, *strFolder));
			iesEnum iesRet;
			if((iesRet = riEngine.ExecuteRecord(ixoSetTargetFolder, *pSTFParams)) != iesSuccess)
				return iesRet;
			strPrevFolder = strFolder; 
		}

		// get shortcut name
		MsiString strShortcutName;
		if(riEngine.GetMode() & iefSuppressLFN)
		{
			if((pError = piServices->ExtractFileName(piRec->GetString(irsName),fFalse,*&strShortcutName)) != 0)
				return riEngine.FatalError(*pError);
		}
		else
		{
			strShortcutName = piRec->GetMsiString(irsName);
		}

		if(fRemove == fFalse)
		{
			using namespace IxoShortcutCreate;
			piShortcutRec= &piServices->CreateRecord(Args);
			piShortcutRec->SetMsiString(Name, *strShortcutName);
			if(fCreateADVTShortcuts && (fAdvertisable != fFalse))
			{
				// use darwin descriptor
				MsiString strFeature = piRec->GetMsiString(irsFeature);
				MsiString strComponentId = piRec->GetMsiString(irsComponent);
				MsiString strComponentWithOptFlags = GetComponentWithDarwinDescriptorOptimizationFlag(riEngine, *strFeature, *strComponentId);
				piShortcutRec->SetMsiString(Feature, *strFeature);
				piShortcutRec->SetMsiString(Component, *strComponentWithOptFlags);
			}
			else
			{
				// if we are in the advertise mode
				if(fMode & iefAdvertise)
					continue;

				// use file name, if not purely advertising
				if(fAdvertisable != fFalse)
				{
 					// cannot create non-advertisable shortcuts for a feature in advertise state
 					if(piRec->GetInteger(irsFeatureAction) == iisAdvertise)
 						continue; 

					PMsiPath piTargetPath(0);
					int iefLFN;
					iisEnum iisState = (iisEnum)piRec->GetInteger(irsComponentAction);
					if(iisState == iMsiNullInteger)
						iisState = (iisEnum)piRec->GetInteger(irsComponentInstalled);

					if(iisState == iisSource)
					{
						if(pError = piDirectoryMgr->GetSourcePath(*MsiString(piRec->GetMsiString(irsTargetDirectory)), *&piTargetPath))
						{
							if (pError->GetInteger(1) == imsgUser)
								return iesUserExit;
							else
								return riEngine.FatalError(*pError);
						}
						iefLFN = iefNoSourceLFN;
					}
					else
					{
						//!! we should assert that either iisState is local or iisState is null and the requested action state is local
						if(pError = piDirectoryMgr->GetTargetPath(*MsiString(piRec->GetMsiString(irsTargetDirectory)), *&piTargetPath))
						{
							return riEngine.FatalError(*pError);
						}
						iefLFN = iefSuppressLFN;
					}
					MsiString strFileName, strFullPath;
					Bool fLFN = (fMode & iefLFN) == 0 && piTargetPath->SupportsLFN() ? fTrue : fFalse;
					if(pError = piServices->ExtractFileName(piRec->GetString(irsFileName),fLFN,*&strFileName))
						return riEngine.FatalError(*pError);
					if(pError = piTargetPath->GetFullFilePath(strFileName, *&strFullPath))
					{
						return riEngine.FatalError(*pError);
					}
					piShortcutRec->SetMsiString(FileName, *strFullPath);
				}
				else
				{
					MsiString strTarget = piRec->GetMsiString(irsFileName);
					if(!strTarget.Compare(iscStart, TEXT("[")))
						continue;//!! Advertisable shortcut
					strTarget = riEngine.FormatText(*strTarget);
					if(!strTarget.TextSize())
						continue;// we are not installing the target or the target is absent
					piShortcutRec->SetMsiString(FileName, *strTarget);			
				}
			}
			if(!piRec->IsNull(irsArguments))
				piShortcutRec->SetMsiString(Arguments, *MsiString(riEngine.FormatText(*MsiString(piRec->GetMsiString(irsArguments)))));
			if(!piRec->IsNull(irsWkDir))
				piShortcutRec->SetMsiString(WorkingDir, *MsiString(riEngine.GetProperty(*MsiString(piRec->GetMsiString(irsWkDir)))));
			if(!piRec->IsNull(irsIcon))
				piShortcutRec->SetMsiString(Icon, *MsiString(piRec->GetMsiString(irsIcon)));
			if(!piRec->IsNull(irsIconIndex))
				piShortcutRec->SetInteger(IconIndex, piRec->GetInteger(irsIconIndex));
			if(!piRec->IsNull(irsHotkey))
				piShortcutRec->SetInteger(HotKey, piRec->GetInteger(irsHotkey));
			if(!piRec->IsNull(irsShowCmd))
				piShortcutRec->SetInteger(ShowCmd, piRec->GetInteger(irsShowCmd));
			if(!piRec->IsNull(irsDescription))
				piShortcutRec->SetMsiString(Description, *MsiString(piRec->GetMsiString(irsDescription)));
		}
		else
		{
			using namespace IxoShortcutRemove;

			MsiString strTarget = piRec->GetMsiString(iusTarget);
			if (!fAdvertisable && !strTarget.Compare(iscStart, TEXT("[")))
				continue;  // skip shortcuts that are advertisable, for this phase we're handling non-advertisable shortcuts

			if(fCreateADVTShortcuts && fAdvertisable && (piRec->GetInteger(iusFeatureAction) == iisAdvertise))
				continue;// we do not delete the shortcut if we are in pure advertise state AND system supports DD shortcuts

			if(!fCreateADVTShortcuts && fAdvertisable &&  (piRec->GetInteger(iusComponentAction) != iisAbsent))
				continue; // skip removing shortcuts to components that are shared

			piShortcutRec= &piServices->CreateRecord(Args);
			piShortcutRec->SetMsiString(Name, *strShortcutName);
		}

		if ((iesRet = riEngine.ExecuteRecord((fRemove == fFalse)?ixoShortcutCreate:ixoShortcutRemove, *piShortcutRec)) != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}

const ICHAR sqlGetFeatureInfo[] = TEXT("SELECT `ComponentId` FROM `FeatureComponents`, `Component` WHERE `Component` = `Component_` AND `Feature_` = ?");
const ICHAR sqlEnumeratePublishUnavailableFeatures[] = TEXT("SELECT `Feature`, `Feature_Parent` FROM `Feature` WHERE `Feature`.`Action` = 0 AND `Feature`.`RuntimeLevel` > 0");
const ICHAR sqlEnumeratePublishUnavailableFeaturesReinstall[] = TEXT("SELECT `Feature`, `Feature_Parent` FROM `Feature` WHERE (`Feature`.`Action` = 0 OR (`Feature`.`Action` = null AND `Feature`.`Installed` = 0)) AND `Feature`.`RuntimeLevel` > 0");
const ICHAR sqlEnumeratePublishUnavailableFeaturesFirstRun[] = TEXT("SELECT `Feature`, `Feature_Parent` FROM `Feature` WHERE (`Feature`.`Installed` = null OR `Feature`.`Installed` = 0) AND (`Feature`.`Action` = null OR `Feature`.`Action` = 0 OR `Feature`.`Action` = 3) AND `Feature`.`RuntimeLevel` > 0");
const ICHAR sqlEnumeratePublishAvailableFeatures[] = TEXT("SELECT `Feature`, `Feature_Parent` FROM `Feature` WHERE ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");
const ICHAR sqlEnumeratePublishAvailableFeaturesGPT[]  = TEXT("SELECT `Feature`, `Feature_Parent` FROM `Feature` WHERE `Feature`.`Action` = 4");
const ICHAR sqlEnumeratePublishUnavailableFeaturesGPT[]= TEXT("SELECT `Feature`, `Feature_Parent` FROM `Feature` WHERE (`Feature`.`Action` = null OR `Feature`.`Action` = 0) AND `Feature`.`RuntimeLevel` > 0");
const ICHAR sqlEnumerateUnPublishFeatures[] = TEXT("SELECT `Feature`, `Feature_Parent` FROM `Feature` WHERE `Feature`.`RuntimeLevel` > 0");


iesEnum ProcessFeaturesInfo(IMsiEngine& riEngine, pfiStates pfis)
{
	enum pfiFeatureInfo{
		pfiFeature = 1,
		pfiFeatureParent,
	};

	enum pfciFeatureComponentInfo{
		pfciComponent = 1,
	};


	PMsiServices piServices(riEngine.GetServices()); 
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;
	int fMode = riEngine.GetMode();
	int iPublishFeatureFlags = 0;

	bool fQFEUpgrade = false;
	MsiString strQFEUpgrade = riEngine.GetPropertyFromSz(IPROPNAME_QFEUPGRADE);
	if(strQFEUpgrade.TextSize())
		fQFEUpgrade = true;


	const ICHAR* szQuery;
	switch(pfis)
	{
	case pfiAvailable:
		szQuery = (fMode & iefAdvertise) ? sqlEnumeratePublishAvailableFeaturesGPT : sqlEnumeratePublishAvailableFeatures;
		break;
	case pfiRemove:
		szQuery = sqlEnumerateUnPublishFeatures;
		break;
	case pfiAbsent:
	{
		iPublishFeatureFlags = iPublishFeatureAbsent;
		if(fMode & iefAdvertise)
			szQuery = sqlEnumeratePublishUnavailableFeaturesGPT;
		else
		{
			INSTALLSTATE is = MSI::MsiQueryProductState(MsiString(riEngine.GetProductKey()));
			szQuery = (is == INSTALLSTATE_UNKNOWN || is == INSTALLSTATE_ABSENT) ? sqlEnumeratePublishUnavailableFeaturesFirstRun : (fQFEUpgrade ? sqlEnumeratePublishUnavailableFeaturesReinstall : sqlEnumeratePublishUnavailableFeatures);
		}
		break;
	}
	default:
		Assert(0);// should never be here, this is our own private function can afford to assert
		szQuery = TEXT("");
		break;
	}


	if(!(fMode & iefAdvertise))
		iPublishFeatureFlags |= iPublishFeatureInstall;
	PMsiView piEnumFeatureView(0);
	if((pError = riEngine.OpenView(szQuery, ivcFetch, *&piEnumFeatureView)) ||
		(pError = piEnumFeatureView->Execute(0)))
	{
		if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pError);
		else
			return iesNoAction;
	}
	PMsiRecord piEnumRec(0);
	PMsiView piFeatureView(0);

	while(piEnumRec = piEnumFeatureView->Fetch())
	{
		using namespace IxoFeaturePublish;

		MsiString strFeature = piEnumRec->GetMsiString(pfiFeature);
		MsiString strFeatureParent = piEnumRec->GetMsiString(pfiFeatureParent);
		if(strFeatureParent.Compare(iscExact, strFeature))
			strFeatureParent = TEXT("");
		long lRowCount = 0;
		if (iPublishFeatureFlags & iPublishFeatureInstall)
		{
			if (piFeatureView == 0)
			{
				if(	(pError = riEngine.OpenView(sqlGetFeatureInfo, ivcFetch, *&piFeatureView)))
				{
					if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
						return riEngine.FatalError(*pError);
				}
			}
			else
				piFeatureView->Close();

			if((pError = piFeatureView->Execute(piEnumRec)) ||
			   (pError = piFeatureView->GetRowCount(lRowCount)))
			{
				return riEngine.FatalError(*pError);
			}
		}
		PMsiRecord piFeatureRec(0);
		int cCount = Args;
		piFeatureRec = &piServices->CreateRecord((lRowCount - 1) + Args);
		piFeatureRec->SetMsiString(Feature, *strFeature);
		piFeatureRec->SetMsiString(Parent, *strFeatureParent);
		piFeatureRec->SetInteger(Absent, iPublishFeatureFlags);
		if(lRowCount)
		{
			PMsiRecord piComponentRec(0);
			MsiString strComponentsList;
			while(piComponentRec = piFeatureView->Fetch())
			{
				if(!piComponentRec->IsNull(pfciComponent)) // skip components with null component id
				{
					// pack components on the client side into one string
					ICHAR szSQUID[cchComponentIdCompressed+1];
					AssertNonZero(PackGUID(piComponentRec->GetString(pfciComponent), szSQUID, ipgCompressed));
					strComponentsList += szSQUID;
				}
			}
			piFeatureRec->SetMsiString(cCount++, *strComponentsList);
		}
		if ((iesRet = riEngine.ExecuteRecord((pfis == pfiRemove)?ixoFeatureUnpublish :ixoFeaturePublish, *piFeatureRec)) != iesSuccess)
			return iesRet;
	}
	return iesSuccess;
}

const ICHAR sqlUnpublishComponents[] = TEXT("SELECT `PublishComponent`.`ComponentId`, `PublishComponent`.`Qualifier`, `PublishComponent`.`AppData`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `PublishComponent`, `Component`, `Feature`  WHERE `PublishComponent`.`Component_` = `Component`.`Component` AND `PublishComponent`.`Feature_` = `Feature`.`Feature` AND (`Feature`.`Action` = 0 OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");
const ICHAR sqlPublishComponents[]   = TEXT("SELECT `PublishComponent`.`ComponentId`, `PublishComponent`.`Qualifier`, `PublishComponent`.`AppData`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `PublishComponent`, `Component`, `Feature`  WHERE `PublishComponent`.`Component_` = `Component`.`Component` AND `PublishComponent`.`Feature_` = `Feature`.`Feature` AND ((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");
const ICHAR sqlPublishComponentsGPT[]= TEXT("SELECT `PublishComponent`.`ComponentId`, `PublishComponent`.`Qualifier`, `PublishComponent`.`AppData`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `PublishComponent`, `Component`, `Feature`  WHERE `PublishComponent`.`Component_` = `Component`.`Component` AND `PublishComponent`.`Feature_` = `Feature`.`Feature` AND `Feature`.`Action` = 4");

iesEnum ProcessComponentsInfo(IMsiEngine& riEngine, int fRemove)
{
	enum pciEnum
	{
		pciComponentId = 1,
		pciQualifier,
		pciAppData,
		pciFeature,
		pciComponent,
		pciComponentRuntimeFlags,
	};

	PMsiServices piServices(riEngine.GetServices()); 
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;
	int fMode = riEngine.GetMode();

	// advertise the component factories for cross-product usage
	PMsiView piView(0);
	const ICHAR* szQuery = (fMode & iefAdvertise) ? sqlPublishComponentsGPT: (fRemove == fFalse) ? sqlPublishComponents : sqlUnpublishComponents;

	if((pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) ||
		(pError = piView->Execute(0)))
	{
		if (pError)
		{
			if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
				return riEngine.FatalError(*pError);
			else
				return iesNoAction;
		}
	}
	PMsiRecord piRec(0);
	while(piRec = piView->Fetch())
	{
		using namespace IxoComponentPublish;

		Assert(piRec->GetInteger(pciComponentRuntimeFlags) != iMsiNullInteger);
		if(!fRemove && (piRec->GetInteger(pciComponentRuntimeFlags) & bfComponentDisabled))
			continue; // skip publishing for disabled "primary" components

		PMsiRecord piComponentRec = &piServices->CreateRecord(Args);
		piComponentRec->SetMsiString(ComponentId, *MsiString(piRec->GetMsiString(pciComponentId)));
		if(!piRec->IsNull(pciQualifier))
			piComponentRec->SetMsiString(Qualifier, *MsiString(piRec->GetMsiString(pciQualifier)));
		if(!piRec->IsNull(pciAppData))
			piComponentRec->SetMsiString(AppData, *MsiString(piRec->GetMsiString(pciAppData)));			

		MsiString strFeature = piRec->GetMsiString(pciFeature);
		MsiString strComponentId = piRec->GetMsiString(pciComponent);
		MsiString strComponentWithOptFlags = GetComponentWithDarwinDescriptorOptimizationFlag(riEngine, *strFeature, *strComponentId);
		piComponentRec->SetMsiString(Feature, *strFeature);
		piComponentRec->SetMsiString(Component, *strComponentWithOptFlags);
		if ((iesRet = riEngine.ExecuteRecord((fRemove == fFalse)?ixoComponentPublish:ixoComponentUnpublish, *piComponentRec)) != iesSuccess)
			return iesRet;
	}
	return iesRet;
}


// fn: remove assembly registration corr. to a component
// used during qfe upgrades when assembly names might have potentially changed
iesEnum UnpublishPreviousAssembly(IMsiEngine& riEngine, iatAssemblyType iatAssemblyType, const IMsiString& ristrAppCtx, const IMsiString& riFeature, const IMsiString& riComponent, const IMsiString & ristrDescriptor)
{
	CTempBuffer<ICHAR, 1> rgchAppCtxWOBS(MAX_PATH);
	if(ristrAppCtx.TextSize())
	{
		// we need to replace the backslashes in the AppCtx with something else, since registry keys cannot
		// have backslashes
		DWORD cchLen = ristrAppCtx.TextSize() + 1;
		rgchAppCtxWOBS.SetSize(cchLen);
		memcpy((ICHAR*)rgchAppCtxWOBS, (const ICHAR*)ristrAppCtx.GetString(), cchLen*sizeof(ICHAR));
		ICHAR* lpTmp = rgchAppCtxWOBS;
		while(*lpTmp)
		{
			if(*lpTmp == '\\')
				*lpTmp = '|';
			lpTmp = ICharNext(lpTmp);
		}
	}

	DWORD iIndex = 0;
	CTempBuffer<ICHAR, 1> rgchAssemblyName(MAX_PATH);
	CTempBuffer<ICHAR, 1> rgchDescriptorList(1024);

	DWORD dwAssemblyInfo = (iatWin32Assembly == iatAssemblyType || iatWin32AssemblyPvt == iatAssemblyType) ? MSIASSEMBLYINFO_WIN32ASSEMBLY : MSIASSEMBLYINFO_NETASSEMBLY;
	extern UINT EnumAssemblies(DWORD dwAssemblyInfo,const ICHAR* szAppCtx, DWORD iIndex, ICHAR* lpAssemblyNameBuf, DWORD *pcchAssemblyBuf, ICHAR* lpDescriptorBuf, DWORD *pcchDescriptorBuf);// from msinst.cpp

	UINT uiRet = ERROR_SUCCESS;
	for(;;)
	{
		DWORD cchAssemblyName = rgchAssemblyName.GetSize();
		DWORD cchDescriptorList = rgchDescriptorList.GetSize();
		uiRet = EnumAssemblies(dwAssemblyInfo, ristrAppCtx.TextSize() ? (const ICHAR*)rgchAppCtxWOBS : szGlobalAssembliesCtx, iIndex, rgchAssemblyName, &cchAssemblyName, rgchDescriptorList, &cchDescriptorList);
		if(ERROR_MORE_DATA == uiRet)
		{
			rgchAssemblyName.SetSize(++cchAssemblyName);
			rgchDescriptorList.SetSize(++cchDescriptorList);					
			if ( !(ICHAR *)rgchAssemblyName || !(ICHAR *)rgchDescriptorList)
				uiRet = ERROR_OUTOFMEMORY;
			else
				uiRet = EnumAssemblies(dwAssemblyInfo, ristrAppCtx.TextSize() ? (const ICHAR*)rgchAppCtxWOBS : szGlobalAssembliesCtx, iIndex, rgchAssemblyName, &cchAssemblyName, rgchDescriptorList, &cchDescriptorList);
		}			
		iIndex++;
		if(ERROR_SUCCESS != uiRet)
		{
			if(ERROR_NO_MORE_ITEMS != uiRet && ERROR_UNKNOWN_COMPONENT != uiRet)
			{
				// log the unexpected failure
				DEBUGMSG1(TEXT("Unexpected error enumerating registered assemblies: %d"), (const ICHAR*)(INT_PTR)uiRet);
			}
			break;
		}

		
		// is our descriptor in this 
		const ICHAR* szDescriptorList = rgchDescriptorList;
		while(*szDescriptorList)
		{
			if(ristrDescriptor.Compare(iscExactI, szDescriptorList))
			{
				// set up the assembly registration for removal
				using namespace IxoAssemblyUnpublish;
				PMsiServices piServices(riEngine.GetServices()); 
				PMsiRecord piAssemblyRec = &piServices->CreateRecord(Args);
				piAssemblyRec->SetInteger(AssemblyType,(int)iatAssemblyType);
				piAssemblyRec->SetString(AssemblyName, rgchAssemblyName);
				if(ristrAppCtx.TextSize())
					piAssemblyRec->SetMsiString(AppCtx, ristrAppCtx);

				piAssemblyRec->SetMsiString(Feature, riFeature);
				piAssemblyRec->SetMsiString(Component, riComponent);

				iesEnum iesRet;
				if ((iesRet = riEngine.ExecuteRecord(ixoAssemblyUnpublish, *piAssemblyRec)) != iesSuccess)
					return iesRet;
			}
			// continue on to the next descriptor in the list
			szDescriptorList = szDescriptorList + lstrlen(szDescriptorList) + 1;
		}
	}
	return iesSuccess;
}

const ICHAR sqlPublishPvtAssemblies[]   = TEXT("SELECT `File`.`FileName`, `Component_Parent`.`Directory_`, `Component`.`Component`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `MsiAssembly`, `Component`, `Feature`, `File`, `Component` AS `Component_Parent` WHERE `MsiAssembly`.`Component_` = `Component`.`Component` AND `MsiAssembly`.`Feature_` = `Feature`.`Feature` AND `MsiAssembly`.`File_Application` = `File`.`File` AND `File`.`Component_` =  `Component_Parent`.`Component` AND ")
										  TEXT("(`Component_Parent`.`ActionRequest` = 1 OR `Component_Parent`.`ActionRequest` = 2 OR (`Component_Parent`.`ActionRequest` = null AND (`Component_Parent`.`Action`= 1 OR `Component_Parent`.`Action`= 2))) ");

const ICHAR sqlUnpublishPvtAssemblies[] = TEXT("SELECT `File`.`FileName`, `Component_Parent`.`Directory_`, `Component`.`Component`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `MsiAssembly`, `Component`, `Feature`, `File`, `Component`  AS `Component_Parent` WHERE `MsiAssembly`.`Component_` = `Component`.`Component` AND `MsiAssembly`.`Feature_` = `Feature`.`Feature` AND `MsiAssembly`.`File_Application` = `File`.`File` AND `File`.`Component_` =  `Component_Parent`.`Component` AND ")
										  TEXT("`Component_Parent`.`ActionRequest` = 0");

const ICHAR sqlPublishAssembliesGPT[]   = TEXT("SELECT null, null, `Component`.`Component`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `MsiAssembly`, `Component`, `Feature`  WHERE `MsiAssembly`.`Component_` = `Component`.`Component` AND `MsiAssembly`.`Feature_` = `Feature`.`Feature` AND `MsiAssembly`.`File_Application` = null AND ")
										  TEXT("`Feature`.`Action` = 4");
const ICHAR sqlPublishAssemblies[]      = TEXT("SELECT null, null, `Component`.`Component`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `MsiAssembly`, `Component`, `Feature`  WHERE `MsiAssembly`.`Component_` = `Component`.`Component` AND `MsiAssembly`.`Feature_` = `Feature`.`Feature` AND `MsiAssembly`.`File_Application` = null AND ")
										  TEXT("((`Feature`.`Action` = 1 OR `Feature`.`Action` = 2)  OR (`Feature`.`Action` = 4 AND `Feature`.`Installed` = 0) OR (`Feature`.`Action` = 3 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2 OR `Feature`.`Installed` = 4)))");
const ICHAR sqlUnpublishAssemblies[]    = TEXT("SELECT null, null, `Component`.`Component`, `Feature`, `Component`.`ComponentId`, `Component`.`RuntimeFlags` FROM `MsiAssembly`, `Component`, `Feature`  WHERE `MsiAssembly`.`Component_` = `Component`.`Component` AND `MsiAssembly`.`Feature_` = `Feature`.`Feature` AND `MsiAssembly`.`File_Application` = null AND ")
										  TEXT("(`Feature`.`Action` = 0 OR ((`Feature`.`Action` = NULL OR `Feature`.`Action` = 3) AND `Component`.`Action` = 0 AND (`Feature`.`Installed` = 1 OR `Feature`.`Installed` = 2)))");

iesEnum ProcessAssembliesInfo(IMsiEngine& riEngine, int fRemove)
{
	enum pciEnum
	{
		paiAppCtx = 1,
		paiAppDirectory,
		paiComponent,
		paiFeature,
		paiComponentId,
		paiComponentRuntimeFlags,
	};

	PMsiServices piServices(riEngine.GetServices()); 
	MsiString strProductKey = riEngine.GetProductKey();
	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;
	int fMode = riEngine.GetMode();

	// advertise the assemblies
	for(int cCount = 0 ; cCount < 2; cCount++) // loop to advertise global and pvt assemblies
	{
		PMsiView piView(0);
		const ICHAR* szQuery;
		if(!cCount)
			szQuery = (fMode & iefAdvertise) ? sqlPublishAssembliesGPT: (fRemove == fFalse) ? sqlPublishAssemblies : sqlUnpublishAssemblies;
		else
			szQuery = (fRemove == fFalse) ? sqlPublishPvtAssemblies : sqlUnpublishPvtAssemblies;

		if((pError = riEngine.OpenView(szQuery, ivcFetch, *&piView)) ||
			(pError = piView->Execute(0)))
		{
			if (pError)
			{
				if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
					return riEngine.FatalError(*pError);
				else
					return iesNoAction;
			}
		}
		PMsiRecord piRec(0);
		while(piRec = piView->Fetch())
		{
			using namespace IxoAssemblyPublish;

			Assert(piRec->GetInteger(paiComponentRuntimeFlags) != iMsiNullInteger);
			if(!fRemove && (piRec->GetInteger(paiComponentRuntimeFlags) & bfComponentDisabled))
				continue; // skip publishing for disabled "primary" components

			PMsiRecord piAssemblyRec = &piServices->CreateRecord(Args);

			// get the assembly name
			iatAssemblyType iatAssemblyType;
			MsiString strAssemblyName;
			if((pError = riEngine.GetAssemblyInfo(*MsiString(piRec->GetMsiString(paiComponent)), iatAssemblyType, &strAssemblyName, 0)) != 0)
				return riEngine.FatalError(*pError);

			MsiString strAppCtx;
			if(!piRec->IsNull(paiAppCtx))
			{
				// advertising/unadvertising pvt assemblies
				// get the full file path that represents the parent's context
				PMsiDirectoryManager piDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
				PMsiPath pPath(0);
				if((pError = piDirectoryMgr->GetTargetPath(*MsiString(piRec->GetMsiString(paiAppDirectory)),*&pPath)) != 0)
					return riEngine.FatalError(*pError);

				Bool fLFN = (fMode & iefSuppressLFN) == 0 && pPath->SupportsLFN() ? fTrue : fFalse;

				MsiString strFile;
				if((pError = piServices->ExtractFileName(piRec->GetString(paiAppCtx),fLFN,*&strFile)) != 0)
					return riEngine.FatalError(*pError);

				if((pError = pPath->GetFullFilePath(strFile, *&strAppCtx)) != 0)
					return riEngine.FatalError(*pError);			
			}

			piAssemblyRec->SetInteger(AssemblyType,(int)iatAssemblyType);
			piAssemblyRec->SetMsiString(AssemblyName, *strAssemblyName);
			if(strAppCtx.TextSize())
				piAssemblyRec->SetMsiString(AppCtx, *strAppCtx);

			MsiString strFeature = piRec->GetMsiString(paiFeature);
			MsiString strComponentId = piRec->GetMsiString(paiComponentId);
			MsiString strComponentWithOptFlags = GetComponentWithDarwinDescriptorOptimizationFlag(riEngine, *strFeature, *strComponentId);
			piAssemblyRec->SetMsiString(Feature, *strFeature);
			piAssemblyRec->SetMsiString(Component, *strComponentWithOptFlags);

			// set up removal of previous registration
			extern const IMsiString& ComposeDescriptor(const IMsiString& riProductCode, const IMsiString& riFeature, const IMsiString& riComponent, bool fComClassicInteropForAssembly);
			MsiString strDescriptor = ComposeDescriptor(*MsiString(riEngine.GetProductKey()), *strFeature, *strComponentWithOptFlags, false);

			// we need to accomodate the possibility of the assembly name order having changed
			// hence we seek out the previous registration associated with this product, feature, component and explicitly 
			// delete the same
			if((iesRet = UnpublishPreviousAssembly(riEngine, iatAssemblyType, *strAppCtx, *strFeature, *strComponentWithOptFlags, *strDescriptor)) != iesSuccess)
				return iesRet;
			if(!fRemove) // (re)register 
			{
				if ((iesRet = riEngine.ExecuteRecord(ixoAssemblyPublish, *piAssemblyRec)) != iesSuccess)
					return iesRet;
			}
		}
	}
	return iesRet;
}

/*---------------------------------------------------------------------------
	MsiPublishAssemblies action - 
---------------------------------------------------------------------------*/
iesEnum MsiPublishAssemblies(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessAssembliesInfo(riEngine, fFalse);
}

/*---------------------------------------------------------------------------
	MsiUnpublishAssemblies action - 
---------------------------------------------------------------------------*/
iesEnum MsiUnpublishAssemblies(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessAssembliesInfo(riEngine, fTrue);
}

/*---------------------------------------------------------------------------
	PublishSourceList action - 
---------------------------------------------------------------------------*/
const ICHAR sqlMediaInformation[] = TEXT("SELECT `DiskPrompt`, `VolumeLabel`, `DiskId` FROM `Media` ORDER BY `DiskId`");
const ICHAR sqlPatchMediaInformation[] = TEXT("SELECT `DiskPrompt`, `VolumeLabel`, `DiskId` FROM `Media`, `PatchPackage` WHERE `PatchPackage`.`Media_` = `DiskId`");


enum slmiEnum
{
	slmiDiskPrompt  = 1,
	slmiVolumeLabel,
	slmiDiskId,
};

const int ciMaxOpCodeSize = 254;
class CSourceListPublisher 
{
public:
	CSourceListPublisher(IMsiEngine& riEngine);
	iesEnum AddPatchInfo(const ICHAR *szPatchCode, const ICHAR* szPatchPackageName);
	
	iesEnum AddMediaSource(int iDiskId, const IMsiString &riVolumeLabel, const IMsiString &riDiskPrompt);
	iesEnum AddSource(const IMsiString &riSource);
	iesEnum Flush();

	inline void CSourceListPublisher::AddMediaPrompt(const IMsiString &riDiskPromptTemplate)
	{
		Assert(m_fFirst);
		if (!pSourceListRec)
			return;
		pSourceListRec->SetMsiString(IxoSourceListPublish::DiskPromptTemplate, riDiskPromptTemplate);
	}

	inline void CSourceListPublisher::AddMediaPath(const IMsiString &riMediaRelativePath)
	{
		Assert(m_fFirst);
		if (!pSourceListRec)
			return;
		pSourceListRec->SetMsiString(IxoSourceListPublish::PackagePath, riMediaRelativePath);
	}

private:
	IMsiEngine& m_riEngine;
	bool m_fFirst;
	int m_cArg;
	PMsiRecord pSourceListRec;
	MsiString m_strPatchCode;
	PMsiServices m_pServices;
};

CSourceListPublisher::CSourceListPublisher(IMsiEngine& riEngine) : m_fFirst(true), m_cArg(IxoSourceListPublish::NumberOfDisks+1), pSourceListRec(0), 
	m_riEngine(riEngine), m_pServices(riEngine.GetServices()), m_strPatchCode(TEXT(""))
{
	pSourceListRec = &m_pServices->CreateRecord(ciMaxOpCodeSize);
	if (pSourceListRec)
		pSourceListRec->SetInteger(IxoSourceListPublish::NumberOfDisks, 0);
}

iesEnum CSourceListPublisher::AddPatchInfo(const ICHAR *szPatchCode, const ICHAR* szPatchPackageName)
{
	if (!pSourceListRec)
		return iesFailure;
		
	using namespace IxoSourceListPublish;
	// full patch information is passed only in the ixoSourceListPublish opcode, so this 
	// must be our initial record. Only the patch code is passed in additional Append calls
	Assert(m_fFirst);
	if (szPatchCode)
	{
		m_strPatchCode = szPatchCode;
		pSourceListRec->SetString(PatchCode, szPatchCode);
	}

	if (szPatchPackageName)
		pSourceListRec->SetString(PatchPackageName, szPatchPackageName);

	return iesSuccess;
}

iesEnum CSourceListPublisher::AddMediaSource(int iDiskId, const IMsiString &riVolumeLabel, const IMsiString &riDiskPrompt)
{
	if (!pSourceListRec)
		return iesFailure;
		
	// if adding this media source to the record would push us over the limit,
	// execute this record and create a new one. The maximum we can fill is
	// max-2, max-1, and max.
	if (m_cArg > ciMaxOpCodeSize-2)
	{
		iesEnum iesRet = Flush();
		if (iesSuccess != iesRet)
			return iesRet;
	}

	// add the info for this media source to the end of the record
	pSourceListRec->SetInteger(m_cArg++, iDiskId);
	pSourceListRec->SetMsiString(m_cArg++, riVolumeLabel);
	pSourceListRec->SetMsiString(m_cArg++, riDiskPrompt);

	// increment the number of media entries in this record
	int iField = m_fFirst ? (int)IxoSourceListPublish::NumberOfDisks : (int)IxoSourceListAppend::NumberOfMedia;
	pSourceListRec->SetInteger(iField, pSourceListRec->GetInteger(iField)+1);
	return iesSuccess;
}

iesEnum CSourceListPublisher::AddSource(const IMsiString &riSource)
{
	if (!pSourceListRec)
		return iesFailure;

	// if we're over the limit for this record,
	if (m_cArg > ciMaxOpCodeSize)
	{
		iesEnum iesRet = Flush();
		if (iesSuccess != iesRet)
			return iesRet;
	}

	// add the info for this media source to the end of the record
	pSourceListRec->SetMsiString(m_cArg++, riSource);

	return iesSuccess;
}

iesEnum CSourceListPublisher::Flush()
{
	if (!pSourceListRec)
		return iesFailure;
		
	iesEnum iesRet = iesSuccess;
	// we only need to execute and flush this record if it has data.
	if (m_cArg != IxoSourceListAppend::NumberOfMedia+1)
	{
		if (m_fFirst)
		{
			m_fFirst = false;
			if (iesSuccess != (iesRet = m_riEngine.ExecuteRecord(ixoSourceListPublish, *pSourceListRec)))
				return iesRet;
		}
		else
		{
			if (iesSuccess != (iesRet = m_riEngine.ExecuteRecord(ixoSourceListAppend, *pSourceListRec)))
				return iesRet;
		}
		m_cArg = IxoSourceListAppend::NumberOfMedia+1;
		
		// writing the script record strips trailing null fields, so we can be generous instead of
		// re-allocating every time we run off the end of a record.
		for (int i=0; i <= ciMaxOpCodeSize; i++)
			pSourceListRec->SetNull(i);
//		pSourceListRec = &m_pServices->CreateRecord(ciMaxOpCodeSize);
		pSourceListRec->SetInteger(IxoSourceListAppend::NumberOfMedia, 0);
		pSourceListRec->SetString(IxoSourceListAppend::PatchCode, m_strPatchCode);
	}
	
	return iesRet;
}

iesEnum PublishSourceList(IMsiEngine& riEngine, const IMsiString& riSourceList, const ICHAR* szPatchCode, const ICHAR* sqlMedia, const ICHAR* szSourceDir, const ICHAR* szPatchPackageName=0)
{
	PMsiRecord pError(0);
	PMsiServices pServices(riEngine.GetServices());
	
	MsiString strSourceList = riSourceList; 
	riSourceList.AddRef();

	CSourceListPublisher ListPublisher(riEngine);
	
	// determine patch information and add it to the initial record
	// patch code and patch package must both be NULL or both set
	Assert(!szPatchCode == !szPatchPackageName);
	if (szPatchCode)
	{
		ListPublisher.AddPatchInfo(szPatchCode, szPatchPackageName);
	}

	unsigned int iSourceArg = 0;
	unsigned int cDisks = 0;
	bool fAddLaunchedSource = false;

	// determine the media-relative package path
	MsiString strSourceDir = szSourceDir;
	MsiString strMediaRelativePath;
	if(strSourceDir.TextSize())
	{
		// If our current source is media then we'll use it to determine our media package path, if
		// the media package path property isn't already set.
		
		PMsiPath pPath(0);
		if ((pError = pServices->CreatePath(strSourceDir, *&pPath)) != 0)
			return riEngine.FatalError(*pError);

		idtEnum idt = PMsiVolume(&pPath->GetVolume())->DriveType();
		if (idt == idtCDROM || idt == idtFloppy || idt == idtRemovable)
		{
			strMediaRelativePath = pPath->GetRelativePath();
		}
		else 
		{
			if (!szPatchCode)
				strMediaRelativePath = riEngine.GetPropertyFromSz(IPROPNAME_MEDIAPACKAGEPATH);

			if ( !g_MessageContext.IsOEMInstall() )
			{
				// if we're not running from media then we need to add the source we were launched from as a 
				// source for the product
				fAddLaunchedSource = true;
			}
		}

		if (strMediaRelativePath.TextSize())
			ListPublisher.AddMediaPath(*strMediaRelativePath);
	}

	// Add the media source information if we're not prohibited from doing so
	if (!MsiString(riEngine.GetPropertyFromSz(IPROPNAME_DISABLEMEDIA)).TextSize())
	{
		PMsiRecord pFetchRecord(0);
		PMsiView pView(0);
		long lRowCount;
		if((pError = riEngine.OpenView(sqlMedia, ivcFetch, *&pView)) ||
			(pError = pView->Execute(0)) || 
			(pError = pView->GetRowCount(lRowCount)))
			return riEngine.FatalError(*pError); //?? is this a fatal error
		
		MsiString strFirstVolumeLabel;
		ListPublisher.AddMediaPrompt(*MsiString(riEngine.GetPropertyFromSz(IPROPNAME_DISKPROMPT)));

		// fetch every record from the media table, adding it to the list. 
		while ((pFetchRecord = pView->Fetch()) != 0)
		{
			MsiString strVolumeLabel = pFetchRecord->GetMsiString(slmiVolumeLabel);
			if (cDisks == 0)
			{
				strFirstVolumeLabel = strVolumeLabel;
			}
			
			// check if this is the first media disk
			// if so, we may need to replace the volume label from the Media table
			// NOTE: assumes that all Media table entries with same VolumeLabel as first entry
			//       represent the same (first) disk
			if (cDisks == 0 || strVolumeLabel.Compare(iscExact, strFirstVolumeLabel))
			{
				MsiString strCurrentLabel = riEngine.GetPropertyFromSz(IPROPNAME_CURRENTMEDIAVOLUMELABEL);

				// we are looking at a record representing the first media label
				// we allow the first disk's volume label to not match the real volume label
				// this is for authoring simplicity with single-volume installs
				
				//!! need to make sure proper label is used when migrating source list during a patch
				if (strCurrentLabel.TextSize())
				{
					if (strCurrentLabel.Compare(iscExact, szBlankVolumeLabelToken))
						strCurrentLabel = g_MsiStringNull;
					
					strVolumeLabel = strCurrentLabel;
				}
			}
			else if (pFetchRecord->IsNull(slmiVolumeLabel)) // if we're at disk 2 or higher then if we must not have any volume labels; if one's NULL then they all are
				break;

			cDisks++;
			iesEnum iesRet = ListPublisher.AddMediaSource(pFetchRecord->GetInteger(slmiDiskId), 
				*strVolumeLabel, *MsiString(pFetchRecord->GetMsiString(slmiDiskPrompt)));	
			if (iesRet != iesSuccess)
				return iesRet;
		} 
	}

	// add the launched-from source if not media (determined above)
	if (fAddLaunchedSource)
		ListPublisher.AddSource(*strSourceDir);
	
	// Add all sources that are in the SOURCELIST property

	if (strSourceDir.Compare(iscEnd, szRegSep))
		strSourceDir.Remove(iseLast, 1);

	strSourceList += TEXT(";"); // helps our loop

	while(strSourceList.TextSize())
	{
		MsiString strSource = strSourceList.Extract(iseUpto, ';');
		if (strSource.Compare(iscEnd, szRegSep))
			strSource.Remove(iseLast, 1);

		if (!strSource.Compare(iscExactI, strSourceDir))
		{
			if(strSource.TextSize())
			{
				ListPublisher.AddSource(*strSource);
			}
		}
		//?? else error??
		strSourceList.Remove(iseIncluding, ';');
	}
	
	return ListPublisher.Flush();
}

iesEnum GetForeignSourceList(IMsiEngine& riEngine, const IMsiString& ristrProduct,
									  const IMsiString*& rpistrForeignSourceList)
// reads source list for another product and returns SOURCELIST-like string
{
	PMsiServices pServices(riEngine.GetServices());
	PMsiRecord pError(0);
	LONG lResult = 0;
	
	CRegHandle HKey;
	if ((lResult = OpenSourceListKey(ristrProduct.GetString(), fFalse, HKey, fFalse, false)) != ERROR_SUCCESS)
	{
		pError = PostError(Imsg(idbgSrcOpenSourceListKey), (int)lResult);
		return riEngine.FatalError(*pError);
	}

	PMsiRegKey pSourceListKey = &pServices->GetRootKey((rrkEnum)(int)HKey, ibtCommon);

	PEnumMsiString pEnumString(0);
	MsiString strSourceList;
	MsiString strSource;

	for(int i=0;i<2;i++) // i == 0: net key; i == 1: url key
	{
		PMsiRegKey pSourceListSubKey = &pSourceListKey->CreateChild((i == 0 ? szSourceListNetSubKey : szSourceListURLSubKey));

		if ((pError = pSourceListSubKey->GetValueEnumerator(*&pEnumString)) != 0)
		{
			return riEngine.FatalError(*pError);
		}

		MsiString strIndex;
		while (pEnumString->Next(1, &strIndex, 0) == S_OK)
		{
			if ((pError = pSourceListSubKey->GetValue(strIndex, *&strSource)) != 0)
				return riEngine.FatalError(*pError);

			if (strSource.Compare(iscStart, TEXT("#%"))) 
				strSource.Remove(iseFirst, 2); // remove REG_EXPAND_SZ token
			
			strSourceList += strSource;
			strSourceList += MsiChar(';');
		}
	}
	
	strSourceList.ReturnArg(rpistrForeignSourceList);
	return iesSuccess;
}

/*---------------------------------------------------------------------------
	PublishProduct action - 
---------------------------------------------------------------------------*/
// we advertise information that needs to be placed with the configuration manager
const ICHAR sqlAdvertiseIcons[] = TEXT("SELECT `Name`, `Data` FROM `Icon`");
const ICHAR sqlEnumerateInstalledFeatures[] = TEXT("SELECT `Feature` FROM `Feature` WHERE `Feature`.`Action` = 1 OR `Feature`.`Action` = 2 OR `Feature`.`Action` = 4");

const ICHAR sqlRegisterPatchPackages[] = TEXT("SELECT `PatchId`, `PackageName`, `SourceList`, `TransformList`, `TempCopy`, `Existing`, `Unregister`, `SourcePath` FROM `#_PatchCache` ORDER BY `Sequence`");
const ICHAR sqlUnregisterPatchPackages[] = TEXT("SELECT `PatchId` FROM `#_PatchCache`");

enum sppEnum
{
	sppPatchId = 1,
	sppPackageName,
	sppSourceList,
	sppTransformList,
	sppTempCopy,
	sppExisting,
	sppUnregister,
	sppSourcePath,
};

// local function that returns the source path for a child install, relative to the parent's
IMsiRecord* GetProductSourcePathRelativeToParent(IMsiEngine& riEngine, const IMsiString*& rpistrRelativePath)
{
	MsiString istrDatabase = riEngine.GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE);
	if (*(const ICHAR*)istrDatabase == ':')  // substorage
	{
		istrDatabase.ReturnArg(rpistrRelativePath);  // return prefixed substorage name
		return 0;
	}

	PMsiServices pServices(riEngine.GetServices());

	MsiString strParent = riEngine.GetPropertyFromSz(IPROPNAME_PARENTPRODUCTCODE);
	MsiString strProduct = riEngine.GetProductKey();
	MsiString strDummy;

	if (ProductHasBeenPublished(*pServices, strProduct, strParent))
	{
		AssertNonZero(GetClientInformation(*pServices, strProduct, strParent, rpistrRelativePath, *&strDummy));
		return 0;
	}
	else
	{
		IMsiRecord* piErrRec;
		PMsiServices piServices(riEngine.GetServices()); 
		PMsiPath pPath(0), pParentPath(0);
		MsiString istrFileName;
		if (((piErrRec =  piServices->CreateFilePath(MsiString(riEngine.GetPropertyFromSz(IPROPNAME_PARENTORIGINALDATABASE)),*&pParentPath,*&istrFileName)) != 0) ||
			 ((piErrRec = piServices->CreateFilePath(istrDatabase, *&pPath, *&istrFileName)) != 0))
		{
			return piErrRec;
		}

		//!! validation needs to ensure that the child package locations is in the same directory or a subdir of the one that the parent is in
	#ifdef DEBUG
		ipcEnum ipc;
		AssertRecord(pParentPath->Compare(*pPath, ipc));
		AssertSz(ipc == ipcChild || ipc == ipcEqual, "Child package must be in the same directory, or in a subdirectory, as the parent package");
	#endif	

		return piErrRec = pPath->Child(*pParentPath, rpistrRelativePath);
	}
}


iesEnum CreatePublishProductRecord(IMsiEngine& riEngine, bool fUnpublish, IMsiRecord*& pPublishRecord)
{
	iesEnum iesRet = iesSuccess;
	PMsiServices piServices(riEngine.GetServices()); 
	PMsiRecord pError(0);

	Assert(IxoProductPublish::PackageKey == IxoProductUnpublish::PackageKey);

	// ixoProductPublish
	// Record description
	// package key
	// transform name1
	// transform data1 (if file transform)
	// transform name2
	// transform data2 (if file transform)
	// ...
	// ...
	
	MsiString strTransformList(riEngine.GetPropertyFromSz(IPROPNAME_TRANSFORMS));

	// Create a record large enough to hold all of the transforms that are in our list.
	const ICHAR* pchTransformList = strTransformList;
	int cCount = 0;
	while(*pchTransformList != 0)
	{
		cCount++;
		while((*pchTransformList != 0) && (*pchTransformList++ != ';'));
	}
	pPublishRecord = &piServices->CreateRecord(IxoProductPublish::PackageKey+cCount*2); // max possible record size

	AssertNonZero(pPublishRecord->SetMsiString(IxoProductPublish::PackageKey,*MsiString(riEngine.GetPropertyFromSz(IPROPNAME_PACKAGECODE))));

	// There's nothing more to do if we're unpublishing. We rely on the transforms
	// information that's in the registry to unpublish. We'll grab the info out
	// of the registry in the executor. Why not here? Because when we unpublish
	// a product during app deployment we'll need to be able to grab the transforms
	// list from the registry to unpublish the product. Therefore it needs to be in 
	// the executor.
	
	if (!fUnpublish)
	{
		cCount = IxoProductPublish::PackageKey + 1;
		
		bool fTransformsSecure = false;

		while(strTransformList.TextSize() != 0)
		{
			MsiString strTransform = strTransformList.Extract(iseUpto, ';');
			
			ICHAR chFirst = *(const ICHAR*)strTransform;
			
			if (cCount == IxoProductPublish::PackageKey + 1) // first transform
			{
				// The token preceding the first transform tells us whether
				// we're dealing with secure transforms or not.
				if (chFirst == SECURE_RELATIVE_TOKEN || 
					 chFirst == SECURE_ABSOLUTE_TOKEN)
				{
					fTransformsSecure = true;
				}
			}

			// For the purposes of this code we have two kinds of transforms:
			// Those that we store just the name, and those that we store
			// the name plus the data. Secure and storage transforms are of the
			// first kind and regular cached file transforms are of the second 
			// kind. We store the data for cached file transforms in the script
			// so that the transforms can be spit onto the machine during
			// app deployment. Although we also cache secure transforms, we
			// do not do so at advertise time and therefore do not need
			// to put them into the script.

			if((chFirst == STORAGE_TOKEN) ||
				(fTransformsSecure))
			{
				// unless we're publishing the product for the 2nd time
				// (which we never should be) we should never see a 
				// ShellFolder token here.
				Assert(chFirst != SHELLFOLDER_TOKEN); 
																	
				pPublishRecord->SetMsiString(cCount++, *strTransform);
			}
			else // transform is a cached file transform
			{
				// FUTURE: Consider using a smart cache manager that would prevent multiple downloads by asking
				//         the cache manager for the location of the downloaded file (if already downloaded).
				//         Accessing the file here is done directly without ever looking at a local copy. If the
				//         network were to fail, we'd still have problems with transforms at \\server\share paths.
				//         We should consider using a smart cache manager for all files, including the temp copies
				//         we make to cover wireless scenarios where network drops can happen frequently.

				bool fNet = false;

				MsiString strActualTransform(strTransform);

				if ((fNet = FIsNetworkVolume(strTransform)) == true)
					MsiDisableTimeout();

				bool fFileUrl = false;
				bool fUrl = false;
				bool fUsedWinHttp = true;
				CDeleteUrlLocalFileOnClose cDeleteUrlLocalFileOnClose; // set later with filename to delete

				fUrl = IsURL(strTransform, fFileUrl);
				if (fUrl)
				{
					if (fFileUrl)
					{
						// canonicalize and convert to DOS path
						CTempBuffer<ICHAR, 1> rgchFilePath(cchExpectedMaxPath+1);
						DWORD cchFilePath = rgchFilePath.GetSize();

						// if this fails, we'll simply let this fall through to the piServices->CreateFileStream.
						// it will create an appropriate error

						if (MsiConvertFileUrlToFilePath(strTransform, rgchFilePath, &cchFilePath, 0))
						{
							strActualTransform = static_cast<const ICHAR*>(rgchFilePath);
						}
					}
					else
					{
						// download file
						//     on .NET Server and greater, we're less likely to incur the expensive
						//     download and loss of network issues here given that the default behavior is to now
						//     use secure transforms

						MsiString strCache;
						DWORD dwRet = DownloadUrlFile(strTransform, *&strCache, fUrl, /* cTicks = */ 0, &fUsedWinHttp);

						// if the file isn't found, we'll simply let this fall through to the piServices->CreateFileStream.
						// it will create an appropriate error.

						if (fUrl && (ERROR_SUCCESS == dwRet))
						{
							if (fUsedWinHttp)
							{
								// only handle cleanup w/ winhttp downloads where we control file location
								cDeleteUrlLocalFileOnClose.SetFileName(*strCache, /* fDeleteFromIECache = */ !fUsedWinHttp);
							}
							strActualTransform = strCache;
						}
					}
				}

				if (fNet)
					MsiEnableTimeout();

				pPublishRecord->SetMsiString(cCount++, *strTransform);

				// stick the transform into the script
				PMsiStream pStream(0);
				if(pError = piServices->CreateFileStream(strActualTransform, fFalse, *&pStream))
				{
					Assert(0); // we should have already found the transform in Engine.Initialize.
					return riEngine.FatalError(*pError);
				}

				pPublishRecord->SetMsiData(cCount++, pStream);
			}

			strTransformList.Remove(iseFirst, strTransform.CharacterCount());
			if((*(const ICHAR*)strTransformList == ';'))
				strTransformList.Remove(iseFirst, 1);
		}
	}
	return iesRet;
}

iesEnum PublishProduct(IMsiEngine& riEngine)
{
	iesEnum iesRet = iesSuccess;
	int fMode = riEngine.GetMode();
	PMsiServices piServices(riEngine.GetServices()); 
	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiView piView(0);
	PMsiRecord pExecuteRecord(0);
	PMsiRecord pFetchRecord(0);
	PMsiRecord pError(0);
	Bool fFeaturesInstalled = FFeaturesInstalled(riEngine);
	Bool fProductHasBeenPublished = ProductHasBeenPublished(*piServices, MsiString(riEngine.GetProductKey()));

	// write the AdvtFlags
	if(fProductHasBeenPublished && !(riEngine.GetMode() & iefAdvertise) && fFeaturesInstalled && ((fMode & iefInstallShortcuts) || (fMode & iefInstallMachineData)))
	{
		// get the AdvtFlags
		int iADVTFlagsExisting = 0;
		int iADVTFlags = 0;
		MsiString strProductCode = riEngine.GetProductKey();
		CTempBuffer<ICHAR, 15> rgchADVTFlags;
		if(GetProductInfo(strProductCode,INSTALLPROPERTY_ADVTFLAGS,rgchADVTFlags))
			iADVTFlagsExisting = MsiString(*(ICHAR* )rgchADVTFlags);

		//!! backward compatibility 
		if(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_APPINFO_OLD)
			iADVTFlagsExisting = (iADVTFlagsExisting & ~SCRIPTFLAGS_REGDATA_APPINFO_OLD) | SCRIPTFLAGS_REGDATA_APPINFO;

		if((fMode & iefInstallShortcuts) && !(iADVTFlagsExisting & SCRIPTFLAGS_SHORTCUTS))
			iADVTFlags |= SCRIPTFLAGS_SHORTCUTS;

		if((fMode & iefInstallMachineData) && (!(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_CLASSINFO) || !(iADVTFlagsExisting & SCRIPTFLAGS_REGDATA_EXTENSIONINFO)))
			iADVTFlags |= SCRIPTFLAGS_REGDATA_APPINFO;

		if(iADVTFlags)
		{
			// need to write the updated AdvtFlags
			using namespace IxoAdvtFlagsUpdate;
			PMsiRecord pExecuteRecord = &piServices->CreateRecord(Args);
			pExecuteRecord->SetInteger(Flags, iADVTFlags | iADVTFlagsExisting);
			if ((iesRet = riEngine.ExecuteRecord(ixoAdvtFlagsUpdate, *pExecuteRecord)) != iesSuccess)
				return iesRet;
		}
	}
	bool fPublishProduct = ((riEngine.GetMode() & iefAdvertise) || ((!fProductHasBeenPublished) && (fFeaturesInstalled)));

	MsiString strReinstall = riEngine.GetPropertyFromSz(IPROPNAME_REINSTALL);

	if (((fMode & iefInstallShortcuts) || (fMode & iefInstallMachineData)) && (strReinstall.TextSize() || fPublishProduct))
	{
		// do icons
		// ixoIconCreate
		// Record description
		// 1 = IconName // includes the file extension since this could be .ICO or .EXE or .DLL
		// 2 = IconData

		pError = riEngine.OpenView(sqlAdvertiseIcons, ivcFetch, *&piView);
		if (!pError)
		{
			if (!(pError = piView->Execute(0)))
			{
				while (pFetchRecord = piView->Fetch())
				{
					PMsiData pData = pFetchRecord->GetMsiData(2);
					if(!pData || 0 == pData->GetIntegerValue())
					{
						pError = PostError(Imsg(idbgStreamNotFoundInRecord),
										  *MsiString(TEXT("Icon.Data")),
										  *MsiString(pFetchRecord->GetMsiString(1)));
						return riEngine.FatalError(*pError);
					}
					
					using namespace IxoIconCreate;
					pExecuteRecord = &piServices->CreateRecord(Args);
					pExecuteRecord->SetMsiString(Icon, *MsiString(pFetchRecord->GetMsiString(1)));
					pExecuteRecord->SetMsiData(Data, pData);
					if ((iesRet = riEngine.ExecuteRecord(ixoIconCreate, *pExecuteRecord)) != iesSuccess)
						return iesRet;
				}
			}
			else
			{
				return riEngine.FatalError(*pError);
			}

		}
		else // pError != 0
		{
			if (pError->GetInteger(1) != idbgDbQueryUnknownTable)
			{
				return riEngine.FatalError(*pError);
			}
		}
	}

	if(fFeaturesInstalled && (fMode & iefRecachePackage))
	{
		if (MsiString(riEngine.GetPropertyFromSz(IPROPNAME_PACKAGECODE_CHANGING)).TextSize() != 0)
		{
			using namespace IxoPackageCodePublish;
			MsiString strPackageCode = riEngine.GetPropertyFromSz(IPROPNAME_PACKAGECODE);

			pExecuteRecord = &piServices->CreateRecord(Args);
			pExecuteRecord->SetMsiString(PackageKey, *strPackageCode);		

			if((iesRet = riEngine.ExecuteRecord(Op, *pExecuteRecord)) != iesSuccess)
				return iesRet;
		}
	}

	if(!(fMode & iefInstallMachineData))
		return iesSuccess;

	// register and cache any patches that need it
	// now we are safe to try to open the view
	if(fPublishProduct || fFeaturesInstalled)
	{
		if((pError = riEngine.OpenView(sqlRegisterPatchPackages, ivcFetch, *&piView)) == 0 &&
			(pError = piView->Execute(0)) == 0)
		{		
			while((pFetchRecord = piView->Fetch()) != 0)
			{
				MsiString strPatchId = pFetchRecord->GetMsiString(sppPatchId);
				MsiString strPackageName = pFetchRecord->GetMsiString(sppPackageName);
				Assert(strPatchId.TextSize());
				if(pFetchRecord->GetInteger(sppUnregister) == 1) // Unregister column
				{
					// need to unregister this patch
					pExecuteRecord = &piServices->CreateRecord(2); // for ixoPatchUnregister and ixoSourceListUnpublish
					AssertNonZero(pExecuteRecord->SetMsiString(1,*strPatchId));
					AssertNonZero(pExecuteRecord->SetMsiString(2,*MsiString(riEngine.GetPropertyFromSz(IPROPNAME_UPGRADINGPRODUCTCODE))));
					if((iesRet = riEngine.ExecuteRecord(ixoPatchUnregister,*pExecuteRecord)) != iesSuccess)
						return iesRet;
					if((iesRet = riEngine.ExecuteRecord(ixoSourceListUnpublish,*pExecuteRecord)) != iesSuccess)
						return iesRet;

				}
				else
				{
					bool fExisting = pFetchRecord->GetInteger(sppExisting) == 1;
					// need to register this patch if this is a new patch (!fExisting)
					// or this product hasn't been published yet and existing patches must be added
					// in the latter case we won't register the source list since it is already registered
					if(!fExisting || fPublishProduct)
					{
						// need to register this patch
						Assert(strPatchId.TextSize());
						Assert(!pFetchRecord->IsNull(sppTransformList));
						pExecuteRecord = &piServices->CreateRecord(IxoPatchRegister::Args);
						AssertNonZero(pExecuteRecord->SetMsiString(IxoPatchRegister::PatchId,*strPatchId));
						AssertNonZero(pExecuteRecord->SetMsiString(IxoPatchRegister::TransformList,*MsiString(pFetchRecord->GetMsiString(sppTransformList))));

						if((iesRet = riEngine.ExecuteRecord(ixoPatchRegister,*pExecuteRecord)) != iesSuccess)
							return iesRet;

						if(!fExisting)
						{
							// new patch - register source list
							MsiString strSourceList = pFetchRecord->GetMsiString(sppSourceList);
							MsiString strPackagePath = pFetchRecord->GetMsiString(sppSourcePath);
							MsiString strFileName;
							
							PMsiPath pPatchPath(0);
							if ((pError = piServices->CreateFilePath(strPackagePath, *&pPatchPath, *&strFileName)) == 0)
							{
								strPackagePath.Remove(iseLast, strFileName.CharacterCount());
							}

							if ((iesRet = PublishSourceList(riEngine, *strSourceList, strPatchId, sqlPatchMediaInformation, strPackagePath, strPackageName)) != iesSuccess)
								return iesRet;
						}
					}

					MsiString strTempCopy = pFetchRecord->GetMsiString(sppTempCopy);
					if(strTempCopy.TextSize())
					{
						// need to cache this patch
						pExecuteRecord = &piServices->CreateRecord(IxoPatchCache::Args);
						AssertNonZero(pExecuteRecord->SetMsiString(IxoPatchCache::PatchId,*strPatchId));
						AssertNonZero(pExecuteRecord->SetMsiString(IxoPatchCache::PatchPath,*strTempCopy));

						if((iesRet = riEngine.ExecuteRecord(ixoPatchCache,*pExecuteRecord)) != iesSuccess)
							return iesRet;
					}
				}
			}	
		}
		else if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
		{
			return riEngine.FatalError(*pError);
		}
		// else no error
	}

	if (fPublishProduct)
	{
		// advertise product
		// we advertise product and output the icons if
		// 1. we are operating in the advertise mode OR
		// 2. we have not advertised on this m/c.

		
		if ((iesRet = CreatePublishProductRecord(riEngine, false, *&pExecuteRecord)) != iesSuccess)
			return iesRet;

		if((iesRet = riEngine.ExecuteRecord(ixoProductPublish, *pExecuteRecord)) != iesSuccess)
			return iesRet;// error

		MsiString strUpgradeCode = riEngine.GetPropertyFromSz(IPROPNAME_UPGRADECODE);
		if(strUpgradeCode.TextSize())
		{
			pExecuteRecord = &piServices->CreateRecord(IxoUpgradeCodePublish::Args);
			AssertNonZero(pExecuteRecord->SetMsiString(IxoUpgradeCodePublish::UpgradeCode, *strUpgradeCode));

			if((iesRet = riEngine.ExecuteRecord(ixoUpgradeCodePublish, *pExecuteRecord)) != iesSuccess)
				return iesRet;// error
		}
	}
	else if (fFeaturesInstalled) // we're not publishing or unpublishing the product
										  // but may need to do some extra stuff anyway
	{

		if(MsiString(riEngine.GetPropertyFromSz(IPROPNAME_QFEUPGRADE)).TextSize() != 0)
		{
			// we didn't publish the product above, but we are patching or installing from a new package
			// so we use ixoProductPublishUpdate to register the new product name or version if
			// necessary

			DEBUGMSG(TEXT("Re-publishing product - installing new package with existing product code."));

			Assert(fProductHasBeenPublished);
			pExecuteRecord = &piServices->CreateRecord(0);
			if((iesRet = riEngine.ExecuteRecord(ixoProductPublishUpdate, *pExecuteRecord)) != iesSuccess)
				return iesRet;// error
		}
	}

	if (fFeaturesInstalled)
	{
		// we might have some transforms that need to be cached again. this happens
		// if someone deletes his cached transform. we need to copy it back
		// down from the source. we'll cheat and use ixoIconCreate because
		// it does what we want to do

		MsiString strRecache = riEngine.GetPropertyFromSz(IPROPNAME_RECACHETRANSFORMS);

		bool fTransformsSecure = MsiString(riEngine.GetPropertyFromSz(IPROPNAME_TRANSFORMSSECURE)).TextSize() != 0;
		strRecache += TEXT(";"); // helps our loop
		while(strRecache.TextSize())
		{
			MsiString strTransform = strRecache.Extract(iseUpto, ';');
			if(strTransform.TextSize())
			{
				ixoEnum ixo = ixoNoop;
				PMsiRecord pExecuteRecord(0);

				// obtain the actual transform data.  whereas before we would do this only for 
				// insecure transforms (those stored in user profile), we now do this for all.
				// For more info, see comment below.
				MsiString strActualTransform(strTransform);

				bool fNet = false;
				if ((fNet = FIsNetworkVolume(strTransform)) == true)
					MsiDisableTimeout();

				bool fFileUrl = false;
				bool fUrl = false;
				bool fUsedWinHttp = true;
				CDeleteUrlLocalFileOnClose cDeleteUrlLocalFileOnClose; // set later with filename to delete

				fUrl = IsURL(strTransform, fFileUrl);
				if (fUrl)
				{
					if (fFileUrl)
					{
						// canonicalize and convert to DOS path
						CTempBuffer<ICHAR, 1> rgchFilePath(cchExpectedMaxPath+1);
						DWORD cchFilePath = rgchFilePath.GetSize();

						// if this fails, we'll simply let this fall through to the piServices->CreateFileStream.
						// it will create an appropriate error

						if (MsiConvertFileUrlToFilePath(strTransform, rgchFilePath, &cchFilePath, 0))
						{
							strActualTransform = static_cast<const ICHAR*>(rgchFilePath);
						}
					}
					else
					{
						// there is a potential for failure here in loss of network situations

						MsiString strCache;
						DWORD dwRet = DownloadUrlFile(strTransform, *&strCache, fUrl, /* cTicks = */ 0, &fUsedWinHttp);

						// if the file isn't found, we'll simply let this fall through to the piServices->CreateFileStream.
						// it will create an appropriate error.

						if (fUrl && (ERROR_SUCCESS == dwRet))
						{
							if (fUsedWinHttp)
							{
								// only handle cleanup w/ winhttp downloads where we control file location
								cDeleteUrlLocalFileOnClose.SetFileName(*strCache, /* fDeleteFromIECache = */ !fUsedWinHttp);
							}
							strActualTransform = strCache;
						}
					}
				}

				if (fNet)
					MsiEnableTimeout();

				PMsiStream pStream(0);
				if(pError = piServices->CreateFileStream(strActualTransform, fFalse, *&pStream))
				{
					return riEngine.FatalError(*pError);
				}


				// per bug 652617, it's possible to have a secure at source or full path transform that 
				// is located on removable media.  In an install that uses multiple disks, the caching
				// of the secure transform will fail because the transform will be on disk 1 when the
				// current disk is disk 2.  Rather than asking the user to swap disks (again), we
				// put the transform into the script for use

				if (fTransformsSecure)
				{
					using namespace IxoSecureTransformCache;
					pExecuteRecord = &piServices->CreateRecord(Args);

					ixo = ixoSecureTransformCache;
					pExecuteRecord->SetString(Transform, strTransform);

					// are the transforms full path or "at source" (relative)
					MsiString strTransforms = riEngine.GetProperty(*MsiString(*IPROPNAME_TRANSFORMS));
					if(*(const ICHAR*)strTransforms == SECURE_RELATIVE_TOKEN)
						pExecuteRecord->SetInteger(AtSource, 1);

					DEBUGMSG1(TEXT("Recaching secure transform: %s"), strTransform);

					pExecuteRecord->SetMsiData(Data, pStream);
				}
				else // non-secure transforms stored in user profile
				{
					PMsiPath pPath(0);
					MsiString strFileName;
					
					ixo = ixoIconCreate;
					if ((pError = piServices->CreateFilePath(strTransform, *&pPath, *&strFileName)))
					{
						riEngine.Message(imtInfo, *pError);
					}
					else
					{
						using namespace IxoIconCreate;
						pExecuteRecord = &piServices->CreateRecord(Args);

						// pass on only the file name
						pExecuteRecord->SetString(Icon, strFileName);

						DEBUGMSG1(TEXT("Recaching cached transform: %s"), strTransform);

						pExecuteRecord->SetMsiData(Data, pStream);
					}
				}

				if((iesRet = riEngine.ExecuteRecord(ixo, *pExecuteRecord)) != iesSuccess)
					return iesRet;
				
			}
			strRecache.Remove(iseIncluding, ';');
		}
	}

	MsiString strSource;
	MsiString strParent = riEngine.GetPropertyFromSz(IPROPNAME_PARENTPRODUCTCODE);

	MsiString strProductCode = riEngine.GetProductKey();

	bool fPublishClientInfo   = ((riEngine.GetMode() & iefAdvertise) || (!ProductHasBeenPublished(*piServices, strProductCode, strParent) && (fFeaturesInstalled)));

	if (fPublishClientInfo)
	{
		if ((strParent.TextSize() == 0) && fPublishClientInfo) // don't publish source lists for child installs
		{
			MsiString strSourceDir  = riEngine.GetPropertyFromSz(IPROPNAME_SOURCEDIR);
			if (!strSourceDir.TextSize())
			{
				riEngine.ResolveFolderProperty(*MsiString(*IPROPNAME_SOURCEDIR));
				strSourceDir  = riEngine.GetPropertyFromSz(IPROPNAME_SOURCEDIR);
			}
			riEngine.SetProperty(*MsiString(*IPROPNAME_SOURCEDIROLD), *strSourceDir);

			MsiString strPatchedProduct = riEngine.GetPropertyFromSz(IPROPNAME_PATCHEDPRODUCTCODE);
			MsiString strSourceList;
			if(strPatchedProduct.TextSize())
			{
				// need to migrate source list from another product - may have been saved already
				strSourceList = riEngine.GetPropertyFromSz(IPROPNAME_PATCHEDPRODUCTSOURCELIST);
				if(strSourceList.TextSize() == 0)
				{
					// source list not saved yet
					if ((iesRet = GetForeignSourceList(riEngine, *strPatchedProduct, *&strSourceList)) != iesSuccess)
						return iesRet;

					AssertNonZero(riEngine.SetProperty(*MsiString(IPROPNAME_PATCHEDPRODUCTSOURCELIST),
																  *strSourceList));
				}
			}
			else
			{
				strSourceList = riEngine.GetPropertyFromSz(IPROPNAME_SOURCELIST);
			}

			if ((iesRet = PublishSourceList(riEngine, *strSourceList, 0, sqlMediaInformation, strSourceDir)) != iesSuccess)
				return iesRet;
		}

		if (fPublishClientInfo)
		{
			{ // block for ProductPublishClient op
			// add client from client list
			using namespace IxoProductPublishClient;

			pExecuteRecord = &piServices->CreateRecord(Args);
			MsiString strRelativePath;
			if (strParent.TextSize())
			{
				if((pError = GetProductSourcePathRelativeToParent(riEngine, *&strRelativePath)) != 0)
					return riEngine.FatalError(*pError);
			}

			pExecuteRecord->SetMsiString(ChildPackagePath, *strRelativePath);
			pExecuteRecord->SetMsiString(Parent, *strParent);		
			//!! shouldn't we be passing DiskId here as well?

			if((iesRet = riEngine.ExecuteRecord(Op, *pExecuteRecord)) != iesSuccess)
				return iesRet;// error
			}// end ProductPublishClient block
		}
	}

	if(!(riEngine.GetMode() & iefAdvertise) && fFeaturesInstalled && /*!! temporary check - BENCH !!*/ strParent.TextSize() == 0 /*!!*/)
	{
		// Force source resolution if our original package is not a cached package.
		// If the original package is not a cached package then there's a chance
		// that it's a package path representing a source that's not in our source
		// list, thereby requiring addition to our source list. We don't want
		// to always resolve the source because source resolution is expensive if
		// our original package is the cached package -- we have to hit the source list
		// in this case.
		//
		// Note: we've already verified in Engine.Initialize that this new source is
		// allowed. Also, SetLastUsedSource will verify this again.

		MsiString strOriginalDbPath = riEngine.GetPropertyFromSz(IPROPNAME_ORIGINALDATABASE);

		if(!IsCachedPackage(riEngine, *strOriginalDbPath))
		{
			if((iesRet == ResolveSource(riEngine)) != iesSuccess)
					return iesRet;
		}

		// Set the last used source for the product. This must be done after PublishSourceList
		MsiString strSource = riEngine.GetPropertyFromSz(IPROPNAME_SOURCEDIR);
		MsiString strSourceProduct;
		if(strParent.TextSize())
			strSourceProduct = riEngine.GetPropertyFromSz(IPROPNAME_SOURCEDIRPRODUCT);
		else
			strSourceProduct = riEngine.GetProductKey();

		if (!g_MessageContext.IsOEMInstall() && strSource.TextSize() && strSourceProduct.TextSize())
		{
			using namespace IxoSourceListRegisterLastUsed;
			PMsiRecord pLastUsedInfo(&CreateRecord(Args));
			pLastUsedInfo->SetMsiString(SourceProduct, *strSourceProduct);
			pLastUsedInfo->SetMsiString(LastUsedSource, *strSource);
			
			if ((iesRet = riEngine.ExecuteRecord(Op, *pLastUsedInfo)) != iesSuccess)
				return iesRet;
		}

		bool fFileUrl = false;
		if (!g_MessageContext.IsOEMInstall() && strSource.TextSize() && strSourceProduct.TextSize() && IsURL(strSource, fFileUrl))
		{
			// register source type for URLs so that we don't have to download the package repeatedly to determine its source
			int iSourceType = riEngine.GetDeterminedPackageSourceType();
			if (iSourceType != -1)
			{
				using namespace IxoURLSourceTypeRegister;
				PMsiRecord pURLSourceTypeInfo(&CreateRecord(Args));
				pURLSourceTypeInfo->SetMsiString(ProductCode, *strSourceProduct);
				pURLSourceTypeInfo->SetInteger(SourceType, iSourceType);
				
				if ((iesRet = riEngine.ExecuteRecord(Op, *pURLSourceTypeInfo)) != iesSuccess)
					return iesRet;
			}
		}
	}

	return iesRet;
}


/*---------------------------------------------------------------------------
	PublishFeatures action - 
---------------------------------------------------------------------------*/
iesEnum PublishFeatures(IMsiEngine& riEngine)
{
	iesEnum iesRet = iesSuccess;
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesRet;
	// publish the available and unavailable features
	if(((iesRet = ProcessFeaturesInfo(riEngine, pfiAvailable)) != iesSuccess))
		return iesRet;
	if((fMode & iefAdvertise) || FFeaturesInstalled(riEngine))
		iesRet = ProcessFeaturesInfo(riEngine, pfiAbsent);
	return iesRet;
}


/*---------------------------------------------------------------------------
	UnpublishFeatures action - 
---------------------------------------------------------------------------*/
iesEnum UnpublishFeatures(IMsiEngine& riEngine)
{
	// unpublish all features, available or not
	PMsiServices piServices(riEngine.GetServices()); 
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData) || (fMode & iefAdvertise) || (!ProductHasBeenPublished(*piServices, MsiString(riEngine.GetProductKey()))) || FFeaturesInstalled(riEngine))
		return iesSuccess;
	return ProcessFeaturesInfo(riEngine, pfiRemove);
}

/*---------------------------------------------------------------------------
	PublishComponents action - 
---------------------------------------------------------------------------*/
iesEnum PublishComponents(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessComponentsInfo(riEngine, fFalse);
}

/*---------------------------------------------------------------------------
	UnpublishComponents action - 
---------------------------------------------------------------------------*/
iesEnum UnpublishComponents(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessComponentsInfo(riEngine, fTrue);
}


/*---------------------------------------------------------------------------
	UnpublishProduct action - 
---------------------------------------------------------------------------*/
// we unadvertise information from the configuration manager
iesEnum UnpublishProduct(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;

	PMsiServices piServices(riEngine.GetServices());
	PMsiView piView(0);
	PMsiRecord pFetchRecord(0);
	PMsiRecord pExecuteRecord(0);
	PMsiRecord pError(0);
	iesEnum iesRet = iesSuccess;

	// unregister all patches, if last client going away
	Bool fFeaturesInstalled = FFeaturesInstalled(riEngine);
	Bool fProductPublished  = ProductHasBeenPublished(*piServices, MsiString(riEngine.GetProductKey()), 0);
	if(!fFeaturesInstalled && fProductPublished)
	{
		if((pError = riEngine.OpenView(sqlUnregisterPatchPackages, ivcFetch, *&piView)) == 0 &&
			(pError = piView->Execute(0)) == 0)
		{
			while((pFetchRecord = piView->Fetch()) != 0)
			{
				MsiString strPatchId = pFetchRecord->GetMsiString(1); //!!
				// need to unregister this patch
				pExecuteRecord = &piServices->CreateRecord(2); // for ixoPatchUnregister and ixoSourceListUnpublish
				AssertNonZero(pExecuteRecord->SetMsiString(1,*strPatchId));
				AssertNonZero(pExecuteRecord->SetMsiString(2,*MsiString(riEngine.GetPropertyFromSz(IPROPNAME_UPGRADINGPRODUCTCODE))));
				if((iesRet = riEngine.ExecuteRecord(ixoPatchUnregister,*pExecuteRecord)) != iesSuccess)
					return iesRet;
				if((iesRet = riEngine.ExecuteRecord(ixoSourceListUnpublish,*pExecuteRecord)) != iesSuccess)
					return iesRet;
			}
		}
		else if(pError->GetInteger(1) != idbgDbQueryUnknownTable)
			return riEngine.FatalError(*pError);

		// Unadvertise product

		if ((iesRet = CreatePublishProductRecord(riEngine, true, *&pExecuteRecord)) != iesSuccess)
			return iesRet;

		if((iesRet = riEngine.ExecuteRecord(ixoProductUnpublish, *pExecuteRecord)) != iesSuccess)
			return iesRet;// error

		MsiString strUpgradeCode = riEngine.GetPropertyFromSz(IPROPNAME_UPGRADECODE);
		if(strUpgradeCode.TextSize())
		{
			pExecuteRecord = &piServices->CreateRecord(IxoUpgradeCodeUnpublish::Args);
			AssertNonZero(pExecuteRecord->SetMsiString(IxoUpgradeCodeUnpublish::UpgradeCode, *strUpgradeCode));

			if((iesRet = riEngine.ExecuteRecord(ixoUpgradeCodeUnpublish, *pExecuteRecord)) != iesSuccess)
				return iesRet;// error
		}

		// ixoIconCreate
		// Record description
		// 1 = IconName // includes the file extension since this could be .ICO or .EXE or .DLL
		// 2 = IconData

		pError = riEngine.OpenView(sqlAdvertiseIcons, ivcFetch, *&piView);
		if (!pError)
		{
			if (!(pError = piView->Execute(0)))
			{
				const ICHAR sqlPermanentClass[] = 
						TEXT("SELECT `CLSID` FROM `Class` WHERE ")
						TEXT("`Icon_`=? AND `Class`.`Attributes`=1");
#define COMPONENT_PRESENT	TEXT(" (`Component`.`Installed` <> 0 AND `Component`.`Action` <> 0)")
				const ICHAR sqlComponentViaShortcut[] = 
						TEXT("SELECT `Component`,`Shortcut`,`Target` FROM `Component`,`Shortcut` WHERE ")
						TEXT("`Component`=`Component_` AND `Icon_`=? AND ")
						COMPONENT_PRESENT;
				const ICHAR sqlComponentViaClass[] = 
						TEXT("SELECT `Component`,`CLSID` FROM `Component`,`Class` WHERE ")
						TEXT("`Component`=`Component_` AND `Icon_`=? AND ")
						COMPONENT_PRESENT;
				const ICHAR sqlComponentViaExtension[] = 
						TEXT("SELECT `Component`,`Extension` FROM `Component`,`Extension`,`ProgId` WHERE ")
						TEXT("`Component`.`Component`=`Extension`.`Component_` AND ")
						TEXT("`ProgId`.`ProgId`=`Extension`.`ProgId_` AND ")
						TEXT("`ProgId`.`Icon_`=? AND ")
						COMPONENT_PRESENT;
#undef COMPONENT_PRESENT
				PMsiView piClassView1(0);
				pError = riEngine.OpenView(sqlPermanentClass, ivcFetch, *&piClassView1);
				if ( pError )
				{
					int iError = pError->GetInteger(1);
					if ( iError != idbgDbQueryUnknownColumn &&
						  iError != idbgDbQueryUnknownTable )
						//  we're dealing with a database that does not have either
						//  the Class.Attributes column or the Class table.
						return riEngine.FatalError(*pError);  // is this the right thing to to?
				}

				PMsiView piShortcutView(0);
				pError = riEngine.OpenView(sqlComponentViaShortcut, ivcFetch, *&piShortcutView);
				if ( pError && pError->GetInteger(1) != idbgDbQueryUnknownTable )
					return riEngine.FatalError(*pError);  // is this the right thing to to?

				PMsiView piClassView2(0);
				pError = riEngine.OpenView(sqlComponentViaClass, ivcFetch, *&piClassView2);
				if ( pError && pError->GetInteger(1) != idbgDbQueryUnknownTable )
					return riEngine.FatalError(*pError);  // is this the right thing to to?

				PMsiView piExtensionView(0);
				pError = riEngine.OpenView(sqlComponentViaExtension, ivcFetch, *&piExtensionView);
				if ( pError && pError->GetInteger(1) != idbgDbQueryUnknownTable )
					return riEngine.FatalError(*pError);  // is this the right thing to to?

				PMsiView piFeatureView(0);
				MsiString strTemp = riEngine.GetPropertyFromSz(IPROPNAME_DISABLEADVTSHORTCUTS);
				if ( IsDarwinDescriptorSupported(iddShell) &&
					  (strTemp.TextSize() == 0) )
				{
					//  advertised shortcuts are supported.
					const ICHAR sqlGetFeature[] = 
						TEXT("SELECT `Feature` FROM `Feature` WHERE `Feature`=?");
					pError = riEngine.OpenView(sqlGetFeature, ivcFetch, *&piFeatureView);
					if ( pError && pError->GetInteger(1) != idbgDbQueryUnknownTable )
						return riEngine.FatalError(*pError);  // is this the right thing to to?
				}

				PMsiRecord pParamRec = &piServices->CreateRecord(1);

				while (pFetchRecord = piView->Fetch())
				{
					//  check first if we should leave the icon file behind.
					MsiString strIconName(pFetchRecord->GetMsiString(1));
					pParamRec->SetMsiString(1, *strIconName);

					if ( piClassView1 &&
						  (pError = piClassView1->Execute(pParamRec)) == 0 &&
						  (pError = piClassView1->Fetch()) != 0 )
						//  the class stays => the icon should stay too.
					{
						DEBUGMSG2(TEXT("'%s' class is marked permanent, so that ")
									 TEXT("'%s' icon will not be removed."),
									 pError->GetString(1), strIconName);
						continue;
					}
					if ( piClassView2 &&
						  (pError = piClassView2->Execute(pParamRec)) == 0 &&
						  (pError = piClassView2->Fetch()) != 0 )
						//  the component stays => the icon should stay too.
					{
						DEBUGMSG3(TEXT("'%s' class', '%s' component will not be removed, ")
									 TEXT("so that '%s' icon will not be removed."),
									 pError->GetString(2), pError->GetString(1), strIconName);
						continue;
					}
					if ( piExtensionView &&
						  (pError = piExtensionView->Execute(pParamRec)) == 0 &&
						  (pError = piExtensionView->Fetch()) != 0 )
						//  the component stays => the icon should stay too.
					{
						DEBUGMSG3(TEXT("'%s' extension's, '%s' component will not be ")
									 TEXT("removed, so that '%s' icon will not be removed."),
									 pError->GetString(2), pError->GetString(1), strIconName);
						continue;
					}
					if ( piShortcutView &&
						  (pError = piShortcutView->Execute(pParamRec)) == 0 &&
						  (pError = piShortcutView->Fetch()) != 0 )
					{
						//  shortcuts need one more check before deciding if the
						//  icon should stay: if it is authored as an advertised
						//  shortcut then the icon will go.
						bool fIconStays = true;
						if ( piFeatureView )
						{
							// advertised shortcuts are supported.
							pParamRec->SetMsiString(1, *MsiString(pError->GetMsiString(3)));
							PMsiRecord pRec = piFeatureView->Execute(pParamRec);
							if ( pRec == 0 && (pRec = piFeatureView->Fetch()) != 0 )
								//  it's an advertised shortcut => the icon goes
								fIconStays = false;
						}
						if ( fIconStays )
						{
							DEBUGMSG3(TEXT("'%s' shortcut's, '%s' component will not be ")
										 TEXT("removed, so that '%s' icon will not be removed."),
										 pError->GetString(2), pError->GetString(1), strIconName);
							continue;
						}
						else
							DEBUGMSG2(TEXT("'%s' shortcut is advertised, so that '%s' ")
										 TEXT("icon will be removed."),
										 pError->GetString(2), strIconName);
					}
					else
						DEBUGMSG1(TEXT("'%s' icon will be removed."), strIconName);

					using namespace IxoIconRemove;
					pExecuteRecord = &piServices->CreateRecord(Args);
					pExecuteRecord->SetMsiString(Icon, *strIconName);
					// following may be passed as blank.
					// piIconRec->SetMsiData(Data, PMsiData(pFetchRecord->GetMsiData(2)));
					if ((iesRet = riEngine.ExecuteRecord(ixoIconRemove, *pExecuteRecord)) != iesSuccess)
						return iesRet;				
				}
			}
			else
			{
				return riEngine.FatalError(*pError);
			}

		}
		else // pError != 0
		{
			if (pError->GetInteger(1) != idbgDbQueryUnknownTable)
			{
				return riEngine.FatalError(*pError);
			}
		}

	} 
	
	MsiString strParent = riEngine.GetPropertyFromSz(IPROPNAME_PARENTPRODUCTCODE);
	Bool fFeaturesInstalled2 = FFeaturesInstalled(riEngine, fFalse);
	Bool fProductPublished2  = ProductHasBeenPublished(*piServices, MsiString(riEngine.GetProductKey()), strParent);
	if(!fFeaturesInstalled2 && fProductPublished2)
	{
		{ // block for ProductUnpublishClient op
		// remove client from client list
		using namespace IxoProductUnpublishClient;
		pExecuteRecord = &piServices->CreateRecord(Args);

		MsiString strRelativePath;
		if (strParent.TextSize())
		{
			if((pError = GetProductSourcePathRelativeToParent(riEngine, *&strRelativePath)) != 0)
				return riEngine.FatalError(*pError);
		}

		pExecuteRecord->SetMsiString(ChildPackagePath, *strRelativePath);
		pExecuteRecord->SetMsiString(Parent, *strParent);		
		if((iesRet = riEngine.ExecuteRecord(Op, *pExecuteRecord)) != iesSuccess)
			return iesRet;// error
		}// end block for ProductUnpublishClient op

		if(!strParent.TextSize()) // the source list goes away when the standalone instance of the product is being removed
		{
			using namespace IxoSourceListUnpublish;
			AssertNonZero(pExecuteRecord->ClearData());
			if((iesRet = riEngine.ExecuteRecord(Op, *pExecuteRecord)) != iesSuccess)
				return iesRet;// error
		}
	}
	return iesSuccess;
}

/*---------------------------------------------------------------------------
	RegisterClassInfo action - 
---------------------------------------------------------------------------*/
iesEnum RegisterClassInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessClassInfo(riEngine, fFalse);
}

/*---------------------------------------------------------------------------
	UnregisterClassInfo action - 
---------------------------------------------------------------------------*/
iesEnum UnregisterClassInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessClassInfo(riEngine, fTrue);
}

/*---------------------------------------------------------------------------
	RegisterProgIdInfo action - 
---------------------------------------------------------------------------*/
iesEnum RegisterProgIdInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	iesEnum iesRet = ProcessProgIdInfo(riEngine, fFalse);
	if(iesRet != iesSuccess)
		return iesRet;
	return ProcessProgIdInfoExt(riEngine, fFalse);
}

/*---------------------------------------------------------------------------
	UnregisterProgIdInfo action - 
---------------------------------------------------------------------------*/
iesEnum UnregisterProgIdInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	iesEnum iesRet = ProcessProgIdInfo(riEngine, fTrue);
	if(iesRet != iesSuccess)
		return iesRet;
		return ProcessProgIdInfoExt(riEngine, fTrue);
}


/*---------------------------------------------------------------------------
	RegisterMIMEInfo action - 
---------------------------------------------------------------------------*/
iesEnum RegisterMIMEInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessMIMEInfo(riEngine, fFalse);
}

/*---------------------------------------------------------------------------
	UnregisterMIMEInfo action - 
---------------------------------------------------------------------------*/
iesEnum UnregisterMIMEInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessMIMEInfo(riEngine, fTrue);
}


/*---------------------------------------------------------------------------
	RegisterExtensionInfo action - 
---------------------------------------------------------------------------*/
iesEnum RegisterExtensionInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessExtensionInfo(riEngine, fFalse);
}

/*---------------------------------------------------------------------------
	UnregisterExtensionInfo action - 
---------------------------------------------------------------------------*/
iesEnum UnregisterExtensionInfo(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessExtensionInfo(riEngine, fTrue);
}

/*---------------------------------------------------------------------------
	CreateShortcuts action - 
---------------------------------------------------------------------------*/
iesEnum CreateShortcuts(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallShortcuts))
		return iesSuccess;

	iesEnum iesRet = ProcessShortcutInfo(riEngine, fFalse); // advertised shortcuts
	if((iesRet != iesSuccess) || (fMode & iefAdvertise))
		return iesRet;
	return ProcessShortcutInfo(riEngine, fFalse, fFalse); // non-advertised shortcuts
}

/*---------------------------------------------------------------------------
	RemoveShortcuts action - 
---------------------------------------------------------------------------*/
iesEnum RemoveShortcuts(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallShortcuts))
		return iesSuccess;
	iesEnum iesRet = ProcessShortcutInfo(riEngine, fTrue); // advertised shortcuts
	if(iesRet != iesSuccess)
		return iesRet;
	return ProcessShortcutInfo(riEngine, fTrue, fFalse); // non-advertised shortcuts
}

/*---------------------------------------------------------------------------
	RegisterTypeLibraries action - 
---------------------------------------------------------------------------*/
iesEnum RegisterTypeLibraries(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessTypeLibraryInfo(riEngine, fFalse);
}

/*---------------------------------------------------------------------------
	UnregisterTypeLibraries action - 
---------------------------------------------------------------------------*/
iesEnum UnregisterTypeLibraries(IMsiEngine& riEngine)
{
	int fMode = riEngine.GetMode();
	if(!(fMode & iefInstallMachineData))
		return iesSuccess;
	return ProcessTypeLibraryInfo(riEngine, fTrue);
}

/*---------------------------------------------------------------------------
	AllocateRegistrySpace action - 
---------------------------------------------------------------------------*/
iesEnum AllocateRegistrySpace(IMsiEngine& riEngine)
{
	// validate that the registry has enough free space, if a desired size requested
	int iIncrementKB = 	riEngine.GetPropertyInt(*MsiString(*IPROPNAME_AVAILABLEFREEREG));
	if(iIncrementKB != iMsiNullInteger)
	{
		using namespace IxoRegAllocateSpace;

		PMsiServices piServices(riEngine.GetServices());
		PMsiRecord pSetRegistrySizeRec = &piServices->CreateRecord(Args);

		pSetRegistrySizeRec->SetInteger(Space, iIncrementKB);

		return riEngine.ExecuteRecord(ixoRegAllocateSpace,*pSetRegistrySizeRec);
	}
	return iesSuccess;
}

/*---------------------------------------------------------------------------
	ResolveSource action - 

	Ensure that the properties SOURCEDIR and SourcedirProduct are set
---------------------------------------------------------------------------*/
iesEnum ResolveSource(IMsiEngine& riEngine)
{
	PMsiPath   pPath(0);	
	PMsiDirectoryManager pDirectoryMgr(riEngine, IID_IMsiDirectoryManager);
	PMsiRecord pErrRec = ENG::GetSourcedir(*pDirectoryMgr, *&pPath);
	if (pErrRec)
	{
		if (pErrRec->GetInteger(1) == imsgUser)
			return iesUserExit;
		else
			return riEngine.FatalError(*pErrRec);
	}
	return iesSuccess; 
}

/*---------------------------------------------------------------------------
	ACL Generation -- used by several actions, but not an action by itself
---------------------------------------------------------------------------*/
BOOL AllocateAndInitializeUserSid (const ICHAR* szUser, PSID *Sid, DWORD &cbSid)
{
	
	// On foreign systems the "SYSTEM" account isn't under that name.
	// There is a separate API for looking it up.   However,
	// to avoid requiring localization of account names, and to conform
	// to our callers current conventions, we'll get called with "SYSTEM" and make
	// the correct translation.

	ICHAR        szDomain[MAX_PATH+1];
	DWORD        cbDomain = MAX_PATH; 
	SID_NAME_USE snu = SidTypeUnknown;
	cbSid = 0;

	BOOL fStatus = fTrue;

	// Guess at the size of a Sid.
	// If we get it wrong, we end up with two LookupAccountName calls, which is
	// *really* slow

	// On the other hand, if we allocate too big a buffer, the API isn't polite
	// enough to tell us how much we actually used.

	// The well known SIDs allocate their own buffer, so the resizing isn't needed.
	cbSid = 80;
	char SidBuffer[80];
	char* pSidBuffer = SidBuffer;
	Bool fWellKnown = fFalse;

	//   LookupAccountName is *reaaaaaalllly* slow.
	//   We cache what we can.

	MsiString strUser(szUser);

	DWORD dwRet = ERROR_SUCCESS;
	SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;

	if (strUser.Compare(iscExactI, TEXT("SYSTEM")))
	{
		DEBUGMSG("Using well known SID for System");
		fStatus = fWellKnown = fTrue;
		if (!AllocateAndInitializeSid(&sia, 1, SECURITY_LOCAL_SYSTEM_RID,0,0,0,0,0,0,0,(void**)&(pSidBuffer)))
			return fFalse;
	}
	else if (strUser.Compare(iscExactI, TEXT("Administrators")))
	{
		DEBUGMSG("Using well known SID for Administrators");
		fStatus = fWellKnown = fTrue;
		if (!AllocateAndInitializeSid(&sia, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,0,0,0,0,0,0,(void**)&(pSidBuffer)))
			return fFalse;
	}
	else if (strUser.Compare(iscExactI, TEXT("Everyone")))
	{
		DEBUGMSG("Using well known SID for Everyone");
		fStatus = fWellKnown = fTrue;

		SID_IDENTIFIER_AUTHORITY sia = SECURITY_WORLD_SID_AUTHORITY;
		if (!AllocateAndInitializeSid(&sia, 1, SECURITY_WORLD_RID,0,0,0,0,0,0,0,(void**)&(pSidBuffer)))
			return fFalse;
	}
   else 
	{

#ifdef DEBUG
		ICHAR rgchDebug[256];
		ASSERT_IF_FAILED(StringCchPrintf(rgchDebug, ARRAY_ELEMENTS(rgchDebug),
							 TEXT("Initializing new user SID for %s"), szUser));
		DEBUGMSG(rgchDebug);
#endif
		
		AssertNonZero(StartImpersonating());
		fStatus = WIN::LookupAccountName (NULL, szUser,(void*) SidBuffer, &cbSid, szDomain, &cbDomain, &snu);
		DWORD dwLastError = GetLastError();
		StopImpersonating();

		if (fStatus)
		{
			cbSid = WIN::GetSidLengthRequired(*WIN::GetSidSubAuthorityCount(SidBuffer));
		}
		else
		{
			if (dwLastError != ERROR_INSUFFICIENT_BUFFER)
			{
				WIN::SetLastError(dwLastError);
				return fFalse;
			}
		}
	}
	
	if (fWellKnown)
	{
		if (ERROR_SUCCESS == dwRet)
			cbSid = WIN::GetLengthSid(pSidBuffer);
		else return fFalse;
	}

	*Sid = (PSID) new byte[cbSid];
	Assert(Sid);

	cbDomain = MAX_PATH;

	if (fStatus)
	{
		AssertNonZero(WIN::CopySid(cbSid, *Sid, pSidBuffer));
	}
	else
	{
		AssertNonZero(StartImpersonating());
		fStatus = WIN::LookupAccountName (NULL, szUser, *Sid, &cbSid, szDomain, &cbDomain, &snu);
		StopImpersonating();
	}

	if (fWellKnown)
		FreeSid(pSidBuffer);

	Assert(WIN::IsValidSid(*Sid));
	Assert(WIN::GetLengthSid(*Sid) == cbSid);
	Assert(SidTypeInvalid != snu);

	//!! what to do if the snu maps to invalid or deleted users...
	DEBUGMSG("Finished allocating new user SID");
	return fStatus;
}

#ifndef ENSURE
#define ENSURE_DEFINED_LOCALLY
#define ENSURE(function) {	\
							IMsiRecord* piError;\
							piError = function;	\
							if (piError) \
								return piError; \
						 }
#endif
IMsiRecord* LookupSid(IMsiEngine& riEngine, const IMsiString& riUser, IMsiStream*& rpistrmSid)
{
	MsiString strSidCacheTable(TEXT("SidCache"));

	PSID psidUser;
	DWORD cbSid = 0;

	PMsiServices pServices = riEngine.GetServices();
	Assert(pServices);

	ICHAR szReferencedDomainName[MAX_PATH] = TEXT("");
	DWORD cbReferencedDomainName = MAX_PATH;

	PMsiDatabase pDatabase(riEngine.GetDatabase());
	PMsiTable ptblSidCache(0);
	PMsiRecord pError(0);
	if ((pError = pDatabase->LoadTable(*strSidCacheTable, 1, *&ptblSidCache)))
	{
		ENSURE(pDatabase->CreateTable(*strSidCacheTable,1,*&ptblSidCache));
		AssertNonZero(ptblSidCache->CreateColumn(icdString | icdPrimaryKey,*MsiString(*TEXT("USER"))));
		AssertNonZero(ptblSidCache->CreateColumn(icdObject, *MsiString(*TEXT("SIDBlob"))));

		// We want this table available during the entire script generation process.  Generating the 
		// Sids are *very* expensive.
		AssertNonZero(pDatabase->LockTable(*strSidCacheTable, fTrue));
	}

	PMsiCursor pcurSidCache = ptblSidCache->CreateCursor(fFalse);
	pcurSidCache->Reset();
	pcurSidCache->SetFilter(1);
	AssertNonZero(pcurSidCache->PutString(1, riUser));

	if (pcurSidCache->Next())
	{
		rpistrmSid = (IMsiStream*) pcurSidCache->GetMsiData(2);
		rpistrmSid->Reset();
		Assert(rpistrmSid);
	}
	else
	{
		if (iesSuccess != AllocateAndInitializeUserSid(riUser.GetString(), &psidUser, cbSid))
		{
			return PostError(Imsg(imsgCreateAclFailed), riUser.GetString(), WIN::GetLastError());
		}

		char* pbstrmSid = pServices->AllocateMemoryStream((unsigned int) cbSid, rpistrmSid);
		Assert(pbstrmSid);

		Assert(WIN::IsValidSid(psidUser));
		AssertNonZero(WIN::CopySid(cbSid, pbstrmSid, psidUser));
		AssertZero(memcmp(pbstrmSid, psidUser, cbSid));

		delete[] psidUser;
		Assert(WIN::IsValidSid(pbstrmSid));
		

		AssertNonZero(pcurSidCache->PutString(1, riUser));
		Assert(rpistrmSid);
		AssertNonZero(pcurSidCache->PutMsiData(2, rpistrmSid));
		AssertNonZero(pcurSidCache->Insert());
	}

	return 0;
}

const IMsiString& FormatUser(IMsiEngine& riEngine, const IMsiString& riDomain, const IMsiString& riUser)
{
	riDomain.AddRef();
	MsiString strUser(riDomain);
	if (strUser.TextSize())
		strUser += TEXT("\\");
	strUser += riUser;
	strUser = riEngine.FormatText(*strUser);

	return strUser.Return();
}

bool InitializeAceHeader(ACL* pACL, int iIndex)
{
	// iIndex is a 0 based index for which ACE to set up.

	// AceType and AceSize are filled in by the AddAccess*ACE functions.
	LPVOID pACE = 0;
	if (GetAce(pACL, iIndex, &pACE))
	{
		// get the ace, and make sure the inheritance flags are set correctly.
		_ACE_HEADER* pAceHeader = (struct _ACE_HEADER*) pACE;

		// objects created under this one will get the same set of permissions.
		pAceHeader->AceFlags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;
		return true;
	}
	else 
	{
		return false;
	}
}

IMsiRecord* GenerateSD(IMsiEngine& riEngine, IMsiView& riviewLockList, IMsiRecord* piExecute, IMsiStream*& rpiSD)
{
	// Assumes that the LockList comes in already executed,
	// the Execute record is to allow us to re-execute the view if necessary.

	// First pass updates the SID cache, and calculates the total size of the ACL we're generating.
	// Second pass fetches the SIDs from the cache, and starts filling in an allocated ACL.

	// this is much better than using a function that takes a single ACE, and re-allocates the ACL
	// each time.  (The example in the SDK does this.  *yuck*)

	Assert(!g_fWin9X);

	const int cbDefaultSid = sizeof(SID) + sizeof(DWORD)*SID_MAX_SUB_AUTHORITIES;
	int cbSid = 0;

	PMsiStream pstrmSid(0);
	PMsiRecord precFetch(0);
	PMsiServices pServices = riEngine.GetServices();
	MsiString strUser;


	DWORD cbSids = 0;
	static DWORD cbDefaultSids = 0;
	int cAllowSids = 0;
	int cDenySids = 0;

	if (!cbDefaultSids)
	{
		ENSURE(LookupSid(riEngine, *MsiString(TEXT("SYSTEM")), *&pstrmSid));
		cbDefaultSids += pstrmSid->GetIntegerValue();
	}

	while((precFetch = riviewLockList.Fetch()))
	{
		// we must know how many ACEs to add, and their SIDs, before can initialize an ACL.

		strUser = FormatUser(riEngine, *MsiString(precFetch->GetMsiString(1)), *MsiString(precFetch->GetMsiString(2)));
		ENSURE(LookupSid(riEngine, *strUser, *&pstrmSid));

		if (pstrmSid)
		{
			//REVIEW:  How do we handle not being able to find a particular user's SID?
			if (precFetch->GetInteger(3))
				cAllowSids++;
			else
				cDenySids++;

			cbSids += pstrmSid->GetIntegerValue();
		}
	}	
	
	// initialize ACL with appropriate calculated sizes + sizes for default ACEs (system/interactive, and everyone denied)

	// the SIDs and the ACEs share a structure in common, so the size is calculated
	// by adding the sizes together, then substracting that particular piece.
	// see documentation for InitializeAcl

	if (!cDenySids && !cAllowSids) 
		return 0;

	const DWORD cbACLSize = sizeof (ACL) + cbDefaultSids + cbSids + 
		 (cDenySids	 + 0 /*defaults*/)*(sizeof(ACCESS_DENIED_ACE)  - sizeof(DWORD /*ACCESS_DENIED_ACE.SidStart*/)) +       
		 (cAllowSids + 1 /*defaults*/)*(sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD/*ACCESS_ALLOWED_ACE.SidStart*/));

	const int cbDefaultAcl = 512;
	CTempBuffer<char, cbDefaultAcl> pchACL;
	if (cbDefaultAcl < cbACLSize)
		pchACL.SetSize(cbACLSize);

	ACL* pACL = (ACL*) (char*) pchACL;

	if (!WIN::InitializeAcl (pACL, cbACLSize, ACL_REVISION))
		return PostError(Imsg(idbgCreateAclFailed), WIN::GetLastError());

	CTempBuffer<char, cbDefaultSid> pchSid;

	ENSURE(riviewLockList.Close());
	ENSURE(riviewLockList.Execute(piExecute));

	BOOL fAllowSet = fFalse;

	int cACE = 0;
	while((precFetch = riviewLockList.Fetch()))
	{
		
		// build ACL with Access Allowed ACEs...
		strUser = FormatUser(riEngine, *MsiString(precFetch->GetMsiString(1)), *MsiString(precFetch->GetMsiString(2)));
		ENSURE(LookupSid(riEngine, *strUser, *&pstrmSid));
		if (!pstrmSid) 
		{
			continue;
		}
			
		cbSid = pstrmSid->GetIntegerValue();
		if (cbSid > pchSid.GetSize())
			pchSid.SetSize(cbSid);

		pstrmSid->GetData(pchSid, cbSid);

		Assert(WIN::IsValidSid(pchSid));
		// build permission mask

		//Permission mask a bit field for easy
		// passing directly through

		// See also: GENERIC_READ, GENERIC_WRITE, GENERIC_EXECUTE, GENERIC_ALL
		DWORD dwPermissions = precFetch->GetInteger(3);


		if (dwPermissions)
		{
			fAllowSet = fTrue;

			if (!WIN::AddAccessAllowedAce(pACL, ACL_REVISION, dwPermissions, pchSid))
				return PostError(Imsg(idbgCreateAclFailed), WIN::GetLastError());
		}
		else
		{
			// All denies must be handled before allows.
			Assert(fFalse == fAllowSet);
			if (!WIN::AddAccessDeniedAce(pACL, ACL_REVISION, dwPermissions, pchSid))
				return PostError(Imsg(idbgCreateAclFailed), WIN::GetLastError());
		}
		AssertNonZero(InitializeAceHeader(pACL, cACE++));
	}
	
	ENSURE(LookupSid(riEngine, *MsiString(TEXT("SYSTEM")), *&pstrmSid));
	Assert(pstrmSid);

	cbSid = pstrmSid->GetIntegerValue();
	Assert(cbSid <= cbDefaultSid);

	pstrmSid->GetData(pchSid, cbSid);
	Assert(WIN::IsValidSid(pchSid));

	if (!WIN::AddAccessAllowedAce(pACL, ACL_REVISION, GENERIC_ALL, pchSid))
		return PostError(Imsg(idbgCreateAclFailed), WIN::GetLastError());
	AssertNonZero(InitializeAceHeader(pACL, cACE++));

	Assert(WIN::IsValidAcl(pACL));

	SECURITY_DESCRIPTOR sd;
	if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
		return PostError(Imsg(idbgCreateAclFailed), WIN::GetLastError());
	if (!SetSecurityDescriptorDacl(&sd, TRUE, pACL, FALSE))
		return PostError(Imsg(idbgCreateAclFailed), WIN::GetLastError());
  	if (!WIN::IsValidSecurityDescriptor(&sd))
		return PostError(Imsg(idbgCreateAclFailed), WIN::GetLastError());

	CTempBuffer<char, cbDefaultSD> pchSD;
	DWORD cbSD = WIN::GetSecurityDescriptorLength(&sd);
	if (cbSD > cbDefaultSD)
		pchSD.SetSize(cbSD);

	AssertNonZero(WIN::MakeSelfRelativeSD(&sd, pchSD, &cbSD));
		
	char* pchstrmSD = pServices->AllocateMemoryStream(cbSD, rpiSD);
	Assert(pchstrmSD);

	memcpy(pchstrmSD, pchSD, cbSD);

	return 0;
}

#ifdef ENSURE_DEFINED_LOCALLY
#undef ENSURE
#undef ENSURE_DEFINED_LOCALLY
#endif


//
// From shared.cpp
//
extern iesEnum RegisterFonts(IMsiEngine& riEngine);
extern iesEnum UnregisterFonts(IMsiEngine& riEngine);
extern iesEnum WriteRegistryValues(IMsiEngine& riEngine);
extern iesEnum WriteIniValues(IMsiEngine& riEngine);
extern iesEnum RemoveRegistryValues(IMsiEngine& riEngine);
extern iesEnum RemoveIniValues(IMsiEngine& riEngine);
extern iesEnum AppSearch(IMsiEngine& riEngine);
extern iesEnum CCPSearch(IMsiEngine& riEngine);
extern iesEnum RMCCPSearch(IMsiEngine& riEngine);
extern iesEnum SelfRegModules(IMsiEngine& riEngine);
extern iesEnum SelfUnregModules(IMsiEngine& riEngine);
extern iesEnum BindImage(IMsiEngine& riEngine);
extern iesEnum ProcessComponents(IMsiEngine& riEngine);
extern iesEnum StartServices(IMsiEngine& riEngine);
extern iesEnum StopServices(IMsiEngine& riEngine);
extern iesEnum DeleteServices(IMsiEngine& riEngine);
extern iesEnum ServiceInstall(IMsiEngine& riEngine);
extern iesEnum SetODBCFolders(IMsiEngine& riEngine);
extern iesEnum InstallODBC(IMsiEngine& riEngine);
extern iesEnum RemoveODBC(IMsiEngine& riEngine);
extern iesEnum WriteEnvironmentStrings(IMsiEngine& riEngine);
extern iesEnum RemoveEnvironmentStrings(IMsiEngine& riEngine);
extern iesEnum InstallSFPCatalogFile(IMsiEngine& riEngine);

//
// From fileactn.cpp
//
extern iesEnum InstallFiles(IMsiEngine& riEngine);
extern iesEnum RemoveFiles(IMsiEngine& riEngine);
extern iesEnum MoveFiles(IMsiEngine& riEngine);
extern iesEnum DuplicateFiles(IMsiEngine& riEngine);
extern iesEnum RemoveDuplicateFiles(IMsiEngine& riEngine);
extern iesEnum InstallValidate(IMsiEngine& riEngine);
extern iesEnum FileCost(IMsiEngine& riEngine);
extern iesEnum PatchFiles(IMsiEngine& riEngine);
extern iesEnum CreateFolders(IMsiEngine& riEngine);
extern iesEnum RemoveFolders(IMsiEngine& riEngine);
extern iesEnum InstallAdminPackage(IMsiEngine& riEngine);
extern iesEnum IsolateComponents(IMsiEngine& riEngine);

//
// From complus.cpp
//
extern iesEnum RegisterComPlus(IMsiEngine& riEngine);
extern iesEnum UnregisterComPlus(IMsiEngine& riEngine);

// action m_fSafeInRestrictedEngine settings
const bool fUnsafeAction = false; // action not allowed in restricted engine
const bool fSafeAction   = true;  // action allowed in restricted engine

// Action registration object, to put action in modules action table
// {m_szName, m_fSafeInRestrictedEngine, m_pfAction}

// This list must be in sorted order by ASCII value, not alphabetical
const CActionEntry rgcae[] = {
	{IACTIONNAME_ADMIN, fSafeAction, Admin},
	{IACTIONNAME_ADVERTISE, fSafeAction, Advertise},
	{TEXT("AllocateRegistrySpace"), fUnsafeAction, AllocateRegistrySpace},
	{TEXT("AppSearch"), fSafeAction, AppSearch},
	{TEXT("BindImage"), fUnsafeAction, BindImage},
	{TEXT("CCPSearch"), fSafeAction, CCPSearch},
	{TEXT("CollectUserInfo"), fUnsafeAction, CollectUserInfo},
	{TEXT("CostFinalize"), fSafeAction, CostFinalize},
	{TEXT("CostInitialize"), fSafeAction, CostInitialize},
	{TEXT("CreateFolders"), fUnsafeAction, CreateFolders},
	{TEXT("CreateShortcuts"), fUnsafeAction, CreateShortcuts},
	{TEXT("DeleteServices"), fUnsafeAction, DeleteServices},
	{TEXT("DisableRollback"), fUnsafeAction, DisableRollback},
	{TEXT("DuplicateFiles"), fUnsafeAction, DuplicateFiles},
	{TEXT("ExecuteAction"), fUnsafeAction, ExecuteAction},
	{TEXT("FileCost"), fSafeAction, FileCost},
	{TEXT("FindRelatedProducts"), fSafeAction, FindRelatedProducts},
	{TEXT("ForceReboot"), fUnsafeAction, ForceReboot},
	{IACTIONNAME_INSTALL, fSafeAction, Install},
	{TEXT("InstallAdminPackage"), fUnsafeAction, InstallAdminPackage},
	{TEXT("InstallExecute"), fUnsafeAction, InstallExecute},
	{TEXT("InstallExecuteAgain"), fUnsafeAction, InstallExecuteAgain},
	{TEXT("InstallFiles"), fUnsafeAction, InstallFiles},
	{TEXT("InstallFinalize"), fUnsafeAction, InstallFinalize},
	{TEXT("InstallInitialize"), fUnsafeAction, InstallInitialize},
	{TEXT("InstallODBC"), fUnsafeAction, InstallODBC},
	{TEXT("InstallSFPCatalogFile"), fUnsafeAction, InstallSFPCatalogFile},
	{TEXT("InstallServices"), fUnsafeAction, ServiceInstall},
	{TEXT("InstallValidate"), fUnsafeAction, InstallValidate},
	{TEXT("IsolateComponents"), fSafeAction, IsolateComponents},
	{TEXT("LaunchConditions"), fSafeAction, LaunchConditions},
	{TEXT("MigrateFeatureStates"), fSafeAction, MigrateFeatureStates},
	{TEXT("MoveFiles"), fUnsafeAction, MoveFiles},
	{TEXT("MsiPublishAssemblies"), fUnsafeAction, MsiPublishAssemblies},
	{TEXT("MsiUnpublishAssemblies"), fUnsafeAction, MsiUnpublishAssemblies},
	{TEXT("PatchFiles"), fUnsafeAction, PatchFiles},
	{TEXT("ProcessComponents"), fUnsafeAction, ProcessComponents},
	{TEXT("PublishComponents"), fUnsafeAction, PublishComponents},
	{TEXT("PublishFeatures"), fUnsafeAction, PublishFeatures},
	{TEXT("PublishProduct"), fUnsafeAction, PublishProduct},
	{TEXT("RMCCPSearch"), fSafeAction, RMCCPSearch},
	{TEXT("RegisterClassInfo"), fUnsafeAction, RegisterClassInfo},
	{TEXT("RegisterComPlus"), fUnsafeAction, RegisterComPlus},
	{TEXT("RegisterExtensionInfo"), fUnsafeAction, RegisterExtensionInfo},
	{TEXT("RegisterFonts"), fUnsafeAction, RegisterFonts},
	{TEXT("RegisterMIMEInfo"), fUnsafeAction, RegisterMIMEInfo},
	{TEXT("RegisterProduct"), fUnsafeAction, RegisterProduct},
	{TEXT("RegisterProgIdInfo"), fUnsafeAction, RegisterProgIdInfo},
	{TEXT("RegisterTypeLibraries"), fUnsafeAction, RegisterTypeLibraries},
	{TEXT("RegisterUser"), fUnsafeAction, RegisterUser},
	{TEXT("RemoveDuplicateFiles"), fUnsafeAction, RemoveDuplicateFiles},
	{TEXT("RemoveEnvironmentStrings"), fUnsafeAction, RemoveEnvironmentStrings},
	{TEXT("RemoveExistingProducts"), fUnsafeAction, RemoveExistingProducts},
	{TEXT("RemoveFiles"), fUnsafeAction, RemoveFiles},
	{TEXT("RemoveFolders"), fUnsafeAction, RemoveFolders},
	{TEXT("RemoveIniValues"), fUnsafeAction, RemoveIniValues},
	{TEXT("RemoveODBC"), fUnsafeAction, RemoveODBC},
	{TEXT("RemoveRegistryValues"), fUnsafeAction, RemoveRegistryValues},
	{TEXT("RemoveShortcuts"), fUnsafeAction, RemoveShortcuts},
	{TEXT("ResolveSource"), fSafeAction, ResolveSource},
	{IACTIONNAME_SEQUENCE, fSafeAction, Sequence},
	{TEXT("ScheduleReboot"), fUnsafeAction, ScheduleReboot},
	{TEXT("SelfRegModules"), fUnsafeAction, SelfRegModules},
	{TEXT("SelfUnregModules"), fUnsafeAction, SelfUnregModules},
	{TEXT("SetODBCFolders"), fUnsafeAction, SetODBCFolders},
	{TEXT("StartServices"), fUnsafeAction, StartServices},
	{TEXT("StopServices"), fUnsafeAction, StopServices},
	{TEXT("UnpublishComponents"), fUnsafeAction, UnpublishComponents},
	{TEXT("UnpublishFeatures"), fUnsafeAction, UnpublishFeatures},
	{TEXT("UnregisterClassInfo"), fUnsafeAction, UnregisterClassInfo},
	{TEXT("UnregisterComPlus"), fUnsafeAction, UnregisterComPlus},
	{TEXT("UnregisterExtensionInfo"), fUnsafeAction, UnregisterExtensionInfo},
	{TEXT("UnregisterFonts"), fUnsafeAction, UnregisterFonts},
	{TEXT("UnregisterMIMEInfo"), fUnsafeAction, UnregisterMIMEInfo},
	{TEXT("UnregisterProgIdInfo"), fUnsafeAction, UnregisterProgIdInfo},
	{TEXT("UnregisterTypeLibraries"), fUnsafeAction, UnregisterTypeLibraries},
	{TEXT("ValidateProductID"), fSafeAction, ValidateProductID},
	{TEXT("WriteEnvironmentStrings"), fUnsafeAction, WriteEnvironmentStrings},
	{TEXT("WriteIniValues"), fUnsafeAction, WriteIniValues},
	{TEXT("WriteRegistryValues"), fUnsafeAction, WriteRegistryValues},
	{ 0, 0, 0 },
};
	
#define cCae	(sizeof(rgcae)/sizeof(CActionEntry))

const CActionEntry* CActionEntry::Find(const ICHAR* szName)
{
#ifdef DEBUG
	static boolean fCheckedOrder = false;
	int i = cCae - 2;
	int cch;
	
	if (!fCheckedOrder)
	{
		for ( const CActionEntry* pAction = &rgcae[0] ; i > 0 ; pAction = pAction++, i--)
		{		
			cch = (lstrlen(pAction->m_szName) + 1) * sizeof(ICHAR);
			if (memcmp(pAction->m_szName, (pAction+1)->m_szName, cch) >= 0)
			{
				ICHAR rgchMsg[256];

				
				ASSERT_IF_FAILED(StringCchPrintf(rgchMsg, ARRAY_ELEMENTS(rgchMsg),
									 TEXT("Action strings out of order [%s] [%s]"),
									 pAction->m_szName, (pAction+1)->m_szName));
				FailAssertMsg(rgchMsg);
			}
		}
	fCheckedOrder = true;
	}
#endif //DEBUG
	for ( const CActionEntry* pAction = &rgcae[0] ; pAction->m_szName ; pAction = pAction++)
		if (IStrComp(pAction->m_szName, szName) == 0)
			return pAction;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\darwin\src\engine\database.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       database.cpp
//
//--------------------------------------------------------------------------

/* database.cpp - common database implementation

CMsiDatabase - common database implementation, MSI database functions
CMsiTable - low-level in-memory database table management
CMsiCursor - data access to CMsiTable
____________________________________________________________________________*/

#define ALIGN(x) (x+(-x & 3))
#include "precomp.h"
#include "_databas.h"// CMsiTable, CMsiCursor, CMsiDatabase, CreateString() factory
#include "tables.h" // table and column name definitions

// database option flag definitions, any unknown option makes a database incompatible
const int idbfExpandedStringIndices = 1 << 31;
const int idbfDatabaseOptionsMask   = 0xFF000000L;
const int idbfHashBinCountMask      = 0x000F0000L;
const int idbfHashBinCountShift     = 16;
const int idbfReservedMask          = 0x00F00000L;
const int idbfCodepageMask          = 0x0000FFFFL;
const int idbfKnownDatabaseOptions  = idbfExpandedStringIndices;

const GUID IID_IMsiDatabase   = GUID_IID_IMsiDatabase;
const GUID IID_IMsiView       = GUID_IID_IMsiView;
const GUID IID_IMsiTable      = GUID_IID_IMsiTable;
const GUID IID_IMsiCursor     = GUID_IID_IMsiCursor;
const GUID STGID_MsiDatabase1 = GUID_STGID_MsiDatabase1;
const GUID STGID_MsiDatabase2 = GUID_STGID_MsiDatabase2;
const GUID STGID_MsiPatch1    = GUID_STGID_MsiPatch1;
const GUID STGID_MsiPatch2    = GUID_STGID_MsiPatch2;
const GUID STGID_MsiTransformTemp = GUID_STGID_MsiTransformTemp; //!! remove at 1.0 ship

const int cRowCountDefault = 16; // default number of rows for new table
const int cRowCountGrowMin = 4;  // minimum number of rows to expand table
const int cCatalogInitRowCount = 30; // initial row count for catalog
const int iFileNullInteger   = 0x8000;  // null integer in file stream

const ICHAR szSummaryInfoTableName[]   = TEXT("_SummaryInformation");  // name recognized by Import()
const ICHAR szForceCodepageTableName[] = TEXT("_ForceCodepage");       // name recognized by Import()
const ICHAR szSummaryInfoColumnName1[] = TEXT("PropertyId");
const ICHAR szSummaryInfoColumnName2[] = TEXT("Value");
const ICHAR szSummaryInfoColumnType1[] = TEXT("i2");
const ICHAR szSummaryInfoColumnType2[] = TEXT("l255");
const int rgiMaxDateField[6] = {2099, 12, 31, 23, 59, 59};
const ICHAR rgcgDateDelim[6] = TEXT("// ::"); // yyyy/mm/dd hh:mm:ss

// exposed catalog column names
const ICHAR sz_TablesName[]    = TEXT("Name");
const ICHAR sz_ColumnsTable[]  = TEXT("Table");
const ICHAR sz_ColumnsNumber[] = TEXT("Number");
const ICHAR sz_ColumnsName[]   = TEXT("Name");
const ICHAR sz_ColumnsType[]   = TEXT("Type");
const ICHAR sz_StreamsName[]   = TEXT("Name");
const ICHAR sz_StreamsData[]   = TEXT("Data");


//____________________________________________________________________________
//
// Storage class validation
//____________________________________________________________________________

bool ValidateStorageClass(IStorage& riStorage, ivscEnum ivsc)
{
	if (ivsc == ivscDatabase)
		return ValidateStorageClass(riStorage, ivscDatabase2) ? true : ValidateStorageClass(riStorage, ivscDatabase1);

	if (ivsc == ivscTransform)
		return ValidateStorageClass(riStorage, ivscTransform2) ? true : (ValidateStorageClass(riStorage, ivscTransform1) ? true: ValidateStorageClass(riStorage, ivscTransformTemp)); //!! remove last test at 1.0 ship

	if (ivsc == ivscPatch)
		return ValidateStorageClass(riStorage, ivscPatch2) ? true : ValidateStorageClass(riStorage, ivscPatch1);

	STATSTG statstg;
	HRESULT hres = riStorage.Stat(&statstg, STATFLAG_NONAME);
	if (hres != S_OK || statstg.clsid.Data1 != ivsc)     // iidMsi* is the low-order 32-bits
		return false;
	return  memcmp(&statstg.clsid.Data2, &STGID_MsiDatabase2.Data2, sizeof(GUID)-sizeof(DWORD)) == 0;
}

//____________________________________________________________________________
//
// String cache private definitions
//____________________________________________________________________________

struct MsiCacheLink  // 8 byte array element, should be power of 2 for alignment
{
	const IMsiString*    piString;  // pointer to string object, holds single refcnt
	MsiCacheIndex        iNextLink; // array index of next hash link or free link
}; // MsiCacheRefCnt[] kept separate for alignment, follows this array

const int cHashBitsMinimum =  8; // miminum bit count of hash value
const int cHashBitsMaximum = 12; // maximum bit count of hash value
const int cHashBitsDefault = 10; // default bit count of hash value

const int cCacheInitSize   = 256; // initial number of entries in string cache
const int cCacheLoadReserve=  32; // entries on reload to allow from growth
const int cCacheMaxGrow = 1024;  // limit growth to reasonable value

//____________________________________________________________________________
//
// CMsiTextKeySortCursor definitions - used for ExportTable
//____________________________________________________________________________

const Bool ictTextKeySort = Bool(2);  // internal use cursor type

class CMsiTextKeySortCursor : public CMsiCursor
{
	unsigned long __stdcall Release();
	int           __stdcall Next();
	void          __stdcall Reset();
 public:
	CMsiTextKeySortCursor(CMsiTable& riTable, CMsiDatabase& riDatabase, int cRows, int* rgiIndex);
 private:
	int  m_iIndex;
	int  m_cIndex;
	int* m_rgiIndex;
 private: // eliminate warning: assignment operator could not be generated
	void operator =(const CMsiTextKeySortCursor&){}
};

//____________________________________________________________________________________________________
//
// CMsiValConditionParser enums
//____________________________________________________________________________________________________

enum ivcpEnum
{
	ivcpInvalid = 0, // Invalid expression
	ivcpValid   = 1, // Valid exression
	ivcpNone    = 2, // No expression
	ivcNextEnum
};

enum vtokEnum // token parsed by Lex, operators from low to high precedence
{
	vtokEos,        // End of string
	vtokRightPar,   // right parenthesis
	vtokImp,
	vtokEqv,
	vtokXor,
	vtokOr,
	vtokAnd,
	vtokNot,        // unaray, between logical and comparison ops
	vtokEQ, vtokNE, vtokGT, vtokLT, vtokGE, vtokLE, vtokLeft, vtokMid, vtokRight,
	vtokValue,
	vtokLeftPar,    // left parenthese
	vtokError
};

//____________________________________________________________________________________________________
//
// CMsiValConditionParser class declaration
//		Borrowed from:  engine.cpp
//____________________________________________________________________________________________________

struct CMsiValConditionParser  // Non-recursive Lex state structure
{
	CMsiValConditionParser(const ICHAR* szExpression);
   ~CMsiValConditionParser();
    vtokEnum Lex();
	void     UnLex();                           // cache current token for next Lex call
	ivcpEnum Evaluate(vtokEnum vtokPrecedence); // recursive evaluator
 private:                   // Result of Lex
	vtokEnum     m_vtok;        // current token type
	iscEnum      m_iscMode;     // string compare mode flags
	MsiString    m_istrToken;   // string value of token if vtok==vtokValue
	int          m_iToken;      // integer value if obtainable, else iMsiNullInteger
 private:                   // To Lex
	int          m_iParenthesisLevel;
	const ICHAR* m_pchInput;
	Bool         m_fAhead;
 private:                   //  Eliminate warning
	void operator =(const CMsiValConditionParser&) {}
};
inline CMsiValConditionParser::CMsiValConditionParser(const ICHAR* szExpression)
	: m_pchInput(szExpression), m_iParenthesisLevel(0), m_fAhead(fFalse), m_vtok(vtokError) {}
inline CMsiValConditionParser::~CMsiValConditionParser() {}
inline void CMsiValConditionParser::UnLex() { Assert(m_fAhead == fFalse); m_fAhead = fTrue; }


//________________________________________________________________________________
//
// Separate Validator implementation
//________________________________________________________________________________

// Buffer sizes
const int cchBuffer                    = 512;
const int cchMaxCLSID                  = 40;

// Mask for Lang Ids
const int iMask                        = ~((15 << 10) + 0x7f);

//___________________________________________
//
// Validator functions
//___________________________________________

static Bool CheckIdentifier(const ICHAR* szIdentifier);
static Bool CheckCase(MsiString& rstrData, Bool fUpperCase);
static Bool ParsePath(MsiString& rstrPath, bool fRelative);
static Bool GetProperties(const ICHAR* szRecord, Bool fFormatted, Bool fKeyAllowed, int iCol, int& iForeignKeyMask);
static Bool ParseProperty(const ICHAR* szProperty, Bool fFormatted, Bool fKeyAllowed, int iCol, int& iForeignKeyMask);
static Bool CheckSet(MsiString& rstrSet, MsiString& rstrData, Bool fIntegerData);
static Bool ParseFilename(MsiString& strFile, Bool fWildCard);
static ifvsEnum CheckWildFilename(const ICHAR *szFileName, Bool fLFN, Bool fWildCard);

//____________________________________________________________________________
//
// IMsiDatabase factory
//____________________________________________________________________________

IMsiRecord* CreateDatabase(const ICHAR* szDatabase, idoEnum idoOpenMode, IMsiServices&  riServices,
									IMsiDatabase*& rpiDatabase)
{
	IMsiRecord* piRec = &riServices.CreateRecord(3);
	ISetErrorCode(piRec, Imsg(idbgDbConstructor));
	piRec->SetString(2, szDatabase);
	piRec->SetInteger(3, idoOpenMode);

	if (idoOpenMode == idoListScript)
	{
		CScriptDatabase* piDb;
		piDb = new CScriptDatabase(riServices);
		if (piDb != 0)
		{
			piRec->Release();
			if ((piRec = piDb->OpenDatabase(szDatabase)) != 0)
			{
				piDb->Release(); //if we delete here then services are never released
				piDb = 0;
			}
		}
		rpiDatabase = piDb;
		return piRec;
	}

	CMsiDatabase* piDb = new CMsiDatabase(riServices);
	if (piDb != 0)
	{
		piRec->Release();
		if ((piRec = piDb->OpenDatabase(szDatabase, idoOpenMode)) != 0)
		{
			piDb->Release(); //if we delete here then services are never released
			piDb = 0;
		}
	}
	rpiDatabase = piDb;
	return piRec;
}

IMsiRecord*  CreateDatabase(IMsiStorage& riStorage, Bool fReadOnly,
									 IMsiServices&  riServices,
									 IMsiDatabase*& rpiDatabase)
{
	IMsiRecord* piRec = &riServices.CreateRecord(3);
	ISetErrorCode(piRec, Imsg(idbgDbConstructor));
	//!! other parameters???
	CMsiDatabase* piDb;
	piDb = new CMsiDatabase(riServices);
	if (piDb != 0)
	{
		piRec->Release();
		if ((piRec = piDb->OpenDatabase(riStorage, fReadOnly)) != 0)
		{
			piDb->Release(); //if we delete here then services are never released
			piDb = 0;
		}
	}
	rpiDatabase = piDb;
	return piRec;
}


#ifdef USE_OBJECT_POOL
// Pointer-Pool implementation
const IMsiData**	g_rgpvObject = NULL;
int		g_iNextFree	 = -1;
HGLOBAL g_hGlobal;
int		g_rcRows	 = 0;
int		g_rcTotalRows = 0;

#ifndef _WIN64
bool	g_fUseObjectPool = false;
#endif

extern CRITICAL_SECTION vcsHeap;

const IMsiData* GetObjectDataProc(int iIndex)
{
	const IMsiData* piRet = 0;
	EnterCriticalSection(&vcsHeap);
	if (iIndex != iMsiStringBadInteger && iIndex < (g_rcTotalRows + iMaxStreamId + 1) && iIndex > iMaxStreamId)
	{
		iIndex -= iMaxStreamId + 1;
		Assert(g_rgpvObject[iIndex] != (IMsiData*)(INT_PTR)(0xdeadf00d));
		piRet = g_rgpvObject[iIndex];
	}
	else
		piRet = (const IMsiData*)(INT_PTR)(iIndex);
	LeaveCriticalSection(&vcsHeap);
	return piRet;
}

//
// Adds the object to the pool
// The Caller is expected to have addrefed this object if it is an IUnknown
// We use the Heap's critical section here because we want to avoid deadlock and we know
// that another thread would not be waiting to allocate memory until we returned.
//
int PutObjectDataProc(const IMsiData* pvData)
{

	if (pvData == 0)
		return 0;

	EnterCriticalSection(&vcsHeap);
	unsigned int iIndex = pvData->GetUniqueId();
	Assert(iIndex <= g_rcTotalRows || iIndex == 0);

	if (iIndex == 0)
	{
		if (g_iNextFree < 0) 				// no free space
		{
			int rcNewRows = g_rcTotalRows*2;
			if (!g_rcTotalRows)					// allocate memory- first time
			{
				rcNewRows = 20;				//!! to change.
				while(NULL == (g_hGlobal = GlobalAlloc(GMEM_MOVEABLE, sizeof(PVOID)*rcNewRows)))
					HandleOutOfMemory();
				g_rgpvObject = (const IMsiData**)GlobalLock(g_hGlobal);
			}
			else 							// out of space- realloc more.
			{
				GlobalUnlock(g_hGlobal);
				HGLOBAL hGlobalT;
				while(NULL == (hGlobalT = (PVOID *)GlobalReAlloc(g_hGlobal, sizeof(PVOID)*rcNewRows, GMEM_MOVEABLE)))
					HandleOutOfMemory();
				g_hGlobal = hGlobalT;
				g_rgpvObject = (const IMsiData**)GlobalLock(g_hGlobal);
			}
			
			// set new cells to point to next free cell
			for (int i = g_rcTotalRows; i < rcNewRows-1; i++)
				g_rgpvObject[i] = (IMsiData*)(INT_PTR)(i + 1);

			g_rgpvObject[rcNewRows-1] = (IMsiData*)(-1);	// last free cell has -1
			g_iNextFree = g_rcTotalRows;				// newly added cells (from rg[g_rcTotalRows] to rg[rcNewRows-1]) are free
			g_rcTotalRows = rcNewRows;
		}

		g_rcRows++;
		iIndex = g_iNextFree;			// store data in next available cell
		g_iNextFree = PtrToInt(g_rgpvObject[iIndex]);

		g_rgpvObject[iIndex] = pvData;
		iIndex++;
		((IMsiData*)pvData)->SetUniqueId(iIndex);
		Assert(pvData->GetUniqueId() == iIndex);
	}
	LeaveCriticalSection(&vcsHeap);
	
	// Returned value must be > iMaxStreamId
	return iIndex + iMaxStreamId;
}

//
// Removes the data from the Object pool
// Called when an object is deleted
// iIndex is the index into the object pool + 1 (the value stored in the object itself, not in the Tables
//
void RemoveObjectData(int iIndex)
{

	if (iIndex == 0)
		return;

	iIndex--;

#ifndef _WIN64
	if (!g_fUseObjectPool)
		return;
#endif // !_WIN64
		
	EnterCriticalSection(&vcsHeap);
	g_rcRows--;
	g_rgpvObject[iIndex] = (IMsiData*)(INT_PTR)g_iNextFree;
	g_iNextFree = iIndex;
	LeaveCriticalSection(&vcsHeap);
}

void CMsiDatabase::RemoveObjectData(int iIndex)
{
	::RemoveObjectData(iIndex);
}

// End Pointer-Pool Implementation
#endif // ifdef USE_OBJECT_POOL

//
// Assumes the object is IUnknown* and does a release on it before removing it
//
inline void ReleaseObjectData(int iIndex)
{
	const IMsiData* piUnk = GetObjectData(iIndex);
	if ((INT_PTR)piUnk > iMaxStreamId)
	{
		piUnk->Release();
	}
}

inline int AddRefObjectData(int iIndex)
{
	const IMsiData* piUnk = GetObjectData(iIndex);
	if ((INT_PTR)piUnk > iMaxStreamId)
	{
		return piUnk->AddRef();
	}
	return 0;
}


//____________________________________________________________________________
//
//  CScriptDatabase virtual function implementation
//____________________________________________________________________________


CScriptDatabase::CScriptDatabase(IMsiServices& riServices): m_riServices(riServices)
{
	m_piName = &::CreateString();
	m_riServices.AddRef();
}



IMsiServices& CScriptDatabase::GetServices()
{
	m_riServices.AddRef();
	return m_riServices;
}


IMsiRecord* __stdcall CScriptDatabase::OpenView(const ICHAR* /*szQuery*/, ivcEnum /*ivcIntent*/, IMsiView*& rpiView)
{

	m_piView = new CScriptView(*this, m_riServices);
	Assert(m_piView != 0);
	if ( ! m_piView )
		return PostError(Imsg(idbgDbDataMemory), *m_piName);
	IMsiRecord* piRec = m_piView->Initialise(m_piName->GetString());
	if (piRec != 0)
	{
		m_piView->Release();
		rpiView = 0;
		return piRec;
	}

	rpiView=m_piView;
	return 0;
}


const IMsiString& __stdcall CScriptDatabase::DecodeString(MsiStringId /*iString*/)
{

	return ::CreateString();
	
//	const IMsiString* piString;
//	if (iString == 0
//	 || iString >= m_cCacheUsed
//	 || (piString = m_rgCache[iString].piString) == 0)
//		return g_MsiStringNull;
//	piString->AddRef();
//	return *piString;
}

const IMsiString& __stdcall CScriptDatabase::CreateTempTableName()
{
	static ICHAR rgchTempName[] = TEXT("#TEMP0000");  // leading '#' designates SQLServer local temp table
	ICHAR* pchName = rgchTempName + sizeof(rgchTempName)/sizeof(ICHAR) - 2; // last char
	ICHAR ch;
	while ((ch = *pchName) >= '9')
	{
		*pchName = '0';  // overflow digit to next
		if (ch == '9')   // if was a digit
			pchName--;
	}
	(*pchName)++;
	const IMsiString* piName = &::CreateString();
	piName->SetString(rgchTempName, piName);
	return *piName;
}


IMsiRecord* CScriptDatabase::OpenDatabase(const ICHAR* szDataSource)
{
	m_piName->SetString(szDataSource, m_piName);
	return 0;
}


CScriptDatabase::~CScriptDatabase()
{
}


unsigned long __stdcall CScriptDatabase::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}

unsigned long __stdcall CScriptDatabase::Release()
{
	ReleaseTrack();
	if (m_Ref.m_iRefCnt == 1)  // no external refs to database object remain
	{
		m_piName->Release();
		IMsiServices& riServices = m_riServices;  // save pointer before destruction
		delete this;  // remove ourselves before releasing Services
		riServices.Release();
		return 0;
	}
	return --m_Ref.m_iRefCnt;
}

#ifdef USE_OBJECT_POOL
void CScriptDatabase::RemoveObjectData(int iIndex)
{
	::RemoveObjectData(iIndex);
}
#endif //USE_OBJECT_POOL

//____________________________________________________________________________
//
// CStreamTable definitions - subclassed table to manage raw streams
//____________________________________________________________________________

class CStreamTable : public CMsiTable
{
 public:
	unsigned long __stdcall Release();
   bool WriteData();
 public:  // constructor
	static CStreamTable* Create(CMsiDatabase& riDatabase);
	CStreamTable(CMsiDatabase& riDatabase, IMsiStorage& riStorage);
 protected:
	bool m_fErrorOnRelease;
};

//____________________________________________________________________________
//
// CStorageTable definitions - subclassed table to manage raw substorages
//____________________________________________________________________________

class CStorageTable : public CStreamTable
{
 public:
	unsigned long __stdcall Release();
   bool WriteData();
 public:  // constructor
	static CStorageTable* Create(CMsiDatabase& riDatabase);
	CStorageTable(CMsiDatabase& riDatabase, IMsiStorage& riStorage);
};

inline CStorageTable::CStorageTable(CMsiDatabase& riDatabase, IMsiStorage& riStorage)
	: CStreamTable(riDatabase, riStorage) { m_fStorages = fTrue; }

//____________________________________________________________________________
//
// CStreamTable methods
//____________________________________________________________________________

CStreamTable* CStreamTable::Create(CMsiDatabase& riDatabase)
{
	IMsiStorage* piStorage = riDatabase.GetCurrentStorage();
	if (!piStorage)
		return 0;
	CStreamTable* piTable = new CStreamTable(riDatabase, *piStorage);
	PEnumMsiString pEnum(piStorage->GetStreamEnumerator());
	PMsiCursor pCursor(piTable->CreateCursor(fFalse));
	const IMsiString* pistrName;
	unsigned long cFetched;
	while (pEnum->Next(1, &pistrName, &cFetched) == S_OK)
	{
		pCursor->PutString(1, *pistrName);
		pistrName->Release();
		if (!pCursor->PutInteger(2, iPersistentStream)
		 || !pCursor->Insert())
		{
			piTable->Release();
			return 0;
		}
	}
	piTable->m_fDirty = 0;
	return piTable;
}

CStreamTable::CStreamTable(CMsiDatabase& riDatabase, IMsiStorage& riStorage)
	: CMsiTable(riDatabase, 0, 64/*rows*/, iNonCatalog), m_fErrorOnRelease(fFalse)
{
	m_pinrStorage = &riStorage;  // non-ref counted, refcnt held by database
	CreateColumn(icdString + icdPrimaryKey + icdTemporary + 62, *MsiString(sz_StreamsName));
	CreateColumn(icdObject + icdNullable   + icdTemporary, *MsiString(sz_StreamsData));
	m_rgiColumnDef[1] |= icdPersistent;  // allow CMsiCursor to check for stream column
	m_rgiColumnDef[2] |= icdPersistent;  // restrict objects to stream type
	riDatabase.AddTableCount();
}

bool CStreamTable::WriteData()
{
	bool fStat = true;
	if (m_idsUpdate != idsWrite || !(m_fDirty & iColumnBit(2)))
		return true;
	PMsiRecord pError(0);
	MsiTableData* pData =  m_rgiData;
	int cRows = m_cRows;
	for (; cRows--; pData += m_cWidth)
	{
		bool fOk = true;
		const IMsiString& ristrName = m_riDatabase.DecodeStringNoRef(pData[1]);
		int iInStream = pData[2];
		if (iInStream == 0)
		{
			if ((pError = m_pinrStorage->RemoveElement(ristrName.GetString(), fFalse)) != 0)
				fOk = fFalse;
		}
		else if (iInStream != iPersistentStream)
		{
			IMsiStream *piInStream = (IMsiStream *)GetObjectData(iInStream);
			piInStream->Reset(); //!! should clone stream here to save/restore current loc in stream
			IMsiStream* piOutStream;
			if ((pError = m_pinrStorage->OpenStream(ristrName.GetString(), fTrue, piOutStream)) != 0)
				fOk = fFalse;
			else
			{
				char rgbBuffer[512];
				int cbInput = piInStream->GetIntegerValue();
				while (cbInput > 0)
				{
					int cb = sizeof(rgbBuffer);
					if (cb > cbInput)
						cb = cbInput;
					piInStream->GetData(rgbBuffer, cb);
					piOutStream->PutData(rgbBuffer, cb);
					cbInput -= cb;
				}
				if (piInStream->Error() || piOutStream->Error())
					fOk = fFalse; // continue to process remaining data
				piOutStream->Release();
			}
			if (fOk)
				piInStream->Release();  // ref count from table
		}
		if (fOk)
			pData[2] = iPersistentStream;
		else
			fStat = false;
	}
	if (fStat)
		m_fDirty = 0;
	if (m_fErrorOnRelease)  // ref count transferred to database
		Release();
	return fStat;
}

unsigned long CStreamTable::Release()
{
	if (m_Ref.m_iRefCnt == 1)
	{
		if (!m_fErrorOnRelease && !WriteData())
		{
			m_fErrorOnRelease = true;  // try again on commit
			return m_Ref.m_iRefCnt;   // database now owns this refcnt
		}
		m_riDatabase.StreamTableReleased();
	}
	m_fErrorOnRelease = false;  // in case Commit called while other refs remain
	return CMsiTable::Release();
}

//____________________________________________________________________________
//
// CStorageTable methods
//____________________________________________________________________________

CStorageTable* CStorageTable::Create(CMsiDatabase& riDatabase)
{
	IMsiStorage* piStorage = riDatabase.GetCurrentStorage();
	if (!piStorage)
		return 0;
	CStorageTable* piTable = new CStorageTable(riDatabase, *piStorage);
	PEnumMsiString pEnum(piStorage->GetStorageEnumerator());
	PMsiCursor pCursor(piTable->CreateCursor(fFalse));
	const IMsiString* pistrName;
	unsigned long cFetched;
	while (pEnum->Next(1, &pistrName, &cFetched) == S_OK)
	{
		pCursor->PutString(1, *pistrName);
		pistrName->Release();
		if (!pCursor->PutInteger(2, iPersistentStream)
		 || !pCursor->Insert())
		{
			piTable->Release();
			return 0;
		}
	}
	piTable->m_fDirty = 0;
	return piTable;
}

bool CStorageTable::WriteData()
{
	bool fStat = true;
	if (m_idsUpdate != idsWrite || !(m_fDirty & iColumnBit(2)))
		return true;
	PMsiRecord pError(0);
	MsiTableData* pData = m_rgiData;
	int cRows = m_cRows;
	for (; cRows--; pData += m_cWidth)
	{
		bool fOk = true;
		const IMsiString& ristrName = m_riDatabase.DecodeStringNoRef(pData[1]);
		int iInStream = pData[2];
		if (iInStream == 0)
		{
			if ((pError = m_pinrStorage->RemoveElement(ristrName.GetString(), fTrue)) != 0)
				fOk = fFalse;
		}
		else if (iInStream != iPersistentStream)
		{
			IMsiStream* piInStream = (IMsiStream*)GetObjectData(iInStream);
			piInStream->Reset(); //!! should clone stream here to save/restore current loc in stream
			PMsiStorage pOutStorage(0);
			PMsiStorage pInStorage(0);
			pError = SRV::CreateMsiStorage(*piInStream, *&pInStorage);
			if (pError
			|| (pError = m_pinrStorage->OpenStorage(ristrName.GetString(), ismCreate, *&pOutStorage)) != 0
			|| (pError = pInStorage->CopyTo(*pOutStorage, 0)) != 0)
				fOk = fFalse;
			else
				piInStream->Release();  // ref count from table
		}
		if (fOk)
			pData[2] = iPersistentStream;
		else
			fStat = false;
	}
	if (fStat)
		m_fDirty = 0;
	if (m_fErrorOnRelease)  // ref count transferred to database
		Release();
	return fStat;
}

unsigned long CStorageTable::Release()
{
	if (m_Ref.m_iRefCnt == 1)
	{
		if (!m_fErrorOnRelease && !WriteData())
		{
			m_fErrorOnRelease = true;  // try again on commit
			return m_Ref.m_iRefCnt;   // database now owns this refcnt
		}
		m_riDatabase.StorageTableReleased();
	}
	m_fErrorOnRelease = false;  // in case Commit called while other refs remain
	return CMsiTable::Release();
}

//____________________________________________________________________________
//
//  CMsiDatabase virtual function implementation
//____________________________________________________________________________

HRESULT CMsiDatabase::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IMsiDatabase))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiDatabase::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}
unsigned long CMsiDatabase::Release()
{
	ReleaseTrack();
	if (m_Ref.m_iRefCnt == 1) // no external refs to database object remain
	{  // if tables are still loaded, remove all locks
		IMsiCursor* piCursor;
		if (m_iTableCnt != 0
		 && (piCursor = m_piCatalogTables->CreateCursor(fFalse)) != 0)
		{
			while (piCursor->Next()) // need separate cursor, table may be updated
			{	
				IMsiTable* piTable = (IMsiTable*)GetObjectData(piCursor->GetInteger(ctcTable));
				if (piTable)  // table still loaded
				{
					int iState = piCursor->GetInteger(~iTreeLinkMask);  // get raw row attribute bits
					if (iState & iRowTableSaveErrorBit)  // failed to persist on table release, refcnt held by database
					{
						int iName = piCursor->GetInteger(ctcName);
						m_piCatalogTables->SetTableState(iName, ictsNoSaveError);  // remove flag, fatal if fails this time
						piTable->Release();  // remove refcount set when itsSaveError state set, refcnt still held by pTable
					}

					while (m_piCatalogTables->SetTableState(piCursor->GetInteger(ctcName), ictsUnlockTable))
						;
				}
			}
			piCursor->Release();
		}

		if (m_piTransformCatalog)			// must be released before catalogs
		{
			m_piTransformCatalog->Release();
			m_piTransformCatalog=0;
		}

		if (m_iTableCnt == 0)
		{
			IMsiServices& riServices = m_riServices;  // save pointer before destruction
			delete this;  // remove ourselves before releasing Services
			riServices.Release();
			return 0;
		}
	}
	return --m_Ref.m_iRefCnt;
}

IMsiServices& CMsiDatabase::GetServices()
{
	m_riServices.AddRef();
	return m_riServices;
}

IMsiRecord* CMsiDatabase::OpenView(const ICHAR* szQuery, ivcEnum ivcIntent,
												IMsiView*& rpiView)
{
	return CreateMsiView(*this, m_riServices, szQuery, ivcIntent, rpiView);
}

IMsiRecord* CMsiDatabase::GetPrimaryKeys(const ICHAR* szTable)
{
	Block();
	IMsiRecord* pirecKeys;
	MsiString istrTableName(szTable);
	CMsiTable* piTable;
	int iState = m_piCatalogTables->GetLoadedTable(EncodeString(*istrTableName), piTable);
	if (iState == -1)
	{
		Unblock();
		return 0;
	}
	int cPrimaryKeys = 0;
	int iColumn = 1;
	if (piTable)
	{
		cPrimaryKeys = piTable->GetPrimaryKeyCount();
		pirecKeys = &SRV::CreateRecord(cPrimaryKeys);
		for (; iColumn <= cPrimaryKeys; iColumn++)
			pirecKeys->SetMsiString(iColumn, DecodeStringNoRef(piTable->GetColumnName(iColumn)));
		pirecKeys->SetMsiString(0, *istrTableName);
		Unblock();
		return pirecKeys;
	}
	// else must query column catalog table
	MsiStringId iTableName = EncodeString(*istrTableName);
	m_piColumnCursor->Reset();  //!! necessary?
	m_piColumnCursor->SetFilter(iColumnBit(cccTable));
	m_piColumnCursor->PutInteger(cccTable, iTableName);
	while (m_piColumnCursor->Next() && (m_piColumnCursor->GetInteger(cccType) & icdPrimaryKey))
		cPrimaryKeys++;
	pirecKeys = &SRV::CreateRecord(cPrimaryKeys);
	m_piColumnCursor->Reset();
	m_piColumnCursor->PutInteger(cccTable, iTableName);
	for (; iColumn <= cPrimaryKeys; iColumn++)
	{
		m_piColumnCursor->Next();
		pirecKeys->SetMsiString(iColumn, DecodeStringNoRef(m_piColumnCursor->GetInteger(cccName)));
	}
	m_piColumnCursor->Reset();  //!! necessary?
	pirecKeys->SetMsiString(0, *istrTableName);
	Unblock();
	return pirecKeys;
}

IMsiRecord* CMsiDatabase::ImportTable(IMsiPath& riPath, const ICHAR* szFile)
{
//!! critical section?
	IMsiRecord* piError = 0;

	// may change path so create a new path object
	PMsiPath pPath(0);
	piError = riPath.ClonePath(*&pPath);
	if(piError)
		return piError;

	Bool fSummaryInfo = fFalse;
	MsiString istrField;  // must have lifetime longer than last PostError
	const ICHAR* szError = szFile;  // text field for error message
	IMsiStorage* piStorage = GetOutputStorage();  // this pointer not ref counted
	if (!piStorage || m_idsUpdate != idsWrite)
		return PostError(Imsg(idbgDbNotWritable));

	int iFileCodePage = m_iCodePage;
	for(;;)  // retry loop in case codepage changed by import file
	{
	// read row of column names into array of strings
	int iRow = 1;  // for error reporting
	CFileRead File(iFileCodePage);
	if (!File.Open(*pPath, szFile))
		return PostError(Imsg(idbgDbImportFileOpen), szFile);
	MsiColumnDef rgColumnDef[32];
	MsiString rgistrName[32];
	const IMsiString* piData;
	ICHAR ch;
	IErrorCode iErr = 0;
	int iCol = 0;
	Bool fEmptyData = fFalse;
	do
	{
		if (iCol == 32)
			return PostError(Imsg(idbgDbImportFileRead), szFile, iRow);

		ch = File.ReadString(piData);
		if (!piData->TextSize())
			fEmptyData = fTrue;
		rgistrName[iCol] = *piData; // transfers refcnt
		iCol++;
	} while (ch != '\n');
	int nCol = iCol;

	// read row of column specifications, convert to MsiColumnDef format
	iRow++;
	iCol = 0;
	do
	{
		ch = File.ReadString(piData); // datatype
		if (!piData->TextSize())
		{
			fEmptyData = fTrue;
			continue;
		}
		int chType = piData->GetString()[0];
		piData->Remove(iseFirst, 1, piData);
		unsigned int iLength = piData->GetIntegerValue();
		piData->Release();
		if (iLength == iMsiStringBadInteger)
			return PostError(Imsg(idbgDbImportFileRead), szFile, iRow);
		int fNullable = 0;
		int icdType = 0;
		switch(chType | 0x20) // force lower case
		{
		case 'b':
			if (iLength == 0)
				icdType = icdShort;  // backwards compatibility
			else
				icdType = icdObject;
			break;
		case 'd':
			if (iLength == 6)  // date only
				icdType = icdShort;
			else if (iLength != 16) // date and time
				iErr = Imsg(idbgDbImportFileRead);
			break;
		case 'k':  // allow counter column for now, treat as integer
		case 'i':
			if (iLength <= 2)  // boolean, byte, or short
				icdType = icdShort;
			else if (iLength != 4) // long integer
				iErr = Imsg(idbgDbImportFileRead);
			break;
		case 'l':
			icdType = icdString + icdLocalizable;
			break;
		case 'c':
		case 's':
			icdType = icdString;
			break;
		case 'v':
			icdType = icdObject;
			break;
		default:
			iErr = Imsg(idbgDbImportFileRead);
		};
		if (iErr)
			return PostError(iErr, szFile, iRow);
		if (icdType == icdObject)  // stream column, create subdirectory
		{
			MsiString istrFolder(szFile);
			istrFolder.Remove(iseFrom, '.');   // remove extension
			PMsiRecord precError = pPath->AppendPiece(*istrFolder);
			Assert(precError == 0);
		}
		icdType |= iLength;
		icdType |= icdPersistent;
		if (chType <= 'Z')
			icdType |= icdNullable;
		rgColumnDef[iCol] = MsiColumnDef(icdType);
	} while (iCol++, ch != '\n');
	if (iCol != nCol)
		return PostError(Imsg(idbgDbImportFileRead), szFile, iRow);

	// read row containing codepage, table name, and primary key columns
	iRow++;
	MsiString istrTable;
	ch = File.ReadString(*&istrTable);  // table name, primary keys
	int iCodePage = istrTable;  // check if codepage specifier
	if (iCodePage != iMsiStringBadInteger)
	{
		if (iCodePage != 0 && iCodePage != CP_UTF8 && iCodePage != CP_UTF7 && !WIN::IsValidCodePage(iCodePage))
			return PostError(Imsg(idbgDbCodepageNotSupported), iCodePage);
		ch = File.ReadString(*&istrTable);  // next should be table name
		if (istrTable.Compare(iscExact, szForceCodepageTableName))
		{
			m_iCodePage = iCodePage & idbfCodepageMask; // unconditional code page override
			if (iCodePage & idbfHashBinCountMask)  // explicit hash bin count set, only affect persisted database
				m_iDatabaseOptions = (m_iDatabaseOptions & ~idbfHashBinCountMask) | (iCodePage & idbfHashBinCountMask);
			return 0;                  // ignore any data
		}
		if (m_iCodePage && iCodePage != m_iCodePage)
			return PostError(Imsg(idbgDbCodepageConflict), szFile, iRow);
		if (iCodePage != iFileCodePage)  // oops, possibly reading file with wrong codepage
		{
			iFileCodePage = iCodePage;   // reopen file using codepage stamped into file
			continue;
		}
	}
	if (fEmptyData || !ch || !istrTable.TextSize())
		return PostError(Imsg(idbgDbImportFileRead), szFile, iRow);
	int cKeys = 0;
	while (ch == '\t')  // read in primary keys, must be in column order or else
	{
		ch = File.ReadString(piData);
		int iMatch = 0;
		if (cKeys < nCol)
			iMatch = rgistrName[cKeys].Compare(iscExact, piData->GetString());
		piData->Release();
		if (!iMatch)
			return PostError(Imsg(idbgDbImportFileRead), szFile, iRow);
		rgColumnDef[cKeys++] |= icdPrimaryKey;
	}
	if (!cKeys)  //!! if no primary key, error, used to assume 1st column only
		return PostError(Imsg(idbgDbImportFileRead), szFile, iRow);

	// check for pseudo-table representing SummaryInformation stream
	CComPointer<CMsiTable> pTable(0);
	if (istrTable.Compare(iscExact, szSummaryInfoTableName))  // summary stream stored as table
	{
		if ((rgColumnDef[0] & icdObject)                  // Column 1 is PID, must be integer
		 || ((rgColumnDef[1] & icdString) != icdString))    // Column 2 is data, must be string
			return PostError(Imsg(idbgDbImportFileRead), szFile, iRow);
		fSummaryInfo = fTrue;
		if ((pTable = new CMsiTable(*this, 0, 0, iNonCatalog))==0) // temporary, not a catalog table
			return PostError(Imsg(idbgDbTableCreate), szSummaryInfoTableName);
	}
	else
	{
		// drop any existing table by that name
		piError = DropTable(istrTable);
		if (piError)
		{
			int iError = piError->GetInteger(1);
			if (iError == idbgDbTableUndefined)
				piError->Release(); // OK if table doesn't exist
			else if (iError == idbgStgRemoveStream) // OK no stream data for table
				piError->Release();
			else
				return piError;
		}
		piError = CreateTable(*istrTable, 0 /*initRows*/, (IMsiTable*&)*&pTable);
		if (piError)
			return piError;
	}
	// create new table according to column specifications
	for (iCol = 0; iCol < nCol; iCol++)
	{
		int iColumnDef = rgColumnDef[iCol];
		if (fSummaryInfo)
			iColumnDef &= ~icdPersistent;
		int iNewCol = pTable->CreateColumn(iColumnDef, *rgistrName[iCol]);
		Assert(iNewCol == iCol + 1);
	}

	// read data rows into cursor and insert rows into table
	PMsiCursor pCursor(pTable->CreateCursor(fFalse));
	for (;;)  // loop to read in rows
	{
		iRow++;
		for (iCol = 1; iCol <= nCol; iCol++)  // loop to read in fields
		{
			MsiColumnDef iColDef = rgColumnDef[iCol-1];
			ch = File.ReadString(*&istrField);
			if (ch == 0) //!! john, please confirm - chetanp
//			if (ch == 0 && iCol != nCol) //!! for now allow last line to be missing CR/LF
			{
				if (iCol != 1)
					iErr = Imsg(idbgDbImportFileRead); // file truncated
				break;
			}
			if (ch == '\n' && iCol != nCol)
			{
					iErr = Imsg(idbgDbImportFileRead); // record truncated
					break;
			}
			if (!istrField.TextSize())  // if null data
			{
				if (!(iColDef & icdNullable))
					iErr = Imsg(idbgDbImportFileRead); // nulls not accepted
			}
			else if (!(iColDef & icdObject)) // integer
			{
				int i = istrField;
				if (i == iMsiStringBadInteger || !pCursor->PutInteger(iCol, i))
					iErr = Imsg(idbgDbImportFileRead); // invalid integer
			}
			else if (iColDef & icdShort)  // string
			{
				//!! should also handle long text data here
				pCursor->PutString(iCol, *istrField);
				//!! if (non-ASCII data && iCodePage not set) iCodePage = WIN::GetACP();
			}
			else // binary stream
			{
				szError = istrField; // set name in error message
				CFileRead LongDataFile;
				if (!LongDataFile.Open(*pPath, istrField))
				{
					iErr = Imsg(idbgDbImportFileRead); // couldn't open stream file
					break;
				}
				unsigned int cbBuf = LongDataFile.GetSize();
				IMsiStream* piStream;
				char* pbBuf = SRV::AllocateMemoryStream(cbBuf, piStream);
				if (!pbBuf)
				{
					iErr = Imsg(idbgDbDataMemory);
					break;
				}
				if (LongDataFile.ReadBinary(pbBuf, cbBuf) == cbBuf)
					pCursor->PutMsiData(iCol, piStream);
				else
					iErr = Imsg(idbgDbImportFileRead); // couldn't read all bytes from file
				piStream->Release();
				szError = szFile; // restore
			}
		}
		if (iErr != 0 || iCol == 1)  // error or end of file
			break;
		if (!pCursor->Insert())
			return PostError(Imsg(idbgDbImportFileRead), szFile, iRow); // key violation
		pCursor->Reset();  // clear fields to null for next row
	}
	if (iErr)
	{
		DropTable(istrTable);
		return PostError(iErr, szError, iRow);
	}
	Bool fSuccess = fTrue;
	if (fSummaryInfo)
		fSuccess = pTable->SaveToSummaryInfo(*piStorage);
	else
		fSuccess = pTable->SaveToStorage(*istrTable, *piStorage);
	if (iCodePage != iMsiStringBadInteger)
		m_iCodePage = iCodePage;
	if (!fSuccess)
		return PostError(Imsg(idbgDbSaveTableFailure), *istrTable); // save to storage failed
	break;
	} // end of codepage retry loop, always breaks unless continue from within
	return 0;
}

const int rgcbDate[6] = { 7, 4, 5, 5, 6, 5 };  // bits for each date field
const char rgchDelim[6] = "// ::";
void DateTimeToString(int iDateTime, ICHAR* rgchBuffer, DWORD cchSize) // must be at least 20 characters long
{
	int iValue;
	int rgiDate[6];
	for (iValue = 5; iValue >= 0; iValue--)
	{
		rgiDate[iValue] = iDateTime & (( 1 << rgcbDate[iValue]) - 1);
		iDateTime >>= rgcbDate[iValue];
	}
	rgiDate[0] += 1980;
	rgiDate[5] *= 2;
	ICHAR* pBuffer = rgchBuffer;
	if (rgiDate[0] != 0 || rgiDate[1] != 0)
	{
		StringCchPrintf(pBuffer, cchSize, TEXT("%4i/%02i/%02i "), rgiDate[0],rgiDate[1],rgiDate[2]);
		size_t i;
		StringCchLength(pBuffer, cchSize, &i);
		pBuffer += i;
		cchSize -= i;
	}
	StringCchPrintf(pBuffer, cchSize, TEXT("%02i:%02i:%02i"), rgiDate[3],rgiDate[4],rgiDate[5]);
}

IMsiRecord* CMsiDatabase::ExportTable(const ICHAR* szTable, IMsiPath& riPath, const ICHAR* szFile)
{
//!! critical section? needed if access simultaneously by custom actions
	CFileWrite File(m_iCodePage);
	IMsiRecord* piError = 0;

	// may change path so create a new path object
	PMsiPath pPath(0);
	piError = riPath.ClonePath(*&pPath);
	if(piError)
		return piError;

	// check for pseudo-table representing forced codepage setting
	if (m_piStorage && IStrComp(szTable, szForceCodepageTableName) == 0)
	{
		if (!File.Open(*pPath, szFile))
			return PostError(Imsg(idbgDbExportFile), szFile);
		File.WriteString(0, fTrue);
		File.WriteString(0, fTrue);
		File.WriteInteger(m_iCodePage + (m_iDatabaseOptions & idbfHashBinCountMask), fFalse);
		File.WriteString(szForceCodepageTableName, fTrue);
		return 0;
	}

	// check for pseudo-table representing SummaryInformation stream, MSI databases only
	if (m_piStorage && IStrComp(szTable, szSummaryInfoTableName) == 0)
	{
		PMsiSummaryInfo pSummary(0);
		IMsiRecord* piError = m_piStorage->CreateSummaryInfo(0, *&pSummary);
		if (piError)
			return piError;
		if (!File.Open(*pPath, szFile))
			return PostError(Imsg(idbgDbExportFile), szFile);
		File.WriteString(szSummaryInfoColumnName1, fFalse);
		File.WriteString(szSummaryInfoColumnName2, fTrue);
		File.WriteString(szSummaryInfoColumnType1, fFalse);
		File.WriteString(szSummaryInfoColumnType2, fTrue);
		File.WriteString(szSummaryInfoTableName,   fFalse);
		File.WriteString(szSummaryInfoColumnName1, fTrue);
		int cProperties = pSummary->GetPropertyCount();
		int iPropType;
		for (int iPID = 0; cProperties; iPID++)
		{
			if ((iPropType = pSummary->GetPropertyType(iPID)) == 0)
				continue;
			cProperties--;
			ICHAR rgchTemp[20];
			File.WriteInteger(iPID, fFalse);
			int iValue;
			int iDateTime;
			switch (iPropType)
			{
			case VT_I2:
			case VT_I4:
				pSummary->GetIntegerProperty(iPID, iValue);
				File.WriteInteger(iValue, fTrue);
				break;
			case VT_LPSTR:
				File.WriteMsiString(*MsiString(pSummary->GetStringProperty(iPID)), fTrue);
				break;
			case VT_FILETIME:
				pSummary->GetTimeProperty(iPID, (MsiDate&)iDateTime);
				DateTimeToString(iDateTime, rgchTemp, sizeof(rgchTemp)/sizeof(ICHAR));
				File.WriteString(rgchTemp, fTrue);
				break;
			case VT_CF:
				File.WriteString(TEXT("(Bitmap)"), fTrue);
				break;
			default:
				File.WriteString(TEXT("(Unknown format)"), fTrue);
			}
		}
		if (!File.Close())
			return PostError(Imsg(idbgDbExportFile), szFile);
		return 0;
	}

	// load table into memory, insure not temporary table
	MsiString istrTableName(szTable);
	MsiString istrSubFolder;
	CComPointer<CMsiTable> pTable(0);
	piError = LoadTable(*istrTableName, 0, *(IMsiTable**)&pTable);
	if (piError)
		return piError;
	int cPersist = pTable->GetPersistentColumnCount();
	if (!cPersist)
		return PostError(Imsg(idbgDbExportFile), szFile);

	// open output file
	if (!File.Open(*pPath, szFile))
		return PostError(Imsg(idbgDbExportFile), szFile);

	// output row of column names
	int iCol;
	for (iCol = 1; iCol <= cPersist; iCol++)
		File.WriteMsiString(DecodeStringNoRef(pTable->GetColumnName(iCol)),iCol==cPersist);

	// output row of column specifications
	MsiColumnDef* pColumnDef = pTable->GetColumnDefArray();
	for (iCol = 1; iCol <= cPersist; iCol++)
	{
		MsiColumnDef iColumnDef = *(++pColumnDef);
		int iSize = iColumnDef & icdSizeMask;
		ICHAR chType = 'i';
		if (!(iColumnDef & icdObject)) // integer
		{
			if (iColumnDef & icdShort)
			{
				if (iSize == 6)
					chType = 'd';
			}
			else
			{
				if (iSize == 16)
					chType = 'd';
				else if (!iSize)
				{
					Assert(0); //!! until test at create column
					iSize = 4;
				}
			}
		}
		else if (iColumnDef & icdShort) // string
		{
			chType = (iColumnDef & icdLocalizable) ? 'l' : 's';
		}
		else // persistent stream
		{
			chType = 'v'; //!! will change to 'b'
			MsiString istrFolder(szFile);
			istrFolder.Remove(iseFrom, '.');   // remove extension
			PMsiRecord precError = pPath->AppendPiece(*istrFolder); // create subdirectory for stream files
			Assert(precError == 0);
			int cCreated;
			precError = pPath->EnsureExists(&cCreated);
			Assert(precError == 0);
		}
		if (iColumnDef & icdNullable)
			chType -= ('a' - 'A');
		ICHAR szTemp[20];
		StringCchPrintf(szTemp, (sizeof(szTemp)/sizeof(ICHAR)), TEXT("%c%i"), chType, iSize);
		File.WriteString(szTemp, iCol==cPersist);
	}

	// output codepage if non-neutral codepage
	IMsiCursor* piCursor = pTable->CreateCursor(fFalse);
	const IMsiString* piStr;
	Bool fExtended = fFalse;   // scan for non-ASCII characters
	while (!fExtended && piCursor && piCursor->Next())
	{
		pColumnDef = pTable->GetColumnDefArray();
		for (iCol = 1; iCol <= cPersist; iCol++)
		{
			MsiColumnDef iColumnDef = *(++pColumnDef);
			if ((iColumnDef & (icdObject | icdShort)) == (icdObject | icdShort))
			{
				piStr = &piCursor->GetString(iCol);
				const ICHAR* pch = piStr->GetString();
				while (*pch)
					if (*pch++ >= 0x80)
					{
						fExtended = fTrue;
						iCol = cPersist;
						break;  // break out of all three loops
					}
				piStr->Release();
			}
		}
	}
	if (piCursor)
		piCursor->Release();
	if (fExtended)
	{
		int iCodePage = m_iCodePage;   // use codepage of database
		if (iCodePage == 0)            // if no database codepage, use current codepage
			iCodePage = WIN::GetACP();
		File.WriteInteger(iCodePage, fFalse);
	}

	// output table name and primary key columns
	int cPrimaryKey = pTable->GetPrimaryKeyCount();
	for (iCol = 0; iCol <= cPrimaryKey; iCol++)
	{
		MsiStringId iName = iCol ? pTable->GetColumnName(iCol) : pTable->GetTableName();
		File.WriteMsiString(DecodeStringNoRef(iName),iCol==cPrimaryKey);
	}

	// output table rows
	PMsiCursor pCursor(pTable->CreateCursor(ictTextKeySort));
	while (pCursor && pCursor->Next())
	{
		pColumnDef = pTable->GetColumnDefArray();
		for (iCol = 1; iCol <= cPersist; iCol++)
		{
			MsiColumnDef iColumnDef = *(++pColumnDef);
			MsiString strColData;
			if (!(iColumnDef & icdObject)) // integer
			{
				File.WriteInteger(pCursor->GetInteger(iCol), iCol==cPersist);
				continue;
			}
			else if (iColumnDef & icdShort) // string
			{
				strColData = pCursor->GetString(iCol);
				//FUTURE if size == 0, then we could ".imd" extension and use separate file
			}
			else // persistent stream
			{
				PMsiStream pStream(pCursor->GetStream(iCol));
				if (pStream)
				{
					// Compute stream name for filename
					strColData = pCursor->GetMoniker();
					strColData.Remove(iseIncluding, '.'); // subtract table name and '.'
					strColData += TEXT(".ibd"); // append default extension
					CFileWrite LongDataFile;
					if (!LongDataFile.Open(*pPath, strColData))
						return PostError(Imsg(idbgDbExportFile), *strColData);

					CTempBuffer<char,1> rgchBuf(1024);
					int cbRead, cbWrite;
					do
					{
						cbRead = rgchBuf.GetSize();
						cbWrite = pStream->GetData(static_cast<char*>(rgchBuf), cbRead);
						if (cbWrite)
							LongDataFile.WriteBinary(rgchBuf, cbWrite);
					} while (cbWrite == cbRead);
				}
			}
			File.WriteMsiString(*strColData,iCol==cPersist);
		}
	}
	if (!File.Close())
		return PostError(Imsg(idbgDbExportFile), szFile);
	return 0;
}

IMsiRecord* CMsiDatabase::DropTable(const ICHAR* szName)
{
	IMsiRecord* piError;
	CComPointer<CMsiTable> piTable(0);
	MsiString istrTable(szName);
	MsiStringId iTableName = EncodeString(*istrTable);
	CMsiTable* piTableTemp;
	int iState = m_piCatalogTables->GetLoadedTable(iTableName, piTableTemp);
	if (iState == -1)
		return PostError(Imsg(idbgDbTableUndefined), szName);
	if (iState & iRowTemporaryBit)
		return PostError(Imsg(idbgDbDropTable), szName);
	Block();
	if (m_piStorage || piTableTemp)
	{
		if ((piError = LoadTable(*istrTable, 0, (IMsiTable*&)*&piTable)) != 0)
			return Unblock(), piError;
	}
	IMsiStorage* piStorage = GetOutputStorage();
	Bool fRemoveFromStorage = piStorage ? fTrue : fFalse;
	if (!piTable || piTable->GetInputStorage() != piStorage) // streams never transferred
		fRemoveFromStorage = fFalse;
	if (fRemoveFromStorage)
	{
		if ((piError = piStorage->RemoveElement(szName, Bool(fFalse | iCatalogStreamFlag))) != 0)
			piError->Release(); // Stream might not exist....
		if (!piTable->RemovePersistentStreams(iTableName, *m_piStorage))
			return Unblock(), PostError(Imsg(idbgDbDropTable), szName);
	}
	while(m_piCatalogTables->SetTableState(iTableName, ictsUnlockTable)) // remove locks
		;
	// remove entries from catalogs
	m_piCatalogTables->SetTableState(iTableName, ictsTemporary); //!! TEMP to force TableReleased to delete row
	TableReleased(iTableName);  // remove entry from table catalog
	m_piColumnCursor->Reset();  //!! necessary?
	m_piColumnCursor->SetFilter(iColumnBit(cccTable));
	m_piColumnCursor->PutInteger(cccTable, iTableName);
	while (m_piColumnCursor->Next())
		m_piColumnCursor->Delete();
	if (piTable)
		piTable->TableDropped(); // remove all data and definitions
	Unblock();
	return 0;
}  // TableReleased() will not be called again since m_fNonCatalog is true

bool CMsiDatabase::GetTableState(const ICHAR * szTable, itsEnum its)
{
	Block();
	bool fRet = m_piCatalogTables->GetTableState(EncodeStringSz(szTable), (ictsEnum)its);
	Unblock();
	return fRet;
}

int CMsiDatabase::GetANSICodePage()
{
	return m_iCodePage;
}


//!! OBSOLETE - will remove soon
itsEnum CMsiDatabase::FindTable(const IMsiString& ristrTable)  //!! OBSOLETE
{
	CMsiTable* piTable;
	int iState = m_piCatalogTables->GetLoadedTable(EncodeString(ristrTable), piTable);
	if (iState == -1)
		return  itsUnknown;
	if (piTable == 0)
		return  itsUnloaded; // or itsTransform
	if (iState & iRowTemporaryBit)
		return itsTemporary;
	return itsLoaded; // or itsSaveError
}

IMsiRecord*  CMsiDatabase::LoadTable(const IMsiString& ristrTable,
												 unsigned int cAddColumns,
												 IMsiTable*& rpiTable)
{
	IMsiRecord* piError = 0;
	CMsiTable* piTable;
	int iName  = EncodeString(ristrTable);
	Block();
	int iState = m_piCatalogTables->GetLoadedTable(iName, piTable);
	if (iState == -1)
	{
		if (ristrTable.Compare(iscExact, szStreamCatalog) != 0)
		{
			if (!m_piCatalogStreams)
				m_piCatalogStreams = CStreamTable::Create(*this);
			else
				m_piCatalogStreams->AddRef();
			piTable = m_piCatalogStreams;
		}
		else if (ristrTable.Compare(iscExact, szStorageCatalog) != 0)
		{
			if (!m_piCatalogStorages)
				m_piCatalogStorages = CStorageTable::Create(*this);
			else
				m_piCatalogStorages->AddRef();
			piTable = m_piCatalogStorages;
		}
		else
			piTable = 0;
		rpiTable = piTable;        // the single refcnt transferred to caller
		Unblock();
		return piTable ? 0 : PostError(Imsg(idbgDbTableUndefined), ristrTable);
	}
	if (piTable == 0)   // table not in memory
	{  // unfortunately we don't know how many rows we have, too slow to execute twice
		Bool fStat;
		if ((piTable = new CMsiTable(*this, iName, 0, cAddColumns)) != 0)
		{
			int cbStringIndex = (iState & iRowTableStringPoolBit) ? 2 : m_cbStringIndex;
			int cbFileWidth = piTable->CreateColumnsFromCatalog(iName, cbStringIndex);
			if (piTable->GetColumnCount() + cAddColumns > cMsiMaxTableColumns)
				fStat = fFalse;
			else if (iState & iRowTableOutputDbBit)
				fStat = piTable->LoadFromStorage(ristrTable, *m_piOutput, cbFileWidth, cbStringIndex);
			else if (m_piStorage)  // itsUnloaded and MSI storage
				fStat = piTable->LoadFromStorage(ristrTable, *m_piStorage, cbFileWidth, cbStringIndex);
			else // no storage, can ever happen?
				fStat = fFalse;
			if (fStat == fFalse)
			{
				piTable->MakeNonCatalog();  // remove name to prevent catalog operations
				piTable->Release();
				piTable = 0;
			}
		}
		if (!piTable)
			piError = PostError(Imsg(idbgDbTableCreate), ristrTable);
		else
		{
			m_iTableCnt++;             // keep count of table objects
			// set the cursor position back to where it belongs
			int iState = m_piCatalogTables->SetLoadedTable(iName, piTable); // will addref only if locked
			while (cAddColumns)  // fill temp columns with null
				piTable->FillColumn(piTable->GetColumnCount() + cAddColumns--, 0);
			if (m_piCatalogTables->GetTableState(iName, ictsTransform))
			{
				piError = ApplyTransforms(iName, *piTable, iState);
				if (piError)
				{
					piTable->Release();
					Unblock();
					return piError;
				}
			}
		}
	}
	else
		piTable->AddRef();
	rpiTable = piTable;        // refcnt transferred to caller
	Unblock();
	return piError;
}

IMsiRecord* CMsiDatabase::CreateTable(const IMsiString& ristrTable,
												  unsigned int cInitRows,
												  IMsiTable*& rpiTable)
{
	IMsiTable* piTable;
	IMsiRecord* piError = 0;
	Block();
	if (m_piCatalogTables->GetTableState(EncodeString(ristrTable), ictsTableExists))
	{
		piTable = 0;
		piError = PostError(Imsg(idbgDbTableDefined), ristrTable);
	}
	else
	{
		m_piTableCursor->PutString(ctcName, ristrTable);  // does a BindString
		int iName = m_piTableCursor->GetInteger(ctcName);
		if (!iName)
		{
			piTable = 0;
			piError = PostError(Imsg(idbgDbNoTableName));
		}
		else if ((piTable = new CMsiTable(*this, iName, cInitRows, 0)) != 0)
		{
			m_piTableCursor->PutMsiData(ctcTable, piTable);      // adds a refcnt
			m_piTableCursor->PutInteger(0, 1<<iraTemporary);  // temporary if no columns
			AssertNonZero(m_piTableCursor->Insert());
			m_iTableCnt++;                // keep count of table objects
			piTable->Release();  // release extra refcnt by catalog table insert
		}
		else
			piError = PostError(Imsg(idbgDbTableCreate), ristrTable);
	}
	m_piTableCursor->Reset();   // clear ref counts in cursor
	rpiTable = piTable;           // the single refcnt transferred to caller
	Unblock();
	return piError;
}

Bool CMsiDatabase::LockTable(const IMsiString& ristrTable, Bool fLock)
{
	if (m_Ref.m_iRefCnt == 0)
		return fFalse;
	bool fRet;
	Block();
		fRet = m_piCatalogTables->SetTableState(EncodeString(ristrTable), fLock?ictsLockTable:ictsUnlockTable);
	Unblock();
	return fRet ? fTrue : fFalse;
}

IMsiTable* CMsiDatabase::GetCatalogTable(int iTable)
{
	IMsiTable* piTable;
	switch (iTable)
	{
	case 0:  piTable = m_piCatalogTables;  break;
	case 1:  piTable = m_piCatalogColumns; break;
	default: piTable = 0;
	};
	if (piTable)
		piTable->AddRef();
	return piTable;
}

const IMsiString& CMsiDatabase::CreateTempTableName()
{
	static ICHAR rgchTempName[] = TEXT("#TEMP0000");  // leading '#' designates SQLServer local temp table
	Block();
	ICHAR* pchName = rgchTempName + sizeof(rgchTempName)/sizeof(ICHAR) - 2; // last char
	ICHAR ch;
	while ((ch = *pchName) >= '9')
	{
		*pchName = '0';  // overflow digit to next
		if (ch == '9')   // if was a digit
			pchName--;
	}
	(*pchName)++;
	const IMsiString* piName = &::CreateString();
	piName->SetString(rgchTempName, piName);
	Unblock();
	return *piName;
}

IMsiRecord* CMsiDatabase::CreateOutputDatabase(const ICHAR* szFile, Bool fSaveTempRows)
//!! fSaveTempRows is not supported and could be removed, along with m_fSaveTempRows
{
	if (m_piOutput != 0)
		return PostError(Imsg(idbgCreateOutputDb), szFile);

	if (!szFile) // the mode where szFile == 0 is obsolete and should generate an error
		szFile = TEXT("");

	ismEnum ismOpen = ismCreate;
		m_pguidClass = &STGID_MsiDatabase2;
	if (m_fRawStreamNames)
	{
		ismOpen = ismEnum(ismCreate + ismRawStreamNames);
		m_pguidClass = &STGID_MsiDatabase1;
	}
	Block();
	IMsiRecord* piError = CreateMsiStorage(szFile, ismOpen, m_piOutput);
	Unblock();
	if (piError)
		return piError;

	m_idsUpdate = idsWrite;
	m_fSaveTempRows = fSaveTempRows;  // not supported
	return 0;
}

IMsiRecord* CMsiDatabase::Commit()
{
	Bool fStat;
	IMsiStream* piStream;
	IMsiRecord* piError;
	IMsiRecord* piTransformError = 0;
	IMsiStorage* piStorage = GetOutputStorage(); // doesn't bump refcnt - don't release
	if (!piStorage)
		return 0;  // ignore if read-only

	int cErrors = 0;
	if ((piError = piStorage->OpenStream(szTableCatalog, Bool(fTrue + iCatalogStreamFlag), piStream)) != 0)
		return piError;
	CTempBuffer<MsiCacheRefCnt, 1> rgRefCnt(m_cCacheUsed);  // non-persistent string ref counts
	Block();
	int cTempRefCnt = rgRefCnt.GetSize();
	memset(rgRefCnt, 0, sizeof (MsiCacheRefCnt) * cTempRefCnt);
	m_rgiCacheTempRefCnt = rgRefCnt; // set for DerefTemporaryString

	if (m_piCatalogStreams  && !m_piCatalogStreams->WriteData())
		cErrors++;
	if (m_piCatalogStorages && !m_piCatalogStorages->WriteData())
		cErrors++;

	IMsiCursor* piCursor = m_piCatalogTables->CreateCursor(fFalse);
	//!!FIX
	((CMsiCursor*)(IMsiCursor*)piCursor)->m_idsUpdate = idsWrite; //!!FIX allow updates
	//!!FIX

	int cbOldStringIndex = m_cbStringIndex;

	while (piCursor->Next()) // need separate cursor, table may be updated
	{
		int cbFileWidth;
		int iName = piCursor->GetInteger(ctcName);
		const IMsiString& riTableName = DecodeStringNoRef(iName); // not ref counted

		CComPointer<CMsiTable> pTable((CMsiTable*)piCursor->GetMsiData(ctcTable));
		int iState = piCursor->GetInteger(~iTreeLinkMask);  // get raw row attribute bits
		if (pTable == 0)  // not loaded
		{
			if ((iState & iRowTableStringPoolBit) != 0
			 || (iState & iRowTableTransformBit) != 0
			 ||((iState & iRowTableOutputDbBit) == 0 && m_piOutput != 0))
			{
				if (!(pTable = new CMsiTable(*this, iName, 0, iNonCatalog))) // avoid catalog mgmt
				{
					cErrors++;
					continue;
				}
				int cbStringIndex = (iState & iRowTableStringPoolBit) ? 2 : m_cbStringIndex;
				cbFileWidth = pTable->CreateColumnsFromCatalog(iName, cbStringIndex);
				fStat = pTable->LoadFromStorage(riTableName, *m_piStorage, cbFileWidth, cbStringIndex);
				if (fStat == fFalse)
				{
					cErrors++;
					continue;
				}
				else
				{
					if (m_piOutput && !(iState & iRowTableOutputDbBit))
						m_piCatalogTables->SetTableState(iName, ictsOutputDb);
				}

				if (iState & iRowTableTransformBit)
				{
					piError = ApplyTransforms(iName, *pTable, iState);
					if (piError)
					{
						if (piTransformError)
							piError->Release(); // keep first one
						else
							piTransformError = piError;
						cErrors++;
						continue;
					}
				}
				fStat = pTable->SaveToStorage(riTableName, *piStorage);
				if (fStat == fFalse)
				{
					cErrors++;
					continue;
				}
				// table will be released at end of loop
			}
		}
		else if (iState & iRowTemporaryBit) // temporary table loaded
		{
			pTable->DerefStrings();
			continue;
		}
		else  // persistent table already loaded
		{
			if (iState & iRowTableSaveErrorBit)  // failed to persist on table release, refcnt held by database
			{
				m_piCatalogTables->SetTableState(iName, ictsNoSaveError);  // remove flag, fatal if fails this time
				AssertNonZero(pTable->Release());  // remove refcount set when itsSaveError state set, refcnt still held by pTable
//				iNewState &= ~iRowTableSaveErrorBit;
			}
			pTable->DerefStrings();  // table remains in memory
			fStat = pTable->SaveToStorage(riTableName, *piStorage);
			if (fStat == fFalse)
			{
				cErrors++;
				continue;
			}
		}
//		if (iNewState != iState)
//		{
//			piCursor->PutInteger(~iTreeLinkMask, iNewState);
//			if (!piCursor->Update())
//				cErrors++; // should never happen
//		}
		piStream->PutData(&iName, m_cbStringIndex);  // table catalog row, name only
	}
	piCursor->Release();
	piStream->Release();  // close table catalog stream

	if (cbOldStringIndex != m_cbStringIndex) // transform may have increased the string index size. if this is the case then we need to go again.
	{
		DEBUGMSG(TEXT("Change in string index size during commit. Recommitting database."));
		return Unblock(), Commit();
	}
	else
	{
		m_idsUpdate = idsWrite; // restore state in case of any error below
		if (piTransformError)
			return Unblock(), piTransformError;
		if (cErrors)
			return Unblock(), PostError(Imsg(idbgDbCommitTables));

		// write catalog tables to storage and deref temporary table refs
		CMsiTable* pTable = m_piTables;
		while(pTable)
		{
			pTable->DerefStrings();
			pTable = pTable->GetNextNonCatalogTable();
		}
		if (!m_piCatalogColumns->SaveToStorage(*MsiString(*szColumnCatalog), *piStorage)
		 || (piError = StoreStringCache(*piStorage, rgRefCnt, cTempRefCnt)) != 0
		 || (m_pguidClass && (piError = piStorage->SetClass(*m_pguidClass)) != 0)
		 || (piError = piStorage->Commit()) != 0)
			return Unblock(), piError;
	}
	Unblock();
	return 0;
}

IMsiRecord* CMsiDatabase::StoreStringCache(IMsiStorage &riStorage, MsiCacheRefCnt* rgRefCntTemp, int cRefCntTemp)
{
	// write string cache to storage

	IMsiRecord* piError;
	PMsiStream pPoolStream(0);
	PMsiStream pDataStream(0);
	if ((piError = riStorage.OpenStream(szStringPool, Bool(fTrue + iCatalogStreamFlag), *&pPoolStream)) != 0
	 || (piError = riStorage.OpenStream(szStringData, Bool(fTrue + iCatalogStreamFlag), *&pDataStream)) != 0)
		return piError;

	CTempBuffer<char, 1> rgbBuf(1024);  // intermediate buffer for non-Unicode strings
	int cBadStrings = 0;
	DWORD dwFlags = 0; // WC_COMPOSITECHECK fails on Vietnamese
	const char* szDefault = "\177";
	BOOL fDefaultUsed = 0;
	BOOL* pfDefaultUsed = &fDefaultUsed;
	if (m_iCodePage >= CP_UTF7 || m_iCodePage >= CP_UTF8)
	{
		dwFlags = 0;    // flags must be 0 to avoid invalid argument errors
		szDefault = 0;
		pfDefaultUsed = 0;
	}

	pPoolStream->PutInt32(m_iCodePage + m_iDatabaseOptions); // write header entry
	int cEntries = m_cCacheUsed;
	MsiCacheLink*   pCache = m_rgCacheLink; // skip over header, [0], null string index
	MsiCacheRefCnt* pRefCnt = m_rgCacheRefCnt;
	int iPool;
	while (--cEntries > 0)  // truncate empty entries at end, keep [0] entry for codepage and flags
	{
		iPool = pRefCnt[cEntries] & 0x7FFF;
		if (cRefCntTemp > cEntries)
			iPool -= rgRefCntTemp[cEntries];
		if (iPool != 0)
			break;
		if (cRefCntTemp > cEntries)
			cRefCntTemp--;
	}
	while (++pCache, ++pRefCnt, cEntries-- != 0)
	{
		iPool = *pRefCnt & 0x7FFF;
		if (--cRefCntTemp > 0)
			iPool -= *(++rgRefCntTemp);
		if (iPool != 0)
		{
			const IMsiString* piStr = pCache->piString;
			int cch = piStr->TextSize();
			int cb = WIN::WideCharToMultiByte(m_iCodePage, dwFlags,
								piStr->GetString(), cch, rgbBuf, rgbBuf.GetSize(), szDefault, pfDefaultUsed);
			if (cb == 0)   // can only happen on invalid argurment or buffer overflow
			{
				cb = WIN::WideCharToMultiByte(m_iCodePage, dwFlags,
								piStr->GetString(), cch, 0, 0, 0, 0);
				rgbBuf.SetSize(cb);
				cb = WIN::WideCharToMultiByte(m_iCodePage, dwFlags,
								piStr->GetString(), cch, rgbBuf, rgbBuf.GetSize(), szDefault, pfDefaultUsed);
				Assert(cb);
			}
			if (fDefaultUsed)
				cBadStrings++;
			iPool <<= 16;
			if (cb > cch)   // must be DBCS characters in string
				iPool |= (1<<31);
			if (cb > 0xFFFF)
			{
				pPoolStream->PutInt32(iPool);  // 0 length designates next int as extended size
				iPool = 0;
			}
			iPool += cb;
			pDataStream->PutData(rgbBuf, cb);

		}
		pPoolStream->PutInt32(iPool);
	}
	if (cBadStrings)
	{
		DEBUGMSG1(TEXT("Database Commit: %i strings with unconvertible characters"), (const ICHAR*)(INT_PTR)cBadStrings);
	}
	if (pDataStream->Error() | pPoolStream->Error())
		return PostError(Imsg(idbgDbCommitTables));
	
	return 0;
}

idsEnum CMsiDatabase::GetUpdateState()
{
	return m_idsUpdate;
}

IMsiStorage* CMsiDatabase::GetStorage(int iStorage)
{
	IMsiStorage* piStorage = 0;
	if (iStorage == 0) // output database
	{
		piStorage = m_piOutput;
	}
	else if (iStorage == 1) // input (main) database
	{
		piStorage = m_piStorage;
	}
	else // transform storage file
	{
		// Apply all transforms, in order
		IMsiCursor* piCursor = m_piTransformCatalog->CreateCursor(fFalse);
		Assert(piCursor);

		piCursor->PutInteger(tccID, iStorage);
		if (piCursor->Next())
			piStorage = (IMsiStorage*)piCursor->GetMsiData(tccTransform);

		piCursor->Release();	
	}
	if (piStorage)
		piStorage->AddRef();
	return piStorage;
}



//____________________________________________________________________________
//
//  CMsiDatabase non-virtual implementation
//____________________________________________________________________________

CMsiDatabase::CMsiDatabase(IMsiServices& riServices)  // members zeroed bv operator new
 : m_cCacheInit(cCacheInitSize), m_cHashBins(1<<cHashBitsDefault), m_riServices(riServices)
{
	m_riServices.AddRef();
	m_piDatabaseName = &g_MsiStringNull;
	Debug(m_Ref.m_pobj = this);
	WIN::InitializeCriticalSection(&m_csBlock);
#if !defined(_WIN64) && defined(DEBUG)
	g_fUseObjectPool = GetTestFlag('O');
#endif // _WIN64
}

CMsiDatabase::~CMsiDatabase() // cannot be called until all tables released
{
	if (m_idsUpdate == idsWrite)
	{
		IMsiStorage* piStorage = GetOutputStorage();
		if (piStorage)    // ignore if read-only
		{
			IMsiRecord* piError = piStorage->Rollback();
			if (piError)
				SRV::SetUnhandledError(piError);
		}
	}

	if (m_piCatalogTables)
		m_piCatalogTables->Release();
	if (m_piTableCursor)
		m_piTableCursor->Release();
	if (m_piCatalogColumns)
		m_piCatalogColumns->Release();
	if (m_piColumnCursor)
		m_piColumnCursor->Release();
	if (m_piCatalogStreams)  // unprocessed error
		m_piCatalogStreams->Release();
	if (m_piCatalogStorages)  // unprocessed error
		m_piCatalogStorages->Release();
	
	delete [] m_rgHash;
	if (m_rgCacheLink)
	{
		if (m_cCacheUsed > 0)
		{
			MsiCacheLink* pCache = m_rgCacheLink + m_cCacheUsed;  // free in reverse order to help debug mem mgr
			for (int cEntries = m_cCacheUsed; --pCache,--cEntries != 0; )
			{
				if (pCache->piString)
					pCache->piString->Release();
			}
		}
		GlobalUnlock(m_hCache);
		GlobalFree(m_hCache);
	}
	m_piDatabaseName->Release();
	if (m_piStorage)
		m_piStorage->Release();
	if (m_piOutput)
		m_piOutput->Release();

	WIN::DeleteCriticalSection(&m_csBlock);
}

IMsiRecord* CMsiDatabase::OpenDatabase(const ICHAR* szDataSource, idoEnum idoOpenMode)
{
	idoEnum idoOpenType = idoEnum(idoOpenMode & idoOpenModeMask);  // filter off option flags
	bool fCreate = (idoOpenType== idoCreate || idoOpenType == idoCreateDirect);
	
	m_piDatabaseName->SetString(szDataSource, m_piDatabaseName);
	m_idsUpdate = (idoReadOnly == idoOpenType ? idsRead : idsWrite);
	ismEnum ismOpenMode = (ismEnum)idoOpenMode;  // idoListScript already processed

	if (!fCreate && (!szDataSource || !szDataSource[0]))
		return PostError(Imsg(idbgDbOpenStorage), ERROR_INVALID_PARAMETER);
	
	IMsiStorage* piStorage = 0;
	IMsiRecord* piError;
	if (szDataSource && *szDataSource)
	{
		piError = SRV::CreateMsiStorage(szDataSource, ismOpenMode, piStorage);
		if (piError)
			return piError;
	}
	if ((piError = CreateSystemTables(piStorage, idoOpenMode)) != 0) // initialize string cache, catalog tables
	{
		if (piStorage)
			piStorage->Release();
		return piError;
	}
	m_piStorage = piStorage;  // transfers ref cnt
	return 0;
}

IMsiRecord* CMsiDatabase::OpenDatabase(IMsiStorage& riStorage, Bool fReadOnly)
{
	m_idsUpdate = fReadOnly ? idsRead : idsWrite;
	idoEnum idoOpenMode = (fReadOnly ? idoReadOnly : idoTransact);
	IMsiRecord* piError;
	if ((piError = CreateSystemTables(&riStorage, idoOpenMode)) != 0) // initialize string cache, catalog tables
		return piError;
	m_piStorage = &riStorage;
	riStorage.AddRef();
	return 0;
}

IMsiRecord* CMsiDatabase::PostError(IErrorCode iErr, const IMsiString& istr)
{
	return ::PostError(iErr, *m_piDatabaseName, istr);
}

IMsiRecord* CMsiDatabase::PostError(IErrorCode iErr, const ICHAR* szText1,
                                    const ICHAR* szText2)
{
	return ::PostError(iErr, *m_piDatabaseName, *MsiString(szText1), *MsiString(szText2));
}

IMsiRecord* CMsiDatabase::PostError(IErrorCode iErr, const IMsiString& istr, int iCol)
{
	return ::PostError(iErr, *m_piDatabaseName, istr, iCol);
}

IMsiRecord* CMsiDatabase::PostError(IErrorCode iErr, const ICHAR* szText, int iRow)
{
	return ::PostError(iErr, *m_piDatabaseName, *MsiString(szText), iRow);
}

IMsiRecord* CMsiDatabase::PostError(IErrorCode iErr, int iCol)
{
	return ::PostError(iErr, *m_piDatabaseName, iCol);
}

IMsiRecord* CMsiDatabase::PostError(IErrorCode iErr, int i1, int i2)
{
	return ::PostError(iErr, *m_piDatabaseName, i1, i2);
}

IMsiRecord* CMsiDatabase::PostOutOfMemory()
{
	IMsiRecord* piRec = &m_riServices.CreateRecord(3);
	ISetErrorCode(piRec, Imsg(idbgDbInitMemory));
	piRec->SetMsiString(2, *m_piDatabaseName);
	return piRec;
}

// Notificaton of CMsiTable destruction, called from CMsiTable::Release, DropTable
// caller must AddRef the Database to prevent premature database destruction

void CMsiDatabase::TableReleased(MsiStringId iName)
{
	m_piTableCursor->SetFilter(iColumnBit(ctcName));
	m_piTableCursor->PutInteger(ctcName, iName);
	AssertNonZero(m_piTableCursor->Next());
	int iState = m_piTableCursor->GetInteger(~iTreeLinkMask);
	const IMsiData* piData = m_piTableCursor->GetMsiData(ctcTable); // do AddRef to cancel Release when table ref cleared
	if (iState & iRowTemporaryBit)
		AssertNonZero(m_piTableCursor->Delete());
	else // release object from table row
	{
		m_piCatalogTables->SetLoadedTable(iName, 0);
		if (m_piOutput)
			m_piCatalogTables->SetTableState(iName, ictsOutputDb);
	}
	m_piTableCursor->Reset();   // clear ref counts in cursor
	if (piData)
		--m_iTableCnt;
	return;
}

const IMsiString& CMsiDatabase::ComputeStreamName(const IMsiString& riTableName, MsiTableData* pData, MsiColumnDef* pColumnDef)
{
	const IMsiString* piStreamName = &g_MsiStringNull;
	int cchTable = riTableName.TextSize();
	const IMsiString* pistr;
	MsiString istrTemp;
	for(;;)
	{
		if (cchTable)
		{
			pistr = &riTableName;
			cchTable = 0;
		}
		else if (!(*pColumnDef++ & icdObject)) // integer primary key
		{
			istrTemp = int(*pData++ - iIntegerDataOffset);
			pistr = istrTemp;
		}
		else // string primary key
		{
			pistr = &DecodeStringNoRef(*pData++);
		}
		piStreamName->AppendMsiString(*pistr, piStreamName);
		if (!(*pColumnDef & icdPrimaryKey))
			return *piStreamName;  // extra refcnt returned
		piStreamName->AppendMsiString(*MsiString(MsiChar('.')), piStreamName);
	}
}

Bool CMsiDatabase::LockIfNotPersisted(MsiStringId iTable)
{
	if (m_piCatalogTables->GetTableState(iTable, ictsLockTable))
		return fTrue;
	return m_piCatalogTables->SetTableState(iTable, ictsLockTable) ? fTrue : fFalse;
}

IMsiStorage* CMsiDatabase::GetTransformStorage(unsigned int iStorage)
{
	Assert(iStorage > iPersistentStream && iStorage <= iMaxStreamId && m_piTransformCatalog != 0);
	IMsiCursor* piCursor = m_piTransformCatalog->CreateCursor(fFalse);
	if (piCursor == 0)
		return 0;  // should never happen
	piCursor->SetFilter(tccID);
	piCursor->PutInteger(tccID, iStorage);
	if (!piCursor->Next())
		return 0; // only should happen if internal error
	IMsiStorage* piStorage = (IMsiStorage*)piCursor->GetMsiData(tccTransform);
	piCursor->Release();
	return piStorage;
}

//____________________________________________________________________________
//
//  CMsiDatabase string cache implementation
//____________________________________________________________________________

IMsiRecord* CMsiDatabase::InitStringCache(IMsiStorage* piStorage)
{
	PMsiStream pPoolStream(0);
	PMsiStream pDataStream(0);
	IMsiRecord* piError;
	int cbDataStream;
	int cbStringPool = 0; //prevent warning

	// Open persistent streams, read string pool header word
	if (piStorage)
	{
		piError = piStorage->OpenStream(szStringPool, Bool(fFalse + iCatalogStreamFlag), *&pPoolStream);
		if (piError == 0)
		{
			piError = piStorage->OpenStream(szStringData, Bool(fFalse + iCatalogStreamFlag), *&pDataStream);
		}
		if (piError != 0)
		{
			piError->Release();
			return PostError(Imsg(idbgDbInvalidFormat));
		}
		cbStringPool = pPoolStream->GetIntegerValue();
		cbDataStream = pDataStream->GetIntegerValue();
		m_cCacheInit = m_cCacheUsed = cbStringPool/sizeof(int);
		m_cCacheTotal = m_cCacheUsed + cCacheLoadReserve;
		int iPoolHeader = pPoolStream->GetInt32();  // 1st cache entry (string index 0) reserved for header
		m_iCodePage        = iPoolHeader & idbfCodepageMask;
		if (m_iCodePage != 0 && m_iCodePage != CP_UTF8 && m_iCodePage != CP_UTF7 && !WIN::IsValidCodePage(m_iCodePage))
			return PostError(Imsg(idbgDbCodepageNotSupported), m_iCodePage);
		if (iPoolHeader & idbfHashBinCountMask)  // explicit hash bin count set
			m_cHashBins = 1 << ((iPoolHeader & idbfHashBinCountMask) >> idbfHashBinCountShift);
		else
		{
		// Make a rough guess at what the number should be
			int iBits = cHashBitsMinimum + 1;

			iBits = iBits + m_cCacheTotal/10000;

			if (iBits > cHashBitsMaximum)
				iBits = cHashBitsMaximum;

			Assert (iBits >= cHashBitsMinimum);
			
			m_cHashBins = 1 << iBits;
		}
		m_iDatabaseOptions = iPoolHeader & (idbfDatabaseOptionsMask | idbfHashBinCountMask); // preserve forced hash count
		if (m_iDatabaseOptions & ~(idbfKnownDatabaseOptions | idbfHashBinCountMask))
			return PostError(Imsg(idbgDbInvalidFormat));
	}
	else
	{
		m_cCacheTotal = m_cCacheInit;
		m_cCacheUsed  = 1;  // reserve [0] for header
	}

	// Initialize hash table
	int cHashBins = m_cHashBins;
	if ((m_rgHash = new MsiCacheIndex[cHashBins]) == 0)
		return PostOutOfMemory();
	int iHashBin = 0x80000000L;     // point hash bins to themselves
	MsiCacheIndex* pHash = m_rgHash;
	while (cHashBins--)
		*pHash++ = MsiCacheIndex(iHashBin++);

	// Initialize string array, cache link array followed by refcount array
	while ((m_hCache = GlobalAlloc(GMEM_MOVEABLE, m_cCacheTotal
						* (sizeof(MsiCacheLink) + sizeof(MsiCacheRefCnt)))) == 0)
		HandleOutOfMemory();
	if ((m_rgCacheLink = (MsiCacheLink*)GlobalLock(m_hCache)) == 0)
		return PostOutOfMemory(); // should never fail
	m_rgCacheLink->piString = 0;   // [0] reserved for null string
	m_rgCacheLink->iNextLink = 0;  // to force assert on hash chain errors
	m_rgCacheRefCnt = (MsiCacheRefCnt*)(m_rgCacheLink + m_cCacheTotal);
	m_rgCacheRefCnt[0] = 0;    // should never be accessed
	m_cbStringIndex = 2;       // default string index persistent size
	if (piStorage)
	{
		int cEntries = m_cCacheUsed;
		MsiCacheLink*   pCache  = m_rgCacheLink + 1;
		MsiCacheRefCnt* pRefCnt = m_rgCacheRefCnt;
		CTempBuffer<char, 1> rgbBuf(1024);  // intermediate buffer for non-Unicode strings
		for (MsiStringId iCache = 1; iCache < cEntries; pCache++, iCache++)
		{
			int iPool = pPoolStream->GetInt32();
			if (iPool == 0)
			{
				*(++pRefCnt) = 0;
				pCache->piString = 0;
				pCache->iNextLink = MsiCacheIndex(m_iFreeLink);
				m_iFreeLink = iCache;
			}
			else
			{
				*(++pRefCnt) = (short)((iPool >> 16) & 0x7FFF);
				int cb = iPool & 0xFFFF;
				if (cb == 0)
				{
					cb = pPoolStream->GetInt32();
					cEntries--;
					m_cCacheUsed--;
				}
				Bool fDBCS = iPool < 0 ? fTrue : fFalse;
				rgbBuf.SetSize(cb);
				pDataStream->GetData(rgbBuf, cb);
				int cch = cb;
				if (fDBCS)  // need extra call to find size of DBCS string
					cch = WIN::MultiByteToWideChar(m_iCodePage, 0, rgbBuf, cb, 0, 0);
				ICHAR* pchStr = SRV::AllocateString(cch, fFalse, pCache->piString);
				WIN::MultiByteToWideChar(m_iCodePage, 0, rgbBuf, cb, pchStr, cch);
				int iLen;
				unsigned int iHash = HashString(pchStr, iLen);
				pCache->iNextLink = m_rgHash[iHash];
				m_rgHash[iHash] = MsiCacheIndex(iCache);
			}
		}
		if (pDataStream->Error() | pPoolStream->Error())
			return PostError(Imsg(idbgDbOpenStorage)); //!! different msg?
	}
	else
	{
		m_iCodePage        = 0;  // initialize to neutral
		m_iDatabaseOptions = 0;
	}
	m_cbStringIndex = (m_iDatabaseOptions & idbfExpandedStringIndices) ? 3 : 2;
	return 0;

}

IMsiRecord* CMsiDatabase::CreateSystemTables(IMsiStorage* piStorage, idoEnum idoOpenMode)
{
	idoEnum idoOpenType = idoEnum(idoOpenMode & idoOpenModeMask);  // filter off option flags
	bool fCreate = (idoOpenType== idoCreate || idoOpenType == idoCreateDirect);
	
	if (!fCreate && NULL == piStorage)
		return PostError(Imsg(idbgDbOpenStorage), ERROR_INVALID_PARAMETER);

	if (fCreate)
	{
		if ((idoOpenMode & idoRawStreamNames) || GetTestFlag('Z')) //!! temp option to force old storage name format
		{
			m_pguidClass = (idoOpenMode & idoPatchFile) ? &STGID_MsiPatch1 : &STGID_MsiDatabase1;
			m_fRawStreamNames = fTrue;
		}
		else if (idoOpenMode & idoPatchFile)
			m_pguidClass = &STGID_MsiPatch2;
		else
			m_pguidClass = &STGID_MsiDatabase2;
	}
	else if (idoOpenMode & idoPatchFile)  // request to open a patch file as a database for query or update
	{
		if (piStorage->ValidateStorageClass(ivscPatch1))   // temp support for update of obsolete patch files
			m_fRawStreamNames = fTrue;
		else if (!piStorage->ValidateStorageClass(ivscPatch2))
			return PostError(Imsg(idbgDbInvalidFormat));
	}
	else if (piStorage->ValidateStorageClass(ivscDatabase1)) // old database with uncompressed stream names
	{
		m_fRawStreamNames = fTrue;  // internal flag, used when creating transform or output database
		piStorage->OpenStorage(0, ismRawStreamNames, piStorage); // force storage to uncompressed streams
	}
	else if (!piStorage->ValidateStorageClass(ivscDatabase2))  // current database format
		return PostError(Imsg(idbgDbInvalidFormat));

	IMsiRecord* piError = InitStringCache(fCreate ? 0 : piStorage);
	if (piError)
		return piError;

	// create system catalog tables - currently not stored in catalog
	CCatalogTable* piCatalog;
	if ((piCatalog = new CCatalogTable(*this, cCatalogInitRowCount, 2)) == 0
	 || ctcName  != piCatalog->CreateColumn(icdString + icdPrimaryKey + icdPersistent + 64, *MsiString(sz_TablesName))
	 || ctcTable != piCatalog->CreateColumn(icdObject + icdNullable   + icdTemporary, g_MsiStringNull))
		return PostOutOfMemory();
	m_piCatalogTables = piCatalog;
	if ((piCatalog = new CCatalogTable(*this, cCatalogInitRowCount, 2)) == 0
	 || cccTable != piCatalog->CreateColumn(icdString  + icdPrimaryKey + icdPersistent + 64, *MsiString(sz_ColumnsTable))
	 || cccColumn!= piCatalog->CreateColumn(icdShort   + icdPrimaryKey + icdPersistent + 2,  *MsiString(sz_ColumnsNumber))
	 || cccName  != piCatalog->CreateColumn(icdString  + icdNullable   + icdPersistent + 64, *MsiString(sz_ColumnsName))
	 || cccType  != piCatalog->CreateColumn(icdShort   + icdNoNulls    + icdPersistent + 2,  *MsiString(sz_ColumnsType)))
		return PostOutOfMemory();
	m_piCatalogColumns = piCatalog;
	if (!fCreate)
	{
		//!! check error when changed to return IMsiRecord!
		if (!m_piCatalogTables->LoadData(*MsiString(*szTableCatalog), *piStorage, m_cbStringIndex, m_cbStringIndex)
		 || !m_piCatalogColumns->LoadData(*MsiString(*szColumnCatalog), *piStorage, m_cbStringIndex * 2 + sizeof(short) * 2, m_cbStringIndex))
			return PostError(Imsg(idbgDbInvalidFormat));
		AssertNonZero(m_piCatalogTables->FillColumn(ctcTable, 0));
	}

	if ((m_piTableCursor  = m_piCatalogTables->CreateCursor(fFalse)) == 0
	 || (m_piColumnCursor = m_piCatalogColumns->CreateCursor(fFalse)) == 0)
		return PostOutOfMemory();
	m_piCatalogTables->SetReadOnly();  // prevent update by user cursors
	m_piCatalogColumns->SetReadOnly();

	// eventually we could put these table into the catalog, need column names?

	// Create transform table to hold all transforms associated w/ this database
	CMsiTable* piTable;
	if ((piTable = new CMsiTable(*this, 0, 0, iNonCatalog)) == 0
		|| tccID     != piTable->CreateColumn(icdShort + icdPrimaryKey +
															icdTemporary, g_MsiStringNull)
		|| tccTransform != piTable->CreateColumn(icdObject +
															icdTemporary, g_MsiStringNull)
		|| tccErrors != piTable->CreateColumn(icdShort +
															icdTemporary, g_MsiStringNull))
		return PostOutOfMemory();
	m_piTransformCatalog = piTable;
	m_iLastTransId= 1; // Reserve 1 for identifying local persistent streams
	return 0;
}

unsigned int CMsiDatabase::HashString(const ICHAR* sz, int& iLen)
{
	unsigned int iHash = 0;
	int iHashBins = m_cHashBins;
	int iHashMask = iHashBins - 1;
	const ICHAR *pchStart = sz;
	
	iLen = 0;
	while (*sz != 0)
	{
		int carry;
		carry = iHash & 0x80000000;	
		iHash <<= 1;
		if (carry)
			iHash |= 1;
		iHash ^= *sz;
		sz++;
	}
	iLen = (int)(sz - pchStart);
	iHash &= iHashMask;
	return iHash;
}

MsiStringId CMsiDatabase::FindString(int iLen, int iHash, const ICHAR* sz)
{
	MsiCacheIndex iLink = m_rgHash[iHash];
	while (iLink >= 0)
	{
		MsiCacheLink* pCache = &m_rgCacheLink[iLink];
		const IMsiString* piStr = pCache->piString;
		if (piStr->TextSize() == iLen && piStr->Compare(iscExact, sz))
			return iLink;
		iLink = pCache->iNextLink;
	}
	return 0; // if not found
}

inline MsiStringId CMsiDatabase::MaxStringIndex()
{
	return m_cCacheUsed - 1;
}

MsiStringId CMsiDatabase::BindString(const IMsiString& riString)
{
	//!! do we need to have a reserve, and indicate when we're getting low?
	int iLen = riString.TextSize();
	if (iLen == 0)
		return 0;
	Assert(m_rgCacheLink);
	const ICHAR* sz = riString.GetString();
	int iHash = HashString(sz, iLen);
	MsiStringId iLink = FindString(iLen, iHash, sz);
	if (iLink)
	{
		++m_rgCacheRefCnt[iLink];
		AssertSz(m_rgCacheRefCnt[iLink] != 0, "Refcounts wrapped, all bets are off");
	}
	else
	{
		MsiCacheLink* pLink;
		if (m_iFreeLink)
		{
			iLink = m_iFreeLink;
			m_iFreeLink = m_rgCacheLink[iLink].iNextLink;
		}
		else
		{
			if (m_cCacheUsed >= m_cCacheTotal)
			{
				int cCacheGrow = m_cCacheTotal - m_cCacheInit;
				if (cCacheGrow == 0)
					cCacheGrow = m_cCacheInit >> 2;
				int cOldCacheTotal = m_cCacheTotal;
				m_cCacheTotal += cCacheGrow;
				GlobalUnlock(m_hCache);
				HGLOBAL hCache;
				while((hCache = GlobalReAlloc(m_hCache, m_cCacheTotal
									* (sizeof(MsiCacheLink) + sizeof(MsiCacheRefCnt)), GMEM_MOVEABLE)) == 0)
					HandleOutOfMemory();

				m_hCache = hCache;
				m_rgCacheLink = (MsiCacheLink*)GlobalLock(hCache); // caution, data may move
				Assert(m_rgCacheLink);
				if (!m_rgCacheLink)  // should never fail, but be safe anyway
					return 0;
				MsiCacheRefCnt* pOldRefCnt = (MsiCacheRefCnt*)(m_rgCacheLink + cOldCacheTotal);
				m_rgCacheRefCnt = (MsiCacheRefCnt*)(m_rgCacheLink + m_cCacheTotal);
				memmove(m_rgCacheRefCnt, pOldRefCnt, cOldCacheTotal * sizeof(MsiCacheRefCnt));
			}
			iLink = m_cCacheUsed++;
			// check if overflowing 2-byte persistent string indices
			// if so, must flag all persistent tables (including those tables in memory) with 2-byte indices for reprocessing
			// temporary tables are excluded
			if (m_cCacheUsed == (1<<16) && m_cbStringIndex != 3)
			{
				DEBUGMSG(TEXT("Exceeded 64K strings. Bumping database string index size."));
				m_cbStringIndex = 3;
				m_iDatabaseOptions |= idbfExpandedStringIndices;
				if (m_piCatalogTables) // transforms use the database object to hold the string pool, but not catalog tables
				{
					PMsiCursor pCursor = m_piCatalogTables->CreateCursor(fFalse); // catalog cursor may be in use
					while (pCursor->Next())
					{
						if (!(pCursor->GetInteger(~iTreeLinkMask) & iRowTemporaryBit))  // table not temporary
							m_piCatalogTables->SetTableState(pCursor->GetInteger(ctcName), ictsStringPoolSet);
					}
				}
			}
		}
		m_rgCacheRefCnt[iLink] = 1;
		pLink = &m_rgCacheLink[iLink];
		pLink->piString  = &riString;
		pLink->iNextLink = m_rgHash[iHash];
		m_rgHash[iHash] = MsiCacheIndex(iLink);
		riString.AddRef();
	}
	return iLink;
}

inline void CMsiDatabase::DerefTemporaryString(MsiStringId iString)
{
	Assert(iString < m_cCacheUsed);
	if (iString != 0)
		++m_rgiCacheTempRefCnt[iString];
}

void CMsiDatabase::UnbindStringIndex(MsiStringId iString)
{
	if (iString == 0)
		return;
	if(iString >= m_cCacheUsed || m_rgCacheRefCnt[iString] == 0)
	{
		AssertSz(0, "Database string pool is corrupted.");
		DEBUGMSGV("Database string pool is corrupted.");
		return;
	}
	unsigned int i = --m_rgCacheRefCnt[iString];
	if (!i)
	{
		MsiCacheLink* pLink = &m_rgCacheLink[iString];
		MsiCacheIndex iLink = pLink->iNextLink;
		MsiCacheIndex* pPrev;
		do // walk circular list until previous link found
		{
			if (iLink < 0)  // pass through hash bin
				pPrev = &m_rgHash[iLink & 0x7FFFFFFF];
			else
				pPrev = &m_rgCacheLink[iLink].iNextLink;
			iLink = *pPrev;
			if (iLink == 0)
			{
				AssertSz(0, "Database string pool is corrupted.");
				DEBUGMSGV("Database string pool is corrupted.");
				return;
			}
		} while (iLink !=  iString);
		*pPrev = pLink->iNextLink;

		pLink->piString->Release();
		pLink->piString = 0;
		pLink->iNextLink = MsiCacheIndex(m_iFreeLink);
		m_iFreeLink = iString;
	}
}

const IMsiString& CMsiDatabase::DecodeString(MsiStringId iString)
{
	const IMsiString* piString;
		if (iString == 0
	 || iString >= m_cCacheUsed
	 || (piString = m_rgCacheLink[iString].piString) == 0)
		return g_MsiStringNull;
	piString->AddRef();
	return *piString;
}

const IMsiString& CMsiDatabase::DecodeStringNoRef(MsiStringId iString)
{
	Assert(iString < m_cCacheUsed);
	const IMsiString* piString = m_rgCacheLink[iString].piString;
//	return piString ? *piString : g_MsiStringNull; //!! compiler error, constructs dead IMsiString object
	if (piString)
		return *piString;
	else
		return g_MsiStringNull;
}

MsiStringId CMsiDatabase::EncodeStringSz(const ICHAR* pstr)
{
	if (*pstr == 0)
		return 0;
	int iLen;
	int iHash = HashString((const ICHAR *)pstr, iLen);
	if (iLen == 0)
		return 0;
	return FindString(iLen, iHash, pstr);
}

MsiStringId CMsiDatabase::EncodeString(const IMsiString& riString)
{
	return EncodeStringSz(riString.GetString());
}

//____________________________________________________________________________
//
// CMsiTable external virtual function implementation
//____________________________________________________________________________

HRESULT CMsiTable::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown)
	 || MsGuidEqual(riid, IID_IMsiTable)
	 || MsGuidEqual(riid, IID_IMsiData))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}

unsigned long CMsiTable::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}
	
unsigned long CMsiTable::Release()
{
	ReleaseTrack();
	if (--m_Ref.m_iRefCnt != 0)  // note that refcnt for catalog cancelled when entered
		return m_Ref.m_iRefCnt;
	CMsiDatabase* piDatabase = &m_riDatabase;  // save pointer before destruction
	piDatabase->Block();
	piDatabase->AddRef();  // prevent Services destruction before we're gone
	if (!m_fNonCatalog)  // tables without names are not managed in catalog
	{
		m_Ref.m_iRefCnt = 3;  // prevent recursive destruction during catalog operations
		if (!SaveIfDirty())
		{
			piDatabase->SetTableState(m_iName, ictsSaveError); // mark table catalog
			piDatabase->Unblock();
			piDatabase->Release();
			return m_Ref.m_iRefCnt = 1;   // database now owns this refcnt, may try to save again
		}
		ReleaseData(); // release references before notifying database
		piDatabase->TableReleased(m_iName); // will cause reentry of Release, may release database
	}
	else if(m_ppiPrevTable) // we need to check this since if a table is dropped, it becomes anonymous
	{
		// remove from link
		if (m_piNextTable)
			m_piNextTable->m_ppiPrevTable = m_ppiPrevTable;
		*m_ppiPrevTable = m_piNextTable;
		//!! may be safe to combine ReleaseData in both cases to common place in beginning
		ReleaseData(); // release references before notifying database
	}
	MsiStringId* piName = m_rgiColumnNames;  //!!TEMP dereference column names after Close
	for (int cColumns = m_cColumns; cColumns--; )
		piDatabase->UnbindStringIndex(*piName++);
	// delete before release
	delete this;   // now we can remove ourselves
	piDatabase->Unblock();  // need to do this before releasing the database
	piDatabase->Release();  // now release the database, will destruct if no tables outstanding
	return 0;
}

const IMsiString& CMsiTable::GetMsiStringValue() const
{
	return m_riDatabase.DecodeString(m_iName);
}

int CMsiTable::GetIntegerValue() const
{
	return iMsiNullInteger;
}

#ifdef USE_OBJECT_POOL
unsigned int CMsiTable::GetUniqueId() const
{
	return m_iCacheId;
}

void CMsiTable::SetUniqueId(unsigned int id)
{
	Assert(m_iCacheId == 0);
	m_iCacheId = id;
}
#endif //USE_OBJECT_POOL

int CMsiTable::CreateColumn(int iColumnDef, const IMsiString& istrName)
{
	if ((iColumnDef & icdPersistent) != 0 && istrName.TextSize() == 0)  // persistent columns must be named
		return 0;
	m_riDatabase.Block();
	int iName = m_riDatabase.EncodeStringSz(istrName.GetString());  // OK if name not in string pool yet
	if (iName)
	{
		for (int iCol = m_cColumns; iCol--; )
			if (m_rgiColumnNames[iCol] == (MsiStringId)iName)
				return m_riDatabase.Unblock(), ~iCol;  // duplicate name, return negative of column number
	}
	if (m_cColumns >= cMsiMaxTableColumns
	 || ((iColumnDef & icdPersistent) && m_cColumns >= 31) //!! TEMP FOR 1.0 until our problems w/ 32 columns are sorted out; don't allow more than 31 persistent columns
	 || ((iColumnDef & icdPersistent) && m_cPersist != m_cColumns)
	 || ((iColumnDef & icdPrimaryKey) && m_cPrimaryKey != m_cColumns)
	 || (m_cColumns == 0 && !(iColumnDef & icdPrimaryKey)))  //!! allow this for temp tables?
		return m_riDatabase.Unblock(), 0;
	if (m_rgiData && (m_cColumns + 1) == m_cWidth)
	{  // if array allocated, must widen rows and realloc data if no spares
		int cOldWidth = m_cWidth;
		int cNewWidth = cOldWidth + 1;
		int cNewLength = (cOldWidth * m_cLength) / cNewWidth;
		if (cNewLength >= m_cRows)  // enough room to grow
		{
			m_cLength = cNewLength;
			m_cWidth  = cNewWidth;
		}
		else  // not enough spare room in unused rows, must realloc table
		{
			if (!AllocateData(cNewWidth, m_cLength))
				return m_riDatabase.Unblock(), 0;
		}

		if (m_cRows) //no data to move if there aren't any rows
		{
			MsiTableData* pNewData = m_rgiData + m_cRows * cNewWidth;
			MsiTableData* pOldData = m_rgiData + m_cRows * cOldWidth;
			for(;;) // starts pointing beyond last row
			{
				*(pNewData - 1) = 0;   // null out new field
				pNewData -= cNewWidth;
				pOldData -= cOldWidth;
				if (pNewData == pOldData)
					break;   // no need to move first row
				memmove(pNewData, pOldData, cOldWidth * sizeof(MsiTableData));
			}
		}
	}
	MsiStringId iColumnName = m_riDatabase.BindString(istrName);
	if (iColumnDef & icdPrimaryKey)
		m_cPrimaryKey++;
	if (iColumnDef & icdPersistent)  // put persistent columns into catalog //!!REMOVE THIS TEST, temp columns need to go in catalog
	{
		m_cPersist++;
		if (!m_fNonCatalog)
		{
			IMsiCursor* piColumnCursor = m_riDatabase.GetColumnCursor(); // no ref cnt
			piColumnCursor->PutInteger(cccTable,  m_iName);
			piColumnCursor->PutInteger(cccColumn, m_cPersist);
			piColumnCursor->PutInteger(cccName,   iColumnName);
			piColumnCursor->PutInteger(cccType,   GetUpdateState() == idsWrite ? iColumnDef : (iColumnDef & ~icdPersistent));
			AssertNonZero(piColumnCursor->Insert());
			//!! need to unbind string, columns names not ref counted in table array
			//!! m_riDatabase.UnbindStringIndex(iColumnName); // refcnt held in catalog
			m_fDirty |= (1 << m_cColumns); // do this to make sure the table is saved
													 // to storage even if no data is changed
			piColumnCursor->Reset(); // remove ref counts from cursor
		}
		if (m_cColumns == 0)
			m_riDatabase.SetTableState(m_iName, ictsPermanent);
	}
	else if (m_cColumns == 0)  // now we know its a temporary table
	{
		if (m_idsUpdate == idsRead)   // only temp updates allowed
			m_idsUpdate = idsWrite;    // allow inserts
		// temporary set at table creation, not needed->  m_riDatabase.SetTableState(m_iName, ictsTemporary);
	}
	m_rgiColumnNames[m_cColumns++] = (MsiStringId)iColumnName;
	m_rgiColumnDef[m_cColumns] = MsiColumnDef(iColumnDef);
	m_riDatabase.Unblock();
	return m_cColumns;
}


IMsiDatabase& CMsiTable::GetDatabase()
{
	m_riDatabase.AddRef();
	return m_riDatabase;
}	

unsigned int CMsiTable::GetRowCount()
{
	return m_cRows;
}	

unsigned int CMsiTable::GetColumnCount()
{
	return m_cColumns;
}

unsigned int CMsiTable::GetPersistentColumnCount()
{
	return m_cPersist;
}

unsigned int CMsiTable::GetPrimaryKeyCount()
{
	return m_cPrimaryKey;
}

/*OBSOLETE*/Bool CMsiTable::IsReadOnly()
{
	return m_idsUpdate == idsWrite ? fFalse : fTrue;
}

unsigned int CMsiTable::GetColumnIndex(MsiStringId iColumnName)
{

	MsiStringId* piName = m_rgiColumnNames;
	for (unsigned int i = m_cColumns; i--; piName++)
		if (*piName == (MsiStringId)iColumnName)
			return m_cColumns - i;
	return 0;
}

MsiStringId CMsiTable::GetColumnName(unsigned int iColumn)
{
	if (iColumn == 0)
		return m_iName;
	if (--iColumn >= m_cColumns)
		return 0;
	return m_rgiColumnNames[iColumn];
}

int CMsiTable::GetColumnType(unsigned int iColumn)
{
	if (iColumn > m_cColumns)
		return -1;
	return m_rgiColumnDef[iColumn];  // allow 0 for row state access
}

int CMsiTable::LinkTree(unsigned int iParentColumn)
{
	int cRoots = 0;
	if (m_cPrimaryKey != 1 || iParentColumn == 1)
		return -1;

	m_riDatabase.Block();
	MsiTableData* pData = m_rgiData;
	for (int cRows = m_cRows; cRows--; pData += m_cWidth)
		pData[0] &= ~iTreeInfoMask;
	m_iTreeRoot = 0;
	if ((m_iTreeParent = iParentColumn) != 0)
	{
		pData = m_rgiData;
		for (int iRow = 0; ++iRow <= m_cRows ; pData += m_cWidth)
		{
			if ((pData[0] & iTreeInfoMask) == 0)
				switch(LinkParent(iRow, pData))
				{
				case -1: LinkTree(0); m_riDatabase.Unblock(); return -1; // parent unresolved
				case  1: cRoots++;
				};
		}
	}
	m_riDatabase.Unblock();
	return cRoots;
}

IMsiCursor*  CMsiTable::CreateCursor(Bool fTree)
{
	m_riDatabase.Block();
	if (!m_rgiData && !AllocateData(0, 0))
		return m_riDatabase.Unblock(), 0;
	if (fTree == ictTextKeySort) // special case for use with ExportTable()
	{
		int* rgiIndex = IndexByTextKey();
		if (rgiIndex)
		{
			IMsiCursor* piCursor = new CMsiTextKeySortCursor(*this, m_riDatabase, m_cRows, rgiIndex);
			m_riDatabase.Unblock();
			return piCursor;
		}
		fTree = fFalse;
	}
	IMsiCursor* piCursor = new CMsiCursor(*this, m_riDatabase, fTree);
	m_riDatabase.Unblock();
	return piCursor;
}

//____________________________________________________________________________
//
// CMsiTable internal function implementation
//____________________________________________________________________________

CMsiTable::CMsiTable(CMsiDatabase& riDatabase, MsiStringId iName,
						unsigned int cInitRows, unsigned int cAddColumns)
 : m_riDatabase(riDatabase), m_iName(iName),
	m_cInitRows(cInitRows), m_cAddColumns(cAddColumns)
{
	m_idsUpdate = riDatabase.GetUpdateState();
	// m_rgiColumnDef[0] initialized to 0, == icdLong to force simple copy of RowState to cursor

	// if table is a table not in the catalog, add to separate link list
	if(!m_iName || cAddColumns == iNonCatalog)
	{
		m_cAddColumns = 0;
		m_fNonCatalog = fTrue;
		CMsiTable** ppiTableHead = riDatabase.GetNonCatalogTableListHead();
		if ((m_piNextTable = *ppiTableHead) != 0)
			m_piNextTable->m_ppiPrevTable = &m_piNextTable;
		m_ppiPrevTable = ppiTableHead;
		*ppiTableHead = this;
	}
	Debug(m_Ref.m_pobj = this);
} // doesn't keep refcnt on database to avoid deadlock

Bool CMsiTable::SaveToStorage(const IMsiString& riName, IMsiStorage& riStorage)  //!! change to IMsiRecord return
{
	if (m_cRows == 0) // don't write out stream --> no data
	{
		PMsiRecord pError(riStorage.RemoveElement(riName.GetString(), Bool(fFalse | iCatalogStreamFlag)));
		return fTrue;
	}

	Bool fStat = fTrue;
	PMsiStream  pStream(0);
	IMsiRecord* piError = riStorage.OpenStream(riName.GetString(), Bool(fTrue + iCatalogStreamFlag), *&pStream);
	if (piError)
	{
		piError->Release();
		return fFalse;
	}

	int cbStringIndex = m_riDatabase.GetStringIndexSize();
	MsiColumnDef* pColumnDef = m_rgiColumnDef + 1;
	for (int iColumn = 1; iColumn <= m_cPersist; iColumn++, pColumnDef++)
	{
		int cRows = m_cRows;  // multiple loops below for performance gain
		MsiTableData* pData = m_rgiData;
		if (*pColumnDef & icdObject)
		{
			if (*pColumnDef & icdShort) // string
				for (; cRows-- && !(*pData & iRowTemporaryBit); pData += m_cWidth)
					pStream->PutData(&pData[iColumn], cbStringIndex);
			else // stream
				for (; cRows-- && !(*pData & iRowTemporaryBit); pData += m_cWidth)
				{
					MsiTableData iData = pData[iColumn];
					if (iData != 0)
					{
						MsiString istrStream(m_riDatabase.ComputeStreamName(riName, pData + 1, m_rgiColumnDef+1));
						IMsiStream* piInStream;
						if (iData == iPersistentStream)  // persisted MSI stream data
						{
							if (GetInputStorage() == &riStorage)  // writing to the input storage
							{
								pStream->PutInt16((short)iData); // already persisted
								continue;
							}
							if ((piError = GetInputStorage()->OpenStream(istrStream, fFalse, *&piInStream)) != 0)
							{
								piError->Release();
								fStat = fFalse;
								continue;
							}
						}
						else if (iData <= iMaxStreamId) // stream is in transform file
						{
							// iData is a transform id. Find correct trans file.
							IMsiStorage* piStorage = m_riDatabase.GetTransformStorage(iData);
							Assert(piStorage);
							piError = piStorage->OpenStream(istrStream, fFalse, *&piInStream);
							piStorage->Release();
							if (piError)
							{
								piError->Release();
								fStat = fFalse;
								continue;
							}
						}
						else // stream object, memory stream or loaded MSI stream
						{
							IMsiData* piData = (IMsiData*)GetObjectData(iData);
							if (piData->QueryInterface(IID_IMsiStream, (void**)&piInStream) != NOERROR)
							{
								fStat = fFalse;
								continue;
							}
							piData->Release(); // piInStream owns refcnt
							piInStream->Reset(); //!! should clone stream here to save/restore current loc in stream
							
						}
						IMsiStream* piOutStream;
						if ((piError = riStorage.OpenStream(istrStream, fTrue, piOutStream)) != 0)
						{
							// don't release piInStream - will attempt write again at Commit()
							piError->Release();
							fStat = fFalse;
							continue;
						}
						char rgbBuffer[512];
						int cbInput = piInStream->GetIntegerValue();
						while (cbInput)
						{
							int cb = sizeof(rgbBuffer);
							if (cb > cbInput)
								cb = cbInput;
							piInStream->GetData(rgbBuffer, cb);
							piOutStream->PutData(rgbBuffer, cb);
							cbInput -= cb;
						}
						if (piInStream->Error() || piOutStream->Error())
						{
							// don't release piInStream - will attempt write again at Commit()
							piOutStream->Release();
							fStat = fFalse; // continue to process remaining data
							continue;
						}
						// stream successfully written
						piInStream->Release();
						piOutStream->Release();
						pData[iColumn] = iData = iPersistentStream;
					}
					pStream->PutInt16((short)iData);
				}
		}
		else
		{
			if (*pColumnDef & icdShort) // short integer
				for (; cRows-- && !(*pData & iRowTemporaryBit); pData += m_cWidth)
				{
					int i;
					if ((i = pData[iColumn]) != 0)  // if not null
						i ^= 0x8000;    // translate offset
					pStream->PutInt16((short)i);
				}
			else // long integer
				for (; cRows-- && !(*pData & iRowTemporaryBit); pData += m_cWidth)
					pStream->PutInt32(pData[iColumn]);
		}
	}
	if (pStream->Error())
		fStat = fFalse;  // mark not dirty even if failure to prevent retry at persist
	m_fDirty = 0;
	m_riDatabase.SetTableState(m_iName, ictsNoTransform); // transform permanently applied
	if (m_riDatabase.GetStringIndexSize() == 3)
		m_riDatabase.SetTableState(m_iName, ictsStringPoolClear); // indexes are now at 3 bytes
	m_pinrStorage = &riStorage;  // update storage to prevent needless write on release
	return fStat;
}

Bool CMsiTable::SaveToSummaryInfo(IMsiStorage& riStorage)  // used only for IMsiDatabase::Import
{
	PMsiSummaryInfo pSummary(0);
	IMsiRecord* piError = riStorage.CreateSummaryInfo(32, *&pSummary);
	if (piError)
		return piError->Release(), fFalse;
	MsiString istrValue;
	MsiTableData* pData = m_rgiData;
	for (int cRows = m_cRows;  cRows--; pData += m_cWidth)
	{
		int iPID = pData[1] - iIntegerDataOffset;
		istrValue = m_riDatabase.DecodeString(pData[2]);
		int iValue = istrValue;
		if (iValue != iMsiStringBadInteger)
		{
			pSummary->SetIntegerProperty(iPID, iValue);
		}
		else // date or string
		{
			int rgiDate[6] = {0,0,0,0,0,0};
			int iDateField = -1; // flag to indicate empty
			int cDateField = 0;
			const ICHAR* pch = istrValue;
			int ch;
			while (cDateField < 6)
			{
				ch = *pch++;
				if (ch == rgcgDateDelim[cDateField])
				{
					rgiDate[cDateField++] = iDateField;
					iDateField = -1;  // reinitialize
				}
				else if (ch >= '0' && ch <= '9')
				{
					ch -= '0';
					if (iDateField < 0)
						iDateField = ch;
					else
					{
						iDateField = iDateField * 10 + ch;
						if (iDateField > rgiMaxDateField[cDateField])
							cDateField = 7;  // field overflow, quiet
					}
				}
				else if (ch == 0 && iDateField >= 0) // less than 6 fields
				{
					rgiDate[cDateField++] = iDateField;
					break;  // all done, successful
				}
				else
					cDateField = 99; // error, not a date
			}
			if (cDateField == 3 || cDateField == 6) // actual date found
			{
				//!! check if date format error (!= 99)
				MsiDate iDateTime = MsiDate(((((((((((rgiDate[0] - 1980) << 4)
																+ rgiDate[1]) << 5)
																+ rgiDate[2]) << 5)
																+ rgiDate[3]) << 6)
																+ rgiDate[4]) << 5)
																+ rgiDate[5] / 2);
				pSummary->SetTimeProperty(iPID, iDateTime);
			}
			else // string data
				pSummary->SetStringProperty(iPID, *istrValue);
		}
	}
	return pSummary->WritePropertyStream();
}

Bool CMsiTable::RemovePersistentStreams(MsiStringId iName, IMsiStorage& riStorage)
{
//	if (m_pinrStorage != &riStorage)
//		return fTrue;  // stream not present in output database
	MsiColumnDef* pColumnDef = m_rgiColumnDef + 1;
	int iColumn = -1;
	do
	{
		if (++iColumn >= m_cColumns)
			return fTrue;  // table has no persisten streams
	} while ((*pColumnDef++ & (icdObject|icdPersistent|icdShort))
								  != (icdObject|icdPersistent));
	int cErrors = 0;
	MsiTableData* pData = m_rgiData + 1;
	for (int cRows = m_cRows; cRows--; pData += m_cWidth)
	{
		// Transformed streams can be ignored -- they can't have been saved to
		// storage. If they were, they'd turn into iPersistentStreams.
		if (pData[iColumn] != iPersistentStream)
			continue;
		MsiString istrStream(m_riDatabase.ComputeStreamName(m_riDatabase.DecodeStringNoRef(iName),
																			pData, m_rgiColumnDef+1));
		IMsiRecord* piError = riStorage.RemoveElement(istrStream, m_fStorages);
		if (piError)
		{
		//!! OK if doesn't exist?
			piError->Release();
			cErrors++;
		}
		pData[iColumn] = 0;
	}
	return cErrors ? fFalse : fTrue;
}

// Called from Commit() prior to saving string table to remove ref counts for non-persistent strings

void CMsiTable::DerefStrings()
{
	MsiColumnDef* pColumnDef = m_rgiColumnDef;
	for (int iColumn = 1; pColumnDef++, iColumn <= m_cColumns; iColumn++)
	{
		m_riDatabase.DerefTemporaryString(m_rgiColumnNames[iColumn-1]); //!!TEMP until columns names not ref counted
		if ((*pColumnDef & (icdObject|icdShort)) != (icdObject|icdShort))
			continue;
		MsiTableData* pData = m_rgiData;
		if (iColumn > m_cPersist)  // all temporary column data is non-persistent
			for (int cRows = m_cRows; cRows--; pData += m_cWidth)
				m_riDatabase.DerefTemporaryString(pData[iColumn]);
		else
			for (int cRows = m_cRows; cRows--; pData += m_cWidth)
				if ((pData[0] & iRowTemporaryBit) != 0)
					m_riDatabase.DerefTemporaryString(pData[iColumn]);
	}
	if (m_piCursors)
		m_piCursors->DerefStrings();  // notify all cursors
}

Bool CMsiTable::SaveIfDirty()
{
//	Assert(m_piCursors == 0);
	IMsiStorage* piStorage = m_riDatabase.GetOutputStorage(); // no AddRef done
	if (!piStorage)  // no output storage
		return fTrue;
	int cbStringIndex = m_riDatabase.GetStringIndexSize();
	if (m_cPersist && m_riDatabase.GetUpdateState() == idsWrite)  // if not temporary table
	{
		if (piStorage != m_pinrStorage || (m_fDirty & ((1 << m_cPersist)-1))
			|| m_riDatabase.GetTableState(m_iName, ictsStringPoolSet)) // if output storage, any persistent columns dirty, or string pool bumped
		{
			if (!SaveToStorage(m_riDatabase.DecodeStringNoRef(m_iName), *piStorage))
				return fFalse;
		}
		else // persistent data unchanged, or no writable output
		{
		}
	}
	return fTrue;
}

Bool CMsiTable::ReleaseData()
{
	MsiColumnDef* pColumnDef = m_rgiColumnDef;
	int cPersistData = 0;
//	if (m_riDatabase.GetCurrentStorage())
		cPersistData = m_cPersist;
	Bool fCountedTemp = fFalse;
	int cTempRows = 0;
	for (int iColumn = 1; pColumnDef++, iColumn <= m_cColumns; iColumn++)
	{
		if ((*pColumnDef & icdObject) == 0)
			continue;
		MsiTableData* pData = m_rgiData;
		int cRows = m_cRows;
		if (iColumn <= cPersistData)
		{
			if (*pColumnDef & icdShort) // string
			{
				if (fCountedTemp && cTempRows == 0)
					continue;
				for (; cRows--; pData += m_cWidth)
					if (pData[0] & iRowTemporaryBit)
					{
						m_riDatabase.UnbindStringIndex(pData[iColumn]);
						if (!fCountedTemp)
							cTempRows++;
					}
				fCountedTemp = fTrue;
			}
			else
			{

				for (; cRows--; pData += m_cWidth)
				{
					MsiTableData iData = pData[iColumn];
					ReleaseObjectData(iData);
				}
			}
		}
		else
		{
			if (*pColumnDef & icdShort) // string
			{
				for (pData += iColumn; cRows--; pData += m_cWidth)
					m_riDatabase.UnbindStringIndex(*pData);
			}
			else
			{

				for (pData += iColumn; cRows--; pData += m_cWidth)
					ReleaseObjectData(*pData);
			}
		}
	}
	return fTrue;
}

void CMsiTable::TableDropped()
{
	m_iName = 0;    // table is anonymous in case external references still remain
	m_fNonCatalog = fTrue;
	if (m_piCursors)
		m_piCursors->RowDeleted(0, 0);  // notify all cursors to Reset
	MsiStringId* piName = m_rgiColumnNames;  //!!TEMP dereference column names after Close
	for (int cColumns = m_cColumns; cColumns--; )
		m_riDatabase.UnbindStringIndex(*piName++);
	m_cPersist = 0;  // force all data to be released
	//!! can we let this ReleaseData happen in CMsiTable::Release ?
	ReleaseData();   // remove all string and object references
	if (m_hData != 0)
	{
		GlobalUnlock(m_hData);
		GlobalFree(m_hData);
		m_hData = 0;
	}
	m_rgiData = 0;
	m_cRows = m_cColumns = 0;
	SetReadOnly();  // prevent further updates
}

CMsiTable::~CMsiTable()
{
	RemoveObjectData(m_iCacheId);
	if (m_hData != 0)
	{
		GlobalUnlock(m_hData);
		GlobalFree(m_hData);
		m_hData = 0;
	}
}

// Load CMsiTable data array from storage

Bool CMsiTable::LoadFromStorage(const IMsiString& riName, IMsiStorage& riStorage, int cbFileWidth, int cbStringIndex)
{
	m_pinrStorage = &riStorage;  // save, non-ref counted, for comparison with output
	PMsiStream  pStream(0);
	IMsiRecord* piError = riStorage.OpenStream(riName.GetString(), Bool(fFalse + iCatalogStreamFlag), *&pStream);
	if (piError)
	{
		int iError = piError->GetInteger(1);
		piError->Release();
		return (iError == idbgStgStreamMissing) ? fTrue : fFalse;
	}
	Assert(cbFileWidth);
	if (cbFileWidth <= 0)
		return fFalse;
	m_cRows = pStream->GetIntegerValue()/cbFileWidth;
	if (m_cRows > m_cInitRows)
		m_cInitRows = m_cRows;
	if (!AllocateData(0, 0))
		return fFalse;
	MsiColumnDef* pColumnDef = m_rgiColumnDef;
	for (int iColumn = 1; pColumnDef++, iColumn <= m_cPersist; iColumn++)
	{
		if (iColumn <= m_cLoadColumns)
		{
				int cRows = m_cRows;
			MsiTableData* pData = &m_rgiData[iColumn];
			if (*pColumnDef & icdObject) // string or stream(as Bool)
			{
				if (*pColumnDef & icdShort) // string index
					for (; cRows--; pData += m_cWidth)
					{
						*pData = 0;   // to clear high-order bits
						pStream->GetData(pData, cbStringIndex);
					}
				else // stream flag
					for (; cRows--; pData += m_cWidth)
						*pData = pStream->GetInt16();
			}
			else
			{
				if (*pColumnDef & icdShort) // short integer
					for (; cRows--; pData += m_cWidth)
					{
						int i;
						if ((i = (int)(unsigned short)pStream->GetInt16()) != 0)
							i += 0x7FFF8000L;  // translate offset if not null
						*pData = i;
					}
				else // long integer
					for (; cRows--; pData += m_cWidth)
						*pData = pStream->GetInt32();
			}
			if (pStream->Error())
				return fFalse;
		}
		else
			FillColumn(iColumn, 0);
	}
	FillColumn(0, 0); //!! set TableState into column 0
	return fTrue;
}

int CMsiTable::CreateColumnsFromCatalog(MsiStringId iName, int cbStringIndex)
{
	IMsiCursor* piColumnCursor = m_riDatabase.GetColumnCursor(); // no ref cnt
	piColumnCursor->Reset();
	piColumnCursor->SetFilter(cccTable);
	piColumnCursor->PutInteger(cccTable, iName);
	int cbFileWidth = 0;
	while (piColumnCursor->Next())
	{
		if (m_cColumns >= cMsiMaxTableColumns)
			break;	

		int iColType = piColumnCursor->GetInteger(cccType);
		if (iColType & icdPrimaryKey)
			m_cPrimaryKey++;
		if (iColType & icdPersistent)
		{
			m_cLoadColumns++;
			cbFileWidth += (iColType & icdShort) ? ((iColType & icdObject) ? cbStringIndex : 2)
															 : ((iColType & icdObject) ? 2 : 4);
		}
		else
		{
			iColType |= icdPersistent;
			if (GetUpdateState() == idsWrite)
			{
				piColumnCursor->PutInteger(cccType, iColType);
				AssertNonZero(piColumnCursor->Update() == fTrue);
			}  // else leave as temporary to produce proper file width on subsequent load
		}
//		if (!m_fNonCatalog) // no column names if system or transfer table
//		{
			int iName = piColumnCursor->GetInteger(cccName);
			m_rgiColumnNames[m_cColumns] = (MsiStringId)iName;
			m_riDatabase.BindStringIndex(iName);
//		}
		m_rgiColumnDef[++m_cColumns] = (MsiColumnDef)iColType;
		Assert(piColumnCursor->GetInteger(cccColumn) == m_cColumns);
	}
	m_cPersist = m_cColumns;
	return cbFileWidth;
}

Bool CMsiTable::AllocateData(int cWidth, int cLength)
{
	HGLOBAL hData;
	if (m_rgiData)
	{
		Assert(cWidth  >= m_cWidth);
		Assert(cLength >= m_cLength);
		GlobalUnlock(m_hData);
		while((hData = GlobalReAlloc(m_hData, cLength * cWidth * sizeof(MsiTableData),
									 GMEM_MOVEABLE)) == NULL)
			HandleOutOfMemory();
	}
	else
	{
		if (!cWidth)
			cWidth = m_cColumns + m_cAddColumns + 1;
		if (!cLength)
			cLength = m_cInitRows ? m_cInitRows : cRowCountDefault;
		if (!cWidth)
			return fFalse;
		m_cInitRows = cLength;
		while((hData = GlobalAlloc(GMEM_MOVEABLE, cLength * cWidth*sizeof(MsiTableData))) == NULL)
			HandleOutOfMemory();
	}
	m_hData = hData;
	m_cLength = cLength;
	m_cWidth = cWidth;
	m_rgiData = (MsiTableData*)GlobalLock(m_hData);
	Assert(m_rgiData);   // should never fail, if so we've lost our data
	return (m_rgiData != 0 ? fTrue : fFalse);
}

Bool CMsiTable::FillColumn(unsigned int iColumn, MsiTableData iData)
{
	if (iColumn >= m_cWidth || !m_rgiData) // can fill unused columns
		return fFalse;
	MsiTableData* pData = m_rgiData + iColumn;
	for (int cRows = m_cRows; cRows--; pData += m_cWidth)
		*pData = iData;
	return fTrue;
}

int CMsiTable::LinkParent(int iChildRow, MsiTableData* rgiChild)
{  // assumes that iTreeInfoMask are zero on entry, except for recursion check
	MsiTableData* pData = m_rgiData;
	int iParent = rgiChild[m_iTreeParent];
	if (iParent == 0 || iParent == rgiChild[1]) // root node
	{
		rgiChild[0] |= m_iTreeRoot + (1 << iTreeLinkBits); // root is level 1
		m_iTreeRoot = iChildRow;
		return 1;   // indicate a new root found
	}
	int cRows = m_cRows;
	for (int iRow = 0; ++iRow <= cRows; pData += m_cWidth)
	{
		if (pData[1] == iParent)  // parent row found
		{
			int iStat = 0; // initialize to no new root
			if ((pData[0] & iTreeLinkMask) == iTreeLinkMask)  // caught recursion check
				iStat = -1;  // circular reference
			else if ((pData[0] & iTreeInfoMask) == 0)  // parent unresolved
			{
				rgiChild[0] |= iTreeLinkMask;   // flag link to prevent infinite recursion
				iStat = LinkParent(iRow, pData);
			}
			if (iStat != -1)  // check for missing parent
			{
				rgiChild[0] &= ~iTreeInfoMask;  // preserve row flags
				rgiChild[0] |= (pData[0] & iTreeInfoMask) + (1 << iTreeLinkBits);  // child level is one more
				pData[0] = (pData[0] & ~iTreeLinkMask) | iChildRow;
			}
			return iStat;
		}
	}
	return -1; // parent missing
}

// FindFirstKey - quick search for matching key
//   iKeyData is value to match exactly
//   iRowLower is the highest row to exclude, 1-based, 0 to search all
//   iRowCurrent is the initial guess on input, 1-based, returns matched row on output
//   If key is found the pointer to the row data is returned [0]=row attributes
//   If key is not matched, iRowCurrent is set to the insert location
MsiTableData* CMsiTable::FindFirstKey(MsiTableData iKeyData, int iRowLower, int& iRowCurrent)
{
	// crit sec'd to prevent m_rgiData from being realloced elsewhere during the call
	CDatabaseBlock dbBlk(m_riDatabase);

	if (m_cRows == 0)
		return (iRowCurrent = 1, 0);
	iRowLower--;                 // lowest excluded row, 0-based
	int iRowUpper = m_cRows;     // highest excluded row, 0-based
	int iRowOffset;
	int iRow = iRowCurrent - 1;  // iRow is 0-based in this function, unlike arg
	if ((unsigned int)iRow >= iRowUpper)
		iRow = iRowUpper - 1;     // cursor reset, position at end in case sorted insert
	MsiTableData* pTableBase = m_rgiData + 1;  // skip over row attributes
	MsiTableData* pTable = pTableBase + iRow * m_cWidth;
	while (*pTable != iKeyData)  // check if already positioned at first key column
	{
		if (*pTable < iKeyData) // positioned before matching row
		{
			if ((iRowOffset = (iRowUpper - iRow)/2) == 0) // no intervening rows
			{
				iRow++;  // separate to allow common return code to merge
				return (iRowCurrent = iRow + 1, 0);
			}
			iRowLower = iRow;
			iRow += iRowOffset;
		}
		else                  // positioned after matching row
		{
			if ((iRowOffset = (iRow - iRowLower)/2) == 0) // no intervening rows
				return (iRowCurrent = iRow + 1, 0);
			iRowUpper = iRow;
			iRow = iRowLower + iRowOffset;
		}
		pTable = pTableBase + iRow * m_cWidth;
	}
	return (iRowCurrent = iRow + 1, pTable - 1);
}

// FindNextRow - advance cursor to next row matching filter
// private used by CMsiCursor::Next

Bool CMsiTable::FindNextRow(int& iRow, MsiTableData* pData, MsiColumnMask fFilter, Bool fTree)
{
	// crit sec'd to prevent m_rgiData from being realloced elsewhere during the call
	CDatabaseBlock dbBlk(m_riDatabase);
	fFilter &= ((unsigned int)-1 >> (32 - m_cColumns)); // ignore filter bits beyond column count

	if (fTree && m_iTreeParent && !(iRow == 0 && fFilter & 1))
	{
		int iNextNode = iRow ? m_rgiData[(iRow - 1) * m_cWidth] & iTreeLinkMask : m_iTreeRoot;
		while ((iRow = iNextNode) != 0)
		{
			if (fFilter == 0)
				return fTrue;
			MsiTableData* pRow = &m_rgiData[(iRow - 1) * m_cWidth];
			iNextNode = *pRow & iTreeLinkMask;
			MsiTableData* pCursor = pData;
			for (MsiColumnMask fMask = fFilter;  pCursor++, pRow++, fMask;  fMask >>=1)
				if ((fMask & 1) && *pCursor != *pRow)
					break;
			if (fMask == 0)
				return fTrue;
		}
		return fFalse;
	}

	if (iRow >= m_cRows)
		return (iRow = 0, fFalse);

	if (fFilter == 0)  // no filter columns
		return (iRow++, fTrue);
	MsiTableData* pRow;
	int iNextRow = iRow;  // initialize to just before first row to search
	if (fFilter & 1)   // first primary key column in filter, optimize search
	{
		iNextRow++;     // first possible row
		pRow = FindFirstKey(pData[1], iRow, iNextRow);  // updates iNextRow
		if (!pRow)
			return (iRow = 0, fFalse);
		if (fFilter == 1 && m_cPrimaryKey == 1) // quick exit if single key lookup
			return (iRow = iNextRow, fTrue);
		while (--iNextRow > iRow && pRow[1 - m_cWidth] == pData[1])
			pRow -= m_cWidth;  // backup to start of multiple key group
	}  // iNextRow low by 1 after this loop, fixed below by preincrement
	else
		pRow = m_rgiData + iRow * m_cWidth; // first row to check (iRow + 1)
	for ( ; ++iNextRow <= m_cRows; pRow += m_cWidth)
	{
		MsiTableData* pCursor = pData;
		MsiTableData* pTable  = pRow;
		for (MsiColumnMask fMask = fFilter; pCursor++, pTable++, fMask; fMask >>=1)
			if ((fMask & 1) && *pCursor != *pTable)
				break;
		if (fMask == 0)
			return (iRow = iNextRow, fTrue);
	}
	return (iRow = 0, fFalse);
}

// Copies data from requested table row into cursor data buffer
// Returns tree level, or 1 if not tree-linked
// Does not fail, row validity check on previous Find.. call

int CMsiTable::FetchRow(int iRow, MsiTableData* pData)
{
	// crit sec'd to prevent m_rgiData from being realloced elsewhere during the call
	CDatabaseBlock dbBlk(m_riDatabase);

	Assert(unsigned(iRow-1) < m_cRows);
	MsiTableData* pRow = m_rgiData + (iRow-1) * m_cWidth; // points to row status word
	int iLevel = 1;  // default level if not tree-linked
	if (m_iTreeParent)
		iLevel = (pRow[0] >> iTreeLinkBits) & iTreeLevelMask;
	MsiColumnDef* pColumnDef = m_rgiColumnDef;
	for (int cCol = m_cColumns; cCol-- >= 0; pColumnDef++, pData++, pRow++)
	{
		if (*pData != *pRow)  // optimize in case data is identical
		{
			if (*pColumnDef & icdObject)
			{
				if (*pColumnDef & icdShort) // string index
				{
					m_riDatabase.UnbindStringIndex(*pData);
					m_riDatabase.BindStringIndex(*pData = *pRow);
				}
				else  // object pointer
				{
					ReleaseObjectData(*pData);
					if ((*pData = *pRow) != 0 && *pData > iMaxStreamId)
						AddRefObjectData(*pData);
				}
			}
			else  // integer
			{
				*pData = *pRow;
			}
		}
	}
	return iLevel;
}

// FindKey - local function used by Update, Delete, Assign methods
// to validate row position before modification of data.
// Returns fTrue if key found, else positioned just before insert point if not found.
// The supplied row is the current position, which may be 0 if reset. This row
// position is used only as a hint for faster access. The actual row is
// determined by the primary key and the reference argument will be updated.

Bool CMsiTable::FindKey(int& iCursorRow, MsiTableData* pData)
{
	Assert(iCursorRow <= m_cRows);
	if (m_cRows == 0)
		return (iCursorRow = 1, fFalse);
	MsiTableData* pTable = FindFirstKey(pData[1], 0, iCursorRow);
	if (!pTable)
		return fFalse;
	int iScan = 0; // + if scanning forward, - if scanning backwards
	int iCol = 2;  // start at 2nd column 1st time as we matched above
	while (iCol <= m_cPrimaryKey) // test all key values
	{
		if (pTable[iCol] < pData[iCol])   // positioned before matching row
		{
			if (iCursorRow++ == m_cRows || iScan < 0)
				return fFalse;
			pTable += m_cWidth; // check next row
			iScan++;            // indicate scanning downwards
			iCol = 1;           // restart compare with new row
		}
		else if (pTable[iCol] > pData[iCol]) // positioned after matching row
		{
			if (iCursorRow == 1 || iScan > 0)
				return fFalse;
			iCursorRow--;
			pTable -= m_cWidth;  // check previous row
			iScan--;             // indicate scanning upwards
			iCol = 1;            // restart compare with new row
		}
		else
			iCol++;  // this column matches, check if more key columns
	} // > 1 primary key
	return fTrue;
}
	
Bool CMsiTable::ReplaceRow(int& iRow, MsiTableData* pData)
{
	// crit sec'd to prevent m_rgiData from being realloced elsewhere during the call
	CDatabaseBlock dbBlk(m_riDatabase);

	Assert(unsigned(iRow-1) < m_cRows);
	MsiTableData* pRow = m_rgiData + (iRow-1) * m_cWidth;
	if (m_iTreeParent && pRow[m_iTreeParent] != pData[m_iTreeParent])
		return fFalse;  // cannot update parent column if tree-linked
	MsiColumnDef* pColumnDef = m_rgiColumnDef + 1;  // skip RowStatus
	int iColumnMask = 1;
	pRow[0] &= ~(iRowSettableBits | iRowMergeFailedBit);
	pRow[0] |= (pData[0] & iRowSettableBits) + iRowModifiedBit;
	for (int cCol = m_cColumns; pData++, pRow++, cCol--; pColumnDef++, iColumnMask <<= 1)
	{
		MsiTableData iData = *pData;
		if (iData == *pRow)  // optimize in case data is identical
			continue;
		m_fDirty |= iColumnMask;  // mark table column as changed
		if (*pColumnDef & icdObject)
		{
			if (*pColumnDef & icdShort) // string index
			{
				m_riDatabase.UnbindStringIndex(*pRow);
				m_riDatabase.BindStringIndex(*pRow = iData);
			}
			else  // object pointer
			{
				ReleaseObjectData(*pRow);
				if ((*pRow = iData) != 0 && *pRow > iMaxStreamId)
					AddRefObjectData(iData);
			}
		}
		else  // integer
		{
			*pRow = iData;
		}
	}
	return fTrue;
}

Bool CMsiTable::InsertRow(int& iRow, MsiTableData* pData)
{
	// crit sec'd to prevent m_rgiData from being realloced elsewhere during the call
	CDatabaseBlock dbBlk(m_riDatabase);

	Assert(unsigned(iRow-1) <= m_cRows);
	if (m_cRows == m_cLength)
	{
		int cGrowPrev = (m_cLength - m_cInitRows)/2;
		int cGrow = m_cLength / 4;
		if (cGrowPrev > cGrow)
			cGrow = cGrowPrev;
		if (cGrow < cRowCountGrowMin)
			cGrow = cRowCountGrowMin;
		if (!AllocateData(m_cWidth, m_cLength + cGrow))
			return fFalse;
	}
	MsiTableData* pRow = m_rgiData + (iRow-1) * m_cWidth; // insert location
	int cbRow = m_cWidth * sizeof(MsiTableData);
	int cbMove = (++m_cRows - iRow) * cbRow;
	if (cbMove != 0)
	{
		if (m_piCursors)  // notify all cursors if row not added at end
		{
			m_piCursors->RowInserted(iRow--);// prevent increment of this cursor
			iRow++;
		}
		if (m_iTreeParent)
		{
			if (m_iTreeRoot >= iRow)
				m_iTreeRoot++;
			MsiTableData* pTable = m_rgiData;
			for (int cRows = m_cRows; cRows--; pTable += m_cWidth)
				if ((pTable[0] & iTreeLinkMask) >= iRow)
					pTable[0]++;
		}
		memmove((char*)pRow + cbRow, pRow, cbMove);
	}
	memset(pRow, 0, cbRow);
	MsiColumnDef* pColumnDef = m_rgiColumnDef + 1;
	MsiTableData* pTable = pRow; //!! check temp.flag here
	pRow[0] = (pData[0] & iRowSettableBits) + iRowInsertedBit;
	for (int cCol = m_cColumns; pData++, pTable++, cCol--; pColumnDef++)
	{
		MsiTableData iData = *pTable = *pData;
		if (iData == 0)
			continue;
		if (*pColumnDef & icdObject)
		{
			if (*pColumnDef & icdShort) // string index
				m_riDatabase.BindStringIndex(iData);
			else  // object pointer
				AddRefObjectData(iData);
		}
	}
	if (m_iTreeParent)
	{
		if (LinkParent(iRow, pRow) == -1)
		{
			int fDirty = m_fDirty;    // save current state
			m_fDirty = ~(MsiColumnMask)0; // preserve cursor data
			DeleteRow(iRow);
			m_fDirty = fDirty;
			return fFalse;
		}
	}
	m_fDirty = ~(MsiColumnMask)0;  // mark all columns as changed
	return fTrue;
}

// Checks for exact match of cursor with table data, excluding temporary columns
// Sets or clears the row attribute: iraMergeFailed

Bool CMsiTable::MatchRow(int& iRow, MsiTableData* pData)
{
	// crit sec'd to prevent m_rgiData from being realloced elsewhere during the call
	CDatabaseBlock dbBlk(m_riDatabase);

	Assert(iRow-1 < unsigned(m_cRows));
	MsiTableData* pRow = m_rgiData + (iRow-1) * m_cWidth;
	for (int iCol = m_cPrimaryKey; ++iCol <= m_cPersist; )
	{
		if (pRow[iCol] != pData[iCol])
		{
			if ((pData[iCol] != 0) && (pRow[iCol] != 0) &&
				((m_rgiColumnDef[iCol] & (icdObject + icdShort + icdPersistent))
								== (icdObject + icdPersistent)))
			{
				PMsiStream pTableStream(0);
				if (pRow[iCol] == iPersistentStream)
				{
					// load stream
					MsiString istrStream
						(m_riDatabase.ComputeStreamName(m_riDatabase.DecodeStringNoRef(m_iName),
										 pRow + 1, m_rgiColumnDef + 1));
					IMsiStorage* piStorage = GetInputStorage();
					IMsiRecord* piError = piStorage->OpenStream(istrStream, fFalse,
																*&pTableStream);
					if (piError)
					{
						piError->Release();
						return fFalse;
					}
				}
				else
				{
					pTableStream = (IMsiStream*)GetObjectData(pRow[iCol]);
					pTableStream->AddRef();
				}
				IMsiStream* piDataStream = (IMsiStream*)GetObjectData(pData[iCol]);

				Assert(pTableStream);
				Assert(piDataStream);

				// compare the streams
				int cbRemaining;
				if (((cbRemaining = pTableStream->GetIntegerValue())) == piDataStream->GetIntegerValue())
				{
					CTempBuffer<char,1> rgchTableStreamBuf(1024);
					CTempBuffer<char,1> rgchDataStreamBuf(1024);

					int cbRead = rgchTableStreamBuf.GetSize();

					do
					{
						if (cbRemaining < cbRead)
							cbRead = cbRemaining;
						pTableStream->GetData(rgchTableStreamBuf, cbRead);
						piDataStream->GetData(rgchDataStreamBuf, cbRead);
						if (memcmp(rgchTableStreamBuf, rgchDataStreamBuf,
												cbRead) != 0)
							break;
						cbRemaining -= cbRead;
					}
					while (cbRemaining);

					Assert(!pTableStream->Error());
					Assert(!piDataStream->Error());

					// reset streams
					pTableStream->Reset();
					piDataStream->Reset();

					if (cbRemaining == 0)
					{
						pRow[0] &= ~iRowMergeFailedBit;
						return fTrue;
					}
				}
			}
			pRow[0] |= iRowMergeFailedBit;
			return fFalse;
		}
	}
	pRow[0] &= ~iRowMergeFailedBit;
	return fTrue;
}

Bool CMsiTable::DeleteRow(int iRow)
{
	// crit sec'd to prevent m_rgiData from being realloced elsewhere during the call
	CDatabaseBlock dbBlk(m_riDatabase);

	Assert(iRow-1 < unsigned(m_cRows));
	MsiTableData* pRow = m_rgiData + (iRow-1) * m_cWidth; // delete location
	unsigned int iPrevNode = 0;  // initialize to cursor reset position
	if (m_iTreeParent)  // validate that tree node has no children
	{
		int iNextNode = pRow[0] & iTreeLinkMask;
		if (iNextNode != 0
			 && ((m_rgiData + (iNextNode-1) * m_cWidth)[0] & (iTreeLevelMask<<iTreeLinkBits))
															> (pRow[0] & (iTreeLevelMask<<iTreeLinkBits)))
			return fFalse;  // error if node has children
		
		if (iNextNode > iRow)
			iNextNode--;
		if (m_iTreeRoot > iRow)
			m_iTreeRoot--;
		else if (m_iTreeRoot == iRow)
			m_iTreeRoot = iNextNode;
			
		MsiTableData* pTable = m_rgiData;
		for (int cRows = m_cRows; cRows--; pTable += m_cWidth)
		{
			int iNext = pTable[0] & iTreeLinkMask;
			if (iNext > iRow)
				pTable[0]--;
			else if (iNext == iRow)
			{
				pTable[0] += iNextNode - iNext;  // splice out current node
				iPrevNode = m_cRows - cRows;  // row to set in tree cursors
				if (iPrevNode > iRow)
					iPrevNode--;     // adjust for deleted row
			}
		}  // could also have walked the tree list, better?
	}
	else
		iPrevNode = iRow - 1;  // in case not tree-linked
	if (m_piCursors)
		m_piCursors->RowDeleted(iRow, iPrevNode);  // notify all cursors
	m_fDirty = ~(MsiColumnMask)0;  // mark all columns as changed

	MsiColumnDef* pColumnDef = m_rgiColumnDef + m_cColumns;
	MsiTableData* pData = pRow + m_cColumns;  // last data field
	// must go backwards to avoid dereferencing string columns need for stream name
	for (; pData > pRow; pData--, pColumnDef--)
	{
		if (*pData != 0)
		{	
			if (*pColumnDef & icdObject)
			{
				if (*pColumnDef & icdShort)
				{
					m_riDatabase.UnbindStringIndex(*pData);
				}
				else if (*pData == iPersistentStream)
				{
						MsiString istrStream(m_riDatabase.ComputeStreamName(m_riDatabase.
								DecodeStringNoRef(m_iName), pRow+1, m_rgiColumnDef+1));
						IMsiStorage* piStorage = m_riDatabase.GetOutputStorage();
						if (piStorage && piStorage == m_pinrStorage) // if present in output database
						{
							PMsiRecord pError = piStorage->RemoveElement(istrStream, m_fStorages);
							if (pError && pError->GetInteger(1) != idbgStgStreamMissing) // could be missing due to Replace
								return fFalse;
						}
				}
				else if (*pData <= iMaxStreamId)
				{
					// Transformed streams can be ignored -- they can't have been saved to
					// storage. If they were, they'd turn into iPersistentStreams.
					continue;	
				}
				else
					ReleaseObjectData(*pData);
			}
		}
	}
	int cbRow = m_cWidth * sizeof(MsiTableData);
	int cbMove = (m_cRows-- - iRow) * cbRow;
	if (cbMove != 0)
		memmove(pRow, (char*)pRow + cbRow, cbMove);
	return fTrue;
}

int* CMsiTable::IndexByTextKey()
{
	// crit sec'd to prevent m_rgiData from being realloced elsewhere during the call
	CDatabaseBlock dbBlk(m_riDatabase);

	int cIndex = m_cRows;
	int cKeys = m_cPrimaryKey;
	int iKey, cTextKey;
	MsiTableData* pDataBase = m_rgiData + 1;
	int cRowWidth = m_cWidth;
	const ICHAR* rgszIndex[cMsiMaxTableColumns];
	for (cTextKey = 0; cTextKey < cKeys && (m_rgiColumnDef[cTextKey+1] & icdObject); cTextKey++)
		;
	if (!cTextKey)
		return 0;  // integer keys already sorted
	int* rgiIndex = new int[cIndex];
	if ( ! rgiIndex )
		return 0;
	int iIndex, iBefore;  // indexes into rgiIndex, 0-based
	MsiTableData* pDataIndex = pDataBase;
	for (iIndex = 0; iIndex < cIndex; iIndex++, pDataIndex += cRowWidth) // major index walk
	{
		for (iKey = 0; iKey < cTextKey; iKey++) // set compare string values
			rgszIndex[iKey] = m_riDatabase.DecodeStringNoRef(pDataIndex[iKey]).GetString();

		MsiTableData* pData = NULL;
		int iRowBefore = 0;
		for (iKey = 0, iBefore = iIndex; iBefore; ) // bubble up loop
		{
			if (iKey == 0)
			{
				iRowBefore = rgiIndex[iBefore-1];
				pData = pDataBase + (iRowBefore - 1) * cRowWidth;
			}
			const ICHAR* szBefore = m_riDatabase.DecodeStringNoRef(pData[iKey]).GetString();
			int iComp = IStrComp(szBefore, rgszIndex[iKey]);
			if (iComp < 0) // szBefore < szIndex, we're done
				break;
			if (iComp == 0) // match, must check other keys
			{
				if (++iKey >= cTextKey)
					break;   // numeric keys already ordered
				continue;
			}
			rgiIndex[iBefore--] = iRowBefore;
			iKey = 0;
		}
		rgiIndex[iBefore] = iIndex + 1; // row number for newly-placed key
	}
	return rgiIndex;  // caller must free array
}

bool CMsiTable::HideStrings()
{
	bool fHidden = false;
	MsiColumnDef* pColumnDef = m_rgiColumnDef + 1;
	for (int cCol = m_cPersist; cCol--; pColumnDef++)
		if ((*pColumnDef & (icdShort | icdObject)) == (icdShort | icdObject))
		{
			*pColumnDef &= ~(icdShort | icdObject);
			*pColumnDef |= icdInternalFlag;
			fHidden = true;
		}
	return fHidden;
}

bool CMsiTable::UnhideStrings()
{
	MsiColumnDef* pColumnDef = m_rgiColumnDef + 1;
	for (int cCol = m_cPersist; cCol--; pColumnDef++)
		if (*pColumnDef & icdInternalFlag)
		{
			*pColumnDef |= (icdShort | icdObject);
			*pColumnDef &= ~icdInternalFlag;
		}
	return false;  // no longer hidden
}

Bool CMsiTable::RenameStream(unsigned int iCurrentRow, MsiTableData* pNewData, unsigned int iStreamCol)
{
	// crit sec'd to prevent m_rgiData from being realloced elsewhere during the call
	CDatabaseBlock dbBlk(m_riDatabase);

	Assert(iCurrentRow-1 < unsigned(m_cRows));
	unsigned int iStorage = pNewData[iStreamCol];
	if (iStorage == 0 || iStorage > iMaxStreamId)
		return fTrue;   // no action needed if null or data is actual stream object
	MsiTableData* pRow = m_rgiData + (iCurrentRow-1) * m_cWidth;
	MsiString istrOldName(m_riDatabase.ComputeStreamName(m_riDatabase.DecodeStringNoRef(m_iName), pRow+1, m_rgiColumnDef+1));
	MsiString istrNewName(m_riDatabase.ComputeStreamName(m_riDatabase.DecodeStringNoRef(m_iName), pNewData+1, m_rgiColumnDef+1));
	if (iStorage == iPersistentStream && m_pinrStorage == m_riDatabase.GetOutputStorage())  // stream in current output database
	{
		PMsiRecord precError = m_pinrStorage->RenameElement(istrOldName, istrNewName, m_fStorages); // must rename otherwise will be deleted
		return precError == 0 ? fTrue : fFalse;
	}
	else  // stream in output database or transform storage, must create stream object
	{
		IMsiStorage* piStorage;
		if (iStorage == iPersistentStream)
			piStorage = m_pinrStorage;  // no refcnt
		else
			piStorage = m_riDatabase.GetTransformStorage(iStorage);
		if (!piStorage)
			return fFalse; // should never happen
		IMsiStream* piStream = 0;
		IMsiRecord* piError = piStorage->OpenStream(istrOldName, fFalse, piStream);
		if (iStorage != iPersistentStream)
			piStorage->Release();
		if (piError)
			return piError->Release(), fFalse;
		pNewData[iStreamCol] = (MsiTableData)PutObjectData(piStream);
		return fTrue;
	}
}

//____________________________________________________________________________
//
// CCatalogTable overridden methods
//____________________________________________________________________________

CCatalogTable::CCatalogTable(CMsiDatabase& riDatabase, unsigned int cInitRows, int cRefBase)
	: CMsiTable(riDatabase, 0, cInitRows, 0), m_cRefBase(cRefBase)
{
	//!! is the following necessary? as we mark the row temporary anyway, we could use InsertTemporary
	m_idsUpdate = idsWrite;  // always allow insertion of temporary tables
}

unsigned long CCatalogTable::AddRef()
{
	AddRefTrack();
	if (m_Ref.m_iRefCnt == m_cRefBase)
		m_riDatabase.AddTableCount();
	return ++m_Ref.m_iRefCnt;
}

unsigned long CCatalogTable::Release()
{
	ReleaseTrack();
	if (--m_Ref.m_iRefCnt == 0)  // can't happen until released by database
	{
		delete this;
		return 0;
	}
	if (m_Ref.m_iRefCnt == m_cRefBase)       // all external references removed
	{
		m_riDatabase.AddRef();            // add count so that Release may destruct
		m_riDatabase.RemoveTableCount();  // remove count for this table, internal refs only remain
		if (m_riDatabase.Release() == 0)  // will destruct if no external refs remain
			return 0;                      // this table is now destroyed, can't return refcnt
	}
	return m_Ref.m_iRefCnt;
}

//____________________________________________________________________________
//
// CCatalogTable table management methods
//____________________________________________________________________________

bool CCatalogTable::SetTransformLevel(MsiStringId iName, int iTransform)
{
	int iRow = 0;
	MsiTableData* pRow;
	if (iName==0 || (pRow = FindFirstKey(iName, 0, iRow))== 0)
		return false;
	int iRowStatus = *pRow;
	
	*pRow = (*pRow & ~(iRowTableTransformMask << iRowTableTransformOffset))
						| (iTransform << iRowTableTransformOffset);
	return true;
}

bool CCatalogTable::SetTableState(MsiStringId iName, ictsEnum icts)
{
	int iRow = 0;
	MsiTableData* pRow;
	if (iName==0 || (pRow = FindFirstKey(iName, 0, iRow))== 0)
		return false;
	int iRowStatus = *pRow;
	int cLocks = iRowStatus & iRowTableLockCountMask;
	switch (icts)
	{
	case ictsPermanent: iRowStatus &= ~iRowTemporaryBit; break;
	case ictsTemporary: iRowStatus |=  iRowTemporaryBit; break;

	case ictsLockTable:
		if (cLocks == iRowTableLockCountMask)
			return false;  // overflow, should never happen
		if (!cLocks && pRow[ctcTable] != 0)  // unlocked table is loaded
			AddRefObjectData(pRow[ctcTable]);  // table keeps a refcnt	
		iRowStatus++;
		break;
	case ictsUnlockTable:
		if (!cLocks)
			return false;
		(*pRow)--;  // must decrement before table is released, row may be deleted!
		if (cLocks == 1)
		{
			ReleaseObjectData(pRow[ctcTable]);
		}
		return true;

	case ictsUserClear:       iRowStatus &= ~iRowUserInfoBit; break;
	case ictsUserSet:         iRowStatus |=  iRowUserInfoBit; break;

	case ictsOutputDb:        iRowStatus |=  iRowTableOutputDbBit; break;
	case ictsTransform:       iRowStatus |=  iRowTableTransformBit; break;
	case ictsNoTransform:     iRowStatus &= ~iRowTableTransformBit; break;
//	case ictsTransformDone:   iRowStatus |=  iRowTableTransformedBit; break;
	case ictsSaveError:       iRowStatus |=  iRowTableSaveErrorBit; break;
	case ictsNoSaveError:     iRowStatus &= ~iRowTableSaveErrorBit; break;

	case ictsStringPoolSet:   iRowStatus |=  iRowTableStringPoolBit; break;
	case ictsStringPoolClear: iRowStatus &= ~iRowTableStringPoolBit; break;

	default: return false;  // ictsDataLoaded and ictsTableExists are read-only
	};
	*pRow = iRowStatus;
	return true;
}

bool CCatalogTable::GetTableState(MsiStringId iName, ictsEnum icts)
{
	int iRow = 0;
	MsiTableData* pRow;
	if (iName==0 || (pRow = FindFirstKey(iName, 0, iRow))==0)
		return false;
	int iRowStatus = *pRow;
	switch (icts)
	{
	case ictsPermanent:       iRowStatus ^= iRowTemporaryBit; // fall through
	case ictsTemporary:       iRowStatus &= iRowTemporaryBit; break;
	case ictsUserClear:       iRowStatus ^= iRowUserInfoBit; // fall through
	case ictsUserSet:         iRowStatus &= iRowUserInfoBit; break;
	case ictsUnlockTable:     iRowStatus = (iRowStatus & iRowTableLockCountMask) - 1 & iRowTableLockCountMask + 1; break;
	case ictsLockTable:       iRowStatus &= iRowTableLockCountMask; break;
	case ictsOutputDb:        iRowStatus &= iRowTableOutputDbBit; break;
	case ictsTransform:       iRowStatus &= iRowTableTransformBit; break;
//	case ictsTransformDone:   iRowStatus &= iRowTableTransformedBit; break;
	case ictsSaveError:       iRowStatus &= iRowTableSaveErrorBit; break;
	case ictsStringPoolClear: iRowStatus ^= iRowTableStringPoolBit; // fall through
	case ictsStringPoolSet:   iRowStatus &= iRowTableStringPoolBit; break;
	case ictsDataLoaded:      iRowStatus =  pRow[ctcTable]; break;
	case ictsTableExists: return true;
	default:              return false;
	};
	return iRowStatus ? true : false;
}

int CCatalogTable::GetLoadedTable(MsiStringId iName, CMsiTable*& rpiTable)
{
	int iRow = 0;
	MsiTableData* pRow;
	if (iName==0 || (pRow = FindFirstKey(iName, 0, iRow))==0)
		return rpiTable = 0, -1;
	rpiTable = (CMsiTable*)GetObjectData(pRow[ctcTable]);
	return *pRow;
}

int CCatalogTable::SetLoadedTable(MsiStringId iName, CMsiTable* piTable)
{
	int iRow = 0;
	MsiTableData* pRow;
	if (iName==0 || (pRow = FindFirstKey(iName, 0, iRow))==0)
	{
		AssertSz(0, "Table not in catalog");
		return 0;
	}
	if (piTable)
	{
		if (pRow[ctcTable] != 0)  // error if already loaded
		{
			AssertSz(0, "Table already loaded");
			return 0;
		}
		if (pRow[0] & iRowTableLockCountMask)
			piTable->AddRef();
	}
	else // removing table, no refcnt kept by table if no locks
	{
		if (pRow[ctcTable] == 0)  // no error if not loaded, is this right?
			return pRow[0];
		Assert((pRow[0] & iRowTableLockCountMask) == 0); // assume that no locks can remain, and thus no refcnt held
	}
	pRow[ctcTable] = PutObjectData(piTable);
	return pRow[0];
}

//____________________________________________________________________________
//
// CMsiCursor implementation
//____________________________________________________________________________

CMsiCursor::CMsiCursor(CMsiTable& riTable, CMsiDatabase& riDatabase, Bool fTree)
 : m_riTable(riTable), m_riDatabase(riDatabase), m_fTree(fTree),
	m_pColumnDef(riTable.GetColumnDefArray()), m_rcColumns(riTable.GetColumnCountRef())
{
	riTable.AddRef();  // current implementation holds a refcnt on table
	m_Ref.m_iRefCnt = 1;
	m_idsUpdate = riTable.GetUpdateState();
	if (fTree == ictUpdatable)  // special case for applying transform to read-only db
	{
		m_idsUpdate = idsWrite;
		m_fTree = fFalse;
	}
	CMsiCursor** ppiCursorHead = riTable.GetCursorListHead();
	if ((m_piNextCursor = *ppiCursorHead) != 0)
		m_piNextCursor->m_ppiPrevCursor = &m_piNextCursor;
	m_ppiPrevCursor = ppiCursorHead;
	*ppiCursorHead = this;
	Debug(m_Ref.m_pobj = this);
}

HRESULT CMsiCursor::QueryInterface(const IID& riid, void** ppvObj)
{
	if (MsGuidEqual(riid, IID_IUnknown) || MsGuidEqual(riid, IID_IMsiCursor))
	{
		*ppvObj = this;
		AddRef();
		return NOERROR;
	}
	*ppvObj = 0;
	return E_NOINTERFACE;
}
unsigned long CMsiCursor::AddRef()
{
	AddRefTrack();
	return ++m_Ref.m_iRefCnt;
}
unsigned long CMsiCursor::Release()
{
	ReleaseTrack();
	if (--m_Ref.m_iRefCnt != 0)
		return m_Ref.m_iRefCnt;
	m_riDatabase.Block();
	Reset();
	if (m_piNextCursor)
		m_piNextCursor->m_ppiPrevCursor = m_ppiPrevCursor;
	*m_ppiPrevCursor = m_piNextCursor;
	CMsiTable& riTable = m_riTable;  // copy before deleting memory
	m_riDatabase.Unblock();
	delete this;  // remove memory before possibly releasing Services
	riTable.Release();
	return 0;
}

IMsiTable& CMsiCursor::GetTable()
{
	m_riTable.AddRef();
	return m_riTable;
}

void CMsiCursor::Reset()
{
	m_riDatabase.Block();
	MsiColumnDef* pColumnDef = m_pColumnDef;
	MsiTableData* pData = m_Data;
	for (int cCol = m_rcColumns; cCol-- >= 0; pColumnDef++, pData++)
	{
		if (*pData != 0)
		{
			if (*pColumnDef & icdObject)
			{
				if (*pColumnDef & icdShort)
					m_riDatabase.UnbindStringIndex(*pData);
				else
					ReleaseObjectData(*pData);
			}
			*pData = 0;
		}
	}
	m_iRow = 0;
	m_fDirty = 0;
	m_riDatabase.Unblock();
}

int CMsiCursor::Next()
{
	int iRet;
	m_riDatabase.Block();
	if (m_riTable.FindNextRow (m_iRow, m_Data, m_fFilter, m_fTree))
		iRet = m_riTable.FetchRow(m_iRow, m_Data);
	else
	{
		Reset();
		iRet = 0;
	}
	m_riDatabase.Unblock();
	return iRet;
}

unsigned int CMsiCursor::SetFilter(unsigned int fFilter)
{
	unsigned int fOld = m_fFilter;
	m_fFilter = fFilter;
	return fOld;
}

int CMsiCursor::GetInteger(unsigned int iCol)
{
	if (iCol-1 >= m_rcColumns)
	{
		if (iCol == 0)
			return (m_Data[0] >> iRowBitShift) & ((1 << iraTotalCount) - 1);
		if (iCol == ~iTreeLinkMask)  // for accessing raw row bits internally
			return m_Data[0];
		return 0;
	}
	return m_pColumnDef[iCol] & icdObject ? m_Data[iCol] : m_Data[iCol] - iIntegerDataOffset;
}


// internal function to return object from column assured to be of type icdObject
IMsiStream* CMsiCursor::GetObjectStream(int iCol)
{
	unsigned int iStream = m_Data[iCol];
	if (!iStream)
		return 0;
	if (iStream > iMaxStreamId)
	{
		IMsiStream* piStream = (IMsiStream*)GetObjectData(iStream);
		piStream->AddRef();
		return piStream;
	}
	if (iStream == iPersistentStream)
		return CreateInputStream(0);
	IMsiStorage* piStorage = m_riDatabase.GetTransformStorage(iStream);
	if (!piStorage)
		return 0; //!! Is this sufficient?
	IMsiStream* piStream = CreateInputStream(piStorage);
	piStorage->Release();
	return piStream;
}

const IMsiString& CMsiCursor::GetString(unsigned int iCol)
{
	// crit sec'd to prevent m_rgCacheLink from being realloced elsewhere during the call
	CDatabaseBlock dbBlk(m_riDatabase);

	if (iCol-1 >= m_rcColumns)
		return ::CreateString();
	MsiColumnDef iColumnDef = m_pColumnDef[iCol];
	if (iColumnDef & icdObject)
	{
		if (iColumnDef & icdShort) // string index
		{
			return m_riDatabase.CMsiDatabase::DecodeString(m_Data[iCol]);
		}
		else // data object
		{
			PMsiData pData = GetObjectStream(iCol);
			if (pData != 0)
				return pData->GetMsiStringValue();
		}
	}
	return ::CreateString();
}

const IMsiData* CMsiCursor::GetMsiData(unsigned int iCol)
{
	// crit sec'd to prevent m_rgCacheLink from being realloced elsewhere during the call
	CDatabaseBlock dbBlk(m_riDatabase);

	if (iCol-1 >= m_rcColumns)
		return 0;
	MsiColumnDef iColumnDef = m_pColumnDef[iCol];
	if (iColumnDef & icdObject)
	{
		if (iColumnDef & icdShort) // string index
		{
			MsiStringId iStr = m_Data[iCol];
			return iStr ? &m_riDatabase.DecodeString(iStr) : 0;
		}
		else // data object
		{
			return GetObjectStream(iCol);	 // OK if a non-stream object
		}
	}
	return 0;
}

IMsiStream* CMsiCursor::GetStream(unsigned int iCol)
{
	if (iCol-1 >= m_rcColumns)
		return 0;
	if ((m_pColumnDef[iCol] & (icdObject|icdPersistent|icdShort))
								  != (icdObject|icdPersistent))
		return 0;
	return GetObjectStream(iCol);
}

Bool CMsiCursor::PutStream(unsigned int iCol, IMsiStream* piStream)
{
	if (iCol-1 >= m_rcColumns)
		return fFalse;
	MsiColumnDef iColumnDef = m_pColumnDef[iCol];
	if ((iColumnDef & (icdObject|icdShort|icdPersistent)) != (icdObject|icdPersistent))
		return fFalse;
	if (piStream != 0)
		piStream->AddRef();
	else if (!(iColumnDef & icdNullable))
 		return fFalse;
	IUnknown* piData = (IUnknown *)GetObjectData(m_Data[iCol]);
	if (piData > (IUnknown*)((INT_PTR)iMaxStreamId))
		piData->Release();
	m_Data[iCol] = (MsiTableData)PutObjectData(piStream);
	m_fDirty |= (1 << (iCol-1));
	return fTrue;
}


Bool CMsiCursor::PutInteger(unsigned int iCol, int iData)
{
	if (iCol-1 >= m_rcColumns)
	{
		if (iCol == 0)
		{
			int iRowMask = m_idsUpdate == idsWrite ? iRowTemporaryBit|iRowUserInfoBit : iRowUserInfoBit;
			m_Data[0] = (m_Data[0] & ~iRowMask) | ((iData << iRowBitShift) & iRowMask);
			return fTrue;
		}
		if (iCol == ~iTreeLinkMask)  // for accessing raw row bits internally
		{
			m_Data[0] = iData;
			return fTrue;
		}
//		if ((iCol & iTreeLinkMask) == 0)  // internal call with row state mask
//		{
//			m_Data[0] = (m_Data[0] & ~iCol) | (iData & iCol);
//			return fTrue;
//		}
		return fFalse;
	}
	MsiColumnDef iColumnDef = m_pColumnDef[iCol];
	if (iColumnDef & icdObject)
	{
		if (iData == 0 && !(iColumnDef & icdNullable))
			return fFalse;
		if (iColumnDef & icdShort) // string index
		{
			if (m_Data[iCol] != iData) // optimization
			{
				m_riDatabase.Block();
				m_riDatabase.BindStringIndex(iData); // Bind before Unbind incase =
				m_riDatabase.UnbindStringIndex(m_Data[iCol]);
				m_riDatabase.Unblock();
			}
		}
		else  // object					
		{
			int iDataOld = m_Data[iCol];
			if (iData > iMaxStreamId)
			{
#ifndef _WIN64
 				(*(IUnknown**)&iData)->AddRef();				//!!merced: Converting INT (iData) to PTR
#endif // !_WIN64
				Assert(fFalse);
			}
			ReleaseObjectData(iDataOld);
		}
		m_Data[iCol] = iData;
	}
	else // integer
	{
		if (iData == iMsiNullInteger)
		{
		 	if (!(iColumnDef & icdNullable))
				return fFalse;
			m_Data[iCol] = 0;
		}
		else if ((iColumnDef & icdShort) && (iData + 0x8000 & 0xFFFF0000L)) // short integer
			return fFalse;
		m_Data[iCol] = iData + iIntegerDataOffset;
	}
	m_fDirty |= (1 << (iCol-1)); // dirty even if data unchanged? prevents removal on delete
	return fTrue;
}

Bool CMsiCursor::PutString(unsigned int iCol, const IMsiString& riData)
{
	if (iCol-1 >= m_rcColumns)
		return fFalse;
	MsiColumnDef iColumnDef = m_pColumnDef[iCol];
	if ((iColumnDef & icdObject) == 0) // integer column
		return fFalse;
	if (iColumnDef & icdShort) // string index column
	{
		CDatabaseBlock dbBlk(m_riDatabase);
		int iData = m_riDatabase.BindString(riData);
		if (iData == 0 && !(iColumnDef & icdNullable))
			return fFalse;
		m_riDatabase.UnbindStringIndex(m_Data[iCol]);
		m_Data[iCol] = iData;
	}
	else  // object column
	{
		if (iColumnDef & icdPersistent)
			return fFalse;
		IUnknown* piData = *(IUnknown**)&m_Data[iCol];
		if (riData.TextSize() == 0)
			m_Data[iCol] = 0;
		else
		{
			riData.AddRef();
			Assert(fFalse);
			m_Data[iCol] = PutObjectData(&riData);
		}
		if (piData > (IUnknown*)((INT_PTR)iMaxStreamId))
			piData->Release(); // release after AddRef
	}
	m_fDirty |= (1 << (iCol-1));
	return fTrue;
}

Bool CMsiCursor::PutMsiData(unsigned int iCol, const IMsiData* piData)
{
	if (iCol-1 >= m_rcColumns)
		return fFalse;
	MsiColumnDef iColumnDef = m_pColumnDef[iCol];
	if (!(iColumnDef & icdObject) || (iColumnDef & icdShort))
		return fFalse;
	if (piData == 0 && !(iColumnDef & icdNullable))
		return fFalse;
	if (piData && (iColumnDef & icdPersistent))
	{
		IUnknown* piunk;
		if (piData->QueryInterface(IID_IMsiStream, (void**)&piunk) != S_OK)
			return fFalse;  // must be a stream if persistent
		piunk->Release();
	}
	if (piData)
		piData->AddRef();
	int iDataOld = m_Data[iCol];
	ReleaseObjectData(iDataOld);
	m_Data[iCol] = PutObjectData(piData);
	m_fDirty |= (1 << (iCol-1));
	return fTrue;
}

Bool CMsiCursor::PutNull(unsigned int iCol)
{
	if (iCol-1 >= m_rcColumns)
		return fFalse;
	MsiColumnDef iColumnDef = m_pColumnDef[iCol];
	if (!(iColumnDef & icdNullable))
		return fFalse;
	if (iColumnDef & icdObject)
	{
		if (iColumnDef & icdShort) // string index
		{
			m_riDatabase.Block();
			m_riDatabase.UnbindStringIndex(m_Data[iCol]);
			m_riDatabase.Unblock();
		}
		else  // object
		{
			ReleaseObjectData(m_Data[iCol]);
		}
	}
	m_Data[iCol] = 0;
	m_fDirty |= (1 << (iCol-1)); // dirty even if data unchanged? prevents removal on delete
	return fTrue;
}

Bool CMsiCursor::Update()  // update fetched row, no primary key changes allowed
{
	if (m_idsUpdate == idsNone)
		return fFalse;
	if (m_iRow == 0 || (m_Data[0] & iTreeInfoMask) == iTreeInfoMask)  // current row has been deleted
#ifdef DEBUG  //!!TEMP
/*temp*/		return AssertSz(0,"Update: not positioned on fetched row"), fFalse;   // must be positioned on a valid row
#else
		return fFalse;   // must be positioned on a valid row
#endif
	m_riDatabase.Block();
	if (m_idsUpdate == idsRead)  // allow temporary changes
	{
		if ((m_Data[0] & iRowTemporaryBit) == 0)  // permanent row, must check columns
		{
			if (m_riTable.MatchRow(m_iRow, m_Data) == fFalse)
				return m_riDatabase.Unblock(), fFalse;
		}
	}
	if (((1 << m_riTable.GetPrimaryKeyCount()) - 1) & m_fDirty)  // primary key changed
	{
		int iCurrentRow = m_iRow;   // OK if dirty but same value
		if (m_riTable.FindKey(m_iRow, m_Data) == fFalse || m_iRow != iCurrentRow)
			return m_riDatabase.Unblock(), fFalse;   // sorry, can't change primary key with Update
	}
	Bool fRet = m_riTable.ReplaceRow(m_iRow, m_Data);
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::Insert()  // insert unique record, fails if primary key exists
{
	if (m_idsUpdate != idsWrite)
		return fFalse;
	if (!CheckNonNullColumns())
		return fFalse;
	m_riDatabase.Block();
	Bool fRet;
	if (m_riTable.FindKey(m_iRow, m_Data))
	{
		m_iRow = 0;  // not representing a valid row, prevent Update from succeeding
		fRet = fFalse;
	}
	else
		fRet = m_riTable.InsertRow(m_iRow, m_Data);
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::InsertTemporary()  // insert temporary record, fails if primary key exists
{
	if (m_idsUpdate == idsNone)
		return fFalse;
	if (!CheckNonNullColumns())
		return fFalse;
	m_riDatabase.Block();
	Bool fRet;
	if (m_riTable.FindKey(m_iRow, m_Data))
	{
		m_iRow = 0;  // not representing a valid row, prevent Update from succeeding
		fRet = fFalse;
	}
	else
	{
		m_Data[0] |= iRowTemporaryBit;
		fRet = m_riTable.InsertRow(m_iRow, m_Data);
	}
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::Assign()  // force insert by overwriting any existing row
{
	if (m_idsUpdate != idsWrite)
		return fFalse;
	if (!CheckNonNullColumns())
		return fFalse;
	m_riDatabase.Block();
	Bool fRet;
	if (m_riTable.FindKey(m_iRow, m_Data))
		fRet = m_riTable.ReplaceRow(m_iRow, m_Data);
	else
		fRet = m_riTable.InsertRow(m_iRow, m_Data);
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::Replace()  // force update of fetched row, allowing primary key changes
{
	if (m_idsUpdate != idsWrite)
		return fFalse;
	if (m_iRow == 0)
		return fFalse;   // must be positioned on a row, may be a deleted row
	if (!CheckNonNullColumns())
		return fFalse;
	m_riDatabase.Block();
	Bool fRet = fTrue;
	if (((1 << m_riTable.GetPrimaryKeyCount()) - 1) & m_fDirty)  // primary key changed
	{
		int iCurrentRow = m_iRow;
		if (m_riTable.FindKey(m_iRow, m_Data))
		{
			if (iCurrentRow == m_iRow)  // primary key value unchanged
				fRet = m_riTable.ReplaceRow(m_iRow, m_Data); // do a normal update, not really dirty
			else
				fRet = fFalse;   // new primary key cannot exist already
		}
		else  // changed key value does not exist
		{
			// check for persisted stream column
			MsiColumnDef* pColumnDef = m_pColumnDef + 1;
			for (int iCol = 1; iCol <= m_rcColumns && (*pColumnDef & icdPersistent); iCol++, pColumnDef++)
				if ((*pColumnDef & (icdObject | icdShort)) == icdObject)
					fRet = m_riTable.RenameStream(iCurrentRow, m_Data, iCol);

			// insert new row and delete row referenced by previous key value, if not already deleted
			if (!m_riTable.InsertRow(m_iRow, m_Data))
				fRet = fFalse;
			else if ((m_Data[0] & iTreeInfoMask) != iTreeInfoMask)  // current row has not been deleted
				m_riTable.DeleteRow(iCurrentRow + (m_iRow <= iCurrentRow));// if inserted ahead of row to be deleted, add 1
		}
	}
	else if (m_riTable.FindKey(m_iRow, m_Data))
		fRet = m_riTable.ReplaceRow(m_iRow, m_Data);
	else
		fRet = m_riTable.InsertRow(m_iRow, m_Data);
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::Merge()
{
//	if (m_fReadOnly)
//		return fFalse;
	Bool fRet;
	m_riDatabase.Block();
	if (m_riTable.FindKey(m_iRow, m_Data))
		fRet = m_riTable.MatchRow(m_iRow, m_Data);
	else if (!CheckNonNullColumns())
		fRet = fFalse;
	else
		fRet = m_riTable.InsertRow(m_iRow, m_Data);
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::Refresh()
{
	if (m_iRow == 0)
	{
		Reset();
		return fFalse;
	}
	Bool fRet;
	m_riDatabase.Block();
	if ((m_Data[0] & iTreeInfoMask) == iTreeInfoMask)  // current row has been deleted
	{
		int iRow = m_iRow;
		Reset();
		m_Data[0] = iTreeInfoMask;   // restore deleted state
		m_iRow = iRow;       // and position
		fRet = fFalse;
	}
	else
	{
		fRet = m_riTable.FetchRow(m_iRow, m_Data) ? fTrue : fFalse;
		m_fDirty = 0;
	}
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::Seek()
{
	Bool fRet = fFalse;
	m_riDatabase.Block();
	if (m_riTable.FindKey(m_iRow, m_Data))
		fRet = m_riTable.FetchRow(m_iRow, m_Data) ? fTrue : fFalse;
	if (!fRet)
		Reset();
	m_riDatabase.Unblock();
	return fRet;
}

Bool CMsiCursor::Delete()
{
//	if (m_fReadOnly || (m_Data[0] & iTreeInfoMask) == iTreeInfoMask)  // can't delete twice
	if ((m_Data[0] & iTreeInfoMask) == iTreeInfoMask)  // can't delete twice
		return fFalse;
	Bool fRet;
	m_riDatabase.Block();
	if (!(m_riTable.FindKey(m_iRow, m_Data)))  // leaves m_iRow at insert point if fails
	{
		m_iRow = 0;  // not pointing at a valid row, prevent update
		fRet = fFalse;
	}
	else
		fRet = m_riTable.DeleteRow(m_iRow);
	m_riDatabase.Unblock();
	return fRet;
}

IMsiRecord*  CMsiCursor::Validate(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor, int iCol)
{
	// Error record & column count
	// If there is an error, then the error record is created with cCol fields
	m_riDatabase.Block();  //!! probably don't need this, but one could have a multi-threaded authoring tool
	IMsiRecord* piRecord = 0;
	int cCol = m_riTable.GetColumnCount();
	int i = 0;

	// Check for invalid cursor state (row for delete, or cursor reset)
	// Cursor can be reset if validating new row or a field
	// An empty/null record represents some other *serious* error
	if ((m_iRow == 0 && iCol == 0) || (m_Data[0] & iTreeInfoMask) == iTreeInfoMask)
		return m_riDatabase.Unblock(), (piRecord = &(SetUpRecord(cCol)));
		
	
	// Check to see if row is a row of _Validation table
	// If yes, don't validate -- we don't validate ourselves
	if (IStrComp(MsiString(m_riTable.GetMsiStringValue()), sztblValidation) == 0)
		return m_riDatabase.Unblock(), 0;

	int vtcTable = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colTable));
	Assert(vtcTable);
	int vtcColumn = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colColumn));
	Assert(vtcColumn);
	
	// Validate pre-delete (see if any *explicit* foreign keys point to us)
	// *Explicit* foreign keys are those columns with 'our' table name in the KeyTable column
	// of some other column of a table
	// The delimited list of tables and possibility of value being referenced in a [#identifier]
	// type property, etc. are not evaluated/validated.
	if (iCol == -2)
	{
		int vtcKeyTable = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colKeyTable));
		Assert(vtcKeyTable);
		int vtcKeyColumn = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colKeyColumn));
		Assert(vtcKeyColumn);
		riValidationCursor.Reset();
		riValidationCursor.SetFilter(iColumnBit(vtcKeyTable));
		riValidationCursor.PutInteger(vtcKeyTable, m_riTable.GetTableName());
		while (riValidationCursor.Next())
		{
			// Someone could be pointing to us
			// Load table and see if they reference our primary key
			// Check value in 'KeyColumn' column to determine what column in us they point to
			int iKeyColumn = riValidationCursor.GetInteger(vtcKeyColumn);
			PMsiTable pRefTable(0);
			MsiString strRefTableName = riValidationCursor.GetString(vtcTable);
			IMsiRecord* piErrRec = m_riDatabase.LoadTable(*strRefTableName, 0, *&pRefTable);
			if (piErrRec)
			{
				//!! Should we report some error here??
				piErrRec->Release();
				continue;
			}
			// Create cursor on table
			PMsiCursor pRefCursor(pRefTable->CreateCursor(fFalse));
			Assert(pRefCursor);
			int ircRefColumn = pRefTable->GetColumnIndex(riValidationCursor.GetInteger(vtcColumn));
			Assert(ircRefColumn);
			
			pRefCursor->Reset();
			pRefCursor->SetFilter(iColumnBit(ircRefColumn));
			int iDelKeyData = m_pColumnDef[iKeyColumn] & icdObject ? m_Data[iKeyColumn] : m_Data[iKeyColumn] - iIntegerDataOffset;
			//!! Should we check for NULL?? --> iDelKeyData should never be NULL since it is supposed to be a primary key
			//!! BUT key columns can be null - chetanp
			pRefCursor->PutInteger(ircRefColumn, iDelKeyData);
			while (pRefCursor->Next())
			{
				// Possible match, must check primary key data if value in vtcKeyColumn > 1 to be sure
				if (iKeyColumn > 1)
				{
					Bool fMatch = fTrue;
					for (i = 1; i < iKeyColumn; i++)
					{
						iDelKeyData = m_pColumnDef[i] & icdObject ? m_Data[i] : m_Data[i] - iIntegerDataOffset;
						if (pRefCursor->GetInteger(i) != iDelKeyData)
							fMatch = fFalse;
					}
					if (!fMatch)
						continue; // while (pRefCursor->Next())
				}
				// Insert error, as this row is referenced by a field of a row in another table (or this table)
				if (piRecord == 0)
				{
					piRecord = &(SetUpRecord(cCol));
					Assert(piRecord);
				}
				for (i = 1; i <= iKeyColumn; i++)
					piRecord->SetInteger(1, (int)iveRequired); // required field, needed for foreign key validation to succeed
				piRecord->SetInteger(0, iKeyColumn); // set num errors to primary key columns
				return m_riDatabase.Unblock(), piRecord; // Error already found (note, numErrors could differ, but shouldn't)
			}// end while (pRefCursor->Next())
		} // end while (riValidationCursor.Next())
		return m_riDatabase.Unblock(), 0; // no match found
	}

	// Set up _Validation table and cursor for Insert/Update validation
	// Set the filter of the cursor on the _Validation table for the 'Table' & 'Column' columns
	// Initialize the foreign key mask (32-bits, bit set on if column is supposed to be a foreign key)
	// Intialize validation status to no error
	int iForeignKeyMask = 0;
	iveEnum iveStat = iveNoError;
	riValidationCursor.Reset();
	riValidationCursor.SetFilter(iColumnBit(vtcTable)|iColumnBit(vtcColumn));

	// Validate a single field of the row
	// If invalid, the invalid enum is placed in that column's corresponding field of the error record
	// The zeroeth field of the record contains the number of invalid entries
	// At the field level, no foreign key validation occurs
	// Also, no special row level validation (where the value of a column is dependent upon another
	// column in the row
	if (iCol != -1 && iCol != 0)
	{
		Assert(m_riTable.GetColumnName(iCol) != 0);
		iveStat = ValidateField(riValidationTable, riValidationCursor, iCol, iForeignKeyMask, fFalse /*fRow*/, vtcTable, vtcColumn);
		if (iveStat != iveNoError)
		{
			if (piRecord == 0)
			{
				piRecord = &(SetUpRecord(cCol));
				Assert(piRecord);
			}
			piRecord->SetInteger(iCol, (int)iveStat);
			piRecord->SetInteger(0, 1);
		}
		return m_riDatabase.Unblock(), piRecord;
	}

	// Validate entire row
	// If invalid, the record field corresponding to the column number is marked with the particular error enum
	// At row validation, foreign keys are validated as well as special *row* related (where one column's value
	// depends on another column in that row)
	// The zeroeth field of the record contains the number of columns with errors
	int iNumErrors = 0;
	for (i = 1; i <= cCol; i++) // Check each field
	{
		iveStat = ValidateField(riValidationTable, riValidationCursor, i, iForeignKeyMask, fTrue /*fRow*/, vtcTable, vtcColumn);
		if (iveStat != iveNoError)
		{
			if (piRecord == 0)
			{
				piRecord = &(SetUpRecord(cCol));
				Assert(piRecord);
			}
			piRecord->SetInteger(i, (int)iveStat);
			iNumErrors++;
		}
	}
	
	// Valiate the foreign keys according to the foreign key mask (bit would be set for that column)
	if (iForeignKeyMask != 0)
		CheckForeignKeys(riValidationTable, riValidationCursor, piRecord, iForeignKeyMask, iNumErrors);

	// Row is about to inserted, check for duplicate primary keys
	// Help prevent errors that would occur at Insert time
	if (iCol == -1)
		CheckDuplicateKeys(piRecord, iNumErrors);

	// Insert the number of columns with errors in the zeroeth field
	if (piRecord)
		piRecord->SetInteger(0, iNumErrors);
	return m_riDatabase.Unblock(), piRecord;
}

iveEnum CMsiCursor::ValidateField(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor, int iCol,
											 int& iForeignKeyMask, Bool fRow, int vtcTable, int vtcColumn)
{
	// Check for temporary column as don't validate temporary columns
	if (!(m_pColumnDef[iCol] & icdPersistent))
		return iveNoError;

	// Insert data into _Validation table cursor
	riValidationCursor.Reset();

#ifdef DEBUG
	MsiString strTable(m_riTable.GetMsiStringValue());
	MsiString strColumn(m_riDatabase.DecodeString(m_riTable.GetColumnName(iCol)));
#endif

	riValidationCursor.PutString(vtcTable, *MsiString(m_riTable.GetMsiStringValue()));
	riValidationCursor.PutString(vtcColumn, *MsiString(m_riDatabase.DecodeString(m_riTable.GetColumnName(iCol))));
	if (!riValidationCursor.Next())
		return iveMissingData;

	// Check for correct localize attributes for column
	// Only non-primary string columns may have the localizable attribute
	if ((m_pColumnDef[iCol] & icdLocalizable)
	 && (m_pColumnDef[iCol] & (icdShort | icdObject | icdPrimaryKey)) != (icdShort | icdObject))
		return iveBadLocalizeAttrib;

	// Check for null data
	int vtcNullable = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colNullable));
	Assert(vtcNullable);
	int iData = m_pColumnDef[iCol] & icdObject ? m_Data[iCol] : m_Data[iCol] - iIntegerDataOffset;
	int iDef = m_pColumnDef[iCol];
	if (((iDef & icdObject) && iData == 0) || (!(iDef & icdObject) && iData == iMsiNullInteger))
		return (IStrComp(MsiString(riValidationCursor.GetString(vtcNullable)), TEXT("Y")) == 0) ? iveNoError : iveRequired;
	//!! is this needed anymore since we don't support ODBC?? -- t-caroln
	else if ( (iDef & icdString) == icdString && IStrComp(MsiString(m_riDatabase.DecodeString(m_Data[iCol])), TEXT("@")) == 0)
	{
		if (IStrComp(MsiString(riValidationCursor.GetString(vtcNullable)), TEXT("@")) == 0)
			return iveNoError;
	}
	
	// Data not null, continue checks
	int vtcCategory = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colCategory));
	Assert(vtcCategory);
	switch (m_pColumnDef[iCol] & icdTypeMask)
	{
	case icdLong: // fall through
	case icdShort:	 return CheckIntegerValue(riValidationTable, riValidationCursor, iCol, iForeignKeyMask, fFalse /*fVersionString*/);
	case icdString: return CheckStringValue(riValidationTable, riValidationCursor, iCol, iForeignKeyMask, fRow);
	case icdObject:
		{
			if (m_pColumnDef[iCol] & icdPersistent)
				return (IStrComp(MsiString(riValidationCursor.GetString(vtcCategory)), szBinary) ==  0) ? iveNoError : iveBadCategory;
			return iveNoError;
		}
	default: Assert(0); // should never happen, unknown column type
	}
	return iveNoError;
}
	

void CMsiCursor::CheckDuplicateKeys(IMsiRecord*& rpiRecord, int& iNumErrors)
{
	// Create a new cursor for table
	PMsiCursor pDuplicateCheckCursor(m_riTable.CreateCursor(fFalse));
	Assert(pDuplicateCheckCursor);
	pDuplicateCheckCursor->Reset();

	// Get number of primary keys and determine filter for cursor
	int cPrimaryKey = m_riTable.GetPrimaryKeyCount();
	int i;
	int iFilter=1;
	for (i=0; i < cPrimaryKey; i++)
		iFilter |= (1 << i);				
	pDuplicateCheckCursor->SetFilter(iFilter);
	
	// Insert primary keys
	for (i = 1; i <= cPrimaryKey; i++)
	{
		if(rpiRecord != 0 && rpiRecord->GetInteger(i) != iMsiStringBadInteger && rpiRecord->GetInteger(i) != iveNoError)
			return; // invalid (from previous data check)
		int iData = m_pColumnDef[i] & icdObject ? m_Data[i] : m_Data[i] - iIntegerDataOffset;
		pDuplicateCheckCursor->PutInteger(i, iData);
	}
	if (pDuplicateCheckCursor->Next())
	{
		// ERROR: Row with those primary keys already exists
		if (rpiRecord == 0)
		{	
			rpiRecord = &(SetUpRecord(m_riTable.GetColumnCount()));
			Assert(rpiRecord);
		}
		for (i = 1; i <= cPrimaryKey; i++, iNumErrors++)
			rpiRecord->SetInteger(i, (int)iveDuplicateKey);
	}
}

void CMsiCursor::CheckForeignKeys(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor,
											 IMsiRecord*& rpiRecord, int iForeignKeyMask, int& iNumErrors)
{
	MsiString strForeignTableName;  // foreign table name
	MsiString strCategory;			  // category string
	int       iStat;                // validation status
	int       iForeignCol;  		  // foreign column
	
	// Obtain column indexes of certain columns in the _Validation table
	int cCol = m_riTable.GetColumnCount();
	int vtcTable = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colTable));
	Assert(vtcTable);
	int vtcColumn = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colColumn));
	Assert(vtcColumn);
	int vtcKeyTable = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colKeyTable));
	Assert(vtcKeyTable);
	int vtcKeyColumn = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colKeyColumn));
	Assert(vtcKeyColumn);
	int vtcCategory = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colCategory));
	Assert(vtcCategory);
	
	// Cycle through mask to find those columns that are marked as foreign key columns
	for (int i = 0; i < cCol; i++)
	{
		if ( (1 << i) & iForeignKeyMask )
		{
			if (rpiRecord != 0 && rpiRecord->GetInteger(i+1) != iMsiStringBadInteger && rpiRecord->GetInteger(i+1) != iveNoError)
				continue; // already invalid

			iStat = 1;
			
			// Insert data into Validation table cursor
			riValidationCursor.Reset();
			riValidationCursor.PutString(vtcTable, *MsiString(m_riTable.GetMsiStringValue()));
			riValidationCursor.PutString(vtcColumn, *MsiString(m_riDatabase.DecodeString(m_riTable.GetColumnName(i+1))));
			if (!riValidationCursor.Next())
			{
				// Should never get here...should be caught earlier
				if (rpiRecord == 0)
				{	
					rpiRecord = &(SetUpRecord(m_riTable.GetColumnCount()));
					Assert(rpiRecord);
				}
				rpiRecord->SetInteger(i+1, (int)iveMissingData);
				iNumErrors++;
				continue;
			}

			// Determine which table this column is a foreign key to
			strForeignTableName = riValidationCursor.GetString(vtcKeyTable);
			strCategory = riValidationCursor.GetString(vtcCategory);
			iForeignCol = riValidationCursor.GetInteger(vtcKeyColumn);

			if (strForeignTableName.Compare(iscWithin, TEXT(";")) == 0)
				iStat = SetupForeignKeyValidation(strForeignTableName, strCategory, i+1, iForeignCol);
			else // Delimited list of tables
			{
				while (strForeignTableName.TextSize())
				{
					MsiString strTable = (const ICHAR*)0;  // Table name
					strTable = strForeignTableName.Extract(iseUptoTrim, TEXT(';'));
					iStat = SetupForeignKeyValidation(strTable, strCategory, i+1, iForeignCol);
					if (!strForeignTableName.Remove(iseIncluding, TEXT(';')) || iStat == 1)
						break;
				}
			}
			if (iStat != 1)
			{
				// Invalid, enter invalid enum in field of record
				if (rpiRecord == 0)
				{	
					rpiRecord = &(SetUpRecord(m_riTable.GetColumnCount()));
					Assert(rpiRecord);
				}
				rpiRecord->SetInteger(i+1, (int)(iStat == 0 ? iveBadLink : iveBadKeyTable));
				iNumErrors++;
			}
		}
	}// end for
}

int CMsiCursor::SetupForeignKeyValidation(MsiString& rstrForeignTableName, MsiString& rstrCategory, int iCol, int iForeignCol)
/*-----------------------------------------------------------------------------------------------------------------------
CMsiCursor::SetupForeignKeyValidation -- Sets up foreign key validation by determining the foreign table
name as well as parsing keyformatted strings which can have multiple properties within the string that
are foreign keys.

Some instances of the foreign keys are *special* and the table names change as they are not explicitly
listed as the foreign key tables in the 'KeyTable' column of the '_Validation' table.  The particular table
and the data that is supposed to be the foreign key are determined here.

  Returns:
	int 1 (valid), 0 (invalid), -1 (foreign table error)
------------------------------------------------------------------------------------------------------------------------*/
{
	// If fSpecialKey is true, then the foreign key validation ignores the 'KeyColumn' column and uses 1 as the
	// value for the 'KeyColumn' column
	Bool fSpecialKey = fFalse;

	// Put foreign key data into cursor
	MsiString strData = (const ICHAR*)0;
	if (m_pColumnDef[iCol] & icdObject)
		strData = m_riDatabase.DecodeString(m_Data[iCol]);
	else
		strData = (int) (m_Data[iCol] - iIntegerDataOffset);
	
	// Determine whether string is a special property string.
	// [#identifier] is a foreign key to the 'File' table
	// [$identifier] is a foreign key to the 'Component' table
	// [!identifier] is a foreign key to the 'File' table
	if ((strData.Compare(iscWithin, TEXT("[#")) != 0) ||
		(strData.Compare(iscWithin, TEXT("[!")) != 0) ||
		(strData.Compare(iscWithin, TEXT("[$")) != 0) )
	{
		fSpecialKey = fTrue;
		const ICHAR* pch =  (const ICHAR*)strData;
		ICHAR szValue[MAX_PATH];
		ICHAR* pchOut = szValue;
		int iStat = ERROR_FUNCTION_FAILED;
		while ( *pch != 0 ) // Must loop because can have multiple instances of [#abc] & [$abc] in string
		{
			if (*pch == '[')
			{
				pch++; // for '['
				if (*pch != '#' && *pch != '$' && *pch != '!')
				{
					// just a plain property
					while (*pch != ']')
						pch = ICharNext(pch); // move to end of property
					pch++; // for ']'
					continue;
				}
				if ((*pch == '#') || (*pch == '!'))
					rstrForeignTableName = MsiString(sztblFile); // link to file table
				else // *pch == '$'
					rstrForeignTableName = MsiString(sztblComponent); // link to component table
				pch++; // for '#' or '$'

				// get the property
				while (*pch != ']')
				{
#ifdef UNICODE
					*pchOut++ = *pch++;
#else // !UNICODE
					const ICHAR* pchTemp = pch;
					*pchOut++ = *pch;
					pch = ICharNext(pch);
					if (pch == pchTemp + 2)
						*pchOut++ = *(pch - 1); // for DBCS char
#endif // UNICODE
				}
				*pchOut = '\0'; // null terminate
				pch++; // for ']'

				// validate the foreign key
				MsiString strKey(szValue);
				if ((iStat = ValidateForeignKey( rstrForeignTableName, strKey, fSpecialKey, iCol, iForeignCol )) != 1)
					return iStat;

				// re-init
				pchOut = szValue;
			}
			else
				pch = ICharNext(pch);
		} // end while (*pch != 0)
		return iStat;
	}
	// Determine whether string is in the 'Source' column of the 'CustomAction' table
	// The table that it is a foreign key to depends on the value in the 'Type' column of the 'CustomAction' table
	// Can be a foreign key to the 'Binary', 'Directory', 'File', or 'Property' table
	// The 'Property' table is not validated as properties can be added at run-time
	else if (IStrComp(rstrCategory, szCustomSource) == 0)
	{
		fSpecialKey = fTrue;
		int catcType = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(szcatcType));
		Assert(catcType);
		int icaFlags = int(m_Data[catcType]);
		switch (icaFlags & icaSourceMask)
		{
		case icaBinaryData: rstrForeignTableName = MsiString(sztblBinary);    break;
		case icaSourceFile: rstrForeignTableName = MsiString(sztblFile);      break;
		case icaDirectory:  rstrForeignTableName = MsiString(sztblDirectory); break;
		case icaProperty:   return 1;
		default:            return 0; // invalid (not a defined custom source type)
		}
	}
	// Determine whether string is in the 'Target' column of the 'Shortcut' table
	// Means that string does not contain properties (brackets)
	// String must be a foreign key to the 'Feature' table
	else if (IStrComp(rstrCategory, szShortcut) == 0)
	{
		fSpecialKey = fTrue;
		rstrForeignTableName = MsiString(sztblFeature);
	}
	return ValidateForeignKey( rstrForeignTableName, strData, fSpecialKey, iCol, iForeignCol );
}

int CMsiCursor::ValidateForeignKey(MsiString& rstrTableName, MsiString& rstrData, Bool fSpecialKey, int iCol, int iForeignCol)
/*----------------------------------------------------------------------------------------------------------------------
CMsiCursor::ValidateForeignKey -- Performs actual validation of foreign key by setting up foreign table and cursor and
attempting to find record in the foreign table.

  Returns:
	int 1 (valid), 0 (invalid), -1 (foreign table error)
-----------------------------------------------------------------------------------------------------------------------*/
{
	PMsiTable pForeignTable(0);		  // Foreign table
	PMsiCursor pForeignTableCursor(0); // Cursor on Foreign table
	IMsiRecord* piErrRecord;   		  // Error record holder
	int i;	    							  // Loop variable

	// Load foreign table
	if ((piErrRecord = m_riDatabase.LoadTable(*rstrTableName, 0, *&pForeignTable)) != 0)
	{
		piErrRecord->Release();
		return -1; // invalid (unable to load foreign table)
	}

	// Set up foreign table cursor
	pForeignTableCursor = pForeignTable->CreateCursor(fFalse);
	Assert(pForeignTableCursor);
	pForeignTableCursor->Reset();
	if (fSpecialKey)
		iForeignCol = 1; // automatic for [#abc], [$abc], Shortcut.Target and CustomSource data

	// Determine filter according to iForeignCol and set filter
	int iFilter=1;
	for (i=0; i < iForeignCol; i++)
		iFilter |= (1 << i);				
	pForeignTableCursor->SetFilter(iFilter);

	// Insert data into cursor
	// Use integers except in case of special key (and we know these are all strings)
	Bool fIntValue = fFalse;
	int iDataValue = 0;
	if (!fSpecialKey)
	{
		if (m_pColumnDef[iCol] & icdObject)
			iDataValue = m_Data[iCol];
		else
		{
			fIntValue = fTrue;
			iDataValue = m_Data[iCol] - iIntegerDataOffset;
		}
		pForeignTableCursor->PutInteger(iForeignCol, iDataValue);
	}
	else
		pForeignTableCursor->PutString(iForeignCol, *rstrData);
	
	if (iForeignCol != 1)
	{
		// More data needed for validation....primary key cols
		for (i = 1; i < iForeignCol; i++)
		{
			int iValue;
			if (m_pColumnDef[i] & icdObject)
				iValue = m_Data[i];
			else
				iValue = m_Data[i] - iIntegerDataOffset;
			pForeignTableCursor->PutInteger(i, iValue);
		}
	}
	if (pForeignTableCursor->Next())
		return 1;
	
	// check for possibility of self-joins
	PMsiTable pTable(&GetTable());
	MsiString strTableName(pTable->GetMsiStringValue());
	if (0 == IStrComp(rstrTableName, strTableName))
	{
		// foreign key table name and us match, self-join
		// compare column to iForeignCol value
		// we only need to compare that last of the primary key
		if (fIntValue)
		{
			// integer compare
			if (iDataValue == (m_Data[iForeignCol] - iIntegerDataOffset))
				return 1; // no error
		}
		else
		{
			// string compare
			if (0 == IStrComp(rstrData, MsiString(m_riDatabase.DecodeString(m_Data[iForeignCol]))))
				return 1; // no error
		}
	}
	return 0; // invalid
}

iveEnum CMsiCursor::CheckIntegerValue(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor, int iCol, int& iForeignKeyMask, Bool fVersionString)
/*-----------------------------------------------------------------------------------------------------------------------
CMsiCursor::CheckIntegerValue -- Checks the integer data for being between the acceptable limits of the MinValue and
MaxValue columns of the _Validation table. The integer data can also be a member of a set or be a foreign key.

  Returns:
	iveEnum -- iveNoError (valid)
					or iveOverflow or iveUnderflow for invalid data
------------------------------------------------------------------------------------------------------------------------*/
{
	int vtcMinValue = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colMinValue));
	Assert(vtcMinValue);
	int vtcMaxValue = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colMaxValue));
	Assert(vtcMaxValue);
	int vtcKeyTable = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colKeyTable));
	Assert(vtcKeyTable);
	int vtcSet = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colSet));
	Assert(vtcSet);
	
	int iData = m_pColumnDef[iCol] & icdObject ? m_Data[iCol] : m_Data[iCol] - iIntegerDataOffset;
	int iMaxValue = riValidationCursor.GetInteger(vtcMaxValue); // Max value allowed
	int iMinValue = riValidationCursor.GetInteger(vtcMinValue); // Min value allowed
	Bool fSet = (riValidationCursor.GetInteger(vtcSet) == 0 ? fFalse : fTrue);

	if (!fSet)
	{
		if (iMinValue != iMsiNullInteger && iMaxValue != iMsiNullInteger && iMinValue > iMaxValue)
			return iveBadMaxMinValues; // invalid (_Validation table max < min)
		else if (iMinValue == iMsiNullInteger && iMaxValue == iMsiNullInteger && !fSet)
				return iveNoError;
		else if (iMinValue == iMsiNullInteger && iData <= iMaxValue)
			return iveNoError;
		else if (iMaxValue == iMsiNullInteger && iData >= iMinValue)
			return iveNoError; 	
		else if (iData >= iMinValue && iData <= iMaxValue)
			return iveNoError;
	}
#ifdef DEBUG
	else
	{
		// cannot have both sets and ranges.
		Assert(iMsiNullInteger == iMinValue);
		Assert(iMsiNullInteger == iMaxValue);
	}
#endif

	
	// Data failed accepted values, check Set if possible
	if (fSet && CheckSet(MsiString(riValidationCursor.GetString(vtcSet)), MsiString(iData), fTrue /*fIntegerData*/))
		return iveNoError;
	
	// Data failed accepted values and set, check foreign key if possible
	if (riValidationCursor.GetInteger(vtcKeyTable) != 0 && !fVersionString)
	{	
		iForeignKeyMask |=  1 << (iCol - 1);
		return iveNoError;
	}

	// Return an informative error msg
	if (fSet)
		return iveNotInSet;
	return iData < iMinValue ? iveUnderFlow : iveOverFlow;
}
	
const ICHAR szScrollableTextControl[] = TEXT("ScrollableText");

iveEnum CMsiCursor::CheckStringValue(IMsiTable& riValidationTable, IMsiCursor& riValidationCursor, int iCol, int& iForeignKeyMask, Bool fRow)
/*-----------------------------------------------------------------------------------------------------------------------
CMsiCursor::CheckStringValue -- validates string column of a row.  The strings can also be a member of a set, a particular
data category, or a foreign key.

  Returns:
	iveEnum -- iveNoError (valid)
					other iveEnums for invalid data
------------------------------------------------------------------------------------------------------------------------*/
{
	// Column numbers
	int vtcKeyTable = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colKeyTable));
	Assert(vtcKeyTable);
	int vtcCategory = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colCategory));
	Assert(vtcCategory);
	
	// Variables
	MsiString strCategory(riValidationCursor.GetString(vtcCategory)); // Category
	MsiString strData(m_riDatabase.DecodeString(m_Data[iCol]));			// Data
	
	// Check string length, 0 indicates infinite
	int iLen = m_pColumnDef[iCol] & 255;
	if (iLen != 0 && strData.TextSize() > iLen)
		return iveStringOverflow;
	
	MsiString strSet = (const ICHAR*)0;											// Set data
	iveEnum iveStat   = iveNoError;												// Status
	Bool fIntPossible = fFalse;													// Can be int
	Bool fKey         = fFalse;													// Could be foreign key
	Bool fVersionString = fFalse;													// Whether version string

	// See if can be foreign key
	if (riValidationCursor.GetInteger(vtcKeyTable) != 0)
		fKey = fTrue;
	if (IStrComp(strCategory, szIdentifier) == 0)	// Identifier string
	{
		if (fKey)
			iForeignKeyMask |= 1 << (iCol - 1);
		if (CheckIdentifier((const ICHAR*)strData))
			return iveNoError;
		iveStat = iveBadIdentifier;
	}
	// fKeyAllowed should always be TRUE now as Darwin does not distinguish.
	// Only difference is Template allows [1], [2] etc. whereas KeyFormatted and Formatted do not
	// KeyFormatted not removed for backwards compatibility sake
	else if (IStrComp(strCategory, szFormatted) == 0)	// Formatted string
	{
		// per bug 191416, check for special case of type 37 or 38 custom actions where the target column is
		// treated as literal script text rather than formatted text. note that if this is the CustomAction table
		// and the Target column, we must return success on Field level only validation since we do not have enough
		// information to determine otherwise (szCustomSource is similar...)

		MsiString strTable = m_riTable.GetMsiStringValue();
		
		// verify that this is the CustomAction.Target column ... if not, then default to original behavior
		if (IStrComp(strTable, sztblCustomAction) == 0
			&& m_riDatabase.EncodeStringSz(sztblCustomAction_colTarget) == m_riTable.GetColumnName(iCol))
		{
			if (fRow)
			{
				unsigned int iColCAType = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblCustomAction_colType));
				Assert(iColCAType);
				int iCATypeFlags = int(m_Data[iColCAType]) & icaTypeMask;
				int iCASourceFlags = int(m_Data[iColCAType]) & icaSourceMask;
				if ((icaVBScript == iCATypeFlags || icaJScript == iCATypeFlags) && (icaDirectory == iCASourceFlags))
				{
					// straight literal script text is stored in CustomAction.Target column
					return iveNoError;
				}
			}
			else // !fRow
			{
				// can't check the type at field level only since no other info exists
				// must simply return success ... similar to szCustomSource
				return iveNoError;
			}
		} // end special CustomAction.Target column validation
		
		if (IStrComp(strTable, sztblControl) == 0
			&& m_riDatabase.EncodeStringSz(sztblControl_colText) == m_riTable.GetColumnName(iCol))
		{
			if (fRow)
			{
				unsigned int iColCtrlType = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblControl_colType));
				Assert(iColCtrlType);
				MsiString strControlType(m_riDatabase.DecodeString(m_Data[iColCtrlType]));			// Data
				if (IStrComp(strControlType, szScrollableTextControl) == 0)
				{
					// RTF text is stored in Control.Text column when Control.Type='ScrollableText'
					return iveNoError;
				}
			}
			else // !fRow
			{
				// can't check the type at field level only since no other info exists
				// must simply return success
				return iveNoError;
			}
		} // end special Control.Text column validation for scrollable text controls that include RTF

		if (GetProperties((const ICHAR*)strData, fTrue /*fFormatted*/, fTrue /*fKeyAllowed*/, iCol, iForeignKeyMask))
			 return iveNoError;
		iveStat = iveBadFormatted;
	}
	else if (IStrComp(strCategory, szTemplate) == 0)	// Template string
	{
		if (GetProperties((const ICHAR*)strData, fFalse /*fFormatted*/, fTrue /*fKeyAllowed*/, iCol, iForeignKeyMask))
			 return iveNoError;
		iveStat = iveBadTemplate;
	}
	else if (IStrComp(strCategory, szKeyFormatted) == 0)	// KeyFormatted string
	{
		if (GetProperties((const ICHAR*)strData, fTrue /*fFormatted*/, fTrue /*fKeyAllowed*/, iCol, iForeignKeyMask))
			 return iveNoError;
		iveStat = iveBadFormatted;
	}
	else if (IStrComp(strCategory, szProperty) == 0)	// Property string
	{
		if (strData.Compare(iscStart, TEXT("%")) != 0)
			strData.Remove(iseFirst, 1);
		if (CheckIdentifier((const ICHAR*)strData))
			return iveNoError;
		iveStat = iveBadProperty;
	}
	else if (IStrComp(strCategory, szCondition) == 0)	// Conditional string
	{
		if (strData == 0)
			return iveNoError;
		CMsiValConditionParser Parser((const ICHAR*)strData);
		ivcpEnum ivcpStat = Parser.Evaluate(vtokEos);
		if (ivcpStat == ivcpNone || ivcpStat == ivcpValid)
			return iveNoError;
		iveStat = iveBadCondition;
	}
	else if (IStrComp(strCategory, szFilename) == 0)	// Filename
	{
		if (ParseFilename(strData, fFalse /*fAllowWildcards*/))
			return iveNoError;
		iveStat = iveBadFilename;
	}
	else if (IStrComp(strCategory, szGuid) == 0)	// Guid/ClassId string
	{
		// must be all UPPER CASE
		if (!CheckCase(strData, fTrue /*fUPPER*/))
			iveStat = iveBadGuid;
		else
		{
			// it may also be a foreign key
			LPCLSID pclsid = new CLSID;
#ifdef UNICODE
			HRESULT hres = OLE32::IIDFromString(const_cast<ICHAR*>((const ICHAR*)strData), pclsid);
#else
			CTempBuffer<WCHAR, cchMaxCLSID> wsz; /* Buffer for unicode string */
			int iReturn = WIN::MultiByteToWideChar(CP_ACP, 0, (const ICHAR*)strData, strData.TextSize() + 1, wsz, strData.TextSize() + 1);
			HRESULT hres = OLE32::IIDFromString(wsz, pclsid);
#endif
			if (pclsid)
				delete pclsid;
			if (hres == S_OK)
			{
				if (fKey)
					iForeignKeyMask |= 1 << (iCol - 1);
				return iveNoError;
			}
			iveStat = iveBadGuid;
		}
	}
	else if (IStrComp(strCategory, szRegPath) == 0)	// RegPath string
	{
		ICHAR rgDoubleSeps[] = {chRegSep, chRegSep, '\0'};

		if (strData.Compare(iscStart, szRegSep) || strData.Compare(iscEnd, szRegSep) ||
			strData.Compare(iscWithin, rgDoubleSeps))
			iveStat = iveBadRegPath; // cannot begin/end with a '\' and can't have 2 in a row
		else if (GetProperties((const ICHAR*)strData, fTrue /*fFormatted*/, fTrue /*fKeyAllowed*/, iCol, iForeignKeyMask))
			return iveNoError;
		iveStat = iveBadRegPath;
	}
	else if (IStrComp(strCategory, szLanguage) == 0)	// Language string
	{
		Bool fLangStat = fTrue;
		int iLangId;
		MsiString strLangId = (const ICHAR*)0;
		while (strData.TextSize())
		{
			strLangId = strData.Extract(iseUptoTrim, TEXT(','));
			if ((iLangId = int(strLangId)) == iMsiStringBadInteger || iLangId & iMask)
			{
				fLangStat = fFalse; // invalid (lang id bad)
				break; // short-circuit loop, we're already invalid
			}
			if (!strData.Remove(iseIncluding, TEXT(',')))
				break;
		}
		if (fLangStat)
			return iveNoError;
		iveStat = iveBadLanguage;
	}
	else if (IStrComp(strCategory, szAnyPath) == 0)	// AnyPath string
	{
		if (strData.Compare(iscWithin, TEXT("|")))
		{
			// only filenames (parent-relative paths) are supported with a pipe.
			MsiString strSFN = strData.Extract(iseUpto, '|');
			if (ifvsValid != CheckFilename(strSFN, fFalse /*fLFN*/))
				iveStat = iveBadPath;
			else
			{
				// validate LFN
				MsiString strLFN = strData.Extract(iseLast, strData.CharacterCount() - strSFN.CharacterCount() -1);
				if (ifvsValid != CheckFilename(strLFN, fTrue/*fLFN*/))
					iveStat = iveBadPath;
			}
		}
		else
		{
			if (!ParsePath(strData, true /*fRelative*/))
				iveStat = iveBadPath;
		}
	}
	else if (IStrComp(strCategory, szPaths) == 0)	// Delimited set of Paths string
	{
		Bool fPathsStat = fTrue;
		MsiString strPath = (const ICHAR*)0;
		while (strData.TextSize())
		{
			// Darwin supports SFN or LFN in the path data type. Only blatantly
			// bad things can be checked here, because darwin will often ignore
			// bogus paths or generate SFN versions
			strPath = strData.Extract(iseUptoTrim, ';');
			if (!ParsePath(strPath, false /*fRelative*/))
			{
				fPathsStat = fFalse; // invalid (bad path)
				break;
			}
			if (!strData.Remove(iseIncluding, ';'))
				break;
		}
		if (fPathsStat)
			return iveNoError;
		iveStat = iveBadPath;
	}
	else if (IStrComp(strCategory, szURL) == 0) // URL string
	{
		// is it URL syntax?
		bool fFileUrl = false;
		if (!IsURL((const ICHAR*)strData, fFileUrl))
			iveStat = iveBadPath; // invalid
		else
		{
			// try and canonicalize it
			ICHAR szCanonicalizedURL[MAX_PATH+1] = TEXT("");
			DWORD cchURL = MAX_PATH;
			if (!MsiCanonicalizeUrl((const ICHAR*)strData, szCanonicalizedURL, &cchURL, dwMsiInternetNoEncode))
				iveStat = iveBadPath; // invalid -- could not canonicalize it
			else
				return iveNoError;
		}
	}
	else if (IStrComp(strCategory, szDefaultDir) == 0)	// DefaultDir string
	{
		// DefaultDir: roots may be 'identifier' or '%identifier'
		//             non-roots may be 'filename', '[identifier]', or [%identifier]
		int dtcDirParent = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblDirectory_colDirectoryParent));
		int dtcDirectory;
		if (dtcDirParent == 0)
		{
			// Repack SourceDirectory table
			dtcDirParent = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(szsdtcSourceParentDir));
			dtcDirectory = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(szsdtcSourceDir));
		}
		else
			dtcDirectory = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblDirectory_colDirectory));
		Assert(dtcDirParent);
		Assert(dtcDirectory);
		// Know that DirParent and Directory cols are identifiers...no integers, no offset
		Bool fRoot = (m_Data[dtcDirParent] != 0 && m_Data[dtcDirParent] != m_Data[dtcDirectory]) ? fFalse : fTrue;	
		if(fRoot)
		{
			// may be identifier or %identifier
			// %identifier ?
			if (strData.Compare(iscStart, TEXT("%")) != 0)
				strData.Remove(iseFirst, 1);
			// identifier ?
			if (CheckIdentifier((const ICHAR*)strData))
				return iveNoError;
			iveStat = iveBadDefaultDir;
		}
		else
		{
			int c = strData.Compare(iscWithin,TEXT(":")) ? 2 : 1;
			Bool fBad = fFalse;
			for(int i = 1; i <= c; i++)
			{
				// filename ?
				MsiString strFileName = strData.Extract((i == 1 ? iseUpto : iseAfter), ':');
				
				// is it only a period?  (dir located in parent w/out subdir)
				if (strFileName.Compare(iscExact, TEXT(".")))
					continue;
				
				if (!ParseFilename(strFileName, fFalse /*allow wildcards*/))
				{
					fBad = fTrue;
					break;
				}
			}
			if(fBad)
				iveStat = iveBadDefaultDir;
			else
				return iveNoError;
		}
	}
	else if (IStrComp(strCategory, szVersion) == 0)	// Version string
	{
		// Per bug 8122, the requirement for having a language column is completely removed from the
		// "Version" data type. This check will be moved to an ICE. Thus we only check the
		// #####.#####.#####.##### format.
		const ICHAR* pchVersion = (const ICHAR*)strData;

		// can't have a '.' at the beginning
		if (*pchVersion == '.')
		{
			iveStat = iveBadVersion;
		}
		else
		{
			for (unsigned int ius = 0; ius < 4; ius++)
			{
				// convert the string of digits into a number
				long lVerNum = 0;
				int cChars = 0;
				while (*pchVersion != 0 && *pchVersion != '.')
				{
					if (!FIsdigit(*pchVersion) || (++cChars > 5))
					{
						iveStat = iveBadVersion;
						break;
					}
					
					lVerNum *= 10;
					lVerNum += *pchVersion-'0';					
					pchVersion = ICharNext(pchVersion);
				}
			
				// hit the end of the string, a period, or a bogus character.
				if (lVerNum > 65535)
				{
					iveStat = iveBadVersion;
					break;
				}

				// If we hit a period make sure the next character is also
				// not a period or null
				if (*pchVersion == '.')
				{
					pchVersion = ICharNext(pchVersion);
					if (*pchVersion == 0 || *pchVersion == '.')
					{
						iveStat = iveBadVersion;
						break;
					}
				}
				else
					break; // bad character or end of string
			}
			// should be at the end of the string
			if (*pchVersion != 0)
				iveStat = iveBadVersion;
		}
		if (iveStat == iveNoError)
			return iveNoError;
	}
	else if (IStrComp(strCategory, szCabinet) == 0) // Cabinet string
	{
		const ICHAR* pch = (const ICHAR*)strData;
		if (*pch == '#')
		{
			// cabinet in stream must be a valid identifer
			strData.Remove(iseFirst, 1);
			if (CheckIdentifier(strData))
				return iveNoError;
		}
		else
		{
			if (ifvsValid == CheckWildFilename(strData, fTrue /*fLFN*/, fFalse /*allow wildcards*/))
				return iveNoError;
		}
		iveStat = iveBadCabinet;
	}
	else if (IStrComp(strCategory, szShortcut) == 0) // Shortcut string
	{
		if (strData.Compare(iscWithin, TEXT("[")) == 0)
		{
			iForeignKeyMask |= 1 << (iCol - 1); // foreign key to feature table
			if (CheckIdentifier((const ICHAR*)strData))
				return iveNoError;
		}
		else
		{
			if (GetProperties((const ICHAR*)strData, fTrue /*fFormatted*/, fTrue /*fKeyAllowed*/, iCol, iForeignKeyMask))
				return iveNoError;
		}
		iveStat = iveBadShortcut;
	}
	else if (IStrComp(strCategory, szCustomSource) == 0)	// CustomSource string
	{
		if (fRow)
		{
			int catcType = m_riTable.GetColumnIndex(m_riDatabase.EncodeStringSz(szcatcType));
			Assert(catcType);
			int icaFlags = int(m_Data[catcType]);

			if ((icaFlags & icaTypeMask) == icaInstall) // special source handling for nested install
				return iveNoError;  // custom validators take care of nested installs
			iForeignKeyMask |= 1 << (iCol - 1);
			if (CheckIdentifier((const ICHAR*)strData))
				return iveNoError;
			iveStat = iveBadCustomSource;
			return iveNoError;
		}
		else
			return iveNoError; // only field level so we have no way of knowing what type of CA
	}
	else if (IStrComp(strCategory, szWildCardFilename) == 0)	// WildCardFilename
	{
		if (ParseFilename(strData, fTrue /*allow wildcards*/))
			return iveNoError;
		iveStat = iveBadWildCard;
	}
	else if (IStrComp(strCategory, szText) == 0)	// Any String allowed
		return iveNoError;
	else if (IStrComp(strCategory, szPath) == 0)	// Path string
	{
		// only blatantly bad things can be checked here. Bogus paths
		// on one system may be valid on another, and Darwin will
		// often ignore them. DrLocator for example.
		if (ParsePath(strData, false /*fRelative*/))
			return iveNoError;
		iveStat = iveBadPath;
	}
	else if (IStrComp(strCategory, szUpperCase) == 0)	// Upper-case
	{
		// if it's bad case, immediately kick out.  However,
		// it may also have foreign keys.
		if (!CheckCase(strData, fTrue /*fUpperCase*/))
			return iveBadCase;
	}
	else if (IStrComp(strCategory, szLowerCase) == 0)	// Lower-case
	{
		if (CheckCase(strData, fFalse /*fUpperCase*/))
			return iveNoError;
		iveStat = iveBadCase;
	}
	else if (IStrComp(strCategory, szBinary) == 0)	// Stream -- should never happen
		return iveBadCategory;
	else if (strCategory.TextSize() > 0)	// Unsupported category string
		return iveBadCategory;

	// Check to see if can be an integer value
	int vtcMinValue = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colMinValue));
	Assert(vtcMinValue);
	int vtcMaxValue = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colMaxValue));
	Assert(vtcMaxValue);
	if ((riValidationCursor.GetInteger(vtcMinValue) != iMsiNullInteger || riValidationCursor.GetInteger(vtcMaxValue) != iMsiNullInteger)
		&& (int)strData != iMsiStringBadInteger)
	{
		if (CheckIntegerValue(riValidationTable, riValidationCursor, iCol, iForeignKeyMask, fVersionString))
			return iveNoError;
	}
	
	// Check to see if it is a member of the set
	int vtcSet = riValidationTable.GetColumnIndex(m_riDatabase.EncodeStringSz(sztblValidation_colSet));
	Assert(vtcSet);
	if (riValidationCursor.GetInteger(vtcSet) != 0)
	{
		if (iveStat == iveNoError)
			iveStat = iveNotInSet;
		if (CheckSet(MsiString(riValidationCursor.GetString(vtcSet)), strData, fFalse /*fIntegerData*/))
			return iveNoError;
	}

	// Check to see if is an identifier for a foreign key
	if (fKey)
	{
		iForeignKeyMask |= 1 << (iCol - 1);
		if (CheckIdentifier((const ICHAR*)strData))
			return iveNoError;
	}
	return iveStat;
}

Bool CMsiCursor::SetRowState(iraEnum ira, Bool fState)
{
	if ((unsigned)ira >= (unsigned)iraSettableCount)
		return fFalse;
	if (fState)
		m_Data[0] |= 1 << (iRowBitShift + ira);
	else
		m_Data[0] &= ~(1 << (iRowBitShift + ira));
	return fTrue;
}

Bool CMsiCursor::GetRowState(iraEnum ira)
{
	return m_Data[0] & (1 << (iRowBitShift + ira)) ? fTrue : fFalse;
}

// notification from table when any row is deleted
// Does not block the database because all callers block/unblock.
void CMsiCursor::RowDeleted(unsigned int iRow, unsigned int iPrevNode)
{
	if (iRow == 0)
		Reset();
	else if (iRow <= m_iRow)
	{
		if (iRow == m_iRow--) // position to previous record
		{
			if (m_fTree)
				m_iRow = iPrevNode;  // previous node if tree walk cursor
			int fDirty = m_fDirty;  // null out any non-dirty fields
			MsiColumnDef* pColumnDef = m_pColumnDef;
			MsiTableData* pData = m_Data;
			pData[0] = iTreeInfoMask;  // flag refresh to not fetch previous record
			for (int iCol = 1; pColumnDef++, pData++, iCol <= m_rcColumns; iCol++, fDirty >>= 1)
			{
				if (*pData != 0 && !(fDirty & 1))
				{
					if (*pColumnDef & icdObject)
					{
						if (*pColumnDef & icdShort)  // string
							m_riDatabase.UnbindStringIndex(*pData);
						else  // object
						{
							int iData = m_Data[iCol];
							ReleaseObjectData(iData);
						}
					}
					*pData = 0;
				}
			}
		}
	}
	if (m_piNextCursor)
		m_piNextCursor->RowDeleted(iRow, iPrevNode);
}

// notification from table when any row is inserted causing data movement

void CMsiCursor::RowInserted(unsigned int iRow)
{
	if (iRow <= m_iRow)
		m_iRow++;
	if (m_piNextCursor)
		m_piNextCursor->RowInserted(iRow);
}

// notification from database when strings are persisted

void CMsiCursor::DerefStrings()
{
	MsiColumnDef* pColumnDef = m_pColumnDef;
	MsiTableData* pData = m_Data;
	for (int cCol = m_rcColumns; pColumnDef++, pData++, cCol-- > 0; )
	{
		if ((*pColumnDef & (icdObject|icdShort)) == (icdObject|icdShort))
			m_riDatabase.DerefTemporaryString(*pData);
	}
	if (m_piNextCursor)
		m_piNextCursor->DerefStrings();  // notify all cursors
}

// creates a stream object from storage using table and primary key for name

IMsiStream* CMsiCursor::CreateInputStream(IMsiStorage* piInputStorage)
{
	MsiString istrName(m_riDatabase.ComputeStreamName(m_riDatabase.DecodeStringNoRef(
										m_riTable.GetTableName()), m_Data+1, m_pColumnDef+1));
	IMsiStorage* piStorage;
	if (piInputStorage)
		piStorage = piInputStorage;
	else
		piStorage = m_riTable.GetInputStorage();

	if (!piStorage)
		return 0;
	IMsiStream* piStream = 0;
	IMsiRecord* piError = piStorage->OpenStream(istrName, fFalse, piStream);
	if (piError)
		piError->Release();
	return piStream;
}

Bool CMsiCursor::CheckNonNullColumns()
{
	MsiColumnDef* pColumnDef = m_pColumnDef;
	MsiTableData* pData = m_Data;
	for (int cCol = m_rcColumns; pColumnDef++, pData++, cCol-- > 0; )
		if (*pData == 0 && (*pColumnDef & (icdNullable|icdInternalFlag)) == 0)
			return fFalse;
	return fTrue;
}

// returns unique identifier for row, using database's ComputeStreamName method which creates a name
// having table.key1.key2... format
const IMsiString& CMsiCursor::GetMoniker()
{
	return (m_riDatabase.ComputeStreamName(m_riDatabase.DecodeStringNoRef(m_riTable.GetTableName()), m_Data+1, m_pColumnDef+1));
}

//____________________________________________________________________________
//
// CMsiTextKeySortCursor implementation
//____________________________________________________________________________

CMsiTextKeySortCursor::CMsiTextKeySortCursor(CMsiTable& riTable, CMsiDatabase& riDatabase, int cRows, int* rgiIndex)
	: CMsiCursor(riTable, riDatabase, fFalse), m_iIndex(0), m_cIndex(cRows), m_rgiIndex(rgiIndex)
{
	m_idsUpdate = idsNone;  // read-only cursor, cannot maintain index on update
}

unsigned long CMsiTextKeySortCursor::Release()
{
	if (m_Ref.m_iRefCnt == 1)
		delete [] m_rgiIndex;
	return CMsiCursor::Release();
}

int CMsiTextKeySortCursor::Next()
{
	if (m_iIndex < m_cIndex)
	{
		m_riDatabase.Block();
		int iRet = m_riTable.FetchRow(m_rgiIndex[m_iIndex++], m_Data);
		m_riDatabase.Unblock();
		return iRet;
	}
	Reset();
	return 0;
}

void CMsiTextKeySortCursor::Reset()
{
	m_iIndex = 0;
	CMsiCursor::Reset();
}



vtokEnum CMsiValConditionParser::Lex()
{
	if (m_fAhead || m_vtok == vtokEos)
	{
		m_fAhead = fFalse;
		return m_vtok;
	}
	ICHAR ch;   // skip white space
	while ((ch = *m_pchInput) == ' ' || ch == '\t')
		m_pchInput++;
	if (ch == 0)  // end of expression
		return (m_vtok = vtokEos);

	if (ch == '(')   // start of parenthesized expression
	{
		++m_pchInput;
		m_iParenthesisLevel++;
		return (m_vtok = vtokLeftPar);
	}
	if (ch == ')')   // end of parenthesized expression
	{
		++m_pchInput;
		m_vtok = vtokRightPar;
		if (m_iParenthesisLevel-- == 0)
			m_vtok = vtokError;
		return m_vtok;
	}
	if (ch == '"')  // text literal
	{
		const ICHAR* pch = ++m_pchInput;
		Bool fDBCS = fFalse;
		while ((ch = *m_pchInput) != '"')
		{
			if (ch == 0)
				return (m_vtok = vtokError);
#ifdef UNICODE
			m_pchInput++;
#else // !UNICODE
			const ICHAR* pchTemp = m_pchInput;
			m_pchInput = INextChar(m_pchInput);
			if (m_pchInput == pchTemp + 2)
				fDBCS = fTrue;
#endif // UNICODE
		}
//		Assert((m_pchInput - pch) <= INT_MAX);	//--merced: 64-bit ptr subtraction may lead to values too big for cch.
		int cch = (int)(INT_PTR)(m_pchInput++ - pch);
		memcpy(m_istrToken.AllocateString(cch, fDBCS), pch, cch * sizeof(ICHAR));
		m_iToken = iMsiNullInteger; // prevent compare as an integer
	}
	else if (ch == '-' || ch >= '0' && ch <= '9')  // integer
	{
		m_iToken = ch - '0';
		int chFirst = ch;  // save 1st char in case minus sign
		if (ch == '-')
			m_iToken = iMsiNullInteger; // check for lone minus sign

		while ((ch = *(++m_pchInput)) >= '0' && ch <= '9')
			m_iToken = m_iToken * 10 + ch - '0';
		if (m_iToken < 0)  // integer overflow or '-' with no digits
			return (m_vtok = vtokError);
		if (chFirst == '-')
			m_iToken = -m_iToken;
		m_istrToken = (const ICHAR*)0;
	}
	else if ((ch == '_') || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'))
	{
		const ICHAR* pch = m_pchInput;
		while (((ch = *m_pchInput) >= '0' && ch <= '9')
			  || (ch == '_')  // allow underscore??
			  || (ch == '.')  // allow period??
			  || (ch >= 'A' && ch <= 'Z')
			  || (ch >= 'a' && ch <= 'z'))
			m_pchInput++;
//		Assert((m_pchInput - pch) <= INT_MAX);	//--merced: 64-bit ptr subtraction may lead to values too big for cch.
		int cch = (int)(INT_PTR)(m_pchInput - pch);
		if (cch <= 3)  // check for text operators
		{
			switch((pch[0] | pch[1]<<8 | (cch==3 ? pch[2]<<16 : 0)) & 0xDFDFDF)
			{
			case 'O' | 'R'<<8:           return (m_vtok = vtokOr);
			case 'A' | 'N'<<8 | 'D'<<16: return (m_vtok = vtokAnd);
			case 'N' | 'O'<<8 | 'T'<<16: return (m_vtok = vtokNot);
			case 'X' | 'O'<<8 | 'R'<<16: return (m_vtok = vtokXor);
			case 'E' | 'Q'<<8 | 'V'<<16: return (m_vtok = vtokEqv);
			case 'I' | 'M'<<8 | 'P'<<16: return (m_vtok = vtokImp);
			};
		}
		memcpy(m_istrToken.AllocateString(cch, fFalse), pch, cch * sizeof(ICHAR));
		m_istrToken = (const ICHAR*)0;
		m_iToken = m_istrToken;
	}
	else if ( ch == '%' || ch == '$' || ch == '&' || ch == '?' || ch == '!' )
	{
		const ICHAR* pch = m_pchInput;
		m_pchInput++;
		if ((ch = *m_pchInput) == '_' || (ch >= 'A' && ch <= 'Z') || (ch >='a' && ch <= 'z'))
		{
			m_pchInput++;
			while (((ch = *m_pchInput) >= '0' && ch <= '9')
					|| (ch == '_') // allow underscore??
					|| (ch == '.') // allow period??
					|| (ch >= 'A' && ch <= 'Z')
					|| (ch >= 'a' && ch <= 'z'))
				m_pchInput++;
			m_istrToken = (const ICHAR*)0;
		}
		else
			return (m_vtok = vtokError);
	}
	else // check for operators
	{
		ICHAR ch1 = *m_pchInput++;
		if (ch1 == '~')  // prefix for string operators
		{
			m_iscMode = iscExactI;
			ch1 = *m_pchInput++;
		}
		else
			m_iscMode = iscExact;

		if (ch1 == '=')
			return (m_vtok = vtokEQ);

		ICHAR ch2 = *m_pchInput;
		if (ch1 == '<')
		{
			if (ch2 == '=')
			{
				m_vtok = vtokLE;
				m_pchInput++;
			}
			else if (ch2 == '>')
			{
				m_vtok = vtokNE;
				m_pchInput++;
			}
			else if (ch2 == '<')
			{
				m_vtok = vtokLeft;
				m_iscMode = (iscEnum)(m_iscMode | iscStart);
				m_pchInput++;
			}
			else
				m_vtok = vtokLT;
		}
		else if (ch1 == '>')
		{
			if (ch2 == '=')
			{
				m_vtok = vtokGE;
				m_pchInput++;
			}
			else if (ch2 == '>')
			{
				m_vtok = vtokRight;
				m_iscMode = (iscEnum)(m_iscMode | iscEnd);
				m_pchInput++;
			}
			else if (ch2 == '<')
			{
				m_vtok = vtokMid;
				m_iscMode = (iscEnum)(m_iscMode | iscWithin);
				m_pchInput++;
			}
			else
				m_vtok = vtokGT;
		}
		else
			m_vtok = vtokError;

		return m_vtok;
	}
	return (m_vtok = vtokValue);
}



ivcpEnum CMsiValConditionParser::Evaluate(vtokEnum vtokPrecedence)
{
	ivcpEnum ivcStat = ivcpValid;
	if (Lex() == vtokEos || m_vtok == vtokRightPar)
	{
		UnLex();  // put back ')' in case of "()"
		return ivcpNone;
	}
	if (m_vtok == vtokNot) // only unary op valid here
	{
		switch(Evaluate(m_vtok))
		{
		case ivcpValid:  ivcStat = ivcpValid; break;
		default:       return ivcpInvalid;
		};
	}
	else if (m_vtok == vtokLeftPar)
	{
		ivcStat = Evaluate(vtokRightPar);
		if (Lex() != vtokRightPar) // parse off right parenthesis
			return ivcpInvalid;
		if (ivcStat == ivcpInvalid || ivcStat == ivcpNone)
			return ivcStat;
	}
	else
	{
		if (m_vtok != vtokValue)
			return ivcpInvalid;
		
		if (Lex() >= vtokValue)  // get next operator (or end)
			return ivcpInvalid;

		if (m_vtok <= vtokNot)  // logical op or end
		{
			UnLex();   // vtokNot is not allowed, caught below
			if (m_istrToken.TextSize() == 0
			&& (m_iToken == iMsiNullInteger || m_iToken == 0))
				ivcStat = ivcpValid;
		}
		else // comparison op
		{
			MsiString istrLeft = m_istrToken;
			int iLeft = m_iToken;
			vtokEnum vtok = m_vtok;
			iscEnum isc = m_iscMode;
			if (Lex() != vtokValue)  // get right operand
				return ivcpInvalid;
		}
	}
	for(;;)
	{
		vtokEnum vtok = Lex();
		if (vtok >= vtokNot)  // disallow NOT without op, comparison of terms
			return ivcpInvalid;

		if (vtok <= vtokPrecedence)  // stop at logical ops of <= precedence
		{
			UnLex();         // put back for next caller
			return ivcStat;  // return what we have so far
		}
		ivcpEnum ivcRight = Evaluate(vtok);
		if (ivcRight == ivcpNone || ivcRight == ivcpInvalid)
			return ivcpInvalid;
	}
}


//_______________________________________________________________________________________________________________________
//
// Validator functions
//_______________________________________________________________________________________________________________________

Bool CheckIdentifier(const ICHAR* szIdentifier)
/*-------------------------------------------------------------------------------------------
CheckIdentifer -- Evaluates the data in a column whose category in the _Validation
table is listed as Identifier.  A valid identifier can contain letters, digits, underbars,
or periods, but must begin with a letter or underbar.

  Returns:
	Bool fTrue (valid), fFalse (invalid)
--------------------------------------------------------------------------------------------*/
{
	if (szIdentifier == 0 || *szIdentifier == 0)
		return fFalse; // invalid (no string)

	if ((*szIdentifier >= 'A' && *szIdentifier <= 'Z') ||
		(*szIdentifier >= 'a' && *szIdentifier <= 'z') ||
		(*szIdentifier == '_'))
	{
		while (*szIdentifier != 0)
		{
			if ((*szIdentifier >= 'A' && *szIdentifier <= 'Z') ||
				(*szIdentifier >= 'a' && *szIdentifier<= 'z') ||
				(*szIdentifier >= '0' && *szIdentifier <= '9') ||
				(*szIdentifier == '_' || *szIdentifier == '.'))
				szIdentifier++; // okay to not use ICharNext, we know it's ASCII
			else
				return fFalse; // invalid (non-permitted char)
		}
		return fTrue;
	}
	return fFalse; // invalid (doesn't begin with a letter or underbar)
}



Bool CheckCase(MsiString& rstrData, Bool fUpperCase)
/*---------------------------------------------------------------------------------------------
CheckCase -- Evaluates data as to being of proper case.  The data must either be all upper-case
or all lower-case depending on the fUpperCase boolean.

  Returns:
	Bool fTrue (valid), fFalse (invalid)
------------------------------------------------------------------------------------------------*/
{
	MsiString strComparison = rstrData;
	if (fUpperCase)
		strComparison.UpperCase();
	else
		strComparison.LowerCase();
	return (IStrComp(rstrData, strComparison) == 0 ? fTrue : fFalse);
}

// Validation array of acceptable filename/folder characters
// This array is for the first 128 ASCII character codes.
// The first 32 are control character codes and are disallowed
// We set the bit if character is allowed
// First int is 32 control characters
// Second int is sp to ?
// Third int is @ to _
// Fourth int is ` to ASCII code 127 (Ctrl + BKSP)
const int rgiSFNValidChar[4] =
{
	0x00000000, // disallows control characters -- ^X, ^Z, etc.
	0x03ff63fa, // disallows sp " * + , / : ; < = > ?
	0xc7ffffff, // disallows [ \ ]
	0x6fffffff  // disallows | and ASCII code 127 (Ctrl + BKSP)
};

const int rgiLFNValidChar[4] =
{
	0x00000000, // disallows characters -- ^X, ^Z, etc.
	0x2bff7bfb, // disallows " * / : < > ?
	0xefffffff, // disallows backslash
	0x6fffffff  // disallows | and ASCII code 127 (Ctrl + BKSP)
};

const int cszReservedWords = 3;
// No DBCS characters can be in these reserved words in order for CheckFilename to work
const ICHAR *const pszReservedWords[cszReservedWords] = {TEXT("AUX"), TEXT("CON"), TEXT("PRN")};

// These are the Max and Min respectively of characters in the reserved words list above
// by checking against these, we can exit CheckFileName a bit faster.
const int cchMaxReservedWords = 3;
const int cchMinReservedWords = 3;

const int cchMaxShortFileName = 12;
const int cchMaxLongFileName = 255;
const int cchMaxSFNPreDotLength = 8;
const int cchMaxSFNPostDotLength = 3;
const int iValidChar = 127; // any char with ASCII code > 127 is valid in a filename

Bool ParseFilename(MsiString& strFile, Bool fWildCard)
/*-----------------------------------------------------------------------------------
ParseFilename -- parses a filename into particular short and long filenames dependent
 on whether SFN|LFN syntax specified.  If no '|', then assumes SFN only
 -------------------------------------------------------------------------------------*/
{
	ifvsEnum ifvs;
	if (strFile.Compare(iscWithin, TEXT("|")))
	{
		// SFN|LFN
		MsiString strFilename = strFile.Extract(iseUpto, '|');
		ifvs = CheckWildFilename(strFilename, fFalse /*fLFN*/, fWildCard);
		if (ifvsValid == ifvs)
		{
			strFilename = strFile.Extract(iseLast, strFile.CharacterCount()-strFilename.CharacterCount()-1);
			ifvs = CheckWildFilename(strFilename, fTrue /*fLFN*/, fWildCard);
		}
	}
	else  // no LFN specified
		ifvs = CheckWildFilename(strFile, fFalse /*fLFN*/, fWildCard);
	if (ifvsValid == ifvs)
		return fTrue