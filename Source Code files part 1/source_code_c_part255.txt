RD mask = ~validBits;

    if (!(flags & mask))
        return S_OK;

    return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
}

IMAGE_DATA_DIRECTORY *PEFile::GetSecurityHeader()
{
    if (m_pNT == NULL)
        return NULL;
    else
        return &m_pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
}

HRESULT PEFile::SetFileName(LPCWSTR codeBase)
{
    if(codeBase == NULL)
        return E_INVALIDARG;

    DWORD lgth = (DWORD) wcslen(codeBase) + 1;
    if(lgth > MAX_PATH)
        return HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);

    wcscpy(m_wszSourceFile, codeBase);
    return S_OK;
}


LPCWSTR PEFile::GetFileName()
{
    return m_wszSourceFile;
}

LPCWSTR PEFile::GetLeafFileName()
{
    WCHAR *pStart = m_wszSourceFile;
    WCHAR *pEnd = pStart + wcslen(m_wszSourceFile);
    WCHAR *p = pEnd;
    
    while (p > pStart)
    {
        if (*--p == '\\')
        {
            p++;
            break;
        }
    }

    return p;
}

HRESULT PEFile::GetFileNameFromImage()
{
    HRESULT hr = S_OK;

    DWORD dwSourceFile = 0;

    if (m_hCorModule)
    {
        CorMap::GetFileName(m_hCorModule, m_wszSourceFile, MAX_PATH, &dwSourceFile);
    }
    else if (m_hModule)
    {
        dwSourceFile = WszGetModuleFileName(m_hModule, m_wszSourceFile, MAX_PATH);
        if (dwSourceFile == 0)
        {
            *m_wszSourceFile = 0;
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (SUCCEEDED(hr)) // GetLastError doesn't always do what we'd like
                hr = E_FAIL;
        }

        if (dwSourceFile == MAX_PATH)
        {
            // Since dwSourceFile doesn't include the null terminator, this condition
            // implies that the file name was truncated.  We cannot 
            // currently tolerate this condition.
            // @nice: add logic to handle larger paths
            return HRESULT_FROM_WIN32(ERROR_CANNOT_MAKE);
        }
        else
        dwSourceFile++; // add in the null terminator
    }

    if (SystemDomain::System()->IsSystemFile(m_wszSourceFile))
        m_flags |= PEFILE_SYSTEM;

    _ASSERTE(dwSourceFile <= MAX_PATH);

    return hr;
}

HRESULT PEFile::GetFileName(LPSTR psBuffer, DWORD dwBuffer, DWORD* pLength)
{
    if (m_hCorModule)
    {
        CorMap::GetFileName(m_hCorModule, psBuffer, dwBuffer, pLength);
    }
    else if (m_hModule)
    {
        DWORD length = GetModuleFileNameA(m_hModule, psBuffer, dwBuffer);
        if (length == 0)
        {
            HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
            if (SUCCEEDED(hr)) // GetLastError doesn't always do what we'd like
                hr = E_FAIL;
        }
        *pLength = length;
    }
    else
    {
        *pLength = 0;
    }

    return S_OK;
}

/*** For reference, from ntimage.h
    typedef struct _IMAGE_TLS_DIRECTORY {
        ULONG   StartAddressOfRawData;
        ULONG   EndAddressOfRawData;
        PULONG  AddressOfIndex;
        PIMAGE_TLS_CALLBACK *AddressOfCallBacks;
        ULONG   SizeOfZeroFill;
        ULONG   Characteristics;
    } IMAGE_TLS_DIRECTORY;
***/

IMAGE_TLS_DIRECTORY* PEFile::GetTLSDirectory() 
{
    if (m_pNT == 0) 
        return NULL;

    IMAGE_DATA_DIRECTORY *entry 
      = &m_pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
    
    if (entry->VirtualAddress == 0 || entry->Size == 0) 
        return NULL;

    return (IMAGE_TLS_DIRECTORY*) (m_base + entry->VirtualAddress);
}

BOOL PEFile::IsTLSAddress(void* address)  
{
    IMAGE_TLS_DIRECTORY* tlsDir = GetTLSDirectory();
    if (tlsDir == 0)
        return FALSE;

    size_t asInt = (size_t) address;

    return (tlsDir->StartAddressOfRawData <= asInt 
            && asInt < tlsDir->EndAddressOfRawData);
}

LPCWSTR PEFile::GetLoadersFileName()
{
    return m_pLoadersFileName;
}

HRESULT PEFile::FindCodeBase(WCHAR* pCodeBase, 
                             DWORD* pdwCodeBase)
{
    DWORD dwPrefix = 0;
    LPWSTR pFileName = (LPWSTR) GetFileName();
    CQuickWSTR buffer;
    
    // Cope with the case where we've been loaded from a byte array and
    // don't have a code base of our own. In this case we should have cached
    // the file name of the assembly that loaded us.
    if (pFileName[0] == L'\0') {
        pFileName = (LPWSTR) GetLoadersFileName();
        
        if (!pFileName) {
            HRESULT hr;
            if (FAILED(hr = buffer.ReSize(MAX_PATH)))
                return hr;

            pFileName = buffer.Ptr();

            DWORD dwFileName = WszGetModuleFileName(NULL, pFileName, MAX_PATH);
            if (dwFileName == MAX_PATH)
            {
                // Since dwSourceFile doesn't include the null terminator, this condition
                // implies that the file name was truncated.  We cannot 
                // currently tolerate this condition. (We can't reallocate the buffer
                // since we don't know how big to make it.)
                return HRESULT_FROM_WIN32(ERROR_CANNOT_MAKE);
            }
            else if ( dwFileName == 0)  // zero means failure, so can'r continue in this case
                return E_UNEXPECTED;

            LOG((LF_CLASSLOADER, LL_INFO10, "Found codebase from OSHandle: \"%ws\".\n", pFileName));
        }
    }
    
    return FindCodeBase(pFileName, pCodeBase, pdwCodeBase);
}

HRESULT PEFile::FindCodeBase(LPCWSTR pFileName, 
                             WCHAR* pCodeBase, 
                             DWORD* pdwCodeBase)
{
    if(pFileName == NULL || *pFileName == 0) return E_FAIL;

    BOOL fCountOnly;
    if (*pdwCodeBase == 0)
        fCountOnly = TRUE;
    else
        fCountOnly = FALSE;

    *pdwCodeBase = (DWORD) wcslen(pFileName) + 1;

    BOOL fHavePath = TRUE;
    if (*pFileName == L'\\')
        (*pdwCodeBase) += 7; // file://
    else if (pFileName[1] == L':')
        (*pdwCodeBase) += 8; // file:///
    else // it's already a codebase
        fHavePath = FALSE;

    if (fCountOnly)
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);           

    if (fHavePath) {
        wcscpy(pCodeBase, L"file://");
        pCodeBase += 7;

        if (*pFileName != L'\\') {
            *pCodeBase = L'/';
            pCodeBase++;
        }
    }

    wcscpy(pCodeBase, pFileName);

    if (fHavePath) {
        // Don't need to convert first two backslashes to /'s
        if (*pCodeBase == L'\\')
            pCodeBase += 2;
        
        while(1) {
            pCodeBase = wcschr(pCodeBase, L'\\');
            if (pCodeBase)
                *pCodeBase = L'/';
            else
                break;
        }
    }

    LOG((LF_CLASSLOADER, LL_INFO10, "Created codebase: \"%ws\".\n", pCodeBase));
    return S_OK;
}



// We need to verify a module to see if it verifiable. 
// Returns:
//    1) Module has been previously loaded and verified
//         1a) loaded via LoadLibrary
//         1b) loaded using CorMap
//    2) The module is veriable
//    3) The module is not-verifable but allowed
//    4) The module is not-verifable and not allowed
HRESULT PEFile::VerifyModule(HCORMODULE hModule,
                             Assembly* pParent,      
                             IAssembly *pFusionAssembly,
                             LPCWSTR pCodeBase,
                             OBJECTREF* pExtraEvidence,
                             LPCWSTR moduleName,
                             HCORMODULE *phModule,
                             PEFile** ppFile,
                             BOOL* pfPreBindAllowed)
{
    HRESULT hr = S_OK;
    PEFile* pImage = NULL;

    DWORD dwFileLen;
    dwFileLen = (DWORD)CorMap::GetRawLength(hModule);
    if(dwFileLen == -1)
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        
    HMODULE pHandle;
    IfFailRet(CorMap::BaseAddress(hModule, &pHandle));
    PEVerifier pe((PBYTE)pHandle, dwFileLen);
        
    BOOL fVerifiable = pe.Check();
    if (fVerifiable) CorMap::SetVerifiable(hModule);

    if (!fVerifiable || pfPreBindAllowed != NULL) {
        // It is not verifiable so we need to map it with out calling any entry
        // points and then ask the security system whether we are allowed to 
        // load this Image.
            
        // Release the metadata pointer if it exists. This has been passed in to
        // maintain the life time of the image if it first loaded by fusion. We
        // now have our own ref count with hModule.

        LOG((LF_CLASSLOADER, LL_INFO10, "Module is not verifiable: \"%ws\".\n", moduleName));
            
        // Remap the image, if it has been loaded by fusion for meta-data
        // then the image will be in data format.

        // Load as special unmapped version of a PEFile
        hr = Create((HCORMODULE)hModule, &pImage);
        hModule = NULL; // So we won't release it if error
        IfFailGo(hr);

        if (Security::IsSecurityOn()) {
            if(pParent) {
                if(!fVerifiable) {
                    if(!Security::CanSkipVerification(pParent)) {
                        LOG((LF_CLASSLOADER, LL_INFO10, "Module fails to load because assembly module did not get granted permission: \"%ws\".\n", moduleName));
                        IfFailGo(SECURITY_E_UNVERIFIABLE);
                    }
                }
            }
            else {
                PEFile* pSecurityImage = NULL;

                CorMap::AddRefHandle(pImage->GetCORModule());
                hr = Create(pImage->GetCORModule(), &pSecurityImage);
                IfFailGo(hr);
            
                if(pCodeBase)
                    pSecurityImage->SetFileName(pCodeBase);

                if(!Security::CanLoadUnverifiableAssembly(pSecurityImage, pExtraEvidence, FALSE, pfPreBindAllowed) &&
                   !fVerifiable) {
                    LOG((LF_CLASSLOADER, LL_INFO10, "Module fails to load because assembly did not get granted permission: \"%ws\".\n", moduleName));
                    delete pSecurityImage;
                    IfFailGo(SECURITY_E_UNVERIFIABLE);
                }
                delete pSecurityImage;
            }
        }
        else if(pfPreBindAllowed) 
            *pfPreBindAllowed = TRUE;

        if(ppFile != NULL) {
            // Release the fusion handle
            if(pFusionAssembly) 
                IfFailGo(ReleaseFusionMetadataImport(pFusionAssembly));
            
            // Remap the image using the OS loader
            HCORMODULE pResult;
            IfFailGo(CorMap::MemoryMapImage(pImage->m_hCorModule, &pResult));
            if(pImage->m_hCorModule != pResult) {
                pImage->m_hCorModule = pResult;
            }
            
            // The image has changed so we need to set up the PEFile
            // with the correct addresses.
            IfFailGo(Setup(pImage, pImage->m_hCorModule, FALSE));
            *ppFile = pImage;

            // It is not verifable but it is allowed to be loaded.
        }
        else 
            delete pImage;

        return S_OK;
    }            
    else
        return CreateImageFile(hModule, pFusionAssembly, ppFile);
    

 ErrExit:
#ifdef _DEBUG
    LOG((LF_CLASSLOADER, LL_INFO10, "Failed to load module: \"%ws\". Error %x\n", moduleName, hr));
#endif //_DEBUG
    
    // On error try and release the handle;
    if(pImage)
        delete pImage;
    else if(hModule)
        CorMap::ReleaseHandle(hModule); // Ignore error

    return hr;
}

HRESULT PEFile::CreateImageFile(HCORMODULE hModule, IAssembly* pFusionAssembly, PEFile **ppFile)
{
    HRESULT hr = S_OK;

    // Release the fusion handle
    if(pFusionAssembly) 
        IfFailRet(ReleaseFusionMetadataImport(pFusionAssembly));

    // Remap the image, if it has been loaded by fusion for meta-data
    // then the image will be in data format. If it fails then
    // close hmodule and return success. The module can be loaded
    // it just cannot not have the image remapped
    HCORMODULE hResult;
    IfFailRet(CorMap::MemoryMapImage(hModule, &hResult));
    if(hResult != hModule)
        hModule = hResult;
    
    hr = Create(hModule, ppFile, FALSE);
    return hr;
}


HRESULT PEFile::ReleaseFusionMetadataImport(IAssembly* pAsm)
{
    HRESULT hr = S_OK;
    IServiceProvider *pSP;
    IAssemblyManifestImport *pAsmImport;
    IMetaDataAssemblyImportControl *pMDAIControl;

    hr = pAsm->QueryInterface(__uuidof(IServiceProvider), (void **)&pSP);
    if (hr == S_OK && pSP) {
        hr = pSP->QueryService(__uuidof(IAssemblyManifestImport), 
                               __uuidof(IAssemblyManifestImport), (void**)&pAsmImport);
        if (hr == S_OK && pAsmImport) {
            hr = pAsmImport->QueryInterface(__uuidof(IMetaDataAssemblyImportControl), 
                                            (void **)&pMDAIControl);
        
            if (hr == S_OK && pMDAIControl) {
                IUnknown* pImport = NULL;
                // Temporary solution until fusion makes this generic
                CorMap::EnterSpinLock();
                // This may return an error if we have already
                // released the import.
                pMDAIControl->ReleaseMetaDataAssemblyImport((IUnknown**)&pImport);
                CorMap::LeaveSpinLock();
                if(pImport != NULL)
                    pImport->Release();
                pMDAIControl->Release();
            }
            pAsmImport->Release();
        }
        pSP->Release();
    }
    return hr;
}


HRESULT PEFile::GetStrongNameSignature(BYTE **ppbSNSig, DWORD *pcbSNSig)
{
    HRESULT hr = E_FAIL;

    IMAGE_COR20_HEADER *pCOR = GetCORHeader();

    if (pCOR)
    {
        if (pCOR->StrongNameSignature.VirtualAddress != 0 &&
            pCOR->StrongNameSignature.Size != 0)
        {
            if (pCOR->Flags & COMIMAGE_FLAGS_STRONGNAMESIGNED)
            {
                *pcbSNSig = pCOR->StrongNameSignature.Size;
                *ppbSNSig = RVAToPointer(pCOR->StrongNameSignature.VirtualAddress);

                hr = S_OK;
            }

            // In the case that it's delay signed, we return this hresult as a special flag
            // to whoever is asking for the signature so that they can do some special case
            // work (like using the MVID as the hash and letting the loader determine if
            // delay signed assemblies are allowed).
            else
                hr = CORSEC_E_INVALID_STRONGNAME;
        }

    }
    return (hr);
}

HRESULT PEFile::GetStrongNameSignature(BYTE *pbSNSig, DWORD *pcbSNSig)
{
    HRESULT hr = S_OK;

    BYTE *pbSig;
    DWORD cbSig;
    IfFailGo(GetStrongNameSignature(&pbSig, &cbSig));

    if (pcbSNSig)
    {
        if (pbSNSig)
        {
            if (cbSig <= *pcbSNSig)
                memcpy(pbSNSig, pbSig, cbSig);
            else
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }

        *pcbSNSig = cbSig;
    }

ErrExit:
    return hr;
}

HRESULT /* static */ PEFile::GetStrongNameHash(LPWSTR szwFile, BYTE *pbHash, DWORD *pcbHash)
{
    HRESULT hr = S_OK;

    if (pcbHash)
    {
        // First get the size of a hash
        _ASSERTE(A_SHA_DIGEST_LEN <= MAX_SNHASH_SIZE);
        DWORD dwSNHashSize = A_SHA_DIGEST_LEN;

        if (szwFile && pbHash)
        {
            if (dwSNHashSize <= *pcbHash)
            {
                HANDLE hFile = WszCreateFile((LPCWSTR) szwFile,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);

                if (hFile != INVALID_HANDLE_VALUE)
                {
                    DWORD cbFile = GetFileSize(hFile, NULL);
                    HANDLE hFileMap = WszCreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

                    if (hFileMap != NULL)
                    {
                        BYTE *pbFile = (BYTE *) MapViewOfFileEx(hFileMap, FILE_MAP_READ, 0, 0, 0, NULL);

                        if (pbFile != NULL)
                        {
                            A_SHA_CTX ctx;

                            A_SHAInit(&ctx);
                            A_SHAUpdate(&ctx, pbFile, cbFile);
                            A_SHAFinal(&ctx, pbHash);

                            VERIFY(UnmapViewOfFile(pbFile));
                        }
                        else
                            hr = HRESULT_FROM_WIN32(GetLastError());

                        CloseHandle(hFileMap);
                    }
                    else
                        hr = HRESULT_FROM_WIN32(GetLastError());

                    CloseHandle(hFile);
                }
                else
                    hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
        *pcbHash = dwSNHashSize;
    }

    LOG((LF_CLASSLOADER, LL_INFO10, "PEFile::GetStrongNameHash : Strong name hash calculation for %ws %s\n", szwFile, SUCCEEDED(hr) ? "succeeded" : "failed"));
    return hr;
}

HRESULT PEFile::GetStrongNameHash(BYTE *pbHash, DWORD *pcbHash)
{
    // Shortcut for a cached file hash
    if (m_cbSNHash > 0)
    {
        if (pcbHash)
        {
            if (pbHash && m_cbSNHash <= *pcbHash)
            {
                memcpy(pbHash, &m_rgbSNHash[0], m_cbSNHash);
            }
            *pcbHash = m_cbSNHash;
        }
        return S_OK;
    }

    // Pass on to the static function
    HRESULT hr = GetStrongNameHash((LPWSTR) GetFileName(), pbHash, pcbHash);

    // Cache the file hash
    if (pcbHash && pbHash && SUCCEEDED(hr))
    {
        if (*pcbHash <= PEFILE_SNHASH_BUF_SIZE)
        {
            memcpy(&m_rgbSNHash[0], pbHash, *pcbHash);
            m_cbSNHash = *pcbHash;
        }
    }

    return hr;
}

HRESULT PEFile::GetSNSigOrHash(BYTE *pbHash, DWORD *pcbHash)
{
    HRESULT hr;

    if (FAILED(hr = GetStrongNameSignature(pbHash, pcbHash)) &&
        hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
    {
        if (hr == CORSEC_E_INVALID_STRONGNAME)
        {
            if (pcbHash)
            {
                if (pbHash)
                {
                    // @TODO:HACK: This is a hack because fusion is expecting at least 20 bytes of data.
                    if (max(sizeof(GUID), 20) <= *pcbHash)
                    {
                        IMDInternalImport *pIMD = GetMDImport(&hr);
                        if (SUCCEEDED(hr) && pIMD != NULL)
                        {
                            memset(pbHash, 0, *pcbHash);
                            pIMD->GetScopeProps(NULL, (GUID *) pbHash);
                        }
                        else
                            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                    }
                }
                *pcbHash = max(sizeof(GUID), 20);
            }
        }
        else
            hr = GetStrongNameHash(pbHash, pcbHash);
    }

    return hr;
}

//================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\permset.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Used for loading permissions into the runtime
//*****************************************************************************
#include "common.h"

#include <wintrust.h>
#include "object.h"
#include "vars.hpp"
#include "excep.h"
#include "permset.h"
#include "utilcode.h"
#include "CorPermP.h"
#include "COMString.h"
#include "gcscan.h"
#include "SecurityDB.h"
#include "field.h"
#include "security.h"
#include "CorError.h"
#include "PostError.h"
#include "ComCallWrapper.h"

// this file handles string conversion errors for itself
#undef  MAKE_TRANSLATIONFAILED

HRESULT STDMETHODCALLTYPE
ConvertFromDB(const PBYTE pbInBytes,
              DWORD cbInBytes,
              PBYTE* ppbEncoding,
              DWORD* pcbEncoding);

CQuickArray<PsetCacheEntry> SecurityHelper::s_rCachedPsets;
EEPsetHashTable SecurityHelper::s_sCachedPsetsHash;
SimpleRWLock *SecurityHelper::s_prCachedPsetsLock = NULL;
MethodDesc *SecurityHelper::s_pMarshalObjectMD = NULL;
MethodDesc *SecurityHelper::s_pMarshalObjectsMD = NULL;
MethodDesc *SecurityHelper::s_pUnmarshalObjectMD = NULL;
MethodDesc *SecurityHelper::s_pUnmarshalObjectsMD = NULL;

VOID SecurityHelper::Init()
{
    s_prCachedPsetsLock = new SimpleRWLock(COOPERATIVE_OR_PREEMPTIVE, LOCK_TYPE_DEFAULT);
    LockOwner lock = {NULL, TrustMeIAmSafe};
    s_sCachedPsetsHash.Init(19,&lock);
}

VOID SecurityHelper::Shutdown()
{
    s_sCachedPsetsHash.ClearHashTable();
    for (size_t i = 0; i < s_rCachedPsets.Size(); i++)
        delete [] s_rCachedPsets[i].m_pbPset;
    s_rCachedPsets.~CQuickArray<PsetCacheEntry>();
    delete s_prCachedPsetsLock;
}

HRESULT SecurityHelper::MapToHR(OBJECTREF refException)
{
    HRESULT hr = E_FAIL;
    COMPLUS_TRY {
        // @Managed: Exception.HResult
        FieldDesc *pFD = g_Mscorlib.GetField(FIELD__EXCEPTION__HRESULT);
            hr = pFD->GetValue32(refException);
        }
    COMPLUS_CATCH {
        _ASSERTE(!"Caught an exception while trying to get another exception's HResult!");
    } COMPLUS_END_CATCH

    return hr;
}


OBJECTREF SecurityHelper::CreatePermissionSet(BOOL fTrusted)
{
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF pResult = NULL;
    
    OBJECTREF pPermSet = NULL;
    GCPROTECT_BEGIN(pPermSet);

    MethodTable *pMT = g_Mscorlib.GetClass(CLASS__PERMISSION_SET);
    MethodDesc *pCtor = g_Mscorlib.GetMethod(METHOD__PERMISSION_SET__CTOR);

    pPermSet = (OBJECTREF) AllocateObject(pMT);

    INT64 fStatus = (fTrusted) ? 1 : 0;

    INT64 arg[2] = { 
        ObjToInt64(pPermSet),
        fStatus
    };
    pCtor->Call(arg, METHOD__PERMISSION_SET__CTOR);
    
    pResult = pPermSet;

    GCPROTECT_END();

    return pResult;
}

/*
 * Creates a permission set from the encoded data.
 */
void SecurityHelper::LoadPermissionSet(IN PBYTE             pbRawPermissions,
                                       IN DWORD             cbRawPermissions,
                                       OUT OBJECTREF       *pPermissionSet,
                                       OUT BOOL            *pFullyTrusted,
                                       OUT DWORD           *pdwSetIndex,
                                       IN BOOL              fNoCache,
                                       OUT SpecialPermissionSetFlag *pSpecialFlags,
                                       IN BOOL              fCreate)
{
    static WCHAR s_skipVerificationXmlBegin[] =
        L"<PermissionSet class=\"System.Security.PermissionSet\"\r\n               version=\"1\">\r\n   <IPermission class=\"System.Security.Permissions.SecurityPermission, mscorlib, Version=1.0.";

    static WCHAR s_skipVerificationXmlEnd[] =
        L", Culture=neutral, PublicKeyToken=b77a5c561934e089\"\r\n                version=\"1\"\r\n                Flags=\"SkipVerification\"/>\r\n</PermissionSet>\r\n";

    HRESULT hr = S_OK;
    BOOL isFullyTrusted = FALSE;
    DWORD dwSetIndex = ~0;
    SpecialPermissionSetFlag dummySpecialFlags;

    THROWSCOMPLUSEXCEPTION();
    
    if(pPermissionSet == NULL) return;
    
    *pPermissionSet = NULL;

    // Create an empty permission set if that's what's needed.
    if ((pbRawPermissions == NULL) || (cbRawPermissions == 0)) {
        if (!fCreate) {
            if (pSpecialFlags != NULL)
                *pSpecialFlags = EmptySet;
        } else {
            *pPermissionSet = CreatePermissionSet(FALSE);
            if (pFullyTrusted)
                *pFullyTrusted = FALSE;
        }
        return;
    }

    struct _gc {
        OBJECTREF pset;
        OBJECTREF encoding;
    } gc;
    memset(&gc, 0, sizeof(gc));

    GCPROTECT_BEGIN(gc);

    // See if we've already decoded a similar blob.
    if (!fNoCache && LookupPermissionSet(pbRawPermissions, cbRawPermissions, &dwSetIndex)) {

        // Yup, grab it.
        gc.pset = GetPermissionSet(dwSetIndex, pSpecialFlags != NULL ? pSpecialFlags : &dummySpecialFlags);

    } else {
    
        if (!fCreate) {
            if (pSpecialFlags != NULL) {
                *pSpecialFlags = Regular;

                // We do some wackiness here to compare against a binary version of the skip verification
                // permission set (which is easy) and the xml version (which is somewhat harder since
                // we have to skip the section that explicitly mentions the build and revision numbers.

                if ((cbRawPermissions >= sizeof( s_skipVerificationXmlBegin ) + sizeof( s_skipVerificationXmlEnd ) - 2 * sizeof( WCHAR ) &&
                     memcmp( pbRawPermissions, s_skipVerificationXmlBegin, sizeof( s_skipVerificationXmlBegin ) - sizeof( WCHAR ) ) == 0 &&
                     memcmp( pbRawPermissions + cbRawPermissions - sizeof( s_skipVerificationXmlEnd ) + sizeof( WCHAR ), s_skipVerificationXmlEnd, sizeof( s_skipVerificationXmlEnd ) - sizeof( WCHAR ) ) == 0))
                    *pSpecialFlags = SkipVerification;
            }
        } else {
            MethodDesc *pMD;
    
            // Create a new (empty) permission set.
            gc.pset = CreatePermissionSet(FALSE);
    
            // Buffer in managed space.
            CopyEncodingToByteArray(pbRawPermissions, cbRawPermissions, &gc.encoding);

            INT64 args[] = { 
                ObjToInt64(gc.pset),
                    (INT64)(pSpecialFlags != NULL ? pSpecialFlags : &dummySpecialFlags),
                    ObjToInt64(gc.encoding),
            };

            // Deserialize into a managed object.
            // Check to see if it is in XML (we skip the first two characters since they,
            // mark it as unicode).

            BOOL success = FALSE;

            COMPLUS_TRY
            {
                pMD = g_Mscorlib.GetMethod(METHOD__PERMISSION_SET__DECODE_XML);
                success = (BOOL) pMD->Call(args, METHOD__PERMISSION_SET__DECODE_XML);
            }
            COMPLUS_CATCH
            {
            }
            COMPLUS_END_CATCH

            if (!success)
                COMPlusThrow(kSecurityException, IDS_ENCODEDPERMSET_DECODEFAILURE);


            // Cache the decoded set.
            if (!fNoCache)
                InsertPermissionSet(pbRawPermissions, cbRawPermissions, gc.pset, pSpecialFlags != NULL ? pSpecialFlags : &dummySpecialFlags, &dwSetIndex);
        }
    }

    if (pFullyTrusted)
    {
        MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__PERMISSION_SET__IS_UNRESTRICTED);

        INT64 arg[1] = {
            ObjToInt64(gc.pset)
        };

        *pFullyTrusted = (BOOL) pMD->Call(arg, METHOD__PERMISSION_SET__IS_UNRESTRICTED);
    }

    // Set the result 
    *pPermissionSet = gc.pset;
    if (pdwSetIndex)
        *pdwSetIndex = dwSetIndex;

    GCPROTECT_END();
}

// Retrieves a previously loaded permission set by index (this will work
// even if the permission set was loaded in a different appdomain).
OBJECTREF SecurityHelper::GetPermissionSet(DWORD dwIndex, SpecialPermissionSetFlag* pSpecialFlags)
{
    // Actual permission set objects are stored in handle tables held on each
    // unmanaged AppDomain object. These tables are lazily populated as accesses
    // are made.
    AppDomain                   *pDomain        = GetAppDomain();
    CQuickArray<OBJECTHANDLE>   &sTable         = pDomain->m_pSecContext->m_rCachedPsets;
    size_t                      *pnTableSize    = &pDomain->m_pSecContext->m_nCachedPsetsSize;
    SimpleRWLock                *prGlobalLock   = s_prCachedPsetsLock;
    OBJECTHANDLE                nHandle;
    OBJECTREF                   orRet = NULL;
    PsetCacheEntry              *pPCE;
    PBYTE                       pbPset;
    DWORD                       cbPset;
    
    //
    // Check if we may need to expand the array.
    //
    if (dwIndex >= *pnTableSize) {

        prGlobalLock->EnterWrite();

        //
        // Check if another thread has already resized the array.
        // If nobody has, then we will resize it here
        //
        if( dwIndex >= sTable.Size() ) {

            size_t nOldSize = sTable.Size();

            if (FAILED(sTable.ReSize(dwIndex + 1))) {
                prGlobalLock->LeaveWrite();
                return NULL;
            }

            for (size_t i = nOldSize; i < sTable.Size(); i++) {
                if ((sTable[i] = pDomain->CreateHandle(NULL)) == NULL) {
                    sTable.ReSize(i);
                    *pnTableSize = i;
                    prGlobalLock->LeaveWrite();
                    return NULL;
                }
            }

            *pnTableSize = sTable.Size();
        }

        nHandle = sTable[dwIndex];

        pPCE = &s_rCachedPsets[dwIndex];
        pbPset = pPCE->m_pbPset;
        cbPset = pPCE->m_cbPset;

        if (pSpecialFlags != NULL) {
            *pSpecialFlags = pPCE->m_SpecialFlags;
        }

        prGlobalLock->LeaveWrite();
        
    }
    //
    // The array is large enough; get the handle at dwIndex
    //
    else {

        prGlobalLock->EnterRead();
        nHandle = sTable[dwIndex];

        pPCE = &s_rCachedPsets[dwIndex];
        pbPset = pPCE->m_pbPset;
        cbPset = pPCE->m_cbPset;

        if (pSpecialFlags != NULL) {
            *pSpecialFlags = pPCE->m_SpecialFlags;
        }

        prGlobalLock->LeaveRead();
    }

    if((orRet = ObjectFromHandle( nHandle )) == NULL ) {
        // No object allocated yet (we've decoded it at least once, but in a
        // different appdomain). Decode in this appdomain and cache the result.
        // We can't hold the lock over this operation (since it will call into
        // managed code).

        SecurityHelper::LoadPermissionSet(pbPset,
                                          cbPset,
                                          &orRet,
                                          NULL,
                                          NULL,
                                          TRUE);
        if (orRet == NULL)
            return NULL;

        StoreFirstObjectInHandle( nHandle, orRet );
    }

    return orRet;
}
    

// Locate the index of a permission set in the cache (returns false if the
// permission set has not yet been seen and decoded).
BOOL SecurityHelper::LookupPermissionSet(IN PBYTE       pbPset,
                                         IN DWORD       cbPset,
                                         OUT DWORD     *pdwSetIndex)
{
    PsetCacheEntry sKey(pbPset, cbPset);
    DWORD           dwIndex;

    // WARNING: note that we are doing a GetValue here without
    // holding the lock.  This means that we can get false failures
    // of this function.  If you call this function, you must handle
    // the false failure case appropriately (or you have to fix this
    // function to never false fail).

    if (s_sCachedPsetsHash.GetValue(&sKey, (HashDatum*)&dwIndex)) {
        if (pdwSetIndex)
            *pdwSetIndex = dwIndex;
        return TRUE;
    } else
        return FALSE;
}

// Insert a decoded permission set into the cache. Duplicates are discarded.
BOOL SecurityHelper::InsertPermissionSet(IN PBYTE       pbPset,
                                         IN DWORD       cbPset,
                                         IN OBJECTREF   orPset,
                                         OUT SpecialPermissionSetFlag *pSpecialFlags, //thomash: this looks like an INPUT, not OUT
                                         OUT DWORD     *pdwSetIndex)
{
    SimpleRWLock                *prGlobalLock   = s_prCachedPsetsLock;
    PsetCacheEntry              sKey(pbPset, cbPset);
    size_t                      dwIndex;
    AppDomain                   *pDomain        = GetAppDomain();
    CQuickArray<OBJECTHANDLE>   &sTable         = pDomain->m_pSecContext->m_rCachedPsets;
    size_t                      *pnTableSize    = &pDomain->m_pSecContext->m_nCachedPsetsSize;
    OBJECTHANDLE                nHandle;

    prGlobalLock->EnterWrite();

    // Check for duplicates.
    if (s_sCachedPsetsHash.GetValue(&sKey, (HashDatum*)&dwIndex)) {
        if (pdwSetIndex)
            *pdwSetIndex = (DWORD)dwIndex;
        prGlobalLock->LeaveWrite();
        return TRUE;
    }

    // Buffer permission set blob (it might go away if the metadata scope it
    // came from is closed).
    PBYTE pbPsetCopy = new BYTE[cbPset];
    if (pbPsetCopy == NULL) {
        prGlobalLock->LeaveWrite();
        return FALSE;
    }
    memcpy(pbPsetCopy, pbPset, cbPset);

    // Add another entry to the array of cache entries (this gives us an index).
    dwIndex = s_rCachedPsets.Size();
    if (FAILED(s_rCachedPsets.ReSize(dwIndex + 1))) {
        prGlobalLock->LeaveWrite();
        return FALSE;
    }
    PsetCacheEntry *pPCE = &s_rCachedPsets[dwIndex];

    pPCE->m_pbPset = pbPsetCopy;
    pPCE->m_cbPset = cbPset;
    pPCE->m_dwIndex = (DWORD)dwIndex;
    pPCE->m_SpecialFlags = *pSpecialFlags;

    // Place the new entry into the hash.
    s_sCachedPsetsHash.InsertValue(pPCE, (HashDatum)dwIndex); // thomash: check for errors

    if (pdwSetIndex)
        *pdwSetIndex = (DWORD)dwIndex;

    //
    // Check if we may need to expand the array.
    //
    if(dwIndex >= sTable.Size()) {

        size_t nOldSize = sTable.Size();

        if (FAILED(sTable.ReSize(dwIndex + 1))) {
            prGlobalLock->LeaveWrite();
            return TRUE;
        }

        //
        // Fill the table with null handles
        //
        for (size_t i = nOldSize; i < sTable.Size(); i++) {
            if ((sTable[i] = pDomain->CreateHandle(NULL)) == NULL) {
                sTable.ReSize(i);
                *pnTableSize = i;
                prGlobalLock->LeaveWrite();
                return TRUE;
            }
        }

        *pnTableSize = sTable.Size();
    }

    nHandle = sTable[dwIndex];
    _ASSERTE(ObjectFromHandle(nHandle) == NULL);
    StoreFirstObjectInHandle(nHandle, orPset);
        
    prGlobalLock->LeaveWrite();
        
    return TRUE;
}


void SecurityHelper::CopyEncodingToByteArray(IN PBYTE   pbData,
                                                IN DWORD   cbData,
                                                OUT OBJECTREF* pArray)
{
    THROWSCOMPLUSEXCEPTION();
    U1ARRAYREF pObj;
    _ASSERTE(pArray);

    pObj = (U1ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_U1,cbData);  
    if(pObj == NULL) COMPlusThrowOM();
        
    memcpyNoGCRefs(pObj->m_Array, pbData, cbData);
    *pArray = (OBJECTREF) pObj;        
}


void SecurityHelper::CopyByteArrayToEncoding(IN U1ARRAYREF* pArray,
                                             OUT PBYTE*   ppbData,
                                             OUT DWORD*   pcbData)
{
    THROWSCOMPLUSEXCEPTION();
    HRESULT hr = S_OK;
    _ASSERTE(pArray);
    _ASSERTE((*pArray));
    _ASSERTE(ppbData);
    _ASSERTE(pcbData);

    DWORD size = (DWORD) (*pArray)->GetNumComponents();
    *ppbData = (PBYTE) MallocM(size);
    if(*ppbData == NULL) COMPlusThrowOM();
    *pcbData = size;
        
    CopyMemory(*ppbData, (*pArray)->GetDirectPointerToNonObjectElements(), size);
}


void SecurityHelper::EncodePermissionSet(IN OBJECTREF* pRef,
                                         OUT PBYTE* ppbData,
                                         OUT DWORD* pcbData)
{
    THROWSCOMPLUSEXCEPTION();

    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__PERMISSION_SET__ENCODE_XML);

    // Encode up the result
    INT64 args1[1];
    args1[0] = ObjToInt64(*pRef);
    OBJECTREF pByteArray = NULL;
    pByteArray = Int64ToObj(pMD->Call(args1, METHOD__PERMISSION_SET__ENCODE_XML));
        
    SecurityHelper::CopyByteArrayToEncoding((U1ARRAYREF*) &pByteArray,
                                            ppbData,
                                            pcbData);
}

void SecurityHelper::CopyStringToWCHAR(IN STRINGREF* pString,
                                       OUT WCHAR**   ppwString,
                                       OUT DWORD*    pcbString)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(pString);
    _ASSERTE(ppwString);
    _ASSERTE(pcbString);
    
    *ppwString = NULL;
    *pcbString = 0;

    WCHAR* result = NULL;

    int size = ((*pString)->GetStringLength() + 1) * sizeof(WCHAR);
    result = (WCHAR*) MallocM(size);
    if(result == NULL) COMPlusThrowOM();

    memcpyNoGCRefs(result, (*pString)->GetBuffer(), size);
    *ppwString = result;
    *pcbString = size;
}

// Append a string to a buffer, enlarging buffer as needed.
BOOL AppendToStringBuffer(LPSTR *pszBuffer, DWORD *pdwBuffer, LPSTR szString)
{
    DWORD   cbString = (DWORD)strlen(szString);
    DWORD   cbBuffer = *pszBuffer ? (DWORD)strlen(*pszBuffer) : 0;

    // Expand buffer as needed.
    if ((*pdwBuffer - cbBuffer) < (cbString + 1)) {
        DWORD   cbNewBuffer;
        LPSTR   szNewBuffer;

        cbNewBuffer = cbBuffer + cbString + 1 + 100;
        szNewBuffer = new CHAR[cbNewBuffer];
        if (szNewBuffer == NULL)
            return FALSE;
        memcpy(szNewBuffer, *pszBuffer, cbBuffer);
        *pszBuffer = szNewBuffer;
        *pdwBuffer = cbNewBuffer;
    }

    // Append new string.
    memcpy(*pszBuffer + cbBuffer, szString, cbString);
    (*pszBuffer)[cbBuffer + cbString] = '\0';

    return TRUE;
}

// Translate a set of security custom attributes into a serialized permission set blob.
HRESULT STDMETHODCALLTYPE
TranslateSecurityAttributes(CORSEC_PSET    *pPset,
                            BYTE          **ppbOutput,
                            DWORD          *pcbOutput,
                            BYTE          **ppbNonCasOutput,
                            DWORD          *pcbNonCasOutput,
                            DWORD          *pdwErrorIndex)
{
    ComCallWrapper             *pWrap = NULL;
    AppDomain                  *pAppDomain = NULL;
    DWORD                       i, j, k;
    Thread                     *pThread;
    BOOL                        bGCDisabled = FALSE;
    ContextTransitionFrame      sFrame;
    OBJECTREF                  *or;
    TypeHandle                  hType;
    EEClass                    *pClass;
    HRESULT                     hr = S_OK;
    MethodDesc                 *pMD;
    IMetaDataAssemblyImport    *pImport = pPset->pImport;
    DWORD                       dwGlobalError = 0;
    PTRARRAYREF                 orInput = NULL;
    U1ARRAYREF                  orNonCasOutput = NULL;
    
    if (pdwErrorIndex)
        dwGlobalError = *pdwErrorIndex;

    // There's a special case where we're building mscorlib.dll and we won't be
    // able to start up the EE. In this case we translate sets of security
    // custom attributes into serialized permission sets directly, using a
    // pre-built translation database stored on disk. We can tell that we've hit
    // this case because all security attribute constructors will be methoddefs
    // rather than memberrefs, and the corresponding typeref and assemblyref
    // fields will have been set to nil. Checking the first permission is
    // enough.
    // **** NOTE ****
    // We assume that mscorlib uses no non-code access security permissions
    // (since we need to split CAS and non-CAS perms into two sets, and that's
    // difficult to do without a runtime). We should assert this in SecDBEdit
    // where we finally build the real translations.
    // **** NOTE ****
    if (IsNilToken(pPset->pPermissions[0].tkTypeRef)) {
        LPSTR   szBuffer = NULL;
        DWORD   dwBuffer = 0;
#define CORSEC_EMIT_STRING(_str) do {                                   \
            if (!AppendToStringBuffer(&szBuffer, &dwBuffer, (_str)))    \
                return E_OUTOFMEMORY;                                   \
        } while (false)

        // Need to construct the key for the database lookup. This key is also
        // used during initial database construction to generate the required
        // translation (this is performed by a standalone database conversion
        // utility that takes a database containing only keys and adds all the
        // required translated values). Because of this, we write the key in a
        // simple string format that's easy for the utility (which is a managed
        // app) to use. The format syntax is as follows:
        //
        //  Key         ::= '<CorSecAttrV1/>' (SecAttr ';')...
        //  SecAttr     ::= <Attribute class name> ('@' StateData)...
        //  StateData   ::= ['F' | 'P'] Type <Name> '=' <Value>
        //  Type        ::= 'BL'
        //                | 'I1'
        //                | 'I2'
        //                | 'I4'
        //                | 'I8'
        //                | 'U1'
        //                | 'U2'
        //                | 'U4'
        //                | 'U8'
        //                | 'R4'
        //                | 'R8'
        //                | 'CH'
        //                | 'SZ'
        //                | 'EN' <Enumeration class name> '!'

        // Emit tag to differentiate from XML and provide version info.
        CORSEC_EMIT_STRING("<CorSecAttrV1/>");

        // Iterate over each security attribute (one per permission).
        for (i = 0; i < pPset->dwPermissions; i++) {
            CORSEC_PERM *pPerm = &pPset->pPermissions[i];
            BYTE        *pbBuffer = pPerm->pbValues;
            DWORD        cbBuffer = pPerm->cbValues;
            
            // Emit fully qualified name of security attribute class.
            CORSEC_EMIT_STRING(pPerm->szName);

            // Emit zero or more state data definitions.
            for (j = 0; j < pPerm->wValues; j++) {
                DWORD       dwType;
                BOOL        bIsField;
                BYTE       *pbName;
                DWORD       cbName;
                DWORD       dwLength;
                LPSTR       szName;
                CHAR        szValue[32];
                LPSTR       szString;

                // Emit the state data separator.
                CORSEC_EMIT_STRING("@");

                // Grab the field/property specifier.
                bIsField = *(BYTE*)pbBuffer == SERIALIZATION_TYPE_FIELD;
                _ASSERTE(bIsField || (*(BYTE*)pbBuffer == SERIALIZATION_TYPE_PROPERTY));
                pbBuffer += sizeof(BYTE);
                cbBuffer -= sizeof(BYTE);

                // Emit field/property indicator.
                CORSEC_EMIT_STRING(bIsField ? "F" : "P");

                // Grab the value type.
                dwType = *(BYTE*)pbBuffer;
                pbBuffer += sizeof(BYTE);
                cbBuffer -= sizeof(BYTE);

                // Emit the type code (and perhaps some further type
                // specification).
                switch (dwType) {
                case SERIALIZATION_TYPE_BOOLEAN:
                    CORSEC_EMIT_STRING("BL");
                    break;
                case SERIALIZATION_TYPE_I1:
                    CORSEC_EMIT_STRING("I1");
                    break;
                case SERIALIZATION_TYPE_I2:
                    CORSEC_EMIT_STRING("I2");
                    break;
                case SERIALIZATION_TYPE_I4:
                    CORSEC_EMIT_STRING("I4");
                    break;
                case SERIALIZATION_TYPE_I8:
                    CORSEC_EMIT_STRING("I8");
                    break;
                case SERIALIZATION_TYPE_U1:
                    CORSEC_EMIT_STRING("U1");
                    break;
                case SERIALIZATION_TYPE_U2:
                    CORSEC_EMIT_STRING("U2");
                    break;
                case SERIALIZATION_TYPE_U4:
                    CORSEC_EMIT_STRING("U4");
                    break;
                case SERIALIZATION_TYPE_U8:
                    CORSEC_EMIT_STRING("U8");
                    break;
                case SERIALIZATION_TYPE_R4:
                    CORSEC_EMIT_STRING("R4");
                    break;
                case SERIALIZATION_TYPE_R8:
                    CORSEC_EMIT_STRING("R8");
                    break;
                case SERIALIZATION_TYPE_CHAR:
                    CORSEC_EMIT_STRING("CH");
                    break;
                case SERIALIZATION_TYPE_STRING:
                    CORSEC_EMIT_STRING("SZ");
                    break;
                case SERIALIZATION_TYPE_ENUM:
                    CORSEC_EMIT_STRING("EN");

                    // The enum type code is followed immediately by the name of
                    // the underyling value type.
                    pbName = (BYTE*)CPackedLen::GetData((const void *)pbBuffer, &cbName);
                    dwLength = CPackedLen::Size(cbName) + cbName;
                    _ASSERTE(cbBuffer >= dwLength);
                    pbBuffer += dwLength;
                    cbBuffer -= dwLength;

                    // Buffer the name and nul terminate it.
                    szName = (LPSTR)_alloca(cbName + 1);
                    memcpy(szName, pbName, cbName);
                    szName[cbName] = '\0';

                    // Emit the fully qualified name of the enumeration value
                    // type.
                    CORSEC_EMIT_STRING(szName);

                    // Emit the vvalue type name terminator.
                    CORSEC_EMIT_STRING("!");

                    break;
                default:
                    _ASSERTE(!"Bad security permission state data field type");
                }

                // Grab the field/property name and length.
                pbName = (BYTE*)CPackedLen::GetData((const void *)pbBuffer, &cbName);
                dwLength = CPackedLen::Size(cbName) + cbName;
                _ASSERTE(cbBuffer >= dwLength);
                pbBuffer += dwLength;
                cbBuffer -= dwLength;

                // Buffer the name and nul terminate it.
                szName = (LPSTR)_alloca(cbName + 1);
                memcpy(szName, pbName, cbName);
                szName[cbName] = '\0';

                // Emit the field/property name.
                CORSEC_EMIT_STRING(szName);

                // Emit name/value separator.
                CORSEC_EMIT_STRING("=");

                // Emit the field/property value.
                switch (dwType) {
                case SERIALIZATION_TYPE_BOOLEAN:
                    sprintf(szValue, "%c", *(BYTE*)pbBuffer ? 'T' : 'F');
                    pbBuffer += sizeof(BYTE);
                    cbBuffer -= sizeof(BYTE);
                    break;
                case SERIALIZATION_TYPE_I1:
                    sprintf(szValue, "%d", *(char*)pbBuffer);
                    pbBuffer += sizeof(char);
                    cbBuffer -= sizeof(char);
                    break;
                case SERIALIZATION_TYPE_I2:
                    sprintf(szValue, "%d", *(short*)pbBuffer);
                    pbBuffer += sizeof(short);
                    cbBuffer -= sizeof(short);
                    break;
                case SERIALIZATION_TYPE_I4:
                    sprintf(szValue, "%d", *(int*)pbBuffer);
                    pbBuffer += sizeof(int);
                    cbBuffer -= sizeof(int);
                    break;
                case SERIALIZATION_TYPE_I8:
                    sprintf(szValue, "%I64d", *(__int64*)pbBuffer);
                    pbBuffer += sizeof(__int64);
                    cbBuffer -= sizeof(__int64);
                    break;
                case SERIALIZATION_TYPE_U1:
                    sprintf(szValue, "%u", *(unsigned char*)pbBuffer);
                    pbBuffer += sizeof(unsigned char);
                    cbBuffer -= sizeof(unsigned char);
                    break;
                case SERIALIZATION_TYPE_U2:
                    sprintf(szValue, "%u", *(unsigned short*)pbBuffer);
                    pbBuffer += sizeof(unsigned short);
                    cbBuffer -= sizeof(unsigned short);
                    break;
                case SERIALIZATION_TYPE_U4:
                    sprintf(szValue, "%u", *(unsigned int*)pbBuffer);
                    pbBuffer += sizeof(unsigned int);
                    cbBuffer -= sizeof(unsigned int);
                    break;
                case SERIALIZATION_TYPE_U8:
                    sprintf(szValue, "%I64u", *(unsigned __int64*)pbBuffer);
                    pbBuffer += sizeof(unsigned __int64);
                    cbBuffer -= sizeof(unsigned __int64);
                    break;
                case SERIALIZATION_TYPE_R4:
                    sprintf(szValue, "%f", *(float*)pbBuffer);
                    pbBuffer += sizeof(float);
                    cbBuffer -= sizeof(float);
                    break;
                case SERIALIZATION_TYPE_R8:
                    sprintf(szValue, "%g", *(double*)pbBuffer);
                    pbBuffer += sizeof(double);
                    cbBuffer -= sizeof(double);
                    break;
                case SERIALIZATION_TYPE_CHAR:
                    sprintf(szValue, "%c", *(char*)pbBuffer);
                    pbBuffer += sizeof(char);
                    cbBuffer -= sizeof(char);
                    break;
                case SERIALIZATION_TYPE_STRING:
                    // Locate string data.
                    // Special case 'null' (represented as a length byte of '0xFF').
                    if (*pbBuffer == 0xFF) {
                        szString = "";
                        pbBuffer += sizeof(BYTE);
                        cbBuffer -= sizeof(BYTE);
                    } else {
                        pbName = (BYTE*)CPackedLen::GetData((const void *)pbBuffer, &cbName);
                        dwLength = CPackedLen::Size(cbName) + cbName;
                        _ASSERTE(cbBuffer >= dwLength);
                        pbBuffer += dwLength;
                        cbBuffer -= dwLength;

                        // Dump as hex to avoid conflicts with the rest of the
                        // string data we're emitting.
                        szString = (LPSTR)_alloca((cbName * 2) + 1);
                        for (k = 0; k < cbName; k++)
                            sprintf(&szString[k * 2], "%02X", pbName[k]);
                    }
                    CORSEC_EMIT_STRING(szString);
                    break;
                case SERIALIZATION_TYPE_ENUM:
                    // NOTE: We just have to assume that the underlying type
                    // here is I4. Probably best to avoid using enums for state
                    // data in mscorlib.
                    sprintf(szValue, "%u", *(DWORD*)pbBuffer);
                    pbBuffer += sizeof(DWORD);
                    cbBuffer -= sizeof(DWORD);
                    break;
                default:
                    _ASSERTE(!"Bad security permission state data field type");
                }
                if (dwType != SERIALIZATION_TYPE_STRING)
                    CORSEC_EMIT_STRING(szValue);

            }

            // Emit security attribute class definition terminator.
            CORSEC_EMIT_STRING(";");
        }

        // Perform the conversion.
        hr = ConvertFromDB((BYTE*)szBuffer, (DWORD)(strlen(szBuffer) + 1), ppbOutput, pcbOutput);

        delete [] szBuffer;

        return hr;
    }

    // Make sure the EE knows about the current thread.
    pThread = SetupThread();
    if (pThread == NULL)
        return E_FAIL;

    // And we're in cooperative GC mode.
    if (!pThread->PreemptiveGCDisabled()) {
        pThread->DisablePreemptiveGC();
        bGCDisabled = TRUE;
    }
    


    {
        COMPLUS_TRY {

            // Get into the context of the special compilation appdomain (which has an
            // AppBase set to the current directory).
            COMPLUS_TRY {
                pWrap = ComCallWrapper::GetWrapperFromIP(pPset->pAppDomain);
                pAppDomain = pWrap->GetDomainSynchronized();
                pThread->EnterContextRestricted(pAppDomain->GetDefaultContext(), &sFrame, TRUE);
            } COMPLUS_CATCH {
                if(bGCDisabled)
                    pThread->EnablePreemptiveGC();
                return E_OUTOFMEMORY;
            } COMPLUS_END_CATCH

                // throwable needs protection across the COMPLUS_TRY
            OBJECTREF                   throwable = NULL;
            GCPROTECT_BEGIN(throwable);
        
            // we need to setup special security settings that we use during compilation
            COMPLUS_TRY
            {
                pMD = g_Mscorlib.GetMethod(METHOD__PERMISSION_SET__SETUP_SECURITY);

                pMD->Call( NULL, METHOD__PERMISSION_SET__SETUP_SECURITY );
            }
            COMPLUS_CATCH
            {
                // There is a possibility that we've already set the appdomain policy
                // level for this process.  In that case we'll get a policy exception
                // that we are free to ignore.

                OBJECTREF pThrowable = GETTHROWABLE();
                DefineFullyQualifiedNameForClassOnStack();
                LPUTF8 szClass = GetFullyQualifiedNameForClass(pThrowable->GetClass());
                if (strcmp(g_PolicyExceptionClassName, szClass) != 0)
                {
                    COMPlusThrow(pThrowable);
                }
            }
            COMPLUS_END_CATCH

            // Make a pass through the permission set, allocating objects for each
            // security attribute class.
            or = (OBJECTREF*)_alloca(pPset->dwPermissions * sizeof(OBJECTREF));
            memset(or, 0, pPset->dwPermissions * sizeof(OBJECTREF));

            GCPROTECT_ARRAY_BEGIN(*or, pPset->dwPermissions);

            for (i = 0; i < pPset->dwPermissions; i++) {
                CORSEC_PERM *pPerm = &pPset->pPermissions[i];

                if (pdwErrorIndex)
                    *pdwErrorIndex = pPerm->dwIndex;

                // Attempt to load the security attribute class.
                // If the assembly resolution scope is null we assume the attribute
                // class is defined in mscorlib and that assembly is already loaded.
                Assembly *pAssembly=NULL;
                if (!IsNilToken(pPerm->tkAssemblyRef)) {

                    _ASSERTE(TypeFromToken(pPerm->tkAssemblyRef) == mdtAssemblyRef);

                    // Find all the details needed to name an assembly for loading.
                    LPSTR                       szAssemblyName;
                    ASSEMBLYMETADATA            sContext;
                    BYTE                       *pbPublicKeyOrToken;
                    DWORD                       cbPublicKeyOrToken;
                    DWORD                       dwFlags;
                    LPWSTR                      wszName;
                    DWORD                       cchName;

                    // Initialize ASSEMBLYMETADATA structure.
                    ZeroMemory(&sContext, sizeof(ASSEMBLYMETADATA));

                    // Retrieve size of assembly name.
                    hr = pImport->GetAssemblyRefProps(pPerm->tkAssemblyRef, // [IN] The AssemblyRef for which to get the properties.
                                                      NULL,                 // [OUT] Pointer to the public key or token.
                                                      NULL,                 // [OUT] Count of bytes in the public key or token.
                                                      NULL,                 // [OUT] Buffer to fill with name.
                                                      NULL,                 // [IN] Size of buffer in wide chars.
                                                      &cchName,             // [OUT] Actual # of wide chars in name.
                                                      &sContext,            // [OUT] Assembly MetaData.
                                                      NULL,                 // [OUT] Hash blob.
                                                      NULL,                 // [OUT] Count of bytes in the hash blob.
                                                      NULL);                // [OUT] Flags.
                    _ASSERTE(SUCCEEDED(hr));

                    // Allocate the necessary buffers.
                    wszName = (LPWSTR)_alloca(cchName * sizeof(WCHAR));
                    sContext.szLocale = (LPWSTR)_alloca(sContext.cbLocale * sizeof(WCHAR));
                    sContext.rProcessor = (DWORD *)_alloca(sContext.ulProcessor * sizeof(WCHAR));
                    sContext.rOS = (OSINFO *)_alloca(sContext.ulOS * sizeof(OSINFO));

                    // Get the assembly name and rest of naming properties.
                    hr = pImport->GetAssemblyRefProps(pPerm->tkAssemblyRef,
                                                      (const void **)&pbPublicKeyOrToken,
                                                      &cbPublicKeyOrToken,
                                                      wszName,
                                                      cchName,
                                                      &cchName,
                                                      &sContext,
                                                      NULL,
                                                      NULL,
                                                      &dwFlags);
                    _ASSERTE(SUCCEEDED(hr));

                    // We've got the details of the assembly, just need to load it.

                    // Convert assembly name to UTF8.
                    szAssemblyName = (LPSTR)_alloca(cchName*3 + 1);
                    WszWideCharToMultiByte(CP_UTF8, 0, wszName, cchName, szAssemblyName, cchName * 3, NULL, NULL);
                    szAssemblyName[cchName * 3] = '\0';

                    // Unfortunately we've got an ASSEMBLYMETADATA structure, but we need
                    // an AssemblyMetaDataInternal
                    AssemblyMetaDataInternal internalContext;

                    // Initialize the structure.
                    ZeroMemory(&internalContext, sizeof(AssemblyMetaDataInternal));

                    internalContext.usMajorVersion = sContext.usMajorVersion;
                    internalContext.usMinorVersion = sContext.usMinorVersion;
                    internalContext.usBuildNumber = sContext.usBuildNumber;
                    internalContext.usRevisionNumber = sContext.usRevisionNumber;
                    internalContext.rProcessor = sContext.rProcessor;
                    internalContext.ulProcessor = sContext.ulProcessor;
                    internalContext.rOS = sContext.rOS;
                    internalContext.ulOS = sContext.ulOS;
                    hr=S_OK;
					if(sContext.cbLocale) {
						#define MAKE_TRANSLATIONFAILED hr=E_UNEXPECTED
                        MAKE_UTF8PTR_FROMWIDE(pLocale, sContext.szLocale);
						#undef MAKE_TRANSLATIONFAILED
                        internalContext.szLocale = pLocale;
                    } else {
                        internalContext.szLocale = "";
                    }
					if(SUCCEEDED(hr))
						hr = AssemblySpec::LoadAssembly(szAssemblyName, 
                                                    &internalContext,
                                                    pbPublicKeyOrToken, cbPublicKeyOrToken, dwFlags,
                                                    &pAssembly, &throwable);


                    if (throwable != NULL || FAILED(hr)) {
                        CQuickWSTRNoDtor sMessage;
                        if (throwable != NULL)
                            GetExceptionMessage(throwable, &sMessage);
                        if (sMessage.Size() > 0)
                            hr = PostError(CORSECATTR_E_ASSEMBLY_LOAD_FAILED_EX, wszName, sMessage.Ptr());
                        else
                            hr = PostError(CORSECATTR_E_ASSEMBLY_LOAD_FAILED, wszName);
                        goto ErrorUnderGCProtect;
                    }

                } else {
                    // Load from MSCORLIB.
                    pAssembly = SystemDomain::SystemAssembly();
                }

                // Load the security attribute class.
                hType = pAssembly->GetLoader()->FindTypeHandle(pPerm->szName, &throwable);
                if (hType.IsNull() || (pClass = hType.GetClass()) == NULL) {
					#define MAKE_TRANSLATIONFAILED wszTemp=L""
                    MAKE_WIDEPTR_FROMUTF8_FORPRINT(wszTemp, pPerm->szName);
					#undef MAKE_TRANSLATIONFAILED
                    CQuickWSTRNoDtor sMessage;
                    if (throwable != NULL)
                        GetExceptionMessage(throwable, &sMessage);
                    if (sMessage.Size() > 0)
                        hr = PostError(CORSECATTR_E_TYPE_LOAD_FAILED_EX, wszTemp, sMessage.Ptr());
                    else
                        hr = PostError(CORSECATTR_E_TYPE_LOAD_FAILED, wszTemp);
                    goto ErrorUnderGCProtect;
                }

                // It better not be abstract.
                if (pClass->IsAbstract()) {
                    hr = PostError(CORSECATTR_E_ABSTRACT);
                    goto ErrorUnderGCProtect;
                }

    #ifdef _DEBUG
                // Is it really a security attribute class?
                {
                    EEClass    *pParent = pClass->GetParentClass();
                    CHAR       *szClass;
                    DefineFullyQualifiedNameForClassOnStack();
                    while (pParent) {
                        szClass = GetFullyQualifiedNameForClass(pParent);
                        if (_stricmp(szClass, COR_BASE_SECURITY_ATTRIBUTE_CLASS_ANSI) == 0)
                            break;
                        pParent = pParent->GetParentClass();
                    }
                    _ASSERTE(pParent && "Security attribute not derived from COR_BASE_SECURITY_ATTRIBUTE_CLASS");
                }
    #endif

                // Run the class initializer.
                if (!pClass->GetMethodTable()->CheckRunClassInit(&throwable)
                    || (throwable != NULL))
                    if (throwable != NULL)
                        COMPlusThrow(throwable);
                    else
                        FATAL_EE_ERROR();

                // Instantiate an instance.
                or[i] = AllocateObject(pClass->GetMethodTable());
                if (or[i] == NULL)
                    COMPlusThrowOM();

                // Find and call the constructor.
                pMD = pClass->FindConstructor(gsig_IM_SecurityAction_RetVoid.GetBinarySig(),
                                              gsig_IM_SecurityAction_RetVoid.GetBinarySigLength(),
                                              gsig_IM_SecurityAction_RetVoid.GetModule());
                if (pMD == NULL)
                    FATAL_EE_ERROR();

                INT64 args[] = {
                    ObjToInt64(or[i]),
                    (INT64)pPset->dwAction
                };

                pMD->Call(args);
                // Setup fields and properties on the object, as specified by the
                // serialized data passed to us.
                BYTE   *pbBuffer = pPerm->pbValues;
                DWORD   cbBuffer = pPerm->cbValues;
                for (j = 0; j < pPerm->wValues; j++) {
                    DWORD       dwType;
                    BOOL        bIsField;
                    BYTE       *pbName;
                    DWORD       cbName;
                    DWORD       dwLength;
                    LPSTR       szName;
                    LPSTR       szString;
                    STRINGREF   orString;
                    FieldDesc  *pFD;
                    BYTE        pbSig[128];
                    DWORD       cbSig = 0;
                    TypeHandle      hEnum;
                    CorElementType  eEnumType = ELEMENT_TYPE_END;

                    // Check we've got at least the field/property specifier and the
                    // type code.
                    _ASSERTE(cbBuffer >= (sizeof(BYTE) + sizeof(BYTE)));

                    // Grab the field/property specifier.
                    bIsField = *(BYTE*)pbBuffer == SERIALIZATION_TYPE_FIELD;
                    _ASSERTE(bIsField || (*(BYTE*)pbBuffer == SERIALIZATION_TYPE_PROPERTY));
                    pbBuffer += sizeof(BYTE);
                    cbBuffer -= sizeof(BYTE);

                    // Grab the value type.
                    dwType = *(BYTE*)pbBuffer;
                    pbBuffer += sizeof(BYTE);
                    cbBuffer -= sizeof(BYTE);

                    // Some types need further specification.
                    switch (dwType) {
                    case SERIALIZATION_TYPE_ENUM:
                        // Immediately after the enum type token is the fully
                        // qualified name of the value type used to represent
                        // the enum.
                        pbName = (BYTE*)CPackedLen::GetData((const void *)pbBuffer, &cbName);
                        dwLength = CPackedLen::Size(cbName) + cbName;
                        _ASSERTE(cbBuffer >= dwLength);
                        pbBuffer += dwLength;
                        cbBuffer -= dwLength;

                        // Buffer the name and nul terminate it.
                        szName = (LPSTR)_alloca(cbName + 1);
                        memcpy(szName, pbName, cbName);
                        szName[cbName] = '\0';

                        // Lookup the type (possibly loading an assembly containing
                        // the type).
                        hEnum = GetAppDomain()->FindAssemblyQualifiedTypeHandle(szName,
                                                                                true,
                                                                                NULL,
                                                                                NULL,
                                                                                &throwable);
                        if (hEnum.IsNull()) {
							#define MAKE_TRANSLATIONFAILED wszTemp=L""
                            MAKE_WIDEPTR_FROMUTF8_FORPRINT(wszTemp, szName);
							#undef MAKE_TRANSLATIONFAILED
                            CQuickWSTRNoDtor sMessage;
                            if (throwable != NULL)
                                GetExceptionMessage(throwable, &sMessage);
                            if (sMessage.Size() > 0)
                                hr = PostError(CORSECATTR_E_TYPE_LOAD_FAILED_EX, wszTemp, sMessage.Ptr());
                            else
                                hr = PostError(CORSECATTR_E_TYPE_LOAD_FAILED, wszTemp);
                            goto ErrorUnderGCProtect;
                        }

                        // Calculate the underlying primitive type of the
                        // enumeration.
                        eEnumType = hEnum.GetNormCorElementType();
                        break;
                    case SERIALIZATION_TYPE_SZARRAY:
                    case SERIALIZATION_TYPE_TYPE:
                        // Can't deal with these yet.
                        hr = PostError(CORSECATTR_E_UNSUPPORTED_TYPE);
                        goto ErrorUnderGCProtect;
                    }

                    // Grab the field/property name and length.
                    pbName = (BYTE*)CPackedLen::GetData((const void *)pbBuffer, &cbName);
                    dwLength = CPackedLen::Size(cbName) + cbName;
                    _ASSERTE(cbBuffer >= dwLength);
                    pbBuffer += dwLength;
                    cbBuffer -= dwLength;

                    // Buffer the name and nul terminate it.
                    szName = (LPSTR)_alloca(cbName + 1);
                    memcpy(szName, pbName, cbName);
                    szName[cbName] = '\0';

                    if (bIsField) {
                        // Build the field signature.
                        cbSig = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_FIELD, &pbSig[cbSig]);
                        switch (dwType) {
                        case SERIALIZATION_TYPE_BOOLEAN:
                        case SERIALIZATION_TYPE_I1:
                        case SERIALIZATION_TYPE_I2:
                        case SERIALIZATION_TYPE_I4:
                        case SERIALIZATION_TYPE_I8:
                        case SERIALIZATION_TYPE_U1:
                        case SERIALIZATION_TYPE_U2:
                        case SERIALIZATION_TYPE_U4:
                        case SERIALIZATION_TYPE_U8:
                        case SERIALIZATION_TYPE_R4:
                        case SERIALIZATION_TYPE_R8:
                        case SERIALIZATION_TYPE_CHAR:
                            _ASSERTE(SERIALIZATION_TYPE_BOOLEAN == ELEMENT_TYPE_BOOLEAN);
                            _ASSERTE(SERIALIZATION_TYPE_I1 == ELEMENT_TYPE_I1);
                            _ASSERTE(SERIALIZATION_TYPE_I2 == ELEMENT_TYPE_I2);
                            _ASSERTE(SERIALIZATION_TYPE_I4 == ELEMENT_TYPE_I4);
                            _ASSERTE(SERIALIZATION_TYPE_I8 == ELEMENT_TYPE_I8);
                            _ASSERTE(SERIALIZATION_TYPE_U1 == ELEMENT_TYPE_U1);
                            _ASSERTE(SERIALIZATION_TYPE_U2 == ELEMENT_TYPE_U2);
                            _ASSERTE(SERIALIZATION_TYPE_U4 == ELEMENT_TYPE_U4);
                            _ASSERTE(SERIALIZATION_TYPE_U8 == ELEMENT_TYPE_U8);
                            _ASSERTE(SERIALIZATION_TYPE_R4 == ELEMENT_TYPE_R4);
                            _ASSERTE(SERIALIZATION_TYPE_R8 == ELEMENT_TYPE_R8);
                            _ASSERTE(SERIALIZATION_TYPE_CHAR == ELEMENT_TYPE_CHAR);
                            cbSig += CorSigCompressData(dwType, &pbSig[cbSig]);
                            break;
                        case SERIALIZATION_TYPE_STRING:
                            cbSig += CorSigCompressData((ULONG)ELEMENT_TYPE_STRING, &pbSig[cbSig]);
                            break;
                        case SERIALIZATION_TYPE_ENUM:
                            // To avoid problems when the field and enum are defined
                            // in different scopes (we'd have to go hunting for
                            // typerefs), we build a signature with a special type
                            // (ELEMENT_TYPE_INTERNAL, which contains a TypeHandle).
                            // This compares loaded types for indentity.
                            cbSig += CorSigCompressData((ULONG)ELEMENT_TYPE_INTERNAL, &pbSig[cbSig]);
                            cbSig += CorSigCompressPointer(hEnum.AsPtr(), &pbSig[cbSig]);
                            break;
                        default:
                            hr = PostError(CORSECATTR_E_UNSUPPORTED_TYPE);
                            goto ErrorUnderGCProtect;
                        }

                        // Locate a field desc.
                        pFD = pClass->FindField(szName, (PCCOR_SIGNATURE)pbSig,
                                                cbSig, pClass->GetModule());
                        if (pFD == NULL) {
							#define MAKE_TRANSLATIONFAILED wszTemp=L""
                            MAKE_WIDEPTR_FROMUTF8(wszTemp, szName);
							#undef MAKE_TRANSLATIONFAILED
                            hr = PostError(CORSECATTR_E_NO_FIELD, wszTemp);
                            goto ErrorUnderGCProtect;
                        }

                        // Set the field value.
                        switch (dwType) {
                        case SERIALIZATION_TYPE_BOOLEAN:
                        case SERIALIZATION_TYPE_I1:
                        case SERIALIZATION_TYPE_U1:
                        case SERIALIZATION_TYPE_CHAR:
                            pFD->SetValue8(or[i], *(BYTE*)pbBuffer);
                            pbBuffer += sizeof(BYTE);
                            cbBuffer -= sizeof(BYTE);
                            break;
                        case SERIALIZATION_TYPE_I2:
                        case SERIALIZATION_TYPE_U2:
                            pFD->SetValue16(or[i], *(WORD*)pbBuffer);
                            pbBuffer += sizeof(WORD);
                            cbBuffer -= sizeof(WORD);
                            break;
                        case SERIALIZATION_TYPE_I4:
                        case SERIALIZATION_TYPE_U4:
                        case SERIALIZATION_TYPE_R4:
                            pFD->SetValue32(or[i], *(DWORD*)pbBuffer);
                            pbBuffer += sizeof(DWORD);
                            cbBuffer -= sizeof(DWORD);
                            break;
                        case SERIALIZATION_TYPE_I8:
                        case SERIALIZATION_TYPE_U8:
                        case SERIALIZATION_TYPE_R8:
                            pFD->SetValue64(or[i], *(INT64*)pbBuffer);
                            pbBuffer += sizeof(INT64);
                            cbBuffer -= sizeof(INT64);
                            break;
                        case SERIALIZATION_TYPE_STRING:
                            // Locate string data.
                            // Special case 'null' (represented as a length byte of '0xFF').
                            if (*pbBuffer == 0xFF) {
                                szString = NULL;
                                dwLength = sizeof(BYTE);
                            } else {
                                pbName = (BYTE*)CPackedLen::GetData((const void *)pbBuffer, &cbName);
                                dwLength = CPackedLen::Size(cbName) + cbName;
                                _ASSERTE(cbBuffer >= dwLength);

                                // Buffer and nul terminate it.
                                szString = (LPSTR)_alloca(cbName + 1);
                                memcpy(szString, pbName, cbName);
                                szString[cbName] = '\0';
                            }

                            // Allocate and initialize a managed version of the string.
                            if (szString) {
                            orString = COMString::NewString(szString);
                            if (orString == NULL)
                                COMPlusThrowOM();
                            } else
                                orString = NULL;

                            pFD->SetRefValue(or[i], (OBJECTREF)orString);

                            pbBuffer += dwLength;
                            cbBuffer -= dwLength;
                            break;
                        case SERIALIZATION_TYPE_ENUM:
                            // Get the underlying primitive type.
                            switch (eEnumType) {
                            case ELEMENT_TYPE_I1:
                            case ELEMENT_TYPE_U1:
                                pFD->SetValue8(or[i], *(BYTE*)pbBuffer);
                                pbBuffer += sizeof(BYTE);
                                cbBuffer -= sizeof(BYTE);
                                break;
                            case ELEMENT_TYPE_I2:
                            case ELEMENT_TYPE_U2:
                                pFD->SetValue16(or[i], *(WORD*)pbBuffer);
                                pbBuffer += sizeof(WORD);
                                cbBuffer -= sizeof(WORD);
                                break;
                            case ELEMENT_TYPE_I4:
                            case ELEMENT_TYPE_U4:
                                pFD->SetValue32(or[i], *(DWORD*)pbBuffer);
                                pbBuffer += sizeof(DWORD);
                                cbBuffer -= sizeof(DWORD);
                                break;
                            default:
                                hr = PostError(CORSECATTR_E_UNSUPPORTED_ENUM_TYPE);
                                goto ErrorUnderGCProtect;
                            }
                            break;
                        default:
                            hr = PostError(CORSECATTR_E_UNSUPPORTED_TYPE);
                            goto ErrorUnderGCProtect;
                        }

                    } else {

                        // Locate the property setter.
                        pMD = pClass->FindPropertyMethod(szName, PropertySet);
                        if (pMD == NULL) {
							#define MAKE_TRANSLATIONFAILED wszTemp=L""
                            MAKE_WIDEPTR_FROMUTF8(wszTemp, szName);
							#undef MAKE_TRANSLATIONFAILED
                            hr = PostError(CORSECATTR_E_NO_PROPERTY, wszTemp);
                            goto ErrorUnderGCProtect;
                        }

                        // Build the argument list.
                        INT64 args[2] = { NULL, NULL };
                        switch (dwType) {
                        case SERIALIZATION_TYPE_BOOLEAN:
                        case SERIALIZATION_TYPE_I1:
                        case SERIALIZATION_TYPE_U1:
                        case SERIALIZATION_TYPE_CHAR:
                            args[1] = (INT64)*(BYTE*)pbBuffer;
                            pbBuffer += sizeof(BYTE);
                            cbBuffer -= sizeof(BYTE);
                            break;
                        case SERIALIZATION_TYPE_I2:
                        case SERIALIZATION_TYPE_U2:
                            args[1] = (INT64)*(WORD*)pbBuffer;
                            pbBuffer += sizeof(WORD);
                            cbBuffer -= sizeof(WORD);
                            break;
                        case SERIALIZATION_TYPE_I4:
                        case SERIALIZATION_TYPE_U4:
                        case SERIALIZATION_TYPE_R4:
                            args[1] = (INT64)*(DWORD*)pbBuffer;
                            pbBuffer += sizeof(DWORD);
                            cbBuffer -= sizeof(DWORD);
                            break;
                        case SERIALIZATION_TYPE_I8:
                        case SERIALIZATION_TYPE_U8:
                        case SERIALIZATION_TYPE_R8:
                            args[1] = (INT64)*(INT64*)pbBuffer;
                            pbBuffer += sizeof(INT64);
                            cbBuffer -= sizeof(INT64);
                            break;
                        case SERIALIZATION_TYPE_STRING:
                            // Locate string data.
                            // Special case 'null' (represented as a length byte of '0xFF').
                            if (*pbBuffer == 0xFF) {
                                szString = NULL;
                                dwLength = sizeof(BYTE);
                            } else {
                                pbName = (BYTE*)CPackedLen::GetData((const void *)pbBuffer, &cbName);
                                dwLength = CPackedLen::Size(cbName) + cbName;
                                _ASSERTE(cbBuffer >= dwLength);

                                // Buffer and nul terminate it.
                                szString = (LPSTR)_alloca(cbName + 1);
                                memcpy(szString, pbName, cbName);
                                szString[cbName] = '\0';
                            }

                            // Allocate and initialize a managed version of the string.
                            if (szString) {
                            orString = COMString::NewString(szString);
                            if (orString == NULL)
                                COMPlusThrowOM();
                            } else
                                orString = NULL;

                            args[1] = ObjToInt64(orString);

                            pbBuffer += dwLength;
                            cbBuffer -= dwLength;
                            break;
                        case SERIALIZATION_TYPE_ENUM:
                            // Get the underlying primitive type.
                            switch (eEnumType) {
                            case ELEMENT_TYPE_I1:
                            case ELEMENT_TYPE_U1:
                                args[1] = (INT64)*(BYTE*)pbBuffer;
                                pbBuffer += sizeof(BYTE);
                                cbBuffer -= sizeof(BYTE);
                                break;
                            case ELEMENT_TYPE_I2:
                            case ELEMENT_TYPE_U2:
                                args[1] = (INT64)*(WORD*)pbBuffer;
                                pbBuffer += sizeof(WORD);
                                cbBuffer -= sizeof(WORD);
                                break;
                            case ELEMENT_TYPE_I4:
                            case ELEMENT_TYPE_U4:
                                args[1] = (INT64)*(DWORD*)pbBuffer;
                                pbBuffer += sizeof(DWORD);
                                cbBuffer -= sizeof(DWORD);
                                break;
                            default:
                                hr = PostError(CORSECATTR_E_UNSUPPORTED_ENUM_TYPE);
                                goto ErrorUnderGCProtect;
                            }
                            break;
                        default:
                            hr = PostError(CORSECATTR_E_UNSUPPORTED_TYPE);
                            goto ErrorUnderGCProtect;
                        }


                        // ! don't move this up, COMString::NewString
                        // ! inside the switch causes a GC
                        args[0] = ObjToInt64(or[i]);

                        // Call the setter.
                        pMD->Call(args);

                    }

                }

                _ASSERTE(cbBuffer == 0);
            }

            if (pdwErrorIndex)
                *pdwErrorIndex = dwGlobalError;

            // Call into managed code to group permissions into a PermissionSet and
            // serialize it down into a binary blob.

            // Locate the managed function.
            pMD = g_Mscorlib.GetMethod(METHOD__PERMISSION_SET__CREATE_SERIALIZED);

            // Allocate a managed array of permission objects for input to the
            // function.
            orInput = (PTRARRAYREF) AllocateObjectArray(pPset->dwPermissions, g_pObjectClass);
            if (orInput == NULL)
                COMPlusThrowOM();

            // Copy over the permission objects references.
            for (i = 0; i < pPset->dwPermissions; i++)
                orInput->SetAt(i, or[i]);

            // Call the routine.
            orNonCasOutput = NULL;
            INT64 args[] = { (INT64)&orNonCasOutput, ObjToInt64(orInput) };

            GCPROTECT_BEGIN(orNonCasOutput);

            U1ARRAYREF orOutput = (U1ARRAYREF) Int64ToObj(pMD->Call(args, METHOD__PERMISSION_SET__CREATE_SERIALIZED));

            // Buffer the managed output in a native binary blob.
            // Special case the empty blob. We might get a second blob output if
            // there were any non-CAS permissions present.
            if (orOutput == NULL) {
                *ppbOutput = NULL;
                *pcbOutput = 0;
            } else {
                BYTE   *pbArray = orOutput->GetDataPtr();
                DWORD   cbArray = orOutput->GetNumComponents();
                *ppbOutput = new (throws) BYTE[cbArray];
                memcpy(*ppbOutput, pbArray, cbArray);
                *pcbOutput = cbArray;
            }

            if (orNonCasOutput == NULL) {
                *ppbNonCasOutput = NULL;
                *pcbNonCasOutput = 0;
            } else {
                BYTE   *pbArray = orNonCasOutput->GetDataPtr();
                DWORD   cbArray = orNonCasOutput->GetNumComponents();
                *ppbNonCasOutput = new (throws) BYTE[cbArray];
                memcpy(*ppbNonCasOutput, pbArray, cbArray);
                *pcbNonCasOutput = cbArray;
            }

            GCPROTECT_END();

        ErrorUnderGCProtect:

            GCPROTECT_END();
            GCPROTECT_END(); // for throwable

            pThread->ReturnToContext(&sFrame, TRUE);

        } COMPLUS_CATCH {
            CQuickWSTRNoDtor sMessage;

            OBJECTREF throwable = GETTHROWABLE();
            GCPROTECT_BEGIN(throwable);    // GetExceptionMessage can make a managed call
            COMPLUS_TRY {
                GetExceptionMessage(throwable, &sMessage);
            } COMPLUS_CATCH {
                sMessage.ReSize(0);
            } COMPLUS_END_CATCH
            if (sMessage.Size() > 0)
                hr = PostError(CORSECATTR_E_EXCEPTION, sMessage.Ptr());
            else {
                hr = SecurityHelper::MapToHR(throwable);
                hr = PostError(CORSECATTR_E_EXCEPTION_HR, hr);
            }
            GCPROTECT_END();
        } COMPLUS_END_CATCH
    }


    if(bGCDisabled)
        pThread->EnablePreemptiveGC();

    return hr;
}

HRESULT STDMETHODCALLTYPE
ConvertFromDB(const PBYTE pbInBytes,
              DWORD cbInBytes,
              PBYTE* ppbEncoding,
              DWORD* pcbEncoding)
{
    static SecurityDB db;

    return db.Convert(pbInBytes, cbInBytes, ppbEncoding, pcbEncoding) ? 
        S_OK : E_FAIL;
}

// Reads permission requests (if any) from the manifest of an assembly.
HRESULT STDMETHODCALLTYPE
GetPermissionRequests(LPCWSTR   pwszFileName,
                      BYTE    **ppbMinimal,
                      DWORD    *pcbMinimal,
                      BYTE    **ppbOptional,
                      DWORD    *pcbOptional,
                      BYTE    **ppbRefused,
                      DWORD    *pcbRefused)
{
    HRESULT                     hr;
    IMetaDataDispenser         *pMD = NULL;
    IMetaDataAssemblyImport    *pMDAsmImport = NULL;
    IMetaDataImport            *pMDImport = NULL;
    mdAssembly                  mdAssembly;
    BYTE                       *pbMinimal = NULL;
    DWORD                       cbMinimal = 0;
    BYTE                       *pbOptional = NULL;
    DWORD                       cbOptional = 0;
    BYTE                       *pbRefused = NULL;
    DWORD                       cbRefused = 0;
    HCORENUM                    hEnumDcl = NULL;
    mdPermission                rPSets[dclMaximumValue + 1];
    DWORD                       dwSets;
    DWORD                       i;

    *ppbMinimal = NULL;
    *pcbMinimal = 0;
    *ppbOptional = NULL;
    *pcbOptional = 0;
    *ppbRefused = NULL;
    *pcbRefused = 0;

    // Get the meta data interface dispenser.
    hr = MetaDataGetDispenser(CLSID_CorMetaDataDispenser,
                              IID_IMetaDataDispenserEx,
                              (void **)&pMD);
    if (FAILED(hr))
        goto Error;

    // Open a scope on the assembly file.
    hr = pMD->OpenScope(pwszFileName,
                        0,
                        IID_IMetaDataAssemblyImport,
                        (IUnknown**)&pMDAsmImport);
    if (FAILED(hr))
        goto Error;

    // Determine the assembly token.
    hr = pMDAsmImport->GetAssemblyFromScope(&mdAssembly);
    if (FAILED(hr))
        goto Error;

    // QI for a normal import interface.
    hr = pMDAsmImport->QueryInterface(IID_IMetaDataImport, (void**)&pMDImport);
    if (FAILED(hr))
        goto Error;

    // Look for permission request sets hung off the assembly token.
    hr = pMDImport->EnumPermissionSets(&hEnumDcl,
                                       mdAssembly,
                                       dclActionNil,
                                       rPSets,
                                       dclMaximumValue + 1,
                                       &dwSets);
    if (FAILED(hr))
        goto Error;

    for (i = 0; i < dwSets; i++) {
        BYTE   *pbData;
        DWORD   cbData;
        DWORD   dwAction;

        pMDImport->GetPermissionSetProps(rPSets[i],
                                         &dwAction,
                                         (void const **)&pbData,
                                         &cbData);

        switch (dwAction) {
        case dclRequestMinimum:
            _ASSERTE(pbMinimal == NULL);
            pbMinimal = pbData;
            cbMinimal = cbData;
            break;
        case dclRequestOptional:
            _ASSERTE(pbOptional == NULL);
            pbOptional = pbData;
            cbOptional = cbData;
            break;
        case dclRequestRefuse:
            _ASSERTE(pbRefused == NULL);
            pbRefused = pbData;
            cbRefused = cbData;
            break;
        default:
            _ASSERTE(FALSE);
        }
    }

    pMDImport->CloseEnum(hEnumDcl);

    // Buffer the results (since we're about to close the metadata scope and
    // lose the original data).
    if (pbMinimal) {
        *ppbMinimal = (BYTE*)MallocM(cbMinimal);
        if (*ppbMinimal == NULL)
            goto Error;
        memcpy(*ppbMinimal, pbMinimal, cbMinimal);
        *pcbMinimal = cbMinimal;
    }

    if (pbOptional) {
        *ppbOptional = (BYTE*)MallocM(cbOptional);
        if (*ppbOptional == NULL)
            goto Error;
        memcpy(*ppbOptional, pbOptional, cbOptional);
        *pcbOptional = cbOptional;
    }

    if (pbRefused) {
        *ppbRefused = (BYTE*)MallocM(cbRefused);
        if (*ppbRefused == NULL)
            goto Error;
        memcpy(*ppbRefused, pbRefused, cbRefused);
        *pcbRefused = cbRefused;
    }

    pMDImport->Release();
    pMDAsmImport->Release();
    pMD->Release();

    return S_OK;

 Error:
    if (pMDImport)
        pMDImport->Release();
    if (pMDAsmImport)
        pMDAsmImport->Release();
    if (pMD)
        pMD->Release();
    return hr;
}

// Load permission requests in their serialized form from assembly metadata.
// This consists of a required permissions set and optionally an optional and
// deny permission set.
void SecurityHelper::LoadPermissionRequestsFromAssembly(IN Assembly*     pAssembly,
                                                        OUT OBJECTREF*   pReqdPermissions,
                                                        OUT OBJECTREF*   pOptPermissions,
                                                        OUT OBJECTREF*   pDenyPermissions,
                                                        OUT PermissionRequestSpecialFlags *pSpecialFlags,
                                                        IN BOOL          fCreate)
{
    mdAssembly          mdAssembly;
    IMDInternalImport*  pImport;
    HRESULT             hr;

    *pReqdPermissions = NULL;
    *pOptPermissions = NULL;
    *pDenyPermissions = NULL;

    // It's OK to be called with a NULL assembly. This can happen in the code
    // path where we're just checking for a signature, nothing else. So just
    // return without doing anything.
    if (pAssembly == NULL)
        return;

    // Check for existence of manifest within assembly.
    if ((pImport = pAssembly->GetManifestImport()) == NULL)
        return;

    // Locate assembly metadata token since the various permission sets are
    // written as custom values against this token.
    if (pImport->GetAssemblyFromScope(&mdAssembly) != S_OK) {
        _ASSERT(FALSE);
        return;
    }

    struct _gc {
        OBJECTREF reqdPset;
        OBJECTREF optPset;
        OBJECTREF denyPset;
    } gc;
    ZeroMemory(&gc, sizeof(gc));
      
    BEGIN_ENSURE_COOPERATIVE_GC();

    GCPROTECT_BEGIN(gc);
    
    // Read and translate required permission set.
    hr = GetDeclaredPermissions(pImport, mdAssembly, dclRequestMinimum, &gc.reqdPset, (pSpecialFlags != NULL ? &pSpecialFlags->required : NULL), fCreate);
    _ASSERT(SUCCEEDED(hr) || (hr == CLDB_E_RECORD_NOTFOUND));

    // Now the optional permission set.
    hr = GetDeclaredPermissions(pImport, mdAssembly, dclRequestOptional, &gc.optPset, (pSpecialFlags != NULL ? &pSpecialFlags->optional : NULL), fCreate);
    _ASSERT(SUCCEEDED(hr) || (hr == CLDB_E_RECORD_NOTFOUND));

    // And finally the refused permission set.
    hr = GetDeclaredPermissions(pImport, mdAssembly, dclRequestRefuse, &gc.denyPset, (pSpecialFlags != NULL ? &pSpecialFlags->refused : NULL), fCreate);
    _ASSERT(SUCCEEDED(hr) || (hr == CLDB_E_RECORD_NOTFOUND));

    *pReqdPermissions = gc.reqdPset;
    *pOptPermissions = gc.optPset;
    *pDenyPermissions = gc.denyPset;

    GCPROTECT_END();

    END_ENSURE_COOPERATIVE_GC();
}

// Determine whether permission requests were made in the assembly manifest.
BOOL SecurityHelper::PermissionsRequestedInAssembly(IN  Assembly* pAssembly)
{
    mdAssembly          mdAssembly;
    IMDInternalImport*  pImport;
    HRESULT             hr;
    HENUMInternal       hEnumDcl;
    BOOL                bFoundRequest;

    // Check for existence of manifest within assembly.
    if ((pImport = pAssembly->GetManifestImport()) == NULL)
        return false;

    // Locate assembly metadata token since the various permission sets are
    // written as custom values against this token.
    if (pImport->GetAssemblyFromScope(&mdAssembly) != S_OK) {
        _ASSERT(FALSE);
        return false;
    }

    // Scan for any requests on the assembly (we assume these must be permission
    // requests, since declarative security can't be applied to assemblies).
    hr = pImport->EnumPermissionSetsInit(mdAssembly,
                                         dclActionNil,
                                         &hEnumDcl);
    _ASSERT(SUCCEEDED(hr));

    bFoundRequest = pImport->EnumGetCount(&hEnumDcl) > 0;

    pImport->EnumClose(&hEnumDcl);

    return bFoundRequest;
}

// Returns the declared permissions for the specified action type.
HRESULT SecurityHelper::GetDeclaredPermissions(IN IMDInternalImport *pInternalImport,
                                               IN mdToken classToken,
                                               IN CorDeclSecurity action,
                                               OUT OBJECTREF *pDeclaredPermissions,
                                               OUT SpecialPermissionSetFlag *pSpecialFlags,
                                               IN BOOL fCreate)
{
    HRESULT         hr = S_FALSE;
    PBYTE           pbPerm = NULL;
    ULONG           cbPerm = 0;
    void const **   ppData = const_cast<void const**> (reinterpret_cast<void**> (&pbPerm));
    mdPermission    tkPerm;
    HENUMInternal   hEnumDcl;
    OBJECTREF       pGrantedPermission = NULL;

    _ASSERTE(pDeclaredPermissions);
    _ASSERTE(action > dclActionNil && action <= dclMaximumValue);

    // Initialize the output parameter.
    *pDeclaredPermissions = NULL;

    // Lookup the permissions for the given declarative action type.
    hr = pInternalImport->EnumPermissionSetsInit(
        classToken,
        action,
        &hEnumDcl);
    
    if (FAILED(hr))
    {
        if (pSpecialFlags != NULL)
            *pSpecialFlags = NoSet;
        goto exit;
    }
    
    if (hr != S_FALSE)
    {
        _ASSERTE(pInternalImport->EnumGetCount(&hEnumDcl) == 1 &&
            "Multiple permissions sets for the same "
            "declaration aren't currently supported.");
        
        if (pInternalImport->EnumNext(&hEnumDcl, &tkPerm))
        {
            DWORD dwActionDummy;
            pInternalImport->GetPermissionSetProps(
                tkPerm,
                &dwActionDummy,
                ppData,
                &cbPerm);

            //_ASSERTE((dwActionDummy == action) && "Action retrieved different from requested");
            
            if(pbPerm)
            {
                SecurityHelper::LoadPermissionSet(pbPerm,
                                                  cbPerm,
                                                  &pGrantedPermission,
                                                  NULL,
                                                  NULL,
                                                  FALSE,
                                                  pSpecialFlags,
                                                  fCreate);
                
                if (pGrantedPermission != NULL)
                    *pDeclaredPermissions = pGrantedPermission;
            }
            else
            {
                if (pSpecialFlags != NULL)
                    *pSpecialFlags = NoSet;
            }
        }
        else
        {
            _ASSERTE(!"At least one enumeration expected");
        }
    }
    
    pInternalImport->EnumClose(&hEnumDcl);
    
exit:
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\peverifier.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 *
 * Header:  PEVerifier.h
 *
 * Author:  Shajan Dasan
 *
 * Purpose: Verify PE images before loading. This is to prevent
 *          Native code (other than Mscoree.DllMain() ) to execute.
 *
 *
 * The entry point should be the following instruction.
 *
 * [_X86_]
 * jmp dword ptr ds:[XXXX]
 *
 * XXXX should be the RVA of the first entry in the IAT.
 * The IAT should have only one entry, that should be MSCoree.dll:_CorMain
 *
 * Date created : 1 July 1999 
 * 
 */

#pragma once

#include "RangeTree.h"

class PEVerifier
{
public:
    PEVerifier(PBYTE pBase, DWORD dwLength) : 
        m_pBase(pBase), 
        m_dwLength(dwLength), 
        m_pDOSh(NULL), 
        m_pNTh(NULL), 
        m_pFh(NULL), 
        m_pSh(NULL),
        m_dwPrefferedBase(0),
        m_nSections(0),
        m_dwIATRVA(0),
        m_dwRelocRVA(0)
    {
    }

    BOOL Check();

    // Convinience wrapper for clients using SEH who cannot instantiate PEVerifier
    // because it has a destructor
    static BOOL Check(PBYTE pBase, DWORD dwLength)
    {
        PEVerifier pev(pBase, dwLength);
        return pev.Check();
    }

    // The reason we have this function public and static is that we will be calling
    // it from CorExeMain to do some early validation
    static BOOL CheckPEManagedStack(IMAGE_NT_HEADERS*   pNT);       

protected:

    PBYTE m_pBase;      // base of the module
    DWORD m_dwLength;   // length of the contents of the module, loaded as a data file

private:

    BOOL CheckDosHeader();
    BOOL CheckNTHeader();
    BOOL CheckFileHeader();
    BOOL CheckOptionalHeader();
    BOOL CheckSectionHeader();

    BOOL CheckSection          (DWORD *pOffsetCounter, 
                                DWORD dataOffset,
                                DWORD dataSize, 
                                DWORD *pAddressCounter,
                                DWORD virtualAddress, 
                                DWORD unalignedVirtualSize,
                                int sectionIndex);

    BOOL CheckDirectories();
    BOOL CheckImportDlls();    // Sets m_dwIATRVA
    BOOL CheckRelocations();   // Sets m_dwRelocRVA
    BOOL CheckEntryPoint();

    BOOL CheckImportByNameTable(DWORD dwRVA, BOOL fNameTable);

    BOOL CheckCOMHeader();
    
    BOOL CompareStringAtRVA(DWORD dwRVA, CHAR *pStr, DWORD dwSize);

    // Returns the file offset corresponding to the RVA
    // Returns 0 if the RVA does not live in a valid section of the image
    DWORD RVAToOffset      (DWORD dwRVA,
                            DWORD *pdwSectionOffset, // [OUT] - File offset to corresponding section
                            DWORD *pdwSectionSize) const; // [OUT] - Size of the corresponding section

    // Returns the file offset corresponding to the directory
    // Checks that the given directory lives within a valid section of the image.
    DWORD DirectoryToOffset(DWORD dwDirectory, 
                            DWORD *pdwDirectorySize, // [OUT] - Size of the directory
                            DWORD *pdwSectionOffset, // [OUT] - File offset of the directory
                            DWORD *pdwSectionSize) const; // [OUT] - Size of the section containing the directory

#ifdef _MODULE_VERIFY_LOG 
    static void LogError(PCHAR szField, DWORD dwActual, DWORD dwExpected);
    static void LogError(PCHAR szField, DWORD dwActual, DWORD *pdwExpected, 
        int n);
#endif

    PIMAGE_DOS_HEADER      m_pDOSh;
    PIMAGE_NT_HEADERS      m_pNTh;
    PIMAGE_FILE_HEADER     m_pFh;
    PIMAGE_OPTIONAL_HEADER m_pOPTh;
    PIMAGE_SECTION_HEADER  m_pSh;

    RangeTree   m_ranges; // Extents of data-structures we check. Ensurew that they are mutually-exclusive
    
    size_t m_dwPrefferedBase;
    DWORD  m_nSections;
    DWORD  m_dwIATRVA;      // RVA of the single IAT entry of the image
    DWORD  m_dwRelocRVA;    // RVA where the one and only one reloc of a verifiable IL image will be applied
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\rangetree.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _RANGETREE_
#define _RANGETREE_

#include "memorypool.h"

//
// A RangeTree is a self-balancing binary tree of non-overlapping 
// ranges [start-end), which provides log N operation time for 
// lookup, insertion, and deletion of nodes.
//
// The tree is always balanced in the sense that the left and right
// sides of a node have the same amount of address space allocated to
// them - (for worst case data, the nodes of the tree might actually
// not be balanced).
//
// This address-space balancing means that if all the ranges cover a
// contiguous range of memory, and if lookup occur uniformly throughout
// the overall range covered, the tree provides optimal lookup
// structure.
//
// Another interesting property is that the same set of 
// ranges always produces the same tree layout, regardless of
// the order the nodes are added in.
// 
// Each node represents a range of the address space (in binary)
// from m0...0 to m1...1, where m is any number of 31 bits or
// less.
//
// Each node has 3 components:
//  * a range
//  * a 0-child,
//  * a 1-child
//
// The range is the numeric range [start,end),
// represented by the node.  A range is always assigned to the
// widest possible node (i.e. most bits in m) possible.  Thus the
// bits of start and end share the same prefix string m, and
// differ in the next bit after m: the start bound will have a 0
// and the end bound will have a 1 in that position.
//
// Note that any other range which is represented by the same node
// must necessarily intersect the node.  Thus, if no overlaps are
// possible, each node can only contain a single range. (To help
// see why this must be, it helps to realize that the node
// represents the transition from m01...1 to m10...0, which any
// range represented by this node must contain.)
// 
// All range nodes represented by the form m0...  are contained in
// the 0-child subtree, and all nodes represented by the form
// m1... are contained in the 1-child subtree.  Either child can
// of course be null.
//

class RangeTree
{
  public:

    //
    // Imbed the RangeTreeNode structure in your data structure
    // in order to place it into a RangeTree.
    //
    
    struct Node
    {
        friend RangeTree;

    private:
        // start & end (exclusive) of range 
        SIZE_T          start;
        SIZE_T          end;
        // mask of high-order bits which are the same in start & end
        SIZE_T          mask;

        Node            *children[2];

        Node** Child(SIZE_T address)
        {
            return &children[ ! ! (address & ((~mask>>1)+1))];
        }

    public:
        void Init(SIZE_T rangeStart, SIZE_T rangeEnd);
        Node(SIZE_T rangeStart, SIZE_T rangeEnd) { this->Init(rangeStart,rangeEnd); };

        SIZE_T GetStart() { return start; }
        SIZE_T GetEnd() { return end; }
    };

    friend Node;

    RangeTree();

    Node *Lookup(SIZE_T address);
    Node *LookupEndInclusive(SIZE_T nonStartingAddress);
    BOOL Overlaps(SIZE_T start, SIZE_T end);
    HRESULT AddNode(Node *addNode);
    HRESULT RemoveNode(Node *removeNode);

    typedef void (*IterationCallback)(Node *next);

    void Iterate(IterationCallback pCallback);

  private:

    Node *m_root;
    MemoryPool m_pool;

    Node *AddIntermediateNode(Node *node0, Node *node1);
    Node *AllocateIntermediate();
    void FreeIntermediate(Node *node);
    BOOL IsIntermediate(Node *node);

    void IterateNode(Node *node, IterationCallback pCallback);

    static SIZE_T GetRangeCommonMask(SIZE_T start, SIZE_T end);
};

#endif // _RANGETREE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\prestub.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: Prestub.cpp
//
// ===========================================================================
// This file contains the implementation for creating and using prestubs
// ===========================================================================
//

#include "common.h"
#include "vars.hpp"
#include "Security.h"
#include "eeconfig.h"
#include "compluscall.h"
#include "ndirect.h"
#include "COMDelegate.h"
#include "remoting.h"
#include "DbgInterface.h"

#include "listlock.inl"

// this file handles string conversion errors for itself
#undef  MAKE_TRANSLATIONFAILED

//==========================================================================
// This function is logically part of PreStubWorker(). The only reason
// it's broken out into a separate function is that StubLinker has a destructor
// and thus, we must put an inner COMPLUS_TRY clause to trap any
// COM+ exceptions that would otherwise bypass the StubLinker destructor.
// Because COMPLUS_TRY is based on SEH, VC won't let us use it in the
// same function that declares the StubLinker object.
//==========================================================================
Stub *MakeSecurityWorker(CPUSTUBLINKER *psl,
                         MethodDesc *pMD,
                         DWORD dwDeclFlags,
                         Stub* pRealStub,
                         LPVOID pRealAddr,
                         OBJECTREF *pThrowable)
{
    Stub *pStub = NULL;

    LOG((LF_CORDB, LL_INFO10000, "Real Stub 0x%x\n", pRealStub));
    
    COMPLUS_TRY
    {
        pStub = Security::CreateStub(psl,
                                     pMD,
                                     dwDeclFlags,
                                     pRealStub,
                                     pRealAddr);
    }
    COMPLUS_CATCH
    {
		UpdateThrowable(pThrowable);
        return NULL;
    }
    COMPLUS_END_CATCH

    return pStub;

}


//==========================================================================
// This is another function to help the PreStubWorker().  I have broken this
// out since only in the backpatch case do we need this method!
//==========================================================================
OBJECTREF GetActiveObject(PrestubMethodFrame *pPFrame)
{
    THROWSCOMPLUSEXCEPTION();


#ifdef _X86_
#if _DEBUG 

    // This check is expensive (it accesses metadata), so only do it in a checked build 
    // @todo: investigate why this was added - seantrow

    BYTE callingConvention = MetaSig::GetCallingConvention(pPFrame->GetModule(),pPFrame->GetFunction()->GetSig());

    if (!isCallConv(callingConvention, IMAGE_CEE_CS_CALLCONV_DEFAULT) &&
        !isCallConv(callingConvention, IMAGE_CEE_CS_CALLCONV_VARARG))
    {
        _ASSERTE(!"Unimplemented calling convention.");
        FATAL_EE_ERROR();
        return NULL;
    }
    else
#endif
    {
        // Now return the this pointer!
        return pPFrame->GetThis();
    }
#elif defined(CHECK_PLATFORM_BUILD)
    #error "Unimplemented platform"
#else
    _ASSERTE(!"Unimplemented platform.");
    return NULL;
#endif
}

static void DoBackpatch(MethodDesc *pMD, Stub *pstub, MethodTable *pDispatchingMT)
{
    _ASSERTE(!pMD->IsAbstract());

    // don't want to update for EditAndContinue on the jit pass through a prestub becuase
    // could be calling from ResumeInUpdatedFunction which calls PrestubWorker directly
    // so wouldn't have a current object to work from. So this would get updated to the
    // updateable stub on the next call through.
    // @perf: Note that we could ignore final methods as well, but it's too expensive
    // to access the metadata to find out.
    if (pMD->IsVtableMethod() &&
        !pMD->GetClass()->IsValueClass() &&
        !pMD->GetModule()->IsEditAndContinue() && 
        pDispatchingMT)
    {
        // Try patching up and down the hierarchy.  If this fails (e.g.
        // because of app domain unloading) then fall back on the tired old
        // single slot patch.
        if (!EEClass::PatchAggressively(pMD, (SLOT)pstub))
            {
            if ((pDispatchingMT->GetVtable())[(pMD)->GetSlot()] == (SLOT)pMD->GetPreStubAddr())
                (pDispatchingMT->GetVtable())[(pMD)->GetSlot()] = (SLOT)pstub;
        }
    }

    // Always patch the entry of the class identified by the method desc.
    // This may have already happened, but it's not worth checking.
    (pMD->GetClass()->GetMethodTable()->GetVtable())[pMD->GetSlot()] = (SLOT)pstub;
}

//==========================================================================
// This function is logically part of PreStubWorker(). The only reason
// it's broken out into a separate function is that StubLinker has a destructor
// and thus, we must put an inner COMPLUS_TRY clause to trap any
// COM+ exceptions that would otherwise bypass the StubLinker destructor.
// Because COMPLUS_TRY is based on SEH, VC won't let us use it in the
// same function that declares the StubLinker object.
//==========================================================================
Stub *MakeJitWorker(MethodDesc *pMD, COR_ILMETHOD_DECODER* ILHeader, BOOL fIntercepted, BOOL fGenerateUpdateableStub, MethodTable *pDispatchingMT, OBJECTREF *pThrowable)
{
    // ********************************************************************
    //                  README!!
    // ********************************************************************
    
    // This helper method is assumed to be thread safe!
    // If multiple threads get in here for the same pMD ALL of them
    // MUST return the SAME value for pstub.
    
    // ********************************************************************
    //                  End README!
    // ********************************************************************
   

    Stub *pstub = NULL; // CHANGE, VC6.0
    BOOL fisEJitted = FALSE;
    // complus to com calls don't really have a method desc
    _ASSERTE(!pMD->IsComPlusCall());

    // REVIEW: this fires on fstChk during profiler checkin BVTs(appdomain.exe)
    // investigate!
    // _ASSERTE(!pMD->IsPrejitted());

    _ASSERTE(pMD->GetModule());
    _ASSERTE(pMD->GetModule()->GetClassLoader());
    Assembly* pAssembly = pMD->GetModule()->GetAssembly();
    _ASSERTE(pAssembly);

    COMPLUS_TRY
    {
        if (pMD->IsIL())
        {
            DeadlockAwareLockedListElement * pEntry = NULL;
            BOOL                             bEnterLockSucceed = FALSE;
            BOOL                             fSuccess = FALSE;


            // @TODO:   (FPG)
            //      - error checking
            //      - clean up in case of error (e.g. release EHtable, infoTable, etc.)
            //      - complete setup of CodeHeader
            //      - interface methods
            //
            //

            // Enter the global lock which protects the list of all functions being JITd
            CLR_LISTLOCK_HOLDER_BEGIN(globalJitLock, pAssembly->GetJitLock())
            globalJitLock.Enter();

            // It is possible that another thread stepped in before we entered the global lock for the first time.
            if (pMD->IsJitted())
            {
                // We came in to jit but someone beat us so return the jitted method!
                globalJitLock.Leave();
                return (Stub*)pMD->GetAddrofJittedCode();
            }

            EE_TRY_FOR_FINALLY 
            {
                pEntry = (DeadlockAwareLockedListElement *) pAssembly->GetJitLock()->Find(pMD);

                // The function is not currently being jitted.
                if (pEntry == NULL)
                {
                    // Did not find an entry for this function, so create one
                    pEntry = new DeadlockAwareLockedListElement();
                    if (pEntry == NULL)
                    {
                        globalJitLock.Leave();
                        COMPlusThrowOM();
                    }

                    pEntry->AddEntryToList(pAssembly->GetJitLock(), pMD);
                    pEntry->m_hrResultCode = S_FALSE;

                    // Take the entries lock.  This should always succeed since we're holding the global lock.
                    bEnterLockSucceed = pEntry->DeadlockAwareEnter();
                    _ASSERTE(bEnterLockSucceed); 

                    pMD->GetModule()->LogMethodLoad(pMD);

                    // Leave global lock
                    globalJitLock.Leave();
                }
                else 
                {
                    // Someone else was JITing the function

                    // Refcount ourselves as waiting for it
                    pEntry->m_dwRefCount++;

                    // Leave global lock
                    globalJitLock.Leave();

                    bEnterLockSucceed = pEntry->DeadlockAwareEnter();
                    if (!bEnterLockSucceed)
                    {
                        //
                        // Taking this lock would cause a deadlock (presumably because we
                        // are involved in a class constructor circular dependency.)  For
                        // instance, another thread may be waiting to run the class constructor
                        // that we are jitting, but is currently jitting this function.
                        // 
                        // To remedy this, we want to go ahead and do the jitting anyway.
                        // The other threads contending for the lock will then notice that
                        // the jit finished while they were running class constructors, and abort their
                        // current jit effort.
                        //
                        // Anyway I guess we don't have to do anything special right here since we 
                        // can check pMD->IsJitted() to detect this case later.
                        //
                    }
                }

                // It is possible that another thread stepped in before we entered the global lock for the first time.
                if (!pMD->IsJitted())
                {

#ifdef PROFILING_SUPPORTED
                    // If profiling, need to give a chance for a tool to examine and modify
                    // the IL before it gets to the JIT.  This allows one to add probe calls for
                    // things like code coverage, performance, or whatever.
                    if (CORProfilerTrackJITInfo())
                    {
                        g_profControlBlock.pProfInterface->JITCompilationStarted((ThreadID) GetThread(),
                                                                                 (FunctionID) pMD,
                                                                                 TRUE);

                        // The profiler may have changed the code on the callback.  Need to
                        // pick up the new code.  Note that you have to be fully trusted in
                        // this mode and the code will not be verified.
                        COR_ILMETHOD *pilHeader = pMD->GetILHeader();
                        new (ILHeader) COR_ILMETHOD_DECODER(pilHeader, pMD->GetMDImport());
                    }
#endif // PROFILING_SUPPORTED

                    // which is expensive.
                    COMPLUS_TRY 
                      {
                          pstub = JITFunction(pMD, ILHeader, &fisEJitted);
                      }
                    COMPLUS_CATCH
                      {
                          // catch the jit error here so that make sure unlink our jit lock later
                          // too late if wait for outer catch
                          pstub = NULL;

                          // Don't forget the case where we aborted our jit because of a deadlock cycle that
                          // another function broke by jitting our function
                          if (!pMD->IsJitted())
                          {
                              *pThrowable = GETTHROWABLE();
                              pEntry->m_hrResultCode = E_FAIL;
                          }
                      }
                    COMPLUS_END_CATCH
                }

                if (pstub)
                {
                    if (fGenerateUpdateableStub)
                    {
                        if (UpdateableMethodStubManager::CheckIsStub(pMD->GetAddrofCode(), NULL))
                            pstub = UpdateableMethodStubManager::UpdateStub((Stub*)pMD->GetAddrofJittedCode(), (BYTE*)pstub);
                        else
                            pstub = UpdateableMethodStubManager::GenerateStub((BYTE*)pstub);
                    }

#if defined(STRESS_HEAP) && defined(_DEBUG)
                    if (fisEJitted == FALSE && (g_pConfig->GetGCStressLevel() & EEConfig::GCSTRESS_INSTR))
                        SetupGcCoverage(pMD, (BYTE*) pstub);
#endif
                    pMD->SetAddrofCode((BYTE*)pstub);

                    pEntry->m_hrResultCode = S_OK;

#ifdef PROFILING_SUPPORTED
                    // Notify the profiler that JIT completed.  Must do this after the
                    // address has been set.
                    if (CORProfilerTrackJITInfo())
                    {
                        g_profControlBlock.pProfInterface->
                        JITCompilationFinished((ThreadID) GetThread(), (FunctionID) pMD,
                                               pEntry->m_hrResultCode, !fisEJitted);
                    }
#endif // PROFILING_SUPPORTED
                }
                else if (pMD->IsJitted())
                {
                    // We came in to jit but someone beat us so return the 
                    // jitted method! 

                    // We *must* use GetAddrofJittedCode here ... 
                    // if we use the pMD->GetUnsafeAddrofCode() version, 
                    // in a race condition 2 threads can come out of this 
                    // function with different return values
                    // (eg. if ENC is ON for the assembly etc)
                    pstub = (Stub*)pMD->GetAddrofJittedCode();
                }

                fSuccess = (pstub != NULL);

            }
            EE_FINALLY 
            {
                // Now decrement refcount
                if (! globalJitLock.IsHeld())
                    globalJitLock.Enter();

                // Release the method's JIT lock, if we were able to obtain it in the first place.
                if (bEnterLockSucceed) {
                    pEntry->DeadlockAwareLeave();
                    bEnterLockSucceed = FALSE;
                }

                // If we are the last waiter, delete the entry
                if (pEntry && --pEntry->m_dwRefCount == 0)
                {
                    // Unlink item from list - in reality, anyone can do this, it doesn't have to be the last waiter.
                    pAssembly->GetJitLock()->Unlink(pEntry);

                    pEntry->Destroy();
                    delete(pEntry);
                }

                globalJitLock.Leave();
            }
            EE_END_FINALLY

            CLR_LISTLOCK_HOLDER_END(globalJitLock);

            if (fSuccess == FALSE && !*pThrowable)
            {
                FATAL_EE_ERROR();
            }

            // if this is a method of any sort then we want to backpatch the vtable this came from
            if (pstub && !fIntercepted)
            {
                DoBackpatch(pMD, pstub, pDispatchingMT);
            }
        }
        else
        {
            if (!((pMD->IsECall()) || (pMD->IsNDirect())))
                // This is a method type we don't handle yet
                FATAL_EE_ERROR();
        }
    }
    COMPLUS_CATCH
    {
        *pThrowable = GETTHROWABLE();
        return NULL;
    }
    COMPLUS_END_CATCH

    return pstub; // CHANGE, VC6.0
}

//==========================================================================
// This function is logically part of PreStubWorker(). The only reason
// it's broken out into a separate function is that StubLinker has a destructor
// and thus, we must put an inner COMPLUS_TRY clause to trap any
// COM+ exceptions that would otherwise bypass the StubLinker destructor.
// Because COMPLUS_TRY is based on SEH, VC won't let us use it in the
// same function that declares the StubLinker object.
//==========================================================================
Stub *MakeStubWorker(MethodDesc *pMD, CPUSTUBLINKER *psl, OBJECTREF *pThrowable)
{

    // Note: this should be kept idempotent ... in the sense that
    // if multiple threads get in here for the same pMD 
    // it should not matter whose stub finally gets used. This applies
    // to all the helper functions this calls!

    Stub *pstub = NULL;  // CHANGE, VC6.0

    COMPLUS_TRY
    {
        /* NOTE:
        // Check for COMPLUS call needs to be the first check
        // do not move this
        */
        if (pMD->IsComPlusCall())
        {
            pstub = ComPlusCall::GetComPlusCallMethodStub(psl, (ComPlusCallMethodDesc *)pMD);
        }
        else
        if (pMD->IsIL())
        {
            _ASSERTE(!"Could not JIT method");
            FATAL_EE_ERROR();
            pstub = 0;
        }
        else if (pMD->IsECall())
        {

            LOG((LF_LOADER, LL_INFO1000, "Made ECALL stub for method '%s.%s'\n",
                pMD->GetClass()->m_szDebugClassName,
                pMD->GetName()));
            pstub = ECall::GetECallMethodStub(psl, (ECallMethodDesc*)pMD);
        }
        else if (pMD->IsNDirect())
        {
            LOG((LF_LOADER, LL_INFO1000, "Made NDirect stub for method '%s.%s'\n",
                pMD->GetClass()->m_szDebugClassName,
                pMD->GetName()));
            pstub = NDirect::GetNDirectMethodStub(psl, (NDirectMethodDesc*)pMD);
        }
        else if (pMD->IsEEImpl())
        {
            LOG((LF_LOADER, LL_INFO1000, "Made EEImpl stub for method '%s'\n",
                pMD->GetName()));
            _ASSERTE(pMD->GetClass()->IsAnyDelegateClass());
            pstub = COMDelegate::GetInvokeMethodStub(psl, (EEImplMethodDesc*)pMD);
        }
        else
        {
            // This is a method type we don't handle yet
            FATAL_EE_ERROR();
        }

    }
    COMPLUS_CATCH
    {
		UpdateThrowable(pThrowable);
        return NULL;
    }
    COMPLUS_END_CATCH
    return pstub;  // CHANGE, VC6.0
}

// helper to replace the prestub with a more appropriate stub
void InterLockedReplacePrestub(MethodDesc* pMD, Stub* pStub)
{
    _ASSERTE(pMD != NULL);
    // At this point, we've either thrown an exception or we have a stub.
    _ASSERTE(pStub != NULL);

    // Now, try to replace ThePreStub with the stub. We have to be careful
    // here because it's possible for two threads to be running the
    // prestub simultaneously. We use InterlockCompareExchange to ensure
    // that we don't replace a previously replaced stub.

    SLOT entry = (SLOT)pStub->GetEntryPoint();

    if (setCallAddrInterlocked(((SLOT*)pMD)-1, entry, 
                               (SLOT) ThePreStub()->GetEntryPoint()) != entry)
    {
        Module *pModule = pMD->GetModule();
        
        if (!pModule->IsPreload()
            || (setCallAddrInterlocked(((SLOT*)pMD)-1, entry,
                                       (SLOT)pModule->GetPrestubJumpStub()) != entry))
        {
            // 
            // Somebody else beat us there -- throw away our stub. :-(
            //

            pStub->DecRef();
        }
    }
}

/* Make a stub that for a value class method that expects a BOXed this poitner */

// CTS: BIG hole if pMD is a method impl that has implemented more then one method
// on this value class!!!
Stub *MakeUnboxStubWorker(MethodDesc *pMD, CPUSTUBLINKER *psl, OBJECTREF *pThrowable)
{
    // Note: this should be kept idempotent ... in the sense that
    // if multiple threads get in here for the same pMD 
    // it should not matter whose stuff finally gets used.

    Stub *pstub = NULL;

    COMPLUS_TRY
    {
        MethodDesc *pUnboxedMD = pMD->GetClass()->GetMethodDescForUnboxingValueClassMethod(pMD);

        _ASSERTE(pUnboxedMD != 0 && pUnboxedMD != pMD);

        psl->EmitUnboxMethodStub(pUnboxedMD);
        pstub = psl->Link(pMD->GetClass()->GetClassLoader()->GetStubHeap());
    }
    COMPLUS_CATCH
    {
		UpdateThrowable(pThrowable);
        pstub = NULL;
    }
    COMPLUS_END_CATCH
    return pstub;
}

//=============================================================================
// This function generates the real code for a method and installs it into
// the methoddesc. Usually ***BUT NOT ALWAYS***, this function runs only once
// per methoddesc. In addition to installing the new code, this function
// returns a pointer to the new code for the prestub's convenience.
//=============================================================================
extern "C" const BYTE * __stdcall PreStubWorker(PrestubMethodFrame *pPFrame)
{
    MethodDesc *pMD = pPFrame->GetFunction();
    MethodTable *pDispatchingMT = NULL;

    if (pMD->IsVtableMethod() && !pMD->GetClass()->IsValueClass())
    {
        OBJECTREF curobj = GetActiveObject(pPFrame);
        if (curobj != 0)
            pDispatchingMT = curobj->GetMethodTable();
    }

    return pMD->DoPrestub(pDispatchingMT);
}

// Separated out the body of PreStubWorker for the case where we don't have a frame
const BYTE * MethodDesc::DoPrestub(MethodTable *pDispatchingMT)
{
#ifdef _IA64_
    _ASSERTE(!"PreStubWorker not implemented for IA64");
#endif

    BOOL bBashCall = FALSE;         // convert MD's CALL Prestub to JMP Code?
    BOOL bIsCode = FALSE;           // pStub is pointer to code, not to a Stub
    DWORD dwSecurityFlags = 0;
    BOOL   fRemotingIntercepted = 0;
    THROWSCOMPLUSEXCEPTION();
    OBJECTREF     throwable = NULL;
    BOOL fMustReturnPreStubCallAddr = FALSE;

    Stub *pStub = NULL;

    // Make sure the class is restored
    MethodTable *pMT = GetMethodTable();
    Module* pModule = GetModule();
    pMT->CheckRestore();
    
    // We better be in cooperative mode
    _ASSERTE(GetThread()->PreemptiveGCDisabled());
#ifdef _DEBUG  
    static unsigned ctr = 0;
    ctr++;

    if (g_pConfig->ShouldPrestubHalt(this))
        _ASSERTE(!"PreStubHalt");
    LOG((LF_CLASSLOADER, LL_INFO10000, "In PreStubWorker for %s::%s\n", 
                m_pszDebugClassName, m_pszDebugMethodName));
#endif
    STRESS_LOG1(LF_CLASSLOADER, LL_INFO10000, "Prestubworker: method %pM\n", this);

#ifdef STRESS_HEAP
        // Force a GC on every jit if the stress level is high enough
    if (g_pConfig->GetGCStressLevel() != 0
#ifdef _DEBUG
        && !g_pConfig->FastGCStressLevel()
#endif
        )
        g_pGCHeap->StressHeap();
#endif

    /**************************   INTEROP   *************************/
    /*-----------------------------------------------------------------
    // Some method descriptors are COMPLUS-to-COM call descriptors
    // they are not your every day method descriptors, for example
    // they don't have an IL or code, the CALL instruction above the
    // method descriptor points to a COM Interop stub that delegate the call
    */
    if (IsComPlusCall())
    {
        GCPROTECT_BEGIN(throwable);
        CPUSTUBLINKER sl;
        pStub = MakeStubWorker(this, &sl, &throwable);
        if (!pStub)
            COMPlusThrow(throwable);
        // We may need to perform a runtime security check (in which case we'll
        // indirect through yet another stub). The check is disabled if the
        // interface we're calling through is marked with a runtime check
        // suppression attribute.
        if (Security::IsSecurityOn() &&
            GetMDImport()->GetCustomAttributeByName(((ComPlusCallMethodDesc*)this)->GetInterfaceMethodTable()->GetClass()->GetCl(),
                                                         COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI,
                                                         NULL,
                                                         NULL) == S_FALSE) {
            CPUSTUBLINKER secsl;

            LOG((LF_CORDB, LL_INFO10000,
                 "::PSW: Placing security interceptor before interop stub 0x%08x\n",
                 pStub));

            pStub = MakeSecurityWorker(&secsl, this, DECLSEC_UNMNGD_ACCESS_DEMAND, pStub, (LPVOID) pStub->GetEntryPoint(), &throwable);
            if (!pStub)
            {
                COMPlusThrow(throwable);
            }
            LOG((LF_CORDB, LL_INFO10000,
                 "::PSW security interceptor stub 0x%08x\n",pStub));         
             
            // Mark the method as intercepted
            SetIntercepted(TRUE);
        }
        InterLockedReplacePrestub(this,pStub);
        GCPROTECT_END();
        //@todo debugger interaction
        return GetPreStubAddr();
    }

    /**************************   SECURITY   *************************/
    //--------------------------------------------------------------------

    // If the function desc is an method then check to see if it has security
    // properties. If it does then set the flag so the Native addr's get set
    // correctly in the Jitted case and a Security Interceptor is created.

    if(Security::IsSecurityOn())
        dwSecurityFlags = GetSecurityFlags();

    // check if remoting needs to intercept this call
    fRemotingIntercepted = IsRemotingIntercepted();


    /**************************   BACKPATCHING   *************************/
    // See if the addr of code is the pre-stub && that the method has been jitted
    if ((GetUnsafeAddrofCode() != GetPreStubAddr()) && (IsIL() || MustBeFCall()))
    {
        LOG((LF_CLASSLOADER, LL_INFO10000, "    In PreStubWorker, method already jitted, backpatching call point\n"));

        // Can we backpatch?
        // Only back packpatch here if it is a virtual call.
        if (pDispatchingMT != NULL)
        {
            // if it is not the pre stub then we are calling on this method 
            // from a vtable that hasn't been fixed up yet although we have 
            // already jitted the method - we need to backpatch

            // We should not get here for methods where the slot in
            // the method table that the MethodDesc is defined on has not
            // been backpatched.
            //
            // Actually, we cannot assert the following because of race conditions.
            // MakeJitWorker will actually do the SetAddrOfCode before it does the
            // VTable patching, so there's a small window where we might notice the
            // following is violated.
            // @TODO: LBS to investigate further.
            // _ASSERTE(pMT->GetVtable()[GetSlot()] == (SLOT)GetUnsafeAddrofCode());

            // If we have backpatched the main slot for this method.  If not,
            // do so, if so, backpatch duplicates.
            
            if ((pDispatchingMT->GetVtable())[GetSlot()] == (SLOT)GetPreStubAddr())
            {
                (pDispatchingMT->GetVtable())[GetSlot()] = (SLOT)GetAddrofJittedCode();
            }                
            else
            {
                // The location of the duplicate slots is not guaranteed to be after the 
                // slot number containing method desc if the method desc is a method impl
                // Use the information stored with the method impl to finish the backpatch
                if(IsMethodImpl()) 
                {
                    MethodImpl* pImpl = MethodImpl::GetMethodImplData(this);
                    DWORD numslots = pImpl->GetSize();
                    DWORD* slots = pImpl->GetSlots();
                    for(DWORD sl = 0; sl < numslots; sl++) 
                    {
                        if ((pDispatchingMT->GetVtable())[slots[sl]] == (SLOT)GetPreStubAddr())
                        {
                            (pDispatchingMT->GetVtable())[slots[sl]] = (SLOT)GetAddrofJittedCode();
                        }
                    }
                }
                else 
                {
                    // We have a slot in the vtable that seems to already been backpatched or
                    // is not pointing at the this method's methoddesc.
                    // We must have called through a duplicate slot
                    // Walk the vtable looking for the current methoddesc
                    // if we find it  - backpatch it!
                    int numslots = (pDispatchingMT->GetClass())->GetNumVtableSlots();
                    for( int dupslot = 0 ;dupslot < numslots ; dupslot++ )
                    {
                        if ((pDispatchingMT->GetVtable())[dupslot] == (SLOT)GetPreStubAddr())
                        {
                            (pDispatchingMT->GetVtable())[dupslot] = (SLOT)GetAddrofJittedCode();
                        }
                    }
                }
            }
        
        }
            
        const BYTE *pbDest = GetAddrofJittedCode();
        
#ifdef _X86_
        return pbDest;
#else
        _ASSERTE(!"NYI for platform");
        return 0;
#endif
    }

    // 
    // Make sure .cctor has been run
    //
    GCPROTECT_BEGIN (throwable);
    if (pMT->CheckRunClassInit(&throwable) == FALSE)
        COMPlusThrow(throwable);
    
    /**************************   CODE CREATION  *************************/
    if (IsUnboxingStub()) 
    {
        CPUSTUBLINKER sl;
        pStub = MakeUnboxStubWorker(this, &sl, &throwable);
        bBashCall = TRUE;
    }
    else if (IsIL()) 
    {

        //
        // See if we have any prejitted code to use.
        //

        if (IsPrejitted())
        {
            BOOL fShouldSearchCache = TRUE;

#ifdef PROFILING_SUPPORTED
            if (CORProfilerTrackCacheSearches())
            {
                g_profControlBlock.pProfInterface->
                    JITCachedFunctionSearchStarted((ThreadID) GetThread(), (FunctionID) this,
                                                   &fShouldSearchCache);
            }
#endif // PROFILING_SUPPORTED

            if (fShouldSearchCache == TRUE)
                pStub = (Stub *) GetPrejittedCode();

            if (pStub != NULL)
            {
                LOG((LF_ZAP, LL_INFO100000, 
                     "ZAP: Using code 0x%x for %s.%s%s (token %x).\n", 
                     pStub, 
                     m_pszDebugClassName,
                     m_pszDebugMethodName,
                     m_pszDebugMethodSignature,
                     GetMemberDef()));

                if (pStub != NULL)
                {
                    pModule->LogMethodLoad(this);

                    DWORD delayListRVA = ((DWORD*)pStub)[-1];
                    if (delayListRVA != 0)
                    {
                        pModule->FixupDelayList((DWORD *) 
                                                ((CORCOMPILE_METHOD_HEADER*)pStub)[-1].fixupList);
                    }

                    if (pModule->SupportsUpdateableMethods())
                    {
                        const BYTE *destAddr;
                        if (UpdateableMethodStubManager::CheckIsStub(GetAddrofCode(), &destAddr))
                        {
                            _ASSERTE(destAddr == (const BYTE *) pStub);
                        }
                        else
                            pStub = UpdateableMethodStubManager::GenerateStub((BYTE*)pStub);
                    }

                    SetAddrofCode((BYTE*)pStub);

                    // if this is a method of any sort then we want to backpatch the vtable this came from
                    if ((dwSecurityFlags == 0) && !fRemotingIntercepted)
                    {
                        DoBackpatch(this, pStub, pDispatchingMT);
                    }

                    bBashCall = bIsCode = TRUE;
                }

#ifdef PROFILING_SUPPORTED
                /*
                 * This notifies the profiler that a search to find a
                 * cached jitted function has been made.
                 */
                if (CORProfilerTrackCacheSearches())
                {
                    COR_PRF_JIT_CACHE reason =
                      pStub == NULL ? COR_PRF_CACHED_FUNCTION_NOT_FOUND : COR_PRF_CACHED_FUNCTION_FOUND;

                    g_profControlBlock.pProfInterface->
                        JITCachedFunctionSearchFinished((ThreadID) GetThread(), (FunctionID) this, reason);
                }
#endif // PROFILING_SUPPORTED
            }
        } //IsPrejitted()
        
        //
        // If not, try to jit it
        //

        if (pStub == NULL)
        {
            // Get the information on the method
            BOOL fMustFreeIL = FALSE;
            COR_ILMETHOD* ilHeader = GetILHeader();
			bool verify = !Security::LazyCanSkipVerification(pModule);
            COR_ILMETHOD_DECODER header(ilHeader, pModule->GetMDImport(), verify);
			if(verify && header.Code)
			{
				IMAGE_DATA_DIRECTORY dir;
				dir.VirtualAddress = GetRVA();
				dir.Size = header.CodeSize + (header.EH ? header.EH->DataSize() : 0);
				if (pModule->IsPEFile() &&
                    (FAILED(pModule->GetPEFile()->VerifyDirectory(&dir,IMAGE_SCN_MEM_WRITE))))
                        header.Code = 0;
			}
            BAD_FORMAT_ASSERT(header.Code != 0);
            if (header.Code == 0)
                COMPlusThrowHR(COR_E_BADIMAGEFORMAT);


#ifdef _VER_EE_VERIFICATION_ENABLED
            static ConfigDWORD peVerify(L"PEVerify", 0);
            if (peVerify.val())
                Verify(&header, TRUE, FALSE);   // Throws a VerifierException if verification fails
#endif 

            // JIT it
            if (g_pConfig->ShouldJitMethod(this) || g_pConfig->ShouldEJitMethod(this))
            {
                LOG((LF_CLASSLOADER, LL_INFO10000, 
                     "    In PreStubWorker, calling MakeJitWorker\n"));
    
                // MakeJit worker uses a combination of the security flag, 
                // Edit and continue flag and RemotingIntercepted flag to 
                // determine whether or not to set the return address
                // (i.e. to do backpatching).
                
                // For Edit&Continue scenario ... (i.e. pMD belongs to a module
                // which was built for Edit&Continue .. this is kind of default
                // in debug builds) this function will return a stub that has 
                // already wrapped the actual native code 
                // (in which case m_dwCodeOrIL also represents the updateable 
                // EnC stub)
                pStub = MakeJitWorker(this,
                                      &header,
                                      (dwSecurityFlags != 0) || 
                                          fRemotingIntercepted ||
                                          this->IsEnCMethod(),
                                      pModule->SupportsUpdateableMethods(),
                                      pDispatchingMT,
                                      &throwable);
                                      
                // Security and/or Remoting may want to build stubs that hold 
                // the actual Jitted stub ... eventually we do an 
                // InterlockedExchange the code at GetPreStubAddr() with a 
                // call to the 'final' (outermost) stub. 
                // The call to MakeJitWorker above had better not return 
                // the same value as GetPreStubAddr() .. or else we will 
                // end up with code with an infinite loop! (hence this assert)
                // Note: pStub may be NULL if an exception happened during JIT
                
                _ASSERTE(pStub==NULL ||
                        !IsJitted()  ||
                        (IsJitted() && (((BYTE*)pStub) != GetPreStubAddr()))
                        ); // URTBugs 74588,74825
                        
                if (!IsJitted())
                {
                    // In the rare case where a profiler causes the function to
                    // be un-jitted in the JitCompilationFinished notification
                    // we should not wrap pStub with the remoting stub ... 
                    // Since in such a case the above call will return 
                    // a mini-stub that does a "jmp GetPreStubAddr()" ... if
                    // remoting builds a stub around that we will have 
                    // the same infinite loop problem
                    fRemotingIntercepted = FALSE;

                    // REVIEW: what about security stubs?
                }
                
                bBashCall = bIsCode = TRUE;
            }

            if (fMustFreeIL)
                delete (BYTE*) header.Code;

            // We have no backup plan, if jitting fails, we are toast
        }
    }
    else    //!IsUnBoxingStub() && !IsIL() case
    {
        if (IsECall()) 
            pStub = (Stub*) FindImplForMethod(this);         // See if it is an FCALL
       
        if (pStub != 0)
        {
            if (!fRemotingIntercepted)
            {
                // backpatch the main slot.  
                pMT->GetVtable()[GetSlot()] = (SLOT) pStub;
            }
            bBashCall = bIsCode = TRUE;
        }
        else 
        {   // do all the other stubs. 
            if (IsNDirect() && (!pModule->GetSecurityDescriptor()->CanCallUnmanagedCode(&throwable)))
                COMPlusThrow(throwable);
            CPUSTUBLINKER sl;
            pStub = MakeStubWorker(this, &sl, &throwable);
            fMustReturnPreStubCallAddr = TRUE;
        }
    }

    /**************************   CLEANUP / POSTJIT *************************/
    if (!pStub)
        COMPlusThrow(throwable);

    
    // Lets check to see if we need declarative security on this stub, If we have
    // security checks on this method or class then we need to add an intermediate
    // stub that performs declarative checks prior to calling the real stub.
    if(dwSecurityFlags != 0) {
        CPUSTUBLINKER sl;

        LOG((LF_CORDB, LL_INFO10000,
             "::PSW: Placing security interceptor before real stub 0x%08x\n",
             pStub));

        Stub *pCurrentStub = pStub;
        if(bIsCode)
            pStub = MakeSecurityWorker(&sl, this, dwSecurityFlags, NULL, (LPVOID) pStub, &throwable);
        else
            pStub = MakeSecurityWorker(&sl, this, dwSecurityFlags, pStub, (LPVOID) pStub->GetEntryPoint(), &throwable);
        if (!pStub)
        {
            // If there's no throwable, it's just MakeSecurityWorker telling us
            // (in the case where we're wrapping jitted code) that there was no
            // need to create an interceptor after all.
            if (throwable == NULL)
            {
                _ASSERTE(bIsCode);
                pStub = pCurrentStub;
            }
            else
                COMPlusThrow(throwable);
        }

        LOG((LF_CORDB, LL_INFO10000,
             "::PSW security interceptor stub 0x%08x\n",pStub));            
       
        // Check if a security interceptor was indeed created
        if (pCurrentStub != pStub)
        {
            bBashCall = bIsCode = FALSE;
        }
        else
            // We already marked the method as intercepted speculatively, back
            // out from that decision. Any caller that saw the intermediate
            // value will just go through a harmless extra level of indirection.
            SetIntercepted(FALSE);
    }

    // check for MarshalByRef scenarios ... we need to intercept
    // Non-virtual calls on MarshalByRef types
    if (fRemotingIntercepted)
    {   
        Stub* pCurrentStub = pStub;
        // find the actual address to jump to
        LPVOID pvAddrOfCode = (bIsCode) ? (LPVOID)pStub : (LPVOID)pStub->GetEntryPoint();
        Stub* pInnerStub  = (bIsCode) ? NULL : pStub;
        
        // let us setup a remoting stub to intercept all the calls
        pStub = CRemotingServices::GetStubForNonVirtualMethod(this, pvAddrOfCode, pInnerStub); // throws

        if (pCurrentStub != pStub)
        {
            bBashCall = bIsCode = FALSE;
            fMustReturnPreStubCallAddr = TRUE;
        }
    }

    //************************  BACKPATCH THE PRESTUB CALL AREA ************
    if (!bBashCall)
    {
        // Function was something other than an IL or an FCall.
        // Replace "call prestub" with "call realstub"

#ifdef DEBUGGING_SUPPORTED
        //
        // Tell the debugger that the function is now ready to run.
        //
        if ((g_pDebugInterface != NULL) && (IsIL()))
            g_pDebugInterface->FunctionStubInitialized(this, (const BYTE *)pStub);
#endif // DEBUGGING_SUPPORTED

        LOG((LF_CORDB, LL_EVERYTHING,
             "Backpatching prestub call to 0x%08x for %s::%s\n", pStub,
             (m_pszDebugClassName!=NULL)?(m_pszDebugClassName):("<Global Namespace>"),
             m_pszDebugMethodName));
        
        InterLockedReplacePrestub(this,pStub);
    }
    else
    {
        size_t   codeAddr = 0;

        if (IsUnboxingStub())
        {
            codeAddr = (size_t) pStub->GetEntryPoint();
        }
        else if (IsJitted())
        {
            // The profiler can cause the IL function to become unjitted again:
            // The above test checks to see if that happened. The control flow
            // paths probably need to be rethought here...
            codeAddr = (size_t)GetAddrofJittedCode();
        }

        if (codeAddr != 0)
        {
    
#ifdef _X86_
            // Function was an IL or an FCall.
            // Replace "call prestub" with "jmp code"
    
    
            _ASSERTE(sizeof(StubCallInstrs) == 8);
            StubCallInstrs *pStubCallInstrs = GetStubCallInstrs();
            _ASSERTE( (((size_t)pStubCallInstrs) & 7) == 0);
            UINT64 oldvalue = *(UINT64*)pStubCallInstrs;
            UINT64 newvalue = oldvalue;
            ((StubCallInstrs*)&newvalue)->m_op = 0xe9;  //JMP NEAR32
            ((StubCallInstrs*)&newvalue)->m_target = (UINT32)(codeAddr - ((size_t) (1 + &(pStubCallInstrs->m_target))));
    
    
#if 1 
            if (ProcessorFeatures::SafeIsProcessorFeaturePresent(PF_COMPARE_EXCHANGE_DOUBLE, FALSE) &&
                !(DbgRandomOnExe(0.9)) 
                )
            {
                __asm
                {

                    push    ebx
                    push    esi
                    
                    ;; load old value (comparator)  
                    mov     eax, dword ptr [oldvalue]
                    mov     edx, dword ptr [oldvalue + 4]
    
    
                    ;; load new value
                    mov     ebx, dword ptr [newvalue]
                    mov     ecx, dword ptr [newvalue + 4]
                    
                    ;; atomic exchange
                    mov     esi, dword ptr [pStubCallInstrs]
                    lock    cmpxchg8b qword ptr [esi]
    
                    pop     esi
                    pop     ebx
                }
            }
            else
            {
				// This is the less preferred way to do the atomic update
				// (less preferred because it can cause rare spurious privileged
				// instruction faults that can be a nuisance for people
				// trapping first-chance exceptions.) This path is used
				// for processors that lack the cmpxch8b instruction.

                // To fake an atomic update, we do the following.
                // First, we replace the "call" instruction with a "hlt".
                // Then, we overwrite the target address.
                // Then, we replace the "hlt" with the final transfer opcode
                //  (which is either a jump or a call.)
                //
                // If during the one instruction window, we lose our timeslice
                // and another thread tries to execute the same method, it will
                // hit the "hlt" instruction.
                //
                // Our exception handler will notice that this has happened,
                // and spin a few times, giving up its timeslice to give _this_
                // thread a chance to complete the update.

                __asm
                {
                    mov       eax, dword ptr [newvalue]
                    mov       edx, dword ptr [newvalue + 4]
                    and       eax, 0x00ffffff
                    or        eax, 0xf4000000
                    mov       ecx, [pStubCallInstrs]
                    mov       dword ptr [ecx],eax
                    mov       dword ptr [ecx+4],edx
                    mov       eax, dword ptr [newvalue]
                    mov       dword ptr [ecx],eax
    
                }
            }
#endif // 1
#endif // _X86_
        }
    }



    GCPROTECT_END();

    if (fMustReturnPreStubCallAddr)
    {
        return GetPreStubAddr();
    }
    else
    {
        // REVIEW: we hit this assert for some cases on fstchk when 
        // m_codeOrIL==0xFFFFFFFF ? I am checking this in commented out.
        // This happened during caspol -security ON etc at prepBVT time.
        // _ASSERTE(GetAddrofJittedCode() == GetUnsafeAddrofCode());
        return GetUnsafeAddrofCode();
    }        
}

//==========================================================================
// The following code manages the PreStub. All method stubs initially
// use the prestub. Note that method's do not IncRef the prestub as they
// do their regular stubs. This PreStub is permanent.
//==========================================================================
static Stub *g_preStub = NULL;
static Stub *g_UMThunkPreStub = NULL;

//-----------------------------------------------------------
// Stub manager for the prestub.  Although there is just one, it has
// unique behavior so it gets its own stub manager.
//-----------------------------------------------------------

class ThePreStubManager : public StubManager
{
  public:
    ThePreStubManager(const BYTE *address) : m_prestubAddress(address) {}

    BOOL CheckIsStub(const BYTE *stubStartAddress)
    {
        return stubStartAddress == m_prestubAddress;
    }

    BOOL DoTraceStub(const BYTE *stubStartAddress, TraceDestination *trace)
    {
        //
        // We cannot tell where the stub will end up
        // until after the prestub worker has been run.
        //

        Stub *stub = Stub::RecoverStub((const BYTE *)stubStartAddress);

        trace->type = TRACE_FRAME_PUSH;
        trace->address = ((const BYTE*) stubStartAddress) + stub->GetPatchOffset();

        return TRUE;
    }
    MethodDesc *Entry2MethodDesc(const BYTE *stubStartAddress, MethodTable *pMT) {return NULL;}
    const BYTE *m_prestubAddress;

    static ThePreStubManager *g_pManager;

    static BOOL Init()
    {
        //
        // Add the prestub manager
        //

        g_pManager = new ThePreStubManager((const BYTE *) g_preStub->GetEntryPoint());
        if (g_pManager == NULL)
            return FALSE;

        StubManager::AddStubManager(g_pManager);

        return TRUE;
    }

#ifdef SHOULD_WE_CLEANUP
    static void Uninit()
    {
        delete g_pManager;
    }
#endif /* SHOULD_WE_CLEANUP */
};

ThePreStubManager *ThePreStubManager::g_pManager = NULL;

//-----------------------------------------------------------
// Initialize the prestub.
//-----------------------------------------------------------
BOOL InitPreStubManager()
{
#ifdef _X86_


    // Because we're at bootup time, we can't officially use COMPLUS_TRY, but
    // we use a slimy hack to grant us special dispensation to use the StubLinker
    // object at this time. In short, we use the global g_fPrestubCreated variable
    // to turn attempts to throw COM+ exceptions into a simple RaiseException call
    // which we trap using raw Win32 SEH.
    __try {

        CPUSTUBLINKER *psl = NewCPUSTUBLINKER();

        psl->EmitMethodStubProlog(PrestubMethodFrame::GetMethodFrameVPtr());

        // push the new frame as an argument and call PreStubWorker.
        psl->X86EmitPushReg(kESI);
        psl->X86EmitCall(psl->NewExternalCodeLabel(PreStubWorker), 4);

        // eax now contains replacement stub. PreStubWorker will never return
        // NULL (it throws an exception if stub creation fails.)

        // Debugger patch location
        psl->EmitPatchLabel();

        // mov [ebx + Thread.GetFrame()], edi  ;; restore previous frame
        psl->X86EmitIndexRegStore(kEBX, Thread::GetOffsetOfCurrentFrame(), kEDI);

        // Save the replacement stuff in the space that Frame.Next used to occupy
        psl->X86EmitIndexRegStore(kESI, sizeof(Frame) - sizeof(LPVOID), kEAX);

        // Pop ArgumentRegisters structure, while restoring the actual
        // machine registers.
        #define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname) psl->X86EmitPopReg(k##regname);
        #include "eecallconv.h"

        // !!! From here on, mustn't trash eax, ecx or edx.

#ifdef _DEBUG
        // Deallocate VC stack trace info
        psl->X86EmitAddEsp(sizeof(VC5Frame));
#endif

        //--------------------------------------------------------------------------
        // Pop CalleeSavedRegisters structure, while restoring the actual machine registers.
        //--------------------------------------------------------------------------
        psl->X86EmitPopReg(kEDI);
        psl->X86EmitPopReg(kESI);
        psl->X86EmitPopReg(kEBX);
        psl->X86EmitPopReg(kEBP);

        //--------------------------------------------------------------------------
        //!!! From here on, can't trash ANY register other than esp & eip.
        //--------------------------------------------------------------------------

        // Pop off the Frame structure *except* for the "next" field
        // which has been overwritten with the new address to jump to.
        psl->X86EmitAddEsp(sizeof(Frame) - sizeof(LPVOID));

        // Pop off methodref - this allows us to remove pop ecx from the jitted code
        //   pop dword ptr [esp]
        psl->Emit8(0x8f);
        psl->Emit16(0x2404);

        // Now, jump to the new address.
        //    retn
        psl->Emit8(0xc3);


        g_preStub = psl->Link();
        delete psl;


        g_UMThunkPreStub = GenerateUMThunkPrestub();

    } __except(GetExceptionCode() == BOOTUP_EXCEPTION_COMPLUS ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

        // If we got here, StubLinker tried to throw some COM+ exception which we intercepted
        // through some slimy hacks. The only plausible exception for StubLinker to throw
        // is out of memory. In any case, we're in no position to do elaborate error handling
        // at this stage so just fail the COM+ init.

        return FALSE;
    }
#elif defined(_IA64_)

    //
    // @TODO_IA64: this should be separated out into a platform specific file
    // and implemented for IA64
    //

    g_preStub           = (Stub*)0xBAAD;
    g_UMThunkPreStub    = (Stub*)0xBAAD;

    return TRUE;
#else
    _ASSERTE(!"@TODO Alpha - InitPreStubManager (Class.cpp)");
    return FALSE;
#endif

    ThePreStubManager::Init();

    return TRUE;
}


//-----------------------------------------------------------
// Destroy the prestub.
//-----------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
VOID
TerminatePreStubManager()
{
    if (g_preStub)
    {
        ThePreStubManager::Uninit();

        // This had better go away
        BOOL PrestubWasDeleted = g_preStub->DecRef();

        _ASSERTE(PrestubWasDeleted);

        g_UMThunkPreStub->DecRef();
        
        g_preStub = NULL;
    }
}
#endif /* SHOULD_WE_CLEANUP */


//-----------------------------------------------------------
// Access the prestub (NO incref.)
//-----------------------------------------------------------
Stub *ThePreStub()
{
    return g_preStub;
}

Stub *TheUMThunkPreStub()
{
    return g_UMThunkPreStub;
}

void CallDefaultConstructor(OBJECTREF ref)
{
    THROWSCOMPLUSEXCEPTION();

    MethodTable *pMT = ref->GetTrueMethodTable();

    if (!pMT->HasDefaultConstructor())
    {
		#define MAKE_TRANSLATIONFAILED wzMethodName=L""
        MAKE_WIDEPTR_FROMUTF8_FORPRINT(wzMethodName, COR_CTOR_METHOD_NAME);
		#undef MAKE_TRANSLATIONFAILED
        COMPlusThrowNonLocalized(kMissingMethodException, wzMethodName);
    }

    MethodDesc *pMD = pMT->GetDefaultConstructor();

    static MetaSig *sig = NULL;
    if (sig == NULL)
    {
        // Allocate a metasig to use for all default constructors.
        void *tempSpace = SystemDomain::Loader()->GetHighFrequencyHeap()->AllocMem(sizeof(MetaSig));
        sig = new (tempSpace) MetaSig(gsig_IM_RetVoid.GetBinarySig(), SystemDomain::SystemModule());
    }

    INT64 arg = ObjToInt64(ref);

    pMD->Call(&arg, sig);
}

//
// NOTE: Please don't call this method.  It binds to the constructor
// by doing name lookup, which is very expensive.
//
INT64 CallConstructor(LPHARDCODEDMETASIG szMetaSig, const BYTE *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF pThis = ObjectToOBJECTREF (*(Object **) pArgs);

    _ASSERTE(pThis != 0 && "about to call a null pointer, guess what's going to happen next");

    MethodDesc *pMD = pThis->GetTrueClass()->FindMethod(COR_CTOR_METHOD_NAME, szMetaSig);
    if (!pMD)
    {
		#define MAKE_TRANSLATIONFAILED wzMethodName=L""
        MAKE_WIDEPTR_FROMUTF8_FORPRINT(wzMethodName, COR_CTOR_METHOD_NAME);
		#undef MAKE_TRANSLATIONFAILED
        COMPlusThrowNonLocalized(kMissingMethodException, wzMethodName);
    }
    MetaSig sig(pMD->GetSig(),pMD->GetModule());
    return pMD->Call(pArgs,&sig);
}

INT64 CallConstructor(LPHARDCODEDMETASIG szMetaSig, const __int64 *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF pThis = Int64ToObj(pArgs[0]);

    _ASSERTE(pThis != 0 && "about to call a null pointer, guess what's going to happen next");

    MethodDesc *pMD = pThis->GetTrueClass()->FindMethod(COR_CTOR_METHOD_NAME, szMetaSig);
    if (!pMD)
    {
		#define MAKE_TRANSLATIONFAILED wzMethodName=L""
        MAKE_WIDEPTR_FROMUTF8_FORPRINT(wzMethodName, COR_CTOR_METHOD_NAME);
		#undef MAKE_TRANSLATIONFAILED
        COMPlusThrowNonLocalized(kMissingMethodException, wzMethodName);
    }
    return pMD->Call(pArgs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\rangetree.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"

#include "rangetree.h"
#include "eeconfig.h"

void RangeTree::Node::Init(SIZE_T rangeStart, SIZE_T rangeEnd)
{
    start = rangeStart;
    end = rangeEnd;
            
    mask = GetRangeCommonMask(rangeStart, rangeEnd);

    children[0] = NULL;
    children[1] = NULL;
}


RangeTree::RangeTree() : 
  m_root(NULL), m_pool(sizeof(Node), 10) 
{
}

RangeTree::Node *RangeTree::Lookup(SIZE_T address)
{
    Node *node = m_root;

    //
    // When comparing an address to a node,
    // there are 5 possibilities:
    // * the node is null - no match
    // * the address doesn't contain the prefix m - no match
    // * the address is inside the node's range (and necessarily
    //   contains the prefix m) - match
    // * the address is less than the range (and necessarily
    //   has the prefix m0) - traverse the zero child
    // * the address is greater than the range (and necessarily
    //   has the prefix m1) - traverse the one child
    //
            
    while (node != NULL
           && (address < node->start || address >= node->end))
    {
        //
        // See if the address has prefix m.
        //

        if ((address & node->mask) != (node->start & node->mask))
            return NULL;

        //
        // Determine which subnode to look in.
        //

        node = *node->Child(address);
    }

    if (IsIntermediate(node))
        node = NULL;

    return node;
}

RangeTree::Node *RangeTree::LookupEndInclusive(SIZE_T address)
{
    //
    // Lookup an address which may be the ending range
    // of a node.  In order for this to make sense, it
    // must be the case that address is never the starting
    // address of the node.  (Otherwise there is an 
    // ambiguity when 2 nodes are adjacent.)
    //

    Node *result = Lookup(address-1);

    if (address >= result->start
        && address <= result->end)
        return result;
    else
        return NULL;
}

BOOL RangeTree::Overlaps(SIZE_T start, SIZE_T end)
{
    Node **nodePtr = &m_root;

    SIZE_T mask = GetRangeCommonMask(start, end);

    while (TRUE)
    {
        Node *node = *nodePtr;

        if (node == NULL)
            return FALSE;

        //
        // See if the range intersects
        //

        if (end > node->start 
            && start < node->end
            && !IsIntermediate(node))
            return TRUE;

        //
        // If our mask is a subset of the current mask, and the
        // bits match, continue the tree traversal.
        //

        if (node->mask != mask
            && (node->mask & ~mask) == 0
            && (start & node->mask) == (node->start & node->mask))
        {
            nodePtr = node->Child(start);
        }
        else
            return FALSE;
    }
}

HRESULT RangeTree::AddNode(Node *addNode)
{
    if (addNode == NULL)
       return E_INVALIDARG;

    _ASSERTE(addNode->end > addNode->start);

    Node **nodePtr = &m_root;

    while (TRUE)
    {
        Node *node = *nodePtr;

        //
        // See if we can live here
        //

        if (node == NULL)
        {
            *nodePtr = addNode;
            return S_OK;
        }

        //
        // Make sure the range doesn't intersect.
        //

        if (!IsIntermediate(node)
            && addNode->end > node->start
            && addNode->start < node->end)
        {
            BAD_FORMAT_ASSERT(!"Overlapping ranges added to rangetree");
            return E_INVALIDARG;
        }

        //
        // Decide if we are a child of the
        // current node, or it is a child
        // of us, or neither.
        //

        if (node->mask == addNode->mask)
        {
            //
            // See if we need to replace a intermediate node.
            //

            if ((addNode->start & node->mask) == (node->start & node->mask))
            {
                _ASSERTE(IsIntermediate(node));

                addNode->children[0] = node->children[0];
                addNode->children[1] = node->children[1];
                *nodePtr = addNode;
                FreeIntermediate(node);

                return S_OK;
            }
        }
        else if ((node->mask & ~addNode->mask) == 0)
        {
            if ((addNode->start & node->mask) == (node->start & node->mask))
            {
                nodePtr = node->Child(addNode->start);
                continue;
            }
        }
        else if ((addNode->mask & ~node->mask) == 0)
        {
            if ((addNode->start & addNode->mask) == (node->start & addNode->mask))
            {
                *nodePtr = addNode;
                nodePtr = addNode->Child(node->start);
                addNode = node;
                continue;
            }
        }
                
        //
        // We need to construct a intermediate node to be the parent of these
        // two.
        //

        *nodePtr = AddIntermediateNode(node, addNode);
        if (*nodePtr == NULL)
        {
            // @todo: data structure is hosed at this point - should
            // we undo the operation?
            return E_OUTOFMEMORY;
        }
        else
            return S_OK;
    }
}

HRESULT RangeTree::RemoveNode(Node *removeNode)
{
    Node **nodePtr = &m_root;

    while (TRUE)
    {
        Node *node = *nodePtr;

        _ASSERTE(node != NULL);

        if (node == removeNode)
        {
            if (node->children[0] == NULL)
                *nodePtr = node->children[1];
            else if (node->children[1] == NULL)
                *nodePtr = node->children[0];
            else
            {
                *nodePtr = AddIntermediateNode(node->children[0], 
                                               node->children[1]);
                if (*nodePtr == NULL)
                {
                    // @todo: data structure is hosed at this point - should
                    // we undo the operation?
                    return E_OUTOFMEMORY;
                }
            }
        }
        else if (IsIntermediate(node))
        {
            if (node->children[0] == removeNode)
            {
                *nodePtr = node->children[1];
                FreeIntermediate(node);
                return S_OK;
            }
            else if (node->children[1] == removeNode)
            {
                *nodePtr = node->children[0];
                FreeIntermediate(node);
                return S_OK;
            }
        }

        nodePtr = node->Child(removeNode->start);
    }
}

void RangeTree::Iterate(IterationCallback pCallback)
{
    if (m_root != NULL)
        IterateNode(m_root, pCallback);
}

void RangeTree::IterateNode(Node *node, IterationCallback pCallback)
{
    if (node->children[0] != NULL)
        IterateNode(node->children[0], pCallback);

    if (!IsIntermediate(node))
        pCallback(node);

    if (node->children[1] != NULL)
        IterateNode(node->children[1], pCallback);
}

SIZE_T RangeTree::GetRangeCommonMask(SIZE_T start, SIZE_T end)
{
    //
    // Compute which bits are different
    //

    SIZE_T diff = start ^ end;

        //
        // Find the highest order 1 bit - use a binary
        // search method of shifting over N bits
        // & seeing if the result is zero or not.
        //

    int index = 0;
    int half = sizeof(diff) * 8;

    do
    {
        half >>= 1;
        SIZE_T test = diff >> half;
        if (test != 0)
        {
            index += half;
            diff = test;
        }
    }
    while (half > 0);

    // Special case this boundary condition, as << wraps around on x86,
    // (i.e. (1<<32) -> 1 rather than 0)
    if (index == 0x1f)
        return 0;
    else
        return ~((1<<(index+1))-1);
}

RangeTree::Node *RangeTree::AddIntermediateNode(Node *node0, 
                                                Node *node1)
{
    SIZE_T mask = GetRangeCommonMask(node0->start,
                                  node1->start);
                
    _ASSERTE((mask & ~node0->mask) == 0);
    _ASSERTE((mask & ~node1->mask) == 0);
    _ASSERTE((node0->start & mask) == (node1->start & mask));
    _ASSERTE((node0->start & mask) == (node1->start & mask));
                
    SIZE_T middle = (node0->start & mask) + (~mask>>1);
                
    Node *intermediate = AllocateIntermediate();
    intermediate->start = middle;
    intermediate->end = middle+1;
    intermediate->mask = mask;
                
    int less = (node0->start < node1->start);

    intermediate->children[!less] = node0;
    intermediate->children[less] = node1;

    return intermediate;
}

RangeTree::Node *RangeTree::AllocateIntermediate()
{
    return (RangeTree::Node *) m_pool.AllocateElement();
}

void RangeTree::FreeIntermediate(Node *node)
{
    m_pool.FreeElement(node);
}

BOOL RangeTree::IsIntermediate(Node *node)
{
    return m_pool.IsElement(node);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\proftoeeinterfaceimpl.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ProfToEEInterfaceImpl.cpp
//
// This module contains the code used by the Profiler to communicate with
// the EE.  This allows the Profiler DLL to get access to private EE data
// structures and other things that should never be exported outside of
// mscoree.dll.
//
//*****************************************************************************
#include "common.h"
#include <PostError.h>
#include "ProfToEEInterfaceImpl.h"
#include "icecap.h"
#include "ndirect.h"
#include "Threads.h"
#include "method.hpp"
#include "Vars.hpp"
#include "DbgInterface.h"
#include "corprof.h"
#include "class.h"
#include "object.h"
#include "ejitmgr.h"
#include "ceegen.h"

//********** Code. ************************************************************

UINT_PTR __stdcall DefaultFunctionIDMapper(FunctionID funcId, BOOL *pbHookFunction)
{
    *pbHookFunction = TRUE;
    return ((UINT) funcId);
}
FunctionIDMapper *g_pFuncIDMapper = &DefaultFunctionIDMapper;


#ifdef PROFILING_SUPPORTED
ProfToEEInterfaceImpl::ProfToEEInterfaceImpl() :
    m_pHeapList(NULL)
{
}

HRESULT ProfToEEInterfaceImpl::Init()
{
    return (S_OK);
}

void ProfToEEInterfaceImpl::Terminate()
{
    while (m_pHeapList)
    {
        HeapList *pDel = m_pHeapList;
        m_pHeapList = m_pHeapList->m_pNext;
        delete pDel;
    }

    // Terminate is called from another DLL, so we need to delete ourselves.
    delete this;
}

bool ProfToEEInterfaceImpl::SetEventMask(DWORD dwEventMask)
{
    // If we're not in initialization or shutdown, make sure profiler is
    // not trying to set an immutable attribute
    if (g_profStatus != profInInit)
    {
        if ((dwEventMask & COR_PRF_MONITOR_IMMUTABLE) !=
            (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_IMMUTABLE))
        {
            return (false);
        }
    }

    // Now save the modified masks
    g_profControlBlock.dwControlFlags = dwEventMask;

    if (g_profStatus == profInInit)
    {
        // If the profiler has requested remoting cookies so that it can
        // track logical call stacks, then we must initialize the cookie
        // template.
        if (CORProfilerTrackRemotingCookie())
        {
            HRESULT hr = g_profControlBlock.pProfInterface->InitGUID();

            if (FAILED(hr))
                return (false);
        }

        // If the profiler has requested that inproc debugging be enabled,
        // turn on the various support facilities
        if (CORProfilerInprocEnabled())
        {
            SetEnterLeaveFunctionHooks(g_profControlBlock.pEnter,
                                       g_profControlBlock.pLeave,
                                       g_profControlBlock.pTailcall);
        }
    }

    // Return success
    return (true);
}

void ProfToEEInterfaceImpl::DisablePreemptiveGC(ThreadID threadId)
{
    ((Thread *)threadId)->DisablePreemptiveGC();
}

void ProfToEEInterfaceImpl::EnablePreemptiveGC(ThreadID threadId)
{
    ((Thread *)threadId)->EnablePreemptiveGC();
}

BOOL ProfToEEInterfaceImpl::PreemptiveGCDisabled(ThreadID threadId)
{
    return ((Thread *)threadId)->PreemptiveGCDisabled();
}

HRESULT ProfToEEInterfaceImpl::GetHandleFromThread(ThreadID threadId, HANDLE *phThread)
{
    HRESULT hr = S_OK;

    HANDLE hThread = ((Thread *)threadId)->GetThreadHandle();

    if (hThread == INVALID_HANDLE_VALUE)
        hr = E_INVALIDARG;

    else if (phThread)
        *phThread = hThread;

    return (hr);
}

HRESULT ProfToEEInterfaceImpl::GetObjectSize(ObjectID objectId, ULONG *pcSize)
{
    // Get the object pointer
    Object *pObj = reinterpret_cast<Object *>(objectId);

    // Get the size
    if (pcSize)
        *pcSize = (ULONG) pObj->GetSize();

    // Indicate success
    return (S_OK);
}

HRESULT ProfToEEInterfaceImpl::IsArrayClass(
    /* [in] */  ClassID classId,
    /* [out] */ CorElementType *pBaseElemType,
    /* [out] */ ClassID *pBaseClassId,
    /* [out] */ ULONG   *pcRank)
{
    _ASSERTE(classId != NULL);
    TypeHandle th((void *)classId);

    // If this is indeed an array class, get some info about it
    if (th.IsArray())
    {
        // This is actually an array, so cast it up
        ArrayTypeDesc *pArr = th.AsArray();

        // Fill in the type if they want it
        if (pBaseElemType != NULL)
            *pBaseElemType = pArr->GetElementTypeHandle().GetNormCorElementType();

        // If this is an array of classes and they wish to have the base type
        // If there is no associated class with this type, then there's no problem
        // because AsClass returns NULL which is the default we want to return in
        // this case.
        if (pBaseClassId != NULL)
            *pBaseClassId = (ClassID) pArr->GetTypeParam().AsPtr();

        // If they want the number of dimensions of the array
        if (pcRank != NULL)
            *pcRank = (ULONG) pArr->GetRank();

        // S_OK indicates that this was indeed an array
        return (S_OK);
    }
    else if (!th.IsTypeDesc() && th.AsClass()->IsArrayClass())
    {
        ArrayClass *pArr = (ArrayClass *)th.AsClass();

        // Fill in the type if they want it
        if (pBaseElemType != NULL)
            *pBaseElemType = pArr->GetElementType();

        // If this is an array of classes and they wish to have the base type
        // If there is no associated class with this type, then there's no problem
        // because AsClass returns NULL which is the default we want to return in
        // this case.
        if (pBaseClassId != NULL)
            *pBaseClassId = (ClassID) pArr->GetElementTypeHandle().AsPtr();

        // If they want the number of dimensions of the array
        if (pcRank != NULL)
            *pcRank = (ULONG) pArr->GetRank();

        // S_OK indicates that this was indeed an array
        return (S_OK);
    }

    // This is not an array, S_FALSE indicates so.
    else
        return (S_FALSE);

}

HRESULT ProfToEEInterfaceImpl::GetThreadInfo(ThreadID threadId, DWORD *pdwWin32ThreadId)
{
    if (pdwWin32ThreadId)
        *pdwWin32ThreadId = ((Thread *)threadId)->GetThreadId();

    return (S_OK);
}

HRESULT ProfToEEInterfaceImpl::GetCurrentThreadID(ThreadID *pThreadId)
{
    HRESULT hr = S_OK;

    // No longer assert that GetThread doesn't return NULL, since callbacks
    // can now occur on non-managed threads (such as the GC helper threads)
    Thread *pThread = GetThread();

    // If pThread is null, then the thread has never run managed code and
    // so has no ThreadID
    if (pThread == NULL)
        hr = CORPROF_E_NOT_MANAGED_THREAD;

    // Only provide value if they want it
    else if (pThreadId)
        *pThreadId = (ThreadID) pThread;

    return (hr);
}

HRESULT ProfToEEInterfaceImpl::GetFunctionFromIP(LPCBYTE ip, FunctionID *pFunctionId)
{
    HRESULT hr = S_OK;

    // Get the JIT manager for the current IP
    IJitManager *pJitMan = ExecutionManager::FindJitMan((SLOT)ip);

    // We got a JIT manager that claims to own the IP
    if (pJitMan != NULL)
    {
        // Get the FunctionDesc for the current IP from the JIT manager
        MethodDesc *pMethodDesc = pJitMan->JitCode2MethodDesc((SLOT)ip);

        // I believe that if a JIT manager claims to own an IP then it should also
        // always return a MethodDesc corresponding to the IP
        _ASSERTE(pMethodDesc != NULL);

        // Only fill out the value if they want one
        if (pFunctionId)
            *pFunctionId = (FunctionID) pMethodDesc;
    }

    // IP does not belong to a JIT manager
    else
        hr = E_FAIL;
    
    return (hr);
}

//*****************************************************************************
// Given a function id, retrieve the metadata token and a reader api that
// can be used against the token.
//*****************************************************************************
HRESULT ProfToEEInterfaceImpl::GetTokenFromFunction(
    FunctionID  functionId, 
    REFIID      riid,
    IUnknown    **ppOut,
    mdToken     *pToken)
{
    HRESULT     hr = S_OK;

    // Just cast it to what it really is
    MethodDesc *pMDesc = (MethodDesc *)functionId;
    _ASSERTE(pMDesc != NULL);

    // Ask for the importer interfaces from the metadata, and then QI
    // for the requested guy.
    Module *pMod = pMDesc->GetModule();
    IMetaDataImport *pImport = pMod->GetImporter();
    _ASSERTE(pImport);

    if (ppOut)
    {
        // Get the requested interface
        hr = pImport->QueryInterface(riid, (void **) ppOut);
    }

    // Provide the metadata token if necessary
    if (pToken)
    {
        *pToken = pMDesc->GetMemberDef();
        _ASSERTE(*pToken != mdMethodDefNil);

        if (!pToken)
            hr = CORPROF_E_DATAINCOMPLETE;
    }

    return (hr);
}

//*****************************************************************************
// Gets the location and size of a jitted function
//*****************************************************************************
HRESULT ProfToEEInterfaceImpl::GetCodeInfo(FunctionID functionId, LPCBYTE *pStart, ULONG *pcSize)
{
    HRESULT hr = S_OK;

    // Just cast it to what it really is
    MethodDesc *pMDesc = (MethodDesc *)functionId;
    _ASSERTE(pMDesc != NULL);

    ///////////////////////////////////
    // Get the start of the function

    // Need to make sure that pStart isn't null because it's needed in obtaining the size of the method too
    LPCBYTE start;
    if (pStart == NULL)
        pStart = &start;

    // If the function isn't jitted, can't get any info on it.
    if (!pMDesc->IsJitted())
    {
        hr = CORPROF_E_FUNCTION_NOT_COMPILED;
        goto ErrExit;
    }

    // Get the start address of the jitted method
    else
        *pStart = pMDesc->GetNativeAddrofCode();

    ///////////////////////////////////////////
    // Now get the size of the jitted method

    if (pcSize)
    {
        // Now get the JIT manager for the function
        IJitManager *pEEJM = ExecutionManager::FindJitMan((SLOT)*pStart);
        _ASSERTE(pEEJM != NULL);

        if (pEEJM->SupportsPitching() && EconoJitManager::IsCodePitched(*pStart))
        {
            hr = CORPROF_E_FUNCTION_NOT_COMPILED;
            goto ErrExit;
        }

        {
            METHODTOKEN methodtoken;
            DWORD relOffset;
            pEEJM->JitCode2MethodTokenAndOffset((SLOT)*pStart, &methodtoken,&relOffset);
            LPVOID methodInfo = pEEJM->GetGCInfo(methodtoken);
            _ASSERTE(methodInfo != NULL);

            ICodeManager* codeMgrInstance = pEEJM->GetCodeManager();
            _ASSERTE(codeMgrInstance != NULL);

            *pcSize = (ULONG)codeMgrInstance->GetFunctionSize(methodInfo);
        }
    }

ErrExit:
    return (hr);
}

/*
 * Get a metadata interface insance which maps to the given module.
 * One may ask for the metadata to be opened in read+write mode, but
 * this will result in slower metadata execution of the program, because
 * changes made to the metadata cannot be optimized as they were from
 * the compiler.
 */
HRESULT ProfToEEInterfaceImpl::GetModuleInfo(
    ModuleID    moduleId,
    LPCBYTE     *ppBaseLoadAddress,
    ULONG       cchName, 
    ULONG      *pcchName,
    WCHAR       szName[],
    AssemblyID  *pAssemblyId)
{
    Module      *pModule;               // Working pointer for real class.
    HRESULT     hr = S_OK;

    pModule = (Module *) moduleId;

    // Pick some safe defaults to begin with.
    if (ppBaseLoadAddress)
        *ppBaseLoadAddress = 0;
    if (szName)
        *szName = 0;
    if (pcchName)
        *pcchName = 0;
    if (pAssemblyId)
        *pAssemblyId = PROFILER_PARENT_UNKNOWN;

    // Get the module file name
    LPCWSTR pFileName = pModule->GetFileName();
    _ASSERTE(pFileName);

    ULONG trueLen = (ULONG)(wcslen(pFileName) + 1);

    // Return name of module as required.
    if (szName && cchName > 0)
    {
        ULONG copyLen = min(trueLen, cchName);

        wcsncpy(szName, pFileName, copyLen);

        // Null terminate
        szName[copyLen-1] = L'\0';

    }

    // If they request the actual length of the name
    if (pcchName)
        *pcchName = trueLen;

#if 0
    // Do this check here instead of at the very beginning because someone wants
    // the ability to get the module filename when they get the ModuleLoadStarted
    // callback instead of waiting for the ModuleLoadFinished callback.
    if (!pModule->IsInitialized())
        return (CORPROF_E_DATAINCOMPLETE);
#endif
    
    if (ppBaseLoadAddress != NULL && !pModule->IsInMemory())
    {
        // Set the base load address.
        *ppBaseLoadAddress = (LPCBYTE) pModule->GetILBase();
        _ASSERTE(*ppBaseLoadAddress);

        // If we get a null base address, we haven't completely inited
        if (!*ppBaseLoadAddress)
            hr = CORPROF_E_DATAINCOMPLETE;
    }

    // Return the parent assembly for this module if desired.
    if (pAssemblyId != NULL)
    {
        if (pModule->GetAssembly() != NULL)
        {
            Assembly *pAssembly = pModule->GetAssembly();
            _ASSERTE(pAssembly);

            *pAssemblyId = (AssemblyID) pAssembly;
        }
        else
        {
            hr = CORPROF_E_DATAINCOMPLETE;
        }
    }

    return (hr);
}


/*
 * Get a metadata interface insance which maps to the given module.
 * One may ask for the metadata to be opened in read+write mode, but
 * this will result in slower metadata execution of the program, because
 * changes made to the metadata cannot be optimized as they were from
 * the compiler.
 */
HRESULT ProfToEEInterfaceImpl::GetModuleMetaData(
    ModuleID    moduleId,
    DWORD       dwOpenFlags,
    REFIID      riid,
    IUnknown    **ppOut)
{
    Module      *pModule;               // Working pointer for real class.
    HRESULT     hr = S_OK;

    pModule = (Module *) moduleId;
    _ASSERTE(pModule);

    IUnknown *pObj = pModule->GetImporter();

    // Make sure we can get the importer first
    if (pObj)
    {
        // Decide which type of open mode we are in to see which you require.
        if (dwOpenFlags & ofWrite)
        {
            IfFailGo(pModule->ConvertMDInternalToReadWrite());
            pObj = (IUnknown *) pModule->GetEmitter();
        }

        // Ask for the interface the caller wanted, only if they provide a out param
        if (ppOut)
            hr = pObj->QueryInterface(riid, (void **) ppOut);
    }
    else
        hr = CORPROF_E_DATAINCOMPLETE;

ErrExit:
    return (hr);
}


/*
 * Retrieve a pointer to the body of a method starting at it's header.
 * A method is scoped by the module it lives in.  Because this function
 * is designed to give a tool access to IL before it has been loaded
 * by the Runtime, it uses the metadata token of the method to find
 * the instance desired.  Note that this function has no effect on
 * already compiled code.
 */
HRESULT ProfToEEInterfaceImpl::GetILFunctionBody(
    ModuleID    moduleId,
    mdMethodDef methodId,
    LPCBYTE     *ppMethodHeader,
    ULONG       *pcbMethodSize)
{
    Module      *pModule;               // Working pointer for real class.
    ULONG       RVA;                    // Return RVA of the method body.
    DWORD       dwImplFlags;            // Flags for the item.
    ULONG       cbExtra;                // Extra bytes past code (eg, exception table)
    HRESULT     hr = S_OK;

    pModule = (Module *) moduleId;
    _ASSERTE(pModule && methodId != mdMethodDefNil);

    // Find the method body based on metadata.
    IMDInternalImport *pImport = pModule->GetMDImport();
    _ASSERTE(pImport);

    if (!pImport)
        return (CORPROF_E_DATAINCOMPLETE);

    pImport->GetMethodImplProps(methodId, &RVA, &dwImplFlags);

    // Check to see if the method has associated IL
    if ((RVA == 0 && !pModule->IsInMemory()) || !(IsMiIL(dwImplFlags) || IsMiOPTIL(dwImplFlags) || IsMiInternalCall(dwImplFlags)))
        return (CORPROF_E_FUNCTION_NOT_IL);

    // Get the location of the IL
    LPCBYTE pbMethod = (LPCBYTE) (pModule->GetILCode((DWORD) RVA));

    // Fill out param if provided
    if (ppMethodHeader)
        *ppMethodHeader = pbMethod;

    // Calculate the size of the method itself.
    if (pcbMethodSize)
    {
        if (((COR_ILMETHOD_FAT *)pbMethod)->IsFat())
        {
            COR_ILMETHOD_FAT *pMethod = (COR_ILMETHOD_FAT *)pbMethod;
            cbExtra = 0;
            
            // Also look for variable sized data that comes after the method itself.
            const COR_ILMETHOD_SECT *pFirst = pMethod->GetSect();
            const COR_ILMETHOD_SECT *pLast = pFirst;
            if (pFirst)
            {
                // Skip to the last extra sect.
                while (pLast->More())
                    pLast = pLast->NextLoc();

                // Skip to where next sect would be
                pLast = pLast->NextLoc();

                // Extra is delta from first extra sect to first sect past this method.
                cbExtra = (ULONG)((BYTE *) pLast - (BYTE *) pFirst);
            }
            
            *pcbMethodSize = pMethod->Size * 4;
            *pcbMethodSize += pMethod->GetCodeSize();
            *pcbMethodSize += cbExtra;
        }
        else
        {
            // Make sure no one has added any other header type
            _ASSERTE(((COR_ILMETHOD_TINY *)pbMethod)->IsTiny() && "PROFILER: Unrecognized header type.");

            COR_ILMETHOD_TINY *pMethod = (COR_ILMETHOD_TINY *)pbMethod;

            *pcbMethodSize = sizeof(COR_ILMETHOD_TINY);
            *pcbMethodSize += ((COR_ILMETHOD_TINY *) pMethod)->GetCodeSize();
        }
    }

    return (S_OK);
}


/*
 * IL method bodies must be located as RVA's to the loaded module, which
 * means they come after the module within 4 gb.  In order to make it
 * easier for a tool to swap out the body of a method, this allocator
 * will ensure memory allocated after that point.
 */
HRESULT ProfToEEInterfaceImpl::GetILFunctionBodyAllocator(
    ModuleID    moduleId,
    IMethodMalloc **ppMalloc)
{
    Module      *pModule;               // Working pointer for real class.
    HRESULT     hr;
    
    pModule = (Module *) moduleId;

    if (pModule->GetILBase() == 0 && !pModule->IsInMemory())
        return (CORPROF_E_DATAINCOMPLETE);

    hr = ModuleILHeap::CreateNew(IID_IMethodMalloc, (void **) ppMalloc, 
            (LPCBYTE) pModule->GetILBase(), this, pModule);
    return (hr);
}


/*
 * Replaces the method body for a function in a module.  This will replace
 * the RVA of the method in the metadata to point to this new method body,
 * and adjust any internal data structures as required.  This function can
 * only be called on those methods which have never been compiled by a JITTER.
 * Please use the GetILFunctionBodyAllocator to allocate space for the new method to
 * ensure the buffer is compatible.
 */
HRESULT ProfToEEInterfaceImpl::SetILFunctionBody(
    ModuleID    moduleId,
    mdMethodDef methodId,
    LPCBYTE     pbNewILMethodHeader)
{
    Module      *pModule;               // Working pointer for real class.
    ULONG       rva;                    // Location of code.
    HRESULT     hr = S_OK;

    // Cannot set the body for anything other than a method def
    if (TypeFromToken(methodId) != mdtMethodDef)
        return (E_INVALIDARG);

    // Cast module to appropriate type
    pModule = (Module *) moduleId;

    if (pModule->IsInMemory())
    {
        InMemoryModule *pIMM = (InMemoryModule *)pModule;
        ICeeGen *pICG = pIMM->GetCeeGen();
        _ASSERTE(pICG != NULL);

        if (pICG != NULL)
        {
            HCEESECTION hCeeSection;
            pICG->GetIlSection(&hCeeSection);

            CeeSection *pCeeSection = (CeeSection *)hCeeSection;
            if ((rva = pCeeSection->computeOffset((char *)pbNewILMethodHeader)) != 0)
            {
                // Lookup the method desc
                MethodDesc *pDesc = LookupMethodDescFromMethodDef(methodId, pModule);
                _ASSERTE(pDesc != NULL);

                // Set the RVA in the desc
                pDesc->SetRVA(rva);

                // Set the RVA in the metadata
                IMetaDataEmit *pEmit = pDesc->GetEmitter();
                pEmit->SetRVA(methodId, rva);
            }
            else
                hr = E_FAIL;
        }
        else
            hr = E_FAIL;
    }
    else
    {
        // If the module is not initialized, then there probably isn't a valid IL base yet.
        if (pModule->GetILBase() == 0)
            return (CORPROF_E_DATAINCOMPLETE);

        // Sanity check the new method body.
        if (pbNewILMethodHeader <= (LPCBYTE) pModule->GetILBase())
        {
            _ASSERTE(!"Bogus RVA for new method, need to use our allocator");
            return E_INVALIDARG;
        }

        // Find the RVA for the new method and replace this in metadata.
        rva = (ULONG) (pbNewILMethodHeader - (LPCBYTE) pModule->GetILBase());
        _ASSERTE(rva < ~0);

        // Get the metadata emitter
        IMetaDataEmit *pEmit = pModule->GetEmitter();

        // Set the new RVA
        hr = pEmit->SetRVA(methodId, rva);

        // If the method has already been instantiated, then we must go whack the
        // RVA address in the MethodDesc
        if (hr == S_OK)
        {
            MethodDesc *pMD = pModule->FindFunction(methodId);

            if (pMD)
            {
                _ASSERTE(pMD->IsIL());
                pMD->SetRVA(rva);
            }
        }
    }

    return (hr);
}

/*
 * Marks a function as requiring a re-JIT.  The function will be re-JITted
 * at its next invocation.  The normal profiller events will give the profiller
 * an opportunity to replace the IL prior to the JIT.  By this means, a tool
 * can effectively replace a function at runtime.  Note that active instances
 * of the function are not affected by the replacement.
 */
HRESULT ProfToEEInterfaceImpl::SetFunctionReJIT(
    FunctionID  functionId)
{
    // Cast to appropriate type
    MethodDesc *pMDesc = (MethodDesc *) functionId;

    // Get the method's Module
    Module  *pModule = pMDesc->GetModule();

    // Module must support updateable methods.
    if (!pModule->SupportsUpdateableMethods())
        return (CORPROF_E_NOT_REJITABLE_METHODS);

    if (!pMDesc->IsJitted())
        return (CORPROF_E_CANNOT_UPDATE_METHOD);

    // Ask JIT Manager to re-jit the function.
    if (!IJitManager::ForceReJIT(pMDesc)) 
        return (CORPROF_E_CANNOT_UPDATE_METHOD);

    return S_OK;
}

/*
 * Sets the codemap for the replaced IL function body
 */
HRESULT ProfToEEInterfaceImpl::SetILInstrumentedCodeMap(
        FunctionID functionId,
        BOOL fStartJit,
        ULONG cILMapEntries,
        COR_IL_MAP rgILMapEntries[])
{
    DWORD dwDebugBits = ((MethodDesc*)functionId)->GetModule()->GetDebuggerInfoBits();

    // If we're tracking JIT info for this module, then update the bits
    if (CORDebuggerTrackJITInfo(dwDebugBits))
    {
        return g_pDebugInterface->SetILInstrumentedCodeMap((MethodDesc*)functionId,
                                                           fStartJit,
                                                           cILMapEntries,
                                                           rgILMapEntries);
    }
    else
    {
        // Throw it on the floor & life is good
        CoTaskMemFree(rgILMapEntries);
        return S_OK;
    }
}

HRESULT ProfToEEInterfaceImpl::ForceGC()
{
    if (GetThread() != NULL)
        return (E_FAIL);

    if (g_pGCHeap == NULL)
        return (CORPROF_E_NOT_YET_AVAILABLE);

    // -1 Indicates that all generations should be collected
    return (g_pGCHeap->GarbageCollect(-1));
}


HRESULT ProfToEEInterfaceImpl::GetInprocInspectionInterfaceFromEE( 
        IUnknown **iu,
        bool fThisThread)
{
    // If it's not enabled, return right away
    if (!CORProfilerInprocEnabled())
        return (CORPROF_E_INPROC_NOT_ENABLED);

    // If they want the interface for this thread, check error conditions
    else if (fThisThread && !g_profControlBlock.fIsSuspended)
    {
        Thread *pThread = GetThread();

        // If there is no managed thread, error
        if (!pThread || !g_pDebugInterface->GetInprocActiveForThread())
            return (CORPROF_E_NOT_MANAGED_THREAD);
    }

    // If they want the interface for the entire process and the runtime is not
    // suspended, error
    else if (!g_profControlBlock.fIsSuspended)
        return (CORPROF_E_INPROC_NOT_ENABLED);

    // Most error contitions pass, so try to get the interface
    return g_pDebugInterface->GetInprocICorDebug(iu, fThisThread);
}

HRESULT ProfToEEInterfaceImpl::SetCurrentPointerForDebugger(
        void *ptr,
        PTR_TYPE ptrType)
{
    if (CORProfilerInprocEnabled())
        return g_pDebugInterface->SetCurrentPointerForDebugger(ptr, ptrType);
    else
        return (S_OK);
}

/*
 * Returns the ContextID for the current thread.
 */
HRESULT ProfToEEInterfaceImpl::GetThreadContext(ThreadID threadId,
                                                ContextID *pContextId)
{
    // Cast to right type
    Thread *pThread = reinterpret_cast<Thread *>(threadId);

    // Get the context for the Thread* provided
    Context *pContext = pThread->GetContext();
    _ASSERTE(pContext);

    // If there's no current context, return incomplete info
    if (!pContext)
        return (CORPROF_E_DATAINCOMPLETE);

    // Set the result and return
    if (pContextId)
        *pContextId = reinterpret_cast<ContextID>(pContext);

    return (S_OK);
}

HRESULT ProfToEEInterfaceImpl::BeginInprocDebugging(
    /* [in] */  BOOL   fThisThreadOnly,
    /* [out] */ DWORD *pdwProfilerContext)
{
    // Default value of 0 is necessary
    _ASSERTE(pdwProfilerContext);
    *pdwProfilerContext = 0;

    if (g_profStatus == profInInit || !CORProfilerInprocEnabled())
        return (CORPROF_E_INPROC_NOT_ENABLED);

    if (pdwProfilerContext == NULL)
        return (E_INVALIDARG);

    Thread *pThread = GetThread();

    // If the runtime is suspended for reason of GC, can't enter inproc debugging
    if (g_pGCHeap->IsGCInProgress()
        && pThread == g_pGCHeap->GetGCThread()
        && g_profControlBlock.inprocState == ProfControlBlock::INPROC_FORBIDDEN)
    {
        return (CORPROF_E_INPROC_NOT_AVAILABLE);
    }

    // If the profiler wishes to enumerate threads and crawl their stacks we need to suspend the runtime.
    if (!fThisThreadOnly)
    {
        // If this thread is already in inproc debugging mode, can't suspend the runtime
        if (pThread != NULL && g_pDebugInterface->GetInprocActiveForThread())
            return (CORPROF_E_INPROC_ALREADY_BEGUN);

        // If the runtime has already been suspended by this thread, then no suspension is necessary
        BOOL fShouldSuspend = !(g_pGCHeap->IsGCInProgress() && pThread != NULL && pThread == g_pGCHeap->GetGCThread());

        // If the thread is in preemptive GC mode, turn it to cooperative GC mode so that stack
        // tracing functions will work
        if (pThread != NULL && !pThread->PreemptiveGCDisabled())
        {
            *pdwProfilerContext |= profThreadPGCEnabled;
            pThread->DisablePreemptiveGC();
        }

        // If the runtime is suspended and this is the thread that did the suspending, then we can
        // skip trying to suspend the runtime.  Otherwise, try and suspend it, and thus wait for
        // the other suspension to finish
        if (fShouldSuspend)
            g_pGCHeap->SuspendEE(GCHeap::SUSPEND_FOR_INPROC_DEBUGGER);

        // Can't recursively call BeginInprocDebugging
        if (g_profControlBlock.fIsSuspended)
            return (CORPROF_E_INPROC_ALREADY_BEGUN);

        // Enter the lock
        EnterCriticalSection(&g_profControlBlock.crSuspendLock);

        g_profControlBlock.fIsSuspended = TRUE;
        g_profControlBlock.fIsSuspendSimulated = !fShouldSuspend;
        g_profControlBlock.dwSuspendVersion++;

        // Count this runtime suspend
        *pdwProfilerContext |= profRuntimeSuspended;

        // Exit the lock
        LeaveCriticalSection(&g_profControlBlock.crSuspendLock);
    }

    else if (pThread != NULL)
    {
        // If the runtime has already been suspended by this thread, then can't enable this-thread-only inproc debugging
        BOOL fDidSuspend = g_pGCHeap->IsGCInProgress() && pThread != NULL && pThread == g_pGCHeap->GetGCThread();
        if (fDidSuspend && g_profControlBlock.fIsSuspended)
            return (CORPROF_E_INPROC_ALREADY_BEGUN);

        // Let the thread know that it has been activated for in-process debugging
        if (!g_pDebugInterface->GetInprocActiveForThread())
        {
                // Find out if preemptive GC needs to be disabled
                BOOL fPGCEnabled = !(pThread->PreemptiveGCDisabled());

                // If the thread is PGCEnabled, need to disable
                if (fPGCEnabled)
                {
                    pThread->DisablePreemptiveGC();

                    // This value is returned to the profiler, which will pass it back to EndInprocDebugging
                    *pdwProfilerContext = profThreadPGCEnabled;
                }

            // @TODO: There are places that enable preemptive GC which will cause problems
            // BEGINFORBIDGC();
            g_pDebugInterface->SetInprocActiveForThread(TRUE);
        }
        else
            return (CORPROF_E_INPROC_ALREADY_BEGUN);
    }

    _ASSERTE((*pdwProfilerContext & ~(profRuntimeSuspended | profThreadPGCEnabled)) == 0);

    return (S_OK);
}

HRESULT ProfToEEInterfaceImpl::EndInprocDebugging(
    /* [in] */ DWORD dwProfilerContext)
{
    _ASSERTE((dwProfilerContext & ~(profRuntimeSuspended | profThreadPGCEnabled)) == 0);

    // If the profiler caused the entire runtime to suspend, must decrement the count and
    // resume the runtime if the count reaches 0
    if (dwProfilerContext & profRuntimeSuspended)
    {
        Thread *pThread = GetThread();

        // This had better be true
        _ASSERTE(g_profControlBlock.fIsSuspended);
        _ASSERTE(g_pGCHeap->IsGCInProgress() && pThread != NULL && pThread == g_pGCHeap->GetGCThread());

        // If we're the last one to resume the runtime, do it for real
        if (!g_profControlBlock.fIsSuspendSimulated)
            g_pGCHeap->RestartEE(FALSE, TRUE);

        g_profControlBlock.fIsSuspended = FALSE;
    }

    // If this thread was enabled for inproc, turn that off
    if (g_pDebugInterface->GetInprocActiveForThread())
    {
        g_pDebugInterface->SetInprocActiveForThread(FALSE);
        // @TODO: There are places that enable preemptive GC which will cause problems
        // ENDFORBIDGC();
    }

    // If preemptive GC was enabled when called, we need to re-enable it.
    if (dwProfilerContext & profThreadPGCEnabled)
    {
        Thread *pThread = GetThread();

        _ASSERTE(pThread && pThread->PreemptiveGCDisabled());

        // Enable PGC
        pThread->EnablePreemptiveGC();
    }

    return (S_OK);
}

HRESULT ProfToEEInterfaceImpl::GetClassIDInfo( 
    ClassID classId,
    ModuleID *pModuleId,
    mdTypeDef *pTypeDefToken)
{
    if (pModuleId != NULL)
        *pModuleId = NULL;

    if (pTypeDefToken != NULL)
        *pTypeDefToken = NULL;

    // Handle globals which don't have the instances.
    if (classId == PROFILER_GLOBAL_CLASS)
    {
        if (pModuleId != NULL)
            *pModuleId = PROFILER_GLOBAL_MODULE;

        if (pTypeDefToken != NULL)
            *pTypeDefToken = mdTokenNil;
    }

    // Get specific data.
    else
    {
        _ASSERTE(classId != NULL);
        TypeHandle th((void *)classId);

        if (!th.IsTypeDesc())
        {
            EEClass *pClass = th.AsClass();
            _ASSERTE(pClass != NULL);

            if (!pClass->IsArrayClass())
            {
                if (pModuleId != NULL)
                {
                    *pModuleId = (ModuleID) pClass->GetModule();
                    _ASSERTE(*pModuleId != NULL);
                }

                if (pTypeDefToken != NULL)
                {
                    *pTypeDefToken = pClass->GetCl();
                    _ASSERTE(*pTypeDefToken != NULL);
                }
            }
        }
    }

    return (S_OK);
}


HRESULT ProfToEEInterfaceImpl::GetFunctionInfo( 
    FunctionID functionId,
    ClassID *pClassId,
    ModuleID *pModuleId,
    mdToken *pToken)
{
    MethodDesc *pMDesc = (MethodDesc *) functionId;
    EEClass *pClass = pMDesc->GetClass();

    if (pClassId != NULL)
    {
        if (pClass != NULL)
            *pClassId = (ClassID) TypeHandle(pClass).AsPtr();

        else
            *pClassId = PROFILER_GLOBAL_CLASS;
    }

    if (pModuleId != NULL)
    {
        *pModuleId = (ModuleID) pMDesc->GetModule();
    }

    if (pToken != NULL)
    {
        *pToken = pMDesc->GetMemberDef();
    }

    return (S_OK);
}

/*
 * GetILToNativeMapping returns a map from IL offsets to native
 * offsets for this code. An array of COR_DEBUG_IL_TO_NATIVE_MAP
 * structs will be returned, and some of the ilOffsets in this array
 * may be the values specified in CorDebugIlToNativeMappingTypes.
 */
HRESULT ProfToEEInterfaceImpl::GetILToNativeMapping(
            /* [in] */  FunctionID functionId,
            /* [in] */  ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [out, size_is(cMap), length_is(*pcMap)] */
                COR_DEBUG_IL_TO_NATIVE_MAP map[])
{
    // If JIT maps are not enabled, then we can't provide it
    if (!CORProfilerJITMapEnabled())
        return (CORPROF_E_JITMAPS_NOT_ENABLED);

    // Cast to proper type
    MethodDesc *pMD = (MethodDesc *)functionId;

    return (g_pDebugInterface->GetILToNativeMapping(pMD, cMap, pcMap, map));
}

/*
 * This tries to reserve memory of size dwMemSize as high up in virtual memory
 * as possible, and return a heap that manages it.
 */
HRESULT ProfToEEInterfaceImpl::NewHeap(LoaderHeap **ppHeap, LPCBYTE pBase, DWORD dwMemSize)
{
    HRESULT hr = S_OK;
    *ppHeap = NULL;

    // Create a new loader heap we can use for suballocation.
    LoaderHeap *pHeap = new LoaderHeap(4096, 0);

    if (!pHeap)
    {
        hr = E_OUTOFMEMORY;
        goto ErrExit;
    }

    // Note: its important to use pBase + METHOD_MAX_RVA as the upper limit on the allocation!
    if (!pHeap->ReservePages(0, NULL, dwMemSize, pBase, (PBYTE)((UINT_PTR)pBase + (UINT_PTR)METHOD_MAX_RVA), FALSE))
    {
        hr = E_OUTOFMEMORY;
        goto ErrExit;
    }

    // Succeeded, so return the created heap
    *ppHeap = pHeap;

ErrExit:
    if (FAILED(hr))
    {
        if (pHeap)
            delete pHeap;
    }

    return (hr);
}

/*
 * This will add a heap to the list of heaps available for allocations.
 */
HRESULT ProfToEEInterfaceImpl::AddHeap(LoaderHeap *pHeap)
{
    HRESULT hr = S_OK;

    HeapList *pElem = new HeapList(pHeap);
    if (!pElem)
    {
        hr = E_OUTOFMEMORY;
        goto ErrExit;
    }

    // For now, add it to the front of the list
    pElem->m_pNext = m_pHeapList;
    m_pHeapList = pElem;

ErrExit:
    if (FAILED(hr))
    {
        if (pElem)
            delete pElem;
    }

    return (hr);
}

/*
 * This allocates memory for use as an IL method body.
 */
void *ProfToEEInterfaceImpl::Alloc(LPCBYTE pBase, ULONG cb, Module *pModule)
{
    _ASSERTE(pBase != 0 || pModule->IsInMemory());

    LPBYTE pb = NULL;

    if (pModule->IsInMemory())
    {
        InMemoryModule *pIMM = (InMemoryModule *)pModule;
        ICeeGen *pICG = pIMM->GetCeeGen();
        _ASSERTE(pICG != NULL);

        if (pICG != NULL)
        {
            ULONG RVA;  // Dummy - will compute later
            pICG->AllocateMethodBuffer(cb, (UCHAR **) &pb, &RVA);
        }
    }
    else
    {
        // Now try to allocate the memory
        HRESULT hr = S_OK;
        HeapList **ppCurHeap = &m_pHeapList;
        while (*ppCurHeap && !pb)
        {
            // Note: its important to use pBase + METHOD_MAX_RVA as the upper limit on the allocation!
            if ((*ppCurHeap)->m_pHeap->CanAllocMemWithinRange((size_t) cb, (BYTE *)pBase, 
                                                              (BYTE *)((UINT_PTR)pBase + (UINT_PTR)METHOD_MAX_RVA), FALSE))
            {
                pb = (LPBYTE) (*ppCurHeap)->m_pHeap->AllocMem(cb);

                if (pb)
                {
                    break;
                }
            }

            ppCurHeap = &((*ppCurHeap)->m_pNext);
        }

        // If we failed to allocate memory, grow the heap
        if (!pb)
        {
            LoaderHeap *pHeap = NULL;

            // Create new heap, reserving at least a meg at a time
            // Add sizeof(LoaderHeapBlock) to requested size since
            // beginning of the heap is used by the heap manager, and will
            // fail if an exact size over 1 meg is requested if we
            // don't compensate
            if (SUCCEEDED(hr = NewHeap(&pHeap, pBase, max(cb + sizeof(LoaderHeapBlock), 0x1000*8))))
            {
                if (SUCCEEDED(hr = AddHeap(pHeap)))
                {
                    // Try to make allocation once more
                    pb = (LPBYTE) pHeap->AllocMem(cb, FALSE);
                    _ASSERTE(pb);

                    if (pb == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }

            if (FAILED(hr))
            {
                if (pHeap)
                    delete pHeap;
            }
        }

        // Pointer must come *after* the base or we are in bad shape.
        _ASSERTE(pb > pBase);
    }

    // Limit ourselves to RVA's that fit within the MethodDesc.
    if ((pb - pBase) >= (ULONG) METHOD_MAX_RVA)
        pb = NULL;
    
    return ((void *) pb);
}


//*****************************************************************************
// Given an ObjectID, go get the EE ClassID for it.
//*****************************************************************************
HRESULT ProfToEEInterfaceImpl::GetClassFromObject(
    ObjectID objectId,
    ClassID *pClassId)
{
    _ASSERTE(objectId);

    // Cast the ObjectID as a Object
    Object *pObj = reinterpret_cast<Object *>(objectId);

    // Set the out param and indicate success
    if (pClassId)
        *pClassId = (ClassID) pObj->GetTypeHandle().AsPtr();

    return (S_OK);
}

//*****************************************************************************
// Given a module and a token for a class, go get the EE data structure for it.
//*****************************************************************************
HRESULT ProfToEEInterfaceImpl::GetClassFromToken( 
    ModuleID    moduleId,
    mdTypeDef   typeDef,
    ClassID     *pClassId)
{
    // Get the module
    Module *pModule = (Module *) moduleId;

    // Get the class
    ClassLoader *pcls = pModule->GetClassLoader();

    // No class loader
    if (!pcls)
        return (CORPROF_E_DATAINCOMPLETE);

    NameHandle name(pModule, typeDef);
    TypeHandle th = pcls->LoadTypeHandle(&name);

    // No EEClass
    if (!th.AsClass())
        return (CORPROF_E_DATAINCOMPLETE);

    // Return value if necessary
    if (pClassId)
        *pClassId = (ClassID) th.AsPtr();

    return (S_OK);
}


//*****************************************************************************
// Given the token for a method, return the fucntion id.
//*****************************************************************************
HRESULT ProfToEEInterfaceImpl::GetFunctionFromToken( 
    ModuleID moduleId,
    mdToken typeDef,
    FunctionID *pFunctionId)
{
    // Default HRESULT
    HRESULT hr = S_OK;

    // Cast the in params to appropriate types
    Module      *pModule = (Module *) moduleId;

    // Default return value of NULL
    MethodDesc *pDesc = NULL;

    // Different lookup depending on whether it's a Def or Ref
    if (TypeFromToken(typeDef) == mdtMethodDef)
        pDesc = pModule->LookupMethodDef(typeDef);

    else if (TypeFromToken(typeDef) == mdtMemberRef)
        pDesc = pModule->LookupMemberRefAsMethod(typeDef);

    else
        hr = E_INVALIDARG;

    if (pFunctionId && SUCCEEDED(hr))
        *pFunctionId = (FunctionID) pDesc;

    return (hr);
}


//*****************************************************************************
// Retrive information about a given application domain, which is like a
// sub-process.
//*****************************************************************************
HRESULT ProfToEEInterfaceImpl::GetAppDomainInfo(
    AppDomainID appDomainId,
    ULONG       cchName, 
    ULONG       *pcchName,
    WCHAR       szName[],
    ProcessID   *pProcessId)
{
    BaseDomain   *pDomain;            // Internal data structure.
    HRESULT     hr = S_OK;
    
    // @todo:
    // Right now, this ID is not a true AppDomain, since we use the old
    // AppDomain/SystemDomain model in the profiling API.  This means that
    // the profiler exposes the SharedDomain and the SystemDomain to the
    // outside world. It's not clear whether this is actually the right thing
    // to do or not. - seantrow
    //
    // Postponed to V2.
    //

    pDomain = (BaseDomain *) appDomainId;

    // Make sure they've passed in a valid appDomainId
    if (pDomain == NULL)
        return (E_INVALIDARG);

    // Pick sensible defaults.
    if (pcchName)
        *pcchName = 0;
    if (szName)
        *szName = 0;
    if (pProcessId)
        *pProcessId = 0;

    LPCWSTR szFriendlyName;
    if (pDomain == SystemDomain::System())
        szFriendlyName = g_pwBaseLibrary;
    else if (pDomain == SharedDomain::GetDomain())
        szFriendlyName = L"EE Shared Assembly Repository";
    else
        szFriendlyName = ((AppDomain*)pDomain)->GetFriendlyName();

    if (szFriendlyName != NULL)
    {
        // Get the module file name
        ULONG trueLen = (ULONG)(wcslen(szFriendlyName) + 1);

        // Return name of module as required.
        if (szName && cchName > 0)
        {
            ULONG copyLen = min(trueLen, cchName);

            wcsncpy(szName, szFriendlyName, copyLen);

            // Null terminate
            szName[copyLen-1] = L'\0';

        }

        // If they request the actual length of the name
        if (pcchName)
            *pcchName = trueLen;
    }

    // If we don't have a friendly name but the call was requesting it, then return incomplete data HR
    else
    {
        if ((szName != NULL && cchName > 0) || pcchName)
            hr = CORPROF_E_DATAINCOMPLETE;
    }

    if (pProcessId)
        *pProcessId = (ProcessID) GetCurrentProcessId();

    return (hr);
}


//*****************************************************************************
// Retrieve information about an assembly, which is a collection of dll's.
//*****************************************************************************
HRESULT ProfToEEInterfaceImpl::GetAssemblyInfo(
    AssemblyID  assemblyId,
    ULONG       cchName, 
    ULONG       *pcchName,
    WCHAR       szName[],
    AppDomainID *pAppDomainId,
    ModuleID    *pModuleId)
{
    HRESULT hr = S_OK;

    Assembly    *pAssembly;             // Internal data structure for assembly.

    VERIFY((pAssembly = (Assembly *) assemblyId) != NULL);

    if (pcchName || szName)
    {
        // Get the friendly name of the assembly
        LPCUTF8 szUtfName = NULL;
        HRESULT res = pAssembly->GetName(&szUtfName);

        if (FAILED(res))
            hr = CORPROF_E_DATAINCOMPLETE;

        else
        {
            // Get length of UTF8 name including NULL
            int cchUtfName = (int)(strlen(szUtfName) + 1);

            // Find out how many characters are needed in the destination buffer
            int cchReq = WszMultiByteToWideChar(CP_UTF8, 0, szUtfName, cchUtfName, NULL, 0);
            _ASSERTE(cchReq > 0);

            // If they want the number of characters required or written, record it
            if (pcchName)
                *pcchName = cchReq;

            // If the friendly name itself is requested
            if (szName && cchName > 0)
            {
                // Figure out how much to actually copy
                int cchCopy = min((int)cchName, cchUtfName);

                // Convert the string
                int iRet = WszMultiByteToWideChar(CP_UTF8, 0, szUtfName, cchUtfName, szName, cchCopy);
                _ASSERTE(iRet > 0 && iRet == cchCopy);

                // If we somehow fail, return the error code.
                if (iRet == 0)
                    hr = HRESULT_FROM_WIN32(GetLastError());

                // null terminate it
                szName[cchCopy-1] = L'\0';
            }
        }
    }

    // Get the parent application domain.
    if (pAppDomainId)
    {
        *pAppDomainId = (AppDomainID) pAssembly->GetDomain();
        _ASSERTE(*pAppDomainId != NULL);
    }

    // Find the module the manifest lives in.
    if (pModuleId)
    {
        *pModuleId = (ModuleID) pAssembly->GetSecurityModule();

        // This is the case where the profiler has called GetAssemblyInfo
        // on an assembly that has been completely created yet.
        if (!*pModuleId)
            hr = CORPROF_E_DATAINCOMPLETE;
    }

    return (hr);
}

// Forward Declarations
void InprocEnterNaked();
void InprocLeaveNaked();
void InprocTailcallNaked();

//*****************************************************************************
//
//*****************************************************************************
HRESULT ProfToEEInterfaceImpl::SetEnterLeaveFunctionHooks(FunctionEnter *pFuncEnter,
                                                          FunctionLeave *pFuncLeave,
                                                          FunctionTailcall *pFuncTailcall)
{
    // The profiler must call SetEnterLeaveFunctionHooks during initialization, since
    // the enter/leave events are immutable and must also be set during initialization.
    if (g_profStatus != profInInit)
        return (CORPROF_E_CALL_ONLY_FROM_INIT);

    // Always save onto the function pointers, since we won't know if the profiler
    // is going to enable inproc debugging until after it returns from Initialize
    g_profControlBlock.pEnter = pFuncEnter;
    g_profControlBlock.pLeave = pFuncLeave;
    g_profControlBlock.pTailcall = pFuncTailcall;

    // When in-proc debugging is enabled, we indirect enter and leave callbacks to our own
    // function before calling the profiler's because we want to put a helper method frame
    // on the stack.
    if (CORProfilerInprocEnabled())
    {
        // Set the function pointer that the JIT calls
        SetEnterLeaveFunctionHooksForJit((FunctionEnter *)InprocEnterNaked,
                                         (FunctionLeave *)InprocLeaveNaked,
                                         (FunctionTailcall *)InprocTailcallNaked);
    }

    else
    {
        // Set the function pointer that the JIT calls
        SetEnterLeaveFunctionHooksForJit(pFuncEnter,
                                         pFuncLeave,
                                         pFuncTailcall);
    }

    return (S_OK);
}

//*****************************************************************************
//
//*****************************************************************************
HRESULT ProfToEEInterfaceImpl::SetFunctionIDMapper(FunctionIDMapper *pFunc)
{
    if (pFunc == NULL)
        g_pFuncIDMapper = &DefaultFunctionIDMapper;
    else
        g_pFuncIDMapper = pFunc;

    return (S_OK);
}


//
//
// Module helpers.
//
//

//*****************************************************************************
// Static creator
//*****************************************************************************
HRESULT ModuleILHeap::CreateNew(
    REFIID riid, void **pp, LPCBYTE pBase, ProfToEEInterfaceImpl *pParent, Module *pModule)
{
    HRESULT hr;

    ModuleILHeap *pHeap = new ModuleILHeap(pBase, pParent, pModule);
    if (!pHeap)
        hr = OutOfMemory();
    else
    {
        hr = pHeap->QueryInterface(riid, pp);
        pHeap->Release();
    }
    return (hr);
}


//*****************************************************************************
// ModuleILHeap ctor
//*****************************************************************************
ModuleILHeap::ModuleILHeap(LPCBYTE pBase, ProfToEEInterfaceImpl *pParent, Module *pModule) :
    m_cRef(1),
    m_pBase(pBase),
    m_pParent(pParent),
    m_pModule(pModule)
{
}


//*****************************************************************************
// AddRef
//*****************************************************************************
ULONG ModuleILHeap::AddRef()
{
    InterlockedIncrement((long *) &m_cRef);
    return (m_cRef);
}


//*****************************************************************************
// Release
//*****************************************************************************
ULONG ModuleILHeap::Release()
{
    ULONG cRef = InterlockedDecrement((long *) &m_cRef);
    if (cRef == 0)
        delete this;
    return (cRef);
}


//*****************************************************************************
// QI
//*****************************************************************************
HRESULT ModuleILHeap::QueryInterface(REFIID riid, void **pp)
{
    HRESULT     hr = S_OK;

    if (pp == NULL)
        return (E_POINTER);

    *pp = 0;
    if (riid == IID_IUnknown)
        *pp = (IUnknown *) this;
    else if (riid == IID_IMethodMalloc)
        *pp = (IMethodMalloc *) this;
    else
        hr = E_NOINTERFACE;
    
    if (hr == S_OK)
        AddRef();
    return (hr);
}


//*****************************************************************************
// Alloc
//*****************************************************************************
void *STDMETHODCALLTYPE ModuleILHeap::Alloc( 
        /* [in] */ ULONG cb)
{
    return m_pParent->Alloc(m_pBase, cb, m_pModule);
}

void __stdcall ProfilerManagedToUnmanagedTransition(Frame *pFrame,
                                                          COR_PRF_TRANSITION_REASON reason)
{
    MethodDesc *pMD = pFrame->GetFunction();
    if (pMD == NULL)
        return;

    g_profControlBlock.pProfInterface->ManagedToUnmanagedTransition((FunctionID) pMD,
                                                                          reason);
}

void __stdcall ProfilerUnmanagedToManagedTransition(Frame *pFrame,
                                                          COR_PRF_TRANSITION_REASON reason)
{
    MethodDesc *pMD = pFrame->GetFunction();
    if (pMD == NULL)
        return;

    g_profControlBlock.pProfInterface->UnmanagedToManagedTransition((FunctionID) pMD,
                                                                          reason);
}

void __stdcall ProfilerManagedToUnmanagedTransitionMD(MethodDesc *pMD,
                                                            COR_PRF_TRANSITION_REASON reason)
{
    if (pMD == NULL)
        return;

    g_profControlBlock.pProfInterface->ManagedToUnmanagedTransition((FunctionID) pMD,
                                                                          reason);
}

void __stdcall ProfilerUnmanagedToManagedTransitionMD(MethodDesc *pMD,
                                                            COR_PRF_TRANSITION_REASON reason)
{
    if (pMD == NULL)
        return;

    g_profControlBlock.pProfInterface->UnmanagedToManagedTransition((FunctionID) pMD,
                                                                          reason);
}

/**********************************************************************************************
 * These are helper functions for the GC events
 **********************************************************************************************/

class CObjectHeader;

BOOL CountContainedObjectRef(Object* pBO, void *context)
{
    // Increase the count
    (*((size_t *)context))++;

    return (TRUE);
}

BOOL SaveContainedObjectRef(Object* pBO, void *context)
{
    // Assign the value
    **((BYTE ***)context) = (BYTE *)pBO;

    // Now increment the array pointer
    (*((Object ***)context))++;

    return (TRUE);
}

BOOL HeapWalkHelper(Object* pBO, void* pv)
{
    OBJECTREF   *arrObjRef      = NULL;
    ULONG        cNumRefs       = 0;
    bool         bOnStack       = false;
    MethodTable *pMT            = pBO->GetMethodTable();

    if (pMT->ContainsPointers())
    {
        // First round through calculates the number of object refs for this class
        walk_object(pBO, &CountContainedObjectRef, (void *)&cNumRefs);

        if (cNumRefs > 0)
        {
            // Create an array to contain all of the refs for this object
            bOnStack = cNumRefs <= 32 ? true : false;

            // If it's small enough, just allocate on the stack
            if (bOnStack)
                arrObjRef = (OBJECTREF *)_alloca(cNumRefs * sizeof(OBJECTREF));

            // Otherwise, allocate from the heap
            else
            {
                arrObjRef = new OBJECTREF[cNumRefs];

                if (!arrObjRef)
                    return (FALSE);
            }

            // Second round saves off all of the ref values
            OBJECTREF *pCurObjRef = arrObjRef;
            walk_object(pBO, &SaveContainedObjectRef, (void *)&pCurObjRef);
        }
    }

    HRESULT hr = g_profControlBlock.pProfInterface->
        ObjectReference((ObjectID) pBO, (ClassID) pBO->GetTypeHandle().AsPtr(),
                        cNumRefs, (ObjectID *)arrObjRef);

    // If the data was not allocated on the stack, need to clean it up.
    if (arrObjRef != NULL && !bOnStack)
        delete [] arrObjRef;

    // Must return the hr from the callback, as a failed hr will cause
    // the heap walk to cease
    return (SUCCEEDED(hr));
}

BOOL AllocByClassHelper(Object* pBO, void* pv)
{
    _ASSERTE(pv != NULL);

#ifdef _DEBUG
    HRESULT hr =
#endif
    // Pass along the call
    g_profControlBlock.pProfInterface->AllocByClass(
        (ObjectID) pBO, (ClassID) pBO->GetTypeHandle().AsPtr(), pv);

    _ASSERTE(SUCCEEDED(hr));

    return (TRUE);
}

void ScanRootsHelper(Object*& o, ScanContext *pSC, DWORD dwUnused)
{
    // Let the profiling code know about this root reference
    g_profControlBlock.pProfInterface->
        RootReference((ObjectID)o, &(((ProfilingScanContext *)pSC)->pHeapId));
}

#endif // PROFILING_SUPPORTED


FCIMPL0(INT32, ProfilingFCallHelper::FC_TrackRemoting)
{
#ifdef PROFILING_SUPPORTED
    return ((INT32) CORProfilerTrackRemoting());
#else // !PROFILING_SUPPORTED
    return 0;
#endif // !PROFILING_SUPPORTED
}
FCIMPLEND

FCIMPL0(INT32, ProfilingFCallHelper::FC_TrackRemotingCookie)
{
#ifdef PROFILING_SUPPORTED
    return ((INT32) CORProfilerTrackRemotingCookie());
#else // !PROFILING_SUPPORTED
    return 0;
#endif // !PROFILING_SUPPORTED
}
FCIMPLEND

FCIMPL0(INT32, ProfilingFCallHelper::FC_TrackRemotingAsync)
{
#ifdef PROFILING_SUPPORTED
    return ((INT32) CORProfilerTrackRemotingAsync());
#else // !PROFILING_SUPPORTED
    return 0;
#endif // !PROFILING_SUPPORTED
}
FCIMPLEND

FCIMPL2(void, ProfilingFCallHelper::FC_RemotingClientSendingMessage, GUID *pId, BOOL fIsAsync)
{
#ifdef PROFILING_SUPPORTED
    // Need to erect a GC frame so that GCs can occur without a problem
    // within the profiler code.

    // Note that we don't need to worry about pId moving around since
    // it is a value class declared on the stack and so GC doesn't
    // know about it.

    _ASSERTE (!g_pGCHeap->IsHeapPointer(pId));     // should be on the stack, not in the heap
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();

    if (CORProfilerTrackRemotingCookie())
    {
        g_profControlBlock.pProfInterface->GetGUID(pId);
        _ASSERTE(pId->Data1);

        g_profControlBlock.pProfInterface->RemotingClientSendingMessage(
            reinterpret_cast<ThreadID>(GetThread()), pId, fIsAsync);
    }
    else
    {
        g_profControlBlock.pProfInterface->RemotingClientSendingMessage(
            reinterpret_cast<ThreadID>(GetThread()), NULL, fIsAsync);
    }

    HELPER_METHOD_FRAME_END_POLL();
#endif // PROFILING_SUPPORTED
}
FCIMPLEND

FCIMPL2(void, ProfilingFCallHelper::FC_RemotingClientReceivingReply, GUID id, BOOL fIsAsync)
{
#ifdef PROFILING_SUPPORTED
    // Need to erect a GC frame so that GCs can occur without a problem
    // within the profiler code.

    // Note that we don't need to worry about pId moving around since
    // it is a value class declared on the stack and so GC doesn't
    // know about it.

    HELPER_METHOD_FRAME_BEGIN_NOPOLL();

    if (CORProfilerTrackRemotingCookie())
    {
        g_profControlBlock.pProfInterface->RemotingClientReceivingReply(
            reinterpret_cast<ThreadID>(GetThread()), &id, fIsAsync);
    }
    else
    {
        g_profControlBlock.pProfInterface->RemotingClientReceivingReply(
            reinterpret_cast<ThreadID>(GetThread()), NULL, fIsAsync);
    }

    HELPER_METHOD_FRAME_END_POLL();
#endif // PROFILING_SUPPORTED
}
FCIMPLEND

FCIMPL2(void, ProfilingFCallHelper::FC_RemotingServerReceivingMessage, GUID id, BOOL fIsAsync)
{
#ifdef PROFILING_SUPPORTED
    // Need to erect a GC frame so that GCs can occur without a problem
    // within the profiler code.

    // Note that we don't need to worry about pId moving around since
    // it is a value class declared on the stack and so GC doesn't
    // know about it.

    HELPER_METHOD_FRAME_BEGIN_NOPOLL();

    if (CORProfilerTrackRemotingCookie())
    {
        g_profControlBlock.pProfInterface->RemotingServerReceivingMessage(
            reinterpret_cast<ThreadID>(GetThread()), &id, fIsAsync);
    }
    else
    {
        g_profControlBlock.pProfInterface->RemotingServerReceivingMessage(
            reinterpret_cast<ThreadID>(GetThread()), NULL, fIsAsync);
    }

    HELPER_METHOD_FRAME_END_POLL();
#endif // PROFILING_SUPPORTED
}
FCIMPLEND

FCIMPL2(void, ProfilingFCallHelper::FC_RemotingServerSendingReply, GUID *pId, BOOL fIsAsync)
{
#ifdef PROFILING_SUPPORTED
    // Need to erect a GC frame so that GCs can occur without a problem
    // within the profiler code.

    // Note that we don't need to worry about pId moving around since
    // it is a value class declared on the stack and so GC doesn't
    // know about it.

    HELPER_METHOD_FRAME_BEGIN_NOPOLL();

    if (CORProfilerTrackRemotingCookie())
    {
        g_profControlBlock.pProfInterface->GetGUID(pId);
        _ASSERTE(pId->Data1);

        g_profControlBlock.pProfInterface->RemotingServerSendingReply(
            reinterpret_cast<ThreadID>(GetThread()), pId, fIsAsync);
    }
    else
    {
        g_profControlBlock.pProfInterface->RemotingServerSendingReply(
            reinterpret_cast<ThreadID>(GetThread()), NULL, fIsAsync);
    }

    HELPER_METHOD_FRAME_END_POLL();
#endif // PROFILING_SUPPORTED
}
FCIMPLEND

FCIMPL0(void, ProfilingFCallHelper::FC_RemotingClientInvocationFinished)
{
    #ifdef PROFILING_SUPPORTED
    // Need to erect a GC frame so that GCs can occur without a problem
    // within the profiler code.

    // Note that we don't need to worry about pId moving around since
    // it is a value class declared on the stack and so GC doesn't
    // know about it.

    HELPER_METHOD_FRAME_BEGIN_NOPOLL();

    // This is just a wrapper to pass the call on.
    g_profControlBlock.pProfInterface->RemotingClientInvocationFinished(
        reinterpret_cast<ThreadID>(GetThread()));

    HELPER_METHOD_FRAME_END_POLL();
    #endif // PROFILING_SUPPORTED
}
FCIMPLEND

//*******************************************************************************************
// These allow us to add a helper method frames onto the stack when inproc debugging is
// enabled.
//*******************************************************************************************

HCIMPL1(void, InprocEnter, FunctionID functionId)
{

#ifdef PROFILING_SUPPORTED
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();    // Set up a frame

    Thread *pThread = GetThread();
    _ASSERTE(pThread->PreemptiveGCDisabled());

    pThread->EnablePreemptiveGC();

    g_profControlBlock.pEnter(functionId);

    pThread->DisablePreemptiveGC();

    HELPER_METHOD_FRAME_END();      // Un-link the frame
#endif // PROFILING_SUPPORTED
}
HCIMPLEND

HCIMPL1(void, InprocLeave, FunctionID functionId)
{
    FC_GC_POLL_NOT_NEEDED();            // we pulse GC mode, so we are doing a poll

#ifdef PROFILING_SUPPORTED
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();    // Set up a frame

    Thread *pThread = GetThread();
    _ASSERTE(pThread->PreemptiveGCDisabled());

    pThread->EnablePreemptiveGC();

    g_profControlBlock.pLeave(functionId);

    pThread->DisablePreemptiveGC();

    HELPER_METHOD_FRAME_END();      // Un-link the frame
#endif // PROFILING_SUPPORTED
}
HCIMPLEND
              
HCIMPL1(void, InprocTailcall, FunctionID functionId)
{
    FC_GC_POLL_NOT_NEEDED();            // we pulse GC mode, so we are doing a poll

#ifdef PROFILING_SUPPORTED
    HELPER_METHOD_FRAME_BEGIN_NOPOLL();    // Set up a frame

    Thread *pThread = GetThread();
    _ASSERTE(pThread->PreemptiveGCDisabled());

    pThread->EnablePreemptiveGC();

    g_profControlBlock.pTailcall(functionId);

    pThread->DisablePreemptiveGC();

    HELPER_METHOD_FRAME_END();      // Un-link the frame
#endif // PROFILING_SUPPORTED
}
HCIMPLEND
              
void __declspec(naked) InprocEnterNaked()
{
#ifdef _X86_
    __asm
    {
#ifdef _DEBUG
        push ebp
        mov  ebp, esp
#endif
        call InprocEnter
#ifdef _DEBUG
        pop  ebp
#endif
        ret
    }
#else // !_X86_
    _ASSERTE(!"NYI");
#endif // !_X86_
}

void __declspec(naked) InprocLeaveNaked()
{
#ifdef _X86_
    __asm
    {
        push eax
        push ecx
        push edx
        mov  ecx, [esp+16]
        call InprocLeave
        pop edx
        pop ecx
        pop eax
        ret 4
    }
#else // !_X86_
    _ASSERTE(!"NYI");
#endif // !_X86_
}

void __declspec(naked) InprocTailcallNaked()
{
#ifdef _X86_
    __asm
    {
        push eax
        push ecx
        push edx
        mov  ecx, [esp+16]
        call InprocTailcall
        pop edx
        pop ecx
        pop eax
        ret 4
    }
#else // !_X86_
    _ASSERTE(!"NYI");
#endif // !_X86_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\proftoeeinterfaceimpl.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#ifndef __PROFTOEEINTERFACEIMPL_H__
#define __PROFTOEEINTERFACEIMPL_H__

#include "EEProfInterfaces.h"
#include "Vars.hpp"
#include "Threads.h"
#include "codeman.h"
#include "cor.h"
#include "utsem.h"

//*****************************************************************************
// One of these is allocated per EE instance.   A pointer is cached to this
// from the profiler implementation.  The profiler will call back on the v-table
// to get at EE internals as required.
//*****************************************************************************
class ProfToEEInterfaceImpl : public ProfToEEInterface
{
public:
	ProfToEEInterfaceImpl();

    HRESULT Init();

    void Terminate();

    bool SetEventMask(DWORD dwEventMask);

    void DisablePreemptiveGC(ThreadID threadId);

    void EnablePreemptiveGC(ThreadID threadId);

    BOOL PreemptiveGCDisabled(ThreadID threadId);

    HRESULT GetHandleFromThread(ThreadID threadId, HANDLE *phThread);

    HRESULT GetObjectSize(ObjectID objectId, ULONG *pcSize);

    HRESULT IsArrayClass(
        /* [in] */  ClassID classId,
        /* [out] */ CorElementType *pBaseElemType,
        /* [out] */ ClassID *pBaseClassId,
        /* [out] */ ULONG   *pcRank);

    HRESULT GetThreadInfo(ThreadID threadId, DWORD *pdwWin32ThreadId);

	HRESULT GetCurrentThreadID(ThreadID *pThreadId);

    HRESULT GetFunctionFromIP(LPCBYTE ip, FunctionID *pFunctionId);

    HRESULT GetTokenFromFunction(FunctionID functionId, REFIID riid, IUnknown **ppOut,
                                 mdToken *pToken);

    HRESULT GetCodeInfo(FunctionID functionId, LPCBYTE *pStart, ULONG *pcSize);

	HRESULT GetModuleInfo(
		ModuleID	moduleId,
		LPCBYTE		*ppBaseLoadAddress,
		ULONG		cchName, 
		ULONG		*pcchName,
		WCHAR		szName[],
        AssemblyID  *pAssemblyId);

	HRESULT GetModuleMetaData(
		ModuleID	moduleId,
		DWORD		dwOpenFlags,
		REFIID		riid,
		IUnknown	**ppOut);

	HRESULT GetILFunctionBody(
		ModuleID	moduleId,
		mdMethodDef	methodid,
		LPCBYTE		*ppMethodHeader,
		ULONG		*pcbMethodSize);

	HRESULT GetILFunctionBodyAllocator(
		ModuleID	moduleId,
		IMethodMalloc **ppMalloc);

	HRESULT SetILFunctionBody(
		ModuleID	moduleId,
		mdMethodDef	methodid,
		LPCBYTE		pbNewILMethodHeader);

	HRESULT SetFunctionReJIT(
		FunctionID	functionId);

    HRESULT SetILInstrumentedCodeMap(
        FunctionID functionId,
        BOOL fStartJit,
        ULONG cILMapEntries,
        COR_IL_MAP rgILMapEntries[]);

    HRESULT ForceGC();
        
	HRESULT GetClassIDInfo( 
		ClassID classId,
		ModuleID *pModuleId,
		mdTypeDef *pTypeDefToken);

	HRESULT GetFunctionInfo( 
		FunctionID functionId,
		ClassID *pClassId,
		ModuleID *pModuleId,
		mdToken *pToken);

    HRESULT GetClassFromObject(
        ObjectID objectId,
        ClassID *pClassId);

	HRESULT GetClassFromToken( 
		ModuleID moduleId,
		mdTypeDef typeDef,
		ClassID *pClassId);

	HRESULT GetFunctionFromToken( 
		ModuleID moduleId,
		mdToken typeDef,
		FunctionID *pFunctionId);

    HRESULT GetAppDomainInfo(
        AppDomainID appDomainId,
        ULONG		cchName, 
        ULONG		*pcchName,
        WCHAR		szName[],
        ProcessID   *pProcessId);
    
    HRESULT GetAssemblyInfo(
        AssemblyID  assemblyId,
        ULONG		cchName, 
        ULONG		*pcchName,
        WCHAR		szName[],
        AppDomainID *pAppDomainId,
        ModuleID    *pModuleId);

	HRESULT SetEnterLeaveFunctionHooks(
		FunctionEnter *pFuncEnter,
		FunctionLeave *pFuncLeave,
        FunctionTailcall *pFuncTailcall);

	HRESULT SetEnterLeaveFunctionHooksForJit(
		FunctionEnter *pFuncEnter,
		FunctionLeave *pFuncLeave,
        FunctionTailcall *pFuncTailcall);

	HRESULT SetFunctionIDMapper(
		FunctionIDMapper *pFunc);

    HRESULT GetInprocInspectionInterfaceFromEE( 
        IUnknown **iu,
        bool fThisThread);

    HRESULT GetThreadContext(
        ThreadID threadId,
        ContextID *pContextId);

    HRESULT BeginInprocDebugging(
        /* [in] */  BOOL   fThisThreadOnly,
        /* [out] */ DWORD *pdwProfilerContext);
    
    HRESULT EndInprocDebugging(
        /* [in] */  DWORD  dwProfilerContext);

    HRESULT GetILToNativeMapping(
                /* [in] */  FunctionID functionId,
                /* [in] */  ULONG32 cMap,
                /* [out] */ ULONG32 *pcMap,
                /* [out, size_is(cMap), length_is(*pcMap)] */
                    COR_DEBUG_IL_TO_NATIVE_MAP map[]);

    HRESULT SetCurrentPointerForDebugger(
        void *ptr,
        PTR_TYPE ptrType);

private:
    struct HeapList
    {
        LoaderHeap *m_pHeap;
        struct HeapList *m_pNext;

        HeapList(LoaderHeap *pHeap) : m_pHeap(pHeap), m_pNext(NULL)
        {
        }

        ~HeapList()
        {
            delete m_pHeap;
        }
    };

	HeapList *m_pHeapList;      // Heaps for allocator.

public:
    // Helpers.
    HRESULT NewHeap(LoaderHeap **ppHeap, LPCBYTE pBase, DWORD dwMemSize = 1024*1024);
    HRESULT GrowHeap(LoaderHeap *pHeap, DWORD dwMemSize = 1024*1024);
    HRESULT AddHeap(LoaderHeap *pHeap);
	void *Alloc(LPCBYTE pBase, ULONG cb, Module *pModule);

    MethodDesc *LookupMethodDescFromMethodDef(mdMethodDef methodId, Module *pModule)
    {
        _ASSERTE(TypeFromToken(methodId) == mdtMethodDef);

        return (pModule->LookupMethodDef(methodId));
    }

    MethodDesc *LookupMethodDescFromMemberRef(mdMemberRef memberId, Module *pModule)
    {
        _ASSERTE(TypeFromToken(memberId) == mdtMemberRef);

        return (pModule->LookupMemberRefAsMethod(memberId));
    }

    MethodDesc *LookupMethodDesc(mdMemberRef memberId, Module *pModule)
    {
        MethodDesc *pDesc = NULL;

        // Different lookup depending on whether it's a Def or Ref
        if (TypeFromToken(memberId) == mdtMethodDef)
            pDesc = pModule->LookupMethodDef(memberId);

        else if (TypeFromToken(memberId) == mdtMemberRef)
            pDesc = pModule->LookupMemberRefAsMethod(memberId);

        return (pDesc);
    }
};





//*****************************************************************************
// This helper class wraps a loader heap which can be used to allocate 
// memory for IL after the current module.
//*****************************************************************************
class ModuleILHeap : public IMethodMalloc
{
public:
	ModuleILHeap(LPCBYTE pBase, ProfToEEInterfaceImpl *pParent, Module *pModule);

	static HRESULT CreateNew(
        REFIID riid, void **pp, LPCBYTE pBase, ProfToEEInterfaceImpl *pParent, Module *pModule);

// IUnknown
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **pp);

// IMethodMalloc
    virtual void *STDMETHODCALLTYPE Alloc( 
        /* [in] */ ULONG cb);

private:
	ULONG		m_cRef;					// Ref count for object.
	LPCBYTE		m_pBase;				// Base address for this module.
	ProfToEEInterfaceImpl *m_pParent;	// Parent class.
    Module     *m_pModule;              // Module associated with allocator
};
//**********************************************************************************
// This provides the implementations for FCALLs in managed code related to profiling
//**********************************************************************************
class ProfilingFCallHelper
{
public:
    // This is a high-efficiency way for managed profiler code to determine if
    // profiling of remoting is active.
    static FCDECL0(INT32, FC_TrackRemoting);

    // This is a high-efficiency way for managed profiler code to determine if
    // profiling of remoting with RPC cookie IDs is active.
    static FCDECL0(INT32, FC_TrackRemotingCookie);

    // This is a high-efficiency way for managed profiler code to determine if
    // profiling of asynchronous remote calls is profiled
    static FCDECL0(INT32, FC_TrackRemotingAsync);

    // This will let the profiler know that the client side is sending a message to
    // the server-side.
    static FCDECL2(void, FC_RemotingClientSendingMessage, GUID *pId, BOOL fIsAsync);

    // This will let the profiler know that the client side is receiving a reply
    // to a message that it sent
    static FCDECL2(void, FC_RemotingClientReceivingReply, GUID id, BOOL fIsAsync);

    // This will let the profiler know that the server side is receiving a message
    // from a client
    static FCDECL2(void, FC_RemotingServerReceivingMessage, GUID id, BOOL fIsAsync);

    // This will let the profiler know that the server side is sending a reply to
    // a received message.
    static FCDECL2(void, FC_RemotingServerSendingReply, GUID *pId, BOOL fIsAsync);

    // This will let the profiler know that the client side remoting code is done
    // with an asynchronous reply and is passing the info to the client app.
    static FCDECL0(void, FC_RemotingClientInvocationFinished);
};

#endif // __PROFTOEEINTERFACEIMPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\reflectclasswriter.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _REFCLASSWRITER_H_
#define _REFCLASSWRITER_H_

#include "ICeeFileGen.h"

// RefClassWriter
// This will create a Class
class RefClassWriter {
protected:
    friend class COMDynamicWrite;
	IMetaDataEmit*			m_emitter;			// Emit interface.
	IMetaDataImport*		m_importer;			// Import interface.
	IMDInternalImport*		m_internalimport;	// Scopeless internal import interface
	ICeeGen*				m_pCeeGen;
    ICeeFileGen*            m_pCeeFileGen;
    HCEEFILE                m_ceeFile;
	IMetaDataEmitHelper*	m_pEmitHelper;
	ULONG					m_ulResourceSize;
    mdFile                  m_tkFile;
    IMetaDataEmit*          m_pOnDiskEmitter;

public:
    RefClassWriter() {m_pOnDiskEmitter = NULL;}

	HRESULT		Init(ICeeGen *pCeeGen, IUnknown *pUnk);

	IMetaDataEmit* GetEmitter() {
		return m_emitter;
	}

	IMetaDataEmitHelper* GetEmitHelper() {
		return m_pEmitHelper;
	}

	IMetaDataImport* GetImporter() {
		return m_importer;
	}

	IMDInternalImport* GetMDImport() {
		return m_internalimport;
	}

	ICeeGen* GetCeeGen() {
		return m_pCeeGen;
	}

	ICeeFileGen* GetCeeFileGen() {
		return m_pCeeFileGen;
	}

	HCEEFILE GetHCEEFILE() {
		return m_ceeFile;
	}

    IMetaDataEmit* GetOnDiskEmitter() {
        return m_pOnDiskEmitter;
    }

    void SetOnDiskEmitter(IMetaDataEmit *pOnDiskEmitter) {
        if (m_pOnDiskEmitter)
            m_pOnDiskEmitter->Release();
        m_pOnDiskEmitter = pOnDiskEmitter;
        if (m_pOnDiskEmitter)
            m_pOnDiskEmitter->AddRef();
    }

    HRESULT EnsureCeeFileGenCreated();
    HRESULT DestroyCeeFileGen();

	~RefClassWriter();
};

#endif	// _REFCLASSWRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\reflectclasswriter.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h" 
#include "ReflectClassWriter.h"

// Forward declaration.
STDAPI  GetMetaDataInternalInterfaceFromPublic(
	void		*pv,					// [IN] Given interface.
	REFIID		riid,					// [IN] desired interface
	void		**ppv);					// [OUT] returned interface

//******************************************************
//*
//* constructor for RefClassWriter
//*
//******************************************************
HRESULT RefClassWriter::Init(ICeeGen *pCeeGen, IUnknown *pUnk)
{
	// Initialize the Import and Emitter interfaces
	// @TODO: Can we remove the dependence on the Importer and use
	//	the IMetaDataInternal?
	m_emitter = NULL;
	m_importer = NULL;
	m_internalimport = NULL;
    m_pCeeFileGen = NULL;
    m_ceeFile = NULL;
	m_ulResourceSize = 0;
    m_tkFile = mdFileNil;

	m_pCeeGen = pCeeGen;
	pCeeGen->AddRef();

	// Get the interfaces
	HRESULT hr = pUnk->QueryInterface(IID_IMetaDataEmit, (void**)&m_emitter);
	if (FAILED(hr))
		return hr;

	hr = pUnk->QueryInterface(IID_IMetaDataImport, (void**)&m_importer);
	if (FAILED(hr))
		return hr;

	hr = pUnk->QueryInterface(IID_IMetaDataEmitHelper, (void**)&m_pEmitHelper);
	if (FAILED(hr))
		return hr;

	hr = GetMetaDataInternalInterfaceFromPublic(pUnk, IID_IMDInternalImport, (void**)&m_internalimport);
	if (FAILED(hr))
		return hr;

	// TODO: We will need to set this at some point.
	hr = m_emitter->SetModuleProps(L"Default Dynamic Module");
	if (FAILED(hr))
		return hr;



	return S_OK;
}


//******************************************************
//*
//* destructor for RefClassWriter
//*
//******************************************************
RefClassWriter::~RefClassWriter()
{
	if (m_emitter) {
		m_emitter->Release();
	}

	if (m_importer) {
		m_importer->Release();
	}

	if (m_pEmitHelper) {
		m_pEmitHelper->Release();
	}

	if (m_internalimport) {
		m_internalimport->Release();
	}

	if (m_pCeeGen) {
		m_pCeeGen->Release();
		m_pCeeGen = NULL;
	}

    if (m_pOnDiskEmitter) {
        m_pOnDiskEmitter->Release();
        m_pOnDiskEmitter = NULL;
    }

    DestroyCeeFileGen();
}

//******************************************************
//*
//* Make sure that CeeFileGen for this module is created for emitting to disk
//*
//******************************************************
HRESULT RefClassWriter::EnsureCeeFileGenCreated()
{
    HRESULT     hr = NOERROR;
    if (m_pCeeFileGen == NULL)
    {
        //Create and ICeeFileGen and the corresponding HCEEFile if it has not been created!
        IfFailGo( CreateICeeFileGen(&m_pCeeFileGen) );
        IfFailGo( m_pCeeFileGen->CreateCeeFileFromICeeGen(m_pCeeGen, &m_ceeFile) );
    }    
ErrExit:
    if (FAILED(hr))
    {
        DestroyCeeFileGen();
    }
    return hr;
}


//******************************************************
//*
//* Destroy the instance of CeeFileGen that we created
//*
//******************************************************
HRESULT RefClassWriter::DestroyCeeFileGen()
{
    HRESULT     hr = NOERROR;
    if (m_pCeeFileGen) 
    {

        //Cleanup the HCEEFILE.  
        if (m_ceeFile) 
        {
            hr= m_pCeeFileGen->DestroyCeeFile(&m_ceeFile);
            _ASSERTE( SUCCEEDED(hr) || "Destory CeeFile" );
        }
        
        //Cleanup the ICeeFileGen.
        hr = DestroyICeeFileGen(&m_pCeeFileGen);
        _ASSERTE( SUCCEEDED(hr) || "Destroy ICeeFileGen" );
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\reflectutil.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// This module defines a Utility Class used by reflection
//
// Author: Daryl Olander
// Date: May 1998
////////////////////////////////////////////////////////////////////////////////

#include "common.h"
#include "ReflectWrap.h"
#include "ReflectUtil.h"
#include "COMMember.h"
#include "COMClass.h"
#include "gcscan.h"
#include "security.h"
#include "field.h"

ReflectUtil* g_pRefUtil = 0;
BinderClassID ReflectUtil::classId[RC_LAST] = 
{
    CLASS__CLASS,			    // sentinel
    CLASS__CLASS,			    // Class
    CLASS__METHOD,			    // Method
    CLASS__FIELD,			    // Field
    CLASS__CONSTRUCTOR,			// Ctor
    CLASS__MODULE,			    // Module
    CLASS__EVENT,			    // Event
    CLASS__PROPERTY,			// Property
    CLASS__MODULE_BUILDER,      // ModuleBuilder
    CLASS__METHOD_BASE,         // ModuleBuilder
};

ReflectUtil::ReflectUtil()
{
    ZeroMemory(&_filt,sizeof(_filt));
    ZeroMemory(&_class,sizeof(_class));
    ZeroMemory(&_trueClass,sizeof(_trueClass));
    ZeroMemory(&_filtClass,sizeof(_filtClass));

    // Init the FilterType information
    
    _filtClass[RFT_CLASS].id = METHOD__CLASS_FILTER__INVOKE;
    _filtClass[RFT_MEMBER].id = METHOD__MEMBER_FILTER__INVOKE;

    // Init the Known Filters
    
    _filt[RF_ModClsName].id = FIELD__MODULE__FILTER_CLASS_NAME;
    _filt[RF_ModClsNameIC].id = FIELD__MODULE__FILTER_CLASS_NAME_IC;

    // Initialize the critical section
    InitializeCriticalSection(&_StaticFieldLock);
}

ReflectUtil::~ReflectUtil()
{
    // Initialize the critical section
    DeleteCriticalSection(&_StaticFieldLock);
}

MethodDesc* ReflectUtil::GetFilterInvoke(FilterTypes type)
{
    _ASSERTE(type > RFT_INVALID && type < RFT_LAST);
    if (_filtClass[type].pMeth)
        return _filtClass[type].pMeth;

    _filtClass[type].pMeth = g_Mscorlib.GetMethod(_filtClass[type].id);

    return _filtClass[type].pMeth;
}

OBJECTREF ReflectUtil::GetFilterField(ReflectFilters type)
{
    _ASSERTE(type > RF_INVALID && type < RF_LAST);
    // Get the field Descr
    if (!_filt[type].pField) {
        switch (type) {
        case RF_ModClsName:
        case RF_ModClsNameIC:
            _filt[type].pField = g_Mscorlib.GetField(_filt[type].id);
            break;
        default:
            _ASSERTE(!"Illegal Case in GetFilterField");
            return 0;
        }
    }
    _ASSERTE(_filt[type].pField);
    return _filt[type].pField->GetStaticOBJECTREF();
}

// CreateReflectClass
// This method will create a reflection class based upon type.  This will only
//  create one of the classes that is available from the class object (It fails if you
//  try and create a Class Object)
OBJECTREF ReflectUtil::CreateReflectClass(ReflectClassType type,ReflectClass* pRC,void* pData)
{
    _ASSERTE(type > RC_INVALID && type < RC_LAST);
    _ASSERTE(type != RC_Class);
    THROWSCOMPLUSEXCEPTION();

    if (type == RC_Module || type == RC_DynamicModule)
    {
        REFLECTMODULEBASEREF obj;

        // Create a COM+ Class object
        obj = (REFLECTMODULEBASEREF) AllocateObject(GetClass(type));

        // Set the data in the COM+ object
        obj->SetReflClass(pRC);
        obj->SetData(pData);
        return (OBJECTREF) obj;
    }
    else
    {
        REFLECTBASEREF obj;

        // Create a COM+ Class object
        MethodTable *pClass = GetClass(type);
        obj = (REFLECTBASEREF) AllocateObject(pClass);

        // Set the data in the COM+ object
        obj->SetReflClass(pRC);
        obj->SetData(pData);
        return (OBJECTREF) obj;
    }
}

// CreateClassArray
// This method creates an array of classes based upon the type
//  It will only create classes that are the base reflection class
PTRARRAYREF ReflectUtil::CreateClassArray(ReflectClassType type,ReflectClass* pRC,
        ReflectMethodList* pMeths,int bindingAttr, bool verifyAccess)
{
    PTRARRAYREF     retArr;
    PTRARRAYREF     refArr;
    RefSecContext   sCtx;

    // The Search modifiers
    bool ignoreCase = ((bindingAttr & BINDER_IgnoreCase)  != 0);
    bool declaredOnly = ((bindingAttr & BINDER_DeclaredOnly)  != 0);

    // The search filters
    bool addStatic = ((bindingAttr & BINDER_Static)  != 0);
    bool addInst = ((bindingAttr & BINDER_Instance)  != 0);
    bool addPriv = ((bindingAttr & BINDER_NonPublic) != 0);
    bool addPub = ((bindingAttr & BINDER_Public) != 0);

    _ASSERTE(type > RC_INVALID && type < RC_LAST);

    // Allocate the COM+ array

    DWORD searchSpace = ((bindingAttr & BINDER_FlattenHierarchy) != 0) ? pMeths->dwTotal : pMeths->dwMethods;
    refArr = (PTRARRAYREF) AllocateObjectArray(
        searchSpace, GetTrueType(type));
    GCPROTECT_BEGIN(refArr);

    if (searchSpace) {
        MethodTable *pParentMT = pRC->GetClass()->GetMethodTable();

        // Now create each COM+ Method object and insert it into the array.

        for (DWORD i=0,dwCur = 0; i<searchSpace; i++) {
            // Check for access to publics, non-publics
            if (pMeths->methods[i].IsPublic()) {
                if (!addPub) continue;
            }
            else {
                if (!addPriv) continue;
                if (verifyAccess && !InvokeUtil::CheckAccess(&sCtx, pMeths->methods[i].attrs, pParentMT, 0)) continue;
            }

            // Check for static instance 
            if (pMeths->methods[i].IsStatic()) {
                if (!addStatic) continue;
            }
            else {
                if (!addInst) continue;
            }

            if (declaredOnly) {
                EEClass* pEEC = pRC->GetClass();
                if (pMeths->methods[i].pMethod->GetClass() != pEEC)
                    continue;
            }

            // If the method has a linktime security demand attached, check it now.
            if (verifyAccess && !InvokeUtil::CheckLinktimeDemand(&sCtx, pMeths->methods[i].pMethod, false))
                continue;

            if (type == RC_Method) {
                // Do not change this code.  This is done this way to
                //  prevent a GC hole in the SetObjectReference() call.  The compiler
                //  is free to pick the order of evaluation.
                OBJECTREF o = (OBJECTREF) pMeths->methods[i].GetMethodInfo(pRC);
                refArr->SetAt(dwCur++, o);
                _ASSERTE(pMeths->methods[i].GetMethodInfo(pRC) != 0);
            }
            if (type == RC_Ctor) {
                // Do not change this code.  This is done this way to
                //  prevent a GC hole in the SetObjectReference() call.  The compiler
                //  is free to pick the order of evaluation.
                OBJECTREF o = (OBJECTREF) pMeths->methods[i].GetConstructorInfo(pRC);
                refArr->SetAt(dwCur++, o);
                _ASSERTE((OBJECTREF) pMeths->methods[i].GetConstructorInfo(pRC));
            }
       }

        // Copy the array if these aren't the same size
        //@TODO: Should this be optimized?
        if (dwCur != i) {
            PTRARRAYREF p = (PTRARRAYREF) AllocateObjectArray( dwCur, GetTrueType(type));
            for (i=0;i<dwCur;i++) {
                p->SetAt(i, refArr->GetAt(i));
                _ASSERTE(refArr->m_Array[i] != 0);
            }
            refArr = p;
        }
    }

    // Assign the return value to the COM+ array
    retArr = refArr;
    GCPROTECT_END();
    return retArr;
}

PTRARRAYREF ReflectUtil::CreateClassArray(ReflectClassType type,ReflectClass* pRC,
        ReflectFieldList* pFlds,int bindingAttr, bool verifyAccess)
{
    PTRARRAYREF     refArr;
    PTRARRAYREF     retArr;
    RefSecContext   sCtx;

    // The Search modifiers
    bool ignoreCase = ((bindingAttr & BINDER_IgnoreCase)  != 0);
    bool declaredOnly = ((bindingAttr & BINDER_DeclaredOnly)  != 0);

    // The search filters
    bool addStatic = ((bindingAttr & BINDER_Static)  != 0);
    bool addInst = ((bindingAttr & BINDER_Instance)  != 0);
    bool addPriv = ((bindingAttr & BINDER_NonPublic) != 0);
    bool addPub = ((bindingAttr & BINDER_Public) != 0);

    _ASSERTE(type == RC_Field);

    // Allocate the COM+ array
    DWORD searchSpace = ((bindingAttr & BINDER_FlattenHierarchy) != 0) ? pFlds->dwTotal : pFlds->dwFields;
    refArr = (PTRARRAYREF) AllocateObjectArray(searchSpace, GetTrueType(type));
    GCPROTECT_BEGIN(refArr);

    if (searchSpace) {
        MethodTable *pParentMT = pRC->GetClass()->GetMethodTable();

        // Now create each COM+ Method object and insert it into the array.

        for (DWORD i=0,dwCur = 0; i<searchSpace; i++) {
            // Check for access to publics, non-publics
            if (pFlds->fields[i].pField->IsPublic()) {
                if (!addPub) continue;
            }
            else {
                if (!addPriv) continue;
                if (verifyAccess && !InvokeUtil::CheckAccess(&sCtx, pFlds->fields[i].pField->GetFieldProtection(), pParentMT, 0)) continue;
            }

            // Check for static instance 
            if (pFlds->fields[i].pField->IsStatic()) {
                if (!addStatic) continue;
            }
            else {
                if (!addInst) continue;
            }

            if (declaredOnly) {
                EEClass* pEEC = pRC->GetClass();
                if (pFlds->fields[i].pField->GetEnclosingClass() != pEEC)
                    continue;
            }

            // Do not change this code.  This is done this way to
            //  prevent a GC hole in the SetObjectReference() call.  The compiler
            //  is free to pick the order of evaluation.
            OBJECTREF o = (OBJECTREF) pFlds->fields[i].GetFieldInfo(pRC);
            refArr->SetAt(dwCur++, o);
        }
        
        // Copy the array if these aren't the same size
        //@TODO: Should this be optimized?
        if (dwCur != i) {
            PTRARRAYREF p = (PTRARRAYREF) AllocateObjectArray( dwCur, GetTrueType(type));
            for (i=0;i<dwCur;i++)
                p->SetAt(i, refArr->GetAt(i));
            refArr = p;
        }
    }

    // Assign the return value to the COM+ array
    retArr = refArr;
    GCPROTECT_END();
    return retArr;
}

// GetStaticFieldsCount
// This routine will return the number of Static Final Fields
int ReflectUtil::GetStaticFieldsCount(EEClass* pVMC)
{
    THROWSCOMPLUSEXCEPTION();

    REFLECTCLASSBASEREF pRefClass;
    pRefClass = (REFLECTCLASSBASEREF) pVMC->GetExposedClassObject();
    ReflectClass* pRC = (ReflectClass*) pRefClass->GetData();

    int cnt = pRC->GetStaticFieldCount();
    if (cnt == -1)
        GetStaticFields(pRC,&cnt);
    return cnt;
}

// GetStaticFields
// This will return an array of static fields
FieldDesc* ReflectUtil::GetStaticFields(ReflectClass* pRC,int* cnt)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT         hr;
    mdFieldDef      fd;             // Meta data members
    DWORD           cMembers;       // Count of meta data members
    int             cStatic;        // Count of statics
    int             i;
    FieldDesc*      flds = 0;

    PCCOR_SIGNATURE pMemberSignature;   // Signature stuff to check the type of the field
    DWORD           cMemberSignature;
    PCCOR_SIGNATURE pFieldSig;
    HENUMInternal   hEnumField;
    bool            fNeedToCloseEnumField = false;

    // If we've already found the Static field simply return it
    if (pRC->GetStaticFieldCount() >= 0) {
        *cnt = pRC->GetStaticFieldCount();
        return (FieldDesc*) pRC->GetStaticFields();
    }

    //NOTE: Critical Section In USE!!!!!
    Thread  *thread = GetThread();

    thread->EnablePreemptiveGC();
    LOCKCOUNTINCL("GetStaticFields in reflectutils.cpp");                       \
    EnterCriticalSection(&_StaticFieldLock);
    thread->DisablePreemptiveGC();

    // Retest the exit condition incase I was waiting for this object to be built
    // and now it built.
    if (pRC->GetStaticFieldCount() >= 0) {
        LeaveCriticalSection(&_StaticFieldLock);
        LOCKCOUNTDECL("GetStaticFields in reflectutils.cpp");                       \

        *cnt = pRC->GetStaticFieldCount();
        return (FieldDesc*) pRC->GetStaticFields();
    }
    // Create the StaticFields array
    IMDInternalImport *pInternalImport = pRC->GetMDImport();
    mdTypeDef cl = pRC->GetCl();
    EEClass* pVMC = pRC->GetClass();

    // We have all the fields defined in our interfaces...(They may be hidden)
    int iCnt = pVMC->GetNumInterfaces();
    int iTotalCnt = 0;
    ReflectFieldList** pIFaceFlds = 0;
    if (iCnt > 0)
        pIFaceFlds = (ReflectFieldList**) _alloca(sizeof(ReflectFieldList*) * iCnt);
    if (iCnt > 0) {
        for (int i=0;i<iCnt;i++)
        {
            REFLECTCLASSBASEREF pRefClass;
            pRefClass = (REFLECTCLASSBASEREF) pVMC->GetInterfaceMap()[i].m_pMethodTable->GetClass()->GetExposedClassObject();
            ReflectClass* pIFaceRC = (ReflectClass*) pRefClass->GetData();
            pIFaceFlds[i] = pIFaceRC->GetFields();
            iTotalCnt += pIFaceFlds[i]->dwFields;
        }
    }

    // Assume nothing found
    *cnt = 0;

    // Enumerate this class's fields
    hr = pInternalImport->EnumInit(mdtFieldDef, cl, &hEnumField);
    if (FAILED(hr)) {
        _ASSERTE(!"GetCountMemberDefs Failed");
        LeaveCriticalSection(&_StaticFieldLock);
        LOCKCOUNTDECL("GetStaticFields in reflectutils.cpp");                       \

        return 0;
    }

    cMembers = pInternalImport->EnumGetCount(&hEnumField);

    // If there are no member then return
    if (cMembers == 0 && iTotalCnt == 0) {
        pRC->SetStaticFieldCount(0);
        LeaveCriticalSection(&_StaticFieldLock);
        LOCKCOUNTDECL("GetStaticFields in reflectutils.cpp");                       \

        return 0;
    }
    else {
        cStatic = 0;
    }

    if (cMembers > 0) {

        fNeedToCloseEnumField = true;

        // Loop through everything and count the number of static final fields
        cStatic = 0;
        for (i=0;pInternalImport->EnumNext(&hEnumField, &fd);i++) {
            DWORD       dwMemberAttrs;

            dwMemberAttrs = pInternalImport->GetFieldDefProps(fd);

    #ifdef _DEBUG
            // Expose the name of the member for debugging.
            LPCUTF8     szMemberName;
            szMemberName = pInternalImport->GetNameOfFieldDef(fd);
    #endif
            if (IsFdLiteral(dwMemberAttrs)) {

                // Loop through the fields in the EEClass and make sure this is not there...
                FieldDescIterator fdIterator(pVMC, FieldDescIterator::ALL_FIELDS);
                FieldDesc *pCurField;

                while ((pCurField = fdIterator.Next()) != NULL)
                {
                    if (pCurField->GetMemberDef() == fd)
                        break;
                }
                if (pCurField == NULL)
                    cStatic++;
            }

        }

        _ASSERTE(i == (int)cMembers);

        if (cStatic == 0  && iTotalCnt == 0) {
            pRC->SetStaticFieldCount(0);
            pInternalImport->EnumClose(&hEnumField);
            LeaveCriticalSection(&_StaticFieldLock);
            LOCKCOUNTDECL("GetStaticFields in reflectutils.cpp");                       \

            return 0;
        }
    }


    // Allocate the cache for the static fields.
    flds = (FieldDesc*) pVMC->GetDomain()->GetReflectionHeap()->AllocMem(sizeof(FieldDesc) * (cStatic + iTotalCnt));
    if (!flds) {
        pInternalImport->EnumClose(&hEnumField);
        LeaveCriticalSection(&_StaticFieldLock);
        COMPlusThrowOM();
    }

    ZeroMemory(flds,sizeof(FieldDesc) * (cStatic + iTotalCnt));

    if (cMembers > 0) {

        pInternalImport->EnumReset(&hEnumField);

        // Now we loop back through the members and build the static fields
        for (i=0,cStatic=0; pInternalImport->EnumNext(&hEnumField, &fd); i++) {
            DWORD       dwMemberAttrs;
        
            dwMemberAttrs = pInternalImport->GetFieldDefProps(fd);

            // process only fields
            if (IsFdLiteral(dwMemberAttrs)) {
                CorElementType      FieldDescElementType;

                // Loop through the fields in the EEClass and make sure this is not there...
                FieldDescIterator fdIterator(pVMC, FieldDescIterator::ALL_FIELDS);
                FieldDesc *pCurField;

                while ((pCurField = fdIterator.Next()) != NULL)
                {
                    if (pCurField->GetMemberDef() == fd)
                        break;
                }
                if (pCurField == NULL) {
                    // Get the signature and type of the field.
                    pMemberSignature = pInternalImport->GetSigOfFieldDef(fd,&cMemberSignature);
                    pFieldSig = pMemberSignature;
                    if (*pFieldSig++ != IMAGE_CEE_CS_CALLCONV_FIELD) {
                        pInternalImport->EnumClose(&hEnumField);
                        LeaveCriticalSection(&_StaticFieldLock);
                        COMPlusThrow(kNotSupportedException);
                    }

                    FieldDescElementType = CorSigEatCustomModifiersAndUncompressElementType(pFieldSig);
                    switch (FieldDescElementType) {
                    case ELEMENT_TYPE_I1:
                    case ELEMENT_TYPE_BOOLEAN:
                    case ELEMENT_TYPE_U1:
                    case ELEMENT_TYPE_I2:
                    case ELEMENT_TYPE_U2:
                    case ELEMENT_TYPE_CHAR:
                    case ELEMENT_TYPE_I4:
                    case ELEMENT_TYPE_U4:
                    case ELEMENT_TYPE_I8:
                    case ELEMENT_TYPE_U8:
                    case ELEMENT_TYPE_R4:
                    case ELEMENT_TYPE_R8:
                    case ELEMENT_TYPE_CLASS:
                    case ELEMENT_TYPE_VALUETYPE:
                    case ELEMENT_TYPE_PTR:
                    case ELEMENT_TYPE_FNPTR:
                        break;
                    default:
                        FieldDescElementType = ELEMENT_TYPE_CLASS;
                        break;
                    }

                    LPCSTR pszFieldName = NULL;
#ifdef _DEBUG
                    pszFieldName = pInternalImport->GetNameOfFieldDef(fd);
#endif

                    // Initialize contents
                    flds[cStatic].Init(fd, FieldDescElementType, dwMemberAttrs, 
                                       TRUE, FALSE, FALSE, FALSE, pszFieldName);
                    flds[cStatic].SetMethodTable(pVMC->GetMethodTable());

                    // Set the offset to -1 indicating things are not stored in with the object
                    flds[cStatic].SetOffset(FIELD_OFFSET_NOT_REAL_FIELD);
                    cStatic++;
                }
            }
        }
    }

    if (iTotalCnt > 0) {
        for (int i=0;i<iCnt;i++) {
            for (DWORD j=0;j<pIFaceFlds[i]->dwFields;j++) {
                memcpy(&flds[cStatic],pIFaceFlds[i]->fields[j].pField,sizeof(FieldDesc));
                cStatic++;
            }
        }
    }

    // Save the fields
    // Make sure count is last thing set because it is used
    //  as the trigger to start this process.
    pRC->SetStaticFields(flds);
    pRC->SetStaticFieldCount(cStatic);
    LeaveCriticalSection(&_StaticFieldLock);
    LOCKCOUNTDECL("GetStaticFields in reflectutils.cpp");                       \

    // Free the members array
    *cnt = cStatic;
    pInternalImport->EnumClose(&hEnumField);
    return flds;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\registration.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: Registration.h
**
** Author: Tarun Anand (TarunA)
**
** Purpose: Native methods on System.Runtime.InteropServices.RegistrationServices
**
** Date:  June 26, 2000
** 
===========================================================*/
#ifndef __REGISTRATION_H
#define __REGISTRATION_H

struct RegisterTypeForComClientsNativeArgs
{
    DECLARE_ECALL_PTR_ARG(GUID*, pGuid);
    DECLARE_ECALL_OBJECTREF_ARG( REFLECTCLASSBASEREF, pType );
};

VOID __stdcall RegisterTypeForComClientsNative(RegisterTypeForComClientsNativeArgs *pArgs);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\reflectutil.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// This module defines a Utility Class used by reflection
//
// Author: Daryl Olander
// Date: March/April 1998
////////////////////////////////////////////////////////////////////////////////

#ifndef __REFLECTUTIL_H__
#define __REFLECTUTIL_H__

#include "COMClass.h"

// The global Reflect Util variable
class ReflectUtil;
extern ReflectUtil* g_pRefUtil;

class MethodDesc;
class MethodTable;
class ReflectClass;
class ReflectMethodList;
class ReflectFieldList;

// There are a set of reflection defined filters
//	All of these have special representation internally
enum ReflectFilters
{
    RF_INVALID,			            // sentinel
	RF_ModClsName,			        // Module
	RF_ModClsNameIC,			    // Module
	RF_LAST,			            // Number to allocate

};

// These are the types of filters that we provide in reflection
enum FilterTypes
{
	RFT_INVALID,
	RFT_CLASS,
	RFT_MEMBER,
	RFT_LAST,
};

// These are the internally modified Reflection classes
enum ReflectClassType
{
    RC_INVALID,			    // sentinel
	RC_Class,			    // Class
	RC_Method,			    // Method
	RC_Field,			    // Field
	RC_Ctor,			    // Ctor
	RC_Module,			    // Module
	RC_Event,			    // Event
	RC_Prop,			    // Property
    RC_DynamicModule,       // ModuleBuilder
    RC_MethodBase,          // ModuleBuilder
	RC_LAST,			    // Number to allocate
};

// ReflectUtil
//	This class defines a set of routines that are used by during
//	reflection.  Most of these routines manage the filtering of
//	reflection lists.
class ReflectUtil
{
public:
	// Constructors
    ReflectUtil();
    ~ReflectUtil();

	// We provide a static creation of the global above
	static HRESULT Create()
	{
		if (!g_pRefUtil)
			g_pRefUtil = new ReflectUtil();
		return S_OK;
	}

#ifdef SHOULD_WE_CLEANUP
	static void Destroy()
	{
		delete g_pRefUtil;
		g_pRefUtil = 0;
	}
#endif /* SHOULD_WE_CLEANUP */

	MethodDesc* GetFilterInvoke(FilterTypes type);
	OBJECTREF GetFilterField(ReflectFilters type);

	// CreateReflectClass
	// This method will create a reflection class based upon type.  This will only
	//	create one of the classes that is available from the class object (It fails if you
	//	try and create a Class Object)
	OBJECTREF CreateReflectClass(ReflectClassType type,ReflectClass* pRC,void* pData);

	// CreateClassArray
	// This method creates an array of classes based upon the type
	//	It will only create classes that are the base reflection class
	PTRARRAYREF CreateClassArray(ReflectClassType type,ReflectClass* pRC,ReflectMethodList* pMeths,
		int bindingAttr, bool verifyAccess);
	PTRARRAYREF CreateClassArray(ReflectClassType type,ReflectClass* pRC,ReflectFieldList* pMeths,
		int bindingAttr, bool verifyAccess);

	// Return the MethodTable for all of the base reflection types
	MethodTable* GetClass(ReflectClassType type) {
        if (_class[type].pClass)
            return _class[type].pClass;
        InitSpecificEntry(type);
		return _class[type].pClass;
	}

	// This method will return the MethodTable for System.Type which is
	//	the base abstract type for all Type classes.
	MethodTable* GetTrueType(ReflectClassType type)
	{
        if (_trueClass[type])
            return _trueClass[type];
        InitSpecificEntry(type);
		return _trueClass[type];
	}

	// Set the MethodTable (This is called only during initialization)
	void SetClass(ReflectClassType type,MethodTable* p) {
                THROWSCOMPLUSEXCEPTION();
		_class[type].pClass = p;
	}

	void SetTrueClass(ReflectClassType type,MethodTable* p) {
		_trueClass[type] = p;
	}

	// GetStaticFieldsCount
	// This will return the count of static fields...
	int GetStaticFieldsCount(EEClass* pVMC);

	// GetStaticFields
	// This will return an array of static fields
	FieldDesc* GetStaticFields(ReflectClass* pRC,int* cnt);

    void InitSpecificEntry(ReflectClassType type)
    {
        MethodTable *pMT = g_Mscorlib.FetchClass(classId[type]);
        _class[type].pClass = pMT;
        SetClass(type, pMT);
        SetTrueClass(type, pMT->GetParentMethodTable());
    }

private:
	struct FilterClass {
        BinderMethodID  id;
		MethodDesc*	    pMeth;
	};

	struct FilterDesc {
        BinderFieldID   id;
		FieldDesc*	    pField;
	};

	struct RClassDesc {
		MethodTable*	pClass;
	};

	FilterDesc	_filt[RF_LAST];
	RClassDesc	_class[RC_LAST];
	MethodTable*_trueClass[RC_LAST];
	FilterClass _filtClass[RFT_LAST];
    static BinderClassID classId[RC_LAST];

    // Protects addition of elements to m_pAvailableClasses
    CRITICAL_SECTION    _StaticFieldLock;
};


#endif	// __REFLECTUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\reflectwrap.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"

#include "ReflectWrap.h"
#include "COMClass.h"
#include "ReflectUtil.h"

#include "COMReflectionCommon.h"
#include "field.h"

// These are basically Empty elements that can be allocated one time and then returned
static ReflectTypeList* EmptyTypeList = 0;
static ReflectPropertyList* EmptyPropertyList = 0;
static ReflectEventList* EmptyEventList = 0;
static ReflectFieldList* EmptyFieldList = 0;


ReflectTypeList* GetEmptyTypeList()
{
    if (!EmptyTypeList) {
        ReflectTypeList *tempTypeList = (ReflectTypeList*) 
            SystemDomain::System()->GetReflectionHeap()->AllocMem(sizeof(ReflectTypeList));
        if (tempTypeList == NULL)
            FatalOutOfMemoryError();
        tempTypeList->dwTypes = 0;
        if (!EmptyTypeList) 
            EmptyTypeList = tempTypeList;
    }
    return EmptyTypeList;
}

ReflectPropertyList* GetEmptyPropertyList()
{
    if (!EmptyPropertyList) {
        ReflectPropertyList *tempList = (ReflectPropertyList*) 
            SystemDomain::System()->GetReflectionHeap()->AllocMem(sizeof(ReflectPropertyList));
        if (tempList == NULL)
            FatalOutOfMemoryError();
        tempList->dwProps = 0;
        tempList->dwTotal = 0;
        if (!EmptyPropertyList) 
            EmptyPropertyList = tempList;
    }
    return EmptyPropertyList;
}

ReflectEventList* GetEmptyEventList()
{
    if (!EmptyEventList) {
        ReflectEventList *tempList = (ReflectEventList*) 
            SystemDomain::System()->GetReflectionHeap()->AllocMem(sizeof(ReflectEventList));
        if (tempList == NULL)
            FatalOutOfMemoryError();
        tempList->dwEvents = 0;
        tempList->dwTotal = 0;
        if (!EmptyEventList) 
            EmptyEventList = tempList;
    }
    return EmptyEventList;
}

ReflectFieldList* GetEmptyFieldList()
{
    if (!EmptyFieldList) {
        ReflectFieldList *tempList = (ReflectFieldList*) 
            SystemDomain::System()->GetReflectionHeap()->AllocMem(sizeof(ReflectFieldList));
        if (tempList == NULL)
            FatalOutOfMemoryError();
        tempList->dwFields = 0;
        tempList->dwTotal = 0;
        if (!EmptyFieldList) 
            EmptyFieldList = tempList;
    }
    return EmptyFieldList;
}


void* ReflectClass::operator new(size_t s, void *pBaseDomain)
{
    return ((BaseDomain*)pBaseDomain)->GetReflectionHeap()->AllocMem((ULONG)s);
}

void ReflectClass::operator delete(void* p, size_t s)
{
    _ASSERTE(!"Delete in Loader Heap");
}

// FindReflectMethod
// Given a member find it inside this class
ReflectMethod* ReflectClass::FindReflectMethod(MethodDesc* pMeth)
{
    ReflectMethod *pRefMeth = GetMethods()->FindMethod(pMeth);
    _ASSERTE(pRefMeth && "Method Not Found");
    return pRefMeth;
}

// FindReflectConstructor
// Given a member find it inside this class
ReflectMethod* ReflectClass::FindReflectConstructor(MethodDesc* pMeth)
{
    ReflectMethod *pRefCons = GetConstructors()->FindMethod(pMeth);
    _ASSERTE(pRefCons && "Constructor Not Found");
    return pRefCons;
}

// FindReflectField
// Given a member find it inside this class
ReflectField* ReflectClass::FindReflectField(FieldDesc* pField)
{
    ReflectFieldList* p = GetFields();
    for (DWORD i = 0; i < p->dwTotal; i++) {
        if (p->fields[i].pField == pField)
            return &p->fields[i];
    }
    _ASSERTE(!"Field Not Found");
    return 0;
}

// FindReflectProperty
// Given a member find it inside this class
ReflectProperty* ReflectClass::FindReflectProperty(mdProperty propTok)
{
    ReflectPropertyList* p = GetProperties();
    for (DWORD i = 0; i < p->dwTotal; i++) {
        if (p->props[i].propTok == propTok)
            return &p->props[i];
    }
    _ASSERTE(!"Property Not Found");
    return 0;
}

TypeHandle ReflectClass::FindTypeHandleForMethod(MethodDesc* method) {

    MethodTable* pMT = method->GetMethodTable();


    if (!pMT->IsArray()) {          // Does the method belong to a normal class (ie System.Object)?
        _ASSERTE(!pMT->HasSharedMethodTable());  // currently assume that only arrays have shared method tables
        return(TypeHandle(pMT));
    }

    TypeHandle ret = GetTypeHandle();
    do {
        if (pMT == ret.GetMethodTable())
            return(ret);
        ret = ret.GetParent();
    } while (!ret.IsNull());

    _ASSERTE(!"Could not find method's type handle");
    return(ret);

}

void ReflectBaseClass::GetName(LPCUTF8* szcName, LPCUTF8* szcNameSpace) 
{
    _ASSERTE(szcName);
    LPCUTF8 pNamespace = NULL;
    IMDInternalImport *pImport = m_pEEC->GetMDImport();
    mdTypeDef mdClass = m_pEEC->GetCl();
    pImport->GetNameOfTypeDef(mdClass, szcName, &pNamespace);
    if (szcNameSpace) {
        if (IsNested()) {
            // get the namespace off the outer most class
            LPCUTF8 szcOuterName = NULL;
            while (SUCCEEDED(pImport->GetNestedClassProps(mdClass, &mdClass)));
            pImport->GetNameOfTypeDef(mdClass, &szcOuterName, szcNameSpace);
        } 
        else
            *szcNameSpace = pNamespace;
    }
}

// GetMethods
// This will return the methods associated with a Base object
void ReflectBaseClass::InternalGetMethods() 
{
    ReflectMethodList *pMeths = ReflectMethods::GetMethods(this, 0);
    FastInterlockCompareExchange ((void**)&m_pMeths, *(void**)&pMeths, NULL);
}

// GetProperties
// This will return the properties associated with a Base object
void ReflectBaseClass::InternalGetProperties()
{
    ReflectPropertyList* pProps = ReflectProperties::GetProperties(this, m_pEEC);
    if (!pProps) {
        pProps = GetEmptyPropertyList();
    }
    FastInterlockCompareExchange ((void**)&m_pProps, *(void**)&pProps, NULL);
}

void ReflectBaseClass::InternalGetEvents()
{
    ReflectEventList *pEvents = ReflectEvents::GetEvents(this, m_pEEC);
    if (!pEvents) {
        pEvents = GetEmptyEventList();
    }
    FastInterlockCompareExchange ((void**)&m_pEvents, *(void**)&pEvents, NULL);
}

// GetNestedTypes
// This will return a list of all the nested types defined for the type
void ReflectBaseClass::InternalGetNestedTypes()
{
    ReflectTypeList *pNestedTypes = ReflectNestedTypes::Get(this);
    if (pNestedTypes == 0) 
        pNestedTypes = GetEmptyTypeList();
    FastInterlockCompareExchange ((void**)&m_pNestedTypes, *(void**)&pNestedTypes, NULL);
}

// GetConstructors
// This will return the constructors associated with a Base object
ReflectMethodList* ReflectBaseClass::GetConstructors()
{
    if (!m_pCons) {
        // Get all the ctors
        ReflectMethodList *pCons = ReflectCtors::GetCtors(this);
        FastInterlockCompareExchange ((void**)&m_pCons, *(void**)&pCons, NULL);
        _ASSERTE(m_pCons);
    }
    return m_pCons;
}

// GetFields
// This will return the fields associated with a Base object
ReflectFieldList* ReflectBaseClass::GetFields()
{
    if (!m_pFlds) {
        // Get all the fields
        ReflectFieldList *pFlds = ReflectFields::GetFields(m_pEEC);
        if (!pFlds) {
            pFlds = GetEmptyFieldList();
        }
        FastInterlockCompareExchange ((void**)&m_pFlds, *(void**)&pFlds, NULL);
        _ASSERTE(m_pFlds);
    }
    return m_pFlds;
}

// Init
// This will initalize the Array class.  This method differs
//  from the base init.
void ReflectArrayClass::Init(ArrayTypeDesc* arrayType)
{
    // Save off the EEClass
    m_pMeths = 0;
    m_pCons = 0;
    m_pFlds = 0;
    m_pEEC = arrayType->GetMethodTable()->GetClass();
    m_pArrayType = arrayType;

    // Initalize the Class Object
    GetDomain()->AllocateObjRefPtrsInLargeTable(1, &m_ExposedClassObject);
}

void ReflectArrayClass::GetName(LPCUTF8* szcName,LPCUTF8* szcNameSpace) 
{
    if (m_szcName == 0) {
        CQuickBytes qb;
        LPSTR nameBuff = (LPSTR) qb.Alloc(MAX_CLASSNAME_LENGTH * sizeof(CHAR));
        if (nameBuff == NULL)
            FatalOutOfMemoryError();
        unsigned len = m_pArrayType->GetName(nameBuff, MAX_CLASSNAME_LENGTH);
        LPUTF8 szcName = (LPUTF8) GetDomain()->GetReflectionHeap()->AllocMem(len+1);
        if (szcName == NULL)
            FatalOutOfMemoryError();
        strcpy(szcName, nameBuff);
        FastInterlockCompareExchange ((void**)&m_szcName, *(void**)&szcName, NULL);
    }
    if (szcNameSpace)
        *szcNameSpace = 0;
    *szcName = m_szcName;
}

// GetClassObject
// The class object for an array is stored in ReflectArrayClass
//  If this is not found we will create it.  Otherwise simply return
//  it.
OBJECTREF ReflectArrayClass::GetClassObject()
{
    // Check to see if we've allocated an object yet? 
    if (*m_ExposedClassObject == NULL) {

        // No object, so create it an initalize it.
        REFLECTCLASSBASEREF RefClass = (REFLECTCLASSBASEREF) AllocateObject(g_pRefUtil->GetClass(RC_Class));

        // Set the data in the COM+ object
        RefClass->SetData(this);
        SetObjectReferenceSafe(m_ExposedClassObject, (OBJECTREF)RefClass, (RefClass->GetMethodTable()->IsShared()) ? 
                                                                                                NULL : 
                                                                                                (AppDomain*)RefClass->GetMethodTable()->GetDomain());
    }
    return *m_ExposedClassObject;
}


ReflectFieldList* ReflectArrayClass::GetFields()
{
    // There are not fields in Arrays.  Length is implemented
    //  as UpperBound...
    if (!m_pFlds) {
        ReflectFieldList *pFlds = (ReflectFieldList*)   GetDomain()->GetReflectionHeap()->AllocMem(sizeof(ReflectFieldList));
        if (pFlds == NULL)
            FatalOutOfMemoryError();
        pFlds->dwFields = 0;
        pFlds->dwTotal = 0;
        FastInterlockCompareExchange ((void**)&m_pFlds, *(void**)&pFlds, NULL);
    }
    return m_pFlds;
}

void ReflectArrayClass::InternalGetMethods()
{
    ReflectMethodList *pMeths = ReflectMethods::GetMethods(this, 1);
    for (DWORD i = 0; i < pMeths->dwTotal; i++) {
        if (pMeths->methods[i].typeHnd.IsNull()) 
            pMeths->methods[i].typeHnd = FindTypeHandleForMethod(pMeths->methods[i].pMethod);
    }
    FastInterlockCompareExchange ((void**)&m_pMeths, *(void**)&pMeths, NULL);
}

void ReflectArrayClass::InternalGetProperties()
{
    ReflectPropertyList *pProps = ReflectProperties::GetProperties(this, GetClass());
    FastInterlockCompareExchange ((void**)&m_pProps, *(void**)&pProps, NULL);
}

void ReflectArrayClass::InternalGetEvents()
{
    m_pEvents = GetEmptyEventList();
}

void ReflectArrayClass::InternalGetNestedTypes()
{
    m_pNestedTypes = GetEmptyTypeList();
}

ReflectMethodList* ReflectArrayClass::GetConstructors()
{
    THROWSCOMPLUSEXCEPTION();

    if (!m_pCons) {
        MethodDesc**    rgpMD;

        //@TODO: Today this is broken because the Members appear in the VTable side
        //  they should only be in the non-vtable
        //DWORD vtableSlots = m_pEEC->GetNumVtableSlots();
        DWORD vtableSlots = 0;
        DWORD totalSlots = m_pEEC->GetNumMethodSlots();
        rgpMD = (MethodDesc**) _alloca(sizeof(MethodDesc*) * (totalSlots - vtableSlots));

        DWORD dwCurIndex = 0;
        for (DWORD i = vtableSlots; i < totalSlots; i++)
        {
            MethodDesc* pCurMethod = m_pEEC->GetUnknownMethodDescForSlot(i);
            if (pCurMethod == NULL)
                continue;

            //@TODO: Looks like this bit is not set
            //DWORD dwCurMethodAttrs = pCurMethod->GetAttrs();
            //if (!IsMdRTSpecialName(dwCurMethodAttrs))
            //  continue;

            if (strcmp(COR_CTOR_METHOD_NAME,pCurMethod->GetName()) != 0)
                continue;

            rgpMD[dwCurIndex++] = pCurMethod;
        }

        ReflectMethodList *pCons = (ReflectMethodList*) 
            GetDomain()->GetReflectionHeap()->AllocMem(sizeof(ReflectMethodList) + 
            (sizeof(ReflectMethod) * (dwCurIndex - 1)));
        if (!pCons)
            COMPlusThrowOM();
        pCons->dwMethods = dwCurIndex;
        pCons->dwTotal = dwCurIndex;
        if (!m_pCons) {
            for (i=0;i<dwCurIndex;i++) {
                pCons->methods[i].pMethod = rgpMD[i];
                pCons->methods[i].szName = pCons->methods[i].pMethod->GetName((USHORT) i);
                pCons->methods[i].dwNameCnt = (DWORD)strlen(pCons->methods[i].szName);
                pCons->methods[i].pSignature = 0;
                GetDomain()->AllocateObjRefPtrsInLargeTable(1, &(pCons->methods[i].pMethodObj));
                pCons->methods[i].typeHnd = FindTypeHandleForMethod(rgpMD[i]);
                pCons->methods[i].attrs = pCons->methods[i].pMethod->GetAttrs();
                if (i > 0) 
                    pCons->methods[i - 1].pNext = &pCons->methods[i]; // link the ctors together so we can access them either way (array or list)
            }
            FastInterlockCompareExchange ((void**)&m_pCons, *(void**)&pCons, NULL);
        }
    }
    return m_pCons;
}

REFLECTBASEREF  ReflectMethod::GetMethodInfo(ReflectClass* pRC)
{
    if (*pMethodObj == NULL)
    {
        REFLECTBASEREF refMethod = (REFLECTBASEREF) g_pRefUtil->CreateReflectClass(RC_Method,pRC,this);
        _ASSERTE(refMethod != NULL); 
        SetObjectReferenceSafe(pMethodObj, (OBJECTREF)refMethod, (refMethod->GetMethodTable()->IsShared()) ? 
                                                                                                NULL : 
                                                                                                (AppDomain*)refMethod->GetMethodTable()->GetDomain());
    }
    return (REFLECTBASEREF)(*pMethodObj);
}

REFLECTBASEREF  ReflectMethod::GetConstructorInfo(ReflectClass* pRC)
{
    if (*pMethodObj == NULL)
    {
        REFLECTBASEREF refMethod = (REFLECTBASEREF) g_pRefUtil->CreateReflectClass(RC_Ctor,pRC,this);
        _ASSERTE(refMethod != NULL); 
        SetObjectReferenceSafe(pMethodObj, (OBJECTREF)refMethod, (refMethod->GetMethodTable()->IsShared()) ? 
                                                                                                NULL : 
                                                                                                (AppDomain*)refMethod->GetMethodTable()->GetDomain());
    }
    return (REFLECTBASEREF)(*pMethodObj);
}

REFLECTTOKENBASEREF  ReflectProperty::GetPropertyInfo(ReflectClass* pRC)
{
    if (*pPropObj == NULL)
    {
        REFLECTTOKENBASEREF refProp = (REFLECTTOKENBASEREF) g_pRefUtil->CreateReflectClass(RC_Prop,pRC,this);
        _ASSERTE(refProp);
        SetObjectReferenceSafe(pPropObj, (OBJECTREF)refProp, (refProp->GetMethodTable()->IsShared()) ? 
                                                                                                NULL : 
                                                                                                (AppDomain*)refProp->GetMethodTable()->GetDomain());
    }
    return (REFLECTTOKENBASEREF)(*pPropObj);
}

REFLECTTOKENBASEREF  ReflectEvent::GetEventInfo(ReflectClass* pRC)
{
    if (*pEventObj == NULL)
    {
        REFLECTTOKENBASEREF refEvent = (REFLECTTOKENBASEREF) g_pRefUtil->CreateReflectClass(RC_Event,pRC,this);
        refEvent->SetToken(eventTok);
        _ASSERTE(refEvent);
        SetObjectReferenceSafe(pEventObj, (OBJECTREF)refEvent, (refEvent->GetMethodTable()->IsShared()) ? 
                                                                                                NULL : 
                                                                                                (AppDomain*)refEvent->GetMethodTable()->GetDomain());
    }
    return (REFLECTTOKENBASEREF)(*pEventObj);
}

REFLECTBASEREF  ReflectField::GetFieldInfo(ReflectClass* pRC)
{
    if (*pFieldObj == NULL)
    {
        REFLECTBASEREF refField = REFLECTBASEREF(g_pRefUtil->CreateReflectClass(RC_Field,pRC,this));
        _ASSERTE(refField);
        SetObjectReferenceSafe(pFieldObj, (OBJECTREF)refField, (refField->GetMethodTable()->IsShared()) ? 
                                                                                                NULL : 
                                                                                                (AppDomain*)refField->GetMethodTable()->GetDomain());
    }
    return (REFLECTBASEREF)(*pFieldObj);
}

mdToken ReflectField::GetToken() {
    return pField->GetMemberDef();
}

Module* ReflectField::GetModule() {
    return pField->GetModule();
}

ReflectMethod* ReflectMethodList::FindMethod(mdMethodDef mb)
{
    for (DWORD i=0;i<dwTotal;i++) {
        if (methods[i].pMethod->GetMemberDef() == mb)
            return &methods[i];
    }
    return 0;
}

ReflectMethod* ReflectMethodList::FindMethod(MethodDesc* pMeth)
{
    for (DWORD i=0;i<dwTotal;i++) {
        if (methods[i].pMethod == pMeth)
            return &methods[i];
    }

    // We didn't find it, it may be a unboxed method and we need to 
    //  unboxing stub instead...
    EEClass* pEEC = pMeth->GetClass();
    if (pEEC && pEEC->IsValueClass()) {
        // Find the non virtual version (unboxing stub) of this method
        if (pMeth->IsVirtual()) {
            DWORD vtableSlots = pEEC->GetNumVtableSlots();

            // Get the name and signature info
            LPCUTF8 szName = pMeth->GetName();
            PCCOR_SIGNATURE  pP1Sig;
            DWORD            cP1Sig;
            pMeth->GetSig(&pP1Sig, &cP1Sig);

            // go through the non-virtual part of the method table
            //  looking for the method.
            for (DWORD i=0;i<vtableSlots;i++) {
                MethodDesc* pCurMethod = pEEC->GetUnknownMethodDescForSlot(i);

                // Compare the method name followed by the signature...
                LPCUTF8 szCurName = pCurMethod->GetName();
                if (strcmp(szName,szCurName) == 0) {
                    PCCOR_SIGNATURE  pP2Sig;
                    DWORD            cP2Sig;
    
                    pCurMethod->GetSig(&pP2Sig, &cP2Sig);

                    // if the signatures match, this this must be our
                    //  real method.
                    if (MetaSig::CompareMethodSigs(pP1Sig,cP1Sig,pMeth->GetModule(),
                            pP2Sig,cP2Sig,pCurMethod->GetModule())) {
                        // search for the method again...
                        for (DWORD i=0;i<dwMethods;i++) {
                            if (methods[i].pMethod == pCurMethod)
                                return &methods[i];
                        }
                        _ASSERTE(!"Didn't find unboxing stub!");
                    }
                }
            }
        }
    }
    // @TODO: This seems like a bug
    return 0;
}

void ReflectMethodHash::Init(ReflectMethodList* meths)
{
    memset(_buckets,0,sizeof(_buckets));
    memset(_ignBuckets,0,sizeof(_ignBuckets));

    DWORD i;
    int max = 0;
    for (i=0;i<meths->dwMethods;i++) {
        DWORD dwHash = HashStringA(meths->methods[i].szName);
        int len = (int)strlen(meths->methods[i].szName);
        if (len > max)
            max = len;
        dwHash = dwHash % REFLECT_BUCKETS;
        meths->methods[i].pNext = _buckets[dwHash];
        _buckets[dwHash] = &meths->methods[i];
    }

    LPUTF8 szName = (LPUTF8) _alloca(max + 1);
    for (i=0;i<meths->dwMethods;i++) {
        int len = (int)strlen(meths->methods[i].szName);
        for (int j=0;j<len;j++)
            szName[j] = tolower(meths->methods[i].szName[j]);
        szName[j] = 0;
        DWORD dwHash = HashStringA(szName);
        dwHash = dwHash % REFLECT_BUCKETS;
        meths->methods[i].pIgnNext = _ignBuckets[dwHash];
        _ignBuckets[dwHash] = &meths->methods[i];
    }
}

ReflectMethod*  ReflectMethodHash::Get(LPCUTF8 szName)
{
    DWORD dwHash = HashStringA(szName);
    dwHash = dwHash % REFLECT_BUCKETS;
    return _buckets[dwHash];
}

ReflectMethod*  ReflectMethodHash::GetIgnore(LPCUTF8 szName)
{
    int len = (int)strlen(szName);
    LPUTF8 szHashName = (LPUTF8) _alloca(len + 1);
    for (int j=0;j<len;j++)
        szHashName[j] = tolower(szName[j]);
    szHashName[j] = 0;
    DWORD dwHash = HashStringA(szHashName);
    dwHash = dwHash % REFLECT_BUCKETS;
    return _ignBuckets[dwHash];
}

void ReflectTypeDescClass::Init(ParamTypeDesc *td)
{
    // Store the TypeHandle
    m_pTypeDesc = td;

    // The name is lazy allocated.
    m_szcName = 0;
    m_szcNameSpace = 0;
    m_pCons = 0;
    m_pFlds = 0;

    // Initalize the Class Object
    GetDomain()->AllocateObjRefPtrsInLargeTable(1, &m_ExposedClassObject);
}

OBJECTREF ReflectTypeDescClass::GetClassObject()
{
    // Check to see if we've allocated an object yet? 
    if (*m_ExposedClassObject == NULL) {

        // No object, so create it an initalize it.
        REFLECTCLASSBASEREF RefClass = (REFLECTCLASSBASEREF) AllocateObject(g_pRefUtil->GetClass(RC_Class));

        // Set the data in the COM+ object
        RefClass->SetData(this);
        SetObjectReferenceSafe(m_ExposedClassObject, (OBJECTREF)RefClass, (RefClass->GetMethodTable()->IsShared()) ? 
                                                                                                NULL : 
                                                                                                (AppDomain*)RefClass->GetMethodTable()->GetDomain());
    }
    return *m_ExposedClassObject;
}

void ReflectTypeDescClass::GetName(LPCUTF8* szcName,LPCUTF8* szcNameSpace) 
{
    if (m_szcName == 0) {
        CQuickBytes qb;
        LPSTR nameBuff = (LPSTR) qb.Alloc(MAX_CLASSNAME_LENGTH * sizeof(CHAR));
        unsigned len = m_pTypeDesc->GetName(nameBuff, MAX_CLASSNAME_LENGTH);
        LPUTF8 szcName, szcNameSpace = (LPUTF8) GetDomain()->GetReflectionHeap()->AllocMem(len+1);
        if (szcNameSpace == NULL)
            FatalOutOfMemoryError();
        strcpy(szcNameSpace, nameBuff);
        while (szcNameSpace[len] != '.' && len > 0) len--;
        if (len != 0) {
            szcNameSpace[len] = 0;
            szcName = &szcNameSpace[len+1];
        }
        else {
            szcName = szcNameSpace;
            szcNameSpace = 0;
        }
        FastInterlockCompareExchange ((void**)&m_szcNameSpace, *(void**)&szcNameSpace, NULL);
        FastInterlockCompareExchange ((void**)&m_szcName, *(void**)&szcName, NULL);
    }
    if (szcNameSpace)
        *szcNameSpace = m_szcNameSpace;
    *szcName = m_szcName;
}

void ReflectTypeDescClass::InternalGetMethods()
{
    if (!m_pMeths) {
        ReflectMethodList *pMeths = (ReflectMethodList*) GetDomain()->GetReflectionHeap()->AllocMem(sizeof(ReflectMethodList));
        if (pMeths == NULL)
            FatalOutOfMemoryError();
        pMeths->dwMethods = 0;
        pMeths->dwTotal = 0;
        FastInterlockCompareExchange ((void**)&m_pMeths, *(void**)&pMeths, NULL);
    }
}

ReflectMethodList* ReflectTypeDescClass::GetConstructors()
{
    if (!m_pCons) {
        ReflectMethodList *pCons = (ReflectMethodList*)  GetDomain()->GetReflectionHeap()->AllocMem(sizeof(ReflectMethodList));
        if (pCons == NULL)
            FatalOutOfMemoryError();
        pCons->dwMethods = 0;
        pCons->dwTotal = 0;
        FastInterlockCompareExchange ((void**)&m_pCons, *(void**)&pCons, NULL);
    }
    return m_pCons;
}

ReflectFieldList* ReflectTypeDescClass::GetFields()
{
    // There are not fields in pointers.  Length is implemented
    //  as UpperBound...
    if (!m_pFlds) {
        ReflectFieldList *pFlds = (ReflectFieldList*)   GetDomain()->GetReflectionHeap()->AllocMem(sizeof(ReflectFieldList));
        if (pFlds == NULL)
            FatalOutOfMemoryError();
        pFlds->dwFields = 0;
        pFlds->dwTotal = 0;
        FastInterlockCompareExchange ((void**)&m_pFlds, *(void**)&pFlds, NULL);
    }
    return m_pFlds;
}

void ReflectTypeDescClass::InternalGetProperties()
{
    m_pProps = GetEmptyPropertyList();
}

void ReflectTypeDescClass::InternalGetEvents()
{
    m_pEvents = GetEmptyEventList();
}

void ReflectTypeDescClass::InternalGetNestedTypes()
{
    m_pNestedTypes = GetEmptyTypeList();
}

Module* ReflectTypeDescClass::GetModule()
{
    return m_pTypeDesc->GetModule();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\reflectwrap.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _REFLECTWRAP_H_
#define _REFLECTWRAP_H_

#include "ExpandSig.h"

class ReflectClass;

// Reflect Base is the base class for an object 
class ReflectBase {
};

// dwFlags bitmap
#define RM_ATTR_INITTED          0x80000000
#define RM_ATTR_NEED_SECURITY    0x00000001
#define RM_ATTR_NEED_PRESTUB     0x00000002
#define RM_ATTR_DONT_VIRTUALIZE  0x00000004
#define RM_ATTR_BYREF_FLAG_SET   0x00000008
#define RM_ATTR_HAS_BYREF_ARG    0x00000010
#define RM_ATTR_IS_CTOR          0x00000020
#define RM_ATTR_RISKY_METHOD     0x00000040
#define RM_ATTR_SECURITY_IMPOSED 0x00000080

// ReflectMethod
// This class is abstracts a method from the low-level representation
class ReflectMethod  : public ReflectBase {
public:
	MethodDesc*		pMethod;		// Pointer to Method
	LPCUTF8			szName;			// Pointer to name
	DWORD			dwNameCnt;		// Strlen of name
	ExpandSig*		pSignature;		// Signature
    OBJECTREF*      pMethodObj;    	// The method
	DWORD			attrs;			// The Method Attributes
	TypeHandle      typeHnd;		// The enclosing type (needed for arrays)
    DWORD           dwFlags;        // Some properties of the method, to avoid recalculation

	// Hash of the name
	ReflectMethod*	pNext;
	ReflectMethod*	pIgnNext;

	REFLECTBASEREF  GetMethodInfo(ReflectClass* pRC);
	REFLECTBASEREF  GetConstructorInfo(ReflectClass* pRC);
	ExpandSig*		GetSig();

	// Common booleans...
    inline DWORD IsPublic() {
        return IsMdPublic(attrs);
    }
	inline DWORD IsStatic() {
		return IsMdStatic(attrs);
	}
    
    mdToken GetToken() {
        return pMethod->GetMemberDef();
    }

    Module* GetModule() {
        return pMethod->GetModule();
    }
};

#define REFLECT_BUCKETS 13
class ReflectMethodList;
class ReflectMethodHash
{
private:
	ReflectMethod*	_buckets[REFLECT_BUCKETS];
	ReflectMethod*	_ignBuckets[REFLECT_BUCKETS];

public:
	void Init(ReflectMethodList* meths);
	ReflectMethod*	Get(LPCUTF8 szName);
	ReflectMethod*  GetIgnore(LPCUTF8 szName);
};

class ReflectMethodList {
public:
	DWORD				dwMethods;		// Number of methods
	DWORD				dwTotal;		// Number of methods including the statics from base classes
	ReflectMethodHash	hash;

	ReflectMethod		methods[1];		// Array of methods

	ReflectMethod*		FindMethod(mdMethodDef mb);
	ReflectMethod*		FindMethod(MethodDesc* pMeth);
};


class ReflectField : public ReflectBase { 
public:
	FieldDesc*		pField;			// Pointer to the Field
    OBJECTREF*      pFieldObj;    	// The field
    TypeHandle      thField;        // Typehandle
    CorElementType  type;           //
    DWORD           dwAttr;          //

	REFLECTBASEREF  GetFieldInfo(ReflectClass* pRC);
    mdToken GetToken();
    Module* GetModule();

};

class ReflectFieldList {
public:
	DWORD			dwFields;		// Number of fields
	DWORD			dwTotal;		// Number of fields including the statics from base classes
	ReflectField	fields[1];		// Array of fiels
};

class ReflectTypeList {
public:
	DWORD			dwTypes;		// Number of types
	EEClass*		types[1];		// Array of pointers to types
};

// the list of others method for a property
struct PropertyOtherList {
    ReflectMethod       *pMethod;
    PropertyOtherList   *pNext;
};

class ReflectProperty : public ReflectBase {
public:
	LPCUTF8			    szName;			// Pointer to name
	mdProperty		    propTok;		// Token for the property
	Module*			    pModule;		// The module that defines the property
	EEClass*		    pDeclCls;		// Pointer to declaring class
	ReflectClass*	    pRC;			// Parent Pointer....
	ExpandSig*		    pSignature;		// Signature
	DWORD               attr;           // Attributes
	ReflectMethod*	    pSetter;
	ReflectMethod*	    pGetter;	
    PropertyOtherList*  pOthers;
    OBJECTREF*          pPropObj;    	// The method

	REFLECTTOKENBASEREF  GetPropertyInfo(ReflectClass* pRC);
    
    mdToken GetToken() {
        return propTok;
    }

    Module* GetModule() {
        return pModule;
    }
};

class ReflectPropertyList {
public:
	DWORD			dwProps;		// Number of properties
	DWORD			dwTotal;		// Number of properties including the statics from base classes
	ReflectProperty	props[1];		// Array of properties
};

class ReflectEvent : public ReflectBase {
public:
	LPCUTF8			szName;			// pointer to the name
	mdEvent			eventTok;		// The event token
	Module*			pModule;		// The module that defines the event
	EEClass*		pDeclCls;		// The declaring class
	DWORD			attr;			// The flags
	ReflectClass*	pRC;			// Parent Pointer...
	ReflectMethod*	pAdd;			// The add method
	ReflectMethod*	pRemove;		// The remove method
	ReflectMethod*	pFire;			// The fire method
    OBJECTREF*      pEventObj;    	// The method

	REFLECTTOKENBASEREF  GetEventInfo(ReflectClass* pRC);

    mdToken GetToken() {
        return eventTok;
    }

    Module* GetModule() {
        return pModule;
    }
};

class ReflectEventList {
public:
	DWORD			dwEvents;		// Number of events
	DWORD			dwTotal;		// Number of events including the statics from base classes
	ReflectEvent	events[1];		// Array of events.
};

// Base class for all Class implementations.  There
//	are three types of classes supported by the runtime
//	BaseClass are the normal objects used by the runtime.
//	ArrayClass are the array objects used by the runtime.
//  ComClass are the COM classic objects used by the runtime.
class ReflectClass : public ReflectBase {
public:

	// GetCorElementType
	// Return the GetCorElementType
	virtual CorElementType GetCorElementType() = 0;

	// GetSigElementType
	// How this class will look like in signature
	virtual CorElementType GetSigElementType() = 0;

	// IsArray
	// Indicates if the Class represents an Array
	virtual BOOL IsArray() = 0;

	// IsTypeDesc
	// The Type is a TypeDesc
	virtual BOOL IsTypeDesc() = 0;

	virtual BOOL IsByRef() = 0;

	virtual BOOL IsNested() = 0;
	
    // a bit of a HACK: we define this to return FALSE so we only need to ovverride the method in ReflectBaseClass to return TRUE
    virtual BOOL IsClass() {
        return FALSE;
    }

	// GetAttributes
	// Returns the attributes defined on the class.
	virtual DWORD GetAttributes() = 0;

    // GetName
	// This routine will return both the name and the namespace assocated with
	//	a class
	// szcName -- Pointer to return the UTF8 name string
	// szcNameSpace -- Pointer to return the UTF8 name space string
	virtual void GetName(LPCUTF8* szcName,LPCUTF8* szcNameSpace) = 0;

	// Init
	// This is the initalization of the object.  There may be multiple
	//	Init depending upon what the object is.
	// pEEC -- The EEClass for this object.
	virtual void Init(EEClass* pEEC) = 0;

    // Return the domain of the type
    virtual BaseDomain *GetDomain() = 0;

	// GetClass
	// GetClass will return the EEClass.  This is a bit of a hack because
	//	not all Objects will have an EEClass (COM classic objects.)

	inline EEClass* GetClass()
	{
		return m_pEEC;
	}

	virtual TypeHandle GetTypeHandle()
	{
		_ASSERTE(!IsArray());
		return(TypeHandle(m_pEEC->GetMethodTable()));
	}

	// GetClassObject
	// This will return the class object associated with this class.
	virtual OBJECTREF GetClassObject() = 0;

	// GetMDImport
	// This will return the meta data internal interface that contains
	// within itself the metadata object.
	virtual IMDInternalImport* GetMDImport() = 0;

	// GetCL
	// This will return the meta data token of the object.  Not all
	//	objects have a Token.
	virtual mdTypeDef GetCl() = 0;
	
    virtual Module* GetModule() = 0;

    mdToken GetToken() {
        return GetCl();
    }
	// GetMethods
	// This will return a list of all of the methods defined
	//	on an object.
	FORCEINLINE ReflectMethodList* GetMethods()
	{
		if (!m_pMeths)
			InternalGetMethods();
		return m_pMeths;
	}

	// GetNestedTypes
	// This will return a list of all the nested types defined for the type
	FORCEINLINE ReflectTypeList* GetNestedTypes()
	{
		if (!m_pNestedTypes)
			InternalGetNestedTypes();
		return m_pNestedTypes;
	}

	// InvalidateCachedNestedTypes
	// Invalidate the cached nested type information
	FORCEINLINE void InvalidateCachedNestedTypes()
	{
		m_pNestedTypes = NULL;
	}


	// GetProperties
	// This will return a list of all the properties defined for the object
	FORCEINLINE ReflectPropertyList* GetProperties()
	{
		if (!m_pProps)
			InternalGetProperties();
		return m_pProps;
	}

	// GetEvents
	// This will return a list of all the events defined for the object
	FORCEINLINE ReflectEventList* GetEvents()
	{
		if (!m_pEvents)
			InternalGetEvents();
		return m_pEvents;
	}

	// GetConstructors
	// This will return a list of all of the constructors defined
	//	on an object.
	virtual ReflectMethodList* GetConstructors() = 0;

	// GetFields
	// This will return a list of all of the Fields defined
	//	on an object.
	virtual ReflectFieldList* GetFields() = 0;

	// FindMethod
	// Given a Meta data token mb, find that method on this
	//	object.
	// mb -- the meta data token of the method to find.
	virtual MethodDesc* FindMethod(mdMethodDef mb) = 0;

	// GetStaticFieldCount
	// Return the count of static fields defined for object.  These
	//	represent the fields that are not stored in the internal structures
	virtual int GetStaticFieldCount() = 0;

	// SetStaticFieldCount
	// Set the count of static fields.
	// cnt - the count to set.
	virtual void SetStaticFieldCount(int cnt) = 0;

	// GetStaticFields
	// This returns a list of the static fields assocated with
	virtual FieldDesc* GetStaticFields() = 0;

	// SetStaticFields
	// This will store that list of static fields associated
	//	with the object
	virtual void SetStaticFields(FieldDesc* flds) = 0;

	// p -- this is the COM object.  
	virtual void SetCOMObject(void* p) = 0;

	virtual void* GetCOMObject() = 0;

	// Override allocation routines to use the COMClass Heap.
	// DONT Call delete.
	void* operator new(size_t s, void* pBaseDomain);
	void operator delete(void*, size_t);

	ReflectMethod* FindReflectMethod(MethodDesc* pMeth);
	ReflectMethod* FindReflectConstructor(MethodDesc* pMeth);
	ReflectField* FindReflectField(FieldDesc* pField);
    ReflectProperty* FindReflectProperty(mdProperty propTok);


protected:
	virtual void InternalGetMethods() = 0;
	virtual void InternalGetProperties() = 0;
	virtual void InternalGetEvents() = 0;
	virtual void InternalGetNestedTypes() = 0;
	TypeHandle FindTypeHandleForMethod(MethodDesc* method);

	EEClass*				m_pEEC;			// This is accessed a large number of times
	ReflectMethodList*		m_pMeths;		// The methods
	ReflectPropertyList*	m_pProps;		// The properties
	ReflectEventList*		m_pEvents;		// The events
	ReflectTypeList*		m_pNestedTypes;	// The nested types
};

// ReflectBaseClass
// This class represents the Base object defined in COM+.  It includes
//	all objects except Arrays and COM Classic objects.
class ReflectBaseClass : public ReflectClass {
public:

	// GetCorElementType
	// Return the GetCorElementType
	CorElementType GetCorElementType() 
	{
		return m_CorType;
	}

	// GetSigElementType
	// How this class will look like from the signature
	CorElementType GetSigElementType() 
	{
        LPCUTF8     szcName;
        LPCUTF8     szcNameSpace;

        if (m_SigType != ELEMENT_TYPE_END)
            return m_SigType;
        CorElementType sigType = m_CorType;
        
        GetName(&szcName, &szcNameSpace);

        if (m_CorType == ELEMENT_TYPE_CLASS)
        {            
            if (g_Mscorlib.IsClass(m_pEEC->GetMethodTable(), CLASS__OBJECT))
                sigType = ELEMENT_TYPE_OBJECT;
            else if (g_Mscorlib.IsClass(m_pEEC->GetMethodTable(), CLASS__STRING))
                sigType = ELEMENT_TYPE_STRING;
        }
        else if (m_CorType == ELEMENT_TYPE_I)
        {
            // Reverse the hack from class.cpp.
            if (strcmp(szcNameSpace, "System") == 0)
            {
                if (strcmp(szcName, g_RuntimeTypeHandleName) == 0 || 
                    strcmp(szcName, g_RuntimeMethodHandleName) == 0 ||
                    strcmp(szcName, g_RuntimeFieldHandleName) == 0 ||
                    strcmp(szcName, g_RuntimeArgumentHandleName) == 0)
                    sigType = ELEMENT_TYPE_VALUETYPE;
            }
        }
        m_SigType = sigType;
		return m_SigType;
	}

	BOOL IsArray()
	{
		return m_pEEC->IsArrayClass();
	}

	BOOL IsTypeDesc()
	{
		return 0;
	}

	BOOL IsByRef()
	{
		return 0;
	}

	BOOL IsNested()
    {
        return m_pEEC->IsNested();
    }

    virtual BOOL IsClass() {
        return TRUE;
    }

	DWORD GetAttributes()
	{
		return m_pEEC->GetAttrClass();
	}

	Module* GetModule()
	{
		return m_pEEC->GetModule();
	}

	void GetName(LPCUTF8* szcName, LPCUTF8* szcNameSpace);

    BaseDomain *GetDomain()
    {
        return m_pEEC->GetDomain();
    }

	void Init(EEClass* pEEC)
	{
		m_pEEC = pEEC;
		m_pMeths = 0;
		m_pCons = 0;
		m_pFlds = 0;
		m_StatFldCnt = -1;
		m_Fields = 0;
		m_pClassFact = 0;

		// There is a special case in reflection for 
		//	Enums because they are typed by the runtime as their
		//	underlying type.
		if (!m_pEEC->IsEnum())
			m_CorType = m_pEEC->GetMethodTable()->GetNormCorElementType();
        else
			m_CorType = ELEMENT_TYPE_VALUETYPE;
        m_SigType = ELEMENT_TYPE_END;
	}

	EEClass* GetClass()
	{
		return m_pEEC;
	}

	OBJECTREF GetClassObject()
	{
		return m_pEEC->GetExposedClassObject();
	}

	IMDInternalImport* GetMDImport()
	{
		return m_pEEC->GetMDImport();
	}

	mdTypeDef GetCl()
	{
		return m_pEEC->GetCl();
	}

	ReflectMethodList* GetConstructors();
	ReflectFieldList* GetFields();

	MethodDesc* FindMethod(mdMethodDef mb)
	{
		return m_pEEC->FindMethod(mb);
	}

	int GetStaticFieldCount()
	{
		return m_StatFldCnt;
	}

	void SetStaticFieldCount(int cnt)
	{
		m_StatFldCnt = cnt;
	}

	FieldDesc* GetStaticFields()
	{
		return m_Fields;
	}

	void SetStaticFields(FieldDesc* flds)
	{
		m_Fields = flds;
	}

	void SetCOMObject(void* p)
	{
		m_pClassFact = p;
	}

	void* GetCOMObject()
	{
		return m_pClassFact;
	}

protected:
	void InternalGetMethods(); 
	void InternalGetProperties(); 
	void InternalGetEvents(); 
	void InternalGetNestedTypes();

private:
	ReflectMethodList*		m_pCons;
	ReflectFieldList*		m_pFlds;
	int						m_StatFldCnt;
	FieldDesc*				m_Fields;
	CorElementType			m_CorType;			// Do we really want to add this?
    CorElementType          m_SigType;          // the way this class will appear in metadata signature
	void*					m_pClassFact;
};

// ReflectArrayClass
// This class represents the array version of
//	the internal class.
class ReflectArrayClass : public ReflectClass
{
public:

	CorElementType GetCorElementType() 
	{
		return m_pEEC->GetMethodTable()->GetNormCorElementType();
	}

	// GetSigElementType
	// How this class will look like from the signature
	CorElementType GetSigElementType() 
	{
        return GetCorElementType();
	}


	BOOL IsArray()
	{
		return 1;
	}

	BOOL IsTypeDesc()
	{
		return 0;
	}

	BOOL IsByRef()
	{
		return 0;
	}

	BOOL IsNested()
    {
        DWORD dwAttr;
        EEClass *pClass = GetTypeHandle().GetClassOrTypeParam();
        pClass->GetMDImport()->GetTypeDefProps(pClass->GetCl(), &dwAttr, NULL);
        return IsTdNested(dwAttr);
    }

	DWORD GetAttributes()
	{
		return m_pEEC->GetAttrClass();
	}

	// Arrays simply differ to the EEClass.
	Module* GetModule()
	{
		return m_pArrayType->GetModule();
	}

	// GetName
	// This routine will return both the name and the namespace assocated with
	//	a class
	void GetName(LPCUTF8* szcName,LPCUTF8* szcNameSpace);

	void Init(ArrayTypeDesc* arrayType);
	void Init(EEClass*) {_ASSERTE(!"You must call the Init(EEClass,LPCUTF8,LPCUTF8) version");}

	EEClass* GetClass()
	{
		return m_pEEC;
	}

	OBJECTREF GetClassObject();

	IMDInternalImport* GetMDImport()
	{
		return m_pEEC->GetMDImport();
	}

	mdTypeDef GetCl()
	{
		return m_pEEC->GetCl();
	}

	ReflectMethodList* GetConstructors();
	ReflectFieldList* GetFields();

	MethodDesc* FindMethod(mdMethodDef mb)
	{
		return 0;
	}

	int GetStaticFieldCount()
	{
		return 0;
	}

	void SetStaticFieldCount(int cnt)
	{
	}

	FieldDesc* GetStaticFields()
	{
		return 0;
	}

	void SetStaticFields(FieldDesc* flds)
	{
	}

	void SetCOMObject(void* p)
	{
	}

	void* GetCOMObject()
	{
		return 0;
	}

	// GetElementType
	TypeHandle GetElementTypeHandle()
	{
		return m_pArrayType->GetElementTypeHandle();
	}

	TypeHandle GetTypeHandle()
	{
		return TypeHandle(m_pArrayType);
	}

    BaseDomain *GetDomain()
    {
        // don't want the domain of the array template, want the actual domain of the type itself
        return m_pArrayType->GetDomain();
    }

protected:
	void InternalGetMethods(); 
	void InternalGetProperties(); 
	void InternalGetEvents(); 
	void InternalGetNestedTypes();

private:
	ArrayTypeDesc*			m_pArrayType;			// My array type
	LPUTF8					m_szcName;				// Constructed Name
    OBJECTREF*			    m_ExposedClassObject;	// Pointer to the Class Object for this
	ReflectMethodList*		m_pCons;				// The constructors
	ReflectFieldList*		m_pFlds;				// The fields
};

// ReflectArrayClass
// This class represents the array version of
//	the internal class.
class ReflectTypeDescClass : public ReflectClass
{
public:

	CorElementType GetCorElementType() 
	{
		return m_pTypeDesc->GetNormCorElementType();
	}

	// GetSigElementType
	// How this class will look like from the signature
	CorElementType GetSigElementType() 
	{
        return GetCorElementType();
	}

	BOOL IsArray()
	{
		return 0;
	}

	BOOL IsTypeDesc()
	{
		return 1;
	}

	BOOL IsByRef()
	{
		return m_pTypeDesc->IsByRef();
	}

	BOOL IsNested()
    {
        DWORD dwAttr;
        EEClass *pClass = GetTypeHandle().GetClassOrTypeParam();
        pClass->GetMDImport()->GetTypeDefProps(pClass->GetCl(), &dwAttr, NULL);
        return IsTdNested(dwAttr);
    }

	DWORD GetAttributes()
	{
		return 0;
	}

	Module* GetModule();

	EEClass* GetClass()
	{
		// What do we do here?
		return 0;
	}

	IMDInternalImport* GetMDImport()
	{
		return 0;
	}

	mdTypeDef GetCl()
	{
		return 0;
	}

	ReflectMethodList* GetConstructors();
	ReflectFieldList* GetFields();

	MethodDesc* FindMethod(mdMethodDef mb)
	{
		return 0;
	}

	int GetStaticFieldCount()
	{
		return 0;
	}

	void SetStaticFieldCount(int cnt)
	{
	}

	FieldDesc* GetStaticFields()
	{
		return 0;
	}

	void SetStaticFields(FieldDesc* flds)
	{
	}

	void SetCOMObject(void* p)
	{
	}

	void* GetCOMObject()
	{
		return 0;
	}

	// GetName
	// This routine will return both the name and the namespace assocated with
	//	a class
	void GetName(LPCUTF8* szcName,LPCUTF8* szcNameSpace);

    BaseDomain *GetDomain()
    {
        return GetTypeHandle().GetClassOrTypeParam()->GetDomain();
    }

	void Init(ParamTypeDesc *td);
	void Init(EEClass*) {_ASSERTE(!"You must call the Init(EEClass,LPCUTF8,LPCUTF8) version");}

	OBJECTREF GetClassObject();

	TypeHandle GetTypeHandle()
	{
		return TypeHandle(m_pTypeDesc);
	}

protected:
	void InternalGetMethods();
	void InternalGetProperties();
	void InternalGetEvents();
	void InternalGetNestedTypes();

private:
	LPUTF8					m_szcName;				// TypeDesc Name
	LPUTF8					m_szcNameSpace;			// TypeDesc NameSpace
    OBJECTREF*			    m_ExposedClassObject;	// Pointer to the Class Object for this
	ParamTypeDesc	        *m_pTypeDesc;			// The ParamTypeDesc for this type
	ReflectMethodList*		m_pCons;				// Constructors
	ReflectFieldList*		m_pFlds;				// The fields
};


inline ExpandSig* ReflectMethod::GetSig()
{
    if (!pSignature) {
        PCCOR_SIGNATURE pCorSig;     // The signature of the found method
        DWORD			cSignature;
        pMethod->GetSig(&pCorSig,&cSignature);
        pSignature = ExpandSig::GetReflectSig(pCorSig,pMethod->GetModule());
    }
	return pSignature;
}

#endif	// _REFLECTWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\rexcep.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//====================================================================
//
// Purpose: Lists the commonly-used Runtime Exceptions visible to users.
// 
// Date: This file was generated on 98/08/31 11:51:02 AM
//
//====================================================================

// If you add an exception, modify CorError.h to add an HResult there.
// (Guidelines for picking a unique number for your HRESULT are in CorError.h)
// Also modify your managed Exception class to include its HResult.  
// Modify __HResults in the same directory as your exception, to include
// your new HResult.  And of course, add your exception and symbolic
// name for your HResult to the list below so it can be thrown from
// within the EE and recognized in Interop scenarios.


// This is an exhaustive list of all exceptions that can be
// thrown by the EE itself.  If you add to this list the IL spec
// needs to be updated!  Please see vancem or jsmiller if you
// add something here.   Thanks

// Note: When multiple exceptions map to the same hresult it is very important
//       that the exception that should be created when the hresult in question
//       is returned by a function be FIRST in the list.
//

// please email dennisan with any additions or deletions to this list


//
// These are the macro's that need to be implemented before this file is included.
//

//
// EXCEPTION_BEGIN_DEFINE(ns, reKind, hr)
//
// This macro starts an exception definition.
//
// ns          Namespace of the exception.
// reKind      Name of the exception.
// hr          Basic HRESULT that this exception maps to.
//

//
// #define EXCEPTION_ADD_HR(hr)
//
// This macro adds an additional HRESULT that maps to the exception.
//
// hr          Additional HRESULT that maps to the exception.
//

//
// #define EXCEPTION_END_DEFINE()
//
// This macro terminates the exception definition.
//


//
// Namespaces used to define the exceptions.
//


#include "namespace.h"

//
// A helper macro to define simple exceptions. A simple exception is an exception that maps
// to a single HR.
//

#define DEFINE_EXCEPTION_SIMPLE(ns, reKind, hr) \
    EXCEPTION_BEGIN_DEFINE(ns, reKind, hr) \
    EXCEPTION_END_DEFINE() \

// 
// This is a more convenient helper macro for exceptions when you need two different
// HRESULTs to map to the same exception.  You can pretty trivially expand this to
// support N different HRESULTs.
//

#define DEFINE_EXCEPTION_2HRESULTS(ns, reKind, hr1, hr2) \
    EXCEPTION_BEGIN_DEFINE(ns, reKind, hr1) \
    EXCEPTION_ADD_HR(hr2) \
    EXCEPTION_END_DEFINE() \

#define DEFINE_EXCEPTION_3HRESULTS(ns, reKind, hr1, hr2, hr3) \
    EXCEPTION_BEGIN_DEFINE(ns, reKind, hr1) \
    EXCEPTION_ADD_HR(hr2) \
    EXCEPTION_ADD_HR(hr3) \
    EXCEPTION_END_DEFINE() \

#define DEFINE_EXCEPTION_4HRESULTS(ns, reKind, hr1, hr2, hr3, hr4) \
    EXCEPTION_BEGIN_DEFINE(ns, reKind, hr1) \
    EXCEPTION_ADD_HR(hr2) \
    EXCEPTION_ADD_HR(hr3) \
    EXCEPTION_ADD_HR(hr4) \
    EXCEPTION_END_DEFINE() \

#define DEFINE_EXCEPTION_5HRESULTS(ns, reKind, hr1, hr2, hr3, hr4, hr5) \
    EXCEPTION_BEGIN_DEFINE(ns, reKind, hr1) \
    EXCEPTION_ADD_HR(hr2) \
    EXCEPTION_ADD_HR(hr3) \
    EXCEPTION_ADD_HR(hr4) \
    EXCEPTION_ADD_HR(hr5) \
    EXCEPTION_END_DEFINE() \

#define DEFINE_EXCEPTION_6HRESULTS(ns, reKind, hr1, hr2, hr3, hr4, hr5, hr6) \
    EXCEPTION_BEGIN_DEFINE(ns, reKind, hr1) \
    EXCEPTION_ADD_HR(hr2) \
    EXCEPTION_ADD_HR(hr3) \
    EXCEPTION_ADD_HR(hr4) \
    EXCEPTION_ADD_HR(hr5) \
    EXCEPTION_ADD_HR(hr6) \
    EXCEPTION_END_DEFINE() \

#define DEFINE_EXCEPTION_9HRESULTS(ns, reKind, hr1, hr2, hr3, hr4, hr5, hr6, hr7, hr8, hr9) \
    EXCEPTION_BEGIN_DEFINE(ns, reKind, hr1) \
    EXCEPTION_ADD_HR(hr2) \
    EXCEPTION_ADD_HR(hr3) \
    EXCEPTION_ADD_HR(hr4) \
    EXCEPTION_ADD_HR(hr5) \
    EXCEPTION_ADD_HR(hr6) \
    EXCEPTION_ADD_HR(hr7) \
    EXCEPTION_ADD_HR(hr8) \
    EXCEPTION_ADD_HR(hr9) \
    EXCEPTION_END_DEFINE() \

#define DEFINE_EXCEPTION_22HRESULTS(ns, reKind, hr1, hr2, hr3, hr4, hr5, hr6, hr7, \
                                    hr8, hr9, hr10, hr11, hr12, hr13, hr14, \
                                    hr15, hr16, hr17, hr18, hr19, hr20, hr21, hr22) \
    EXCEPTION_BEGIN_DEFINE(ns, reKind, hr1) \
    EXCEPTION_ADD_HR(hr2) \
    EXCEPTION_ADD_HR(hr3) \
    EXCEPTION_ADD_HR(hr4) \
    EXCEPTION_ADD_HR(hr5) \
    EXCEPTION_ADD_HR(hr6) \
    EXCEPTION_ADD_HR(hr7) \
    EXCEPTION_ADD_HR(hr8) \
    EXCEPTION_ADD_HR(hr9) \
    EXCEPTION_ADD_HR(hr10) \
    EXCEPTION_ADD_HR(hr11) \
    EXCEPTION_ADD_HR(hr12) \
    EXCEPTION_ADD_HR(hr13) \
    EXCEPTION_ADD_HR(hr14) \
    EXCEPTION_ADD_HR(hr15) \
    EXCEPTION_ADD_HR(hr16) \
    EXCEPTION_ADD_HR(hr17) \
    EXCEPTION_ADD_HR(hr18) \
    EXCEPTION_ADD_HR(hr19) \
    EXCEPTION_ADD_HR(hr20) \
    EXCEPTION_ADD_HR(hr21) \
    EXCEPTION_ADD_HR(hr22) \
    EXCEPTION_END_DEFINE() \


//
// Actual definition of the exceptions and their matching HRESULT's.
// HRESULTs are expected to be defined in CorError.h, and must also be
// redefined in managed code in an __HResults class.  The managed exception
// object MUST use the same HRESULT in all of its constructors for COM Interop.
// Read comments near top of this file.
//
//
// NOTE: Please keep this list sorted according to the name of the HRESULT.
//

DEFINE_EXCEPTION_SIMPLE(g_ReflectionNS,       AmbiguousMatchException,        COR_E_AMBIGUOUSMATCH)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           ApplicationException,           COR_E_APPLICATION)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           AppDomainUnloadedException,     COR_E_APPDOMAINUNLOADED)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           ArithmeticException,            COR_E_ARITHMETIC)
DEFINE_EXCEPTION_4HRESULTS(g_SystemNS,        ArgumentException,              COR_E_ARGUMENT, STD_CTL_SCODE(449), STD_CTL_SCODE(450),COR_E_DEVICESNOTSUPPORTED)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           ArgumentOutOfRangeException,    COR_E_ARGUMENTOUTOFRANGE)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           ArrayTypeMismatchException,     COR_E_ARRAYTYPEMISMATCH)

DEFINE_EXCEPTION_6HRESULTS(g_SystemNS,        BadImageFormatException,
                           COR_E_BADIMAGEFORMAT, CLDB_E_FILE_OLDVER,
                           CLDB_E_FILE_CORRUPT,
                           HRESULT_FROM_WIN32(ERROR_BAD_EXE_FORMAT),
                           HRESULT_FROM_WIN32(ERROR_EXE_MARKED_INVALID),
                           CORSEC_E_INVALID_IMAGE_FORMAT) 

DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           CannotUnloadAppDomainException, COR_E_CANNOTUNLOADAPPDOMAIN)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           ContextMarshalException,        COR_E_CONTEXTMARSHAL)
DEFINE_EXCEPTION_SIMPLE(g_ReflectionNS,       CustomAttributeFormatException, COR_E_CUSTOMATTRIBUTEFORMAT)
DEFINE_EXCEPTION_SIMPLE(g_CryptographyNS,     CryptographicException,         CORSEC_E_CRYPTO)
DEFINE_EXCEPTION_SIMPLE(g_CryptographyNS,     CryptographicUnexpectedOperationException, CORSEC_E_CRYPTO_UNEX_OPER)

DEFINE_EXCEPTION_3HRESULTS(g_IONS,            DirectoryNotFoundException,     COR_E_DIRECTORYNOTFOUND, STG_E_PATHNOTFOUND, CTL_E_PATHNOTFOUND)
DEFINE_EXCEPTION_2HRESULTS(g_SystemNS,        DivideByZeroException,          COR_E_DIVIDEBYZERO, CTL_E_DIVISIONBYZERO)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           DllNotFoundException,           COR_E_DLLNOTFOUND)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           DuplicateWaitObjectException,   COR_E_DUPLICATEWAITOBJECT)

DEFINE_EXCEPTION_2HRESULTS(g_IONS,            EndOfStreamException,           COR_E_ENDOFSTREAM, STD_CTL_SCODE(62))
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           EntryPointNotFoundException,    COR_E_ENTRYPOINTNOTFOUND)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           Exception,                      COR_E_EXCEPTION)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           ExecutionEngineException,       COR_E_EXECUTIONENGINE)

DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           FieldAccessException,           COR_E_FIELDACCESS)

DEFINE_EXCEPTION_22HRESULTS(g_IONS,            FileLoadException,
                            FUSION_E_REF_DEF_MISMATCH, FUSION_E_INVALID_PRIVATE_ASM_LOCATION,
                            COR_E_ASSEMBLYEXPECTED, FUSION_E_SIGNATURE_CHECK_FAILED,
                            FUSION_E_ASM_MODULE_MISSING, FUSION_E_INVALID_NAME,
                            COR_E_MODULE_HASH_CHECK_FAILED, COR_E_FILELOAD,
                            SECURITY_E_INCOMPATIBLE_SHARE, SECURITY_E_INCOMPATIBLE_EVIDENCE,
                            SECURITY_E_UNVERIFIABLE, COR_E_FIXUPSINEXE, HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES),
                            HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION), HRESULT_FROM_WIN32(ERROR_LOCK_VIOLATION),
                            HRESULT_FROM_WIN32(ERROR_OPEN_FAILED), HRESULT_FROM_WIN32(ERROR_DISK_CORRUPT),
                            HRESULT_FROM_WIN32(ERROR_UNRECOGNIZED_VOLUME), HRESULT_FROM_WIN32(ERROR_FILE_INVALID),
                            HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED), HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT),
                            FUSION_E_CODE_DOWNLOAD_DISABLED)

DEFINE_EXCEPTION_9HRESULTS(g_IONS,            FileNotFoundException,
                           HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND), HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND),
                           HRESULT_FROM_WIN32(ERROR_INVALID_NAME), CTL_E_FILENOTFOUND,
                           HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND), HRESULT_FROM_WIN32(ERROR_BAD_NET_NAME),
                           HRESULT_FROM_WIN32(ERROR_BAD_NETPATH), HRESULT_FROM_WIN32(ERROR_NOT_READY),
                           HRESULT_FROM_WIN32(ERROR_WRONG_TARGET_NAME))

DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           FormatException,                COR_E_FORMAT)

DEFINE_EXCEPTION_2HRESULTS(g_SystemNS,        IndexOutOfRangeException,       COR_E_INDEXOUTOFRANGE, 0x800a0009 /*Subscript out of range*/)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           InvalidCastException,           COR_E_INVALIDCAST)
DEFINE_EXCEPTION_SIMPLE(g_InteropNS,          InvalidComObjectException,      COR_E_INVALIDCOMOBJECT)
DEFINE_EXCEPTION_SIMPLE(g_ReflectionNS,       InvalidFilterCriteriaException, COR_E_INVALIDFILTERCRITERIA)
DEFINE_EXCEPTION_SIMPLE(g_InteropNS,          InvalidOleVariantTypeException, COR_E_INVALIDOLEVARIANTTYPE)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           InvalidOperationException,      COR_E_INVALIDOPERATION)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           InvalidProgramException,        COR_E_INVALIDPROGRAM)
DEFINE_EXCEPTION_4HRESULTS(g_IONS,            IOException,                    COR_E_IO, CTL_E_DEVICEIOERROR, STD_CTL_SCODE(31036), STD_CTL_SCODE(31037))

DEFINE_EXCEPTION_SIMPLE(g_InteropNS,          MarshalDirectiveException,      COR_E_MARSHALDIRECTIVE)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           MethodAccessException,          COR_E_METHODACCESS)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           MemberAccessException,          COR_E_MEMBERACCESS)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           MissingFieldException,          COR_E_MISSINGFIELD)
DEFINE_EXCEPTION_SIMPLE(g_ResourcesNS,        MissingManifestResourceException, COR_E_MISSINGMANIFESTRESOURCE)
DEFINE_EXCEPTION_2HRESULTS(g_SystemNS,        MissingMemberException,         COR_E_MISSINGMEMBER, STD_CTL_SCODE(461))
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           MissingMethodException,         COR_E_MISSINGMETHOD)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           MulticastNotSupportedException, COR_E_MULTICASTNOTSUPPORTED)

DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           NotFiniteNumberException,       COR_E_NOTFINITENUMBER)
DEFINE_EXCEPTION_5HRESULTS(g_SystemNS,        NotSupportedException,          COR_E_NOTSUPPORTED, STD_CTL_SCODE(438), STD_CTL_SCODE(445), STD_CTL_SCODE(458), STD_CTL_SCODE(459))
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           NullReferenceException,         COR_E_NULLREFERENCE)

DEFINE_EXCEPTION_2HRESULTS(g_SystemNS,        OverflowException,              COR_E_OVERFLOW, CTL_E_OVERFLOW)

DEFINE_EXCEPTION_SIMPLE(g_IONS,               PathTooLongException,           COR_E_PATHTOOLONG)
 
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           PlatformNotSupportedException,  COR_E_PLATFORMNOTSUPPORTED)

DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           RankException,                  COR_E_RANK)
DEFINE_EXCEPTION_SIMPLE(g_ReflectionNS,       ReflectionTypeLoadException,    COR_E_REFLECTIONTYPELOAD)
DEFINE_EXCEPTION_SIMPLE(g_RemotingNS,         RemotingException,              COR_E_REMOTING)

DEFINE_EXCEPTION_SIMPLE(g_RemotingNS,         ServerException,                COR_E_SERVER)
DEFINE_EXCEPTION_4HRESULTS(g_SecurityNS,      SecurityException,              COR_E_SECURITY,CTL_E_PERMISSIONDENIED,STD_CTL_SCODE(419),CORSEC_E_INVALID_STRONGNAME)
DEFINE_EXCEPTION_SIMPLE(g_InteropNS,          SafeArrayRankMismatchException, COR_E_SAFEARRAYRANKMISMATCH)
DEFINE_EXCEPTION_SIMPLE(g_InteropNS,          SafeArrayTypeMismatchException, COR_E_SAFEARRAYTYPEMISMATCH)
DEFINE_EXCEPTION_SIMPLE(g_SerializationNS,    SerializationException,         COR_E_SERIALIZATION)
DEFINE_EXCEPTION_2HRESULTS(g_SystemNS,        StackOverflowException,         COR_E_STACKOVERFLOW, CTL_E_OUTOFSTACKSPACE)
DEFINE_EXCEPTION_SIMPLE(g_ThreadingNS,        SynchronizationLockException,   COR_E_SYNCHRONIZATIONLOCK)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           SystemException,                COR_E_SYSTEM)

DEFINE_EXCEPTION_SIMPLE(g_ReflectionNS,       TargetException,                COR_E_TARGET)
DEFINE_EXCEPTION_SIMPLE(g_ReflectionNS,       TargetInvocationException,      COR_E_TARGETINVOCATION)
DEFINE_EXCEPTION_SIMPLE(g_ReflectionNS,       TargetParameterCountException,  COR_E_TARGETPARAMCOUNT)
DEFINE_EXCEPTION_SIMPLE(g_ThreadingNS,        ThreadAbortException,           COR_E_THREADABORTED)
DEFINE_EXCEPTION_SIMPLE(g_ThreadingNS,        ThreadInterruptedException,     COR_E_THREADINTERRUPTED)
DEFINE_EXCEPTION_SIMPLE(g_ThreadingNS,        ThreadStateException,           COR_E_THREADSTATE)
DEFINE_EXCEPTION_SIMPLE(g_ThreadingNS,        ThreadStopException,            COR_E_THREADSTOP)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           TypeInitializationException,    COR_E_TYPEINITIALIZATION)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           TypeLoadException,              COR_E_TYPELOAD)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           TypeUnloadedException,          COR_E_TYPEUNLOADED)

DEFINE_EXCEPTION_3HRESULTS(g_SystemNS,        UnauthorizedAccessException,    COR_E_UNAUTHORIZEDACCESS, CTL_E_PATHFILEACCESSERROR, STD_CTL_SCODE(335))

DEFINE_EXCEPTION_SIMPLE(g_SecurityNS,         VerificationException,          COR_E_VERIFICATION)
DEFINE_EXCEPTION_3HRESULTS(g_PolicyNS,        PolicyException,                CORSEC_E_POLICY_EXCEPTION, CORSEC_E_NO_EXEC_PERM, CORSEC_E_MIN_GRANT_FAIL)
DEFINE_EXCEPTION_SIMPLE(g_SecurityNS,         XmlSyntaxException,             CORSEC_E_XMLSYNTAX)

DEFINE_EXCEPTION_SIMPLE(g_InteropNS,          COMException,                   E_FAIL)
DEFINE_EXCEPTION_SIMPLE(g_InteropNS,          ExternalException,              E_FAIL)
DEFINE_EXCEPTION_SIMPLE(g_InteropNS,          SEHException,                   E_FAIL)
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           NotImplementedException,        E_NOTIMPL)

DEFINE_EXCEPTION_3HRESULTS(g_SystemNS,        OutOfMemoryException,           E_OUTOFMEMORY, CTL_E_OUTOFMEMORY, STD_CTL_SCODE(31001))
DEFINE_EXCEPTION_SIMPLE(g_SystemNS,           ArgumentNullException,          E_POINTER)

DEFINE_EXCEPTION_SIMPLE(g_IsolatedStorageNS,  IsolatedStorageException,       ISS_E_ISOSTORE)

// Please see comments on at the top of this list
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\rwlock.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+-------------------------------------------------------------------
//
//  File:       RWLock.cpp
//
//  Contents:   Reader writer lock implementation that supports the
//              following features
//                  1. Cheap enough to be used in large numbers
//                     such as per object synchronization.
//                  2. Supports timeout. This is a valuable feature
//                     to detect deadlocks
//                  3. Supports caching of events. This allows
//                     the events to be moved from least contentious
//                     regions to the most contentious regions.
//                     In other words, the number of events needed by
//                     Reader-Writer lockls is bounded by the number
//                     of threads in the process.
//                  4. Supports nested locks by readers and writers
//                  5. Supports spin counts for avoiding context switches
//                     on  multi processor machines.
//                  6. Supports functionality for upgrading to a writer
//                     lock with a return argument that indicates
//                     intermediate writes. Downgrading from a writer
//                     lock restores the state of the lock.
//                  7. Supports functionality to Release Lock for calling
//                     app code. RestoreLock restores the lock state and
//                     indicates intermediate writes.
//                  8. Recovers from most common failures such as creation of
//                     events. In other words, the lock mainitains consistent
//                     internal state and remains usable
//
//
//  Classes:    CRWLock
//
//  History:    19-Aug-98   Gopalk      Created
//
//--------------------------------------------------------------------
#include "common.h"
#include "RWLock.h"
#ifndef _TESTINGRWLOCK
#include "..\fjit\helperframe.h"
#endif //_TESTINGRWLOCK


// Reader increment
#define READER                 0x00000001
// Max number of readers
#define READERS_MASK           0x000003FF
// Reader being signaled
#define READER_SIGNALED        0x00000400
// Writer being signaled
#define WRITER_SIGNALED        0x00000800
#define WRITER                 0x00001000
// Waiting reader increment
#define WAITING_READER         0x00002000
// Note size of waiting readers must be less
// than or equal to size of readers
#define WAITING_READERS_MASK   0x007FE000
#define WAITING_READERS_SHIFT  13
// Waiting writer increment
#define WAITING_WRITER         0x00800000
// Max number of waiting writers
#define WAITING_WRITERS_MASK   0xFF800000
// Events are being cached
#define CACHING_EVENTS         (READER_SIGNALED | WRITER_SIGNALED)

// Cookie flags
#define UPGRADE_COOKIE         0x02000
#define RELEASE_COOKIE         0x04000
#define COOKIE_NONE            0x10000
#define COOKIE_WRITER          0x20000
#define COOKIE_READER          0x40000
#define INVALID_COOKIE         (~(UPGRADE_COOKIE | RELEASE_COOKIE |            \
                                  COOKIE_NONE | COOKIE_WRITER | COOKIE_READER))

// globals
HANDLE CRWLock::s_hHeap = NULL;
volatile DWORD CRWLock::s_mostRecentLLockID = 0;
volatile DWORD CRWLock::s_mostRecentULockID = -1;
#ifdef _TESTINGRWLOCK
CRITICAL_SECTION *CRWLock::s_pRWLockCrst = NULL;
CRITICAL_SECTION CRWLock::s_rgbRWLockCrstInstanceData;
#else // !_TESTINGRWLOCK
Crst *CRWLock::s_pRWLockCrst = NULL;
BYTE CRWLock::s_rgbRWLockCrstInstanceData[];
#endif // _TESTINGRWLOCK

// Default values
#ifdef _DEBUG
DWORD gdwDefaultTimeout = 120000;
#else //!_DEBUG
DWORD gdwDefaultTimeout = INFINITE;
#endif //_DEBUG
DWORD gdwDefaultSpinCount = 0;
DWORD gdwNumberOfProcessors = 1;
DWORD gdwLockSeqNum = 0;
BOOL fBreakOnErrors = FALSE; // BUGBUG: Temporarily break on errors
const DWORD gdwReasonableTimeout = 120000;
const DWORD gdwMaxReaders = READERS_MASK;
const DWORD gdwMaxWaitingReaders = (WAITING_READERS_MASK >> WAITING_READERS_SHIFT);

// BUGBUG: Bad practise
#define HEAP_SERIALIZE                   0
#define RWLOCK_RECOVERY_FAILURE          (0xC0000227L)

// Helpers class that tracks the lifetime of a frame
#ifdef _TESTINGRWLOCK
#define COR_E_THREADINTERRUPTED          WAIT_IO_COMPLETION
#define FCALL_SETUP_FRAME_NO_INTERIOR(pGCRefs)
#define FCALL_POP_FRAME
#define __FCALL_THROW_WIN32(hr, args)    RaiseException(hr, EXCEPTION_NONCONTINUABLE, 0, NULL)                                                 
#define FCALL_THROW_WIN32(hr, args)      RaiseException(hr, EXCEPTION_NONCONTINUABLE, 0, NULL)
#define FCALL_PREPARED_FOR_THROW
#define VALIDATE(pRWLock)
#define COMPlusThrowWin32(dwStatus, args) RaiseException(dwStatus, EXCEPTION_NONCONTINUABLE, 0, NULL)

#define FastInterlockExchangeAdd InterlockedExchangeAdd

inline LONG FastInterlockCompareExchange(LONG* pvDestination, LONG dwExchange, LONG dwComperand)
{
    return(InterlockedCompareExchange(pvDestination, dwExchange, dwComperand));
}

#else //!_TESTINGRWLOCK
// Helper macros for setting up and tearing down frames
// See HELPER_METHOD_FRAME_END on an explaination of alwaysZero (which is always zero, but we
// can't let the compiler know that.  


// TODO [08/03/2001]:   remove the following macros and use the standard fcall macros instead;
//                      consider erecting the frames only when necessary (before blocking or throwing)
//                      instead of every time we come from managed code like now. To see where the
//                      frames are needed you can look at rwlock.cpp#16

#define FCALL_SETUP_FRAME_NO_INTERIOR(pGCRef)                                                     \
                                     int __alwaysZero = 0;                                        \
                                     do                                                           \
                                     {                                                            \
                                         LazyMachState __ms;                                      \
                                         HelperMethodFrame_1OBJ __helperFrame;                    \
                                         GCFrame __gcFrame;                                       \
                                         Thread *__pThread = GetThread();                         \
                                         INDEBUG((Thread::ObjectRefNew((OBJECTREF*)&pGCRef)));               \
                                         BOOL __fFrameSetup = __pThread->IsNativeFrameSetup();    \
                                         if(__fFrameSetup == FALSE)                               \
                                         {                                                        \
                                             CAPTURE_STATE(__ms);                                 \
                                             __helperFrame.SetProtectedObject((OBJECTREF*) &pGCRef);\
                                             __helperFrame.SetFrameAttribs(0);                    \
                                             __helperFrame.Init(&__ms);                           \
                                             __pThread->NativeFramePushed();                      \
                                         }                                                        \
                                         else                                                     \
                                             __gcFrame.Init(__pThread,                            \
                                                            (OBJECTREF*)&(pGCRef),                \
                                                            sizeof(pGCRef)/sizeof(OBJECTREF),     \
                                                            FALSE)

#define FCALL_POP_FRAME                  if(__fFrameSetup == FALSE)                               \
                                         {                                                        \
                                             __helperFrame.Pop();                         \
                                             __alwaysZero = __helperFrame.RestoreState(); \
                                             __pThread->NativeFramePopped();                      \
                                         }                                                        \
                                         else                                                     \
                                         {                                                        \
                                             __gcFrame.Frame::Pop(__pThread);                     \
                                         }                                                        \
                                     } while(__alwaysZero)

#define __FCALL_THROW_WIN32(hr, args)   _ASSERTE(__pThread->IsNativeFrameSetup() == TRUE);       \
                                        __pThread->NativeFramePopped();                          \
                                        COMPlusThrowWin32((hr), (args))

                                                 
#define FCALL_THROW_WIN32(hr, args)     _ASSERTE(__pThread->IsNativeFrameSetup() == TRUE);       \
                                        __pThread->NativeFramePopped();                          \
                                        COMPlusThrowWin32((hr), (args));                         \
                                        __alwaysZero = 1;                                        \
                                     } while(__alwaysZero)

#define FCALL_THROW_RE(reKind)          _ASSERTE(__pThread->IsNativeFrameSetup() == TRUE);       \
                                        __pThread->NativeFramePopped();                          \
                                        COMPlusThrow((reKind));                                  \
                                        __alwaysZero = 1;                                        \
                                     } while(__alwaysZero)

#define __FCALL_THROW_RE(reKind)        _ASSERTE(__pThread->IsNativeFrameSetup() == TRUE);       \
                                        __pThread->NativeFramePopped();                          \
                                        COMPlusThrow((reKind))

#define FCALL_PREPARED_FOR_THROW     _ASSERTE(__pThread->IsNativeFrameSetup() == FALSE)

// Catch GC holes
#if _DEBUG
#define VALIDATE(pRWLock)                ((Object *) (pRWLock))->Validate();
#else // !_DEBUG
#define VALIDATE(pRWLock)
#endif // _DEBUG

#endif //_TESTINGRWLOCK                                               

//+-------------------------------------------------------------------
//
//  Method:     CRWLock::ProcessInit     public
//
//  Synopsis:   Reads default values from registry and intializes 
//              process wide data structures
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CRWLock::ProcessInit()
{
    SYSTEM_INFO system;

    // Obtain number of processors on the system
    GetSystemInfo(&system);
    gdwNumberOfProcessors = system.dwNumberOfProcessors;
    gdwDefaultSpinCount = (gdwNumberOfProcessors > 1) ? 500 : 0;

    // Obtain system wide timeout value
    HKEY hKey;
    LONG lRetVal = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                 "SYSTEM\\CurrentControlSet\\Control\\Session Manager",
                                 NULL,
                                 KEY_READ,
                                 &hKey);
    if(lRetVal == ERROR_SUCCESS)
    {
        DWORD dwTimeout, dwSize = sizeof(dwTimeout);

        lRetVal = RegQueryValueExA(hKey,
                                   "CriticalSectionTimeout",
                                   NULL,
                                   NULL,
                                   (LPBYTE) &dwTimeout,
                                   &dwSize);
        if(lRetVal == ERROR_SUCCESS)
        {
            gdwDefaultTimeout = dwTimeout * 2000;
        }
        RegCloseKey(hKey);
    }

    // Obtain process heap
    s_hHeap = GetProcessHeap();

    // Initialize the critical section used by the lock
#ifdef _TESTINGRWLOCK
    InitializeCriticalSection(&s_rgbRWLockCrstInstanceData);
    s_pRWLockCrst = &s_rgbRWLockCrstInstanceData;
#else
    s_pRWLockCrst = new (&s_rgbRWLockCrstInstanceData) Crst("RWLock", CrstDummy);
    _ASSERTE(s_pRWLockCrst == (Crst *) &s_rgbRWLockCrstInstanceData);
#endif

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::ProcessCleanup     public
//
//  Synopsis:   Cleansup process wide data structures
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
void CRWLock::ProcessCleanup()
{
    // Initialize the critical section used by the lock
    if(s_pRWLockCrst)
    {
#ifdef _TESTINGRWLOCK
        DeleteCriticalSection(&s_rgbRWLockCrstInstanceData);
#else
        delete s_pRWLockCrst;
#endif
        s_pRWLockCrst = NULL;
    }
}
#endif /* SHOULD_WE_CLEANUP */

//+-------------------------------------------------------------------
//
//  Method:     CRWLock::CRWLock     public
//
//  Synopsis:   Constructor
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
CRWLock::CRWLock()
:   _hWriterEvent(NULL),
    _hReaderEvent(NULL),
    _dwState(0),
    _dwWriterID(0),
    _dwWriterSeqNum(1),
    _wFlags(0),
    _wWriterLevel(0)
#ifdef RWLOCK_STATISTICS
    ,
    _dwReaderEntryCount(0),
    _dwReaderContentionCount(0),
    _dwWriterEntryCount(0),
    _dwWriterContentionCount(0),
    _dwEventsReleasedCount(0)
#endif
{
    DWORD dwKnownLLockID;
    DWORD dwULockID = s_mostRecentULockID;
    DWORD dwLLockID = s_mostRecentLLockID;
    do
    {
        dwKnownLLockID = dwLLockID;
        if(dwKnownLLockID != 0)
        {
            dwLLockID = RWInterlockedCompareExchange(&s_mostRecentLLockID, dwKnownLLockID+1, dwKnownLLockID);
        }
        else
        {
#ifdef _TESTINGRWLOCK
            LOCKCOUNTINCL("CRWLock in rwlock.cpp");                        \
            EnterCriticalSection(s_pRWLockCrst);
#else
            s_pRWLockCrst->Enter();
#endif
            
            if(s_mostRecentLLockID == 0)
            {
                dwULockID = ++s_mostRecentULockID;
                dwLLockID = s_mostRecentLLockID++;
                dwKnownLLockID = dwLLockID;
            }
            else
            {
                dwULockID = s_mostRecentULockID;
                dwLLockID = s_mostRecentLLockID;
            }

#ifdef _TESTINGRWLOCK
            LeaveCriticalSection(s_pRWLockCrst);
            LOCKCOUNTDECL("CRWLock in rwlock.cpp");                        \

#else
            s_pRWLockCrst->Leave();
#endif
        }
    } while(dwKnownLLockID != dwLLockID);

    _dwLLockID = ++dwLLockID;
    _dwULockID = dwULockID;

    _ASSERTE(_dwLLockID > 0);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::Cleanup    public
//
//  Synopsis:   Cleansup state
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CRWLock::Cleanup()
{
    // Sanity checks
    _ASSERTE(_dwState == 0);
    _ASSERTE(_dwWriterID == 0);
    _ASSERTE(_wWriterLevel == 0);

    if(_hWriterEvent)
        CloseHandle(_hWriterEvent);
    if(_hReaderEvent)
        CloseHandle(_hReaderEvent);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::ChainEntry     private
//
//  Synopsis:   Chains the given lock entry into the chain
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CRWLock::ChainEntry(Thread *pThread, LockEntry *pLockEntry)
{
    LockEntry *pHeadEntry = pThread->m_pHead;
    pLockEntry->pNext = pHeadEntry;
    pLockEntry->pPrev = pHeadEntry->pPrev;
    pLockEntry->pPrev->pNext = pLockEntry;
    pHeadEntry->pPrev = pLockEntry;

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::GetLockEntry     private
//
//  Synopsis:   Gets lock entry from TLS
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline LockEntry *CRWLock::GetLockEntry()
{
    LockEntry *pHeadEntry = GetThread()->m_pHead;
    LockEntry *pLockEntry = pHeadEntry;
    do
    {
        if((pLockEntry->dwLLockID == _dwLLockID) && (pLockEntry->dwULockID == _dwULockID))
            return(pLockEntry);
        pLockEntry = pLockEntry->pNext;
    } while(pLockEntry != pHeadEntry);

    return(NULL);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::FastGetOrCreateLockEntry     private
//
//  Synopsis:   The fast path for getting a lock entry from TLS
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline LockEntry *CRWLock::FastGetOrCreateLockEntry()
{
    Thread *pThread = GetThread();
    _ASSERTE(pThread);
    LockEntry *pLockEntry = pThread->m_pHead;
    if(pLockEntry->dwLLockID == 0)
    {
        _ASSERTE(pLockEntry->wReaderLevel == 0);
        pLockEntry->dwLLockID = _dwLLockID;
        pLockEntry->dwULockID = _dwULockID;
        return(pLockEntry);
    }
    else if((pLockEntry->dwLLockID == _dwLLockID) && (pLockEntry->dwULockID == _dwULockID))
    {
        _ASSERTE(pLockEntry->wReaderLevel);
        return(pLockEntry);
    }

    return(SlowGetOrCreateLockEntry(pThread));
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::SlowGetorCreateLockEntry     private
//
//  Synopsis:   The slow path for getting a lock entry from TLS
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
LockEntry *CRWLock::SlowGetOrCreateLockEntry(Thread *pThread)
{
    LockEntry *pFreeEntry = NULL;
    LockEntry *pHeadEntry = pThread->m_pHead;

    // Search for an empty entry or an entry belonging to this lock
    LockEntry *pLockEntry = pHeadEntry->pNext;
    while(pLockEntry != pHeadEntry)
    {
         if(pLockEntry->dwLLockID && 
            ((pLockEntry->dwLLockID != _dwLLockID) || (pLockEntry->dwULockID != _dwULockID)))
         {
             // Move to the next entry
             pLockEntry = pLockEntry->pNext;
         }
         else
         {
             // Prepare to move it to the head
             pFreeEntry = pLockEntry;
             pLockEntry->pPrev->pNext = pLockEntry->pNext;
             pLockEntry->pNext->pPrev = pLockEntry->pPrev;

             break;
         }
    }

    if(pFreeEntry == NULL)
    {
        pFreeEntry = (LockEntry *) HeapAlloc(s_hHeap, HEAP_SERIALIZE, sizeof(LockEntry));
        if (pFreeEntry == NULL) FailFast(GetThread(), FatalOutOfMemory);
        pFreeEntry->wReaderLevel = 0;
    }

    if(pFreeEntry)
    {
        _ASSERTE((pFreeEntry->dwLLockID != 0) || (pFreeEntry->wReaderLevel == 0));
        _ASSERTE((pFreeEntry->wReaderLevel == 0) || 
                 ((pFreeEntry->dwLLockID == _dwLLockID) && (pFreeEntry->dwULockID == _dwULockID)));

        // Chain back the entry
        ChainEntry(pThread, pFreeEntry);

        // Move this entry to the head
        pThread->m_pHead = pFreeEntry;

        // Mark the entry as belonging to this lock
        pFreeEntry->dwLLockID = _dwLLockID;
        pFreeEntry->dwULockID = _dwULockID;
    }

    return pFreeEntry;
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::FastRecycleLockEntry     private
//
//  Synopsis:   Fast path for recycling the lock entry that is used
//              when the thread is the next few instructions is going
//              to call FastGetOrCreateLockEntry again
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CRWLock::FastRecycleLockEntry(LockEntry *pLockEntry)
{
    // Sanity checks
    _ASSERTE(pLockEntry->wReaderLevel == 0);
    _ASSERTE((pLockEntry->dwLLockID == _dwLLockID) && (pLockEntry->dwULockID == _dwULockID));
    _ASSERTE(pLockEntry == GetThread()->m_pHead);

    pLockEntry->dwLLockID = 0;
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RecycleLockEntry     private
//
//  Synopsis:   Fast path for recycling the lock entry
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CRWLock::RecycleLockEntry(LockEntry *pLockEntry)
{
    // Sanity check
    _ASSERTE(pLockEntry->wReaderLevel == 0);

    // Move the entry to tail
    Thread *pThread = GetThread();
    LockEntry *pHeadEntry = pThread->m_pHead;
    if(pLockEntry == pHeadEntry)
    {
        pThread->m_pHead = pHeadEntry->pNext;
    }
    else if(pLockEntry->pNext->dwLLockID)
    {
        // Prepare to move the entry to tail
        pLockEntry->pPrev->pNext = pLockEntry->pNext;
        pLockEntry->pNext->pPrev = pLockEntry->pPrev;

        // Chain back the entry
        ChainEntry(pThread, pLockEntry);
    }

    // The entry does not belong to this lock anymore
    pLockEntry->dwLLockID = 0;
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::StaticIsWriterLockHeld    public
//
//  Synopsis:   Return TRUE if writer lock is held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
FCIMPL1(BOOL, CRWLock::StaticIsWriterLockHeld, CRWLock *pRWLock)
{
    THROWSCOMPLUSEXCEPTION();

    if (pRWLock == NULL)
    {
        FCThrow(kNullReferenceException);
    }

    if(pRWLock->_dwWriterID == GetCurrentThreadId())
        return(TRUE);

    return(FALSE);
}
FCIMPLEND


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::StaticIsReaderLockHeld    public
//
//  Synopsis:   Return TRUE if reader lock is held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
FCIMPL1(BOOL, CRWLock::StaticIsReaderLockHeld, CRWLock *pRWLock)
{
    THROWSCOMPLUSEXCEPTION();

    if (pRWLock == NULL)
    {
        FCThrow(kNullReferenceException);
    }
    
    LockEntry *pLockEntry = pRWLock->GetLockEntry();
    if(pLockEntry)
    {
        _ASSERTE(pLockEntry->wReaderLevel);
        return(TRUE);
    }

    return(FALSE);
}
FCIMPLEND


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertWriterLockHeld    public
//
//  Synopsis:   Asserts that writer lock is held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#ifdef _DEBUG
BOOL CRWLock::AssertWriterLockHeld()
{
    if(_dwWriterID == GetCurrentThreadId())
        return(TRUE);

    _ASSERTE(!"Writer lock not held by the current thread");
    return(FALSE);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertWriterLockNotHeld    public
//
//  Synopsis:   Asserts that writer lock is not held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#ifdef _DEBUG
BOOL CRWLock::AssertWriterLockNotHeld()
{
    if(_dwWriterID != GetCurrentThreadId())
        return(TRUE);

    _ASSERTE(!"Writer lock held by the current thread");
    return(FALSE);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertReaderLockHeld    public
//
//  Synopsis:   Asserts that reader lock is held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#ifdef _DEBUG
BOOL CRWLock::AssertReaderLockHeld()
{
    LockEntry *pLockEntry = GetLockEntry();
    if(pLockEntry)
    {
        _ASSERTE(pLockEntry->wReaderLevel);
        return(TRUE);
    }

    _ASSERTE(!"Reader lock not held by the current thread");
    return(FALSE);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertReaderLockNotHeld    public
//
//  Synopsis:   Asserts that writer lock is not held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#ifdef _DEBUG
BOOL CRWLock::AssertReaderLockNotHeld()
{
    LockEntry *pLockEntry = GetLockEntry();
    if(pLockEntry == NULL)
        return(TRUE);

    _ASSERTE(pLockEntry->wReaderLevel);
    _ASSERTE(!"Reader lock held by the current thread");

    return(FALSE);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::AssertReaderOrWriterLockHeld   public
//
//  Synopsis:   Asserts that writer lock is not held
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
#ifdef _DEBUG
BOOL CRWLock::AssertReaderOrWriterLockHeld()
{
    BOOL fLockHeld = FALSE;

    if(_dwWriterID == GetCurrentThreadId())
    {
        return(TRUE);
    }
    else
    {
        LockEntry *pLockEntry = GetLockEntry();
        if(pLockEntry)
        {
            _ASSERTE(pLockEntry->wReaderLevel);
            return(TRUE);
        }
    }

    _ASSERTE(!"Neither Reader nor Writer lock held");
    return(FALSE);
}
#endif


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RWSetEvent    private
//
//  Synopsis:   Helper function for setting an event
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CRWLock::RWSetEvent(HANDLE event)
{
    THROWSCOMPLUSEXCEPTION();
    if(!SetEvent(event))
    {
        _ASSERTE(!"SetEvent failed");
        if(fBreakOnErrors)
            DebugBreak();
        GetThread()->NativeFramePopped();
        COMPlusThrowWin32(E_UNEXPECTED, NULL);        
    }
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RWResetEvent    private
//
//  Synopsis:   Helper function for resetting an event
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CRWLock::RWResetEvent(HANDLE event)
{
    THROWSCOMPLUSEXCEPTION();
    if(!ResetEvent(event))
    {
        _ASSERTE(!"ResetEvent failed");
        if(fBreakOnErrors)
            DebugBreak();
        GetThread()->NativeFramePopped();
        COMPlusThrowWin32(E_UNEXPECTED, NULL);        
    }
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RWWaitForSingleObject    public
//
//  Synopsis:   Helper function for waiting on an event
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline DWORD CRWLock::RWWaitForSingleObject(HANDLE event, DWORD dwTimeout)
{
#ifdef _TESTINGRWLOCK
    return(WaitForSingleObjectEx(event, dwTimeout, TRUE));
#else
    return(GetThread()->DoAppropriateWaitWorker(1, &event, TRUE, dwTimeout, TRUE));
#endif
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RWSleep    public
//
//  Synopsis:   Helper function for calling Sleep
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CRWLock::RWSleep(DWORD dwTime)
{
    SleepEx(dwTime, TRUE);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RWInterlockedCompareExchange    public
//
//  Synopsis:   Helper function for calling intelockedCompareExchange
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline DWORD CRWLock::RWInterlockedCompareExchange(volatile DWORD* pvDestination,
                                                   DWORD dwExchange,
                                                   DWORD dwComperand)
{
    return(DWORD)(size_t)(FastInterlockCompareExchange((void**)(size_t)pvDestination, // @TODO WIN64 - convert DWORD to larger void*
                                                       (void*)(size_t)dwExchange, 
                                                       (void*)(size_t)dwComperand));
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RWInterlockedExchangeAdd    public
//
//  Synopsis:   Helper function for adding state
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline DWORD CRWLock::RWInterlockedExchangeAdd(volatile DWORD *pvDestination,
                                               DWORD dwAddToState)
{
    return(FastInterlockExchangeAdd((LONG *) pvDestination, dwAddToState));
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::RWInterlockedIncrement    public
//
//  Synopsis:   Helper function for incrementing a pointer
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline DWORD CRWLock::RWInterlockedIncrement(DWORD *pdwState)
{
	return (FastInterlockIncrement((long *) pdwState));
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::ReleaseEvents    public
//
//  Synopsis:   Helper function for caching events
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CRWLock::ReleaseEvents()
{
    // Ensure that reader and writers have been stalled
    _ASSERTE((_dwState & CACHING_EVENTS) == CACHING_EVENTS);

    // Save writer event
    HANDLE hWriterEvent = _hWriterEvent;
    _hWriterEvent = NULL;

    // Save reader event
    HANDLE hReaderEvent = _hReaderEvent;
    _hReaderEvent = NULL;

    // Allow readers and writers to continue
    RWInterlockedExchangeAdd(&_dwState, -(CACHING_EVENTS));

    // Cache events
    // BUGBUG: I am closing events for now. What is needed
    //         is an event cache to which the events are
    //         released using InterlockedCompareExchange64
    if(hWriterEvent)
    {
        LOG((LF_SYNC, LL_INFO10, "Releasing writer event\n"));
        CloseHandle(hWriterEvent);
    }
    if(hReaderEvent)
    {
        LOG((LF_SYNC, LL_INFO10, "Releasing reader event\n"));
        CloseHandle(hReaderEvent);
    }
#ifdef RWLOCK_STATISTICS
    RWInterlockedIncrement(&_dwEventsReleasedCount);
#endif

    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CRWLock::GetWriterEvent    public
//
//  Synopsis:   Helper function for obtaining a auto reset event used
//              for serializing writers. It utilizes event cache
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HANDLE CRWLock::GetWriterEvent()
{
    if(_hWriterEvent == NULL)
    {
        HANDLE hWriterEvent = ::WszCreateEvent(NULL, FALSE, FALSE, NULL);
        if(hWriterEvent)
        {
            if(RWInterlockedCompareExchange((volatile DWORD *) &_hWriterEvent,
                                            (DWORD)(size_t)hWriterEvent,        //@TODO WIN64 truncation occurs here
                                            (DWORD) NULL))
            {
                CloseHandle(hWriterEvent);
            }
        }
    }

    return(_hWriterEvent);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::GetReaderEvent    public
//
//  Synopsis:   Helper function for obtaining a manula reset event used
//              by readers to wait when a writer holds the lock.
//              It utilizes event cache
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HANDLE CRWLock::GetReaderEvent()
{
    if(_hReaderEvent == NULL)
    {
        HANDLE hReaderEvent = ::WszCreateEvent(NULL, TRUE, FALSE, NULL);
        if(hReaderEvent)
        {
            if(RWInterlockedCompareExchange((volatile DWORD *) &_hReaderEvent,
                                            (DWORD)(size_t) hReaderEvent,       //@TODO WIN64 truncation occurs here
                                            (DWORD) NULL))
            {
                CloseHandle(hReaderEvent);
            }
        }
    }

    return(_hReaderEvent);
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::StaticAcquireReaderLockPublic    public
//
//  Synopsis:   Public access to StaticAcquireReaderLock
//
//+-------------------------------------------------------------------
void __fastcall CRWLock::StaticAcquireReaderLockPublic(
    CRWLock *pRWLock, 
    DWORD   dwDesiredTimeout)
{
    THROWSCOMPLUSEXCEPTION();

    FCALL_SETUP_FRAME_NO_INTERIOR(pRWLock);

    if (pRWLock == NULL)
    {
        __FCALL_THROW_RE(kNullReferenceException);
    }

    StaticAcquireReaderLock(&pRWLock, dwDesiredTimeout);

    FCALL_POP_FRAME;
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::StaticAcquireReaderLock    private
//
//  Synopsis:   Makes the thread a reader. Supports nested reader locks.
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
// FCIMPL2( void, CRWLock::StaticAcquireReaderLock, 
void __fastcall CRWLock::StaticAcquireReaderLock(
    CRWLock **ppRWLock, 
    DWORD dwDesiredTimeout)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(ppRWLock);
	_ASSERTE(*ppRWLock);

    LockEntry *pLockEntry = (*ppRWLock)->FastGetOrCreateLockEntry();
    if (pLockEntry == NULL)
    {
        GetThread()->NativeFramePopped();
        COMPlusThrowWin32(STATUS_NO_MEMORY, NULL);        
    }
    
    DWORD dwStatus = WAIT_OBJECT_0;
    // Check for the fast path
    if(RWInterlockedCompareExchange(&(*ppRWLock)->_dwState, READER, 0) == 0)
    {
        _ASSERTE(pLockEntry->wReaderLevel == 0);
    }
    // Check for nested reader
    else if(pLockEntry->wReaderLevel != 0)
    {
        _ASSERTE((*ppRWLock)->_dwState & READERS_MASK);
        ++pLockEntry->wReaderLevel;
        INCTHREADLOCKCOUNT();
        return;
    }
    // Check if the thread already has writer lock
    else if((*ppRWLock)->_dwWriterID == GetCurrentThreadId())
    {
        StaticAcquireWriterLock(ppRWLock, dwDesiredTimeout);
        (*ppRWLock)->FastRecycleLockEntry(pLockEntry);
        return;
    }
    else
    {
        DWORD dwSpinCount;
        DWORD dwCurrentState, dwKnownState;
        
        // Initialize
        dwSpinCount = 0;
        dwCurrentState = (*ppRWLock)->_dwState;
        do
        {
            dwKnownState = dwCurrentState;

            // Reader need not wait if there are only readers and no writer
            if((dwKnownState < READERS_MASK) ||
                (((dwKnownState & READER_SIGNALED) && ((dwKnownState & WRITER) == 0)) &&
                 (((dwKnownState & READERS_MASK) +
                   ((dwKnownState & WAITING_READERS_MASK) >> WAITING_READERS_SHIFT)) <=
                  (READERS_MASK - 2))))
            {
                // Add to readers
                dwCurrentState = RWInterlockedCompareExchange(&(*ppRWLock)->_dwState,
                                                              (dwKnownState + READER),
                                                              dwKnownState);
                if(dwCurrentState == dwKnownState)
                {
                    // One more reader
                    break;
                }
            }
            // Check for too many Readers or waiting readers or signaling in progress
            else if(((dwKnownState & READERS_MASK) == READERS_MASK) ||
                    ((dwKnownState & WAITING_READERS_MASK) == WAITING_READERS_MASK) ||
                    ((dwKnownState & CACHING_EVENTS) == READER_SIGNALED))
            {
                //  Sleep
                GetThread()->UserSleep(1000);
                
                // Update to latest state
                dwSpinCount = 0;
                dwCurrentState = (*ppRWLock)->_dwState;
            }
            // Check if events are being cached
            else if((dwKnownState & CACHING_EVENTS) == CACHING_EVENTS)
            {
                if(++dwSpinCount > gdwDefaultSpinCount)
                {
                    RWSleep(1);
                    dwSpinCount = 0;
                }
                dwCurrentState = (*ppRWLock)->_dwState;
            }
            // Check spin count
            else if(++dwSpinCount <= gdwDefaultSpinCount)
            {
                dwCurrentState = (*ppRWLock)->_dwState;
            }
            else
            {
                // Add to waiting readers
                dwCurrentState = RWInterlockedCompareExchange(&(*ppRWLock)->_dwState,
                                                              (dwKnownState + WAITING_READER),
                                                              dwKnownState);
                if(dwCurrentState == dwKnownState)
                {
                    HANDLE hReaderEvent;
                    DWORD dwModifyState;

                    // One more waiting reader
#ifdef RWLOCK_STATISTICS
                    RWInterlockedIncrement(&(*ppRWLock)->_dwReaderContentionCount);
#endif
                    
                    hReaderEvent = (*ppRWLock)->GetReaderEvent();
                    if(hReaderEvent)
                    {
                        dwStatus = RWWaitForSingleObject(hReaderEvent, dwDesiredTimeout);
                        VALIDATE(*ppRWLock);
                    }
                    else
                    {
                        LOG((LF_SYNC, LL_WARNING,
                            "AcquireReaderLock failed to create reader "
                            "event for RWLock 0x%x\n", *ppRWLock));
                        dwStatus = GetLastError();
                    }

                    if(dwStatus == WAIT_OBJECT_0)
                    {
                        _ASSERTE((*ppRWLock)->_dwState & READER_SIGNALED);
                        _ASSERTE(((*ppRWLock)->_dwState & READERS_MASK) < READERS_MASK);
                        dwModifyState = READER - WAITING_READER;
                    }
                    else
                    {
                        dwModifyState = -WAITING_READER;
                        if(dwStatus == WAIT_TIMEOUT)
                        {
                            LOG((LF_SYNC, LL_WARNING,
                                "Timed out trying to acquire reader lock "
                                "for RWLock 0x%x\n", *ppRWLock));
                            dwStatus = ERROR_TIMEOUT;
                        }
                        else if(dwStatus == WAIT_IO_COMPLETION)
                        {
                            LOG((LF_SYNC, LL_WARNING,
                                "Thread interrupted while trying to acquire reader lock "
                                "for RWLock 0x%x\n", *ppRWLock));
                            dwStatus = COR_E_THREADINTERRUPTED;
                        }
                        else
                        {
                            dwStatus = GetLastError();
                            LOG((LF_SYNC, LL_WARNING,
                                "WaitForSingleObject on Event 0x%x failed for "
                                "RWLock 0x%x with status code 0x%x\n",
                                hReaderEvent, *ppRWLock, dwStatus));
                        }
                    }

                    // One less waiting reader and he may have become a reader
                    dwKnownState = RWInterlockedExchangeAdd(&(*ppRWLock)->_dwState, dwModifyState);

                    // Check for last signaled waiting reader
                    if(dwStatus == WAIT_OBJECT_0)
                    {
                        _ASSERTE(dwKnownState & READER_SIGNALED);
                        _ASSERTE((dwKnownState & READERS_MASK) < READERS_MASK);
                        if((dwKnownState & WAITING_READERS_MASK) == WAITING_READER)
                        {
                            // Reset the event and lower reader signaled flag
                            RWResetEvent(hReaderEvent);
                            RWInterlockedExchangeAdd(&(*ppRWLock)->_dwState, -READER_SIGNALED);
                        }
                    }
                    else
                    {
                        if(((dwKnownState & WAITING_READERS_MASK) == WAITING_READER) &&
                           (dwKnownState & READER_SIGNALED))
                        {
                            if(hReaderEvent == NULL)
                                hReaderEvent = (*ppRWLock)->GetReaderEvent();
                            _ASSERTE(hReaderEvent);

                            // Ensure the event is signalled before resetting it.
                            DWORD dwTemp = WaitForSingleObject(hReaderEvent, INFINITE);
                            _ASSERTE(dwTemp == WAIT_OBJECT_0);
                            _ASSERTE(((*ppRWLock)->_dwState & READERS_MASK) < READERS_MASK);
                            
                            // Reset the event and lower reader signaled flag
                            RWResetEvent(hReaderEvent);
                            RWInterlockedExchangeAdd(&(*ppRWLock)->_dwState, (READER - READER_SIGNALED));

                            // Honor the orginal status
                            pLockEntry->wReaderLevel = 1;
                            INCTHREADLOCKCOUNT();
                            StaticReleaseReaderLock(ppRWLock);
                        }
                        else
                        {
                            (*ppRWLock)->FastRecycleLockEntry(pLockEntry);
                        }
                        
                        _ASSERTE((pLockEntry == NULL) ||
                                 ((pLockEntry->dwLLockID == 0) &&
                                  (pLockEntry->wReaderLevel == 0)));
                        if(fBreakOnErrors)
                        {
                            _ASSERTE(!"Failed to acquire reader lock");
                            DebugBreak();
                        }
                        
                        // Prepare the frame for throwing an exception
                        GetThread()->NativeFramePopped();
                        COMPlusThrowWin32(dwStatus, NULL);
                    }

                    // Sanity check
                    _ASSERTE(dwStatus == WAIT_OBJECT_0);
                    break;                        
                }
            }
			pause();		// Indicate to the processor that we are spining
        } while(TRUE);
    }

    // Success
    _ASSERTE(dwStatus == WAIT_OBJECT_0);
    _ASSERTE(((*ppRWLock)->_dwState & WRITER) == 0);
    _ASSERTE((*ppRWLock)->_dwState & READERS_MASK);
    _ASSERTE(pLockEntry->wReaderLevel == 0);
    pLockEntry->wReaderLevel = 1;
    INCTHREADLOCKCOUNT();
#ifdef RWLOCK_STATISTICS
    RWInterlockedIncrement(&(*ppRWLock)->_dwReaderEntryCount);
#endif
    return;
}
// FCIMPLEND


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::StaticAcquireWriterLockPublic    public
//
//  Synopsis:   Public access to StaticAcquireWriterLock
//
//+-------------------------------------------------------------------
void __fastcall CRWLock::StaticAcquireWriterLockPublic(
    CRWLock *pRWLock, 
    DWORD   dwDesiredTimeout)
{
    THROWSCOMPLUSEXCEPTION();

    FCALL_SETUP_FRAME_NO_INTERIOR(pRWLock);

    if (pRWLock == NULL)
    {
        __FCALL_THROW_RE(kNullReferenceException);
    }

    StaticAcquireWriterLock(&pRWLock, dwDesiredTimeout);

    FCALL_POP_FRAME;
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::StaticAcquireWriterLock    private
//
//  Synopsis:   Makes the thread a writer. Supports nested writer
//              locks
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
//FCIMPL2(void, CRWLock::StaticAcquireWriterLock,
void __fastcall CRWLock::StaticAcquireWriterLock(
    CRWLock **ppRWLock, 
    DWORD dwDesiredTimeout)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(ppRWLock);
    _ASSERTE(*ppRWLock);

    // Declare locals needed for setting up frame
    DWORD dwThreadID = GetCurrentThreadId();
    DWORD dwStatus;

    // Check for the fast path
    if(RWInterlockedCompareExchange(&(*ppRWLock)->_dwState, WRITER, 0) == 0)
    {
        _ASSERTE(((*ppRWLock)->_dwState & READERS_MASK) == 0);
    }
    // Check if the thread already has writer lock
    else if((*ppRWLock)->_dwWriterID == dwThreadID)
    {
        ++(*ppRWLock)->_wWriterLevel;
        INCTHREADLOCKCOUNT();
        return;
    }
    else
    {
        DWORD dwCurrentState, dwKnownState;
        DWORD dwSpinCount;

        // Initialize
        dwSpinCount = 0;
        dwCurrentState = (*ppRWLock)->_dwState;
        do
        {
            dwKnownState = dwCurrentState;

            // Writer need not wait if there are no readers and writer
            if((dwKnownState == 0) || (dwKnownState == CACHING_EVENTS))
            {
                // Can be a writer
                dwCurrentState = RWInterlockedCompareExchange(&(*ppRWLock)->_dwState,
                                                              (dwKnownState + WRITER),
                                                              dwKnownState);
                if(dwCurrentState == dwKnownState)
                {
                    // Only writer
                    break;
                }
            }
            // Check for too many waiting writers
            else if(((dwKnownState & WAITING_WRITERS_MASK) == WAITING_WRITERS_MASK))
            {
                // Sleep
                GetThread()->UserSleep(1000);
                
                // Update to latest state
                dwSpinCount = 0;
                dwCurrentState = (*ppRWLock)->_dwState;
            }
            // Check if events are being cached
            else if((dwKnownState & CACHING_EVENTS) == CACHING_EVENTS)
            {
                if(++dwSpinCount > gdwDefaultSpinCount)
                {
                    RWSleep(1);
                    dwSpinCount = 0;
                }
                dwCurrentState = (*ppRWLock)->_dwState;
            }
            // Check spin count
            else if(++dwSpinCount <= gdwDefaultSpinCount)
            {
                dwCurrentState = (*ppRWLock)->_dwState;
            }
            else
            {
                // Add to waiting writers
                dwCurrentState = RWInterlockedCompareExchange(&(*ppRWLock)->_dwState,
                                                              (dwKnownState + WAITING_WRITER),
                                                              dwKnownState);
                if(dwCurrentState == dwKnownState)
                {
                    HANDLE hWriterEvent;
                    DWORD dwModifyState;

                    // One more waiting writer
#ifdef RWLOCK_STATISTICS
                    RWInterlockedIncrement(&(*ppRWLock)->_dwWriterContentionCount);
#endif
                    hWriterEvent = (*ppRWLock)->GetWriterEvent();
                    if(hWriterEvent)
                    {
                        dwStatus = RWWaitForSingleObject(hWriterEvent, dwDesiredTimeout);
                        VALIDATE(*ppRWLock);
                    }
                    else
                    {
                        LOG((LF_SYNC, LL_WARNING,
                            "AcquireWriterLock failed to create writer "
                            "event for RWLock 0x%x\n", *ppRWLock));
                        dwStatus = WAIT_FAILED;
                    }

                    if(dwStatus == WAIT_OBJECT_0)
                    {
                        _ASSERTE((*ppRWLock)->_dwState & WRITER_SIGNALED);
                        dwModifyState = WRITER - WAITING_WRITER - WRITER_SIGNALED;
                    }
                    else
                    {
                        dwModifyState = -WAITING_WRITER;
                        if(dwStatus == WAIT_TIMEOUT)
                        {
                            LOG((LF_SYNC, LL_WARNING,
                                "Timed out trying to acquire writer "
                                "lock for RWLock 0x%x\n", *ppRWLock));
                            dwStatus = ERROR_TIMEOUT;
                        }
                        else if(dwStatus == WAIT_IO_COMPLETION)
                        {
                            LOG((LF_SYNC, LL_WARNING,
                                "Thread interrupted while trying to acquire writer lock "
                                "for RWLock 0x%x\n", *ppRWLock));
                            dwStatus = COR_E_THREADINTERRUPTED;
                        }
                        else
                        {
                            dwStatus = GetLastError();
                            LOG((LF_SYNC, LL_WARNING,
                                "WaitForSingleObject on Event 0x%x failed for "
                                "RWLock 0x%x with status code 0x%x",
                                hWriterEvent, *ppRWLock, dwStatus));
                        }
                    }

                    // One less waiting writer and he may have become a writer
                    dwKnownState = RWInterlockedExchangeAdd(&(*ppRWLock)->_dwState, dwModifyState);

                    // Check for last timing out signaled waiting writer
                    if(dwStatus == WAIT_OBJECT_0)
                    {
                        // Common case
                    }
                    else
                    {
                        if((dwKnownState & WRITER_SIGNALED) &&
                           ((dwKnownState & WAITING_WRITERS_MASK) == WAITING_WRITER))
                        {
                            if(hWriterEvent == NULL)
                                hWriterEvent = (*ppRWLock)->GetWriterEvent();
                            _ASSERTE(hWriterEvent);
                            do
                            {
                                dwKnownState = (*ppRWLock)->_dwState;
                                if((dwKnownState & WRITER_SIGNALED) &&
                                   ((dwKnownState & WAITING_WRITERS_MASK) == 0))
                                {
                                    DWORD dwTemp = WaitForSingleObject(hWriterEvent, 10);
                                    if(dwTemp == WAIT_OBJECT_0)
                                    {
                                        dwKnownState = RWInterlockedExchangeAdd(&(*ppRWLock)->_dwState, (WRITER - WRITER_SIGNALED));
                                        _ASSERTE(dwKnownState & WRITER_SIGNALED);
                                        _ASSERTE((dwKnownState & WRITER) == 0);

                                        // Honor the orginal status
                                        (*ppRWLock)->_dwWriterID = dwThreadID;
                                        Thread *pThread = GetThread();
                                        _ASSERTE (pThread);
                                        pThread->m_dwLockCount -= (*ppRWLock)->_wWriterLevel - 1;
                                        _ASSERTE (pThread->m_dwLockCount >= 0);
                                        (*ppRWLock)->_wWriterLevel = 1;
                                        StaticReleaseWriterLock(ppRWLock);
                                        break;
                                    }
                                    // else continue;
                                }
                                else
                                    break;
                            }while(TRUE);
                        }

                        if(fBreakOnErrors)
                        {
                            _ASSERTE(!"Failed to acquire writer lock");
                            DebugBreak();
                        }
                        
                        // Prepare the frame for throwing an exception
                        GetThread()->NativeFramePopped();
                        COMPlusThrowWin32(dwStatus, NULL);
                    }

                    // Sanity check
                    _ASSERTE(dwStatus == WAIT_OBJECT_0);
                    break;
                }
            }
			pause();		// indicate to the processor that we are spinning 
        } while(TRUE);
    }

    // Success
    _ASSERTE((*ppRWLock)->_dwState & WRITER);
    _ASSERTE(((*ppRWLock)->_dwState & READERS_MASK) == 0);
    _ASSERTE((*ppRWLock)->_dwWriterID == 0);

    // Save threadid of the writer
    (*ppRWLock)->_dwWriterID = dwThreadID;
    (*ppRWLock)->_wWriterLevel = 1;
    INCTHREADLOCKCOUNT();
    ++(*ppRWLock)->_dwWriterSeqNum;
#ifdef RWLOCK_STATISTICS
    ++(*ppRWLock)->_dwWriterEntryCount;
#endif
    return;
}
// FCIMPLEND


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::StaticReleaseWriterLockPublic    public
//
//  Synopsis:   Public access to StaticReleaseWriterLock
//
//+-------------------------------------------------------------------
void __fastcall CRWLock::StaticReleaseWriterLockPublic(
    CRWLock *pRWLock)
{
    THROWSCOMPLUSEXCEPTION();

    FCALL_SETUP_FRAME_NO_INTERIOR(pRWLock);

    if (pRWLock == NULL)
    {
        __FCALL_THROW_RE(kNullReferenceException);
    }

    StaticReleaseWriterLock(&pRWLock);

    FCALL_POP_FRAME;
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::StaticReleaseWriterLock    private
//
//  Synopsis:   Removes the thread as a writer if not a nested
//              call to release the lock
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
// FCIMPL1(void, CRWLock::StaticReleaseWriterLock,
void __fastcall CRWLock::StaticReleaseWriterLock(
    CRWLock **ppRWLock)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(ppRWLock);
    _ASSERTE(*ppRWLock);

    DWORD dwThreadID = GetCurrentThreadId();

    // Check validity of caller
    if((*ppRWLock)->_dwWriterID == dwThreadID)
    {
        DECTHREADLOCKCOUNT();
        // Check for nested release
        if(--(*ppRWLock)->_wWriterLevel == 0)
        {
            DWORD dwCurrentState, dwKnownState, dwModifyState;
            BOOL fCacheEvents;
            HANDLE hReaderEvent = NULL, hWriterEvent = NULL;

            // Not a writer any more
            (*ppRWLock)->_dwWriterID = 0;
            dwCurrentState = (*ppRWLock)->_dwState;
            do
            {
                dwKnownState = dwCurrentState;
                dwModifyState = -WRITER;
                fCacheEvents = FALSE;
                if(dwKnownState & WAITING_READERS_MASK)
                {
                    hReaderEvent = (*ppRWLock)->GetReaderEvent();
                    if(hReaderEvent == NULL)
                    {
                        LOG((LF_SYNC, LL_WARNING,
                            "ReleaseWriterLock failed to create "
                            "reader event for RWLock 0x%x\n", *ppRWLock));
                        RWSleep(100);
                        dwCurrentState = (*ppRWLock)->_dwState;
                        dwKnownState = 0;
                        _ASSERTE(dwCurrentState != dwKnownState);
                        continue;
                    }
                    dwModifyState += READER_SIGNALED;
                }
                else if(dwKnownState & WAITING_WRITERS_MASK)
                {
                    hWriterEvent = (*ppRWLock)->GetWriterEvent();
                    if(hWriterEvent == NULL)
                    {
                        LOG((LF_SYNC, LL_WARNING,
                            "ReleaseWriterLock failed to create "
                            "writer event for RWLock 0x%x\n", *ppRWLock));
                        RWSleep(100);
                        dwCurrentState = (*ppRWLock)->_dwState;
                        dwKnownState = 0;
                        _ASSERTE(dwCurrentState != dwKnownState);
                        continue;
                    }
                    dwModifyState += WRITER_SIGNALED;
                }
                else if(((*ppRWLock)->_hReaderEvent || (*ppRWLock)->_hWriterEvent) &&
                        (dwKnownState == WRITER))
                {
                    fCacheEvents = TRUE;
                    dwModifyState += CACHING_EVENTS;
                }

                // Sanity checks
                _ASSERTE((dwKnownState & READERS_MASK) == 0);

                dwCurrentState = RWInterlockedCompareExchange(&(*ppRWLock)->_dwState,
                                                              (dwKnownState + dwModifyState),
                                                              dwKnownState);
            } while(dwCurrentState != dwKnownState);

            // Check for waiting readers
            if(dwKnownState & WAITING_READERS_MASK)
            {
                _ASSERTE((*ppRWLock)->_dwState & READER_SIGNALED);
                _ASSERTE(hReaderEvent);
                RWSetEvent(hReaderEvent);
            }
            // Check for waiting writers
            else if(dwKnownState & WAITING_WRITERS_MASK)
            {
                _ASSERTE((*ppRWLock)->_dwState & WRITER_SIGNALED);
                _ASSERTE(hWriterEvent);
                RWSetEvent(hWriterEvent);
            }
            // Check for the need to release events
            else if(fCacheEvents)
            {
                (*ppRWLock)->ReleaseEvents();
            }
        }
    }
    else
    {
        if(fBreakOnErrors)
        {
            _ASSERTE(!"Attempt to release writer lock on a wrong thread");
            DebugBreak();
        }
        GetThread()->NativeFramePopped();
        COMPlusThrowWin32(ERROR_NOT_OWNER, NULL);
    }

    return;
}
// FCIMPLEND


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::StaticReleaseReaderLockPublic    public
//
//  Synopsis:   Public access to StaticReleaseReaderLock
//
//+-------------------------------------------------------------------
void __fastcall CRWLock::StaticReleaseReaderLockPublic(
    CRWLock *pRWLock)
{
    THROWSCOMPLUSEXCEPTION();

    FCALL_SETUP_FRAME_NO_INTERIOR(pRWLock);

    if (pRWLock == NULL)
    {
        __FCALL_THROW_RE(kNullReferenceException);
    }

    StaticReleaseReaderLock(&pRWLock);

    FCALL_POP_FRAME;
}


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::StaticReleaseReaderLock    private
//
//  Synopsis:   Removes the thread as a reader
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
// FCIMPL1(void, CRWLock::StaticReleaseReaderLock,
void __fastcall CRWLock::StaticReleaseReaderLock(
    CRWLock **ppRWLock)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(ppRWLock);
    _ASSERTE(*ppRWLock);

    // Check if the thread has writer lock
    if((*ppRWLock)->_dwWriterID == GetCurrentThreadId())
    {
        StaticReleaseWriterLock(ppRWLock);
    }
    else
    {
        LockEntry *pLockEntry = (*ppRWLock)->GetLockEntry();
        if(pLockEntry)
        {
            --pLockEntry->wReaderLevel;
            DECTHREADLOCKCOUNT();
            if(pLockEntry->wReaderLevel == 0)
            {
                DWORD dwCurrentState, dwKnownState, dwModifyState;
                BOOL fLastReader, fCacheEvents = FALSE;
                HANDLE hReaderEvent = NULL, hWriterEvent = NULL;

                // Sanity checks
                _ASSERTE(((*ppRWLock)->_dwState & WRITER) == 0);
                _ASSERTE((*ppRWLock)->_dwState & READERS_MASK);

                // Not a reader any more
                dwCurrentState = (*ppRWLock)->_dwState;
                do
                {
                    dwKnownState = dwCurrentState;
                    dwModifyState = -READER;
                    if((dwKnownState & (READERS_MASK | READER_SIGNALED)) == READER)
                    {
                        fLastReader = TRUE;
                        fCacheEvents = FALSE;
                        if(dwKnownState & WAITING_WRITERS_MASK)
                        {
                            hWriterEvent = (*ppRWLock)->GetWriterEvent();
                            if(hWriterEvent == NULL)
                            {
                                LOG((LF_SYNC, LL_WARNING,
                                    "ReleaseReaderLock failed to create "
                                    "writer event for RWLock 0x%x\n", *ppRWLock));
                                RWSleep(100);
                                dwCurrentState = (*ppRWLock)->_dwState;
                                dwKnownState = 0;
                                _ASSERTE(dwCurrentState != dwKnownState);
                                continue;
                            }
                            dwModifyState += WRITER_SIGNALED;
                        }
                        else if(dwKnownState & WAITING_READERS_MASK)
                        {
                            hReaderEvent = (*ppRWLock)->GetReaderEvent();
                            if(hReaderEvent == NULL)
                            {
                                LOG((LF_SYNC, LL_WARNING,
                                    "ReleaseReaderLock failed to create "
                                    "reader event\n", *ppRWLock));
                                RWSleep(100);
                                dwCurrentState = (*ppRWLock)->_dwState;
                                dwKnownState = 0;
                                _ASSERTE(dwCurrentState != dwKnownState);
                                continue;
                            }
                            dwModifyState += READER_SIGNALED;
                        }
                        else if(((*ppRWLock)->_hReaderEvent || (*ppRWLock)->_hWriterEvent) &&
                                (dwKnownState == READER))
                        {
                            fCacheEvents = TRUE;
                            dwModifyState += CACHING_EVENTS;
                        }
                    }
                    else
                    {
                        fLastReader = FALSE;
                    }

                    // Sanity checks
                    _ASSERTE((dwKnownState & WRITER) == 0);
                    _ASSERTE(dwKnownState & READERS_MASK);

                    dwCurrentState = RWInterlockedCompareExchange(&(*ppRWLock)->_dwState,
                                                                  (dwKnownState + dwModifyState),
                                                                  dwKnownState);
                } while(dwCurrentState != dwKnownState);

                // Check for last reader
                if(fLastReader)
                {
                    // Check for waiting writers
                    if(dwKnownState & WAITING_WRITERS_MASK)
                    {
                        _ASSERTE((*ppRWLock)->_dwState & WRITER_SIGNALED);
                        _ASSERTE(hWriterEvent);
                        RWSetEvent(hWriterEvent);
                    }
                    // Check for waiting readers
                    else if(dwKnownState & WAITING_READERS_MASK)
                    {
                        _ASSERTE((*ppRWLock)->_dwState & READER_SIGNALED);
                        _ASSERTE(hReaderEvent);
                        RWSetEvent(hReaderEvent);
                    }
                    // Check for the need to release events
                    else if(fCacheEvents)
                    {
                        (*ppRWLock)->ReleaseEvents();
                    }
                }

                // Recycle lock entry
                RecycleLockEntry(pLockEntry);
            }
        }
        else
        {
            if(fBreakOnErrors)
            {
                _ASSERTE(!"Attempt to release reader lock on a wrong thread");
                DebugBreak();
            }
            // Setup the frame as the thread is about to throw an exception
            GetThread()->NativeFramePopped();
            COMPlusThrowWin32(ERROR_NOT_OWNER, NULL);
        }
    }

    return;
}
// FCIMPLEND


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::StaticUpgradeToWriterLock    public
//
//  Synopsis:   Upgrades to a writer lock. It returns a BOOL that
//              indicates intervening writes.
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CRWLock::StaticUpgradeToWriterLock(
    CRWLock *pRWLock, 
    LockCookie *pLockCookie, 
    DWORD dwDesiredTimeout)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD dwThreadID = GetCurrentThreadId();

    FCALL_SETUP_FRAME_NO_INTERIOR(pRWLock);

    if (pRWLock == NULL)
    {
        __FCALL_THROW_RE(kNullReferenceException);
    }

    // Check if the thread is already a writer
    if(pRWLock->_dwWriterID == dwThreadID)
    {
        // Update cookie state
        pLockCookie->dwFlags = UPGRADE_COOKIE | COOKIE_WRITER;
        pLockCookie->wWriterLevel = pRWLock->_wWriterLevel;

        // Acquire the writer lock again
        StaticAcquireWriterLock(&pRWLock, dwDesiredTimeout);
    }
    else
    {
        BOOL fAcquireWriterLock;
        LockEntry *pLockEntry = pRWLock->GetLockEntry();
        if(pLockEntry == NULL)
        {
            fAcquireWriterLock = TRUE;
            pLockCookie->dwFlags = UPGRADE_COOKIE | COOKIE_NONE;
        }
        else
        {
            // Sanity check
            _ASSERTE(pRWLock->_dwState & READERS_MASK);
            _ASSERTE(pLockEntry->wReaderLevel);

            // Save lock state in the cookie
            pLockCookie->dwFlags = UPGRADE_COOKIE | COOKIE_READER;
            pLockCookie->wReaderLevel = pLockEntry->wReaderLevel;
            pLockCookie->dwWriterSeqNum = pRWLock->_dwWriterSeqNum;

            // If there is only one reader, try to convert reader to a writer
            DWORD dwKnownState = RWInterlockedCompareExchange(&pRWLock->_dwState,
                                                              WRITER,
                                                              READER);
            if(dwKnownState == READER)
            {
                // Thread is no longer a reader
                Thread* pThread = GetThread();
                _ASSERTE (pThread);
                pThread->m_dwLockCount -= pLockEntry->wReaderLevel;
                _ASSERTE (pThread->m_dwLockCount >= 0);
                pLockEntry->wReaderLevel = 0;
                RecycleLockEntry(pLockEntry);

                // Thread is a writer
                pRWLock->_dwWriterID = dwThreadID;
                pRWLock->_wWriterLevel = 1;
                INCTHREADLOCKCOUNT();
                ++pRWLock->_dwWriterSeqNum;
                fAcquireWriterLock = FALSE;

                // No intevening writes
#if RWLOCK_STATISTICS
                ++pRWLock->_dwWriterEntryCount;
#endif
            }
            else
            {
                // Release the reader lock
                Thread *pThread = GetThread();
                _ASSERTE (pThread);
                pThread->m_dwLockCount -= (pLockEntry->wReaderLevel - 1);
                _ASSERTE (pThread->m_dwLockCount >= 0);
                pLockEntry->wReaderLevel = 1;
                StaticReleaseReaderLock(&pRWLock);
                fAcquireWriterLock = TRUE;
            }
        }

        // Check for the need to acquire the writer lock
        if(fAcquireWriterLock)
        {
            // Declare and Setup the frame as we are aware of the contention
            // on the lock and the thread will most probably block
            // to acquire writer lock

            COMPLUS_TRY
            {
                StaticAcquireWriterLock(&pRWLock, dwDesiredTimeout);
            }
            COMPLUS_CATCH
            {
                // Invalidate cookie
                DWORD dwFlags = pLockCookie->dwFlags; 
                pLockCookie->dwFlags = INVALID_COOKIE;

                // Check for the need to restore read lock
                if(dwFlags & COOKIE_READER)
                {
                    DWORD dwTimeout = (dwDesiredTimeout > gdwReasonableTimeout)
                                      ? dwDesiredTimeout
                                      : gdwReasonableTimeout;

                    COMPLUS_TRY
                    {
                        StaticAcquireReaderLock(&pRWLock, dwTimeout);
                    }
                    COMPLUS_CATCH
                    {
                        FCALL_PREPARED_FOR_THROW;
                        _ASSERTE(!"Failed to restore to a reader");
                        COMPlusThrowWin32(RWLOCK_RECOVERY_FAILURE, NULL);
                    }
                    COMPLUS_END_CATCH

                    Thread *pThread = GetThread();
                    _ASSERTE (pThread);
                    pThread->m_dwLockCount -= pLockEntry->wReaderLevel;
                    _ASSERTE (pThread->m_dwLockCount >= 0);
                    pLockEntry->wReaderLevel = pLockCookie->wReaderLevel;
                    pThread->m_dwLockCount += pLockEntry->wReaderLevel;
                }

                FCALL_PREPARED_FOR_THROW;
                COMPlusRareRethrow();
            }
            COMPLUS_END_CATCH

        }
    }

    // Pop the frame
    FCALL_POP_FRAME;

    // Update the validation fields of the cookie 
    pLockCookie->dwThreadID = dwThreadID;

    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CRWLock::StaticDowngradeFromWriterLock   public
//
//  Synopsis:   Downgrades from a writer lock.
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
// FCIMPL2(void, CRWLock::StaticDowngradeFromWriterLock,
void __fastcall CRWLock::StaticDowngradeFromWriterLock(
    CRWLock *pRWLock, 
    LockCookie *pLockCookie)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD dwThreadID = GetCurrentThreadId();

    FCALL_SETUP_FRAME_NO_INTERIOR(pRWLock);

    if (pRWLock == NULL)
    {
        __FCALL_THROW_RE(kNullReferenceException);
    }

    if (pRWLock->_dwWriterID != GetCurrentThreadId())
    {
        __FCALL_THROW_WIN32(ERROR_NOT_OWNER, NULL);
    }

    // Validate cookie
    DWORD dwStatus;
    if(((pLockCookie->dwFlags & INVALID_COOKIE) == 0) && 
       (pLockCookie->dwThreadID == dwThreadID))
    {
        DWORD dwFlags = pLockCookie->dwFlags;
        pLockCookie->dwFlags = INVALID_COOKIE;
        
        // Check if the thread was a reader
        if(dwFlags & COOKIE_READER)
        {
            // Sanity checks
            _ASSERTE(pRWLock->_wWriterLevel == 1);
    
            LockEntry *pLockEntry = pRWLock->FastGetOrCreateLockEntry();
            if(pLockEntry)
            {
                DWORD dwCurrentState, dwKnownState, dwModifyState;
                HANDLE hReaderEvent = NULL;
    
                // Downgrade to a reader
                pRWLock->_dwWriterID = 0;
                pRWLock->_wWriterLevel = 0;
                DECTHREADLOCKCOUNT ();
                dwCurrentState = pRWLock->_dwState;
                do
                {
                    dwKnownState = dwCurrentState;
                    dwModifyState = READER - WRITER;
                    if(dwKnownState & WAITING_READERS_MASK)
                    {
                        hReaderEvent = pRWLock->GetReaderEvent();
                        if(hReaderEvent == NULL)
                        {
                            LOG((LF_SYNC, LL_WARNING,
                                "DowngradeFromWriterLock failed to create "
                                "reader event for RWLock 0x%x\n", pRWLock));
                            RWSleep(100);
                            dwCurrentState = pRWLock->_dwState;
                            dwKnownState = 0;
                            _ASSERTE(dwCurrentState != dwKnownState);
                            continue;
                        }
                        dwModifyState += READER_SIGNALED;
                    }
    
                    // Sanity checks
                    _ASSERTE((dwKnownState & READERS_MASK) == 0);
    
                    dwCurrentState = RWInterlockedCompareExchange(&pRWLock->_dwState,
                                                                  (dwKnownState + dwModifyState),
                                                                  dwKnownState);
                } while(dwCurrentState != dwKnownState);
    
                // Check for waiting readers
                if(dwKnownState & WAITING_READERS_MASK)
                {
                    _ASSERTE(pRWLock->_dwState & READER_SIGNALED);
                    _ASSERTE(hReaderEvent);
                    RWSetEvent(hReaderEvent);
                }
    
                // Restore reader nesting level
                Thread *pThread = GetThread();
                _ASSERTE (pThread);
                pThread->m_dwLockCount -= pLockEntry->wReaderLevel;
                _ASSERTE (pThread->m_dwLockCount >= 0);
                pLockEntry->wReaderLevel = pLockCookie->wReaderLevel;
                pThread->m_dwLockCount += pLockEntry->wReaderLevel;
    #ifdef RWLOCK_STATISTICS
                RWInterlockedIncrement(&pRWLock->_dwReaderEntryCount);
    #endif
            }
            else
            {
                _ASSERTE(!"Failed to restore the thread as a reader");
                dwStatus = RWLOCK_RECOVERY_FAILURE;
                goto ThrowException;
            }
        }
        else if(dwFlags & (COOKIE_WRITER | COOKIE_NONE))
        {
            // Release the writer lock
            StaticReleaseWriterLock(&pRWLock);
            _ASSERTE((pRWLock->_dwWriterID != GetCurrentThreadId()) ||
                     (dwFlags & COOKIE_WRITER));
        }
    }
    else
    {
        dwStatus = E_INVALIDARG;
ThrowException:        
        __FCALL_THROW_WIN32(dwStatus, NULL);
    }

    FCALL_POP_FRAME;

    // Update the validation fields of the cookie 
    pLockCookie->dwThreadID = dwThreadID;
    
    return;
}
// FCIMPLEND


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::StaticReleaseLock    public
//
//  Synopsis:   Releases the lock held by the current thread
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
// FCIMPL2(void, CRWLock::StaticReleaseLock,
void __fastcall CRWLock::StaticReleaseLock(
    CRWLock *pRWLock, 
    LockCookie *pLockCookie)
{
    THROWSCOMPLUSEXCEPTION();

    DWORD dwThreadID = GetCurrentThreadId();

    FCALL_SETUP_FRAME_NO_INTERIOR(pRWLock);

    if (pRWLock == NULL)
    {
        __FCALL_THROW_RE(kNullReferenceException);
    }

    // Check if the thread is a writer
    if(pRWLock->_dwWriterID == dwThreadID)
    {
        // Save lock state in the cookie
        pLockCookie->dwFlags = RELEASE_COOKIE | COOKIE_WRITER;
        pLockCookie->dwWriterSeqNum = pRWLock->_dwWriterSeqNum;
        pLockCookie->wWriterLevel = pRWLock->_wWriterLevel;

        // Release the writer lock
        Thread *pThread = GetThread();
        _ASSERTE (pThread);
        pThread->m_dwLockCount -= (pRWLock->_wWriterLevel - 1);
        _ASSERTE (pThread->m_dwLockCount >= 0);
        pRWLock->_wWriterLevel = 1;
        StaticReleaseWriterLock(&pRWLock);
    }
    else
    {
        LockEntry *pLockEntry = pRWLock->GetLockEntry();
        if(pLockEntry)
        {
            // Sanity check
            _ASSERTE(pRWLock->_dwState & READERS_MASK);
            _ASSERTE(pLockEntry->wReaderLevel);

            // Save lock state in the cookie
            pLockCookie->dwFlags = RELEASE_COOKIE | COOKIE_READER;
            pLockCookie->wReaderLevel = pLockEntry->wReaderLevel;
            pLockCookie->dwWriterSeqNum = pRWLock->_dwWriterSeqNum;

            // Release the reader lock
            Thread *pThread = GetThread();
            _ASSERTE (pThread);
            pThread->m_dwLockCount -= (pLockEntry->wReaderLevel - 1);
            _ASSERTE (pThread->m_dwLockCount >= 0);
            pLockEntry->wReaderLevel = 1;
            StaticReleaseReaderLock(&pRWLock);
        }
        else
        {
            pLockCookie->dwFlags = RELEASE_COOKIE | COOKIE_NONE;
        }
    }

    FCALL_POP_FRAME;

    // Update the validation fields of the cookie 
    pLockCookie->dwThreadID = dwThreadID;
    
    return;
}
// FCIMPLEND


//+-------------------------------------------------------------------
//
//  Method:     CRWLock::StaticRestoreLock    public
//
//  Synopsis:   Restore the lock held by the current thread
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void __fastcall CRWLock::StaticRestoreLock(
    CRWLock *pRWLock, 
    LockCookie *pLockCookie)
{
    THROWSCOMPLUSEXCEPTION();

    FCALL_SETUP_FRAME_NO_INTERIOR(pRWLock);

    if (pRWLock == NULL)
    {
        __FCALL_THROW_RE(kNullReferenceException);
    }

    // Validate cookie
    DWORD dwThreadID = GetCurrentThreadId();
    DWORD dwFlags = pLockCookie->dwFlags;
    if(pLockCookie->dwThreadID == dwThreadID)
    {
        // Assert that the thread does not hold reader or writer lock
        _ASSERTE((pRWLock->_dwWriterID != dwThreadID) && (pRWLock->GetLockEntry() == NULL));
    
        // Check for the no contention case
        pLockCookie->dwFlags = INVALID_COOKIE;
        if(dwFlags & COOKIE_WRITER)
        {
            if(RWInterlockedCompareExchange(&pRWLock->_dwState, WRITER, 0) == 0)
            {
                // Restore writer nesting level
                pRWLock->_dwWriterID = dwThreadID;
                Thread *pThread = GetThread();
                _ASSERTE (pThread);
                pThread->m_dwLockCount -= pRWLock->_wWriterLevel;
                _ASSERTE (pThread->m_dwLockCount >= 0);
                pRWLock->_wWriterLevel = pLockCookie->wWriterLevel;
                pThread->m_dwLockCount += pRWLock->_wWriterLevel;
                ++pRWLock->_dwWriterSeqNum;
#ifdef RWLOCK_STATISTICS
                ++pRWLock->_dwWriterEntryCount;
#endif
                goto LNormalReturn;
            }
        }
        else if(dwFlags & COOKIE_READER)
        {
            LockEntry *pLockEntry = pRWLock->FastGetOrCreateLockEntry();
            if(pLockEntry)
            {
                // This thread should not already be a reader
                // else bad things can happen
                _ASSERTE(pLockEntry->wReaderLevel == 0);
                DWORD dwKnownState = pRWLock->_dwState;
                if(dwKnownState < READERS_MASK)
                {
                    DWORD dwCurrentState = RWInterlockedCompareExchange(&pRWLock->_dwState,
                                                                        (dwKnownState + READER),
                                                                        dwKnownState);
                    if(dwCurrentState == dwKnownState)
                    {
                        // Restore reader nesting level
                        Thread *pThread = GetThread();
                        _ASSERTE (pThread);
                        pThread->m_dwLockCount -= pLockEntry->wReaderLevel;
                        _ASSERTE (pThread->m_dwLockCount >= 0);
                        pLockEntry->wReaderLevel = pLockCookie->wReaderLevel;
                        pThread->m_dwLockCount += pLockEntry->wReaderLevel;
#ifdef RWLOCK_STATISTICS
                        RWInterlockedIncrement(&pRWLock->_dwReaderEntryCount);
#endif
                        goto LNormalReturn;
                    }
                }
    
                // Recycle the lock entry for the slow case
                pRWLock->FastRecycleLockEntry(pLockEntry);
            }
            else
            {
                // Ignore the error and try again below. May be thread will luck
                // out the second time
            }
        }
        else if(dwFlags & COOKIE_NONE) 
        {
            goto LNormalReturn;
        }

        // Declare and Setup the frame as we are aware of the contention
        // on the lock and the thread will most probably block
        // to acquire lock below
ThrowException:        
        if((dwFlags & INVALID_COOKIE) == 0)
        {
            DWORD dwTimeout = (gdwDefaultTimeout > gdwReasonableTimeout)
                              ? gdwDefaultTimeout
                              : gdwReasonableTimeout;
        
            COMPLUS_TRY
            {
                // Check if the thread was a writer
                if(dwFlags & COOKIE_WRITER)
                {
                    // Acquire writer lock
                    StaticAcquireWriterLock(&pRWLock, dwTimeout);
                    Thread *pThread = GetThread();
                    _ASSERTE (pThread);
                    pThread->m_dwLockCount -= pRWLock->_wWriterLevel;
                    _ASSERTE (pThread->m_dwLockCount >= 0);
                    pRWLock->_wWriterLevel = pLockCookie->wWriterLevel;
                    pThread->m_dwLockCount += pRWLock->_wWriterLevel;
                }
                // Check if the thread was a reader
                else if(dwFlags & COOKIE_READER)
                {
                    StaticAcquireReaderLock(&pRWLock, dwTimeout);
                    LockEntry *pLockEntry = pRWLock->GetLockEntry();
                    _ASSERTE(pLockEntry);
                    Thread *pThread = GetThread();
                    _ASSERTE (pThread);
                    pThread->m_dwLockCount -= pLockEntry->wReaderLevel;
                    _ASSERTE (pThread->m_dwLockCount >= 0);
                    pLockEntry->wReaderLevel = pLockCookie->wReaderLevel;
                    pThread->m_dwLockCount += pLockEntry->wReaderLevel;
                }
            }
            COMPLUS_CATCH
            {
                FCALL_PREPARED_FOR_THROW;
                _ASSERTE(!"Failed to restore to a reader");
                COMPlusThrowWin32(RWLOCK_RECOVERY_FAILURE, NULL);
            }
            COMPLUS_END_CATCH
        }
        else
        {
            __FCALL_THROW_WIN32(E_INVALIDARG, NULL);
        }

        goto LNormalReturn;
    }
    else
    {
        dwFlags = INVALID_COOKIE;
        goto ThrowException;
    }

//  _ASSERTE(!"Should never reach here");
LNormalReturn:
    FCALL_POP_FRAME;
    return;
}


//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks::StaticPrivateInitialize
//
//  Synopsis:   Initialize lock
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
// FCIMPL1(void, CRWLock::StaticPrivateInitialize,
void __fastcall CRWLock::StaticPrivateInitialize(
    CRWLock *pRWLock)
{
    // Run the constructor on the GC allocated space
    CRWLock *pTemp = new (pRWLock) CRWLock();
    _ASSERTE(pTemp == pRWLock);

    // Catch GC holes
    VALIDATE(pRWLock);

    return;
}
// FCIMPLEND

//+-------------------------------------------------------------------
//
//  Class:      CRWLock::StaticGetWriterSeqNum
//
//  Synopsis:   Returns the current sequence number
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
FCIMPL1(INT32, CRWLock::StaticGetWriterSeqNum, CRWLock *pRWLock)
{
    THROWSCOMPLUSEXCEPTION();

    if (pRWLock == NULL)
    {
        FCThrow(kNullReferenceException);
    }

    return(pRWLock->_dwWriterSeqNum);
}    
FCIMPLEND


//+-------------------------------------------------------------------
//
//  Class:      CRWLock::StaticAnyWritersSince
//
//  Synopsis:   Returns TRUE if there were writers since the given
//              sequence number
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
FCIMPL2(INT32, CRWLock::StaticAnyWritersSince, CRWLock *pRWLock, DWORD dwSeqNum)
{
    THROWSCOMPLUSEXCEPTION();

    if (pRWLock == NULL)
    {
        FCThrow(kNullReferenceException);
    }
    

    if(pRWLock->_dwWriterID == GetCurrentThreadId())
        ++dwSeqNum;

    return(pRWLock->_dwWriterSeqNum > dwSeqNum);
}
FCIMPLEND

#ifndef FCALLAVAILABLE
//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks::StaticAcquireReaderLock
//
//  Synopsis:   Thunk that delegates to CRWLock::StaticAcquireReaderLock
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
void __stdcall CRWLockThunks::StaticAcquireReaderLock(ThisPlusTimeoutRWArgs *pArgs)
{
    // ECall frame has been setup by now
    Thread *pThread = GetThread();
    pThread->NativeFramePushed();
    
    // Delegate to CRWLock routine
    CRWLock::StaticAcquireReaderLock(pArgs->pRWLock, pArgs->dwDesiredTimeout);
    
    // ECall frame will be popped after we return
    pThread->NativeFramePopped();
    
    return;
}


//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks::StaticAcquireWriterLock
//
//  Synopsis:   Thunk that delegates to CRWLock::StaticAcquireWriterLock
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
void __stdcall CRWLockThunks::StaticAcquireWriterLock(ThisPlusTimeoutRWArgs *pArgs)
{
    // ECall frame has been setup by now
    Thread *pThread = GetThread();
    pThread->NativeFramePushed();
    
    // Delegate to CRWLock routine
    CRWLock::StaticAcquireWriterLock(pArgs->pRWLock, pArgs->dwDesiredTimeout);
    
    // ECall frame will be popped after we return
    pThread->NativeFramePopped();
    
    return;
}


//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks::StaticReleaseReaderLock
//
//  Synopsis:   Thunk that delegates to CRWLock::StaticReleaseReaderLock
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
void __stdcall CRWLockThunks::StaticReleaseReaderLock(OnlyThisRWArgs *pArgs)
{
    // ECall frame has been setup by now
    Thread *pThread = GetThread();
    pThread->NativeFramePushed();
    
    // Delegate to CRWLock routine
    CRWLock::StaticReleaseReaderLock(pArgs->pRWLock);
    
    // ECall frame will be popped after we return
    pThread->NativeFramePopped();
    
    return;
}


//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks::StaticReleaseWriterLock
//
//  Synopsis:   Thunk that delegates to CRWLock::StaticReleaseWriterLock
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
void __stdcall CRWLockThunks::StaticReleaseWriterLock(OnlyThisRWArgs *pArgs)
{
    // ECall frame has been setup by now
    Thread *pThread = GetThread();
    pThread->NativeFramePushed();
    
    // Delegate to CRWLock routine
    CRWLock::StaticReleaseWriterLock(pArgs->pRWLock);
    
    // ECall frame will be popped after we return
    pThread->NativeFramePopped();
    
    return;
}


//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks::StaticUpgradeToWriterLock
//
//  Synopsis:   Thunk that delegates to CRWLock::StaticUpgradeToWriterLock
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
void __stdcall CRWLockThunks::StaticUpgradeToWriterLock(ThisPlusLockCookiePlusTimeoutRWArgs *pArgs)
{
    // ECall frame has been setup by now
    Thread *pThread = GetThread();
    pThread->NativeFramePushed();
    
    // Delegate to CRWLock routine
    CRWLock::StaticUpgradeToWriterLock(pArgs->pRWLock, pArgs->pLockCookie, 
                                       pArgs->dwDesiredTimeout);
    
    // ECall frame will be popped after we return
    pThread->NativeFramePopped();
    
    return;
}


//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks::StaticDowngradeFromWriterLock
//
//  Synopsis:   Thunk that delegates to CRWLock::StaticDowngradeFromWriterLock
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
void __stdcall CRWLockThunks::StaticDowngradeFromWriterLock(ThisPlusLockCookieRWArgs *pArgs)
{
    // ECall frame has been setup by now
    Thread *pThread = GetThread();
    pThread->NativeFramePushed();
    
    // Delegate to CRWLock routine
    CRWLock::StaticDowngradeFromWriterLock(pArgs->pRWLock, pArgs->pLockCookie);
    
    // ECall frame will be popped after we return
    pThread->NativeFramePopped();
    
    return;
}


//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks::StaticReleaseLock
//
//  Synopsis:   Thunk that delegates to CRWLock::StaticReleaseLock
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
void __stdcall CRWLockThunks::StaticReleaseLock(ThisPlusLockCookieRWArgs *pArgs)
{
    // ECall frame has been setup by now
    Thread *pThread = GetThread();
    pThread->NativeFramePushed();
    
    // Delegate to CRWLock routine
    CRWLock::StaticReleaseLock(pArgs->pRWLock, pArgs->pLockCookie);
    
    // ECall frame will be popped after we return
    pThread->NativeFramePopped();
    
    return;
}


//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks::StaticRestoreLock
//
//  Synopsis:   Thunk that delegates to CRWLock::StaticRestoreLock
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
void __stdcall CRWLockThunks::StaticRestoreLock(ThisPlusLockCookieRWArgs *pArgs)
{
    // ECall frame has been setup by now
    Thread *pThread = GetThread();
    pThread->NativeFramePushed();
    
    // Delegate to CRWLock routine
    CRWLock::StaticRestoreLock(pArgs->pRWLock, pArgs->pLockCookie);
    
    // ECall frame will be popped after we return
    pThread->NativeFramePopped();
    
    return;
}


//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks::StaticIsReaderLockHeld
//
//  Synopsis:   Thunk that delegates to CRWLock::StaticIsReaderLockHeld
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
INT32 __stdcall CRWLockThunks::StaticIsReaderLockHeld(OnlyThisRWArgs *pArgs)
{
    // ECall frame has been setup by now
    Thread *pThread = GetThread();
    pThread->NativeFramePushed();
    
    // Delegate to CRWLock routine
    INT32 bRet = CRWLock::StaticIsReaderLockHeld(pArgs->pRWLock);
    
    // ECall frame will be popped after we return
    pThread->NativeFramePopped();
    
    return(bRet);
}


//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks::StaticIsWriterLockHeld
//
//  Synopsis:   Thunk that delegates to CRWLock::StaticIsWriterLockHeld
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
INT32 __stdcall CRWLockThunks::StaticIsWriterLockHeld(OnlyThisRWArgs *pArgs)
{
    // ECall frame has been setup by now
    Thread *pThread = GetThread();
    pThread->NativeFramePushed();
    
    // Delegate to CRWLock routine
    INT32 bRet = CRWLock::StaticIsWriterLockHeld(pArgs->pRWLock);
    
    // ECall frame will be popped after we return
    pThread->NativeFramePopped();
    
    return(bRet);
}


//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks::StaticGetWriterSeqNum
//
//  Synopsis:   Thunk that delegates to CRWLock::StaticGetWriterSeqNum
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
INT32 __stdcall CRWLockThunks::StaticGetWriterSeqNum(OnlyThisRWArgs *pArgs)
{
    // ECall frame has been setup by now
    Thread *pThread = GetThread();
    pThread->NativeFramePushed();
    
    // Delegate to CRWLock routine
    INT32 dwRet = CRWLock::StaticGetWriterSeqNum(pArgs->pRWLock);
    
    // ECall frame will be popped after we return
    pThread->NativeFramePopped();
    
    return(dwRet);
}


//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks::StaticAnyWritersSince
//
//  Synopsis:   Thunk that delegates to CRWLock::StaticAnyWritersSince
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
INT32 __stdcall CRWLockThunks::StaticAnyWritersSince(ThisPlusSeqNumRWArgs *pArgs)
{
    // ECall frame has been setup by now
    Thread *pThread = GetThread();
    pThread->NativeFramePushed();
    
    // Delegate to CRWLock routine
    INT32 bRet = CRWLock::StaticAnyWritersSince(pArgs->pRWLock, pArgs->dwSeqNum);
    
    // ECall frame will be popped after we return
    pThread->NativeFramePopped();
    
    return(bRet);
}


//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks::StaticPrivateInitialize
//
//  Synopsis:   Thunk that delegates to CRWLock::StaticPrivateInitialize
//
//  History:    22-Jun-99   Gopalk      Created
//
//+-------------------------------------------------------------------
void __stdcall CRWLockThunks::StaticPrivateInitialize(OnlyThisRWArgs *pArgs)
{
    // ECall frame has been setup by now
    Thread *pThread = GetThread();
    pThread->NativeFramePushed();
    
    // Delegate to CRWLock routine
    CRWLock::StaticPrivateInitialize(pArgs->pRWLock);
    
    // ECall frame will be popped after we return
    pThread->NativeFramePopped();
    
    return;
}
#endif // FCALLAVAILABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\remoting.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    remoting.h
**
** Author:  Gopal Kakivaya      (GopalK)
**          Tarun Anand         (TarunA)    
**          Manish Prabhu       (MPrabhu)
**          Raja Krishnaswamy   (RajaK)
**
** Purpose: Defines various remoting related objects such as
**          proxies
**
** Date:    Feb 16, 1999
**
===========================================================*/
#ifndef __REMOTING_H__
#define __REMOTING_H__

#include "fcall.h"
#include "StubMgr.h"

// Forward declaration
class TPMethodFrame;
struct GITEntry;


// @TODO: Set the hashtable to delete the data.

// Thunk hash table - the keys are MethodDesc
typedef EEHashTable<MethodDesc *, EEPtrHashTableHelper<MethodDesc *, FALSE>, FALSE> EEThunkHashTable;

#ifndef GOLDEN
#define REMOTING_PERF 1
#endif

// These are the values returned by RequiresManagedActivation

enum ManagedActivationType {
	NoManagedActivation = 0,		
    ManagedActivation   = 0x1,
    ComObjectType		= 0x2,
};


// The real proxy class is the class behind the 
// transparent proxy class
class CRealProxy
{
public:
    struct GetProxiedTypeArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, orRP);
    };

    // Native helpers
    static FCDECL2(VOID,   SetStubData, LPVOID pvRP, LPVOID pvStubData);
    static FCDECL1(LPVOID, GetStubData, LPVOID pvRP);        
    static FCDECL1(ULONG_PTR, GetStub, LPVOID pvRP);        
    static FCDECL0(LPVOID, GetDefaultStub);        
    static LPVOID __stdcall GetProxiedType(GetProxiedTypeArgs *pArgs);
    
};

// Class that provides various remoting services
// to the exposed world
class CRemotingServices
{
    friend BOOL InitializeRemoting();
public:
    // Arguments to native methods
    struct OneLPVoidArg
    {
        DECLARE_ECALL_OBJECTREF_ARG(LPVOID, pvTP);
    };
    struct TwoLPVoidArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(LPVOID, pv1);
        DECLARE_ECALL_OBJECTREF_ARG(LPVOID, pv2);
    };
    struct CreateTransparentProxyArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, orStubData);
        DECLARE_ECALL_I4_ARG       (LPVOID,       pStub);
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, pClassToProxy);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, orRP);
    };
    struct AllocateObjectArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF, pClassOfObject);
    };

    struct callDefaultCtorArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG( OBJECTREF, oref );
    };

    struct GetInternalHashCodeArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, orObj);
    };
    
    
private:
    //+-------------------------------------------------------------------
    //
    //  Struct:     FieldArgs
    //
    //  Synopsis:   Structure to GC protect arguments for a field accessor call.
    //              DO NOT add non OBJECTREF data types in the structure
    //              @see GCPROTECT_BEGIN() for a better explanation.
    //
    //+-------------------------------------------------------------------
    typedef struct _FieldArgs
    {
        OBJECTREF obj;
        OBJECTREF val;
        STRINGREF typeName;
        STRINGREF fieldName;        
    } FieldArgs;

public:
    // Native methods
    // @see RemotingServices.cool for corresponding declarations
    static FCDECL1(INT32, IsTransparentProxy, Object* obj);    
    static FCDECL1(INT32, IsTransparentProxyEx, Object* obj);    
    static FCDECL1(Object*, GetRealProxy, Object* obj);        
    static FCDECL1(Object*, Unwrap, Object* obj);            
    static FCDECL1(Object*, AlwaysUnwrap, Object* obj);  
    static FCDECL2(Object*, NativeCheckCast, Object* pObj, ReflectClassBaseObject* pType);
    static FCDECL0(VOID, SetRemotingConfiguredFlag);
    
    static FCDECL1(BOOL, IsNullPtr, Object* obj);
    
#ifdef REMOTING_PERF
    static FCDECL1(VOID, LogRemotingStage, INT32 stage);
    static VOID LogRemotingStageInner(INT32 stage);
    static VOID OpenLogFile();
    static VOID CloseLogFile();
#endif
    static Object * __stdcall CreateTransparentProxy(CreateTransparentProxyArgs *pArgs);
    static Object * __stdcall AllocateUninitializedObject(AllocateObjectArgs *pArgs);
    static VOID __stdcall CallDefaultCtor(callDefaultCtorArgs* pArgs);

    static Object * __stdcall AllocateInitializedObject(AllocateObjectArgs *pArgs);
    static INT32 __stdcall GetInternalHashCode(GetInternalHashCodeArgs *pArgs);
    
    // Methods related to interception of non virtual methods & virtual methods called
    // non virtually
    static LPVOID   GetNonVirtualThunkForVirtualMethod(MethodDesc* pMD);
    static Stub*    GetStubForNonVirtualMethod(MethodDesc* pMD, LPVOID pvAddrOfCode, Stub* pInnerStub);

    static void     DestroyThunk(MethodDesc* pMD);
    // Methods related to interception of interface calls
    static void GenerateCheckForProxy(CPUSTUBLINKER* psl);
    static void __stdcall DispatchInterfaceCall(MethodDesc* pMD);
    // Methods related to activation
    static BOOL         IsRemoteActivationRequired(EEClass *pClass);
    static OBJECTREF    CreateProxyOrObject(MethodTable *pMT, BOOL fIsCom = FALSE, BOOL fIsNewObj = FALSE);
    // Methods related to field accessors
    static void FieldAccessor(FieldDesc* pFD, OBJECTREF o, LPVOID pVal, BOOL fIsGetter);
    // Methods related to wrapping/unwrapping of objects
    static OBJECTREF WrapHelper(OBJECTREF obj);
    static OBJECTREF Wrap(OBJECTREF or);
    static OBJECTREF GetProxyFromObject(OBJECTREF or);
    static OBJECTREF GetObjectFromProxy(OBJECTREF obj, BOOL fMatchContexts);
    static BOOL IsProxyToRemoteObject(OBJECTREF obj);
    static OBJECTREF GetServerContext(OBJECTREF obj);
    
    // Methods related to creation and marshaling of appdomains
    static OBJECTREF CreateProxyForDomain(AppDomain *pDomain);

    // Extract the true class of a proxy
    static REFLECTCLASSBASEREF GetClass(OBJECTREF pThis);

    // Other methods
    static BOOL _InitializeRemoting();
    static BOOL Initialize();
#ifdef SHOULD_WE_CLEANUP
    static void Cleanup();
#endif /* SHOULD_WE_CLEANUP */
    inline static MethodDesc *MDofPrivateInvoke() { return s_pRPPrivateInvoke; }
    inline static MethodDesc *MDofInvokeStatic() { return s_pRPInvokeStatic; }
    inline static MethodDesc *MDofIsCurrentContextOK() { return s_pIsCurrentContextOK; }
    inline static MethodDesc *MDofCreateObjectForCom() { return s_pCreateObjectForCom; }
    inline static MethodDesc *MDofCheckCast() { return s_pCheckCast; }
    inline static MethodDesc *MDofWrap() { return s_pWrapMethodDesc; }    
    inline static MethodDesc *MDofFieldSetter() { return s_pFieldSetterDesc; }
    inline static MethodDesc *MDofFieldGetter() { return s_pFieldGetterDesc; }
    inline static MethodDesc *MDofGetType() { return s_pGetTypeDesc; }

	inline static MethodDesc *MDofGetDCOMProxy() { return s_pGetDCOMProxyDesc; }
    inline static MethodDesc *MDofSetDCOMProxy() { return s_pSetDCOMProxyDesc; }
    inline static MethodDesc *MDofSupportsInterface() { return s_pSupportsInterfaceDesc; }
    
    inline static MethodDesc *MDofMarshalToBuffer() { return s_pMarshalToBufferDesc;}
    inline static MethodDesc *MDofUnmarshalFromBuffer() { return s_pUnmarshalFromBufferDesc;}

    inline static DWORD GetTPOffset()             { return s_dwTPOffset; }

    inline static BOOL IsInstanceOfServerIdentity(MethodTable* pMT)
                                    { return s_pServerIdentityClass == pMT; }
    inline static BOOL IsInstanceOfContext(MethodTable* pMT)
                                    { return s_pContextClass == pMT; }
    inline static MethodTable *GetMarshalByRefClass() { return s_pMarshalByRefObjectClass;}
    static MethodTable *GetProxyAttributeClass();

    static BOOL CheckCast(OBJECTREF orTP, EEClass *pClass);
    static BOOL CheckCast(OBJECTREF orTP, EEClass* pObjClass, EEClass *pClass);
    static OBJECTREF GetExposedContext();
    static AppDomain *GetServerDomainForProxy(OBJECTREF orTP);
    static Context *GetServerContextForProxy(OBJECTREF orTP);
    static int GetServerDomainIdForProxy(OBJECTREF orTP);
    static void CheckForContextMatch();

	static HRESULT  CallSupportsInterface(OBJECTREF realProxy, REFIID iid, INT64 *pret);
	// helpers to call methods in real proxy
	static HRESULT  CallSetDCOMProxy(OBJECTREF realProxy, IUnknown* pUnk);
	struct GetComIPArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, orObj);
    };
   	static LPVOID __stdcall GetComIUnknown(GetComIPArgs* pArgs);

    // helpers to acces the m_pCrst
    static VOID EnterLock()
    {
        _ASSERTE(s_pRemotingCrst != NULL);
        s_pRemotingCrst->Enter();
    }

    static VOID LeaveLock()
    {
        _ASSERTE(s_pRemotingCrst != NULL);
        s_pRemotingCrst->Leave();
    }
    static ManagedActivationType __stdcall RequiresManagedActivation(EEClass *pClass);        
	static BOOL IsRemotingInitialized()
	{
		return s_fInitializedRemoting;
	};

private:
    static BOOL InitializeFields();    
    static HRESULT GetExecutionLocation(EEClass *pClass, LPCSTR pszLoc); 
    static void CopyDestToSrc(LPVOID pDest, LPVOID pSrc, UINT cbSize);
    static void CallFieldAccessor(FieldDesc* pFD, OBJECTREF o, VOID * pVal,
                                  BOOL fIsGetter, BOOL fIsByValue, BOOL fIsGCRef,
                                  EEClass *pClass, EEClass *fldClass,
                                  CorElementType fieldType, UINT cbSize);
    static void __stdcall CallFieldGetter(MethodDesc *pMD, LPVOID pThis,
                                          LPVOID pFirst, LPVOID pSecond, LPVOID pThird);
    static void __stdcall CallFieldSetter(MethodDesc *pMD, LPVOID pThis,
                                          LPVOID pFirst, LPVOID pSecond, LPVOID pThird);

    static void GetTypeAndFieldName(FieldArgs *pArgs, FieldDesc *pFD);
    static BOOL MatchField(FieldDesc* pCurField, LPCUTF8 szFieldName);
    static OBJECTREF SetExposedContext(OBJECTREF newContext);
    static OBJECTREF GetServerIdentityFromProxy(OBJECTREF obj);
    inline static MethodDesc *MDOfCreateProxyForDomain() { return s_pProxyForDomainDesc; }
    inline static MethodDesc *MDofGetServerContextForProxy() { return s_pServerContextForProxyDesc; }
    inline static MethodDesc *MDofGetServerDomainIdForProxy() { return s_pServerDomainIdForProxyDesc; }
    static BOOL InitActivationServicesClass();
    static BOOL InitRealProxyClass();
    static BOOL InitRemotingProxyClass();
    static BOOL InitServerIdentityClass();
    static BOOL InitProxyAttributeClass();
    static BOOL InitIdentityClass();
    static BOOL InitContextBoundObjectClass();
    static BOOL InitContextClass();
    static BOOL InitMarshalByRefObjectClass();
    static BOOL InitRemotingServicesClass();
    static BOOL InitObjectClass();

    static MethodTable *s_pMarshalByRefObjectClass;    
    static MethodTable *CRemotingServices::s_pServerIdentityClass;
    static MethodTable *CRemotingServices::s_pContextClass;
    static MethodTable *CRemotingServices::s_pProxyAttributeClass;

    static MethodDesc *s_pRPPrivateInvoke;
    static MethodDesc *s_pRPInvokeStatic;
    static MethodDesc *s_pIsCurrentContextOK;
    static MethodDesc *s_pCreateObjectForCom;
    static MethodDesc *s_pCheckCast;
    static MethodDesc *s_pWrapMethodDesc;    
    static MethodDesc *s_pFieldSetterDesc;
    static MethodDesc *s_pFieldGetterDesc;
    static MethodDesc *s_pGetTypeDesc;
    static MethodDesc *s_pProxyForDomainDesc;
    static MethodDesc *s_pServerContextForProxyDesc;
    static MethodDesc *s_pServerDomainIdForProxyDesc;

	static MethodDesc *s_pGetDCOMProxyDesc;
	static MethodDesc *s_pSetDCOMProxyDesc;
	static MethodDesc *s_pSupportsInterfaceDesc;
    
    static MethodDesc *s_pMarshalToBufferDesc;
    static MethodDesc *s_pUnmarshalFromBufferDesc;

    static DWORD s_dwTPOffset;
    static DWORD s_dwIdOffset;
    static DWORD s_dwServerOffsetInRealProxy;
    static DWORD s_dwServerCtxOffset;
    static DWORD s_dwTPOrObjOffsetInIdentity;
    static DWORD s_dwMBRIDOffset;
    static DWORD s_dwGITEntryOffset;
    static Crst *s_pRemotingCrst;
    static BYTE s_rgbRemotingCrstInstanceData[sizeof(Crst)];    
    static BOOL s_fInitializedRemoting;
#ifdef REMOTING_PERF
    static HANDLE   s_hTimingData;
#endif
};


// Class that manages transparent proxy thunks
#ifdef _X86_
static const DWORD ConstVirtualThunkSize    = sizeof(BYTE) + sizeof(DWORD) + 
                                              sizeof(BYTE) + sizeof(LONG);

static const DWORD ConstStubLabel           = sizeof(BYTE) + sizeof(DWORD);
#else
#pragma message ("@TODO ALPHA - remoting.h")
#pragma message ("@TODO ALPHA - Determine thunk size for other architectures")
static const DWORD ConstVirtualThunkSize    = sizeof(BYTE) + sizeof(DWORD) + 
                                              sizeof(BYTE) + sizeof(LONG);
static const DWORD ConstStubLabel           = sizeof(BYTE) + sizeof(DWORD);
#endif

// Forward declarations
class CVirtualThunkMgr;
class CNonVirtualThunkMgr;

class CVirtualThunks
{

public:
    inline static Initialize() { s_pVirtualThunks = NULL; }
    // Destructor
    static DestroyVirtualThunk(CVirtualThunks *pThunk)
    {
        ::VirtualFree(pThunk, 0, MEM_RELEASE);
    }
    inline static CVirtualThunks* GetVirtualThunks() { return s_pVirtualThunks; }
    inline static CVirtualThunks* SetVirtualThunks(CVirtualThunks* pThunks) 
                                            { return (s_pVirtualThunks = pThunks); }

    inline CVirtualThunks* GetNextThunk()  { return _pNext; }

    // Public member variables
    CVirtualThunks *_pNext;
    DWORD _dwReservedThunks;
    DWORD _dwStartThunk;
    DWORD _dwCurrentThunk;
    struct tagThunkCode {
        BYTE pCode[ConstVirtualThunkSize];
    } ThunkCode[1];

private:
    // Cannot be created
    CVirtualThunks(CVirtualThunks *pNext, DWORD dwCommitedSlots, DWORD dwReservedSlots,
              DWORD dwStartSlot, DWORD dwCurrentSlot)
    {
    }

    // Private statics
    static CVirtualThunks *s_pVirtualThunks;
};


class CNonVirtualThunk
{
public: 
    // Constructor
    CNonVirtualThunk(const BYTE* pbCode)
    : _addrOfCode(pbCode), _pNext(NULL)
    {         
    }
    // Destructor
    ~CNonVirtualThunk();
    inline LPVOID*  GetAddrOfCode() { return (LPVOID*)&_addrOfCode; }
    inline const BYTE* GetThunkCode() { return _addrOfCode;}
    inline CNonVirtualThunk* GetNextThunk()  { return _pNext; }
    
    static void Initialize();
    static CNonVirtualThunk* AddrToThunk(LPVOID pAddr);
    inline static CNonVirtualThunk* GetNonVirtualThunks() { return s_pNonVirtualThunks; }
    static CNonVirtualThunk* SetNonVirtualThunks(const BYTE* pbCode); 
public:

    const BYTE* _addrOfCode;
private:    

    void SetNextThunk();

    // Private statics
    static CNonVirtualThunk *s_pNonVirtualThunks;

    // Private members
    CNonVirtualThunk* _pNext;
};

inline void CNonVirtualThunk::Initialize() 
{ 
    s_pNonVirtualThunks = NULL; 
}

inline void CNonVirtualThunk::SetNextThunk()  
{
    _pNext = s_pNonVirtualThunks; 
    s_pNonVirtualThunks = this;
}

inline CNonVirtualThunk* CNonVirtualThunk::AddrToThunk(LPVOID pAddr)
{
    return (CNonVirtualThunk *)((size_t)pAddr - 
                                 (size_t)offsetof(CNonVirtualThunk, _addrOfCode));
}
// Class that manages transparent proxy method table
#define NONVIRTUAL_THUNK_ARRAY_SIZE         256
#define TP_OFFSET_STUBDATA                  0x8
#define TP_OFFSET_MT                        0xc
#define TP_OFFSET_STUB                      0x14

class CTPMethodTable
{
    friend BOOL InitializeRemoting();
    friend CRemotingServices;
public:
    // Public statics
    static DWORD AddRef()                       { return InterlockedIncrement((LONG *) &s_cRefs); }
    static DWORD Release()                      { return InterlockedDecrement((LONG *) &s_cRefs); }
    static DWORD GetCommitedTPSlots()           { return s_dwCommitedTPSlots; }
    static DWORD GetReservedTPSlots()           { return s_dwReservedTPSlots; }
    static MethodTable *GetMethodTable()        { return s_pThunkTable; }
    static MethodTable **GetMethodTableAddr()   { return &s_pThunkTable; }
    static BOOL Initialize();
    static void Cleanup();
    static BOOL InitializeFields();
    static OBJECTREF CreateTPOfClassForRP(EEClass *pClass, OBJECTREF pRP);
    static INT32 IsTPMethodTable(MethodTable *pMT);
    static EEClass *GetClassBeingProxied(OBJECTREF pTP);    
    
    static Stub* CreateStubForNonVirtualMethod(MethodDesc* pMD, CPUSTUBLINKER *psl, LPVOID pvAddrOfCode, Stub* pInnerStub);
    static LPVOID GetOrCreateNonVirtualThunkForVirtualMethod(MethodDesc* pMD, CPUSTUBLINKER* psl);

    static OBJECTREF GetRP(OBJECTREF orTP);
    static INT64 __stdcall CallTarget(const void *pTarget, LPVOID pvFirst, LPVOID pvSecond);
    static INT64 __stdcall CallTarget(const void *pTarget, LPVOID pvFirst, LPVOID pvSecond, LPVOID pvThird);
    static BOOL CheckCast(const void* pTarget, OBJECTREF orTP, EEClass *pClass);
    static BOOL RefineProxy(OBJECTREF orTP, EEClass *pClass);
    inline static Stub* GetTPStub() { return s_pTPStub; }
    inline static Stub* GetDelegateStub() { return s_pDelegateStub; }
    inline static DWORD GetOffsetOfMT() { return s_dwMTOffset; }
    inline static DWORD GetOffsetOfInterfaceMT() { return s_dwItfMTOffset; }
    inline static DWORD GetOffsetOfStub(){ return s_dwStubOffset; }
    inline static DWORD GetOffsetOfStubData(){ return s_dwStubDataOffset; }
    static void DestroyThunk(MethodDesc* pMD);
    static BOOL GenericCheckForContextMatch(OBJECTREF orTP);    

    inline static BOOL IsInstanceOfRemotingProxy(MethodTable *pMT) 
                                    { return s_pRemotingProxyClass == pMT;}
    inline static MethodTable *GetRemotingProxyClass() { return s_pRemotingProxyClass;}

    // This has to be public to access it from inline asm
    static Stub *s_pTPStub;

    static Stub *s_pDelegateStub;

private:
    // Private statics    
    static void InitThunkTable(DWORD dwCommitedTPSlots, DWORD dwReservedTPSlots, MethodTable* pTPMethodTable)
    {
      s_cRefs = 1;
      s_dwCommitedTPSlots = dwCommitedTPSlots;
      s_dwReservedTPSlots = dwReservedTPSlots;
      s_pThunkTable = pTPMethodTable;    
    }

    
    static void DestroyThunkTable()
    {
        ::VirtualFree(MTToAlloc(s_pThunkTable, s_dwGCInfoBytes), 0, MEM_RELEASE);
        s_pThunkTable = NULL;
        s_cRefs = 0;
        s_dwCommitedTPSlots = 0;
        s_dwReservedTPSlots = 0;
    }

    
    static BOOL CreateTPMethodTable();    
    static BOOL ExtendCommitedSlots(DWORD dwSlots);
    static BOOL AllocateThunks(DWORD dwSlots, DWORD dwCommitSize);
    static void __stdcall PreCall(TPMethodFrame *pFrame);
    static INT64 __stdcall OnCall(TPMethodFrame *pFrame, Thread *pThrd, INT64 *pReturn);    
    static MethodTable *AllocToMT(BYTE *Alloc, LONG off) { return (MethodTable *) (Alloc + off); }
    static BYTE *MTToAlloc(MethodTable *MT, LONG off)    { return (((BYTE *) MT) - off); }
    static CPUSTUBLINKER *NewStubLinker();
    static void CreateThunkForVirtualMethod(DWORD dwSlot, BYTE *bCode);    
    static Stub *CreateTPStub();
    static Stub *CreateDelegateStub();
    static void EmitCallToStub(CPUSTUBLINKER* pStubLinker, CodeLabel* pCtxMismatch);
    static void EmitJumpToAddressCode(CPUSTUBLINKER* pStubLinker, CodeLabel* ConvMD, CodeLabel* UseCode);
    static void EmitJumpToCode(CPUSTUBLINKER* pStubLinker, CodeLabel* UseCode);
    static void EmitSetupFrameCode(CPUSTUBLINKER *pStubLinker);
    static void InitThunkHashTable();
    static void EmptyThunkHashTable();
    
    // Static members    
    static DWORD s_cRefs;
    static DWORD s_dwCommitedTPSlots;
    static DWORD s_dwReservedTPSlots;
    static MethodTable* s_pThunkTable;
    static MethodTable* s_pRemotingProxyClass;
    static EEClass *s_pTransparentProxyClass;
    static DWORD s_dwGCInfoBytes;
    static DWORD s_dwMTDataSlots;
    static DWORD s_dwRPOffset;    
    static DWORD s_dwMTOffset;
    static DWORD s_dwItfMTOffset;
    static DWORD s_dwStubOffset;
    static DWORD s_dwStubDataOffset;
    static DWORD s_dwMaxSlots;
    static MethodTable *s_pTPMT;    
    static CRITICAL_SECTION s_TPMethodTableCrst;
    static EEThunkHashTable *s_pThunkHashTable;
    static BOOL s_fInitializedTPTable;

    enum {
        CALLTYPE_INVALIDCALL        = 0x0,          // Important:: sync this with RealProxy.cool        
        CALLTYPE_METHODCALL         = 0x1,          // Important:: sync this with RealProxy.cool
        CALLTYPE_CONSTRUCTORCALL    = 0x2           // Important:: sync this with RealProxy.cool
    };
};

inline EEClass *CTPMethodTable::GetClassBeingProxied(OBJECTREF pTP)
{
    _ASSERTE(pTP->GetMethodTable()->IsTransparentProxyType());
    return ((MethodTable *) pTP->GetPtrOffset((size_t)s_dwMTOffset))->GetClass();
}

// Returns the one and only transparent proxy stub
inline Stub* TheTPStub()
{
    return CTPMethodTable::GetTPStub();
}

// Returns the one and only delegate stub
inline Stub* TheDelegateStub()
{
    return CTPMethodTable::GetDelegateStub();
}


// initialize remoting
inline BOOL InitializeRemoting()
{
    BOOL fReturn = TRUE;
    if (!CRemotingServices::s_fInitializedRemoting)
    {
        fReturn = CRemotingServices::_InitializeRemoting();
    }
    return fReturn;
}



// These stub manager classes help the debugger to step
// through the various stubs and thunks generated by the
// remoting infrastructure
class CVirtualThunkMgr :public StubManager
{
public:
        static void InitVirtualThunkManager(const BYTE* stubAddress);
        static void Cleanup();
        CVirtualThunkMgr(const BYTE *address) : _stubAddress(address) {}        

protected:
        virtual BOOL CheckIsStub(const BYTE *stubStartAddress);

        virtual BOOL DoTraceStub(const BYTE *stubStartAddress, 
                                 TraceDestination *trace);
        MethodDesc *Entry2MethodDesc(const BYTE *StubStartAddress, MethodTable *pMT);

private:
    // Private methods
    LPBYTE FindThunk(const BYTE *stubStartAddress);
    MethodDesc *GetMethodDescByASM(const BYTE *startaddr, MethodTable *pMT);
    BOOL IsThunkByASM(const BYTE *startaddr);

    // Private statics
    static CVirtualThunkMgr *s_pVirtualThunkMgr;

    // Private member variables
    const BYTE *_stubAddress;    
};


class CNonVirtualThunkMgr :public StubManager
{
public:
    static void InitNonVirtualThunkManager();
    static void Cleanup();

protected:

    virtual BOOL CheckIsStub(const BYTE *stubStartAddress);

    virtual BOOL DoTraceStub(const BYTE *stubStartAddress, 
                             TraceDestination *trace);

    virtual BOOL TraceManager(Thread *thread,
                              TraceDestination *trace,
                              CONTEXT *pContext,
                              BYTE **pRetAddr);
    
    MethodDesc *Entry2MethodDesc(const BYTE *StubStartAddress, MethodTable *pMT);
private:
    // Private methods
    CNonVirtualThunk* FindThunk(const BYTE *stubStartAddress);

    // Private statics
    static CNonVirtualThunkMgr *s_pNonVirtualThunkMgr;

    MethodDesc *GetMethodDescByASM(const BYTE *startaddr);
    BOOL IsThunkByASM(const BYTE *startaddr);
};

// This struct is also accessed from managed world
struct messageData
{
    PVOID       pFrame;
    INT32       iFlags;
    MethodDesc  *pMethodDesc;
    MethodDesc  *pDelegateMD;
    MetaSig     *pSig;
};

#ifdef REMOTING_PERF
//Internal stages
#define CLIENT_MSG_GEN          1
#define CLIENT_MSG_SINK_CHAIN   2
#define CLIENT_MSG_SER          3
#define CLIENT_MSG_SEND         4
#define SERVER_MSG_RECEIVE      5
#define SERVER_MSG_DESER        6
#define SERVER_MSG_SINK_CHAIN   7
#define SERVER_MSG_STACK_BUILD  8
#define SERVER_DISPATCH         9
#define SERVER_RET_STACK_BUILD  10
#define SERVER_RET_SINK_CHAIN   11
#define SERVER_RET_SER          12
#define SERVER_RET_SEND         13
#define SERVER_RET_END          14
#define CLIENT_RET_RECEIVE      15
#define CLIENT_RET_DESER        16
#define CLIENT_RET_SINK_CHAIN   17
#define CLIENT_RET_PROPAGATION  18
#define CLIENT_END_CALL         19
#define TIMING_DATA_EOF         99

struct timingData
{
    DWORD       threadId;
    BYTE        stage;
    __int64     cycleCount;
};

#endif
#endif // __REMOTING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\remoting.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

/*===========================================================================
**
** File:    remoting.cpp
**
** Author(s):   Gopal Kakivaya  (GopalK)
**              Tarun Anand     (TarunA)     
**              Matt Smith      (MattSmit)
**              Manish Prabhu   (MPrabhu)
**              Raja Krishnaswamy (RajaK)
**
** Purpose: Defines various remoting related objects such as
**          proxies
**
** Date:    Feb 16, 1999
**
=============================================================================*/
#include "common.h"
#include "excep.h"
#include "COMString.h"
#include "COMDelegate.h"
#include "remoting.h"
#include "reflectwrap.h"
#include "field.h"
#include "ComCallWrapper.h"
#include "siginfo.hpp"
#include "COMClass.h"
#include "StackBuilderSink.h"
#include "eehash.h"
#include "wsperf.h"
#include "profilepriv.h"
#include "message.h"
#include "EEConfig.h"
#include "windows.h"

#include "InteropConverter.h"

// Macros

#define IDS_REMOTING_LOCK           "Remoting Services" // Remoting services lock
#define IDS_TPMETHODTABLE_LOCK      "TP Method Table"   // Transparent Proxy Method table


// Globals
size_t g_dwTPStubAddr;
size_t g_dwOOContextAddr;

// These hold label offsets into non-virtual thunks. They are used by
// CNonVirtualThunkMgr::DoTraceStub and ::TraceManager to help the
// debugger figure out where the thunk is going to go.
DWORD g_dwNonVirtualThunkRemotingLabelOffset = 0;
DWORD g_dwNonVirtualThunkReCheckLabelOffset = 0;

// Statics

MethodTable *CRemotingServices::s_pMarshalByRefObjectClass;    
MethodTable *CRemotingServices::s_pServerIdentityClass;
MethodTable *CRemotingServices::s_pProxyAttributeClass;
MethodTable *CRemotingServices::s_pContextClass;

MethodDesc *CRemotingServices::s_pRPPrivateInvoke;
MethodDesc *CRemotingServices::s_pRPInvokeStatic;
MethodDesc *CRemotingServices::s_pWrapMethodDesc;
MethodDesc *CRemotingServices::s_pIsCurrentContextOK;
MethodDesc *CRemotingServices::s_pCreateObjectForCom;
MethodDesc *CRemotingServices::s_pCheckCast;
MethodDesc *CRemotingServices::s_pFieldSetterDesc;
MethodDesc *CRemotingServices::s_pFieldGetterDesc;
MethodDesc *CRemotingServices::s_pGetTypeDesc;
MethodDesc *CRemotingServices::s_pProxyForDomainDesc;
MethodDesc *CRemotingServices::s_pServerContextForProxyDesc;
MethodDesc *CRemotingServices::s_pServerDomainIdForProxyDesc;
MethodDesc *CRemotingServices::s_pMarshalToBufferDesc;
MethodDesc *CRemotingServices::s_pUnmarshalFromBufferDesc;

MethodDesc *CRemotingServices::s_pGetDCOMProxyDesc;
MethodDesc *CRemotingServices::s_pSetDCOMProxyDesc;
MethodDesc *CRemotingServices::s_pSupportsInterfaceDesc;

DWORD CRemotingServices::s_dwTPOffset;
DWORD CRemotingServices::s_dwServerOffsetInRealProxy;
DWORD CRemotingServices::s_dwIdOffset;
DWORD CRemotingServices::s_dwServerCtxOffset;
DWORD CRemotingServices::s_dwTPOrObjOffsetInIdentity;
DWORD CRemotingServices::s_dwMBRIDOffset;
Crst *CRemotingServices::s_pRemotingCrst;
BYTE CRemotingServices::s_rgbRemotingCrstInstanceData[];
BOOL CRemotingServices::s_fInitializedRemoting;


#ifdef REMOTING_PERF
HANDLE CRemotingServices::s_hTimingData = NULL;
#endif

// CTPMethodTable Statics
DWORD CTPMethodTable::s_cRefs;
DWORD CTPMethodTable::s_dwCommitedTPSlots;
DWORD CTPMethodTable::s_dwReservedTPSlots;
MethodTable *CTPMethodTable::s_pThunkTable;
EEClass *CTPMethodTable::s_pTransparentProxyClass;
DWORD CTPMethodTable::s_dwGCInfoBytes;
DWORD CTPMethodTable::s_dwMTDataSlots;
DWORD CTPMethodTable::s_dwRPOffset;
DWORD CTPMethodTable::s_dwMTOffset;
DWORD CTPMethodTable::s_dwItfMTOffset;
DWORD CTPMethodTable::s_dwStubOffset;
DWORD CTPMethodTable::s_dwStubDataOffset;
DWORD CTPMethodTable::s_dwMaxSlots;
MethodTable *CTPMethodTable::s_pTPMT;
MethodTable *CTPMethodTable::s_pRemotingProxyClass;
Stub *CTPMethodTable::s_pTPStub;
Stub *CTPMethodTable::s_pDelegateStub;
CRITICAL_SECTION CTPMethodTable::s_TPMethodTableCrst;
EEThunkHashTable *CTPMethodTable::s_pThunkHashTable;
BOOL CTPMethodTable::s_fInitializedTPTable;

// CVirtualThunks statics
CVirtualThunks *CVirtualThunks::s_pVirtualThunks;

// CVirtualThunkMgr statics                                                     
CVirtualThunkMgr *CVirtualThunkMgr::s_pVirtualThunkMgr;

// CNonVirtualThunk statics
CNonVirtualThunk *CNonVirtualThunk::s_pNonVirtualThunks;

// CNonVirtualThunkMgr statics
CNonVirtualThunkMgr *CNonVirtualThunkMgr::s_pNonVirtualThunkMgr;

HRESULT COMStartup(); // ceemain.cpp    

BOOL InitOLETEB(); // forward decl for functiond defined in interoputil.cpp

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::Initialize    public
//
//  Synopsis:   Initialized remoting state
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::Initialize()
{
    s_pRPPrivateInvoke = NULL;
    s_pRPInvokeStatic = NULL;
    s_dwTPOffset = NULL;
    s_fInitializedRemoting = FALSE;

    // Initialize the remoting services critical section
    s_pRemotingCrst = new (&s_rgbRemotingCrstInstanceData) 
                      Crst(IDS_REMOTING_LOCK,CrstRemoting,TRUE,FALSE);
    if (!s_pRemotingCrst)
        return FALSE;

    return CTPMethodTable::Initialize();
}

#ifdef REMOTING_PERF
//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::LogRemotingStage    public
//
//  Synopsis:   Records timing data for a particular stage in a call
//
//+----------------------------------------------------------------------------
FCIMPL1(VOID, CRemotingServices::LogRemotingStage, INT32 stage)

    LogRemotingStageInner(stage);

FCIMPLEND

VOID CRemotingServices::LogRemotingStageInner(INT32 stage)
{
    if (s_hTimingData == NULL)
        return;

    struct timingData td;
    LARGE_INTEGER   cycles;
    DWORD written = 0;

    td.threadId = GetCurrentThreadId();
    td.stage = stage;
    QueryPerformanceCounter(&cycles);
    td.cycleCount = cycles.QuadPart;

    BOOL result = WriteFile(s_hTimingData, &td, 
                            sizeof(struct timingData), &written, NULL);
    // we don't want to throw an exception to halt the run time in this case.
    // but keep the assertion will help us to catch some error under debug build.
    _ASSERTE(result && written == sizeof(struct timingData));
}

void CRemotingServices::OpenLogFile()
{
    if (g_pConfig->LogRemotingPerf() > 0)
    {
        HMODULE hCurrProc = WszGetModuleHandle(NULL);
        WCHAR path[MAX_PATH];
        DWORD len = WszGetModuleFileName(hCurrProc, &path[0], MAX_PATH);
        if (len) {
            WCHAR *period = wcsrchr(&path[0], '.');
            wcscpy(period + 1, L"dat");
            s_hTimingData = WszCreateFile(&path[0], GENERIC_WRITE, FILE_SHARE_READ, NULL, 
                                          OPEN_ALWAYS, 
                                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                          NULL);
    	     // we don't want to throw an exception to halt the run time in this case.
	     // but keep the assertion will help us to catch some error under debug build.
            _ASSERTE(s_hTimingData != INVALID_HANDLE_VALUE);
            if( s_hTimingData == INVALID_HANDLE_VALUE) {
                // setting to NULL because we check fo NULL in following file ops    
                s_hTimingData = NULL;            
            }
        }
    }
}

void CRemotingServices::CloseLogFile()
{
    if (s_hTimingData)
    {
        LogRemotingStageInner(TIMING_DATA_EOF);
        CloseHandle(s_hTimingData);
        s_hTimingData = NULL;
    }

}
#endif // REMOTING_PERF

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::CleanUp    public
//
//  Synopsis:   Cleansup remoting state
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
void CRemotingServices::Cleanup()
{
    if (s_pRemotingCrst)
    {
        delete s_pRemotingCrst;
        s_pRemotingCrst = NULL;
    }

    CTPMethodTable::Cleanup();
}
#endif /* SHOULD_WE_CLEANUP */


//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::IsTransparentProxy    public
//
//  Synopsis:   Check whether the supplied object is proxy or not. This 
//              represents the overloaded method that takes an object.
//              
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
FCIMPL1(INT32, CRemotingServices::IsTransparentProxy, Object* orTP)
{
    INT32 fIsTPMT = FALSE;

    if(orTP != NULL)
    {
        // Check if the supplied object has transparent proxy method table
        MethodTable *pMT = orTP->GetMethodTable();
        fIsTPMT = pMT->IsTransparentProxyType() ? TRUE : FALSE;
    }

    LOG((LF_REMOTING, LL_INFO1000, "!IsTransparentProxy(0x%x) returning %s",
         orTP, fIsTPMT ? "TRUE" : "FALSE"));

    return(fIsTPMT);
}
FCIMPLEND

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::IsTransparentProxyEx    public
//
//  Synopsis:   Check whether the supplied object is proxy or not. This 
//              represents the overloaded method which takes a contextbound 
//              object
//              
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
FCIMPL1(INT32, CRemotingServices::IsTransparentProxyEx, Object* orTP)
{
    INT32 fIsTPMT = FALSE;

    if(orTP != NULL)
    {
        // Check if the supplied object has transparent proxy method table
        MethodTable *pMT = orTP->GetMethodTable();
        fIsTPMT = pMT->IsTransparentProxyType() ? TRUE : FALSE;
    }

    LOG((LF_REMOTING, LL_INFO1000, "!IsTransparentProxyEx(0x%x) returning %s",
         orTP, fIsTPMT ? "TRUE" : "FALSE"));

    return(fIsTPMT);
}
FCIMPLEND

// Called from RemotingServices::ConfigureRemoting to remember that
// a config file has been parsed.
FCIMPL0(VOID, CRemotingServices::SetRemotingConfiguredFlag)
    // Mark a flag for the current appDomain to remember the fact
    // that ConfigureRemoting has been called.
    GetThread()->GetDomain()->SetRemotingConfigured();
FCIMPLEND


//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GetRealProxy    public
//
//  Synopsis:   Returns the real proxy backing the transparent
//              proxy
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
FCIMPL1(Object*, CRemotingServices::GetRealProxy, Object* objTP)
{   
    // Check if the supplied object has transparent proxy method table
    Object* rv = NULL;
    if ((NULL != objTP) && IsTransparentProxy(objTP))
    {
        // RemotingServices should have already been initialized by now
        _ASSERTE(s_fInitializedRemoting);
        rv = OBJECTREFToObject(CTPMethodTable::GetRP(OBJECTREF(objTP)));
    }

    LOG((LF_REMOTING, LL_INFO100, "!GetRealProxy(0x%x) returning 0x%x\n", objTP, rv));
    return(rv);
}
FCIMPLEND

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::CreateTransparentProxy    public
//
//  Synopsis:   Creates a new transparent proxy for the supplied real
//              proxy
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
Object * __stdcall CRemotingServices::CreateTransparentProxy(CreateTransparentProxyArgs *pArgs)
{
    // Sanity check
    THROWSCOMPLUSEXCEPTION();

    // Ensure that the fields of remoting service have been initialized
    // This is separated from the initialization of the remoting services
    if (!s_fInitializedRemoting)
    {
        if (!InitializeFields())
        {
            _ASSERTE(!"Initialization Failed");
            FATAL_EE_ERROR();
        }
    }
    // Check if the supplied object has a transparent proxy already
    if (pArgs->orRP->GetOffset32(s_dwTPOffset) != NULL)
        COMPlusThrow(kArgumentException, L"Remoting_TP_NonNull");

    // Create a tranparent proxy that behaves as an object of the desired class
    ReflectClass *pRefClass = (ReflectClass *) pArgs->pClassToProxy->GetData();
    EEClass *pEEClass = pRefClass->GetClass();
    OBJECTREF pTP = CTPMethodTable::CreateTPOfClassForRP(pEEClass, pArgs->orRP);
    
    // Set the stub pointer
    pTP->SetOffsetPtr(CTPMethodTable::GetOffsetOfStub(), pArgs->pStub);

    // Set the stub data
    pTP->SetOffsetObjectRef(CTPMethodTable::GetOffsetOfStubData(), (size_t)OBJECTREFToObject(pArgs->orStubData));

    COUNTER_ONLY(GetPrivatePerfCounters().m_Context.cProxies++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Context.cProxies++);
    
    LOG((LF_REMOTING, LL_INFO100, "CreateTransparentProxy returning 0x%x\n", pTP));
    return OBJECTREFToObject(pTP);
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::_InitializeRemoting    private
//
//  Synopsis:   Initialize the static fields of CTPMethodTable class
//
//
//  History:    16-Apr-99   TarunA      Created
//
//+----------------------------------------------------------------------------

BOOL CRemotingServices::_InitializeRemoting()
{
    BOOL fReturn = TRUE;
    if (!CRemotingServices::s_fInitializedRemoting)
    {
        fReturn = CRemotingServices::InitializeFields();
        if (fReturn && !CTPMethodTable::s_fInitializedTPTable)
        {
            fReturn = CTPMethodTable::InitializeFields();
        }
    }
    return fReturn;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::InitializeFields    private
//
//  Synopsis:   Initialize the static fields of CRemotingServices class
//
//
//  History:    16-Apr-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::InitializeFields()
{
    BOOL fReturn = TRUE;

    // Acquire the remoting lock before initializing fields
    Thread *t = GetThread();
    BOOL toggleGC = (t && t->PreemptiveGCDisabled());
    if (toggleGC)
        t->EnablePreemptiveGC();
    s_pRemotingCrst->Enter();
    if (toggleGC)
        t->DisablePreemptiveGC();

    // Make sure that no other thread has initialized the fields
    if (!s_fInitializedRemoting)
    {
        if(!InitActivationServicesClass())
        {
            goto ErrExit;
        }
        
        if(!InitRealProxyClass())
        {
            goto ErrExit;
        }

        if(!InitRemotingProxyClass())
        {
            goto ErrExit;
        }

        if(!InitIdentityClass())
        {
            goto ErrExit;
        }
        
        if(!InitServerIdentityClass())
        {
            goto ErrExit;
        }

        if(!InitContextBoundObjectClass())
        {
            goto ErrExit;        
        }

        if(!InitContextClass())
        {
            goto ErrExit;
        }

        if(!InitMarshalByRefObjectClass())
        {
            goto ErrExit;
        }

        if(!InitRemotingServicesClass())
        {
            goto ErrExit;
        }

        if(!InitProxyAttributeClass())
        {
            goto ErrExit;
        }

        if(!InitObjectClass())
        {
            goto ErrExit;
        }

        if (!InitOLETEB())
        {
            goto ErrExit;
        }

        // *********   NOTE   ************ 
        // This must always be the last statement in this block to prevent races
        // 
        s_fInitializedRemoting = TRUE;
        // ********* END NOTE ************        
    }

ErrExit:
    // Leave the remoting lock
    s_pRemotingCrst->Leave();

    LOG((LF_REMOTING, LL_INFO10, "InitializeFields returning %d\n", fReturn));
    return fReturn;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::InitActivationServicesClass    private
//
//  Synopsis:   Extract the method descriptors and fields of ActivationServices class
//
//
//  History:    30-Sep-2000   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::InitActivationServicesClass()
{
    BOOL fReturn = TRUE;

    s_pIsCurrentContextOK = g_Mscorlib.GetMethod(METHOD__ACTIVATION_SERVICES__IS_CURRENT_CONTEXT_OK);
    s_pCreateObjectForCom = g_Mscorlib.GetMethod(METHOD__ACTIVATION_SERVICES__CREATE_OBJECT_FOR_COM);

    LOG((LF_REMOTING, LL_INFO10, "InitRealProxyClass returning %d\n", fReturn));
    return fReturn;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::InitRealProxyClass    private
//
//  Synopsis:   Extract the method descriptors and fields of Real Proxy class
//
//
//  History:    16-Apr-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::InitRealProxyClass()
{
    BOOL fReturn = TRUE;

    // Now store the methoddesc of the PrivateInvoke method on the RealProxy class
    s_pRPPrivateInvoke = g_Mscorlib.GetMethod(METHOD__REAL_PROXY__PRIVATE_INVOKE);

        // Now find the offset to the _tp field inside the RealProxy class
    s_dwTPOffset = g_Mscorlib.GetFieldOffset(FIELD__REAL_PROXY__TP);
            _ASSERTE(s_dwTPOffset == 0);

        // Now find the offset to the _identity field inside the 
        // RealProxy  class
    s_dwIdOffset = g_Mscorlib.GetFieldOffset(FIELD__REAL_PROXY__IDENTITY);

    s_dwServerOffsetInRealProxy = 
            g_Mscorlib.GetFieldOffset(FIELD__REAL_PROXY__SERVER);

    LOG((LF_REMOTING, LL_INFO10, "InitRealProxyClass returning %d\n", fReturn));
    return fReturn;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::InitRemotingProxyClass    private
//
//  Synopsis:   Extract the method descriptors and fields of RemotingProxy class
//
//
//  History:    02-Dec-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::InitRemotingProxyClass()
{
    BOOL fReturn = TRUE;

    s_pRPInvokeStatic = g_Mscorlib.GetMethod(METHOD__REMOTING_PROXY__INVOKE);

    // Note: We cannot do this inside TPMethodTable::InitializeFields ..
    // that causes recursions if in some situation only the latter is called
    // If you do this you will see Asserts when running any process under CorDbg
    // This is because jitting of NV methods on MBR objects calls 
    // InitializeFields and when actually doing that we should not need to
    // JIT another NV method on some MBR object.
    CTPMethodTable::s_pRemotingProxyClass = g_Mscorlib.GetClass(CLASS__REMOTING_PROXY);
    _ASSERTE(CTPMethodTable::s_pRemotingProxyClass);

    LOG((LF_REMOTING, LL_INFO10, "InitRemotingProxyClass returning %d\n", fReturn));
    return fReturn;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::InitServerIdentityClass    private
//
//  Synopsis:   Extract the method descriptors and fields of ServerIdentity class
//
//
//  History:    02-Dec-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::InitServerIdentityClass()
{
    BOOL fReturn = TRUE;

    s_pServerIdentityClass = g_Mscorlib.GetClass(CLASS__SERVER_IDENTITY);

    s_dwServerCtxOffset = g_Mscorlib.GetFieldOffset(FIELD__SERVER_IDENTITY__SERVER_CONTEXT);

    LOG((LF_REMOTING, LL_INFO10, "InitServerIdentityClass returning %d\n", fReturn));
    return fReturn;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::InitIdentityClass    private
//
//  Synopsis:   Extract the method descriptors and fields of Identity class
//
//
//  History:    02-Dec-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::InitIdentityClass()
{
    BOOL fReturn = TRUE;

    s_dwTPOrObjOffsetInIdentity = g_Mscorlib.GetFieldOffset(FIELD__IDENTITY__TP_OR_OBJECT);

    LOG((LF_REMOTING, LL_INFO10, "InitIdentityClass returning %d\n", fReturn));
    return fReturn;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::InitContextBoundObjectClass    private
//
//  Synopsis:   Extract the method descriptors and fields of ContextBoundObject class
//
//
//  History:    02-Dec-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::InitContextBoundObjectClass()
{
    BOOL fReturn = TRUE;

    LOG((LF_REMOTING, LL_INFO10, "InitContextBoundObjectClass returning %d\n", fReturn));
    return fReturn;
}


//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::InitContextClass    private
//
//  Synopsis:   Extract the method descriptors and fields of Contexts class
//
//
//  History:    02-Dec-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::InitContextClass()
{
    BOOL fReturn = TRUE;
    // Note reliance on LoadClass being an idempotent operation

    s_pContextClass = g_Mscorlib.GetClass(CLASS__CONTEXT);

    LOG((LF_REMOTING, LL_INFO10, "InitContextClass returning %d\n", fReturn));
    return fReturn;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::InitMarshalByRefObjectClass    private
//
//  Synopsis:   Extract the method descriptors and fields of MarshalByRefObject class
//
//
//  History:    02-Dec-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::InitMarshalByRefObjectClass()
{
    BOOL fReturn = TRUE;

    s_pMarshalByRefObjectClass = g_Mscorlib.GetClass(CLASS__MARSHAL_BY_REF_OBJECT);
    s_dwMBRIDOffset = g_Mscorlib.GetFieldOffset(FIELD__MARSHAL_BY_REF_OBJECT__IDENTITY);

    LOG((LF_REMOTING, LL_INFO10, "InitMarshalByRefObjectClass returning %d\n", fReturn));
    return fReturn;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::InitRemotingServicesClass    private
//
//  Synopsis:   Extract the method descriptors and fields of RemotingServices class
//
//
//  History:    02-Dec-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::InitRemotingServicesClass()
{
    BOOL fReturn = TRUE;

    s_pCheckCast = g_Mscorlib.GetMethod(METHOD__REMOTING_SERVICES__CHECK_CAST);

        // Need these to call wrap/unwrap from the VM (message.cpp).
        // Also used by JIT helpers to wrap/unwrap
    s_pWrapMethodDesc = g_Mscorlib.GetMethod(METHOD__REMOTING_SERVICES__WRAP);
    s_pProxyForDomainDesc = g_Mscorlib.GetMethod(METHOD__REMOTING_SERVICES__CREATE_PROXY_FOR_DOMAIN);
    s_pServerContextForProxyDesc = g_Mscorlib.GetMethod(METHOD__REMOTING_SERVICES__GET_SERVER_CONTEXT_FOR_PROXY);
    s_pServerDomainIdForProxyDesc = g_Mscorlib.GetMethod(METHOD__REMOTING_SERVICES__GET_SERVER_DOMAIN_ID_FOR_PROXY);
    s_pGetTypeDesc = g_Mscorlib.GetMethod(METHOD__REMOTING_SERVICES__GET_TYPE);
    s_pMarshalToBufferDesc = g_Mscorlib.GetMethod(METHOD__REMOTING_SERVICES__MARSHAL_TO_BUFFER);
    s_pUnmarshalFromBufferDesc = g_Mscorlib.GetMethod(METHOD__REMOTING_SERVICES__UNMARSHAL_FROM_BUFFER);

    s_pSetDCOMProxyDesc = g_Mscorlib.GetMethod(METHOD__REAL_PROXY__SETDCOMPROXY);
    s_pGetDCOMProxyDesc = g_Mscorlib.GetMethod(METHOD__REAL_PROXY__GETDCOMPROXY);
    s_pSupportsInterfaceDesc = g_Mscorlib.GetMethod(METHOD__REAL_PROXY__SUPPORTSINTERFACE);

    LOG((LF_REMOTING, LL_INFO10, "InitRemotingServicesClass returning %d\n", fReturn));
    return fReturn;
}




//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::InitProxyAttributeClass    private
//
//  Synopsis:   Cache the ProxyAttribute class method table
//
//
//  History:    19-July-01  MPrabhu Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::InitProxyAttributeClass()
{
    if (s_pProxyAttributeClass == NULL)
    {
        s_pProxyAttributeClass = g_Mscorlib.GetClass(CLASS__PROXY_ATTRIBUTE);
    }
    return s_pProxyAttributeClass != NULL;
}

MethodTable *CRemotingServices::GetProxyAttributeClass()
{
    InitProxyAttributeClass();
    _ASSERTE(s_pProxyAttributeClass != NULL);
    return s_pProxyAttributeClass;
}


//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::InitObjectClass    private
//
//  Synopsis:   Extract the method descriptors and fields of Object class
//
//
//  History:    02-Dec-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::InitObjectClass()
{
    BOOL fReturn = TRUE;

    s_pFieldSetterDesc = g_Mscorlib.GetMethod(METHOD__OBJECT__FIELD_SETTER);
    s_pFieldGetterDesc = g_Mscorlib.GetMethod(METHOD__OBJECT__FIELD_GETTER);

    LOG((LF_REMOTING, LL_INFO10, "InitObjectClass returning %d\n", fReturn));
    return fReturn;
}


//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GetInternalHashCode    public
//
//  Synopsis:   Returns sync block index for use in hash tables
//              
//
//  History:    26-July-99   MPrabhu      Created
//
//+----------------------------------------------------------------------------
INT32 __stdcall CRemotingServices::GetInternalHashCode(GetInternalHashCodeArgs *pArgs)
{
    DWORD idx = (pArgs->orObj)->GetSyncBlockIndex();    // succeeds or throws

    _ASSERTE(idx != 0);

    return (INT32) idx; 
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::IsRemoteActivationRequired    public
//
//  Synopsis:   Determines whether we can activate in the current context.  
//              If not, then we will end up creating the object in a different 
//              context/appdomain/process/machine and so on...
//              This is used to provide the appropriate activator to JIT
//              (if we return true here ... JIT_NewCrossContext will get called
//              when the "new" executes)
//
//
//  Note:       Called by getNewHelper
//
//  History:    24-May-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::IsRemoteActivationRequired(EEClass* pClass)
{   
    BEGINFORBIDGC();

    _ASSERTE(!pClass->IsThunking());
    
    BOOL fRequiresNewContext = pClass->IsMarshaledByRef();

    // Contextful classes imply marshal by ref but not vice versa
    _ASSERTE(!fRequiresNewContext || 
             !(pClass->IsContextful() && !pClass->IsMarshaledByRef()));

    LOG((LF_REMOTING, LL_INFO1000, "IsRemoteActivationRequired returning %d\n", fRequiresNewContext));

    ENDFORBIDGC();

    return fRequiresNewContext; 
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::RequiresManagedActivation    private
//
//  Synopsis:   Determine if a config file has been parsed or if there
//              are any attributes on the class that would require us
//              to go into the managed activation codepath.
//              
//
//  Note:       Called by CreateProxyOrObject (JIT_NewCrossContext)
//
//  History:    8-Sep-00   MPrabhu      Created
//
//+----------------------------------------------------------------------------
ManagedActivationType __stdcall CRemotingServices::RequiresManagedActivation(EEClass* pClass)
{
    if (!pClass->IsMarshaledByRef())
        return NoManagedActivation;

    // FUTURE: We can make this into an asm stub for perf reasons
    BEGINFORBIDGC();
   
    
	ManagedActivationType bManaged = NoManagedActivation;
    if (pClass->IsConfigChecked())
    {
        // We have done work to figure this out in the past ... 
        // use the cached result
        bManaged = pClass->IsRemoteActivated() ? ManagedActivation : NoManagedActivation;
    }
    else if (pClass->IsContextful() || pClass->HasRemotingProxyAttribute()) 
    {
        // Contextful and classes that have a remoting proxy attribute 
        // (whether they are MarshalByRef or ContextFul) always take the slow 
        // path of managed activation
        bManaged = ManagedActivation;
    }
    else
    {
        // If we have parsed a config file that might have configured
        // this Type to be activated remotely 
        if (GetAppDomain()->IsRemotingConfigured())
        {
            bManaged = ManagedActivation;
            // We will remember if the activation is actually going
            // remote based on if the managed call to IsContextOK returned us
            // a proxy or not
        }        
		else if (pClass->GetMethodTable()->IsComObjectType())
		{
			bManaged = ComObjectType;
		}

        if (bManaged == NoManagedActivation)
        {
            pClass->SetConfigChecked();       
        }
    }                       

    ENDFORBIDGC();

    return bManaged;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::CreateProxyOrObject    public
//
//  Synopsis:   Determine if the current context is appropriate
//              for activation. If the current context is OK then it creates 
//              an object else it creates a proxy.
//              
//
//  Note:       Called by JIT_NewCrossContext 
//
//  History:    24-May-99   TarunA      Created
//
//+----------------------------------------------------------------------------
    
OBJECTREF CRemotingServices::CreateProxyOrObject(MethodTable* pMT, 
    BOOL fIsCom /*default:FALSE*/, BOOL fIsNewObj /*default:FALSE*/)
    /* fIsCom == Did we come here through CoCreateInstance */
    /* fIsNewObj == Did we come here through Jit_NewCrossContext (newObj) */
{   
    _ASSERTE(!pMT->IsThunking());

    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;

    EEClass* pClass = pMT->GetClass();

    // By the time we reach here, we have alread checked that the class requires
    // managed activation. This check is made either through the JIT_NewCrossContext helper
    // or Activator.CreateInstance codepath.
    _ASSERTE(RequiresManagedActivation(pClass) || IsRemoteActivationRequired(pClass));

    if(!s_fInitializedRemoting)
    {        
        if(!InitializeFields())
        {
            // Fatal Error if initialization returns false
            // We can throw exceptions here because a helper frame is setup
            // by the caller
            _ASSERTE(!"Initialization Failed");
            FATAL_EE_ERROR();
        }
    }

        Object *pServer = NULL;
        // Get the address of IsCurrentContextOK in managed code
        void* pTarget = NULL;
        if(!fIsCom)
        {
            pTarget = (void *)CRemotingServices::MDofIsCurrentContextOK()->GetAddrofCode();
        }
        else
        {
            pTarget = (void *)CRemotingServices::MDofCreateObjectForCom()->GetAddrofCode();
        }

        // Arrays are not created by JIT_NewCrossContext
        _ASSERTE(!pClass->IsArrayClass());

        // Get the type seen by reflection
        REFLECTCLASSBASEREF reflectType = (REFLECTCLASSBASEREF) pClass->GetExposedClassObject();
        LPVOID pvType = NULL;
        *(REFLECTCLASSBASEREF *)&pvType = reflectType;

        // This will either an uninitialized object or a proxy
        pServer = (Object *)CTPMethodTable::CallTarget(pTarget, pvType, NULL,(LPVOID)(size_t)(fIsNewObj?1:0));

        if (!pClass->IsContextful() 
            && !pClass->GetMethodTable()->IsComObjectType())
        {   
            // Cache the result of the activation attempt ... 
            // if a strictly MBR class is not configured for remote 
            // activation we will not go 
            // through this slow path next time! 
            // (see RequiresManagedActivation)
            if (IsTransparentProxy(pServer))
            {
                // Set the flag that this class is remote activate
                // which means activation will go to managed code.
                pClass->SetRemoteActivated();
            }
            else
            {
                // Set only the flag that no managed checks are required
                // for this class next time.
                pClass->SetConfigChecked();
            }
        }

        LOG((LF_REMOTING, LL_INFO1000, "CreateProxyOrObject returning 0x%0x\n", pServer));
        if (pClass->IsContextful())
        {
            COUNTER_ONLY(GetPrivatePerfCounters().m_Context.cObjAlloc++);
            COUNTER_ONLY(GetGlobalPerfCounters().m_Context.cObjAlloc++);
        }
        return ObjectToOBJECTREF(pServer);
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::AllocateUninitializedObject    public
//
//  Synopsis:   Allocates an uninitialized object of the given type
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
Object* CRemotingServices::AllocateUninitializedObject(AllocateObjectArgs *pArgs)
{   
    THROWSCOMPLUSEXCEPTION();

    ReflectClass *pRefClass = (ReflectClass *) pArgs->pClassOfObject->GetData();
    EEClass *pEEClass = pRefClass->GetClass();

    // Make sure that this private allocator function is used by remoting 
    // only for marshalbyref objects
    if (!pEEClass->IsMarshaledByRef())
    {
        COMPlusThrow(kRemotingException,L"Remoting_Proxy_ProxyTypeIsNotMBR");
    }

    // if this is an abstract class then we will
    //  fail this
    if (pEEClass->IsAbstract())
    {
        COMPlusThrow(kMemberAccessException,L"Acc_CreateAbst");
    }

    OBJECTREF newobj = AllocateObject(pEEClass->GetMethodTable());

    LOG((LF_REMOTING, LL_INFO1000, "AllocateUninitializedObject returning 0x%0x\n", newobj));
    return OBJECTREFToObject(newobj);
}


//+----------------------------------------------------------------------------
//
//  Method:     VOID RemotingServices::CallDefaultCtor(callDefaultCtorArgs* pArgs)
//  Synopsis:   call default ctor
//
//  History:    01-Nov-99   RajaK      Created
//
//+----------------------------------------------------------------------------
VOID CRemotingServices::CallDefaultCtor(callDefaultCtorArgs* pArgs)
{
    CallDefaultConstructor(pArgs->oref);
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::AllocateInitializedObject    public
//
//  Synopsis:   Allocates an uninitialized object of the given type
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
Object* CRemotingServices::AllocateInitializedObject(AllocateObjectArgs *pArgs)
{   
    THROWSCOMPLUSEXCEPTION();

    ReflectClass *pRefClass = (ReflectClass *) pArgs->pClassOfObject->GetData();
    EEClass *pEEClass = pRefClass->GetClass();

    // Make sure that this private allocator function is used by remoting 
    // only for marshalbyref objects
    _ASSERTE(!pEEClass->IsContextful() || pEEClass->IsMarshaledByRef());

    OBJECTREF newobj = AllocateObject(pEEClass->GetMethodTable());

    CallDefaultConstructor(newobj);

    LOG((LF_REMOTING, LL_INFO1000, "AllocateInitializedObject returning 0x%0x\n", newobj));
    return OBJECTREFToObject(newobj);
}
//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GetStubForNonVirtualMethod   public
//
//  Synopsis:   Get a stub for a non virtual method. 
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
Stub* CRemotingServices::GetStubForNonVirtualMethod(MethodDesc* pMD, LPVOID pvAddrOfCode, Stub* pInnerStub)
{
    THROWSCOMPLUSEXCEPTION();
    
    CPUSTUBLINKER sl;
    Stub* pStub = CTPMethodTable::CreateStubForNonVirtualMethod(pMD, &sl, pvAddrOfCode, pInnerStub);
    return pStub;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GetNonVirtualThunkForVirtualMethod   public
//
//  Synopsis:   Get a thunk for a non virtual method. 
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
LPVOID CRemotingServices::GetNonVirtualThunkForVirtualMethod(MethodDesc* pMD)
{
    THROWSCOMPLUSEXCEPTION();
    
    CPUSTUBLINKER sl;
    return CTPMethodTable::GetOrCreateNonVirtualThunkForVirtualMethod(pMD, &sl);
} 

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::DestroyThunk   public
//
//  Synopsis:   Destroy the thunk for the non virtual method. 
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void CRemotingServices::DestroyThunk(MethodDesc* pMD)
{
    // Delegate to a helper routine
    CTPMethodTable::DestroyThunk(pMD);
} 

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::CheckCast   public
//
//  Synopsis:   Checks either 
//              (1) If the object type supports the given interface OR
//              (2) If the given type is present in the hierarchy of the 
//              object type
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::CheckCast(OBJECTREF orTP, EEClass* pObjClass, 
                                  EEClass *pClass)
{
    BEGINFORBIDGC();

    BOOL fCastOK = FALSE;

    _ASSERTE((NULL != pClass) && (NULL != pObjClass));
    // Object class can never be an interface. We use a separate cached
    // entry for storing interfaces that the proxy supports.
    _ASSERTE(!pObjClass->IsInterface());
    

    // (1) We are trying to cast to an interface 
    if(pClass->IsInterface())
    {
        // Do a quick check for interface cast by comparing it against the
        // cached entry
        MethodTable *pItfMT = (MethodTable *)(size_t)orTP->GetOffset32(CTPMethodTable::GetOffsetOfInterfaceMT()); // @TODO WIN64 - conversion from DWORD to MethodTable* of greater size
        if(NULL != pItfMT)
        {
            if(pItfMT == pClass->GetMethodTable())
            {
                fCastOK = TRUE;
            }
            else
            {
                fCastOK = pItfMT->GetClass()->StaticSupportsInterface(pClass->GetMethodTable());
            }
        }

        if(!fCastOK)
        {
            fCastOK = pObjClass->StaticSupportsInterface(pClass->GetMethodTable());
        }
        
    }
    // (2) Everything else...
    else
    {
        // Walk up the class hierarchy and find a matching class
        while (pObjClass != pClass)
        {
            if (pObjClass == NULL)
            {
                // Oh-oh, the cast did not succeed. Maybe we have to refine
                // the proxy to match the clients view
                break;
            }            

            // Continue searching
            pObjClass = pObjClass->GetParentClass();
        }

        if(pObjClass == pClass)
        {
            fCastOK = TRUE;
        }
    }

    ENDFORBIDGC();

    return fCastOK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::CheckCast   public
//
//  Synopsis:   Refine the type hierarchy that the proxy represents to match
//              the client view. If the client is trying to cast the proxy
//              to a type not supported by the server object then we 
//              return NULL
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::CheckCast(OBJECTREF orTP, EEClass *pClass)
{
    BEGINFORBIDGC();

    MethodTable *pMT = orTP->GetMethodTable();

    // Make sure that we have a transparent proxy
    _ASSERTE(pMT->IsTransparentProxyType());

    pMT = pMT->AdjustForThunking(orTP);
    EEClass *pObjClass = pMT->GetClass();

    // Do a cast check without taking a lock
    BOOL fCastOK = CheckCast(orTP, pObjClass, pClass);

    ENDFORBIDGC();

    if(!fCastOK)
    {
        // Cast on arrays work via ComplexArrayStoreCheck. We should not
        // reach here for such cases.
        _ASSERTE(!pClass->IsArrayClass());

        // We reach here only if any of the types in the current type hierarchy
        // represented by the proxy does not match the given type.     
        // Call a helper routine in managed RemotingServices to find out 
        // whether the server object supports the given type
        const void* pTarget = (const void *)MDofCheckCast()->GetAddrofCode();
        fCastOK = CTPMethodTable::CheckCast(pTarget, orTP, pClass);
    }

    LOG((LF_REMOTING, LL_INFO100, "CheckCast returning %s for object 0x%x and class 0x%x \n", (fCastOK ? "TRUE" : "FALSE")));

    return (fCastOK);
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::NativeCheckCast    public
//
//  Synopsis:   Does a CheckCast to force the expansion of the MethodTable for 
//              the object (possibly a proxy) contained in pvObj.  Returns True if
//              the object is not a proxy or if it can be cast to the specified
//              type.
//
//  History:    22-May-2000   JRoxe     Created
//              03-Oct-2000   TarunA    Modified function name
//
//+----------------------------------------------------------------------------
FCIMPL2(Object*, CRemotingServices::NativeCheckCast, Object* pObj, ReflectClassBaseObject* pType) 
{
    _ASSERTE(pObj != NULL);
    _ASSERTE(pType != NULL);

    OBJECTREF orObj(pObj);
    REFLECTCLASSBASEREF typeObj(pType);

    //Get the EEClass of the object which we have and the class to which we're widening.
    ReflectClass *pRC = (ReflectClass *)typeObj->GetData();
    EEClass *pEEC = pRC->GetClass();
    EEClass *pEECOfObj = orObj->GetClass();

    //Always initialize retval
    // If it's thunking, check what we actually have.
    if (pEECOfObj->IsThunking()) {
        HELPER_METHOD_FRAME_BEGIN_RET_1(orObj);
        if (!CRemotingServices::CheckCast(orObj, pEEC))
            orObj = 0;
        HELPER_METHOD_FRAME_END();
    } 
    return OBJECTREFToObject(orObj);
}
HCIMPLEND

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::FieldAccessor   public
//
//  Synopsis:   Sets/Gets the value of the field given an instance or a proxy
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void CRemotingServices::FieldAccessor(FieldDesc* pFD, OBJECTREF o, LPVOID pVal,
                                      BOOL fIsGetter)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(o->IsThunking() || o->GetClass()->IsMarshaledByRef());

    EEClass *pClass = o->GetClass();
    CorElementType fieldType = pFD->GetFieldType();
    UINT cbSize = GetSizeForCorElementType(fieldType);
    BOOL fIsGCRef = pFD->IsObjRef();
    BOOL fIsByValue = pFD->IsByValue();
    TypeHandle  th;
    EEClass *fldClass = NULL;

    //
    // We mustn't try to get the type handle of a field
    // unless it's a proxy or value type.  Otherwise
    // there is an obscure case where we may cause
    // class loading to happen which is forbidden here.
    // (e.g. getting or setting a null field with a type which
    // hasn't been restored yet.)
    //

    if(!pClass->IsMarshaledByRef() || fIsByValue)
    {
        // Extract the type of the field
        PCCOR_SIGNATURE pSig;
        DWORD       cSig;
        pFD->GetSig(&pSig, &cSig);
        FieldSig sig(pSig, pFD->GetModule());

        OBJECTREF throwable = NULL;
        GCPROTECT_BEGIN(throwable);
        GCPROTECT_BEGIN(o);
        GCPROTECT_BEGININTERIOR(pVal);
        th = sig.GetTypeHandle(&throwable);
        if (throwable != NULL)
            COMPlusThrow(throwable);
        GCPROTECT_END();
        GCPROTECT_END();
        GCPROTECT_END();
        // Extract the field class for unshared method tables only
        // FUTURE: There is a note in class.h that TarunA is supposed 
        // to fix th.AsClass() -- fix it dude !! TarunA
        if(th.IsUnsharedMT())
        {
            fldClass = th.AsClass();
        }
    }

    if(pClass->IsMarshaledByRef())
    {
        BEGINFORBIDGC();

        _ASSERTE(!o->IsThunking());
    
        // This is a reference to a real object. Get/Set the field value
        // and return
        LPVOID pFieldAddress = pFD->GetAddress((LPVOID)OBJECTREFToObject(o));
        LPVOID pDest = (fIsGetter ? pVal : pFieldAddress);
        LPVOID pSrc  = (fIsGetter ? pFieldAddress : pVal);
        if(fIsGCRef && !fIsGetter)
        {
            SetObjectReference((OBJECTREF*)pDest, ObjectToOBJECTREF(*(Object **)pSrc), o->GetAppDomain());
        }
        else if(fIsByValue) 
        {
            CopyValueClass(pDest, pSrc, th.AsMethodTable(), o->GetAppDomain());
        }
        else
        {    
            CopyDestToSrc(pDest, pSrc, cbSize);
        }

        ENDFORBIDGC();
    }
    else
    {
        // This is a reference to a proxy. Get the real class of the instance.
        pClass = pFD->GetMethodTableOfEnclosingClass()->GetClass();
#ifdef _DEBUG
        EEClass *pCheckClass = CTPMethodTable::GetClassBeingProxied(o);
    
        while (pCheckClass != pClass) 
        {
            pCheckClass = pCheckClass->GetParentClass();
            _ASSERTE(pCheckClass);
        }
#endif

        // Call the managed code to start the field access call
        CallFieldAccessor(pFD, o, pVal, fIsGetter, fIsByValue, fIsGCRef, pClass, 
                          fldClass, fieldType, cbSize);        
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::CopyDestToSrc   private
//
//  Synopsis:   Copies the specified number of bytes from the src to dest
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
VOID CRemotingServices::CopyDestToSrc(LPVOID pDest, LPVOID pSrc, UINT cbSize)
{
    BEGINFORBIDGC();

    switch (cbSize)
    {
        case 1:
            *(INT8*)pDest = *(INT8*)pSrc;
            break;
    
        case 2:
            *(INT16*)pDest = *(INT16*)pSrc;
            break;
    
        case 4:
            *(INT32*)pDest = *(INT32*)pSrc;
            break;
    
        case 8:
            *(INT64*)pDest = *(INT64*)pSrc;
            break;
    
        default:
            _ASSERTE(!"Invalid size");
            break;
    }

    ENDFORBIDGC();
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::CallFieldAccessor   private
//
//  Synopsis:   Sets up the arguments and calls RealProxy::FieldAccessor
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
VOID CRemotingServices::CallFieldAccessor(FieldDesc* pFD, 
                                          OBJECTREF o, 
                                          VOID* pVal, 
                                          BOOL fIsGetter, 
                                          BOOL fIsByValue, 
                                          BOOL fIsGCRef,
                                          EEClass *pClass, 
                                          EEClass *fldClass, 
                                          CorElementType fieldType, 
                                          UINT cbSize)
{
    THROWSCOMPLUSEXCEPTION();

    //****************************WARNING******************************
    // GC Protect all non-primitive variables
    //*****************************************************************
    
    FieldArgs fieldArgs;
    // Initialize the member variables because GCPROTECT_BEGIN expects 
    // valid contents. NULL is a valid value
    fieldArgs.obj = NULL;
    fieldArgs.val = NULL;
    fieldArgs.typeName = NULL;
    fieldArgs.fieldName = NULL;    

    GCPROTECT_BEGIN(fieldArgs); // fieldArgs

    fieldArgs.obj = o;

    // protect the field value if it is a gc-ref type
    if(fIsGCRef)
    {
        fieldArgs.val = ObjectToOBJECTREF(*(Object **)pVal);
    }

    // Set up the arguments
    
    // Argument 1: String typeName
    // Argument 2: String fieldName
    // Get the type name and field name strings
    GetTypeAndFieldName(&fieldArgs, pFD); 
    
    // Argument 3: Object val
    OBJECTREF val = NULL;
    if(!fIsGetter)
    {
        // If we are setting a field value then we create a variant data 
        // structure to hold the field value        
        // Extract the field from the gc protected structure if it is an object
        // else use the value passed to the function
        LPVOID pvFieldVal = (fIsGCRef ? (LPVOID)&(fieldArgs.val) : pVal);
        // BUGBUG: This can cause a GC. We need some way to protect the variant
        // data
        OBJECTREF *lpVal = &val;
        GetObjectFromStack(lpVal, pvFieldVal, fieldType, fldClass); 
    }
        
    // Get the method descriptor of the call
    MethodDesc *pMD = (fIsGetter ? MDofFieldGetter() : MDofFieldSetter());
            
    // Call the field accessor function 
    //////////////////////////////// GETTER ///////////////////////////////////
    if(fIsGetter)
    {       
        // Set up the return value
        OBJECTREF oRet = NULL;

        GCPROTECT_BEGIN (oRet);
        CallFieldGetter(pMD, (LPVOID)OBJECTREFToObject(fieldArgs.obj),         
                        (LPVOID)OBJECTREFToObject(fieldArgs.typeName),
                        (LPVOID)&OBJECTREFToObject(oRet),
                        (LPVOID)OBJECTREFToObject(fieldArgs.fieldName));

        // If we are getting a field value then extract the field value
        // based on the type of the field    
        if(fIsGCRef)
        {
            // Do a check cast to ensure that the field type and the 
            // return value are compatible
            OBJECTREF orRet = oRet;
            OBJECTREF orSaved = orRet;
            if(IsTransparentProxy(OBJECTREFToObject(orRet)))
            {
                GCPROTECT_BEGIN(orRet);

                if(!CheckCast(orRet, fldClass))
                {
                    COMPlusThrow(kInvalidCastException, L"Arg_ObjObj");
                }

                orSaved = orRet;

                GCPROTECT_END();
            }

            *(OBJECTREF *)pVal = orSaved;
        }
        else if (fIsByValue) 
        {       
            // Copy from the source to the destination
            if (oRet != NULL)
            {
                CopyValueClass(pVal, oRet->UnBox(), fldClass->GetMethodTable(), fieldArgs.obj->GetAppDomain());
            }
        }
        else
        {
            if (oRet != NULL)
            {                
                CopyDestToSrc(pVal, oRet->UnBox(), cbSize);
            }
        }    
        GCPROTECT_END ();
    }
    ///////////////////////// SETTER //////////////////////////////////////////
    else
    {    
        CallFieldSetter(pMD, 
                        (LPVOID)OBJECTREFToObject(fieldArgs.obj), 
                        (LPVOID)OBJECTREFToObject(fieldArgs.typeName), 
                        (LPVOID)OBJECTREFToObject(val), 
                        (LPVOID)OBJECTREFToObject(fieldArgs.fieldName));
    }

    GCPROTECT_END(); // fieldArgs
}
  
//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GetTypeAndFieldName   private
//
//  Synopsis:   Get the type name and field name of the 
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
VOID CRemotingServices::GetTypeAndFieldName(FieldArgs *pArgs, FieldDesc *pFD)                                   
{
    THROWSCOMPLUSEXCEPTION();

    DWORD          i = 0;
    REFLECTBASEREF refField = NULL;
    ReflectFieldList* pFields = NULL;
    ReflectClass *pRC = NULL;
    LPCUTF8 pszFieldName = pFD->GetName();
    LPWSTR  szName = NULL;

    // Protect the reflection info
    REFLECTCLASSBASEREF reflectType = (REFLECTCLASSBASEREF)pFD->GetEnclosingClass()->GetExposedClassObject();
        
    pRC = (ReflectClass *)(reflectType->GetData());
    // This call can cause a GC!
    pFields = pRC->GetFields();    

    for(i=0;i<pFields->dwFields;i++) 
    {
        // Check for access to non-publics
        // FUTURE: Turn on this restriction when remoting is integrated with
        // We already have a check in managed code. This check might be appropriate as well
        // ManishG 6/28/01
        //if (!pFields->fields[i].pField->IsPublic())
        //    continue;

        // Get the FieldDesc and match names
        if (MatchField(pFields->fields[i].pField, pszFieldName)) 
        {
            // Found the first field that matches, so return it
            // This call can cause a GC!
            refField = pFields->fields[i].GetFieldInfo(pRC);

            break;
        }
    }

    if(refField == NULL)
    {
        // Throw an exception
        COMPlusThrow(kMissingFieldException, L"Arg_MissingFieldException");
    }

    // Extract the type name and field name string
    // FUTURE: Put this in the reflection data structure cache TarunA 11/26/00
    DefineFullyQualifiedNameForClassW();
    szName = GetFullyQualifiedNameForClassW(pFD->GetEnclosingClass());    
    pArgs->typeName = COMString::NewString(szName);
    pArgs->fieldName = COMString::NewString(pszFieldName);
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::MatchField   private
//
//  Synopsis:   Find out whether the given field name is the same as the name
//              of the field descriptor field name.
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::MatchField(FieldDesc* pCurField, LPCUTF8 szFieldName)
{
    BEGINFORBIDGC();

    _ASSERTE(pCurField);

    // Get the name of the field
    LPCUTF8 pwzCurFieldName = pCurField->GetName();
    
    ENDFORBIDGC();

    return strcmp(pwzCurFieldName, szFieldName) == 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::Unwrap   public
//
//  Synopsis:   Unwrap a proxy to return the underlying object
//              
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
FCIMPL1(Object*, CRemotingServices::Unwrap, Object* pvTP)
{
    return pvTP;
}
FCIMPLEND    

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::AlwaysUnwrap   public
//
//  Synopsis:   Unwrap a proxy to return the underlying object
//              
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
FCIMPL1(Object*, CRemotingServices::AlwaysUnwrap, Object* obj)
{
    VALIDATEOBJECTREF(obj);
    
    //**********WARNING************************************************
    // Do not throw exceptions or provoke GC without setting up a frame    
    //
    //*****************************************************************                 
    if(IsTransparentProxy(obj))
        obj = OBJECTREFToObject(GetObjectFromProxy(OBJECTREF(obj), TRUE));

    return obj;
}
FCIMPLEND    

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::Wrap   public
//
//  Synopsis:   Wrap a contextful object to create a proxy
//              Delegates to a helper method to do the actual work
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
OBJECTREF CRemotingServices::Wrap(OBJECTREF or)
{
    THROWSCOMPLUSEXCEPTION();

    // Basic sanity check
    VALIDATEOBJECTREF(or);

    // ******************* WARNING ********************************************
    // Do not throw any exceptions or provoke GC without setting up a frame.
    // At present its the callers responsibility to setup a frame that can 
    // handle exceptions.
    // ************************************************************************    
    OBJECTREF orProxy = or;
    if(or != NULL && (or->GetMethodTable()->IsContextful()))       
    {
        if(!IsTransparentProxy(OBJECTREFToObject(or)))
        {
            // See if we can extract the proxy from the object
            orProxy = GetProxyFromObject(or);
            if(orProxy == NULL)
            {
                // ask the remoting services to wrap the object
                orProxy = CRemotingServices::WrapHelper(or);

                // Check to make sure that everything went fine
                if(orProxy == NULL)
                {
                    // The frame should have been setup by now
                    FATAL_EE_ERROR();
                }                 
            }
        }
    }

    return orProxy;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::WrapHelper   public
//
//  Synopsis:   Wrap an object to return a proxy. This function assumes that 
//              a fcall frame is already setup.
//              Called by JIT_Wrap & Wrap
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
OBJECTREF CRemotingServices::WrapHelper(OBJECTREF obj)
{
    // Basic sanity check
    VALIDATEOBJECTREF(obj);

    // Default return value indicates an error
    OBJECTREF newobj = NULL;
    const void *pTarget = NULL;
    BOOL fThrow = FALSE;
    
    _ASSERTE((obj != NULL) && 
                (!IsTransparentProxy(OBJECTREFToObject(obj))) &&
                obj->GetMethodTable()->IsContextful());
    if (InitializeRemoting())
    {
        // Get the address of wrap in managed code        
        pTarget = (const void *)CRemotingServices::MDofWrap()->GetAddrofCode();
        _ASSERTE(pTarget);
    
        // call the managed method to wrap
        newobj = ObjectToOBJECTREF( (Object *)CTPMethodTable::CallTarget(pTarget,
                                                (LPVOID)OBJECTREFToObject(obj),
                                                NULL));    
    }
    
    return newobj;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GetProxyFromObject   public
//
//  Synopsis:   Extract the proxy from the field in the 
//              ContextBoundObject class
//              
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
OBJECTREF CRemotingServices::GetProxyFromObject(OBJECTREF or)
{
    BEGINFORBIDGC();

    // Basic sanity check
    VALIDATEOBJECTREF(or);

    // We can derive a proxy for contextful types only.
    _ASSERTE(or->GetMethodTable()->IsContextful());

    OBJECTREF srvID = (OBJECTREF)(size_t)or->GetOffset32(s_dwMBRIDOffset);
    OBJECTREF orProxy = NULL;
    
    if (srvID != NULL)
    {
        orProxy = (OBJECTREF)(size_t)srvID->GetOffset32(s_dwTPOrObjOffsetInIdentity);    
    }

    // This should either be null or a proxy type
    _ASSERTE((orProxy == NULL) || 
             IsTransparentProxy(OBJECTREFToObject(orProxy)));

    ENDFORBIDGC();

    return orProxy;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::IsProxyToRemoteObject   public
//
//  Synopsis:   Check if the proxy is to a remote object
//              (1) TRUE : if object is non local (ie outside this PROCESS) otherwise
//              (2) FALSE 
//              
//              
//
//  History:    11-Jan-00   RajaK      Created
//
//+----------------------------------------------------------------------------
BOOL CRemotingServices::IsProxyToRemoteObject(OBJECTREF obj)
{
    // Basic sanity check
    VALIDATEOBJECTREF(obj);

    BOOL fRemote = TRUE;

    // If remoting is not initialzed, for now let us
    // just return FALSE
    if(!s_fInitializedRemoting)
        return FALSE;

    BEGINFORBIDGC();

    _ASSERTE(obj != NULL);

    if(!obj->GetMethodTable()->IsTransparentProxyType())
    {       
        fRemote = FALSE;    
    }
    ENDFORBIDGC();
    
    // so it is a transparent proxy
    if (fRemote != FALSE)
    {       
        AppDomain *pDomain = GetServerDomainForProxy(obj);
        if(pDomain != NULL)
        {
            fRemote = FALSE;
        }
    }    

    return fRemote;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GetObjectFromProxy   public
//
//  Synopsis:   Extract the object given a proxy. 
//              fMatchContexts if
//              (1) TRUE It matches the current context with the server context
//              and if they match then returns the object else the proxy
//              (2) FALSE returns the object without matching the contexts.
//              WARNING!! This should be used by code which is context-aware.
//              
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
OBJECTREF CRemotingServices::GetObjectFromProxy(OBJECTREF obj, 
                                                BOOL fMatchContexts)
{
    BEGINFORBIDGC();

    // Basic sanity check
    VALIDATEOBJECTREF(obj);

    // Make sure that remoting is initialized
    ASSERT(s_fInitializedRemoting);

    // Make sure that we are given a proxy
    ASSERT(IsTransparentProxy(OBJECTREFToObject(obj)));

    OBJECTREF oref = NULL;
    if (CTPMethodTable::GenericCheckForContextMatch(obj))
    {
        OBJECTREF or = ObjectToOBJECTREF(GetRealProxy(OBJECTREFToObject(obj)));
        oref = (OBJECTREF)(size_t)or->GetOffset32(s_dwServerOffsetInRealProxy);
        if (oref != NULL)
        {
            obj = oref; 
        }
    }

    ENDFORBIDGC();

    return obj;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GetServerContext   public
//
//  Synopsis:   Gets the context of the object. If the object is a proxy 
//              extract the context from the identity else the current context
//              is the context of the object.
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
OBJECTREF CRemotingServices::GetServerContext(OBJECTREF obj)
{
    BEGINFORBIDGC();

    // Basic sanity check
    VALIDATEOBJECTREF(obj);

    OBJECTREF serverCtx = NULL;

    if(IsTransparentProxy(OBJECTREFToObject(obj)))
    {
        OBJECTREF id = GetServerIdentityFromProxy(obj);
        if(id != NULL)
        {
            // We can extract the server context only for proxies of objects
            // that were born in this app domain. 
            serverCtx  = (OBJECTREF)(size_t)id->GetOffset32(s_dwServerCtxOffset);
            _ASSERTE(IsInstanceOfContext(serverCtx->GetMethodTable()));
        }
    }
    else
    {
        // Current context is the server context
        serverCtx = GetCurrentContext()->GetExposedObject();
    }

    ENDFORBIDGC();

    return serverCtx;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GetServerIdentityFromProxy   private
//
//  Synopsis:   Gets the server identity (if one exists) from a proxy
//              
//              
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
OBJECTREF CRemotingServices::GetServerIdentityFromProxy(OBJECTREF obj)
{
    BEGINFORBIDGC();

    // Make sure that we are given a proxy
    ASSERT(IsTransparentProxy(OBJECTREFToObject(obj)));

    // Extract the real proxy underlying the transparent proxy
    OBJECTREF or = ObjectToOBJECTREF(GetRealProxy(OBJECTREFToObject(obj)));

    OBJECTREF id = NULL;
        
    // Extract the identity object
    or = (OBJECTREF)(size_t)or->GetOffset32(s_dwIdOffset);

    // Extract the _identity from the real proxy only if it is an instance of 
    // remoting proxy
    if((or != NULL) && IsInstanceOfServerIdentity(or->GetMethodTable()))
    {
        id = or;
    }

    ENDFORBIDGC();

    return id;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GetServerDomainForProxy public
//
//  Synopsis:   Returns the AppDomain corresponding to the server
//              if the proxy and the server are in the same process.
//              
//
//  History:    26-Jan-00    MPrabhu      Created
//
//+----------------------------------------------------------------------------
AppDomain *CRemotingServices::GetServerDomainForProxy(OBJECTREF proxy)
{
    // call the managed method 
    Context *pContext = (Context *)GetServerContextForProxy(proxy);
    if (pContext)
    {
        return pContext->GetDomain();
    }
    else
    {
        return NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GetServerDomainIdForProxy public
//
//  Synopsis:   Returns the AppDomain ID corresponding to the server
//              if the proxy and the server are in the same process.
//              Returns 0 if it cannot determine.
//              
//
//  History:    24-Jan-01    MPrabhu      Created
//
//+----------------------------------------------------------------------------
int CRemotingServices::GetServerDomainIdForProxy(OBJECTREF proxy)
{
    _ASSERTE(IsTransparentProxy(OBJECTREFToObject(proxy)));

    TRIGGERSGC();

    // Get the address of GetDomainIdForProxy in managed code
    const void *pTarget = (const void *)
    CRemotingServices::MDofGetServerDomainIdForProxy()->GetAddrofCode();
    _ASSERTE(pTarget);

    // This will just read the appDomain ID from the marshaled data
    // for the proxy. It returns 0 if the proxy is to a server in another
    // process. It may also return 0 if it cannot determine the server
    // domain ID (eg. for Well Known Object proxies).

    // call the managed method
    // ToDo[MPrabhu]: This cast to Int32 actually causes a potential loss
    // of data.
    return (INT32)CTPMethodTable::CallTarget(
                pTarget,
                (LPVOID)OBJECTREFToObject(proxy),
                NULL);
}


//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GetServerContextForProxy public
//
//  Synopsis:   Returns the AppDomain corresponding to the server
//              if the proxy and the server are in the same process.
//              
//
//  History:    26-Jan-00    MPrabhu      Created
//
//+----------------------------------------------------------------------------
Context *CRemotingServices::GetServerContextForProxy(OBJECTREF proxy)
{
    _ASSERTE(IsTransparentProxy(OBJECTREFToObject(proxy)));
    

    TRIGGERSGC();

    // Get the address of GetAppDomainForProxy in managed code        
    const void *pTarget = (const void *)
    CRemotingServices::MDofGetServerContextForProxy()->GetAddrofCode();
    _ASSERTE(pTarget);
    
    // This will return the correct VM Context object for the server if 
    // the proxy is true cross domain proxy to a server in another domain 
    // in the same process. The managed method will Assert if called on a proxy
    // which is either half-cooked or does not have an ObjRef ... which may
    // happen for eg. if the proxy and the server are in the same appdomain.

    // we return NULL if the server object for the proxy is in another 
    // process or if the appDomain for the server is invalid or if we cannot
    // determine the context (eg. well known object proxies).

    // call the managed method 
    return (Context *)CTPMethodTable::CallTarget(
                            pTarget,
                            (LPVOID)OBJECTREFToObject(proxy),
                            NULL);    
}


// To get the ExportedType for a nested class, we must first get
// the ExportedTypes for all of its enclosers.
HRESULT NestedExportedTypeHelper(
    IMDInternalImport *pTDImport, mdTypeDef mdCurrent, 
    IMDInternalImport *pCTImport, mdExportedType *mct)
{
    mdTypeDef mdEnclosing;
    LPCSTR szcNameSpace;
    LPCSTR szcName;
    HRESULT hr;

    pTDImport->GetNameOfTypeDef(mdCurrent, &szcName, &szcNameSpace);
    if (SUCCEEDED(pTDImport->GetNestedClassProps(mdCurrent, &mdEnclosing))) {
        hr = NestedExportedTypeHelper(pTDImport, mdEnclosing, pCTImport, mct);
        if (FAILED(hr)) return hr;

        return pCTImport->FindExportedTypeByName(szcNameSpace, szcName, *mct, mct);
    }

    return pCTImport->FindExportedTypeByName(szcNameSpace, szcName, mdTokenNil, mct);
}


//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GetExecutionLocation   private
//
//  Synopsis:   Finds the execution location for a given class from the 
//              manifest
//              
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
HRESULT CRemotingServices::GetExecutionLocation(EEClass *pClass, LPCSTR pszLoc)
{
    // Init the out params
    pszLoc = NULL;

    _ASSERTE(!"No longer implemented");

        return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::CreateProxyForDomain   public
//
//  Synopsis:   Create a proxy for the app domain object by calling marshal
//              inside the newly created domain and unmarshaling in the old
//              domain
//              
//
//  History:    02-Dec-99   TarunA      Created
//
//+----------------------------------------------------------------------------
OBJECTREF CRemotingServices::CreateProxyForDomain(AppDomain* pDomain)
{
    THROWSCOMPLUSEXCEPTION();

    // Ensure that the fields of remoting service have been initialized
    // This is separated from the initialization of the remoting services
    if (!s_fInitializedRemoting)
    {
        if (!InitializeFields())
        {
            _ASSERTE(!"Initialization Failed");
            FATAL_EE_ERROR();
    }

    }

    const void *pTarget = (const void *)MDOfCreateProxyForDomain()->GetAddrofCode();

    // Call the managed method which will marshal and unmarshal the 
    // appdomain object to create the proxy

    // We pass the ContextID of the default context of the new appDomain
    // object. This helps the boot-strapping! (i.e. entering the new domain
    // to marshal itself out).

    Object *proxy = (Object *)CTPMethodTable::CallTarget(
                                    pTarget, 
                                    (LPVOID)(size_t)pDomain->GetId(), // @TODO WIN64 - conversion of ULONG to LPVOID of greater size
                                    (LPVOID)pDomain->GetDefaultContext());
    return ObjectToOBJECTREF(proxy);
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GetClass   public
//
//  Synopsis:   Extract the true class of the object whose proxy is given.
//              
//              
//
//  History:    30-Mar-00   TarunA      Created
//
//+----------------------------------------------------------------------------
REFLECTCLASSBASEREF CRemotingServices::GetClass(OBJECTREF pThis)
{
    THROWSCOMPLUSEXCEPTION();

    REFLECTCLASSBASEREF refClass = NULL;
    EEClass *pClass = NULL;

    GCPROTECT_BEGIN(pThis);

    TRIGGERSGC();

    // For proxies to objects in the same appdomain, we always know the
    // correct type
    if(GetServerIdentityFromProxy(pThis) != NULL)
    {
        pClass = pThis->GetTrueMethodTable()->GetClass();
    }
    // For everything else either we have refined the proxy to its correct type
    // or we have to consult the objref to get the true type
    else
    {   const void *pTarget = (const void *)CRemotingServices::MDofGetType()->GetAddrofCode();

        refClass = (REFLECTCLASSBASEREF)(ObjectToOBJECTREF((Object *)CTPMethodTable::CallTarget(pTarget, (LPVOID)OBJECTREFToObject(pThis), NULL)));
        if(refClass == NULL)
        {
            // There was no objref associated with the proxy or it is a proxy
            // that we do not understand. 
            // In this case, we return the class that is stored in the proxy
            pClass = pThis->GetTrueMethodTable()->GetClass();
        }

        _ASSERTE(refClass != NULL || pClass != NULL);

        // Refine the proxy to the class just retrieved
        if(refClass != NULL)
        {
            if(!CTPMethodTable::RefineProxy(pThis, 
                                            ((ReflectClass *)refClass->GetData())->GetClass()))
            {
                // Throw an exception to indicate that we failed to expand the 
                // method table to the given size.
                FATAL_EE_ERROR();
            }
        }
    }    

    if (refClass == NULL)
        refClass = (REFLECTCLASSBASEREF)pClass->GetExposedClassObject();

    GCPROTECT_END();

    _ASSERTE(refClass != NULL);
    return refClass;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRealProxy::SetStubData   public
//
//  Synopsis:   Set the stub data in the transparent proxy
//
//  History:    12-Oct-00   TarunA      Created
//
//+----------------------------------------------------------------------------
FCIMPL2(VOID, CRealProxy::SetStubData, LPVOID pvRP, LPVOID pvStubData)
{
    BOOL fThrow = FALSE;
    OBJECTREF orRP = ObjectToOBJECTREF((Object *)pvRP);    
    
    if(orRP != NULL)
    {
    OBJECTREF orTP = ObjectToOBJECTREF((Object *)(size_t)orRP->GetOffset32(CRemotingServices::GetTPOffset())); // @TODO WIN64 - conversion from 'DWORD' to 'Object *' of greater size
        if(orTP != NULL)
        {
            orTP->SetOffsetObjectRef(
                    CTPMethodTable::GetOffsetOfStubData(), 
                    (size_t)pvStubData);
        }
        else
        {
            fThrow = TRUE;
        }
    }
    else
    {
        fThrow = TRUE;
    }
    
    if(fThrow)
    {
        FCThrowVoid(kArgumentNullException);
    }
}
FCIMPLEND

//+----------------------------------------------------------------------------
//
//  Method:     CRealProxy::GetStubData   public
//
//  Synopsis:   Get the stub data in the transparent proxy
//
//  History:    12-Oct-00   TarunA      Created
//
//+----------------------------------------------------------------------------
FCIMPL1(LPVOID, CRealProxy::GetStubData, LPVOID pvRP)
{
    BOOL fThrow = FALSE;
    OBJECTREF orRP = ObjectToOBJECTREF((Object *)pvRP);    
    LPVOID pvRet = NULL;

    if(orRP != NULL)
    {
    OBJECTREF orTP = ObjectToOBJECTREF((Object *)(size_t)orRP->GetOffset32(CRemotingServices::GetTPOffset())); // @TODO WIN64 - conversion from 'DWORD' to 'Object *' of greater size
        if(orTP != NULL)
        {
            pvRet = (LPVOID)(size_t)orTP->GetOffset32(CTPMethodTable::GetOffsetOfStubData()); // @TODO WIN64 - conversion from 'DWORD' to 'LPVOID' of greater size
        }
        else
        {
            fThrow = TRUE;
        }
    }
    else
    {
        fThrow = TRUE;
    }
    
    if(fThrow)
    {
        FCThrow(kArgumentNullException);
    }

    return pvRet;
}
FCIMPLEND

//+----------------------------------------------------------------------------
//
//  Method:     CRealProxy::GetDefaultStub   public
//
//  Synopsis:   Get the default stub implemented by us which matches contexts
//
//  History:    12-Oct-00   TarunA      Created
//
//+----------------------------------------------------------------------------
FCIMPL0(LPVOID, CRealProxy::GetDefaultStub)
{

    return (LPVOID)CRemotingServices::CheckForContextMatch;
}
FCIMPLEND

//+----------------------------------------------------------------------------
//
//  Method:     CRealProxy::GetStub   public
//
//  Synopsis:   Get the stub pointer in the transparent proxy 
//
//  History:    30-Mar-01   TarunA      Created
//
//+----------------------------------------------------------------------------
FCIMPL1(ULONG_PTR, CRealProxy::GetStub, LPVOID pvRP)
{
    ULONG_PTR stub = 0;
    OBJECTREF orRP = ObjectToOBJECTREF((Object *)pvRP);    
    OBJECTREF orTP = ObjectToOBJECTREF((Object *)(size_t)orRP->GetOffset32(CRemotingServices::GetTPOffset())); // @TODO WIN64 - conversion from 'DWORD' to 'Object *' of greater size
            
    stub = (ULONG_PTR)orTP->GetOffset32(CTPMethodTable::GetOffsetOfStub()); 

    return stub;
}
FCIMPLEND

//+----------------------------------------------------------------------------
//
//  Method:     CRealProxy::GetProxiedType   public
//
//  Synopsis:   Get the type that is represented by the transparent proxy 
//
//  History:    15-Feb-01   TarunA      Created
//
//+----------------------------------------------------------------------------
LPVOID __stdcall CRealProxy::GetProxiedType(GetProxiedTypeArgs *pArgs)
{
    REFLECTCLASSBASEREF refClass = NULL;
    LPVOID rv = NULL;
    OBJECTREF orTP = ObjectToOBJECTREF((Object *)(size_t)pArgs->orRP->GetOffset32(CRemotingServices::GetTPOffset())); // @TODO WIN64 - conversion from 'DWORD' to 'Object *' of greater size
    
    refClass = CRemotingServices::GetClass(orTP);
    
    _ASSERTE(refClass != NULL);
    *((REFLECTCLASSBASEREF *)&rv) = refClass;
    return rv;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::Initialize   public
//
//  Synopsis:   Initialized data structures needed for managing tranparent
//              proxies
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
BOOL CTPMethodTable::Initialize()
{
    // Init    
    s_cRefs = 0;
    s_dwCommitedTPSlots = 0;
    s_dwReservedTPSlots = 0;
    s_pThunkTable = NULL;
    s_pTransparentProxyClass = NULL;
    s_dwGCInfoBytes = 0;
    s_dwMTDataSlots = 0;
    s_dwRPOffset = 0;
    s_dwMTOffset = 0;
    s_dwItfMTOffset = 0;
    s_dwStubOffset = 0;
    s_dwStubDataOffset = 0;
    s_dwMaxSlots = 0;
    s_pTPMT = NULL;    
    s_pTPStub = NULL;    
    s_pDelegateStub = NULL;    
    s_fInitializedTPTable = FALSE;

    // Initialize the thunks
    CVirtualThunks::Initialize();
    CNonVirtualThunk::Initialize();
    
    InitializeCriticalSection(&s_TPMethodTableCrst);
    
    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::Cleanup   public
//
//  Synopsis:   Cleansup data structures used for managing tranparent
//              proxies
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
void CTPMethodTable::Cleanup()
{
    // Replace the transparent proxy method table with the true TP method
    // table so that the transparent proxy class can be unloaded properly
    if(s_pTransparentProxyClass && s_pTPMT)
    {
        s_pTransparentProxyClass->SetMethodTableForTransparentProxy(s_pTPMT);
    }

    // Reclaim memory used by transparent proxies
    if(s_pThunkTable)
    {
        DestroyThunkTable();
    }

    // Reclaim memory used by thunks
    CVirtualThunks *pNextVirtualThunk = CVirtualThunks::GetVirtualThunks();
    CVirtualThunks *pCurrentVirtualThunk = NULL;
    while (pNextVirtualThunk)
    {
        pCurrentVirtualThunk = pNextVirtualThunk;
        pNextVirtualThunk = pNextVirtualThunk->_pNext;
        CVirtualThunks::DestroyVirtualThunk(pCurrentVirtualThunk);
    }

    // Uninit
    if (s_pTPStub)
        s_pTPStub->DecRef();

    if (s_pDelegateStub)
        s_pDelegateStub->DecRef();

    // Clean up the stub managers which aid in debugging
    CVirtualThunkMgr::Cleanup();

    CNonVirtualThunkMgr::Cleanup();

    DeleteCriticalSection(&s_TPMethodTableCrst);

    // Delete the hash table used to store the thunks
    if(s_pThunkHashTable)
    {
        // We need to empty out the hash table of all the thunks we've store in it
        EmptyThunkHashTable();
        delete s_pThunkHashTable;
        s_pThunkHashTable = NULL;
    }
    
    return;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::EmptyThunkHashTable private
//
//  Synopsis:   Frees all the Thunks that are stored in the hash table
//
//  History:    26-Jun-99   TimKur Created
//
//+----------------------------------------------------------------------------
void CTPMethodTable::EmptyThunkHashTable()
{
    EEHashTableIteration Itr;
    LPVOID pvCode = NULL;

    s_pThunkHashTable->IterateStart(&Itr);

    while(s_pThunkHashTable->IterateNext(&Itr))
    {
        pvCode = s_pThunkHashTable->IterateGetValue(&Itr);  

        if(NULL != pvCode)
            delete CNonVirtualThunk::AddrToThunk(pvCode);
    }
}// CTPMethodTable::EmptyThunkHashTable


//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::InitThunkHashTable private
//
//  Synopsis:   Inits the hashtable used to store Thunks
//
//  History:    28-Jun-01   ManishG Created
//
//+----------------------------------------------------------------------------
void CTPMethodTable::InitThunkHashTable()
{
    s_pThunkHashTable = new EEThunkHashTable();
}// CTPMethodTable:InitThunkHashTable


//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::InitializeFields    private
//
//  Synopsis:   Initialize the static fields of CTPMethodTable class
//              and the thunk manager classes
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CTPMethodTable::InitializeFields()
{
    BOOL bRet = TRUE;

    EE_TRY_FOR_FINALLY
    {
        // Acquire the lock
        LOCKCOUNTINCL("InitializeFields in remoting.cpp");
        EnterCriticalSection(&s_TPMethodTableCrst);
        if(!s_fInitializedTPTable)
        {
            // Load Tranparent proxy class
            s_pTransparentProxyClass = g_Mscorlib.GetClass(CLASS__TRANSPARENT_PROXY)->GetClass();

            s_pTPMT = s_pTransparentProxyClass->GetMethodTable();
            s_pTPMT->SetTransparentProxyType();
            
            // Obtain size of GCInfo stored above the method table
            CGCDesc *pGCDesc = CGCDesc::GetCGCDescFromMT(s_pTPMT);
            BYTE *pGCTop = (BYTE *) pGCDesc->GetLowestSeries();
            s_dwGCInfoBytes = (DWORD)(((BYTE *) s_pTPMT) - pGCTop);
            _ASSERTE((s_dwGCInfoBytes & 3) == 0);
            
            // Obtain the number of bytes to be copied for creating the TP
            // method tables containing thunks
            _ASSERTE(((s_dwGCInfoBytes + MethodTable::GetOffsetOfVtable()) & 3) == 0);
            s_dwMTDataSlots = ((s_dwGCInfoBytes + MethodTable::GetOffsetOfVtable()) >> 2);
            
            // We rely on the number of interfaces implemented by the
            // Transparent proxy being 0, so that InterfaceInvoke hints
            // fail and trap to InnerFailStub which also fails and
            // in turn traps to FailStubWorker. In FailStubWorker, we
            // determine the class being proxied and return correct slot.
            _ASSERTE(s_pTPMT->m_wNumInterface == 0);
        
            // Calculate offsets to various fields defined by the
            // __Transparent proxy class
            s_dwRPOffset = g_Mscorlib.GetFieldOffset(FIELD__TRANSPARENT_PROXY__RP);
            s_dwMTOffset = g_Mscorlib.GetFieldOffset(FIELD__TRANSPARENT_PROXY__MT);
            s_dwItfMTOffset = g_Mscorlib.GetFieldOffset(FIELD__TRANSPARENT_PROXY__INTERFACE_MT);
            s_dwStubOffset = g_Mscorlib.GetFieldOffset(FIELD__TRANSPARENT_PROXY__STUB);
            s_dwStubDataOffset = g_Mscorlib.GetFieldOffset(FIELD__TRANSPARENT_PROXY__STUB_DATA);
    
            _ASSERTE(s_dwStubDataOffset == (TP_OFFSET_STUBDATA - sizeof(MethodTable*)));

            // Create the one and only transparent proxy stub
            s_pTPStub = CreateTPStub();
            _ASSERTE(s_pTPStub);
            if(!s_pTPStub)
            {
                bRet = FALSE;
            }
            else
            {
                g_dwTPStubAddr = (size_t)s_pTPStub->GetEntryPoint();
            }

            // Create the one and only delegate stub
            s_pDelegateStub = CreateDelegateStub();

            _ASSERTE(s_pDelegateStub);
            if(!s_pDelegateStub)
            {
                bRet = FALSE;
            }
            else
            {
                
            }

            if(bRet)
            {
                // FUTURE: PERFWORK: Determine the initial size of the hashtable
                _ASSERTE(NULL == s_pThunkHashTable);
                InitThunkHashTable();
                if(NULL != s_pThunkHashTable)
                {
                    LockOwner lock = {&s_TPMethodTableCrst,IsOwnerOfOSCrst};
                    bRet = s_pThunkHashTable->Init(23,&lock);
                }
                else
                {
                    bRet = FALSE;
                }                
            }
    
                // Set the largest possible vtable size 64K
                s_dwMaxSlots = 64*1024;
    
            if(bRet)
            {
                // Create the global thunk table and set the cycle between
                // the transparent proxy class and the global thunk table
                bRet = CreateTPMethodTable();
    
                // Either we successfully initialized the method table or
                // the return value is false
                _ASSERTE(!bRet || s_pThunkTable);
            }
    
            // NOTE: This must always be the last statement in this block
            // to prevent races
            // Load Tranparent proxy class
            s_fInitializedTPTable = TRUE;
        }
    }
    EE_FINALLY
    {
        LeaveCriticalSection(&s_TPMethodTableCrst);
        LOCKCOUNTDECL("InitializeFields in remoting.cpp");
        // Leave the lock
    }EE_END_FINALLY;
    
    // Make sure that the field has been set (done at the end of a 
    // successful initialization)
    _ASSERTE(!bRet || s_fInitializedTPTable);
    
    return bRet;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::GetRP       public
//
//  Synopsis:   Get the real proxy backing the transparent proxy
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
OBJECTREF CTPMethodTable::GetRP(OBJECTREF orTP) 
{
    //THROWSCOMPLUSEXCEPTION();

    if(!s_fInitializedTPTable)
    {
        if(!InitializeFields())
        {
            //Future: Throw an exception here. Can't do like below because
            //one frame has CANNOTTHROWCOMPLUSEXCEPTION
            //_ASSERTE(!"Initialization Failed");
            //COMPlusThrow(kExecutionEngineException, L"ExecutionEngine_YoureHosed");
        }
    }

    _ASSERTE(s_fInitializedTPTable);
    return (OBJECTREF)(size_t)orTP->GetOffset32(s_dwRPOffset);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CreateTPMethodTable   private
//
//  Synopsis:   (1) Reserves a transparent proxy method table that is large 
//              enough to support the largest vtable
//              (2) Commits memory for the GC info of the global thunk table and
//              sets the cycle between the transparent proxy class and the 
//              globale thunk table.
//
//  History:    17-Feb-99   Gopalk      Created
//              12-Jul-99   TarunA      Modified to create one big table
//
//+----------------------------------------------------------------------------
BOOL CTPMethodTable::CreateTPMethodTable()
{
    // Allocate virtual memory that is big enough to hold a method table
    // of the maximum possible size
    DWORD dwReserveSize = ((s_dwMTDataSlots << 2) +
                           (s_dwMaxSlots << 2) +
                           g_SystemInfo.dwPageSize) & ~(g_SystemInfo.dwPageSize - 1);
    void *pAlloc = ::VirtualAlloc(0, dwReserveSize,
                                  MEM_RESERVE | MEM_TOP_DOWN,
                                  PAGE_EXECUTE_READWRITE);
    
    if (pAlloc)
    {
        BOOL bFailed = TRUE;
        // Compute reserved slots
        DWORD dwReservedSlots = dwReserveSize - (s_dwMTDataSlots << 2);
        _ASSERTE((dwReservedSlots & 3) == 0);
        dwReservedSlots = dwReservedSlots >> 2;

        // Make sure that we have not created the one and only
        // transparent proxy method table before
        _ASSERTE(NULL == s_pThunkTable);


        WS_PERF_SET_HEAP(REMOTING_HEAP);

        // Commit the required amount of memory
        DWORD dwCommitSize = (s_dwMTDataSlots) << 2;        
        if (::VirtualAlloc(pAlloc, dwCommitSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE))
        {
            WS_PERF_UPDATE("CreateTPMethodTable", dwCommitSize, pAlloc);

            // Copy the fixed portion from the true TP Method Table
            memcpy(pAlloc,MTToAlloc(s_pTPMT, s_dwGCInfoBytes),
                   (s_dwMTDataSlots << 2));

            // Initialize the transparent proxy method table
            InitThunkTable(
                        0, 
                        dwReservedSlots, 
                        AllocToMT((BYTE *) pAlloc, s_dwGCInfoBytes));

            // At this point the transparent proxy class points to the
            // the true TP Method Table and not the transparent 
            // proxy method table. We do not use the true method table
            // any more. Instead we use the transparent proxy method table
            // for allocating transparent proxies. So, we have to make the
            // transparent proxy class point to the one and only transparent 
            // proxy method table
            MethodTable *pMethodTable = s_pTransparentProxyClass->GetMethodTable();
            CTPMethodTable::s_pTransparentProxyClass->SetMethodTableForTransparentProxy(s_pThunkTable);            

            // Allocate the slots of the Object class method table because
            // we can reflect on the __Transparent proxy class even though 
            // we never intend to use remoting.
            _ASSERTE(NULL != g_pObjectClass);
            _ASSERTE(0 == GetCommitedTPSlots());
            if(ExtendCommitedSlots(g_pObjectClass->GetTotalSlots()))
            {
                bFailed = FALSE;

                // We override the slots allocated for the methods
                // on System.Object class with the slots in 
                // __TransparentProxy class. This gives us the desired behavior 
                // of not intercepting methods on System.Object and executing
                // them locally.
                SLOT *pThunkVtable = s_pThunkTable->GetVtable();
                SLOT *pClassVtable = pMethodTable->GetVtable();
                /*for(unsigned i = 0; i < g_pObjectClass->GetTotalSlots(); i++)
                {
                    pThunkVtable[i] = pClassVtable[i];
                }*/
            }
        }
        else{
            VirtualFree(pAlloc, 0, MEM_RELEASE);
        }
        
        if(bFailed)
        {
            DestroyThunkTable();
        }        
    }

    // Note that the thunk table is set to null on any failure path
    // via DestroyThunkTable
    return (s_pThunkTable == NULL ? FALSE : TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::ExtendCommitedSlots   private
//
//  Synopsis:   Extends the commited slots of transparent proxy method table to
//              the desired number
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
BOOL CTPMethodTable::ExtendCommitedSlots(DWORD dwSlots)
{
    // Sanity checks
    _ASSERTE(s_dwCommitedTPSlots <= dwSlots);
    _ASSERTE(dwSlots <= s_dwReservedTPSlots);
    _ASSERTE((CVirtualThunks::GetVirtualThunks() == NULL) || 
                (s_dwCommitedTPSlots == CVirtualThunks::GetVirtualThunks()->_dwCurrentThunk));
    // Either we have initialized everything or we are asked to allocate
    // some slots during initialization
    _ASSERTE(s_fInitializedTPTable || (0 == s_dwCommitedTPSlots));

    // Commit memory for TPMethodTable
    WS_PERF_SET_HEAP(REMOTING_HEAP);

    BOOL bAlloc = FALSE;
    void *pAlloc = MTToAlloc(s_pThunkTable, s_dwGCInfoBytes);
    DWORD dwCommitSize = (s_dwMTDataSlots + dwSlots) << 2;
    if (::VirtualAlloc(pAlloc, dwCommitSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE))
    {
        WS_PERF_UPDATE("ExtendCommittedSlots", dwCommitSize, pAlloc);

        bAlloc = AllocateThunks(dwSlots, dwCommitSize);
        if (!bAlloc)
            VirtualFree(pAlloc, dwCommitSize, MEM_DECOMMIT);
    }

    return bAlloc;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::AllocateThunks   private
//
//  Synopsis:   Allocates the desired number of thunks for virtual methods
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
BOOL CTPMethodTable::AllocateThunks(DWORD dwSlots, DWORD dwCommitSize)
{
    // Check for existing thunks
    DWORD dwCommitThunks = 0;
    DWORD dwAllocThunks = dwSlots;
    void **pVTable = (void **) s_pThunkTable->GetVtable();
    CVirtualThunks* pThunks = CVirtualThunks::GetVirtualThunks();
    if (pThunks)
    {
        // Compute the sizes of memory to be commited and allocated
        BOOL fCommit;
        if (dwSlots < pThunks->_dwReservedThunks)
        {
            fCommit = TRUE;
            dwCommitThunks = dwSlots;
            dwAllocThunks = 0;
        } 
        else
        {
            fCommit = (pThunks->_dwCurrentThunk != pThunks->_dwReservedThunks);
            dwCommitThunks = pThunks->_dwReservedThunks;
            dwAllocThunks = dwSlots - pThunks->_dwReservedThunks;
        }

        // Commit memory if needed
        if (fCommit)
        {
            WS_PERF_SET_HEAP(REMOTING_HEAP);
            DWORD dwCommitSize = (sizeof(CVirtualThunks) - ConstVirtualThunkSize) +
                                 ((dwCommitThunks - pThunks->_dwStartThunk) * ConstVirtualThunkSize);
            if (!::VirtualAlloc(pThunks, dwCommitSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE))
                return(NULL);
            WS_PERF_UPDATE("ExtendCommittedSlots", dwCommitSize, pThunks);

            // Generate thunks that push slot number and jump to TP stub
            DWORD dwStartSlot = pThunks->_dwStartThunk;
            DWORD dwCurrentSlot = pThunks->_dwCurrentThunk;
            while (dwCurrentSlot < dwCommitThunks)
            {
                pVTable[dwCurrentSlot] = &pThunks->ThunkCode[dwCurrentSlot-dwStartSlot];
                CreateThunkForVirtualMethod(dwCurrentSlot, (BYTE *) pVTable[dwCurrentSlot]);
                ++dwCurrentSlot;
            }
            s_dwCommitedTPSlots = dwCommitThunks;
            pThunks->_dwCurrentThunk = dwCommitThunks;
        }
    }

    // @todo:GopalK
    // Check for the avialability of a TP method table that is no longer being
    // reused

    // Allocate memory if necessary
    if (dwAllocThunks)
    {
        DWORD dwReserveSize = ((sizeof(CVirtualThunks) - ConstVirtualThunkSize) +
                               ((dwAllocThunks << 1) * ConstVirtualThunkSize) +
                               g_SystemInfo.dwPageSize) & ~(g_SystemInfo.dwPageSize - 1);
        void *pAlloc = ::VirtualAlloc(0, dwReserveSize,
                                      MEM_RESERVE | MEM_TOP_DOWN,
                                      PAGE_EXECUTE_READWRITE);
        if (pAlloc)
        {
            WS_PERF_SET_HEAP(REMOTING_HEAP);
            // Commit the required amount of memory
            DWORD dwCommitSize = (sizeof(CVirtualThunks) - ConstVirtualThunkSize) +
                                 (dwAllocThunks * ConstVirtualThunkSize);
            if (::VirtualAlloc(pAlloc, dwCommitSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE))
            {
                WS_PERF_UPDATE("AllocateThunks", dwCommitSize, pAlloc);
                ((CVirtualThunks *) pAlloc)->_pNext = pThunks;
                pThunks = CVirtualThunks::SetVirtualThunks((CVirtualThunks *) pAlloc);
                pThunks->_dwReservedThunks = (dwReserveSize -
                                                  (sizeof(CVirtualThunks) - ConstVirtualThunkSize)) /
                                                 ConstVirtualThunkSize;
                pThunks->_dwStartThunk = dwCommitThunks;
                pThunks->_dwCurrentThunk = dwCommitThunks;

                // Generate thunks that push slot number and jump to TP stub
                DWORD dwStartSlot = pThunks->_dwStartThunk;
                DWORD dwCurrentSlot = pThunks->_dwCurrentThunk;
                while (dwCurrentSlot < dwSlots)
                {
                    pVTable[dwCurrentSlot] = &pThunks->ThunkCode[dwCurrentSlot-dwStartSlot];
                    CreateThunkForVirtualMethod(dwCurrentSlot, (BYTE *) pVTable[dwCurrentSlot]);
                    ++dwCurrentSlot;
                }
                s_dwCommitedTPSlots = dwSlots;
                pThunks->_dwCurrentThunk = dwSlots;
            } else
            {
                ::VirtualFree(pAlloc, 0, MEM_RELEASE);
                return FALSE;
            }
        } else
        {
            return FALSE;
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CreateTPForRP   private
//
//  Synopsis:   Creates a transparent proxy that behaves as an object of the
//              supplied class
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
OBJECTREF CTPMethodTable::CreateTPOfClassForRP(EEClass *pClass, OBJECTREF pRP)
{
    // Sanity check
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pClass);

    OBJECTREF pTP = NULL;
    BOOL fAddRef = TRUE;
    RuntimeExceptionKind reException = kLastException;
    BOOL fAlloc = FALSE;

    if(!s_fInitializedTPTable)
    {
        if(!InitializeFields())
        {
            // Set the exception kind to RuntimeException
            reException = kExecutionEngineException;
        }
        else
        {
            fAddRef = FALSE;
        }
    }

    // Proceed only if we have successfully initialized the fields
    if(s_fInitializedTPTable)
    {
        // Get the size of the VTable for the class to proxy
        DWORD dwSlots = pClass->GetNumVtableSlots();
        if (dwSlots == 0)
            dwSlots = 1;
        
        // The global thunk table must have been initialized
        _ASSERTE(s_pThunkTable != NULL);

        // Check for the need to extend existing TP method table
        if (dwSlots > GetCommitedTPSlots())
        {            
            // Acquire the lock
            LOCKCOUNTINC
            EnterCriticalSection(&s_TPMethodTableCrst);
            if (dwSlots > GetCommitedTPSlots())
            {
                fAlloc = ExtendCommitedSlots(dwSlots);
            }
            else
            {
                // The existing method table is sufficient for us
                fAlloc = TRUE;
            }
            LeaveCriticalSection(&s_TPMethodTableCrst);
            LOCKCOUNTDECL("CreateTPOfClassForRP in remoting.cpp");
        }
        else
        {
            // The existing method table is sufficient for us
            fAlloc = TRUE;
        }
    }

    // Check for failure to create TP Method table of desired size
    if (fAlloc)
    {
        reException = kLastException;

        // GC protect the reference to real proxy
        GCPROTECT_BEGIN(pRP);

        // Create a TP Object
        pTP = FastAllocateObject(GetMethodTable());
        if (pTP != NULL)
        {
            // Sanity check
            _ASSERTE((s_dwRPOffset == 0) && (s_dwStubDataOffset == 0x4) && 
                     (s_dwMTOffset == 8) && (s_dwItfMTOffset == 0xc) && 
                     (s_dwStubOffset == 0x10));

            // Create the cycle between TP and RP
            pRP->SetOffsetObjectRef(CRemotingServices::GetTPOffset(), (size_t)OBJECTREFToObject(pTP));

            // Make the TP behave as an object of supplied class
            pTP->SetOffsetObjectRef(s_dwRPOffset, (size_t) OBJECTREFToObject(pRP));
            
            // If we are creating a proxy for an interface then the class
            // is the object class else it is the class supplied
            if(pClass->IsInterface())
            {
                _ASSERTE(NULL != g_pObjectClass);

                // FUTURE: This is a HACK till we get the signature of 
                // Unmarshal and Connect in managed code changed. Replace it
                // with the line below. TarunA
                //pTP->SetOffset32(s_dwMTOffset, (DWORD)g_pObjectClass);
                pTP->SetOffset32(s_dwMTOffset, (DWORD)(size_t)(CRemotingServices::GetMarshalByRefClass())); // @TODO WIN64 - pointer trunction
                // Set the cached interface method table to the given interface
                // method table
                pTP->SetOffset32(s_dwItfMTOffset, (DWORD)(size_t)pClass->GetMethodTable()); // @TODO WIN64 - pointer truncation
            }
            else
            {
                pTP->SetOffset32(s_dwMTOffset, (DWORD)(size_t)pClass->GetMethodTable()); // @TODO WIN64 - pointer truncation
            }
            

            // Addref the TP Method Table if necessary
            if (fAddRef)
                AddRef();
        } 
        else
        {
            reException = kOutOfMemoryException;
        }

        GCPROTECT_END();
    }

    // Throw if necessary
    if (reException != kLastException)
    {
        COMPlusThrow(reException);
    }

    return(pTP);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::PreCall   private
//
//  Synopsis:   This function replaces the slot number with the function
//              descriptor thus completely setting up the frame
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void __stdcall CTPMethodTable::PreCall(TPMethodFrame *pFrame)
{
    BEGINFORBIDGC();

    _ASSERTE(s_fInitializedTPTable);

    // The frame is not completly setup at this point.
    // Do not throw exceptions or provoke GC
    OBJECTREF pTP = pFrame->GetThis();
    MethodTable *pMT = (MethodTable *)(size_t) pTP->GetOffset32(s_dwMTOffset); // @TODO WIN64 - conversion from 'DWORD' to 'MethodTable *' of greater size
    _ASSERTE(pMT);
    DWORD dwSlot = (DWORD) pFrame->GetSlotNumber();

    // For virtual calls the slot number is pushed but for 
    // non virtual calls/interface invoke the method descriptor is already 
    // pushed
    if(-1 != dwSlot)
    {
        // Replace the slot number with the method descriptor on the stack
        MethodDesc *pMD = pMT->GetClass()->GetMethodDescForSlot(dwSlot);
        pFrame->SetFunction(pMD);
    }
    
    ENDFORBIDGC();

}

PCCOR_SIGNATURE InitMessageData(messageData *msgData, FramedMethodFrame *pFrame, Module **ppModule)
{
    msgData->pFrame = pFrame;
    msgData->iFlags = 0;

    MethodDesc *pMD = pFrame->GetFunction();    
	EEClass* cls = pMD->GetClass();
    if (cls->IsAnyDelegateClass())
    {
		DelegateEEClass* delegateCls = (DelegateEEClass*) cls;

        _ASSERTE(   pFrame->GetThis()->GetClass()->IsDelegateClass()
                 || pFrame->GetThis()->GetClass()->IsMultiDelegateClass());
        msgData->pDelegateMD = pMD;
        msgData->pMethodDesc = COMDelegate::GetMethodDesc(pFrame->GetThis());
        _ASSERTE(msgData->pMethodDesc != NULL);

        if (pMD == delegateCls->m_pBeginInvokeMethod)
        {
            msgData->iFlags |= MSGFLG_BEGININVOKE;
        }
        else
        {
			_ASSERTE(pMD == delegateCls->m_pEndInvokeMethod);
            msgData->iFlags |= MSGFLG_ENDINVOKE;
        }
    }
    else
    {
        msgData->pDelegateMD = NULL;
        msgData->pMethodDesc = pMD;
    }
    if (msgData->pMethodDesc->IsOneWay())
    {
        msgData->iFlags |= MSGFLG_ONEWAY;
    }

    if (msgData->pMethodDesc->IsCtor())
    {
        msgData->iFlags |= MSGFLG_CTOR;
    }

    PCCOR_SIGNATURE pSig;
    DWORD cSig;
    Module *pModule;

    if (msgData->pDelegateMD)
    {
        msgData->pDelegateMD->GetSig(&pSig, &cSig);
        pModule = msgData->pDelegateMD->GetModule();
    }
    else if (msgData->pMethodDesc->IsVarArg()) 
    {
        VASigCookie *pVACookie = pFrame->GetVASigCookie();
        pSig = pVACookie->mdVASig;
        pModule = pVACookie->pModule;
    }
    else 
    {
        msgData->pMethodDesc->GetSig(&pSig, &cSig);
        pModule = msgData->pMethodDesc->GetModule();
    }

    _ASSERTE(ppModule);
    *ppModule = pModule;
    return pSig;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::OnCall   private
//
//  Synopsis:   This function gets control in two situations
//              (1) When a call is made on the transparent proxy it delegates to              
//              PrivateInvoke method on the real proxy
//              (2) When a call is made on the constructor it again delegates to the 
//              PrivateInvoke method on the real proxy.
//              
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
INT64 __stdcall CTPMethodTable::OnCall(TPMethodFrame *pFrame, Thread *pThrd, INT64 *pReturn)
{
    _ASSERTE(s_fInitializedTPTable);
    *pReturn = 0;

    // The frame should be completely setup at this point    

#ifdef REMOTING_PERF
    CRemotingServices::LogRemotingStageInner(CLIENT_MSG_GEN);
#endif

    // We can handle exception and GC promotion from this point
    THROWSCOMPLUSEXCEPTION();

    messageData msgData;
    PCCOR_SIGNATURE pSig = NULL;
    Module *pModule = NULL;
    pSig = InitMessageData(&msgData, pFrame, &pModule);

    _ASSERTE(pSig && pModule);

    // Allocate metasig on the stack
    MetaSig mSig(pSig, pModule);
    msgData.pSig = &mSig; 

    MethodDesc *pMD = pFrame->GetFunction();    
    if (pMD->GetClass()->IsMultiDelegateClass())
    {
        // check that there is only one target
        if (COMDelegate::GetpNext()->GetValue32(pFrame->GetThis()) != NULL)
        {
            COMPlusThrow(kArgumentException, L"Remoting_Delegate_TooManyTargets");
        }
    }

#ifdef PROFILING_SUPPORTED
    // If profiling is active, notify it that remoting stuff is kicking in
    if (CORProfilerTrackRemoting())
        g_profControlBlock.pProfInterface->RemotingClientInvocationStarted(
            reinterpret_cast<ThreadID>(pThrd));
#endif // PROFILING_SUPPORTED

    OBJECTREF pThisPointer = NULL;

#ifdef PROFILING_SUPPORTED
	GCPROTECT_BEGIN(pThisPointer);
#endif // PROFILING_SUPPORTED

    if (pMD->GetClass()->IsDelegateClass() 
        || pMD->GetClass()->IsMultiDelegateClass())
    {
    
        // this is an async call

        _ASSERTE(   pFrame->GetThis()->GetClass()->IsDelegateClass()
                 || pFrame->GetThis()->GetClass()->IsMultiDelegateClass());

        COMDelegate::GetOR()->GetInstanceField(pFrame->GetThis(),&pThisPointer);
    }
    else
    {
        pThisPointer = pFrame->GetThis();
    }

#ifdef PROFILING_SUPPORTED
	GCPROTECT_END();
#endif // PROFILING_SUPPORTED


    OBJECTREF firstParameter;
    const void *pTarget = NULL;
    size_t callType = CALLTYPE_INVALIDCALL;
    // We are invoking either the constructor or a method on the object
    if(pMD->IsCtor())
    {
        // Get the address of PrivateInvoke in managed code
        pTarget = (const void *)CRemotingServices::MDofPrivateInvoke()->GetAddrofCode();
        _ASSERTE(pTarget);
        _ASSERTE(IsTPMethodTable(pThisPointer->GetMethodTable()));
        firstParameter = (OBJECTREF)(size_t)pThisPointer->GetOffset32(s_dwRPOffset);

        // Set a field to indicate that it is a constructor call
        callType = CALLTYPE_CONSTRUCTORCALL;
    }
    else
    {
        // Set a field to indicate that it is a method call
        callType = CALLTYPE_METHODCALL;

        if (IsTPMethodTable(pThisPointer->GetMethodTable()))
        {

            _ASSERTE(pReturn == (void *) (((BYTE *)pFrame) - pFrame->GetNegSpaceSize() - sizeof(INT64)));

            // Extract the real proxy underlying the transparent proxy
            firstParameter = (OBJECTREF)(size_t)pThisPointer->GetOffset32(s_dwRPOffset);

            // Get the address of PrivateInvoke in managed code
            pTarget = (const void *)CRemotingServices::MDofPrivateInvoke()->GetAddrofCode();
            _ASSERTE(pTarget);
        }
        else 
        {
            // must be async if this is not a TP 
            _ASSERTE(pMD->GetClass()->IsAnyDelegateClass());
            firstParameter = NULL;
            
            // Get the address of PrivateInvoke in managed code
            pTarget = (const void *)CRemotingServices::MDofInvokeStatic()->GetAddrofCode();
            _ASSERTE(pTarget);
        }

        
        // Go ahead and call PrivateInvoke on Real proxy. There is no need to 
        // catch exceptions thrown by it
        // @see RealProxy.cool
    }

    _ASSERTE(pTarget);
    
    // Call the appropriate target
    CallTarget(pTarget, (LPVOID)OBJECTREFToObject(firstParameter), (LPVOID)&msgData, (LPVOID)callType);

    // Check for the need to trip thread
    if (pThrd->CatchAtSafePoint())
    {
        // There is no need to GC protect the return object as
        // TPFrame is GC protecting it
        CommonTripThread();
    }

    // floating point return values go in different registers.
    // check that here.
    CorElementType typ = msgData.pSig->GetReturnType();
    if (typ == ELEMENT_TYPE_R4)
    {
        setFPReturn(4, *pReturn);
    }
    else if (typ == ELEMENT_TYPE_R8)
    {
        setFPReturn(8, *pReturn);
    }

#ifdef PROFILING_SUPPORTED
    // If profiling is active, tell profiler we've made the call, received the
    // return value, done any processing necessary, and now remoting is done.
    if (CORProfilerTrackRemoting())
        g_profControlBlock.pProfInterface->RemotingClientInvocationFinished(
            reinterpret_cast<ThreadID>(pThrd));
#endif // PROFILING_SUPPORTED

    // Set the number of bytes to pop
    pFrame->SetFunction((void *)(size_t)pMD->CbStackPop());

#ifdef REMOTING_PERF
    CRemotingServices::LogRemotingStageInner(CLIENT_END_CALL);
#endif

    return(*pReturn);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CheckCast   private
//
//  Synopsis:   Call the managed checkcast method to determine whether the 
//              server type can be cast to the given type
//              
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CTPMethodTable::CheckCast(const void* pTarget, OBJECTREF orTP, EEClass *pClass)
{
    THROWSCOMPLUSEXCEPTION();
    REFLECTCLASSBASEREF reflectType = NULL;
    LPVOID pvType = NULL;    
    BOOL fCastOK = FALSE;
    
    typedef struct _GCStruct
    {
        OBJECTREF orTP;
        OBJECTREF orRP;
    } GCStruct;

    GCStruct gcValues;
    gcValues.orTP = orTP;
    gcValues.orRP = GetRP(orTP);

    GCPROTECT_BEGIN (gcValues);
    COMPLUS_TRY
    {        
        reflectType = (REFLECTCLASSBASEREF) pClass->GetExposedClassObject();
        *(REFLECTCLASSBASEREF *)&pvType = reflectType;

        fCastOK = (BOOL)CallTarget(pTarget, 
                                   (LPVOID)OBJECTREFToObject(gcValues.orRP),
                                   pvType);    
    }
    COMPLUS_CATCH
    {
        fCastOK = FALSE;
        COMPlusRareRethrow();
    }
    COMPLUS_END_CATCH


    if(fCastOK)
    {
        _ASSERTE(s_fInitializedTPTable);

        // The cast succeeded. Replace the current type in the proxy
        // with the given type. 

        // Acquire the lock
        LOCKCOUNTINC
        EnterCriticalSection(&s_TPMethodTableCrst);

        MethodTable *pCurrent = (MethodTable *)(size_t)gcValues.orTP->GetOffset32(s_dwMTOffset); // @TODO WIN64 - conversion from 'DWORD' to 'MethodTable *' of greater size
        
        
        if(pClass->IsInterface())
        {
            // We replace the cached interface method table with the interface
            // method table that we are trying to cast to. This will ensure that
            // casts to this interface, which are likely to happen, will succeed.
            gcValues.orTP->SetOffset32(s_dwItfMTOffset, (DWORD)(size_t) pClass->GetMethodTable()); // @TODO WIN64 - pointer truncation
        }
        else
        {
            BOOL fDerivedClass = FALSE;
            // Check whether this class derives from the current class
            fDerivedClass = CRemotingServices::CheckCast(gcValues.orTP, pClass,
                                                         pCurrent->GetClass());
            // We replace the current method table only if we cast to a more 
            // derived class
            if(fDerivedClass)
            {
                // Set the method table in the proxy to the given method table
                fCastOK = RefineProxy(gcValues.orTP, pClass);
            }
        }
                
        // Release the lock
        LeaveCriticalSection(&s_TPMethodTableCrst);
                LOCKCOUNTDECL("CheckCast in remoting.cpp");
    }

    GCPROTECT_END();
    return fCastOK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::RefineProxy   public
//
//  Synopsis:   Set the method table in the proxy to the given class' method table.
//              Additionally, expand the TP method table to the required number of slots.
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CTPMethodTable::RefineProxy(OBJECTREF orTP, EEClass *pClass)
{
    _ASSERTE((orTP != NULL) && (pClass != NULL));

    BOOL fExpanded = TRUE;

    // Do the expansion only if necessary
    MethodTable *pMT = pClass->GetMethodTable();
    if(pMT != (MethodTable *)(size_t)orTP->GetOffset32(s_dwMTOffset)) // @TODO WIN64 - conversion from 'DWORD' to 'MethodTable *' of greater size
    {
        orTP->SetOffset32(s_dwMTOffset, (DWORD)(size_t)pMT); // @TODO WIN64 - pointer truncation
    
        // Extend the vtable if necessary
        DWORD dwSlots = pClass->GetNumVtableSlots();
        if (dwSlots == 0)
            dwSlots = 1;
    
        if((dwSlots > GetCommitedTPSlots()) && !ExtendCommitedSlots(dwSlots))
        {
            // We failed to extend the committed slots. Indicate a failure
            // by setting the flag to false
            fExpanded = FALSE;
        }
    }

    return fExpanded;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::IsTPMethodTable   private
//
//  Synopsis:   Returns TRUE if the supplied method table is the one and only TP Method
//              Table
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
INT32 CTPMethodTable::IsTPMethodTable(MethodTable *pMT)
{    
    if (GetMethodTable() == pMT)
    {
        return(TRUE);        
    }
    else
    {
        return(FALSE);
    }

}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::DestroyThunk   public
//
//  Synopsis:   Destroy the thunk for the non virtual method. 
//
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void CTPMethodTable::DestroyThunk(MethodDesc* pMD)
{
    if(s_pThunkHashTable)
    {
        EnterCriticalSection (&s_TPMethodTableCrst);

        LPVOID pvCode = NULL;
        s_pThunkHashTable->GetValue(pMD, (HashDatum *)&pvCode);
        CNonVirtualThunk *pThunk = NULL;
        if(NULL != pvCode)
        {
            pThunk = CNonVirtualThunk::AddrToThunk(pvCode);
            delete pThunk;
            s_pThunkHashTable->DeleteValue(pMD);
        }

        LeaveCriticalSection (&s_TPMethodTableCrst);
    }
} 

//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunk::SetNextThunk   public
//
//  Synopsis:   Creates a thunk for the given address and adds it to the global
//              list
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
CNonVirtualThunk* CNonVirtualThunk::SetNonVirtualThunks(const BYTE* pbCode)
{    
    THROWSCOMPLUSEXCEPTION();

    CNonVirtualThunk *pThunk = new CNonVirtualThunk(pbCode);            
    if(NULL == pThunk)
    {
        COMPlusThrowOM();
    }

    // Put the generated thunk in a global list
    // Note: this is called when a NV thunk is being created ..
    // The TPMethodTable critsec is held at this point
    pThunk->SetNextThunk();

    // Set up the stub manager if necessary
    CNonVirtualThunkMgr::InitNonVirtualThunkManager();

    return pThunk;
}

//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunk::~CNonVirtualThunk   public
//
//  Synopsis:   Deletes the thunk from the global list of thunks
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
CNonVirtualThunk::~CNonVirtualThunk()
{
    _ASSERTE(NULL != s_pNonVirtualThunks);

    CNonVirtualThunk* pCurr = s_pNonVirtualThunks;
    CNonVirtualThunk* pPrev = NULL;
    BOOL found = FALSE;

    // Note: This is called with the TPMethodTable critsec held
    while(!found && (NULL != pCurr))
    {
        if(pCurr == this)
        {
            found = TRUE;
            // Unlink from the chain 
            if(NULL != pPrev)
            {                    
                pPrev->_pNext = pCurr->_pNext;
            }
            else
            {
               // First entry needs to be deleted
                s_pNonVirtualThunks = pCurr->_pNext;
            }
        }
        pPrev = pCurr;
        pCurr = pCurr->_pNext;
    }

    _ASSERTE(found);
}

//+----------------------------------------------------------------------------
//
//  Method:     CVirtualThunkMgr::InitVirtualThunkManager   public
//
//  Synopsis:   Adds the stub manager to aid debugger in stepping into calls
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void CVirtualThunkMgr::InitVirtualThunkManager(const BYTE* stubAddress)
{    
    THROWSCOMPLUSEXCEPTION();

    // This is function is already threadsafe since this method is called from within a 
    // critical section ManishG 6/29/01
    if(NULL == s_pVirtualThunkMgr)
    {
        // Add the stub manager for vtable calls
        s_pVirtualThunkMgr =  new CVirtualThunkMgr(stubAddress);
        if (s_pVirtualThunkMgr == NULL)
        {
            COMPlusThrowOM();
        }
    
        StubManager::AddStubManager(s_pVirtualThunkMgr);
    }

}

//+----------------------------------------------------------------------------
//
//  Method:     CVirtualThunkMgr::Cleanup   public
//
//  Synopsis:   Removes the stub manager that aids the debugger 
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void CVirtualThunkMgr::Cleanup()
{
    if(s_pVirtualThunkMgr)
    {
        delete s_pVirtualThunkMgr;
        s_pVirtualThunkMgr = NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CVirtualThunkMgr::CheckIsStub   public
//
//  Synopsis:   Returns TRUE if the given address is the starting address of
//              the transparent proxy stub
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CVirtualThunkMgr::CheckIsStub(const BYTE *stubStartAddress)
{
    BOOL bIsStub = FALSE;

    if(NULL != FindThunk(stubStartAddress))
    {
        bIsStub = TRUE;       
    }

    return bIsStub;
}

//+----------------------------------------------------------------------------
//
//  Method:     CVirtualThunkMgr::Entry2MethodDesc   public
//
//  Synopsis:   Convert a starting address to a MethodDesc
//
//  History:    14-Sep-99 MattSmit      Created
//
//+----------------------------------------------------------------------------
MethodDesc *CVirtualThunkMgr::Entry2MethodDesc(const BYTE *StubStartAddress, MethodTable *pMT)
{
    if (pMT && IsThunkByASM(StubStartAddress))
    {
        return GetMethodDescByASM(StubStartAddress, pMT);
    }
    else
    {
        return NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  Method:     CVirtualThunkMgr::FindThunk   private
//
//  Synopsis:   Finds a thunk that matches the given starting address
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
LPBYTE CVirtualThunkMgr::FindThunk(const BYTE *stubStartAddress)
{
    CVirtualThunks* pThunks = CVirtualThunks::GetVirtualThunks();
    LPBYTE pThunkAddr = NULL;

    while(NULL != pThunks)
    {
        DWORD dwStartSlot = pThunks->_dwStartThunk;
        DWORD dwCurrSlot = pThunks->_dwStartThunk;
        DWORD dwMaxSlot = pThunks->_dwCurrentThunk;        
        while (dwCurrSlot < dwMaxSlot)
        {
            LPBYTE pStartAddr =  pThunks->ThunkCode[dwCurrSlot-dwStartSlot].pCode;
            if((stubStartAddress >= pStartAddr) &&
               (stubStartAddress <  (pStartAddr + ConstVirtualThunkSize)))
            {
                pThunkAddr = pStartAddr;
                break;
            }            
            ++dwCurrSlot;
        }

        pThunks = pThunks->GetNextThunk();            
     }

     return pThunkAddr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunkMgr::InitNonVirtualThunkManager   public
//
//  Synopsis:   Adds the stub manager to aid debugger in stepping into calls
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void CNonVirtualThunkMgr::InitNonVirtualThunkManager()
{   
    THROWSCOMPLUSEXCEPTION();

    // This function is already thread safe since this method is called from within a 
    // critical section
    if(NULL == s_pNonVirtualThunkMgr)
    {
        // Add the stub manager for non vtable calls
        s_pNonVirtualThunkMgr = new CNonVirtualThunkMgr();
        if (s_pNonVirtualThunkMgr == NULL)
        {
            COMPlusThrowOM();
        }
        
        StubManager::AddStubManager(s_pNonVirtualThunkMgr);
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunkMgr::Cleanup   public
//
//  Synopsis:   Removes the stub manager that aids the debugger 
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void CNonVirtualThunkMgr::Cleanup()
{
    if(s_pNonVirtualThunkMgr)
    {
        delete s_pNonVirtualThunkMgr;
        s_pNonVirtualThunkMgr = NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunkMgr::CheckIsStub   public
//
//  Synopsis:   Returns TRUE if the given address is the starting address of
//              one of our thunks
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CNonVirtualThunkMgr::CheckIsStub(const BYTE *stubStartAddress)
{
    BOOL bIsStub = FALSE;

    if(NULL != FindThunk(stubStartAddress))
    {
        bIsStub = TRUE;       
    }

    return bIsStub;
}

//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunkMgr::Entry2MethodDesc   public
//
//  Synopsis:   Convert a starting address to a MethodDesc
//
//  History:    14-Sep-99 MattSmit      Created
//
//+----------------------------------------------------------------------------
MethodDesc *CNonVirtualThunkMgr::Entry2MethodDesc(const BYTE *StubStartAddress, MethodTable *pMT)
{
    if (IsThunkByASM(StubStartAddress))
    {
        return GetMethodDescByASM(StubStartAddress);
    }
    else
    {
        return NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunkMgr::FindThunk   private
//
//  Synopsis:   Finds a thunk that matches the given starting address
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
CNonVirtualThunk* CNonVirtualThunkMgr::FindThunk(const BYTE *stubStartAddress)
{
    CNonVirtualThunk* pThunk = CNonVirtualThunk::GetNonVirtualThunks();

     while(NULL != pThunk)
     {
        if(stubStartAddress == pThunk->GetThunkCode())           
        {
            break;
        }
        pThunk = pThunk->GetNextThunk();            
     }

     return pThunk;
}


//+----------------------------------------------------------------------------
//+- HRESULT MethodDescDispatchHelper(MethodDesc* pMD, INT64[] args, INT64 *pret)
//+----------------------------------------------------------------------------
HRESULT MethodDescDispatchHelper(MethodDesc* pMD, BinderMethodID sigID, INT64 args[], INT64 *pret)
{
    _ASSERTE(pMD != NULL);
    _ASSERTE(pret != NULL);
    _ASSERTE(args != NULL);

    // Setup the thread object.
    Thread *pThread = SetupThread();

    // SetupThread will return NULL if memory is exhausted
    // or if there is some initialization problem
    if (!pThread)
        return E_FAIL;
    
    BOOL fGCDisabled = pThread->PreemptiveGCDisabled();
    if (!fGCDisabled)
    {
        pThread->DisablePreemptiveGC();
    }

    HRESULT hr = S_OK;

    COMPLUS_TRY
    {
        *pret = pMD->Call(args, sigID);
    }
    COMPLUS_CATCH
    {
        hr = SetupErrorInfo(GETTHROWABLE());
    }
    COMPLUS_END_CATCH

    if (!fGCDisabled)
    {
        pThread->EnablePreemptiveGC();
    }
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Method:     HRESULT  CRemotingServices::CallSetDCOMProxy(OBJECTREF realProxy, IUnknown* pUnk)
//
//+----------------------------------------------------------------------------

HRESULT  CRemotingServices::CallSetDCOMProxy(OBJECTREF realProxy, IUnknown* pUnk)
{
    MethodDesc* pMD = CRemotingServices::MDofSetDCOMProxy();
    _ASSERTE(pMD != NULL);

    INT64 args[] = {
        ObjToInt64(realProxy),
        (INT64)pUnk
    };

    INT64 ret;
    return MethodDescDispatchHelper(pMD, METHOD__REAL_PROXY__SETDCOMPROXY, args, &ret);
}

//+----------------------------------------------------------------------------
//
//  HRESULT  CRemotingServices::CallSupportsInterface(OBJECTREF realProxy, REFIID iid)
//
//+----------------------------------------------------------------------------

HRESULT  CRemotingServices::CallSupportsInterface(OBJECTREF realProxy, REFIID iid, INT64* pret)
{
    MethodDesc* pMD = CRemotingServices::MDofSupportsInterface();
    _ASSERTE(pMD != NULL);

    INT64 args[] = {
        ObjToInt64(realProxy),
        (INT64)&iid
    };

    return MethodDescDispatchHelper(pMD, METHOD__REAL_PROXY__SUPPORTSINTERFACE, args, pret);
}
//+----------------------------------------------------------------------------
//
//  Method:     LPVOID CRemotingServices::GetComIUnknown(GetComIPArgs* pArgs)
//  Synopsis:   Get IUnknown for object
//
//  History:    01-Nov-99   RajaK      Created
//
//+----------------------------------------------------------------------------
LPVOID CRemotingServices::GetComIUnknown(GetComIPArgs* pArgs)
{
    _ASSERTE(pArgs != NULL);
    _ASSERTE(pArgs->orObj != NULL);
    return GetIUnknownForMarshalByRefInServerDomain(&pArgs->orObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\securitydb.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _SECURITY_DB_H_
#define _SECURITY_DB_H_

#define INDEX_FILE L"SecurityDB.idx"
#define DB_FILE    L"SecurityDB.db"
#define RAW_FILE   L"SecurityDB.raw"

struct Index {
    DWORD pXml;
    DWORD cXml;
    DWORD pAsn;
    DWORD cAsn;
    Index() : pXml(0), cXml(0), pAsn(0), cAsn(0) {}
};

class List;

class List {
public :
    List *pNext;
    Index *pData;

public :
    List() : pNext(NULL), pData(NULL) {}

    ~List()
    {
        if (pData)
            delete pData;

        // This could be made iterative..
        if (pNext)
            delete pNext;
    }

    BOOL Add(Index *pd)
    {
        _ASSERTE(pd);

        if (!pData)
        {
            // This is the first node
            pData = pd;
            return TRUE;
        }

        List* lst = new List;
        if (!lst)
            return FALSE;

        lst->pData = pd;
        lst->pNext = pNext;
        pNext = lst;

        return TRUE;
    }
};

class SecurityDB {
private:
    DWORD   nRec;
    Index*  pIndex;
    WORD    nNewRec;
    List*   pNewIndex;
    HANDLE  hDB;
    BOOL    dirty;
    BOOL    error;
    WCHAR   szIndexFile[MAX_PATH + 1];
    WCHAR   szDbFile[MAX_PATH + 1];
    WCHAR   szRawFile[MAX_PATH + 1];

public:
    SecurityDB();
    ~SecurityDB();
    BOOL Convert(BYTE* pXml, DWORD cXml, BYTE** pAsn, DWORD* cAsn);

private:
    void FlushIndex();
    BOOL Add(BYTE* pXml, DWORD cXml);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\securitydb.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Used for Creating, Adding, Accessing XML/ASN blobs from a file
//*****************************************************************************

#include "common.h"
#include "CorPerm.h"
#include "SecurityDB.h"

SecurityDB::SecurityDB()
{
    HANDLE hIndex = INVALID_HANDLE_VALUE;
    DWORD dwBytes = 0;
    DWORD dwSizeHigh = 0, dwSize = 0;

    hDB     = INVALID_HANDLE_VALUE;
    dirty   = FALSE;
    error   = FALSE;
    pIndex  = NULL;
    nRec    = 0;
    nNewRec = 0;

    // Fetch database file directory from environment variable.
    WCHAR szDir[MAX_PATH + 1];
    DWORD cchDir = WszGetEnvironmentVariable(SECURITY_BOOTSTRAP_DB, szDir, MAX_PATH);
    if (cchDir == 0)
    {
        wcscpy(szDir, L".\\");
        cchDir = 2;
    }
    else if (cchDir > MAX_PATH)
    {
        goto Error;
    }
    else if (szDir[cchDir - 1] != L'\\')
    {
        szDir[cchDir] = L'\\';
        szDir[cchDir + 1] = L'\0';
        cchDir++;
    }

    size_t ccDir = wcslen( szDir );

    if ((ccDir + wcslen( INDEX_FILE ) > MAX_PATH) ||
        (ccDir + wcslen( DB_FILE ) > MAX_PATH) ||
        (ccDir + wcslen( RAW_FILE ) > MAX_PATH))
    {
        goto Error;
    }

    wcscpy(szIndexFile, szDir);
    wcscpy(szIndexFile + cchDir, INDEX_FILE);

    wcscpy(szDbFile, szDir);
    wcscpy(szDbFile + cchDir, DB_FILE);

    wcscpy(szRawFile, szDir);
    wcscpy(szRawFile + cchDir, RAW_FILE);

    if ((pNewIndex = new List) == NULL)
        goto Error;

    if ((hIndex = WszCreateFile(szIndexFile, GENERIC_READ, 0, NULL,  OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    {
        goto Error;
    }

    dwSize = GetFileSize(hIndex, &dwSizeHigh);

    if ((dwSize == 0xFFFFFFFF) && (GetLastError() != NO_ERROR))
        goto Error;

    _ASSERTE(dwSizeHigh == 0);

    if (dwSize >= sizeof(nRec))
    {
        if (!ReadFile(hIndex, &nRec, sizeof(nRec), &dwBytes, NULL))
            goto Error;

        if (dwBytes != sizeof(nRec))
            goto Error;

        dwSize -= sizeof(nRec);

        if ((sizeof(Index) * nRec) != dwSize)
            goto Error;

        if ((dwSize > 0) && ((pIndex = new Index[nRec]) == NULL))
            goto Error;

        if (!ReadFile(hIndex, pIndex, sizeof(Index) * nRec, &dwBytes, NULL))
            goto Error;

        if (dwBytes != (sizeof(Index) * nRec))
            goto Error;
    }

    if ((hDB = WszCreateFile(szDbFile, GENERIC_READ|GENERIC_WRITE, 0, NULL,
        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_RANDOM_ACCESS, NULL))
        == INVALID_HANDLE_VALUE)
    {
        goto Error;
    }

    goto Cleanup;


Error :

    error = TRUE;

Cleanup :

    if (hIndex != INVALID_HANDLE_VALUE)
        CloseHandle(hIndex);
}

SecurityDB::~SecurityDB()
{
    FlushIndex();

    if (pIndex)
        delete [] pIndex;

    if (pNewIndex)
        delete pNewIndex;

    if (hDB != INVALID_HANDLE_VALUE)
        CloseHandle(hDB);
}

void SecurityDB::FlushIndex()
{
    if (!dirty)
        return;

    HANDLE hIndex = INVALID_HANDLE_VALUE;
    HANDLE hTemp  = INVALID_HANDLE_VALUE;
    DWORD dwBytes = 0;
    List*  pList  = NULL;

    // Create a file to signal that there are new uncompiled enties.
    if ((hTemp = WszCreateFile(szRawFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
        FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    {
        goto Cleanup;
    }

    if(!WriteFile(hTemp, &nNewRec, sizeof(DWORD), &dwBytes, NULL) )
    	goto Cleanup;
    
    FlushFileBuffers(hTemp);
    CloseHandle(hTemp);

    if ((hIndex = WszCreateFile(szIndexFile, GENERIC_WRITE|GENERIC_READ, 0, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_RANDOM_ACCESS, NULL))
        == INVALID_HANDLE_VALUE)
    {
        goto Cleanup;
    }

    if (0xFFFFFFFF == SetFilePointer(hIndex, 0, NULL, FILE_BEGIN))
        goto Cleanup;

    if (!WriteFile(hIndex, &nRec, sizeof(nRec), &dwBytes, NULL))
        goto Cleanup;

    if (dwBytes != sizeof(nRec))
        goto Cleanup;

    if (0xFFFFFFFF == SetFilePointer(hIndex, 0, NULL, FILE_END))
        goto Cleanup;

    pList = pNewIndex;

    while ((pList) && (pList->pData))
    {
        if (!WriteFile(hIndex, pList->pData, sizeof(Index), &dwBytes, NULL))
            goto Cleanup;

        if (dwBytes != sizeof(Index))
            goto Cleanup;

        pList = pList->pNext;
    }

Cleanup :

    if (hIndex != INVALID_HANDLE_VALUE)
        CloseHandle(hIndex);
}

BOOL SecurityDB::Convert(BYTE* pXml, DWORD cXml, BYTE** ppAsn, DWORD* pcAsn)
{
    if (error)
        return FALSE;

    BOOL retVal = TRUE;
    DWORD dwBytes = 0;
    BYTE *pDBXml = NULL;
    DWORD i;

    _ASSERTE(pXml);
    _ASSERTE(cXml);
    _ASSERTE(ppAsn);
    _ASSERTE(pcAsn);

    *ppAsn = NULL;
    *pcAsn = 0;

    pDBXml = new BYTE[cXml];
    if (!pDBXml)
       goto Error;

    for (i=0; i<nRec; ++i)
    {
        // The size of XML blob in DB is compared to the size of input blob.
        if (pIndex[i].cXml == cXml)
        {
            // First get the xml blob from the DB file
            // And compare it with the input blob.
            // If they match, the corresponding Asn is the Asn blob
            // obtained from the DB
            if (0xFFFFFFFF == SetFilePointer(hDB, pIndex[i].pXml, NULL,
                FILE_BEGIN))
                goto Error;

            if (!ReadFile(hDB, pDBXml, cXml, &dwBytes, NULL))
                goto Error;

            if (dwBytes != cXml)
                goto Error;

            if (memcmp(pDBXml, pXml, cXml))
            {
                // Not the one we are looking for..
                continue;
            }

            if (pIndex[i].cAsn == 0 && pIndex[i].pAsn == 0)
            {
                // Not yet compiled
                goto Cleanup;
            }
            
            *ppAsn = new (nothrow) BYTE[pIndex[i].cAsn];

            if (*ppAsn == NULL)
                goto Error;

            if (pIndex[i].cAsn != 0)
            {
                if (0xFFFFFFFF == SetFilePointer(hDB, pIndex[i].pAsn, NULL,
                    FILE_BEGIN))
                    goto Error;
                
                if (!ReadFile(hDB, *ppAsn, pIndex[i].cAsn, &dwBytes, NULL))
                    goto Error;
                
                if (dwBytes != pIndex[i].cAsn)
                {
                    delete [] *ppAsn;
                    *ppAsn = NULL;
                    goto Error;
                }
            }

            *pcAsn = pIndex[i].cAsn;
            goto Cleanup;
        }
    }

    // Not found in DB, need to add the xml blob to db.
    // This is to be compiled later by the Compile utility.
    retVal = Add(pXml, cXml);

    goto Cleanup;

Error :

    retVal = FALSE;

Cleanup :

    if (pDBXml)
        delete [] pDBXml;

    return retVal;
}

BOOL SecurityDB::Add(BYTE* pXml, DWORD cXml)
{
    DWORD dwBytes = 0;
    DWORD dwSizeHigh = 0, dwSize = 0;
    Index* idx = new Index;
    Index* pOldIdx = NULL;
    Index* pNewIdx = NULL;

    if (!idx)
        goto Error;

    dwSize = GetFileSize(hDB, &dwSizeHigh);

    if ((dwSize == 0xFFFFFFFF) && (GetLastError() != NO_ERROR))
        goto Error;

    _ASSERTE(dwSizeHigh == 0);

    if (0xFFFFFFFF == SetFilePointer(hDB, 0, NULL, FILE_END))
        goto Error;

    if (!WriteFile(hDB, pXml, cXml, &dwBytes, NULL))
        goto Error;

    if (dwBytes != cXml)
        goto Error;

    idx->cXml = cXml;
    idx->pXml = dwSize;

    pNewIndex->Add(idx);

    dirty = TRUE;
    ++nNewRec;

    pOldIdx = pIndex; 
    pNewIdx = new Index[nRec + 1];

    memcpy(pNewIdx, pOldIdx, sizeof(Index) * nRec);
    memcpy(&pNewIdx[nRec], idx, sizeof(Index));

    pIndex = pNewIdx;
    ++nRec;

    if (pOldIdx)
        delete [] pOldIdx;
 
    return TRUE;

Error :

    if (idx)
        delete idx;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\rwlock.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+-------------------------------------------------------------------
//
//  File:       RWLock.h
//
//  Contents:   Reader writer lock implementation that supports the
//              following features
//                  1. Cheap enough to be used in large numbers
//                     such as per object synchronization.
//                  2. Supports timeout. This is a valuable feature
//                     to detect deadlocks
//                  3. Supports caching of events. The allows
//                     the events to be moved from least contentious
//                     regions to the most contentious regions.
//                     In other words, the number of events needed by
//                     Reader-Writer lockls is bounded by the number
//                     of threads in the process.
//                  4. Supports nested locks by readers and writers
//                  5. Supports spin counts for avoiding context switches
//                     on  multi processor machines.
//                  6. Supports functionality for upgrading to a writer
//                     lock with a return argument that indicates
//                     intermediate writes. Downgrading from a writer
//                     lock restores the state of the lock.
//                  7. Supports functionality to Release Lock for calling
//                     app code. RestoreLock restores the lock state and
//                     indicates intermediate writes.
//                  8. Recovers from most common failures such as creation of
//                     events. In other words, the lock mainitains consistent
//                     internal state and remains usable
//
//  Classes:    CRWLock,
//              CStaticRWLock
//
//  History:    19-Aug-98   Gopalk      Created
//
//--------------------------------------------------------------------
#ifndef _RWLOCK_H_
#define _RWLOCK_H_
#include "common.h"
#include "threads.h"
#include "frame.h"
#include "ecall.h"
#include <member-offset-info.h>

#ifdef _TESTINGRWLOCK
/***************************************************/
// BUBUG: Testing code
#define LF_SYNC         0x1
#define LL_WARNING      0x2
#define LL_INFO10       0x2
extern void DebugOutput(int expr, int value, char *string, ...);
extern void MyAssert(int expr, char *string, ...);
#define LOG(Arg)  DebugOutput Arg
#define _ASSERTE(expr) MyAssert((int)(expr), "Assert:%s, File:%s, Line:%-d\n",  #expr, __FILE__, __LINE__)
/**************************************************/
#endif

#define RWLOCK_STATISTICS     0   // BUGBUG: Temporarily collect statistics

extern DWORD gdwDefaultTimeout;
extern DWORD gdwDefaultSpinCount;
extern DWORD gdwNumberOfProcessors;


//+-------------------------------------------------------------------
//
//  Struct:     LockCookie
//
//  Synopsis:   Lock cookies returned to the client
//
//+-------------------------------------------------------------------
typedef struct {
    DWORD dwFlags;
    DWORD dwWriterSeqNum;
    WORD wReaderLevel;
    WORD wWriterLevel;
    DWORD dwThreadID;
} LockCookie;

//+-------------------------------------------------------------------
//
//  Class:      CRWLock
//
//  Synopsis:   Class the implements the reader writer locks. 
//
//  History:    21-Aug-98   Gopalk      Created
//
//+-------------------------------------------------------------------
class CRWLock
{
  friend struct MEMBER_OFFSET_INFO(CRWLock);
public:
    // Constuctor
    CRWLock();

    // Cleanup
    void Cleanup();

    // Lock functions
    void AcquireReaderLock(DWORD dwDesiredTimeout = gdwDefaultTimeout);
    void AcquireWriterLock(DWORD dwDesiredTimeout = gdwDefaultTimeout);
    void ReleaseReaderLock();
    void ReleaseWriterLock();
    void UpgradeToWriterLock(LockCookie *pLockCookie,
                             DWORD dwDesiredTimeout = gdwDefaultTimeout);
    void DowngradeFromWriterLock(LockCookie *pLockCookie);
    void ReleaseLock(LockCookie *pLockCookie);
    void RestoreLock(LockCookie *pLockCookie);
    BOOL IsReaderLockHeld();
    BOOL IsWriterLockHeld();
    DWORD GetWriterSeqNum();
    BOOL AnyWritersSince(DWORD dwSeqNum);

    // Statics that do the core work
    static FCDECL1 (void, StaticPrivateInitialize, CRWLock *pRWLock);
    static FCDECL2 (void, StaticAcquireReaderLockPublic, CRWLock *pRWLock, DWORD dwDesiredTimeout);
    static FCDECL2 (void, StaticAcquireWriterLockPublic, CRWLock *pRWLock, DWORD dwDesiredTimeout);
    static FCDECL1 (void, StaticReleaseReaderLockPublic, CRWLock *pRWLock);
    static FCDECL1 (void, StaticReleaseWriterLockPublic, CRWLock *pRWLock);
    static FCDECL3 (void, StaticUpgradeToWriterLock, CRWLock *pRWLock, LockCookie *pLockCookie, DWORD dwDesiredTimeout);
    static FCDECL2 (void, StaticDowngradeFromWriterLock, CRWLock *pRWLock, LockCookie *pLockCookie);
    static FCDECL2 (void, StaticReleaseLock, CRWLock *pRWLock, LockCookie *pLockCookie);
    static FCDECL2 (void, StaticRestoreLock, CRWLock *PRWLock, LockCookie *pLockCookie);
    static FCDECL1 (BOOL, StaticIsReaderLockHeld, CRWLock *pRWLock);
    static FCDECL1 (BOOL, StaticIsWriterLockHeld, CRWLock *pRWLock);
    static FCDECL1 (INT32, StaticGetWriterSeqNum, CRWLock *pRWLock);
    static FCDECL2 (INT32, StaticAnyWritersSince, CRWLock *pRWLock, DWORD dwSeqNum);
private:
    static FCDECL2 (void, StaticAcquireReaderLock, CRWLock **ppRWLock, DWORD dwDesiredTimeout);
    static FCDECL2 (void, StaticAcquireWriterLock, CRWLock **ppRWLock, DWORD dwDesiredTimeout);
    static FCDECL1 (void, StaticReleaseReaderLock, CRWLock **ppRWLock);
    static FCDECL1 (void, StaticReleaseWriterLock, CRWLock **ppRWLock);
public:
    // Assert functions
#ifdef _DEBUG
    BOOL AssertWriterLockHeld();
    BOOL AssertWriterLockNotHeld();
    BOOL AssertReaderLockHeld();
    BOOL AssertReaderLockNotHeld();
    BOOL AssertReaderOrWriterLockHeld();
    void AssertHeld()                            { AssertWriterLockHeld(); }
    void AssertNotHeld()                         { AssertWriterLockNotHeld();
                                                   AssertReaderLockNotHeld(); }
#else
    void AssertWriterLockHeld()                  {  }
    void AssertWriterLockNotHeld()               {  }
    void AssertReaderLockHeld()                  {  }
    void AssertReaderLockNotHeld()               {  }
    void AssertReaderOrWriterLockHeld()          {  }
    void AssertHeld()                            {  }
    void AssertNotHeld()                         {  }
#endif

    // Helper functions
#ifdef RWLOCK_STATISTICS
    DWORD GetReaderEntryCount()                  { return(_dwReaderEntryCount); }
    DWORD GetReaderContentionCount()             { return(_dwReaderContentionCount); }
    DWORD GetWriterEntryCount()                  { return(_dwWriterEntryCount); }
    DWORD GetWriterContentionCount()             { return(_dwWriterContentionCount); }
#endif
    // Static functions
    static void *operator new(size_t size)       { return ::operator new(size); }
    static void ProcessInit();
#ifdef SHOULD_WE_CLEANUP
    static void ProcessCleanup();
#endif /* SHOULD_WE_CLEANUP */
    static void SetTimeout(DWORD dwTimeout)      { gdwDefaultTimeout = dwTimeout; }
    static DWORD GetTimeout()                    { return(gdwDefaultTimeout); }
    static void SetSpinCount(DWORD dwSpinCount)  { gdwDefaultSpinCount = gdwNumberOfProcessors > 1
                                                                         ? dwSpinCount
                                                                         : 0; }
    static DWORD GetSpinCount()                  { return(gdwDefaultSpinCount); }

private:
    // Private helpers
    static void ChainEntry(Thread *pThread, LockEntry *pLockEntry);
    LockEntry *GetLockEntry();
    LockEntry *FastGetOrCreateLockEntry();
    LockEntry *SlowGetOrCreateLockEntry(Thread *pThread);
    void FastRecycleLockEntry(LockEntry *pLockEntry);
    static void RecycleLockEntry(LockEntry *pLockEntry);

    HANDLE GetReaderEvent();
    HANDLE GetWriterEvent();
    void ReleaseEvents();

    static DWORD RWInterlockedCompareExchange(volatile DWORD *pvDestination,
                                              DWORD dwExchange,
                                              DWORD dwComperand);
    static ULONG RWInterlockedExchangeAdd(volatile DWORD *pvDestination, ULONG dwAddState);
    static DWORD RWInterlockedIncrement(DWORD *pdwState);
    static DWORD RWWaitForSingleObject(HANDLE event, DWORD dwTimeout);
    static void RWSetEvent(HANDLE event);
    static void RWResetEvent(HANDLE event);
    static void RWSleep(DWORD dwTime);

    // private new
    static void *operator new(size_t size, void *pv)   { return(pv); }

    // Private data
    void *_pMT;
    HANDLE _hWriterEvent;
    HANDLE _hReaderEvent;
    volatile DWORD _dwState;
    DWORD _dwULockID;
    DWORD _dwLLockID;
    DWORD _dwWriterID;
    DWORD _dwWriterSeqNum;
    WORD _wFlags;
    WORD _wWriterLevel;
#ifdef RWLOCK_STATISTICS
    DWORD _dwReaderEntryCount;
    DWORD _dwReaderContentionCount;
    DWORD _dwWriterEntryCount;
    DWORD _dwWriterContentionCount;
    DWORD _dwEventsReleasedCount;
#endif

    // Static data
    static HANDLE s_hHeap;
    static volatile DWORD s_mostRecentULockID;
    static volatile DWORD s_mostRecentLLockID;
#ifdef _TESTINGRWLOCK
    static CRITICAL_SECTION *s_pRWLockCrst;    
    static CRITICAL_SECTION s_rgbRWLockCrstInstanceData;
#else
    static Crst *s_pRWLockCrst;
    static BYTE s_rgbRWLockCrstInstanceData[sizeof(Crst)];
#endif
};

inline void CRWLock::AcquireReaderLock(DWORD dwDesiredTimeout)
{
    StaticAcquireReaderLockPublic(this, dwDesiredTimeout);
}
inline void CRWLock::AcquireWriterLock(DWORD dwDesiredTimeout)
{
    StaticAcquireWriterLockPublic(this, dwDesiredTimeout);
}
inline void CRWLock::ReleaseReaderLock()
{
    StaticReleaseReaderLockPublic(this);
}
inline void CRWLock::ReleaseWriterLock()
{
    StaticReleaseWriterLockPublic(this);
}
inline void CRWLock::UpgradeToWriterLock(LockCookie *pLockCookie,
                                         DWORD dwDesiredTimeout)
{
    StaticUpgradeToWriterLock(this, pLockCookie, dwDesiredTimeout);
}
inline void CRWLock::DowngradeFromWriterLock(LockCookie *pLockCookie)
{
    StaticDowngradeFromWriterLock(this, pLockCookie);
}
inline void CRWLock::ReleaseLock(LockCookie *pLockCookie)
{
    StaticReleaseLock(this, pLockCookie);
}
inline void CRWLock::RestoreLock(LockCookie *pLockCookie)
{
    StaticRestoreLock(this, pLockCookie);
}
inline BOOL CRWLock::IsReaderLockHeld()
{
    return(StaticIsReaderLockHeld(this));
}
inline BOOL CRWLock::IsWriterLockHeld()
{
    return(StaticIsWriterLockHeld(this));
}
// The following are the inlined versions of the static 
// functions
inline DWORD CRWLock::GetWriterSeqNum()
{
    return(_dwWriterSeqNum);
}
inline BOOL CRWLock::AnyWritersSince(DWORD dwSeqNum)
{ 
    if(_dwWriterID == GetCurrentThreadId())
        ++dwSeqNum;

    return(_dwWriterSeqNum > dwSeqNum);
}

//+-------------------------------------------------------------------
//
//  Class:      CRWLockThunks
//
//  Synopsis:   ECall thunks for RWLock
//
//  History:    02-Jul-99   Gopalk      Created
//
//+-------------------------------------------------------------------
#ifndef FCALLAVAILABLE
class CRWLockThunks
{
public:
    // Arguments to native methods
    struct OnlyThisRWArgs
    {
        DECLARE_ECALL_PTR_ARG(CRWLock *, pRWLock);
    };
    struct ThisPlusTimeoutRWArgs
    {
        DECLARE_ECALL_PTR_ARG(CRWLock *, pRWLock);
        DECLARE_ECALL_I4_ARG(DWORD, dwDesiredTimeout);
    };
    struct ThisPlusLockCookieRWArgs
    {
        DECLARE_ECALL_PTR_ARG(CRWLock *, pRWLock);
        DECLARE_ECALL_PTR_ARG(LockCookie *, pLockCookie);
    };
    struct ThisPlusLockCookiePlusTimeoutRWArgs
    {
        DECLARE_ECALL_PTR_ARG(CRWLock *, pRWLock);
        DECLARE_ECALL_I4_ARG(DWORD, dwDesiredTimeout);
        DECLARE_ECALL_PTR_ARG(LockCookie *, pLockCookie);
    };
    struct ThisPlusSeqNumRWArgs
    {
        DECLARE_ECALL_PTR_ARG(CRWLock *, pRWLock);
        DECLARE_ECALL_I4_ARG(DWORD, dwSeqNum);
    };
    
    // Statics that do the core work
    static void __stdcall StaticPrivateInitialize(OnlyThisRWArgs *pArgs);
    static void __stdcall StaticAcquireReaderLock(ThisPlusTimeoutRWArgs *pArgs);
    static void __stdcall StaticAcquireWriterLock(ThisPlusTimeoutRWArgs *pArgs);
    static void __stdcall StaticReleaseReaderLock(OnlyThisRWArgs *pArgs);
    static void __stdcall StaticReleaseWriterLock(OnlyThisRWArgs *pArgs);
    static void __stdcall StaticUpgradeToWriterLock(ThisPlusLockCookiePlusTimeoutRWArgs *pArgs);
    static void __stdcall StaticDowngradeFromWriterLock(ThisPlusLockCookieRWArgs *pArgs);
    static void __stdcall StaticReleaseLock(ThisPlusLockCookieRWArgs *pArgs);
    static void __stdcall StaticRestoreLock(ThisPlusLockCookieRWArgs *pArgs);
    static INT32 __stdcall StaticIsReaderLockHeld(OnlyThisRWArgs *pArgs);
    static INT32 __stdcall StaticIsWriterLockHeld(OnlyThisRWArgs *pArgs);
    static INT32 __stdcall StaticGetWriterSeqNum(OnlyThisRWArgs *pArgs);
    static INT32 __stdcall StaticAnyWritersSince(ThisPlusSeqNumRWArgs *pArgs);
};
#endif // FCALLAVAILABLE
#endif // _RWLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\sigformat.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// This Module contains routines that expose properties of Member (Classes, Constructors
//  Interfaces and Fields)
//
// Author: Daryl Olander
// Date: March/April 1998
////////////////////////////////////////////////////////////////////////////////


#ifndef _SIGFORMAT_H
#define _SIGFORMAT_H

#include "COMClass.h"
#include "InvokeUtil.h"
#include "ReflectUtil.h"
#include "COMString.h"
#include "COMVariant.h"
#include "COMVarArgs.h"
#include "field.h"

#define SIG_INC 256

//@TODO: Adjust the subclassing to support method and field with a
//	common base class.  M5 when signatures are really implemented.
class SigFormat
{
public:
	SigFormat();

	SigFormat(MethodDesc* pMeth, TypeHandle arrayType, BOOL fIgnoreMethodName = false);
	SigFormat(MetaSig &metaSig, LPCUTF8 memberName, LPCUTF8 className = NULL, LPCUTF8 ns = NULL);
    
	void FormatSig(MetaSig &metaSig, LPCUTF8 memberName, LPCUTF8 className = NULL, LPCUTF8 ns = NULL);
	
	~SigFormat();
	
	STRINGREF GetString();
	const char * GetCString();
	const char * GetCStringParmsOnly();
	
	int AddType(TypeHandle th);

protected:
	char*		_fmtSig;
	int			_size;
	int			_pos;
    TypeHandle  _arrayType; // null type handle if the sig is not for an array. This is currently only set 
                            // through the ctor taking a MethodInfo as its first argument. It will have to be 
                            // exposed some other way to be used in a more generic fashion

	int AddSpace();
	int AddString(LPCUTF8 s);
	
};

class FieldSigFormat : public SigFormat
{
public:
	FieldSigFormat(FieldDesc* pFld);
};

class PropertySigFormat : public SigFormat
{
public:
	PropertySigFormat(MetaSig &metaSig, LPCUTF8 memberName);
	void FormatSig(MetaSig &sig, LPCUTF8 memberName);
};

#endif _SIGFORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\sigformat.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// This Module contains routines that expose properties of Member (Classes, Constructors
//  Interfaces and Fields)
//
// Author: Daryl Olander
// Date: March/April 1998
////////////////////////////////////////////////////////////////////////////////

#include "common.h"
#include "SigFormat.h"

SigFormat::SigFormat() : _arrayType()
{
        _size = SIG_INC;
        _pos = 0;
        _fmtSig = new char[_size];
}

SigFormat::SigFormat(MetaSig &metaSig, LPCUTF8 szMemberName, LPCUTF8 szClassName, LPCUTF8 szNameSpace) : _arrayType()
{
    FormatSig(metaSig, szMemberName, szClassName, szNameSpace);
}
    

// SigFormat::SigFormat()
// This constructor will create the string representation of a 
//  method.
SigFormat::SigFormat(MethodDesc* pMeth, TypeHandle arrayType, BOOL fIgnoreMethodName) : _arrayType()
{
    PCCOR_SIGNATURE pSig;
    DWORD           cSig;
    if (arrayType.IsArray()) 
       _arrayType = arrayType.AsTypeDesc()->GetTypeParam();
    pMeth->GetSig(&pSig,&cSig);
    _ASSERTE(pSig != NULL);
    MetaSig sig(pSig,pMeth->GetModule());
    if (fIgnoreMethodName)
    {
        FormatSig(sig, NULL);
    }
    else
    {
        FormatSig(sig, pMeth->GetName());
    }
}

    
SigFormat::~SigFormat()
{
    if (_fmtSig)
        delete [] _fmtSig;
}

STRINGREF SigFormat::GetString()
{
    STRINGREF p;
    COMPLUS_TRY {
     p = COMString::NewString(_fmtSig);
    } COMPLUS_CATCH {
        return 0;
    } COMPLUS_END_CATCH
    return p;
}

const char * SigFormat::GetCString()
{
    return _fmtSig;
}

const char * SigFormat::GetCStringParmsOnly()
{
     // _fmtSig looks like: "void Put (byte[], int, int)".
     // Skip to the '('.
     int skip;
     for(skip=0; _fmtSig[skip]!='('; skip++)
            ;  
     return _fmtSig + skip;
}


int SigFormat::AddSpace()
{
    if (_pos == _size) {
        char* temp = new char[_size+SIG_INC];
        if (!temp)
            return 0;
        memcpy(temp,_fmtSig,_size);
        delete [] _fmtSig;
        _fmtSig = temp;
        _size+=SIG_INC;
    }
    _fmtSig[_pos] = ' ';
    _fmtSig[++_pos] = 0;
    return 1;
}

int SigFormat::AddString(LPCUTF8 s)
{
    int len = (int)strlen(s);
    // Allocate on overflow
    if (_pos + len >= _size) {
        int newSize = (_size+SIG_INC > _pos + len) ? _size+SIG_INC : _pos + len + SIG_INC; 
        char* temp = new char[newSize];
        if (!temp)
            return 0;
        memcpy(temp,_fmtSig,_size);
        delete [] _fmtSig;
        _fmtSig = temp;
        _size=newSize;
    }
    strcpy(&_fmtSig[_pos],s);
    _pos += len;
    return 1;
}


void SigFormat::FormatSig(MetaSig &sig, LPCUTF8 szMemberName, LPCUTF8 szClassName, LPCUTF8 szNameSpace)
{
    THROWSCOMPLUSEXCEPTION();

    UINT            cArgs;
    TypeHandle      th;

    _size = SIG_INC;
    _pos = 0;
    _fmtSig = new char[_size];

    Thread          *pCurThread = GetThread();
    BOOL            fToggleGC = !pCurThread->PreemptiveGCDisabled();

    if (fToggleGC)
        pCurThread->DisablePreemptiveGC();

    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);
    th = sig.GetReturnProps().GetTypeHandle(sig.GetModule(), &throwable, FALSE, FALSE, &_arrayType);
    if (throwable != NULL)
        COMPlusThrow(throwable);

    AddType(th);
    AddSpace();
    if (szNameSpace != NULL)
    {
        AddString(szNameSpace);
        AddString(".");
    }
    if (szClassName != NULL) 
    {
        AddString(szClassName);
        AddString(".");
    }
    if (szMemberName != NULL)
    {
        AddString(szMemberName);
    }

    cArgs = sig.NumFixedArgs();
    sig.Reset();
    // If the first parameter is the magic value return type
    //  suck it up.

    AddString("(");

    // Loop through all of the args
    for (UINT i=0;i<cArgs;i++) {
        sig.NextArg();
        th = sig.GetArgProps().GetTypeHandle(sig.GetModule(), &throwable, FALSE, FALSE, &_arrayType);
        if (throwable != NULL)
            COMPlusThrow(throwable);

       AddType(th);
       if (i != cArgs-1)
           AddString(", ");
    }

    // Display vararg signature at end
    if (sig.IsVarArg())
    {
        if (cArgs)
            AddString(", ");
        AddString("...");
    }

    AddString(")");
    GCPROTECT_END();
        
    if (fToggleGC)
        pCurThread->EnablePreemptiveGC();
}

int SigFormat::AddType(TypeHandle th)
{
    LPCUTF8     szcName;
    LPCUTF8     szcNameSpace;
    ExpandSig  *pSig;
    ULONG       cArgs;
    VOID       *pEnum;
    ULONG       i;

    if (th.IsNull()) {
        AddString("**UNKNOWN TYPE**");
        return(1);
    }
  
    CorElementType type = th.GetSigCorElementType();

	if ((type == ELEMENT_TYPE_I) && (!(th.AsMethodTable()->GetClass()->IsTruePrimitive())))
		type = ELEMENT_TYPE_VALUETYPE;
	
    // Format the output
    switch (type) 
    {
// @Todo: Should these be ilasm-style types?
    case ELEMENT_TYPE_VOID:     AddString("Void"); break;
    case ELEMENT_TYPE_BOOLEAN:  AddString("Boolean"); break;
    case ELEMENT_TYPE_I1:       AddString("SByte"); break;
    case ELEMENT_TYPE_U1:       AddString("Byte"); break;
    case ELEMENT_TYPE_I2:       AddString("Int16"); break;
    case ELEMENT_TYPE_U2:       AddString("UInt16"); break;
    case ELEMENT_TYPE_CHAR:     AddString("Char"); break;
    case ELEMENT_TYPE_I:        AddString("IntPtr"); break;
    case ELEMENT_TYPE_U:        AddString("UIntPtr"); break;
    case ELEMENT_TYPE_I4:       AddString("Int32"); break;
    case ELEMENT_TYPE_U4:       AddString("UInt32"); break;
    case ELEMENT_TYPE_I8:       AddString("Int64"); break;
    case ELEMENT_TYPE_U8:       AddString("UInt64"); break;
    case ELEMENT_TYPE_R4:       AddString("Single"); break;
    case ELEMENT_TYPE_R8:       AddString("Double"); break;
    case ELEMENT_TYPE_OBJECT:   AddString(g_ObjectClassName); break;
    case ELEMENT_TYPE_STRING:   AddString(g_StringClassName); break;

    // For Value Classes we fall through unless the pVMC is an Array Class, 
    // If its an array class we need to get the name of the underlying type from 
    // it.
    case ELEMENT_TYPE_VALUETYPE:
    case ELEMENT_TYPE_CLASS:
        {
            EEClass* pEEC = th.AsClass();
            pEEC->GetMDImport()->GetNameOfTypeDef(pEEC->GetCl(), &szcName, &szcNameSpace);

            if (*szcNameSpace)
            {
                AddString(szcNameSpace);
                AddString(".");
            }
            AddString(szcName);
            break;
        }
    case ELEMENT_TYPE_TYPEDBYREF:
        {
            AddString("TypedReference");
            break;
        }

    case ELEMENT_TYPE_BYREF:
        {
            TypeHandle h = th.AsTypeDesc()->GetTypeParam();
            AddType(h);
            AddString(" ByRef");
        }
        break;

    case ELEMENT_TYPE_SZARRAY:      // Single Dim, Zero
    case ELEMENT_TYPE_ARRAY:        // General Array
        {
            ArrayTypeDesc* aTD = th.AsArray();
            AddType(aTD->GetElementTypeHandle());
            if (type == ELEMENT_TYPE_ARRAY) {
                AddString("[");
                int len = aTD->GetRank();
                for (int i=0;i<len-1;i++)
                    AddString(",");
                AddString("]");
            }
            else {
                AddString("[]");
            }
        }
        break;

    case ELEMENT_TYPE_PTR:
        {
            // This will pop up on methods that take a pointer to a block of unmanaged memory.
            TypeHandle h = th.AsTypeDesc()->GetTypeParam();
            AddType(h);
            AddString("*");
            break;
        }
    case ELEMENT_TYPE_FNPTR:
        pSig = ((FunctionTypeDesc*)th.AsTypeDesc())->GetSig();
        AddType(pSig->GetReturnTypeHandle());
        AddSpace();
        AddString("(");
        cArgs = pSig->NumFixedArgs();
        pSig->Reset(&pEnum);
        for (i = 0; i < cArgs; i++) {
            AddType(pSig->NextArgExpanded(&pEnum));
            if (i != (cArgs - 1))
                AddString(", ");
        }
        if (pSig->IsVarArg()) {
            if (cArgs)
                AddString(", ");
            AddString("...");
        }
        AddString(")");
        break;

    default:
        AddString("**UNKNOWN TYPE**");

    }
    return 1;
}


FieldSigFormat::FieldSigFormat(FieldDesc* pFld)
{
    THROWSCOMPLUSEXCEPTION();

    PCCOR_SIGNATURE pSig;
    DWORD           cSig;
    CorElementType  type;
    TypeHandle      th;

    pFld->GetSig(&pSig,&cSig);

    _size = SIG_INC;
    _pos = 0;

    // We shouldn't need to allocate memory for this data member since the
    // base class already allocates memory for it.
    // _fmtSig = new char[_size];

    FieldSig sig(pSig,pFld->GetModule());

    type = sig.GetFieldType();

    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);
    th = sig.GetTypeHandle(&throwable);
    if (throwable != NULL)
        COMPlusThrow(throwable);
    GCPROTECT_END();

    AddType(th);
    AddSpace();
    AddString(pFld->GetName());
}


PropertySigFormat::PropertySigFormat(MetaSig &metaSig, LPCUTF8 memberName)
{
    FormatSig(metaSig, memberName);
}


void PropertySigFormat::FormatSig(MetaSig &sig, LPCUTF8 memberName)
{
    THROWSCOMPLUSEXCEPTION();

    UINT            cArgs;
    TypeHandle      th;

    _size = SIG_INC;
    _pos = 0;

    // _fmtSig is already allocated in the base class SigFormat's constructor.
    _ASSERTE(_fmtSig);

    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);
    th = sig.GetRetTypeHandle(&throwable);
    if (throwable != NULL)
        COMPlusThrow(throwable);

    AddType(th);
    AddSpace();
    if (memberName != NULL)
    {
        AddString(memberName);
    }

    cArgs = sig.NumFixedArgs();
    sig.Reset();
    // If the first parameter is the magic value return type
    //  suck it up.

    if (cArgs || sig.IsVarArg()) // For indexed properties and varargs
    {
        AddSpace();
        AddString("[");
            
        // Loop through all of the args
        for (UINT i=0;i<cArgs;i++) {
            sig.NextArg();
            th = sig.GetTypeHandle();

           AddType(th);
           if (i != cArgs-1)
               AddString(", ");
        }

        // Display vararg signature at end
        if (sig.IsVarArg())
        {
            if (cArgs)
                AddString(", ");
            AddString("...");
        }

        AddString("]");
    }

    GCPROTECT_END();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\security.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Security.cpp
**
** Author: Paul Kromann (paulkr)
**
** Purpose: Security implementation and initialization.
**
** Date:  April 15, 1998
**
===========================================================*/

#include "common.h"

#include <shlobj.h>

#include "object.h"
#include "excep.h"
#include "vars.hpp"
#include "security.h"
#include "permset.h"
#include "PerfCounters.h"
#include "COMCodeAccessSecurityEngine.h"
#include "COMSecurityRuntime.h"
#include "COMSecurityConfig.h"
#include "COMString.h"
#include "COMPrincipal.h"
#include "NLSTable.h"
#include "frames.h"
#include "ndirect.h"
#include "StrongName.h"
#include "wsperf.h"
#include "EEConfig.h"
#include "field.h"
#include "AppDomainHelper.h"

#include "threads.inl"

// Statics
DWORD Security::s_dwGlobalSettings = 0;
BOOL SecurityDescriptor::s_quickCacheEnabled = TRUE;
HMODULE Security::s_kernelHandle = NULL;
BOOL Security::s_getLongPathNameWide;
void* Security::s_getLongPathNameFunc = NULL;

void *SecurityProperties::operator new(size_t size, LoaderHeap *pHeap)
{
    return pHeap->AllocMem(size);
}

void SecurityProperties::operator delete(void *pMem)
{
    // No action required
}


Security::StdSecurityInfo Security::s_stdData;

// This function is only used on NT4.

static DWORD WINAPI
Emulate_GetLongPathName(LPCWSTR ptszShort, LPWSTR ptszLong, DWORD ctchBuf)
{
    LPSHELLFOLDER psfDesk;
    HRESULT hr;
    LPITEMIDLIST pidl;
    WCHAR tsz[MAX_PATH];            /* Scratch TCHAR buffer */
    DWORD dwRc;
    LPMALLOC pMalloc;

    //  The file had better exist.  GetFileAttributes() will
    //  not only tell us, but it'll even call SetLastError()
    //  for us.
    if (WszGetFileAttributes(ptszShort) == 0xFFFFFFFF) {
        return 0;
    }

    //
    //  First convert from relative path to absolute path.
    //  This uses the scratch TCHAR buffer.
    //
    dwRc = WszGetFullPathName(ptszShort, MAX_PATH, tsz, NULL);
    if (dwRc == 0) {
        /*
         *  Failed; GFPN already did SetLastError().
         */
    } else if (dwRc >= MAX_PATH) {
        /*
         *  Resulting path would be too long.
         */
        SetLastError(ERROR_BUFFER_OVERFLOW);
        dwRc = 0;
    } else {
        /*
         *  Just right.
         */
        hr = SHGetDesktopFolder(&psfDesk);
        if (SUCCEEDED(hr)) {
            ULONG cwchEaten;

            hr = psfDesk->ParseDisplayName(NULL, NULL, tsz,
                                       &cwchEaten, &pidl, NULL);

            if (FAILED(hr)) {
                /*
                 *  Weird.  Convert the result back to a Win32
                 *  error code if we can.  Otherwise, use the
                 *  generic "duh" error code ERROR_INVALID_DATA.
                 */
                if (HRESULT_FACILITY(hr) == FACILITY_WIN32) {
                    SetLastError(HRESULT_CODE(hr));
                } else {
                    SetLastError(ERROR_INVALID_DATA);
                }
                dwRc = 0;
            } else {
                /*
                 *  Convert the pidl back to a filename in the
                 *  TCHAR scratch buffer.
                 */
                dwRc = SHGetPathFromIDList(pidl, tsz);
                if (dwRc == 0 && tsz[0]) {
                    /*
                     *  Bizarre failure.
                     */
                    SetLastError(ERROR_INVALID_DATA);
                } else {
                    /*
                     *  Copy the result back to the user's buffer.
                     */
                    dwRc = (DWORD)wcslen(tsz);
                    if (dwRc + 1 > ctchBuf) {
                        /*
                         *  On buffer overflow, return necessary
                         *  size including terminating null (+1).
                         */
                        SetLastError(ERROR_INSUFFICIENT_BUFFER);
                        dwRc = dwRc + 1;
                    } else {
                        /*
                         *  On buffer okay, return actual size not
                         *  including terminating null.
                         */
                        wcscpy(ptszLong, tsz);
                    }
                }

                /*
                 *  Free the pidl.
                 */
                if (SUCCEEDED(SHGetMalloc(&pMalloc))) {
                    pMalloc->Free(pidl);
                    pMalloc->Release();
                }
            }
            /*
             *  Release the desktop folder now that we no longer
             *  need it.
             */
            psfDesk->Release();
        }
    }
    return dwRc;
}


void Security::InitData()
{
    THROWSCOMPLUSEXCEPTION();

    static BOOL initialized = FALSE;

    if (!initialized)
    {
        // Note: these buffers should be at least as big as the longest possible
        // string that will be placed into them by the code below.
        WCHAR* cache = new WCHAR[MAX_PATH + sizeof( L"defaultusersecurity.config.cch" ) / sizeof( WCHAR ) + 1];
        WCHAR* config = new WCHAR[MAX_PATH + sizeof( L"defaultusersecurity.config.cch" ) / sizeof( WCHAR ) + 1];

        if (cache == NULL || config == NULL)
            FATAL_EE_ERROR();

        BOOL result;
        
        result = COMSecurityConfig::GetMachineDirectory( config, MAX_PATH );

        _ASSERTE( result );
        if (!result)
            FATAL_EE_ERROR();

        wcscat( config, L"security.config" );
        wcscpy( cache, config );
        wcscat( cache, L".cch" );
        COMSecurityConfig::InitData( COMSecurityConfig::ConfigId::MachinePolicyLevel, config, cache );

        result = COMSecurityConfig::GetMachineDirectory( config, MAX_PATH );

        _ASSERTE( result );
        if (!result)
            FATAL_EE_ERROR();

        wcscat( config, L"enterprisesec.config" );
        wcscpy( cache, config );
        wcscat( cache, L".cch" );
        COMSecurityConfig::InitData( COMSecurityConfig::ConfigId::EnterprisePolicyLevel, config, cache );

        result = COMSecurityConfig::GetUserDirectory( config, MAX_PATH, FALSE );

        if (!result)
        {
            result = COMSecurityConfig::GetMachineDirectory( config, MAX_PATH );

            _ASSERTE( result );
            if (!result)
                FATAL_EE_ERROR();

            wcscat( config, L"defaultusersecurity.config" );
        }
        else
        {
            wcscat( config, L"security.config" );
        }

        wcscpy( cache, config );
        wcscat( cache, L".cch" );
        COMSecurityConfig::InitData( COMSecurityConfig::ConfigId::UserPolicyLevel, config, cache );

        delete [] cache;
        delete [] config;

        OSVERSIONINFOW versionInfo;
        ZeroMemory( &versionInfo, sizeof( versionInfo ) );
        versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);

        if (!WszGetVersionEx( &versionInfo )) {
            _ASSERTE(!"GetVersionEx failed");
            COMPlusThrowWin32();            
        }

        BOOL win98OrHigher = (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
                             ((versionInfo.dwMajorVersion > 4) ||
                              ((versionInfo.dwMajorVersion == 4) && (versionInfo.dwMinorVersion > 0)));

        BOOL win2kOrHigher = (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
                             (versionInfo.dwMajorVersion >= 5);

        if (win98OrHigher || win2kOrHigher)
        {
            s_kernelHandle = WszLoadLibrary( L"kernel32.dll" );

            if (s_kernelHandle != NULL)
            {
                if (win98OrHigher)
                {
                    s_getLongPathNameWide = FALSE;
                    s_getLongPathNameFunc = GetProcAddress( s_kernelHandle, "GetLongPathNameA" );
                }
                else
                {
                    s_getLongPathNameWide = TRUE;
                    s_getLongPathNameFunc = GetProcAddress( s_kernelHandle, "GetLongPathNameW" );
                }
            }
            else
            {
                s_getLongPathNameWide = TRUE;
                s_getLongPathNameFunc = Emulate_GetLongPathName;
            }

            // This looks like a really bad idea since we're holding pointers into
            // this dll from the code directly above.  However, kernel32 is guaranteed
            // to already be loaded in the process, so this merely decrements the count
            // of open handles on it.  The reason we do that here and not in some cleanup
            // code is because it was causing a deadlock. -gregfee 4/2/2001

            FreeLibrary( s_kernelHandle );
            s_kernelHandle = NULL;
        }
        else
        {
            s_getLongPathNameWide = TRUE;
            s_getLongPathNameFunc = Emulate_GetLongPathName;
        }

        initialized = TRUE;
    }
}

typedef DWORD (*GETLONGPATHNAMEWIDE)( LPCWSTR, LPWSTR, DWORD );
typedef DWORD (*GETLONGPATHNAME)( LPCSTR, LPSTR, DWORD );

DWORD
Security::GetLongPathName(
    LPCWSTR lpShortPath,
    LPWSTR lpLongPath,
    DWORD cchLongPath)
{
    COMPLUS_TRY
    {
        InitData();
    }
    COMPLUS_CATCH
    {
        return 0;
    }
    COMPLUS_END_CATCH

    if (s_getLongPathNameFunc == NULL)
    {
        DWORD size = (DWORD)wcslen( lpShortPath );

        if (size < cchLongPath)
        {
            wcscpy( lpLongPath, lpShortPath );
            return size;
        }
        else
        {
            return 0;
        }
    }

    if (s_getLongPathNameWide)
        return ((GETLONGPATHNAMEWIDE)s_getLongPathNameFunc)(lpShortPath, lpLongPath, cchLongPath);

    DWORD  uRet = 0;
    LPSTR szShortPath = NULL;
    LPSTR szLongPath = new (nothrow) CHAR[cchLongPath];

    if (szLongPath == NULL || (lpShortPath != NULL && FAILED( WszConvertToAnsi( (LPWSTR)lpShortPath, &szShortPath, 0, NULL, TRUE ) )))
    {
        goto Exit;
    }

    uRet = ((GETLONGPATHNAME)s_getLongPathNameFunc)(szShortPath, szLongPath, cchLongPath);
    if (uRet <= cchLongPath && lpLongPath != NULL)
    {
        MultiByteToWideChar(CP_ACP, 0, szLongPath, uRet+1, lpLongPath, cchLongPath);
        lpLongPath[uRet] = L'\0';
    }

Exit:
    delete [] szShortPath;
    delete [] szLongPath;

    return uRet;
}


HRESULT Security::Start()
{
    // Making sure we are in sync with URLMon
    _ASSERTE(URLZONE_LOCAL_MACHINE == 0);
    _ASSERTE(URLZONE_INTRANET == 1);
    _ASSERTE(URLZONE_TRUSTED == 2);
    _ASSERTE(URLZONE_INTERNET == 3);
    _ASSERTE(URLZONE_UNTRUSTED == 4);

    ApplicationSecurityDescriptor::s_LockForAppwideFlags = ::new Crst("Appwide Security Flags", CrstPermissionLoad);

#ifdef _DEBUG
    if (g_pConfig->GetSecurityOptThreshold())
        ApplicationSecurityDescriptor::s_dwSecurityOptThreshold = g_pConfig->GetSecurityOptThreshold();
#endif

    SecurityHelper::Init();
    CompressedStack::Init();

    COMSecurityConfig::Init();

    return GetSecuritySettings(&s_dwGlobalSettings);
}

void Security::Stop()
{
    ::delete ApplicationSecurityDescriptor::s_LockForAppwideFlags;

    SecurityHelper::Shutdown();
    CompressedStack::Shutdown();
    COMPrincipal::Shutdown();
}

void Security::SaveCache()
{
    COMSecurityConfig::SaveCacheData( COMSecurityConfig::ConfigId::MachinePolicyLevel );
    COMSecurityConfig::SaveCacheData( COMSecurityConfig::ConfigId::UserPolicyLevel );
    COMSecurityConfig::SaveCacheData( COMSecurityConfig::ConfigId::EnterprisePolicyLevel );

    COMSecurityConfig::Cleanup();
}

//-----------------------------------------------------------
// Currently this method is only useful for setting up a
// cached pointer to the SecurityManager class.
// In the future it may be used to set up other structures.
// For now, it does not even need to be called unless the
// cached pointer is to be used.
//-----------------------------------------------------------
void Security::InitSecurity()
{
        // In the event that we need to run the class initializer (ie, the first time we
        // call this method), running the class initializer allocates a string.  Hence,
        // you can never call InitSecurity (even indirectly) from any FCALL method.  The GC will
        // assert this later of course, but this may save you 10 mins. of debugging.  -- BrianGru
        TRIGGERSGC();

    if (IsInitialized())
        return;

    Thread *pThread = GetThread();
    BOOLEAN bGCDisabled = pThread->PreemptiveGCDisabled();
    if (!bGCDisabled)
        pThread->DisablePreemptiveGC();

    COMPLUS_TRY
    {
        s_stdData.pMethPermSetContains = g_Mscorlib.GetMethod(METHOD__PERMISSION_SET__CONTAINS);
        s_stdData.pMethGetCodeAccessEngine = g_Mscorlib.GetMethod(METHOD__SECURITY_MANAGER__GET_SECURITY_ENGINE);
        s_stdData.pMethResolvePolicy = g_Mscorlib.GetMethod(METHOD__SECURITY_MANAGER__RESOLVE_POLICY);
        s_stdData.pMethCheckGrantSets = g_Mscorlib.GetMethod(METHOD__SECURITY_MANAGER__CHECK_GRANT_SETS);
        s_stdData.pMethCreateSecurityIdentity = g_Mscorlib.GetMethod(METHOD__ASSEMBLY__CREATE_SECURITY_IDENTITY);
        s_stdData.pMethAppDomainCreateSecurityIdentity = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__CREATE_SECURITY_IDENTITY);
        s_stdData.pMethPermSetDemand = g_Mscorlib.GetMethod(METHOD__PERMISSION_SET__DEMAND);
        s_stdData.pMethPrivateProcessMessage = g_Mscorlib.FetchMethod(METHOD__STACK_BUILDER_SINK__PRIVATE_PROCESS_MESSAGE);
        s_stdData.pTypeRuntimeMethodInfo = g_Mscorlib.FetchClass(CLASS__METHOD);
        s_stdData.pTypeMethodBase = g_Mscorlib.FetchClass(CLASS__METHOD_BASE);
        s_stdData.pTypeRuntimeConstructorInfo = g_Mscorlib.FetchClass(CLASS__CONSTRUCTOR);
        s_stdData.pTypeConstructorInfo = g_Mscorlib.FetchClass(CLASS__CONSTRUCTOR_INFO);
        s_stdData.pTypeRuntimeType = g_Mscorlib.FetchClass(CLASS__CLASS);
        s_stdData.pTypeType = g_Mscorlib.FetchClass(CLASS__TYPE);
        s_stdData.pTypeRuntimeEventInfo = g_Mscorlib.FetchClass(CLASS__EVENT);
        s_stdData.pTypeEventInfo = g_Mscorlib.FetchClass(CLASS__EVENT_INFO);
        s_stdData.pTypeRuntimePropertyInfo = g_Mscorlib.FetchClass(CLASS__PROPERTY);
        s_stdData.pTypePropertyInfo = g_Mscorlib.FetchClass(CLASS__PROPERTY_INFO);
        s_stdData.pTypeActivator = g_Mscorlib.FetchClass(CLASS__ACTIVATOR);
        s_stdData.pTypeAppDomain = g_Mscorlib.FetchClass(CLASS__APP_DOMAIN);
        s_stdData.pTypeAssembly = g_Mscorlib.FetchClass(CLASS__ASSEMBLY);
    }
    COMPLUS_CATCH
    {
        // We shouldn't get any exceptions. We just have the handler to keep the
        // EE exception handler happy.
        _ASSERTE(FALSE);
    } 
    COMPLUS_END_CATCH

    if (!bGCDisabled)
        pThread->EnablePreemptiveGC();

    SetInitialized();
}

// This is an ecall
void __stdcall Security::GetGrantedPermissions(const GetPermissionsArg* args)
{
    // Skip one frame (SecurityManager.IsGranted) to get to the caller

    AppDomain* pDomain;
    Assembly* callerAssembly = SystemDomain::GetCallersAssembly( (StackCrawlMark*)args->stackmark, &pDomain );

    _ASSERTE( callerAssembly != NULL);

    AssemblySecurityDescriptor* pSecDesc = callerAssembly->GetSecurityDescriptor(pDomain);

    _ASSERTE( pSecDesc != NULL );

    OBJECTREF token = pSecDesc->GetGrantedPermissionSet(args->ppDenied);
    *(args->ppGranted) = token;
}

void Security::CheckExceptionForSecuritySafety( OBJECTREF obj, BOOL allowPolicyException )
{
    GCPROTECT_BEGIN( obj );

    DefineFullyQualifiedNameForClassOnStack();
    LPUTF8 szClass = GetFullyQualifiedNameForClass(obj->GetClass());
    BOOL bPolicyException = (allowPolicyException && strcmp(g_PolicyExceptionClassName, szClass) == 0);
    BOOL bThreadAbortAppDomainUnloadException = ((strcmp(g_ThreadAbortExceptionClassName, szClass) == 0) ||
                                (strcmp(g_AppDomainUnloadedExceptionClassName, szClass) == 0));
    if (!bPolicyException && !bThreadAbortAppDomainUnloadException) {
        _ASSERTE( FALSE && "Unexcepted exception type thrown thru security routine" );
    }

    GCPROTECT_END();
}

// This is for ecall.
DWORD Security::IsSecurityOnNative(void *pParameters)
{
    return IsSecurityOn();
}

// This is for ecall.
DWORD Security::GetGlobalSecurity(void *pParameters)
{
    return GlobalSettings();
}


void __stdcall Security::SetGlobalSecurity(_SetGlobalSecurity* args)
{
    THROWSCOMPLUSEXCEPTION();
    if((args->flags & CORSETTING_SECURITY_OFF) == CORSETTING_SECURITY_OFF)
    {
        MethodDesc* pMd = g_Mscorlib.GetMethod(METHOD__SECURITY_MANAGER__CHECK_PERMISSION_TO_SET_GLOBAL_FLAGS);
        INT64 arg[] = {
            (INT64)args->flags
        };
        pMd->Call(arg, METHOD__SECURITY_MANAGER__CHECK_PERMISSION_TO_SET_GLOBAL_FLAGS);
    }
    Security::SetGlobalSettings( args->mask, args->flags );
}

void __stdcall Security::SaveGlobalSecurity(void *pParamaters)
{
    ::SetSecurityFlags( 0xFFFFFFFF, GlobalSettings() );
}

void Security::_GetSharedPermissionInstance(OBJECTREF *perm, int index)
{
    _ASSERTE(index < NUM_PERM_OBJECTS);

    COMPLUS_TRY
    {
     AppDomain *pDomain = GetAppDomain();
    SharedPermissionObjects *pShared = &pDomain->m_pSecContext->m_rPermObjects[index];

    if (pShared->hPermissionObject == NULL) {
        pShared->hPermissionObject = pDomain->CreateHandle(NULL);
        *perm = NULL;
    }
    else
        *perm = ObjectFromHandle(pShared->hPermissionObject);

    if (*perm == NULL)
    {
        EEClass *pClass = NULL;
        MethodTable *pMT = NULL;
        OBJECTREF p = NULL;

        GCPROTECT_BEGIN(p);

        pMT = g_Mscorlib.GetClass(pShared->idClass);
        MethodDesc *pCtor = g_Mscorlib.GetMethod(pShared->idConstructor);

        p = AllocateObject(pMT);

        INT64 argInit[2] =
        {
            ObjToInt64(p),
            (INT64) pShared->dwPermissionFlag
        };

        pCtor->Call(argInit, pShared->idConstructor);

        StoreObjectInHandle(pShared->hPermissionObject, p);

        *perm = p;
        GCPROTECT_END();
    }
}
    COMPLUS_CATCH
    {
        *perm = NULL;
    }
    COMPLUS_END_CATCH
}

//---------------------------------------------------------
// Does a method have a REQ_SO CustomAttribute?
//
// S_OK    = yes
// S_FALSE = no
// FAILED  = unknown because something failed.
//---------------------------------------------------------
/*static*/
HRESULT Security::HasREQ_SOAttribute(IMDInternalImport *pInternalImport, mdToken token)
{
    _ASSERTE(TypeFromToken(token) == mdtMethodDef);

    DWORD       dwAttr = pInternalImport->GetMethodDefProps(token);

    return (dwAttr & mdRequireSecObject) ? S_OK : S_FALSE;
}

// Called at the beginning of code-access and code-identity stack walk
// callback functions.
//
// Returns true if action set
//         false if no action
BOOL Security::SecWalkCommonProlog (SecWalkPrologData * pData,
                                    MethodDesc * pMeth,
                                    StackWalkAction * pAction,
                                    CrawlFrame * pCf)
{
    // If we're not searching for the first interesting frame based on a stack
    // mark, we're probably running a declarative demand, in which case we want
    // to skip the frame established by the demand itself (in keeping with the
    // imperative semantics). It's always safe to do this (based simply on
    // whether the frame is a security interceptor) since we never initiate a
    // security stackwalk for any other scenario in which the first frame is an
    // interceptor.
    if (pData->pStackMark == NULL &&
        pData->bFirstFrame &&
        !pCf->IsFrameless() &&
        pCf->GetFrame()->GetVTablePtr() == InterceptorFrame::GetMethodFrameVPtr())
    {
        DBG_TRACE_STACKWALK("        Skipping initial interceptor frame...\n", true);
        pData->bFirstFrame = FALSE;
        *pAction = SWA_CONTINUE;
        return TRUE;
    }
    pData->bFirstFrame = FALSE;

    _ASSERTE (pData && pMeth && pAction) ; // args should never be null

    // First check if the walk has skipped the required frames. The check
    // here is between the address of a local variable (the stack mark) and a
    // pointer to the EIP for a frame (which is actually the pointer to the
    // return address to the function from the previous frame). So we'll
    // actually notice which frame the stack mark was in one frame later. This
    // is fine for our purposes since we're always looking for the frame of the
    // caller (or the caller's caller) of the method that actually created the
    // stack mark.
    _ASSERTE((pData->pStackMark == NULL) || (*pData->pStackMark == LookForMyCaller) || (*pData->pStackMark == LookForMyCallersCaller));
    if ((pData->pStackMark != NULL) &&
        ((size_t)pCf->GetRegisterSet()->pPC) < (size_t)pData->pStackMark)
    {
        DBG_TRACE_STACKWALK("        Skipping before start...\n", true);

        *pAction = SWA_CONTINUE;
        return TRUE;
    }

    // Skip reflection invoke / remoting frames if we've been asked to.
    if (pData->dwFlags & CORSEC_SKIP_INTERNAL_FRAMES)
    {
        InitSecurity();

        if (pMeth == s_stdData.pMethPrivateProcessMessage)
        {
            _ASSERTE(!pData->bSkippingRemoting);
            pData->bSkippingRemoting = TRUE;
            DBG_TRACE_STACKWALK("        Skipping remoting PrivateProcessMessage frame...\n", true);
            *pAction = SWA_CONTINUE;
            return TRUE;
        }
        if (!pCf->IsFrameless() && pCf->GetFrame()->GetFrameType() == Frame::TYPE_TP_METHOD_FRAME)
        {
            _ASSERTE(pData->bSkippingRemoting);
            pData->bSkippingRemoting = FALSE;
            DBG_TRACE_STACKWALK("        Skipping remoting TP frame...\n", true);
            *pAction = SWA_CONTINUE;
            return TRUE;
        }
        if (pData->bSkippingRemoting)
        {
            DBG_TRACE_STACKWALK("        Skipping remoting frame...\n", true);
            *pAction = SWA_CONTINUE;
            return TRUE;
        }

        MethodTable *pMT = pMeth->GetMethodTable();
        if (pMT == s_stdData.pTypeRuntimeMethodInfo ||
            pMT == s_stdData.pTypeMethodBase ||
            pMT == s_stdData.pTypeRuntimeConstructorInfo ||
            pMT == s_stdData.pTypeConstructorInfo ||
            pMT == s_stdData.pTypeRuntimeType ||
            pMT == s_stdData.pTypeType ||
            pMT == s_stdData.pTypeRuntimeEventInfo ||
            pMT == s_stdData.pTypeEventInfo ||
            pMT == s_stdData.pTypeRuntimePropertyInfo ||
            pMT == s_stdData.pTypePropertyInfo ||
            pMT == s_stdData.pTypeActivator ||
            pMT == s_stdData.pTypeAppDomain ||
            pMT == s_stdData.pTypeAssembly)
        {
            DBG_TRACE_STACKWALK("        Skipping reflection invoke frame...\n", true);
            *pAction = SWA_CONTINUE;
            return TRUE;
        }
    }

    // If we're looking for the caller's caller, skip the frame after the stack
    // mark as well.
    if ((pData->pStackMark != NULL) &&
        (*pData->pStackMark == LookForMyCallersCaller) &&
        !pData->bFoundCaller)
    {
        DBG_TRACE_STACKWALK("        Skipping before start...\n", true);
        pData->bFoundCaller = TRUE;
        *pAction = SWA_CONTINUE;
        return TRUE;
    }

    // Then check if the walk has checked the maximum required frames.
    if (pData->cCheck >= 0)
    {
        if (pData->cCheck == 0)
        {
            DBG_TRACE_STACKWALK("        Halting stackwalk - check limit reached.\n", false);
            pData->dwFlags |= CORSEC_STACKWALK_HALTED;
            *pAction = SWA_ABORT;
            return TRUE;
        }
        else
        {
            --(pData->cCheck);
            // ...and fall through to perform a check...
        }
    }

    return FALSE;
}


//@nice: this should return an HRESULT so we are properly notified of errors.

// Returns TRUE if the token has declarations of the type specified by 'action'
BOOL Security::TokenHasDeclarations(IMDInternalImport *pInternalImport, mdToken token, CorDeclSecurity action)
{
    HRESULT hr = S_OK;
    HENUMInternal hEnumDcl;
    DWORD cDcl;

    // Check if the token has declarations for
    // the action specified.
    hr = pInternalImport->EnumPermissionSetsInit(
        token,
        action,
        &hEnumDcl);

    if (FAILED(hr) || hr == S_FALSE)
        return FALSE;

    cDcl = pInternalImport->EnumGetCount(&hEnumDcl);
    pInternalImport->EnumClose(&hEnumDcl);

    return (cDcl > 0);
}

// Accumulate status of declarative security.
// NOTE: This method should only be called after it has been
//       determined that the token has declarative security.
//       It will work if there is no security, but it is an
//       expensive call to make to find out.
HRESULT Security::GetDeclarationFlags(IMDInternalImport *pInternalImport, mdToken token, DWORD* pdwFlags, DWORD* pdwNullFlags)
{
    HENUMInternal   hEnumDcl;
    HRESULT         hr;
    DWORD           dwFlags = 0;
    DWORD           dwNullFlags = 0;

    _ASSERTE(pdwFlags);
    *pdwFlags = 0;

    if (pdwNullFlags)
        *pdwNullFlags = 0;

    hr = pInternalImport->EnumPermissionSetsInit(token, dclActionNil, &hEnumDcl);
    if (FAILED(hr))
        goto exit;

    if (hr == S_OK)
    {
        mdPermission    perms;
        DWORD           dwAction;
        DWORD           dwDclFlags;
        ULONG           cbPerm;
        PBYTE           pbPerm;

        while (pInternalImport->EnumNext(&hEnumDcl, &perms))
        {
           pInternalImport->GetPermissionSetProps(
                perms,
                &dwAction,
                (const void**)&pbPerm,
                &cbPerm);

            dwDclFlags = DclToFlag(dwAction);

            dwFlags |= dwDclFlags;

            if (cbPerm == 0)
                dwNullFlags |= dwDclFlags;
        }
    }

    pInternalImport->EnumClose(&hEnumDcl);

    // Disable any runtime checking of UnmanagedCode permission if the correct
    // custom attribute is present.
    if (pInternalImport->GetCustomAttributeByName(token,
                                                  COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI,
                                                  NULL,
                                                  NULL) == S_OK)
    {
        dwFlags |= DECLSEC_UNMNGD_ACCESS_DEMAND;
        dwNullFlags |= DECLSEC_UNMNGD_ACCESS_DEMAND;
    }

    *pdwFlags = dwFlags;
    if (pdwNullFlags)
        *pdwNullFlags = dwNullFlags;

exit:
    return hr;
}

BOOL Security::ClassInheritanceCheck(EEClass *pClass, EEClass *pParent, OBJECTREF *pThrowable)
{
    _ASSERTE(pClass);
    _ASSERTE(!pClass->IsInterface());
    _ASSERTE(pParent);
//    _ASSERTE(pThrowable);

    if (pClass->GetModule()->IsSystem())
        return TRUE;
/*
    if (pClass->GetAssembly() == pParent->GetAssembly())
        return TRUE;
*/
    BOOL fResult = TRUE;

    _ASSERTE(pParent->RequiresInheritanceCheck());

    {
        // If we have a class that requires inheritance checks,
        // then we require a thread to perform the checks.
        // We won't have a thread when some of the system classes
        // are preloaded, so make sure that none of them have
        // inheritance checks.
        _ASSERTE(GetThread() != NULL);

        COMPLUS_TRY
        {
            struct gc {
                OBJECTREF refCasDemands;
                OBJECTREF refNonCasDemands;
            } gc;
            ZeroMemory(&gc, sizeof(gc));

            GCPROTECT_BEGIN(gc);

            if (pParent->RequiresCasInheritanceCheck())
                gc.refCasDemands = pParent->GetModule()->GetCasInheritancePermissions(pParent->GetCl());

            if (pParent->RequiresNonCasInheritanceCheck())
                gc.refNonCasDemands = pParent->GetModule()->GetNonCasInheritancePermissions(pParent->GetCl());

            if (gc.refCasDemands != NULL)
            {
                // @nice: Currently the linktime check does exactly what
                //        we want for the inheritance check. We might want
                //        give it a more general name.
                COMCodeAccessSecurityEngine::LinktimeCheck(pClass->GetAssembly()->GetSecurityDescriptor(), gc.refCasDemands);
            }

            if (gc.refNonCasDemands != NULL)
            {
                InitSecurity();
                INT64 arg = ObjToInt64(gc.refNonCasDemands);                
                Security::s_stdData.pMethPermSetDemand->Call(&arg, METHOD__PERMISSION_SET__DEMAND);
            }

            GetAppDomain()->OnLinktimeCheck(pClass->GetAssembly(), gc.refCasDemands, gc.refNonCasDemands);

            GCPROTECT_END();
        }
        COMPLUS_CATCH
        {
            fResult = FALSE;
            UpdateThrowable(pThrowable);
        }
        COMPLUS_END_CATCH
    }

    return fResult;
}

BOOL Security::MethodInheritanceCheck(MethodDesc *pMethod, MethodDesc *pParent, OBJECTREF *pThrowable)
{
    _ASSERTE(pParent != NULL);
    _ASSERTE (pParent->RequiresInheritanceCheck());
    _ASSERTE(GetThread() != NULL);

    BOOL            fResult = TRUE;
    HRESULT         hr = S_FALSE;
    PBYTE           pbPerm = NULL;
    ULONG           cbPerm = 0;
    void const **   ppData = const_cast<void const**> (reinterpret_cast<void**> (&pbPerm));
    mdPermission    tkPerm;
    HENUMInternal   hEnumDcl;
    OBJECTREF       pGrantedPermission = NULL;
    DWORD           dwAction;
    IMDInternalImport *pInternalImport = pParent->GetModule()->GetMDImport();

    if (pMethod->GetModule()->IsSystem())
        return TRUE;
/*
    if (pMethod->GetAssembly() == pParent->GetAssembly())
        return TRUE;
*/
    // Lookup the permissions for the given declarative action type.
    hr = pInternalImport->EnumPermissionSetsInit(
        pParent->GetMemberDef(),
        dclActionNil,
        &hEnumDcl);

    if (FAILED(hr))
        return fResult;     // Nothing to check

    if (hr != S_FALSE)
    {
        while (pInternalImport->EnumNext(&hEnumDcl, &tkPerm))
        {
            pInternalImport->GetPermissionSetProps(tkPerm,
                                                   &dwAction,
                                                   ppData,
                                                   &cbPerm);

            if (!pbPerm)
                continue;

            if (dwAction == dclNonCasInheritance)
            {
                OBJECTREF refNonCasDemands = NULL;

                COMPLUS_TRY
                {
                    GCPROTECT_BEGIN(refNonCasDemands);

                    // Decode the bits from the metadata.
                    SecurityHelper::LoadPermissionSet(pbPerm,
                                                      cbPerm,
                                                      &refNonCasDemands,
                                                      NULL);

                    if (refNonCasDemands != NULL)
                    {
                        Security::InitSecurity();                    
                        INT64 arg = ObjToInt64(refNonCasDemands);
                        Security::s_stdData.pMethPermSetDemand->Call(&arg, METHOD__PERMISSION_SET__DEMAND);
                    }

                    GetAppDomain()->OnLinktimeCheck(pMethod->GetAssembly(), NULL, refNonCasDemands);

                    GCPROTECT_END();
                }
                COMPLUS_CATCH
                {
                    fResult = FALSE;
                    UpdateThrowable(pThrowable);
                }
                COMPLUS_END_CATCH
            }
            else if (dwAction == dclInheritanceCheck)  // i,e. If Cas demands..
            {
                OBJECTREF refCasDemands = NULL;
                AssemblySecurityDescriptor *pInheritorAssem = pMethod->GetModule()->GetAssembly()->GetSecurityDescriptor();
                DWORD dwSetIndex;

                if (SecurityHelper::LookupPermissionSet(pbPerm, cbPerm, &dwSetIndex))
                {
                    // See if inheritor's assembly has passed this demand before
                    DWORD index = 0;
                    for (; index < pInheritorAssem->m_dwNumPassedDemands; index++)
                    {
                        if (pInheritorAssem->m_arrPassedLinktimeDemands[index] == dwSetIndex)
                            break;
                    }

                    if (index < pInheritorAssem->m_dwNumPassedDemands)
                        continue;

                    // This is a new demand
                    refCasDemands = SecurityHelper::GetPermissionSet(dwSetIndex);
                }

                COMPLUS_TRY
                {
                    if (refCasDemands == NULL)
                        // Decode the bits from the metadata.
                        SecurityHelper::LoadPermissionSet(pbPerm,
                                                          cbPerm,
                                                          &refCasDemands,
                                                          NULL,
                                                          &dwSetIndex);

                    if (refCasDemands != NULL)
                    {
                        GCPROTECT_BEGIN(refCasDemands);

                        COMCodeAccessSecurityEngine::LinktimeCheck(pMethod->GetAssembly()->GetSecurityDescriptor(), refCasDemands);
                        // Demand passed. Add it to the Inheritor's assembly's list of passed demands
                        if (pInheritorAssem->m_dwNumPassedDemands <= (MAX_PASSED_DEMANDS - 1))
                            pInheritorAssem->m_arrPassedLinktimeDemands[pInheritorAssem->m_dwNumPassedDemands++] = dwSetIndex;
                        GetAppDomain()->OnLinktimeCheck(pMethod->GetAssembly(), refCasDemands, NULL);

                        GCPROTECT_END();
                    }
                }
                COMPLUS_CATCH
                {
                    fResult = FALSE;
                    UpdateThrowable(pThrowable);
                }
                COMPLUS_END_CATCH

            }   // Cas or NonCas
        }   // While there are more permission sets
    }   // If Metadata init was ok
    return fResult;
}

void Security::InvokeLinktimeChecks(Assembly *pCaller,
                                    Module *pModule,
                                    mdToken token,
                                    BOOL *pfResult,
                                    OBJECTREF *pThrowable)
{
    _ASSERTE( pCaller );
    _ASSERTE( pModule );

    COMPLUS_TRY
    {
        struct gc {
            OBJECTREF refNonCasDemands;
            OBJECTREF refCasDemands;
        } gc;
        ZeroMemory(&gc, sizeof(gc));

        GCPROTECT_BEGIN(gc);

        gc.refCasDemands = pModule->GetLinktimePermissions(token, &gc.refNonCasDemands);

        if (gc.refCasDemands != NULL)
        {
            COMCodeAccessSecurityEngine::LinktimeCheck(pCaller->GetSecurityDescriptor(), gc.refCasDemands);
        }

        if (gc.refNonCasDemands != NULL)
        {
            // Make sure s_stdData is initialized
            Security::InitSecurity();

            INT64 arg = ObjToInt64(gc.refNonCasDemands);
            Security::s_stdData.pMethPermSetDemand->Call(&arg, METHOD__PERMISSION_SET__DEMAND);
        }

        GetAppDomain()->OnLinktimeCheck(pCaller, gc.refCasDemands, gc.refNonCasDemands);

        GCPROTECT_END();

    }
    COMPLUS_CATCH
    {
        *pfResult = FALSE;
        UpdateThrowable(pThrowable);
    }
    COMPLUS_END_CATCH
}

/*static*/
void Security::ThrowSecurityException(AssemblySecurityDescriptor* pSecDesc)
{
    THROWSCOMPLUSEXCEPTION();

    MethodDesc * pCtor = NULL;
        
    static MethodTable * pMT = g_Mscorlib.GetClass(CLASS__SECURITY_EXCEPTION);
    _ASSERTE(pMT && "Unable to load the throwable class !");

    struct _gc {
        OBJECTREF throwable;
        OBJECTREF grantSet;
        OBJECTREF deniedSet;
    } gc;
    memset(&gc, 0, sizeof(gc));

    GCPROTECT_BEGIN(gc);

    // Allocate the security exception object
    gc.throwable = AllocateObject(pMT);
    if (gc.throwable == NULL) COMPlusThrowOM();

    gc.grantSet = pSecDesc->GetGrantedPermissionSet( &gc.deniedSet );

    pCtor = g_Mscorlib.GetMethod(METHOD__SECURITY_EXCEPTION__CTOR2);
    INT64 arg6[4] = {
        ObjToInt64(gc.throwable),
        ObjToInt64(gc.deniedSet),
        ObjToInt64(gc.grantSet),
    };
    pCtor->Call(arg6, METHOD__SECURITY_EXCEPTION__CTOR2);
        
    COMPlusThrow(gc.throwable);
        
    _ASSERTE(!"Should never reach here !");
    GCPROTECT_END();
}


/*static*/
// Do a fulltrust check on the caller if the callee is fully trusted and
// callee did not enable AllowUntrustedCallerChecks
BOOL Security::DoUntrustedCallerChecks(
        Assembly *pCaller, MethodDesc *pCallee, OBJECTREF *pThrowable, 
        BOOL fFullStackWalk)
{
    THROWSCOMPLUSEXCEPTION();
    BOOL fRet = TRUE;

#ifdef _DEBUG
    if (!g_pConfig->Do_AllowUntrustedCaller_Checks())
        return TRUE;
#endif

    if (!MethodIsVisibleOutsideItsAssembly(pCallee->GetAttrs()) ||
        !ClassIsVisibleOutsideItsAssembly(pCallee->GetClass()->GetAttrClass())||
        pCallee->GetAssembly()->AllowUntrustedCaller() ||
        (pCaller == pCallee->GetAssembly()))
        return TRUE;

    // Expensive calls after this point, this could end up resolving policy

    if (fFullStackWalk)
    {
        // It is possible that wrappers like VBHelper libraries that are
        // fully trusted, make calls to public methods that do not have
        // safe for Untrusted caller custom attribute set.
        // Like all other link demand that gets transformed to a full stack 
        // walk for reflection, calls to public methods also gets 
        // converted to full stack walk

        OBJECTREF permSet = NULL;
        GCPROTECT_BEGIN(permSet);

        GetPermissionInstance(&permSet, SECURITY_FULL_TRUST);

        COMPLUS_TRY
        {
            DEBUG_SAFE_TO_THROW_IN_THIS_BLOCK;
            COMCodeAccessSecurityEngine::DemandSet(permSet);
            
        }
        COMPLUS_CATCH
        {
            fRet = FALSE;
            if (pThrowable != RETURN_ON_ERROR)
                UpdateThrowable(pThrowable);
        }        
        COMPLUS_END_CATCH

        GCPROTECT_END();
    }
    else
    {
        _ASSERTE(pCaller);

        // Link Demand only, no full stack walk here
        if (!pCaller->GetSecurityDescriptor()->IsFullyTrusted())
        {
            fRet = FALSE;
            
            // Construct the exception object
            if (pThrowable != RETURN_ON_ERROR)
            {
                COMPLUS_TRY
                {
                    DEBUG_SAFE_TO_THROW_IN_THIS_BLOCK;
                    ThrowSecurityException( pCaller->GetSecurityDescriptor() );
                }
                COMPLUS_CATCH
                {
                    UpdateThrowable(pThrowable);
                }        
                COMPLUS_END_CATCH
            }
        }
        else
        {
            // Add fulltrust permission Set to the prejit case.
            GetAppDomain()->OnLinktimeFullTrustCheck(pCaller);
        }
    }

    return fRet;
}

//---------------------------------------------------------
// Invoke linktime checks on the caller if demands exist
// for the callee.
//
// TRUE  = check pass
// FALSE = check failed
//---------------------------------------------------------
/*static*/
BOOL Security::LinktimeCheckMethod(Assembly *pCaller, MethodDesc *pCallee, OBJECTREF *pThrowable)
{
/*
    if (pCaller == pCallee->GetAssembly())
        return TRUE;
*/

    // Do a fulltrust check on the caller if the callee is fully trusted and
    // callee did not enable AllowUntrustedCallerChecks
    if (!Security::DoUntrustedCallerChecks(pCaller, pCallee, pThrowable, FALSE))
        return FALSE;

    if (pCaller->GetSecurityDescriptor()->IsSystemClasses())
        return TRUE;

    // Disable linktime checks from mscorlib to mscorlib (non-virtual methods
    // only). This prevents nasty recursions when the managed code used to
    // implement the check requires a security check itself.
    if (!pCaller->GetSecurityDescriptor()->IsSystemClasses() ||
        !pCallee->GetAssembly()->GetSecurityDescriptor()->IsSystemClasses() ||
        pCallee->IsVirtual())
    {
        BOOL        fResult = TRUE;
        EEClass    *pTargetClass = pCallee->GetClass();

        // Track perfmon counters. Linktime security checkes.
        COUNTER_ONLY(GetPrivatePerfCounters().m_Security.cLinkChecks++);
        COUNTER_ONLY(GetGlobalPerfCounters().m_Security.cLinkChecks++);

        // If the class has its own linktime checks, do them first...
        if (pTargetClass->RequiresLinktimeCheck())
        {
            InvokeLinktimeChecks(pCaller,
                                 pTargetClass->GetModule(),
                                 pTargetClass->GetCl(),
                                 &fResult,
                                 pThrowable);
        }

        // If the previous check passed, check the method for
        // method-specific linktime checks...
        if (fResult && IsMdHasSecurity(pCallee->GetAttrs()) &&
            (TokenHasDeclarations(pTargetClass->GetMDImport(),
                                  pCallee->GetMemberDef(),
                                  dclLinktimeCheck) ||
             TokenHasDeclarations(pTargetClass->GetMDImport(),
                                  pCallee->GetMemberDef(),
                                  dclNonCasLinkDemand)))
        {
            InvokeLinktimeChecks(pCaller,
                                 pTargetClass->GetModule(),
                                 pCallee->GetMemberDef(),
                                 &fResult,
                                 pThrowable);
        }

        // We perform automatic linktime checks for UnmanagedCode in three cases:
        //   o  P/Invoke calls
        //   o  Calls through an interface that have a suppress runtime check
        //      attribute on them (these are almost certainly interop calls).
        //   o  Interop calls made through method impls.
        if (pCallee->IsNDirect() ||
            (pTargetClass->IsInterface() &&
             pTargetClass->GetMDImport()->GetCustomAttributeByName(pTargetClass->GetCl(),
                                                                   COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI,
                                                                   NULL,
                                                                   NULL) == S_OK) ||
            (pCallee->IsComPlusCall() && !pCallee->IsInterface()))
        {
            if (pCaller->GetSecurityDescriptor()->CanCallUnmanagedCode(pThrowable))
            {
                GetAppDomain()->OnLinktimeCanCallUnmanagedCheck(pCaller);
            }
            else
                fResult = FALSE;
        }

        return fResult;
    }

    return TRUE;
}


//@perf: (M6) This method is called every time a thread is created.
//       This call is potentially very expensive because of the computations
//       involved in compressing some permissions. One way to speed up the
//       creation of threads is to delay the computation of the compressed
//       stack until it is needed. A stack trace is still required at this
//       point to capture the state of the stack for later use, but in the
//       initial trace, we could just save pointers to modules and per-frame
//       security objects in a linked list. When the real information is
//       needed for a check, the compression algorithm will walk the linked
//       list to construct the compressed stack required for the check.
OBJECTREF Security::GetCompressedStack(StackCrawlMark* stackMark)
{
    //@perf: move this check outside of this method, e.g. verifier.cpp
    //       Or better yet, don't call it at all if we can avoid it.
    // Set up security before using its cached pointers.
    InitSecurity();

    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    _ASSERTE(s_stdData.pMethGetCodeAccessEngine != NULL);

    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__SECURITY_ENGINE__GET_COMPRESSED_STACK);

    INT64 args[2];

    //@perf: we don't want to check this every time.
    //  Keep an object handle or something.
    //  Only trouble is destroying when done.
    //  Perhaps put tear-down stuff in CEEUninitialize code.
    OBJECTREF refCodeAccessSecurityEngine =
        Int64ToObj(s_stdData.pMethGetCodeAccessEngine->Call((INT64*)NULL, METHOD__SECURITY_MANAGER__GET_SECURITY_ENGINE));

    if (refCodeAccessSecurityEngine == NULL)
        return NULL;

    args[0] = ObjToInt64(refCodeAccessSecurityEngine);
    args[1] = (INT64)stackMark;

    INT64 ret = pMD->Call(args, METHOD__SECURITY_ENGINE__GET_COMPRESSED_STACK);

    return Int64ToObj(ret);
}

CompressedStack* Security::GetDelayedCompressedStack(void)
{
    return COMCodeAccessSecurityEngine::GetCompressedStack();
}


typedef struct _SkipFunctionsData
{
    INT32           cSkipFunctions;
    StackCrawlMark* pStackMark;
    BOOL            bUseStackMark;
    BOOL            bFoundCaller;
    MethodDesc*     pFunction;
    OBJECTREF*      pSecurityObject;
    AppDomain*      pSecurityObjectAppDomain;
} SkipFunctionsData;

static
StackWalkAction SkipFunctionsCB(CrawlFrame* pCf, VOID* pData)
{
    SkipFunctionsData *skipData = (SkipFunctionsData*)pData;
    _ASSERTE(skipData != NULL);

    MethodDesc *pFunc = pCf->GetFunction();
#ifdef _DEBUG
    // Get the interesting info now, so we can get a trace
    // while debugging...
    OBJECTREF  *pSecObj = pCf->GetAddrOfSecurityObject();
#endif

    if (skipData->bUseStackMark)
    {
        // First check if the walk has skipped the required frames. The check
        // here is between the address of a local variable (the stack mark) and a
        // pointer to the EIP for a frame (which is actually the pointer to the
        // return address to the function from the previous frame). So we'll
        // actually notice which frame the stack mark was in one frame later. This
        // is fine for our purposes since we're always looking for the frame of the
        // caller of the method that actually created the stack mark. 
        if ((skipData->pStackMark != NULL) &&
            ((size_t)pCf->GetRegisterSet()->pPC) < (size_t)skipData->pStackMark)
            return SWA_CONTINUE;
    }
    else
    {
        if (skipData->cSkipFunctions-- > 0)
            return SWA_CONTINUE;
    }

    skipData->pFunction                 = pFunc;
    skipData->pSecurityObject           = pCf->GetAddrOfSecurityObject();
    skipData->pSecurityObjectAppDomain  = pCf->GetAppDomain();
    return SWA_ABORT; // This actually indicates success.
}

// This function skips extra frames created by reflection in addition
// to the number of frames specified in the argument.
BOOL Security::SkipAndFindFunctionInfo(INT32 cSkipFns, MethodDesc ** ppFunc, OBJECTREF ** ppObj, AppDomain ** ppAppDomain)
{
    _ASSERTE(cSkipFns >= 0);
    _ASSERTE(ppFunc != NULL || ppObj != NULL || !"Why was this function called?!");

    SkipFunctionsData walkData;
    walkData.cSkipFunctions = cSkipFns;
    walkData.bUseStackMark = FALSE;
    walkData.pFunction = NULL;
    walkData.pSecurityObject = NULL;
    StackWalkAction action = StackWalkFunctions(GetThread(), SkipFunctionsCB, &walkData);
    if (action == SWA_ABORT)
    {
        if (ppFunc != NULL)
            *ppFunc = walkData.pFunction;
        if (ppObj != NULL)
        {
            *ppObj = walkData.pSecurityObject;
            if (ppAppDomain != NULL)
                *ppAppDomain = walkData.pSecurityObjectAppDomain;
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

// Version of the above method that looks for a stack mark (the address of a
// local variable in a frame called by the target frame).
BOOL Security::SkipAndFindFunctionInfo(StackCrawlMark* stackMark, MethodDesc ** ppFunc, OBJECTREF ** ppObj, AppDomain ** ppAppDomain)
{
    _ASSERTE(ppFunc != NULL || ppObj != NULL || !"Why was this function called?!");

    SkipFunctionsData walkData;
    walkData.pStackMark = stackMark;
    walkData.bUseStackMark = TRUE;
    walkData.bFoundCaller = FALSE;
    walkData.pFunction = NULL;
    walkData.pSecurityObject = NULL;
    StackWalkAction action = StackWalkFunctions(GetThread(), SkipFunctionsCB, &walkData);
    if (action == SWA_ABORT)
    {
        if (ppFunc != NULL)
            *ppFunc = walkData.pFunction;
        if (ppObj != NULL)
        {
            *ppObj = walkData.pSecurityObject;
            if (ppAppDomain != NULL)
                *ppAppDomain = walkData.pSecurityObjectAppDomain;
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

Stub* Security::CreateStub(StubLinker *pstublinker,
                           MethodDesc* pMD,
                           DWORD dwDeclFlags,
                           Stub* pRealStub,
                           LPVOID pRealAddr)
{
#ifdef _SH3_
    DebugBreak(); // NYI
    return NULL;
#else
    DeclActionInfo *actionsNeeded = DetectDeclActions(pMD, dwDeclFlags);
    if (actionsNeeded == NULL)
        return pRealStub;       // Nothing to do

    // Wrapper needs to know if the stub is intercepted interpreted or jitted.  pRealStub
    // is null when it is jitted.
    BOOL fToStub = pRealStub != NULL;
    CPUSTUBLINKER *psl = (CPUSTUBLINKER*)pstublinker;
    if(dwDeclFlags & DECLSEC_FRAME_ACTIONS)
        psl->EmitSecurityWrapperStub(pMD->SizeOfActualFixedArgStack(), pMD, fToStub, pRealAddr, actionsNeeded);
    else
        psl->EmitSecurityInterceptorStub(pMD, fToStub, pRealAddr, actionsNeeded);

    Stub* result = psl->LinkInterceptor(pMD->GetClass()->GetDomain()->GetStubHeap(),
                                           pRealStub, pRealAddr);
    return result;
#endif
}

DeclActionInfo *DeclActionInfo::Init(MethodDesc *pMD, DWORD dwAction, DWORD dwSetIndex)
{
    DeclActionInfo *pTemp;
    WS_PERF_SET_HEAP(LOW_FREQ_HEAP);    
    pTemp = (DeclActionInfo *)pMD->GetClass()->GetClassLoader()->GetLowFrequencyHeap()->AllocMem(sizeof(DeclActionInfo));

    if (pTemp == NULL)
        return NULL;

    WS_PERF_UPDATE_DETAIL("DeclActionInfo low freq", sizeof(DeclActionInfo), pTemp);

    pTemp->dwDeclAction = dwAction;
    pTemp->dwSetIndex = dwSetIndex;
    pTemp->pNext = NULL;

    return pTemp;
}

// Here we see what declarative actions are needed everytime a method is called,
// and create a list of these actions, which will be emitted as an argument to 
// DoDeclarativeSecurity
DeclActionInfo *Security::DetectDeclActions(MethodDesc *pMeth, DWORD dwDeclFlags)
{
    DeclActionInfo              *pDeclActions = NULL;

    EEClass *pCl = pMeth -> GetClass () ;
    _ASSERTE(pCl && "Should be a EEClass pointer here") ;

    PSecurityProperties psp = pCl -> GetSecurityProperties () ;
    _ASSERTE(psp && "Should be a PSecurityProperties here") ;

    Module *pModule = pMeth -> GetModule () ;
    _ASSERTE(pModule && "Should be a Module pointer here") ;

    AssemblySecurityDescriptor *pMSD = pModule -> GetSecurityDescriptor () ;
    _ASSERTE(pMSD && "Should be a security descriptor here") ;

    IMDInternalImport          *pInternalImport = pModule->GetMDImport();

    // Lets check the Ndirect/Interop cases first
    if (dwDeclFlags & DECLSEC_UNMNGD_ACCESS_DEMAND)
    {
        HRESULT hr = pInternalImport->GetCustomAttributeByName(pMeth->GetMemberDef(),
                                                               COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI,
                                                               NULL,
                                                               NULL);
        _ASSERTE(SUCCEEDED(hr));
        if (hr == S_OK)
            dwDeclFlags &= ~DECLSEC_UNMNGD_ACCESS_DEMAND;
        else
        {
            if (pMeth->GetClass())
            {
                hr = pInternalImport->GetCustomAttributeByName(pMeth->GetClass()->GetCl(),
                                                               COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI,
                                                               NULL,
                                                               NULL);
                _ASSERTE(SUCCEEDED(hr));
                if (hr == S_OK)
                    dwDeclFlags &= ~DECLSEC_UNMNGD_ACCESS_DEMAND;
            }
        }
        // Check if now there are no actions left
        if (dwDeclFlags == 0)
            return NULL;

        if (dwDeclFlags & DECLSEC_UNMNGD_ACCESS_DEMAND)
        {
            // A NDirect/Interop demand is required. 
            DeclActionInfo *temp = DeclActionInfo::Init(pMeth, DECLSEC_UNMNGD_ACCESS_DEMAND, NULL);
            if (!pDeclActions)
                pDeclActions = temp;
            else
            {
                temp->pNext = pDeclActions;
                pDeclActions = temp;
            }
        }
    } // if DECLSEC_UNMNGD_ACCESS_DEMAND

    // Look for the other actions
    mdToken         tk;
    PBYTE           pbPerm = NULL;
    ULONG           cbPerm = 0;
    void const **   ppData = const_cast<void const**> (reinterpret_cast<void**> (&pbPerm));
    mdPermission    tkPerm;
    DWORD           dwAction;
    HENUMInternal   hEnumDcl;
    OBJECTREF       refPermSet = NULL;
    int             loops = 2;
    DWORD           dwSetIndex;

    while (loops-- > 0)
    {
        if (loops == 1)
            tk = pMeth->GetMemberDef();
        else
            tk = pCl->GetCl();

        HRESULT hr = pInternalImport->EnumPermissionSetsInit(tk,
                                                     dclActionNil, // look up all actions
                                                     &hEnumDcl);

        if (hr != S_OK) // EnumInit returns S_FALSE if it didn't find any records.
        {
            continue;
        }

        while (pInternalImport->EnumNext(&hEnumDcl, &tkPerm))
        {
            pInternalImport->GetPermissionSetProps(tkPerm,
                                                   &dwAction,
                                                   ppData,
                                                   &cbPerm);

            // Only perform each action once.
            // Note that this includes "null" actions, where
            // the permission data is empty. This offers a
            // way to omit a global check.
            DWORD dwActionFlag = DclToFlag(dwAction);
            if (dwDeclFlags & dwActionFlag)
                dwDeclFlags &= ~dwActionFlag;
            else
                continue;

            // If there's nothing on which to perform an action,
            // skip it!
            if (! (cbPerm > 0 && pbPerm != NULL))
                continue;

            // Decode the permissionset and add this action to the linked list
            SecurityHelper::LoadPermissionSet(pbPerm,
                                              cbPerm,
                                              &refPermSet,
                                              NULL,
                                              &dwSetIndex);

            DeclActionInfo *temp = DeclActionInfo::Init(pMeth, dwActionFlag, dwSetIndex);
            if (!pDeclActions)
                pDeclActions = temp;
            else
            {
                temp->pNext = pDeclActions;
                pDeclActions = temp;
            }
        } // permission enum loop

        pInternalImport->EnumClose(&hEnumDcl);

    } // Method and class enum loop

    return pDeclActions;
}

extern LPVOID GetSecurityObjectForFrameInternal(StackCrawlMark *stackMark, INT32 create, OBJECTREF *pRefSecDesc);

inline void UpdateFrameSecurityObj(DWORD dwAction, OBJECTREF *refPermSet, OBJECTREF * pSecObj)
{
    FieldDesc *actionFld;   // depends on assert, deny, permitonly etc

    GetSecurityObjectForFrameInternal(NULL, true, pSecObj);
    actionFld = COMSecurityRuntime::GetFrameSecDescField(dwAction);

    _ASSERTE(actionFld && "Could not find a field inside FrameSecurityDescriptor. Renamed ?");
    actionFld->SetRefValue(*pSecObj, *refPermSet);
}

void InvokeDeclarativeActions (MethodDesc *pMeth, DeclActionInfo *pActions, OBJECTREF * pSecObj)
{
    OBJECTREF       refPermSet = NULL;
    INT64           arg = 0;

    refPermSet = SecurityHelper::GetPermissionSet(pActions->dwSetIndex);
    _ASSERTE(refPermSet != NULL);

    // If we get a real PermissionSet, then invoke the action.
    if (refPermSet != NULL)
    {
        switch (pActions->dwDeclAction)
        {
        case DECLSEC_DEMANDS:
            COMCodeAccessSecurityEngine::DemandSet(refPermSet);
            break;
    
        case DECLSEC_ASSERTIONS:
            {
                EEClass    * pCl   = pMeth -> GetClass () ;
                Module * pModule = pMeth -> GetModule () ;
                AssemblySecurityDescriptor * pMSD = pModule -> GetSecurityDescriptor () ;

                GCPROTECT_BEGIN(refPermSet);
                // Check if this Assembly has permission to assert
                if (!pMSD->AssertPermissionChecked())
                {
                    if (!pMSD->IsFullyTrusted() && !pMSD->CheckSecurityPermission(SECURITY_ASSERT))
                        Security::ThrowSecurityException(g_SecurityPermissionClassName, SPFLAGSASSERTION);

                    pMSD->SetCanAssert();

                    pMSD->SetAssertPermissionChecked();
                }

                if (!pMSD->CanAssert())
                    Security::ThrowSecurityException(g_SecurityPermissionClassName, SPFLAGSASSERTION);

                // Now update the frame security object
                UpdateFrameSecurityObj(dclAssert, &refPermSet, pSecObj);
                GCPROTECT_END();
                break;
            }
    
        case DECLSEC_DENIALS:
            // Update the frame security object
            GCPROTECT_BEGIN(refPermSet);
            UpdateFrameSecurityObj(dclDeny, &refPermSet, pSecObj);
            Security::IncrementOverridesCount();
            GCPROTECT_END();
            break;
    
        case DECLSEC_PERMITONLY:
            // Update the frame security object
            GCPROTECT_BEGIN(refPermSet);
            UpdateFrameSecurityObj(dclPermitOnly, &refPermSet, pSecObj);
            Security::IncrementOverridesCount();
            GCPROTECT_END();
            break;

        case DECLSEC_NONCAS_DEMANDS:
            GCPROTECT_BEGIN(refPermSet);
            Security::InitSecurity();
            GCPROTECT_END();
            arg = ObjToInt64(refPermSet);
            Security::s_stdData.pMethPermSetDemand->Call(&arg, METHOD__PERMISSION_SET__DEMAND);
            break;

        default:
            _ASSERTE(!"Unknown action requested in InvokeDeclarativeActions");
            break;

        } // switch
    } // if refPermSet != null
}

void Security::DoDeclarativeActions(MethodDesc *pMeth, DeclActionInfo *pActions, LPVOID pSecObj)
{
    THROWSCOMPLUSEXCEPTION();

    // --------------------------------------------------------------------------- //
    //          D E C L A R A T I V E   S E C U R I T Y   D E M A N D S            //
    // --------------------------------------------------------------------------- //
    // The frame is now fully formed, arguments have been copied into place,
    // and synchronization monitors have been entered if necessary.  At this
    // point, we are prepared for something to throw an exception, so we may
    // check for declarative security demands and execute them.  We need a
    // well-formed frame and synchronization domain to accept security excep-
    // tions thrown by the SecurityManager.  We MAY need argument values in
    // the frame so that the arguments may be finalized if security throws an
    // exception across them (unknown).  [brianbec]

    if (pActions->dwDeclAction == DECLSEC_UNMNGD_ACCESS_DEMAND && 
        pActions->pNext == NULL)
    {
        /* We special-case the security check on single pinvoke/interop calls
           so we can avoid setting up the GCFrame */

        COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_UNMANAGED_CODE);
        return;
    }
    else
    {
        OBJECTREF secObj = NULL;
        GCPROTECT_BEGIN(secObj);

        for (/**/; pActions; pActions = pActions->pNext)
        {
            if (pActions->dwDeclAction == DECLSEC_UNMNGD_ACCESS_DEMAND)
            {
                COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_UNMANAGED_CODE);
            }
            else
            {
                InvokeDeclarativeActions(pMeth, pActions, &secObj);
            }
        }

        // Required for InterceptorFrame::GetInterception() to work correctly
        _ASSERTE(*((Object**) pSecObj) == NULL);

        *((Object**) pSecObj) = OBJECTREFToObject(secObj);

        GCPROTECT_END();
    }
}

// This functions is logically part of the security stub
VOID DoDeclarativeSecurity(MethodDesc *pMeth, DeclActionInfo *pActions, InterceptorFrame* frame)
{
    THROWSCOMPLUSEXCEPTION();

    LPVOID pSecObj = frame->GetAddrOfSecurityDesc();
    *((Object**) pSecObj) = NULL;
    Security::DoDeclarativeActions(pMeth, pActions, pSecObj);
}

OBJECTREF Security::ResolvePolicy(OBJECTREF evidence, OBJECTREF reqdPset, OBJECTREF optPset,
                                  OBJECTREF denyPset, OBJECTREF* grantdenied, int* grantIsUnrestricted, BOOL checkExecutionPermission)
{
    // If we got here, then we are going to do at least one security
    // check. Make sure security is initialized.

    struct _gc {
        OBJECTREF reqdPset;         // Required Requested Permissions
        OBJECTREF optPset;          // Optional Requested Permissions
        OBJECTREF denyPset;         // Denied Permissions
        OBJECTREF evidence;         // Object containing evidence
    } gc;
    ZeroMemory(&gc, sizeof(gc));
    gc.evidence = evidence;
    gc.reqdPset = reqdPset;
    gc.denyPset = denyPset;
    gc.optPset = optPset;

    GCPROTECT_BEGIN(gc);
    InitSecurity();
    GCPROTECT_END();

    INT64 args[7];
    args[0] = (INT64) checkExecutionPermission;
    args[1] = (INT64) grantIsUnrestricted;
    args[2] = (INT64) grantdenied;
    args[3] = ObjToInt64(gc.denyPset);
    args[4] = ObjToInt64(gc.optPset);
    args[5] = ObjToInt64(gc.reqdPset);
    args[6] = ObjToInt64(gc.evidence);

    return Int64ToObj(s_stdData.pMethResolvePolicy->Call(args, METHOD__SECURITY_MANAGER__RESOLVE_POLICY));
}

static BOOL IsCUIApp( PEFile* pFile )
{
    if (pFile == NULL)
        return FALSE;

    IMAGE_NT_HEADERS *pNTHeader = pFile->GetNTHeader();

    if (pNTHeader == NULL)
        return FALSE;

    // Sanity check we have a real header and didn't mess up this parsing.
    _ASSERTE((pNTHeader->Signature == IMAGE_NT_SIGNATURE) &&
        (pNTHeader->FileHeader.SizeOfOptionalHeader == IMAGE_SIZEOF_NT_OPTIONAL_HEADER) &&
        (pNTHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC));
    
    return (pNTHeader->OptionalHeader.Subsystem & (IMAGE_SUBSYSTEM_WINDOWS_CUI | IMAGE_SUBSYSTEM_OS2_CUI | IMAGE_SUBSYSTEM_POSIX_CUI));
}


// Call this version of resolve against an assembly that's not yet fully loaded.
// It copes with exceptions due to minimal permission request grant or decodes
// failing and does the necessary magic to stop the debugger single stepping the
// managed code that gets invoked.
HRESULT Security::EarlyResolve(Assembly *pAssembly, AssemblySecurityDescriptor *pSecDesc, OBJECTREF *pThrowable)
{
    static COMSecurityConfig::QuickCacheEntryType executionTable[] =
        { COMSecurityConfig::QuickCacheEntryType::ExecutionZoneMyComputer,
          COMSecurityConfig::QuickCacheEntryType::ExecutionZoneIntranet,
          COMSecurityConfig::QuickCacheEntryType::ExecutionZoneInternet,
          COMSecurityConfig::QuickCacheEntryType::ExecutionZoneTrusted,
          COMSecurityConfig::QuickCacheEntryType::ExecutionZoneUntrusted };

    static COMSecurityConfig::QuickCacheEntryType skipVerificationTable[] =
        { COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneMyComputer,
          COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneIntranet,
          COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneInternet,
          COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneTrusted,
          COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneUntrusted };

    BOOL    fExecutionCheckEnabled = Security::IsExecutionPermissionCheckEnabled();
    BOOL    fRequest = SecurityHelper::PermissionsRequestedInAssembly(pAssembly);
    HRESULT hr = S_OK;
        
    if (fExecutionCheckEnabled || fRequest)
    {
        BEGIN_ENSURE_COOPERATIVE_GC();

        COMPLUS_TRY {
            DebuggerClassInitMarkFrame __dcimf;
                    
            if (fRequest)
            {
                // If we make a required request for skip verification
                // and nothing else, detect that and use the QuickCache

                PermissionRequestSpecialFlags specialFlags;
                OBJECTREF required, optional, refused;

                required = pSecDesc->GetRequestedPermissionSet( &optional, &refused, &specialFlags, FALSE );

                if (specialFlags.required == SkipVerification &&
                    (specialFlags.refused == NoSet || specialFlags.refused == EmptySet))
                {
                    if (!pSecDesc->CheckQuickCache( COMSecurityConfig::QuickCacheEntryType::SkipVerificationAll, skipVerificationTable, CORSEC_SKIP_VERIFICATION ))
                    {
                        pSecDesc->Resolve();
                    }
                    else
                    {
                        // We have skip verification rights so now check
                        // for execution rights as needed.
                
                        if (fExecutionCheckEnabled)
                        {
                            if (!pSecDesc->CheckQuickCache( COMSecurityConfig::QuickCacheEntryType::ExecutionAll, executionTable ))
                                pSecDesc->Resolve();
                        }
                    }
                }
              else
                {
                    pSecDesc->Resolve();
                }
            }
            else if (fExecutionCheckEnabled)
            {
                if (!pSecDesc->CheckQuickCache( COMSecurityConfig::QuickCacheEntryType::ExecutionAll, executionTable ))
                    pSecDesc->Resolve();
            }
            else
            {
                pSecDesc->Resolve();
            }

            __dcimf.Pop();
        } COMPLUS_CATCH {
            OBJECTREF orThrowable = NULL;
            GCPROTECT_BEGIN( orThrowable );
            orThrowable = GETTHROWABLE();
            hr = SecurityHelper::MapToHR(orThrowable);

            if (pThrowableAvailable(pThrowable)) {
                *pThrowable = orThrowable;
            } else {
                PEFile *pManifestFile = pAssembly->GetManifestFile();
                if (((pManifestFile != NULL) &&
                     IsNilToken(pManifestFile->GetCORHeader()->EntryPointToken)) ||
                    SystemDomain::System()->DefaultDomain() != GetAppDomain()) {
#ifdef _DEBUG
                    DefineFullyQualifiedNameForClassOnStack();
                    LPUTF8 szClass = GetFullyQualifiedNameForClassNestedAware(orThrowable->GetClass());
                    if (strcmp(g_SerializationExceptionName, szClass) == 0)
                        printf("***** Error: failure in decode of permission requests\n" );
                    else
                        printf("***** Error: failed to grant minimum permissions\n");
#endif
                    DEBUG_SAFE_TO_THROW_IN_THIS_BLOCK;
                    COMPlusThrow(orThrowable);
                } else {
                    // Print out the exception message ourselves.
                    WCHAR   wszBuffer[256];
                    WCHAR  *wszMessage = wszBuffer;

                    COMPLUS_TRY
                    {
                        ULONG       ulLength = GetExceptionMessage(orThrowable, wszBuffer, 256);
                        if (ulLength >= 256)
                        {
                            wszMessage = (WCHAR*)_alloca((ulLength + 1) * sizeof(WCHAR));
                            GetExceptionMessage(orThrowable, wszMessage, ulLength + 1);
                        }
                    }
                    COMPLUS_CATCH
                    {
                        wszMessage = wszBuffer;
                        wcscpy(wszMessage, L"<could not generate exception message>");
                    }
                    COMPLUS_END_CATCH

                    if (pManifestFile != NULL && IsCUIApp( pManifestFile ))
                        printf("%S\n", wszMessage);
                    else
                        WszMessageBoxInternal( NULL, wszMessage, NULL, MB_OK | MB_ICONERROR );
                }
            }
            GCPROTECT_END();
        } COMPLUS_END_CATCH
       
        END_ENSURE_COOPERATIVE_GC();
    }

    return hr;
}

LPVOID __stdcall Security::GetSecurityId(_GetSecurityId *args)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(args);
    _ASSERTE(args->url);

    if (args->url->GetStringLength() <= 0)
        return NULL;

#define URL_SIZE 7

    static WCHAR *s_url = L"http://";
    static WCHAR *s_end = L"/";

    HRESULT hr = S_OK;
    LPWSTR  pURL = new WCHAR[URL_SIZE + args->url->GetStringLength() + 2];

    if (pURL == NULL)
        COMPlusThrowOM();

    memcpy(pURL, s_url, URL_SIZE * sizeof(WCHAR));

    memcpy(pURL + 7, args->url->GetBuffer(),
        args->url->GetStringLength() * sizeof(WCHAR));

    pURL[URL_SIZE + args->url->GetStringLength()] = s_end[0];
    pURL[URL_SIZE + args->url->GetStringLength() + 1] = 0;

    // Should we cache this ?
    IInternetSecurityManager *pSecurityManager = NULL;
    BYTE uniqueID[MAX_SIZE_SECURITY_ID];
    DWORD dwSize = MAX_SIZE_SECURITY_ID;
    OBJECTREF obj = NULL;
    LPVOID pRet  = NULL;

    Thread* pThread = GetThread();
    BOOL fWasGCDisabled = pThread->PreemptiveGCDisabled();

    if (fWasGCDisabled)
        pThread->EnablePreemptiveGC();

    hr = CoInternetCreateSecurityManager(NULL, &pSecurityManager, 0);

    if (fWasGCDisabled)
        pThread->DisablePreemptiveGC();

    if (FAILED(hr) || (pSecurityManager == NULL))
        goto Exit;

    hr = pSecurityManager->GetSecurityId(pURL, uniqueID, &dwSize, 0);


    if (FAILED(hr))
        goto Exit;

    GCPROTECT_BEGIN(obj);

    SecurityHelper::CopyEncodingToByteArray(uniqueID, dwSize, &obj);

    *((OBJECTREF *)&pRet) = obj;

    GCPROTECT_END();

Exit:

    delete [] pURL;

    if (pSecurityManager != NULL) {
        pSecurityManager->Release();
    }

    return pRet;
}

VOID __stdcall Security::Log(_Log *args)
{
    if (args->msg == NULL || args->msg->GetStringLength() <= 0)
        return;

    WCHAR *p = args->msg->GetBuffer();
    int length = args->msg->GetStringLength();
    CHAR *str = new (nothrow) CHAR[length + 1];
    
    if (str == NULL)
        return;

    for (int i=0; i<length; ++i)    // Wchar -> Char
        str[i] = (CHAR) p[i];       // This is only for debug.

    str[length] = 0;

    LOG((LF_SECURITY, LL_INFO10, str));

    delete [] str;
}

BOOL Security::_CanSkipVerification(Assembly * pAssembly, BOOL fLazy)
{
    _ASSERTE(pAssembly != NULL);

    BOOL canSkipVerification = TRUE;
    
    if (IsSecurityOn())
    {
        AssemblySecurityDescriptor *pSec = pAssembly->GetSecurityDescriptor();

        _ASSERTE(pSec);
        
        if (pSec)
        {
            if (fLazy)
                canSkipVerification = pSec->QuickCanSkipVerification();
            else
                canSkipVerification = pSec->CanSkipVerification();
        }
        else
        {
            canSkipVerification = FALSE;
        }
    }
    
    if (canSkipVerification)
        GetAppDomain()->OnLinktimeCanSkipVerificationCheck(pAssembly);

    return canSkipVerification;
}

// Call this function if you wont completely rely on the result (since it
// does not call OnLinktimeCanSkipVerificationCheck(). Use it only
// to make decisions which can be overriden later.

BOOL Security::QuickCanSkipVerification(Module *pModule)
{
    _ASSERTE(pModule != NULL);
    _ASSERTE(GetAppDomain()->IsCompilationDomain()); // Only used by ngen

    if (IsSecurityOff())
        return TRUE;

    AssemblySecurityDescriptor *pSec = pModule->GetSecurityDescriptor();

    _ASSERTE(pSec);

    return pSec->QuickCanSkipVerification();
}


BOOL Security::CanCallUnmanagedCode(Module *pModule)
{
    _ASSERTE(pModule != NULL);

    if (IsSecurityOff())
        return TRUE;

    AssemblySecurityDescriptor *pSec = pModule->GetSecurityDescriptor();

    _ASSERTE(pSec);

    return pSec->CanCallUnmanagedCode();
}

BOOL Security::AppDomainCanCallUnmanagedCode(OBJECTREF *pThrowable)
{
    if (IsSecurityOff())
        return TRUE;

    Thread *pThread = GetThread();
    if (pThread == NULL)
        return TRUE;

    AppDomain *pDomain = pThread->GetDomain();
    if (pDomain == NULL)
        return TRUE;

    ApplicationSecurityDescriptor *pSecDesc = pDomain->GetSecurityDescriptor();
    if (pSecDesc == NULL)
        return TRUE;

    return pSecDesc->CanCallUnmanagedCode(pThrowable);
}

// Retrieve the public portion of a public/private key pair. The key pair is
// either exported (available as a byte array) or encapsulated in a Crypto API
// key container (identified by name).
LPVOID __stdcall Security::GetPublicKey(GetPublicKeyArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    LPWSTR      wszKeyContainer = NULL;
    DWORD       cchKeyContainer;
    BYTE       *pbKeyPair = NULL;
    DWORD       cbKeyPair = 0;
    BYTE       *pbPublicKey;
    DWORD       cbPublicKey;
    OBJECTREF   orOutputArray;

    // Read the arguments; either a byte array or a container name.
    if (args->bExported) {
        // Key pair provided directly in a byte array.
        cbKeyPair = args->pArray->GetNumComponents();
        pbKeyPair = (BYTE*)_alloca(cbKeyPair);
        memcpy(pbKeyPair, args->pArray->GetDataPtr(), cbKeyPair);
    } else {
        // Key pair referenced by key container name.
        cchKeyContainer = args->pContainer->GetStringLength();
        wszKeyContainer = (LPWSTR)_alloca((cchKeyContainer + 1) * sizeof(WCHAR));
        memcpy(wszKeyContainer, args->pContainer->GetBuffer(), cchKeyContainer * sizeof(WCHAR));
        wszKeyContainer[cchKeyContainer] = L'\0';
    }

    // Call the strong name routine to extract the public key. Need to switch
    // into GC pre-emptive mode for this call since it might perform a load
    // library (don't need to bother for the StrongNameFreeBuffer call later on).
    Thread *pThread = GetThread();
    pThread->EnablePreemptiveGC();
    BOOL fResult = StrongNameGetPublicKey(wszKeyContainer,
                                          pbKeyPair,
                                          cbKeyPair,
                                          &pbPublicKey,
                                          &cbPublicKey);
    pThread->DisablePreemptiveGC();
    if (!fResult)
        COMPlusThrow(kArgumentException, L"Argument_StrongNameGetPublicKey");

    // Translate the unmanaged byte array into managed form.
    SecurityHelper::CopyEncodingToByteArray(pbPublicKey, cbPublicKey, &orOutputArray);

    StrongNameFreeBuffer(pbPublicKey);

    RETURN(orOutputArray, OBJECTREF);
}

LPVOID __stdcall Security::CreateFromUrl( CreateFromUrlArgs* args )
{
    // We default to MyComputer zone.
    DWORD dwZone = -1; 

    const WCHAR* rootFile = args->url->GetBuffer();
    
    if (rootFile != NULL)
    {
        dwZone = Security::QuickGetZone( (WCHAR*)rootFile );

        if (dwZone == -1)
        {
            IInternetSecurityManager *securityManager = NULL;
            HRESULT hr;

            hr = CoInternetCreateSecurityManager(NULL,
                                                 &securityManager,
                                                 0);

            if (SUCCEEDED(hr))
            {
                hr = securityManager->MapUrlToZone(rootFile,
                                                   &dwZone,
                                                   0);
                                                      
                if (FAILED(hr))
                    dwZone = -1;
             
                securityManager->Release();
            }
        }
    }

    RETURN( dwZone, DWORD );
}

static LONG s_nDataReady = 0;
static LONG s_nInitData = 0;

DWORD Security::QuickGetZone( WCHAR* url )
{
    static WCHAR internetCacheDirectory[MAX_PATH];
    static size_t internetCacheDirectorySize = 0;

    // If we aren't given an url, just early out.

    if (url == NULL)
        return NoZone;

    // Initialize where the internet cache directory is.
    // We sort of invent a simple spin lock here to keep
    // from having to allocate yet another CriticalSection.

    while (s_nDataReady != 1)
    {
        if (InterlockedExchange(&s_nInitData, 1) == 0) 
        {
            HRESULT result = GetInternetCacheDir( internetCacheDirectory, MAX_PATH );

            if (FAILED( result ))
            {
                internetCacheDirectory[0] = L'\0';
            }

            internetCacheDirectorySize = wcslen( internetCacheDirectory );

            // Flip all the backslashes to forward slashes to match
            // url format.

            for (size_t i = 0; i < internetCacheDirectorySize; ++i)
            {
                if (internetCacheDirectory[i] == L'\\')
                    internetCacheDirectory[i] = L'/';
            }

            LONG checkValue = InterlockedExchange( &s_nDataReady, 1 );

            _ASSERTE( checkValue == 0 && "Someone beat us to setting this value" );
        }
        else
            Sleep(1);
    }

    // If we were unable to determine to internetCacheDirectory,
    // we can't guarantee that we'll return the right zone
    // so just give up.

    if (internetCacheDirectorySize == 0)
        return NoZone;

    WCHAR filePrefix[] = L"file://";

    if (memcmp( url, filePrefix, sizeof( filePrefix ) - sizeof( WCHAR ) ) != 0)
        return NoZone;

    WCHAR* temp = (WCHAR*)&url[7];

    if (*temp == '/')
        temp++;

    WCHAR* path = temp;

    WCHAR rootPath[4];
    ZeroMemory( rootPath, sizeof( rootPath ) );

    rootPath[0] = *(temp++);
    wcscat( rootPath, L":\\" );

    if (*temp != ':' && *temp != '|')
        return -1;

    UINT driveType = WszGetDriveType( rootPath );

    if (driveType == DRIVE_REMOVABLE ||
        driveType == DRIVE_FIXED ||
        driveType == DRIVE_CDROM ||
        driveType == DRIVE_RAMDISK)
    {
        INT32 result;

        if (wcslen( path ) >= internetCacheDirectorySize && COMString::CaseInsensitiveCompHelper((WCHAR *)path, (WCHAR *)internetCacheDirectory, (INT32)internetCacheDirectorySize, (INT32)internetCacheDirectorySize, &result) && (result == 0 || result == path[internetCacheDirectorySize]))
        {
            // This comes from the internet cache so we'll claim it's from
            // the internet.
            return URLZONE_INTERNET;
        }
        else
        {
            // Otherwise we'll say it's from MyComputer.
            return URLZONE_LOCAL_MACHINE;
        }
    }

    return NoZone;
}


// Retrieve all linktime demands sets for a method. This includes both CAS and
// non-CAS sets for LDs at the class and the method level, so we could get up to
// four sets.
void Security::RetrieveLinktimeDemands(MethodDesc  *pMD,
                                       OBJECTREF   *pClassCas,
                                       OBJECTREF   *pClassNonCas,
                                       OBJECTREF   *pMethodCas,
                                       OBJECTREF   *pMethodNonCas)
{
    EEClass *pClass = pMD->GetClass();
    
    // Class level first.
    if (pClass->RequiresLinktimeCheck())
        *pClassCas = pClass->GetModule()->GetLinktimePermissions(pClass->GetCl(), pClassNonCas);

    // Then the method level.
    if (IsMdHasSecurity(pMD->GetAttrs()))
        *pMethodCas = pMD->GetModule()->GetLinktimePermissions(pMD->GetMemberDef(), pMethodNonCas);
}


// Used by interop to simulate the effect of link demands when the caller is
// in fact script constrained by an appdomain setup by IE.
void Security::CheckLinkDemandAgainstAppDomain(MethodDesc *pMD)
{
    THROWSCOMPLUSEXCEPTION();

    if (!pMD->RequiresLinktimeCheck())
        return;

    // Find the outermost (closest to caller) appdomain. This
    // represents the domain in which the unmanaged caller is
    // considered to "live" (or, at least, be constrained by).
    AppDomain *pDomain = GetThread()->GetInitialDomain();

    // The link check is only performed if this app domain has
    // security permissions associated with it, which will be
    // the case for all IE scripting callers that have got this
    // far because we automatically reported our managed classes
    // as "safe for scripting".
    ApplicationSecurityDescriptor *pSecDesc = pDomain->GetSecurityDescriptor();
    if (pSecDesc == NULL || pSecDesc->IsDefaultAppDomain())
        return;

    struct _gc
    {
        OBJECTREF refThrowable;
        OBJECTREF refGrant;
        OBJECTREF refDenied;
        OBJECTREF refClassNonCasDemands;
        OBJECTREF refClassCasDemands;
        OBJECTREF refMethodNonCasDemands;
        OBJECTREF refMethodCasDemands;
    } gc;
    ZeroMemory(&gc, sizeof(gc));

    GCPROTECT_BEGIN(gc);

    // Do a fulltrust check on the caller if the callee did not enable
    // AllowUntrustedCallerChecks. Pass a NULL caller assembly:
    // DoUntrustedCallerChecks needs to be able to cope with this.
    if (!Security::DoUntrustedCallerChecks(NULL, pMD, &gc.refThrowable, TRUE))
        COMPlusThrow(gc.refThrowable);

    // Fetch link demand sets from all the places in metadata where we might
    // find them (class and method). These might be split into CAS and non-CAS
    // sets as well.
    Security::RetrieveLinktimeDemands(pMD,
                                      &gc.refClassCasDemands,
                                      &gc.refClassNonCasDemands,
                                      &gc.refMethodCasDemands,
                                      &gc.refMethodNonCasDemands);

    if (gc.refClassCasDemands != NULL || gc.refMethodCasDemands != NULL)
    {
        // Get grant (and possibly denied) sets from the app
        // domain.
        gc.refGrant = pSecDesc->GetGrantedPermissionSet(&gc.refDenied);

        // Check one or both of the demands.
        if (gc.refClassCasDemands != NULL)
            COMCodeAccessSecurityEngine::CheckSetHelper(&gc.refClassCasDemands,
                                                        &gc.refGrant,
                                                        &gc.refDenied,
                                                        pDomain);

        if (gc.refMethodCasDemands != NULL)
            COMCodeAccessSecurityEngine::CheckSetHelper(&gc.refMethodCasDemands,
                                                        &gc.refGrant,
                                                        &gc.refDenied,
                                                        pDomain);
    }

    // Non-CAS demands are not applied against a grant
    // set, they're standalone.
    if (gc.refClassNonCasDemands != NULL)
        CheckNonCasDemand(&gc.refClassNonCasDemands);

    if (gc.refMethodNonCasDemands != NULL)
        CheckNonCasDemand(&gc.refMethodNonCasDemands);
 
    // We perform automatic linktime checks for UnmanagedCode in three cases:
    //   o  P/Invoke calls (shouldn't get these here, but let's be paranoid).
    //   o  Calls through an interface that have a suppress runtime check
    //      attribute on them (these are almost certainly interop calls).
    //   o  Interop calls made through method impls.
    // Just walk the stack in these cases, they'll be extremely rare and the
    // perf delta isn't that huge.
    if (pMD->IsNDirect() ||
        (pMD->GetClass()->IsInterface() &&
         pMD->GetClass()->GetMDImport()->GetCustomAttributeByName(pMD->GetClass()->GetCl(),
                                                                  COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI,
                                                                  NULL,
                                                                  NULL) == S_OK) ||
        (pMD->IsComPlusCall() && !pMD->IsInterface()))
        COMCodeAccessSecurityEngine::SpecialDemand(SECURITY_UNMANAGED_CODE);

    GCPROTECT_END();
}

BOOL __stdcall Security::LocalDrive(_LocalDrive *args)
{
    WCHAR rootPath[4];
    ZeroMemory( rootPath, sizeof( rootPath ) );

    rootPath[0] = args->path->GetBuffer()[0];
    wcscat( rootPath, L":\\" );
    
    UINT driveType = WszGetDriveType( rootPath );
    BOOL retval =
       (driveType == DRIVE_REMOVABLE ||
        driveType == DRIVE_FIXED ||
        driveType == DRIVE_CDROM ||
        driveType == DRIVE_RAMDISK);

    return retval;
}

LPVOID __stdcall Security::EcallGetLongPathName(_GetLongPathNameArgs *args)
{
    WCHAR* wszShortPath = args->shortPath->GetBuffer();
    WCHAR wszBuffer[MAX_PATH];

    DWORD size = Security::GetLongPathName( wszShortPath, wszBuffer, MAX_PATH );

    if (size == 0)
    {
        // We have to deal with files that do not exist so just
        // because GetLongPathName doesn't give us anything doesn't
        // mean that we can give up.  We iterate through the input
        // trying GetLongPathName on every subdirectory until
        // it succeeds or we run out of string.

        WCHAR wszIntermediateBuffer[MAX_PATH];

        if (wcslen( wszShortPath ) >= MAX_PATH)
            RETURN( args->shortPath, STRINGREF );

        wcscpy( wszIntermediateBuffer, wszShortPath );

        size_t index = wcslen( wszIntermediateBuffer );

        do
        {
            while (index > 0 && wszIntermediateBuffer[index-1] != L'\\')
                --index;

            if (index == 0)
                break;

            wszIntermediateBuffer[index-1] = L'\0';

            size = Security::GetLongPathName( wszIntermediateBuffer, wszBuffer, MAX_PATH );

            if (size != 0)
            {
                size_t sizeBuffer = wcslen( wszBuffer );

                if (sizeBuffer + wcslen( &wszIntermediateBuffer[index] ) > MAX_PATH - 2)
                {
                    RETURN( args->shortPath, STRINGREF );
                }
                else
                {
                    if (wszBuffer[sizeBuffer-1] != L'\\')
                        wcscat( wszBuffer, L"\\" );
                    wcscat( wszBuffer, &wszIntermediateBuffer[index] );
                    RETURN( COMString::NewString( wszBuffer ), STRINGREF );
                }
            }
        }
        while( true );

        RETURN( args->shortPath, STRINGREF );
    }
    else if (size > MAX_PATH)
    {
        RETURN( args->shortPath, STRINGREF );
    }
    else
    {
        RETURN( COMString::NewString( wszBuffer ), STRINGREF );
    }
}


static DWORD SecurityWNetGetConnection(
    LPCWSTR lpwLocalPath,
    LPWSTR lpwNetworkPath,
    LPDWORD lpdwNetworkPath )
{
    // NT is always UNICODE.  GetVersionEx is faster than actually doing a
    // RegOpenKeyExW on NT, so figure it out that way and do hard way if you have to.
    OSVERSIONINFO   sVerInfo;
    sVerInfo.dwOSVersionInfoSize = sizeof(sVerInfo);
    if (WszGetVersionEx(&sVerInfo) && sVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) 
    {
        return WNetGetConnectionW( 
            lpwLocalPath,
            lpwNetworkPath,
            lpdwNetworkPath );
    }

    LPSTR szLocalPath = NULL;
    LPSTR szNetworkPath = (LPSTR)new CHAR[*lpdwNetworkPath];
    DWORD cbNetworkPathCopy = *lpdwNetworkPath;
    DWORD retval = ERROR_EXTENDED_ERROR;

    if (FAILED( WszConvertToAnsi( (LPWSTR)lpwLocalPath, &szLocalPath, 0, NULL, TRUE ) ))
    {
        goto Exit;
    }
    
    retval = WNetGetConnectionA( szLocalPath, szNetworkPath, &cbNetworkPathCopy );
    
    if (retval == NO_ERROR)
    {
        if (FAILED( WszConvertToUnicode( szNetworkPath, -1, &lpwNetworkPath, &cbNetworkPathCopy, FALSE ) ))
        {
            retval = ERROR_EXTENDED_ERROR;
            goto Exit;
        }
        
        *lpdwNetworkPath = cbNetworkPathCopy;
    }

Exit:
    delete [] szLocalPath;
    delete [] szNetworkPath;
    
    return retval;
}


LPVOID __stdcall Security::GetDeviceName(_GetDeviceName *args)
{
    WCHAR networkName[MAX_PATH];
    DWORD networkNameSize = MAX_PATH;
    ZeroMemory( networkName, sizeof( networkName ) );

    if (SecurityWNetGetConnection( args->driveLetter->GetBuffer(), networkName, &networkNameSize ) != NO_ERROR)
    {
        return NULL;
    }

    RETURN( COMString::NewString( networkName ), STRINGREF );
}

///////////////////////////////////////////////////////////////////////////////
//
//  [SecurityDescriptor]
//  |
//  |
//  +----[ApplicationSecurityDescriptor]
//  |
//  |
//  +----[AssemblySecurityDescriptor]
//
///////////////////////////////////////////////////////////////////////////////

BOOL SecurityDescriptor::IsFullyTrusted( BOOL lazy )
{
    BOOL bIsFullyTrusted = FALSE;

    static COMSecurityConfig::QuickCacheEntryType fullTrustTable[] =
        { COMSecurityConfig::QuickCacheEntryType::FullTrustZoneMyComputer,
          COMSecurityConfig::QuickCacheEntryType::FullTrustZoneIntranet,
          COMSecurityConfig::QuickCacheEntryType::FullTrustZoneInternet,
          COMSecurityConfig::QuickCacheEntryType::FullTrustZoneTrusted,
          COMSecurityConfig::QuickCacheEntryType::FullTrustZoneUntrusted };

    if (Security::IsSecurityOff())
        return TRUE;

    // If this is an AppDomain with no zone set, we can assume full trust
    // without having to initialize security or resolve policy.
    if (GetProperties(CORSEC_DEFAULT_APPDOMAIN))
        return TRUE;

    BOOL fullTrustFlagSet = GetProperties(CORSEC_FULLY_TRUSTED);

    if (fullTrustFlagSet || GetProperties(CORSEC_RESOLVED))
        return fullTrustFlagSet;

    if (CheckQuickCache( COMSecurityConfig::QuickCacheEntryType::FullTrustAll, fullTrustTable ))
    {
        PermissionRequestSpecialFlags specialFlags;
        OBJECTREF required, optional, refused;

        // We need to make sure the request doesn't take away what the grant would be.
        COMPLUS_TRY
        {
            required = this->GetRequestedPermissionSet( &optional, &refused, &specialFlags, FALSE );

            if ((specialFlags.optional == NoSet) &&
                (specialFlags.refused == NoSet || specialFlags.refused == EmptySet))
            {   // fall through finally, since returning in try is expensive
                SetProperties(CORSEC_FULLY_TRUSTED);
                bIsFullyTrusted = TRUE;
            }
        }
        COMPLUS_CATCH
        {
            // If we throw an exception in the above, just fall through (since
            // using the cache is optional anyway).
        }
        COMPLUS_END_CATCH
        if (bIsFullyTrusted)
            return TRUE;
    }

    if (!lazy)
    {
        COMPLUS_TRY
        {
            // Resolve() operation need to be done before we can determine
            // if this is fully trusted
            Resolve();
        }
        COMPLUS_CATCH
        {
        }
        COMPLUS_END_CATCH
    }

    return GetProperties(CORSEC_FULLY_TRUSTED);
}

OBJECTREF SecurityDescriptor::GetGrantedPermissionSet(OBJECTREF* DeniedPermissions)
{
    THROWSCOMPLUSEXCEPTION();

    COMPLUS_TRY
    {
        // Resolve() operation need to be done before we can get the
        // granted PermissionSet
        Resolve();
    }
    COMPLUS_CATCH
    {
        OBJECTREF pThrowable = GETTHROWABLE();
        Security::CheckExceptionForSecuritySafety( pThrowable, TRUE );
        COMPlusThrow( pThrowable );
    }
    COMPLUS_END_CATCH

    OBJECTREF pset = NULL;

    pset = ObjectFromHandle(m_hGrantedPermissionSet);

    if (pset == NULL)
    {
        // We're going to create a new permission set and we might be called in
        // the wrong context. Always create the object in the context of the
        // descriptor, the caller must be able to cope with this if they're
        // outside that context.
        bool fSwitchContext = false;
        ContextTransitionFrame frame;
        Thread *pThread = GetThread();
        if (m_pAppDomain != GetAppDomain() && !IsSystem())
        {
            fSwitchContext = true;
            pThread->EnterContextRestricted(m_pAppDomain->GetDefaultContext(), &frame, TRUE);
        }

        if ((GetProperties(CORSEC_FULLY_TRUSTED) != 0) || 
            Security::IsSecurityOff())
        {
            // MarkAsFullyTrusted() call could set FULLY_TRUSTED flag without
            // setting the granted permissionSet.

            pset = SecurityHelper::CreatePermissionSet(TRUE);
        }
        else
        {
            // This could happen if Resolve was unable to obtain an
            // IdentityInfo.

            pset = SecurityHelper::CreatePermissionSet(FALSE);
            SetGrantedPermissionSet(pset, NULL);
        }

        if (fSwitchContext)
            pThread->ReturnToContext(&frame, TRUE);

        *DeniedPermissions = NULL;
    } else
        *DeniedPermissions = ObjectFromHandle(m_hGrantDeniedPermissionSet);

    return pset;
}

BOOL SecurityDescriptor::CheckQuickCache( COMSecurityConfig::QuickCacheEntryType all, COMSecurityConfig::QuickCacheEntryType* zoneTable, DWORD successFlags )
{
    BOOL bFallThroughFinally = FALSE;
    BOOL bEnablePreemptiveGC = FALSE;
    
    if (Security::IsSecurityOff())
        return TRUE;

    if (!SecurityDescriptor::QuickCacheEnabled())
        return FALSE;

    if (GetProperties(CORSEC_SYSTEM_CLASSES) != 0 || GetProperties(CORSEC_DEFAULT_APPDOMAIN) != 0)
        return TRUE;

    if (!m_pAppDomain->GetSecurityDescriptor()->QuickCacheEnabled())
        return FALSE;

    Thread* pThread = GetThread();

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY
    {
        if (((APPDOMAINREF)m_pAppDomain->GetExposedObject())->HasSetPolicy())
        {   // returning before falling through finally is expensive, so avoid in common path situations
            bFallThroughFinally = TRUE;
            goto FallThroughFinally;
        }

        _ASSERTE( this->m_hAdditionalEvidence != NULL );

        if (ObjectFromHandle( this->m_hAdditionalEvidence ) != NULL)
        {   // returning before falling through finally is expensive, so avoid in common path situations
            bFallThroughFinally = TRUE;
            goto FallThroughFinally;
        }

        Security::InitData();
FallThroughFinally:;
    }
    COMPLUS_CATCH
    {
        bFallThroughFinally = TRUE;
    }
    COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

    if (bFallThroughFinally)
        return FALSE;
        
    BOOL machine, user, enterprise;

    // First, check the quick cache for the all case.

    machine = COMSecurityConfig::GetQuickCacheEntry( COMSecurityConfig::ConfigId::MachinePolicyLevel, all );
    user = COMSecurityConfig::GetQuickCacheEntry( COMSecurityConfig::ConfigId::UserPolicyLevel, all );
    enterprise = COMSecurityConfig::GetQuickCacheEntry( COMSecurityConfig::ConfigId::EnterprisePolicyLevel, all );

    if (machine && user && enterprise)
    {
        SetProperties( successFlags );
        return TRUE;
    }
        
    // If we can't match for all, try for our zone.
    
    DWORD zone = GetZone();

    if (zone == 0xFFFFFFFF)
        return FALSE;

    machine = COMSecurityConfig::GetQuickCacheEntry( COMSecurityConfig::ConfigId::MachinePolicyLevel, zoneTable[zone] );
    user = COMSecurityConfig::GetQuickCacheEntry( COMSecurityConfig::ConfigId::UserPolicyLevel, zoneTable[zone] );
    enterprise = COMSecurityConfig::GetQuickCacheEntry( COMSecurityConfig::ConfigId::EnterprisePolicyLevel, zoneTable[zone] );
    
    if (machine && user && enterprise)
    {
        SetProperties( successFlags );
        return TRUE;
    }
        
    return FALSE;
}    
    
    
void SecurityDescriptor::Resolve()
{
    THROWSCOMPLUSEXCEPTION();

    if (Security::IsSecurityOff())
        return;

    if (GetProperties(CORSEC_RESOLVED) != 0)
        return;

    // For assembly level resolution we go through a synchronization process
    // (since we can have a single assembly loaded into multiple appdomains, but
    // must compute the same grant set for all).
    if (m_pAssem) {
        AssemblySecurityDescriptor *pASD = (AssemblySecurityDescriptor*)this;
        pASD->GetSharedSecDesc()->Resolve(pASD);
    } else
        ResolveWorker();
}

void SecurityDescriptor::ResolveWorker()
{
    THROWSCOMPLUSEXCEPTION();

    struct _gc {
        OBJECTREF reqdPset;         // Required Requested Permissions
        OBJECTREF optPset;          // Optional Requested Permissions
        OBJECTREF denyPset;         // Denied Permissions
        OBJECTREF evidence;         // Object containing evidence
        OBJECTREF granted;          // Policy based Granded Permission
        OBJECTREF grantdenied;      // Policy based explicitly Denied Permissions
    } gc;
    ZeroMemory(&gc, sizeof(gc));

    // In the following code we must avoid using m_pAppDomain if we're a system
    // assembly descriptor. That's because only one descriptor is allocated for
    // such assemblies and the appdomain is arbitrary. We special case system
    // assemblies enough so that this doesn't matter.
    // Note that IsSystem() automatically checks the difference between
    // appdomain and assembly descriptors (it's always false for appdomains).

    // Turn the security demand optimization off for the duration of the resolve,
    // to prevent some recursive resolves
    ApplicationSecurityDescriptor *pAppSecDesc = NULL;
    if (!IsSystem())
    {
        pAppSecDesc = m_pAppDomain->GetSecurityDescriptor();
        if (pAppSecDesc)
            pAppSecDesc->DisableOptimization();
    }

    // Resolve is one of the few SecurityDescriptor routines that may be called
    // from the wrong appdomain context. If that's the case we will transition
    // into the correct appdomain for the duration of the call.
    bool fSwitchContext = false;
    ContextTransitionFrame frame;
    Thread *pThread = GetThread();
    if (m_pAppDomain != GetAppDomain() && !IsSystem())
    {
        fSwitchContext = true;
        pThread->EnterContextRestricted(m_pAppDomain->GetDefaultContext(), &frame, TRUE);
    }

    // If we got here, then we are going to do at least one security check.
    // Make sure security is initialized.

    BEGIN_ENSURE_COOPERATIVE_GC();

    GCPROTECT_BEGIN(gc);

    // Short circuit system classes assembly to avoid recursion.
    // Also, AppDomains which weren't created with any input evidence are fully
    // trusted.
    if (GetProperties(CORSEC_SYSTEM_CLASSES) != 0)
    {
        // Create the unrestricted permission set.
        if (!IsSystem())
        {
            gc.granted = SecurityHelper::CreatePermissionSet(TRUE);
            SetGrantedPermissionSet(gc.granted, NULL);
        }
        MarkAsFullyTrusted();
    }
    else
    {
        Security::InitSecurity();

        if (GetProperties(CORSEC_EVIDENCE_COMPUTED))
            gc.evidence = ObjectFromHandle(m_hAdditionalEvidence);
        else
            gc.evidence = GetEvidence();

        gc.reqdPset = GetRequestedPermissionSet(&gc.optPset, &gc.denyPset);

        COMPLUS_TRY {
            int grantIsUnrestricted;
            gc.granted = Security::ResolvePolicy(gc.evidence, gc.reqdPset, gc.optPset, gc.denyPset, &gc.grantdenied, &grantIsUnrestricted, this->CheckExecutionPermission());
            if (grantIsUnrestricted)
                MarkAsFullyTrusted();
        } COMPLUS_CATCH {
            // In the specific case of a PolicyException, we have failed to
            // grant the required part of an explicit request. In this case
            // we need to rethrow the exception to trigger the assembly load
            // to fail.
            OBJECTREF pThrowable = GETTHROWABLE();
            DefineFullyQualifiedNameForClassOnStack();
            LPUTF8 szClass = GetFullyQualifiedNameForClass(pThrowable->GetClass());
            if (pAppSecDesc)
                pAppSecDesc->EnableOptimization();

            if (strcmp(g_PolicyExceptionClassName, szClass) == 0 ||
                strcmp(g_ThreadAbortExceptionClassName, szClass) == 0 ||
                strcmp(g_AppDomainUnloadedExceptionClassName, szClass) == 0)
            {
                COMPlusThrow(pThrowable);
            }
            gc.granted = SecurityHelper::CreatePermissionSet(FALSE);
        } COMPLUS_END_CATCH

        SetGrantedPermissionSet(gc.granted, gc.grantdenied);
    }

    GCPROTECT_END();

    END_ENSURE_COOPERATIVE_GC();

    if (fSwitchContext)
        pThread->ReturnToContext(&frame, TRUE);

    // Turn the security demand optimization on again
    if (pAppSecDesc)
        pAppSecDesc->EnableOptimization();
}

OBJECTREF SecurityDescriptor::GetRequestedPermissionSet(OBJECTREF *pOptionalPermissionSet,
                                                        OBJECTREF *pDeniedPermissionSet,
                                                        PermissionRequestSpecialFlags *pSpecialFlags,
                                                        BOOL fCreate)
{
    _ASSERTE( Security::IsSecurityOn() && "This method should not be called if security is not on" );

    SEC_CHECKCONTEXT();

    OBJECTREF RequestedPermission = NULL;

    RequestedPermission = ObjectFromHandle(m_hRequiredPermissionSet);
    *pOptionalPermissionSet = ObjectFromHandle(m_hOptionalPermissionSet);
    *pDeniedPermissionSet = ObjectFromHandle(m_hDeniedPermissionSet);

    if (pSpecialFlags != NULL)
        *pSpecialFlags = m_SpecialFlags;

    return RequestedPermission;
}

OBJECTREF ApplicationSecurityDescriptor::GetEvidence()
{
    SEC_CHECKCONTEXT();

    OBJECTREF   retval = NULL;

    Security::InitSecurity();

    struct _gc {
        OBJECTREF rootAssemblyEvidence;
        OBJECTREF additionalEvidence;
    } gc;
    ZeroMemory(&gc, sizeof(_gc));

    GCPROTECT_BEGIN(gc);

    if (m_pAppDomain->m_pRootAssembly != NULL)
    {
        gc.rootAssemblyEvidence = m_pAppDomain->m_pRootAssembly->GetSecurityDescriptor()->GetEvidence();
    } 

    OBJECTREF orAppDomain = m_pAppDomain->GetExposedObject();

    gc.additionalEvidence = ObjectFromHandle(m_hAdditionalEvidence);

    INT64 args[] = {
        ObjToInt64(orAppDomain),
        ObjToInt64(gc.additionalEvidence),
        ObjToInt64(gc.rootAssemblyEvidence)
    };

    retval = Int64ToObj(Security::s_stdData.pMethAppDomainCreateSecurityIdentity->Call(args, 
                                                                                       METHOD__APP_DOMAIN__CREATE_SECURITY_IDENTITY));

    if (gc.additionalEvidence == NULL)
        SetProperties(CORSEC_DEFAULT_APPDOMAIN);

    GCPROTECT_END();

    return retval;
}


DWORD ApplicationSecurityDescriptor::GetZone()
{
    // We default to MyComputer zone.
    DWORD dwZone = -1; 

    if ((m_pAppDomain == SystemDomain::System()->DefaultDomain()) &&
        m_pAppDomain->m_pRootFile)
    {
        const WCHAR* rootFile = m_pAppDomain->m_pRootFile->GetFileName();
        
        if (rootFile != NULL)
        {
            dwZone = Security::QuickGetZone( (WCHAR*)rootFile );

            if (dwZone == -1)
            {
            IInternetSecurityManager *securityManager = NULL;
            HRESULT hr;

            hr = CoInternetCreateSecurityManager(NULL,
                                                 &securityManager,
                                                 0);

            if (SUCCEEDED(hr))
            {
                hr = securityManager->MapUrlToZone(rootFile,
                                                   &dwZone,
                                                   0);
                                                          
                if (FAILED(hr))
                    dwZone = -1;
                 
                securityManager->Release();
                }
            }
        }
    } 

    return dwZone;
}


OBJECTREF AssemblySecurityDescriptor::GetRequestedPermissionSet(OBJECTREF *pOptionalPermissionSet,
                                                                OBJECTREF *pDeniedPermissionSet,
                                                                PermissionRequestSpecialFlags *pSpecialFlags,
                                                                BOOL fCreate)
{
    _ASSERTE( Security::IsSecurityOn() && "This method should not be called if security is not on" );

    if (fCreate)
        SEC_CHECKCONTEXT();

    OBJECTREF req = NULL;

    req = ObjectFromHandle(m_hRequiredPermissionSet);

    if (req == NULL)
    {
        // Try to load permission requests from assembly first.
        SecurityHelper::LoadPermissionRequestsFromAssembly(m_pAssem,
                                                           &req,
                                                           pOptionalPermissionSet,
                                                           pDeniedPermissionSet,
                                                           &m_SpecialFlags,
                                                           fCreate);

        if (pSpecialFlags != NULL)
            *pSpecialFlags = m_SpecialFlags;
        if (fCreate)
            SetRequestedPermissionSet(req, *pOptionalPermissionSet, *pDeniedPermissionSet);
    }
    else
    {
        *pOptionalPermissionSet = ObjectFromHandle(m_hOptionalPermissionSet);
        *pDeniedPermissionSet = ObjectFromHandle(m_hDeniedPermissionSet);
        if (pSpecialFlags)
            *pSpecialFlags = m_SpecialFlags;
    }

    return req;
}

// Checks if the granted permission set has a security permission
// using stored Permission Object instances.
BOOL SecurityDescriptor::CheckSecurityPermission(int index)
{
    _ASSERTE( Security::IsSecurityOn() && "This method should not be called if security is not on" );

    SEC_CHECKCONTEXT();

    BOOL    fRet = FALSE;

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY
    {

        // Check for Security.SecurityPermission.SkipVerification
        struct _gc {
            OBJECTREF granted;
            OBJECTREF denied;
            OBJECTREF perm;
        } gc;
        ZeroMemory(&gc, sizeof(_gc));

        GCPROTECT_BEGIN(gc);

        Security::_GetSharedPermissionInstance(&gc.perm, index);
        if (gc.perm == NULL)
        {
            _ASSERTE(FALSE);
            goto Exit;
        }

        // This will call Resolve(), that inturn calls InitSecurity()
        gc.granted = GetGrantedPermissionSet(&gc.denied);

        // Denied permission set should NOT contain
        // SecurityPermission.xxx

        if (gc.denied != NULL)
        {
            // s_stdData.pMethPermSetContains needs to be initialised.
            _ASSERTE(Security::IsInitialized());

            INT64 arg[2] =
            {
                ObjToInt64(gc.denied),
                ObjToInt64(gc.perm)
            };

            if ((BOOL)(Security::s_stdData.pMethPermSetContains->Call(arg, METHOD__PERMISSION_SET__CONTAINS)))
                goto Exit;
        }

        // Granted permission set should contain
        // SecurityPermission.SkipVerification

        if (gc.granted != NULL)
        {
            // s_stdData.pMethPermSetContains needs to be initialised.
            _ASSERTE(Security::IsInitialized());

            INT64 arg[2] =
            {
                ObjToInt64(gc.granted),
                ObjToInt64(gc.perm)
            };

            if ((BOOL)(Security::s_stdData.pMethPermSetContains->Call(arg, METHOD__PERMISSION_SET__CONTAINS)))
                            fRet = TRUE;
        }

Exit:
        GCPROTECT_END();
    }
    COMPLUS_CATCH
    {
        OBJECTREF pThrowable = GETTHROWABLE();
        Security::CheckExceptionForSecuritySafety( pThrowable, TRUE );
        fRet = FALSE;
    }
    COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

    return fRet;
}

BOOL SecurityDescriptor::CanCallUnmanagedCode(OBJECTREF *pThrowable)
{
    BOOL bCallUnmanagedCode = FALSE;

    static COMSecurityConfig::QuickCacheEntryType unmanagedTable[] =
        { COMSecurityConfig::QuickCacheEntryType::UnmanagedZoneMyComputer,
          COMSecurityConfig::QuickCacheEntryType::UnmanagedZoneIntranet,
          COMSecurityConfig::QuickCacheEntryType::UnmanagedZoneInternet,
          COMSecurityConfig::QuickCacheEntryType::UnmanagedZoneTrusted,
          COMSecurityConfig::QuickCacheEntryType::UnmanagedZoneUntrusted };

    if (Security::IsSecurityOff())
        return TRUE;

    if (LazyCanCallUnmanagedCode())
        return TRUE;

    if (CheckQuickCache( COMSecurityConfig::QuickCacheEntryType::UnmanagedAll, unmanagedTable ))
    {
        PermissionRequestSpecialFlags specialFlags;
        OBJECTREF required, optional, refused;

        // We need to make sure the request doesn't take away what the grant would be.
        COMPLUS_TRY
        {
            required = this->GetRequestedPermissionSet( &optional, &refused, &specialFlags, FALSE );

            if ((specialFlags.optional == NoSet) &&
                (specialFlags.refused == NoSet || specialFlags.refused == EmptySet))
            {   // fall through finally, since returning in try is expensive
                SetProperties(CORSEC_CALL_UNMANAGEDCODE);
                bCallUnmanagedCode = TRUE;
            }
        }
        COMPLUS_CATCH
        {
            // If we throw an exception in the above, just fall through (since
            // using the cache is optional anyway).
        }
        COMPLUS_END_CATCH
        if (bCallUnmanagedCode)
            return TRUE;
    }

    // IsFullyTrusted will cause a Resolve() if not already done.

    if (IsFullyTrusted())
    {
        SetProperties(CORSEC_CALL_UNMANAGEDCODE);
        return TRUE;
    }

    if (CheckSecurityPermission(SECURITY_UNMANAGED_CODE))
    {
        SetProperties(CORSEC_CALL_UNMANAGEDCODE);
        return TRUE;
    }

    if (pThrowable != RETURN_ON_ERROR)
    {
        COMPLUS_TRY
        {
            Security::ThrowSecurityException(g_SecurityPermissionClassName, SPFLAGSUNMANAGEDCODE);
        }
        COMPLUS_CATCH
        {
            UpdateThrowable(pThrowable);
        }        
        COMPLUS_END_CATCH
    }

    return FALSE;
}

BOOL SecurityDescriptor::CanRetrieveTypeInformation()
{
    if (Security::IsSecurityOff())
        return TRUE;

    if (IsFullyTrusted())
    {
        SetProperties(CORSEC_TYPE_INFORMATION);
        return TRUE;
    }

    if (CheckSecurityPermission(REFLECTION_TYPE_INFO))
    {
        SetProperties(CORSEC_TYPE_INFORMATION);
        return TRUE;
    }

    return FALSE;
}

BOOL SecurityDescriptor::AllowBindingRedirects()
{
    static COMSecurityConfig::QuickCacheEntryType bindingRedirectsTable[] =
        { COMSecurityConfig::QuickCacheEntryType::BindingRedirectsZoneMyComputer,
          COMSecurityConfig::QuickCacheEntryType::BindingRedirectsZoneIntranet,
          COMSecurityConfig::QuickCacheEntryType::BindingRedirectsZoneInternet,
          COMSecurityConfig::QuickCacheEntryType::BindingRedirectsZoneTrusted,
          COMSecurityConfig::QuickCacheEntryType::BindingRedirectsZoneUntrusted };


    _ASSERTE( Security::IsSecurityOn() && "This method should not be called if security is not on" );

    if (CheckQuickCache( COMSecurityConfig::QuickCacheEntryType::BindingRedirectsAll, bindingRedirectsTable ))
    {
        return TRUE;
    }

    // IsFullyTrusted will cause a Resolve() if not already done.

    if (IsFullyTrusted())
    {
        return TRUE;
    }

    if (CheckSecurityPermission(SECURITY_BINDING_REDIRECTS))
    {
        return TRUE;
    }

    return FALSE;
}


BOOL SecurityDescriptor::CanSkipVerification()
{
    BOOL bSkipVerification = FALSE;

    static COMSecurityConfig::QuickCacheEntryType skipVerificationTable[] =
        { COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneMyComputer,
          COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneIntranet,
          COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneInternet,
          COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneTrusted,
          COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneUntrusted };


    _ASSERTE( Security::IsSecurityOn() && "This method should not be called if security is not on" );

    if (LazyCanSkipVerification())
        return TRUE;

    if (CheckQuickCache( COMSecurityConfig::QuickCacheEntryType::SkipVerificationAll, skipVerificationTable ))
    {
        PermissionRequestSpecialFlags specialFlags;
        OBJECTREF required, optional, refused;

        // We need to make sure the request doesn't take away what the grant would be.
        COMPLUS_TRY
        {
            required = this->GetRequestedPermissionSet( &optional, &refused, &specialFlags, FALSE );

            if ((specialFlags.optional == NoSet) &&
                (specialFlags.refused == NoSet || specialFlags.refused == EmptySet))
            {   // fall through finally, since returning in try is expensive
                SetProperties(CORSEC_SKIP_VERIFICATION);
                bSkipVerification = TRUE;
            }
        }
        COMPLUS_CATCH
        {
            // If we throw an exception in the above, just fall through (since
            // using the cache is optional anyway).
        }
        COMPLUS_END_CATCH
        if (bSkipVerification)
            return TRUE;
    }

    // IsFullyTrusted will cause a Resolve() if not already done.

    if (IsFullyTrusted())
    {
        SetProperties(CORSEC_SKIP_VERIFICATION);
        return TRUE;
    }

    if (CheckSecurityPermission(SECURITY_SKIP_VER))
    {
        SetProperties(CORSEC_SKIP_VERIFICATION);
        return TRUE;
    }

    return FALSE;
}

BOOL SecurityDescriptor::QuickCanSkipVerification()
{
    BOOL bSkipVerification = FALSE;
    
    static COMSecurityConfig::QuickCacheEntryType skipVerificationTable[] =
        { COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneMyComputer,
          COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneIntranet,
          COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneInternet,
          COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneTrusted,
          COMSecurityConfig::QuickCacheEntryType::SkipVerificationZoneUntrusted };


    _ASSERTE( Security::IsSecurityOn() && "This method should not be called if security is not on" );

    if (LazyCanSkipVerification())
        return TRUE;

    if (CheckQuickCache( COMSecurityConfig::QuickCacheEntryType::SkipVerificationAll, skipVerificationTable ))
    {
        PermissionRequestSpecialFlags specialFlags;
        OBJECTREF required, optional, refused;

        // We need to make sure the request doesn't take away what the grant would be.
        COMPLUS_TRY
        {
            required = this->GetRequestedPermissionSet( &optional, &refused, &specialFlags, FALSE );

            if ((specialFlags.optional == NoSet) &&
                (specialFlags.refused == NoSet || specialFlags.refused == EmptySet))
            {   // fall through finally, since returning in try is expensive
                SetProperties(CORSEC_SKIP_VERIFICATION);
                bSkipVerification = TRUE;
            }
        }
        COMPLUS_CATCH
        {
            // If we throw an exception in the above, just fall through (since
            // using the cache is optional anyway).
        }
        COMPLUS_END_CATCH
        if (bSkipVerification)
            return TRUE;
    }

    return FALSE;
}

OBJECTREF AssemblySecurityDescriptor::GetSerializedEvidence()
{
    DWORD cbResource;
    U1ARRAYREF serializedEvidence;
    PBYTE pbInMemoryResource = NULL;

    SEC_CHECKCONTEXT();

    // Get the resource, and associated file handle, from the assembly.
    if (FAILED(m_pAssem->GetResource(s_strSecurityEvidence, NULL,
                                     &cbResource, &pbInMemoryResource,
                                     NULL, NULL, NULL, NULL, FALSE, TRUE)))
        return NULL;

    // Allocate the proper size unsigned byte array.
    serializedEvidence = (U1ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_U1, cbResource);

    memcpyNoGCRefs(serializedEvidence->GetDirectPointerToNonObjectElements(),
               pbInMemoryResource, cbResource);

    // Successfully read all data, set the allocated array as the return value.
    return (OBJECTREF) serializedEvidence;
}

// Gather all raw materials to construct evidence and punt them up to the managed
// assembly, which constructs the actual Evidence object and returns it (as well
// as caching it).
OBJECTREF AssemblySecurityDescriptor::GetEvidence()
{
    HRESULT     hr;
    OBJECTREF   evidence = NULL;
    LPWSTR      wszCodebase = NULL;
    DWORD       dwZone = -1;
    BYTE        rbUniqueID[MAX_SIZE_SECURITY_ID];
    DWORD       cbUniqueID = sizeof(rbUniqueID);

    SEC_CHECKCONTEXT();

    Security::InitSecurity();

    hr = m_pAssem->GetSecurityIdentity(&wszCodebase, &dwZone, rbUniqueID, &cbUniqueID);
    _ASSERTE(SUCCEEDED(hr));

    if (FAILED(hr))
    {
        dwZone = -1;
        wszCodebase = NULL;
    }

    hr = LoadSignature();
    _ASSERTE(SUCCEEDED(hr) || this->m_pSignature == NULL);

    struct _gc {
        STRINGREF url;
        OBJECTREF uniqueID;
        OBJECTREF cert;
        OBJECTREF serializedEvidence;
        OBJECTREF additionalEvidence;
    } gc;
    ZeroMemory(&gc, sizeof(_gc));

    GCPROTECT_BEGIN(gc);

    if (wszCodebase != NULL && *wszCodebase)
        gc.url = COMString::NewString(wszCodebase);
    else
        gc.url = NULL;

    if (m_pSignature && m_pSignature->pbSigner && m_pSignature->cbSigner)
        SecurityHelper::CopyEncodingToByteArray(m_pSignature->pbSigner,
                                                m_pSignature->cbSigner,
                                                &gc.cert);

    gc.serializedEvidence = GetSerializedEvidence();

    gc.additionalEvidence = ObjectFromHandle(m_hAdditionalEvidence);

    OBJECTREF assemblyref = m_pAssem->GetExposedObject();

    INT64 args[] = {
        ObjToInt64(assemblyref),
        ObjToInt64(gc.additionalEvidence),
        ObjToInt64(gc.serializedEvidence),
        ObjToInt64(gc.cert),
        (INT64)dwZone,
        ObjToInt64(gc.uniqueID),
        ObjToInt64(gc.url)
    };

    evidence = Int64ToObj(Security::s_stdData.pMethCreateSecurityIdentity->Call(args, METHOD__ASSEMBLY__CREATE_SECURITY_IDENTITY));

    GCPROTECT_END();

    return evidence;
}


DWORD AssemblySecurityDescriptor::GetZone()
{
    HRESULT     hr;
    LPWSTR      wszCodebase;
    DWORD       dwZone = -1;
    BYTE        rbUniqueID[MAX_SIZE_SECURITY_ID];
    DWORD       cbUniqueID = sizeof(rbUniqueID);

    hr = m_pAssem->GetSecurityIdentity(&wszCodebase, &dwZone, rbUniqueID, &cbUniqueID);
    _ASSERTE(SUCCEEDED(hr));

    if (FAILED(hr))
        dwZone = -1;

    return dwZone;
}


HRESULT AssemblySecurityDescriptor::LoadSignature(COR_TRUST **ppSignature)
{
    if (GetProperties(CORSEC_SIGNATURE_LOADED) != 0) {
        if (ppSignature)
            *ppSignature = m_pSignature;
        return S_OK;
    }

    // Dynamic modules never have a signature.
    if (m_pSharedSecDesc->GetManifestFile() == NULL)
        return S_OK;

    HRESULT hr        = S_OK;
    HANDLE  hCertFile = NULL;
    IMAGE_DATA_DIRECTORY *pDir = m_pSharedSecDesc->GetManifestFile()->GetSecurityHeader();

    if (pDir == NULL || pDir->VirtualAddress == 0 || pDir->Size == 0)
    {
        SetProperties(CORSEC_SIGNATURE_LOADED);
        LOG((LF_SECURITY, LL_INFO1000, "No certificates found in module\n"));
        _ASSERTE(m_pSignature == NULL);
        if (ppSignature)
            *ppSignature = NULL;
        return hr;
    }

    LPCWSTR wszModule;
    DWORD   dwFlags    = COR_NOUI | COR_NOPOLICY;
    DWORD   dwSig      = 0;

    wszModule = m_pSharedSecDesc->GetManifestFile()->GetFileName();

    if (*wszModule != 0)
    {
#ifndef _ALPHA_
        // Failing to find a signature is OK.
        if (FAILED(GetPublisher((LPWSTR) wszModule,
                     hCertFile,
                     dwFlags,
                     &m_pSignature,
                     &dwSig)))
        {
            if (m_pSignature != NULL)
                FreeM(m_pSignature);
            m_pSignature = NULL;
        }
#endif
    }

    SetProperties(CORSEC_SIGNATURE_LOADED);

    if (ppSignature)
        *ppSignature = m_pSignature;

    return S_OK;
}

AssemblySecurityDescriptor::~AssemblySecurityDescriptor()
{
    if (m_pSignature != NULL)
        FreeM(m_pSignature);

    if (!m_pAssem)
        return;

    if (m_pSharedSecDesc)
        m_pSharedSecDesc->RemoveSecDesc(this);

    if (m_pSharedSecDesc == NULL || !IsSystem()) {

        // If we're not a system assembly (loaded into an arbitrary appdomain),
        // remove this ASD from the owning domain's ASD list. This should happen at
        // only two points: appdomain unload and assembly load failure. We don't
        // really care about the removal in case one, but case two would result in a
        // corrupt list off the appdomain.
        RemoveFromAppDomainList();

        ApplicationSecurityDescriptor *asd = m_pAppDomain->GetSecurityDescriptor();
        if (asd)
            asd->RemoveSecDesc(this);
    }
}

AssemblySecurityDescriptor *AssemblySecurityDescriptor::Init(Assembly *pAssembly, bool fLink)
{
    SharedSecurityDescriptor *pSharedSecDesc = pAssembly->GetSharedSecurityDescriptor();
    m_pAssem = pAssembly;
    m_pSharedSecDesc = pSharedSecDesc;
    
    AssemblySecurityDescriptor *pSecDesc = this;

    // Attempt to insert onto list of assembly descriptors (one per domain this
    // assembly is loaded into to). We could be racing to do this, so if we fail
    // the insert back off and use the descriptor that won.
    if (fLink && !pSharedSecDesc->InsertSecDesc(this)) {
        pSecDesc = pSharedSecDesc->FindSecDesc(m_pAppDomain);
        delete this;
    }

    return pSecDesc;
}

bool SecurityDescriptor::IsSystem()
{
    // Always return false for appdomains.
    if (m_pAssem == NULL)
        return false;

    return ((AssemblySecurityDescriptor*)this)->m_pSharedSecDesc->IsSystem();
}


// Add ASD to list of ASDs seen in the current AppDomain context.
void AssemblySecurityDescriptor::AddToAppDomainList()
{
    _ASSERTE( m_pAppDomain != NULL);
    SecurityContext *pSecContext = m_pAppDomain->m_pSecContext;
    EnterCriticalSection(&pSecContext->m_sAssembliesLock);
    m_pNextAssembly = pSecContext->m_pAssemblies;
    pSecContext->m_pAssemblies = this;
    LeaveCriticalSection(&pSecContext->m_sAssembliesLock);
}

// Remove ASD from list of ASDs seen in the current AppDomain context.
void AssemblySecurityDescriptor::RemoveFromAppDomainList()
{
    _ASSERTE( m_pAppDomain != NULL);
    SecurityContext *pSecContext = m_pAppDomain->m_pSecContext;
    EnterCriticalSection(&pSecContext->m_sAssembliesLock);
    AssemblySecurityDescriptor **ppSecDesc = &pSecContext->m_pAssemblies;
    while (*ppSecDesc && *ppSecDesc != this)
        ppSecDesc = &(*ppSecDesc)->m_pNextAssembly;
    if (*ppSecDesc)
        *ppSecDesc = m_pNextAssembly;
    LeaveCriticalSection(&pSecContext->m_sAssembliesLock);
}


// Creates the PermissionListSet which holds the AppDomain level intersection of 
// granted and denied permission sets of all assemblies in the domain
OBJECTREF ApplicationSecurityDescriptor::Init()
{
    THROWSCOMPLUSEXCEPTION();

    if (Security::IsSecurityOn())
    {
        OBJECTREF refPermListSet = NULL;
        GCPROTECT_BEGIN(refPermListSet);

        ContextTransitionFrame frame;
        Thread *pThread = GetThread();
        Context *pContext = this->m_pAppDomain->GetDefaultContext();

        MethodTable *pMT = g_Mscorlib.GetClass(CLASS__PERMISSION_LIST_SET);
        MethodDesc *pCtor = g_Mscorlib.GetMethod(METHOD__PERMISSION_LIST_SET__CTOR);

        pThread->EnterContextRestricted(pContext, &frame, TRUE);

        refPermListSet = AllocateObject(pMT);

        INT64 arg[1] = { 
            ObjToInt64(refPermListSet)
        };

        pCtor->Call(arg, METHOD__PERMISSION_LIST_SET__CTOR);
    
        if (!GetProperties(CORSEC_SYSTEM_CLASSES) && !GetProperties(CORSEC_DEFAULT_APPDOMAIN))
        {
            OBJECTREF refGrantedSet, refDeniedSet;
            INT64 ilargs[5];
            refGrantedSet = GetGrantedPermissionSet(&refDeniedSet);
            ilargs[4] = ObjToInt64(refPermListSet);
            ilargs[3] = (INT64)FALSE;
            ilargs[2] = ObjToInt64(refGrantedSet);
            ilargs[1] = ObjToInt64(refDeniedSet);
            ilargs[0] = ObjToInt64(NULL);

            INT32 retCode = (INT32)COMCodeAccessSecurityEngine::s_seData.pMethStackCompressHelper->Call(&(ilargs[0]), METHOD__SECURITY_ENGINE__STACK_COMPRESS_WALK_HELPER);
        }

        if (!IsFullyTrusted())
            m_fEveryoneFullyTrusted = FALSE;

        pThread->ReturnToContext(&frame, TRUE);

        GCPROTECT_END();

        return refPermListSet;
    }
    else
    {
        return NULL;
    }
}

// Whenever a new assembly is added to the domain, we need to update the PermissionListSet
// This method updates the linked list of assemblies yet to be (lazily) added to the PLS
VOID ApplicationSecurityDescriptor::AddNewSecDesc(SecurityDescriptor *pNewSecDescriptor)
{
    // NOTE: even when the optimization is "turned off", this code should still
    // be run.  This allows us to turn the optimization back on with no lose of
    // information.

    m_LockForAssemblyList.Enter();

    // Set the next to null (we don't clean up when a security descriptor is removed from
    // the list)

    pNewSecDescriptor->m_pNext = NULL;

    // Add the descriptor to this list so that is gets intersected into the AppDomain list

    SecurityDescriptor *head = m_pNewSecDesc;
    if (head == NULL)
    {
        m_pNewSecDesc = pNewSecDescriptor;
    }
    else
    {
        while (head->m_pNext != NULL)
            head = head->m_pNext;
        head->m_pNext = pNewSecDescriptor;
    }

    // Add the descriptor to this list (if necessary) so that it gets re-resolved at the
    // completion of the current resolve.

    if (GetProperties(CORSEC_RESOLVE_IN_PROGRESS) != 0)
    {
        pNewSecDescriptor->m_pPolicyLoadNext = NULL;

        SecurityDescriptor *head = m_pPolicyLoadSecDesc;
        if (head == NULL)
        {
            m_pPolicyLoadSecDesc = pNewSecDescriptor;
        }
        else
        {
            while (head->m_pPolicyLoadNext != NULL)
                head = head->m_pPolicyLoadNext;
            head->m_pNext = pNewSecDescriptor;
        }
    }
    GetNextTimeStamp();

    m_LockForAssemblyList.Leave();

    ResetStatusOf(ALL_STATUS_FLAGS);
}

// Remove assembly security descriptors added using AddNewSecDesc above.
VOID ApplicationSecurityDescriptor::RemoveSecDesc(SecurityDescriptor *pSecDescriptor)
{
    m_LockForAssemblyList.Enter();

    SecurityDescriptor *pSecDesc = m_pNewSecDesc;

    if (pSecDesc == pSecDescriptor)
    {
        m_pNewSecDesc = pSecDesc->m_pNext;
    }
    else
        while (pSecDesc)
        {
            if (pSecDesc->m_pNext == pSecDescriptor)
            {
                pSecDesc->m_pNext = pSecDescriptor->m_pNext;
                break;
            }
            pSecDesc = pSecDesc->m_pNext;
        }

    GetNextTimeStamp();

    m_LockForAssemblyList.Leave();

    ResetStatusOf(ALL_STATUS_FLAGS);
}

VOID ApplicationSecurityDescriptor::ResolveLoadList( void )
{
    THROWSCOMPLUSEXCEPTION();

    // We have to do some ugly stuff in here where we keep
    // locking and unlocking the assembly list.  This is so
    // that we can clear the head of the list off before
    // each resolve but allow the list to be added to during
    // the resolve.

    while (m_pPolicyLoadSecDesc != NULL)
    {
        m_LockForAssemblyList.Enter();

        SecurityDescriptor *head = m_pPolicyLoadSecDesc;
        m_pPolicyLoadSecDesc = m_pPolicyLoadSecDesc->m_pPolicyLoadNext;

        m_LockForAssemblyList.Leave();

        head->ResetProperties( CORSEC_RESOLVED );

        COMPLUS_TRY
        {
            head->Resolve();
        }
        COMPLUS_CATCH
        {
            OBJECTREF pThrowable = GETTHROWABLE();
            Security::CheckExceptionForSecuritySafety( pThrowable, TRUE );
            COMPlusThrow( pThrowable );
        }
        COMPLUS_END_CATCH
    }
}


#ifdef FCALLAVAILABLE
// Add the granted/denied permissions of newly added assemblies to the AppDomain level intersection
FCIMPL1(LPVOID, ApplicationSecurityDescriptor::UpdateDomainPermissionListSet, DWORD *pStatus)
{

    if (Security::IsSecurityOff())
    {
        *pStatus = SECURITY_OFF;
        return NULL;
    }


    _ASSERTE (!g_pGCHeap->IsHeapPointer(pStatus));     // should be on the stack, not in the heap
    LPVOID ret;
    HELPER_METHOD_FRAME_BEGIN_RET_NOPOLL();

    ret = UpdateDomainPermissionListSetInner(pStatus);

    HELPER_METHOD_FRAME_END_POLL();

    return ret;
}
FCIMPLEND

LPVOID ApplicationSecurityDescriptor::UpdateDomainPermissionListSetInner(DWORD *pStatus)
{
    _ASSERTE( Security::IsSecurityOn() && "This method should not be called if security is not on" );

    LPVOID retVal = NULL;
    
    ApplicationSecurityDescriptor *appSecDesc = GetAppDomain()->GetSecurityDescriptor();
    
    _ASSERT(appSecDesc && "Cannot update uninitialized PermissionListSet");

    // Update the permission list for this domain.
    retVal = appSecDesc->UpdateDomainPermissionListSetStatus(pStatus);

    if (GetThread()->GetNumAppDomainsOnThread() > 1)
    {
        // The call to GetDomainPermissionListSet should perform the update for all domains.
        // So, a call to this routine shouldn't have been made if we have mulitple appdomains.
        // This means that appdomain(s) were created in the small window between a get and an update.
        // Bail in this case and the next time we try to get the permilistset the update would occur.
        *pStatus = MULTIPLE_DOMAINS;
    }

    return retVal;
}

LPVOID ApplicationSecurityDescriptor::UpdateDomainPermissionListSetStatus(DWORD *pStatus)
{
    _ASSERTE( Security::IsSecurityOn() && "This method should not be called if security is not on" );

    SEC_CHECKCONTEXT();

    THROWSCOMPLUSEXCEPTION();
    INT64 ilargs[5];
    INT32 retCode;
    LPVOID ret;
    OBJECTREF refGrantedSet, refDeniedSet, refPermListSet = NULL;
    OBJECTREF refNewPermListSet = NULL;
    SecurityDescriptor *pLastAssem = NULL;

    if (m_fInitialised == FALSE)
    {
        refNewPermListSet = Init();
    }

    // First see if anyone else is already got in here
    m_LockForAssemblyList.Enter();

    if (m_fInitialised == FALSE)
    {
        StoreObjectInHandle(m_hDomainPermissionListSet, refNewPermListSet);
        m_fInitialised = TRUE;
    }

    DWORD fIsBusy = m_fPLSIsBusy;
    if (fIsBusy == FALSE)
        m_fPLSIsBusy = TRUE;


    if (fIsBusy == TRUE)
    {
        m_LockForAssemblyList.Leave();
        *pStatus = PLS_IS_BUSY;
        return NULL;
    }

    // Next make sure the linked list integrity is maintained, by noting a time stamp and comparing later
    SecurityDescriptor *head = m_pNewSecDesc;
    DWORD startTimeStamp = GetNextTimeStamp();

    m_LockForAssemblyList.Leave();

    GCPROTECT_BEGIN(refPermListSet);

    refPermListSet = ObjectFromHandle(m_hDomainPermissionListSet);

Add_Assemblies:

    while (head != NULL)
    {
        pLastAssem = head;
        if (!head->IsFullyTrusted())
        {
            refGrantedSet = head->GetGrantedPermissionSet(&refDeniedSet);
            ilargs[4] = ObjToInt64(refPermListSet);
            ilargs[3] = (INT64)FALSE;
            ilargs[2] = ObjToInt64(refGrantedSet);
            ilargs[1] = ObjToInt64(refDeniedSet);
            ilargs[0] = ObjToInt64(NULL);
    
            retCode = (INT32)COMCodeAccessSecurityEngine::s_seData.pMethStackCompressHelper->Call(&(ilargs[0]), METHOD__SECURITY_ENGINE__STACK_COMPRESS_WALK_HELPER);
            m_fEveryoneFullyTrusted = FALSE;
        }
        head = head->m_pNext;
    }

    
    m_LockForAssemblyList.Enter();

    if (startTimeStamp == m_dTimeStamp)
    {
        // No new assembly has been added since I started in this method
        m_pNewSecDesc = NULL;
        m_LockForAssemblyList.Leave();
    }
    else
    {
        // A new assembly MAY been added at the end of the list
        if (pLastAssem != NULL && (head = pLastAssem->m_pNext) != NULL)
        {
            // A new assembly HAS been added
            startTimeStamp = GetNextTimeStamp();
            m_LockForAssemblyList.Leave();
            goto Add_Assemblies;
        }
        m_LockForAssemblyList.Leave();
    }


    m_fPLSIsBusy = FALSE;


    *((OBJECTREF*)&ret) = refPermListSet;
    GCPROTECT_END();

    // See if there are any security overrides
    if (GetThread()->GetOverridesCount() > 0)
        *pStatus = OVERRIDES_FOUND;
    else if (m_fEveryoneFullyTrusted == TRUE)
        *pStatus = FULLY_TRUSTED;
    else
        *pStatus = CONTINUE;
    
    return ret;
}

FCIMPL4(Object*, ApplicationSecurityDescriptor::GetDomainPermissionListSet, DWORD *pStatus, Object* demand, int capOrSet, DWORD whatPermission)
{
    if (Security::IsSecurityOff())
    {
        *pStatus = SECURITY_OFF;
        return NULL;
    }
    
    // Uncomment this code if you want to rid yourself of all those superfluous security exceptions
    // you see in the debugger.
    //*pStatus = NEED_STACKWALK;
    //return NULL;

    // Track perfmon counters. Runtime security checks.
    COMCodeAccessSecurityEngine::IncrementSecurityPerfCounter();
    
    Object* retVal = NULL;
    
    Thread* currentThread = GetThread();

    if (!currentThread->GetPLSOptimizationState())
    {
        *pStatus = NEED_STACKWALK;
        retVal = NULL;
    }
    else if (!currentThread->GetAppDomainStack().IsWellFormed())
    {
        *pStatus = MULTIPLE_DOMAINS;
        retVal = NULL;
    }
    else if (currentThread->GetNumAppDomainsOnThread() > 1)
    {
        _ASSERTE( currentThread->GetNumAppDomainsOnThread() <= MAX_APPDOMAINS_TRACKED );
        MethodDesc *pMeth;
        if (capOrSet == CHECK_CAP)
            pMeth = COMCodeAccessSecurityEngine::s_seData.pMethPLSDemand;
        else
        {
            pMeth = COMCodeAccessSecurityEngine::s_seData.pMethPLSDemandSet;
        }
        
        // pStatus is set to the cumulative status of all the domains.
        OBJECTREF thisDemand(demand);
        HELPER_METHOD_FRAME_BEGIN_RET_1(thisDemand);
        retVal = ApplicationSecurityDescriptor::GetDomainPermissionListSetForMultipleAppDomains (pStatus, thisDemand, pMeth, whatPermission);
        HELPER_METHOD_FRAME_END();
    }
    else
    {
        ApplicationSecurityDescriptor *appSecDesc = GetAppDomain()->GetSecurityDescriptor();
        retVal = appSecDesc->GetDomainPermissionListSetStatus (pStatus);
    }

    FC_GC_POLL_AND_RETURN_OBJREF(retVal);
}
FCIMPLEND

LPVOID ApplicationSecurityDescriptor::GetDomainPermissionListSetInner(DWORD *pStatus, 
                                                                      OBJECTREF demand, 
                                                                      MethodDesc *plsMethod,
                                                                      DWORD whatPermission)
{
    _ASSERTE( Security::IsSecurityOn() && "This method should not be called if security is not on" );

    //*pStatus = NEED_STACKWALK;
    //return NULL;

    // If there are multiple app domains then check the fully trusted'ness of each
    if (!GetThread()->GetAppDomainStack().IsWellFormed())
    {
        *pStatus = NEED_STACKWALK;
        return NULL;
    }
    else if (GetThread()->GetNumAppDomainsOnThread() > 1)
    {
        _ASSERTE( GetThread()->GetNumAppDomainsOnThread() <= MAX_APPDOMAINS_TRACKED );
        return ApplicationSecurityDescriptor::GetDomainPermissionListSetForMultipleAppDomains (pStatus, demand, plsMethod, whatPermission);
    }
    else
    {
        ApplicationSecurityDescriptor *appSecDesc = GetAppDomain()->GetSecurityDescriptor();
        return appSecDesc->GetDomainPermissionListSetStatus (pStatus);
    }
}

Object* ApplicationSecurityDescriptor::GetDomainPermissionListSetStatus (DWORD *pStatus)
{
    _ASSERTE( Security::IsSecurityOn() && "This method should not be called if security is not on" );

    *pStatus = CONTINUE;
    
    // Make sure the number of security checks in this domain has crossed a threshold, before we pull in the optimization
    if (m_dNumDemands < s_dwSecurityOptThreshold)
    {
        m_dNumDemands++;
        *pStatus = BELOW_THRESHOLD;
        return NULL;
    }

    // Optimization may be turned off in a domain, for example to avoid recursion while DomainListSet is being generated
    if (!IsOptimizationEnabled())
    {
        *pStatus = NEED_STACKWALK;
        return NULL;
    }

    // Check if there is suspicion of any Deny() or PermitOnly() on the stack
    if (GetThread()->GetOverridesCount() > 0)
    {
        *pStatus = OVERRIDES_FOUND;
        return NULL;
    }
    
    // Check if DomainListSet needs update (either uninitialised or new assembly has been added etc)
    if ((m_fInitialised == FALSE) || (m_pNewSecDesc != NULL))
    {
        *pStatus = NEED_UPDATED_PLS;
        return NULL;
    }

    // Check if all assemblies so far have full trust. This allows us to do some optimizations
    if (m_fEveryoneFullyTrusted == TRUE)
    {
        *pStatus = FULLY_TRUSTED;
    }

    OBJECTREF refPermListSet = ObjectFromHandle(m_hDomainPermissionListSet);
    return OBJECTREFToObject(refPermListSet);
}

// Helper for GetDomainPermissionListSetForMultipleAppDomains, needed because of destructor
// on AppDomainIterator
static DWORD CallHelper(MethodDesc *plsMethod, INT64 *args, MetaSig *pSig)
{
    DWORD status = 0;

    COMPLUS_TRY 
      {
          INT64 retval = plsMethod->Call(args, pSig);

          // Due to how the runtime returns bools we need to mask off the higher order 32 bits.

          if ((0x00000000FFFFFFFF & retval) == 0)
              status = NEED_STACKWALK;
          else
              status = DEMAND_PASSES;
      }
    COMPLUS_CATCH
      {
          status = NEED_STACKWALK;
          // An exception is okay. It just means the short-path didnt work, need to do stackwalk
      }
    COMPLUS_END_CATCH;

    return status;
}

// OUT PARAM: pStatus   RETURNS : Always returns NULL.
//  FULLY_TRUSTED   : All domains fully trusted, return NULL
//  NEED_STACKWALK  : Need a stack walk ; return NULL
//  DEMAND_PASSES   : Check against all PLSs passed

Object* ApplicationSecurityDescriptor::GetDomainPermissionListSetForMultipleAppDomains (DWORD *pStatus, 
                                                                                        OBJECTREF demand, 
                                                                                        MethodDesc *plsMethod,
                                                                                        DWORD whatPermission)
{
    _ASSERTE( Security::IsSecurityOn() && "This method should not be called if security is not on" );

    THROWSCOMPLUSEXCEPTION();
    // First pass:
    // Update the permission list of all app domains. Side effect is that we know
    // whether all the domains are fully trusted or not.
    // This is ncessary since assemblies could have been added to these app domains.
    
    LPVOID pDomainListSet;

    Thread *pThread = GetThread();
    AppDomain *pExecDomain = GetAppDomain();
    AppDomain *pDomain = NULL, *pPrevAppDomain = NULL;
    ContextTransitionFrame frame;
    DWORD   dwAppDomainIndex = 0;

    struct _gc {
        OBJECTREF orOriginalDemand;
        OBJECTREF orDemand;
    } gc;
    gc.orOriginalDemand = demand;
    gc.orDemand = NULL;

    GCPROTECT_BEGIN (gc);

    pThread->InitDomainIteration(&dwAppDomainIndex);
    
    // Need to turn off the PLS optimization here to avoid recursion when we
    // marshal and unmarshal objects. 
    ApplicationSecurityDescriptor *pAppSecDesc;
    pAppSecDesc = pExecDomain->GetSecurityDescriptor();
    if (!pAppSecDesc->IsOptimizationEnabled())
    {
        *pStatus = NEED_STACKWALK;
        goto Finished;
    }

    // Make sure all domains on the stack have crossed the threshold..
    _ASSERT(SystemDomain::System() && "SystemDomain not yet created!");
    while ((pDomain = pThread->GetNextDomainOnStack(&dwAppDomainIndex)) != NULL)
    {

        ApplicationSecurityDescriptor *currAppSecDesc = pDomain->GetSecurityDescriptor();
        if (currAppSecDesc == NULL)
            // AppDomain still being created.
            continue;

        if (currAppSecDesc->m_dNumDemands < s_dwSecurityOptThreshold)
        {
            *pStatus = NEED_STACKWALK;
            goto Finished;
        }
    }

    // If an appdomain in the stack has been unloaded, we'll get a null before
    // reaching the last appdomain on the stack.  In this case we want to
    // permanently disable the optimization.
    if (dwAppDomainIndex != 0)
    {
        *pStatus = NEED_STACKWALK;
        goto Finished;
    }

    // We're going to make a demand against grant sets in multiple appdomains,
    // so we must marshal the demand for each one. We can perform the serialize
    // half up front and just deserialize as we iterate over the appdomains.
    BYTE *pbDemand;
    DWORD cbDemand;
    pAppSecDesc->DisableOptimization();
    AppDomainHelper::MarshalObject(pExecDomain,
                                  &(gc.orOriginalDemand),
                                  &pbDemand,
                                  &cbDemand);
    pAppSecDesc->EnableOptimization();

    pThread->InitDomainIteration(&dwAppDomainIndex);
    _ASSERT(SystemDomain::System() && "SystemDomain not yet created!");
    while ((pDomain = pThread->GetNextDomainOnStack(&dwAppDomainIndex)) != NULL)
    {

        if (pDomain == pPrevAppDomain)
            continue;

        ApplicationSecurityDescriptor *currAppSecDesc = pDomain->GetSecurityDescriptor();
        if (currAppSecDesc == NULL)
            // AppDomain still being created.
            continue;

        // Transition into current appdomain before doing any work with
        // managed objects that could bleed across boundaries otherwise.
        // We might also need to deserialize the demand into the new appdomain.
        if (pDomain != pExecDomain)
        {
            pAppSecDesc = pDomain->GetSecurityDescriptor();
            if (!pAppSecDesc->IsOptimizationEnabled())
            {
                *pStatus = NEED_STACKWALK;
                break;
            }

            pThread->EnterContextRestricted(pDomain->GetDefaultContext(), &frame, TRUE);
            pAppSecDesc->DisableOptimization();
            AppDomainHelper::UnmarshalObject(pDomain,
                                            pbDemand,
                                            cbDemand,
                                            &gc.orDemand);
            pAppSecDesc->EnableOptimization();
        }
        else
            gc.orDemand = gc.orOriginalDemand;

        // Get the status of permission list for domain.
        pDomainListSet = currAppSecDesc->GetDomainPermissionListSetStatus(pStatus);
            
        // Does this PLS require an update? If so do it now.
        if (*pStatus == NEED_UPDATED_PLS)
            pDomainListSet = currAppSecDesc->UpdateDomainPermissionListSetStatus(pStatus);

        if (*pStatus == CONTINUE || *pStatus == FULLY_TRUSTED)
        {

            OBJECTREF refDomainPLS = ObjectToOBJECTREF((Object *)pDomainListSet);
            INT64 arg[2] = { ObjToInt64(refDomainPLS), ObjToInt64(gc.orDemand)};

            MetaSig sSig(plsMethod == COMCodeAccessSecurityEngine::s_seData.pMethPLSDemand ?
                         COMCodeAccessSecurityEngine::s_seData.pSigPLSDemand :
                         COMCodeAccessSecurityEngine::s_seData.pSigPLSDemandSet);

            if ((*pStatus = CallHelper(plsMethod, &arg[0], &sSig)) == NEED_STACKWALK)
            {
                if (pDomain != pExecDomain)
                    pThread->ReturnToContext(&frame, TRUE);
                break;
            }
        }
        else
        {
            // If the permissions are anything but FULLY TRUSTED or CONTINUE (e.g. OVERRIDES etc. then bail
            *pStatus = NEED_STACKWALK;
            if (pDomain != pExecDomain)
                pThread->ReturnToContext(&frame, TRUE);
            break;
        }

        if (pDomain != pExecDomain)
            pThread->ReturnToContext(&frame, TRUE);
    }

    FreeM(pbDemand);

    // If an appdomain in the stack has been unloaded, we'll get a null before
    // reaching the last appdomain on the stack.  In this case we want to
    // permanently disable the optimization.
    if (dwAppDomainIndex != 0)
    {
        *pStatus = NEED_STACKWALK;
    }


 Finished:
    GCPROTECT_END();

    _ASSERT ((*pStatus == FULLY_TRUSTED) || (*pStatus == NEED_STACKWALK) || (*pStatus == DEMAND_PASSES));
    return NULL;
}

SharedSecurityDescriptor::SharedSecurityDescriptor(Assembly *pAssembly) :
    m_pAssembly(pAssembly),
    m_pManifestFile(NULL),
    m_defaultDesc(NULL),
    m_fIsSystem(false),
    m_fResolved(false),
    m_fFullyTrusted(false),
    m_fModifiedGrant(false),
    m_pResolvingThread(NULL),
    m_pbGrantSetBlob(NULL),
    m_cbGrantSetBlob(0),
    m_pbDeniedSetBlob(NULL),
    m_cbDeniedSetBlob(0),
    SimpleRWLock (COOPERATIVE_OR_PREEMPTIVE, LOCK_SECURITY_SHARED_DESCRIPTOR)
{
    LockOwner lock = {NULL, TrustMeIAmSafe};
    m_asmDescsMap.Init(0, IsDuplicateValue, false, &lock);
}

SharedSecurityDescriptor::~SharedSecurityDescriptor()
{
    // Sever ties to any AssemblySecurityDescriptors we have (they'll be cleaned
    // up in AD unload).

    PtrHashMap::PtrIterator i = m_asmDescsMap.begin();
    while (!i.end()) {
        AssemblySecurityDescriptor* pSecDesc = (AssemblySecurityDescriptor*)i.GetValue();
        if (pSecDesc != NULL)
            pSecDesc->m_pSharedSecDesc = NULL;
        ++i;
    }

    if (m_pbGrantSetBlob)
        FreeM(m_pbGrantSetBlob);
    if (m_pbDeniedSetBlob)
        FreeM(m_pbDeniedSetBlob);
}

bool SharedSecurityDescriptor::InsertSecDesc(AssemblySecurityDescriptor *pSecDesc)
{
    // Here we lookup the value first to make sure we don't make duplicate entries.
    // I don't think this is common case so I've put it inside the lock.  If we
    // get any lock pressure on this we can move it outside the lock (note we still
    // need to do the lookup once we have the lock as well).

    EE_TRY_FOR_FINALLY
    {
        EnterWrite();
            
        // Check again now that we have the lock
        if (m_asmDescsMap.LookupValue((UPTR)pSecDesc->m_pAppDomain, pSecDesc)
            != (LPVOID) INVALIDENTRY) {
            return false;
        }

        // Not a duplicate value, insert in the hash table
        m_asmDescsMap.InsertValue((UPTR)pSecDesc->m_pAppDomain, pSecDesc);
        if (m_defaultDesc == NULL)
            m_defaultDesc = pSecDesc;

        // We also link the ASD in the other direction: all ASDs (for different
        // assemblies) loaded in the same appdomain.
        pSecDesc->AddToAppDomainList();
    }
    EE_FINALLY
    {
        LeaveWrite();
    }
    EE_END_FINALLY

    return true;
}

void SharedSecurityDescriptor::RemoveSecDesc(AssemblySecurityDescriptor *pSecDesc)
{
    // Check that we're not removing a security descriptor that contains the
    // only copy of the grant set (this should be guaranteed by a call to
    // MarshalGrantSet in AppDomain::Exit).
    _ASSERTE(!pSecDesc->IsResolved() || m_pbGrantSetBlob != NULL || m_fIsSystem);

    EnterWrite();
        
    AssemblySecurityDescriptor* pDesc = (AssemblySecurityDescriptor*)m_asmDescsMap.DeleteValue((UPTR)pSecDesc->m_pAppDomain, pSecDesc);
        
    if (pDesc != (AssemblySecurityDescriptor*)INVALIDENTRY) {
        if (m_defaultDesc == pSecDesc) {
            PtrHashMap::PtrIterator i = m_asmDescsMap.begin();
            if (!i.end())
                m_defaultDesc = (AssemblySecurityDescriptor*)i.GetValue();
            else
                m_defaultDesc = NULL;
        }
    }

    LeaveWrite();
}

AssemblySecurityDescriptor *SharedSecurityDescriptor::FindSecDesc(AppDomain *pDomain)
{
    // System assemblies only have only descriptor.
    if (m_fIsSystem)
        return m_defaultDesc;

    EnterRead();
            
    AssemblySecurityDescriptor* pSecDesc = (AssemblySecurityDescriptor*) m_asmDescsMap.LookupValue((UPTR)pDomain, NULL);
    if (pSecDesc != (AssemblySecurityDescriptor*)INVALIDENTRY) {
        LeaveRead();
        return pSecDesc;
    }

    LeaveRead();

    return NULL;
}

void SharedSecurityDescriptor::Resolve(AssemblySecurityDescriptor *pSecDesc)
{
    THROWSCOMPLUSEXCEPTION();

    // Shortcut for resolving when we don't care which appdomain context we use.
    // If there are no instances of this assembly currently loaded, we don't
    // have anything to do (the resolve was already done and the results
    // serialized, or we cannot resolve).
    if (pSecDesc == NULL) {
        pSecDesc = m_defaultDesc;
        if (pSecDesc == NULL)
            return;
    }

    // Quick, low-cost check.
    if (m_fResolved) {
        UpdateGrantSet(pSecDesc);
        return;
    }

    EnterRead();

    // Check again now we're synchronized.
    if (m_fResolved) {
        LeaveRead();
        UpdateGrantSet(pSecDesc);
        return;
    }

    // Policy resolution might be in progress. If so, it's either a
    // recursive call (which we should allow through into the main resolve
    // logic), or another thread, which we should block until policy is
    // fully resolved.
    Thread *pThread = GetThread();
    _ASSERTE(pThread);

    // Recursive case.
    if (m_pResolvingThread == pThread) {
        LeaveRead();
        pSecDesc->ResolveWorker();
        return;
    }

    // Multi-threaded case.
    if (m_pResolvingThread) {
        while (!m_fResolved && m_pResolvingThread) {
            LeaveRead();

            // We need to enable GC while we sleep. Resolve takes a while, and
            // we don't want to spin on a different CPU on an MP machine, so
            // we'll wait a reasonable amount of time. This contention case is
            // unlikely, so there's not really a perf issue with waiting a few
            // ms extra for the result of the resolve on the second thread.
            // Given the length of the wait, it's probably not worth optimizing
            // out the mutex acquisition/relinquishment.
            BEGIN_ENSURE_PREEMPTIVE_GC();
            ::Sleep(50);
            END_ENSURE_PREEMPTIVE_GC();

            EnterRead();
        }
        if (m_fResolved) {
            LeaveRead();
            UpdateGrantSet(pSecDesc);
            return;
        }
        // The resolving thread threw an exception and gave up. Fall through and
        // let this thread have a go.
    }

    // This thread will do the resolve.
    m_pResolvingThread = pThread;
    LeaveRead();

    EE_TRY_FOR_FINALLY {
        pSecDesc->ResolveWorker();
        _ASSERTE(pSecDesc->IsResolved());
    } EE_FINALLY {
        EnterWrite();
        if (pSecDesc->IsResolved()) {
            m_fFullyTrusted = pSecDesc->IsFullyTrusted() != 0;
            m_fResolved = true;
        }
        m_pResolvingThread = NULL;
        LeaveWrite();
    } EE_END_FINALLY
}

AssemblySecurityDescriptor* SharedSecurityDescriptor::FindResolvedSecDesc()
{
    AssemblySecurityDescriptor* pSecDesc = NULL;
    PtrHashMap::PtrIterator i = m_asmDescsMap.begin();
    while (!i.end()) {
        pSecDesc = (AssemblySecurityDescriptor*)i.GetValue();
        if (pSecDesc->IsResolved())
            break;
        ++i;
    }
    return pSecDesc;
}

void SharedSecurityDescriptor::EnsureGrantSetSerialized(AssemblySecurityDescriptor *pSecDesc)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(!m_fIsSystem);
    _ASSERTE(m_fResolved);
    _ASSERTE(pSecDesc == NULL || pSecDesc->IsResolved());

    // Quick early exit.
    if (m_pbGrantSetBlob != NULL)
        return;

    BOOL fMustRelease = FALSE;

    // We don't have a serialized version of the grant set (though someone might
    // be racing to create it), but we know some assembly security descriptor
    // has it in object form (we're guaranteed this since the act of shutting
    // down the only assembly instance with a copy of the grant set will
    // automatically serialize it). We must take the lock to synchronize the act
    // of finding that someone has beaten us to the serialization or finding and
    // ref counting an appdomain to perform the serialization for us.
    if (pSecDesc == NULL) {
        EnterWrite();
        if (m_pbGrantSetBlob == NULL) {
            pSecDesc = FindResolvedSecDesc();
            _ASSERTE(pSecDesc);
            pSecDesc->m_pAppDomain->AddRef();
            fMustRelease = TRUE;
        }
        LeaveWrite();
    }

    if (pSecDesc) {

        COMPLUS_TRY {

            BYTE       *pbGrantedBlob = NULL;
            DWORD       cbGrantedBlob = 0;
            BYTE       *pbDeniedBlob = NULL;
            DWORD       cbDeniedBlob = 0;

            // Since we're outside the lock we're potentially racing to serialize
            // the sets. This is OK, all threads will produce essentially the same
            // serialized blob and the loser will simply discard their copy.

            struct _gc {
                OBJECTREF orGranted;
                OBJECTREF orDenied;
            } gc;
            ZeroMemory(&gc, sizeof(gc));
            GCPROTECT_BEGIN(gc);
            gc.orGranted = ObjectFromHandle(pSecDesc->m_hGrantedPermissionSet);
            gc.orDenied = ObjectFromHandle(pSecDesc->m_hGrantDeniedPermissionSet);

            if (gc.orDenied == NULL) {
                AppDomainHelper::MarshalObject(pSecDesc->m_pAppDomain,
                                               &(gc.orGranted),
                                               &pbGrantedBlob,
                                               &cbGrantedBlob);
            } else {
                AppDomainHelper::MarshalObjects(pSecDesc->m_pAppDomain,
                                                &(gc.orGranted),
                                                &(gc.orDenied),
                                                &pbGrantedBlob,
                                                &cbGrantedBlob,
                                                &pbDeniedBlob,
                                                &cbDeniedBlob);
            }
            GCPROTECT_END();

            // Acquire lock to update shared fields atomically.
            EnterWrite();

            if (m_pbGrantSetBlob == NULL) {
                m_pbGrantSetBlob = pbGrantedBlob;
                m_cbGrantSetBlob = cbGrantedBlob;
                m_pbDeniedSetBlob = pbDeniedBlob;
                m_cbDeniedSetBlob = cbDeniedBlob;
            } else {
                FreeM(pbGrantedBlob);
                if (pbDeniedBlob)
                    FreeM(pbDeniedBlob);
            }

            LeaveWrite();

        } COMPLUS_CATCH {

            // First we need to check what type of exception occured.
            // If it is anything other than an appdomain unloaded exception
            // than we should just rethrow it.

            OBJECTREF pThrowable = GETTHROWABLE();
            DefineFullyQualifiedNameForClassOnStack();
            LPUTF8 szClass = GetFullyQualifiedNameForClass(pThrowable->GetClass());
            if (strcmp(g_AppDomainUnloadedExceptionClassName, szClass) != 0)
            {
                if (fMustRelease)
                    pSecDesc->m_pAppDomain->Release();
                FATAL_EE_ERROR();
            }

            Thread* pThread = GetThread();

            // If this thread references the appdomain that we are trying to
            // marshal into (and which is being unloaded), then our job is
            // done and we should just get out of here as the unload process
            // will take care of everything for us.

            if (pThread->IsRunningIn( pSecDesc->m_pAppDomain, NULL ) == NULL)
            {
                // We could get really unlucky here: we found an appdomain with the
                // resolved grant set, but the appdomain is unloading and won't allow us
                // to enter it in order to marshal the sets out. The unload operation
                // itself will serialize the set, so all we need to do is wait.

                DWORD dwWaitCount = 0;

                while (pSecDesc->m_pAppDomain->ShouldHaveRoots() &&
                       m_pbGrantSetBlob == NULL) {
                    pThread->UserSleep( 100 );

                    if (++dwWaitCount > 300)
                    {
                        if (fMustRelease)
                            pSecDesc->m_pAppDomain->Release();
                        FATAL_EE_ERROR();
                    }
                }

                _ASSERTE(m_pbGrantSetBlob);
                if (!m_pbGrantSetBlob)
                {
                    if (fMustRelease)
                        pSecDesc->m_pAppDomain->Release();
                    FATAL_EE_ERROR();
                }
            }
            else
            {
                if (fMustRelease)
                    pSecDesc->m_pAppDomain->Release();
                COMPlusThrow(pThrowable);
            }

        } COMPLUS_END_CATCH

        if (fMustRelease)
            pSecDesc->m_pAppDomain->Release();
    }
}

void SharedSecurityDescriptor::UpdateGrantSet(AssemblySecurityDescriptor *pSecDesc)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(m_fResolved);

    if (pSecDesc->IsResolved())
        return;

    _ASSERTE(!m_fIsSystem);

    // Since we don't have a copy of the grant and denied sets in the context of
    // the given appdomain, but we do know they have been calculated in at least
    // one appdomain for this shared assembly, we need to deserialize the sets
    // into our appdomain. If we're lucky the serialization half has been
    // performed already, otherwise we'll have to hunt down an appdomain that's
    // already resolved (we're guaranteed to find one, since if we try to unload
    // such an appdomain and grant sets haven't been serialized, the
    // serialization is performed then and there).
    EnsureGrantSetSerialized();

    // We should have a serialized set by now; deserialize into the correct
    // context.
    _ASSERTE(m_pbGrantSetBlob);

    OBJECTREF   orGranted = NULL;
    OBJECTREF   orDenied = NULL;

    if (m_pbDeniedSetBlob == NULL) {
        AppDomainHelper::UnmarshalObject(pSecDesc->m_pAppDomain,
                                        m_pbGrantSetBlob,
                                        m_cbGrantSetBlob,
                                        &orGranted);
    } else {
        AppDomainHelper::UnmarshalObjects(pSecDesc->m_pAppDomain,
                                         m_pbGrantSetBlob,
                                         m_cbGrantSetBlob,
                                         m_pbDeniedSetBlob,
                                         m_cbDeniedSetBlob,
                                         &orGranted,
                                         &orDenied);
    }

    StoreObjectInHandle(pSecDesc->m_hGrantedPermissionSet, orGranted);
    StoreObjectInHandle(pSecDesc->m_hGrantDeniedPermissionSet, orDenied);

    pSecDesc->SetProperties(CORSEC_RESOLVED | (m_fFullyTrusted ? CORSEC_FULLY_TRUSTED : 0));
}

OBJECTREF SharedSecurityDescriptor::GetGrantedPermissionSet(OBJECTREF* pDeniedPermissions)
{
    THROWSCOMPLUSEXCEPTION();

    AppDomain *pDomain = GetAppDomain();
    AssemblySecurityDescriptor *pSecDesc = NULL;

    // Resolve if needed (in the current context if possible).
    if (!m_fResolved) {
        pSecDesc = FindSecDesc(pDomain);
        if (pSecDesc == NULL)
            pSecDesc = m_defaultDesc;
        _ASSERTE(pSecDesc);
        COMPLUS_TRY {
            pSecDesc->Resolve();
        } COMPLUS_CATCH {
            OBJECTREF pThrowable = GETTHROWABLE();
            Security::CheckExceptionForSecuritySafety( pThrowable, TRUE );
            COMPlusThrow( pThrowable );
        }
        COMPLUS_END_CATCH
    }

    // System case is simple.
    if (m_fIsSystem) {
        *pDeniedPermissions = NULL;
        return SecurityHelper::CreatePermissionSet(TRUE);
    }

    // If we happen to have the results in the right context, use them.
    if (pSecDesc && pSecDesc->m_pAppDomain == pDomain)
        return pSecDesc->GetGrantedPermissionSet(pDeniedPermissions);

    // Serialize grant/deny sets.
    EnsureGrantSetSerialized();

    // Deserialize into current context.
    OBJECTREF   orGranted = NULL;
    OBJECTREF   orDenied = NULL;

    if (m_pbDeniedSetBlob == NULL) {
        AppDomainHelper::UnmarshalObject(pDomain,
                                         m_pbGrantSetBlob,
                                         m_cbGrantSetBlob,
                                         &orGranted);
    } else {
        AppDomainHelper::UnmarshalObjects(pDomain,
                                          m_pbGrantSetBlob,
                                          m_cbGrantSetBlob,
                                          m_pbDeniedSetBlob,
                                          m_cbDeniedSetBlob,
                                          &orGranted,
                                          &orDenied);
    }

    // Return the results.
    *pDeniedPermissions = orDenied;
    return orGranted;
}

BOOL SharedSecurityDescriptor::IsFullyTrusted( BOOL lazy )
{
    if (this->m_fIsSystem)
        return TRUE;
    
    AssemblySecurityDescriptor *pSecDesc = m_defaultDesc;

    // Returning false here should be fine since the worst thing
    // that happens is that someone doesn't do something that
    // they would do if we were fully trusted.

    if (pSecDesc == NULL)
        return FALSE;

    return pSecDesc->IsFullyTrusted( lazy );
}


bool SharedSecurityDescriptor::MarshalGrantSet(AppDomain *pDomain)
{
    THROWSCOMPLUSEXCEPTION();

    // This is called when one of the appdomains in which this assembly is
    // loaded is being shut down. If we've resolved policy and not yet
    // serialized our grant/denied sets for the use of other instances of this
    // assembly in different appdomain contexts, we need to do it now.

    AssemblySecurityDescriptor *pSecDesc = FindSecDesc(pDomain);
    _ASSERTE(pSecDesc);

    if (pSecDesc->IsResolved() &&
        m_pbGrantSetBlob == NULL
        && !m_fIsSystem) {

        BEGIN_ENSURE_COOPERATIVE_GC();
        EnsureGrantSetSerialized(pSecDesc);
        END_ENSURE_COOPERATIVE_GC();
        return true;
    }

    return false;
}

long ApplicationSecurityDescriptor::s_iAppWideTimeStamp = 0;
Crst *ApplicationSecurityDescriptor::s_LockForAppwideFlags = NULL;
DWORD ApplicationSecurityDescriptor::s_dwSecurityOptThreshold = MAGIC_THRESHOLD;

OBJECTREF Security::GetDefaultMyComputerPolicy( OBJECTREF* porDenied )
{
    THROWSCOMPLUSEXCEPTION();

    MethodDesc* pMd = g_Mscorlib.GetMethod(METHOD__SECURITY_MANAGER__GET_DEFAULT_MY_COMPUTER_POLICY);
    
    INT64 arg[] = {
        (INT64) porDenied
    };
    
    return Int64ToObj(pMd->Call(arg, METHOD__SECURITY_MANAGER__GET_DEFAULT_MY_COMPUTER_POLICY));
}   

LPVOID __stdcall Security::GetEvidence(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    if (!args->pThis)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    Assembly *pAssembly = ((ASSEMBLYREF)args->pThis)->GetAssembly();
    AssemblySecurityDescriptor *pSecDesc = pAssembly->GetSecurityDescriptor();

    OBJECTREF orEvidence;
    if (pSecDesc->GetProperties(CORSEC_EVIDENCE_COMPUTED))
        orEvidence = pSecDesc->GetAdditionalEvidence();
    else
        orEvidence = pSecDesc->GetEvidence();

    RETURN(orEvidence, OBJECTREF);
}

FCIMPL1(VOID, Security::SetOverridesCount, DWORD numAccessOverrides)
{
    GetThread()->SetOverridesCount(numAccessOverrides);
}
FCIMPLEND

FCIMPL0(DWORD, Security::IncrementOverridesCount)
{
    return GetThread()->IncrementOverridesCount();
}
FCIMPLEND

FCIMPL0(DWORD, Security::DecrementOverridesCount)
{
    return GetThread()->DecrementOverridesCount();
}
FCIMPLEND

#endif // FCALLAVAILABLE

static LPCWSTR gszGlobalPolicy = KEY_COM_SECURITY_POLICY;
static LPCWSTR gszGlobalPolicySettings = L"GlobalSettings";

static LPCWSTR gszModule = KEY_COM_SECURITY_MODULE;

#define DEFAULT_GLOBAL_POLICY 0

#define DEFAULT_MODULE_ATTRIBUTE 0

HKEY OpenOrCreateKey(HKEY rootKey, LPCWSTR wszKey, DWORD access)
{
    HKEY hReg = NULL;
    if (WszRegOpenKeyEx(rootKey,
                        wszKey,
                        0,
                        KEY_ALL_ACCESS,
                        &hReg) != ERROR_SUCCESS) {
        if (WszRegCreateKeyEx(rootKey, 
                              wszKey, 
                              0, 
                              NULL,
                              REG_OPTION_NON_VOLATILE, 
                              access,
                              NULL, 
                              &hReg, 
                              NULL) != ERROR_SUCCESS) {
            LOG((LF_SECURITY, LL_ALWAYS, "Could not open security setting %s\n", wszKey));
        }
    }
    return hReg;
}

HKEY OpenKey(HKEY rootKey, LPCWSTR wszKey, DWORD access)
{
    HKEY hReg = NULL;

    if (WszRegOpenKeyEx(rootKey, wszKey,
                        0, access,
                        &hReg) != ERROR_SUCCESS)
        hReg = NULL;

    return hReg;
}

HRESULT STDMETHODCALLTYPE
GetSecuritySettings(DWORD* pdwState)
{
    HRESULT hr = S_OK;
    HKEY  hGlobal = 0;
    DWORD state = 0;

    if (pdwState == NULL) 
        return E_INVALIDARG;
    
    *pdwState = DEFAULT_GLOBAL_POLICY;

    hGlobal = OpenKey(HKEY_POLICY_ROOT, gszGlobalPolicy, KEY_READ);

    if (hGlobal != NULL) 
    {
        DWORD iType = REG_BINARY;
        DWORD iSize = sizeof(DWORD);

        if (WszRegQueryValueEx(hGlobal, gszGlobalPolicySettings,
            0, &iType, (PBYTE) &state, &iSize) != ERROR_SUCCESS)
        {
            state = DEFAULT_GLOBAL_POLICY;
        }

        *pdwState = state;
    }

    if(hGlobal) RegCloseKey(hGlobal);

    return hr;
}
 
HRESULT STDMETHODCALLTYPE
SetSecuritySettings(DWORD dwState)
{
    HRESULT hr = S_OK;
    HKEY  hGlobal = 0;
    DWORD iType = REG_BINARY;

    CORTRY {
        if (dwState == DEFAULT_GLOBAL_POLICY)
        {
            hGlobal = OpenKey(HKEY_POLICY_ROOT, gszGlobalPolicy, KEY_WRITE);
            if (hGlobal != NULL)
            {
                if (WszRegDeleteValue(hGlobal, gszGlobalPolicySettings) != ERROR_SUCCESS)
                {
                    if (WszRegSetValueEx(hGlobal, gszGlobalPolicySettings,
                                            0, iType, (PBYTE) &dwState,
                                            sizeof(DWORD))!= ERROR_SUCCESS) 
                    {
                        CORTHROW(Win32Error());
                    }
                }
            }
        }
        else
        {
            hGlobal = OpenOrCreateKey(HKEY_POLICY_ROOT, gszGlobalPolicy, KEY_WRITE);
            if(hGlobal == NULL) CORTHROW(Win32Error());

            if (WszRegSetValueEx(hGlobal, gszGlobalPolicySettings,
                                    0, iType, (PBYTE) &dwState,
                                    sizeof(DWORD))!= ERROR_SUCCESS) 
            {
                CORTHROW(Win32Error());
            }
        }
    }
    CORCATCH(err) {
        hr = err.corError;
    } COREND;

    if(hGlobal) RegCloseKey(hGlobal);
    return hr;
}

// Callers need to synchronize
HRESULT STDMETHODCALLTYPE
SetSecurityFlags(DWORD dwMask, DWORD dwFlags)
{

    HRESULT hr = S_OK;
    DWORD dwOldSettings = 0; 

    CORTRY {
        hr = GetSecuritySettings(&dwOldSettings);

        if (FAILED(hr))
            CORTHROW(Win32Error());

        hr = SetSecuritySettings((dwOldSettings & ~dwMask) | dwFlags);

        if (FAILED(hr))
            CORTHROW(Win32Error());
    }
    CORCATCH(err) {
        hr = err.corError;
    } COREND;

    return hr;
}


// @TODO: Use Security::CanSkipVerification() instead
static BOOL CallCanSkipVerification( Assembly * pAssembly, BOOL fQuickCheckOnly )
{
    BOOL bRetval = FALSE;
    AssemblySecurityDescriptor* pSecDesc = pAssembly->GetSecurityDescriptor();

    BEGIN_ENSURE_COOPERATIVE_GC();

    if (pSecDesc->QuickCanSkipVerification())
        bRetval = TRUE;

    if (!bRetval && !fQuickCheckOnly)
    {
        COMPLUS_TRY
        {
            pSecDesc->Resolve();
            bRetval = pSecDesc->CanSkipVerification();
        }
        COMPLUS_CATCH
        {
            bRetval = FALSE;
        }
        COMPLUS_END_CATCH
    }

    if (bRetval)
        GetAppDomain()->OnLinktimeCanSkipVerificationCheck(pAssembly);
    
    END_ENSURE_COOPERATIVE_GC();

    return bRetval;
}

BOOL
Security::CanLoadUnverifiableAssembly( PEFile* pFile, OBJECTREF* pExtraEvidence, BOOL fQuickCheckOnly, BOOL* pfPreBindAllowed )
{
    if (Security::IsSecurityOff())
    {
        return TRUE;
    }

    // We do most of the logic to load the assembly
    // and then resolve normally.

    Assembly* pAssembly = NULL;
    Module* pModule = NULL;
    AssemblySecurityDescriptor* pSecDesc = NULL;
    HRESULT hResult;
    BOOL bRetval = FALSE;

    pAssembly = new Assembly();

    _ASSERTE( pAssembly != NULL );

    if(pAssembly == NULL)
    {
        goto CLEANUP;
    }

    pAssembly->SetParent(SystemDomain::GetCurrentDomain());

    hResult = pAssembly->Init(false);

    if (FAILED(hResult))
    {
        goto CLEANUP;
    }

    hResult = Assembly::CheckFileForAssembly(pFile);

    if (FAILED(hResult))
    {
        goto CLEANUP;
    }
    

    hResult = pAssembly->AddManifest(pFile, FALSE, FALSE);

    if (FAILED(hResult))
    {
        goto CLEANUP;
    }

    pSecDesc = AssemSecDescHelper::Allocate(SystemDomain::GetCurrentDomain());

    if (pSecDesc == NULL)
    {
        goto CLEANUP;
    }

    pAssembly->GetSharedSecurityDescriptor()->SetManifestFile(pFile);
    pSecDesc = pSecDesc->Init(pAssembly);
    if (pAssembly->IsSystem())
        pSecDesc->GetSharedSecDesc()->SetSystem();

    if(pExtraEvidence != NULL) {
        BEGIN_ENSURE_COOPERATIVE_GC();
        pSecDesc->SetAdditionalEvidence(*pExtraEvidence);
        END_ENSURE_COOPERATIVE_GC();
    }

    // Then just call our existing APIs.

    bRetval = CallCanSkipVerification( pAssembly, fQuickCheckOnly );

    // If the caller needs to know if binding redirects are allowed
    // check with the security descriptory.
    if(pfPreBindAllowed) 
        *pfPreBindAllowed = pSecDesc->AllowBindingRedirects();

CLEANUP:
    if (pAssembly != NULL) {
        pAssembly->Terminate( FALSE );
        delete pAssembly;
    }

    return bRetval;
}

#ifdef _SECURITY_FRAME_FOR_DISPEX_CALLS
void NativeSecurityDescriptor::Resolve()
{

}
#endif  // _SECURITY_FRAME_FOR_DISPEX_CALLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\security.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Security.h
**
** Purpose:
**
** Date:  April 15, 1998
**
===========================================================*/

#ifndef __security_h__
#define __security_h__

#include "crst.h"
#include "CorPermP.h"
#include "ObjectHandle.h"
#include "permset.h"
#include "DeclSec.h"
#include "fcall.h"
#include "cgensys.h"
#include "rwlock.h"
#include "COMSecurityConfig.h"
#include "COMString.h"

// this file handles string conversion errors for itself
#undef  MAKE_TRANSLATIONFAILED

// Security Frame for all IDispEx::InvokeEx calls. Enable in frames.h also
// Consider post V.1
// #define _SECURITY_FRAME_FOR_DISPEX_CALLS

//
// Security flags for the objects that store security information
// CORSEC_SYSTEM_CLASSES       Loaded as system classes (these are special classes)
// CORSEC_SIGNATURE_LOADED     Was digitally verified for integrity
// CORSEC_FULLY_TRUSTED        Has unrestricted (full) permission
// CORSEC_RESOLVED             Permissions have been resolved
// CORSEC_ASSERTED             Asseted permission set present on frame
// CORSEC_DENIED               Denied permission set present on frame
// CORSEC_REDUCED              Reduced permission set present on frame
// CORSEC_SKIP_VERIFICATION    Do not verify
// CORSEC_CAN_ASSERT           Has permission to Assert
// CORSEC_ASSERT_PERM_CHECKED  Permission has been checked
// CORSEC_CALL_UNMANAGEDCODE   Permission to call unmanaged code
// CORSEC_DEFAULT_APPDOMAIN    AppDomain without zone, assume full trust
// CORSEC_EVIDENCE_COMPUTED    Evidence already held is complete
//
#define CORSEC_SYSTEM_CLASSES       0x0001
#define CORSEC_SIGNATURE_LOADED     0x0002
#define CORSEC_FULLY_TRUSTED        0x0004
#define CORSEC_RESOLVED             0x0008
#define CORSEC_ASSERTED             0x0020
#define CORSEC_DENIED               0x0040
#define CORSEC_REDUCED              0x0080
#define CORSEC_SKIP_VERIFICATION    0x0100
#define CORSEC_CAN_ASSERT           0x0200
#define CORSEC_ASSERT_PERM_CHECKED  0x0400
#define CORSEC_CALL_UNMANAGEDCODE   0x0800
#define CORSEC_DEFAULT_APPDOMAIN    0x1000
#define CORSEC_EVIDENCE_COMPUTED    0x2000
#define CORSEC_RESOLVE_IN_PROGRESS  0x4000
#define CORSEC_TYPE_INFORMATION     0x8000

#define SPFLAGSASSERTION        0x01
#define SPFLAGSUNMANAGEDCODE    0x02
#define SPFLAGSSKIPVERIFICATION 0x04

//
// Flags for specifying the types of ICodeIdentityPermission checks.
//
#define CODEIDCHECK_ALLCALLERS      0x00000001
#define CODEIDCHECK_IMMEDIATECALLER 0x00000002

#define CORSEC_STACKWALK_HALTED       0x00000001   // Stack walk was halted
#define CORSEC_SKIP_INTERNAL_FRAMES   0x00000002   // Skip reflection/remoting frames in stack walk

/******** Shared Permission Objects related constants *******/
#define NUM_PERM_OBJECTS    (sizeof(g_rPermObjectsTemplate) / sizeof(SharedPermissionObjects))

#define NO_ARG                                  -1
// Constants to use with SecurityPermission
#define SECURITY_PERMISSION_ASSERTION               1      // SecurityPermission.cs
#define SECURITY_PERMISSION_UNMANAGEDCODE           2      // SecurityPermission.cs
#define SECURITY_PERMISSION_SKIPVERIFICATION        4      // SecurityPermission.cs
#define SECURITY_PERMISSION_SERIALIZATIONFORMATTER  0X80   // SecurityPermission.cs
#define SECURITY_PERMISSION_BINDINGREDIRECTS        0X2000 // SecurityPermission.cs

// Constants to use with ReflectionPermission
#define REFLECTION_PERMISSION_TYPEINFO          1      // ReflectionPermission.cs
#define REFLECTION_PERMISSION_MEMBERACCESS      2      // ReflectionPermission.cs
#define PERMISSION_SET_FULLTRUST                1      // PermissionSet.cs

// Array index in SharedPermissionObjects array
// Note: these should all be permissions that implement IUnrestrictedPermission.
// Any changes to these must be reflected in bcl\system\security\codeaccesssecurityengine.cs
#define SECURITY_UNMANAGED_CODE                 0   
#define SECURITY_SKIP_VER                       1
#define REFLECTION_TYPE_INFO                    2
#define SECURITY_ASSERT                         3
#define REFLECTION_MEMBER_ACCESS                4
#define SECURITY_SERIALIZATION                  5       // Used from managed code
#define REFLECTION_EMIT                         6       // Used from managed code
#define SECURITY_FULL_TRUST                     7
#define SECURITY_BINDING_REDIRECTS              8

// Used in ApplicationSecurityDescriptor::CheckStatusOf
#define EVERYONE_FULLY_TRUSTED      31
#define ALL_STATUS_FLAGS            0xFFFF
#define DEFAULT_FLAG                0xFFFFFFFF
/************************************************************/

/* Return status codes of ApplicationSecurityDescriptor::GetDomainPermissionListSet */
#define CONTINUE            1
#define NEED_UPDATED_PLS    2
#define OVERRIDES_FOUND     3
#define FULLY_TRUSTED       4
#define MULTIPLE_DOMAINS    5
#define BELOW_THRESHOLD     6
#define PLS_IS_BUSY         7
#define NEED_STACKWALK      8
#define DEMAND_PASSES       9   // The demand passed, but not because of full trust
#define SECURITY_OFF        10

#define CHECK_CAP           1
#define CHECK_SET           2

/************************************************************/
// The timestamp will go from 0 to roughly 2 x # of assemblies in domain, if everything goes right
#define DOMAIN_PLS_TS_RANGE 1000
// Only if an app invokes more than MAGIC_THRESHOLD demands, the domain permission listset is created
// and used, to make sure small apps dont pay the overhead
#define MAGIC_THRESHOLD     100
// If the app creates more than MAGIC_NUM_OF_THRESHOLD appdomains then a stack walk might be less
// expensive than checking permissions on all the appdomains.
#define MAGIC_NUM_OF_APPDOMAINS_THRESHOLD       10

/******** Location of serialized security evidence **********/

#define s_strSecurityEvidence "Security.Evidence"

/************************************************************/

// Forward declarations to avoid pulling in too many headers.
class Frame;
class FramedMethodFrame;
class ClassLoader;
class Thread;
class CrawlFrame;
class SystemNative;
class NDirect;
class SystemDomain;
class AssemblySecurityDescriptor;
class SharedSecurityDescriptor;

enum StackWalkAction;

#define SEC_CHECKCONTEXT() _ASSERTE(m_pAppDomain == GetAppDomain() || IsSystem())

struct DeclActionInfo
{
    DWORD           dwDeclAction;   // This'll tell InvokeDeclarativeSecurity whats the action needed
    DWORD           dwSetIndex;     // The index of the cached permissionset on which to demand/assert/deny/blah
    DeclActionInfo *pNext;              // Next declarative action needed on this method, if any.

    static DeclActionInfo *Init(MethodDesc *pMD, DWORD dwAction, DWORD dwSetIndex);
};

typedef struct _SecWalkPrologData
{
    DWORD               dwFlags;
    BOOL                bFirstFrame;
    StackCrawlMark *    pStackMark;
    BOOL                bFoundCaller;
    INT32               cCheck;
    BOOL                bSkippingRemoting;
} SecWalkPrologData;

void DoDeclarativeSecurity(MethodDesc *pMD, DeclActionInfo *pActions, InterceptorFrame* frame);

class Security
{
    friend SecurityDescriptor;
    friend AssemblySecurityDescriptor;
    friend ApplicationSecurityDescriptor;
    friend void InvokeDeclarativeActions (MethodDesc *pMeth, DeclActionInfo *pActions, OBJECTREF * pSecObj);

    typedef struct _StdSecurityInfo
    {
        BOOL            fInitialized;
        MethodDesc *    pMethGetCodeAccessEngine;
        MethodDesc *    pMethResolvePolicy;
        MethodDesc *    pMethPermSetContains;
        MethodDesc *    pMethCreateSecurityIdentity;
        MethodDesc *    pMethAppDomainCreateSecurityIdentity;
        MethodDesc *    pMethPermSetDemand;
        MethodDesc *    pMethCheckGrantSets;
        MethodDesc *    pMethPrivateProcessMessage;
        MethodTable *   pTypeRuntimeMethodInfo;
        MethodTable *   pTypeMethodBase;
        MethodTable *   pTypeRuntimeConstructorInfo;
        MethodTable *   pTypeConstructorInfo;
        MethodTable *   pTypeRuntimeType;
        MethodTable *   pTypeType;
        MethodTable *   pTypeRuntimeEventInfo;
        MethodTable *   pTypeEventInfo;
        MethodTable *   pTypeRuntimePropertyInfo;
        MethodTable *   pTypePropertyInfo;
        MethodTable *   pTypeActivator;
        MethodTable *   pTypeAppDomain;
        MethodTable *   pTypeAssembly;
    } StdSecurityInfo;

    static StdSecurityInfo s_stdData;

    // The global disable settings (see CorPerm.h)
    static DWORD  s_dwGlobalSettings; 

public:
    static void InitData();

    static HRESULT Start();     // Initializes Security;
    static void Stop();         // CleanUp Security;

    static void SaveCache();

    static void InitSecurity();
    static void InitCodeAccessSecurity();

#ifdef _DEBUG
    inline static void DisableSecurity()
    {
        s_dwGlobalSettings |= CORSETTING_SECURITY_OFF;
    }
#endif

    inline static BOOL IsSecurityOn()
    {
        return ((s_dwGlobalSettings & CORSETTING_SECURITY_OFF) != 
            CORSETTING_SECURITY_OFF);
    }

    inline static BOOL IsSecurityOff()
    {
        return ((s_dwGlobalSettings & CORSETTING_SECURITY_OFF) == 
            CORSETTING_SECURITY_OFF);
    }

    inline static BOOL GlobalSettings(DWORD dwFlag)
    {
        return ((s_dwGlobalSettings & dwFlag) != 0);
    }

    inline static DWORD GlobalSettings()
    {
        return s_dwGlobalSettings;
    }
    
    inline static void SetGlobalSettings(DWORD dwMask, DWORD dwFlags)
    {
        s_dwGlobalSettings = (s_dwGlobalSettings & ~dwMask) | dwFlags;
    }

    static void SaveGlobalSettings();     

    // Return an instance of SkipVerification/UnmanagedCode Permission
    // (System.Security.Permissions.SecurityPermission)

    static void GetPermissionInstance(OBJECTREF *perm, int index)
    { _GetSharedPermissionInstance(perm, index); }

    static void GetUnmanagedCodePermissionInstance(OBJECTREF *perm)
    { _GetSharedPermissionInstance(perm, SECURITY_UNMANAGED_CODE); }

    static void GetSkipVerificationPermissionInstance(OBJECTREF *perm)
    { _GetSharedPermissionInstance(perm, SECURITY_SKIP_VER); }

    static void GetAssertPermissionInstance(OBJECTREF *perm)
    { _GetSharedPermissionInstance(perm, SECURITY_ASSERT); }

    static void GetReflectionPermissionInstance(BOOL bMemberAccess, OBJECTREF *perm)
    { _GetSharedPermissionInstance(perm, bMemberAccess ? REFLECTION_MEMBER_ACCESS : REFLECTION_TYPE_INFO); }

    inline static BOOL IsInitialized() { return s_stdData.fInitialized; }

    inline static void SetInitialized() { s_stdData.fInitialized = TRUE; }

    static HRESULT HasREQ_SOAttribute(IMDInternalImport *pInternalImport, mdToken token);

    static BOOL SecWalkCommonProlog (SecWalkPrologData * pData,
                                     MethodDesc * pMeth,
                                     StackWalkAction * pAction,
                                     CrawlFrame * pCf);

    static HRESULT GetDeclarationFlags(IMDInternalImport *pInternalImport, mdToken token, DWORD* pdwFlags, DWORD* pdwNullFlags);

    static BOOL TokenHasDeclarations(IMDInternalImport *pInternalImport, mdToken token, CorDeclSecurity action);

    static BOOL LinktimeCheckMethod(Assembly *pCaller, MethodDesc *pCallee, OBJECTREF *pThrowable); 

    static BOOL ClassInheritanceCheck(EEClass *pClass, EEClass *pParent, OBJECTREF *pThrowable);

    static BOOL MethodInheritanceCheck(MethodDesc *pMethod, MethodDesc *pParent, OBJECTREF *pThrowable);

    static OBJECTREF GetCompressedStack(StackCrawlMark* stackMark);
    static CompressedStack* GetDelayedCompressedStack(void);

    static OBJECTREF GetDefaultMyComputerPolicy( OBJECTREF* porDenied );

    static void ThrowSecurityException(char *szDemandClass, DWORD dwFlags)
    {
        THROWSCOMPLUSEXCEPTION();

        MethodDesc * pCtor = NULL;
        MethodDesc * pToXml = NULL;
        MethodDesc * pToString = NULL;
        
#define MAKE_TRANSLATIONFAILED wszDemandClass=L""
        MAKE_WIDEPTR_FROMUTF8_FORPRINT(wszDemandClass, szDemandClass);
#undef  MAKE_TRANSLATIONFAILED

        static MethodTable * pMT = g_Mscorlib.GetClass(CLASS__SECURITY_EXCEPTION);
        _ASSERTE(pMT && "Unable to load the throwable class !");
        static MethodTable * pMTSecPerm = g_Mscorlib.GetClass(CLASS__SECURITY_PERMISSION);
        _ASSERTE(pMTSecPerm && "Unable to load the security permission class !");

        struct _gc {
            OBJECTREF throwable;
            STRINGREF strDemandClass;
            OBJECTREF secPerm;
            STRINGREF strPermState;
            OBJECTREF secPermType;            
        } gc;
        memset(&gc, 0, sizeof(gc));

        GCPROTECT_BEGIN(gc);

        gc.strDemandClass = COMString::NewString(wszDemandClass);
        if (gc.strDemandClass == NULL) COMPlusThrowOM();
        // Get the type seen by reflection
        gc.secPermType = pMTSecPerm->GetClass()->GetExposedClassObject();
        // Allocate the security exception object
        gc.throwable = AllocateObject(pMT);
        if (gc.throwable == NULL) COMPlusThrowOM();
        // Allocate the security permission object
        gc.secPerm = AllocateObject(pMTSecPerm);
        if (gc.secPerm == NULL) COMPlusThrowOM();

        // Call the construtor with the correct flag
        pCtor = g_Mscorlib.GetMethod(METHOD__SECURITY_PERMISSION__CTOR);
        INT64 arg3[2] = {
            ObjToInt64(gc.secPerm),
            (INT64)dwFlags
        };
        pCtor->Call(arg3, METHOD__SECURITY_PERMISSION__CTOR);

        // Now, get the ToXml method
        pToXml = g_Mscorlib.GetMethod(METHOD__SECURITY_PERMISSION__TOXML);
        INT64 arg4 = ObjToInt64(gc.secPerm);
        INT64 arg5 = pToXml->Call(&arg4, METHOD__SECURITY_PERMISSION__TOXML);
        pToString = g_Mscorlib.GetMethod(METHOD__SECURITY_ELEMENT__TO_STRING);
        gc.strPermState = ObjectToSTRINGREF(Int64ToObj(pToString->Call(&arg5, METHOD__SECURITY_ELEMENT__TO_STRING)));

        pCtor = g_Mscorlib.GetMethod(METHOD__SECURITY_EXCEPTION__CTOR);
        INT64 arg6[4] = {
            ObjToInt64(gc.throwable),
            ObjToInt64(gc.strPermState),
            ObjToInt64(gc.secPermType),
            ObjToInt64(gc.strDemandClass)
        };
        pCtor->Call(arg6, METHOD__SECURITY_EXCEPTION__CTOR);
        
        COMPlusThrow(gc.throwable);
        
        _ASSERTE(!"Should never reach here !");
        GCPROTECT_END();
    }

    static void ThrowSecurityException(AssemblySecurityDescriptor* pSecDesc);

    static HRESULT EarlyResolve(Assembly *pAssembly, AssemblySecurityDescriptor *pSecDesc, OBJECTREF *pThrowable);

    static DWORD QuickGetZone( WCHAR* url );

    static void CheckNonCasDemand(OBJECTREF *prefDemand)
    {
        InitSecurity();
        INT64 arg = ObjToInt64(*prefDemand);
        s_stdData.pMethPermSetDemand->Call(&arg, METHOD__PERMISSION_SET__DEMAND);
    }

    static void RetrieveLinktimeDemands(MethodDesc  *pMD,
                                        OBJECTREF   *pClassCas,
                                        OBJECTREF   *pClassNonCas,
                                        OBJECTREF   *pMethodCas,
                                        OBJECTREF   *pMethodNonCas);

    static void CheckLinkDemandAgainstAppDomain(MethodDesc *pMD);

    static void CheckExceptionForSecuritySafety( OBJECTREF obj, BOOL allowPolicyException );
protected:
    static OBJECTREF GetLinktimeDemandsForToken(Module * pModule, mdToken token, OBJECTREF *refNonCasDemands);

    static void InvokeLinktimeChecks(Assembly *pCaller,
                                     Module *pModule,
                                     mdToken token,
                                     BOOL *pfResult, 
                                     OBJECTREF *pThrowable);

public:

    typedef struct {
        DECLARE_ECALL_I4_ARG(DWORD, flags); 
        DECLARE_ECALL_I4_ARG(DWORD, mask); 
    } _SetGlobalSecurity;

    static void __stdcall SetGlobalSecurity(_SetGlobalSecurity*);
    static void __stdcall SaveGlobalSecurity(void*);

    typedef struct _GetPermissionsArg
    {
        DECLARE_ECALL_PTR_ARG(OBJECTREF*, stackmark);
        DECLARE_ECALL_PTR_ARG(OBJECTREF*, ppDenied);
        DECLARE_ECALL_PTR_ARG(OBJECTREF*, ppGranted);
    } GetPermissionsArg;

    static void GetGrantedPermissions(const GetPermissionsArg* arg);

    typedef struct _GetPublicKeyArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,  pThis);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,  pContainer);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF, pArray);
        DECLARE_ECALL_I4_ARG(INT32,             bExported);
    } GetPublicKeyArgs;

    typedef struct _NoArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,  pThis);
    } NoArgs;

    static LPVOID __stdcall GetPublicKey(GetPublicKeyArgs *args);

    typedef struct _CreateFromUrlArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,  url);
    } CreateFromUrlArgs;

    static LPVOID __stdcall CreateFromUrl(_CreateFromUrlArgs *args);

    typedef struct _GetLongPathNameArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,  shortPath);
    } GetLongPathNameArgs;

    static LPVOID __stdcall EcallGetLongPathName(_GetLongPathNameArgs *args);

    static DWORD IsSecurityOnNative(void *pParameters);
    static DWORD GetGlobalSecurity(void *pParameters);

    static BOOL SkipAndFindFunctionInfo(INT32, MethodDesc**, OBJECTREF**, AppDomain **ppAppDomain = NULL);
    static BOOL SkipAndFindFunctionInfo(StackCrawlMark*, MethodDesc**, OBJECTREF**, AppDomain **ppAppDomain = NULL);

    static Stub* CreateStub(StubLinker *pstublinker, 
                            MethodDesc* pMD, 
                            DWORD dwDeclFlags,
                            Stub* pRealStub, 
                            LPVOID pRealAddr);

    static void DoDeclarativeActions(MethodDesc *pMD, DeclActionInfo *pActions, LPVOID pSecObj);

    static OBJECTREF ResolvePolicy(OBJECTREF evidence, OBJECTREF reqdPset, OBJECTREF optPset,
                                   OBJECTREF denyPset, OBJECTREF* grantdenied, int* grantIsUnrestricted, BOOL checkExecutionPermission);

    static int LazyHasExecutionRights( OBJECTREF evidence );

    // Given a site / url, the uniqu id will be returned

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, url);
    } _GetSecurityId;

    static LPVOID __stdcall GetSecurityId(_GetSecurityId *args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, path);
    } _LocalDrive;

    static BOOL __stdcall LocalDrive(_LocalDrive *args);

    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, driveLetter);
    } _GetDeviceName;

    static LPVOID __stdcall GetDeviceName(_GetDeviceName *args);


    typedef struct {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, msg);
    } _Log;

    static VOID __stdcall Log(_Log *args);

    ////////////////////////////////////////////////////////////////////////
    //
    // This function does not cause a Resolve().
    // The result of this function could change from FALSE ==> TRUE
    // after a Resolve() is called.
    // It will never change from TRUE ==> FALSE
    //
    ////////////////////////////////////////////////////////////////////////
    
    static inline BOOL LazyCanSkipVerification(Module *pModule)
    {
        return _CanSkipVerification(pModule->GetAssembly(), TRUE);
    }

    static BOOL QuickCanSkipVerification(Module *pModule);

    static inline BOOL CanSkipVerification(Assembly * pAssembly)
    {
        return _CanSkipVerification(pAssembly, FALSE);
    }

    // @TODO: Remove this overload. It is only needed to minimize change in Everett
    static inline BOOL CanSkipVerification(Module *pModule)
    {
        return _CanSkipVerification(pModule->GetAssembly(), FALSE);
    }

    static BOOL CanCallUnmanagedCode(Module *pModule);

    static BOOL AppDomainCanCallUnmanagedCode(OBJECTREF *pThrowable);

    static inline BOOL IsExecutionPermissionCheckEnabled()
    {
        return (s_dwGlobalSettings & CORSETTING_EXECUTION_PERMISSION_CHECK_DISABLED) == 0;
    }

    static void InitSigs();

#ifdef FCALLAVAILABLE
    static FCDECL1(void, SetOverridesCount, DWORD numAccessOverrides);
    static FCDECL0(DWORD, IncrementOverridesCount);
    static FCDECL0(DWORD, DecrementOverridesCount);
#endif

    static LPVOID __stdcall GetEvidence(NoArgs *args);

    static inline BOOL CheckGrantSets(INT64 *pArgs)
    {
        Security::InitSecurity();

        return (BOOL)s_stdData.pMethCheckGrantSets->Call(pArgs);
    }

    static BOOL CanLoadUnverifiableAssembly( PEFile* pFile, OBJECTREF* pExtraEvidence, BOOL fQuickCheckOnly, BOOL*pfPreBindAllowed );

    static DWORD GetLongPathName( LPCWSTR lpShortPath, LPWSTR lpLongPath, DWORD cchLongPath);

    static inline BOOL MethodIsVisibleOutsideItsAssembly(
                DWORD dwMethodAttr, DWORD dwClassAttr)
    {
        return (MethodIsVisibleOutsideItsAssembly(dwMethodAttr) &&
                ClassIsVisibleOutsideItsAssembly(dwClassAttr));
    }

    static inline BOOL MethodIsVisibleOutsideItsAssembly(DWORD dwMethodAttr)
    {
        return ( IsMdPublic(dwMethodAttr)    || 
                 IsMdFamORAssem(dwMethodAttr)||
                 IsMdFamily(dwMethodAttr) );
    }

    static inline BOOL ClassIsVisibleOutsideItsAssembly(DWORD dwClassAttr)
    {
        return ( IsTdPublic(dwClassAttr)      || 
                 IsTdNestedPublic(dwClassAttr)||
                 IsTdNestedFamily(dwClassAttr)||
                 IsTdNestedFamORAssem(dwClassAttr) );
    }

    static BOOL DoUntrustedCallerChecks(
        Assembly *pCaller, MethodDesc *pCalee, OBJECTREF *pThrowable, 
        BOOL fFullStackWalk);

private:
    static HMODULE s_kernelHandle;
    static BOOL s_getLongPathNameWide;
    static void* s_getLongPathNameFunc;

    static BOOL _CanSkipVerification(Assembly * pAssembly, BOOL fLazy);
    static void _GetSharedPermissionInstance(OBJECTREF *perm, int index);
    static DeclActionInfo *DetectDeclActions(MethodDesc *pMeth, DWORD dwDeclFlags);
};

struct SharedPermissionObjects
{
    OBJECTHANDLE        hPermissionObject;  // Commonly used Permission Object
    BinderClassID       idClass;            // ID of class
    BinderMethodID      idConstructor;      // ID of constructor to call      
    DWORD               dwPermissionFlag;   // Flag needed by the constructors
                                            // Only a single argument is assumed !
};

const SharedPermissionObjects g_rPermObjectsTemplate[] =
{
    {NULL, CLASS__SECURITY_PERMISSION, METHOD__SECURITY_PERMISSION__CTOR, SECURITY_PERMISSION_UNMANAGEDCODE },
    {NULL, CLASS__SECURITY_PERMISSION, METHOD__SECURITY_PERMISSION__CTOR, SECURITY_PERMISSION_SKIPVERIFICATION },
    {NULL, CLASS__REFLECTION_PERMISSION, METHOD__REFLECTION_PERMISSION__CTOR, REFLECTION_PERMISSION_TYPEINFO },
    {NULL, CLASS__SECURITY_PERMISSION, METHOD__SECURITY_PERMISSION__CTOR, SECURITY_PERMISSION_ASSERTION },
    {NULL, CLASS__REFLECTION_PERMISSION, METHOD__REFLECTION_PERMISSION__CTOR, REFLECTION_PERMISSION_MEMBERACCESS },

    {NULL, CLASS__SECURITY_PERMISSION, METHOD__SECURITY_PERMISSION__CTOR, SECURITY_PERMISSION_SERIALIZATIONFORMATTER},   // Serialization permission. Used in managed code and found in an array in CodeAccessPermission.cs
    {NULL, CLASS__NIL, METHOD__NIL, NULL},    // Reflection Emit perm. Used in managed code and found in an array in CodeAccessPermission.cs
    {NULL, CLASS__PERMISSION_SET, METHOD__PERMISSION_SET__CTOR, PERMISSION_SET_FULLTRUST},    // PermissionSet, FullTrust
    {NULL, CLASS__SECURITY_PERMISSION, METHOD__SECURITY_PERMISSION__CTOR, SECURITY_PERMISSION_BINDINGREDIRECTS }
};

// Class holding a grab bag of security stuff we need on a per-appdomain basis.
struct SecurityContext
{
    SharedPermissionObjects     m_rPermObjects[NUM_PERM_OBJECTS];
    CQuickArray<OBJECTHANDLE>   m_rCachedPsets;
    CRITICAL_SECTION            m_sAssembliesLock;
    AssemblySecurityDescriptor *m_pAssemblies;
    size_t                      m_nCachedPsetsSize;

    SecurityContext() :
        m_nCachedPsetsSize(0)
    {
        memcpy(m_rPermObjects, g_rPermObjectsTemplate, sizeof(m_rPermObjects));
        InitializeCriticalSection(&m_sAssembliesLock);
        m_pAssemblies = NULL;
    }

    ~SecurityContext()
    {
        DeleteCriticalSection(&m_sAssembliesLock);
        m_rCachedPsets.~CQuickArray<OBJECTHANDLE>();
    }
};

///////////////////////////////////////////////////////////////////////////////
//
//      [SecurityDescriptor]
//      |
//      +----[ApplicationSecurityDescriptor]
//      |
//      +----[AssemblySecurityDescriptor]
//      |
//      +----[NativeSecurityDescriptor]
//
///////////////////////////////////////////////////////////////////////////////
//
// A Security Descriptor is placed on AppDomain and Assembly (Unmanged) objects.
// AppDomain and Assembly could be from different zones.
// Security Descriptor could also be placed on a native frame.
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// SecurityDescriptor is the base class for all security descriptors.
// Extend this class to implement SecurityDescriptors for Assemblies and
// AppDomains.
//
///////////////////////////////////////////////////////////////////////////////

class SecurityDescriptor
{
    friend ApplicationSecurityDescriptor;   // Bug in VC6 ? Wont allow AppSecDesc to access m_pNext
    friend SharedSecurityDescriptor;
public:

    // @todo: remove these when appdomain unloading is functional (so assembly
    // security descriptors don't get leaked and trip the debugging allocator
    // leak detection).
    void *operator new(size_t size) {return LocalAlloc(LMEM_FIXED, size); }
    void operator delete(void *p) { if (p != NULL) LocalFree(p); }

    SecurityDescriptor(AppDomain *pAppDomain, Assembly *pAssembly) :
        m_dwProperties(0),
        m_pNext(NULL),
        m_pPolicyLoadNext(NULL),
        m_pAppDomain(pAppDomain),
        m_pAssem(pAssembly)
    {
        THROWSCOMPLUSEXCEPTION();

        m_hRequiredPermissionSet    = pAppDomain->CreateHandle(NULL);
        m_hOptionalPermissionSet    = pAppDomain->CreateHandle(NULL);
        m_hDeniedPermissionSet      = pAppDomain->CreateHandle(NULL);
        m_hGrantedPermissionSet     = pAppDomain->CreateHandle(NULL);
        m_hGrantDeniedPermissionSet = pAppDomain->CreateHandle(NULL);
        m_hAdditionalEvidence       = pAppDomain->CreateHandle(NULL);

        if (m_hRequiredPermissionSet == NULL ||
            m_hOptionalPermissionSet == NULL ||
            m_hDeniedPermissionSet == NULL ||
            m_hGrantedPermissionSet == NULL ||
            m_hGrantDeniedPermissionSet == NULL ||
            m_hAdditionalEvidence == NULL)
            COMPlusThrowOM();
    }

    inline void SetRequestedPermissionSet(OBJECTREF RequiredPermissionSet,
                                          OBJECTREF OptionalPermissionSet,
                                          OBJECTREF DeniedPermissionSet)
    {
        StoreObjectInHandle(m_hRequiredPermissionSet, RequiredPermissionSet);
        StoreObjectInHandle(m_hOptionalPermissionSet, OptionalPermissionSet);
        StoreObjectInHandle(m_hDeniedPermissionSet, DeniedPermissionSet);
    }

    OBJECTREF GetGrantedPermissionSet(OBJECTREF* DeniedPermissions);

    // This method will return TRUE if this object is fully trusted.
    BOOL IsFullyTrusted( BOOL lazy = FALSE );

    // Overide this method to Resolve the granted permission.
    virtual void Resolve();
    virtual void ResolveWorker();
    BOOL CheckQuickCache( COMSecurityConfig::QuickCacheEntryType all, COMSecurityConfig::QuickCacheEntryType* zoneTable, DWORD successFlags = 0 );

    inline void SetGrantedPermissionSet(OBJECTREF GrantedPermissionSet, OBJECTREF DeniedPermissionSet)
    {
        if (GrantedPermissionSet == NULL)
            GrantedPermissionSet = SecurityHelper::CreatePermissionSet(FALSE);

        StoreObjectInHandle(m_hGrantedPermissionSet, GrantedPermissionSet);
        StoreObjectInHandle(m_hGrantDeniedPermissionSet, DeniedPermissionSet);
        SetProperties(CORSEC_RESOLVED);
    }

    inline void SetAdditionalEvidence(OBJECTREF evidence)
    {
        StoreObjectInHandle(m_hAdditionalEvidence, evidence);
    }

    inline OBJECTREF GetAdditionalEvidence(void)
    {
        return ObjectFromHandle(m_hAdditionalEvidence);
    }

    inline void SetEvidence(OBJECTREF evidence)
    {
        _ASSERTE(evidence);
        StoreObjectInHandle(m_hAdditionalEvidence, evidence);
        SetProperties(CORSEC_EVIDENCE_COMPUTED);
    }

    // This will make the object fully trusted.
    // Invoking this method for the wrong object will open up a HUGE security
    // hole. So make sure that the caller knows for sure that this object is
    // fully trusted.
    inline MarkAsFullyTrusted()
    {
        SetProperties(CORSEC_RESOLVED|CORSEC_FULLY_TRUSTED);
    }

    // This method is for testing only. Do not use it for anything else, it's
    // inherently dangerous.
    inline void ResetResolved()
    {
        m_dwProperties = 0;
    }

    // Overide this method to return the requested PermissionSet
    // The default implementation will return an unrestricted permission set
    virtual OBJECTREF GetRequestedPermissionSet(OBJECTREF *pOptionalPermissionSet,
                                                OBJECTREF *pDeniedPermissionSet,
                                                PermissionRequestSpecialFlags *pSpecialFlags = NULL,
                                                BOOL fCreate = TRUE);

    // Override this method to return the Evidence
    virtual OBJECTREF GetEvidence() = 0;
    virtual DWORD GetZone() = 0;

    inline BOOL GetProperties(DWORD dwMask) const
    {
        return ((m_dwProperties & dwMask) != 0);
    }
    
    inline void SetDefaultAppDomainProperty()
    {
        m_dwProperties |= CORSEC_DEFAULT_APPDOMAIN;
    }

    inline BOOL IsDefaultAppDomain()
    {
        return ((m_dwProperties & CORSEC_DEFAULT_APPDOMAIN) != 0);
    }

    // Checks for security permission for SkipVerification , PInvoke etc.
    BOOL        CheckSecurityPermission(int index);

    ////////////////////////////////////////////////////////////////////////
    //
    // This function does not cause a Resolve().
    // The result of this function could change from FALSE ==> TRUE
    // after a Resolve() is called.
    // It will never change from TRUE ==> FALSE
    //
    ////////////////////////////////////////////////////////////////////////

    // @TODO: Security::LazyCanSkipVerification calls SecurityDescriptor::QuickCanSkipVerification
    // Need to name these better
    BOOL QuickCanSkipVerification();

    BOOL LazyCanSkipVerification() const
    {
        return (GetSelectedProperties(CORSEC_SYSTEM_CLASSES|
                                     CORSEC_FULLY_TRUSTED|
                                     CORSEC_SKIP_VERIFICATION) != 0);
    }

    BOOL LazyCanCallUnmanagedCode() const
    {
        return (GetSelectedProperties(CORSEC_SYSTEM_CLASSES|
                                     CORSEC_FULLY_TRUSTED|
                                     CORSEC_CALL_UNMANAGEDCODE) != 0);
    }

    BOOL AllowBindingRedirects();

    BOOL CanSkipVerification();

    BOOL CanCallUnmanagedCode(OBJECTREF *pThrowable = NULL);

    BOOL CanRetrieveTypeInformation();

    BOOL IsResolved() const
    {
        return GetProperties(CORSEC_RESOLVED);
    }

    bool IsSystem();

    static BOOL QuickCacheEnabled( void )
    {
        return s_quickCacheEnabled;
    }

    static void DisableQuickCache( void )
    {
        s_quickCacheEnabled = FALSE;
    }

    virtual BOOL CheckExecutionPermission( void ) = 0;

protected:

    inline DWORD GetSelectedProperties(DWORD dwMask) const
    {
        return (m_dwProperties & dwMask);
    }

    inline void SetProperties(DWORD dwMask)
    {
        FastInterlockOr(&m_dwProperties, dwMask);
    }

    inline void ResetProperties(DWORD dwMask)
    {
        FastInterlockAnd(&m_dwProperties, ~dwMask);
    }


    OBJECTHANDLE m_hRequiredPermissionSet;  // Required Requested Permissions
    OBJECTHANDLE m_hOptionalPermissionSet;  // Optional Requested Permissions
    OBJECTHANDLE m_hDeniedPermissionSet;    // Denied Permissions
    PermissionRequestSpecialFlags m_SpecialFlags; // Special flags associated with the request
    OBJECTHANDLE m_hAdditionalEvidence;     // Evidence Object

    // Next sec desc not yet added to the AppDomain level PermissionListSet
    SecurityDescriptor *m_pNext;

    // Next sec desc not yet re-resolved
    SecurityDescriptor *m_pPolicyLoadNext;

    // The unmanaged Assembly object
    Assembly    *m_pAssem;          

    // The AppDomain context
    AppDomain   *m_pAppDomain;

private:

    OBJECTHANDLE m_hGrantedPermissionSet;   // Granted Permission
    OBJECTHANDLE m_hGrantDeniedPermissionSet;// Specifically Denied Permissions
    DWORD        m_dwProperties;            // Properties for this object
    static BOOL  s_quickCacheEnabled;

#ifdef _SECURITY_FRAME_FOR_DISPEX_CALLS
protected:
    SecurityDescriptor() { memset(this, 0, sizeof(SecurityDescriptor)); }
#endif  // _SECURITY_FRAME_FOR_DISPEX_CALLS
};

class ApplicationSecurityDescriptor : public SecurityDescriptor
{

public:

    ApplicationSecurityDescriptor(AppDomain *pAppDomain):
        SecurityDescriptor(pAppDomain, NULL),
        m_pNewSecDesc(NULL),
        m_pPolicyLoadSecDesc(NULL),
        m_dwOptimizationLevel(0),
        m_fInitialised(FALSE),
        m_fEveryoneFullyTrusted(TRUE),
        m_dTimeStamp(0),
        m_LockForAssemblyList("DomainPermissionListSet", CrstPermissionLoad),
        m_dNumDemands(0),
        m_fPLSIsBusy(FALSE)
    {
        ResetStatusOf(ALL_STATUS_FLAGS);
        m_hDomainPermissionListSet = pAppDomain->CreateHandle(NULL);
    }

    // Called everytime an AssemblySecurityDescriptor or 
    // an ApplicationSecurityDescriptor with zone other than NoZone is created
    VOID AddNewSecDesc(SecurityDescriptor *pNewSecDescriptor);

    // Called wheneveran AssemblySecurityDescriptor for this domain is destroyed
    VOID RemoveSecDesc(SecurityDescriptor *pSecDescriptor);

    // This will re-resolve any assemblies that were loaded during the policy resolve.
    VOID ResolveLoadList( void );

    VOID EnableOptimization()
    {
        FastInterlockDecrement((LONG*)&m_dwOptimizationLevel);
    }

    VOID DisableOptimization()
    {
        FastInterlockIncrement((LONG*)&m_dwOptimizationLevel);
    }

    BOOL IsOptimizationEnabled( )
    {
        return m_dwOptimizationLevel == 0;
    }

    static BOOL CheckStatusOf(DWORD what)
    {
        DWORD   dwAppDomainIndex = 0;
        Thread *pThread = GetThread();
        AppDomain *pDomain = NULL;

        DWORD numDomains = pThread->GetNumAppDomainsOnThread();
        // There may be some domains we have no idea about. Just return FALSE
        if (!pThread->GetAppDomainStack().IsWellFormed())
            return FALSE;

        if (numDomains == 1)
        {
            pDomain = pThread->GetDomain();
            _ASSERTE(pDomain);

            ApplicationSecurityDescriptor *currAppSecDesc = pDomain->GetSecurityDescriptor();
            _ASSERTE(currAppSecDesc);
            if (currAppSecDesc == NULL)
                return FALSE;

            if (!currAppSecDesc->CheckDomainWideFlag(what))
                return FALSE;

            return TRUE;
        }

        _ASSERTE(SystemDomain::System() && "SystemDomain not yet created!");
        _ASSERTE(numDomains <= MAX_APPDOMAINS_TRACKED );

        pThread->InitDomainIteration(&dwAppDomainIndex);

        while ((pDomain = pThread->GetNextDomainOnStack(&dwAppDomainIndex)) != NULL)
        {

            ApplicationSecurityDescriptor *currAppSecDesc = pDomain->GetSecurityDescriptor();
            _ASSERTE(currAppSecDesc);
            if (currAppSecDesc == NULL)
                return FALSE;

            if (!currAppSecDesc->CheckDomainWideFlag(what))
                return FALSE;

        }

        // If we got here, all domains on the thread passed the test
        return TRUE;
    }

    // Check if we are currently in a "fully trusted" environment
    // or if unmanaged code access is allowed at this time
    BOOL CheckDomainWideFlag(DWORD what)
    {
        switch(what)
        {
        case EVERYONE_FULLY_TRUSTED:
        case SECURITY_UNMANAGED_CODE:
        case SECURITY_SKIP_VER:
        case REFLECTION_TYPE_INFO:
        case REFLECTION_MEMBER_ACCESS:
        case SECURITY_SERIALIZATION:
        case REFLECTION_EMIT:
        case SECURITY_FULL_TRUST:
        {
            DWORD index = 1 << what;
            return (m_dwDomainWideFlags & index);
            break;
        }
        default:
            _ASSERTE(!"Unknown option in ApplicationSecurityDescriptor::CheckStatusOf");
            return FALSE;
            break;
        }
    }

    static void SetStatusOf(DWORD what, long startTimeStamp)
    {
        DWORD   dwAppDomainIndex = 0;
        Thread *pThread = GetThread();
        AppDomain *pDomain = NULL;

        // There may be some domains we have no idea about. Do not make attempt to set the flag on any domain
        if (!pThread->GetAppDomainStack().IsWellFormed())
            return;

        s_LockForAppwideFlags->Enter();

        if (startTimeStamp == s_iAppWideTimeStamp)
        {
            _ASSERTE(SystemDomain::System() && "SystemDomain not yet created!");
            _ASSERTE( pThread->GetNumAppDomainsOnThread() < MAX_APPDOMAINS_TRACKED );

            pThread->InitDomainIteration(&dwAppDomainIndex);

            while ((pDomain = pThread->GetNextDomainOnStack(&dwAppDomainIndex)) != NULL)
            {

                ApplicationSecurityDescriptor *currAppSecDesc = pDomain->GetSecurityDescriptor();
                _ASSERTE(currAppSecDesc);
                if (currAppSecDesc == NULL)
                    break;

                currAppSecDesc->SetDomainWideFlagHaveLock(what);

            }

        }

        s_LockForAppwideFlags->Leave();
    }


    // s_LockForAppwideFlags has to be held while calling this
    void SetDomainWideFlagHaveLock(DWORD what)
    {
        switch(what)
        {
        case EVERYONE_FULLY_TRUSTED:
        case SECURITY_UNMANAGED_CODE:
        case SECURITY_SKIP_VER:
        case REFLECTION_TYPE_INFO:
        case REFLECTION_MEMBER_ACCESS:
        case SECURITY_SERIALIZATION:
        case REFLECTION_EMIT:
        case SECURITY_FULL_TRUST:
        {
            DWORD index = 1 << what;
            m_dwDomainWideFlags |= index;
            break;
        }
        case ALL_STATUS_FLAGS:
            m_dwDomainWideFlags = 0xFFFFFFFF;
            break;
        default:
            _ASSERTE(!"Unknown option in ApplicationSecurityDescriptor::SetStatusOf");
            break;
        }

    }

    void ResetStatusOf(DWORD what)
    {
        // While the System Domain is being created, s_LockForAppwideFlags wouldnt be created yet
        // And there are no sync problems either
        if (s_LockForAppwideFlags)
            s_LockForAppwideFlags->Enter();

        switch(what)
        {
        case EVERYONE_FULLY_TRUSTED:
        case SECURITY_UNMANAGED_CODE:
        case SECURITY_SKIP_VER:
        case REFLECTION_TYPE_INFO:
        case REFLECTION_MEMBER_ACCESS:
        case SECURITY_SERIALIZATION:
        case REFLECTION_EMIT:
        case SECURITY_FULL_TRUST:
        {
            DWORD index = 1 << what;
            m_dwDomainWideFlags &= ~index;
            break;
        }
        case ALL_STATUS_FLAGS:
            m_dwDomainWideFlags = 0;
            break;
        default:
            _ASSERTE(!"Unknown option in ApplicationSecurityDescriptor::ResetStatusOf");
            break;
        }

        s_iAppWideTimeStamp++;

        if (s_LockForAppwideFlags)
            s_LockForAppwideFlags->Leave();
    }

    // Returns the domain permission list set against which a Demand can be made
    // pStatus - Look for constants defined elsewhere. Search for GetDomainPermissionListSet
#ifdef FCALLAVAILABLE
    static FCDECL4(Object*, GetDomainPermissionListSet, DWORD *pStatus, Object* demand, int capOrSet, DWORD whatPermission);
    // Update the domain permission list set with any new assemblies added
    static FCDECL1(LPVOID, UpdateDomainPermissionListSet, DWORD *pStatus);
#endif

    // These two do the actual work. The above FCALLs are just wrappers for managed code to call
    static LPVOID GetDomainPermissionListSetInner(DWORD *pStatus, OBJECTREF demand, MethodDesc *plsMethod, DWORD whatPermission = DEFAULT_FLAG);
    static LPVOID UpdateDomainPermissionListSetInner(DWORD *pStatus);
    static Object* GetDomainPermissionListSetForMultipleAppDomains (DWORD *pStatus, OBJECTREF demand, MethodDesc *plsMethod, DWORD whatPermission = DEFAULT_FLAG);
    
    virtual OBJECTREF GetEvidence();
    virtual DWORD GetZone();

    static long GetAppwideTimeStamp()
    {
        return s_iAppWideTimeStamp;
    }

    static BOOL AllDomainsOnStackFullyTrusted()
    {
        if (!Security::IsSecurityOn()) 
            return TRUE;    // All domains are fully trusted

        DWORD   dwAppDomainIndex = 0, status = CONTINUE;
        Thread *pThread = GetThread();
        AppDomain *pDomain = NULL;

        if (!pThread->GetAppDomainStack().IsWellFormed())
            return FALSE;

        _ASSERTE(SystemDomain::System() && "SystemDomain not yet created!");
        _ASSERTE( pThread->GetNumAppDomainsOnThread() <= MAX_APPDOMAINS_TRACKED );

        pThread->InitDomainIteration(&dwAppDomainIndex);

        while ((pDomain = pThread->GetNextDomainOnStack(&dwAppDomainIndex)) != NULL)
        {
            ApplicationSecurityDescriptor *currAppSecDesc = pDomain->GetSecurityDescriptor();
            if (currAppSecDesc == NULL)
                return FALSE;

            status = CONTINUE;
            currAppSecDesc->GetDomainPermissionListSetStatus(&status);

            if (status != FULLY_TRUSTED)
                return FALSE;
        }

        return TRUE;

    }

    static Crst *s_LockForAppwideFlags;     // For serializing update of appwide flags

    static DWORD s_dwSecurityOptThreshold;

    virtual BOOL CheckExecutionPermission( void )
    {
        return FALSE;
    }

private:

    OBJECTREF Init();

    DWORD GetNextTimeStamp()
    {
        m_dTimeStamp++;
#ifdef _DEBUG
        if (m_dTimeStamp > DOMAIN_PLS_TS_RANGE)
            LOG((LF_SECURITY, LL_INFO10, "PERF WARNING: ApplicationSecurityDescriptor : Timestamp hit DOMAIN_PLS_TS_RANGE ! Too many assemblies ?"));
#endif
        return m_dTimeStamp;
    }
    
    // Following are helpers to their "Inner" counterparts
    Object* GetDomainPermissionListSetStatus(DWORD *pStatus);
    LPVOID UpdateDomainPermissionListSetStatus(DWORD *pStatus);
    
    // Intersection of granted/denied permissions of all assemblies in domain
    OBJECTHANDLE    m_hDomainPermissionListSet; 
    // Use the optimization if level equals zero
    DWORD m_dwOptimizationLevel;
    // Linked list of SecurityDescriptors, that are not yet in the intersected set
    SecurityDescriptor *m_pNewSecDesc;
    // Linked list of SecurityDescriptors that were loaded during the most recent policy load
    SecurityDescriptor *m_pPolicyLoadSecDesc;
    // This descriptor is initialized.
    BOOL m_fInitialised;
    // All assemblies in current domain are fully trusted
    BOOL m_fEveryoneFullyTrusted;
    // Timestamp. works with above lock
    DWORD m_dTimeStamp;
    // To serialize access to the linked list of to-be-added assemblies
    Crst m_LockForAssemblyList;

    // Number of Demands made till now. A threshold is used so that they dont have overhead 
    // of DomainPermissionListSet thing..
    DWORD m_dNumDemands;
    BOOL m_fPLSIsBusy;

    static long     s_iAppWideTimeStamp;

    // The bits represent the status of security checks on some specific permissions within this domain
    DWORD   m_dwDomainWideFlags;

    // m_dwDomainWideFlags bit map
    // Bit 0 = Unmanaged Code access permission. Accessed via SECURITY_UNMANAGED_CODE
    // Bit 1 = Skip verification permission. SECURITY_SKIP_VER
    // Bit 2 = Permission to Reflect over types. REFLECTION_TYPE_INFO
    // Bit 3 = Permission to Assert. SECURITY_ASSERT
    // Bit 4 = Permission to invoke methods. REFLECTION_MEMBER_ACCESS
    // Bit 7 = PermissionSet, fulltrust SECURITY_FULL_TRUST
    // Bit 31 = Full Trust across the app domain. EVERYONE_FULLY_TRUSTED


};

#define MAX_PASSED_DEMANDS 10

class AssemblySecurityDescriptor : public SecurityDescriptor
{
    friend SecurityDescriptor;
    friend SharedSecurityDescriptor;
public:
    
    AssemblySecurityDescriptor(AppDomain *pDomain) :
        SecurityDescriptor(pDomain, NULL),
        m_pSharedSecDesc(NULL),
        m_pSignature(NULL),
        m_dwNumPassedDemands(0),
        m_pNextAssembly(NULL)
    {
    }

    virtual ~AssemblySecurityDescriptor();

    AssemblySecurityDescriptor *Init(Assembly *pAssembly, bool fLink = true);

    inline void AddDescriptorToDomainList()
    {
        if (Security::IsSecurityOn() && !IsSystem())
        {
            ApplicationSecurityDescriptor *asd = m_pAppDomain->GetSecurityDescriptor();
            if (asd)
                asd->AddNewSecDesc(this);
        }
    }

    inline SharedSecurityDescriptor *GetSharedSecDesc() { return m_pSharedSecDesc; }

    inline BOOL IsSigned() 
    {
        LoadSignature();
        return (m_pSignature != NULL);
    }

    BOOL IsSystemClasses() const
    {
        return GetProperties(CORSEC_SYSTEM_CLASSES);
    }

    void SetSystemClasses()
    {
        // System classes are always fully trusted as well.
        SetProperties(CORSEC_SYSTEM_CLASSES|
                      CORSEC_FULLY_TRUSTED|
                      CORSEC_SKIP_VERIFICATION|
                      CORSEC_CALL_UNMANAGEDCODE);
    }

    HRESULT LoadSignature(COR_TRUST **ppSignature = NULL);

    void SetSecurity(bool mode)
    {
        if(mode == true) {
            SetSystemClasses();
            return;
        }

        if (!Security::IsSecurityOn())
        {
            SetProperties(CORSEC_SKIP_VERIFICATION|CORSEC_CALL_UNMANAGEDCODE);
        }
    }

    void SetCanAssert()
    {
        SetProperties(CORSEC_CAN_ASSERT);
    }

    BOOL CanAssert() const
    {
        return GetProperties(CORSEC_CAN_ASSERT);
    }

    void SetAssertPermissionChecked()
    {
        SetProperties(CORSEC_ASSERT_PERM_CHECKED);
    }

    BOOL AssertPermissionChecked() 
    {
        return GetProperties(CORSEC_ASSERT_PERM_CHECKED);
    }

    virtual OBJECTREF GetRequestedPermissionSet(OBJECTREF *pOptionalPermissionSet,
                                                OBJECTREF *pDeniedPermissionSet,
                                                PermissionRequestSpecialFlags *pSpecialFlags = NULL,
                                                BOOL fCreate = TRUE);

    virtual OBJECTREF GetEvidence();
    virtual DWORD GetZone();
    
    DWORD   m_arrPassedLinktimeDemands[MAX_PASSED_DEMANDS];
    DWORD   m_dwNumPassedDemands;

    AssemblySecurityDescriptor *GetNextDescInAppDomain() { return m_pNextAssembly; }
    void AddToAppDomainList();
    void RemoveFromAppDomainList();

    virtual BOOL CheckExecutionPermission( void )
    {
        return TRUE;
    }

protected:
    
    virtual OBJECTREF GetSerializedEvidence();

private:

    COR_TRUST                  *m_pSignature;      // Contains the publisher, requested permission
    SharedSecurityDescriptor   *m_pSharedSecDesc;  // Shared state for assemblies loaded into multiple appdomains
    AssemblySecurityDescriptor *m_pNextAssembly;   // Pointer to next assembly loaded in same context
};

#ifdef _SECURITY_FRAME_FOR_DISPEX_CALLS
// used by com / native clients who don't have an assembly.
class NativeSecurityDescriptor : public SecurityDescriptor
{
public:
    NativeSecurityDescriptor() : m_Zone(0), SecurityDescriptor() {}

    virtual void Resolve();

private:
    DWORD m_Zone;
};
#endif  // _SECURITY_FRAME_FOR_DISPEX_CALLS

// This really isn't in the SecurityDescriptor hierarchy, per-se. It's attached
// to the unmanaged assembly object and used to store common information when
// the assembly is shared across multiple appdomains.
class SharedSecurityDescriptor : public SimpleRWLock
{
public:
    SharedSecurityDescriptor(Assembly *pAssembly);
    ~SharedSecurityDescriptor();

    inline void SetManifestFile(PEFile *pFile) { m_pManifestFile = pFile; }
    inline PEFile *GetManifestFile() { return m_pManifestFile; }

    // NOTE: The following list manipulation routines assume you have
    // synchronized access to the assemblies and appdomains involved. This list
    // access is synchronized for you so that multi-threaded operation is safe,
    // but if you look up a security descriptor for a given appdomain, it's your
    // responsibility to make sure that appdomain (and hence the descriptor)
    // doesn't go away underneath you.

    // Insert a new assembly security descriptor into the list. Return true is
    // successful, false if there was a duplicate (another descriptor for the
    // same appdomain).
    bool InsertSecDesc(AssemblySecurityDescriptor *pSecDesc);

    // Remove an assembly security descriptor from the list.
    void RemoveSecDesc(AssemblySecurityDescriptor *pSecDesc);

    // Find the assembly security descriptor associated with a particular
    // appdomain.
    AssemblySecurityDescriptor *FindSecDesc(AppDomain *pDomain);

    // All policy resolution is funnelled through the shared descriptor so we
    // can guarantee everyone's using the same grant/denied sets.
    void Resolve(AssemblySecurityDescriptor *pSecDesc = NULL);

    // Get the grant/deny sets common to all assembly instances (marshaled to
    // the calling appdomain context).
    OBJECTREF GetGrantedPermissionSet(OBJECTREF* pDeniedPermissions);

    // Is this assembly a system assembly?
    bool IsSystem() { return m_fIsSystem; }
    void SetSystem() { m_fIsSystem = true; }

    BOOL IsFullyTrusted( BOOL lazy = FALSE );

    // We record whether a resolved grant set was modified by additional
    // evidence or appdomain policy on one of the assembly loads. (If so, we
    // have to be very careful when loading new assemblies to verify that the
    // grant set will remain the same on resolution).
    bool IsModifiedGrant() { return m_fModifiedGrant; }
    void SetModifiedGrant() { m_fModifiedGrant = true; }

    // Checks whether policy has been resolved and needs to be serialized since
    // the appdomain context it was resolved in is being removed.
    bool MarshalGrantSet(AppDomain *pDomain);

    // Forced the shared state to resolved. Only call this if you *exactly* what
    // you're doing.
    bool IsResolved() { return m_fResolved; }
    void SetResolved() { m_fResolved = true; }

    Assembly* GetAssembly( void ) { return m_pAssembly; }

private:

    static BOOL TrustMeIAmSafe(void *pLock) {
        return TRUE;
    }

    static BOOL IsDuplicateValue (UPTR pSecDesc1, UPTR pSecDesc2) {
        if (pSecDesc1 == NULL) {
            // If there is no value to compare against, then always succeed the comparison.
            return TRUE;
        }
        else {
            // Otherwise compare the AssemblySecurityDescriptor pointers.
            return (pSecDesc1 << 1) == pSecDesc2;
        }
    }

    // We need a helper to get around exception handling and C++ destructor
    // constraints
    AssemblySecurityDescriptor* FindResolvedSecDesc();

    // Once policy resolution has taken place, make sure that the results are
    // serialized ready for use in other appdomain contexts.
    void EnsureGrantSetSerialized(AssemblySecurityDescriptor *pSecDesc = NULL);

    // In case where policy resolution has been run in a different appdomain
    // context, copy the results back into the appdomain that the given security
    // descriptor resides in.
    void UpdateGrantSet(AssemblySecurityDescriptor *pSecDesc);

    // Unmanaged assembly this descriptor is attached to.
    Assembly           *m_pAssembly;

    // Manifest file used by the assembly (can't get it through the assembly
    // object because it's not always guaranteed to be set there in some of the
    // cirumstances we're called from).
    PEFile             *m_pManifestFile;

    // List of assembly security descriptors.
    PtrHashMap m_asmDescsMap;
    AssemblySecurityDescriptor *m_defaultDesc;

    // System assemblies are treated specially, they only have one
    // AssemblySecurityDescriptor because they're only loaded once.
    bool                m_fIsSystem;

    // We record whether a resolved grant set was modified by additional
    // evidence or appdomain policy on one of the assembly loads. (If so, we
    // have to be very careful when loading new assemblies to verify that the
    // grant set will remain the same on resolution).
    bool                m_fModifiedGrant;

    // Cached copies of grant and denied sets. These are stored serialized
    // (since this is a domain neutral format). They are lazily generated (the
    // first appdomain to resolve will build its own in-memory copy, the second
    // appdomain resolving will copy the grant/denied sets by serializing /
    // deserializing the sets). Additionally, if only one appdomain has resolved
    // and then unloads, it needs to serialize the grant set first. All this is
    // necessary since we must guarantee that the grant sets shared between the
    // different instances of the same assembly are alway identical (because we
    // share jitted code, and the jitted code has the results of link time
    // demands burned into it).
    BYTE               *m_pbGrantSetBlob;
    DWORD               m_cbGrantSetBlob;
    BYTE               *m_pbDeniedSetBlob;
    DWORD               m_cbDeniedSetBlob;

    // All policy resolution is funnelled through the shared descriptor so we
    // can guarantee everyone's using the same grant/denied sets.
    bool                m_fResolved;
    bool                m_fFullyTrusted;
    Thread             *m_pResolvingThread;
};

// The following template class exists to get around problems with using SEH
// round a new operator (the new creates a temporary destructor which is
// incompatible with SEH).
template <class T, class PT>
class AllocHelper
{
public:
    static T *Allocate(PT ptParam)
    {
        T *pNew = NULL;

        COMPLUS_TRY {
            pNew = AllocateHelper(ptParam);
        } COMPLUS_CATCH {
            pNew = NULL;
        } COMPLUS_END_CATCH

        return pNew;
    }

private:
    static T *AllocateHelper(PT ptParam)
    {
        THROWSCOMPLUSEXCEPTION();
        return new T(ptParam);
    }
};

typedef AllocHelper<AssemblySecurityDescriptor, AppDomain*> AssemSecDescHelper;
typedef AllocHelper<SharedSecurityDescriptor, Assembly*> SharedSecDescHelper;

#ifdef _DEBUG

#define DBG_TRACE_METHOD(cf)                                                \
    do {                                                                    \
        MethodDesc * __pFunc = cf -> GetFunction();                         \
        if (__pFunc) {                                                      \
            LOG((LF_SECURITY, LL_INFO1000,                                  \
                 "    Method: %s.%s\n",                                     \
                 (__pFunc->m_pszDebugClassName == NULL) ?                   \
                "<null>" : __pFunc->m_pszDebugClassName,                    \
                 __pFunc->GetName()));                                      \
        }                                                                   \
    } while (false)

#define DBG_TRACE_STACKWALK(msg, verbose) LOG((LF_SECURITY, (verbose) ? LL_INFO10000 : LL_INFO1000, msg))
#else //_DEBUG

#define DBG_TRACE_METHOD(cf)
#define DBG_TRACE_STACKWALK(msg, verbose)

#endif //_DEBUG


//
// Get and get the global security settings for the VM
//
HRESULT STDMETHODCALLTYPE
GetSecuritySettings(DWORD* dwState);

HRESULT STDMETHODCALLTYPE
SetSecuritySettings(DWORD dwState);

HRESULT STDMETHODCALLTYPE
SetSecurityFlags(DWORD dwMask, DWORD dwFlags);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\siginfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// siginfo.cpp
//
// Signature parsing code
//
#include "common.h"

#include "siginfo.hpp"
#include "clsload.hpp"
#include "vars.hpp"
#include "excep.h"
#include "gc.h"
#include "wsperf.h"
#include "field.h"
#include "COMVariant.h"    // for Element type to class lookup table.
#include "ExpandSig.h"
#include "EEconfig.h"


TypeHandle ElementTypeToTypeHandle(const CorElementType type)
{
    // @todo: there are some really rare cases (e.g. out of memory) where this could throw.
    // It seems a shame to push a handler just to catch them & return NULL.  Ideally
    // callers should allow a throw to happen

    TypeHandle th;

    COMPLUS_TRY
      {
        // returning inside try with finally is expensive, so fall through
        th = TypeHandle(g_Mscorlib.FetchElementType(type));
      }
    COMPLUS_CATCH
      {
        return TypeHandle();
      }
    COMPLUS_END_CATCH
    return th;
}

/*******************************************************************/
CorTypeInfo::CorTypeInfoEntry CorTypeInfo::info[] = { 
#define TYPEINFO(enumName,className,size,gcType,isEnreg,isArray,isPrim,isFloat, isModifier, isAlias) \
    { enumName, className, size, gcType, isEnreg, isArray, isPrim, isFloat, isModifier, isAlias },
#   include "corTypeInfo.h"
#   undef TYPEINFO
};

const int CorTypeInfo::infoSize = sizeof(CorTypeInfo::info) / sizeof(CorTypeInfo::info[0]);

/*******************************************************************/
/* static */
CorElementType CorTypeInfo::FindPrimitiveType(LPCUTF8 fullName) {

        // FIX this negects the R, I, U types
    for (int i =1; i < CorTypeInfo::infoSize; i++)
        if (info[i].className != 0 && strcmp(fullName, info[i].className) == 0)
            return(info[i].type);

    return(ELEMENT_TYPE_END);
}

/*******************************************************************/
/* static */
CorElementType CorTypeInfo::FindPrimitiveType(LPCUTF8 nameSpace, LPCUTF8 name) {

    if (strcmp(nameSpace, g_SystemNS))
        return(ELEMENT_TYPE_END);

    for (int i =1; i < CorTypeInfo::infoSize; i++) {    // can skip ELEMENT_TYPE_END
        _ASSERTE(info[i].className == 0 || strncmp(info[i].className, "System.", 7) == 0);
        if (info[i].className != 0 && strcmp(name, &info[i].className[7]) == 0)
            return(info[i].type);
    }

    return(ELEMENT_TYPE_END);
}

Crst *HardCodedMetaSig::m_pCrst = NULL;
BYTE  HardCodedMetaSig::m_CrstMemory[sizeof(Crst)];

/*static*/ BOOL HardCodedMetaSig::Init()
{
    return (NULL != (m_pCrst = new (&m_CrstMemory) Crst("HardCodedMetaSig", CrstSigConvert)));
}


#ifdef SHOULD_WE_CLEANUP
/*static*/ VOID HardCodedMetaSig::Terminate()
{
    delete m_pCrst;
}
#endif /* SHOULD_WE_CLEANUP */

const ElementTypeInfo gElementTypeInfo[] = {

#ifdef _DEBUG
#define DEFINEELEMENTTYPEINFO(etname, cbsize, gcness, isfp, inreg, base) {(int)(etname),cbsize,gcness,isfp,inreg,base},
#else
#define DEFINEELEMENTTYPEINFO(etname, cbsize, gcness, isfp, inreg, base) {cbsize,gcness,isfp,inreg,base},
#endif


// Meaning of columns:
//
//     name     - The checked build uses this to verify that the table is sorted
//                correctly. This is a lookup table that uses ELEMENT_TYPE_*
//                as an array index.
//
//     cbsize   - The byte size of this value as returned by SizeOf(). SPECIAL VALUE: -1
//                requires type-specific treatment.
//
//     gc       - 0    no embedded objectrefs
//                1    value is an objectref
//                2    value is an interior pointer - promote it but don't scan it
//                3    requires type-specific treatment
//
//
//     fp       - boolean: does this require special fpu treatment on return?
//
//     reg      - put in a register?
//
//                    name                         cbsize               gc      fp reg Base
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_END,            -1,             TYPE_GC_NONE, 0, 0,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_VOID,           0,              TYPE_GC_NONE, 0, 0,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_BOOLEAN,        1,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_CHAR,           2,              TYPE_GC_NONE, 0, 1,  1)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I1,             1,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U1,             1,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I2,             2,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U2,             2,              TYPE_GC_NONE, 0, 1,  1)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I4,             4,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U4,             4,              TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I8,             8,              TYPE_GC_NONE, 0, 0,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U8,             8,              TYPE_GC_NONE, 0, 0,  1)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_R4,             4,              TYPE_GC_NONE, 1, 0,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_R8,             8,              TYPE_GC_NONE, 1, 0,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_STRING,         sizeof(LPVOID), TYPE_GC_REF,  0, 1,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_PTR,            sizeof(LPVOID), TYPE_GC_NONE, 0, 1,  0)  

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_BYREF,          sizeof(LPVOID), TYPE_GC_BYREF, 0, 1, 0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_VALUETYPE,      -1,             TYPE_GC_OTHER, 0, 0,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_CLASS,          sizeof(LPVOID), TYPE_GC_REF,   0, 1,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_VAR,            sizeof(LPVOID), TYPE_GC_REF,   0, 1,  0)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_ARRAY,          sizeof(LPVOID), TYPE_GC_REF,  0, 1,  0)

// The following element used to be ELEMENT_TYPE_COPYCTOR, but it was removed, though the gap left.
//DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_COPYCTOR,       sizeof(LPVOID), TYPE_GC_BYREF, 0, 1,  0)       
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_ARRAY+1,        0,              TYPE_GC_NONE,  0, 0,  0)       

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_TYPEDBYREF,         sizeof(LPVOID)*2,TYPE_GC_BYREF, 0, 0,0)            
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_VALUEARRAY,     -1,             TYPE_GC_OTHER, 0, 0, 0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_I,              sizeof(LPVOID), TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_U,              sizeof(LPVOID), TYPE_GC_NONE, 0, 1,  1)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_R,              8,              TYPE_GC_NONE, 1, 0,  1)


DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_FNPTR,          sizeof(LPVOID), TYPE_GC_NONE, 0, 1,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_OBJECT,         sizeof(LPVOID), TYPE_GC_REF, 0, 1,  0)
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_SZARRAY,        sizeof(LPVOID), TYPE_GC_REF,  0, 1,  0)

// generic array have been removed. Fill the gap
//DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_GENERICARRAY,   sizeof(LPVOID), TYPE_GC_REF,  0, 1,  0) 
DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_SZARRAY+1,      0,              TYPE_GC_NONE, 0, 0,  0)       

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_CMOD_REQD,      -1,             TYPE_GC_NONE,  0, 1,  0)

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_CMOD_OPT,       -1,             TYPE_GC_NONE,  0, 1,  0)       

DEFINEELEMENTTYPEINFO(ELEMENT_TYPE_INTERNAL,       sizeof(LPVOID), TYPE_GC_NONE,  0, 0,  0)       
};


unsigned GetSizeForCorElementType(CorElementType etyp)
{
        _ASSERTE(gElementTypeInfo[etyp].m_elementType == etyp);
        return gElementTypeInfo[etyp].m_cbSize;
}

const ElementTypeInfo* GetElementTypeInfo(CorElementType etyp)
{
        _ASSERTE(gElementTypeInfo[etyp].m_elementType == etyp);
        return &gElementTypeInfo[etyp];
}

BOOL    IsFP(CorElementType etyp)
{
        _ASSERTE(gElementTypeInfo[etyp].m_elementType == etyp);
        return gElementTypeInfo[etyp].m_fp;
}

BOOL    IsBaseElementType(CorElementType etyp)
{
        _ASSERTE(gElementTypeInfo[etyp].m_elementType == etyp);
        return gElementTypeInfo[etyp].m_isBaseType;

}

// This skips one element and then checks for and skips a varargs sentinal.
VOID SigPointer::Skip()
{
    SkipExactlyOne();

    if (PeekData() == ELEMENT_TYPE_SENTINEL)
        GetData();
}

VOID SigPointer::SkipExactlyOne()
{
    ULONG typ;

    typ = GetElemType();

    if (!CorIsPrimitiveType((CorElementType)typ))
    {
        switch (typ)
        {
            default:
                _ASSERTE(!"Illegal or unimplement type in COM+ sig.");
                break;
            case ELEMENT_TYPE_VAR:
                GetData();      // Skip variable number
                break;
            case ELEMENT_TYPE_OBJECT:
            case ELEMENT_TYPE_STRING:
            case ELEMENT_TYPE_TYPEDBYREF:
            case ELEMENT_TYPE_U:
            case ELEMENT_TYPE_I:
            case ELEMENT_TYPE_R:
                break;

            case ELEMENT_TYPE_BYREF: //fallthru
            case ELEMENT_TYPE_PTR:
            case ELEMENT_TYPE_PINNED:
            case ELEMENT_TYPE_SZARRAY:
                SkipExactlyOne();              // Skip referenced type
                break;

            case ELEMENT_TYPE_VALUETYPE: //fallthru
            case ELEMENT_TYPE_CLASS:
                GetToken();          // Skip RID
                break;

            case ELEMENT_TYPE_VALUEARRAY: 
                SkipExactlyOne();         // Skip element type
                GetData();      // Skip array size
                break;

            case ELEMENT_TYPE_FNPTR: 
                SkipSignature();
                break;

            case ELEMENT_TYPE_ARRAY: 
                {
                    SkipExactlyOne();     // Skip element type
                    UINT32 rank = GetData();    // Get rank
                    if (rank)
                    {
                        UINT32 nsizes = GetData(); // Get # of sizes
                        while (nsizes--)
                        {
                            GetData();           // Skip size
                        }

                        UINT32 nlbounds = GetData(); // Get # of lower bounds
                        while (nlbounds--)
                        {
                            GetData();           // Skip lower bounds
                        }
                    }

                }
                break;

            case ELEMENT_TYPE_SENTINEL:
                break;
        }
    }
}

// Skip a sub signature (as immediately follows an ELEMENT_TYPE_FNPTR).
VOID SigPointer::SkipSignature()
{
    // Skip calling convention;
    ULONG uCallConv = GetData();
    _ASSERTE((uCallConv & IMAGE_CEE_CS_CALLCONV_MASK) != IMAGE_CEE_CS_CALLCONV_FIELD);

    // Get arg count;
    ULONG cArgs = GetData();

    // Skip return type;
    SkipExactlyOne();

    // Skip args.
    while (cArgs) {
        SkipExactlyOne();
        cArgs--;
    }
}


//------------------------------------------------------------------------
// Get info about single-dimensional arrays
//------------------------------------------------------------------------
VOID SigPointer::GetSDArrayElementProps(SigPointer *pElemType, ULONG *pElemCount) const
{
    SigPointer sp = *this;
    ULONG typ = sp.GetElemType();
    _ASSERTE(typ == ELEMENT_TYPE_VALUEARRAY || typ == ELEMENT_TYPE_SZARRAY);
    *pElemType = sp;
    sp.Skip();
    *pElemCount = sp.GetData();
}

//------------------------------------------------------------------
// Constructor.
//------------------------------------------------------------------

MetaSig::MetaSig(PCCOR_SIGNATURE szMetaSig, Module* pModule, 
                 BOOL fConvertSigAsVarArg, MetaSigKind kind)
{
#ifdef _DEBUG
    FillMemory(this, sizeof(*this), 0xcc);
#endif
    m_pModule = pModule;
    m_pszMetaSig = szMetaSig;
    SigPointer psig(szMetaSig);

    switch(kind)
    {
        case sigLocalVars:
        {
            m_CallConv = (BYTE)psig.GetCallingConvInfo(); // Store calling convention
            m_nArgs     = psig.GetData();  // Store number of arguments.
            m_pRetType = NULL;
            break;
        }
        case sigMember:
        {
            m_CallConv = (BYTE)psig.GetCallingConvInfo(); // Store calling convention
            m_nArgs     = psig.GetData();  // Store number of arguments.
            m_pRetType  = psig;
            psig.Skip();
            break;
        }
        case sigField:
        {
            m_CallConv = (BYTE)psig.GetCallingConvInfo(); // Store calling convention
            m_nArgs = 1; //There's only 1 'arg' - the type.
            m_pRetType = NULL;
            break;
        }
    }
    
    m_pStart    = psig;
    // used to treat some sigs as special case vararg
    // used by calli to unmanaged target
    m_fTreatAsVarArg = fConvertSigAsVarArg;

    // Intialize the actual sizes
    m_nActualStack = (UINT32) -1;
    m_nVirtualStack = (UINT32) -1;
    m_cbSigSize = (UINT32) -1;

    m_fCacheInitted = 0;
    // Reset the iterator fields
    Reset();
}

//------------------------------------------------------------------
// Constructor.  This is for use by reflection, to get a thread-safe
// copy of an ExpandSig, for invocation
//------------------------------------------------------------------

MetaSig::MetaSig(ExpandSig &shared)
{
    *this = shared.m_MetaSig;
}

void MetaSig::GetRawSig(BOOL fIsStatic, PCCOR_SIGNATURE *ppszMetaSig, DWORD *pcbSize)
{
    _ASSERTE(m_pRetType.GetPtr() != ((PCCOR_SIGNATURE)POISONC));
    if (NeedsSigWalk())
    ForceSigWalk(fIsStatic);
    _ASSERTE(!!fIsStatic == !!m_WalkStatic);    // booleanize

    *ppszMetaSig = m_pszMetaSig;
    *pcbSize = m_cbSigSize;
}


//------------------------------------------------------------------
// Returns type of current argument index. Returns ELEMENT_TYPE_END 
// if already past end of arguments.
//------------------------------------------------------------------
CorElementType MetaSig::PeekArg()
{
    if (m_iCurArg == m_nArgs)
    {
        return ELEMENT_TYPE_END;
    }
    else
    {
        CorElementType mt = m_pWalk.PeekElemType();
        return mt;
    }
}


//------------------------------------------------------------------
// Returns type of current argument, then advances the argument
// index. Returns ELEMENT_TYPE_END if already past end of arguments.
//------------------------------------------------------------------
CorElementType MetaSig::NextArg()
{
    m_pLastType = m_pWalk;
    if (m_iCurArg == m_nArgs)
    {
        return ELEMENT_TYPE_END;
    }
    else
    {
        m_iCurArg++;
        CorElementType mt = m_pWalk.PeekElemType();
        m_pWalk.Skip();
        return mt;
    }
}

//------------------------------------------------------------------
// Retreats argument index, then returns type of the argument
// under the new index. Returns ELEMENT_TYPE_END if already at first
// argument.
//------------------------------------------------------------------
CorElementType MetaSig::PrevArg()
{
    if (m_iCurArg == 0)
    {
        return ELEMENT_TYPE_END;
    }
    else
    {
        m_iCurArg--;
        m_pWalk = m_pStart;
        for (UINT32 i = 0; i < m_iCurArg; i++)
        {
            m_pWalk.Skip();
        }
        m_pLastType = m_pWalk;
        return m_pWalk.PeekElemType();
    }
}

//------------------------------------------------------------------------
// Returns # of arguments. Does not count the return value.
// Does not count the "this" argument (which is not reflected om the
// sig.) 64-bit arguments are counted as one argument.
//------------------------------------------------------------------------
/*static*/ UINT MetaSig::NumFixedArgs(Module* pModule, PCCOR_SIGNATURE pSig)
{
    MetaSig msig(pSig, pModule);

    return msig.NumFixedArgs();
}

//------------------------------------------------------------------
// reset: goto start pos
//------------------------------------------------------------------
VOID MetaSig::Reset()
{
    m_pWalk = m_pStart;
    m_iCurArg  = 0;
}

//------------------------------------------------------------------
// Moves index to end of argument list.
//------------------------------------------------------------------
VOID MetaSig::GotoEnd()
{
    m_pWalk = m_pStart;
    for (UINT32 i = 0; i < m_nArgs; i++)
    {
        m_pWalk.Skip();
    }
    m_iCurArg = m_nArgs;

}


//------------------------------------------------------------------------

/*******************************************************************/
BOOL IsTypeRefOrDef(LPCSTR szClassName, Module *pModule, mdToken token)
{
    LPCUTF8  pclsname;
    LPCUTF8 pszNamespace;
        
    IMDInternalImport *pInternalImport = pModule->GetMDImport();

    if (TypeFromToken(token) == mdtTypeDef)
        pInternalImport->GetNameOfTypeDef(token, &pclsname, &pszNamespace);
    else if (TypeFromToken(token) == mdtTypeRef)
        pInternalImport->GetNameOfTypeRef(token, &pszNamespace, &pclsname);
    else 
        return false;

    // If the namespace is not the same.
    int iLen = (int)strlen(pszNamespace);
    if (iLen)
    {
        if (strncmp(szClassName, pszNamespace, iLen) != 0)
            return false;
        
        if (szClassName[iLen] != NAMESPACE_SEPARATOR_CHAR)
            return false;
        ++iLen;
    }

    if (strcmp(&szClassName[iLen], pclsname) != 0)
        return false;
    return true;
}

/************************************************************************/
/* compare two method signatures, when 'sig2' may have ELEMENT_TYPE_VAR elements in it. 
   note that we may load classes more often with this routine that with CompareMethodSig */

BOOL MetaSig::CompareMethodSigs(PCCOR_SIGNATURE sig1, DWORD cSig1, Module* mod1, 
                                PCCOR_SIGNATURE sig2, DWORD cSig2, Module* mod2, TypeHandle* varTypes)
{
    if (varTypes == 0)
        return MetaSig::CompareMethodSigs(sig1, cSig1, mod1, sig2, cSig2, mod2);

    SigPointer ptr1(sig1);
    SigPointer ptr2(sig2);

    unsigned callConv1 = ptr1.GetCallingConvInfo();
    unsigned callConv2 = ptr2.GetCallingConvInfo();
        
    if ((callConv1 & (IMAGE_CEE_CS_CALLCONV_HASTHIS | IMAGE_CEE_CS_CALLCONV_MASK)) != 
        (callConv2 & (IMAGE_CEE_CS_CALLCONV_HASTHIS | IMAGE_CEE_CS_CALLCONV_MASK)))
        return FALSE;

        // The + 1 is to check the return type as well as the arguments
    unsigned numArgs1 = ptr1.GetData() + 1;
    unsigned numArgs2 = ptr2.GetData() + 1;

    if (numArgs1 != numArgs2 && (callConv1 & IMAGE_CEE_CS_CALLCONV_MASK) != IMAGE_CEE_CS_CALLCONV_VARARG)
        return FALSE;

    while (numArgs1 > 0 && numArgs2 > 0) {
        CorElementType type1 = ptr1.PeekElemType();
        CorElementType type2 = ptr2.PeekElemType();
        if (CorTypeInfo::IsPrimitiveType(type1) && CorTypeInfo::IsPrimitiveType(type2)) {
            if (type1 != type2)
                return FALSE; 
        }
        else {
            TypeHandle typeHnd1 = ptr1.GetTypeHandle(mod1);
            TypeHandle typeHnd2 = ptr2.GetTypeHandle(mod2, NULL, FALSE, FALSE, varTypes);
            if (typeHnd1 != typeHnd2)
                return FALSE;
        }
        
        ptr2.SkipExactlyOne();
        ptr1.SkipExactlyOne();
        --numArgs1; --numArgs2;
    }

    if (numArgs1 == numArgs2)
        return TRUE;

    if (numArgs1 > 0)
        return (ptr1.GetData() == ELEMENT_TYPE_SENTINEL);
    else 
        return (ptr2.GetData() == ELEMENT_TYPE_SENTINEL);
}

TypeHandle SigPointer::GetTypeHandle(Module* pModule,
                                     OBJECTREF *pThrowable, 
                                     BOOL dontRestoreTypes,
                                     BOOL dontLoadTypes,
                                     TypeHandle* varTypes) const
{
    if (pThrowable == THROW_ON_ERROR ) {
        THROWSCOMPLUSEXCEPTION();   
    }

    SigPointer psig = *this;
    CorElementType typ = psig.GetElemType();
    unsigned rank = 0;
    ExpandSig *pExpSig;
    switch(typ) {
        case ELEMENT_TYPE_R:
        case ELEMENT_TYPE_U:
        case ELEMENT_TYPE_I:
        case ELEMENT_TYPE_I1:      
        case ELEMENT_TYPE_U1:      
        case ELEMENT_TYPE_BOOLEAN:   
        case ELEMENT_TYPE_I2:
        case ELEMENT_TYPE_U2:
        case ELEMENT_TYPE_CHAR:
        case ELEMENT_TYPE_I4:
        case ELEMENT_TYPE_U4:
        case ELEMENT_TYPE_I8:
        case ELEMENT_TYPE_U8:
        case ELEMENT_TYPE_R4:
        case ELEMENT_TYPE_R8:
        case ELEMENT_TYPE_VOID:
        case ELEMENT_TYPE_STRING:
        case ELEMENT_TYPE_OBJECT:
        case ELEMENT_TYPE_TYPEDBYREF:
            return ElementTypeToTypeHandle(typ);

        case ELEMENT_TYPE_VAR:
            if (varTypes != 0) {
                unsigned typeVar = psig.GetData();
                return(varTypes[typeVar]);
            }
            return TypeHandle(g_pObjectClass);

        case ELEMENT_TYPE_CLASS:
        case ELEMENT_TYPE_VALUETYPE: 
        {
            mdTypeRef typeref = psig.GetToken();

            _ASSERTE(TypeFromToken(typeref) == mdtTypeRef ||
                     TypeFromToken(typeref) == mdtTypeDef ||
                     TypeFromToken(typeref) == mdtTypeSpec);
            _ASSERTE(typeref != mdTypeDefNil && typeref != mdTypeRefNil && typeref != mdTypeSpecNil);
            NameHandle name(pModule, typeref);
            if (dontLoadTypes)
                name.SetTokenNotToLoad(tdAllTypes);
            name.SetRestore(!dontRestoreTypes);
           return(pModule->GetClassLoader()->LoadTypeHandle(&name, pThrowable, TRUE));
        }

        case ELEMENT_TYPE_ARRAY:
        case ELEMENT_TYPE_SZARRAY:
        {
            TypeHandle elemType = psig.GetTypeHandle(pModule, pThrowable, dontRestoreTypes, dontLoadTypes, varTypes);
            if (elemType.IsNull())
                return elemType;

            if (typ == ELEMENT_TYPE_ARRAY) {
                psig.SkipExactlyOne();              // skip the element type
                rank = psig.GetData();
                _ASSERTE(0 < rank);
            }
            return(elemType.GetModule()->GetClassLoader()->FindArrayForElem(elemType, typ, rank, pThrowable));
        }

        case ELEMENT_TYPE_PINNED:
            // Return what follows
            return(psig.GetTypeHandle(pModule, pThrowable, dontRestoreTypes, dontLoadTypes, varTypes));

        case ELEMENT_TYPE_BYREF:
        case ELEMENT_TYPE_PTR:
        {
            TypeHandle baseType = psig.GetTypeHandle(pModule, pThrowable, dontRestoreTypes, dontLoadTypes, varTypes);
            if (baseType.IsNull())
                return baseType;

            NameHandle typeName(typ, baseType);
            if (dontLoadTypes)
                typeName.SetTokenNotToLoad(tdAllTypes);
            typeName.SetRestore(!dontRestoreTypes);

            return baseType.GetModule()->GetClassLoader()->FindTypeHandle(&typeName, pThrowable);
        }

        case ELEMENT_TYPE_VALUEARRAY:
            break;       // For now, type handles to value arrays unsupported

        case ELEMENT_TYPE_FNPTR:
            // TODO: This global table is bogus, function poitners need to be treated
            // like the other parameterized types.  The table should be appdomain level.

            // A sub-signature describing the function follows. Expand this into
            // a version using type handles, so we normalize the signature
            // format over all modules.
            pExpSig = ExpandSig::GetSig(psig.m_ptr, pModule);
            if (!pExpSig)
                break;

            // Skip the sub-signature.
            psig.SkipSignature();

            // Lookup the function signature in a global hash table.
            FunctionTypeDesc *pFuncTypeDesc;
            EnterCriticalSection(&g_sFuncTypeDescHashLock);
            if (!g_sFuncTypeDescHash.GetValue(pExpSig, (HashDatum*)&pFuncTypeDesc)) {

                // No signature found, add it ourselves.
                pFuncTypeDesc = new FunctionTypeDesc(typ, pExpSig);
                if (pFuncTypeDesc == NULL) {
                    LeaveCriticalSection(&g_sFuncTypeDescHashLock);
                    break;
                }
                g_sFuncTypeDescHash.InsertValue(pExpSig, (HashDatum)pFuncTypeDesc);

            } else
                delete pExpSig;
            LeaveCriticalSection(&g_sFuncTypeDescHashLock);
            return pFuncTypeDesc;
    
            
        default:
            _ASSERTE(!"Bad type");

        case ELEMENT_TYPE_SENTINEL:     // just return null
            ;
    }

    pModule->GetAssembly()->PostTypeLoadException(pModule->GetMDImport(), psig.GetToken(),
                                                  IDS_CLASSLOAD_GENERIC, pThrowable);
    return TypeHandle();
}

unsigned SigPointer::GetNameForType(Module* pModule, LPUTF8 buff, unsigned buffLen) const 
{

    TypeHandle typeHnd = GetTypeHandle(pModule);
    if (typeHnd.IsNull())
        return(0);
    return(typeHnd.GetName(buff, buffLen));
}

BOOL SigPointer::IsStringType(Module* pModule) const
{
    _ASSERTE(pModule);

    IMDInternalImport *pInternalImport = pModule->GetMDImport();
    SigPointer psig = *this;
    UINT32 typ = psig.GetElemType();
    if (typ == ELEMENT_TYPE_STRING)
    {
        return TRUE;
    }
    if (typ == ELEMENT_TYPE_CLASS)
    {
        LPCUTF8 pclsname;
        LPCUTF8 pszNamespace;
        mdToken token = psig.GetToken();

        if (TypeFromToken(token) == mdtTypeDef)
            pInternalImport->GetNameOfTypeDef(token, &pclsname, &pszNamespace);
        else
        {
            _ASSERTE(TypeFromToken(token) == mdtTypeRef);
            pInternalImport->GetNameOfTypeRef(token, &pszNamespace, &pclsname);
        }

        if (strcmp(pclsname, g_StringName) != 0)
            return FALSE;
        
        if (!pszNamespace)
            return FALSE;
        
        return !strcmp(pszNamespace, g_SystemNS);
    }
    return FALSE;
}



//------------------------------------------------------------------------
// Tests if the element class name is szClassName. 
//------------------------------------------------------------------------
BOOL SigPointer::IsClass(Module* pModule, LPCUTF8 szClassName) const
{
    _ASSERTE(pModule);
    _ASSERTE(szClassName);

    SigPointer psig = *this;
    UINT32 typ = psig.GetElemType();

    _ASSERTE((typ == ELEMENT_TYPE_CLASS)  || (typ == ELEMENT_TYPE_VALUETYPE) || 
             (typ == ELEMENT_TYPE_OBJECT) || (typ == ELEMENT_TYPE_STRING));

    if ((typ == ELEMENT_TYPE_CLASS) || (typ == ELEMENT_TYPE_VALUETYPE))
    {
        mdTypeRef typeref = psig.GetToken();
        return IsTypeRefOrDef(szClassName, pModule, typeref);
    }
    else if (typ == ELEMENT_TYPE_OBJECT) 
    {
        return !strcmp(szClassName, g_ObjectClassName);
    }
    else if (typ == ELEMENT_TYPE_STRING)
    {
        return !strcmp(szClassName, g_StringClassName);
    }

    return false;
}



//------------------------------------------------------------------------
// Tests for the existence of a custom modifier
//------------------------------------------------------------------------
BOOL SigPointer::HasCustomModifier(Module *pModule, LPCSTR szModName, CorElementType cmodtype) const
{
    _ASSERTE(cmodtype == ELEMENT_TYPE_CMOD_OPT || cmodtype == ELEMENT_TYPE_CMOD_REQD);

    SigPointer sp = *this;
    CorElementType etyp;
    while ((etyp = (CorElementType)(sp.GetByte())) == ELEMENT_TYPE_CMOD_OPT || etyp == ELEMENT_TYPE_CMOD_REQD) {

        mdToken tk = sp.GetToken();

        if (etyp == cmodtype && IsTypeRefOrDef(szModName, pModule, tk))
        {
            return TRUE;
        }

    }
    return FALSE;
}
        
CorElementType SigPointer::Normalize(Module* pModule) const
{
    CorElementType type = PeekElemType();
    return Normalize(pModule, type);
}

CorElementType SigPointer::Normalize(Module* pModule, CorElementType type) const
{
    if (type == ELEMENT_TYPE_VALUETYPE) 
    {
        TypeHandle typeHnd = GetTypeHandle(pModule);

        // If we cannot resolve to the type, we cannot determine that a value type is
        // actually an enum is actually an int32 (or whatever).  Except for wierd race
        // conditions where the type becomes available a little later and proves to be
        // an enum=int32, it's fine for us to say "it's a value class" here.  Later the
        // calling code will notice that it can't figure out what kind of value class
        // and will generate a more appropriate error.
        //
        // @TODO -- cwb/vancem -- in M11, allow GetTypeHandle to throw the exception.
        // The JITs will tolerate this.  The check for IsNull() here can go away & the
        // race condition will be eliminated.
        if (!typeHnd.IsNull())
            return(typeHnd.GetNormCorElementType());
    }
    return(type);
}

CorElementType MetaSig::PeekArgNormalized() 
{
    if (m_iCurArg == m_nArgs)
    {
        return ELEMENT_TYPE_END;
    }
    else
    {
        CorElementType mt = m_pWalk.Normalize(m_pModule);
        return mt;
    }
}

//------------------------------------------------------------------------
// Assumes that the SigPointer points to the start of an element type.
// Returns size of that element in bytes. This is the minimum size that a
// field of this type would occupy inside an object. 
//------------------------------------------------------------------------
UINT SigPointer::SizeOf(Module* pModule) const
{
    CorElementType etype = PeekElemType();
    return SizeOf(pModule, etype);
}

UINT SigPointer::SizeOf(Module* pModule, CorElementType etype) const
{

#ifdef _DEBUG
    for (int etypeindex = 0; etypeindex < ELEMENT_TYPE_MAX; etypeindex++)
    {
        _ASSERTE(etypeindex == gElementTypeInfo[etypeindex].m_elementType);
    }
#endif
    _ASSERTE(etype >= 0 && etype < ELEMENT_TYPE_MAX);
    int cbsize = gElementTypeInfo[etype].m_cbSize;
    if (cbsize != -1)
    {
        return cbsize;
    }

    if (etype == ELEMENT_TYPE_VALUETYPE)
    {
        TypeHandle th = GetTypeHandle(pModule, NULL, TRUE);
        EEClass* pClass = th.AsClass();
        _ASSERTE(pClass);
        return pClass->GetAlignedNumInstanceFieldBytes();
    }
    else if (etype == ELEMENT_TYPE_VALUEARRAY)
    {   
        SigPointer elemType;    
        ULONG count;    
        GetSDArrayElementProps(&elemType, &count);  
        UINT ret = elemType.SizeOf(pModule) * count;   
        ret = (ret + 3) & ~3;       // round up to dword alignment  
        return(ret);    
    }   
    _ASSERTE(0);
    return 0;
}

//------------------------------------------------------------------
// Determines if the current argument is System.String.
// Caller must determine first that the argument type is ELEMENT_TYPE_CLASS.
//------------------------------------------------------------------

BOOL MetaSig::IsStringType() const
{
    return m_pLastType.IsStringType(m_pModule);
}


//------------------------------------------------------------------
// Determines if the current argument is a particular class.
// Caller must determine first that the argument type is ELEMENT_TYPE_CLASS.
//------------------------------------------------------------------
BOOL MetaSig::IsClass(LPCUTF8 szClassName) const
{
    return m_pLastType.IsClass(m_pModule, szClassName);
}





//------------------------------------------------------------------
// Return the type of an reference if the array is the param type
//  The arg type must be an ELEMENT_TYPE_BYREF
//  ref to array needs additional arg
//------------------------------------------------------------------
CorElementType MetaSig::GetByRefType(EEClass** pClass, OBJECTREF *pThrowable) const
{
        SigPointer sigptr(m_pLastType);

        CorElementType typ = (CorElementType)sigptr.GetElemType();
        _ASSERTE(typ == ELEMENT_TYPE_BYREF);
        typ = (CorElementType)sigptr.PeekElemType();
        if (!CorIsPrimitiveType(typ))
        {
            _ASSERTE(typ != ELEMENT_TYPE_TYPEDBYREF);
            TypeHandle th = sigptr.GetTypeHandle(m_pModule,pThrowable);
            //*pClass = th.AsClass();
            *pClass = th.GetMethodTable()->GetClass();
            if (pThrowableAvailable(pThrowable) && *pThrowable != NULL)
                return ELEMENT_TYPE_END;
        }
        return typ;
}

//------------------------------------------------------------------
// Determines if the return type is System.String.
// Caller must determine first that the return type is ELEMENT_TYPE_CLASS.
//------------------------------------------------------------------

BOOL MetaSig::IsStringReturnType() const
{
    return m_pRetType.IsStringType(m_pModule);
}



BOOL CompareTypeTokens(mdToken tk1, mdToken tk2, Module *pModule1, Module *pModule2)
{
    if (pModule1 == pModule2 && tk1 == tk2)
        return TRUE;

    IMDInternalImport *pInternalImport1 = pModule1->GetMDImport();
    LPCUTF8 pszName1;
    LPCUTF8 pszNamespace1 = NULL;
    if (TypeFromToken(tk1) == mdtTypeRef) 
        pInternalImport1->GetNameOfTypeRef(tk1, &pszNamespace1, &pszName1);
    else if (TypeFromToken(tk1) == mdtTypeDef) {
        if (TypeFromToken(tk2) == mdtTypeDef)   // two defs can't be the same unless they are identical
            return FALSE;
        pInternalImport1->GetNameOfTypeDef(tk1, &pszName1, &pszNamespace1);
    }
    else 
        return FALSE;       // comparing a type against a module or assemblyref, no match

    IMDInternalImport *pInternalImport2 = pModule2->GetMDImport();
    LPCUTF8 pszName2;
    LPCUTF8 pszNamespace2 = NULL;
    if (TypeFromToken(tk2) == mdtTypeRef) 
        pInternalImport2->GetNameOfTypeRef(tk2, &pszNamespace2, &pszName2);
    else if (TypeFromToken(tk2) == mdtTypeDef)
        pInternalImport2->GetNameOfTypeDef(tk2, &pszName2, &pszNamespace2);
    else 
        return FALSE;       // comparing a type against a module or assemblyref, no match

    _ASSERTE(pszNamespace1 && pszNamespace2);
    if (strcmp(pszName1, pszName2) != 0 || strcmp(pszNamespace1, pszNamespace2) != 0)
        return FALSE;

    //////////////////////////////////////////////////////////////////////
    // OK names pass, see if it is nested, and if so that the nested classes are the same

    mdToken enclosingTypeTk1 = mdTokenNil;
    if (TypeFromToken(tk1) == mdtTypeRef) 
    {
        enclosingTypeTk1 = pInternalImport1->GetResolutionScopeOfTypeRef(tk1);
        if (enclosingTypeTk1 == mdTypeRefNil)
            enclosingTypeTk1 = mdTokenNil;
    }
    else
         pInternalImport1->GetNestedClassProps(tk1, &enclosingTypeTk1);


    mdToken enclosingTypeTk2 = mdTokenNil;
    if (TypeFromToken(tk2) == mdtTypeRef) 
    {
        enclosingTypeTk2 = pInternalImport2->GetResolutionScopeOfTypeRef(tk2);
        if (enclosingTypeTk2 == mdTypeRefNil)
            enclosingTypeTk2 = mdTokenNil;
    }
    else 
         pInternalImport2->GetNestedClassProps(tk2, &enclosingTypeTk2);

    if (TypeFromToken(enclosingTypeTk1) == mdtTypeRef || TypeFromToken(enclosingTypeTk1) == mdtTypeDef)
        return CompareTypeTokens(enclosingTypeTk1, enclosingTypeTk2, pModule1, pModule2);

    // Check if tk1 is non-nested, but tk2 is nested
    if (TypeFromToken(enclosingTypeTk2) == mdtTypeRef || TypeFromToken(enclosingTypeTk2) == mdtTypeDef)
        return FALSE;

    //////////////////////////////////////////////////////////////////////
    // OK, we have non-nested types
    Assembly* pFoundAssembly1 = pModule1->GetAssembly();
    Assembly* pFoundAssembly2 = pModule2->GetAssembly();

    // Note that we are loading the modules here.
    if (TypeFromToken(tk1) == mdtTypeRef) 
    {
        NameHandle name1(pModule1, tk1);
        //@BUG 55106: If the module could not be found, should we still return FALSE?
        // This leads to VERY unhelpful error messages.  We should fix this. 
        HRESULT hr = pFoundAssembly1->FindAssemblyByTypeRef(&name1, &pFoundAssembly1, NULL);
        if (hr == CLDB_S_NULL) {
            // There may be an ExportedType for this type.
            name1.SetName(pszNamespace1, pszName1);
            Module* pFoundModule;
            TypeHandle typeHnd;

            // Do not load the type! (Or else you may run into circular dependency loading problems.)
            if (FAILED(pModule1->GetClassLoader()->FindClassModule(&name1,
                                                                   &typeHnd, 
                                                                   NULL, //&FoundCl, 
                                                                   &pFoundModule,
                                                                   NULL,
                                                                   NULL, 
                                                                   NULL))) //pThrowable
                return FALSE;
            else if (typeHnd.IsNull())
                pFoundAssembly1 = pFoundModule->GetAssembly();
            else
                pFoundAssembly1 = typeHnd.GetAssembly();
        }
        else if (FAILED(hr))
            return FALSE;
    }

    if (TypeFromToken(tk2) == mdtTypeRef) 
    {
        NameHandle name2(pModule2, tk2);
        //@BUG 55106: If the module could not be found, should we still return FALSE?
        HRESULT hr = pFoundAssembly2->FindAssemblyByTypeRef(&name2, &pFoundAssembly2, NULL);
        if (hr == CLDB_S_NULL) {
            // There may be an ExportedType for this type.
            name2.SetName(pszNamespace2, pszName2);
            Module* pFoundModule;
            TypeHandle typeHnd;

            // Do not load the type! (Or else you may run into circular dependency loading problems.)
            if (FAILED(pModule2->GetClassLoader()->FindClassModule(&name2,
                                                                   &typeHnd, 
                                                                   NULL, //&FoundCl, 
                                                                   &pFoundModule,
                                                                   NULL,
                                                                   NULL, 
                                                                   NULL))) //pThrowable
                return FALSE;
            else if (typeHnd.IsNull())
                pFoundAssembly2 = pFoundModule->GetAssembly();
            else
                pFoundAssembly2 = typeHnd.GetAssembly();
        }
        else if (FAILED(hr))
            return FALSE;
    }

    return pFoundAssembly1 == pFoundAssembly2;    
}

//
// Compare the next elements in two sigs.
//
BOOL MetaSig::CompareElementType(
    PCCOR_SIGNATURE &pSig1,
    PCCOR_SIGNATURE &pSig2,
    PCCOR_SIGNATURE pEndSig1, // end of sig1
    PCCOR_SIGNATURE pEndSig2, // end of sig2
    Module*         pModule1,
    Module*         pModule2
)
{
    CorElementType Type;
    CorElementType Type2;


 redo:  // We jump here if the Type was a ET_CMOD prefix.
        // The caller expects us to handle CMOD's but not
        // present them as types on their own.

    if (pSig1 >= pEndSig1 || pSig2 >= pEndSig2)
        return FALSE; // end of sig encountered prematurely

    Type = CorSigUncompressElementType(pSig1);
    Type2 = CorSigUncompressElementType(pSig2);

    if (Type != Type2)
    {
        if (Type == ELEMENT_TYPE_INTERNAL || Type2 == ELEMENT_TYPE_INTERNAL)
        {
            TypeHandle      hInternal;
            PCCOR_SIGNATURE pOtherSig;
            CorElementType  eOtherType;
            Module         *pOtherModule;

            // One type is already loaded, collect all the necessary information
            // to identify the other type.
            if (Type == ELEMENT_TYPE_INTERNAL)
            {
                CorSigUncompressPointer(pSig1, (void**)&hInternal);
                eOtherType = Type2;
                pOtherSig = pSig2;
                pOtherModule = pModule2;
            }
            else
            {
                CorSigUncompressPointer(pSig2, (void**)&hInternal);
                eOtherType = Type;
                pOtherSig = pSig1;
                pOtherModule = pModule1;
            }

            // Internal types can only correspond to types or value types.
            switch (eOtherType)
            {
            case ELEMENT_TYPE_OBJECT:
                return hInternal.AsMethodTable() == g_pObjectClass;
            case ELEMENT_TYPE_STRING:
                return hInternal.AsMethodTable() == g_pStringClass;
            case ELEMENT_TYPE_VALUETYPE:
            case ELEMENT_TYPE_CLASS:
            {
                mdToken tkOther;
                pOtherSig += CorSigUncompressToken(pOtherSig, &tkOther);
                NameHandle name(pOtherModule, tkOther);
                TypeHandle hOtherType;

                // We need to load the other type to check for type identity.
                BEGIN_ENSURE_COOPERATIVE_GC();
                OBJECTREF pThrowable = NULL;
                GCPROTECT_BEGIN(pThrowable);
                hOtherType = pOtherModule->GetClassLoader()->LoadTypeHandle(&name, &pThrowable);
                GCPROTECT_END();
                END_ENSURE_COOPERATIVE_GC();

                return hInternal == hOtherType;
            }
            default:
                return FALSE;
            }

#ifdef _DEBUG
            // Shouldn't get here.
            _ASSERTE(FALSE);
            return FALSE;
#endif
        }
        else
            return FALSE; // types must be the same
    }

    switch (Type)
    {
        default:
        {
            // Unknown type!
            _ASSERTE(0);
            return FALSE;
        }

        case ELEMENT_TYPE_R:
        case ELEMENT_TYPE_U:
        case ELEMENT_TYPE_I:
        case ELEMENT_TYPE_VOID:
        case ELEMENT_TYPE_I1:
        case ELEMENT_TYPE_U1:
        case ELEMENT_TYPE_I2:
        case ELEMENT_TYPE_U2:
        case ELEMENT_TYPE_I4:
        case ELEMENT_TYPE_U4:
        case ELEMENT_TYPE_I8:
        case ELEMENT_TYPE_U8:
        case ELEMENT_TYPE_R4:
        case ELEMENT_TYPE_R8:
        case ELEMENT_TYPE_BOOLEAN:
        case ELEMENT_TYPE_CHAR:
        case ELEMENT_TYPE_TYPEDBYREF:
        case ELEMENT_TYPE_STRING:   
        case ELEMENT_TYPE_OBJECT:
            break;


        case ELEMENT_TYPE_VAR: 
        {
            unsigned varNum1 = CorSigUncompressData(pSig1);
            unsigned varNum2 = CorSigUncompressData(pSig2);
            return (varNum1 == varNum2);
        }
        case ELEMENT_TYPE_CMOD_REQD:
        case ELEMENT_TYPE_CMOD_OPT:
            {
                mdToken      tk1, tk2;
    
                pSig1 += CorSigUncompressToken(pSig1, &tk1);
                pSig2 += CorSigUncompressToken(pSig2, &tk2);

                if (!CompareTypeTokens(tk1, tk2, pModule1, pModule2))
                {
                    return FALSE;
                }

                goto redo;
            }
            break;

        // These take an additional argument, which is the element type
        case ELEMENT_TYPE_SZARRAY:
        case ELEMENT_TYPE_PTR:
        case ELEMENT_TYPE_BYREF:
        {
            if (!CompareElementType(pSig1, pSig2, pEndSig1, pEndSig2, pModule1, pModule2))
                return(FALSE);
            return(TRUE);
        }

        case ELEMENT_TYPE_VALUETYPE:
        case ELEMENT_TYPE_CLASS:
        {
            mdToken      tk1, tk2;

            pSig1 += CorSigUncompressToken(pSig1, &tk1);
            pSig2 += CorSigUncompressToken(pSig2, &tk2);

            return CompareTypeTokens(tk1, tk2, pModule1, pModule2);
        }
        case ELEMENT_TYPE_FNPTR: 
        {
                // compare calling conventions
            if (CorSigUncompressData(pSig1) != CorSigUncompressData(pSig2))
                return(FALSE);

            DWORD argCnt1 = CorSigUncompressData(pSig1);    // Get Arg Counts
            DWORD argCnt2 = CorSigUncompressData(pSig2);

            if (argCnt1 != argCnt2)
                return(FALSE);
            if (!CompareElementType(pSig1, pSig2, pEndSig1, pEndSig2, pModule1, pModule2))
                return(FALSE);
            while(argCnt1 > 0) {
                if (!CompareElementType(pSig1, pSig2, pEndSig1, pEndSig2, pModule1, pModule2))
                    return(FALSE);
                --argCnt1;
            }
            break;
        }
        case ELEMENT_TYPE_ARRAY:
        {
            // syntax: ARRAY <base type> rank <count n> <size 1> .... <size n> <lower bound m>
            // <lb 1> .... <lb m>
            DWORD rank1,rank2,dimension_sizes1,dimension_sizes2,dimension_lowerb1,dimension_lowerb2,i;

            // element type
            if (CompareElementType(pSig1, pSig2, pEndSig1, pEndSig2, pModule1, pModule2) == FALSE)
                return FALSE;

            rank1 = CorSigUncompressData(pSig1);
            rank2 = CorSigUncompressData(pSig2);

            if (rank1 != rank2)
                return FALSE;

            // A zero ends the array spec
            if (rank1 == 0)
                break;

            dimension_sizes1 = CorSigUncompressData(pSig1);
            dimension_sizes2 = CorSigUncompressData(pSig2);

            if (dimension_sizes1 != dimension_sizes2)
                return FALSE;

            for (i = 0; i < dimension_sizes1; i++)
            {
                DWORD size1, size2;

                if (pSig1 == pEndSig1)
                    return TRUE; // premature end ok

                size1 = CorSigUncompressData(pSig1);
                size2 = CorSigUncompressData(pSig2);

                if (size1 != size2)
                    return FALSE;
            }

            if (pSig1 == pEndSig1)
                return TRUE; // premature end ok

            // # dimensions for lower bounds
            dimension_lowerb1 = CorSigUncompressData(pSig1);
            dimension_lowerb2 = CorSigUncompressData(pSig2);

            if (dimension_lowerb1 != dimension_lowerb2)
                return FALSE;

            for (i = 0; i < dimension_lowerb1; i++)
            {
                DWORD size1, size2;

                if (pSig1 == pEndSig1)
                    return TRUE; // premature end

                size1 = CorSigUncompressData(pSig1);
                size2 = CorSigUncompressData(pSig2);

                if (size1 != size2)
                    return FALSE;
            }

            break;
        }
        case ELEMENT_TYPE_INTERNAL:
        {
            TypeHandle hType1, hType2;

            CorSigUncompressPointer(pSig1, (void**)&hType1);
            CorSigUncompressPointer(pSig2, (void**)&hType2);

            return hType1 == hType2;
        }
    }

    return TRUE;
}


//
// Compare two method sigs and return whether they are the same
//
BOOL MetaSig::CompareMethodSigs(
    PCCOR_SIGNATURE pSignature1,
    DWORD       cSig1,
    Module*     pModule1,
    PCCOR_SIGNATURE pSignature2,
    DWORD       cSig2,
    Module*     pModule2
)
{
    PCCOR_SIGNATURE pSig1 = pSignature1;
    PCCOR_SIGNATURE pSig2 = pSignature2;
    PCCOR_SIGNATURE pEndSig1;
    PCCOR_SIGNATURE pEndSig2;
    DWORD           ArgCount1;
    DWORD           ArgCount2;
    DWORD           i;

    // If scopes are the same, and sigs are same, can return.
    // If the sigs aren't the same, but same scope, can't return yet, in
    // case there are two AssemblyRefs pointing to the same assembly or such.
    if ((pModule1 == pModule2) && (cSig1 == cSig2) &&
        (!memcmp(pSig1, pSig2, cSig1)))
        return TRUE;

    if (*pSig1 != *pSig2)
        return FALSE;               // calling convention or hasThis mismatch

    __int8 callConv = *pSig1;

    pSig1++;
    pSig2++;

    pEndSig1 = pSig1 + cSig1;
    pEndSig2 = pSig2 + cSig2;

    ArgCount1 = CorSigUncompressData(pSig1);
    ArgCount2 = CorSigUncompressData(pSig2);

    if (ArgCount1 != ArgCount2)
    {
        if ((callConv & IMAGE_CEE_CS_CALLCONV_MASK) != IMAGE_CEE_CS_CALLCONV_VARARG)
            return FALSE;

        // Signature #1 is the caller.  We proceed until we hit the sentinel, or we hit
        // the end of the signature (which is an implied sentinel).  We never worry about
        // what follows the sentinel, because that is the ... part, which is not
        // involved in matching.
        //
        // Theoretically, it's illegal for a sentinel to be the last element in the
        // caller's signature, because it's redundant.  We don't waste our time checking
        // that case, but the metadata validator should.  Also, it is always illegal
        // for a sentinel to appear in a callee's signature.  We assert against this,
        // but in the shipping product the comparison would simply fail.
        //
        // Signature #2 is the callee.  We must hit the exact end of the callee, because
        // we are trying to match on everything up to the variable part.  This allows us
        // to correctly handle overloads, where there are a number of varargs methods
        // to pick from, like m1(int,...) and m2(int,int,...), etc.

        // <= because we want to include a check of the return value!
        for (i=0; i <= ArgCount1; i++)
        {
            // We may be just going out of bounds on the callee, but no further than that.
            _ASSERTE(i <= ArgCount2 + 1);

            // If we matched all the way on the caller, is the callee now complete?
            if (*pSig1 == ELEMENT_TYPE_SENTINEL)
                return (i > ArgCount2);

            // if we have more to compare on the caller side, but the callee side is
            // exhausted, this isn't our match
            if (i > ArgCount2)
                return FALSE;

            _ASSERTE(*pSig2 != ELEMENT_TYPE_SENTINEL);

            // We are in bounds on both sides.  Compare the element.
            if (CompareElementType(pSig1, pSig2, pEndSig1, pEndSig2, pModule1, pModule2) == FALSE)
                return FALSE;
        }

        // If we didn't consume all of the callee signature, then we failed.
        if (i <= ArgCount2)
            return FALSE;

        return TRUE;
    }

    // do return type as well
    for (i = 0; i <= ArgCount1; i++)
    {
        if (CompareElementType(pSig1, pSig2, pEndSig1, pEndSig2, pModule1, pModule2) == FALSE)
            return FALSE;
    }

    return TRUE;
}


BOOL MetaSig::CompareFieldSigs(
    PCCOR_SIGNATURE pSignature1,
    DWORD       cSig1,
    Module*     pModule1,
    PCCOR_SIGNATURE pSignature2,
    DWORD       cSig2,
    Module*     pModule2
)
{
    PCCOR_SIGNATURE pSig1 = pSignature1;
    PCCOR_SIGNATURE pSig2 = pSignature2;
    PCCOR_SIGNATURE pEndSig1;
    PCCOR_SIGNATURE pEndSig2;

    // @TODO: If scopes are the same, use identity rule - for now, don't, so that we test the code paths
#if 0
    if (cSig1 != cSig2)
        return FALSE; // sigs must be same size if they are in the same scope
#endif

    if (*pSig1 != *pSig2)
        return FALSE; // calling convention, must be IMAGE_CEE_CS_CALLCONV_FIELD

    pEndSig1 = pSig1 + cSig1;
    pEndSig2 = pSig2 + cSig2;

    return CompareElementType(++pSig1, ++pSig2, pEndSig1, pEndSig2, pModule1, pModule2);
}


//------------------------------------------------------------------
// Determines if the current argument is System.String.
// Caller must determine first that the argument type is ELEMENT_TYPE_CLASS.
//------------------------------------------------------------------
BOOL FieldSig::IsStringType() const
{
    return m_pStart.IsStringType(m_pModule);
}


static ULONG CountArgsInSigString(          // return number of arguments in a hard coded sig string
    LPCUTF8     pwzSig)                     // [IN] text signature
{
    DWORD count = 0;

    if (*pwzSig++ != '<')
        return FALSE;

    while (*pwzSig != '>')
    {
        switch (*pwzSig++)
        {
            case 'v':
                _ASSERTE(pwzSig[-2] == 'P'); // only pointer to void allows in signature. 
                /* FALL THROUGH */
            case 'e':
            case 'd':
            case 'f':
            case 'l':
            case 'i':
            case 'I':
            case 'F':
            case 'h':
            case 'u':
            case 'b':
            case 'B':
            case 'p':
            case 'g':
            case 'C':
            case 'j':
            case 's':
            case 'U':
            case 'K':
            case 'H':
            case 'L':
            {
                count++;
                break;
            }

            case 'r':
            case 'P':
            case 'a':
                break;

            default:
                _ASSERTE(!"BadType");
        }
    }

    return count;
}

static ULONG CountParamArgsInSigString(
    LPCUTF8     pwzSig)
{
    DWORD count = 0;

    if (*pwzSig++ != '<')
        return FALSE;

    while (*pwzSig != '>')
    {
        switch (*pwzSig++)
        {
            case 'e':
            case 'd':
            case 'f':
            case 'l':
            case 'i':
            case 'I':
            case 'F':
            case 'h':
            case 'u':
            case 'b':
            case 'B':
            case 'p':
            case 'j':
            case 's':
            case 'r':
            case 'P':
            case 'a':
            case 'U':
            case 'K':
            case 'H':
            case 'L':
                break;

            case 'g':
            case 'C':
                count++;
                break;

            default:
            case 'v':
            {
                return 0xFFFFFFFF;
            }
        }
    }

    return count;
}

static ULONG CorSigConvertSigStringElement(LPCUTF8 *pSigString,
                                           const USHORT **ppParameters,
                                           BYTE *pBuffer,
                                           BYTE *pMax)
{
    BYTE *pEnd = pBuffer;
    BOOL again;

    do
    {
        again = FALSE;
        CorElementType type = ELEMENT_TYPE_END;
        BinderClassID id = CLASS__NIL;
    
        switch (*(*pSigString)++)
        {
        case 'r':
            type = ELEMENT_TYPE_BYREF;
            again = true;
            break;

        case 'P':
            type = ELEMENT_TYPE_PTR;
            again = true;
            break;

        case 'a':
            type = ELEMENT_TYPE_SZARRAY;
            again = true;
            break;

        case 'e':
            type = ELEMENT_TYPE_TYPEDBYREF;
            break;

        case 'i':
            type = ELEMENT_TYPE_I4;
            break;
            
        case 'K':
            type = ELEMENT_TYPE_U4;
            break;
            
        case 'l':
            type = ELEMENT_TYPE_I8;
            break;

        case 'L':
            type = ELEMENT_TYPE_U8;
            break;

        case 'f':
            type = ELEMENT_TYPE_R4;
            break;
            
        case 'd':
            type = ELEMENT_TYPE_R8;
            break;

        case 'u':
            type = ELEMENT_TYPE_CHAR;
            break;
            
        case 'h':
            type = ELEMENT_TYPE_I2;
            break;

        case 'H':
            type = ELEMENT_TYPE_U2;
            break;

        case 'F':
            type = ELEMENT_TYPE_BOOLEAN;
            break;

        case 'b':
            type = ELEMENT_TYPE_U1;
            break;

        case 'B':
            type = ELEMENT_TYPE_I1;
            break;

        case 'p':
        case 'I':
            type = ELEMENT_TYPE_I;
            break;

        case 'U':
            type = ELEMENT_TYPE_U;
            break;

        case 'v':
            type = ELEMENT_TYPE_VOID;
            break;

        case 'C':
            type = ELEMENT_TYPE_CLASS;
            id = (BinderClassID) *(*ppParameters)++;
            break;

        case 'g':
            type = ELEMENT_TYPE_VALUETYPE;
            id = (BinderClassID) *(*ppParameters)++;
            break;

        case 'j':
            type = ELEMENT_TYPE_OBJECT;
            break;
            
        case 's':
            type = ELEMENT_TYPE_STRING;
            break;
            

        default:
            _ASSERTE("Bad hard coded sig string");
        }

        pEnd += CorSigCompressElementTypeSafe(type, pEnd, pMax);

        if (id != CLASS__NIL)
        {
            pEnd += CorSigCompressTokenSafe(g_Mscorlib.GetTypeDef(id), pEnd, pMax);

            // Make sure we've loaded the type.  This is to prevent the situation where
            // a metasig's signature is describing a value type/enum argument on the stack 
            // during gc, but that type has not been loaded yet.

            g_Mscorlib.FetchClass(id);
        }
    }
    while (again);

    return (ULONG)(pEnd - pBuffer);
}


static ULONG CorSigConvertSigString(LPCUTF8 pSigString,
                                    const USHORT *pParameters,
                                    BYTE *pBuffer,
                                    BYTE *pMax)
{
    _ASSERTE(pSigString && pBuffer && pMax);

    BYTE *pEnd = pBuffer;

    if (*pSigString == '<')
    {
        // put calling convention
        pEnd += CorSigCompressDataSafe((ULONG)IMAGE_CEE_CS_CALLCONV_DEFAULT, pEnd, pMax);

        ULONG cArgs = CountArgsInSigString(pSigString);
        // put the count of arguments
        pEnd += CorSigCompressDataSafe(cArgs, pEnd, pMax);

        // get the return type
        LPCUTF8 szRet = (LPCUTF8) strrchr(pSigString, '>');
        if (szRet == NULL)
        {
            _ASSERTE(!"Not a valid TEXT member signature!");
            return E_FAIL;
        }

        // skip over '>'
        szRet++;

        // Write return type
        const USHORT *pRetParameter = pParameters + CountParamArgsInSigString(pSigString);
        pEnd += CorSigConvertSigStringElement(&szRet, &pRetParameter, pEnd, pMax);

        // skip over "("
        pSigString++;

        while (cArgs)
        {
            pEnd += CorSigConvertSigStringElement(&pSigString, &pParameters, pEnd, pMax);
            cArgs--;
        }
    }
    else
    {
        pEnd += CorSigCompressDataSafe((ULONG)IMAGE_CEE_CS_CALLCONV_FIELD, pEnd, pMax);

        pEnd += CorSigConvertSigStringElement(&pSigString, &pParameters, pEnd, pMax);
    }

    return (ULONG)(pEnd - pBuffer);
}

// Do a one-time conversion to binary form.
HRESULT HardCodedMetaSig::GetBinaryForm(PCCOR_SIGNATURE *ppBinarySig, ULONG *pcbBinarySigLength)
{

// Make sure all HardCodedMetaSig's are global. Because there is no individual
// cleanup of converted binary sigs, using allocated HardCodedMetaSig's
// can lead to a quiet memory leak.
#ifdef _DEBUG

// This #include hack generates a monster boolean expression that compares
// "this" against the address of every global defined in metasig.h
    if (! (0
#define DEFINE_METASIG(varname, sig) || this==&gsig_ ## varname
#include "metasig.h"
    ))
    {
        _ASSERTE(!"The HardCodedMetaSig struct can only be declared as a global in metasig.h.");
    }
#endif

    if (!m_fConverted)
    {
        ULONG cbCount;
        CQuickBytes cqb;

        cqb.Maximize();

        cbCount = CorSigConvertSigString(*m_ObsoleteForm == '!' ? m_ObsoleteForm + 1 : m_ObsoleteForm,
                                         m_pParameters,
                                         (BYTE*) cqb.Ptr(), (BYTE*) cqb.Ptr() + cqb.Size());
        if (cbCount > cqb.Size())
        {
            if (FAILED(cqb.ReSize(cbCount)))
                return E_OUTOFMEMORY;

            cbCount = CorSigConvertSigString(*m_ObsoleteForm == '!' ? m_ObsoleteForm + 1 : m_ObsoleteForm,
                                             m_pParameters,
                                             (BYTE*) cqb.Ptr(), (BYTE*) cqb.Ptr() + cqb.Size());

            _ASSERTE(cbCount <= cqb.Size());
        }
                                   

        m_pCrst->Enter();

        if (!m_fConverted) {

            BYTE *pBinarySig = (BYTE *)(SystemDomain::System()->GetHighFrequencyHeap()->AllocMem(cbCount+4));

            WS_PERF_UPDATE_DETAIL("HardCodeMetaSig", cbCount, pBinarySig);
            if (!pBinarySig)
            {
                m_pCrst->Leave();
                return E_OUTOFMEMORY;
            }

#ifdef _DEBUG
            SystemDomain::Loader()->m_dwDebugConvertedSigSize += cbCount;
#endif

            CopyMemory(pBinarySig, cqb.Ptr(), cbCount);

            if (*m_ObsoleteForm == '!')
                *pBinarySig |= IMAGE_CEE_CS_CALLCONV_HASTHIS;

            m_pBinarySig        = (PCCOR_SIGNATURE) pBinarySig;
            m_cbBinarySigLength = cbCount;

            m_fConverted        = TRUE;
        }

        m_pCrst->Leave();
    }

    *ppBinarySig        = m_pBinarySig;
    *pcbBinarySigLength = m_cbBinarySigLength;
    return S_OK;

}


// These versions throw COM+ exceptions
PCCOR_SIGNATURE HardCodedMetaSig::GetBinarySig()
{
    THROWSCOMPLUSEXCEPTION();

    PCCOR_SIGNATURE pBinarySig;
    ULONG       pBinarySigLength;
    HRESULT     hr;

    hr = GetBinaryForm(&pBinarySig, &pBinarySigLength);
    if (FAILED(hr))
    {
        COMPlusThrowHR(hr);
    }
    return pBinarySig;
}


ULONG HardCodedMetaSig::GetBinarySigLength()
{
    THROWSCOMPLUSEXCEPTION();

    PCCOR_SIGNATURE pBinarySig;
    ULONG       pBinarySigLength;
    HRESULT     hr;

    hr = GetBinaryForm(&pBinarySig, &pBinarySigLength);
    if (FAILED(hr))
    {
        COMPlusThrowHR(hr);
    }
    return pBinarySigLength;
}


// This always returns MSCORLIB's Internal interface
IMDInternalImport* HardCodedMetaSig::GetMDImport()
{
    return GetModule()->GetMDImport();
}

// This always returns MSCORLIB's Module
Module* HardCodedMetaSig::GetModule()
{
    _ASSERTE(SystemDomain::SystemModule() != NULL);
    return SystemDomain::SystemModule();
}




//=========================================================================
// Indicates whether an argument is to be put in a register using the
// default IL calling convention. This should be called on each parameter
// in the order it appears in the call signature. For a non-static method,
// this function should also be called once for the "this" argument, prior
// to calling it for the "real" arguments. Pass in a typ of ELEMENT_TYPE_CLASS.
//
//  *pNumRegistersUsed:  [in,out]: keeps track of the number of argument
//                       registers assigned previously. The caller should
//                       initialize this variable to 0 - then each call
//                       will update it.
//
//  typ:                 the signature type
//  structSize:          for structs, the size in bytes
//  fThis:               is this about the "this" pointer?
//  callconv:            see IMAGE_CEE_CS_CALLCONV_*
//  *pOffsetIntoArgumentRegisters:
//                       If this function returns TRUE, then this out variable
//                       receives the identity of the register, expressed as a
//                       byte offset into the ArgumentRegisters structure.
//
// 
//=========================================================================
BOOL IsArgumentInRegister(int   *pNumRegistersUsed,
                          BYTE   typ,
                          UINT32 structSize,
                          BOOL   fThis,
                          BYTE   callconv,
                          int   *pOffsetIntoArgumentRegisters)
{
    int dummy;
    if (pOffsetIntoArgumentRegisters == NULL) {
        pOffsetIntoArgumentRegisters = &dummy;
    }

#ifdef _X86_

    if ( (*pNumRegistersUsed) == NUM_ARGUMENT_REGISTERS || (callconv == IMAGE_CEE_CS_CALLCONV_VARARG && !fThis) ) {
        return FALSE;
    } else {

        if (gElementTypeInfo[typ].m_enregister) {
            int registerIndex = (*pNumRegistersUsed)++;
            *pOffsetIntoArgumentRegisters = sizeof(ArgumentRegisters) - sizeof(UINT32)*(1+registerIndex);
            return TRUE;
        }
        return FALSE;
    }
#else
    return FALSE;
#endif
}


//------------------------------------------------------------------
// Perform type-specific GC promotion on the value (based upon the
// last type retrieved by NextArg()).
//------------------------------------------------------------------
VOID MetaSig::GcScanRoots(LPVOID pValue, promote_func *fn, ScanContext* sc)
{
    Object **pArgPtr = (Object**)pValue;

    int  etype = m_pLastType.PeekElemType();
    _ASSERTE(etype >= 0 && etype < ELEMENT_TYPE_MAX);
    switch (gElementTypeInfo[etype].m_gc)
    {
        case TYPE_GC_NONE:
            // do nothing
            break;

        case TYPE_GC_REF:
            // value is an objectref.  Cannot validate the objectref though if we're in the
            // relocation phase.
            if (sc->promotion)
            {
                LOG((LF_GC, INFO3, "        Value containing %I64x at %x is being Promoted to ", ObjectToOBJECTREF(*(Object**)pArgPtr), pArgPtr));            
            }
            else
            {
                LOG((LF_GC, INFO3, "        Value containing %I64x at %x is being Promoted to ", *(Object**)pArgPtr, pArgPtr));
            }

            (*fn)( *pArgPtr, sc, GC_CALL_CHECK_APP_DOMAIN );
            // !!! Do not cast to (OBJECTREF*)
            // !!! If we are in the relocate phase, we may have updated root,
            // !!! but we have not moved the GC heap yet.
            // !!! The root then points to bad locations until GC is done.
            LOG((LF_GC, INFO3, "%I64x\n", *pArgPtr ));
            break;


        case TYPE_GC_BYREF:
            // value is an interior pointer
            {
                    LOG((LF_GC, INFO3, "        Value containing %I64x at %x is being Promoted to ", *pArgPtr, pArgPtr));
                    PromoteCarefully(fn, *pArgPtr, sc, GC_CALL_INTERIOR|GC_CALL_CHECK_APP_DOMAIN);
            // !!! Do not cast to (OBJECTREF*)
            // !!! If we are in the relocate phase, we may have updated root,
            // !!! but we have not moved the GC heap yet.
            // !!! The root then points to bad locations until GC is done.
                    LOG((LF_GC, INFO3, "%I64x\n", *pArgPtr ));
                }
            break;

        case TYPE_GC_OTHER:
            // value is a ValueClass.  See one of the go_through_object() macros in
            // gc.cpp for the code we are emulating here.  But note that the GCDesc
            // for value classes describes the state of the instance in its boxed
            // state.  Here we are dealing with an unboxed instance, so we must adjust
            // the object size and series offsets appropriately.
            {
                TypeHandle th = GetTypeHandle(NULL, TRUE);
                MethodTable *pMT = th.AsMethodTable();

                if (pMT->ContainsPointers())
                {
                  BYTE        *obj = (BYTE *) pArgPtr;

                    // size of instance when unboxed must be adjusted for the syncblock
                    // index and the VTable pointer.
                    DWORD       size = pMT->GetBaseSize();

                    // we don't include this term in our 'ppstop' calculation below.
                    _ASSERTE(pMT->GetComponentSize() == 0);

                    CGCDesc* map = CGCDesc::GetCGCDescFromMT(pMT);
                    CGCDescSeries* cur = map->GetHighestSeries();
                    CGCDescSeries* last = map->GetLowestSeries();

                    _ASSERTE(cur >= last);
                    do
                    {
                        // offset to embedded references in this series must be
                        // adjusted by the VTable pointer, when in the unboxed state.
                        DWORD   adjustOffset = cur->GetSeriesOffset() - sizeof(void *);

                        Object** parm = (Object**)(obj + adjustOffset);
                        BYTE** ppstop = 
                            (BYTE**)((BYTE*)parm + cur->GetSeriesSize() + size);
                        while ((BYTE **) parm < ppstop)
                        {
                            (*fn)(*parm, sc, GC_CALL_CHECK_APP_DOMAIN);
                            (*(BYTE ***) &parm)++;
                        }
                        cur--;

                    } while (cur >= last);   
      
                }
            }
            break;

        default:
            _ASSERTE(0); // can't get here.
    }
}

//------------------------------------------------------------------------
// Returns # of stack bytes required to create a call-stack using
// the internal calling convention.
// Includes indication of "this" pointer since that's not reflected
// in the sig.
//------------------------------------------------------------------------
/*static*/ UINT MetaSig::SizeOfVirtualFixedArgStack(Module* pModule, PCCOR_SIGNATURE szMetaSig, BOOL fIsStatic)
{
    UINT cb = 0;
    MetaSig msig(szMetaSig, pModule);

    if (!fIsStatic)
        cb += StackElemSize(sizeof(OBJECTREF));
    if (msig.HasRetBuffArg())
        cb += StackElemSize(sizeof(OBJECTREF));

    while (ELEMENT_TYPE_END != msig.NextArg()) {
        cb += StackElemSize(msig.GetArgProps().SizeOf(pModule));
    }
    return cb;

}

//------------------------------------------------------------------------
// Returns # of stack bytes required to create a call-stack using
// the actual calling convention.
// Includes indication of "this" pointer since that's not reflected
// in the sig.
//------------------------------------------------------------------------
/*static*/ UINT MetaSig::SizeOfActualFixedArgStack(Module *pModule, PCCOR_SIGNATURE szMetaSig, BOOL fIsStatic)
{
    UINT cb = 0;
#ifndef _ALPHA_  // Alpha stack usage must be multiples of 16 bytes
    MetaSig msig(szMetaSig, pModule);
    int numregsused = 0;
    BOOL fIsVarArg = msig.IsVarArg();
    BYTE callconv  = msig.GetCallingConvention();

    if (!fIsStatic) {
        if (!IsArgumentInRegister(&numregsused, ELEMENT_TYPE_CLASS, 0, TRUE, callconv, NULL)) {
            cb += StackElemSize(sizeof(OBJECTREF));
        }
    }
    if (msig.HasRetBuffArg())
        numregsused++;

    if (fIsVarArg || msig.IsTreatAsVarArg()) {
        numregsused = NUM_ARGUMENT_REGISTERS;   // No other params in registers 
        cb += StackElemSize(sizeof(LPVOID));    // VASigCookie
    }

    CorElementType mtype;
    while (ELEMENT_TYPE_END != (mtype = msig.NextArgNormalized())) {
        UINT cbSize = msig.GetLastTypeSize();

        if (!IsArgumentInRegister(&numregsused, mtype, cbSize, FALSE, callconv, NULL))
        {
            cb += StackElemSize(cbSize);
        }
    }

        // Parameterized type passed as last parameter, but not mentioned in the sig
    if (msig.GetCallingConventionInfo() & CORINFO_CALLCONV_PARAMTYPE)
        if (!IsArgumentInRegister(&numregsused, ELEMENT_TYPE_I, sizeof(void*), FALSE, callconv, NULL))
            cb += sizeof(void*);

#else _ALPHA_
    _ASSERTE(!"@TODO Alpha - SizeOfActualFixedArgStack (SigInfo.cpp)");
#endif // !_ALPHA_
    return cb;
}


//
void MetaSig::ForceSigWalk(BOOL fIsStatic)
{
    BOOL fVarArg = IsVarArg();
    BYTE callconv = GetCallingConvention();

    // We must use temporaries rather than members here.  That's because the decision
    // of whether to Force a SigWalk is based on a member being -1.  If the last thing
    // we do is post to that member, then multiple threads won't read partially complete
    // signature state.  (Of course, this mechanism depends on the fact that ForceSigWalk
    // can be called multiple times without change.
    //
    // Normally MetaSig isn't supposed to be thread-safe anyway.  For example, the
    // iterator is held inside the MetaSig rather than outside.  But Reflection uses
    // ExpandSigs that hoist the iteration out.  And they make copies of the internal
    // MetaSig during dispatch (in case dispatch happens on multiple threads).  So
    // ExpandSig needs a thread-safe ForceSigWalk implementation here.

    UINT32  tmp_nVirtualStack = 0;
    UINT32  tmp_nActualStack = 0;

    int numregsused = 0;

    int argCnt = 0; 
    SigPointer p = m_pStart;    

    if (fVarArg || IsTreatAsVarArg()) {
        tmp_nActualStack += StackElemSize(sizeof(LPVOID));
    }

    if (!fIsStatic) {
        tmp_nVirtualStack += StackElemSize(sizeof(OBJECTREF));    
        if (!IsArgumentInRegister(&numregsused, ELEMENT_TYPE_CLASS, 0, TRUE, callconv, NULL)) {
            tmp_nActualStack += StackElemSize(sizeof(OBJECTREF));
        }
    }
    if (HasRetBuffArg()) {
        numregsused++;
        tmp_nVirtualStack += StackElemSize(sizeof(LPVOID));
    }

    
    for (DWORD i=0;i<m_nArgs;i++) { 
        CorElementType corType = p.PeekElemType();
        UINT cbSize = p.SizeOf(m_pModule, corType);   
        tmp_nVirtualStack += StackElemSize(cbSize);   

        CorElementType type = p.Normalize(m_pModule, corType); 

        if (m_nArgs <= MAX_CACHED_SIG_SIZE)
        {
            m_types[i] = type;
            m_sizes[i] = cbSize;
            // The value of m_offsets is determined by IsArgumentInRegister.
            // We can not initialize it to -1, because it may trash
            // what has been set by another thread.
            int tmp_offsets = -1;
            if (!IsArgumentInRegister(&numregsused, type, cbSize, FALSE, callconv, &tmp_offsets)) 
                tmp_nActualStack += StackElemSize(cbSize);
            m_offsets[i] = (short)tmp_offsets;
        }
        else
        {
            if (!IsArgumentInRegister(&numregsused, type, cbSize, FALSE, callconv, NULL)) 
                tmp_nActualStack += StackElemSize(cbSize);
        }
        p.Skip();
    }
    if (m_nArgs <= MAX_CACHED_SIG_SIZE)
    {
        m_types[m_nArgs] = ELEMENT_TYPE_END;
        m_fCacheInitted |= SIG_OFFSETS_INITTED;
    }

        // Parameterized type passed as last parameter, but not mentioned in the sig
    if (GetCallingConventionInfo() & CORINFO_CALLCONV_PARAMTYPE)
        if (!IsArgumentInRegister(&numregsused, ELEMENT_TYPE_I, sizeof(void*), FALSE, callconv, NULL))
            tmp_nActualStack += sizeof(void*);

    m_nActualStack = tmp_nActualStack;
    m_WalkStatic = fIsStatic;
    m_cbSigSize = (UINT32)((PBYTE) p.GetPtr() - (PBYTE) m_pszMetaSig); // @TODO LBS do PTR MAth

    // Final post.  This is the trigger for avoiding subsequent calls to ForceSigWalk.
    // See NeedsSigWalk to understand how this achieves thread safety.
    m_nVirtualStack = tmp_nVirtualStack;
}

        // this walks the sig and checks to see if all  types in the sig can be loaded

        // @TODO: this method is not needed anymore.  The JIT does walk the signature of 
        // every method it calls, and insures that all the types are loaded.
        // Did not remove it simply because it does not meet the triage bar  -vancem
void MetaSig::CheckSigTypesCanBeLoaded(PCCOR_SIGNATURE pSig, Module *pModule)
{
    THROWSCOMPLUSEXCEPTION();

    // The signature format is approximately:
    // CallingConvention   NumberOfArguments    ReturnType   Arg1  ...
    // There is also a blob length at pSig-1.  
    SigPointer ptr(pSig);

    // Skip over calling convention.
    ptr.GetCallingConv();

    unsigned numArgs = (unsigned short) ptr.GetData();

    // must do a skip so we skip any class tokens associated with the return type
    ptr.Skip();
    
    // Force a load of value type arguments.  

    for(unsigned i=0; i < numArgs; i++) 
    {
        unsigned type = ptr.Normalize(pModule);
        if (type == ELEMENT_TYPE_VALUETYPE || type == ELEMENT_TYPE_CLASS) 
        {
            BEGIN_ENSURE_COOPERATIVE_GC();
            OBJECTREF pThrowable = NULL;
            GCPROTECT_BEGIN(pThrowable);
            {
                TypeHandle typeHnd = ptr.GetTypeHandle(pModule, &pThrowable);
                if (typeHnd.IsNull()) 
                {
                    _ASSERTE(pThrowable != NULL);
                    COMPlusThrow(pThrowable);
                }
            }
            GCPROTECT_END();        
            END_ENSURE_COOPERATIVE_GC();
        }
        // Move to next argument token.
        ptr.Skip();
    }
}

// Returns a pointer to the end of the signature in the buffer.  If buffer
// isn't big enough, still returns where the end pointer would be if it
// were big enough, but doesn't write past bufferMax

ULONG MetaSig::GetSignatureForTypeHandle(IMetaDataAssemblyEmit *pAssemblyEmitScope,
                                         IMetaDataEmit *pEmitScope, 
                                         TypeHandle handle, 
                                         COR_SIGNATURE *buffer, 
                                         COR_SIGNATURE *bufferMax)
{
    THROWSCOMPLUSEXCEPTION();

    BYTE *p = buffer;
        
    if (handle.IsArray())
    {
        ArrayTypeDesc *desc = handle.AsArray();
            
        CorElementType arrayType = desc->GetNormCorElementType();

        p += CorSigCompressElementTypeSafe(arrayType, p, bufferMax);
        p += GetSignatureForTypeHandle(pAssemblyEmitScope, pEmitScope, 
                                       desc->GetElementTypeHandle(), p, bufferMax);
            
        switch (arrayType)
        {
        case ELEMENT_TYPE_SZARRAY:
            break;
                                    
        case ELEMENT_TYPE_ARRAY:
            p += CorSigCompressDataSafe(desc->GetRank(), p, bufferMax);
            p += CorSigCompressDataSafe(0, p, bufferMax);
            p += CorSigCompressDataSafe(0, p, bufferMax);
            break;
        }
    }
    else if (handle.IsTypeDesc())
    {
        TypeDesc *desc = handle.AsTypeDesc();
        p += CorSigCompressElementTypeSafe(desc->GetNormCorElementType(), p, bufferMax);

        if (CorTypeInfo::IsModifier(desc->GetNormCorElementType())) 
        {
            p += GetSignatureForTypeHandle(pAssemblyEmitScope, pEmitScope, desc->GetTypeParam(), p, bufferMax);
        }
        else 
        {
            _ASSERTE(desc->GetNormCorElementType() == ELEMENT_TYPE_FNPTR);
            ExpandSig* expandSig = ((FunctionTypeDesc*) desc)->GetSig();

                // Emit calling convention
            if (p < bufferMax)
                *p = expandSig->GetCallingConventionInfo();
            p++;
                // number of args
            unsigned numArgs = expandSig->NumFixedArgs();
            p += CorSigCompressDataSafe(numArgs, p, bufferMax);

                // return type 
            p += GetSignatureForTypeHandle(pAssemblyEmitScope, pEmitScope, 
                expandSig->GetReturnTypeHandle(), p, bufferMax);

                // args
            void* iter;
            expandSig->Reset(&iter);
            while (numArgs > 0) {
                p += GetSignatureForTypeHandle(pAssemblyEmitScope, pEmitScope, 
                    expandSig->NextArgExpanded(&iter), p, bufferMax);
                --numArgs;
            }

        }
    }
    else
    {
        MethodTable *pMT = handle.AsMethodTable();

        if (pMT->GetClass()->IsTruePrimitive())
        {
            p += CorSigCompressElementTypeSafe(pMT->GetNormCorElementType(), p, bufferMax);
        }
        else if (pMT->IsArray())
        {
            CorElementType type = pMT->GetNormCorElementType();
            p += CorSigCompressElementTypeSafe(type, p, bufferMax);
            switch (type)
            {
            case ELEMENT_TYPE_SZARRAY:
                {
                    ArrayClass *pArrayClass = (ArrayClass*)pMT->GetClass();
                    TypeHandle elementType = pArrayClass->GetElementTypeHandle();
                    p += GetSignatureForTypeHandle(pAssemblyEmitScope,
                                                   pEmitScope, elementType, 
                                                   p, bufferMax);
                }
                break;

            case ELEMENT_TYPE_ARRAY:
                {
                    ArrayClass *pArrayClass = (ArrayClass*)pMT->GetClass();
                    TypeHandle elementType = pArrayClass->GetElementTypeHandle();
                    p += GetSignatureForTypeHandle(pAssemblyEmitScope,
                                                   pEmitScope, elementType, 
                                                   p, bufferMax);
                    p += CorSigCompressDataSafe(pArrayClass->GetRank(), p, bufferMax);
                    p += CorSigCompressDataSafe(0, p, bufferMax);
                    p += CorSigCompressDataSafe(0, p, bufferMax);
                }
                break;
                
            default:
                _ASSERTE(!"Unknown array type");
            }
        }
        else
        {
            // Beware of enums!  Can't use GetNormCorElementType() here.

            p += CorSigCompressElementTypeSafe(pMT->IsValueClass() 
                                               ? ELEMENT_TYPE_VALUETYPE : ELEMENT_TYPE_CLASS, 
                                               p, bufferMax);

            mdToken token = pMT->GetClass()->GetCl();

            _ASSERTE(!IsNilToken(token));

            if (pEmitScope != NULL)
            {
                HRESULT hr = pEmitScope->DefineImportType(
                                                  pMT->GetAssembly()->GetManifestAssemblyImport(),
                                                  NULL, 0, 
                                                  pMT->GetModule()->GetImporter(),
                                                  token, pAssemblyEmitScope, &token);
                if (FAILED(hr))
                    COMPlusThrowHR(hr);
            }

            p += CorSigCompressTokenSafe(token, p, bufferMax);
        }
    }

    return (ULONG)(p - buffer);      
}

mdToken MetaSig::GetTokenForTypeHandle(IMetaDataAssemblyEmit *pAssemblyEmitScope,
                                       IMetaDataEmit *pEmitScope,
                                       TypeHandle handle)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;

    mdToken result = mdTokenNil;
        
    if (!handle.IsUnsharedMT()
        || handle.GetClass()->IsArrayClass())
    {
        CQuickBytes buffer;
        
        ULONG size = GetSignatureForTypeHandle(pAssemblyEmitScope,
                                               pEmitScope, 
                                               handle, 
                                               (BYTE *)buffer.Ptr(), 
                                               ((BYTE *)buffer.Ptr()) + buffer.Size());

        if (size > (ULONG) buffer.Size())
        {
            if (SUCCEEDED(hr = buffer.ReSize(size))) {
                size = GetSignatureForTypeHandle(pAssemblyEmitScope,
                                                 pEmitScope, 
                                                 handle, 
                                                 (BYTE *)buffer.Ptr(), 
                                                 ((BYTE *)buffer.Ptr()) + buffer.Size());
            }
        }

        if (SUCCEEDED(hr))
            hr = pEmitScope->GetTokenFromTypeSpec((BYTE*) buffer.Ptr(), size, &result);
    }
    else
    {
        MethodTable *pMT = handle.AsMethodTable();

        mdTypeDef td = pMT->GetClass()->GetCl();

        hr = pEmitScope->DefineImportType(pMT->GetAssembly()->GetManifestAssemblyImport(), 
                                          NULL, 0, 
                                          pMT->GetModule()->GetImporter(),
                                          td, pAssemblyEmitScope, &result);
    }

    if (FAILED(hr))
        COMPlusThrowHR(hr);

    return result;
}

// Returns a pointer to the end of the signature in the buffer.  If buffer
// isn't big enough, still returns where the end pointer would be if it
// were big enough, but doesn't write past bufferMax

ULONG SigPointer::GetImportSignature(IMetaDataImport *pInputScope,
                                     IMetaDataAssemblyImport *pAssemblyInputScope,
                                     IMetaDataEmit *pEmitScope, 
                                     IMetaDataAssemblyEmit *pAssemblyEmitScope, 
                                     PCOR_SIGNATURE buffer, 
                                     PCOR_SIGNATURE bufferMax)
{
    THROWSCOMPLUSEXCEPTION();
    
    BYTE *p = buffer;

    CorElementType type = CorSigUncompressElementType(m_ptr);
    p += CorSigCompressElementTypeSafe(type, p, bufferMax);

    if (CorIsPrimitiveType(type))
        return (ULONG)(p - buffer);

    switch (type)
    {
    default:
        _ASSERTE(!"Illegal or unimplement type in COM+ sig.");
        return NULL;

    case ELEMENT_TYPE_OBJECT:
    case ELEMENT_TYPE_STRING:
    case ELEMENT_TYPE_TYPEDBYREF:
    case ELEMENT_TYPE_U:
    case ELEMENT_TYPE_I:
    case ELEMENT_TYPE_R:
        return (ULONG)(p - buffer);

    case ELEMENT_TYPE_BYREF:
    case ELEMENT_TYPE_PTR:
    case ELEMENT_TYPE_PINNED:
    case ELEMENT_TYPE_SZARRAY:
        p += GetImportSignature(pInputScope, pAssemblyInputScope, 
                                pEmitScope, pAssemblyEmitScope, p, bufferMax);
        return (ULONG)(p - buffer);

    case ELEMENT_TYPE_VALUETYPE:
    case ELEMENT_TYPE_CLASS:
    case ELEMENT_TYPE_CMOD_REQD:
    case ELEMENT_TYPE_CMOD_OPT:
        {
            mdToken token = CorSigUncompressToken(m_ptr);
            if (RidFromToken(token) != 0)
            {
                HRESULT hr = pEmitScope->DefineImportType(pAssemblyInputScope, 
                                                          NULL, 0, 
                                                          pInputScope, 
                                                          token, pAssemblyEmitScope, 
                                                          &token);
                if (FAILED(hr))
                    COMPlusThrowHR(hr);
            }

            p += CorSigCompressTokenSafe(token, p, bufferMax);

            return (ULONG)(p - buffer);
        }

    case ELEMENT_TYPE_VALUEARRAY: 
        {
            p += GetImportSignature(pInputScope, pAssemblyInputScope, 
                                    pEmitScope, pAssemblyEmitScope,
                                    p, bufferMax);
            ULONG size = CorSigUncompressData(m_ptr);
            p += CorSigCompressDataSafe(size, p, bufferMax);

            return (ULONG)(p - buffer);
        }

    case ELEMENT_TYPE_VAR:
        {
            ULONG size = CorSigUncompressData(m_ptr);
            p += CorSigCompressDataSafe(size, p, bufferMax);
            return (ULONG)(p - buffer);
        }

    case ELEMENT_TYPE_FNPTR:
        p += GetImportFunctionSignature(pInputScope, pAssemblyInputScope, 
                                        pEmitScope, pAssemblyEmitScope, 
                                        p, bufferMax);

        return (ULONG)(p - buffer);

    case ELEMENT_TYPE_ARRAY: 

        // element type
        p += GetImportSignature(pInputScope, pAssemblyInputScope, 
                                pEmitScope, pAssemblyEmitScope, 
                                p, bufferMax);

        // rank
        ULONG rank = CorSigUncompressData(m_ptr);
        p += CorSigCompressDataSafe(rank, p, bufferMax);
        
        if (rank > 0)
        {
            ULONG sizes = CorSigUncompressData(m_ptr);
            p += CorSigCompressDataSafe(sizes, p, bufferMax);

            while (sizes-- > 0)
            {
                ULONG size = CorSigUncompressData(m_ptr);
                p += CorSigCompressDataSafe(size, p, bufferMax);
            }

            ULONG bounds = CorSigUncompressData(m_ptr);
            p += CorSigCompressDataSafe(bounds, p, bufferMax);

            while (bounds-- > 0)
            {
                ULONG bound = CorSigUncompressData(m_ptr);
                p += CorSigCompressDataSafe(bound, p, bufferMax);
            }
        }

        return (ULONG)(p - buffer);
    }
}

ULONG SigPointer::GetImportFunctionSignature(IMetaDataImport *pInputScope,
                                             IMetaDataAssemblyImport *pAssemblyInputScope,
                                             IMetaDataEmit *pEmitScope, 
                                             IMetaDataAssemblyEmit *pAssemblyEmitScope, 
                                             PCOR_SIGNATURE buffer, 
                                             PCOR_SIGNATURE bufferMax)
{
    BYTE *p = buffer;

    // Calling convention
    int conv = CorSigUncompressCallingConv(m_ptr);
    p += CorSigCompressDataSafe(conv, p, bufferMax);

    // Arg count
    int argCount = CorSigUncompressData(m_ptr);
    p += CorSigCompressDataSafe(argCount, p, bufferMax);
            
    // return value
    p += GetImportSignature(pInputScope, pAssemblyInputScope, 
                            pEmitScope, pAssemblyEmitScope, 
                            p, bufferMax);
        

    while (argCount-- > 0)
    {
        p += GetImportSignature(pInputScope, pAssemblyInputScope, 
                                pEmitScope, pAssemblyEmitScope, 
                                p, bufferMax);
    }

    return (ULONG)(p - buffer);
}


//----------------------------------------------------------
// Returns the unmanaged calling convention.
//----------------------------------------------------------
/*static*/ CorPinvokeMap MetaSig::GetUnmanagedCallingConvention(Module *pModule, PCCOR_SIGNATURE pSig, ULONG cSig)
{
    MetaSig msig(pSig, pModule);
    PCCOR_SIGNATURE pWalk = msig.m_pRetType.GetPtr();
    _ASSERTE(pWalk <= pSig + cSig);
    while (pWalk < pSig + cSig)
    {
        if (*pWalk != ELEMENT_TYPE_CMOD_OPT && *pWalk != ELEMENT_TYPE_CMOD_REQD)
        {
            break;
        }
        if (*pWalk == ELEMENT_TYPE_CMOD_OPT)
        {
            pWalk++;
            if (pWalk + CorSigUncompressedDataSize(pWalk) > pSig + cSig)
            {
                return (CorPinvokeMap)0; // Bad formatting
                break;
            }
            mdToken tk;
            pWalk += CorSigUncompressToken(pWalk, &tk);

            // Old code -- this should be deleted after C++ has converted.
            if (IsTypeRefOrDef("System.Runtime.InteropServices.CallConvCdecl", pModule, tk))
            {
                return pmCallConvCdecl;
            } 
            else if (IsTypeRefOrDef("System.Runtime.InteropServices.CallConvStdcall", pModule, tk))
            {
                return pmCallConvStdcall;
            }
            else if (IsTypeRefOrDef("System.Runtime.InteropServices.CallConvThiscall", pModule, tk))
            {
                return pmCallConvThiscall;
            }
            else if (IsTypeRefOrDef("System.Runtime.InteropServices.CallConvFastcall", pModule, tk))
            {
                return pmCallConvFastcall;
            }
        
            // New code -- this should be retained.
            if (IsTypeRefOrDef("System.Runtime.CompilerServices.CallConvCdecl", pModule, tk))
            {
                return pmCallConvCdecl;
            } 
            else if (IsTypeRefOrDef("System.Runtime.CompilerServices.CallConvStdcall", pModule, tk))
            {
                return pmCallConvStdcall;
            }
            else if (IsTypeRefOrDef("System.Runtime.CompilerServices.CallConvThiscall", pModule, tk))
            {
                return pmCallConvThiscall;
            }
            else if (IsTypeRefOrDef("System.Runtime.CompilerServices.CallConvFastcall", pModule, tk))
            {
                return pmCallConvFastcall;
            }
        
        }


    }

    
    return (CorPinvokeMap)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\simplerwlock.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "simplerwlock.hpp"

BOOL SimpleRWLock::TryEnterRead()
{

#ifdef _DEBUG
    if (m_gcMode == PREEMPTIVE)
        _ASSERTE(!GetThread() || !GetThread()->PreemptiveGCDisabled());
    else if (m_gcMode == COOPERATIVE)
        _ASSERTE(!GetThread() || GetThread()->PreemptiveGCDisabled());
#endif

    LONG RWLock;

    do {
        RWLock = m_RWLock;
        if( RWLock == -1 ) return FALSE;
    } while( RWLock != InterlockedCompareExchange( &m_RWLock, RWLock+1, RWLock ));

    INCTHREADLOCKCOUNT();
    
    return TRUE;
}

//=====================================================================        
void SimpleRWLock::EnterRead()
{
#ifdef _DEBUG
    if (m_gcMode == PREEMPTIVE)
        _ASSERTE(!GetThread() || !GetThread()->PreemptiveGCDisabled());
    else if (m_gcMode == COOPERATIVE)
        _ASSERTE(!GetThread() || GetThread()->PreemptiveGCDisabled());
#endif

    // prevent writers from being starved. This assumes that writers are rare and 
    // dont hold the lock for a long time. 
    while (IsWriterWaiting())
    {
        int spinCount = m_spinCount;
        while (spinCount > 0) {
            spinCount--;
            pause();
        }
        __SwitchToThread(0);
    }

    while (!TryEnterRead());
}

//=====================================================================        
BOOL SimpleRWLock::TryEnterWrite()
{

#ifdef _DEBUG
    if (m_gcMode == PREEMPTIVE)
        _ASSERTE(!GetThread() || !GetThread()->PreemptiveGCDisabled());
    else if (m_gcMode == COOPERATIVE)
        _ASSERTE(!GetThread() || GetThread()->PreemptiveGCDisabled());
#endif

    LONG RWLock = InterlockedCompareExchange( &m_RWLock, -1, 0 );

    if( RWLock ) {
        return FALSE;
    }
    
    INCTHREADLOCKCOUNT();
    
    return TRUE;
}

//=====================================================================        
void SimpleRWLock::EnterWrite()
{
#ifdef _DEBUG
    if (m_gcMode == PREEMPTIVE)
        _ASSERTE(!GetThread() || !GetThread()->PreemptiveGCDisabled());
    else if (m_gcMode == COOPERATIVE)
        _ASSERTE(!GetThread() || GetThread()->PreemptiveGCDisabled());
#endif

    BOOL set = FALSE;

    while (!TryEnterWrite())
    {
        // set the writer waiting word, if not already set, to notify potential
        // readers to wait. Remember, if the word is set, so it can be reset later.
        if (!IsWriterWaiting())
        {
            SetWriterWaiting();
            set = TRUE;
        }
    }

    if (set)
        ResetWriterWaiting();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\simplerwlock.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _SimpleRWLock_hpp_
#define _SimpleRWLock_hpp_
enum GC_MODE {
    COOPERATIVE,
    PREEMPTIVE,
    COOPERATIVE_OR_PREEMPTIVE} ;
    
class SimpleRWLock
{
public:
    SimpleRWLock (GC_MODE gcMode, LOCK_TYPE locktype)
        : m_gcMode (gcMode)
    {
        m_lock.Init(locktype);	
        m_RWLock = 0;
		m_spinCount = (GetCurrentProcessCpuCount() == 1) ? 0 : 4000;
        m_WriterWaiting = FALSE;
    }
    
	// Lock and Unlock, use a very fast lock like a spin lock
    void LOCK()
    {
		m_lock.GetLock();
    }

    void UNLOCK()
    {
		m_lock.FreeLock();
    }

    // Acquire the reader lock.
    BOOL TryEnterRead();
    void EnterRead();

    // Acquire the writer lock.
    BOOL TryEnterWrite();
    void EnterWrite();

    // Leave the reader lock.
    void LeaveRead()
    {
        _ASSERTE(m_RWLock > 0);
        InterlockedDecrement(&m_RWLock);
        DECTHREADLOCKCOUNT();
    }

    // Leave the writer lock.
    void LeaveWrite()
    {
        _ASSERTE(m_RWLock == -1);
        m_RWLock = 0;
        DECTHREADLOCKCOUNT();
    }

#ifdef _DEBUG
    BOOL LockTaken ()
    {
        return m_RWLock != 0;
    }

    BOOL IsReaderLock ()
    {
        return m_RWLock > 0;
    }

    BOOL IsWriterLock ()
    {
        return m_RWLock < 0;
    }
    
#endif
    
private:
    BOOL IsWriterWaiting()
    {
        return m_WriterWaiting != 0;
    }

    void SetWriterWaiting()
    {
        m_WriterWaiting = 1;
    }

    void ResetWriterWaiting()
    {
        m_WriterWaiting = 0;
    }

	// spin lock for fast synchronization	
	SpinLock            m_lock;

    // lock used for R/W synchronization
    LONG                m_RWLock;     

    // Does this lock require to be taken in PreemptiveGC mode?
    const GC_MODE          m_gcMode;

    // spin count for a reader waiting for a writer to release the lock
    LONG                m_spinCount;

    // used to prevent writers from being starved by readers
    // we currently do not prevent writers from starving readers since writers 
    // are supposed to be rare.
    BOOL                m_WriterWaiting;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\spinlock.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//----------------------------------------------------------------------------
//	spinlock.h , defines the spin lock class and a profiler class
//  	
//----------------------------------------------------------------------------


//#ifndef _H_UTIL
//#error I am a part of util.hpp Please don't include me alone !
//#endif


#ifndef _H_SPINLOCK_
#define _H_SPINLOCK_

#include <stddef.h>

// Lock Types, used in profiling
//
enum LOCK_TYPE
{
	LOCK_STARTUP	 = 0,
	LOCK_THREAD_POOL  = 1,
	LOCK_PLUSWRAPPER_CACHE = 2,
	LOCK_COMWRAPPER_CACHE = 3,
	LOCK_HINTCACHE = 4,
    LOCK_COMIPLOOKUP = 5,
    LOCK_FCALL = 7,
	LOCK_COMCTXENTRYCACHE = 8,
    LOCK_COMCALL = 9,
    LOCK_REFLECTCACHE = 10,
    LOCK_SECURITY_SHARED_DESCRIPTOR = 11,
	LOCK_TYPE_DEFAULT  = 12
};

//----------------------------------------------------------------------------
// class: Spinlock 
//
// PURPOSE:
//	 spinlock class that contains constructor and out of line spinloop.
//
//----------------------------------------------------------------------------
class SpinLock
{
protected:
	// m_lock has to be the fist data member in the class
	volatile DWORD      m_lock;		// DWORD used in interlocked exchange	
    
#ifdef _DEBUG
    LOCK_TYPE           m_LockType;		// lock type to track statistics
    bool                m_fInitialized; // DEBUG check to verify initialized
    
    // Check for dead lock situation.
    bool                m_heldInSuspension; // may be held while the thread is
                                            // suspended.
    bool                m_enterInCoopGCMode;
    ULONG               m_ulReadyForSuspensionCount;
    DWORD               m_holdingThreadId;
#endif

public:
		//Init method, initialize lock and _DEBUG flags
	void Init(LOCK_TYPE type)
	{
		m_lock = 0;		

#ifdef _DEBUG
        m_LockType = type;
        m_heldInSuspension = false;
        m_enterInCoopGCMode = false;
        m_fInitialized = true; // DEBUG check for initialization
#endif
	}

	void GetLock () 	// Acquire lock, blocks, if unsuccessfull
	{
		_ASSERTE(m_fInitialized == true);

#ifdef _DEBUG
        dbg_PreEnterLock();
#endif

        LOCKCOUNTINCL("GetLock in spinlock.h");
		if (!GetLockNoWait ())
		{
			SpinToAcquire();
		}
#ifdef _DEBUG
        m_holdingThreadId = GetCurrentThreadId();
        dbg_EnterLock();
#endif
	}
	
	bool GetLockNoWait();	// Acquire lock, fail-fast 

	void FreeLock ();		// Release lock

	void SpinToAcquire (); // out of line call spins 

    //-----------------------------------------------------------------
    // Is the current thread the owner?
    //-----------------------------------------------------------------
#ifdef _DEBUG
    BOOL OwnedByCurrentThread()
    {
        return m_holdingThreadId == GetCurrentThreadId();
    }
#endif
    
private:
#ifdef _DEBUG
    void dbg_PreEnterLock();
    void dbg_EnterLock();
    void dbg_LeaveLock();
#endif

    BOOL LockIsFree()
    {
        return (m_lock == 0);
    }


    // Helper functions to track lock count per thread.
    void IncThreadLockCount();
    void DecThreadLockCount();
};

//----------------------------------------------------------------------------
// SpinLock::GetLockNoWait   
// used interlocked exchange and fast lock acquire

#pragma warning (disable : 4035)
inline bool
SpinLock::GetLockNoWait ()
{
	if (LockIsFree() && FastInterlockExchange ((long*)&m_lock, 1) == 0)
    {
        IncThreadLockCount();
        return 1;
    }
    else
        return 0;
} // SpinLock::GetLockNoWait ()

#pragma warning (default : 4035)

//----------------------------------------------------------------------------
// SpinLock::FreeLock   
//  Release the spinlock
//
inline void
SpinLock::FreeLock ()
{
	_ASSERTE(m_fInitialized);

#ifdef _DEBUG
    _ASSERTE(OwnedByCurrentThread());
    m_holdingThreadId = -1;
    dbg_LeaveLock();
#endif

#if defined (_X86_)
	// This inline asm serves to force the compiler
	// to complete all preceding stores.  Without it,
	// the compiler may clear the spinlock *before*
	// it completes all of the work that was done
	// inside the spinlock.	
	_asm {}

	// This generates a smaller instruction to clear out
	// the byte containing the 1.
	//
	*(char*)&m_lock = 0;

#else
	// else uses interlocked exchange.
	//
	FastInterlockExchange ((long*)&m_lock, 0);
#endif

	LOCKCOUNTDECL("GetLock in spinlock.h");
    DecThreadLockCount();

} // SpinLock::FreeLock ()

__inline BOOL IsOwnerOfSpinLock (LPVOID lock)
{
#ifdef _DEBUG
    return ((SpinLock*)lock)->OwnedByCurrentThread();
#else
    // This function should not be called on free build.
    DebugBreak();
    return TRUE;
#endif
}

#ifdef _DEBUG
//----------------------------------------------------------------------------
// class SpinLockProfiler 
//  to track contention, useful for profiling
//
//----------------------------------------------------------------------------
class SpinLockProfiler
{
	// Pointer to spinlock names.
	//
	static ULONG	s_ulBackOffs;
	static ULONG	s_ulCollisons [LOCK_TYPE_DEFAULT + 1];
	static ULONG	s_ulSpins [LOCK_TYPE_DEFAULT + 1];

public:

	static void	InitStatics ()
	{
		s_ulBackOffs = 0;
		memset (s_ulCollisons, 0, sizeof (s_ulCollisons));
		memset (s_ulSpins, 0, sizeof (s_ulSpins));
	}

	static void	IncrementSpins (LOCK_TYPE type, ULONG value)
	{
        _ASSERTE(type <= LOCK_TYPE_DEFAULT);
		s_ulSpins [type] += value;
	}

	static void	IncrementCollisions (LOCK_TYPE type)
	{
		++s_ulCollisons [type];
	}

	static void IncrementBackoffs (ULONG value)
	{
		s_ulBackOffs += value;
	}

	static void DumpStatics()
	{
		//@todo 
	}

};

#endif	// ifdef _DEBUG
#endif //  ifndef _H_SPINLOCK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\siginfo.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// siginfo.hpp
//
#ifndef _H_SIGINFO
#define _H_SIGINFO

#include "util.hpp"
#include "vars.hpp"
#include "frames.h"

#ifdef COMPLUS_EE
#include "gcscan.h"
#else
// Hack to allow the JIT executable to work
// They have a PELoader but not a Module. All the
// code that uses getScope() from module is currently
// ifdef'd out as well
#define Module mdScope
#endif




// uncompress encoded element type. throw away any custom modifier prefixes along
// the way.
FORCEINLINE CorElementType CorSigEatCustomModifiersAndUncompressElementType(//Element type
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    while (ELEMENT_TYPE_CMOD_REQD == *pData || ELEMENT_TYPE_CMOD_OPT == *pData)
    {
        pData++;
        CorSigUncompressToken(pData);
    }
    return (CorElementType)*pData++;
}

// CorSig helpers which won't overflow your buffer

inline ULONG CorSigCompressDataSafe(ULONG iLen, BYTE *pDataOut, BYTE *pDataMax)
{
    BYTE buffer[4];
    ULONG result = CorSigCompressData(iLen, buffer);
    if (pDataOut + result < pDataMax)
        pDataMax = pDataOut + result;
	if (pDataMax > pDataOut)
		CopyMemory(pDataOut, buffer, pDataMax - pDataOut);
    return result;
}

inline ULONG CorSigCompressTokenSafe(mdToken tk, BYTE *pDataOut, BYTE *pDataMax)
{
    BYTE buffer[4];
    ULONG result = CorSigCompressToken(tk, buffer);
    if (pDataOut + result < pDataMax)
        pDataMax = pDataOut + result;
	if (pDataMax > pDataOut)
		CopyMemory(pDataOut, buffer, pDataMax - pDataOut);
    return result;
}

inline ULONG CorSigCompressSignedIntSafe(int iData, BYTE *pDataOut, BYTE *pDataMax)
{
    BYTE buffer[4];
    ULONG result = CorSigCompressSignedInt(iData, buffer);
    if (pDataOut + result < pDataMax)
        pDataMax = pDataOut + result;
	if (pDataMax > pDataOut)
		CopyMemory(pDataOut, buffer, pDataMax - pDataOut);
    return result;
}

inline ULONG CorSigCompressElementTypeSafe(CorElementType et, 
                                           BYTE *pDataOut, BYTE *pDataMax)
{
    if (pDataMax > pDataOut)
        return CorSigCompressElementType(et, pDataOut);
    else
        return 1;
}


struct ElementTypeInfo {
#ifdef _DEBUG
    int            m_elementType;     
#endif
    int            m_cbSize;
    CorInfoGCType  m_gc         : 3;
    int            m_fp         : 1;
    int            m_enregister : 1;
    int            m_isBaseType : 1;

};
extern const ElementTypeInfo gElementTypeInfo[];

unsigned GetSizeForCorElementType(CorElementType etyp);
const ElementTypeInfo* GetElementTypeInfo(CorElementType etyp);
BOOL    IsFP(CorElementType etyp);
BOOL    IsBaseElementType(CorElementType etyp);

//----------------------------------------------------------------------------
// enum StringType
// defines the various string types
enum StringType
{
    enum_BSTR = 0,
    enum_WSTR = 1,
    enum_CSTR = 2,
    enum_AnsiBSTR = 3,
};


//----------------------------------------------------------------------------
// IsAnsi
inline  BOOL IsAnsi(StringType styp)
{
    return styp == enum_CSTR;
}


//----------------------------------------------------------------------------
// IsBSTR
inline  BOOL IsBSTR(StringType styp)
{
    return styp == enum_BSTR;
}


//----------------------------------------------------------------------------
// IsWSTR
inline  BOOL IsWSTR(StringType styp)
{
    return styp == enum_WSTR;
}

//----------------------------------------------------------------------------
// Free String call appropriate free
inline VOID FreeString(LPVOID pv, StringType styp)
{
    if (pv != NULL)
    {
        if (IsBSTR(styp))
        {
            SysFreeString((BSTR)pv);
        }
        else
        {
            CoTaskMemFree(pv);
        }
    }
}


//------------------------------------------------------------------------
// Encapsulates how compressed integers and typeref tokens are encoded into
// a bytestream.
//
// For M3.5, the bytestream *is* a bytestream. Later on, we may change
// to a nibble-based or var-length encoding, in which case, the implementation
// of this class will become more complex.
//------------------------------------------------------------------------
class SigPointer
{
    private:
        PCCOR_SIGNATURE m_ptr;

    public:
        //------------------------------------------------------------------------
        // Constructor.
        //------------------------------------------------------------------------
        SigPointer() {}

        //------------------------------------------------------------------------
        // Initialize 
        //------------------------------------------------------------------------
        FORCEINLINE SigPointer(PCCOR_SIGNATURE ptr)
        {
            m_ptr = ptr;
        }

        FORCEINLINE SetSig(PCCOR_SIGNATURE ptr)
        {
            m_ptr = ptr;
        }

        //------------------------------------------------------------------------
        // Remove one compressed integer (using CorSigUncompressData) from
        // the head of the stream and return it.
        //------------------------------------------------------------------------
        FORCEINLINE ULONG GetData()
        {
            return CorSigUncompressData(m_ptr);
        }


        //-------------------------------------------------------------------------
        // Remove one byte and return it.
        //-------------------------------------------------------------------------
        FORCEINLINE BYTE GetByte()
        {
            return *(m_ptr++);
        }


        FORCEINLINE CorElementType GetElemType()
        {
            return (CorElementType) CorSigEatCustomModifiersAndUncompressElementType(m_ptr);
        }

        ULONG GetCallingConvInfo()  
        {   
            return CorSigUncompressCallingConv(m_ptr);  
        }   

        ULONG GetCallingConv()  
        {   
            return IMAGE_CEE_CS_CALLCONV_MASK & CorSigUncompressCallingConv(m_ptr); 
        }   

        //------------------------------------------------------------------------
        // Non-destructive read of compressed integer.
        //------------------------------------------------------------------------
        ULONG PeekData() const
        {
            PCCOR_SIGNATURE tmp = m_ptr;
            return CorSigUncompressData(tmp);
        }


        //------------------------------------------------------------------------
        // Non-destructive read of element type.
        //
        // This routine makes it look as if the String type is encoded
        // via ELEMENT_TYPE_CLASS followed by a token for the String class,
        // rather than the ELEMENT_TYPE_STRING. This is partially to avoid
        // rewriting client code which depended on this behavior previously.
        // But it also seems like the right thing to do generally.
        //------------------------------------------------------------------------
        CorElementType PeekElemType() const
        {
            PCCOR_SIGNATURE tmp = m_ptr;
            CorElementType typ = CorSigEatCustomModifiersAndUncompressElementType(tmp);
            if (typ == ELEMENT_TYPE_STRING || typ == ELEMENT_TYPE_OBJECT)
                return ELEMENT_TYPE_CLASS;
            return typ;
        }


        //------------------------------------------------------------------------
        // Removes a compressed metadata token and returns it.
        //------------------------------------------------------------------------
        FORCEINLINE mdTypeRef GetToken()
        {
            return CorSigUncompressToken(m_ptr);
        }


        //------------------------------------------------------------------------
        // Tests if two SigPointers point to the same location in the stream.
        //------------------------------------------------------------------------
        FORCEINLINE BOOL Equals(SigPointer sp) const
        {
            return m_ptr == sp.m_ptr;
        }


        //------------------------------------------------------------------------
        // Assumes that the SigPointer points to the start of an element type
        // (i.e. function parameter, function return type or field type.)
        // Advances the pointer to the first data after the element type.  This
        // will skip the following varargs sentinal if it is there.
        //------------------------------------------------------------------------
        VOID Skip();

        //------------------------------------------------------------------------
        // Like Skip, but will not skip a following varargs sentinal.
        //------------------------------------------------------------------------
        VOID SkipExactlyOne();

        //------------------------------------------------------------------------
        // Skip a sub signature (as immediately follows an ELEMENT_TYPE_FNPTR).
        //------------------------------------------------------------------------
        VOID SkipSignature();


        //------------------------------------------------------------------------
        // Get info about single-dimensional arrays
        //------------------------------------------------------------------------
        VOID GetSDArrayElementProps(SigPointer *pElemType, ULONG *pElemCount) const;


        //------------------------------------------------------------------------
        // Move signature to another scope
        //------------------------------------------------------------------------
        ULONG GetImportSignature(IMetaDataImport *pInputScope,
                                 IMetaDataAssemblyImport *pAssemblyInputScope,
                                 IMetaDataEmit *pEmitScope, 
                                 IMetaDataAssemblyEmit *pAssemblyEmitScope, 
                                 PCOR_SIGNATURE buffer, 
                                 PCOR_SIGNATURE bufferMax);
    
        ULONG GetImportFunctionSignature(IMetaDataImport *pInputScope,
                                         IMetaDataAssemblyImport *pAssemblyInputScope,
                                         IMetaDataEmit *pEmitScope, 
                                         IMetaDataAssemblyEmit *pAssemblyEmitScope, 
                                         PCOR_SIGNATURE buffer, 
                                         PCOR_SIGNATURE bufferMax);

// This functionality needs to "know" about internal VM structures (like EEClass).
// It is conditionally included so that other projects can use the rest of the
// functionality in this file.

#ifdef COMPLUS_EE
        CorElementType Normalize(Module* pModule) const;
        CorElementType Normalize(Module* pModule, CorElementType type) const;

        FORCEINLINE CorElementType PeekElemTypeNormalized(Module* pModule) const {
            return Normalize(pModule);
        }

        //------------------------------------------------------------------------
        // Assumes that the SigPointer points to the start of an element type.
        // Returns size of that element in bytes. This is the minimum size that a
        // field of this type would occupy inside an object. 
        //------------------------------------------------------------------------
        UINT SizeOf(Module* pModule) const;
        UINT SizeOf(Module* pModule, CorElementType type) const;

        //------------------------------------------------------------------------
        // Assuming that the SigPointer points to an ELEMENT_TYPE_CLASS or
        // ELEMENT_TYPE_STRING, and array type returns the specific TypeHandle.
        //------------------------------------------------------------------------
        TypeHandle GetTypeHandle(Module* pModule,OBJECTREF *pThrowable=NULL, 
                                 BOOL dontRestoreTypes=FALSE,
                                 BOOL dontLoadTypes=FALSE,
                                 TypeHandle* varTypes=NULL) const;


        // return the canonical name for the type pointed to by the sigPointer into
        // the buffer 'buff'.  'buff' is of length 'buffLen'.  Return the lenght of
        // the string returned.  Return 0 on failure
        unsigned GetNameForType(Module* pModule, LPUTF8 buff, unsigned buffLen) const;

        //------------------------------------------------------------------------
        // Tests if the element type is a System.String. Accepts
        // either ELEMENT_TYPE_STRING or ELEMENT_TYPE_CLASS encoding.
        //------------------------------------------------------------------------
        BOOL IsStringType(Module* pModule) const;


        //------------------------------------------------------------------------
        // Tests if the element class name is szClassName. 
        //------------------------------------------------------------------------
        BOOL IsClass(Module* pModule, LPCUTF8 szClassName) const;

        //------------------------------------------------------------------------
        // Tests for the existence of a custom modifier
        //------------------------------------------------------------------------
        BOOL HasCustomModifier(Module *pModule, LPCSTR szModName, CorElementType cmodtype) const;

        //------------------------------------------------------------------------
        // Return pointer
        //------------------------------------------------------------------------
        PCCOR_SIGNATURE GetPtr() const
        {
            return m_ptr;
        }

#endif // COMPLUS_EE

};


//------------------------------------------------------------------------
// Encapsulates the format and simplifies walking of MetaData sigs.
//------------------------------------------------------------------------
class ExpandSig;

#ifdef _DEBUG
#define MAX_CACHED_SIG_SIZE     3       // To excercize non-cached code path
#else
#define MAX_CACHED_SIG_SIZE     15
#endif

#define SIG_OFFSETS_INITTED     0x0001
#define SIG_RET_TYPE_INITTED    0x0002

class MetaSig
{
    friend class ArgIterator;
    friend class ExpandSig;
    public:
        enum MetaSigKind { 
            sigMember, 
            sigLocalVars,
            sigField
            };

        //------------------------------------------------------------------
        // Constructor. Warning: Does NOT make a copy of szMetaSig.
        //------------------------------------------------------------------
        MetaSig(PCCOR_SIGNATURE szMetaSig, Module* pModule, BOOL fConvertSigAsVarArg = FALSE, MetaSigKind kind = sigMember);

        //------------------------------------------------------------------
        // Constructor. Fast copy of bytes out of an ExpandSig, for thread-
        // safety reasons.
        //------------------------------------------------------------------
        MetaSig(ExpandSig &shared);

        //------------------------------------------------------------------
        // Constructor. Copy state from existing MetaSig (does not deep copy
        // zsMetaSig). Iterator fields are reset.
        //------------------------------------------------------------------
        MetaSig(MetaSig *pSig) { memcpy(this, pSig, sizeof(MetaSig)); Reset(); }

        void GetRawSig(BOOL fIsStatic, PCCOR_SIGNATURE *pszMetaSig, DWORD *cbSize);

    //------------------------------------------------------------------
        // Returns type of current argument, then advances the argument
        // index. Returns ELEMENT_TYPE_END if already past end of arguments.
        //------------------------------------------------------------------
        CorElementType NextArg();

        //------------------------------------------------------------------
        // Retreats argument index, then returns type of the argument
        // under the new index. Returns ELEMENT_TYPE_END if already at first
        // argument.
        //------------------------------------------------------------------
        CorElementType PrevArg();

        //------------------------------------------------------------------
        // Returns type of current argument index. Returns ELEMENT_TYPE_END if already past end of arguments.
        //------------------------------------------------------------------
        CorElementType PeekArg();

        //------------------------------------------------------------------
        // Returns a read-only SigPointer for the last type to be returned
        // via NextArg() or PrevArg(). This allows extracting more information
        // for complex types.
        //------------------------------------------------------------------
        const SigPointer & GetArgProps() const
        {
            return m_pLastType;
        }

        //------------------------------------------------------------------
        // Returns a read-only SigPointer for the return type.
        // This allows extracting more information for complex types.
        //------------------------------------------------------------------
        const SigPointer & GetReturnProps() const
        {
            return m_pRetType;
        }


        //------------------------------------------------------------------------
        // Returns # of arguments. Does not count the return value.
        // Does not count the "this" argument (which is not reflected om the
        // sig.) 64-bit arguments are counted as one argument.
        //------------------------------------------------------------------------
        static UINT NumFixedArgs(Module* pModule, PCCOR_SIGNATURE pSig);

        //------------------------------------------------------------------------
        // Returns # of arguments. Does not count the return value.
        // Does not count the "this" argument (which is not reflected om the
        // sig.) 64-bit arguments are counted as one argument.
        //------------------------------------------------------------------------
        UINT NumFixedArgs()
        {
            return m_nArgs;
        }
        
        //----------------------------------------------------------
        // Returns the calling convention (see IMAGE_CEE_CS_CALLCONV_*
        // defines in cor.h)
        //----------------------------------------------------------
        static BYTE GetCallingConvention(Module* pModule, PCCOR_SIGNATURE pSig)
        {
            return (BYTE)(IMAGE_CEE_CS_CALLCONV_MASK & (CorSigUncompressCallingConv(/*modifies*/pSig)));
        }

        //----------------------------------------------------------
        // Returns the calling convention (see IMAGE_CEE_CS_CALLCONV_*
        // defines in cor.h)
        //----------------------------------------------------------
        static BYTE GetCallingConventionInfo(Module* pModule, PCCOR_SIGNATURE pSig)
        {
            return (BYTE)CorSigUncompressCallingConv(/*modifies*/pSig);
        }

        //----------------------------------------------------------
        // Returns the calling convention (see IMAGE_CEE_CS_CALLCONV_*
        // defines in cor.h)
        //----------------------------------------------------------
        BYTE GetCallingConvention()
        {
            return m_CallConv & IMAGE_CEE_CS_CALLCONV_MASK; 
        }

        //----------------------------------------------------------
        // Returns the calling convention & flags (see IMAGE_CEE_CS_CALLCONV_*
        // defines in cor.h)
        //----------------------------------------------------------
        BYTE GetCallingConventionInfo()
        {
            return m_CallConv;
        }

        //----------------------------------------------------------
        // Has a 'this' pointer?
        //----------------------------------------------------------
        BOOL HasThis()
        {
            return m_CallConv & IMAGE_CEE_CS_CALLCONV_HASTHIS;
        }

        //----------------------------------------------------------
        // Is vararg?
        //----------------------------------------------------------
        BOOL IsVarArg()
        {
            return GetCallingConvention() == IMAGE_CEE_CS_CALLCONV_VARARG;
        }

        //----------------------------------------------------------
        // Is vararg?
        //----------------------------------------------------------
        static BOOL IsVarArg(Module* pModule, PCCOR_SIGNATURE pSig)
        {
            return GetCallingConvention(pModule, pSig) == IMAGE_CEE_CS_CALLCONV_VARARG;
        }



#ifdef COMPLUS_EE
        Module* GetModule() const {
            return m_pModule;
        }
            
        //----------------------------------------------------------
        // Returns the unmanaged calling convention.
        //----------------------------------------------------------
        static CorPinvokeMap GetUnmanagedCallingConvention(Module *pModule, PCCOR_SIGNATURE pSig, ULONG cSig);

        //------------------------------------------------------------------
        // Like NextArg, but return only normalized type (enums flattned to 
        // underlying type ...
        //------------------------------------------------------------------
        CorElementType NextArgNormalized() {
            m_pLastType = m_pWalk;
            if (m_iCurArg == m_nArgs)
            {
                return ELEMENT_TYPE_END;
            }
            else
            {
                m_iCurArg++;
                CorElementType mt = m_pWalk.Normalize(m_pModule);
                m_pWalk.Skip();
                return mt;
            }
        }

        CorElementType NextArgNormalized(UINT32 *size) {
            m_pLastType = m_pWalk;
            if (m_iCurArg == m_nArgs)
            {
                return ELEMENT_TYPE_END;
            }
            else
            {
                m_iCurArg++;
                CorElementType type = m_pWalk.PeekElemType();
                CorElementType mt = m_pWalk.Normalize(m_pModule, type);
                *size = m_pWalk.SizeOf(m_pModule, type);
                m_pWalk.Skip();
                return mt;
            }
        }
        //------------------------------------------------------------------
        // Like NextArg, but return only normalized type (enums flattned to 
        // underlying type ...
        //------------------------------------------------------------------
        CorElementType PeekArgNormalized();

        // Is there a hidden parameter for the return parameter.  

        BOOL HasRetBuffArg() const
        {
            CorElementType type = GetReturnTypeNormalized();
            return(type == ELEMENT_TYPE_VALUETYPE || type == ELEMENT_TYPE_TYPEDBYREF);
        }


        //------------------------------------------------------------------------
        // Tests if the return type is an object ref 
        //------------------------------------------------------------------------
        BOOL IsObjectRefReturnType()
        {
           switch (GetReturnTypeNormalized())
            {
            case ELEMENT_TYPE_CLASS:
            case ELEMENT_TYPE_SZARRAY:
            case ELEMENT_TYPE_ARRAY:
            case ELEMENT_TYPE_STRING:
            case ELEMENT_TYPE_OBJECT:
            case ELEMENT_TYPE_VAR:
                return TRUE;
            }
           return FALSE;
        }

        static UINT GetFPReturnSize(Module* pModule, PCCOR_SIGNATURE pSig)
        {
            MetaSig msig(pSig, pModule);
            CorElementType rt = msig.GetReturnTypeNormalized();
            return rt == ELEMENT_TYPE_R4 ? 4 : 
                   rt == ELEMENT_TYPE_R8 ? 8 : 0;

        }

        UINT GetReturnTypeSize()
        {    
            return m_pRetType.SizeOf(m_pModule);
        }

        static int GetReturnTypeSize(Module* pModule, PCCOR_SIGNATURE pSig) 
        {
            MetaSig msig(pSig, pModule);
            return msig.GetReturnTypeSize();
        }

        int GetLastTypeSize() 
        {
            return m_pLastType.SizeOf(m_pModule);
        }

        //------------------------------------------------------------------
        // Perform type-specific GC promotion on the value (based upon the
        // last type retrieved by NextArg()).
        //------------------------------------------------------------------
        VOID GcScanRoots(LPVOID pValue, promote_func *fn, ScanContext* sc);

        //------------------------------------------------------------------
        // Is the return type 64 bit?
        //------------------------------------------------------------------
        BOOL Is64BitReturn() const
        {
            CorElementType rt = GetReturnTypeNormalized();
            return (rt == ELEMENT_TYPE_I8 || rt == ELEMENT_TYPE_U8 || rt == ELEMENT_TYPE_R8);
        }
#endif
        //------------------------------------------------------------------
        // Moves index to end of argument list.
        //------------------------------------------------------------------
        VOID GotoEnd();

        //------------------------------------------------------------------
        // reset: goto start pos
        //------------------------------------------------------------------
        VOID Reset();

        //------------------------------------------------------------------
        // Returns type of return value.
        //------------------------------------------------------------------
        FORCEINLINE CorElementType GetReturnType() const
        {
            return m_pRetType.PeekElemType();
        }



// This functionality needs to "know" about internal VM structures (like EEClass).
// It is conditionally included so that other projects can use the rest of the
// functionality in this file.

#ifdef COMPLUS_EE
        FORCEINLINE CorElementType GetReturnTypeNormalized() const
        {
            
            if (m_fCacheInitted & SIG_RET_TYPE_INITTED)
                return m_corNormalizedRetType;
            MetaSig *tempSig = (MetaSig *)this;
            tempSig->m_corNormalizedRetType = m_pRetType.Normalize(m_pModule);
            tempSig->m_fCacheInitted |= SIG_RET_TYPE_INITTED;
            return tempSig->m_corNormalizedRetType;
        }

        //------------------------------------------------------------------
        // Determines if the current argument is System/String.
        // Caller must determine first that the argument type is ELEMENT_TYPE_CLASS.
        //------------------------------------------------------------------
        BOOL IsStringType() const;

        //----------------------------------------------------------------------
        //  determines the type of the string
        //----------------------------------------------------------------------
        VARTYPE GetStringType() const
        {
            // caller must verify that the argument is string type
            // determines the type of the string
            return VT_BSTR;
        }

        //------------------------------------------------------------------
        // Determines if the current argument is a particular class.
        // Caller must determine first that the argument type is ELEMENT_TYPE_CLASS.
        //------------------------------------------------------------------
        BOOL IsClass(LPCUTF8 szClassName) const;


        //------------------------------------------------------------------
        // Determines if the return type is System/String.
        // Caller must determine first that the return type is ELEMENT_TYPE_CLASS.
        //------------------------------------------------------------------
        BOOL IsStringReturnType() const;

        //----------------------------------------------------------------------
        //  determines the type of the string
        //----------------------------------------------------------------------
        VARTYPE GetStringReturnType() const
        {
            // caller must verify that the argument is string type
            // determines the type of the string
            return VT_BSTR;
        }

        //------------------------------------------------------------------
        // If the last thing returned was an Object
        //  this method will return the EEClass pointer for the class
        //------------------------------------------------------------------
        TypeHandle GetTypeHandle(OBJECTREF *pThrowable = NULL, 
                                 BOOL dontRestoreTypes=FALSE,
                                 BOOL dontLoadTypes=FALSE) const
        {
             return m_pLastType.GetTypeHandle(m_pModule, pThrowable, dontRestoreTypes, dontLoadTypes);
        }

        //------------------------------------------------------------------
        // If the Return type is an Object 
        //  this method will return the EEClass pointer for the class
        //------------------------------------------------------------------
        TypeHandle GetRetTypeHandle(OBJECTREF *pThrowable = NULL,
                                    BOOL dontRestoreTypes = FALSE,
                                    BOOL dontLoadTypes = FALSE) const
        {
             return m_pRetType.GetTypeHandle(m_pModule, pThrowable, dontRestoreTypes, dontLoadTypes);
        }

            // Should probably be deprecated
        EEClass* GetRetEEClass(OBJECTREF *pThrowable = NULL) const 
        {
            return(GetRetTypeHandle().GetClass());
        }

        //------------------------------------------------------------------
        // GetByRefType
        //  returns the base type of the reference
        // and for object references, class of the reference
        // the in-out info for this byref param
        //------------------------------------------------------------------
        CorElementType GetByRefType(EEClass** pClass, OBJECTREF *pThrowable = NULL) const;

        static BOOL CompareElementType(PCCOR_SIGNATURE &pSig1,   PCCOR_SIGNATURE &pSig2, 
                                       PCCOR_SIGNATURE pEndSig1, PCCOR_SIGNATURE pEndSig2, 
                                       Module*         pModule1, Module*         pModule2);

        static BOOL CompareMethodSigs(
            PCCOR_SIGNATURE pSig1, 
            DWORD       cSig1, 
            Module*     pModule1, 
            PCCOR_SIGNATURE pSig2, 
            DWORD       cSig2, 
            Module*     pModule2
        );

        static BOOL CompareFieldSigs(
            PCCOR_SIGNATURE pSig1, 
            DWORD       cSig1, 
            Module*     pModule1, 
            PCCOR_SIGNATURE pSig2, 
            DWORD       cSig2, 
            Module*     pModule2
        );

            // This is similar to CompareMethodSigs, but allows ELEMENT_TYPE_VAR's in pSig2, which
            // get instantiated with the types in type handle array 'varTypes'
        static BOOL CompareMethodSigs(
            PCCOR_SIGNATURE pSig1, 
            DWORD       cSig1, 
            Module*     pModule1, 
            PCCOR_SIGNATURE pSig2, 
            DWORD       cSig2, 
            Module*     pModule2,
            TypeHandle* varTypes
        );

        //------------------------------------------------------------------------
        // Returns # of stack bytes required to create a call-stack using
        // the internal calling convention.
        // Includes indication of "this" pointer since that's not reflected
        // in the sig.
        //------------------------------------------------------------------------
        static UINT SizeOfVirtualFixedArgStack(Module* pModule, PCCOR_SIGNATURE szMetaSig, BOOL fIsStatic);
        static UINT SizeOfActualFixedArgStack(Module* pModule, PCCOR_SIGNATURE szMetaSig, BOOL fIsStatic);

        //------------------------------------------------------------------------
        // Returns # of stack bytes to pop upon return.
        // Includes indication of "this" pointer since that's not reflected
        // in the sig.
        //------------------------------------------------------------------------
        static UINT CbStackPop(Module* pModule, PCCOR_SIGNATURE szMetaSig, BOOL fIsStatic)
        {
            if (MetaSig::IsVarArg(pModule, szMetaSig))
            {
                return 0;
            }
            else
            {
                return SizeOfActualFixedArgStack(pModule, szMetaSig, fIsStatic);
            }
        }

        //------------------------------------------------------------------
        // Ensures that all the value types in the sig are loaded. This
        // should be called on sig's that have value types before they
        // are passed to Call(). This ensures that value classes will not
        // be loaded during the operation to determine the size of the
        // stack. Thus preventing the resulting GC hole.
        //------------------------------------------------------------------
        static void EnsureSigValueTypesLoaded(PCCOR_SIGNATURE pSig, Module *pModule)
        {
            MetaSig(pSig, pModule).ForceSigWalk(FALSE);
        }

        // this walks the sig and checks to see if all  types in the sig can be loaded
        static void CheckSigTypesCanBeLoaded(PCCOR_SIGNATURE pSig, Module *pModule);

        // See the comments about thread-safety in ForceSigWalk to understand why
        // this predicate cannot be arbitrarily changed to some other member.
        BOOL NeedsSigWalk()
        {
            return (m_nVirtualStack == (UINT32) -1);
        }

        //------------------------------------------------------------------------
        // The following two routines are the same as the above routines except
        //  they are called on the MetaSig which will cache these values
        //------------------------------------------------------------------------

        UINT SizeOfVirtualFixedArgStack(BOOL fIsStatic)
        {
            if (NeedsSigWalk())
                ForceSigWalk(fIsStatic);
            _ASSERTE(!!fIsStatic == !!m_WalkStatic);    // booleanize
            return m_nVirtualStack;
        }


        UINT SizeOfActualFixedArgStack(BOOL fIsStatic)
        {
            if (NeedsSigWalk())
                ForceSigWalk(fIsStatic);
            _ASSERTE(!!fIsStatic == !!m_WalkStatic);    // booleanize
            return m_nActualStack;
        }

        //------------------------------------------------------------------------

        UINT CbStackPop(BOOL fIsStatic)
        {
            if (IsVarArg())
            {
                return 0;
            }
            else
            {
                return SizeOfActualFixedArgStack(fIsStatic);
            }
        }
        
        UINT GetFPReturnSize()
        {
            CorElementType rt = GetReturnTypeNormalized();
            return rt == ELEMENT_TYPE_R4 ? 4 : 
                   rt == ELEMENT_TYPE_R8 ? 8 : 0;
        }

        void ForceSigWalk(BOOL fIsStatic);

        static ULONG GetSignatureForTypeHandle(IMetaDataAssemblyEmit *pAssemblyEmitScope,
                                               IMetaDataEmit *pEmitScope,
                                               TypeHandle type,
                                               PCOR_SIGNATURE buffer,
                                               PCOR_SIGNATURE bufferMax);

        static mdToken GetTokenForTypeHandle(IMetaDataAssemblyEmit *pAssemblyEmitScope,
                                             IMetaDataEmit *pEmitScope,
                                             TypeHandle type);

#endif  // COMPLUS_EE


    // These are protected because Reflection subclasses Metasig
    protected:

    static const UINT32 s_cSigHeaderOffset;

        // @todo: These fields are only used for new-style signatures.
        Module*      m_pModule;
        SigPointer   m_pStart;
        SigPointer   m_pWalk;
        SigPointer   m_pLastType;
        SigPointer   m_pRetType;
        UINT32       m_nArgs;
        UINT32       m_iCurArg;
    UINT32       m_cbSigSize;
    PCCOR_SIGNATURE m_pszMetaSig;


        // The following are cached so we don't the signature
        //  multiple times
        UINT32       m_nVirtualStack;   // Size of the virtual stack
        UINT32       m_nActualStack;    // Size of the actual stack

        BYTE         m_CallConv;
        BYTE         m_WalkStatic;      // The type of function we walked

        BYTE            m_types[MAX_CACHED_SIG_SIZE + 1];
        short           m_sizes[MAX_CACHED_SIG_SIZE + 1];
        short           m_offsets[MAX_CACHED_SIG_SIZE + 1];
        CorElementType  m_corNormalizedRetType;
        DWORD           m_fCacheInitted;

            // used to treat some sigs as special case vararg
            // used by calli to unmanaged target
        BYTE         m_fTreatAsVarArg;
        BOOL        IsTreatAsVarArg()
        {
                    return m_fTreatAsVarArg;
        }
};

class FieldSig
{
    // For new-style signatures only.
    SigPointer m_pStart;
    Module*    m_pModule;
public:
        //------------------------------------------------------------------
        // Constructor. Warning: Does NOT make a copy of szMetaSig.
        //------------------------------------------------------------------
        
        FieldSig(PCCOR_SIGNATURE szMetaSig, Module* pModule)
        {
            _ASSERTE(*szMetaSig == IMAGE_CEE_CS_CALLCONV_FIELD);
            m_pModule = pModule;
            m_pStart = SigPointer(szMetaSig);
            m_pStart.GetData();     // Skip "calling convention"
        }
        //------------------------------------------------------------------
        // Returns type of the field
        //------------------------------------------------------------------
        CorElementType GetFieldType()
        {
            return m_pStart.PeekElemType();
        }


// This functionality needs to "know" about internal VM structures (like EEClass).
// It is conditionally included so that other projects can use the rest of the
// functionality in this file.

#ifdef COMPLUS_EE

        CorElementType GetFieldTypeNormalized() const
        {
            return m_pStart.Normalize(m_pModule);
        }

        //------------------------------------------------------------------
        // If the last thing returned was an Object
        //  this method will return the EEClass pointer for the class
        //------------------------------------------------------------------
        TypeHandle GetTypeHandle(OBJECTREF *pThrowable = NULL, 
                                 BOOL dontRestoreTypes = FALSE,
                                 BOOL dontLoadTypes = FALSE) const
        {
             return m_pStart.GetTypeHandle(m_pModule, pThrowable, dontRestoreTypes, dontLoadTypes);
        }

        //------------------------------------------------------------------
        // Determines if the current argument is a particular class.
        // Caller must determine first that the argument type is ELEMENT_TYPE_CLASS.
        //------------------------------------------------------------------
        BOOL IsClass(LPCUTF8 szClassName) const
        {
            return m_pStart.IsClass(m_pModule, szClassName);
        }

        //------------------------------------------------------------------
        // Determines if the current argument is System/String.
        // Caller must determine first that the argument type is ELEMENT_TYPE_CLASS.
        //------------------------------------------------------------------
        BOOL FieldSig::IsStringType() const;

        
        //----------------------------------------------------------------------
        //  determines the type of the string
        //----------------------------------------------------------------------
        VARTYPE GetStringType() const
        {
            // caller must verify that the argument is string type
            // determines the type of the string
            return VT_BSTR;
        }

        //------------------------------------------------------------------
        // Returns a read-only SigPointer for extracting more information
        // for complex types.
        //------------------------------------------------------------------
        const SigPointer & GetProps() const
        {
            return m_pStart;
        }

#endif // COMPLUS_EE

};




//=========================================================================
// Indicates whether an argument is to be put in a register using the
// default IL calling convention. This should be called on each parameter
// in the order it appears in the call signature. For a non-static method,
// this function should also be called once for the "this" argument, prior
// to calling it for the "real" arguments. Pass in a typ of IMAGE_CEE_CS_OBJECT.
//
//  *pNumRegistersUsed:  [in,out]: keeps track of the number of argument
//                       registers assigned previously. The caller should
//                       initialize this variable to 0 - then each call
//                       will update it.
//
//  typ:                 the signature type
//  structSize:          for structs, the size in bytes
//  fThis:               is this about the "this" pointer?
//  callconv:            see IMAGE_CEE_CS_CALLCONV_*
//  *pOffsetIntoArgumentRegisters:
//                       If this function returns TRUE, then this out variable
//                       receives the identity of the register, expressed as a
//                       byte offset into the ArgumentRegisters structure.
//
// 
//=========================================================================
BOOL IsArgumentInRegister(int   *pNumRegistersUsed,
                          BYTE   typ,
                          UINT32 structSize,
                          BOOL   fThis,
                          BYTE   callconv,
                          int    *pOffsetIntoArgumentRegisters);

#ifdef COMPLUS_EE


/*****************************************************************/
/* CorTypeInfo is a single global table that you can hang information
   about ELEMENT_TYPE_* */

class CorTypeInfo {
public:
    static LPCUTF8 GetFullName(CorElementType type) {
        _ASSERTE(type < infoSize);
        return info[type].className;
    }

    static void CheckConsistancy() {
        for(int i=0; i < infoSize; i++)
            _ASSERTE(info[i].isAlias || info[i].type == i);
    }

    static CorInfoGCType GetGCType(CorElementType type) {
        _ASSERTE(type < infoSize);
        return info[type].gcType;
    }

    static BOOL IsObjRef(CorElementType type) {
        return (GetGCType(type) == TYPE_GC_REF);
    }

    static BOOL IsArray(CorElementType type) {
        _ASSERTE(type < infoSize);
        return info[type].isArray;
    }

    static BOOL IsFloat(CorElementType type) {
        _ASSERTE(type < infoSize);
        return info[type].isFloat;
    }

    static BOOL IsModifier(CorElementType type) {
        _ASSERTE(type < infoSize);
        return info[type].isModifier;
    }

    static BOOL IsPrimitiveType(CorElementType type) {
        _ASSERTE(type < infoSize);
        return info[type].isPrim;
    }

        // aways returns ELEMENT_TYPE_CLASS for object references (including arrays)
    static CorElementType Normalize(CorElementType type) {
        if (IsObjRef(type))
            return(ELEMENT_TYPE_CLASS); 
        return(type);
    }

    static unsigned Size(CorElementType type) {
        _ASSERTE(type < infoSize);
        return info[type].size;
    }

    static CorElementType FindPrimitiveType(LPCUTF8 fullName);
    static CorElementType FindPrimitiveType(LPCUTF8 nameSp, LPCUTF8 name);
private:
    struct CorTypeInfoEntry {
        CorElementType type;
        LPCUTF8        className;
        unsigned       size         : 8;
        CorInfoGCType  gcType       : 3;
        unsigned       isEnreg      : 1;
        unsigned       isArray      : 1;
        unsigned       isPrim       : 1;
        unsigned       isFloat      : 1;
        unsigned       isModifier   : 1;
        unsigned       isAlias      : 1;
    };

    static CorTypeInfoEntry info[];
    static const int infoSize;
};



BOOL CompareTypeTokens(mdToken tk1, mdToken tk2, Module *pModule1, Module *pModule2);


#endif COMPLUS_EE


#ifndef COMPLUS_EE
#undef Module 
#endif

#endif /* _H_SIGINFO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\specialstatics.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*===========================================================================
**
** File:    SpecialStatics.h
**
** Author(s):   Tarun Anand     (TarunA)     
**
** Purpose: Defines the data structures for thread relative, context relative
**          statics.
**          
**
** Date:    Feb 28, 2000
**
=============================================================================*/
#ifndef _H_SPECIALSTATICS_
#define _H_SPECIALSTATICS_

class AppDomain;

// Data structure for storing special static data like thread relative or
// context relative static data.
typedef struct _STATIC_DATA
{
    WORD            cElem;
    LPVOID          dataPtr[0];
} STATIC_DATA;

typedef struct _STATIC_DATA_LIST
{
    STATIC_DATA *m_pUnsharedStaticData;
    STATIC_DATA *m_pSharedStaticData;
} STATIC_DATA_LIST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\spinlock.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// 
// spinlock.cpp
//

#include "common.h"

#include "list.h"
#include "spinlock.h"
#include "threads.h"

enum
{
	BACKOFF_LIMIT = 1000		// used in spin to acquire
};

#ifdef _DEBUG

	// profile information
ULONG	SpinLockProfiler::s_ulBackOffs = 0;
ULONG	SpinLockProfiler::s_ulCollisons [LOCK_TYPE_DEFAULT + 1] = { 0 };
ULONG	SpinLockProfiler::s_ulSpins [LOCK_TYPE_DEFAULT + 1] = { 0 };

#endif

//----------------------------------------------------------------------------
// SpinLock::SpinToAcquire   , non-inline function, called from inline Acquire
//  
//  Spin waiting for a spinlock to become free.
//
//  
void
SpinLock::SpinToAcquire ()
{
	ULONG				ulBackoffs = 0;
	ULONG				ulSpins = 0;

	while (true)
	{
		for (unsigned i = ulSpins+10000;
			 ulSpins < i;
			 ulSpins++)
		{
			// Note: Must cast through volatile to ensure the lock is
			// refetched from memory.
			//
			if (*((volatile DWORD*)&m_lock) == 0)
			{
				break;
			}
			pause();			// indicate to the processor that we are spining 
		}

		// Try the inline atomic test again.
		//
		if (GetLockNoWait ())
		{
			break;
		}

        //backoff
        ulBackoffs++;

		if ((ulBackoffs % BACKOFF_LIMIT) == 0)
		{	
			//@todo probably should add an ASSERT here
			Sleep (500);
		}
		else
        {
			__SwitchToThread (0);
        }
	}

#ifdef _DEBUG
		//profile info
	SpinLockProfiler::IncrementCollisions (m_LockType);
	SpinLockProfiler::IncrementSpins (m_LockType, ulSpins);
	SpinLockProfiler::IncrementBackoffs (ulBackoffs);
#endif

} // SpinLock::SpinToAcquire ()

void SpinLock::IncThreadLockCount()
{
    INCTHREADLOCKCOUNT();
}

void SpinLock::DecThreadLockCount()
{
    DECTHREADLOCKCOUNT();
}

#ifdef _DEBUG
// If a GC is not allowed when we enter the lock, we'd better not do anything inside
// the lock that could provoke a GC.  Otherwise other threads attempting to block
// (which are presumably in the same GC mode as this one) will block.  This will cause
// a deadlock if we do attempt a GC because we can't suspend blocking threads and we
// can't release the spin lock.
void SpinLock::dbg_PreEnterLock()
{
    Thread* pThread = GetThread();
    if (pThread && m_heldInSuspension && pThread->PreemptiveGCDisabled())
        _ASSERTE (!"Deallock situation 1: spinlock may be held during GC, but not entered in PreemptiveGC mode");
}

void SpinLock::dbg_EnterLock()
{
    Thread  *pThread = GetThread();
	if (pThread)
	{
        if (!m_heldInSuspension)
            m_ulReadyForSuspensionCount =
                pThread->GetReadyForSuspensionCount();
        if (!m_enterInCoopGCMode)
            m_enterInCoopGCMode = (pThread->PreemptiveGCDisabled() == TRUE);
	}
	else
	{
		_ASSERTE(g_fProcessDetach == TRUE || dbgOnly_IsSpecialEEThread());
	}
}

void SpinLock::dbg_LeaveLock()
{
    Thread  *pThread = GetThread();
	if (pThread)
	{
        if (!m_heldInSuspension &&
            m_ulReadyForSuspensionCount !=
            pThread->GetReadyForSuspensionCount())
        {
            m_heldInSuspension = TRUE;
        }
        if (m_heldInSuspension && m_enterInCoopGCMode)
        {
            _ASSERTE (!"Deadlock situation 2: lock may be held during GC, but were not entered in PreemptiveGC mode earlier");
        }
	}
	else
	{
		_ASSERTE(g_fProcessDetach == TRUE || dbgOnly_IsSpecialEEThread());
	}
}
#endif

// End of file: spinlock.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\sources.inc ===
#
# Viper build instructions for this directory
#
#       Bob Atkinson
#       April 1997

NO_CRT                                  =1
!include $(NTMAKEENV)\sources.cor

# WarningControl.h disables too many warnings.  VM folder will not use it.
COMPILER_WARNINGS   =/WX

# @todo Get rid of md\compiler from the INCLUDES once vm is converted to scopeless APIs
INCLUDES                        = $(INCLUDES);..;..\$(_TGTCPU);..\..\inc;..\..\..\inc;..\..\ceegen\inc;..\..\ClassLibNative\Inc;..\..\md\inc;..\..\XMLParser

MINORCOMP                       =cor

TARGETNAME                      =$(CORBUILDENV)cee_$(_CORFLAVOR)
TARGETPATH                      =$(TARGETCORBIN)
TARGETTYPE                      =LIBRARY

COR_C_FLAGS                     = -DUNICODE -D_UNICODE -DCOMPLUS_EE -D_NEW_CLASSLOADER

!IF "$(DDKBUILDENV)"=="checked"
COR_C_FLAGS = $(COR_C_FLAGS) -DBUILDENV_CHECKED=1
!ENDIF

NTTARGETFILES                   =

# On NT or Alpha or IA64
COR_C_FLAGS                     = $(COR_C_FLAGS)

!IF "$(_TGTCPUTYPE)"=="x86"
!IF "$(PROFILING_SUPPORTED_BUILD)"=="1"
COR_C_FLAGS                     = $(COR_C_FLAGS) -DENABLE_PERF_COUNTERS
!ENDIF
COR_C_FLAGS         = $(COR_C_FLAGS) -W4
!ENDIF

!IF "$(NO_EJIT)"=="1"
COR_C_FLAGS                     = $(COR_C_FLAGS) -DNO_EJIT
!ENDIF

#
# remove this when DCOR_ILEXCEPTION_OFFSETLEN_SUPPORTED removed from cor.h
#
COR_C_FLAGS                     = $(COR_C_FLAGS) -DCOR_ILEXCEPTION_OFFSETLEN_SUPPORTED -D_USE_NLS_PLUS_TABLE


# Profile guided optimization
# COR_C_FLAGS=$(COR_C_FLAGS) -d2pv$(CORBASE)\src\inc\mscorwks.pgd


!ifndef _BUILD_WINCE
COR_C_FLAGS                     = $(COR_C_FLAGS)
!else
COR_C_FLAGS                     = $(COR_C_FLAGS)
!endif

CDEFINES                        = $(CDEFINES) $(USER_SPECIFIC_C_DEFINES) $(COR_C_FLAGS)

PRECOMPILED_INCLUDE             = ..\common.h
PRECOMPILED_CXX                 = 1
PRECOMPILED_SOURCEFILE          = ..\common.cpp
CORTHUNKLIBS                    =

#This supresses the annoying warnings from build.exe
CONDITIONAL_INCLUDES=$(CONDITIONAL_INCLUDES) vgmem.h unistd.h alphaops.h stddef.h macwin32.h time.h urlmon.h iostream.h opcode.def assert.h sys\mman.h \usr\include\malloc.h ole2int.h sys\param.h

TARGETLIBS              = $(TARGETLIBS)\
        $(SDK_LIB_PATH)\ole32.lib \
        $(SDK_LIB_PATH)\comdlg32.lib \
        $(SDK_LIB_PATH)\crypt32.lib \
        $(SDK_LIB_PATH)\userenv.lib

#=============================================================
# Lets keep the list of sources in ALPHABETICAL order please!
# These all seem to be relative to the previous directory
# because this file is included by wks\SOURCES and svr\SOURCES
#=============================================================
SOURCES=                \
        ..\fcall.cpp       \
        ..\frames.cpp      \
        ..\JITInterface.cpp \
        ..\AppDomain.cpp \
        ..\AppDomainHelper.cpp \
        ..\AppDomainNative.cpp \
        ..\array.cpp \
        ..\Assembly.cpp \
        ..\AssemblyName.cpp \
        ..\AssemblyNative.cpp \
        ..\AssemblyNativeResource.cpp \
        ..\AssemblySpec.cpp \
        ..\AssemblySink.cpp \
        ..\binder.cpp \
        ..\cachelinealloc.cpp \
        ..\ceeload.cpp \
        ..\ceemain.cpp \
        ..\class.cpp       \
        ..\ClassFactory.cpp   \
        ..\clsload.cpp \
        ..\codeman.cpp \
        ..\ConfigHelper.cpp \
        ..\COMArrayHelpers.cpp \
        ..\COMArrayInfo.cpp \
        ..\ComCache.cpp \
        ..\comcall.cpp \
        ..\ComCallWrapper.cpp \
        ..\COMCodeAccessSecurityEngine.cpp \
        ..\ComConnectionPoints.cpp \
        ..\COMClass.cpp \
        ..\COMCurrency.cpp \
        ..\COMDateTime.cpp \
        ..\COMDecimal.cpp \
        ..\COMDelegate.cpp \
        ..\COMDynamic.cpp \
        ..\COMEvent.cpp \
        ..\COMInterfaceMarshaler.cpp \
        ..\COMIsolatedStorage.cpp \
        ..\COMMethodRental.cpp \
        ..\COMMember.cpp \
        ..\ComMTMemberInfoMap.cpp \
        ..\COMNumber.cpp \
        ..\COMModule.cpp \
        ..\COMMutex.cpp \
        ..\COMNDirect.cpp \
        ..\COMOAVariant.cpp \
        ..\COMObject.cpp \
        ..\compile.cpp \
        ..\compluscall.cpp \
        ..\COMPlusWrapper.cpp \
        ..\COMPrincipal.cpp \
        ..\COMHash.cpp \
        ..\COMReflectionCommon.cpp \
        ..\COMSecurityConfig.cpp \
        ..\COMSecurityRuntime.cpp \
        ..\COMStreams.cpp \
        ..\COMString.cpp \
        ..\COMStringBuffer.cpp \
        ..\COMSynchronizable.cpp \
        ..\COMSystem.cpp \
        ..\COMThreadPool.cpp \
        ..\COMTypeLibConverter.cpp \
        ..\COMUtilNative.cpp \
        ..\COMVariant.cpp \
        ..\COMVarArgs.cpp \
        ..\COMWaitHandle.cpp \
        ..\COMX509Certificate.cpp \
        ..\COMCryptography.cpp \
        ..\CorHost.cpp \
        ..\CorMap.cpp      \
        ..\coverage.cpp \
        ..\CustomerDebugHelper.cpp \
        ..\CustomMarshalerInfo.cpp \
        ..\crst.cpp        \
        ..\contexts.cpp \
        ..\CustomAttribute.cpp \
        ..\dataimage.cpp \
        ..\debugHelp.cpp \
        ..\DebugDebugger.cpp \
        ..\DispatchInfo.cpp \
        ..\DispParamMarshaler.cpp \
        ..\dump-tables.cpp \
        ..\ecall.cpp       \
        ..\eeconfig.cpp \
        ..\eeconfigfactory.cpp \
        ..\eehash.cpp\
        ..\EETwain.cpp\
        ..\EJitMgr.cpp\
        ..\EnCEE.cpp\
        ..\EventStore.cpp  \
        ..\excep.cpp       \
        ..\ExtensibleClassFactory.cpp \
        ..\Field.cpp \
        ..\Fjit_EETwain.cpp \
        ..\gc.cpp \
        ..\gcEE.cpp \
        ..\gcCover.cpp \
        ..\GCDecode.cpp  \
        ..\gchost.cpp \
        ..\gcscan.cpp \
        ..\gmheap.cpp \
        ..\gms.cpp \
        ..\guardpagehelper.cpp \
        ..\handletable.cpp \
        ..\handletableCache.cpp \
        ..\handletableCore.cpp \
        ..\handletableScan.cpp \
        ..\hash.cpp \
        ..\InteropConverter.cpp \
        ..\interoputil.cpp \
        ..\InvokeUtil.cpp \
        ..\jumptargettable.cpp \
        ..\list.cpp \
        ..\ListLock.cpp \
        ..\MDConverter.cpp \
        ..\memorypool.cpp \
        ..\message.cpp \
        ..\Method.cpp \
        ..\MethodImpl.cpp \
        ..\Microsoft.ComServices_i.c \
        ..\ml.cpp \
        ..\mlcache.cpp \
        ..\mlgen.cpp \
        ..\mlinfo.cpp \
        ..\mngstdinterfaces.cpp \
        ..\Monitor.cpp \
        ..\NativeOverlapped.cpp \
        ..\ndirect.cpp \
        ..\nexport.cpp \
        ..\NotifyExternals.cpp \
        ..\nstruct.cpp \
        ..\object.cpp \
        ..\objecthandle.cpp \
        ..\OleVariant.cpp \
        ..\orefcache.cpp \
        ..\PEFile.cpp      \
        ..\permset.cpp \
        ..\PEVerifier.cpp \
        ..\Prestub.cpp \
        ..\ProfToEEInterfaceImpl.cpp \
        ..\rangetree.cpp \
        ..\ReflectClassWriter.cpp \
        ..\ReflectUtil.cpp \
        ..\ReflectWrap.cpp \
        ..\remoting.cpp \
        ..\rwlock.cpp \
        ..\SecurityDB.cpp \
        ..\security.cpp \
        ..\siginfo.cpp \
        ..\SigFormat.cpp \
        ..\SimpleRWLock.cpp \
        ..\spinlock.cpp \
        ..\StackingAllocator.cpp \
        ..\stackwalk.cpp \
        ..\StackBuilderSink.cpp \
        ..\StackProbe.cpp \
        ..\stdinterfaces.cpp \
        ..\stdinterfaces_wrapper.cpp \
        ..\stublink.cpp \
        ..\StringLiteralMap.cpp \
        ..\stubmgr.cpp \
        ..\syncblk.cpp \
        ..\SyncClean.cpp \
        ..\expandSig.cpp \
        ..\threads.cpp \
        ..\tlbexport.cpp \
        ..\tls.cpp \
        ..\tpoolwrap.cpp \
        ..\typehash.cpp \
        ..\util.cpp \
        ..\validator.cpp \
        ..\vars.cpp \
        ..\verifier.cpp \
        ..\versig.cpp \
        ..\Win32Threadpool.cpp \
        ..\zapmonitor.cpp

#============================================================
# Was the file you added to the list inserted in ALPHABETICAL
# order - if not please rerun the ALPHABETIZE IMA!
#============================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stackbuildersink.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    StackBuilderSink.h
**
** Author:  Matt Smith (MattSmit)
**
** Purpose: Native implementaion for Microsoft.Runtime.StackBuilderSink
**
** Date:    Mar 24, 1999
**
===========================================================*/
#ifndef __STACKBUILDERSINK_H__
#define __STACKBUILDERSINK_H__


void CallDescrWithObjectArray(OBJECTREF& pServer, ReflectMethod *pMD, 
                  const BYTE *pTarget, MetaSig* sig, VASigCookie *pCookie,
                  BOOL fIsStatic, PTRARRAYREF& pArguments,
                  OBJECTREF* pVarRet, PTRARRAYREF* ppVarOutParams);

//+----------------------------------------------------------
//
//  Class:      CStackBuilderSink
// 
//  Synopsis:   EE counterpart to 
//              Microsoft.Runtime.StackBuilderSink
//              Code helper to build a stack of parameter 
//              arguments and make a function call on an 
//              object.
//
//  History:    05-Mar-1999    MattSmit     Created
//
//------------------------------------------------------------
class CStackBuilderSink
{
public:    
    
    struct PrivateProcessMessageArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG( OBJECTREF, pSBSink );
        DECLARE_ECALL_OBJECTREF_ARG( PTRARRAYREF*,  ppVarOutParams);
        DECLARE_ECALL_I4_ARG       (BOOL, fContext);
        DECLARE_ECALL_PTR_ARG      ( void*, iMethodPtr);
        DECLARE_ECALL_OBJECTREF_ARG( OBJECTREF, pServer);
        DECLARE_ECALL_OBJECTREF_ARG( PTRARRAYREF,  pArgs);
        DECLARE_ECALL_OBJECTREF_ARG( REFLECTBASEREF, pMethodBase);
    };

    static LPVOID    __stdcall PrivateProcessMessage(PrivateProcessMessageArgs *pArgs);

};

#endif  // __STACKBUILDERSINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stackbuildersink.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    StackBuilderSink.cpp
**
** Author:  Matt Smith (MattSmit)
**
** Purpose: Native implementaion for Microsoft.Runtime.StackBuilderSink
**
** Date:    Mar 24, 1999
**
===========================================================*/
#include "common.h"
#include "COMString.h"
#include "COMReflectionCommon.h"
#include "excep.h"
#include "message.h"
#include "ReflectWrap.h"
#include "StackBuilderSink.h"
#include "DbgInterface.h"
#include "Remoting.h"
#include "profilepriv.h"
#include "class.h"

//+----------------------------------------------------------------------------
//
//  Method:     CStackBuilderSink::PrivateProcessMessage, public
//
//  Synopsis:   Builds the stack and calls an object
//
//  History:    24-Mar-99    MattSmit    Created
//
//+----------------------------------------------------------------------------
LPVOID  __stdcall CStackBuilderSink::PrivateProcessMessage(PrivateProcessMessageArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    TRIGGERSGC();

    LOG((LF_REMOTING, LL_INFO10,
         "CStackBuilderSink::PrivateProcessMessage IN pArgs:0x%x\n", pArgs));
    
    _ASSERTE(pArgs->pMethodBase != NULL);
    ReflectMethod *pRM = (ReflectMethod *)pArgs->pMethodBase->GetData();
    MethodDesc *pMD = pRM->pMethod;    

	// Either pServer is non-null or the method is static (but not both)
    _ASSERTE((pArgs->pServer!=NULL) == !(pMD->IsStatic()));

    // Check if this is an interface invoke, if yes, then we have to find the
    // real method descriptor on the class of the server object.
    if(pMD->GetMethodTable()->IsInterface())
    {
        _ASSERTE(pArgs->pServer != NULL);

        MethodDesc* pTemp = pMD;
        // NOTE: This method can trigger GC
        pMD = pArgs->pServer->GetMethodTable()->GetMethodDescForInterfaceMethod(pMD, pArgs->pServer);
        if(NULL == pMD)
        {
            MAKE_WIDEPTR_FROMUTF8(wName, pTemp->GetName())
            COMPlusThrow(kMissingMethodException, IDS_EE_MISSING_METHOD, NULL, wName);
        }
    }

    MetaSig mSig(pMD->GetSig(), pMD->GetModule());
    
    // get the target depending on whether the method is virtual or non-virtual
    // like a constructor, private or final method
    const BYTE* pTarget = NULL;
     
    if (pArgs->iMethodPtr) 
    {
        pTarget = (const BYTE*) pArgs->iMethodPtr;
    }
    else
    {
        // Get the address of the code
        pTarget = MethodTable::GetTargetFromMethodDescAndServer(pMD, &(pArgs->pServer), pArgs->fContext);    
    }
    

    OBJECTREF ret=NULL;
    VASigCookie *pCookie = NULL;
    _ASSERTE(NULL != pTarget);
    GCPROTECT_BEGIN (ret);
            // this function does the work
    ::CallDescrWithObjectArray(
    		pArgs->pServer, 
    		pRM, 
    		pTarget, 
    		&mSig, 
    		pCookie, 
    		pArgs->pServer==NULL?TRUE:FALSE, //fIsStatic
        	pArgs->pArgs, 
            &ret,
           	pArgs->ppVarOutParams);
    GCPROTECT_END ();

    LOG((LF_REMOTING, LL_INFO10,
         "CStackBuilderSink::PrivateProcessMessage OUT\n"));

    RETURN(ret, OBJECTREF);
}


struct ArgInfo
{
    INT32            *dataLocation;
    INT32             dataSize;
    EEClass          *dataClass;
    BYTE              dataType;
};

//+----------------------------------------------------------------------------
//
//  Function:   CallDescrWithObjectArray, private
//
//  Synopsis:   Builds the stack from a object array and call the object
//
//  History:    24-Mar-99    MattSmit    Created
//
// Note this function triggers GC and assumes that pServer, pArguments, pVarRet, and ppVarOutParams are
// all already protected!!
//+----------------------------------------------------------------------------
void CallDescrWithObjectArray(OBJECTREF& pServer, 
                  ReflectMethod *pRM, 
                  const BYTE *pTarget, 
                  MetaSig* sig, 
                  VASigCookie *pCookie,
                  BOOL fIsStatic,  
                  PTRARRAYREF& pArgArray,
                  OBJECTREF *pVarRet,
                  PTRARRAYREF *ppVarOutParams) 
{
    THROWSCOMPLUSEXCEPTION();
    TRIGGERSGC();       // the debugger, profiler code triggers a GC

    LOG((LF_REMOTING, LL_INFO10,
         "CallDescrWithObjectArray IN\n"));

    ByRefInfo *pByRefs = NULL;
    INT64 retval = 0;
    PVOID retBuf = NULL;
    UINT  nActualStackBytes = 0;
    LPBYTE pAlloc = 0;
    LPBYTE pFrameBase = 0;
    UINT32 numByRef = 0;
    DWORD attr = pRM->dwFlags;
    MethodDesc *pMD = pRM->pMethod;

    // check the calling convention

    BYTE callingconvention = sig->GetCallingConvention();
    if (!isCallConv(callingconvention, IMAGE_CEE_CS_CALLCONV_DEFAULT))
    {
        _ASSERTE(!"This calling convention is not supported.");
        COMPlusThrow(kInvalidProgramException);
    }

#ifdef DEBUGGING_SUPPORTED
    // debugger goo What does this do? can someone put a comment here?
    if (CORDebuggerTraceCall())
        g_pDebugInterface->TraceCall(pTarget);
#endif // DEBUGGING_SUPPORTED

#ifdef PROFILING_SUPPORTED
    // If we're profiling, notify the profiler that we're about to invoke the remoting target
    Thread *pCurThread;
    if (CORProfilerTrackRemoting())
    {
        pCurThread = GetThread();
        _ASSERTE(pCurThread);
        g_profControlBlock.pProfInterface->RemotingServerInvocationStarted(
            reinterpret_cast<ThreadID>(pCurThread));
    }
#endif // PROFILING_SUPPORTED
        
    // Create a fake FramedMethodFrame on the stack.
    nActualStackBytes = sig->SizeOfActualFixedArgStack(fIsStatic);
    pAlloc = (LPBYTE)_alloca(FramedMethodFrame::GetNegSpaceSize() + sizeof(FramedMethodFrame) + nActualStackBytes);
    pFrameBase = pAlloc + FramedMethodFrame::GetNegSpaceSize();


    // cycle through the parameters and see if there are byrefs

    BYTE typ = 0;
    BOOL   fHasByRefs = FALSE;

    if (attr & RM_ATTR_BYREF_FLAG_SET)
        fHasByRefs = attr & RM_ATTR_HAS_BYREF_ARG;
    else
    {
        sig->Reset();
        while ((typ = sig->NextArg()) != ELEMENT_TYPE_END)
        {
            if (typ == ELEMENT_TYPE_BYREF)
            {
                fHasByRefs = TRUE;
                attr |= RM_ATTR_HAS_BYREF_ARG;
                break;
            }
        }
        attr |= RM_ATTR_BYREF_FLAG_SET;
        pRM->dwFlags = attr;
        sig->Reset();
    }

    int nFixedArgs = sig->NumFixedArgs();
    // if there are byrefs allocate and array for the out parameters

    if (fHasByRefs)
    {
        *ppVarOutParams = PTRARRAYREF(AllocateObjectArray(sig->NumFixedArgs(), g_pObjectClass));

        // Null out the array
        memset(&(*ppVarOutParams)->m_Array, 0, sizeof(OBJECTREF) * sig->NumFixedArgs());
    }

    // set the this pointer
    OBJECTREF *ppThis = (OBJECTREF *)(pFrameBase + FramedMethodFrame::GetOffsetOfThis());
    *ppThis = NULL;

    // if there is a return buffer, allocate it
    ArgIterator argit(pFrameBase, sig, fIsStatic);
    if (sig->HasRetBuffArg()) 
    {
        EEClass *pEECValue = sig->GetRetEEClass();
        _ASSERTE(pEECValue->IsValueClass());
        MethodTable * mt = pEECValue->GetMethodTable();
        *pVarRet = AllocateObject(mt);

        *(argit.GetRetBuffArgAddr()) = (*pVarRet)->UnBox();
    }

    
    // gather data about the parameters by iterating over the sig:
    UINT32 i = 0;    
    UINT32 structSize = 0;
    int    ofs = 0;
    // REVIEW: need to use actual arg count if VarArgs are supported
    ArgInfo* pArgInfo = (ArgInfo*) _alloca(nFixedArgs*sizeof(ArgInfo));
#ifdef _DEBUG
    // We expect to write useful data over every part of this so need
    // not do this in retail!
    memset((void *)pArgInfo, 0, sizeof(ArgInfo)*nFixedArgs);
#endif
    while (0 != (ofs = argit.GetNextOffset(&typ, &structSize)))
    {
        if (typ == ELEMENT_TYPE_BYREF)
        {
            EEClass *pClass = NULL;
            CorElementType brType = sig->GetByRefType(&pClass);
            if (CorIsPrimitiveType(brType))
            {
                pArgInfo->dataSize = gElementTypeInfo[brType].m_cbSize;
            }
            else if (pClass->IsValueClass())
            {
                pArgInfo->dataSize = pClass->GetAlignedNumInstanceFieldBytes();
                numByRef ++;
            }
            else
            {

                pArgInfo->dataSize = sizeof(Object *);
                numByRef ++;
            }
            ByRefInfo *brInfo = (ByRefInfo *) _alloca(pArgInfo->dataSize + sizeof(ByRefInfo)- 1);
            brInfo->argIndex = i;
            brInfo->typ = brType;
            brInfo->pClass = pClass;
            pArgInfo->dataLocation = (INT32 *) brInfo->data;
            brInfo->pNext = pByRefs;
            pByRefs = brInfo;
            *((INT32*)(pFrameBase + ofs)) = *((INT32 *) &(pArgInfo->dataLocation));
            pArgInfo->dataClass = pClass;
            pArgInfo->dataType = brType;            
        }
        else
        {
            pArgInfo->dataLocation = (INT32*)(pFrameBase + ofs);
            pArgInfo->dataSize = StackElemSize(structSize);
            pArgInfo->dataClass = sig->GetTypeHandle().GetClass(); // this may cause GC!
            pArgInfo->dataType = typ;            
        }  
        i++;
        pArgInfo++;
    }

    if (!fIsStatic) {
        // If this isn't a value class, verify the objectref
#ifdef _DEBUG
        if (pMD->GetClass()->IsValueClass() == FALSE)
            VALIDATEOBJECTREF(pServer);
#endif //_DEBUG
        *ppThis = pServer;
     }

    // There should be no GC when we fill up the stack with parameters, as we don't protect them
    // Assignment of "*ppThis" above triggers the point where we become unprotected.
    BEGINFORBIDGC();


    // reset pArgInfo to point to the start of the block we _alloca-ed
    pArgInfo = pArgInfo-nFixedArgs;

    INT32            *dataLocation;
    INT32             dataSize;
    EEClass          *dataClass;
    BYTE              dataType;

    OBJECTREF* pArguments = pArgArray->m_Array;
    UINT32 j = i;
    for (i=0; i<j; i++)
    {
        dataSize = pArgInfo->dataSize;
        dataLocation = pArgInfo->dataLocation;
        dataClass = pArgInfo->dataClass;
        dataType = pArgInfo->dataType;
        switch (dataSize) 
        {
            case 1:
                *((BYTE*)dataLocation) = *((BYTE*)pArguments[i]->GetData());
                break;
            case 2:
                *((INT16*)dataLocation) = *((INT16*)pArguments[i]->GetData());
                break;            
            case 4:
                if ((dataType == ELEMENT_TYPE_STRING)  ||
                    (dataType == ELEMENT_TYPE_OBJECT)  ||
                    (dataType == ELEMENT_TYPE_CLASS)   ||
                    (dataType == ELEMENT_TYPE_SZARRAY) ||
                    (dataType == ELEMENT_TYPE_ARRAY))
                {
                    *(OBJECTREF *)dataLocation = pArguments[i];
                }
                else
                {
                    *dataLocation = *((INT32*)pArguments[i]->GetData());
                }
    
                break;
    
            case 8:
                *((INT64*)dataLocation) = *((INT64*)pArguments[i]->GetData());
                break;
    
            default: 
            {
                memcpy(dataLocation, pArguments[i]->UnBox(), dataSize);
            }
        }        
        pArgInfo++;
    }
#ifdef _DEBUG
    // Should not be using this any more
    pArgInfo = pArgInfo - nFixedArgs;
    memset((void *)pArgInfo, 0, sizeof(ArgInfo)*nFixedArgs);
#endif

    // if there were byrefs, push a protection frame

    ProtectByRefsFrame *pProtectionFrame = NULL;    
    if (pByRefs && numByRef > 0)
    {
        char *pBuffer = (char*)_alloca (sizeof (ProtectByRefsFrame));
        pProtectionFrame = new (pBuffer) ProtectByRefsFrame(GetThread(), pByRefs);
    }

    // call the correct worker function depending of if the method
    // is varargs or not

#ifdef _X86_

    ENDFORBIDGC();

    INSTALL_COMPLUS_EXCEPTION_HANDLER();

    retval = CallDescrWorker(pFrameBase + sizeof(FramedMethodFrame) + nActualStackBytes,
             nActualStackBytes / STACK_ELEM_SIZE,
             (ArgumentRegisters*)(pFrameBase + FramedMethodFrame::GetOffsetOfArgumentRegisters()),
             (LPVOID)pTarget);

    UNINSTALL_COMPLUS_EXCEPTION_HANDLER();
    
#else //!_X86_
    _ASSERTE(!"@TODO Alpha - CallDescrWithObjectArray (StackBuilderSink.cpp)");
#endif //_X86_

    // set floating point return values

    getFPReturn(sig->GetFPReturnSize(), retval);

    // need to build a object based on the return type.
    
    if (!sig->HasRetBuffArg()) 
    {
        GetObjectFromStack(pVarRet, &retval, sig->GetReturnType(), sig->GetRetEEClass());
    }

    // extract the out args from the byrefs

    if (pByRefs)
    {     
        do
        {
            // Always extract the data ptr every time we enter this loop because
            // calls to GetObjectFromStack below can cause a GC.
            // Even this is not enough, because that we are passing a pointer to GC heap
            // to GetObjectFromStack .  If GC happens, nobody is protecting the passed in pointer.

            OBJECTREF pTmp = NULL;
            GetObjectFromStack(&pTmp, pByRefs->data, pByRefs->typ, pByRefs->pClass);
            (*ppVarOutParams)->SetAt(pByRefs->argIndex, pTmp);
            pByRefs = pByRefs->pNext;
        }
        while (pByRefs);
        if (pProtectionFrame) pProtectionFrame->Pop();
    }

#ifdef PROFILING_SUPPORTED
    // If we're profiling, notify the profiler that we're about to invoke the remoting target
    if (CORProfilerTrackRemoting())
        g_profControlBlock.pProfInterface->RemotingServerInvocationReturned(
            reinterpret_cast<ThreadID>(pCurThread));
#endif // PROFILING_SUPPORTED

    LOG((LF_REMOTING, LL_INFO10, "CallDescrWithObjectArray OUT\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stackingallocator.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// StackingAllocator.h -
//

#ifndef __stacking_allocator_h__
#define __stacking_allocator_h__

#include "util.hpp"
#include <member-offset-info.h>


// We use zero sized arrays, disable the non-standard extension warning.
#pragma warning(push)
#pragma warning(disable:4200)


// Non-thread safe allocator designed for allocations with the following
// pattern:
//      allocate, allocate, allocate ... deallocate all
// There may also be recursive uses of this allocator (by the same thread), so
// the usage becomes:
//      mark checkpoint, allocate, allocate, ..., deallocate back to checkpoint
//
// Allocations come from a singly linked list of blocks with dynamically
// determined size (the goal is to have fewer block allocations than allocation
// requests).
//
// Allocations are very fast (in the case where a new block isn't allocated)
// since blocks are carved up into packets by simply moving a cursor through
// the block.
//
// Allocations are guaranteed to be quadword aligned.
class StackingAllocator
{
    friend struct MEMBER_OFFSET_INFO(StackingAllocator);
public:

    enum {
        MinBlockSize    = 128,
        MaxBlockSize    = 4096,
        InitBlockSize   = 512
    };

    StackingAllocator();
    ~StackingAllocator();

    void *GetCheckpoint();
    void *Alloc(unsigned Size);
    void  Collapse(void *CheckpointMarker);

private:
#ifdef _DEBUG
    struct Sentinal {
		enum { marker1Val = 0xBAD00BAD };
		Sentinal(Sentinal* next) : m_Marker1(marker1Val), m_Next(next) {}
        unsigned  m_Marker1;        // just some data bytes 
        Sentinal* m_Next;           // linked list of these
    };
#endif

    // Blocks from which allocations are carved. Size is determined dynamically,
    // with upper and lower bounds of MinBlockSize and MaxBlockSize respectively
    // (though large allocation requests will cause a block of exactly the right
    // size to be allocated).
    struct Block
    {
        Block      *m_Next;         // Next oldest block in list
        unsigned    m_Length;       // Length of block excluding header
        INDEBUG(Sentinal*   m_Sentinal;)    // insure that we don't fall of the end of the buffer
        INDEBUG(void**      m_Pad;)    		// keep the size a multiple of 8
        char        m_Data[];       // Start of user allocation space
    };

    // Whenever a checkpoint is requested, a checkpoint structure is allocated
    // (as a normal allocation) and is filled with information about the state
    // of the allocator prior to the checkpoint. When a Collapse request comes
    // in we can therefore restore the state of the allocator.
    // It is the address of the checkpoint structure that we hand out to the
    // caller of GetCheckpoint as an opaque checkpoint marker.
    struct Checkpoint
    {
        Block      *m_OldBlock;     // Head of block list before checkpoint
        unsigned    m_OldBytesLeft; // Number of free bytes before checkpoint
    };

    Block      *m_FirstBlock;       // Pointer to head of allocation block list
    char       *m_FirstFree;        // Pointer to first free byte in head block
    unsigned    m_BytesLeft;        // Number of free bytes left in head block
    Block      *m_InitialBlock;     // The first block is special, we never free it

#ifdef _DEBUG
    unsigned    m_CheckpointDepth;
    unsigned    m_Allocs;
    unsigned    m_Checkpoints;
    unsigned    m_Collapses;
    unsigned    m_BlockAllocs;
    unsigned    m_MaxAlloc;
#endif

    void Init(bool bResetInitBlock)
    {
        if (bResetInitBlock || (m_InitialBlock == NULL)) {
			Clear(NULL);
            m_FirstBlock = NULL;
            m_FirstFree = NULL;
            m_BytesLeft = 0;
            m_InitialBlock = NULL;
        } else {
            m_FirstBlock = m_InitialBlock;
            m_FirstFree = m_InitialBlock->m_Data;
            m_BytesLeft = m_InitialBlock->m_Length;
        }
    }

#ifdef _DEBUG
    void Check(Block *block, void* spot) {
        if (!block) 
            return;
        Sentinal* ptr = block->m_Sentinal;
        _ASSERTE(spot);
        while(ptr >= spot) {
				// If this assert goes off then someone overwrote their buffer!
                // A common candidate is PINVOKE buffer run.  To confirm look
                // up on the stack for NDirect.* Look for the MethodDesc
                // associated with it.  Be very suspicious if it is one that
                // has a return string buffer!.  This usually means the end
                // programmer did not allocate a big enough buffer before passing
                // it to the PINVOKE method.
            if (ptr->m_Marker1 != Sentinal::marker1Val)
                _ASSERTE(!"Memory overrun!! May be bad buffer passed to PINVOKE. turn on logging LF_STUBS level 6 to find method");
            ptr = ptr->m_Next;
        }
        block->m_Sentinal = ptr;
	}
#endif

    void Clear(Block *ToBlock)
    {
        Block *p = m_FirstBlock;
        Block *o;

        while (p != ToBlock) {
            o = p;
            p = p->m_Next;
            INDEBUG(Check(o, o));
            delete [] (char *)o;
        }

    }

};


#pragma warning(pop)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stackprobe.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-----------------------------------------------------------------------------
// StackProbe.cpp
//-----------------------------------------------------------------------------

#include "common.h"
#include "StackProbe.h"

#ifdef STACK_GUARDS_DEBUG

DWORD g_LastStackCookieTlsIdx = (DWORD) -1;

DWORD g_UniqueId = 0;

HRESULT InitStackProbes()
{
	DWORD dwRet = TlsAlloc();
	if(dwRet==TLS_OUT_OF_INDEXES)
	    return HRESULT_FROM_WIN32(GetLastError());
	g_LastStackCookieTlsIdx = dwRet;
	
	if( !TlsSetValue(g_LastStackCookieTlsIdx, NULL) )
	    return HRESULT_FROM_WIN32(GetLastError());
	
	return S_OK;
}

void TerminateStackProbes()
{
	TlsFree(g_LastStackCookieTlsIdx);
	g_LastStackCookieTlsIdx = (DWORD) -1;
}

//-----------------------------------------------------------------------------
// Error handling when we blow a stack guard.
// We have different messages to more aggresively diagnose the problem
//-----------------------------------------------------------------------------

// Called by Check_Stack when we overwrite the cookie
void BaseStackGuard::HandleBlowThisStackGuard()
{
// This fires at a closing Check_Stack.
// The cookie set by Requires_?K_stack was overwritten. We detected that at 
// the closing call to check_stack.
// To fix, increase the guard size at the specified ip.
// 
// A debugging trick: If you can set a breakpoint at the opening Requires_?K_Stack
// macro for this instance, you can step in and see where the cookie is actually
// placed. Then, place a breakpoint that triggers when (DWORD*) 0xYYYYYYYY changes.
// Continue execution. The breakpoint will fire exactly when the cookie is blown.

	printf("!!WE BLEW THE STACK GUARD\n");
	printf(" The stack guard (ip=%08x,&=%08x,id=%08x) requested size %d kB of stack\n",
		(size_t)addr_caller, (size_t)this, m_UniqueId, 
		m_n4k * 4);
	printf(" overflow at end\n");
}

void BaseStackGuard::HandleBlowLastStackGuard()
{
// This fires at an opening Requires_?K_Stack
// We detected that we were already passed our parent's stack guard. So this guard is 
// ok, but our parent's guard is too small. Note that if this test was removed,
// the failure would be detected by our parent's closing Check_Stack. But if we detect it
// here, we have more information.
//
// We can see how many bytes short our parent is and adjust it properly.
//
// A debugging trick: 
	printf("!!WE BLEW THE STACK GUARD\n");
	printf(" Early detection: Gap between this guard (ip=%08x,&=%08x,id=%08x) and parent guard(ip=%08x,&=%08x,id=%08x) is %d bytes short\n",
		(size_t)addr_caller, (size_t)this, m_UniqueId,
		(size_t)m_pPrevGuard->addr_caller, (size_t)m_pPrevGuard, m_pPrevGuard->m_UniqueId,
		(char*) stack_addr_last_cookie - (char*) this);
	printf(" Parent requested %d kB of stack\n", m_pPrevGuard->m_n4k * 4);
	
}


//-----------------------------------------------------------------------------
// Dump the info on a specific stack guard
//-----------------------------------------------------------------------------
void DEBUG_DumpStackGuard(BaseStackGuard * p)
{
	WCHAR buf[200];
	swprintf(buf, L"STACKGUARD INFO: Init:%d this:%08x depth:%4d Id:%08x ip:%08x size:%3dkB\n", 
		p->eInitialized, p, p->m_depth, p->m_UniqueId, p->addr_caller, p->m_n4k * 4);
	WszOutputDebugString(buf);
}

//-----------------------------------------------------------------------------
// Traverse the links to display a complete dump of each stack guard
//-----------------------------------------------------------------------------
void DEBUG_DumpStackGuardTrace()
{
	WszOutputDebugString(L"-----------------Begin Stack Guard Dump---------------\n");

	BaseStackGuard * p = (BaseStackGuard*) TlsGetValue(g_LastStackCookieTlsIdx);

	while(p != NULL) {
		WCHAR buf[200];
		swprintf(buf, L"Init:%d this:%08x depth:%4d Id:%08x ip:%08x size:%3dkB\n", 
			p->eInitialized, p, p->m_depth, p->m_UniqueId, p->addr_caller, p->m_n4k * 4);
		WszOutputDebugString(buf);

		p = p->m_pPrevGuard;
	}

	WszOutputDebugString(L"-----------------End Stack Guard Dump-----------------\n");
}

//-----------------------------------------------------------------------------
// This is a hack function to help in debugging.
// Given our guard's addr and a search depth, return our parent's guard addr
// by searching the stack
// This shouldn't be necessary under normal circumstance since we can
// just use m_pPrevGuard
//-----------------------------------------------------------------------------
BaseStackGuard * DEBUG_FindParentGuard(void * pOurGuard, int steps)
{
	BaseStackGuard * p = (BaseStackGuard *) ((BaseStackGuard *) pOurGuard)->stack_addr_last_cookie;
	if (p == NULL) return NULL;
	int i;
	for(i = 0; i < steps; i++)
	{
		if (p->stack_addr_next_cookie == (void*) (((BaseStackGuard*) pOurGuard)->stack_addr_last_cookie)) {
			return p;
		}
		p = (BaseStackGuard*) ((char*) p + 0x1000);
	}
	return NULL;
}

BaseStackGuard * DEBUG_FindParentGuard(void * pOurGuard) {
	return DEBUG_FindParentGuard(pOurGuard, 10);
}


//-----------------------------------------------------------------------------
// For debugging, helps to get our caller's ip
//-----------------------------------------------------------------------------
inline __declspec(naked) void * GetApproxParentIP()
{
	__asm mov eax, dword ptr [ebp+4];
	__asm ret;
}

//-----------------------------------------------------------------------------
// Place guard in stack
//-----------------------------------------------------------------------------
void BaseStackGuard::Requires_N4K_Stack(int n) 
{
	
	m_fAbnormal = false;
	m_UniqueId = g_UniqueId++;
	m_n4k = n;

	// Get our caller's ip. This is useful for debugging (so we can see
	// when the last guard was set).
	addr_caller = GetApproxParentIP();
	

	DWORD dwTest;
	eInitialized = cPartialInit;
	
	m_pPrevGuard = (BaseStackGuard*) TlsGetValue(g_LastStackCookieTlsIdx);
	if (m_pPrevGuard == NULL) {
		stack_addr_last_cookie = NULL;
		m_depth = 0;
	} else {
		stack_addr_last_cookie = m_pPrevGuard->stack_addr_next_cookie;
		m_depth = m_pPrevGuard->m_depth + 1;
	}

// Check that we haven't already blown it
// Note that logically, we should be able to test: this < stack_addr_last_cookie,
// For the head node, stack_addr_last_cookie is NULL, so this still works
	if ((DWORD*) this < stack_addr_last_cookie) {
		HandleBlowLastStackGuard();
	}

// Go through and touch each page. This may hit a stack overflow,
// which means we immediately jump to a handler and are only partially init
	stack_addr_next_cookie = (DWORD*) this;
	do {				
		dwTest = *stack_addr_next_cookie;
	
		stack_addr_next_cookie -= (0x1000 / sizeof(DWORD)); 
	} while (--n > 0);
		
	// Write cookie
	*stack_addr_next_cookie = STACK_COOKIE_VALUE;


	// By this point, everything is working, so go ahead and hook up	
	TlsSetValue(g_LastStackCookieTlsIdx, this);	

	// mark that we're init (and didn't get interupted from an exception)
	eInitialized = cInit;
}

//-----------------------------------------------------------------------------
// Place guard in stack
//-----------------------------------------------------------------------------
void BaseStackGuard::Requires_4K_Stack() 
{
// Set up chain
	m_fAbnormal = false;	
	m_UniqueId = g_UniqueId++;
	m_n4k = 1;
	eInitialized = cPartialInit;

	addr_caller = GetApproxParentIP();
	
	m_pPrevGuard = (BaseStackGuard*) TlsGetValue(g_LastStackCookieTlsIdx);
	if (m_pPrevGuard == NULL) { 
		stack_addr_last_cookie = NULL;
		m_depth = 0;
	} else {
		stack_addr_last_cookie = m_pPrevGuard->stack_addr_next_cookie;
		m_depth = m_pPrevGuard->m_depth + 1;
	}



// Check that we haven't already blown it	
	if ((DWORD*) this < stack_addr_last_cookie) {
		HandleBlowLastStackGuard();
	}

	stack_addr_next_cookie = (DWORD*) ((BYTE*)this - 0x1000);
																			
// Actually Write cookie
	*stack_addr_next_cookie = STACK_COOKIE_VALUE;


// By this point, everything is working, so go ahead and hook up
	TlsSetValue(g_LastStackCookieTlsIdx, this);	
	
	eInitialized = cInit;
}

//-----------------------------------------------------------------------------
// Check guard in stack
// This must be called 1:1 with REQUIRES_?K_STACK, else:
// - the function's stack cookie isn't restored
// - the stack chain in TLS gets out of wack.
//-----------------------------------------------------------------------------
void BaseStackGuard::Check_Stack()
{
	if (m_fAbnormal) {
		__asm nop; // for debugging breakpoint
	} else {
		__asm nop; // for debugging breakpoint
	}

// Uninitialized
	if (eInitialized != cInit) {
		return;
	}


// Do the check
	if (*stack_addr_next_cookie != STACK_COOKIE_VALUE) {
		HandleBlowThisStackGuard();
	}
																	
// Restore last cookie (for nested stuff)
	if (stack_addr_last_cookie != NULL) {
		*stack_addr_last_cookie = STACK_COOKIE_VALUE;
	}

// Unhook in chain
	//TlsSetValue(g_LastStackCookieTlsIdx, stack_addr_last_cookie);	
	TlsSetValue(g_LastStackCookieTlsIdx, m_pPrevGuard);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stackingallocator.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// StackingAllocator.cpp -
//
// Non-thread safe allocator designed for allocations with the following
// pattern:
//      allocate, allocate, allocate ... deallocate all
// There may also be recursive uses of this allocator (by the same thread), so
// the usage becomes:
//      mark checkpoint, allocate, allocate, ..., deallocate back to checkpoint
//
// Allocations come from a singly linked list of blocks with dynamically
// determined size (the goal is to have fewer block allocations than allocation
// requests).
//
// Allocations are very fast (in the case where a new block isn't allocated)
// since blocks are carved up into packets by simply moving a cursor through
// the block.
//
// Allocations are guaranteed to be quadword aligned.


#include "common.h"
#include "excep.h"


#if 0
#define INC_COUNTER(_name, _amount) do { \
    unsigned _count = REGUTIL::GetLong(L"AllocCounter_" _name, 0, NULL, HKEY_CURRENT_USER); \
    REGUTIL::SetLong(L"AllocCounter_" _name, _count+(_amount), NULL, HKEY_CURRENT_USER); \
 } while (0)
#define MAX_COUNTER(_name, _amount) do { \
    unsigned _count = REGUTIL::GetLong(L"AllocCounter_" _name, 0, NULL, HKEY_CURRENT_USER); \
    REGUTIL::SetLong(L"AllocCounter_" _name, max(_count, (_amount)), NULL, HKEY_CURRENT_USER); \
 } while (0)
#else
#define INC_COUNTER(_name, _amount)
#define MAX_COUNTER(_name, _amount)
#endif


StackingAllocator::StackingAllocator()
{
    _ASSERTE((sizeof(Block) & 7) == 0);
    _ASSERTE((sizeof(Checkpoint) & 7) == 0);

	m_FirstBlock = NULL;
    m_FirstFree = NULL;
    m_InitialBlock = NULL;

#ifdef _DEBUG
        m_CheckpointDepth = 0;
        m_Allocs = 0;
        m_Checkpoints = 0;
        m_Collapses = 0;
        m_BlockAllocs = 0;
        m_MaxAlloc = 0;
#endif

    Init(true);
}


StackingAllocator::~StackingAllocator()
{
    Clear(NULL);

#ifdef _DEBUG
        INC_COUNTER(L"Allocs", m_Allocs);
        INC_COUNTER(L"Checkpoints", m_Checkpoints);
        INC_COUNTER(L"Collapses", m_Collapses);
        INC_COUNTER(L"BlockAllocs", m_BlockAllocs);
        MAX_COUNTER(L"MaxAlloc", m_MaxAlloc);
#endif
}


void *StackingAllocator::GetCheckpoint()
{
    THROWSCOMPLUSEXCEPTION();

#ifdef _DEBUG
    m_CheckpointDepth++;
    m_Checkpoints++;
#endif

    // As an optimization, initial checkpoints are lightweight (they just return
    // a special marker, NULL). This is because we know how to restore the
    // allocator state on a Collapse without having to store any additional
    // context info.
    if ((m_InitialBlock == NULL) || (m_FirstFree == m_InitialBlock->m_Data))
        return NULL;

    // Remember the current allocator state.
    Block *pOldBlock = m_FirstBlock;
    unsigned iOldBytesLeft = m_BytesLeft;

    // Allocate a checkpoint block (just like a normal user request).
    Checkpoint *c = (Checkpoint *)Alloc(sizeof(Checkpoint));

    // Record previous allocator state in it.
    c->m_OldBlock = pOldBlock;
    c->m_OldBytesLeft = iOldBytesLeft;

    // Return the checkpoint marker.
    return c;
}


void *StackingAllocator::Alloc(unsigned Size)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(m_CheckpointDepth > 0);

#ifdef _DEBUG
    m_Allocs++;
    m_MaxAlloc = max(Size, m_MaxAlloc);
#endif


	//special case, 0 size alloc, return non-null but invalid pointer
	if(Size == 0)
		return (void*)-1;
		
    // Round size up to ensure alignment.
    unsigned n = (Size + 7) & ~7;

	INDEBUG(n += sizeof(Sentinal));		// leave room for sentinal

    // Is the request too large for the current block?
    if (n > m_BytesLeft) {

        // Allocate a block four times as large as the request but with a lower
        // limit of MinBlockSize and an upper limit of MaxBlockSize. If the
        // request is larger than MaxBlockSize then allocate exactly that
        // amount.
        // Additionally, if we don't have an initial block yet, use an increased
        // lower bound for the size, since we intend to cache this block.
        unsigned lower = m_InitialBlock ? MinBlockSize : InitBlockSize;
        unsigned allocSize = sizeof(Block) + max(n, min(max(n * 4, lower), MaxBlockSize));

        // Allocate the block.
        // @todo: Is it worth implementing a non-thread safe standard heap for
        // this allocator, to get even more MP scalability?
        Block *b = (Block *)new char[allocSize];
        if (b == NULL)
            COMPlusThrowOM();

        // If this is the first block allocated, we record that fact since we
        // intend to cache it.
        if (m_InitialBlock == NULL) {
            _ASSERTE((m_FirstBlock == NULL) && (m_FirstFree == NULL) && (m_BytesLeft == 0));
            m_InitialBlock = b;
        }

        // Link new block to head of block chain and update internal state to
        // start allocating from this new block.
        b->m_Next = m_FirstBlock;
        b->m_Length = allocSize - sizeof(Block);
		INDEBUG(b->m_Sentinal = 0);
        m_FirstBlock = b;
        m_FirstFree = b->m_Data;
        m_BytesLeft = b->m_Length;

#ifdef _DEBUG
        m_BlockAllocs++;
#endif
    }

    // Once we get here we know we have enough bytes left in the block at the
    // head of the chain.
    _ASSERTE(n <= m_BytesLeft);

    void *ret = m_FirstFree;
    m_FirstFree += n;
    m_BytesLeft -= n;

#ifdef _DEBUG
		// Add sentinal to the end
	m_FirstBlock->m_Sentinal = new(m_FirstFree - sizeof(Sentinal)) Sentinal(m_FirstBlock->m_Sentinal);
#endif
    return ret;
}


void StackingAllocator::Collapse(void *CheckpointMarker)
{
    _ASSERTE(m_CheckpointDepth > 0);

#ifdef _DEBUG
    m_CheckpointDepth--;
    m_Collapses++;
#endif

    Checkpoint *c = (Checkpoint *)CheckpointMarker;

    // Special case collapsing back to the initial checkpoint.
    if (c == NULL) {
        Clear(m_InitialBlock);
        Init(false);
        INDEBUG(Check(m_FirstBlock, m_FirstFree));		// confirm no buffer overruns
        return;
    }

    // Cache contents of checkpoint, we can potentially deallocate it in the
    // next step (if a new block had to be allocated to accomodate the
    // checkpoint).
    Block *pOldBlock = c->m_OldBlock;
    unsigned iOldBytesLeft = c->m_OldBytesLeft;

    // Start deallocating blocks until the block that was at the head on the
    // chain when the checkpoint is taken is there again.
    Clear(pOldBlock);

    // Restore former allocator state.
    m_FirstBlock = pOldBlock;
    m_FirstFree = &pOldBlock->m_Data[pOldBlock->m_Length - iOldBytesLeft];
    m_BytesLeft = iOldBytesLeft;
    INDEBUG(Check(m_FirstBlock, m_FirstFree));		// confirm no buffer overruns
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stackprobe.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-----------------------------------------------------------------------------
// Stack Probe Header
// Used to setup stack guards
//-----------------------------------------------------------------------------
#pragma once


//-----------------------------------------------------------------------------
// Stack Guards.
//
// The idea is to force stack overflows to occur at convenient spots. 
// * Fire at REQUIRES_?K_STACK (beggining of func) if this functions locals 
// cause overflow. Note that in a debug mode, initing the locals to garbage
// will cause the overflow before this macro is executed.
//
// * Fire at CHECK_STACK (end of func) if either our nested function calls 
// cause or use of _alloca cause the stack overflow. Note that this macro 
// is debug only, so release builds won't catch on this
//
// Some comments:
// - Stack grows *down*, 
// - Ideally, all funcs would have EBP frame and we'd use EBP instead of ESP,
//    however, we use the 'this' ptr to get the stack ptr, since the guard
//    is declared on the stack.
//
// Comments about inlining assembly w/ Macros:
// - Must use cstyle comments /* ... */
// - No semi colons, need __asm keyword at the start of each line
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// *How* to use stack guards
//
// There are two ways to place a stack guard.
// Via C++: Place a REQUIRES_?K_STACK; macro at the start of the function. 
//    this will create a C++ object who's dtor will call CHECK_STACK
// Via SEH: Place a BEGIN_REQUIRES_?K_STACK at the start of the function
//    and an END_CHECK_STACK at the end. This creates a try ... finally block
//    and introduces a scope level.
//
// *Where* to place stack guards
// Put stack guards at major operations or at recursive points
// So REQUIRES_NK_STACK really means: All my "stack activity" (my functions and
// any down the callstack, as well as any stunts like alloca, etc) is liable
// to fit within N kB. Since stack guards can be nested, our liability only
// extends until the next stack guard in the execution path (at which point it
// is no longer "my" stack activity, but the function with the new guard's
// activity)
//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
// Stack guards have 3 compiler states:
//#define TOTALLY_DISBLE_STACK_GUARDS
// (DEBUG) All stack guard code is completely removed by the preprocessor.
// This should only be used to disable guards to control debugging situations
//
//#define STACK_GUARDS_DEBUG
// (DEBUG) Full stack guard debugging including cookies, tracking ips, and 
// chaining. More heavy weight, recommended for a debug build only
//
//#define STACK_GUARDS_RELEASE
// (RELEASE) Light stack guard code. For golden builds. Forces Stack Overflow
// to happen at "convenient" times. No debugging help.
//-----------------------------------------------------------------------------



#ifdef _DEBUG

// #define STACK_GUARDS_DEBUG
#define TOTALLY_DISBLE_STACK_GUARDS

#else
//#define STACK_GUARDS_RELEASE
#define TOTALLY_DISBLE_STACK_GUARDS
#endif


//=============================================================================
// DEBUG
//=============================================================================
#if defined(STACK_GUARDS_DEBUG)

//-----------------------------------------------------------------------------
// Need to chain together stack guard address for nested functions
// Use a TLS slot to store the head of the chain
//-----------------------------------------------------------------------------
extern DWORD g_LastStackCookieTlsIdx;

//-----------------------------------------------------------------------------
// Class
//-----------------------------------------------------------------------------

// Base version - has no ctor/dtor, so we can use it with SEH
class BaseStackGuard
{
public:
	void Requires_N4K_Stack(int n);
	void Requires_4K_Stack();

	void Check_Stack();

// Different error messages
	void HandleBlowThisStackGuard();
	void HandleBlowLastStackGuard();

public:
	DWORD	* stack_addr_last_cookie;
	DWORD	* stack_addr_next_cookie;	
	
// provide more debugging info
	BaseStackGuard * m_pPrevGuard;
	void	* addr_caller; // IP of caller
	enum {
		cPartialInit,
		cInit
	} eInitialized;
	DWORD	m_UniqueId; 
	int		m_n4k; // # of 4 k pages
	int		m_depth; // how deep is this guard

	BOOL	m_fAbnormal;

};

// This is the value we place on the stack probe
#define STACK_COOKIE_VALUE 0x12345678
	

// Derived version, add a dtor that automatically calls Check_Stack,
// move convenient, but can't use with SEH
class AutoCleanupStackGuard : public BaseStackGuard
{
public:
	AutoCleanupStackGuard() { m_UniqueId = -1; m_n4k = 0; eInitialized = cPartialInit; }
	~AutoCleanupStackGuard() { Check_Stack(); };
};



// Auto cleanup versions, use ctor/dtor
#define REQUIRES_N4K_STACK(n)	AutoCleanupStackGuard stack_guard_XXX; stack_guard_XXX.Requires_N4K_Stack(n);
#define REQUIRES_4K_STACK		AutoCleanupStackGuard stack_guard_XXX; stack_guard_XXX.Requires_4K_Stack();
#define REQUIRES_8K_STACK		REQUIRES_N4K_STACK(2)
#define REQUIRES_12K_STACK		REQUIRES_N4K_STACK(3)
#define REQUIRES_16K_STACK		REQUIRES_N4K_STACK(4)

// Explicit versions, used with SEH
// 'Begin' creates a frame, 'End' uses finally to guarantee that CheckStack is called.
#define BEGIN_REQUIRES_4K_STACK			BaseStackGuard stack_guard_XXX; stack_guard_XXX.Requires_4K_Stack(); __try {
#define BEGIN_REQUIRES_N4K_STACK(n)		BaseStackGuard stack_guard_XXX; stack_guard_XXX.Requires_N4K_Stack(n); __try {
#define BEGIN_REQUIRES_8K_STACK			BEGIN_REQUIRES_N4K_STACK(2)
#define BEGIN_REQUIRES_12K_STACK		BEGIN_REQUIRES_N4K_STACK(3)
#define BEGIN_REQUIRES_16K_STACK		BEGIN_REQUIRES_N4K_STACK(4)
#define END_CHECK_STACK					} __finally { stack_guard_XXX.m_fAbnormal = AbnormalTermination(); stack_guard_XXX.Check_Stack(); }


// DON'T USE THESE unless you REALLY REALLY know EXACTLY what you're doing. 
// Version used w/ C++ when we don't know immediately if we want to use stack guards
// Should only be used when the codepath is in line of stackoverflow handling path

// Create an uninitialized stack guard. Until the POST_REQUIRES_?K_STACK is called,
// this guard won't do place any probes and won't check for fail on exit
#define CREATE_UNINIT_STACK_GUARD	AutoCleanupStackGuard stack_guard_XXX;
#define POST_REQUIRES_N4K_STACK(n)	stack_guard_XXX.Requires_N4K_Stack(n);

#define SAFE_REQUIRES_N4K_STACK(n)                                  \
    CREATE_UNINIT_STACK_GUARD;                                      \
    Thread * pThreadXXX = GetThread();                              \
    if ((pThreadXXX != NULL) && !pThreadXXX->IsGuardPageGone()) {   \
        POST_REQUIRES_N4K_STACK(n);                                 \
    }                                                               \


//-----------------------------------------------------------------------------
// Startup & Shutdown stack guard subsystem
//-----------------------------------------------------------------------------
HRESULT InitStackProbes();
void TerminateStackProbes();

#elif defined(TOTALLY_DISBLE_STACK_GUARDS)

//=============================================================================
// Totally Disabled
//=============================================================================
inline HRESULT InitStackProbes() { return S_OK; }
inline void TerminateStackProbes() { }

#define REQUIRES_N4K_STACK(n)
#define REQUIRES_4K_STACK
#define REQUIRES_8K_STACK
#define REQUIRES_12K_STACK
#define REQUIRES_16K_STACK

#define BEGIN_REQUIRES_4K_STACK
#define BEGIN_REQUIRES_N4K_STACK(n)
#define BEGIN_REQUIRES_8K_STACK
#define BEGIN_REQUIRES_12K_STACK
#define BEGIN_REQUIRES_16K_STACK
#define END_CHECK_STACK

#define CREATE_UNINIT_STACK_GUARD	
#define POST_REQUIRES_N4K_STACK(n)

#define SAFE_REQUIRES_N4K_STACK(n)

#elif defined(STACK_GUARDS_RELEASE)
//=============================================================================
// Release - really streamlined,
//=============================================================================

// Release doesn't support chaining, so we have nothing to init
inline HRESULT InitStackProbes() { return S_OK; }
inline void TerminateStackProbes() { }

// In Release, stack guards just need to reference the memory. That alone
// will throw a Stack Violation acception.
#define REQUIRES_N4K_STACK(n) 										\
/* Loop through, testing each page */								\
	__asm {															\
		__asm push ebx												\
		__asm push eax												\
																	\
		__asm mov ebx, n											\
		__asm mov eax, esp											\
																	\
		__asm /*ASM_LABEL*/ loop_here:								\
		__asm sub eax, 0x1000										\
		__asm test dword ptr [eax], eax								\
		__asm dec ebx												\
		__asm cmp ebx, 0											\
		__asm jne loop_here											\
																	\
		__asm pop eax												\
		__asm pop ebx												\
	}																\



#define REQUIRES_4K_STACK						{ __asm test eax, [esp-0x1000] }
#define REQUIRES_8K_STACK	REQUIRES_4K_STACK	{ __asm test eax, [esp-0x2000] }
#define REQUIRES_12K_STACK	REQUIRES_8K_STACK	{ __asm test eax, [esp-0x3000] }
#define REQUIRES_16K_STACK	REQUIRES_12K_STACK	{ __asm test eax, [esp-0x4000] }

// Since release doesn't do checking at the end, we don't need to setup
// a try..finally block, so the BEGIN_* macros are just the same as the others:
#define BEGIN_REQUIRES_4K_STACK			REQUIRES_4K_STACK
#define BEGIN_REQUIRES_N4K_STACK(n)		REQUIRES_N4K_STACK(n)
#define BEGIN_REQUIRES_8K_STACK			REQUIRES_8K_STACK
#define BEGIN_REQUIRES_12K_STACK		REQUIRES_12K_STACK
#define BEGIN_REQUIRES_16K_STACK		REQUIRES_16K_STACK
#define END_CHECK_STACK

#define CREATE_UNINIT_STACK_GUARD	
#define POST_REQUIRES_N4K_STACK(n)	REQUIRES_N4K_STACK(n)

#define SAFE_REQUIRES_N4K_STACK(n)                                  \
    CREATE_UNINIT_STACK_GUARD;                                      \
    Thread * pThreadXXX = GetThread();                              \
    if ((pThreadXXX != NULL) !pThreadXXX->IsGuardPageGone()) {      \
        POST_REQUIRES_N4K_STACK(n);                                 \
	}                                                               \


#else

// Should have explicitly specified which version we're using 
#error No Stack Guard setting provided. Must specify one of \
	TOTALLY_DISBLE_STACK_GUARDS, STACK_GUARDS_DEBUG or STACK_GUARDS_RELEASE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stackwalk.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*  STACKWALK.CPP:
 *
 */

#include "common.h"
#include "frames.h"
#include "threads.h"
#include "stackwalk.h"
#include "excep.h"
#include "EETwain.h"
#include "CodeMan.h"
#include "EEConfig.h"
#include "stackprobe.h"

#ifdef _DEBUG
void* forceFrame;   // Variable used to force a local variable to the frame
#endif

MethodDesc::RETURNTYPE CrawlFrame::ReturnsObject() 
{
    if (isFrameless)
        return pFunc->ReturnsObject();
    return pFrame->ReturnsObject();
}

OBJECTREF* CrawlFrame::GetAddrOfSecurityObject()
{
    if (isFrameless)
    {
        OBJECTREF * pObj = NULL;

        _ASSERTE(pFunc);

        pObj = (static_cast <OBJECTREF*>
                    (codeMgrInstance->GetAddrOfSecurityObject(pRD,
                                                              JitManagerInstance->GetGCInfo(methodToken),
                                                              relOffset,
                                                              &codeManState)));

        return (pObj);
    }
    else
    {
        /*ISSUE: Are there any other functions holding a security desc? */
        if (pFunc && (pFunc->IsIL() || pFunc->IsNDirect()) && pFrame->IsFramedMethodFrame())
                return static_cast<FramedMethodFrame*>
                    (pFrame)->GetAddrOfSecurityDesc();
    }
    return NULL;
}

LPVOID CrawlFrame::GetInfoBlock()
{
    _ASSERTE(isFrameless);
    _ASSERTE(JitManagerInstance && methodToken);
    return JitManagerInstance->GetGCInfo(methodToken);
}

unsigned CrawlFrame::GetOffsetInFunction()
{
    _ASSERTE(!"NYI");
    return 0;
}

#if 0
LPVOID CrawlFrame::GetIP()
{
    _ASSERTE(!"NYI");
    return NULL;
}
#endif

OBJECTREF CrawlFrame::GetObject()
{

    if (!pFunc || pFunc->IsStatic() || pFunc->GetClass()->IsValueClass())
        return NULL;

    if (isFrameless)
    {
        EECodeInfo codeInfo(GetMethodToken(), GetJitManager());
        return codeMgrInstance->GetInstance(pRD,
                                            JitManagerInstance->GetGCInfo(methodToken),
                                            &codeInfo,
                                            relOffset);
    }
    else
    {
        _ASSERTE(pFrame);
        _ASSERTE(pFunc);
        /*ISSUE: we already know that we have (at least) a method */
        /*       might need adjustment as soon as we solved the
                 jit-helper frame question
        */
        //@TODO: What about other calling conventions?
//        _ASSERT(pFunc()->GetCallSig()->CALLING CONVENTION);

        return ((FramedMethodFrame*)pFrame)->GetThis();
    }
}



    /* Is this frame at a safe spot for GC?
     */
bool CrawlFrame::IsGcSafe()
{
    _ASSERTE(codeMgrInstance);
    EECodeInfo codeInfo(methodToken, JitManagerInstance);
    return codeMgrInstance->IsGcSafe(pRD,
                                     JitManagerInstance->GetGCInfo(methodToken),
                                     &codeInfo,
                                     0);
}

inline void CrawlFrame::GotoNextFrame()
{
    //
    // Update app domain if this frame caused a transition
    //

    AppDomain *pRetDomain = pFrame->GetReturnDomain();
    if (pRetDomain != NULL)
        pAppDomain = pRetDomain;
    pFrame = pFrame->Next();
}





StackWalkAction Thread::StackWalkFramesEx(
                    PREGDISPLAY pRD,        // virtual register set at crawl start
                    PSTACKWALKFRAMESCALLBACK pCallback,
                    VOID *pData,
                    unsigned flags,
                    Frame *pStartFrame
                )
{
    BEGIN_FORBID_TYPELOAD();
    CrawlFrame cf;
    StackWalkAction retVal = SWA_FAILED;
    Frame * pInlinedFrame = NULL;

    // We can't crawl the stack of a thread that currently has a hijack pending
    // (since the hijack routine won't be recognized by any code manager). So we
    // undo any hijack, the EE will re-attempt it later.
    UnhijackThread();

    if (pStartFrame)
        cf.pFrame = pStartFrame;
    else
        cf.pFrame = this->GetFrame();


    // FRAME_TOP and NULL must be distinct values. This assert
    // will fire if someone changes this.
    _ASSERTE(FRAME_TOP != NULL);

#ifdef _DEBUG
    Frame* startFrame = cf.pFrame;
    int depth = 0;
    forceFrame = &depth;
    cf.pFunc = (MethodDesc*)POISONC;
#endif
    cf.isFirst = true;
    cf.isInterrupted = false;
    cf.hasFaulted = false;
    cf.isIPadjusted = false;
    unsigned unwindFlags = (flags & QUICKUNWIND) ? 0 : UpdateAllRegs;
    ASSERT(pRD);

    IJitManager* pEEJM = ExecutionManager::FindJitMan((*pRD->pPC));
    cf.JitManagerInstance = pEEJM;
    cf.codeMgrInstance = NULL;
    if ((cf.isFrameless = (pEEJM != NULL)) == true)
        cf.codeMgrInstance = pEEJM->GetCodeManager();
    cf.pRD = pRD;
    cf.pAppDomain = GetDomain();

    // can debugger handle skipped frames?
    BOOL fHandleSkippedFrames = !(flags & HANDLESKIPPEDFRAMES);

    IJitManager::ScanFlag fJitManagerScanFlags = IJitManager::GetScanFlags();

    while (cf.isFrameless || (cf.pFrame != FRAME_TOP))
    {
        retVal = SWA_DONE;

        cf.codeManState.dwIsSet = 0;
#ifdef _DEBUG
        memset((void *)cf.codeManState.stateBuf, 0xCD,
                sizeof(cf.codeManState.stateBuf));
        depth++;
#endif

        if (cf.isFrameless)
        {
            // This must be a JITed/managed native method


            pEEJM->JitCode2MethodTokenAndOffset((*pRD->pPC),&(cf.methodToken),(DWORD*)&(cf.relOffset), fJitManagerScanFlags);
            cf.pFunc = pEEJM->JitTokenToMethodDesc(cf.methodToken, fJitManagerScanFlags);
            EECodeInfo codeInfo(cf.methodToken, pEEJM, cf.pFunc);
            //cf.methodInfo = pEEJM->GetGCInfo(&codeInfo);

            END_FORBID_TYPELOAD();
            if (SWA_ABORT == pCallback(&cf, (VOID*)pData)) 
                return SWA_ABORT;
            BEGIN_FORBID_TYPELOAD();

            /* Now find out if we need to leave monitors */
            LPVOID methodInfo = pEEJM->GetGCInfo(cf.methodToken);

            if (flags & POPFRAMES)
            {
                if (cf.pFunc->IsSynchronized())
                {
                    MethodDesc    *pMD = cf.pFunc;
                    OBJECTREF      orUnwind = 0;

                    if (pMD->IsStatic())
                    {
                        EEClass    *pClass = pMD->GetClass();
                        orUnwind = pClass->GetExposedClassObject();
                    }
                    else
                    {
                        orUnwind = cf.codeMgrInstance->GetInstance(
                                                pRD,
                                                methodInfo,
                                                &codeInfo,
                                                cf.relOffset);
                    }

                    _ASSERTE(orUnwind);
                    _ASSERTE(!orUnwind->IsThunking());
                    if (orUnwind != NULL)
                        orUnwind->LeaveObjMonitorAtException();
                }
            }
#ifdef _X86_
            // FaultingExceptionFrame is special case where it gets
            // pushed on the stack after the frame is running
            _ASSERTE((cf.pFrame == FRAME_TOP) ||
                     ((size_t)cf.pRD->Esp < (size_t)cf.pFrame) ||
                           (cf.pFrame->GetVTablePtr() == FaultingExceptionFrame::GetMethodFrameVPtr()) ||
                           (cf.pFrame->GetVTablePtr() == ContextTransitionFrame::GetMethodFrameVPtr()));
#endif
            /* Get rid of the frame (actually, it isn't really popped) */

            cf.codeMgrInstance->UnwindStackFrame(
                                    pRD,
                                    methodInfo,
                                    &codeInfo,
                                    unwindFlags | cf.GetCodeManagerFlags(),
                                                                        &cf.codeManState);

            cf.isFirst = FALSE;
            cf.isInterrupted = cf.hasFaulted = cf.isIPadjusted = FALSE;

#ifdef _X86_
            /* We might have skipped past some Frames */
            /* This happens with InlinedCallFrames and if we unwound */
            /* out of a finally in managed code or for ContextTransitionFrames that are
            /* inserted into the managed call stack */
            while (cf.pFrame != FRAME_TOP && (size_t)cf.pFrame < (size_t)cf.pRD->Esp)
            {
                if (!fHandleSkippedFrames || InlinedCallFrame::FrameHasActiveCall(cf.pFrame))
                {
                    cf.GotoNextFrame();
                    if (flags & POPFRAMES)
                        this->SetFrame(cf.pFrame);
                }
                else
                {
                    cf.codeMgrInstance = NULL;
                    cf.isFrameless     = false;

                    cf.pFunc = cf.pFrame->GetFunction();

                    // process that frame
                    if (cf.pFunc || !(flags&FUNCTIONSONLY))
                    {
                        END_FORBID_TYPELOAD();
                        if (SWA_ABORT == pCallback(&cf, (VOID*)pData)) 
                            return SWA_ABORT;
                        BEGIN_FORBID_TYPELOAD();
                    }

                    if (flags & POPFRAMES)
                    {
#ifdef _DEBUG
                        if (cf.pFrame->GetVTablePtr() == ContextTransitionFrame::GetMethodFrameVPtr())
                            // if it's a context transition frame that was pushed on in managed code, a managed
                            // finally may have already popped it off, so check that either have current
                            // frame or the next one down
                            _ASSERTE(cf.pFrame == GetFrame() || cf.pFrame->Next() == GetFrame());
                        else
                            _ASSERTE(cf.pFrame == GetFrame());
#endif

                        // If we got here, the current frame chose not to handle the
                        // exception. Give it a chance to do any termination work
                        // before we pop it off.
                        END_FORBID_TYPELOAD();
                        cf.pFrame->ExceptionUnwind();
                        BEGIN_FORBID_TYPELOAD();

                        // Pop off this frame and go on to the next one.
                        cf.GotoNextFrame();

                        this->SetFrame(cf.pFrame);
                    }
                    else
                    {
                        /* go to the next frame */
                        cf.GotoNextFrame();
                    }
                }
            }
            /* Now inspect caller (i.e. is it again in "native" code ?) */
            pEEJM = ExecutionManager::FindJitMan(*(pRD->pPC), fJitManagerScanFlags);
            cf.JitManagerInstance = pEEJM;

            cf.codeMgrInstance = NULL;
            if ((cf.isFrameless = (pEEJM != NULL)) == true)
            {
                cf.codeMgrInstance = pEEJM->GetCodeManager(); // CHANGE, VC6.0
            }

#endif // _X86_


        }
        else
        {
            if (InlinedCallFrame::FrameHasActiveCall(cf.pFrame))
                pInlinedFrame = cf.pFrame;
            else
                pInlinedFrame = NULL;

            cf.pFunc  = cf.pFrame->GetFunction();
#ifdef _DEBUG
            cf.codeMgrInstance = NULL;
#endif

            /* Are we supposed to filter non-function frames? */

            if (cf.pFunc || !(flags&FUNCTIONSONLY))
            {
                END_FORBID_TYPELOAD();
                if (SWA_ABORT == pCallback(&cf, (VOID *)pData)) 
                    return SWA_ABORT;
                BEGIN_FORBID_TYPELOAD();
            }

            // Special resumable frames make believe they are on top of the stack
            cf.isFirst = (cf.pFrame->GetFrameAttribs() & Frame::FRAME_ATTR_RESUMABLE) != 0;

            // If the frame is a subclass of ExceptionFrame,
            // then we know this is interrupted

            cf.isInterrupted = (cf.pFrame->GetFrameAttribs() & Frame::FRAME_ATTR_EXCEPTION) != 0;

            if (cf.isInterrupted)
            {
                cf.hasFaulted   = (cf.pFrame->GetFrameAttribs() & Frame::FRAME_ATTR_FAULTED) != 0;
                cf.isIPadjusted = (cf.pFrame->GetFrameAttribs() & Frame::FRAME_ATTR_OUT_OF_LINE) != 0;
                _ASSERTE(!cf.hasFaulted || !cf.isIPadjusted); // both cant be set together
            }

            //
            // Update app domain if this frame caused a transition
            //

            AppDomain *pAppDomain = cf.pFrame->GetReturnDomain();
            if (pAppDomain != NULL)
                cf.pAppDomain = pAppDomain;

            SLOT adr = (SLOT)cf.pFrame->GetReturnAddress();
            _ASSERTE(adr != (LPVOID)POISONC);

            _ASSERTE(!pInlinedFrame || adr);

            if (adr)
            {
                /* is caller in managed code ? */
                pEEJM = ExecutionManager::FindJitMan(adr, fJitManagerScanFlags);
                cf.JitManagerInstance = pEEJM;

                _ASSERTE(pEEJM || !pInlinedFrame);

                cf.codeMgrInstance = NULL;

                if ((cf.isFrameless = (pEEJM != NULL)) == true)
                {
                    cf.pFrame->UpdateRegDisplay(pRD);
                    cf.codeMgrInstance = pEEJM->GetCodeManager(); // CHANGE, VC6.0
                }
            }

            if (!pInlinedFrame)
            {
                if (flags & POPFRAMES)
                {
                    // If we got here, the current frame chose not to handle the
                    // exception. Give it a chance to do any termination work
                    // before we pop it off.
                    cf.pFrame->ExceptionUnwind();

                    // Pop off this frame and go on to the next one.
                    cf.GotoNextFrame();

                    this->SetFrame(cf.pFrame);
                }
                else
                {
                    /* go to the next frame */
                    cf.pFrame = cf.pFrame->Next();
                }
            }
        }
    }

        // Try to insure that the frame chain did not change underneath us.
        // In particular, is thread's starting frame the same as it was when we started?
    _ASSERTE(startFrame  != 0 || startFrame == this->GetFrame());

    /* If we got here, we either couldn't even start (for whatever reason)
       or we came to the end of the stack. In the latter case we return SWA_DONE.
    */
    END_FORBID_TYPELOAD();
    return retVal;
}

StackWalkAction Thread::StackWalkFrames(PSTACKWALKFRAMESCALLBACK pCallback,
                               VOID *pData,
                               unsigned flags,
                               Frame *pStartFrame)
{
    SAFE_REQUIRES_N4K_STACK(3); // shared between exceptions & normal codepath
    
    /*@TODO: Make sure that random users doesn't screw this up
    ASSERT(!(flags&POPFRAMES) || pCallback == "exceptionhandlercallback");
    */

    CONTEXT ctx;
    REGDISPLAY rd;

    if(this == GetThread() || GetFilterContext() == NULL)
    {
#ifdef _DEBUG
        // We don't ever want to be a suspended cooperative mode thread here.
        // All threads that were in cooperative mode before suspend should be moving
        // towards waiting in preemptive mode. 
        int suspendCount = 0;
        if(this!=GetThread())
        {
            suspendCount = ::SuspendThread(GetThreadHandle());
            if (suspendCount >= 0) 
                ::ResumeThread(GetThreadHandle());
        }
        _ASSERTE(this == GetThread() || !m_fPreemptiveGCDisabled || suspendCount==0);
#endif                   
            
#ifdef _X86_
        /* SetPC(&ctx, 0); */
        ctx.Eip = 0;
        rd.pPC = (SLOT*)&(ctx.Eip);
#endif
    }
    else
    {
        if (!InitRegDisplay(&rd, &ctx, FALSE))
            return SWA_FAILED;
    }
    
    return StackWalkFramesEx(&rd, pCallback, pData, flags, pStartFrame);
}

StackWalkAction StackWalkFunctions(Thread * thread,
                                   PSTACKWALKFRAMESCALLBACK pCallback,
                                   VOID * pData)
{
    return thread->StackWalkFrames(pCallback, pData, FUNCTIONSONLY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stackwalk.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* This is a poor man's implementation of virtual methods. */
/* The purpose of pCrawlFrame is to abstract (at least for the most common cases
   from the fact that not all methods are "framed" (basically all methods in
   "native" code are "unframed"). That way the job for the enumerator callbacks
   becomes much simpler (i.e. more transparent and hopefully less error prone).
   Two call-backs still need to distinguish between the two types: GC and exception.
   Both of these call-backs need to do really different things; for frameless methods
   they need to go through the codemanager and use the resp. apis.

   The reason for not implementing virtual methods on crawlFrame is solely because of
   the way exception handling is implemented (it does a "long jump" and bypasses
   the enumerator (stackWalker) when it finds a matching frame. By doing so couldn't
   properly destruct the dynamically created instance of CrawlFrame.
*/

#ifndef __stackwalk_h__
#define __stackwalk_h__

#include "eetwain.h"

class Frame;
class CrawlFrame;
class ICodeManager;
class IJitManager;
struct EE_ILEXCEPTION;
struct _METHODTOKEN;
typedef struct _METHODTOKEN * METHODTOKEN;
class AppDomain;

//************************************************************************
// Stack walking
//************************************************************************
enum StackWalkAction {
    SWA_CONTINUE    = 0,    // continue walking
    SWA_ABORT       = 1,    // stop walking, early out in "failure case"
    SWA_FAILED      = 2     // couldn't walk stack
};

#define SWA_DONE SWA_CONTINUE


// Pointer to the StackWalk callback function.
typedef StackWalkAction (*PSTACKWALKFRAMESCALLBACK)(
    CrawlFrame       *pCF,      //
    VOID*             pData     // Caller's private data

);

enum StackCrawlMark
{
    LookForMe = 0,
    LookForMyCaller = 1,
        LookForMyCallersCaller = 2,
};

//************************************************************************
// Enumerate all functions.
//************************************************************************

/* This enumerator is meant to be used for the most common cases, i.e. to
   enumerate just all the functions of the requested thread. It is just a
   cover for the "real" enumerator.
 */

StackWalkAction StackWalkFunctions(Thread * thread, PSTACKWALKFRAMESCALLBACK pCallback, VOID * pData);

/*@ISSUE: Maybe use a define instead?
#define StackWalkFunctions(thread, callBack, userdata) thread->StackWalkFrames(METHODSONLY, (callBack),(userData))
*/


class CrawlFrame {
    public:

    //************************************************************************
    // Functions available for the callbacks (using the current pCrawlFrame)
    //************************************************************************

    /* Widely used/benign functions */

    /* Is this a function? */
    /* Returns either a MethodDesc* or NULL for "non-function" frames */
            //@TODO: what will it return for transition frames?

    inline MethodDesc *GetFunction()
    {
        return pFunc;
    }

    MethodDesc::RETURNTYPE ReturnsObject();

    /* Returns either a Frame * (for "framed items) or
       Returns NULL for frameless functions
     */
    inline Frame* GetFrame()       // will return NULL for "frameless methods"
    {
        if (isFrameless)
            return NULL;
        else
            return pFrame;
    }


    /* Returns address of the securityobject stored in the current function (method?)
       Returns NULL if
            - not a function OR
            - function (method?) hasn't reserved any room for it
              (which is an error)
     */
    OBJECTREF * GetAddrOfSecurityObject();



    /* Returns 'this' for current method
       Returns NULL if
            - not a non-static method
            - 'this' not available (usually codegen problem)
     */
    OBJECTREF GetObject();

    inline CodeManState * GetCodeManState() { return & codeManState; }
    /*
       IF YOU USE ANY OF THE SUBSEEQUENT FUNCTIONS, YOU NEED TO REALLY UNDERSTAND THE
       STACK-WALKER (INCLUDING UNWINDING OF METHODS IN MANAGED NATIVE CODE)!
       YOU ALSO NEED TO UNDERSTAND THE THESE FUNCTIONS MIGHT CHANGE ON A AS-NEED BASIS.
     */

    /* The rest are meant to be used only by the exception catcher and the GC call-back  */

    /* Is currently a frame available? */
    /* conceptually returns (GetFrame(pCrawlFrame) == NULL)
     */
    inline bool IsFrameless()
    {
        return isFrameless;
    }


    /* Is it the current active (top-most) frame 
     */
    inline bool IsActiveFrame()
    {
        return isFirst;
    }

    /* Is it the current active function (top-most frame)
       asserts for non-functions, should be used for managed native code only
     */
    inline bool IsActiveFunc()
    {
        return (pFunc && isFirst);
    }

    /* Is it the current active function (top-most frame)
       which faulted or threw an exception ?
       asserts for non-functions, should be used for managed native code only
     */
    bool IsInterrupted()
    {
        return (pFunc && isInterrupted /* && isFrameless?? */);
    }

    /* Is it the current active function (top-most frame) which faulted ?
       asserts for non-functions, should be used for managed native code only
     */
    bool HasFaulted()
    {
        return (pFunc && hasFaulted /* && isFrameless?? */);
    }

    /* Has the IP been adjusted to a point where it is safe to do GC ?
       (for OutOfLineThrownExceptionFrame)
       asserts for non-functions, should be used for managed native code only
     */
    bool IsIPadjusted()
    {
        return (pFunc && isIPadjusted /* && isFrameless?? */);
    }

    /* Gets the ICodeMangerFlags for the current frame */

    unsigned GetCodeManagerFlags()
    {
        unsigned flags = 0;

        if (IsActiveFunc())
            flags |= ActiveStackFrame;

        if (IsInterrupted())
        {
            flags |= ExecutionAborted;

            if (!HasFaulted() && !IsIPadjusted())
            {
                _ASSERTE(!(flags & ActiveStackFrame));
                flags |= AbortingCall;
            }
        }

        return flags;
    }

    AppDomain *GetAppDomain()
    {
        return pAppDomain;
    }

    /* Is this frame at a safe spot for GC?
     */
    bool IsGcSafe();


    PREGDISPLAY GetRegisterSet()
    {
        // We would like to make the following assertion, but it is legitimately
        // violated when we perform a crawl to find the return address for a hijack.
        // _ASSERTE(isFrameless);
        return pRD;
    }

/*    EE_ILEXCEPTION* GetEHInfo()
    {
        _ASSERTE(isFrameless);
        return methodEHInfo;
    }
*/

    LPVOID GetInfoBlock();

    METHODTOKEN GetMethodToken()
    {
        _ASSERTE(isFrameless);
        return methodToken;
    }    

    unsigned GetRelOffset()
    {
        _ASSERTE(isFrameless);
        return relOffset;
    }

    IJitManager*  GetJitManager()
    {
        _ASSERTE(isFrameless);
        return JitManagerInstance;
    }

    /* not yet used, maybe in exception catcher call-back ? */

    unsigned GetOffsetInFunction();


    /* Returns codeManager that is responsible for crawlFrame's function in
       managed native code,
       Returns NULL in all other cases (asserts for "frames")
     */

    ICodeManager* CrawlFrame::GetCodeManager()
    {
        _ASSERTE(isFrameless);
        return codeMgrInstance;
    }


    protected:
        // CrawlFrames are temporarily created by the enumerator.
        // Do not create one from C++. This protected constructor polices this rule.
        CrawlFrame() {}

    private:
          friend class Thread;
          friend class EECodeManager;

          CodeManState      codeManState;

          bool              isFrameless;
          bool              isFirst;
          bool              isInterrupted;
          bool              hasFaulted;
          bool              isIPadjusted;
          Frame            *pFrame;
          MethodDesc       *pFunc;
          // the rest is only used for "frameless methods"
          ICodeManager     *codeMgrInstance;
          AppDomain        *pAppDomain;
          PREGDISPLAY       pRD; // "thread context"/"virtual register set"
          METHODTOKEN       methodToken;
          unsigned          relOffset;
          //LPVOID            methodInfo;
          EE_ILEXCEPTION   *methodEHInfo;
          IJitManager      *JitManagerInstance;

        void GotoNextFrame();
};

void GcEnumObject(LPVOID pData, OBJECTREF *pObj);
StackWalkAction GcStackCrawlCallBack(CrawlFrame* pCF, VOID* pData);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stdinterfaces.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------------
// stdinterfaces.h
//
// Defines various standard com interfaces , refer to stdinterfaces.cpp for more documentation
//  //  %%Created by: rajak
//---------------------------------------------------------------------------------
#ifndef _H_STDINTERFACES_
#define _H_STDINTERFACES_


//--------------------------------------------------------------------------------
// When switching to 64 bit this typedef needs to be changed
//@todo 64 bit code
typedef INT32 INTPTR;
typedef UINT32 UINTPTR;

typedef HRESULT (__stdcall* PCOMFN)(void);

// IUnknown is part of IDispatch
// Common vtables for well-known COM interfaces
// shared by all COM+ callable wrappers.
extern UINTPTR*     g_pIUnknown []; // global inner unknown vtable
extern UINTPTR*		g_pIDispatch[];	// global IDispatch vtable
extern UINTPTR*		g_pIMarshal[];	// global IMarshal vtable
extern UINTPTR*		g_pITypeInfo[];	// global ITypeInfo interfaces
extern UINTPTR*     g_pIProvideClassInfo[]; // global IProvideClassInfo interface
extern UINTPTR*     g_pIManagedObject[];    // global IManagedObject interface

// global ISupportsErrorInfo vtable
extern UINTPTR*		g_pISupportsErrorInfo [];

// global IErrorInfo vtable
extern UINTPTR*		g_pIErrorInfo [];

// global IConnectionPointContainer interface
extern UINTPTR*     g_pIConnectionPointContainer[];    

// global IObjectSafety interface
extern UINTPTR*     g_pIObjectSafety[];    

// global IDispatchEx interface
extern UINTPTR*     g_pIDispatchEx[];

// For free-threaded marshaling, we must not be spoofed by out-of-process marshal data.
// Only unmarshal data that comes from our own process.
extern BYTE         g_UnmarshalSecret[sizeof(GUID)];
extern bool         g_fInitedUnmarshalSecret;


#include "dispex.h"

class Assembly;

// make sure to keep the following enum and the g_stdVtables array in sync
enum Enum_StdInterfaces
{
	enum_InnerUnknown   = 0,
    enum_IProvideClassInfo,
    enum_IMarshal,
    enum_ISupportsErrorInfo,
    enum_IErrorInfo,
    enum_IManagedObject,
	enum_IConnectionPointContainer,
	enum_IObjectSafety,
	enum_IDispatchEx,
    //@todo add your favorite std interface here
    enum_LastStdVtable,

	enum_IUnknown = 0xff, // special enum for std unknown 
};

// array of vtable pointers for std. interfaces such as IProvideClassInfo etc.
extern SLOT*   g_rgStdVtables[];

// enum class types
enum ComClassType
{
	enum_UserDefined = 0,
	enum_Collection,
	enum_Exception,
	enum_Event,
	enum_Delegate,
	enum_Control,
	enum_Last,
};

//------------------------------------------------------------------------------------------
// Helper to setup excepinfo from IErrorInfo
HRESULT GetSupportedErrorInfo(IUnknown *iface, REFIID riid, IErrorInfo **ppInfo);


//-------------------------------------------------------------------------
// IProvideClassInfo methods
HRESULT __stdcall ClassInfo_GetClassInfo_Wrapper(IUnknown* pUnk, 
                         ITypeInfo** ppTI  //Address of output variable that receives the type info.
                        );





// ---------------------------------------------------------------------------
//  Interface ISupportsErrorInfo

// %%Function: SupportsErroInfo_IntfSupportsErrorInfo,
// ---------------------------------------------------------------------------
HRESULT __stdcall 
SupportsErroInfo_IntfSupportsErrorInfo_Wrapper(IUnknown* pUnk, REFIID riid);

// ---------------------------------------------------------------------------
//  Interface IErrorInfo

// %%Function: ErrorInfo_GetDescription,   
HRESULT __stdcall ErrorInfo_GetDescription_Wrapper(IUnknown* pUnk, BSTR* pbstrDescription);
// %%Function: ErrorInfo_GetGUID,    
HRESULT __stdcall ErrorInfo_GetGUID_Wrapper(IUnknown* pUnk, GUID* pguid);

// %%Function: ErrorInfo_GetHelpContext, 
HRESULT _stdcall ErrorInfo_GetHelpContext_Wrapper(IUnknown* pUnk, DWORD* pdwHelpCtxt);

// %%Function: ErrorInfo_GetHelpFile,    
HRESULT __stdcall ErrorInfo_GetHelpFile_Wrapper(IUnknown* pUnk, BSTR* pbstrHelpFile);

// %%Function: ErrorInfo_GetSource,    
HRESULT __stdcall ErrorInfo_GetSource_Wrapper(IUnknown* pUnk, BSTR* pbstrSource);

//------------------------------------------------------------------------------------------
//      IDispatch methods for COM+ objects. These methods dispatch to the appropriate 
//		implementation based on the flags of the class that implements them.


// %%Function: IDispatch::GetTypeInfoCount 
HRESULT __stdcall	Dispatch_GetTypeInfoCount_Wrapper (
									 IDispatch* pDisp,
									 unsigned int *pctinfo);


//  %%Function: IDispatch::GetTypeInfo
HRESULT __stdcall	Dispatch_GetTypeInfo_Wrapper (
									IDispatch* pDisp,
									unsigned int itinfo,
									LCID lcid,
									ITypeInfo **pptinfo);

//  %%Function: IDispatch::GetIDsofNames
HRESULT __stdcall	Dispatch_GetIDsOfNames_Wrapper (
									IDispatch* pDisp,
									REFIID riid,
									OLECHAR **rgszNames,
									unsigned int cNames,
									LCID lcid,
									DISPID *rgdispid);

//  %%Function: IDispatch::Invoke
HRESULT __stdcall	Dispatch_Invoke_Wrapper	(
									IDispatch* pDisp,
									DISPID dispidMember,
									REFIID riid,
									LCID lcid,
									unsigned short wFlags,
									DISPPARAMS *pdispparams,
									VARIANT *pvarResult,
									EXCEPINFO *pexcepinfo,
									unsigned int *puArgErr
									);

//------------------------------------------------------------------------------------------
//      IDispatchEx methods for COM+ objects


// %%Function: IDispatchEx::GetTypeInfoCount 
HRESULT __stdcall	DispatchEx_GetTypeInfoCount_Wrapper (
									 IDispatchEx* pDisp,
									 unsigned int *pctinfo);


//  %%Function: IDispatch::GetTypeInfo
HRESULT __stdcall	DispatchEx_GetTypeInfo_Wrapper (
									IDispatchEx* pDisp,
									unsigned int itinfo,
									LCID lcid,
									ITypeInfo **pptinfo);
									
// IDispatchEx::GetIDsofNames
HRESULT __stdcall	DispatchEx_GetIDsOfNames_Wrapper (
									IDispatchEx* pDisp,
									REFIID riid,
									OLECHAR **rgszNames,
									unsigned int cNames,
									LCID lcid,
									DISPID *rgdispid
									);

// IDispatchEx::Invoke
HRESULT __stdcall   DispatchEx_Invoke_Wrapper (
									IDispatchEx* pDisp,
									DISPID dispidMember,
									REFIID riid,
									LCID lcid,
									unsigned short wFlags,
									DISPPARAMS *pdispparams,
									VARIANT *pvarResult,
									EXCEPINFO *pexcepinfo,
									unsigned int *puArgErr
									);

// IDispatchEx::DeleteMemberByDispID
HRESULT __stdcall   DispatchEx_DeleteMemberByDispID_Wrapper (
									IDispatchEx* pDisp,
									DISPID id
									);

// IDispatchEx::DeleteMemberByName
HRESULT __stdcall   DispatchEx_DeleteMemberByName_Wrapper (
									IDispatchEx* pDisp,
									BSTR bstrName,
									DWORD grfdex
									);

// IDispatchEx::GetDispID
HRESULT __stdcall   DispatchEx_GetDispID_Wrapper (
									IDispatchEx* pDisp,
									BSTR bstrName,
									DWORD grfdex,
									DISPID *pid
									);

// IDispatchEx::GetMemberName
HRESULT __stdcall   DispatchEx_GetMemberName_Wrapper (
									IDispatchEx* pDisp,
									DISPID id,
									BSTR *pbstrName
									);

// IDispatchEx::GetMemberProperties
HRESULT __stdcall   DispatchEx_GetMemberProperties_Wrapper (
									IDispatchEx* pDisp,
									DISPID id,
									DWORD grfdexFetch,
									DWORD *pgrfdex
									);

// IDispatchEx::GetNameSpaceParent
HRESULT __stdcall   DispatchEx_GetNameSpaceParent_Wrapper (
									IDispatchEx* pDisp,
									IUnknown **ppunk
									);

// IDispatchEx::GetNextDispID
HRESULT __stdcall   DispatchEx_GetNextDispID_Wrapper (
									IDispatchEx* pDisp,
									DWORD grfdex,
									DISPID id,
									DISPID *pid
									);

// IDispatchEx::InvokeEx
HRESULT __stdcall   DispatchEx_InvokeEx_Wrapper	(
									IDispatchEx* pDisp,
									DISPID id,
									LCID lcid,
									WORD wFlags,
									DISPPARAMS *pdp,
									VARIANT *pVarRes, 
									EXCEPINFO *pei, 
									IServiceProvider *pspCaller 
									);

									

//------------------------------------------------------------------------------------------
//      IMarshal methods for COM+ objects

HRESULT __stdcall Marshal_GetUnmarshalClass_Wrapper (
							IMarshal* pMarsh,
							REFIID riid, void * pv, ULONG dwDestContext, 
							void * pvDestContext, ULONG mshlflags, 
							LPCLSID pclsid);

HRESULT __stdcall Marshal_GetMarshalSizeMax_Wrapper (
								IMarshal* pMarsh,
								REFIID riid, void * pv, ULONG dwDestContext, 
								void * pvDestContext, ULONG mshlflags, 
								ULONG * pSize);

HRESULT __stdcall Marshal_MarshalInterface_Wrapper (
						IMarshal* pMarsh,
						LPSTREAM pStm, REFIID riid, void * pv,
						ULONG dwDestContext, LPVOID pvDestContext,
						ULONG mshlflags);

HRESULT __stdcall Marshal_UnmarshalInterface_Wrapper (
						IMarshal* pMarsh,
						LPSTREAM pStm, REFIID riid, 
						void ** ppvObj);

HRESULT __stdcall Marshal_ReleaseMarshalData_Wrapper (IMarshal* pMarsh, LPSTREAM pStm);

HRESULT __stdcall Marshal_DisconnectObject_Wrapper (IMarshal* pMarsh, ULONG dwReserved);


//------------------------------------------------------------------------------------------
//      IManagedObject methods for COM+ objects

interface IManagedObject;
                                                   
HRESULT __stdcall ManagedObject_GetObjectIdentity_Wrapper(IManagedObject *pManaged, 
											      BSTR* pBSTRGUID, DWORD* pAppDomainID,
                								  void** pCCW); 


HRESULT __stdcall ManagedObject_GetSerializedBuffer_Wrapper(IManagedObject *pManaged,
                                                   BSTR* pBStr);


//------------------------------------------------------------------------------------------
//      IConnectionPointContainer methods for COM+ objects

interface IEnumConnectionPoints;

HRESULT __stdcall ConnectionPointContainer_EnumConnectionPoints_Wrapper(IUnknown* pUnk, 
																IEnumConnectionPoints **ppEnum);

HRESULT __stdcall ConnectionPointContainer_FindConnectionPoint_Wrapper(IUnknown* pUnk, 
															   REFIID riid,
															   IConnectionPoint **ppCP);


//------------------------------------------------------------------------------------------
//      IObjectSafety methods for COM+ objects

interface IObjectSafety;

HRESULT __stdcall ObjectSafety_GetInterfaceSafetyOptions_Wrapper(IUnknown* pUnk,
                                                         REFIID riid,
                                                         DWORD *pdwSupportedOptions,
                                                         DWORD *pdwEnabledOptions);

HRESULT __stdcall ObjectSafety_SetInterfaceSafetyOptions_Wrapper(IUnknown* pUnk,
                                                         REFIID riid,
                                                         DWORD dwOptionSetMask,
                                                         DWORD dwEnabledOptions);


// IUNKNOWN wrappers

// prototypes IUnknown methods
HRESULT __stdcall	Unknown_QueryInterface(
									IUnknown* pUnk, REFIID riid, void** ppv);

ULONG __stdcall		Unknown_AddRef(IUnknown* pUnk);

ULONG __stdcall		Unknown_Release(IUnknown* pUnk);

ULONG __stdcall		Unknown_AddRefInner(IUnknown* pUnk);

ULONG __stdcall		Unknown_ReleaseInner(IUnknown* pUnk);

// for std interfaces such as IProvideClassInfo
ULONG __stdcall		Unknown_AddRefSpecial(IUnknown* pUnk);

ULONG __stdcall		Unknown_ReleaseSpecial(IUnknown* pUnk);


// special idispatch methods

HRESULT __stdcall
InternalDispatchImpl_GetIDsOfNames (
    IDispatch* pDisp,
    REFIID riid,
    OLECHAR **rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID *rgdispid);


HRESULT __stdcall
InternalDispatchImpl_Invoke
    (
    IDispatch* pDisp,
    DISPID dispidMember,
    REFIID riid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    );

class Module;
class EEClass;
class MethodTable;
struct ITypeLibExporterNotifySink;

//------------------------------------------------------------------------------------------
// Helper to setup excepinfo from IErrorInfo
HRESULT GetSupportedErrorInfo(IUnknown *iface, REFIID riid, IErrorInfo **ppInfo);
void FillExcepInfo (EXCEPINFO *pexcepinfo, HRESULT hr);

//------------------------------------------------------------------------------------------
// Helper functions that return HRESULT's instead of throwing exceptions.
HRESULT TryGetGuid(EEClass* pClass, GUID* pGUID, BOOL b);
HRESULT TryGetComSourceInterfacesForClass(MethodTable *pClassMT, CQuickArray<MethodTable *> &rItfList);

//------------------------------------------------------------------------------------------
// HRESULT's returned by GetITypeInfoForEEClass.
#define S_USEIUNKNOWN   2
#define S_USEIDISPATCH  3

//------------------------------------------------------------------------------------------
// Helpers to get the ITypeInfo* for a EEClass.
HRESULT ExportTypeLibFromModule(LPCWSTR szModule, LPCWSTR szTlb);
HRESULT ExportTypeLibFromLoadedAssembly(Assembly *pAssembly, LPCWSTR szTlb, ITypeLib **ppTlb, ITypeLibExporterNotifySink *pINotify, int flags);
HRESULT GetITypeLibForEEClass(EEClass *pClass, ITypeLib **ppTLB, int bAutoCreate, int flags);
HRESULT GetITypeInfoForEEClass(EEClass *pClass, ITypeInfo **ppTI, int bClassInfo=false, int bAutoCreate=true, int flags=0);
HRESULT GetTypeLibIdForRegisteredEEClass(EEClass *pClass, GUID *pGuid);
HRESULT GetDefaultInterfaceForCoclass(ITypeInfo *pTI, ITypeInfo **ppTIDef);

struct ExportTypeLibFromLoadedAssembly_Args
{ 
    Assembly *pAssembly;
    LPCWSTR szTlb;
    ITypeLib **ppTlb;
    ITypeLibExporterNotifySink *pINotify;
    int flags;
    HRESULT hr;
};

void ExportTypeLibFromLoadedAssembly_Wrapper(ExportTypeLibFromLoadedAssembly_Args *args);

//-------------------------------------------------------------------------------------
// Helper to get the ITypeLib* for a Assembly.
HRESULT GetITypeLibForAssembly(Assembly *pAssembly, ITypeLib **ppTLB, int bAutoCreate, int flags);

//-------------------------------------------------------------------------------------
// Helper to get the GUID of the typelib that is created from an assembly.
HRESULT GetTypeLibGuidForAssembly(Assembly *pAssembly, GUID *pGuid);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stdinterfaces.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------------
// stdinterfaces.h
//
// Defines various standard com interfaces 
//  %%Created by: rajak
//---------------------------------------------------------------------------------

#include "common.h"

#include <ole2.h>
#include <guidfromname.h>
#include <olectl.h>
#include <objsafe.h>    // IID_IObjctSafe
#include "vars.hpp"
#include "object.h"
#include "excep.h"
#include "frames.h"
#include "vars.hpp"
#include "COMPlusWrapper.h"
#include "ComString.h"
#include "stdinterfaces.h"
#include "comcallwrapper.h"
#include "field.h"
#include "threads.h"
#include "interoputil.h"
#include "TLBExport.h"
#include "COMTypeLibConverter.h"
#include "COMDelegate.h"
#include "olevariant.h"
#include "eeconfig.h"
#include "typehandle.h"
#include "PostError.h"
#include <CorError.h>
#include <mscoree.h>

#include "remoting.h"
#include "mtx.h"
#include "cgencpu.h"
#include "InteropConverter.h"
#include "COMInterfaceMarshaler.h"

#include "stdinterfaces_internal.h"

#ifdef CUSTOMER_CHECKED_BUILD
    #include "CustomerDebugHelper.h"
#endif // CUSTOMER_CHECKED_BUILD

// {00020430-0000-0000-C000-000000000046}
static const GUID LIBID_STDOLE2 = { 0x00020430, 0x0000, 0x0000, { 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 } };
            
// NOTE: In the following vtables, QI points to the same function 
//       this is because, during marshalling between COM & COM+ we want a fast way to
//       check if a COM IP is a tear-off that we created.

// array of vtable pointers for std. interfaces such as IProvideClassInfo etc.
SLOT*      g_rgStdVtables[] =  {
                                (SLOT*)g_pIUnknown,
                                (SLOT*)g_pIProvideClassInfo,
                                (SLOT*)g_pIMarshal,
                                (SLOT*)g_pISupportsErrorInfo, 
                                (SLOT*)g_pIErrorInfo,
                                (SLOT*)g_pIManagedObject,
                                (SLOT*)g_pIConnectionPointContainer,
                                (SLOT*)g_pIObjectSafety,
                                (SLOT*)g_pIDispatchEx
                            };


// {496B0ABF-CDEE-11d3-88E8-00902754C43A}
const IID IID_IEnumerator = {0x496B0ABF,0xCDEE,0x11d3,{0x88,0xE8,0x00,0x90,0x27,0x54,0xC4,0x3A}};

// For free-threaded marshaling, we must not be spoofed by out-of-process marshal data.
// Only unmarshal data that comes from our own process.
BYTE         g_UnmarshalSecret[sizeof(GUID)];
bool         g_fInitedUnmarshalSecret = false;


static HRESULT InitUnmarshalSecret()
{
    HRESULT hr = S_OK;

    if (!g_fInitedUnmarshalSecret)
    {
        ComCall::LOCK();
        {
            if (!g_fInitedUnmarshalSecret)
            {
                hr = ::CoCreateGuid((GUID *) g_UnmarshalSecret);
                if (SUCCEEDED(hr))
                    g_fInitedUnmarshalSecret = true;
            }
        }
        ComCall::UNLOCK();
    }
    return hr;
}


HRESULT TryGetGuid(EEClass* pClass, GUID* pGUID, BOOL b) {
    HRESULT hr = S_OK;

    COMPLUS_TRY {
        pClass->GetGuid(pGUID, b);
    } COMPLUS_CATCH {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    } COMPLUS_END_CATCH

    return hr;
}

HRESULT TryGetComSourceInterfacesForClass(MethodTable *pClassMT, CQuickArray<MethodTable *> &rItfList) {
    HRESULT hr = S_OK;

    COMPLUS_TRY {
        GetComSourceInterfacesForClass(pClassMT, rItfList);
    } COMPLUS_CATCH {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    } COMPLUS_END_CATCH

    return hr;
}


//------------------------------------------------------------------------------------------
//      IUnknown methods for COM+ objects

// ---------------------------------------------------------------------------
// %%Function: Unknown_QueryInterface_Internal    %%Created by: rajak   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------

HRESULT __stdcall
Unknown_QueryInterface_Internal(IUnknown* pUnk, REFIID riid, void** ppv)
{
    HRESULT hr = S_OK;
    Thread* pThread = NULL;
    ComCallWrapper* pWrap = NULL;
    
    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsComPlusTearOff(pUnk));

    if (!ppv)
    {
        hr = E_POINTER;
        goto Exit;
    }

    pThread = GetThread();
    if (pThread == NULL)
    {
        if(! ((g_fEEShutDown & ShutDown_Finalize2) || g_fForbidEnterEE))
        {
            pThread = SetupThread();
        }

        if (pThread == NULL)
        {
            hr = E_OUTOFMEMORY; 
            goto Exit;
        }
    }
    
    // check for QIs on inner unknown
    if (!IsInnerUnknown(pUnk))
    {       
        // std interfaces such as IProvideClassInfo have a different layout
        // 
        if (IsSimpleTearOff(pUnk))
        {
            SimpleComCallWrapper* pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pUnk);
            pWrap = SimpleComCallWrapper::GetMainWrapper(pSimpleWrap);
        }
        else
        {   // it must be one of our main wrappers
            pWrap = ComCallWrapper::GetWrapperFromIP(pUnk);
        }
        
        // linked wrappers and shutdown is a bad case
        if (g_fEEShutDown && ComCallWrapper::IsLinked(pWrap))
        {
            hr = E_NOINTERFACE;
            *ppv = NULL;
            goto Exit;
        }

        IUnknown *pOuter = ComCallWrapper::GetSimpleWrapper(pWrap)->GetOuter();
        // aggregation support, delegate to the outer unknown
        if (pOuter != NULL)
        {
            hr = pOuter->QueryInterface(riid, ppv);
            LogInteropQI(pOuter, riid, hr, "QI to outer Unknown");
            goto Exit;
        }
    }
    else
    {
        SimpleComCallWrapper* pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pUnk);
        // assert the component has been aggregated     
        _ASSERTE(pSimpleWrap->GetOuter() != NULL);
        pWrap = SimpleComCallWrapper::GetMainWrapper(pSimpleWrap); 

        // okay special case IUnknown
        if (IsEqualIID(riid, IID_IUnknown))
        {
            pUnk->AddRef();
            *ppv = pUnk;
            goto Exit;
        }
    }
    _ASSERTE(pWrap != NULL);
    
    // linked wrappers and shutdown is a bad case
    if (g_fEEShutDown && ComCallWrapper::IsLinked(pWrap))
    {
        hr = E_NOINTERFACE;
        *ppv = NULL;
        goto Exit;
    }

    COMPLUS_TRY
    {
        *ppv = ComCallWrapper::GetComIPfromWrapper(pWrap, riid, NULL, TRUE);
        if (!*ppv)
            hr = E_NOINTERFACE;
    }
    COMPLUS_CATCH
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH

    if (hr == E_NOINTERFACE)
    {
        // check if the wrapper is a transparent proxy
        // if so delegate the QI to the real proxy
        _ASSERTE(pWrap != NULL);
        if (pWrap->IsObjectTP())
        {
            _ASSERTE(pThread);
            BEGIN_ENSURE_COOPERATIVE_GC();

            OBJECTREF oref = pWrap->GetObjectRef();
            OBJECTREF realProxy = ObjectToOBJECTREF(CRemotingServices::GetRealProxy(OBJECTREFToObject(oref)));                
            _ASSERTE(realProxy != NULL);            
            
            INT64 ret = 0;
            hr = CRemotingServices::CallSupportsInterface(realProxy, riid, &ret);
            *ppv = (IUnknown*)ret;
            if (hr ==S_OK && *ppv == NULL)
                hr = E_NOINTERFACE;

            END_ENSURE_COOPERATIVE_GC();
        }
    }
        

Exit:    
    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}  // Unknown_QueryInterface


// ---------------------------------------------------------------------------
// %%Function: Unknown_AddRefInner_Internal    %%Created by: rajak   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------
ULONG __stdcall
Unknown_AddRefInner_Internal(IUnknown* pUnk)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    SimpleComCallWrapper* pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pUnk);
    // assert the component has been aggregated     
    _ASSERTE(pSimpleWrap->GetOuter() != NULL);
    ComCallWrapper* pWrap = SimpleComCallWrapper::GetMainWrapper(pSimpleWrap);     
    // are guaranteed to be in the right domain here, so can always get the oref
    // w/o fear of the handle having been nuked
    return ComCallWrapper::AddRef(pWrap);
} // Unknown_AddRef

// ---------------------------------------------------------------------------
// %%Function: Unknown_AddRef_Internal    %%Created by: rajak   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------
ULONG __stdcall
Unknown_AddRef_Internal(IUnknown* pUnk)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    Thread* pThread = GetThread();
    if (pThread == NULL)
    {
        if(! ((g_fEEShutDown & ShutDown_Finalize2) || g_fForbidEnterEE))
        {
            pThread = SetupThread();
        }
        if (pThread == NULL)
            return -1;  
    }

    ComCallWrapper* pWrap = ComCallWrapper::GetWrapperFromIP(pUnk);

    if (ComCallWrapper::IsLinked(pWrap))
    {
        if(((g_fEEShutDown & ShutDown_Finalize2) || g_fForbidEnterEE))
        {
            // we can't find the start wrapper
            return -1;
        }
    }
    
    // check for aggregation
    IUnknown *pOuter; 
    SimpleComCallWrapper* pSimpleWrap = ComCallWrapper::GetSimpleWrapper(pWrap);
    if (pSimpleWrap  && (pOuter = pSimpleWrap->GetOuter()) != NULL)
    {
        // If we are in process detach, we cannot safely call release on our outer.
        if (g_fProcessDetach)
            return 1;

        ULONG cbRef = pOuter->AddRef();
        LogInteropAddRef(pOuter, cbRef, "Delegate to outer");
        return cbRef;
    }
    // are guaranteed to be in the right domain here, so can always get the oref
    // w/o fear of the handle having been nuked
    return ComCallWrapper::AddRef(pWrap);
} // Unknown_AddRef

// ---------------------------------------------------------------------------
// %%Function: Unknown_ReleaseInner_Internal    %%Created by: rajak   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------
ULONG __stdcall
Unknown_ReleaseInner_Internal(IUnknown* pUnk)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    SimpleComCallWrapper* pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pUnk);
        // assert the component has been aggregated     
    _ASSERTE(pSimpleWrap->GetOuter() != NULL);
    ComCallWrapper* pWrap = SimpleComCallWrapper::GetMainWrapper(pSimpleWrap);  
    // we know for sure this wrapper is a start wrapper
    // let us pass this information in
    return ComCallWrapper::Release(pWrap, TRUE);
} // Unknown_Release


// ---------------------------------------------------------------------------
// %%Function: Unknown_Release_Internal    %%Created by: rajak   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------
ULONG __stdcall
Unknown_Release_Internal(IUnknown* pUnk)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    Thread* pThread = GetThread();
    if (pThread == NULL)
    {
        if(! ((g_fEEShutDown & ShutDown_Finalize2) || g_fForbidEnterEE))
        {
            pThread = SetupThread();
        }
        if (pThread == NULL)
            return -1;  
    }
    
    // check for aggregation
    ComCallWrapper* pWrap = ComCallWrapper::GetWrapperFromIP(pUnk);
    if (ComCallWrapper::IsLinked(pWrap))
    {
        if(((g_fEEShutDown & ShutDown_Finalize2) || g_fForbidEnterEE))
        {
            // we can't find the start wrapper
            return -1;
        }
    }

    SimpleComCallWrapper* pSimpleWrap = ComCallWrapper::GetSimpleWrapper(pWrap);
    IUnknown *pOuter; 
    if (pSimpleWrap  && (pOuter = pSimpleWrap->GetOuter()) != NULL)
    {
        // If we are in process detach, we cannot safely call release on our outer.
        if (g_fProcessDetach)
            return 1;

        ULONG cbRef = pOuter->Release();
        LogInteropRelease(pOuter, cbRef, "Delegate Release to outer");
        return cbRef;
    }

    return ComCallWrapper::Release(pWrap);
} // Unknown_Release


// ---------------------------------------------------------------------------
// %%Function: Unknown_AddRefSpecial_Internal    %%Created by: rajak   %%Reviewed: 00/00/00
//  for simple tearoffs
// ---------------------------------------------------------------------------
ULONG __stdcall
Unknown_AddRefSpecial_Internal(IUnknown* pUnk)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pUnk));
    return SimpleComCallWrapper::AddRef(pUnk);
} // Unknown_AddRefSpecial

// ---------------------------------------------------------------------------
// %%Function: Unknown_ReleaseSpecial    %%Created by: rajak   
// for simplecomcall wrappers, stdinterfaces such as IProvideClassInfo etc.
// ---------------------------------------------------------------------------
ULONG __stdcall
Unknown_ReleaseSpecial_Internal(IUnknown* pUnk)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pUnk));
    return SimpleComCallWrapper::Release(pUnk);
} // Unknown_Release

// ---------------------------------------------------------------------------
//  Interface IProvideClassInfo
// %%Function: ProvideClassInfo_GetClassInfo    %%Created by: rajak 
// ---------------------------------------------------------------------------
HRESULT __stdcall 
ClassInfo_GetClassInfo(IUnknown* pUnk, 
                         ITypeInfo** ppTI  //Address of output variable that receives the 
                        )                  // //ITypeInfo interface pointer
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;

    _ASSERTE(IsSimpleTearOff(pUnk));

    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    SimpleComCallWrapper *pWrap = SimpleComCallWrapper::GetWrapperFromIP(pUnk);

    if (pWrap->IsUnloaded())
        return COR_E_APPDOMAINUNLOADED;

    // If this is an extensible RCW then we need to check to see if the COM+ part of the
    // herarchy is visible to COM.
    if (pWrap->IsExtendsCOMObject())
    {
        // Retrieve the wrapper template for the class.
        ComCallWrapperTemplate *pTemplate = ComCallWrapperTemplate::GetTemplate(pWrap->m_pClass->GetMethodTable());
        if (!pTemplate)
            return E_OUTOFMEMORY;

        // Find the first COM visible IClassX starting at ComMethodTable passed in and
        // walking up the hierarchy.
        ComMethodTable *pComMT = NULL;
        for (pComMT = pTemplate->GetClassComMT(); pComMT && !pComMT->IsComVisible(); pComMT = pComMT->GetParentComMT());

        // If the COM+ part of the object is not visible then delegate the call to the 
        // base COM object if it implements IProvideClassInfo.
        if (!pComMT || pComMT->m_pMT->GetParentMethodTable() == g_pObjectClass)
        {
            IProvideClassInfo *pProvClassInfo = NULL;
            IUnknown *pUnk = pWrap->GetComPlusWrapper()->GetIUnknown();
            hr = pWrap->GetComPlusWrapper()->SafeQueryInterfaceRemoteAware(pUnk, IID_IProvideClassInfo, (IUnknown**)&pProvClassInfo);
            LogInteropQI(pUnk, IID_IProvideClassInfo, hr, "ClassInfo_GetClassInfo");
            if (SUCCEEDED(hr))
            {
                hr = pProvClassInfo->GetClassInfo(ppTI);
                ULONG cbRef = pProvClassInfo->Release();
                LogInteropRelease(pProvClassInfo, cbRef, "ClassInfo_GetClassInfo");
                return hr;
            }
        }
    }

    EEClass* pClass = pWrap->m_pClass;
    hr = GetITypeInfoForEEClass(pClass, ppTI, true/*bClassInfo*/);
    
    return hr;
}


//------------------------------------------------------------------------------------------
// Helper to get the LIBID of a registered class.
HRESULT GetTypeLibIdForRegisteredEEClass(EEClass *pClass, GUID *pGuid)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    DWORD       rslt;                   // A Registry result.
    GUID        guid;                   // Scratch GUID.
    HKEY        hKeyCorI=0;             // HKEY for CLSID or INTERFACE
    WCHAR       rcGuid[40];             // GUID of TypeDef/TypeRef as string.
    DWORD       cbGuid = sizeof(rcGuid);// Size of the TypeLib guid string buffer.
    HKEY        hKeyGuid=0;             // HKEY for GUID string.
    HKEY        hKeyTLB=0;              // HKEY for TypeLib.

    // CLSID or INTERFACE?
    if (pClass->IsInterface())
        rslt = WszRegOpenKeyEx(HKEY_CLASSES_ROOT, L"Interface", 0, KEY_READ, &hKeyCorI);
    else
        rslt = WszRegOpenKeyEx(HKEY_CLASSES_ROOT, L"CLSID", 0, KEY_READ, &hKeyCorI);
    if (rslt != ERROR_SUCCESS)
        IfFailGo(TLBX_E_NO_CLSID_KEY);
    
    // Get the GUID of the desired TypeRef as a string.
    IfFailGo(TryGetGuid(pClass, &guid, TRUE));
    GuidToLPWSTR(guid, rcGuid, lengthof(rcGuid));
    
    // Open the {00000046-00..00} part
    rslt = WszRegOpenKeyEx(hKeyCorI, rcGuid, 0, KEY_READ, &hKeyGuid);
    if (rslt != ERROR_SUCCESS)
        hr = pClass->IsInterface() ? REGDB_E_IIDNOTREG : REGDB_E_CLASSNOTREG;
    else
    {   // Open the TypeLib subkey.
        rslt = WszRegOpenKeyEx(hKeyGuid, L"TypeLib", 0, KEY_READ, &hKeyTLB);
        if (rslt != ERROR_SUCCESS)
            hr = REGDB_E_KEYMISSING;
        else
        {   // Read the value of the TypeLib key.
            rslt = WszRegQueryValueEx(hKeyTLB, 0, 0, 0, (BYTE*)rcGuid, &cbGuid);
            if (rslt != ERROR_SUCCESS)
                hr = REGDB_E_INVALIDVALUE; 
            else
            {   // Convert back into a guid form.
                hr = CLSIDFromString(rcGuid, pGuid);
                if (hr != S_OK)
                    hr = REGDB_E_INVALIDVALUE; 
            }
        }
    }

ErrExit:
    if (hKeyCorI)
        RegCloseKey(hKeyCorI);
    if (hKeyGuid)
        RegCloseKey(hKeyGuid);
    if (hKeyTLB)
        RegCloseKey(hKeyTLB);

    return hr;
} // HRESULT GetTypeLibIdForRegisteredEEClass()

//-------------------------------------------------------------------------------------
// Helper to get the ITypeLib* for a Assembly.
HRESULT GetITypeLibForAssembly(Assembly *pAssembly, ITypeLib **ppTLB, int bAutoCreate, int flags)
{
    HRESULT     hr = S_OK;              // A result.

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    CQuickArrayNoDtor<WCHAR> rName;     // Library (scope) or file naem.
    int         bResize=false;          // If true, had to resize the buffer to hold the name.
    LPCWSTR     szModule=0;             // The module name.
    GUID        guid;                   // A GUID.
    LCID        lcid=LOCALE_USER_DEFAULT;// Library's LCID.
    ITypeLib    *pITLB=0;               // The TypeLib.
    ICreateTypeLib2 *pCTlb2=0;          // The ICreateTypeLib2 pointer.
    Module      *pModule;               // The assembly's module.
    WCHAR       rcDrive[_MAX_DRIVE];    // Module's drive letter.
    WCHAR       rcDir[_MAX_DIR];        // Module's directory.
    WCHAR       rcFname[_MAX_FNAME];    // Module's file name.

    // Check to see if we have a cached copy.
    pITLB = pAssembly->GetTypeLib();
    if (pITLB)
    {
        // Check to see if the cached value is -1. This indicate that we tried
        // to export the typelib but that the export failed.
        if (pITLB == (ITypeLib*)-1)
        {
            hr = E_FAIL;
            goto ReturnHR;
        }

        // We have a cached copy so return it.
        *ppTLB = pITLB;
        hr = S_OK;
        goto ReturnHR;
    }

    // Retrieve the name of the module.
    pModule = pAssembly->GetSecurityModule();
    szModule = pModule->GetFileName();

    // Retrieve the guid for typelib that would be generated from the assembly.
    IfFailGo(GetTypeLibGuidForAssembly(pAssembly, &guid));

    // If the typelib is for the runtime library, we'd better know where it is.
    if (guid == LIBID_ComPlusRuntime)
    {
        ULONG dwSize = (ULONG)rName.MaxSize();
        while (FAILED(GetInternalSystemDirectory(rName.Ptr(), &dwSize)))
        {
            IfFailGo(rName.ReSize(dwSize=(ULONG)rName.MaxSize()*2));
        }

        IfFailGo(rName.ReSize(dwSize + lengthof(g_pwBaseLibraryTLB) + 3));
        wcscat(rName.Ptr(), g_pwBaseLibraryTLB);
        hr = LoadTypeLibEx(rName.Ptr(), REGKIND_NONE, &pITLB);
        goto ErrExit;       
    }
    
    // Maybe the module was imported from COM, and we can get the libid of the existing typelib.
    if (pAssembly->GetManifestImport()->GetCustomAttributeByName(TokenFromRid(1, mdtAssembly), INTEROP_IMPORTEDFROMTYPELIB_TYPE, 0, 0) == S_OK)
    {
        hr = LoadRegTypeLib(guid, -1, -1, LOCALE_USER_DEFAULT, &pITLB);
        if (SUCCEEDED(hr))
            goto ErrExit;

        // The module is known to be imported, so no need to try conversion.

        // Set the error info for most callers.
        PostError(TLBX_E_CIRCULAR_EXPORT, szModule);

        // Set the hr for the case where we're trying to load a type library to
        // resolve a type reference from another library.  The error message will
        // be posted where more information is available.
        if (hr == TYPE_E_LIBNOTREGISTERED)
            hr = TLBX_W_LIBNOTREGISTERED;
        else
            hr = TLBX_E_CANTLOADLIBRARY;

        IfFailGo(hr);
    }

    // Try to load the registered typelib.
    hr = LoadRegTypeLib(guid, -1, -1, lcid, &pITLB);
    if(hr == S_OK)
        goto ErrExit;

    // If caller only wants registered typelibs, exit now, with error from prior call.
    if (flags & TlbExporter_OnlyReferenceRegistered)
        goto ErrExit;
    
    // If we haven't managed to find the typelib so far try and load the typelib by name.
    hr = LoadTypeLibEx(szModule, REGKIND_NONE, &pITLB);
    if(hr == S_OK)
    {   // Check libid.
        TLIBATTR *pTlibAttr;
        int     bMatch;
        IfFailGo(pITLB->GetLibAttr(&pTlibAttr));
        bMatch = pTlibAttr->guid == guid;
        pITLB->ReleaseTLibAttr(pTlibAttr);
        if (bMatch)
        {
            goto ErrExit;
        }
        else
        {
            pITLB->Release();
            pITLB = NULL;
            hr = TLBX_E_CANTLOADLIBRARY;
        }
    }

    // Add a ".tlb" extension and try again.
    IfFailGo(rName.ReSize((int)(wcslen(szModule) + 5)));
    SplitPath(szModule, rcDrive, rcDir, rcFname, 0);
    MakePath(rName.Ptr(), rcDrive, rcDir, rcFname, L".tlb");
    hr = LoadTypeLibEx(rName.Ptr(), REGKIND_NONE, &pITLB);
    if(hr == S_OK)
    {   // Check libid.
        TLIBATTR *pTlibAttr;
        int     bMatch;
        IfFailGo(pITLB->GetLibAttr(&pTlibAttr));
        bMatch = pTlibAttr->guid == guid;
        pITLB->ReleaseTLibAttr(pTlibAttr);
        if (bMatch)
        {
            goto ErrExit;
        }
        else
        {
            pITLB->Release();
            pITLB = NULL;
            hr = TLBX_E_CANTLOADLIBRARY;
        }
    }

    // If the auto create flag is set then try and export the typelib from the module.
    if (bAutoCreate)
    {
        // Try to export the typelib right now.
        // This is FTL export (Fractionally Too Late).
        hr = ExportTypeLibFromLoadedAssembly(pAssembly, 0, &pITLB, 0, flags);
        if (FAILED(hr))
        {
            // If the export failed then remember it failed by setting the typelib
            // to -1 on the assembly.
            pAssembly->SetTypeLib((ITypeLib *)-1);
            IfFailGo(hr);
        }
    }   

ErrExit:
    if (pCTlb2)
        pCTlb2->Release();
    // If we successfully opened (or created) the typelib, cache a pointer, and return it to caller.
    if (pITLB)
    {
        pAssembly->SetTypeLib(pITLB);
        *ppTLB = pITLB;
    }
ReturnHR:
    rName.Destroy();
    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return hr;
} // HRESULT GetITypeLibForAssembly()


//------------------------------------------------------------------------------------------
// Helper to get the ITypeInfo* for a EEClass.
HRESULT GetITypeLibForEEClass(EEClass *pClass, ITypeLib **ppTLB, int bAutoCreate, int flags)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    return GetITypeLibForAssembly(pClass->GetAssembly(), ppTLB, bAutoCreate, flags);
} // HRESULT GetITypeLibForEEClass()


HRESULT GetITypeInfoForEEClass(EEClass *pClass, ITypeInfo **ppTI, int bClassInfo/*=false*/, int bAutoCreate/*=true*/, int flags)
{
    HRESULT     hr = S_OK;              // A result.
    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    ITypeLib    *pITLB=0;               // The TypeLib.
    GUID        clsid;
    GUID ciid;
    ITypeInfo   *pTI=0;                 // A typeinfo.
    ITypeInfo   *pTIDef=0;              // Default typeinfo of a coclass.
    ComMethodTable *pComMT;             
    ComCallWrapperTemplate *pTemplate;
    
    // Get the typeinfo.
    if (bClassInfo || pClass->IsInterface() || pClass->IsValueClass() || pClass->IsEnum())
    {
        // If the class is not an interface then find the first COM visible IClassX in the hierarchy.
        if (!pClass->IsInterface() && !pClass->IsComImport())
        {
            // Retrieve the ComCallWrapperTemplate from the EEClass.
            COMPLUS_TRY 
            {
                pTemplate = ComCallWrapperTemplate::GetTemplate(pClass->GetMethodTable());
            } 
            COMPLUS_CATCH
            {
                BEGIN_ENSURE_COOPERATIVE_GC();
                hr = SetupErrorInfo(GETTHROWABLE());
                END_ENSURE_COOPERATIVE_GC();
            }
            COMPLUS_END_CATCH

            if (hr != S_OK) 
                goto ReturnHR;

            if (!pTemplate)
            {
                hr = E_OUTOFMEMORY;
                goto ReturnHR;
            }

            // Find the first COM visible IClassX starting at ComMethodTable passed in and
            // walking up the hierarchy.
            for (pComMT = pTemplate->GetClassComMT(); pComMT && !pComMT->IsComVisible(); pComMT = pComMT->GetParentComMT());

            // If we haven't managed to find any visible IClassX's then return TYPE_E_ELEMENTNOTFOUND.
            if (!pComMT)
            {
                hr = TYPE_E_ELEMENTNOTFOUND;
                goto ReturnHR;
            }

            // Use the EEClass of the first visible IClassX.
            pClass = pComMT->m_pMT->GetClass();
        }

        // Retrieve the ITypeLib for the assembly containing the EEClass.
        IfFailGo(GetITypeLibForEEClass(pClass, &pITLB, bAutoCreate, flags));

        // Get the GUID of the desired TypeRef.
        IfFailGo(TryGetGuid(pClass, &clsid, TRUE));

        // Retrieve the ITypeInfo from the ITypeLib.
        IfFailGo(pITLB->GetTypeInfoOfGuid(clsid, ppTI));
    }
    else if (pClass->IsComImport())
    {   
        // This is a COM imported class, with no IClassX.  Get default interface.
        IfFailGo(GetITypeLibForEEClass(pClass, &pITLB, bAutoCreate, flags));
        IfFailGo(TryGetGuid(pClass, &clsid, TRUE));       
        IfFailGo(pITLB->GetTypeInfoOfGuid(clsid, &pTI));
        IfFailGo(GetDefaultInterfaceForCoclass(pTI, &pTIDef));

        if (pTIDef)
        {
            *ppTI = pTIDef;
            pTIDef = 0;
        }
        else
            hr = TYPE_E_ELEMENTNOTFOUND;
    }
    else
    {
        // We are attempting to retrieve an ITypeInfo for the default interface on a class.
        TypeHandle hndDefItfClass;
        DefaultInterfaceType DefItfType;
        IfFailGo(TryGetDefaultInterfaceForClass(TypeHandle(pClass->GetMethodTable()), &hndDefItfClass, &DefItfType));
        switch (DefItfType)
        {
            case DefaultInterfaceType_Explicit:
            {
                _ASSERTE(!hndDefItfClass.IsNull());
                _ASSERTE(hndDefItfClass.GetMethodTable()->IsInterface());
                hr = GetITypeInfoForEEClass(hndDefItfClass.GetClass(), ppTI, FALSE, bAutoCreate, flags);
                break;
            }

            case DefaultInterfaceType_AutoDispatch:
            case DefaultInterfaceType_AutoDual:
            {
                _ASSERTE(!hndDefItfClass.IsNull());
                _ASSERTE(!hndDefItfClass.GetMethodTable()->IsInterface());

                // Retrieve the ITypeLib for the assembly containing the EEClass.
                IfFailGo(GetITypeLibForEEClass(hndDefItfClass.GetClass(), &pITLB, bAutoCreate, flags));

                // Get the GUID of the desired TypeRef.
                IfFailGo(TryGetGuid(hndDefItfClass.GetClass(), &clsid, TRUE));
        
                // Generate the IClassX IID from the class.
                TryGenerateClassItfGuid(hndDefItfClass, &ciid);
        
                hr = pITLB->GetTypeInfoOfGuid(ciid, ppTI);
                break;
            }

            case DefaultInterfaceType_IUnknown:
            case DefaultInterfaceType_BaseComClass:
            {
                // @PERF: Optimize this.
                IfFailGo(LoadRegTypeLib(LIBID_STDOLE2, -1, -1, 0, &pITLB));
                IfFailGo(pITLB->GetTypeInfoOfGuid(IID_IUnknown, ppTI));
                hr = S_USEIUNKNOWN;
                break;
            }

            default:
            {
                _ASSERTE(!"Invalid default interface type!");
                hr = E_FAIL;
                break;
            }
        }
    }

ErrExit:
    if (pITLB)
        pITLB->Release();
    if (pTIDef)
        pTIDef->Release();
    if (pTI)
        pTI->Release();

    if (*ppTI == NULL)
    {
        if (!FAILED(hr))
        {
            hr = E_FAIL;
        }
    }
ReturnHR:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return hr;
} // HRESULT GetITypeInfoForEEClass()

//------------------------------------------------------------------------------------------
HRESULT GetDefaultInterfaceForCoclass(ITypeInfo *pTI, ITypeInfo **ppTIDef)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr;                     // A result.
    TYPEATTR    *pAttr=0;               // Attributes on the first TypeInfo.
    int         flags;
    HREFTYPE    href;                   // href for the default typeinfo.

    IfFailGo(pTI->GetTypeAttr(&pAttr));
    if (pAttr->typekind == TKIND_COCLASS)
    {
        for (int i=0; i<pAttr->cImplTypes; ++i)
        {
            IfFailGo(pTI->GetImplTypeFlags(i, &flags));
            if (flags & IMPLTYPEFLAG_FDEFAULT)
                break;
        }
        // If no impltype had the default flag, use 0.
        if (i == pAttr->cImplTypes)
            i = 0;
        IfFailGo(pTI->GetRefTypeOfImplType(i, &href));
        IfFailGo(pTI->GetRefTypeInfo(href, ppTIDef));
    }
    else
    {
        *ppTIDef = 0;
        hr = S_FALSE;
    }

ErrExit:
    if (pAttr)
        pTI->ReleaseTypeAttr(pAttr);
    return hr;
} // HRESULT GetDefaultInterfaceForCoclass()

// Returns a NON-ADDREF'd ITypeInfo.
HRESULT GetITypeInfoForMT(ComMethodTable *pMT, ITypeInfo **ppTI)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    ITypeInfo   *pTI;                   // The ITypeInfo.
    
    pTI = pMT->GetITypeInfo();

    if (pTI == 0)
    {
        EEClass *pClass = pMT->m_pMT->GetClass();

        hr = GetITypeInfoForEEClass(pClass, &pTI);

        if (SUCCEEDED(hr))
        {
            pMT->SetITypeInfo(pTI);
            pTI->Release();
        }
    }

    *ppTI = pTI;
    return hr;
}



//------------------------------------------------------------------------------------------
// helper function to locate error info (if any) after a call, and make sure
// that the error info comes from that call

HRESULT GetSupportedErrorInfo(IUnknown *iface, REFIID riid, IErrorInfo **ppInfo)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(iface && ppInfo);

    //
    // See if we have any error info.  (Also this clears out the error info,
    // we want to do this whether it is a recent error or not.)
    //

    HRESULT hr = GetErrorInfo(0, ppInfo);

    if (hr == S_OK)
    {
        // Switch the GC state to preemptive before we go out to COM.
        Thread* pThread = GetThread();
        int fGC = pThread && pThread->PreemptiveGCDisabled();
        if (fGC)
            pThread->EnablePreemptiveGC();       

        //
        // Make sure that the object we called follows the error info protocol,
        // otherwise the error may be stale, so we just throw it away.
        //

        ISupportErrorInfo *pSupport;
        hr = iface->QueryInterface(IID_ISupportErrorInfo, (void **) &pSupport);
        LogInteropQI(iface, IID_ISupportErrorInfo, hr, "ISupportErrorInfo");

        if (FAILED(hr))
            *ppInfo = NULL;
        else
        {
            hr = pSupport->InterfaceSupportsErrorInfo(riid);

            if (hr == S_FALSE)
                *ppInfo = NULL;

            ULONG cbRef = SafeRelease(pSupport);
            LogInteropRelease(pSupport, cbRef, "SupportsErrorInfo");

        }

        // Switch the GC state back.
        if (fGC)
            pThread->DisablePreemptiveGC();
    }
    else
    {
        *ppInfo = NULL;
    }

    return hr;
}


//------------------------------------------------------------------------------------------
// helper function to fill up dispatch exception info
// from IErrorInfo 

void FillExcepInfo (EXCEPINFO *pexcepinfo, HRESULT hr, IErrorInfo* pErrorInfo)
{
    IErrorInfo* pErrorInfo2 = pErrorInfo;
    HRESULT hr2 = S_OK;
    if (pErrorInfo2 == NULL)
    {
        if (GetErrorInfo(0, &pErrorInfo2) != S_OK)
            pErrorInfo2 = NULL;
    }
    if (pErrorInfo2 != NULL)
    {
        pErrorInfo2->GetSource (&(pexcepinfo->bstrSource));
        pErrorInfo2->GetDescription (&(pexcepinfo->bstrDescription));
        pErrorInfo2->GetHelpFile (&(pexcepinfo->bstrHelpFile));
        pErrorInfo2->GetHelpContext (&(pexcepinfo->dwHelpContext));
    }
    pexcepinfo->scode = hr;
    if (pErrorInfo == NULL && pErrorInfo2 != NULL)
    {
        // clear any error info lying around
        SetErrorInfo(0,NULL);
    }
    if (pErrorInfo2)
    {
        ULONG cbRef = pErrorInfo->Release();
        LogInteropRelease(pErrorInfo, cbRef, " IErrorInfo");
    }    
}

// ---------------------------------------------------------------------------
//  Interface ISupportsErrorInfo
// %%Function: SupportsErroInfo_IntfSupportsErrorInfo,    %%Created by: rajak 
// ---------------------------------------------------------------------------
HRESULT __stdcall 
SupportsErroInfo_IntfSupportsErrorInfo(IUnknown* pUnk, REFIID riid)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pUnk));

    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    SimpleComCallWrapper *pWrap = SimpleComCallWrapper::GetWrapperFromIP(pUnk);
    if (pWrap->IsUnloaded())
        return COR_E_APPDOMAINUNLOADED;

    //@todo for now, all interfaces support ErrorInfo
    return S_OK;
}


// ---------------------------------------------------------------------------
//  Interface IErrorInfo
// %%Function: ErrorInfo_GetDescription,    %%Created by: rajak 
// ---------------------------------------------------------------------------
HRESULT __stdcall 
ErrorInfo_GetDescription(IUnknown* pUnk, BSTR* pbstrDescription)
{
    HRESULT hr = S_OK;
    SimpleComCallWrapper *pWrap = NULL;
    Thread* pThread = NULL;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pUnk));

    if (pbstrDescription == NULL) {
        hr = E_POINTER;
        goto Exit;
    }

    pWrap = SimpleComCallWrapper::GetWrapperFromIP(pUnk);
    if (pWrap->IsUnloaded()) {
        hr = COR_E_APPDOMAINUNLOADED;
        goto Exit;
    }

    pThread = SetupThread();
    if (!pThread) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY {
        *pbstrDescription = pWrap->IErrorInfo_bstrDescription();
    } COMPLUS_CATCH {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    } COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

Exit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}

// ---------------------------------------------------------------------------
//  Interface IErrorInfo
// %%Function: ErrorInfo_GetGUID,    %%Created by: rajak 
// ---------------------------------------------------------------------------
HRESULT __stdcall ErrorInfo_GetGUID(IUnknown* pUnk, GUID* pguid)
{
    HRESULT hr = S_OK;
    SimpleComCallWrapper *pWrap = NULL;
    Thread* pThread = NULL;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pUnk));

    if (pguid == NULL) {
        hr = E_POINTER;
        goto Exit;
    }

    pWrap = SimpleComCallWrapper::GetWrapperFromIP(pUnk);
    if (pWrap->IsUnloaded()) {
        hr = COR_E_APPDOMAINUNLOADED;
        goto Exit;
    }

    pThread = SetupThread();
    if (!pThread) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY {
        *pguid = pWrap->IErrorInfo_guid();
    } COMPLUS_CATCH {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    } COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

Exit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}

// ---------------------------------------------------------------------------
//  Interface IErrorInfo
// %%Function: ErrorInfo_GetHelpContext,    %%Created by: rajak 
// ---------------------------------------------------------------------------
HRESULT _stdcall ErrorInfo_GetHelpContext(IUnknown* pUnk, DWORD* pdwHelpCtxt)
{
    HRESULT hr = S_OK;
    SimpleComCallWrapper *pWrap = NULL;
    Thread* pThread = NULL;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pUnk));

    if (pdwHelpCtxt == NULL) {
        hr = E_POINTER;
        goto Exit;
    }

    pWrap = SimpleComCallWrapper::GetWrapperFromIP(pUnk);
    if (pWrap->IsUnloaded()) {
        hr = COR_E_APPDOMAINUNLOADED;
        goto Exit;
    }

    pThread = SetupThread();
    if (!pThread) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }


    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY {
        *pdwHelpCtxt = pWrap->IErrorInfo_dwHelpContext();
    } COMPLUS_CATCH {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    } COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

Exit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}

// ---------------------------------------------------------------------------
//  Interface IErrorInfo
// %%Function: ErrorInfo_GetHelpFile,    %%Created by: rajak 
// ---------------------------------------------------------------------------
HRESULT __stdcall ErrorInfo_GetHelpFile(IUnknown* pUnk, BSTR* pbstrHelpFile)
{
    HRESULT hr = S_OK;
    SimpleComCallWrapper *pWrap = NULL;
    Thread* pThread = NULL;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pUnk));

    if (pbstrHelpFile == NULL) {
        hr = E_POINTER;
        goto Exit;
    }

    pWrap = SimpleComCallWrapper::GetWrapperFromIP(pUnk);
    if (pWrap->IsUnloaded()) {
        hr = COR_E_APPDOMAINUNLOADED;
        goto Exit;
    }

    pThread = SetupThread();
    if (!pThread) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY {
        *pbstrHelpFile = pWrap->IErrorInfo_bstrHelpFile();
    } COMPLUS_CATCH {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    } COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

Exit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}

// ---------------------------------------------------------------------------
//  Interface IErrorInfo
// %%Function: ErrorInfo_GetSource,    %%Created by: rajak 
// ---------------------------------------------------------------------------
HRESULT __stdcall ErrorInfo_GetSource(IUnknown* pUnk, BSTR* pbstrSource)
{
    HRESULT hr = S_OK;
    SimpleComCallWrapper *pWrap = NULL;
    Thread* pThread = NULL;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pUnk));

    if (pbstrSource == NULL) {
        hr = E_POINTER;
        goto Exit;
    }

    pWrap = SimpleComCallWrapper::GetWrapperFromIP(pUnk);
    if (pWrap->IsUnloaded()) {
        hr = COR_E_APPDOMAINUNLOADED;
        goto Exit;
    }

    pThread = SetupThread();
    if (!pThread) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY {
        *pbstrSource = pWrap->IErrorInfo_bstrSource();
    } COMPLUS_CATCH {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    } COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

Exit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}


//------------------------------------------------------------------------------------------
//  IDispatch methods that forward to the right implementation based on the flags set
//  on the IClassX COM method table.

// ---------------------------------------------------------------------------
// %%Function: Dispatch_GetTypeInfoCount    %%Created by: billev   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------
HRESULT __stdcall
Dispatch_GetTypeInfoCount(
         IDispatch* pDisp,
         unsigned int *pctinfo)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsComPlusTearOff(pDisp));

    if (!pctinfo)
        return E_POINTER;

    ComMethodTable *pMT = ComMethodTable::ComMethodTableFromIP(pDisp);

    ITypeInfo *pTI; 
    HRESULT hr = GetITypeInfoForMT(pMT, &pTI);

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
        *pctinfo = 1;
    }
    else            
    {
        *pctinfo = 0;
    }

    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: Dispatch_GetTypeInfo    %%Created by: billev   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------
HRESULT __stdcall
Dispatch_GetTypeInfo (
    IDispatch* pDisp,
    unsigned int itinfo,
    LCID lcid,
    ITypeInfo **pptinfo)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsComPlusTearOff(pDisp));

    if (!pptinfo)
        return E_POINTER;

    ComMethodTable *pMT = ComMethodTable::ComMethodTableFromIP(pDisp);

    HRESULT hr = GetITypeInfoForMT(pMT, pptinfo);
    if (SUCCEEDED(hr))
    {
        // GetITypeInfoForMT() can return other success codes besides S_OK so 
        // we need to convert them to S_OK.
        hr = S_OK;
        (*pptinfo)->AddRef();
    }
    else
    {
        *pptinfo = NULL;
    }

    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: Dispatch_GetIDsOfNames    %%Created by: billev   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------
HRESULT __stdcall
Dispatch_GetIDsOfNames (
    IDispatch* pDisp,
    REFIID riid,
    OLECHAR **rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID *rgdispid)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsComPlusTearOff(pDisp));

    // Retrieve the IClassX method table from the COM IP.
    ComCallWrapper *pWrap = ComCallWrapper::GetWrapperFromIP(pDisp);
    if (pWrap->IsUnloaded())
        return COR_E_APPDOMAINUNLOADED;

    ComMethodTable *pIClassXCMT = pWrap->GetIClassXComMT();
    if (!pIClassXCMT)
        return E_OUTOFMEMORY;

    // Use the right implementation based on the flags in the IClassX ComMethodTable.
    if (pIClassXCMT->IsUseOleAutDispatchImpl())
    {
        return OleAutDispatchImpl_GetIDsOfNames(pDisp, riid, rgszNames, cNames, lcid, rgdispid);
    }
    else
    {
        return InternalDispatchImpl_GetIDsOfNames(pDisp, riid, rgszNames, cNames, lcid, rgdispid);
    }
}

// ---------------------------------------------------------------------------
// %%Function: Dispatch_Invoke    %%Created by: billev   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------
HRESULT __stdcall
Dispatch_Invoke
    (
    IDispatch* pDisp,
    DISPID dispidMember,
    REFIID riid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT hr;

    _ASSERTE(IsComPlusTearOff(pDisp));

    // Retrieve the IClassX method table from the COM IP.
    ComCallWrapper *pWrap = ComCallWrapper::GetWrapperFromIP(pDisp);
    if (pWrap->IsUnloaded())
        return COR_E_APPDOMAINUNLOADED;

    ComMethodTable *pIClassXCMT = pWrap->GetIClassXComMT();
    if (!pIClassXCMT)
        return E_OUTOFMEMORY;

    // Use the right implementation based on the flags in the IClassX ComMethodTable.
    if (pIClassXCMT->IsUseOleAutDispatchImpl())
    {
        hr = OleAutDispatchImpl_Invoke(pDisp, dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
    }
    else
    {
        hr = InternalDispatchImpl_Invoke(pDisp, dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
    }

    return hr;
}


//------------------------------------------------------------------------------------------
//  IDispatch methods for COM+ objects implemented internally using reflection.

// ---------------------------------------------------------------------------
// %%Function: OleAutDispatchImpl_GetIDsOfNames    %%Created by: billev   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------
HRESULT __stdcall
OleAutDispatchImpl_GetIDsOfNames (
    IDispatch* pDisp,
    REFIID riid,
    OLECHAR **rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID *rgdispid)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsComPlusTearOff(pDisp));

    // Make sure that riid is IID_NULL.
    if (riid != IID_NULL)
        return DISP_E_UNKNOWNINTERFACE;

    // Retrieve the COM method table from the IP.
    ComMethodTable *pMT = ComMethodTable::ComMethodTableFromIP(pDisp);

    ITypeInfo *pTI;
    HRESULT hr = GetITypeInfoForMT(pMT, &pTI);
    if (FAILED(hr))
        return (hr);

    hr = pTI->GetIDsOfNames(rgszNames, cNames, rgdispid);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: OleAutDispatchImpl_Invoke    %%Created by: billev   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------
HRESULT __stdcall
OleAutDispatchImpl_Invoke
    (
    IDispatch* pDisp,
    DISPID dispidMember,
    REFIID riid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
    HRESULT hr = S_OK;
    ComMethodTable* pMT;

    _ASSERTE(IsComPlusTearOff(pDisp));

    // Make sure that riid is IID_NULL.
    if (riid != IID_NULL)
        return DISP_E_UNKNOWNINTERFACE;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    Thread* pThread = SetupThread();
    if (pThread == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Retrieve the COM method table from the IP.
    pMT = ComMethodTable::ComMethodTableFromIP(pDisp);

    ITypeInfo *pTI;
    hr = GetITypeInfoForMT(pMT, &pTI);
    if (FAILED(hr)) 
        goto Exit;

#ifdef CUSTOMER_CHECKED_BUILD
    CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();

    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_ObjNotKeptAlive))
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        g_pGCHeap->GarbageCollect();
        g_pGCHeap->FinalizerThreadWait(1000);
        END_ENSURE_COOPERATIVE_GC();
    }
#endif // CUSTOMER_CHECKED_BUILD

    hr = pTI->Invoke(pDisp, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);

#ifdef CUSTOMER_CHECKED_BUILD
    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_BufferOverrun))
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        g_pGCHeap->GarbageCollect();
        g_pGCHeap->FinalizerThreadWait(1000);
        END_ENSURE_COOPERATIVE_GC();
    }
#endif // CUSTOMER_CHECKED_BUILD

Exit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return hr;
}

//------------------------------------------------------------------------------------------
//  IDispatch methods for COM+ objects implemented internally using reflection.

struct InternalDispatchImpl_GetIDsOfNames_Args {
    IDispatch* pDisp;
    const IID *iid;
    OLECHAR **rgszNames;
    unsigned int cNames;
    LCID lcid;
    DISPID *rgdispid;
    HRESULT *hr;
};
void InternalDispatchImpl_GetIDsOfNames_Wrapper (InternalDispatchImpl_GetIDsOfNames_Args *args)
{
    *(args->hr) = InternalDispatchImpl_GetIDsOfNames(args->pDisp, *args->iid, args->rgszNames, args->cNames, args->lcid, args->rgdispid);
}

// ---------------------------------------------------------------------------
// %%Function: InternalDispatchImpl_GetIDsOfNames    %%Created by: dmortens
// ---------------------------------------------------------------------------
HRESULT __stdcall
InternalDispatchImpl_GetIDsOfNames (
    IDispatch* pDisp,
    REFIID riid,
    OLECHAR **rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID *rgdispid)
{
    HRESULT hr = S_OK;
    DispatchInfo *pDispInfo;
    SimpleComCallWrapper *pSimpleWrap;

    _ASSERTE(IsComPlusTearOff(pDisp));

    // Validate the arguments.
    if (!rgdispid)
        return E_POINTER;

    if (riid != IID_NULL)
        return DISP_E_UNKNOWNINTERFACE;

    if (cNames < 1)
        return S_OK;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    Thread* pThread = SetupThread();
    if (pThread == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Switch to cooperative mode before we play with any OBJECTREF's.
    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY
    {
        // This call is coming thru an interface that inherits from IDispatch.
        pSimpleWrap = ComCallWrapper::GetSimpleWrapper(ComCallWrapper::GetStartWrapperFromIP(pDisp));

        if (pSimpleWrap->NeedToSwitchDomains(pThread, TRUE))
        {
            InternalDispatchImpl_GetIDsOfNames_Args args = 
                {pDisp, &riid, rgszNames, cNames, lcid, rgdispid, &hr};
            // call ourselves again through DoCallBack with a domain transition
             pThread->DoADCallBack(pSimpleWrap->GetObjectContext(pThread), InternalDispatchImpl_GetIDsOfNames_Wrapper, &args);
        }
        else
        {
            pDispInfo = ComMethodTable::ComMethodTableFromIP(pDisp)->GetDispatchInfo();

            // Attempt to find the member in the DispatchEx information.
            DispatchMemberInfo *pDispMemberInfo = pDispInfo->FindMember(rgszNames[0], FALSE);

            // Check to see if the member has been found.
            if (pDispMemberInfo)
            {
                // Get the DISPID of the member.
                rgdispid[0] = pDispMemberInfo->m_DispID;

                // Get the ID's of the named arguments.
                if (cNames > 1)
                    hr = pDispMemberInfo->GetIDsOfParameters(rgszNames + 1, cNames - 1, rgdispid + 1, FALSE);
            }
            else
            {
                rgdispid[0] = DISPID_UNKNOWN;
                hr = DISP_E_UNKNOWNNAME;
            }
        }
    }
    COMPLUS_CATCH 
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();
Exit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: InternalDispatchImpl_Invoke    %%Created by: dmortens
// ---------------------------------------------------------------------------
struct InternalDispatchImpl_Invoke_Args {
    IDispatch* pDisp;
    DISPID dispidMember;
    const IID *riid;
    LCID lcid;
    unsigned short wFlags;
    DISPPARAMS *pdispparams;
    VARIANT *pvarResult;
    EXCEPINFO *pexcepinfo;
    unsigned int *puArgErr;
    HRESULT *hr;
};

void InternalDispatchImpl_Invoke_Wrapper(InternalDispatchImpl_Invoke_Args *pArgs)
{
    *(pArgs->hr) = InternalDispatchImpl_Invoke(pArgs->pDisp, pArgs->dispidMember, *pArgs->riid, pArgs->lcid,
                                              pArgs->wFlags, pArgs->pdispparams, pArgs->pvarResult, 
                                              pArgs->pexcepinfo, pArgs->puArgErr);
}

HRESULT __stdcall
InternalDispatchImpl_Invoke
    (
    IDispatch* pDisp,
    DISPID dispidMember,
    REFIID riid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
    DispatchInfo *pDispInfo;
    SimpleComCallWrapper *pSimpleWrap;
    HRESULT hr = S_OK;

    _ASSERTE(IsComPlusTearOff(pDisp));

    // Check for valid input args that are not covered by DispatchInfo::InvokeMember.
    if (riid != IID_NULL)
        return DISP_E_UNKNOWNINTERFACE;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    Thread* pThread = SetupThread();
    if (pThread == NULL) 
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Switch to cooperative mode before we play with any OBJECTREF's.
    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY
    {
        // This call is coming thru an interface that inherits form IDispatch.
        pSimpleWrap = ComCallWrapper::GetSimpleWrapper(ComCallWrapper::GetStartWrapperFromIP(pDisp));

        if (pSimpleWrap->NeedToSwitchDomains(pThread, TRUE))
        {
            InternalDispatchImpl_Invoke_Args args = 
                {pDisp, dispidMember, &riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr, &hr};
            // call ourselves again through DoCallBack with a domain transition
            pThread->DoADCallBack(pSimpleWrap->GetObjectContext(pThread), InternalDispatchImpl_Invoke_Wrapper, &args);
        }
        else
        {
            // Invoke the member.
            pDispInfo = ComMethodTable::ComMethodTableFromIP(pDisp)->GetDispatchInfo();
            hr = pDispInfo->InvokeMember(pSimpleWrap, dispidMember, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, NULL, puArgErr);
        }
    }
    COMPLUS_CATCH 
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH

    // Switch back to preemptive mode before we go back into COM.
    END_ENSURE_COOPERATIVE_GC();
Exit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}


//------------------------------------------------------------------------------------------
//      Definitions used by the IDispatchEx implementation

// The names of the properties that are accessed on the managed member info's
#define MEMBER_INFO_NAME_PROP           "Name"
#define MEMBER_INFO_TYPE_PROP           "MemberType"
#define PROPERTY_INFO_CAN_READ_PROP     "CanRead"
#define PROPERTY_INFO_CAN_WRITE_PROP    "CanWrite"

//------------------------------------------------------------------------------------------
//      IDispatchEx methods for COM+ objects

// IDispatchEx::GetTypeInfoCount
HRESULT __stdcall   DispatchEx_GetTypeInfoCount(
                                    IDispatch* pDisp,
                                    unsigned int *pctinfo
                                    )
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;
    ITypeInfo *pTI = NULL;

    _ASSERTE(IsSimpleTearOff(pDisp));

    // Validate the arguments.
    if (!pctinfo)
        return E_POINTER;

    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pDisp);
    if (pSimpleWrap->IsUnloaded())
        return COR_E_APPDOMAINUNLOADED;

    // Retrieve the class ComMethodTable.
    ComMethodTable *pComMT = 
        ComCallWrapperTemplate::SetupComMethodTableForClass(pSimpleWrap->m_pClass->GetMethodTable(), FALSE);
    _ASSERTE(pComMT);

    // Check to see if we have a cached ITypeInfo on the class ComMethodTable.
    hr = GetITypeInfoForMT(pComMT, &pTI);
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
        *pctinfo = 1;
    }
    else
    {
        *pctinfo = 0;
    }

    return hr;
}

// IDispatchEx::GetTypeInfo
HRESULT __stdcall   DispatchEx_GetTypeInfo (
                                    IDispatch* pDisp,
                                    unsigned int itinfo,
                                    LCID lcid,
                                    ITypeInfo **pptinfo
                                    )
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;

    _ASSERTE(IsSimpleTearOff(pDisp));

    // Validate the arguments.
    if (!pptinfo)
        return E_POINTER;

    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pDisp);
    if (pSimpleWrap->IsUnloaded())
        return COR_E_APPDOMAINUNLOADED;

    // Retrieve the class ComMethodTable.
    ComMethodTable *pComMT = 
        ComCallWrapperTemplate::SetupComMethodTableForClass(pSimpleWrap->m_pClass->GetMethodTable(), FALSE);
    _ASSERTE(pComMT);

    // Retrieve the ITypeInfo for the ComMethodTable.
    hr = GetITypeInfoForMT(pComMT, pptinfo);
    if (SUCCEEDED(hr))
    {
        // GetITypeInfoForMT() can return other success codes besides S_OK so 
        // we need to convert them to S_OK.
        hr = S_OK;
        (*pptinfo)->AddRef();
    }
    else
    {
        *pptinfo = NULL;
    }

    return hr;
}

// IDispatchEx::GetIDsofNames
HRESULT __stdcall   DispatchEx_GetIDsOfNames (
                                    IDispatchEx* pDisp,
                                    REFIID riid,
                                    OLECHAR **rgszNames,
                                    unsigned int cNames,
                                    LCID lcid,
                                    DISPID *rgdispid
                                    )
{
    HRESULT hr = S_OK;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pDisp));

    // Validate the arguments.
    if (!rgdispid)
        return E_POINTER;

    if (riid != IID_NULL)
        return DISP_E_UNKNOWNINTERFACE;

    if (cNames < 1)
        return S_OK;

    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    // Retrieve the dispatch info and the simpler wrapper for this IDispatchEx.
    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pDisp);

    // Switch to cooperative mode before we play with any OBJECTREF's.
    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY 
    {
        _ASSERTE(pThread->GetDomain() == pSimpleWrap->GetDomainSynchronized());        
        DispatchExInfo *pDispExInfo = pSimpleWrap->m_pDispatchExInfo;
        // Attempt to find the member in the DispatchEx information.
        DispatchMemberInfo *pDispMemberInfo = pDispExInfo->SynchFindMember(rgszNames[0], FALSE);

        // Check to see if the member has been found.
        if (pDispMemberInfo)
        {
            // Get the DISPID of the member.
            rgdispid[0] = pDispMemberInfo->m_DispID;

            // Get the ID's of the named arguments.
            if (cNames > 1)
                hr = pDispMemberInfo->GetIDsOfParameters(rgszNames + 1, cNames - 1, rgdispid + 1, FALSE);
        }
        else
        {
            rgdispid[0] = DISPID_UNKNOWN;
            hr = DISP_E_UNKNOWNNAME;
        }
    }
    COMPLUS_CATCH 
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return hr;
}

// IDispatchEx::Invoke
HRESULT __stdcall   DispatchEx_Invoke (
                                    IDispatchEx* pDisp,
                                    DISPID dispidMember,
                                    REFIID riid,
                                    LCID lcid,
                                    unsigned short wFlags,
                                    DISPPARAMS *pdispparams,
                                    VARIANT *pvarResult,
                                    EXCEPINFO *pexcepinfo,
                                    unsigned int *puArgErr
                                    )
{
    HRESULT hr = S_OK;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pDisp));

    // Check for valid input args that are not covered by DispatchInfo::InvokeMember.
    if (riid != IID_NULL)
        return DISP_E_UNKNOWNINTERFACE;

    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    // Retrieve the dispatch info and the simpler wrapper for this IDispatchEx.
    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pDisp);

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY 
    {
        _ASSERTE(pThread->GetDomain() == pSimpleWrap->GetDomainSynchronized());        
        DispatchExInfo *pDispExInfo = pSimpleWrap->m_pDispatchExInfo;
        // Invoke the member.
        hr = pDispExInfo->SynchInvokeMember(pSimpleWrap, dispidMember, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, NULL, puArgErr);
    }
    COMPLUS_CATCH 
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH
    
    END_ENSURE_COOPERATIVE_GC();

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}

// IDispatchEx::DeleteMemberByDispID
HRESULT __stdcall   DispatchEx_DeleteMemberByDispID (
                                    IDispatchEx* pDisp,
                                    DISPID id
                                    )
{
    HRESULT hr = S_OK;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pDisp));

    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    // Retrieve the dispatch info and the simpler wrapper for this IDispatchEx.
    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pDisp);

    DispatchExInfo *pDispExInfo = pSimpleWrap->m_pDispatchExInfo;

    // If the member does not support expando operations then we cannot remove the member.
    if (!pDispExInfo->SupportsExpando())
        return E_NOTIMPL;

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY
    {
        _ASSERTE(pThread->GetDomain() == pSimpleWrap->GetDomainSynchronized());        
        // Delete the member from the IExpando. This method takes care of synchronizing with
        // the managed view to make sure the member gets deleted.
        pDispExInfo->DeleteMember(id);
        hr = S_OK;
    }
    COMPLUS_CATCH 
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH
    
    END_ENSURE_COOPERATIVE_GC();

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}

// IDispatchEx::DeleteMemberByName
HRESULT __stdcall   DispatchEx_DeleteMemberByName (
                                    IDispatchEx* pDisp,
                                    BSTR bstrName,
                                    DWORD grfdex
                                    )
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;
    DISPID DispID;

    _ASSERTE(IsSimpleTearOff(pDisp));

    // Retrieve the dispatch info and the simpler wrapper for this IDispatchEx.
    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pDisp);
    if (pSimpleWrap->IsUnloaded())
        return COR_E_APPDOMAINUNLOADED;
    DispatchExInfo *pDispExInfo = pSimpleWrap->m_pDispatchExInfo;

    // If the member does not support expando operations then we cannot remove the member.
    if (!pDispExInfo->SupportsExpando())
        return E_NOTIMPL;

    // Simply find the associated DISPID and delegate the call to DeleteMemberByDispID.
    hr = DispatchEx_GetDispID(pDisp, bstrName, grfdex, &DispID);
    if (SUCCEEDED(hr))
        hr = DispatchEx_DeleteMemberByDispID(pDisp, DispID);

    return hr;
}

// IDispatchEx::GetDispID
HRESULT __stdcall   DispatchEx_GetDispID (
                                    IDispatchEx* pDisp,
                                    BSTR bstrName,
                                    DWORD grfdex,
                                    DISPID *pid
                                    )
{
    HRESULT hr = S_OK;
    SimpleComCallWrapper *pSimpleWrap;
    DispatchExInfo *pDispExInfo;

    _ASSERTE(IsSimpleTearOff(pDisp));

    // Validate the arguments.
    if (!pid)
        return E_POINTER;

    // @TODO (DM): Determine what to do with the fdexNameImplicit flag.
    if (grfdex & fdexNameImplicit)
        return E_INVALIDARG;

    // Initialize the pid to DISPID_UNKNOWN before we start.
    *pid = DISPID_UNKNOWN;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    Thread* pThread = SetupThread();
    if (pThread == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Retrieve the dispatch info and the simpler wrapper for this IDispatchEx.
    pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pDisp);

    BEGIN_ENSURE_COOPERATIVE_GC();
    COMPLUS_TRY
    {
        _ASSERTE(pThread->GetDomain() == pSimpleWrap->GetDomainSynchronized());        
        pDispExInfo = pSimpleWrap->m_pDispatchExInfo;

        // Attempt to find the member in the DispatchEx information.
        DispatchMemberInfo *pDispMemberInfo = pDispExInfo->SynchFindMember(bstrName, grfdex & fdexNameCaseSensitive);

        // If we still have not found a match and the fdexNameEnsure flag is set then we 
        // need to add the member to the expando object.
        if (!pDispMemberInfo)
        {
            if (grfdex & fdexNameEnsure)
            {
                if (pDispExInfo->SupportsExpando())
                {
                    pDispMemberInfo = pDispExInfo->AddMember(bstrName, grfdex);
                    if (!pDispMemberInfo)
                        hr = E_UNEXPECTED;
                }
                else
                {
                    hr = E_NOTIMPL;
                }
            }
            else
            {
                hr = DISP_E_UNKNOWNNAME;
            }
        }

        // Set the return DISPID if the member has been found.
        if (pDispMemberInfo)
            *pid = pDispMemberInfo->m_DispID;
    }
    COMPLUS_CATCH
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

Exit:

    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return hr;
}

// IDispatchEx::GetMemberName
HRESULT __stdcall   DispatchEx_GetMemberName (
                                    IDispatchEx* pDisp,
                                    DISPID id,
                                    BSTR *pbstrName
                                    )
{
    HRESULT hr = S_OK;

    _ASSERTE(IsSimpleTearOff(pDisp));

    // Validate the arguments.
    if (!pbstrName)
        return E_POINTER;

    // Initialize the pbstrName to NULL before we start.
    *pbstrName = NULL;

    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    // Retrieve the dispatch info and the simpler wrapper for this IDispatchEx.
    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pDisp);

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY
    {
        _ASSERTE(pThread->GetDomain() == pSimpleWrap->GetDomainSynchronized());        
        DispatchExInfo *pDispExInfo = pSimpleWrap->m_pDispatchExInfo;

        // Do a lookup in the hashtable to find the DispatchMemberInfo for the DISPID.
        DispatchMemberInfo *pDispMemberInfo = pDispExInfo->SynchFindMember(id);

        // If the member does not exist then we return DISP_E_MEMBERNOTFOUND.
        if (!pDispMemberInfo || !ObjectFromHandle(pDispMemberInfo->m_hndMemberInfo))
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        else
        {
            // Copy the name into the output string.
            *pbstrName = SysAllocString(pDispMemberInfo->m_strName);
        }
    }
    COMPLUS_CATCH
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

    return hr;
}

// IDispatchEx::GetMemberProperties
HRESULT __stdcall   DispatchEx_GetMemberProperties (
                                    IDispatchEx* pDisp,
                                    DISPID id,
                                    DWORD grfdexFetch,
                                    DWORD *pgrfdex
                                    )
{
    HRESULT hr = S_OK;
    _ASSERTE(IsSimpleTearOff(pDisp));

    // Validate the arguments.
    if (!pgrfdex)
        return E_POINTER;

    // Initialize the return properties to 0.
    *pgrfdex = 0;

    EnumMemberTypes MemberType;
    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    // Do some argument validation.
    if (!pgrfdex)
        return E_INVALIDARG;

    // Retrieve the dispatch info and the simpler wrapper for this IDispatchEx.
    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pDisp);

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY
    {
        _ASSERTE(pThread->GetDomain() == pSimpleWrap->GetDomainSynchronized());
        DispatchExInfo *pDispExInfo = pSimpleWrap->m_pDispatchExInfo;
        OBJECTREF MemberInfoObj = NULL;
        GCPROTECT_BEGIN(MemberInfoObj)
        {
            // Do a lookup in the hashtable to find the DispatchMemberInfo for the DISPID.
            DispatchMemberInfo *pDispMemberInfo = pDispExInfo->SynchFindMember(id);

            // If the member does not exist then we return DISP_E_MEMBERNOTFOUND.
            if (!pDispMemberInfo || (MemberInfoObj = ObjectFromHandle(pDispMemberInfo->m_hndMemberInfo)) == NULL)
            {
                hr = DISP_E_MEMBERNOTFOUND;
            }
            else
            {
                // Retrieve the type of the member.
                MemberType = pDispMemberInfo->GetMemberType();

                // Retrieve the member properties based on the type of the member.
                switch (MemberType)
                {
                    case Field:
                    {
                        *pgrfdex = fdexPropCanGet | 
                                   fdexPropCanPut | 
                                   fdexPropCannotPutRef | 
                                   fdexPropCannotCall | 
                                   fdexPropCannotConstruct |
                                   fdexPropCannotSourceEvents;
                        break;
                    }

                    case Property:
                    {
                        BOOL bCanRead = FALSE;
                        BOOL bCanWrite = FALSE;

                        // Find the MethodDesc's for the CanRead property.
                        MethodDesc *pCanReadMD = MemberInfoObj->GetClass()->FindPropertyMethod(PROPERTY_INFO_CAN_READ_PROP, PropertyGet);
                        if (!pCanReadMD)
                        {
                            _ASSERTE(!"Unable to find setter method for property PropertyInfo::CanRead");
                        }

                        // Find the MethodDesc's for the CanWrite property.
                        MethodDesc *pCanWriteMD = MemberInfoObj->GetClass()->FindPropertyMethod(PROPERTY_INFO_CAN_WRITE_PROP, PropertyGet);
                        if (!pCanWriteMD)
                        {
                            _ASSERTE(!"Unable to find setter method for property PropertyInfo::CanWrite");
                        }

                        // Check to see if the property can be read.
                        INT64 CanReadArgs[] = { 
                            ObjToInt64(MemberInfoObj)
                        };
                        bCanRead = (BOOL)pCanReadMD->Call(CanReadArgs);

                        // Check to see if the property can be written to.
                        INT64 CanWriteArgs[] = { 
                            ObjToInt64(MemberInfoObj)
                        };
                        bCanWrite = (BOOL)pCanWriteMD->Call(CanWriteArgs);

                        *pgrfdex = bCanRead ? fdexPropCanGet : fdexPropCannotGet |
                                   bCanWrite? fdexPropCanPut : fdexPropCannotPut |
                                   fdexPropCannotPutRef | 
                                   fdexPropCannotCall | 
                                   fdexPropCannotConstruct |
                                   fdexPropCannotSourceEvents;
                        break;
                    }

                    case Method:
                    {
                        *pgrfdex = fdexPropCannotGet | 
                                   fdexPropCannotPut | 
                                   fdexPropCannotPutRef | 
                                   fdexPropCanCall | 
                                   fdexPropCannotConstruct |
                                   fdexPropCannotSourceEvents;
                        break;
                    }

                    default:
                    {
                        hr = E_UNEXPECTED;
                        break;
                    }
                }

                // Mask out the unwanted properties.
                *pgrfdex &= grfdexFetch;
            }
        }
        GCPROTECT_END();
    }
    COMPLUS_CATCH
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

    return hr;
}

// IDispatchEx::GetNameSpaceParent
HRESULT __stdcall   DispatchEx_GetNameSpaceParent (
                                    IDispatchEx* pDisp,
                                    IUnknown **ppunk
                                    )
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pDisp));

    // Validate the arguments.
    if (!ppunk)
        return E_POINTER;

    // @TODO (DM): Implement this.
    *ppunk = NULL;
    return E_NOTIMPL;
}


// IDispatchEx::GetNextDispID
HRESULT __stdcall   DispatchEx_GetNextDispID (
                                    IDispatchEx* pDisp,
                                    DWORD grfdex,
                                    DISPID id,
                                    DISPID *pid
                                    )
{
    DispatchMemberInfo *pNextMember;

    HRESULT hr = S_OK;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pDisp));


    // Validate the arguments.
    if (!pid)
        return E_POINTER;

    // Initialize the pid to DISPID_UNKNOWN.
    *pid = DISPID_UNKNOWN;

    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    // Retrieve the dispatch info and the simpler wrapper for this IDispatchEx.
    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pDisp);

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY
    {
        _ASSERTE(pThread->GetDomain() == pSimpleWrap->GetDomainSynchronized());
        DispatchExInfo *pDispExInfo = pSimpleWrap->m_pDispatchExInfo;
        // Retrieve either the first member or the next based on the DISPID.
        if (id == DISPID_STARTENUM)
            pNextMember = pDispExInfo->GetFirstMember();
        else
            pNextMember = pDispExInfo->GetNextMember(id);
    }
    COMPLUS_CATCH
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
        goto exit;
    }
    COMPLUS_END_CATCH

    // If we have found a member that has not been deleted then return its DISPID.
    if (pNextMember)
    {
        *pid = pNextMember->m_DispID;
        hr = S_OK;
    }
    else 
        hr = S_FALSE;
exit:
    END_ENSURE_COOPERATIVE_GC();
    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return hr;
}


// IDispatchEx::InvokeEx
HRESULT __stdcall   DispatchEx_InvokeEx (
                                    IDispatchEx* pDisp,
                                    DISPID id,
                                    LCID lcid,
                                    WORD wFlags,
                                    DISPPARAMS *pdp,
                                    VARIANT *pVarRes, 
                                    EXCEPINFO *pei, 
                                    IServiceProvider *pspCaller 
                                    )
{
    HRESULT hr = S_OK;
    
    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pDisp));

    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    // Retrieve the dispatch info and the simpler wrapper for this IDispatchEx.
    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pDisp);
    DispatchExInfo *pDispExInfo = pSimpleWrap->m_pDispatchExInfo;

    BEGIN_ENSURE_COOPERATIVE_GC();

#ifdef _SECURITY_FRAME_FOR_DISPEX_CALLS
    ComClientSecurityFrame csf(pspCaller);
#endif

    COMPLUS_TRY
    {
        _ASSERTE(pThread->GetDomain() == pSimpleWrap->GetDomainSynchronized());
        // Invoke the member.
        hr = pDispExInfo->SynchInvokeMember(pSimpleWrap, id, lcid, wFlags, pdp, pVarRes, pei, pspCaller, NULL);
    }
    COMPLUS_CATCH
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH

#ifdef _SECURITY_FRAME_FOR_DISPEX_CALLS
    csf.Pop();
#endif

    END_ENSURE_COOPERATIVE_GC();
    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}

// HELPER to call RealProxy::GetIUnknown to get the iunknown to give out
// for this transparent proxy for calls to IMarshal
IUnknown* GetIUnknownForTransparentProxyHelper(SimpleComCallWrapper *pSimpleWrap)
{
    IUnknown* pMarshalerObj = NULL;
    // Setup the thread object.
    Thread *pThread = GetThread();
    _ASSERTE(pThread);
    BOOL fGCDisabled = pThread->PreemptiveGCDisabled();
    if (!fGCDisabled)
    {
        pThread->DisablePreemptiveGC();
    }

    COMPLUS_TRYEX(pThread)
    {
        OBJECTREF oref = pSimpleWrap->GetObjectRef();
        GCPROTECT_BEGIN(oref)
        {
            pMarshalerObj = GetIUnknownForTransparentProxy(&oref, TRUE);  
            oref = NULL;
        }
        GCPROTECT_END();
   }
   COMPLUS_CATCH
   {
    // ignore
   }
   COMPLUS_END_CATCH
   
   if (!fGCDisabled)
   {
       pThread->EnablePreemptiveGC();
   }

   return pMarshalerObj;
}

// Helper to setup IMarshal 
IMarshal *GetSpecialMarshaler(IMarshal* pMarsh, SimpleComCallWrapper* pSimpleWrap, ULONG dwDestContext)
{
    IMarshal *pMshRet = NULL;
        
    HRESULT hr;
    // transparent proxies are special
    if (pSimpleWrap->IsObjectTP())
    {
        IUnknown *pMarshalerObj = NULL;
        pMarshalerObj = GetIUnknownForTransparentProxyHelper(pSimpleWrap);
        // QI for the IMarshal Interface and verify that we don't get back
        // a pointer to us (GetIUnknownForTransparentProxyHelper could return
        // a pointer back to the same object if realproxy::GetCOMIUnknown 
        // is not overriden
       if (pMarshalerObj != NULL)
       { 
            IMarshal* pMsh = NULL;
            hr = pMarshalerObj->QueryInterface(IID_IMarshal, (void**)&pMsh);
              // make sure we don't recurse
            if(SUCCEEDED(hr) && pMsh != pMarsh) 
            {
                pMshRet = pMsh;
            }
            else
            {
                if (pMsh)
                {
                    ULONG cbRef = pMsh->Release ();
                    LogInteropRelease(pMsh, cbRef, "GetSpecialMarshaler");    
                }
            }
            pMarshalerObj->Release();       
       }    
    }

   // Use standard marshalling for everything except in-proc servers.
    if (pMshRet == NULL && dwDestContext != MSHCTX_INPROC) 
    {       
        IUnknown *pMarshalerObj = NULL;
        hr = CoCreateFreeThreadedMarshaler(NULL, &pMarshalerObj);    
        if (hr == S_OK)
        {
            _ASSERTE(pMarshalerObj);
            hr = pMarshalerObj->QueryInterface(IID_IMarshal, (void**)&pMshRet);
            pMarshalerObj->Release();
        }   
    }

   return pMshRet;
}


ComPlusWrapper* GetComPlusWrapperOverDCOMForManaged(OBJECTREF oref);



//------------------------------------------------------------------------------------------
//      IMarshal methods for COM+ objects

//------------------------------------------------------------------------------------------

HRESULT __stdcall Marshal_GetUnmarshalClass (
                            IMarshal* pMarsh,
                            REFIID riid, void * pv, ULONG dwDestContext, 
                            void * pvDestContext, ULONG mshlflags, 
                            LPCLSID pclsid)
{
    HRESULT hr = S_OK;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pMarsh));
    
    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pMarsh);
    if (pSimpleWrap->IsUnloaded())
        return COR_E_APPDOMAINUNLOADED;

    IMarshal *pMsh = GetSpecialMarshaler(pMarsh, pSimpleWrap, dwDestContext);

    if (pMsh != NULL)
    { 
        hr = pMsh->GetUnmarshalClass (riid, pv, dwDestContext, pvDestContext, mshlflags, pclsid);
        ULONG cbRef = pMsh->Release ();
        LogInteropRelease(pMsh, cbRef, "GetUnmarshal class");    
        return hr;
    }
    
    // Setup logical thread if we've not already done so.
    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    // Use a statically allocated singleton class to do all unmarshalling.
    *pclsid = CLSID_ComCallUnmarshal;
    
    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return S_OK;
}

HRESULT __stdcall Marshal_GetMarshalSizeMax (
                                IMarshal* pMarsh,
                                REFIID riid, void * pv, ULONG dwDestContext, 
                                void * pvDestContext, ULONG mshlflags, 
                                ULONG * pSize)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pMarsh));

    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pMarsh);
    if (pSimpleWrap->IsUnloaded())
        return COR_E_APPDOMAINUNLOADED;

    IMarshal *pMsh = GetSpecialMarshaler(pMarsh, pSimpleWrap, dwDestContext);

    if (pMsh != NULL)
    { 
        HRESULT hr = pMsh->GetMarshalSizeMax (riid, pv, dwDestContext, pvDestContext, mshlflags, pSize);
        ULONG cbRef = pMsh->Release ();
        LogInteropRelease(pMsh, cbRef, "GetMarshalSizeMax");   
        return hr;
    }

    // Setup logical thread if we've not already done so.
    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    *pSize = sizeof (IUnknown *) + sizeof (ULONG) + sizeof(GUID);

    return S_OK;
}

HRESULT __stdcall Marshal_MarshalInterface (
                        IMarshal* pMarsh,
                        LPSTREAM pStm, REFIID riid, void * pv,
                        ULONG dwDestContext, LPVOID pvDestContext,
                        ULONG mshlflags)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    ULONG cbRef;
        
    _ASSERTE(IsSimpleTearOff(pMarsh));

    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pMarsh);
    if (pSimpleWrap->IsUnloaded())
        return COR_E_APPDOMAINUNLOADED;

    IMarshal *pMsh = GetSpecialMarshaler(pMarsh, pSimpleWrap, dwDestContext);

    if (pMsh != NULL)
    { 
        HRESULT hr = pMsh->MarshalInterface (pStm, riid, pv, dwDestContext, pvDestContext, mshlflags);
        ULONG cbRef = pMsh->Release ();
        LogInteropRelease(pMsh, cbRef, " MarshalInterface");        
        return hr;
    }
    
    // Setup logical thread if we've not already done so.
    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    // Write the raw IP into the marshalling stream.
    HRESULT hr = pStm->Write (&pv, sizeof (pv), 0);
    if (FAILED (hr))
        return hr;

    // Followed by the marshalling flags (we need these on the remote end to
    // manage refcounting the IP).
    hr = pStm->Write (&mshlflags, sizeof (mshlflags), 0);
    if (FAILED (hr))
        return hr;

    // Followed by the secret, which confirms that the pointer above can be trusted
    // because it originated from our process.
    hr = InitUnmarshalSecret();
    if (FAILED(hr))
        return hr;

    hr = pStm->Write(g_UnmarshalSecret, sizeof(g_UnmarshalSecret), 0);
    if (FAILED(hr))
        return hr;

    // We have now created an additional reference to the object.
    cbRef = ((IUnknown *)pv)->AddRef ();

    LogInteropAddRef((IUnknown *)pv, cbRef, "MarshalInterface");
    return S_OK;
}

HRESULT __stdcall Marshal_UnmarshalInterface (
                        IMarshal* pMarsh,
                        LPSTREAM pStm, REFIID riid, 
                        void ** ppvObj)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pMarsh));

    // Unmarshal side only.
    _ASSERTE(FALSE);
    return E_NOTIMPL;
}

HRESULT __stdcall Marshal_ReleaseMarshalData (IMarshal* pMarsh, LPSTREAM pStm)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pMarsh));

    // Unmarshal side only.
    _ASSERTE(FALSE);
    return E_NOTIMPL;
}

HRESULT __stdcall Marshal_DisconnectObject (IMarshal* pMarsh, ULONG dwReserved)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pMarsh));

    // Setup logical thread if we've not already done so.
    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    // Nothing we can (or need to) do here. The client is using a raw IP to
    // access this server, so the server shouldn't go away until the client
    // Release()'s it.

    return S_OK;
}

//------------------------------------------------------------------------------------------
//      IManagedObject methods for COM+ objects
//------------------------------------------------------------------------------------------                                                   
HRESULT __stdcall ManagedObject_GetObjectIdentity(IManagedObject *pManaged, 
                                                  BSTR* pBSTRGUID, DWORD* pAppDomainID,
                                                  void** pCCW)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    // NOTE: THIS METHOD CAN BE CALLED FROM ANY APP DOMAIN

    _ASSERTE(IsSimpleTearOff(pManaged));

    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;

    if (pBSTRGUID == NULL ||
        pAppDomainID == NULL || pCCW == NULL)
    {
        return E_POINTER;
    }

    *pCCW = 0;
    *pAppDomainID = 0;
    
    BSTR bstrProcGUID = GetProcessGUID();
    BSTR bstrRetGUID = ::SysAllocString((WCHAR *)bstrProcGUID);

    _ASSERTE(bstrRetGUID);

    *pBSTRGUID = bstrRetGUID;

    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP( pManaged ); 
    _ASSERTE(pThread->GetDomain() == pSimpleWrap->GetDomainSynchronized());

    ComCallWrapper* pComCallWrap = SimpleComCallWrapper::GetMainWrapper(pSimpleWrap);
    _ASSERTE(pComCallWrap);    
    *pCCW = (void*)pComCallWrap;

    AppDomain* pDomain = pThread->GetDomain();
    _ASSERTE(pDomain != NULL);

    *pAppDomainID = pDomain->GetId();
    
    return S_OK;
}


HRESULT __stdcall ManagedObject_GetSerializedBuffer(IManagedObject *pManaged,
                                                   BSTR* pBStr)
{
    _ASSERTE(IsSimpleTearOff(pManaged));

    HRESULT hr = E_FAIL;
    if (pBStr == NULL)
        return E_INVALIDARG;

    *pBStr = NULL;

    Thread* pThread = SetupThread();
    if (pThread == NULL)
        return E_OUTOFMEMORY;
    
    SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP( pManaged );
    ComCallWrapper *pComCallWrap = SimpleComCallWrapper::GetMainWrapper( pSimpleWrap );
    _ASSERTE(pComCallWrap != NULL);
     //@todo don't allow serialization of Configured objects through DCOM
    _ASSERTE(pThread->GetDomain() == pSimpleWrap->GetDomainSynchronized());
    
    BEGINCANNOTTHROWCOMPLUSEXCEPTION();        
    BEGIN_ENSURE_COOPERATIVE_GC();       
    COMPLUS_TRYEX(pThread)
    {
        if (InitializeRemoting())
        {
            hr = ConvertObjectToBSTR(pComCallWrap->GetObjectRef(), pBStr);  
        }
    }
    COMPLUS_CATCH
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH
    END_ENSURE_COOPERATIVE_GC();
    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}


//------------------------------------------------------------------------------------------
//      IConnectionPointContainer methods for COM+ objects
//------------------------------------------------------------------------------------------

// Enumerate all the connection points supported by the component.
HRESULT __stdcall ConnectionPointContainer_EnumConnectionPoints(IUnknown* pUnk, 
                                                                IEnumConnectionPoints **ppEnum)
{
    HRESULT hr = S_OK;

    if ( !ppEnum )
        return E_POINTER;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    COMPLUS_TRY
    {
        _ASSERTE(IsSimpleTearOff(pUnk));
        SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pUnk);
        pSimpleWrap->EnumConnectionPoints(ppEnum);
    }
    COMPLUS_CATCH
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}

// Find a specific connection point based on the IID of the event interface.
HRESULT __stdcall ConnectionPointContainer_FindConnectionPoint(IUnknown* pUnk, 
                                                               REFIID riid,
                                                               IConnectionPoint **ppCP)
{
    HRESULT hr = S_OK;

    if (!ppCP)
        return E_POINTER;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    COMPLUS_TRY
    {
        _ASSERTE(IsSimpleTearOff(pUnk));
        SimpleComCallWrapper *pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pUnk);
        if (!pSimpleWrap->FindConnectionPoint(riid, ppCP))
            hr = CONNECT_E_NOCONNECTION;
    }
    COMPLUS_CATCH
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}


//------------------------------------------------------------------------------------------
//      IObjectSafety methods for COM+ objects
//------------------------------------------------------------------------------------------

HRESULT __stdcall ObjectSafety_GetInterfaceSafetyOptions(IUnknown* pUnk,
                                                         REFIID riid,
                                                         DWORD *pdwSupportedOptions,
                                                         DWORD *pdwEnabledOptions)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pUnk));

    if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
        return E_POINTER;

    // Make sure the COM+ object implements the requested interface.
    IUnknown *pItf;
    HRESULT hr = pUnk->QueryInterface(riid, (void**)&pItf);
    LogInteropQI(pUnk, riid, hr, "QI to for riid in GetInterfaceSafetyOptions");
    if (FAILED(hr))
        return hr;
    ULONG cbRef = pItf->Release();
    LogInteropRelease(pItf, cbRef, "Release requested interface in GetInterfaceSafetyOptions");

    *pdwSupportedOptions = 
        (INTERFACESAFE_FOR_UNTRUSTED_DATA | INTERFACESAFE_FOR_UNTRUSTED_CALLER);
    *pdwEnabledOptions = 
        (INTERFACESAFE_FOR_UNTRUSTED_DATA | INTERFACESAFE_FOR_UNTRUSTED_CALLER);

    return S_OK;
}

HRESULT __stdcall ObjectSafety_SetInterfaceSafetyOptions(IUnknown* pUnk,
                                                         REFIID riid,
                                                         DWORD dwOptionSetMask,
                                                         DWORD dwEnabledOptions) 
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(IsSimpleTearOff(pUnk));

    // Make sure the COM+ object implements the requested interface.
    IUnknown *pItf;
    HRESULT hr = pUnk->QueryInterface(riid, (void**)&pItf);
    LogInteropQI(pUnk, riid, hr, "QI to for riid in SetInterfaceSafetyOptions");
    if (FAILED(hr))
        return hr;
    ULONG cbRef = pItf->Release();
    LogInteropRelease(pItf, cbRef, "Release requested interface in SetInterfaceSafetyOptions");

    if ((dwEnabledOptions &  
      ~(INTERFACESAFE_FOR_UNTRUSTED_DATA | 
        INTERFACESAFE_FOR_UNTRUSTED_CALLER))
        != 0)
    {
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stdinterfaces_internal.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _H_INTERNAL_STDINTERFACES
#define _H_INTERNAL_STDINTERFACES

// ---------------------------------------------------------------------------
// prototypes IUnknown methods
HRESULT __stdcall	Unknown_QueryInterface_Internal (
									IUnknown* pUnk, REFIID riid, void** ppv);

ULONG __stdcall		Unknown_AddRef_Internal(IUnknown* pUnk);

ULONG __stdcall		Unknown_Release_Internal(IUnknown* pUnk);

ULONG __stdcall		Unknown_AddRefInner_Internal(IUnknown* pUnk);

ULONG __stdcall		Unknown_ReleaseInner_Internal(IUnknown* pUnk);

// for std interfaces such as IProvideClassInfo
ULONG __stdcall		Unknown_AddRefSpecial_Internal(IUnknown* pUnk);

ULONG __stdcall		Unknown_ReleaseSpecial_Internal(IUnknown* pUnk);

// ---------------------------------------------------------------------------
//  Interface ISupportsErrorInfo

// %%Function: SupportsErroInfo_IntfSupportsErrorInfo,
// ---------------------------------------------------------------------------
HRESULT __stdcall 
SupportsErroInfo_IntfSupportsErrorInfo(IUnknown* pUnk, REFIID riid);

// ---------------------------------------------------------------------------
//  Interface IErrorInfo

// %%Function: ErrorInfo_GetDescription,   
HRESULT __stdcall 
ErrorInfo_GetDescription(IUnknown* pUnk, BSTR* pbstrDescription);
// %%Function: ErrorInfo_GetGUID,    
HRESULT __stdcall ErrorInfo_GetGUID(IUnknown* pUnk, GUID* pguid);

// %%Function: ErrorInfo_GetHelpContext, 
HRESULT _stdcall ErrorInfo_GetHelpContext(IUnknown* pUnk, DWORD* pdwHelpCtxt);

// %%Function: ErrorInfo_GetHelpFile,    
HRESULT __stdcall ErrorInfo_GetHelpFile(IUnknown* pUnk, BSTR* pbstrHelpFile);


// %%Function: ErrorInfo_GetSource,    
HRESULT __stdcall ErrorInfo_GetSource(IUnknown* pUnk, BSTR* pbstrSource);


//------------------------------------------------------------------------------------------
//      IDispatch methods for COM+ objects. These methods dispatch to the appropriate 
//		implementation based on the flags of the class that implements them.


// IDispatch::GetTypeInfoCount 
HRESULT __stdcall	Dispatch_GetTypeInfoCount (
									 IDispatch* pDisp,
									 unsigned int *pctinfo);


// IDispatch::GetTypeInfo
HRESULT __stdcall	Dispatch_GetTypeInfo (
									IDispatch* pDisp,
									unsigned int itinfo,
									LCID lcid,
									ITypeInfo **pptinfo);

// IDispatch::GetIDsofNames
HRESULT __stdcall	Dispatch_GetIDsOfNames (
									IDispatch* pDisp,
									REFIID riid,
									OLECHAR **rgszNames,
									unsigned int cNames,
									LCID lcid,
									DISPID *rgdispid);

// IDispatch::Invoke
HRESULT __stdcall	Dispatch_Invoke	(
									IDispatch* pDisp,
									DISPID dispidMember,
									REFIID riid,
									LCID lcid,
									unsigned short wFlags,
									DISPPARAMS *pdispparams,
									VARIANT *pvarResult,
									EXCEPINFO *pexcepinfo,
									unsigned int *puArgErr
									);


//------------------------------------------------------------------------------------------
//      IDispatch methods for COM+ objects that use our OleAut's implementation.


// IDispatch::GetIDsofNames
HRESULT __stdcall	OleAutDispatchImpl_GetIDsOfNames (
									IDispatch* pDisp,
									REFIID riid,
									OLECHAR **rgszNames,
									unsigned int cNames,
									LCID lcid,
									DISPID *rgdispid);

// IDispatch::Invoke
HRESULT __stdcall	OleAutDispatchImpl_Invoke	(
									IDispatch* pDisp,
									DISPID dispidMember,
									REFIID riid,
									LCID lcid,
									unsigned short wFlags,
									DISPPARAMS *pdispparams,
									VARIANT *pvarResult,
									EXCEPINFO *pexcepinfo,
									unsigned int *puArgErr
									);



//------------------------------------------------------------------------------------------
//      IDispatch methods for COM+ objects that use our internal implementation.


// IDispatch::GetIDsofNames
HRESULT __stdcall	InternalDispatchImpl_GetIDsOfNames (
									IDispatch* pDisp,
									REFIID riid,
									OLECHAR **rgszNames,
									unsigned int cNames,
									LCID lcid,
									DISPID *rgdispid);

// IDispatch::Invoke
HRESULT __stdcall	InternalDispatchImpl_Invoke	(
									IDispatch* pDisp,
									DISPID dispidMember,
									REFIID riid,
									LCID lcid,
									unsigned short wFlags,
									DISPPARAMS *pdispparams,
									VARIANT *pvarResult,
									EXCEPINFO *pexcepinfo,
									unsigned int *puArgErr
									);


//------------------------------------------------------------------------------------------
//      IDispatchEx methods for COM+ objects


// IDispatchEx::GetTypeInfoCount 
HRESULT __stdcall	DispatchEx_GetTypeInfoCount (
									 IDispatch* pDisp,
									 unsigned int *pctinfo);


// IDispatchEx::GetTypeInfo
HRESULT __stdcall	DispatchEx_GetTypeInfo (
									IDispatch* pDisp,
									unsigned int itinfo,
									LCID lcid,
									ITypeInfo **pptinfo);

// IDispatchEx::GetIDsofNames
HRESULT __stdcall	DispatchEx_GetIDsOfNames (
									IDispatchEx* pDisp,
									REFIID riid,
									OLECHAR **rgszNames,
									unsigned int cNames,
									LCID lcid,
									DISPID *rgdispid
									);

// IDispatchEx::Invoke
HRESULT __stdcall   DispatchEx_Invoke (
									IDispatchEx* pDisp,
									DISPID dispidMember,
									REFIID riid,
									LCID lcid,
									unsigned short wFlags,
									DISPPARAMS *pdispparams,
									VARIANT *pvarResult,
									EXCEPINFO *pexcepinfo,
									unsigned int *puArgErr
									);

// IDispatchEx::DeleteMemberByDispID
HRESULT __stdcall   DispatchEx_DeleteMemberByDispID (
									IDispatchEx* pDisp,
									DISPID id
									);

// IDispatchEx::DeleteMemberByName
HRESULT __stdcall   DispatchEx_DeleteMemberByName (
									IDispatchEx* pDisp,
									BSTR bstrName,
									DWORD grfdex
									);

// IDispatchEx::GetDispID
HRESULT __stdcall   DispatchEx_GetDispID (
									IDispatchEx* pDisp,
									BSTR bstrName,
									DWORD grfdex,
									DISPID *pid
									);

// IDispatchEx::GetMemberName
HRESULT __stdcall   DispatchEx_GetMemberName (
									IDispatchEx* pDisp,
									DISPID id,
									BSTR *pbstrName
									);

// IDispatchEx::GetMemberProperties
HRESULT __stdcall   DispatchEx_GetMemberProperties (
									IDispatchEx* pDisp,
									DISPID id,
									DWORD grfdexFetch,
									DWORD *pgrfdex
									);

// IDispatchEx::GetNameSpaceParent
HRESULT __stdcall   DispatchEx_GetNameSpaceParent (
									IDispatchEx* pDisp,
									IUnknown **ppunk
									);

// IDispatchEx::GetNextDispID
HRESULT __stdcall   DispatchEx_GetNextDispID (
									IDispatchEx* pDisp,
									DWORD grfdex,
									DISPID id,
									DISPID *pid
									);

// IDispatchEx::InvokeEx
HRESULT __stdcall   DispatchEx_InvokeEx	(
									IDispatchEx* pDisp,
									DISPID id,
									LCID lcid,
									WORD wFlags,
									DISPPARAMS *pdp,
									VARIANT *pVarRes, 
									EXCEPINFO *pei, 
									IServiceProvider *pspCaller 
									);


//------------------------------------------------------------------------------------------
//      IMarshal methods for COM+ objects

HRESULT __stdcall Marshal_GetUnmarshalClass (
							IMarshal* pMarsh,
							REFIID riid, void * pv, ULONG dwDestContext, 
							void * pvDestContext, ULONG mshlflags, 
							LPCLSID pclsid);

HRESULT __stdcall Marshal_GetMarshalSizeMax (
								IMarshal* pMarsh,
								REFIID riid, void * pv, ULONG dwDestContext, 
								void * pvDestContext, ULONG mshlflags, 
								ULONG * pSize);

HRESULT __stdcall Marshal_MarshalInterface (
						IMarshal* pMarsh,
						LPSTREAM pStm, REFIID riid, void * pv,
						ULONG dwDestContext, LPVOID pvDestContext,
						ULONG mshlflags);

HRESULT __stdcall Marshal_UnmarshalInterface (
						IMarshal* pMarsh,
						LPSTREAM pStm, REFIID riid, 
						void ** ppvObj);

HRESULT __stdcall Marshal_ReleaseMarshalData (IMarshal* pMarsh, LPSTREAM pStm);

HRESULT __stdcall Marshal_DisconnectObject (IMarshal* pMarsh, ULONG dwReserved);


//------------------------------------------------------------------------------------------
//      IManagedObject methods for COM+ objects

interface IManagedObject;


HRESULT __stdcall ManagedObject_RemoteDispatchAutoDone(IManagedObject *pManaged, BSTR bstr,
                                                   BSTR* pBStrRet);
                                                   
HRESULT __stdcall ManagedObject_RemoteDispatchNotAutoDone(IManagedObject *pManaged, BSTR bstr,
                                                   BSTR* pBStrRet);
                                                   
HRESULT __stdcall ManagedObject_GetObjectIdentity(IManagedObject *pManaged, 
											      BSTR* pBSTRGUID, DWORD* pAppDomainID,
                								  void** pCCW); 


HRESULT __stdcall ManagedObject_GetSerializedBuffer(IManagedObject *pManaged,
                                                   BSTR* pBStr);

//------------------------------------------------------------------------------------------
//      IConnectionPointContainer methods for COM+ objects

interface IEnumConnectionPoints;

HRESULT __stdcall ConnectionPointContainer_EnumConnectionPoints(IUnknown* pUnk, 
																IEnumConnectionPoints **ppEnum);

HRESULT __stdcall ConnectionPointContainer_FindConnectionPoint(IUnknown* pUnk, 
															   REFIID riid,
															   IConnectionPoint **ppCP);

//------------------------------------------------------------------------------------------
//      IObjectSafety methods for COM+ objects

interface IObjectSafety;

HRESULT __stdcall ObjectSafety_GetInterfaceSafetyOptions(IUnknown* pUnk,
                                                         REFIID riid,
                                                         DWORD *pdwSupportedOptions,
                                                         DWORD *pdwEnabledOptions);

HRESULT __stdcall ObjectSafety_SetInterfaceSafetyOptions(IUnknown* pUnk,
                                                         REFIID riid,
                                                         DWORD dwOptionSetMask,
                                                         DWORD dwEnabledOptions);
//-------------------------------------------------------------------------
// IProvideClassInfo methods
HRESULT __stdcall ClassInfo_GetClassInfo(IUnknown* pUnk, 
                         ITypeInfo** ppTI  //Address of output variable that receives the type info.
                        );



//------------------------------------------------------------------------------------------
//      Helper function for IConnectionPointContainer

MethodTable *FindTCEProviderMT( OBJECTREF ObjRef, REFGUID riid );

// helper for errorinfo
void FillExcepInfo (EXCEPINFO *pexcepinfo, HRESULT hr);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stdinterfaces_wrapper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------------
// stdinterfaces_wrapper.cpp
//
// Defines various standard com interfaces 
//  %%Created by: rajak
//---------------------------------------------------------------------------------

#include "common.h"

#include <ole2.h>
#include <guidfromname.h>
#include <olectl.h>
#include <objsafe.h>    // IID_IObjctSafe
#include "vars.hpp"
#include "object.h"
#include "excep.h"
#include "frames.h"
#include "vars.hpp"
#include "COMPlusWrapper.h"
#include "ComString.h"
#include "comcallwrapper.h"
#include "field.h"
#include "threads.h"
#include "interoputil.h"
#include "TLBExport.h"
#include "COMDelegate.h"
#include "olevariant.h"
#include "eeconfig.h"
#include "typehandle.h"
#include "PostError.h"
#include <CorError.h>
#include <mscoree.h>

#include "remoting.h"
#include "mtx.h"
#include "cgencpu.h"
#include "InteropConverter.h"
#include "COMInterfaceMarshaler.h"

#include "stdinterfaces.h"
#include "stdinterfaces_internal.h"


// IUnknown is part of IDispatch
// Common vtables for well-known COM interfaces
// shared by all COM+ callable wrappers.

// All Com+ created vtables have well known IUnknown methods, which is used to identify
// the type of the interface
// For e.g. all com+ created tear-offs have the same QI method in their IUnknown portion
//          Unknown_QueryInterface is the QI method for all the tear-offs created from COM+
//
//  Tearoff interfaces created for std. interfaces such as IProvideClassInfo, IErrorInfo etc.
//  have the AddRef & Release function point to Unknown_AddRefSpecial & Unknown_ReleaseSpecial
//
//  Inner unknown, or the original unknown for a wrapper has 
//  AddRef & Release point to a Unknown_AddRefInner & Unknown_ReleaseInner

// global IProvideClassInfo vtable

UINTPTR*     g_pIProvideClassInfo [] = {
                                (UINTPTR*)Unknown_QueryInterface,  // don't change this
                                (UINTPTR*)Unknown_AddRefSpecial,  // special addref for std. interface
                                (UINTPTR*)Unknown_ReleaseSpecial, // special release for std. interface        
                                (UINTPTR*)ClassInfo_GetClassInfo_Wrapper // GetClassInfo
                            };

// global inner Unknown vtable
UINTPTR*     g_pIUnknown [] = {
                                (UINTPTR*)Unknown_QueryInterface,
                                (UINTPTR*)Unknown_AddRefInner,      // special addref to distinguish inner unk
                                (UINTPTR*)Unknown_ReleaseInner,     //special release to distinguish inner unknown                          
                            };

// global IDispatch vtable
UINTPTR*     g_pIDispatch [] = {
                                (UINTPTR*)Unknown_QueryInterface,
                                (UINTPTR*)Unknown_AddRef,       
                                (UINTPTR*)Unknown_Release,
                                (UINTPTR*)Dispatch_GetTypeInfoCount_Wrapper,
                                (UINTPTR*)Dispatch_GetTypeInfo_Wrapper,
                                (UINTPTR*)Dispatch_GetIDsOfNames_Wrapper,
                                (UINTPTR*)Dispatch_Invoke_Wrapper
                            };

// global ISupportsErrorInfo vtable
UINTPTR*     g_pISupportsErrorInfo [] =  {
                                (UINTPTR*)Unknown_QueryInterface,
                                (UINTPTR*)Unknown_AddRefSpecial,
                                (UINTPTR*)Unknown_ReleaseSpecial,
                                (UINTPTR*)SupportsErroInfo_IntfSupportsErrorInfo_Wrapper
                            };

// global IErrorInfo vtable
UINTPTR*     g_pIErrorInfo [] =  {
                                (UINTPTR*)Unknown_QueryInterface,
                                (UINTPTR*)Unknown_AddRefSpecial,
                                (UINTPTR*)Unknown_ReleaseSpecial,
                                (UINTPTR*)ErrorInfo_GetGUID_Wrapper,
                                (UINTPTR*)ErrorInfo_GetSource_Wrapper,
                                (UINTPTR*)ErrorInfo_GetDescription_Wrapper,
                                (UINTPTR*)ErrorInfo_GetHelpFile_Wrapper,
                                (UINTPTR*)ErrorInfo_GetHelpContext_Wrapper
                            };

    
// global IMarshal vtable
UINTPTR*     g_pIMarshal [] =    {
                                (UINTPTR*)Unknown_QueryInterface,
                                (UINTPTR*)Unknown_AddRefSpecial,
                                (UINTPTR*)Unknown_ReleaseSpecial,
                                (UINTPTR*)Marshal_GetUnmarshalClass_Wrapper,
                                (UINTPTR*)Marshal_GetMarshalSizeMax_Wrapper,
                                (UINTPTR*)Marshal_MarshalInterface_Wrapper,
                                (UINTPTR*)Marshal_UnmarshalInterface_Wrapper,
                                (UINTPTR*)Marshal_ReleaseMarshalData_Wrapper,
                                (UINTPTR*)Marshal_DisconnectObject_Wrapper
                            };

// global IManagedObject vtable
UINTPTR*     g_pIManagedObject [] =  {
                                (UINTPTR*)Unknown_QueryInterface,
                                (UINTPTR*)Unknown_AddRefSpecial,
                                (UINTPTR*)Unknown_ReleaseSpecial,                                
								(UINTPTR*)ManagedObject_GetSerializedBuffer_Wrapper,                                	
                                (UINTPTR*)ManagedObject_GetObjectIdentity_Wrapper
                            };

            
// global IConnectionPointContainer vtable
UINTPTR*     g_pIConnectionPointContainer [] =  {
                                (UINTPTR*)Unknown_QueryInterface,
                                (UINTPTR*)Unknown_AddRefSpecial,
                                (UINTPTR*)Unknown_ReleaseSpecial,
                                (UINTPTR*)ConnectionPointContainer_EnumConnectionPoints_Wrapper,
                                (UINTPTR*)ConnectionPointContainer_FindConnectionPoint_Wrapper
                            };

// global IObjectSafety vtable
UINTPTR*     g_pIObjectSafety [] =  {
                                (UINTPTR*)Unknown_QueryInterface,
                                (UINTPTR*)Unknown_AddRefSpecial,
                                (UINTPTR*)Unknown_ReleaseSpecial,
                                (UINTPTR*)ObjectSafety_GetInterfaceSafetyOptions_Wrapper,
                                (UINTPTR*)ObjectSafety_SetInterfaceSafetyOptions_Wrapper
                            };


// global IDispatchEx vtable
UINTPTR*     g_pIDispatchEx [] = {
                                (UINTPTR*)Unknown_QueryInterface,
                                (UINTPTR*)Unknown_AddRefSpecial,
                                (UINTPTR*)Unknown_ReleaseSpecial,
                                (UINTPTR*)DispatchEx_GetTypeInfoCount_Wrapper,
                                (UINTPTR*)DispatchEx_GetTypeInfo_Wrapper,
                                (UINTPTR*)DispatchEx_GetIDsOfNames_Wrapper,
                                (UINTPTR*)DispatchEx_Invoke_Wrapper,
                                (UINTPTR*)DispatchEx_GetDispID_Wrapper,
                                (UINTPTR*)DispatchEx_InvokeEx_Wrapper,
                                (UINTPTR*)DispatchEx_DeleteMemberByName_Wrapper,
                                (UINTPTR*)DispatchEx_DeleteMemberByDispID_Wrapper,
                                (UINTPTR*)DispatchEx_GetMemberProperties_Wrapper,
                                (UINTPTR*)DispatchEx_GetMemberName_Wrapper,
                                (UINTPTR*)DispatchEx_GetNextDispID_Wrapper,
                                (UINTPTR*)DispatchEx_GetNameSpaceParent_Wrapper
                            };          

// Generic helper to check if AppDomain matches and perform a DoCallBack otherwise

BOOL IsCurrentDomainValid(ComCallWrapper* pWrap)
{
    // If we are finalizing all alive objects, or after this stage, we do not allow 
    // a thread to enter EE.
    if ((g_fEEShutDown & ShutDown_Finalize2) || g_fForbidEnterEE) {
        return FALSE;
    }
    Thread* pThread = GetThread();
    if(pThread != NULL)
    {
        AppDomain *pTgtDomain = pWrap->GetDomainSynchronized();
        return (pTgtDomain && ! pWrap->NeedToSwitchDomains(pThread, FALSE));		
    }
    else
    {
        // force the call into the AppDomain DoCallBack path
        return FALSE;
    }
}

struct AppDomainSwitchToPreemptiveHelperArgs
{
    Context::ADCallBackFcnType pRealCallback;
    void* pRealArgs;
};

VOID __stdcall AppDomainSwitchToPreemptiveHelper(LPVOID pv)
{
    AppDomainSwitchToPreemptiveHelperArgs* pArgs = (AppDomainSwitchToPreemptiveHelperArgs*)pv;
    GetThread()->EnablePreemptiveGC();
    pArgs->pRealCallback(pArgs->pRealArgs);
    GetThread()->DisablePreemptiveGC();
}

VOID AppDomainDoCallBack(ComCallWrapper* pWrap, LPVOID pTarget, LPVOID pArgs, HRESULT* phr)
{
    _ASSERTE(phr && pTarget && pArgs && pWrap);
    
    // If we are finalizing all alive objects, or after this stage, we do not allow 
    // a thread to enter EE.
    if ((g_fEEShutDown & ShutDown_Finalize2) || g_fForbidEnterEE) {
        *phr = E_FAIL;
        return;
    }
    Thread* pThread = SetupThread();
    if (pThread != NULL)
    {
        BEGINCANNOTTHROWCOMPLUSEXCEPTION();
        BEGIN_ENSURE_COOPERATIVE_GC();    
        
        COMPLUS_TRYEX(pThread)
        {
            AppDomain* pDomain = pWrap->GetDomainSynchronized();
            if (! pDomain)
                *phr = COR_E_APPDOMAINUNLOADED;
            else {
                Context *pContext = pWrap->GetObjectContext(pThread);
                if(pThread->GetDomain() != pContext->GetDomain())
                {
                    // call ourselves again through DoCallBack with a domain transition
                    // We need to switch back to preemptive GC mode before we call the 
                    // real target method.
                    AppDomainSwitchToPreemptiveHelperArgs args = {(Context::ADCallBackFcnType)pTarget, pArgs};
                    pThread->DoADCallBack(pContext, AppDomainSwitchToPreemptiveHelper, &args);
                }
                else
                {
                    // make the call directly
                    ((Context::ADCallBackFcnType)pTarget)(pArgs);
                }
            }
        }
    COMPLUS_CATCH
        {
            *phr = SetupErrorInfo(GETTHROWABLE());
        }
        COMPLUS_END_CATCH

        END_ENSURE_COOPERATIVE_GC();
        ENDCANNOTTHROWCOMPLUSEXCEPTION();
    }
    else
    {
        _ASSERTE(!" Out of memory is bad");
        *phr = E_OUTOFMEMORY;
    }
}

// this can only map well know interfaces,
// if you set up a specialized tear-off for this interface
// don't use this method (like CObjectControl for IObjectControl etc.)
ComCallWrapper* MapIUnknownToWrapper(IUnknown* pUnk)
{
    ComCallWrapper* pWrap = NULL;
    if((*(size_t **)pUnk)[0] == (size_t)Unknown_QueryInterface)
    {
        if (IsSimpleTearOff(pUnk) || IsInnerUnknown(pUnk))
        {
            SimpleComCallWrapper* pSimpleWrap = SimpleComCallWrapper::GetWrapperFromIP(pUnk);
            pWrap = SimpleComCallWrapper::GetMainWrapper(pSimpleWrap);            
        }
        else
        {   // it must be one of our main wrappers
            pWrap = ComCallWrapper::GetWrapperFromIP(pUnk);          
        }
    }

    return pWrap;
}

//-------------------------------------------------------------------------
// IUnknown methods

struct QIArgs
{
	IUnknown* pUnk;
	const IID* riid;
	void**	ppv;
	HRESULT* hr;
};

VOID __stdcall Unknown_QueryInterface_CallBack(QIArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = Unknown_QueryInterface_Internal(pArgs->pUnk, *pArgs->riid, pArgs->ppv);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, Unknown_QueryInterface_CallBack, pArgs, pArgs->hr);;
	}
}

HRESULT __stdcall	Unknown_QueryInterface(
									IUnknown* pUnk, REFIID riid, void** ppv)
{
	HRESULT hr;
	QIArgs args = {pUnk, &riid, ppv, &hr};
	Unknown_QueryInterface_CallBack(&args);		
	return hr;	
}

struct AddRefReleaseArgs
{
	IUnknown* pUnk;
	ULONG* pLong;
	HRESULT* hr;
};

VOID __stdcall Unknown_AddRef_CallBack(AddRefReleaseArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->pLong) = Unknown_AddRef_Internal(pArgs->pUnk);
	}
	else
	{		
		*(pArgs->pLong) = 0xbadf00d;
		AppDomainDoCallBack(pWrap, Unknown_AddRef_CallBack, pArgs, pArgs->hr);;
	}
}


ULONG __stdcall		Unknown_AddRef(IUnknown* pUnk)
{
	/*HRESULT hr;
	ULONG pLong =0;
	AddRefReleaseArgs args = {pUnk, &pLong, &hr};
	Unknown_AddRef_CallBack(&args);		
	return pLong;	*/

	// allow addrefs to go through, coz we are allowing 
	// all releases to go through, otherwise we would
	// have a mismatch of ref-counts
	return Unknown_AddRef_Internal(pUnk);
}

ULONG __stdcall		Unknown_Release(IUnknown* pUnk)
{
    // don't switch ADs on a release - need to allow a release after the AD has gone away
    return Unknown_Release_Internal(pUnk);	
}


VOID __stdcall Unknown_AddRef_Inner_CallBack(AddRefReleaseArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->pLong) = Unknown_AddRefInner_Internal(pArgs->pUnk);
	}
	else
	{		
		*(pArgs->pLong) = 0xbadf00d;
		AppDomainDoCallBack(pWrap, Unknown_AddRef_Inner_CallBack, pArgs, pArgs->hr);;
	}
}

ULONG __stdcall		Unknown_AddRefInner(IUnknown* pUnk)
{
/*	HRESULT hr;
	ULONG pLong =0;
	AddRefReleaseArgs args = {pUnk, &pLong, &hr};
	Unknown_AddRef_Inner_CallBack(&args);		
	return pLong;	*/
	// allow addrefs to go through, coz we are allowing 
	// all releases to go through, otherwise we would
	// have a mismatch of ref-counts

	return Unknown_AddRefInner_Internal(pUnk);
}


ULONG __stdcall		Unknown_ReleaseInner(IUnknown* pUnk)
{
    // don't switch ADs on a release - need to allow a release after the AD has gone away
	return Unknown_ReleaseInner_Internal(pUnk);		
}

// for std interfaces such as IProvideClassInfo
VOID __stdcall Unknown_AddRef_Special_CallBack(AddRefReleaseArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->pLong) = Unknown_AddRefSpecial_Internal(pArgs->pUnk);
	}
	else
	{		
		*(pArgs->pLong) = 0xbadf00d;
		AppDomainDoCallBack(pWrap, Unknown_AddRef_Special_CallBack, pArgs, pArgs->hr);;
	}
}


ULONG __stdcall		Unknown_AddRefSpecial(IUnknown* pUnk)
{
	HRESULT hr;
	ULONG pLong =0;
	AddRefReleaseArgs args = {pUnk, &pLong, &hr};
	Unknown_AddRef_Special_CallBack(&args);		
	return pLong;	
}


VOID __stdcall Unknown_Release_Special_CallBack(AddRefReleaseArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->pLong) = Unknown_ReleaseSpecial_Internal(pArgs->pUnk);
	}
	else
	{		
		*(pArgs->pLong) = 0xbadf00d;
		AppDomainDoCallBack(pWrap, Unknown_Release_Special_CallBack, pArgs, pArgs->hr);;
	}
}

ULONG __stdcall		Unknown_ReleaseSpecial(IUnknown* pUnk)
{
	HRESULT hr;
	ULONG pLong =0;
	AddRefReleaseArgs args = {pUnk, &pLong, &hr};
	Unknown_Release_Special_CallBack(&args);		
	return pLong;	
}

//-------------------------------------------------------------------------
// IProvideClassInfo methods

struct GetClassInfoArgs
{
	IUnknown* pUnk;
	ITypeInfo** ppTI; //Address of output variable that receives the type info.
	HRESULT* hr;
};

VOID __stdcall ClassInfo_GetClassInfo_CallBack(GetClassInfoArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = ClassInfo_GetClassInfo(pArgs->pUnk, pArgs->ppTI);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, ClassInfo_GetClassInfo_CallBack, pArgs, pArgs->hr);;
	}
}

HRESULT __stdcall ClassInfo_GetClassInfo_Wrapper(
						IUnknown* pUnk, 
                        ITypeInfo** ppTI  //Address of output variable that receives the type info.
                        )
{
	HRESULT hr;
	GetClassInfoArgs args = {pUnk, ppTI, &hr};
	ClassInfo_GetClassInfo_CallBack(&args);		
	return hr;	
}


// ---------------------------------------------------------------------------
//  Interface ISupportsErrorInfo

// ---------------------------------------------------------------------------
// %%Function: SupportsErroInfo_IntfSupportsErrorInfo,
struct IntfSupportsErrorInfoArgs
{
	IUnknown* pUnk;
	const IID* riid;
	HRESULT* hr;
};

VOID __stdcall SupportsErroInfo_IntfSupportsErrorInfo_CallBack(IntfSupportsErrorInfoArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = SupportsErroInfo_IntfSupportsErrorInfo(pArgs->pUnk, *pArgs->riid);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, SupportsErroInfo_IntfSupportsErrorInfo_CallBack, pArgs, pArgs->hr);;
	}
}


HRESULT __stdcall SupportsErroInfo_IntfSupportsErrorInfo_Wrapper(IUnknown* pUnk, REFIID riid)
{
	HRESULT hr;
	IntfSupportsErrorInfoArgs args = {pUnk, &riid, &hr};
	SupportsErroInfo_IntfSupportsErrorInfo_CallBack(&args);		
	return hr;
}

// ---------------------------------------------------------------------------
//  Interface IErrorInfo


// Interface IErrorInfo_CallBacks

// %%Function: ErrorInfo_GetDescription_CallBack,   
struct GetDescriptionArgs
{
	IUnknown* pUnk;
	BSTR*	pbstDescription;
	HRESULT* hr;
};

VOID __stdcall ErrorInfo_GetDescription_CallBack(GetDescriptionArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = ErrorInfo_GetDescription(pArgs->pUnk, pArgs->pbstDescription);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, ErrorInfo_GetDescription_CallBack, pArgs, pArgs->hr);;
	}
}

// %%Function: ErrorInfo_GetDescription,   
HRESULT __stdcall ErrorInfo_GetDescription_Wrapper(IUnknown* pUnk, BSTR* pbstrDescription)
{
	HRESULT hr;
	GetDescriptionArgs args = {pUnk, pbstrDescription, &hr};
	ErrorInfo_GetDescription_CallBack(&args);		
	return hr;
}


// %%Function: ErrorInfo_GetGUID_CallBack,    
struct GetGUIDArgs
{
	IUnknown* pUnk;
	GUID* pguid;
	HRESULT* hr;
};

VOID __stdcall ErrorInfo_GetGUID_CallBack(GetGUIDArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = ErrorInfo_GetGUID(pArgs->pUnk, pArgs->pguid);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, ErrorInfo_GetGUID_CallBack, pArgs, pArgs->hr);
	}
}

// %%Function: ErrorInfo_GetGUID,    
HRESULT __stdcall ErrorInfo_GetGUID_Wrapper(IUnknown* pUnk, GUID* pguid)
{
	HRESULT hr;
	GetGUIDArgs args = {pUnk, pguid, &hr};
	ErrorInfo_GetGUID_CallBack(&args);		
	return hr;
}


// %%Function: ErrorInfo_GetHelpContext_CallBack, 
struct GetHelpContextArgs
{
	IUnknown* pUnk;
	DWORD* pdwHelpCtxt;
	HRESULT* hr;
};

VOID _stdcall ErrorInfo_GetHelpContext_CallBack(GetHelpContextArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = ErrorInfo_GetHelpContext(pArgs->pUnk, pArgs->pdwHelpCtxt);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, ErrorInfo_GetHelpContext_CallBack, pArgs, pArgs->hr);
	}
}

// %%Function: ErrorInfo_GetHelpContext, 
HRESULT _stdcall ErrorInfo_GetHelpContext_Wrapper(IUnknown* pUnk, DWORD* pdwHelpCtxt)
{
	HRESULT hr;
	GetHelpContextArgs args = {pUnk, pdwHelpCtxt, &hr};
	ErrorInfo_GetHelpContext_CallBack(&args);		
	return hr;
}

// %%Function: ErrorInfo_GetHelpFile_CallBack,    
struct GetHelpFileArgs
{
	IUnknown* pUnk;
	BSTR* pbstrHelpFile;
	HRESULT* hr;
};

VOID __stdcall ErrorInfo_GetHelpFile_CallBack(GetHelpFileArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = ErrorInfo_GetHelpFile(pArgs->pUnk, pArgs->pbstrHelpFile);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, ErrorInfo_GetHelpFile_CallBack, pArgs, pArgs->hr);
	}
}

// %%Function: ErrorInfo_GetHelpFile,    
HRESULT __stdcall ErrorInfo_GetHelpFile_Wrapper(IUnknown* pUnk, BSTR* pbstrHelpFile)
{
	HRESULT hr;
	GetHelpFileArgs args = {pUnk, pbstrHelpFile, &hr};
	ErrorInfo_GetHelpFile_CallBack(&args);		
	return hr;
}

// %%Function: ErrorInfo_GetSource_CallBack,    
struct GetSourceArgs
{
	IUnknown* pUnk;
	BSTR* pbstrSource;
	HRESULT* hr;
};
VOID __stdcall ErrorInfo_GetSource_CallBack(GetSourceArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = ErrorInfo_GetSource(pArgs->pUnk, pArgs->pbstrSource);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, ErrorInfo_GetSource_CallBack, pArgs, pArgs->hr);
	}
}

// %%Function: ErrorInfo_GetSource,    
HRESULT __stdcall ErrorInfo_GetSource_Wrapper(IUnknown* pUnk, BSTR* pbstrSource)
{
	HRESULT hr;
	GetSourceArgs args = {pUnk, pbstrSource, &hr};
	ErrorInfo_GetSource_CallBack(&args);		
	return hr;
}


//------------------------------------------------------------------------------------------
//      IDispatch methods for COM+ objects. These methods dispatch to the appropriate 
//		implementation based on the flags of the class that implements them.


// %%Function: IDispatch::GetTypeInfoCount 

struct GetTypeInfoCountArgs
{
	IDispatch* pUnk;
	unsigned int *pctinfo;
	HRESULT* hr;
};
VOID __stdcall	Dispatch_GetTypeInfoCount_CallBack (GetTypeInfoCountArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = Dispatch_GetTypeInfoCount(pArgs->pUnk, pArgs->pctinfo);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, Dispatch_GetTypeInfoCount_CallBack, pArgs, pArgs->hr);
	}
}

//  %%Function: IDispatch::GetTypeInfoCount 

HRESULT __stdcall	Dispatch_GetTypeInfoCount_Wrapper (
									 IDispatch* pDisp,
									 unsigned int *pctinfo)
{
	HRESULT hr;
	GetTypeInfoCountArgs args = {pDisp, pctinfo, &hr};
	Dispatch_GetTypeInfoCount_CallBack(&args);		
	return hr;
}									 


//  %%Function: IDispatch::GetTypeInfo
struct GetTypeInfoArgs
{
	IDispatch* pUnk;
	unsigned int itinfo;
	LCID lcid;
	ITypeInfo **pptinfo;
	HRESULT* hr;
};
VOID __stdcall	Dispatch_GetTypeInfo_CallBack (GetTypeInfoArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = Dispatch_GetTypeInfo(pArgs->pUnk, pArgs->itinfo, pArgs->lcid, pArgs->pptinfo);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, Dispatch_GetTypeInfo_CallBack, pArgs, pArgs->hr);
	}
}


//  %%Function: IDispatch::GetTypeInfo
HRESULT __stdcall	Dispatch_GetTypeInfo_Wrapper (
									IDispatch* pDisp,
									unsigned int itinfo,
									LCID lcid,
									ITypeInfo **pptinfo)
{
	HRESULT hr;
	GetTypeInfoArgs args = {pDisp, itinfo, lcid, pptinfo, &hr};
	Dispatch_GetTypeInfo_CallBack(&args);		
	return hr;
}									 

//  %%Function: IDispatch::GetIDsofNames
struct GetIDsOfNamesArgs
{
	IDispatch* pUnk;
	const IID* riid;
	OLECHAR **rgszNames;
	unsigned int cNames;
	LCID lcid;
	DISPID *rgdispid;
	HRESULT* hr;
};

VOID __stdcall	Dispatch_GetIDsOfNames_CallBack (GetIDsOfNamesArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = Dispatch_GetIDsOfNames(pArgs->pUnk, *pArgs->riid, pArgs->rgszNames, 
									pArgs->cNames, pArgs->lcid, pArgs->rgdispid);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, Dispatch_GetIDsOfNames_CallBack, pArgs, pArgs->hr);
	}
}

//  %%Function: IDispatch::GetIDsofNames
HRESULT __stdcall	Dispatch_GetIDsOfNames_Wrapper (
									IDispatch* pDisp,
									REFIID riid,
									OLECHAR **rgszNames,
									unsigned int cNames,
									LCID lcid,
									DISPID *rgdispid)
{
	HRESULT hr;
	GetIDsOfNamesArgs args = {pDisp, &riid, rgszNames, cNames, lcid, rgdispid, &hr};
	Dispatch_GetIDsOfNames_CallBack(&args);		
	return hr;
}	

//  %%Function: IDispatch::Invoke
struct InvokeArgs
{
	IDispatch* pUnk;
	DISPID dispidMember;
	const IID* riid;
	LCID lcid;
	unsigned short wFlags;
	DISPPARAMS *pdispparams;
	VARIANT *pvarResult;
	EXCEPINFO *pexcepinfo;
	unsigned int *puArgErr;
	HRESULT* hr;
};
VOID __stdcall	Dispatch_Invoke_CallBack(InvokeArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = Dispatch_Invoke(pArgs->pUnk, pArgs->dispidMember, *pArgs->riid, 
									pArgs->lcid, pArgs->wFlags, pArgs->pdispparams, pArgs->pvarResult,
									pArgs->pexcepinfo, pArgs->puArgErr);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, Dispatch_Invoke_CallBack, pArgs, pArgs->hr);
	}
}

//  %%Function: IDispatch::Invoke
HRESULT __stdcall	Dispatch_Invoke_Wrapper	(
									IDispatch* pDisp,
									DISPID dispidMember,
									REFIID riid,
									LCID lcid,
									unsigned short wFlags,
									DISPPARAMS *pdispparams,
									VARIANT *pvarResult,
									EXCEPINFO *pexcepinfo,
									unsigned int *puArgErr
									)
{
	HRESULT hr;
	InvokeArgs args = {pDisp, dispidMember, &riid, lcid, wFlags, pdispparams, 
								pvarResult, pexcepinfo, puArgErr, &hr};
	Dispatch_Invoke_CallBack(&args);		
	return hr;
}

//------------------------------------------------------------------------------------------
//      IDispatchEx methods for COM+ objects



// %%Function: IDispatchEx::GetTypeInfoCount 

struct GetTypeInfoCountExArgs
{
	IDispatchEx* pUnk;
	unsigned int *pctinfo;
	HRESULT* hr;
};

VOID __stdcall	DispatchEx_GetTypeInfoCount_CallBack (GetTypeInfoCountExArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = DispatchEx_GetTypeInfoCount(pArgs->pUnk, pArgs->pctinfo);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, DispatchEx_GetTypeInfoCount_CallBack, pArgs, pArgs->hr);
	}
}

//  %%Function: IDispatchEx::GetTypeInfoCount 

HRESULT __stdcall	DispatchEx_GetTypeInfoCount_Wrapper (
									 IDispatchEx* pDisp,
									 unsigned int *pctinfo)
{
	HRESULT hr;
	GetTypeInfoCountExArgs args = {pDisp, pctinfo, &hr};
	DispatchEx_GetTypeInfoCount_CallBack(&args);		
	return hr;
}									 


//  %%Function: IDispatchEx::GetTypeInfo
struct GetTypeInfoExArgs
{
	IDispatch* pUnk;
	unsigned int itinfo;
	LCID lcid;
	ITypeInfo **pptinfo;
	HRESULT* hr;
};

VOID __stdcall	DispatchEx_GetTypeInfo_CallBack (GetTypeInfoExArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = DispatchEx_GetTypeInfo(pArgs->pUnk, pArgs->itinfo, pArgs->lcid, pArgs->pptinfo);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, DispatchEx_GetTypeInfo_CallBack, pArgs, pArgs->hr);
	}
}


//  %%Function: IDispatchEx::GetTypeInfo
HRESULT __stdcall	DispatchEx_GetTypeInfo_Wrapper (
									IDispatchEx* pDisp,
									unsigned int itinfo,
									LCID lcid,
									ITypeInfo **pptinfo)
{
	HRESULT hr;
	GetTypeInfoExArgs args = {pDisp, itinfo, lcid, pptinfo, &hr};
	DispatchEx_GetTypeInfo_CallBack(&args);		
	return hr;
}									 

//  %%Function: IDispatchEx::GetIDsofNames
struct GetIDsOfNamesExArgs
{
	IDispatchEx* pUnk;
	const IID* riid;
	OLECHAR **rgszNames;
	unsigned int cNames;
	LCID lcid;
	DISPID *rgdispid;
	HRESULT* hr;
};

VOID __stdcall	DispatchEx_GetIDsOfNames_CallBack (GetIDsOfNamesExArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = DispatchEx_GetIDsOfNames(pArgs->pUnk, *pArgs->riid, pArgs->rgszNames, 
									pArgs->cNames, pArgs->lcid, pArgs->rgdispid);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, DispatchEx_GetIDsOfNames_CallBack, pArgs, pArgs->hr);
	}
}

//  %%Function: IDispatchEx::GetIDsofNames
HRESULT __stdcall	DispatchEx_GetIDsOfNames_Wrapper (
									IDispatchEx* pDisp,
									REFIID riid,
									OLECHAR **rgszNames,
									unsigned int cNames,
									LCID lcid,
									DISPID *rgdispid)
{
	HRESULT hr;
	GetIDsOfNamesExArgs args = {pDisp, &riid, rgszNames, cNames, lcid, rgdispid, &hr};
	DispatchEx_GetIDsOfNames_CallBack(&args);		
	return hr;
}	

//  %%Function: IDispatchEx::Invoke
struct DispExInvokeArgs
{
	IDispatchEx* pUnk;
	DISPID dispidMember;
	const IID* riid;
	LCID lcid;
	unsigned short wFlags;
	DISPPARAMS *pdispparams;
	VARIANT *pvarResult;
	EXCEPINFO *pexcepinfo;
	unsigned int *puArgErr;
	HRESULT* hr;
};
VOID __stdcall	DispatchEx_Invoke_CallBack(DispExInvokeArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = DispatchEx_Invoke(pArgs->pUnk, pArgs->dispidMember, *pArgs->riid, 
									pArgs->lcid, pArgs->wFlags, pArgs->pdispparams, pArgs->pvarResult,
									pArgs->pexcepinfo, pArgs->puArgErr);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, DispatchEx_Invoke_CallBack, pArgs, pArgs->hr);
	}
}

//  %%Function: IDispatchEx::Invoke
HRESULT __stdcall	DispatchEx_Invoke_Wrapper	(
									IDispatchEx* pDisp,
									DISPID dispidMember,
									REFIID riid,
									LCID lcid,
									unsigned short wFlags,
									DISPPARAMS *pdispparams,
									VARIANT *pvarResult,
									EXCEPINFO *pexcepinfo,
									unsigned int *puArgErr
									)
{
	HRESULT hr;
	DispExInvokeArgs args = {pDisp, dispidMember, &riid, lcid, wFlags, pdispparams, 
								pvarResult, pexcepinfo, puArgErr, &hr};
	DispatchEx_Invoke_CallBack(&args);		
	return hr;
}


// IDispatchEx::DeleteMemberByDispID
struct DeleteMemberByDispIDArgs
{
	IDispatchEx* pDisp;
	DISPID id;
	HRESULT* hr;
};
VOID __stdcall   DispatchEx_DeleteMemberByDispID_CallBack  (DeleteMemberByDispIDArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pDisp);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = DispatchEx_DeleteMemberByDispID(pArgs->pDisp, pArgs->id);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, DispatchEx_DeleteMemberByDispID_CallBack, pArgs, pArgs->hr);
	}
}

//
// IDispatchEx::DeleteMemberByDispID
HRESULT __stdcall   DispatchEx_DeleteMemberByDispID_Wrapper (
									IDispatchEx* pDisp,
									DISPID id
									)
{
	HRESULT hr;
	DeleteMemberByDispIDArgs args = {pDisp, id, &hr};
	DispatchEx_DeleteMemberByDispID_CallBack(&args);		
	return hr;
}

// IDispatchEx::DeleteMemberByName
struct DeleteMemberByNameArgs
{
	IDispatchEx* pDisp;
	BSTR bstrName;
	DWORD grfdex;
	HRESULT* hr;
};

VOID __stdcall   DispatchEx_DeleteMemberByName_CallBack  (DeleteMemberByNameArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pDisp);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = DispatchEx_DeleteMemberByName(pArgs->pDisp, pArgs->bstrName, pArgs->grfdex);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, DispatchEx_DeleteMemberByName_CallBack, pArgs, pArgs->hr);
	}
}


// IDispatchEx::DeleteMemberByName
HRESULT __stdcall   DispatchEx_DeleteMemberByName_Wrapper (
									IDispatchEx* pDisp,
									BSTR bstrName,
									DWORD grfdex
									)
{
	HRESULT hr;
	DeleteMemberByNameArgs args = {pDisp, bstrName, grfdex, &hr};
	DispatchEx_DeleteMemberByName_CallBack(&args);		
	return hr;
}
									
// IDispatchEx::GetMemberName
struct GetMemberNameArgs
{
	IDispatchEx* pDisp;
	DISPID id;
	BSTR *pbstrName;
	HRESULT* hr;	
};
VOID __stdcall   DispatchEx_GetMemberName_CallBack  (GetMemberNameArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pDisp);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = DispatchEx_GetMemberName(pArgs->pDisp, pArgs->id, pArgs->pbstrName);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, DispatchEx_GetMemberName_CallBack, pArgs, pArgs->hr);
	}
}
// IDispatchEx::GetMemberName
HRESULT __stdcall   DispatchEx_GetMemberName_Wrapper (
									IDispatchEx* pDisp,
									DISPID id,
									BSTR *pbstrName
									)
{
	HRESULT hr;
	GetMemberNameArgs args = {pDisp, id, pbstrName, &hr};
	DispatchEx_GetMemberName_CallBack(&args);		
	return hr;
}
							

// IDispatchEx::GetDispID
struct GetDispIDArgs
{
	IDispatchEx* pDisp;
	BSTR bstrName;
	DWORD grfdex;
	DISPID *pid;
	HRESULT* hr;	
};
VOID __stdcall   DispatchEx_GetDispID_CallBack  (GetDispIDArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pDisp);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = DispatchEx_GetDispID(pArgs->pDisp, pArgs->bstrName, pArgs->grfdex, pArgs->pid);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, DispatchEx_GetDispID_CallBack, pArgs, pArgs->hr);
	}
}

// IDispatchEx::GetDispID
HRESULT __stdcall   DispatchEx_GetDispID_Wrapper (
									IDispatchEx* pDisp,
									BSTR bstrName,
									DWORD grfdex,
									DISPID *pid
									)
{
	HRESULT hr;
	GetDispIDArgs args = {pDisp, bstrName, grfdex, pid, &hr};
	DispatchEx_GetDispID_CallBack(&args);		
	return hr;
}


// IDispatchEx::GetMemberProperties
struct GetMemberPropertiesArgs
{
	IDispatchEx* pDisp;
	DISPID id;
	DWORD grfdexFetch;
	DWORD *pgrfdex;
	HRESULT* hr;
};
VOID __stdcall   DispatchEx_GetMemberProperties_CallBack  (GetMemberPropertiesArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pDisp);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = DispatchEx_GetMemberProperties(pArgs->pDisp, pArgs->id, pArgs->grfdexFetch, 
									pArgs->pgrfdex);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, DispatchEx_GetMemberProperties_CallBack, pArgs, pArgs->hr);
	}
}

// IDispatchEx::GetMemberProperties
HRESULT __stdcall   DispatchEx_GetMemberProperties_Wrapper (
									IDispatchEx* pDisp,
									DISPID id,
									DWORD grfdexFetch,
									DWORD *pgrfdex
									)
{
	HRESULT hr;
	GetMemberPropertiesArgs args = {pDisp, id, grfdexFetch, pgrfdex, &hr};
	DispatchEx_GetMemberProperties_CallBack(&args);		
	return hr;
}

// IDispatchEx::GetNameSpaceParent
struct GetNameSpaceParentArgs
{
	IDispatchEx* pDisp;
	IUnknown **ppunk;
	HRESULT* hr;
};
VOID __stdcall   DispatchEx_GetNameSpaceParent_CallBack  (GetNameSpaceParentArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pDisp);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = DispatchEx_GetNameSpaceParent(pArgs->pDisp, pArgs->ppunk);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, DispatchEx_GetNameSpaceParent_CallBack, pArgs, pArgs->hr);
	}
}



// IDispatchEx::GetNameSpaceParent
HRESULT __stdcall   DispatchEx_GetNameSpaceParent_Wrapper (
									IDispatchEx* pDisp,
									IUnknown **ppunk
									)
{
	HRESULT hr;
	GetNameSpaceParentArgs args = {pDisp, ppunk, &hr};
	DispatchEx_GetNameSpaceParent_CallBack(&args);		
	return hr;
}

// IDispatchEx::GetNextDispID
struct GetNextDispIDArgs
{
	IDispatchEx* pDisp;
	DWORD grfdex;
	DISPID id;
	DISPID *pid;
	HRESULT* hr;
};
VOID __stdcall   DispatchEx_GetNextDispID_CallBack  (GetNextDispIDArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pDisp);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = DispatchEx_GetNextDispID(pArgs->pDisp, pArgs->grfdex, pArgs->id, pArgs->pid);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, DispatchEx_GetNextDispID_CallBack, pArgs, pArgs->hr);
	}
}

// IDispatchEx::GetNextDispID
HRESULT __stdcall   DispatchEx_GetNextDispID_Wrapper (
									IDispatchEx* pDisp,
									DWORD grfdex,
									DISPID id,
									DISPID *pid
									)
{
	HRESULT hr;
	GetNextDispIDArgs args = {pDisp, grfdex, id, pid, &hr};
	DispatchEx_GetNextDispID_CallBack(&args);		
	return hr;
}

// IDispatchEx::InvokeEx
struct DispExInvokeExArgs
{
	IDispatchEx* pDisp;
	DISPID id;
	LCID lcid;
	WORD wFlags;
	DISPPARAMS *pdp;
	VARIANT *pVarRes; 
	EXCEPINFO *pei;
	IServiceProvider *pspCaller;
	HRESULT* hr;
};

VOID __stdcall   DispatchEx_InvokeEx_CallBack(DispExInvokeExArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pDisp);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = DispatchEx_InvokeEx(pArgs->pDisp, pArgs->id,  
									pArgs->lcid, pArgs->wFlags, pArgs->pdp, pArgs->pVarRes,
									pArgs->pei, pArgs->pspCaller);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, DispatchEx_InvokeEx_CallBack, pArgs, pArgs->hr);
	}
}

// IDispatchEx::InvokeEx
HRESULT __stdcall   DispatchEx_InvokeEx_Wrapper	(
									IDispatchEx* pDisp,
									DISPID id,
									LCID lcid,
									WORD wFlags,
									DISPPARAMS *pdp,
									VARIANT *pVarRes, 
									EXCEPINFO *pei, 
									IServiceProvider *pspCaller 
									)
{
	HRESULT hr;

	DispExInvokeExArgs args = {pDisp, id, lcid, wFlags, pdp, pVarRes, pei, pspCaller, &hr};
	DispatchEx_InvokeEx_CallBack(&args);		
	return hr;
}


//------------------------------------------------------------------------------------------
//      IMarshal methods for COM+ objects

// IMARSHAL CALL BACKS

struct GetUnmarshalClassArgs
{
	IMarshal* pUnk;
	const IID* riid; 
	void * pv; 
	ULONG dwDestContext; 
	void * pvDestContext;
	ULONG mshlflags;
	LPCLSID pclsid;
	HRESULT* hr;							
	
};
VOID __stdcall Marshal_GetUnmarshalClass_CallBack (GetUnmarshalClassArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = Marshal_GetUnmarshalClass(pArgs->pUnk, *(pArgs->riid), pArgs->pv, 
									pArgs->dwDestContext, pArgs->pvDestContext, pArgs->mshlflags, 
									pArgs->pclsid);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, Marshal_GetUnmarshalClass_CallBack, pArgs, pArgs->hr);
	}
}
					
HRESULT __stdcall Marshal_GetUnmarshalClass_Wrapper (
							IMarshal* pMarsh,
							REFIID riid, void * pv, ULONG dwDestContext, 
							void * pvDestContext, ULONG mshlflags, 
							LPCLSID pclsid)
{
	HRESULT hr;
	GetUnmarshalClassArgs args = {pMarsh, &riid, pv, dwDestContext, pvDestContext, 
										mshlflags, pclsid, &hr};
	Marshal_GetUnmarshalClass_CallBack(&args);		
	return hr;
}
							

struct GetMarshalSizeMaxArgs
{
	IMarshal* pUnk;
	const IID* riid;
	void * pv; 
	ULONG dwDestContext; 
	void * pvDestContext;
	ULONG mshlflags;
	ULONG * pSize;
	HRESULT* hr;							
	
};
VOID __stdcall Marshal_GetMarshalSizeMax_CallBack (GetMarshalSizeMaxArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = Marshal_GetMarshalSizeMax(pArgs->pUnk, *(pArgs->riid), pArgs->pv, 
									pArgs->dwDestContext, pArgs->pvDestContext, pArgs->mshlflags,
									pArgs->pSize);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, Marshal_GetMarshalSizeMax_CallBack, pArgs, pArgs->hr);
	}
}


HRESULT __stdcall Marshal_GetMarshalSizeMax_Wrapper (
								IMarshal* pMarsh,
								REFIID riid, void * pv, ULONG dwDestContext, 
								void * pvDestContext, ULONG mshlflags, 
								ULONG * pSize)
{
	HRESULT hr;
	GetMarshalSizeMaxArgs args = {pMarsh, &riid, pv, dwDestContext, pvDestContext, 
										mshlflags, pSize, &hr};
	Marshal_GetMarshalSizeMax_CallBack(&args);		
	return hr;
}

struct MarshalInterfaceArgs
{
	IMarshal* pUnk;
	LPSTREAM pStm;	
	const IID* riid; 
	void * pv; 
	ULONG dwDestContext; 
	void * pvDestContext;
	ULONG mshlflags;
	HRESULT* hr;							
	
};
VOID __stdcall Marshal_MarshalInterface_CallBack (MarshalInterfaceArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = Marshal_MarshalInterface(pArgs->pUnk, pArgs->pStm, *(pArgs->riid), pArgs->pv, 
									pArgs->dwDestContext, pArgs->pvDestContext, pArgs->mshlflags);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, Marshal_MarshalInterface_CallBack, pArgs, pArgs->hr);
	}
}

HRESULT __stdcall Marshal_MarshalInterface_Wrapper (
						IMarshal* pMarsh,
						LPSTREAM pStm, REFIID riid, void * pv,
						ULONG dwDestContext, LPVOID pvDestContext,
						ULONG mshlflags)
{
	HRESULT hr;
	MarshalInterfaceArgs args = {pMarsh, pStm, &riid, pv, dwDestContext, pvDestContext, 
										mshlflags, &hr};
	Marshal_MarshalInterface_CallBack(&args);		
	return hr;
}


struct UnmarshalInterfaceArgs
{
	IMarshal* pUnk;
	LPSTREAM pStm;	
	const IID* riid; 
	void ** ppvObj; 
	HRESULT* hr;							
	
};
VOID __stdcall Marshal_UnmarshalInterface_CallBack (UnmarshalInterfaceArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = Marshal_UnmarshalInterface(pArgs->pUnk, pArgs->pStm, *(pArgs->riid), pArgs->ppvObj);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, Marshal_UnmarshalInterface_CallBack, pArgs, pArgs->hr);
	}
}



HRESULT __stdcall Marshal_UnmarshalInterface_Wrapper (
						IMarshal* pMarsh,
						LPSTREAM pStm, REFIID riid, 
						void ** ppvObj)
{
	HRESULT hr;
	UnmarshalInterfaceArgs args = {pMarsh, pStm, &riid, ppvObj, &hr};
	Marshal_UnmarshalInterface_CallBack(&args);		
	return hr;
}


struct ReleaseMarshalDataArgs
{
	IMarshal* pUnk;
	LPSTREAM pStm;		
	HRESULT* hr;							
	
};						
VOID __stdcall Marshal_ReleaseMarshalData_CallBack (ReleaseMarshalDataArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = Marshal_ReleaseMarshalData(pArgs->pUnk, pArgs->pStm);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, Marshal_ReleaseMarshalData_CallBack, pArgs, pArgs->hr);
	}
}



HRESULT __stdcall Marshal_ReleaseMarshalData_Wrapper (IMarshal* pMarsh, LPSTREAM pStm)
{
	HRESULT hr;
	ReleaseMarshalDataArgs args = {pMarsh, pStm, &hr};
	Marshal_ReleaseMarshalData_CallBack(&args);		
	return hr;
}


struct DisconnectObjectArgs
{
	IMarshal* pUnk;
	ULONG dwReserved; 
	HRESULT* hr;							
	
};
VOID __stdcall Marshal_DisconnectObject_CallBack (DisconnectObjectArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = Marshal_DisconnectObject(pArgs->pUnk, pArgs->dwReserved);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, Marshal_DisconnectObject_CallBack, pArgs, pArgs->hr);
	}
}

HRESULT __stdcall Marshal_DisconnectObject_Wrapper (IMarshal* pMarsh, ULONG dwReserved)
{
	HRESULT hr;
	DisconnectObjectArgs args = {pMarsh, dwReserved, &hr};
	Marshal_DisconnectObject_CallBack(&args);		
	return hr;
}

//------------------------------------------------------------------------------------------
//      IManagedObject methods for COM+ objects

interface IManagedObject;




struct GetObjectIdentityArgs
{
	IManagedObject *pUnk; 
	BSTR* pBSTRGUID; 
    DWORD* pAppDomainID;
	void** pCCW;
	HRESULT* hr;
};

VOID __stdcall ManagedObject_GetObjectIdentity_CallBack(GetObjectIdentityArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = ManagedObject_GetObjectIdentity(pArgs->pUnk, pArgs->pBSTRGUID, pArgs->pAppDomainID,
								pArgs->pCCW);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, ManagedObject_GetObjectIdentity_CallBack, pArgs, pArgs->hr);
	}
}

HRESULT __stdcall ManagedObject_GetObjectIdentity_Wrapper(IManagedObject *pUnk, 
											              BSTR* pBSTRGUID, DWORD* pAppDomainID,
                								          void** pCCW) 
{
	HRESULT hr;
	GetObjectIdentityArgs args = {pUnk, pBSTRGUID, pAppDomainID, pCCW, &hr};
	ManagedObject_GetObjectIdentity_CallBack(&args);		
	return hr;
}

//-----------------------
struct GetSerializedBufferArgs
{
	IManagedObject *pUnk; 
	BSTR* pBStr; 	
	HRESULT* hr;
};
VOID __stdcall ManagedObject_GetSerializedBuffer_CallBack(GetSerializedBufferArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = ManagedObject_GetSerializedBuffer(pArgs->pUnk, pArgs->pBStr);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, ManagedObject_GetSerializedBuffer_CallBack, pArgs, pArgs->hr);
	}
}

HRESULT __stdcall ManagedObject_GetSerializedBuffer_Wrapper(IManagedObject *pUnk,
                                                   BSTR* pBStr)
{
	HRESULT hr;
	GetSerializedBufferArgs args = {pUnk, pBStr, &hr};
	ManagedObject_GetSerializedBuffer_CallBack(&args);		
	return hr;
}

//------------------------------------------------------------------------------------------
//      IConnectionPointContainer methods for COM+ objects

interface IEnumConnectionPoints;

//		IConnectionPointContainer callback
struct EnumConnectionPointsArgs
{
	IUnknown* pUnk;
	IEnumConnectionPoints **ppEnum;
	HRESULT*		hr;
};
VOID __stdcall ConnectionPointContainer_EnumConnectionPoints_CallBack(EnumConnectionPointsArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = ConnectionPointContainer_EnumConnectionPoints(pArgs->pUnk, pArgs->ppEnum);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, ConnectionPointContainer_EnumConnectionPoints_CallBack, pArgs, pArgs->hr);
	}
}

HRESULT __stdcall ConnectionPointContainer_EnumConnectionPoints_Wrapper(IUnknown* pUnk, 
																IEnumConnectionPoints **ppEnum)
{
	HRESULT hr;
	EnumConnectionPointsArgs args = {pUnk, ppEnum, &hr};
	ConnectionPointContainer_EnumConnectionPoints_CallBack(&args);		
	return hr;
}

struct FindConnectionPointArgs
{
	IUnknown* pUnk;
	const IID* riid;															   
	IConnectionPoint **ppCP;
	HRESULT*	hr;
};
VOID __stdcall ConnectionPointContainer_FindConnectionPoint_CallBack(FindConnectionPointArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = ConnectionPointContainer_FindConnectionPoint(pArgs->pUnk, *(pArgs->riid), 
															pArgs->ppCP);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, ConnectionPointContainer_FindConnectionPoint_CallBack, pArgs, pArgs->hr);
	}
}

HRESULT __stdcall ConnectionPointContainer_FindConnectionPoint_Wrapper(IUnknown* pUnk, 
															   REFIID riid,
															   IConnectionPoint **ppCP)
{
	HRESULT hr;
	FindConnectionPointArgs args = {pUnk, &riid, ppCP, &hr};
	ConnectionPointContainer_FindConnectionPoint_CallBack(&args);		
	return hr;
}


//------------------------------------------------------------------------------------------
//      IObjectSafety methods for COM+ objects

interface IObjectSafety;

struct GetInterfaceSafetyArgs
{
	IUnknown* pUnk;
	const IID* riid;
	DWORD *pdwSupportedOptions;
	DWORD *pdwEnabledOptions;
	HRESULT*	hr;
};
VOID __stdcall ObjectSafety_GetInterfaceSafetyOptions_CallBack(GetInterfaceSafetyArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = ObjectSafety_GetInterfaceSafetyOptions(pArgs->pUnk, *(pArgs->riid), 
															pArgs->pdwSupportedOptions,
															pArgs->pdwEnabledOptions);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, ObjectSafety_GetInterfaceSafetyOptions_CallBack, pArgs, pArgs->hr);
	}
}


HRESULT __stdcall ObjectSafety_GetInterfaceSafetyOptions_Wrapper(IUnknown* pUnk,
                                                         REFIID riid,
                                                         DWORD *pdwSupportedOptions,
                                                         DWORD *pdwEnabledOptions)
{
	HRESULT hr;
	GetInterfaceSafetyArgs args = {pUnk, &riid, pdwSupportedOptions, pdwEnabledOptions, &hr};
	ObjectSafety_GetInterfaceSafetyOptions_CallBack(&args);		
	return hr;
}

struct SetInterfaceSafetyArgs
{
	IUnknown* pUnk;
	const IID* riid;
	DWORD dwOptionSetMask;
	DWORD dwEnabledOptions;
	HRESULT*	hr;
};
VOID __stdcall ObjectSafety_SetInterfaceSafetyOptions_CallBack(SetInterfaceSafetyArgs* pArgs)
{
	ComCallWrapper* pWrap = MapIUnknownToWrapper(pArgs->pUnk);
	if (IsCurrentDomainValid(pWrap))
	{
		*(pArgs->hr) = ObjectSafety_SetInterfaceSafetyOptions(pArgs->pUnk, *(pArgs->riid), 
															pArgs->dwOptionSetMask,
															pArgs->dwEnabledOptions
															);
	}
	else
	{		
		AppDomainDoCallBack(pWrap, ObjectSafety_SetInterfaceSafetyOptions_CallBack, pArgs, pArgs->hr);
	}
}


HRESULT __stdcall ObjectSafety_SetInterfaceSafetyOptions_Wrapper(IUnknown* pUnk,
                                                         REFIID riid,
                                                         DWORD dwOptionSetMask,
                                                         DWORD dwEnabledOptions)
{
	HRESULT hr;
	SetInterfaceSafetyArgs args = {pUnk, &riid, dwOptionSetMask, dwEnabledOptions, &hr};
	ObjectSafety_SetInterfaceSafetyOptions_CallBack(&args);		
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stublink.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// stublink.cpp
//

#include "common.h"

#include <limits.h>
#include "threads.h"
#include "excep.h"
#include "stublink.h"
#include "utsem.h"
#include "PerfCounters.h"

#ifdef _DEBUG
Crst    *Stub::m_pStubTrackerCrst = NULL;
BYTE     Stub::m_StubTrackerCrstMemory[sizeof(Crst)];
Stub    *Stub::m_pTrackingList = NULL;
#endif

Crst    *LazyStubMaker::m_pCrst = NULL;
BYTE     LazyStubMaker::m_CrstMemory[sizeof(Crst)];
LazyStubMaker *LazyStubMaker::m_pFirst = NULL;



//************************************************************************
// CodeElement
//
// There are two types of CodeElements: CodeRuns (a stream of uninterpreted
// code bytes) and LabelRefs (an instruction containing
// a fixup.)
//************************************************************************
struct CodeElement
{
    enum CodeElementType {
        kCodeRun  = 0,
        kLabelRef = 1,
    };


    CodeElementType     m_type;  // kCodeRun or kLabelRef
    CodeElement        *m_next;  // ptr to next CodeElement

    // Used as workspace during Link(): holds the offset relative to
    // the start of the final stub.
    UINT                m_globaloffset;
    UINT                m_dataoffset;
};


//************************************************************************
// CodeRun: A run of uninterrupted code bytes.
//************************************************************************

#ifdef _DEBUG
#define CODERUNSIZE 3
#else
#define CODERUNSIZE 32
#endif

struct CodeRun : public CodeElement
{
    UINT    m_numcodebytes;       // how many bytes are actually used
    BYTE    m_codebytes[CODERUNSIZE];
};

//************************************************************************
// LabelRef: An instruction containing an embedded label reference
//************************************************************************
struct LabelRef : public CodeElement
{
    // provides platform-specific information about the instruction
    InstructionFormat    *m_pInstructionFormat;

    // a variation code (interpretation is specific to the InstructionFormat)
    //  typically used to customize an instruction (e.g. with a condition
    //  code.)
    UINT                 m_variationCode;


    CodeLabel           *m_target;

    // Workspace during the link phase
    UINT                 m_refsize;


    // Pointer to next LabelRef
    LabelRef            *m_nextLabelRef;
};







//************************************************************************
// CodeLabel
//************************************************************************
struct CodeLabel
{
    // Link pointer for StubLink's list of labels
    CodeLabel       *m_next;

    // if FALSE, label refers to some code within the same stub
    // if TRUE, label refers to some externally supplied address.
    BOOL             m_fExternal;

    // if TRUE, means we want the actual address of the label and
    // not an offset to it
    BOOL             m_fAbsolute;

    union {

        // Internal
        struct {
            // Indicates the position of the label, expressed
            // as an offset into a CodeRun.
            CodeRun         *m_pCodeRun;
            UINT             m_localOffset;
        
        } i;


        // External
        struct {
            LPVOID           m_pExternalAddress;
        } e;
    };
};








//************************************************************************
// StubLinker
//************************************************************************

//---------------------------------------------------------------
// Construction
//---------------------------------------------------------------
StubLinker::StubLinker()
{
    m_pCodeElements     = NULL;
    m_pFirstCodeLabel   = NULL;
    m_pFirstLabelRef    = NULL;
    m_pPatchLabel       = NULL;
    m_pReturnLabel      = NULL;
    m_pIntermediateDebuggerLabel = NULL;
    m_returnStackSize   = 0;
    m_stackSize         = 0;
}


//---------------------------------------------------------------
// Failable init. Throws COM+ exception on failure.
//---------------------------------------------------------------
VOID StubLinker::Init()
{
    THROWSCOMPLUSEXCEPTION();
}



//---------------------------------------------------------------
// Cleanup.
//---------------------------------------------------------------
StubLinker::~StubLinker()
{
}





//---------------------------------------------------------------
// Append code bytes.
//---------------------------------------------------------------
VOID StubLinker::EmitBytes(const BYTE *pBytes, UINT numBytes)
{
    THROWSCOMPLUSEXCEPTION();

    CodeElement *pLastCodeElement = GetLastCodeElement();
    while (numBytes != 0) {

        if (pLastCodeElement != NULL &&
            pLastCodeElement->m_type == CodeElement::kCodeRun) {
            CodeRun *pCodeRun = (CodeRun*)pLastCodeElement;
            UINT numbytessrc  = numBytes;
            UINT numbytesdst  = CODERUNSIZE - pCodeRun->m_numcodebytes;
            if (numbytesdst <= numbytessrc) {
                CopyMemory(&(pCodeRun->m_codebytes[pCodeRun->m_numcodebytes]),
                           pBytes,
                           numbytesdst);
                pCodeRun->m_numcodebytes = CODERUNSIZE;
                pLastCodeElement = NULL;
                pBytes += numbytesdst;
                numBytes -= numbytesdst;
            } else {
                CopyMemory(&(pCodeRun->m_codebytes[pCodeRun->m_numcodebytes]),
                           pBytes,
                           numbytessrc);
                pCodeRun->m_numcodebytes += numbytessrc;
                pBytes += numbytessrc;
                numBytes = 0;
            }

        } else {
            pLastCodeElement = AppendNewEmptyCodeRun();
        }
    }
}


//---------------------------------------------------------------
// Append code bytes.
//---------------------------------------------------------------
VOID StubLinker::Emit8 (unsigned __int8  val)
{
    THROWSCOMPLUSEXCEPTION();
    CodeRun *pCodeRun = GetLastCodeRunIfAny();
    if (pCodeRun && (CODERUNSIZE - pCodeRun->m_numcodebytes) >= sizeof(val)) {
        *((unsigned __int8 *)(pCodeRun->m_codebytes + pCodeRun->m_numcodebytes)) = val;
        pCodeRun->m_numcodebytes += sizeof(val);
    } else {
        EmitBytes((BYTE*)&val, sizeof(val));
    }
}

//---------------------------------------------------------------
// Append code bytes.
//---------------------------------------------------------------
VOID StubLinker::Emit16(unsigned __int16 val)
{
    THROWSCOMPLUSEXCEPTION();
    CodeRun *pCodeRun = GetLastCodeRunIfAny();
    if (pCodeRun && (CODERUNSIZE - pCodeRun->m_numcodebytes) >= sizeof(val)) {
        *((unsigned __int16 *)(pCodeRun->m_codebytes + pCodeRun->m_numcodebytes)) = val;
        pCodeRun->m_numcodebytes += sizeof(val);
    } else {
        EmitBytes((BYTE*)&val, sizeof(val));
    }
}

//---------------------------------------------------------------
// Append code bytes.
//---------------------------------------------------------------
VOID StubLinker::Emit32(unsigned __int32 val)
{
    THROWSCOMPLUSEXCEPTION();
    CodeRun *pCodeRun = GetLastCodeRunIfAny();
    if (pCodeRun && (CODERUNSIZE - pCodeRun->m_numcodebytes) >= sizeof(val)) {
        *((unsigned __int32 *)(pCodeRun->m_codebytes + pCodeRun->m_numcodebytes)) = val;
        pCodeRun->m_numcodebytes += sizeof(val);
    } else {
        EmitBytes((BYTE*)&val, sizeof(val));
    }
}

//---------------------------------------------------------------
// Append code bytes.
//---------------------------------------------------------------
VOID StubLinker::Emit64(unsigned __int64 val)
{
    THROWSCOMPLUSEXCEPTION();
    CodeRun *pCodeRun = GetLastCodeRunIfAny();
    if (pCodeRun && (CODERUNSIZE - pCodeRun->m_numcodebytes) >= sizeof(val)) {
        *((unsigned __int64 *)(pCodeRun->m_codebytes + pCodeRun->m_numcodebytes)) = val;
        pCodeRun->m_numcodebytes += sizeof(val);
    } else {
        EmitBytes((BYTE*)&val, sizeof(val));
    }
}

//---------------------------------------------------------------
// Append pointer value.
//---------------------------------------------------------------
VOID StubLinker::EmitPtr(const VOID *val)
{
    THROWSCOMPLUSEXCEPTION();
    CodeRun *pCodeRun = GetLastCodeRunIfAny();
    if (pCodeRun && (CODERUNSIZE - pCodeRun->m_numcodebytes) >= sizeof(val)) {
        *((const VOID **)(pCodeRun->m_codebytes + pCodeRun->m_numcodebytes)) = val;
        pCodeRun->m_numcodebytes += sizeof(val);
    } else {
        EmitBytes((BYTE*)&val, sizeof(val));
    }
}


//---------------------------------------------------------------
// Create a new undefined label. Label must be assigned to a code
// location using EmitLabel() prior to final linking.
// Throws COM+ exception on failure.
//---------------------------------------------------------------
CodeLabel* StubLinker::NewCodeLabel()
{
    THROWSCOMPLUSEXCEPTION();

    CodeLabel *pCodeLabel = (CodeLabel*)(m_quickHeap.Alloc(sizeof(CodeLabel)));
    _ASSERTE(pCodeLabel); // QuickHeap throws exceptions rather than returning NULL
    pCodeLabel->m_next       = m_pFirstCodeLabel;
    pCodeLabel->m_fExternal  = FALSE;
    pCodeLabel->m_fAbsolute = FALSE;
    pCodeLabel->i.m_pCodeRun = NULL;
    m_pFirstCodeLabel = pCodeLabel;
    return pCodeLabel;


}

CodeLabel* StubLinker::NewAbsoluteCodeLabel()
{
    THROWSCOMPLUSEXCEPTION();

    CodeLabel *pCodeLabel = NewCodeLabel();
    pCodeLabel->m_fAbsolute = TRUE;
    return pCodeLabel;
}


//---------------------------------------------------------------
// Sets the label to point to the current "instruction pointer".
// It is invalid to call EmitLabel() twice on
// the same label.
//---------------------------------------------------------------
VOID StubLinker::EmitLabel(CodeLabel* pCodeLabel)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(!(pCodeLabel->m_fExternal));       //can't emit an external label
    _ASSERTE(pCodeLabel->i.m_pCodeRun == NULL);  //must only emit label once
    CodeRun *pLastCodeRun = GetLastCodeRunIfAny();
    if (!pLastCodeRun) {
        pLastCodeRun = AppendNewEmptyCodeRun();
    }
    pCodeLabel->i.m_pCodeRun    = pLastCodeRun;
    pCodeLabel->i.m_localOffset = pLastCodeRun->m_numcodebytes;
}                                              


//---------------------------------------------------------------
// Combines NewCodeLabel() and EmitLabel() for convenience.
// Throws COM+ exception on failure.
//---------------------------------------------------------------
CodeLabel* StubLinker::EmitNewCodeLabel()
{
    THROWSCOMPLUSEXCEPTION();

    CodeLabel* label = NewCodeLabel();
    EmitLabel(label);
    return label;
}


//---------------------------------------------------------------
// Creates & emits the patch offset label for the stub
//---------------------------------------------------------------
VOID StubLinker::EmitPatchLabel()
{
    THROWSCOMPLUSEXCEPTION();

    //
    // Note that it's OK to have re-emit the patch label, 
    // just use the later one.
    //

    m_pPatchLabel = EmitNewCodeLabel();
}                                              

VOID StubLinker::EmitDebuggerIntermediateLabel()
{
   THROWSCOMPLUSEXCEPTION();

    //
    // Note that it's OK to have re-emit the patch label, 
    // just use the later one.
    //
    m_pIntermediateDebuggerLabel = EmitNewCodeLabel();
}

//---------------------------------------------------------------
// Creates & emits the return offset label for the stub
//---------------------------------------------------------------
VOID StubLinker::EmitReturnLabel()
{
    THROWSCOMPLUSEXCEPTION();

    //
    // Note that it's OK to have re-emit the patch label, 
    // just use the later one.
    //

    m_pReturnLabel = EmitNewCodeLabel();
    m_returnStackSize = m_stackSize;
}                                              


//---------------------------------------------------------------
// Returns final location of label as an offset from the start
// of the stub. Can only be called after linkage.
//---------------------------------------------------------------
UINT32 StubLinker::GetLabelOffset(CodeLabel *pLabel)
{
    _ASSERTE(!(pLabel->m_fExternal));
    return pLabel->i.m_localOffset + pLabel->i.m_pCodeRun->m_globaloffset;
}


//---------------------------------------------------------------
// Create a new label to an external address.
// Throws COM+ exception on failure.
//---------------------------------------------------------------
CodeLabel* StubLinker::NewExternalCodeLabel(LPVOID pExternalAddress)
{
    THROWSCOMPLUSEXCEPTION();

    CodeLabel *pCodeLabel = (CodeLabel*)(m_quickHeap.Alloc(sizeof(CodeLabel)));
    _ASSERTE(pCodeLabel); // QuickHeap throws exceptions rather than returning NULL
    pCodeLabel->m_next       = m_pFirstCodeLabel;
    pCodeLabel->m_fExternal          = TRUE;
    pCodeLabel->m_fAbsolute  = FALSE;
    pCodeLabel->e.m_pExternalAddress = pExternalAddress;
    m_pFirstCodeLabel = pCodeLabel;
    return pCodeLabel;


}




//---------------------------------------------------------------
// Append an instruction containing a reference to a label.
//
//      target          - the label being referenced.
//      instructionFormat         - a platform-specific InstructionFormat object
//                        that gives properties about the reference.
//      variationCode   - uninterpreted data passed to the pInstructionFormat methods.
//---------------------------------------------------------------
VOID StubLinker::EmitLabelRef(CodeLabel* target, const InstructionFormat & instructionFormat, UINT variationCode)
{
    THROWSCOMPLUSEXCEPTION();

    LabelRef *pLabelRef = (LabelRef *)(m_quickHeap.Alloc(sizeof(LabelRef)));
    _ASSERTE(pLabelRef);      // m_quickHeap throws an exception rather than returning NULL
    pLabelRef->m_type               = LabelRef::kLabelRef;
    pLabelRef->m_pInstructionFormat = (InstructionFormat*)&instructionFormat;
    pLabelRef->m_variationCode      = variationCode;
    pLabelRef->m_target             = target;

    pLabelRef->m_nextLabelRef = m_pFirstLabelRef;
    m_pFirstLabelRef = pLabelRef;

    AppendCodeElement(pLabelRef);

   
}
                  




//---------------------------------------------------------------
// Internal helper routine.
//---------------------------------------------------------------
CodeRun *StubLinker::GetLastCodeRunIfAny()
{
    CodeElement *pLastCodeElem = GetLastCodeElement();
    if (pLastCodeElem == NULL || pLastCodeElem->m_type != CodeElement::kCodeRun) {
        return NULL;
    } else {
        return (CodeRun*)pLastCodeElem;
    }
}


//---------------------------------------------------------------
// Internal helper routine.
//---------------------------------------------------------------
CodeRun *StubLinker::AppendNewEmptyCodeRun()
{
    THROWSCOMPLUSEXCEPTION();

    CodeRun *pNewCodeRun = (CodeRun*)(m_quickHeap.Alloc(sizeof(CodeRun)));
    _ASSERTE(pNewCodeRun); // QuickHeap throws exceptions rather than returning NULL
    pNewCodeRun->m_type = CodeElement::kCodeRun;
    pNewCodeRun->m_numcodebytes = 0;
    AppendCodeElement(pNewCodeRun);
    return pNewCodeRun;

}

//---------------------------------------------------------------
// Internal helper routine.
//---------------------------------------------------------------
VOID StubLinker::AppendCodeElement(CodeElement *pCodeElement)
{
    pCodeElement->m_next = m_pCodeElements;
    m_pCodeElements = pCodeElement;
}



//---------------------------------------------------------------
// Is the current LabelRef's size big enough to reach the target?
//---------------------------------------------------------------
static BOOL LabelCanReach(LabelRef *pLabelRef)
{
    InstructionFormat *pIF  = pLabelRef->m_pInstructionFormat;

    if (pLabelRef->m_target->m_fExternal)
    {
        return pLabelRef->m_pInstructionFormat->CanReach(
                pLabelRef->m_refsize, pLabelRef->m_variationCode, TRUE, 0);
    }
    else
    {
        UINT targetglobaloffset = pLabelRef->m_target->i.m_pCodeRun->m_globaloffset +
                                  pLabelRef->m_target->i.m_localOffset;
        UINT srcglobaloffset = pLabelRef->m_globaloffset +
                               pIF->GetHotSpotOffset(pLabelRef->m_refsize,
                                                     pLabelRef->m_variationCode);
        INT offset = (INT)(targetglobaloffset - srcglobaloffset);
        
        return pLabelRef->m_pInstructionFormat->CanReach(
            pLabelRef->m_refsize, pLabelRef->m_variationCode, FALSE, offset);
    }
} 

//---------------------------------------------------------------
// Generate the actual stub. The returned stub has a refcount of 1.
// No other methods (other than the destructor) should be called
// after calling Link().
//
// Throws COM+ exception on failure.
//---------------------------------------------------------------
Stub *StubLinker::LinkInterceptor(LoaderHeap *pHeap, Stub* interceptee, void *pRealAddr)
{
    THROWSCOMPLUSEXCEPTION();
    int globalsize = 0;
    int size = CalculateSize(&globalsize);

    _ASSERTE(pHeap);
    Stub *pStub = InterceptStub::NewInterceptedStub(pHeap, size, interceptee,
                                                    pRealAddr,
                                                    m_pReturnLabel != NULL);
    if (!pStub) {
        COMPlusThrowOM();
    }
    EmitStub(pStub, globalsize);
    return pStub;
}

//---------------------------------------------------------------
// Generate the actual stub. The returned stub has a refcount of 1.
// No other methods (other than the destructor) should be called
// after calling Link().
//
// Throws COM+ exception on failure.
//---------------------------------------------------------------
Stub *StubLinker::Link(LoaderHeap *pHeap, UINT *pcbSize /* = NULL*/, BOOL fMC)
{
    THROWSCOMPLUSEXCEPTION();
    int globalsize = 0;
    int size = CalculateSize(&globalsize);
    if (pcbSize) {
        *pcbSize = size;
    }
    Stub *pStub = Stub::NewStub(pHeap, size, FALSE, m_pReturnLabel != NULL, fMC);
    if (!pStub) {
        COMPlusThrowOM();
    }
    EmitStub(pStub, globalsize);
    return pStub;
}

int StubLinker::CalculateSize(int* pGlobalSize)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pGlobalSize);

#ifdef _DEBUG
    // Don't want any undefined labels
    for (CodeLabel *pCodeLabel = m_pFirstCodeLabel;
         pCodeLabel != NULL;
         pCodeLabel = pCodeLabel->m_next) {
        if ((!(pCodeLabel->m_fExternal)) && pCodeLabel->i.m_pCodeRun == NULL) {
            _ASSERTE(!"Forgot to define a label before asking StubLinker to link.");
        }
    }
#endif //_DEBUG

    //-------------------------------------------------------------------
    // Tentatively set all of the labelref sizes to their smallest possible
    // value.
    //-------------------------------------------------------------------
    for (LabelRef *pLabelRef = m_pFirstLabelRef;
         pLabelRef != NULL;
         pLabelRef = pLabelRef->m_nextLabelRef) {

        for (UINT bitmask = 1; bitmask <= InstructionFormat::kMax; bitmask = bitmask << 1) {
            if (pLabelRef->m_pInstructionFormat->m_allowedSizes & bitmask) {
                pLabelRef->m_refsize = bitmask;
                break;
            }
        }

    }

    UINT globalsize;
    UINT datasize;
    BOOL fSomethingChanged;
    do {
        fSomethingChanged = FALSE;
        

        // Layout each code element.
        globalsize = 0;
        datasize = 0;
        for (CodeElement *pCodeElem = m_pCodeElements; pCodeElem; pCodeElem = pCodeElem->m_next) {

            switch (pCodeElem->m_type) {
                case CodeElement::kCodeRun:
                    globalsize += ((CodeRun*)pCodeElem)->m_numcodebytes;
                    break;

                case CodeElement::kLabelRef: {
                    LabelRef *pLabelRef = (LabelRef*)pCodeElem;
                    globalsize += pLabelRef->m_pInstructionFormat->GetSizeOfInstruction( pLabelRef->m_refsize,
                                                                                         pLabelRef->m_variationCode );
                    datasize += pLabelRef->m_pInstructionFormat->GetSizeOfData( pLabelRef->m_refsize,
                                                                                         pLabelRef->m_variationCode );
                    //ARULM//RETAILMSG(1, (L"StubLinker: LabelRef(%08x) refsize=%d varcode=%d codesize=%d datasize=%d\r\n",
                    //ARULM//       pLabelRef, pLabelRef->m_refsize, pLabelRef->m_variationCode, globalsize, datasize));
                    }
                    break;

                default:
                    _ASSERTE(0);
            }

            // Record a temporary global offset; this is actually
            // wrong by a fixed value. We'll fix up after we know the
            // size of the entire stub.
            pCodeElem->m_globaloffset = 0 - globalsize;

            // also record the data offset. Note the link-list we walk is in 
            // *reverse* order so we visit the last instruction first
            // so what we record now is in fact the offset from the *end* of 
            // the data block. We fix it up later.
            pCodeElem->m_dataoffset = 0 - datasize;
        }

        // Now fix up the global offsets.
        for (pCodeElem = m_pCodeElements; pCodeElem; pCodeElem = pCodeElem->m_next) {
            pCodeElem->m_globaloffset += globalsize;
            pCodeElem->m_dataoffset += datasize;
        }


        // Now, iterate thru the LabelRef's and check if any of them
        // have to be resized.
        for (LabelRef *pLabelRef = m_pFirstLabelRef;
             pLabelRef != NULL;
             pLabelRef = pLabelRef->m_nextLabelRef) {


            if (!LabelCanReach(pLabelRef)) {
                fSomethingChanged = TRUE;

                //ARULM//RETAILMSG(1, (L"StubLinker: LabelRef(%08x) CANNOT REACH\r\n", pLabelRef));
                // Find the next largest size.
                // (we could be smarter about this and eliminate intermediate
                // sizes based on the tentative offset.)
                for (UINT bitmask = pLabelRef->m_refsize << 1; bitmask <= InstructionFormat::kMax; bitmask = bitmask << 1) {
                    if (pLabelRef->m_pInstructionFormat->m_allowedSizes & bitmask) {
                        pLabelRef->m_refsize = bitmask;
                        break;
                    }
                }
#ifdef _DEBUG
                if (pLabelRef->m_refsize > InstructionFormat::kMax) {
                    _ASSERTE(!"Stub instruction cannot reach target: must choose a different instruction!");
                    //ARULM//RETAILMSG(1, (L"StubLinker: LabelRef(%08x) CANNOT REACH even with kMax\r\n", pLabelRef));
                }
#endif
            }
        }


    } while (fSomethingChanged); // Keep iterating until all LabelRef's can reach


    // We now have the correct layout write out the stub.

    // Compute stub code+data size after aligning data correctly
    if(globalsize % DATA_ALIGNMENT)
        globalsize += (DATA_ALIGNMENT - (globalsize % DATA_ALIGNMENT));

    *pGlobalSize = globalsize;
    return globalsize + datasize;
}

void StubLinker::EmitStub(Stub* pStub, int globalsize)
{
    BYTE *pCode = (BYTE*)(pStub->GetEntryPoint());
    BYTE *pData = pCode+globalsize; // start of data area
    {
        // Write out each code element.
        for (CodeElement* pCodeElem = m_pCodeElements; pCodeElem; pCodeElem = pCodeElem->m_next) {

            switch (pCodeElem->m_type) {
                case CodeElement::kCodeRun:
                    CopyMemory(pCode + pCodeElem->m_globaloffset,
                               ((CodeRun*)pCodeElem)->m_codebytes,
                               ((CodeRun*)pCodeElem)->m_numcodebytes);
                    break;

                case CodeElement::kLabelRef: {
                    LabelRef *pLabelRef = (LabelRef*)pCodeElem;
                    InstructionFormat *pIF  = pLabelRef->m_pInstructionFormat;
                    __int64 fixupval;

                    LPBYTE srcglobaladdr = pCode +
                                           pLabelRef->m_globaloffset +
                                           pIF->GetHotSpotOffset(pLabelRef->m_refsize,
                                                                 pLabelRef->m_variationCode);
                    LPBYTE targetglobaladdr;
                    if (!(pLabelRef->m_target->m_fExternal)) {
                        targetglobaladdr = pCode +
                                           pLabelRef->m_target->i.m_pCodeRun->m_globaloffset +
                                           pLabelRef->m_target->i.m_localOffset;
                    } else {
                        targetglobaladdr = (LPBYTE)(pLabelRef->m_target->e.m_pExternalAddress);
                    }
                    if ((pLabelRef->m_target->m_fAbsolute)) {
                        _ASSERTE(! pLabelRef->m_target->m_fExternal);
                        fixupval = (__int64)targetglobaladdr;
                    } else
                        fixupval = (__int64)(targetglobaladdr - srcglobaladdr);

                    pLabelRef->m_pInstructionFormat->EmitInstruction(
                        pLabelRef->m_refsize,
                        fixupval,
                        pCode + pCodeElem->m_globaloffset,
                        pLabelRef->m_variationCode,
                        pData + pCodeElem->m_dataoffset);
                    }
                    break;

                default:
                    _ASSERTE(0);
            }
        }
    }

    // Fill in patch offset, if we have one
    // Note that these offsets are relative to the start of the stub,
    // not the code, so you'll have to add sizeof(Stub) to get to the
    // right spot.
    if (m_pIntermediateDebuggerLabel != NULL)
    {
        pStub->SetMCDStubSize(GetLabelOffset(m_pPatchLabel));
        pStub->SetMCDPatchOffset(GetLabelOffset(m_pIntermediateDebuggerLabel));
        
        LOG((LF_CORDB, LL_INFO100, "SL::ES: MCD Size:0x%x offset:0x%x\n",
            pStub->GetMCDStubSize(), pStub->GetMCDPatchOffset()));
    }
    else if (m_pPatchLabel != NULL)
    {
        pStub->SetPatchOffset(GetLabelOffset(m_pPatchLabel));
        
        LOG((LF_CORDB, LL_INFO100, "SL::ES: patch offset:0x%x\n",
            pStub->GetPatchOffset()));
    }        


    if (m_pReturnLabel != NULL)
    {
        pStub->SetCallSiteReturnOffset(GetLabelOffset(m_pReturnLabel));
        pStub->SetCallSiteStackSize(m_returnStackSize);
    }
}

USHORT Stub::GetMCDPatchOffset()
{
    ULONG base = m_patchOffset & (MCD_PATCH_OFFSET_MASK << MCD_PATCH_OFFSET_SHIFT);
    return (USHORT)(base >> MCD_PATCH_OFFSET_SHIFT);
}

USHORT Stub::GetMCDStubSize()
{
    return (USHORT)(m_patchOffset & MCD_SIZE_MASK);
}

void Stub::SetMCDPatchOffset(USHORT offset)
{
    _ASSERTE(offset < MCD_PATCH_OFFSET_MASK);
    _ASSERTE(GetMCDPatchOffset() == 0);
    m_patchOffset |= offset << MCD_PATCH_OFFSET_SHIFT;
    _ASSERTE(GetMCDPatchOffset() == offset);
}

void Stub::SetMCDStubSize(USHORT size)
{
    _ASSERTE(size < MCD_SIZE_MASK);
    _ASSERTE(GetMCDStubSize() == 0);
    m_patchOffset |= size;
    _ASSERTE(GetMCDStubSize() == size);
}

//-------------------------------------------------------------------
// ForceDelete
//
// Forces a stub to free itself. This routine forces the refcount
// to 1, then does a DecRef. It is not threadsafe, and thus can
// only be used in shutdown scenarios.
//-------------------------------------------------------------------
VOID Stub::ForceDelete()
{
    m_refcount = 0;
    DecRef();
}

//-------------------------------------------------------------------
// Inc the refcount.
//-------------------------------------------------------------------
VOID Stub::IncRef()
{
    _ASSERTE(m_signature == kUsedStub);
    FastInterlockIncrement((LONG*)&m_refcount);
}

//-------------------------------------------------------------------
// Dec the refcount.
//-------------------------------------------------------------------
BOOL Stub::DecRef()
{
    _ASSERTE(m_signature == kUsedStub);
    int count = FastInterlockDecrement((LONG*)&m_refcount);
    if (count<0) {
#ifdef _DEBUG
        if ((m_patchOffset & LOADER_HEAP_BIT) == 0)
        {
            m_pStubTrackerCrst->Enter();
            Stub **ppstub = &m_pTrackingList;
            Stub *pstub;
            ULONG cnt=0;
            while (NULL != (pstub = *ppstub)) {
				_ASSERTE(m_signature == kUsedStub || m_signature == kFreedStub);
                if (pstub->m_signature == kFreedStub && ++cnt > 3000) {
                    *ppstub = pstub->m_Next;
                    if(pstub->m_patchOffset & INTERCEPT_BIT) 
                        ((InterceptStub*)pstub)->DeleteStub();
                    else
                        pstub->DeleteStub();
                    break;
                } else {
                    ppstub = &(pstub->m_Next);
                }
            }

            m_signature = kFreedStub;
            FillMemory(this+1, m_numCodeBytes, 0xcc);

            m_Next = m_pTrackingList;
            m_pTrackingList = this;

            m_pStubTrackerCrst->Leave();

            if(m_patchOffset & INTERCEPT_BIT) 
                ((InterceptStub*)this)->ReleaseInterceptedStub();

            return TRUE;
        }
#endif

        if(m_patchOffset & INTERCEPT_BIT) {
            ((InterceptStub*)this)->ReleaseInterceptedStub();
            ((InterceptStub*)this)->DeleteStub();
        }
        else
            DeleteStub();

        return TRUE;
    }
    return FALSE;
}

VOID Stub::DeleteStub()
{
	COUNTER_ONLY(GetPrivatePerfCounters().m_Interop.cStubs--);
	COUNTER_ONLY(GetGlobalPerfCounters().m_Interop.cStubs--);
	
    if ((m_patchOffset & LOADER_HEAP_BIT) == 0) {
        if(m_patchOffset & CALL_SITE_BIT)
            delete [] ((BYTE*)this - sizeof(CallSiteInfo));
        else
            delete [] (BYTE*)this;
    }
}


//-------------------------------------------------------------------
// Stub allocation done here.
//-------------------------------------------------------------------
/*static*/ Stub* Stub::NewStub(LoaderHeap *pHeap, UINT numCodeBytes, 
                               BOOL intercept, BOOL callSiteInfo, BOOL fMC)
{

	COUNTER_ONLY(GetPrivatePerfCounters().m_Interop.cStubs++);
	COUNTER_ONLY(GetGlobalPerfCounters().m_Interop.cStubs++);


    SIZE_T size = sizeof(Stub) + numCodeBytes;
    SIZE_T cbIntercept = sizeof(Stub *) + sizeof(void*);

    if (intercept)
        size += cbIntercept;
    
    if (callSiteInfo)
        size += sizeof(CallSiteInfo);

    BYTE *pBlock;
    if (pHeap == NULL)
        pBlock = new BYTE[size];
    else
        pBlock = (BYTE*) pHeap->AllocMem(size);

    if (pBlock == NULL)
        return NULL;

    if (callSiteInfo)
        pBlock += sizeof(CallSiteInfo);

    if (intercept)
        pBlock += cbIntercept;
    
    Stub* pStub = (Stub*) pBlock;

    pStub->SetupStub(numCodeBytes, intercept, pHeap != NULL, callSiteInfo, fMC);

    return pStub;
}


void Stub::SetupStub(int numCodeBytes, BOOL fIntercepted, BOOL fLoaderHeap, 
                     BOOL fCallSiteInfo, BOOL fMulticast)
{
#ifdef _DEBUG
    m_signature = kUsedStub;
    m_numCodeBytes = numCodeBytes;
#endif

    m_refcount = 0;
    m_patchOffset = 0;
    if(fIntercepted)
        m_patchOffset |= INTERCEPT_BIT;
    if(fLoaderHeap)
        m_patchOffset |= LOADER_HEAP_BIT;
    if(fMulticast)
        m_patchOffset |= MULTICAST_DELEGATE_BIT;
    if(fCallSiteInfo)
    {
        m_patchOffset |= CALL_SITE_BIT;

        CallSiteInfo *info = GetCallSiteInfo();
        info->returnOffset = 0;
        info->stackSize = 0;
    }
    
//#ifdef _ALPHA_
//    InitializeCriticalSection(&pStub->m_CriticalSection);
//#endif
    
}

//-------------------------------------------------------------------
// One-time init
//-------------------------------------------------------------------
/*static*/ BOOL Stub::Init()
{
    // There had better be space for both sub-fields, and 
    // they can't overlap
    _ASSERTE((MCD_SIZE_MASK & PATCH_OFFSET_MASK) != 0);
    _ASSERTE(((MCD_PATCH_OFFSET_MASK << MCD_PATCH_OFFSET_SHIFT) & PATCH_OFFSET_MASK) != 0);
    _ASSERTE((MCD_SIZE_MASK & (MCD_PATCH_OFFSET_MASK << MCD_PATCH_OFFSET_SHIFT)) == 0);
    
#ifdef _DEBUG
    if (NULL == (m_pStubTrackerCrst = new (&m_StubTrackerCrstMemory) Crst("StubTracker", CrstStubTracker))) {
        return FALSE;
    }
#endif
    return TRUE;
}


//-------------------------------------------------------------------
// One-time cleanup
//-------------------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
/*static*/ VOID Stub::Terminate()
{
#ifdef _DEBUG
    Stub *pstub = m_pTrackingList;
    while (pstub) {
        Stub* pnext = pstub->m_Next;
#ifdef _ALPHA_
        DeleteCriticalSection(&pstub->m_CriticalSection);
#endif
        if((pstub->m_patchOffset & INTERCEPT_BIT) != 0) 
            ((InterceptStub*)pstub)->DeleteStub();
        else
            pstub->DeleteStub();
        pstub = pnext;
    }
    delete m_pStubTrackerCrst;
    m_pStubTrackerCrst = NULL;
    m_pTrackingList = NULL;
    
#endif
}
#endif /* SHOULD_WE_CLEANUP */

//-------------------------------------------------------------------
// Stub allocation done here.
//-------------------------------------------------------------------
/*static*/ Stub* InterceptStub::NewInterceptedStub(LoaderHeap *pHeap,
                                                   UINT numCodeBytes, 
                                                   Stub* interceptee, 
                                                   void* pRealAddr,
                                                   BOOL callSiteInfo)
{
    InterceptStub *pStub = (InterceptStub *) 
      NewStub(pHeap, numCodeBytes, TRUE, callSiteInfo);

    if (pStub == NULL) 
        return NULL;

    *pStub->GetInterceptedStub() = interceptee;
    *pStub->GetRealAddr() = (BYTE *)pRealAddr;

    LOG((LF_CORDB, LL_INFO10000, "For Stub 0x%x, set intercepted stub to 0x%x\n", 
        pStub, interceptee));

    return pStub;
}

//-------------------------------------------------------------------
// Delete the stub
//-------------------------------------------------------------------
void InterceptStub::DeleteStub()
{
    /* Allocated on the heap
    if(m_patchOffset & CALL_SITE_BIT)
        delete [] ((BYTE*)this - GetNegativeOffset() - sizeof(CallSiteInfo));
    else
        delete [] ((BYTE*)this - GetNegativeOffset());
    */
}

//-------------------------------------------------------------------
// Release the stub that is owned by this stub
//-------------------------------------------------------------------
void InterceptStub::ReleaseInterceptedStub()
{
    Stub** intercepted = GetInterceptedStub();
    // If we own the stub then decrement it. It can be null if the
    // linked stub is actually a jitted stub.
    if(*intercepted)
        (*intercepted)->DecRef();
}

//-------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------
ArgBasedStubCache::ArgBasedStubCache(UINT fixedSlots)
        : m_numFixedSlots(fixedSlots), m_crst("ArgBasedSlotCache", CrstArgBasedStubCache)
{
    m_aStub = new Stub * [m_numFixedSlots];
    _ASSERTE(m_aStub != NULL);

    for (unsigned __int32 i = 0; i < m_numFixedSlots; i++) {
        m_aStub[i] = NULL;
    }
    m_pSlotEntries = NULL;
}


//-------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------
ArgBasedStubCache::~ArgBasedStubCache()
{
    for (unsigned __int32 i = 0; i < m_numFixedSlots; i++) {
        Stub *pStub = m_aStub[i];
        if (pStub) {
            pStub->DecRef();
        }
    }
    SlotEntry **ppSlotEntry = &m_pSlotEntries;
    SlotEntry *pCur;
    while (NULL != (pCur = *ppSlotEntry)) {
        Stub *pStub = pCur->m_pStub;
        pStub->DecRef();
        *ppSlotEntry = pCur->m_pNext;
        delete pCur;
    }
    delete [] m_aStub;
}



//-------------------------------------------------------------------
// Queries/retrieves a previously cached stub.
//
// If there is no stub corresponding to the given index,
//   this function returns NULL.
//
// Otherwise, this function returns the stub after
//   incrementing its refcount.
//-------------------------------------------------------------------
Stub *ArgBasedStubCache::GetStub(unsigned __int32 key)
{
    Stub *pStub;

    m_crst.Enter();
    if (key < m_numFixedSlots) {
        pStub = m_aStub[key];
    } else {
        pStub = NULL;
        for (SlotEntry *pSlotEntry = m_pSlotEntries;
             pSlotEntry != NULL;
             pSlotEntry = pSlotEntry->m_pNext) {

            if (pSlotEntry->m_key == key) {
                pStub = pSlotEntry->m_pStub;
                break;
            }
        }
    }
    if (pStub) {
        pStub->IncRef();
    }
    m_crst.Leave();
    return pStub;
}


//-------------------------------------------------------------------
// Tries to associate a stub with a given index. This association
// may fail because some other thread may have beaten you to it
// just before you make the call.
//
// If the association succeeds, "pStub" is installed, and it is
// returned back to the caller. The stub's refcount is incremented
// twice (one to reflect the cache's ownership, and one to reflect
// the caller's ownership.)
//
// If the association fails because another stub is already installed,
// then the incumbent stub is returned to the caller and its refcount
// is incremented once (to reflect the caller's ownership.)
//
// If the association fails due to lack of memory, NULL is returned
// and no one's refcount changes.
//
// This routine is intended to be called like this:
//
//    Stub *pCandidate = MakeStub();  // after this, pCandidate's rc is 1
//    Stub *pWinner = cache->SetStub(idx, pCandidate);
//    pCandidate->DecRef();
//    pCandidate = 0xcccccccc;     // must not use pCandidate again.
//    if (!pWinner) {
//          OutOfMemoryError;
//    }
//    // If the association succeeded, pWinner's refcount is 2 and so
//    // is pCandidate's (because it *is* pWinner);.
//    // If the association failed, pWinner's refcount is still 2
//    // and pCandidate got destroyed by the last DecRef().
//    // Either way, pWinner is now the official index holder. It
//    // has a refcount of 2 (one for the cache's ownership, and
//    // one belonging to this code.)
//-------------------------------------------------------------------
Stub* ArgBasedStubCache::AttemptToSetStub(unsigned __int32 key, Stub *pStub)
{
    m_crst.Enter();
    if (key < m_numFixedSlots) {
        if (m_aStub[key]) {
            pStub = m_aStub[key];
        } else {
            m_aStub[key] = pStub;
            pStub->IncRef();   // IncRef on cache's behalf
        }
    } else {
        for (SlotEntry *pSlotEntry = m_pSlotEntries;
             pSlotEntry != NULL;
             pSlotEntry = pSlotEntry->m_pNext) {

            if (pSlotEntry->m_key == key) {
                pStub = pSlotEntry->m_pStub;
                break;
            }
        }
        if (!pSlotEntry) {
            SlotEntry *pSlotEntry = new SlotEntry;
            if (!pSlotEntry) {
                pStub = NULL;
            } else {
                pSlotEntry->m_pStub = pStub;
                pStub->IncRef();   // IncRef on cache's behalf
                pSlotEntry->m_key = key;
                pSlotEntry->m_pNext = m_pSlotEntries;
                m_pSlotEntries = pSlotEntry;
            }
        }
    }
    if (pStub) {
        pStub->IncRef();  // IncRef because we're returning it to caller
    }
    m_crst.Leave();
    return pStub;
}



//-------------------------------------------------------------------
// This goes through and eliminates cache entries for stubs
// that look unused based on their refcount. Eliminating the
// cache entry does not necessarily destroy the stub (the
// cache only undoes its initial IncRef.)
//-------------------------------------------------------------------
VOID ArgBasedStubCache::FreeUnusedStubs()
{
    m_crst.Enter();
    for (unsigned __int32 i = 0; i < m_numFixedSlots; i++) {
        Stub *pStub = m_aStub[i];
        if (pStub && pStub->HeuristicLooksOrphaned()) {
            pStub->DecRef();
            m_aStub[i] = NULL;
        }
    }
    SlotEntry **ppSlotEntry = &m_pSlotEntries;
    SlotEntry *pCur;
    while (NULL != (pCur = *ppSlotEntry)) {
        Stub *pStub = pCur->m_pStub;
        if (pStub && pStub->HeuristicLooksOrphaned()) {
            pStub->DecRef();
            *ppSlotEntry = pCur->m_pNext;
            delete pCur;
        } else {
            ppSlotEntry = &(pCur->m_pNext);
        }
    }
    m_crst.Leave();
}





//-------------------------------------------------------------------
// ForceDeleteStubs
//
// Forces all cached stubs to free themselves. This routine forces the refcount
// to 1, then does a DecRef. It is not threadsafe, and thus can
// only be used in shutdown scenarios.
//-------------------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
VOID ArgBasedStubCache::ForceDeleteStubs()
{
    m_crst.Enter();
    for (unsigned __int32 i = 0; i < m_numFixedSlots; i++) {
        Stub *pStub = m_aStub[i];
        if (pStub) {
            pStub->ForceDelete();
            m_aStub[i] = NULL;
        }
    }
    SlotEntry **ppSlotEntry = &m_pSlotEntries;
    SlotEntry *pCur;
    while (NULL != (pCur = *ppSlotEntry)) {
        Stub *pStub = pCur->m_pStub;
        if (pStub) {
            pStub->ForceDelete();
        }
        *ppSlotEntry = pCur->m_pNext;
        delete pCur;
    }
    m_crst.Leave();
}
#endif /* SHOULD_WE_CLEANUP */


//-------------------------------------------------------------------
// Search through the array and list of stubs looking for the one
// with the given entry point. Returns NULL if no stub with this
// entry point exists.
//-------------------------------------------------------------------
Stub* ArgBasedStubCache::FindStubByAddress(const BYTE* entrypoint)
{
    unsigned int i;

    for (i = 0; i < m_numFixedSlots; i++)
    {
        Stub* pStub = m_aStub[i];

        if (pStub != NULL)
            if (pStub->GetEntryPoint() == entrypoint)
                return pStub;
    }

    SlotEntry* pSlotEntry;

    for (pSlotEntry = m_pSlotEntries; pSlotEntry != NULL;
         pSlotEntry = pSlotEntry->m_pNext)
        if (pSlotEntry->m_pStub->GetEntryPoint() == entrypoint)
            return pSlotEntry->m_pStub;

    return NULL;
}


#ifdef _DEBUG
// Diagnostic dump
VOID ArgBasedStubCache::Dump()
{
    printf("--------------------------------------------------------------\n");
    printf("ArgBasedStubCache dump (%lu fixed entries):\n", m_numFixedSlots);
    for (UINT32 i = 0; i < m_numFixedSlots; i++) {

        printf("  Fixed slot %lu: ", (ULONG)i);
        Stub *pStub = m_aStub[i];
        if (!pStub) {
            printf("empty\n");
        } else {
            printf("%lxh   - refcount is %lu\n",
                   (size_t)(pStub->GetEntryPoint()),
                   (ULONG)( *( ( ((ULONG*)(pStub->GetEntryPoint())) - 1))));
        }
    }

    for (SlotEntry *pSlotEntry = m_pSlotEntries;
         pSlotEntry != NULL;
         pSlotEntry = pSlotEntry->m_pNext) {

        printf("  Dyna. slot %lu: ", (ULONG)(pSlotEntry->m_key));
        Stub *pStub = pSlotEntry->m_pStub;
        printf("%lxh   - refcount is %lu\n",
               (size_t)(pStub->GetEntryPoint()),
               (ULONG)( *( ( ((ULONG*)(pStub->GetEntryPoint())) - 1))));

    }


    printf("--------------------------------------------------------------\n");
}
#endif




// Retrieves or creates the stub. Does not bump the stub's refcount.
// Never returns NULL but may throw COM+ exception.
Stub *LazyStubMaker::TheStub()
{
    THROWSCOMPLUSEXCEPTION();

    if (m_pStub == NULL) {

        CPUSTUBLINKER *psl = NewCPUSTUBLINKER();
        if (!psl) {
            COMPlusThrowOM();
        }

        COMPLUS_TRY {

            CreateWorker(psl);
            Stub *pStub = psl->Link(SystemDomain::System()->GetHighFrequencyHeap());
            if (VipInterlockedCompareExchange( (void*volatile*)&m_pStub, pStub, NULL ) != NULL) {
                pStub->DecRef();
            } else {
                m_pCrst->Enter();
                m_pNext = m_pFirst;
                m_pFirst = this;
                m_pCrst->Leave();
            }

        } COMPLUS_CATCH {
            delete psl;
            COMPlusThrow(GETTHROWABLE());
        } COMPLUS_END_CATCH
        delete psl;
    }

    _ASSERTE(m_pStub);
    return m_pStub;
}


// One-time init
/*static*/ BOOL LazyStubMaker::Init()
{
    m_pFirst = NULL;
    if (NULL == (m_pCrst = new (&m_CrstMemory) Crst("LazyStubMakerList", CrstLazyStubMakerList))) {
        return FALSE;
    }
    return TRUE;
}

// One-time cleanup.
#ifdef SHOULD_WE_CLEANUP
void LazyStubMaker::Terminate()
{
    for (LazyStubMaker *pMaker = m_pFirst; pMaker; pMaker = pMaker->m_pNext) {
        pMaker->m_pStub->DecRef();
    }
    delete m_pCrst;
    m_pCrst = NULL;
    m_pFirst = NULL;
}
#endif /* SHOULD_WE_CLEANUP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stringliteralmap.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Map used for interning of string literals.
**  
**      //  %%Created by: dmortens
===========================================================*/

#include "common.h"
#include "EEConfig.h"
#include "StringLiteralMap.h"

#define GLOBAL_STRING_TABLE_BUCKET_SIZE 512
#define INIT_NUM_APP_DOMAIN_STRING_BUCKETS 59
#define INIT_NUM_GLOBAL_STRING_BUCKETS 131

#ifdef _DEBUG
int g_LeakDetectionPoisonCheck = 0;
#endif

// assumes that memory pools's per block data is same as sizeof (StringLiteralEntry) so allocates one less in the hope of getting a page worth.
#define EEHASH_MEMORY_POOL_GROW_COUNT (PAGE_SIZE/SIZEOF_EEHASH_ENTRY)-1

StringLiteralEntryArray *StringLiteralEntry::s_EntryList = NULL;
DWORD StringLiteralEntry::s_UsedEntries = NULL;
StringLiteralEntry *StringLiteralEntry::s_FreeEntryList = NULL;

AppDomainStringLiteralMap::AppDomainStringLiteralMap(BaseDomain *pDomain)
: m_HashTableVersion(0)
, m_HashTableCrst("AppDomainStringLiteralMap", CrstAppDomainStrLiteralMap)
, m_pDomain(pDomain)
, m_MemoryPool(NULL)
, m_StringToEntryHashTable(NULL)
{
	// Allocate the memory pool and set the initial count to same as grow count
	m_MemoryPool = (MemoryPool*) new MemoryPool (SIZEOF_EEHASH_ENTRY, EEHASH_MEMORY_POOL_GROW_COUNT, EEHASH_MEMORY_POOL_GROW_COUNT);
	m_StringToEntryHashTable = (EEUnicodeStringLiteralHashTable*) new EEUnicodeStringLiteralHashTable ();
}

HRESULT AppDomainStringLiteralMap::Init()
{
    LockOwner lock = {&m_HashTableCrst, IsOwnerOfCrst};
    if (!m_StringToEntryHashTable->Init(INIT_NUM_APP_DOMAIN_STRING_BUCKETS, &lock, m_MemoryPool))
        return E_OUTOFMEMORY;

    return S_OK;
}

AppDomainStringLiteralMap::~AppDomainStringLiteralMap()
{
    StringLiteralEntry *pEntry = NULL;
    EEStringData *pStringData = NULL;
    EEHashTableIteration Iter;

    // Iterate through the hash table and release all the string literal entries.
    // This doesn't have to be sunchronized since the deletion of the 
    // AppDomainStringLiteralMap happens when the EE is suspended.
    // But note that we remember the current entry and relaese it only when the 
    // enumerator has advanced to the next entry so that we don't endup deleteing the
    // current entry itself and killing the enumerator.
    m_StringToEntryHashTable->IterateStart(&Iter);
    if (m_StringToEntryHashTable->IterateNext(&Iter))
    {
        pEntry = (StringLiteralEntry*)m_StringToEntryHashTable->IterateGetValue(&Iter);

        while (m_StringToEntryHashTable->IterateNext(&Iter))
        {
            // Release the previous entry
            _ASSERTE(pEntry);
            pEntry->Release();

            // Set the 
            pEntry = (StringLiteralEntry*)m_StringToEntryHashTable->IterateGetValue(&Iter);
        }
        // Release the last entry
        _ASSERTE(pEntry);
        pEntry->Release();
    }
    // else there were no entries.

	// Delete the hash table first. The dtor of the hash table would clean up all the entries.
	delete m_StringToEntryHashTable;
	// Delete the pool later, since the dtor above would need it.
	delete m_MemoryPool;
}

STRINGREF *AppDomainStringLiteralMap::GetStringLiteral(EEStringData *pStringData, BOOL bAddIfNotFound, BOOL bAppDomainWontUnload)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pStringData);

    // Save the current version.
    int CurrentHashTableVersion = m_HashTableVersion;

    STRINGREF *pStrObj = NULL;
    HashDatum Data;

	DWORD dwHash = m_StringToEntryHashTable->GetHash(pStringData);
    if (m_StringToEntryHashTable->GetValue(pStringData, &Data, dwHash))
    {
        pStrObj = ((StringLiteralEntry*)Data)->GetStringObject();
    }
    else
    {
        Thread *pThread = SetupThread();
        if (NULL == pThread)
            COMPlusThrowOM();   

#ifdef _DEBUG
        // Increment the poison check so that we don't try to do leak detection halfway
        // through adding a string literal entry.
        FastInterlockIncrement((LONG*)&g_LeakDetectionPoisonCheck);
#endif

        // Retrieve the string literal from the global string literal map.
        StringLiteralEntry *pEntry = SystemDomain::GetGlobalStringLiteralMap()->GetStringLiteral(pStringData, dwHash, bAddIfNotFound);

        _ASSERTE(pEntry || !bAddIfNotFound);

        // If pEntry is non-null then the entry exists in the Global map. (either we retrieved it or added it just now)
        if (pEntry)
        {
            // If the entry exists in the Global map and the appdomain wont ever unload then we really don't need to add a
            // hashentry in the appdomain specific map.
            if (!bAppDomainWontUnload)
            {
                // Enter preemptive state, take the lock and go back to cooperative mode.
                pThread->EnablePreemptiveGC();
                m_HashTableCrst.Enter();
                pThread->DisablePreemptiveGC();

                EE_TRY_FOR_FINALLY
                {
                    // Make sure some other thread has not already added it.
                    if ((CurrentHashTableVersion == m_HashTableVersion) || !m_StringToEntryHashTable->GetValue(pStringData, &Data))
                    {
                        // Insert the handle to the string into the hash table.
                        m_StringToEntryHashTable->InsertValue(pStringData, (LPVOID)pEntry, FALSE);

                        // Update the version of the string hash table.
                        m_HashTableVersion++;
                    }
                    else
                    {
                        // The string has already been added to the app domain hash
                        // table so we need to release it since the entry was addrefed
                        // by GlobalStringLiteralMap::GetStringLiteral().
                        pEntry->Release();
                    }


                }
                EE_FINALLY
                {
                    m_HashTableCrst.Leave();
                } 
                EE_END_FINALLY
            }
#ifdef _DEBUG
            else
            {
                LOG((LF_APPDOMAIN, LL_INFO10000, "Avoided adding String literal to appdomain map: size: %d bytes\n", pStringData->GetCharCount()));
            }
#endif
            
            // Retrieve the string objectref from the string literal entry.
            pStrObj = pEntry->GetStringObject();
        }
#ifdef _DEBUG
        // We finished adding the entry so we can decrement the poison check.
        FastInterlockDecrement((LONG*)&g_LeakDetectionPoisonCheck);
#endif
    }

    // If the bAddIfNotFound flag is set then we better have a string
    // string object at this point.
    _ASSERTE(!bAddIfNotFound || pStrObj);


    return pStrObj;
}

STRINGREF *AppDomainStringLiteralMap::GetInternedString(STRINGREF *pString, BOOL bAddIfNotFound, BOOL bAppDomainWontUnload)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pString);

    // Save the current version.
    int CurrentHashTableVersion = m_HashTableVersion;

    STRINGREF *pStrObj = NULL;
    HashDatum Data;
    EEStringData StringData = EEStringData((*pString)->GetStringLength(), (*pString)->GetBuffer());

	DWORD dwHash = m_StringToEntryHashTable->GetHash(&StringData);
    if (m_StringToEntryHashTable->GetValue(&StringData, &Data, dwHash))
    {
        pStrObj = ((StringLiteralEntry*)Data)->GetStringObject();
    }
    else
    {
        Thread *pThread = SetupThread();
        if (NULL == pThread)
            COMPlusThrowOM();   

#ifdef _DEBUG
        // Increment the poison check so that we don't try to do leak detection halfway
        // through adding a string literal entry.
        FastInterlockIncrement((LONG*)&g_LeakDetectionPoisonCheck);
#endif

        // Retrieve the string literal from the global string literal map.
        StringLiteralEntry *pEntry = SystemDomain::GetGlobalStringLiteralMap()->GetInternedString(pString, dwHash, bAddIfNotFound);

        _ASSERTE(pEntry || !bAddIfNotFound);

        // If pEntry is non-null then the entry exists in the Global map. (either we retrieved it or added it just now)
        if (pEntry)
        {
            // If the entry exists in the Global map and the appdomain wont ever unload then we really don't need to add a
            // hashentry in the appdomain specific map.
            if (!bAppDomainWontUnload)
            {
                // Enter preemptive state, take the lock and go back to cooperative mode.
                pThread->EnablePreemptiveGC();
                m_HashTableCrst.Enter();
                pThread->DisablePreemptiveGC();

                EE_TRY_FOR_FINALLY
                {
                    // Since GlobalStringLiteralMap::GetInternedString() could have caused a GC,
                    // we need to recreate the string data.
                    StringData = EEStringData((*pString)->GetStringLength(), (*pString)->GetBuffer());

                    // Make sure some other thread has not already added it.
                    if ((CurrentHashTableVersion == m_HashTableVersion) || !m_StringToEntryHashTable->GetValue(&StringData, &Data))
                    {
                        // Insert the handle to the string into the hash table.
                        m_StringToEntryHashTable->InsertValue(&StringData, (LPVOID)pEntry, FALSE);

                        // Update the version of the string hash table.
                        m_HashTableVersion++;
                    }
                    else
                    {
                        // The string has already been added to the app domain hash
                        // table so we need to release it since the entry was addrefed
                        // by GlobalStringLiteralMap::GetStringLiteral().
                        pEntry->Release();
                    }

                }
                EE_FINALLY
                {
                    m_HashTableCrst.Leave();
                } 
                EE_END_FINALLY

            }
            // Retrieve the string objectref from the string literal entry.
            pStrObj = pEntry->GetStringObject();
        }
#ifdef _DEBUG
        // We finished adding the entry so we can decrement the poison check.
        FastInterlockDecrement((LONG*)&g_LeakDetectionPoisonCheck);
#endif
    }

    // If the bAddIfNotFound flag is set then we better have a string
    // string object at this point.
    _ASSERTE(!bAddIfNotFound || pStrObj);

    return pStrObj;
}

GlobalStringLiteralMap::GlobalStringLiteralMap()
: m_HashTableVersion(0)
, m_HashTableCrst("GlobalStringLiteralMap", CrstGlobalStrLiteralMap)
, m_LargeHeapHandleTable(SystemDomain::System(), GLOBAL_STRING_TABLE_BUCKET_SIZE)
, m_MemoryPool(NULL)
, m_StringToEntryHashTable(NULL)
{
	// Allocate the memory pool and set the initial count to same as grow count
	m_MemoryPool = (MemoryPool*) new MemoryPool (SIZEOF_EEHASH_ENTRY, EEHASH_MEMORY_POOL_GROW_COUNT, EEHASH_MEMORY_POOL_GROW_COUNT);
	m_StringToEntryHashTable = (EEUnicodeStringLiteralHashTable*) new EEUnicodeStringLiteralHashTable ();
}

GlobalStringLiteralMap::~GlobalStringLiteralMap()
{
    _ASSERTE(g_fProcessDetach);

    // Once the global string literal map gets deleted the hashtable
    // should contain only entries which were allocated from non unloadable
    // appdomains.
    StringLiteralEntry *pEntry = NULL;
    EEStringData *pStringData = NULL;
    EEHashTableIteration Iter;

    // Iterate through the hash table and release all the string literal entries.
    // This doesn't have to be sunchronized since the deletion of the 
    // GlobalStringLiteralMap happens when the EE is shuting down.
    // But note that we remember the current entry and release it only when the 
    // enumerator has advanced to the next entry so that we don't endup deleteing the
    // current entry itself and killing the enumerator.
    m_StringToEntryHashTable->IterateStart(&Iter);
    if (m_StringToEntryHashTable->IterateNext(&Iter))
    {
        pEntry = (StringLiteralEntry*)m_StringToEntryHashTable->IterateGetValue(&Iter);

        while (m_StringToEntryHashTable->IterateNext(&Iter))
        {
            // Release the previous entry. We call ForceRelease to ignore the
            // ref count since its shutdown. THe ref count can be > 1 because multiple
            // agile appdomains could have AddRef'd this string literal.
            // Also ForceRelease would call back into the GlobalStringLiteralMap's 
            // RemoveStringLiteralEntry but no need to synchronize since we just hold onto the
            // next entry ptr.
            _ASSERTE(pEntry);
            pEntry->ForceRelease();

            pEntry = (StringLiteralEntry*)m_StringToEntryHashTable->IterateGetValue(&Iter);
        }
        // Release the last entry
        _ASSERTE(pEntry);
        pEntry->ForceRelease();
    }
    // else there were no entries.

    // delete all the chunks that we allocated 
    StringLiteralEntry::DeleteEntryArrayList();

    // After forcing release of all the string literal entries, delete the hash table and all the hash entries
    // in it.
    m_StringToEntryHashTable->ClearHashTable();

	// Delete the hash table first. The dtor of the hash table would clean up all the entries.
	delete m_StringToEntryHashTable;
	// Delete the pool later, since the dtor above would need it.
	delete m_MemoryPool;
}

HRESULT GlobalStringLiteralMap::Init()
{
    LockOwner lock = {&m_HashTableCrst, IsOwnerOfCrst};
    if (!m_StringToEntryHashTable->Init(INIT_NUM_GLOBAL_STRING_BUCKETS, &lock, m_MemoryPool))
        return E_OUTOFMEMORY;

    return S_OK;
}

StringLiteralEntry *GlobalStringLiteralMap::GetStringLiteral(EEStringData *pStringData, BOOL bAddIfNotFound)
{
    _ASSERTE(pStringData);

    // Save the current version.
    int CurrentHashTableVersion = m_HashTableVersion;

    HashDatum Data;
    StringLiteralEntry *pEntry = NULL;

    if (m_StringToEntryHashTable->GetValue(pStringData, &Data))
    {
        pEntry = (StringLiteralEntry*)Data;
    }
    else
    {
        if (bAddIfNotFound)
            pEntry = AddStringLiteral(pStringData, CurrentHashTableVersion);
    }

    // If we managed to get the entry then addref it before we return it.
    if (pEntry)
        pEntry->AddRef();

    return pEntry;
}
// Added for perf. Same semantics as GetStringLiteral but avoids recomputation of the hash
StringLiteralEntry *GlobalStringLiteralMap::GetStringLiteral(EEStringData *pStringData, DWORD dwHash, BOOL bAddIfNotFound)
{
    _ASSERTE(pStringData);

    // Save the current version.
    int CurrentHashTableVersion = m_HashTableVersion;

    HashDatum Data;
    StringLiteralEntry *pEntry = NULL;

    if (m_StringToEntryHashTable->GetValue(pStringData, &Data, dwHash))
    {
        pEntry = (StringLiteralEntry*)Data;
    }
    else
    {
        if (bAddIfNotFound)
            pEntry = AddStringLiteral(pStringData, CurrentHashTableVersion);
    }

    // If we managed to get the entry then addref it before we return it.
    if (pEntry)
        pEntry->AddRef();

    return pEntry;
}

StringLiteralEntry *GlobalStringLiteralMap::GetInternedString(STRINGREF *pString, BOOL bAddIfNotFound)
{
    _ASSERTE(pString);
    EEStringData StringData = EEStringData((*pString)->GetStringLength(), (*pString)->GetBuffer());

    // Save the current version.
    int CurrentHashTableVersion = m_HashTableVersion;

    HashDatum Data;
    StringLiteralEntry *pEntry = NULL;

    if (m_StringToEntryHashTable->GetValue(&StringData, &Data))
    {
        pEntry = (StringLiteralEntry*)Data;
    }
    else
    {
        if (bAddIfNotFound)
            pEntry = AddInternedString(pString, CurrentHashTableVersion);
    }

    // If we managed to get the entry then addref it before we return it.
    if (pEntry)
        pEntry->AddRef();

    return pEntry;
}

StringLiteralEntry *GlobalStringLiteralMap::GetInternedString(STRINGREF *pString, DWORD dwHash, BOOL bAddIfNotFound)
{
    _ASSERTE(pString);
    EEStringData StringData = EEStringData((*pString)->GetStringLength(), (*pString)->GetBuffer());

    // Save the current version.
    int CurrentHashTableVersion = m_HashTableVersion;

    HashDatum Data;
    StringLiteralEntry *pEntry = NULL;

    if (m_StringToEntryHashTable->GetValue(&StringData, &Data, dwHash))
    {
        pEntry = (StringLiteralEntry*)Data;
    }
    else
    {
        if (bAddIfNotFound)
            pEntry = AddInternedString(pString, CurrentHashTableVersion);
    }

    // If we managed to get the entry then addref it before we return it.
    if (pEntry)
        pEntry->AddRef();

    return pEntry;
}
StringLiteralEntry *GlobalStringLiteralMap::AddStringLiteral(EEStringData *pStringData, int CurrentHashTableVersion)
{
    THROWSCOMPLUSEXCEPTION();

    HashDatum Data;
    StringLiteralEntry *pEntry = NULL;

    Thread *pThread = SetupThread();
    if (NULL == pThread)
        COMPlusThrowOM();   

    // Enter preemptive state, take the lock and go back to cooperative mode.
    pThread->EnablePreemptiveGC();
    m_HashTableCrst.Enter();
    pThread->DisablePreemptiveGC();

    EE_TRY_FOR_FINALLY
    {
        // Make sure some other thread has not already added it.
        if ((CurrentHashTableVersion == m_HashTableVersion) || !m_StringToEntryHashTable->GetValue(pStringData, &Data))
        {
            STRINGREF *pStrObj;   

            // Create the COM+ string object.
            STRINGREF strObj = AllocateString(pStringData->GetCharCount() + 1);
            GCPROTECT_BEGIN(strObj)
            {
                if (!strObj)
                    COMPlusThrowOM();

                // Copy the string constant into the COM+ string object.  The code
                // will add an extra null at the end for safety purposes, but since
                // we support embedded nulls, one should never treat the string as
                // null termianted.
                LPWSTR strDest = strObj->GetBuffer();
                memcpyNoGCRefs(strDest, pStringData->GetStringBuffer(), pStringData->GetCharCount()*sizeof(WCHAR));
                strDest[pStringData->GetCharCount()] = 0;
                strObj->SetStringLength(pStringData->GetCharCount());
            
                // Set the bit to indicate if any of the chars in this string are greater than 0x7F
                // The actual check that we do in Emit.cpp is insufficient to determine if the string
                // is STRING_STATE_SPECIAL_SORT or is STRING_STATE_HIGH_CHARS, so we'll only set the bit
                // if we know that it's STRING_STATE_FAST_OPS.
                if (pStringData->GetIsOnlyLowChars()) {
                    strObj->SetHighCharState(STRING_STATE_FAST_OPS);
                }

                // Allocate a handle for the string.
                m_LargeHeapHandleTable.AllocateHandles(1, (OBJECTREF**)&pStrObj);
                SetObjectReference((OBJECTREF*)pStrObj, (OBJECTREF) strObj, NULL);
            }
            GCPROTECT_END();

            // Allocate the StringLiteralEntry.
            pEntry = StringLiteralEntry::AllocateEntry(pStringData, pStrObj);
            if (!pEntry)
                COMPlusThrowOM();

            // Insert the handle to the string into the hash table.
            m_StringToEntryHashTable->InsertValue(pStringData, (LPVOID)pEntry, FALSE);

            LOG((LF_APPDOMAIN, LL_INFO10000, "String literal \"%S\" added to Global map, size %d bytes\n", pStringData->GetStringBuffer(), pStringData->GetCharCount()));
            // Update the version of the string hash table.
            m_HashTableVersion++;
        }
        else
        {
            pEntry = ((StringLiteralEntry*)Data);
        }
    }
    EE_FINALLY
    {
        m_HashTableCrst.Leave();
    } EE_END_FINALLY

    return pEntry;
}

StringLiteralEntry *GlobalStringLiteralMap::AddInternedString(STRINGREF *pString, int CurrentHashTableVersion)
{
    THROWSCOMPLUSEXCEPTION();

    HashDatum Data;
    StringLiteralEntry *pEntry = NULL;

    Thread *pThread = SetupThread();
    if (NULL == pThread)
        COMPlusThrowOM();

    // Enter preemptive state, take the lock and go back to cooperative mode.
    pThread->EnablePreemptiveGC();
    m_HashTableCrst.Enter();
    pThread->DisablePreemptiveGC();

    EEStringData StringData = EEStringData((*pString)->GetStringLength(), (*pString)->GetBuffer());
    EE_TRY_FOR_FINALLY
    {
        // Make sure some other thread has not already added it.
        if ((CurrentHashTableVersion == m_HashTableVersion) || !m_StringToEntryHashTable->GetValue(&StringData, &Data))
        {
            STRINGREF *pStrObj;   

            // Allocate a handle for the string.
            m_LargeHeapHandleTable.AllocateHandles(1, (OBJECTREF**)&pStrObj);
            SetObjectReference((OBJECTREF*) pStrObj, (OBJECTREF) *pString, NULL);

            // Since the allocation might have caused a GC we need to re-get the
            // string data.
            StringData = EEStringData((*pString)->GetStringLength(), (*pString)->GetBuffer());

            pEntry = StringLiteralEntry::AllocateEntry(&StringData, pStrObj);
            if (!pEntry)
                COMPlusThrowOM();

            // Insert the handle to the string into the hash table.
            m_StringToEntryHashTable->InsertValue(&StringData, (LPVOID)pEntry, FALSE);

            // Update the version of the string hash table.
            m_HashTableVersion++;
        }
        else
        {
            pEntry = ((StringLiteralEntry*)Data);
        }
    }
    EE_FINALLY
    {
        m_HashTableCrst.Leave();
    } EE_END_FINALLY

    return pEntry;
}

void GlobalStringLiteralMap::RemoveStringLiteralEntry(StringLiteralEntry *pEntry)
{
    EEStringData StringData;

    // Remove the entry from the hash table.
    BEGIN_ENSURE_COOPERATIVE_GC();
    
    pEntry->GetStringData(&StringData);
    BOOL bSuccess = m_StringToEntryHashTable->DeleteValue(&StringData);
    _ASSERTE(bSuccess);

    END_ENSURE_COOPERATIVE_GC();

    // Release the object handle that the entry was using.
    STRINGREF *pObjRef = pEntry->GetStringObject();
    m_LargeHeapHandleTable.ReleaseHandles(1, (OBJECTREF**)&pObjRef);

    LOG((LF_APPDOMAIN, LL_INFO10000, "String literal \"%S\" removed from Global map, size %d bytes\n", StringData.GetStringBuffer(), StringData.GetCharCount()));
    // We do not delete the StringLiteralEntry itself that will be done in the
    // release method of the StringLiteralEntry.
}

StringLiteralEntry *StringLiteralEntry::AllocateEntry(EEStringData *pStringData, STRINGREF *pStringObj)
{
    // Note: we don't synchronize here because allocateEntry is called when HashCrst is held.
    void *pMem = NULL;
    if (s_FreeEntryList != NULL)
    {
        pMem = s_FreeEntryList;
        s_FreeEntryList = s_FreeEntryList->m_pNext;
    }
    else
    {
        if (s_EntryList == NULL || (s_UsedEntries >= MAX_ENTRIES_PER_CHUNK))
        {
            StringLiteralEntryArray *pNew = new StringLiteralEntryArray();
            pNew->m_pNext = s_EntryList;
            s_EntryList = pNew;
            s_UsedEntries = 0;
        }
        pMem = &(s_EntryList->m_Entries[s_UsedEntries++*sizeof(StringLiteralEntry)]);
    }
    _ASSERTE (pMem && "Unable to allocate String literal Entry");
    if (pMem == NULL)
        return NULL;

    return new (pMem) StringLiteralEntry (pStringData, pStringObj);
}

void StringLiteralEntry::DeleteEntry (StringLiteralEntry *pEntry)
{
    // Note; We don't synchronize here because deleting of an entry occurs in appdomain
    // shutdown or eeshutdown 
#ifdef _DEBUG
    memset (pEntry, 0xc, sizeof(StringLiteralEntry));
#endif
    pEntry->m_pNext = s_FreeEntryList;
    s_FreeEntryList = pEntry;

}

void StringLiteralEntry::DeleteEntryArrayList ()
{
    // Note; We don't synchronize here because deleting of an entry occurs in eeshutdown 
    StringLiteralEntryArray *pEntryArray = s_EntryList;
    while (pEntryArray)
    {
        StringLiteralEntryArray *pNext = pEntryArray->m_pNext;
        delete pEntryArray;
        pEntryArray = pNext;
    }
    s_EntryList = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stubmgr.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "stubmgr.h"

StubManager *StubManager::g_pFirstManager = NULL;

StubManager::StubManager()
  : m_pNextManager(NULL)
{
}

StubManager::~StubManager()
{
        StubManager **m = &g_pFirstManager;

        while (*m != this)
                m = &(*m)->m_pNextManager;

        *m = (*m)->m_pNextManager;
}

BOOL StubManager::IsStub(const BYTE *stubAddress)
{
    for (StubManager *m = g_pFirstManager; m != NULL; m = m->m_pNextManager)
    {
        if (m->CheckIsStub(stubAddress))
            return TRUE;
    }

    return FALSE;
}

BOOL StubManager::TraceStub(const BYTE *stubStartAddress, TraceDestination *trace)
{
        for (StubManager *m = g_pFirstManager; m != NULL; m = m->m_pNextManager)
        {
                if (m->CheckIsStub(stubStartAddress))
        {
            LOG((LF_CORDB, LL_INFO10000,
                 "StubManager::TraceStub: addr 0x%08x claimed by mgr "
                 "0x%08x.\n", stubStartAddress, m));
                 
                        return m->DoTraceStub(stubStartAddress, trace);
        }
        }

        if (ExecutionManager::FindCodeMan((SLOT)stubStartAddress) != NULL)
        {
                trace->type = TRACE_MANAGED;
                trace->address = stubStartAddress;

        LOG((LF_CORDB, LL_INFO10000,
             "StubManager::TraceStub: addr 0x%08x is managed code\n",
             stubStartAddress));

                return TRUE;
        }

    LOG((LF_CORDB, LL_INFO10000,
         "StubManager::TraceStub: addr 0x%08x unknown. TRACE_OTHER...\n",
         stubStartAddress));
    
        trace->type = TRACE_OTHER;
        trace->address = stubStartAddress;
        return FALSE;
}

BOOL StubManager::FollowTrace(TraceDestination *trace)
{
        while (trace->type == TRACE_STUB)
        {
        LOG((LF_CORDB, LL_INFO10000,
             "StubManager::FollowTrace: TRACE_STUB for 0x%08x\n",
             trace->address));
        
                if (!TraceStub(trace->address, trace))
                {
                        //
                        // No stub manager claimed it - it must be an EE helper or something.
                        // 

                        trace->type = TRACE_OTHER;
                }
        }

    LOG((LF_CORDB, LL_INFO10000,
         "StubManager::FollowTrace: ended at 0x%08x, "
         "(type != TRACE_OTHER)=%d\n", trace->address,
         trace->type != TRACE_OTHER));
    
        return trace->type != TRACE_OTHER;
}

void StubManager::AddStubManager(StubManager *manager)
{
        manager->m_pNextManager = g_pFirstManager;
        g_pFirstManager = manager;
}

MethodDesc *StubManager::MethodDescFromEntry(const BYTE *stubStartAddress, MethodTable *pMT)
{
    for (StubManager *m = g_pFirstManager; m != NULL; m = m->m_pNextManager)
    {
        MethodDesc *pMD = m->Entry2MethodDesc(stubStartAddress, pMT);
        if (pMD)
            return pMD;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stublink.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// STUBLINK.H -
//
// A StubLinker object provides a way to link several location-independent
// code sources into one executable stub, resolving references,
// and choosing the shortest possible instruction size. The StubLinker
// abstracts out the notion of a "reference" so it is completely CPU
// independent. This StubLinker is intended not only to create method
// stubs but to create the PCode-marshaling stubs for Native/Direct.
//
// A StubLinker's typical life-cycle is:
//
//   1. Create a new StubLinker (it accumulates state for the stub being
//      generated.)
//   2. Emit code bytes and references (requiring fixups) into the StubLinker.
//   3. Call the Link() method to produce the final stub.
//   4. Destroy the StubLinker.
//
// StubLinkers are not multithread-aware: they're intended to be
// used entirely on a single thread. Also, StubLinker's report errors
// using COMPlusThrow. StubLinker's do have a destructor: to prevent
// C++ object unwinding from clashing with COMPlusThrow,
// you must use COMPLUSCATCH to ensure the StubLinker's cleanup in the
// event of an exception: the following code would do it:
//
//  StubLinker stublink;
//  Inner();
//
//
//  // Have to separate into inner function because VC++ forbids
//  // mixing __try & local objects in the same function.
//  void Inner() {
//      COMPLUSTRY {
//          ... do stuff ...
//          pLinker->Link();
//      } COMPLUSCATCH {
//      }
//  }
//


#ifndef __stublink_h__
#define __stublink_h__

#include "crst.h"
#include "util.hpp"

//-------------------------------------------------------------------------
// Forward refs
//-------------------------------------------------------------------------
class  InstructionFormat;
class  Stub;
class  InterceptStub;
struct CodeLabel;

struct CodeRun;
struct LabelRef;
struct CodeElement;


enum StubStyle
{
    kNoTripStubStyle = 0,       // stub doesn't rendezvous the thread on return
    kObjectStubStyle = 1,       // stub will rendezvous & protects an object ref retval
    kScalarStubStyle = 2,       // stub will rendezvous & returns a non-object ref
    kInterceptorStubStyle = 3,  // stub does not does  return but
    kInteriorPointerStubStyle = 4, // stub will rendezvous & protects an interior pointer retval
 // Add more stub styles here...

    kMaxStubStyle    = 5,
};
       

//-------------------------------------------------------------------------
// A non-multithreaded object that fixes up and emits one executable stub.
//-------------------------------------------------------------------------
class StubLinker
{
    public:
        //---------------------------------------------------------------
        // Construction
        //---------------------------------------------------------------
        StubLinker();



        //---------------------------------------------------------------
        // Failable init. Throws COM+ exception on failure.
        //---------------------------------------------------------------
        VOID Init();


        //---------------------------------------------------------------
        // Cleanup.
        //---------------------------------------------------------------
        ~StubLinker();


        //---------------------------------------------------------------
        // Create a new undefined label. Label must be assigned to a code
        // location using EmitLabel() prior to final linking.
        // Throws COM+ exception on failure.
        //---------------------------------------------------------------
        CodeLabel* NewCodeLabel();

        //---------------------------------------------------------------
        // Create a new undefined label for which we want the absolute 
        // address, not offset. Label must be assigned to a code
        // location using EmitLabel() prior to final linking.
        // Throws COM+ exception on failure.
        //---------------------------------------------------------------
        CodeLabel* NewAbsoluteCodeLabel();

        //---------------------------------------------------------------
        // Combines NewCodeLabel() and EmitLabel() for convenience.
        // Throws COM+ exception on failure.
        //---------------------------------------------------------------
        CodeLabel* EmitNewCodeLabel();


        //---------------------------------------------------------------
        // Returns final location of label as an offset from the start
        // of the stub. Can only be called after linkage.
        //---------------------------------------------------------------
        UINT32 GetLabelOffset(CodeLabel *pLabel);

        //---------------------------------------------------------------
        // Append code bytes.
        //---------------------------------------------------------------
        VOID EmitBytes(const BYTE *pBytes, UINT numBytes);
        VOID Emit8 (unsigned __int8  u8);
        VOID Emit16(unsigned __int16 u16);
        VOID Emit32(unsigned __int32 u32);
        VOID Emit64(unsigned __int64 u64);
        VOID EmitPtr(const VOID *pval);

        //---------------------------------------------------------------
        // Emit a UTF8 string
        //---------------------------------------------------------------
        VOID EmitUtf8(LPCUTF8 pUTF8)
        {
            LPCUTF8 p = pUTF8;
            while (*(p++)) {
                //nothing
            }
            EmitBytes((const BYTE *)pUTF8, (unsigned int)(p-pUTF8-1));
        }

        //---------------------------------------------------------------
        // Append an instruction containing a reference to a label.
        //
        //      target             - the label being referenced.
        //      instructionFormat  - a platform-specific InstructionFormat object
        //                           that gives properties about the reference.
        //      variationCode      - uninterpreted data passed to the pInstructionFormat methods.
        //---------------------------------------------------------------
        VOID EmitLabelRef(CodeLabel* target, const InstructionFormat & instructionFormat, UINT variationCode);
                          

        //---------------------------------------------------------------
        // Sets the label to point to the current "instruction pointer"
        // It is invalid to call EmitLabel() twice on
        // the same label.
        //---------------------------------------------------------------
        VOID EmitLabel(CodeLabel* pCodeLabel);

        //---------------------------------------------------------------
        // Emits the patch label for the stub.
        // Throws COM+ exception on failure.
        //---------------------------------------------------------------
        void EmitPatchLabel();

        //---------------------------------------------------------------
        // Emits the debugger intermediate label for the stub.
        // Throws COM+ exception on failure.
        //---------------------------------------------------------------
        VOID EmitDebuggerIntermediateLabel();

        //---------------------------------------------------------------
        // Emits the return label for the stub.
        // Throws COM+ exception on failure.
        //---------------------------------------------------------------
        void EmitReturnLabel();
        
        //---------------------------------------------------------------
        // Create a new label to an external address.
        // Throws COM+ exception on failure.
        //---------------------------------------------------------------
        CodeLabel* NewExternalCodeLabel(LPVOID pExternalAddress);

        //---------------------------------------------------------------
        // Push and Pop can be used to keep track of stack growth.
        // These should be adjusted by opcodes written to the stream.
        //
        // Note that popping & pushing stack size as opcodes are emitted
        // is naive & may not be accurate in many cases, 
        // so complex stubs may have to manually adjust the stack size.  
        // However it should work for the vast majority of cases we care
        // about.
        //---------------------------------------------------------------
        void Push(UINT size) { m_stackSize += size; }
        void Pop(UINT size) { m_stackSize -= size; }
    
        INT GetStackSize() { return m_stackSize; }
        void SetStackSize(SHORT size) { m_stackSize = size; }
        
        //---------------------------------------------------------------
        // Generate the actual stub. The returned stub has a refcount of 1.
        // No other methods (other than the destructor) should be called
        // after calling Link().
        //
        // fMC Set to true if the stub is a multicast delegate, false otherwise
        //
        // Throws COM+ exception on failure.
        //---------------------------------------------------------------
        Stub *Link(UINT *pcbSize = NULL, BOOL fMC = FALSE) { return Link(NULL, pcbSize, fMC); }
        Stub *Link(LoaderHeap *heap, UINT *pcbSize = NULL, BOOL fMC = FALSE);

        //---------------------------------------------------------------
        // Generate the actual stub. The returned stub has a refcount of 1.
        // No other methods (other than the destructor) should be called
        // after calling Link(). The linked stub must have its increment
        // increased by one prior to calling this method. This method
        // does not increment the reference count of the interceptee.
        //
        // Throws COM+ exception on failure.
        //---------------------------------------------------------------
        Stub *LinkInterceptor(Stub* interceptee, void *pRealAddr) 
            { return LinkInterceptor(NULL,interceptee, pRealAddr); }
        Stub *LinkInterceptor(LoaderHeap *heap, Stub* interceptee, void *pRealAddr);

    private:
        CodeElement   *m_pCodeElements;     // stored in *reverse* order
        CodeLabel     *m_pFirstCodeLabel;   // linked list of CodeLabels
        LabelRef      *m_pFirstLabelRef;    // linked list of references
        CodeLabel     *m_pPatchLabel;       // label of stub patch offset
        CodeLabel     *m_pIntermediateDebuggerLabel; // used by the debugger, 
                                            // currently just for multicast 
                                            // frames.
        CodeLabel     *m_pReturnLabel;      // label of stub return offset
        SHORT         m_returnStackSize;    // label of stub stack size 
                                            // @ return label
        SHORT         m_stackSize;          // count of pushes/pops
        CQuickHeap    m_quickHeap;          // throwaway heap for
                                            //   labels, and
                                            //   internals.

        CodeRun *AppendNewEmptyCodeRun();

    
        // Returns pointer to last CodeElement or NULL.
        CodeElement *GetLastCodeElement()
        {
            return m_pCodeElements;
        }
    
        // Appends a new CodeElement. 
        VOID AppendCodeElement(CodeElement *pCodeElement);


        // Calculates the size of the stub code that is allocate
        // immediately after the stub object. Returns the 
        // total size. GlobalSize contains the size without
        // that data part.
        int CalculateSize(int* globalsize);
    
        // Writes out the code element into memory following the
        // stub object.
        void EmitStub(Stub* pStub, int globalsize);

        CodeRun *GetLastCodeRunIfAny();

};

//-------------------------------------------------------------------------
// An executable stub. These can only be created by the StubLinker().
// Each stub has a reference count (which is maintained in a thread-safe
// manner.) When the ref-count goes to zero, the stub automatically
// cleans itself up.
//-------------------------------------------------------------------------
class Stub
{
    protected:
    enum
    {
        // MiPanitz: I moved all these numbers from 
        // MULTICAST_DELEGATE_BIT = 0x00010000,
        // CALL_SITE_BIT          = 0x00008000,etc
        // to their present values.  It seems like it should be ok...
        MULTICAST_DELEGATE_BIT = 0x80000000,
        CALL_SITE_BIT          = 0x40000000,
        LOADER_HEAP_BIT        = 0x20000000,
        INTERCEPT_BIT          = 0x10000000,

        PATCH_OFFSET_MASK       = INTERCEPT_BIT - 1,
        MCD_PATCH_OFFSET_MASK   = 0xFFF,
        MCD_PATCH_OFFSET_SHIFT  = 0x10,
        MCD_SIZE_MASK           = 0xFFFF,
        MAX_PATCH_OFFSET  = PATCH_OFFSET_MASK + 1,
    };


    // CallSiteInfo is allocated before the stub when
    // the CALL_SITE_BIT is set
    struct CallSiteInfo
    {
        USHORT  returnOffset;
        USHORT  stackSize;
    };

    public:
        //-------------------------------------------------------------------
        // Inc the refcount.
        //-------------------------------------------------------------------
        VOID IncRef();


        //-------------------------------------------------------------------
        // Dec the refcount.
        // Returns true if the count went to zero and the stub was deleted
        //-------------------------------------------------------------------
        BOOL DecRef();


        //-------------------------------------------------------------------
        // ForceDelete
        //
        // Forces a stub to free itself. This routine forces the refcount
        // to 1, then does a DecRef. It is not threadsafe, and thus can
        // only be used in shutdown scenarios.
        //-------------------------------------------------------------------
        VOID ForceDelete();



        //-------------------------------------------------------------------
        // Used for throwing out unused stubs from stub caches. This
        // method cannot be 100% accurate due to race conditions. This
        // is ok because stub cache management is robust in the face
        // of missed or premature cleanups.
        //-------------------------------------------------------------------
        BOOL HeuristicLooksOrphaned()
        {
            _ASSERTE(m_signature == kUsedStub);
            return (m_refcount == 1);
        }

        //-------------------------------------------------------------------
        // Used by the debugger to help step through stubs
        //-------------------------------------------------------------------
        BOOL IsIntercept()
        {
            return (m_patchOffset & INTERCEPT_BIT) != 0;
        }

        BOOL IsMulticastDelegate()
        {
            return (m_patchOffset & MULTICAST_DELEGATE_BIT) != 0;
        }

        //-------------------------------------------------------------------
        // For stubs which execute user code, a patch offset needs to be set 
        // to tell the debugger how far into the stub code the debugger has 
        // to step until the frame is set up.
        //-------------------------------------------------------------------
        USHORT GetPatchOffset()
        {
            return (USHORT)(m_patchOffset & PATCH_OFFSET_MASK);
        }

        void SetPatchOffset(USHORT offset)
        {
            _ASSERTE(offset < MAX_PATCH_OFFSET);
            _ASSERTE(GetPatchOffset() == 0);
            m_patchOffset |= offset;
            _ASSERTE(GetPatchOffset() == offset);
        }

        //-------------------------------------------------------------------
        // For multicast delegate stubs, this is positively gross.  We need to store
        // two offsets in the bits remaining in the m_patchOffset field.  
        // See StubLinkStubManager & MulticastFrame::TraceFrame for more info
        //-------------------------------------------------------------------
        USHORT GetMCDPatchOffset();
        USHORT GetMCDStubSize();
        void SetMCDPatchOffset(USHORT offset);
        void SetMCDStubSize(USHORT size);

        //-------------------------------------------------------------------
        // For stubs which call unmanaged code, the stub should publish 
        // information about the unmanaged call site.  Specifically, 
        //  * returnOffset - offset into the stub of the return address 
        //      from the call
        //  * stackSize - offset on the stack (from the end of the frame)
        //      where the return address is pushed during the call
        //-------------------------------------------------------------------

        BOOL HasCallSiteInfo() 
        {
            return (m_patchOffset & CALL_SITE_BIT) != 0;
        }

        CallSiteInfo *GetCallSiteInfo()
        {
            _ASSERTE(HasCallSiteInfo());

            BYTE *info = (BYTE*) this;

            if (IsIntercept())
            {
                info -= (sizeof(Stub*) + sizeof(void*));
            }

            info -= sizeof(CallSiteInfo);

            return (CallSiteInfo*) info;
        }   

        USHORT GetCallSiteReturnOffset()
        {
            return GetCallSiteInfo()->returnOffset;
        }

        void SetCallSiteReturnOffset(USHORT offset)
        {
            _ASSERTE(offset < USHRT_MAX);
            GetCallSiteInfo()->returnOffset = offset;
        }

        USHORT GetCallSiteStackSize()
        {
            return GetCallSiteInfo()->stackSize;
        }

        void SetCallSiteStackSize(USHORT stackSize)
        {
            _ASSERTE(stackSize < USHRT_MAX);
            GetCallSiteInfo()->stackSize = stackSize;
        }

        //-------------------------------------------------------------------
        // Return executable entrypoint.
        //-------------------------------------------------------------------
        const BYTE *GetEntryPoint()
        {
            _ASSERTE(m_signature == kUsedStub);
            // StubLink always puts the entrypoint first.
            return (const BYTE *)(this+1);
        }

        //-------------------------------------------------------------------
        // Reverse GetEntryPoint.
        //-------------------------------------------------------------------
        static Stub* RecoverStub(const BYTE *pEntryPoint)
        {
            Stub *pStub = ((Stub*)pEntryPoint) - 1;
            _ASSERTE(pStub->m_signature == kUsedStub);
            _ASSERTE(pStub->GetEntryPoint() == pEntryPoint);
            return pStub;
        }


        static UINT32 GetOffsetOfEntryPoint()
        {
            return (UINT32)sizeof(Stub);
        }

        //-------------------------------------------------------------------
        // This is the guy that creates stubs.
        // fMC: Set to true if the stub is a multicast delegate, false otherwise
        //-------------------------------------------------------------------
        static Stub* NewStub(LoaderHeap *pLoaderHeap, UINT numCodeBytes, 
                             BOOL intercept = FALSE, BOOL callSiteInfo = FALSE,
                             BOOL fMC = FALSE);


        //-------------------------------------------------------------------
        // One-time init
        //-------------------------------------------------------------------
        static BOOL Init();


        //-------------------------------------------------------------------
        // One-time cleanup
        //-------------------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
        static VOID Terminate();
#endif /* SHOULD_WE_CLEANUP */

#ifdef _ALPHA_
        CRITICAL_SECTION m_CriticalSection;  // need for updating stub address
#endif

    protected:
        // fMC: Set to true if the stub is a multicast delegate, false otherwise
        void SetupStub(int numCodeBytes, BOOL fIntercepted, BOOL fLoaderHeap,
                       BOOL callSiteInfo, BOOL fMC);
        void DeleteStub();

#ifdef _DEBUG
        enum {
            kUsedStub  = 0x42555453,     // 'STUB'
            kFreedStub = 0x46555453,     // 'STUF'
        };


        UINT32  m_signature;
        Stub*   m_Next;
        UINT    m_numCodeBytes;
#endif
    
        ULONG   m_refcount;
        ULONG   m_patchOffset;

#ifdef _DEBUG
        Stub()      // Stubs are created by NewStub(), not "new". Hide the
        {}          //  constructor to enforce this.
#endif

        // This critical section is used for incrementing and decrementing
        // intercepted stubs ONLY. 

#ifdef _DEBUG
        static Crst    *m_pStubTrackerCrst;
        static BYTE     m_StubTrackerCrstMemory[sizeof(Crst)];
        static Stub*    m_pTrackingList;
#endif

};

/*
 * The InterceptStub hides a reference to the real stub at a negitive offset.
 * When this stub is deleted it decrements the real stub cleaning it up as
 * well. The InterceptStub is created by the Stublinker.
 *
 * @TODO: Intercepted stubs need have a routine that will find the 
 *        last real stub in the chain.
 * MiPanitz: The stubs are linked - GetInterceptedStub will return either
 *        a pointer to the next intercept stub (if there is one), or NULL, 
 *        indicating end-of-chain.  GetRealAddr will return the address of
 *        the "real" code, which may, in fact, be another thunk (for example),
 *        and thus should be traced as well.
 */

class InterceptStub : public Stub 
{
    friend class Stub;
    public:
        //-------------------------------------------------------------------
        // This is the guy that creates stubs.
        //-------------------------------------------------------------------
        static Stub* NewInterceptedStub(LoaderHeap *pHeap, 
                                        UINT numCodeBytes, 
                                        Stub* interceptee,
                                        void* pRealAddr,
                                        BOOL callSiteInfo = FALSE);

        //---------------------------------------------------------------
        // Expose key offsets and values for stub generation.
        //---------------------------------------------------------------
        int GetNegativeOffset()
        {
            return sizeof(Stub*)+GetNegativeOffsetRealAddr();
        }

        Stub** GetInterceptedStub()
        {
            return (Stub**) (((BYTE*)this) - GetNegativeOffset());
        }

        int GetNegativeOffsetRealAddr()
        {
            return sizeof(void*);
        }

        BYTE **GetRealAddr()
        {
            return (BYTE **) (((BYTE*)this) - GetNegativeOffsetRealAddr());
        }

protected:
        void DeleteStub();
        void ReleaseInterceptedStub();

#ifdef _DEBUG
        InterceptStub()  // Intercept stubs are only created by NewInterceptStub .
        {}
#endif
};

//-------------------------------------------------------------------------
// Each platform encodes the "branch" instruction in a different
// way. We use objects derived from InstructionFormat to abstract this
// information away. InstructionFormats don't contain any variable data
// so they should be allocated statically.
//
// Note that StubLinker does not create or define any InstructionFormats.
// The client does.
//
// The following example shows how to define a InstructionFormat for the
// X86 jump near instruction which takes on two forms:
//
//   EB xx        jmp  rel8    ;; SHORT JMP (signed 8-bit offset)
//   E9 xxxxxxxx  jmp  rel32   ;; NEAR JMP (signed 32-bit offset)
//
// InstructionFormat's provide StubLinker the following information:
//
//   RRT.m_allowedSizes
//
//     What are the possible sizes that the reference can
//     take? The X86 jump can take either an 8-bit or 32-bit offset
//     so this value is set to (k8|k32). StubLinker will try to
//     use the smallest size possible.
//
//
//   RRT.m_fTreatSizesAsSigned
//     Sign-extend or zero-extend smallsizes offsets to the platform
//     code pointer size? For x86, this field is set to TRUE (rel8
//     is considered signed.)
//
//
//   UINT RRT.GetSizeOfInstruction(refsize, variationCode)
//     Returns the total size of the instruction in bytes for a given
//     refsize. For this example:
//
//          if (refsize==k8) return 2;
//          if (refsize==k32) return 5;
//          CRASH("StubLinker is stupid.")
//
//   UINT RRT.GetSizeOfData(refsize, variationCode)
//     Returns the total size of the seperate data area (if any) that the
//     instruction needs in bytes for a given refsize. For this example 
//     on the SH3
//          if (refsize==k32) return 4; else return 0;
//
//   The default implem of this returns 0, so CPUs that don't have need
//   for a seperate constant area don't have to worry about it.
//
//
//   BOOL CanReach(refsize, variationcode, fExternal, offset)
//     Returns whether the instruction with the given variationcode &
//     refsize can reach the given offset. In the case of External
//     calls, fExternal is set and offset is 0. In this case an implem
//     should return TRUE only if refesize is big enough to fit a 
//     full machine-sized pointer to anywhere in the address space.
//
//
//   VOID RRT.EmitInstruction(UINT     refsize,
//                            __int64  fixedUpReference,
//                            BYTE    *pOutBuffer,
//                            UINT     variationCode,
//                            BYTE    *pDataBuffer)
//
//     Given a chosen size (refsize) and the final offset value
//     computed by StubLink (fixedUpReference), write out the
//     instruction into the provided buffer (guaranteed to be
//     big enough provided you told the truth with GetSizeOfInstruction()).
//     If needed (e.g. on SH3) a data buffer is also passed in for 
//     storage of constants. 
//
//     For x86 jmp near:
//
//          if (refsize==k8) {
//              pOutBuffer[0] = 0xeb;
//              pOutBuffer[1] = (__int8)fixedUpReference;
//          } else if (refsize == k32) {
//              pOutBuffer[0] = 0xe9;
//              *((__int32*)(1+pOutBuffer)) = (__int32)fixedUpReference;
//          } else {
//              CRASH("Bad input.");
//          }
//
// VOID RRT.GetHotSpotOffset(UINT refsize, UINT variationCode)
//
//     The reference offset is always relative to some IP: this
//     method tells StubLinker where that IP is relative to the
//     start of the instruction. For X86, the offset is always
//     relative to the start of the *following* instruction so
//     the correct implementation is:
//
//          return GetSizeOfInstruction(refsize, variationCode);
//
//     Actually, InstructionFormat() provides a default implementation of this
//     method that does exactly this so X86 need not override this at all.
//
//
// The extra "variationCode" argument is an __int32 that StubLinker receives
// from EmitLabelRef() and passes uninterpreted to each RRT method.
// This allows one RRT to handle a family of related instructions,
// for example, the family of conditional jumps on the X86.
//
//-------------------------------------------------------------------------
class InstructionFormat
{
    public:
        enum
        {
        // if you want to add a size, insert it in-order (e.g. a 18-bit size would 
        // go between k16 and k32) and shift all the higher values up. All values
        // must be a power of 2 since the get ORed together.
          k8  = 1,
          k9  = 2,
          k13 = 4,
          k16 = 8,
          k32 = 0x10,
          k64 = 0x20,
          kAllowAlways = 0x40,
          kMax = 0x40
        };

        const UINT m_allowedSizes;         // OR mask using above "k" values
        InstructionFormat(UINT allowedSizes) : m_allowedSizes(allowedSizes)
        {
        }

        virtual UINT GetSizeOfInstruction(UINT refsize, UINT variationCode) = 0;
        virtual VOID EmitInstruction(UINT refsize, __int64 fixedUpReference, BYTE *pCodeBuffer, UINT variationCode, BYTE *pDataBuffer) = 0;
        virtual UINT GetHotSpotOffset(UINT refsize, UINT variationCode)
        {
            // Default implementation: the offset is added to the
            // start of the following instruction.
            return GetSizeOfInstruction(refsize, variationCode);
        }

        virtual UINT GetSizeOfData(UINT refsize, UINT variationCode) 
        {
            // Default implementation: 0 extra bytes needed (most CPUs)
            return 0;
        }

        virtual BOOL CanReach(UINT refsize, UINT variationCode, BOOL fExternal, int offset)
        {
            if (fExternal) {
                // For external, we don't have enough info to predict
                // the offset yet so we only accept if the offset size
                // is at least as large as the native pointer size.
                switch(refsize) {
                    case InstructionFormat::k8: // intentional fallthru
                    case InstructionFormat::k16: // intentional fallthru
                        return FALSE;           // no 8 or 16-bit platforms

                    case InstructionFormat::k32:
                        return sizeof(LPVOID) <= 4;
    
                    case InstructionFormat::k64:  
                        return sizeof(LPVOID) <= 8;

                    case InstructionFormat::kAllowAlways:
                        return TRUE;

                    default:
                        _ASSERTE(0);
                        return FALSE;
                }
            } else {
                switch(refsize)
                {
                    case InstructionFormat::k8:
                        return FitsInI1(offset);
    
                    case InstructionFormat::k16:
                        return FitsInI2(offset);
    
                    case InstructionFormat::k32:
                        return FitsInI4(offset);
    
                    case InstructionFormat::k64:  // intentional fallthru
                    case InstructionFormat::kAllowAlways:
                        return TRUE;
                    default:
                        _ASSERTE(0);
                        return FALSE;
               
                }
            }
        }
};





//-------------------------------------------------------------------------
// This stub cache associates stubs with an integer key.  For some clients,
// this might represent the size of the argument stack in some cpu-specific
// units (for the x86, the size is expressed in DWORDS.)  For other clients,
// this might take into account the style of stub (e.g. whether it returns
// an object reference or not).
//-------------------------------------------------------------------------
class ArgBasedStubCache
{
    public:
       ArgBasedStubCache(UINT fixedSize = NUMFIXEDSLOTS);
       ~ArgBasedStubCache();

       //-----------------------------------------------------------------
       // Retrieves the stub associated with the given key.
       //-----------------------------------------------------------------
       Stub *GetStub(unsigned __int32 key);

       //-----------------------------------------------------------------
       // Tries to associate the stub with the given key.
       // It may fail because another thread might swoop in and
       // do the association before you do. Thus, you must use the
       // return value stub rather than the pStub.
       //-----------------------------------------------------------------
       Stub* AttemptToSetStub(unsigned __int32 key, Stub *pStub);


       //-----------------------------------------------------------------
       // Trigger a sweep to garbage-collect stubs.
       //-----------------------------------------------------------------
       VOID FreeUnusedStubs();

       //-------------------------------------------------------------------
       // ForceDeleteStubs
       //
       // Forces all cached stubs to free themselves. This routine forces the refcount
       // to 1, then does a DecRef. It is not threadsafe, and thus can
       // only be used in shutdown scenarios.
       //-------------------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
       VOID ForceDeleteStubs();
#endif /* SHOULD_WE_CLEANUP */


       //-----------------------------------------------------------------
       // Locate a stub given its entry point
       //-----------------------------------------------------------------
       Stub* FindStubByAddress(const BYTE* entryPoint);

       // Suggestions for number of slots
       enum {
 #ifdef _DEBUG
             NUMFIXEDSLOTS = 3,
 #else
             NUMFIXEDSLOTS = 16,
 #endif
       };

#ifdef _DEBUG
       VOID Dump();  //Diagnostic dump
#endif

    private:

       // How many low-numbered keys have direct access?
       UINT      m_numFixedSlots;

       // For 'm_numFixedSlots' low-numbered keys, we store them in an array.
       Stub    **m_aStub;


       struct SlotEntry
       {
           Stub             *m_pStub;
           unsigned __int32  m_key;
           SlotEntry        *m_pNext;
       };

       // High-numbered keys are stored in a sparse linked list.
       SlotEntry            *m_pSlotEntries;


       Crst                  m_crst;

};


//-------------------------------------------------------------------------
// This is just like an ArgBasedStubCache but does not allow for premature
// cleanup of stubs.
//-------------------------------------------------------------------------
class ArgBasedStubRetainer : public ArgBasedStubCache
{
    public:
        //-----------------------------------------------------------------
        // This method is overriden to prevent premature stub deletions.
        //-----------------------------------------------------------------
        VOID FreeUnusedStubs()
        {
            _ASSERTE(!"Don't call me, I won't call you.");
        }
};



#define CPUSTUBLINKER StubLinkerCPU
//#ifdef _X86_
//#define CPUSTUBLINKER StubLinkerX86
//#elif defined(_ALPHA_)
//#define CPUSTUBLINKER StubLinkerAlpha
//#elif defined(_SH3_)
//#define CPUSTUBLINKER StubLinkerSHX
//#elif defined(_IA64_)
//#define CPUSTUBLINKER StubLinkeria64
//#endif

class CPUSTUBLINKER;




//-------------------------------------------------------------------------
// This class takes some of the grunt work out of generating a one-time stub
// on demand. Just override the CreateWorker() function. CreateWorker() function receives
// an empty stublinker and should fill it out (but not link it.) CreateWorker()
// may throw COM+ exceptions.
//-------------------------------------------------------------------------

class LazyStubMaker
{
    public:
        LazyStubMaker()
        {
            m_pStub = NULL;
        }

        // Retrieves or creates the stub. Does not bump the stub's refcount.
        // Never returns NULL but may throw COM+ exception.
        Stub *TheStub();

        // One-time init
        static BOOL Init();

        // One-time cleanup.
#ifdef SHOULD_WE_CLEANUP
        static void Terminate();
#endif /* SHOULD_WE_CLEANUP */

    protected:
        // 
        virtual void CreateWorker(CPUSTUBLINKER *psl) = 0;

    private:
        Stub          *m_pStub;


        LazyStubMaker *m_pNext;

        static LazyStubMaker *m_pFirst;
        static Crst          *m_pCrst;
        static BYTE           m_CrstMemory[sizeof(Crst)];

};



#endif // __stublink_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stringliteralmap.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Map used for interning of string literals.
**  
**      //  %%Created by: dmortens
===========================================================*/

#ifndef _STRINGLITERALMAP_H
#define _STRINGLITERALMAP_H

#include "vars.hpp"
#include "AppDomain.hpp"
#include "EEHash.h"
#include "comstring.h"
#include "eeconfig.h" // For OS pages size
#include "memorypool.h"


class StringLiteralEntry;
// Allocate one page worth. Assumption sizeof(void*) same as sizeof (StringLiteralEntryArray*)
#define MAX_ENTRIES_PER_CHUNK (PAGE_SIZE-sizeof(void*))/sizeof(StringLiteralEntry)

// AppDomain specific string literal map.
class AppDomainStringLiteralMap
{
public:
	// Constructor and destructor.
	AppDomainStringLiteralMap(BaseDomain *pDomain);
	virtual ~AppDomainStringLiteralMap();

    // Initialization method.
    HRESULT Init();

	// Method to retrieve a string from the map.
    // Important: GetStringLiteral assumes that the string buffer pointed to by the EEStringData *pStringData is 
    //            allocated by the metadata. GetStringLiteral lazyly allocates the String buffer only when more than
    //            one appdomain refer to the StringLiteral.
    STRINGREF *GetStringLiteral(EEStringData *pStringData, BOOL bAddIfNotFound, BOOL bAppDomainWontUnload);

    // Method to explicitly intern a string object.
    STRINGREF *GetInternedString(STRINGREF *pString, BOOL bAddIfNotFound, BOOL bAppDomainWontUnload);

private:
    // Hash tables that maps a Unicode string to a COM+ string handle.
    EEUnicodeStringLiteralHashTable    *m_StringToEntryHashTable;

	// The memorypool for hash entries for this hash table.
	MemoryPool                  *m_MemoryPool;

    // The string hash table version.
    int                         m_HashTableVersion;

    // The hash table table critical section.
    Crst                        m_HashTableCrst;

    BaseDomain                  *m_pDomain;
};

// Global string literal map.
class GlobalStringLiteralMap
{
    friend StringLiteralEntry;

public:
	// Constructor and destructor.
	GlobalStringLiteralMap();
	virtual ~GlobalStringLiteralMap();

    // Initialization method.
    HRESULT Init();

	// Method to retrieve a string from the map.
    // Important: GetStringLiteral assumes that the string buffer pointed to by the EEStringData *pStringData is 
    //            allocated by the metadata. GetStringLiteral lazyly allocates the String buffer only when more than
    //            one appdomain refer to the StringLiteral.
    // The overloaded versions take a precomputed hash (for perf). 
    // Consider folding the two overloads together (what's an illegal value for a hash?)
    StringLiteralEntry *GetStringLiteral(EEStringData *pStringData, BOOL bAddIfNotFound);
    StringLiteralEntry *GetStringLiteral(EEStringData *pStringData, DWORD dwHash, BOOL bAddIfNotFound);

    // Method to explicitly intern a string object.
    StringLiteralEntry *GetInternedString(STRINGREF *pString, BOOL bAddIfNotFound);
    StringLiteralEntry *GetInternedString(STRINGREF *pString, DWORD dwHash, BOOL bAddIfNotFound);

private:    
    // Helper method to add a string to the global string literal map.
    StringLiteralEntry *AddStringLiteral(EEStringData *pStringData, int CurrentHashTableVersion);

    // Helper method to add an interned string.
    StringLiteralEntry *AddInternedString(STRINGREF *pString, int CurrentHashTableVersion);

    // Called by StringLiteralEntry when its RefCount falls to 0.
    void RemoveStringLiteralEntry(StringLiteralEntry *pEntry);

    // Move the string data from the appdomain specific map to the global map.
    void MakeStringGlobal(StringLiteralEntry *pEntry);
    
    // Hash tables that maps a Unicode string to a LiteralStringEntry.
    EEUnicodeStringLiteralHashTable    *m_StringToEntryHashTable;

    // The memorypool for hash entries for this hash table.
    MemoryPool                  *m_MemoryPool;

    // The string hash table version.
    int                         m_HashTableVersion;

    // The hash table table critical section.
    Crst                        m_HashTableCrst;

    // The large heap handle table.
    LargeHeapHandleTable        m_LargeHeapHandleTable;

};

class StringLiteralEntryArray;

// Ref counted entry representing a string literal.
class StringLiteralEntry
{
private:
    StringLiteralEntry(EEStringData *pStringData, STRINGREF *pStringObj)
    : m_pStringObj(pStringObj), m_dwRefCount(0)
    {
    }

	~StringLiteralEntry()
	{
	}

public:
    void AddRef()
    {
        FastInterlockIncrement((LONG*)&m_dwRefCount);
    }

    void Release()
    {
        _ASSERTE(m_dwRefCount > 0);

        ULONG dwRefCount = FastInterlockDecrement((LONG*)&m_dwRefCount);

        if (dwRefCount == 0)
        {
            SystemDomain::GetGlobalStringLiteralMap()->RemoveStringLiteralEntry(this);
            DeleteEntry (this); // Puts this entry in the free list
        }
    }

    void ForceRelease()
    {
        _ASSERTE(m_dwRefCount > 0);
        _ASSERTE(g_fProcessDetach);


        // Ignore the ref count.
        m_dwRefCount = 0;

        // Don't remove entry from global map. This method is only called during
        // shutdown and we may have already blown away the literals in question,
        // so the string comparisons involved in the entry lookup will fail (in
        // fact they'll touch memory that doesn't belong to us any more). 
        //SystemDomain::GetGlobalStringLiteralMap()->RemoveStringLiteralEntry(this);
        
         DeleteEntry (this); // Puts this entry in the free list
    }
    
    LONG GetRefCount()
    {
        return (m_dwRefCount);
    }

    STRINGREF* GetStringObject()
    {
        return m_pStringObj;
    }

    void GetStringData(EEStringData *pStringData)
    {
        // The caller is responsible for protecting the ref returned
        _ASSERTE(GetThread()->PreemptiveGCDisabled());

        _ASSERTE(pStringData);

        WCHAR *thisChars;
        int thisLength;

        RefInterpretGetStringValuesDangerousForGC(ObjectToSTRINGREF(*(StringObject**)m_pStringObj), &thisChars, &thisLength);
        pStringData->SetCharCount (thisLength); // thisLength is in WCHARs and that's what EEStringData's char count wants
        pStringData->SetStringBuffer (thisChars);
    }

    static StringLiteralEntry *AllocateEntry(EEStringData *pStringData, STRINGREF *pStringObj);
    static void DeleteEntry (StringLiteralEntry *pEntry);
    static void DeleteEntryArrayList ();

private:
    STRINGREF*                  m_pStringObj;
    union
    {
        DWORD                       m_dwRefCount;
        StringLiteralEntry         *m_pNext;
    };

    static StringLiteralEntryArray *s_EntryList; // always the first entry array in the chain. 
    static DWORD                    s_UsedEntries;   // number of entries used up in the first array
    static StringLiteralEntry      *s_FreeEntryList; // free list chained thru the arrays.
};

class StringLiteralEntryArray
{
public:
    StringLiteralEntryArray *m_pNext;
    BYTE                     m_Entries[MAX_ENTRIES_PER_CHUNK*sizeof(StringLiteralEntry)];
};

#endif _STRINGLITERALMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\syncblk.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// SYNCBLK.H
//
// Definition of a SyncBlock and the SyncBlockCache which manages it
//

#ifndef _SYNCBLK_H_
#define _SYNCBLK_H_

#include "util.hpp"
#include "class.h"
#include "list.h"
#include "crst.h"
#include "vars.hpp"
#include <member-offset-info.h>


// Every Object is preceded by an ObjHeader (at a negative offset).  The
// ObjHeader has an index to a SyncBlock.  This index is 0 for the bulk of all
// instances, which indicates that the object shares a dummy SyncBlock with
// most other objects.
//
// The SyncBlock is primarily responsible for object synchronization.  However,
// it is also a "kitchen sink" of sparsely allocated instance data.  For instance,
// the default implementation of Hash() is based on the existence of a SyncTableEntry.
// And objects exposed to or from COM, or through context boundaries, can store sparse
// data here.
//
// SyncTableEntries and SyncBlocks are allocated in non-GC memory.  A weak pointer
// from the SyncTableEntry to the instance is used to ensure that the SyncBlock and
// SyncTableEntry are reclaimed (recycled) when the instance dies.
//
// The organization of the SyncBlocks isn't intuitive (at least to me).  Here's
// the explanation:
//
// Before each Object is an ObjHeader.  If the object has a SyncBlock, the
// ObjHeader contains a non-0 index to it.
//
// The index is looked up in the g_pSyncTable of SyncTableEntries.  This means
// the table is consecutive for all outstanding indices.  Whenever it needs to
// grow, it doubles in size and copies all the original entries.  The old table
// is kept until GC time, when it can be safely discarded.
//
// Each SyncTableEntry has a backpointer to the object and a forward pointer to
// the actual SyncBlock.  The SyncBlock is allocated out of a SyncBlockArray
// which is essentially just a block of SyncBlocks.
//
// The SyncBlockArrays are managed by a SyncBlockCache that handles the actual
// allocations and frees of the blocks.
//
// So...
//
// Each allocation and release has to handle free lists in the table of entries
// and the table of blocks.
//
// We burn an extra 4 bytes for the pointer from the SyncTableEntry to the
// SyncBlock.
//
// The reason for this is that many objects have a SyncTableEntry but no SyncBlock.
// That's because someone (e.g. HashTable) called Hash() on them.
//
// Incidentally, there's a better write-up of all this stuff in the archives.


#pragma pack(push,4)

// forwards:
class SyncBlock;
class SyncBlockCache;
class SyncTableEntry;
class SyncBlockArray;
class AwareLock;
class Thread;
class AppDomain;

#ifdef EnC_SUPPORTED
class EnCSyncBlockInfo;
#endif // EnC_SUPPORTED

#include "eventstore.hpp"

#include "eventstore.hpp"

// this is a 'GC-aware' Lock.  It is careful to enable preemptive GC before it
// attempts any operation that can block.  Once the operation is finished, it
// restores the original state of GC.

// AwareLocks can only be created inside SyncBlocks, since they depend on the
// enclosing SyncBlock for coordination.  This is enforced by the private ctor.

class AwareLock
{
friend class SyncBlockCache;
friend class SyncBlock;
friend struct MEMBER_OFFSET_INFO(AwareLock);


  private:
    volatile void  *m_MonitorHeld;
    LONG            m_TransientPrecious;
    ULONG           m_Recursion;
    Thread         *m_HoldingThread;

    // This is a backpointer from the syncblock to the synctable entry.  This allows
    // us to recover the object that holds the syncblock.
    DWORD           m_dwSyncIndex;

    HANDLE          m_SemEvent;

    static Crst *AllocLockCrst;
    static BYTE AllocLockCrstInstance[sizeof(Crst)];

    // Only SyncBlocks can create AwareLocks.  Hence this private constructor.
    AwareLock(DWORD indx)
        : m_SemEvent(INVALID_HANDLE_VALUE),
          m_MonitorHeld(0),
          m_Recursion(0),
          m_HoldingThread(NULL),
          m_TransientPrecious(0),
          m_dwSyncIndex(indx)
    {
    }

    ~AwareLock()
    {
        // We deliberately allow this to remain incremented if an exception blows
        // through a lock attempt.  This simply prevents the GC from aggressively
        // reclaiming a particular syncblock until the associated object is garbage.
        // From a perf perspective, it's not worth using SEH to prevent this from
        // happening.
        //
        // _ASSERTE(m_TransientPrecious == 0);

        if (m_SemEvent != INVALID_HANDLE_VALUE)
            ::CloseHandle(m_SemEvent);
    }

  public:
    void    Enter();
    BOOL    TryEnter(INT32 timeOut = 0);
    BOOL    EnterEpilog(Thread *pCurThread, INT32 timeOut = INFINITE);
    void    Leave();
    void    Signal();
    void    AllocLockSemEvent();
    LONG    EnterCount();
    LONG    LeaveCompletely();
    BOOL    OwnedByCurrentThread();

    void    IncrementTransientPrecious()
    {
        FastInterlockIncrement(&m_TransientPrecious);
        _ASSERTE(m_TransientPrecious > 0);
    }

    void    DecrementTransientPrecious()
    {
        _ASSERTE(m_TransientPrecious > 0);
        FastInterlockDecrement(&m_TransientPrecious);
    }

    void SetPrecious();

    // Provide access to the object associated with this awarelock, so client can
    // protect it.
    inline OBJECTREF GetOwningObject();
};

class ComCallWrapper;
struct ComPlusWrapper;

// this is a lazily created additional block for an object which contains
// synchronzation information and other "kitchen sink" data

class SyncBlock
{
    // ObjHeader creates our Mutex and Event
    friend class ObjHeader;
    friend class SyncBlockCache;
    friend struct ThreadQueue;
    friend struct MEMBER_OFFSET_INFO(SyncBlock);


  protected:
    AwareLock  m_Monitor;                    // the actual monitor


    // If this object is exposed to COM, or it is a proxy over a COM object,
    // we keep some extra info here:
    void       *m_pComData;

    // If this is a delegate marshalled out to unmanaged code, this points
    // to the thunk generated for unmanaged code to call back on.
    void       *m_pUMEntryThunk;

#ifdef EnC_SUPPORTED
    // And if the object has new fields added via EnC, this is a list of them
    EnCSyncBlockInfo *m_pEnCInfo;
#endif // EnC_SUPPORTED

    // This is the index for the appdomain to which the object belongs. If we
    // can't set it in the object header, then we set it here. Note that an
    // object doesn't always have this filled in. Only for COM interop, 
    // finalizers and objects in handles
    DWORD m_dwAppDomainIndex;

    // We thread two different lists through this link.  When the SyncBlock is
    // active, we create a list of waiting threads here.  When the SyncBlock is
    // released (we recycle them), the SyncBlockCache maintains a free list of
    // SyncBlocks here.
    //
    // We can't afford to use an SList<> here because we only want to burn
    // space for the minimum, which is the pointer within an SLink.
    SLink       m_Link;

#if CHECK_APP_DOMAIN_LEAKS 
    DWORD m_dwFlags;

    enum {
        IsObjectAppDomainAgile = 1,
        IsObjectCheckedForAppDomainAgile = 2,
    };
#endif

  public:
    SyncBlock(DWORD indx)
        : m_Monitor(indx)
        , m_pComData(0)
#ifdef EnC_SUPPORTED
        , m_pEnCInfo(0)
#endif // EnC_SUPPORTED
        , m_pUMEntryThunk(0)
        , m_dwAppDomainIndex(0)
#if CHECK_APP_DOMAIN_LEAKS 
        , m_dwFlags(0)
#endif
    {
        // The monitor must be 32-bit aligned for atomicity to be guaranteed.
        _ASSERTE((((size_t) &m_Monitor) & 3) == 0);
    }

   ~SyncBlock();

   // As soon as a syncblock acquires some state that cannot be recreated, we latch
   // a bit.
   void SetPrecious()
   {
       m_Monitor.SetPrecious();
   }

   BOOL IsPrecious()
   {
       return (m_Monitor.m_dwSyncIndex & SyncBlockPrecious) != 0;
   }

    // True is the syncblock and its index are disposable. 
    // If new members are added to the syncblock, this 
    // method needs to be modified accordingly
    BOOL IsIDisposable()
    {
        return (!IsPrecious() &&
                m_Monitor.m_MonitorHeld == 0 &&
                m_Monitor.m_TransientPrecious == 0);
    }

   // helpers to access com data 
    LPVOID GetComVoidPtr()
    {
        return m_pComData;
    }

    void *GetUMEntryThunk()
    {
        return m_pUMEntryThunk;
    }

    // set m_pUMEntryThunk if not already set - return true if not already set
    bool SetUMEntryThunk(void *pUMEntryThunk);

    ComCallWrapper* GetComCallWrapper();

    void SetComCallWrapper(ComCallWrapper *pComData);

    ComPlusWrapper* GetComPlusWrapper();

    void SetComPlusWrapper(ComPlusWrapper* pComData);

    void SetComClassFactory(LPVOID pv)
    {
        // set the low 2 bits
        SetComPlusWrapper((ComPlusWrapper*)((size_t)pv | 0x3));
    }
    
#ifdef EnC_SUPPORTED
    EnCSyncBlockInfo *GetEnCInfo() 
    {
        return m_pEnCInfo;
    }
        
    void SetEnCInfo(EnCSyncBlockInfo *pEnCInfo) 
    {
        SetPrecious();
        m_pEnCInfo = pEnCInfo;
    }
#endif // EnC_SUPPORTED

    DWORD GetAppDomainIndex()
    {
        return m_dwAppDomainIndex;
    }

    void SetAppDomainIndex(DWORD dwAppDomainIndex)
    {
        SetPrecious();
        m_dwAppDomainIndex = dwAppDomainIndex;
    }

    void SetAwareLock(Thread *holdingThread, DWORD recursionLevel)
    {
        m_Monitor.m_MonitorHeld = (void*)(size_t)1;
        m_Monitor.m_HoldingThread = holdingThread;
        m_Monitor.m_Recursion = recursionLevel;
    }
        
    void *operator new (size_t sz, void* p)
    {
        return p ;
    }
    void operator delete(void *p)
    {
        // We've already destructed.  But retain the memory.
    }

    LONG MonitorCount()
    {
        return m_Monitor.EnterCount();
    }

    void EnterMonitor()
    {
        m_Monitor.Enter();
    }

    BOOL TryEnterMonitor(INT32 timeOut = 0)
    {
        return m_Monitor.TryEnter(timeOut);
    }

    // leave the monitor
    void LeaveMonitor()
    {
        m_Monitor.Leave();
    }

    AwareLock* GetMonitor()
    {
        //hold the syncblock 
        SetPrecious();
        return &m_Monitor;
    }

    BOOL DoesCurrentThreadOwnMonitor()
    {
        return m_Monitor.OwnedByCurrentThread();
    }

    LONG LeaveMonitorCompletely()
    {
        return m_Monitor.LeaveCompletely();
    }

    BOOL Wait(INT32 timeOut, BOOL exitContext);
    void Pulse();
    void PulseAll();

    enum
    {
        // This bit indicates that the syncblock is valuable and can neither be discarded
        // nor re-created.
        SyncBlockPrecious   = 0x80000000,
    };

#if CHECK_APP_DOMAIN_LEAKS 
    BOOL IsAppDomainAgile() 
    {
        return m_dwFlags & IsObjectAppDomainAgile;
    }
    void SetIsAppDomainAgile() 
    {
        m_dwFlags |= IsObjectAppDomainAgile;
    }
    void UnsetIsAppDomainAgile()
    {
    	m_dwFlags = m_dwFlags & ~IsObjectAppDomainAgile;
    }
    BOOL IsCheckedForAppDomainAgile() 
    {
        return m_dwFlags & IsObjectCheckedForAppDomainAgile;
    }
    void SetIsCheckedForAppDomainAgile() 
    {
        m_dwFlags |= IsObjectCheckedForAppDomainAgile;
    }
#endif
};


class SyncTableEntry
{
  public:
    SyncBlock    *m_SyncBlock;
    Object   *m_Object;
    static SyncTableEntry*& GetSyncTableEntry();
    static SyncTableEntry* s_pSyncTableEntry;
};


// this class stores free sync blocks after they're allocated and
// unused

class SyncBlockCache
{
    friend class SyncBlock;
    friend struct MEMBER_OFFSET_INFO(SyncBlockCache);

    
  private:
    SLink*      m_pCleanupBlockList;    // list of sync blocks that need cleanup
    SLink*      m_FreeBlockList;        // list of free sync blocks
    Crst        m_CacheLock;            // cache lock
    DWORD       m_FreeCount;            // count of active sync blocks
    DWORD       m_ActiveCount;          // number active
    SyncBlockArray *m_SyncBlocks;       // Array of new SyncBlocks.
    DWORD       m_FreeSyncBlock;        // Next Free Syncblock in the array
    DWORD       m_FreeSyncTableIndex;   // free index in the SyncBlocktable
    size_t      m_FreeSyncTableList;    // index of the free list of SyncBlock
                                        // Table entry
    DWORD       m_SyncTableSize;
    SyncTableEntry *m_OldSyncTables;    // Next old SyncTable
    BOOL        m_bSyncBlockCleanupInProgress;  // A flag indicating if sync block cleanup is in progress.    
    DWORD*		m_EphemeralBitmap;		// card table for ephemeral scanning

    BOOL        GCWeakPtrScanElement(int elindex, HANDLESCANPROC scanProc, LPARAM lp1, LPARAM lp2, BOOL& cleanup);

    void SetCard (size_t card);
    void ClearCard (size_t card);
    BOOL CardSetP (size_t card);
    void CardTableSetBit (size_t idx);


  public:
    static SyncBlockCache* s_pSyncBlockCache;
    static SyncBlockCache*& GetSyncBlockCache();

    void *operator new(size_t size, void *pInPlace)
    {
        return pInPlace;
    }

    void operator delete(void *p)
    {
    }

    SyncBlockCache();
    ~SyncBlockCache();

    static BOOL Attach();
    static void Detach();
    void DoDetach();

    static BOOL Start();
    static void Stop();

    // serializes the monitor cache
    void EnterCacheLock()
    {
        m_CacheLock.Enter();
    }
    void LeaveCacheLock()
    {
        m_CacheLock.Leave();
    }

    // returns and removes next from free list
    SyncBlock* GetNextFreeSyncBlock();
    // returns and removes the next from cleanup list
    SyncBlock* GetNextCleanupSyncBlock();
    // inserts a syncblock into the cleanup list
    void    InsertCleanupSyncBlock(SyncBlock* psb);

    // Obtain a new syncblock slot in the SyncBlock table. Used as a hash code
    DWORD   NewSyncBlockSlot(Object *obj);

    // return sync block to cache or delete
    void    DeleteSyncBlock(SyncBlock *sb);

    // return sync block to cache or delete, called from GC
    void    GCDeleteSyncBlock(SyncBlock *sb);

    void    GCWeakPtrScan(HANDLESCANPROC scanProc, LPARAM lp1, LPARAM lp2);

    void    GCDone(BOOL demoting);

    void    CleanupSyncBlocks();

    // Determines if a sync block cleanup is in progress.
    BOOL    IsSyncBlockCleanupInProgress()
    {
        return m_bSyncBlockCleanupInProgress;
    }
#if CHECK_APP_DOMAIN_LEAKS 
    void CheckForUnloadedInstances(DWORD unloadingIndex);
#endif
#ifdef _DEBUG
    friend void DumpSyncBlockCache();
#endif

#ifdef VERIFY_HEAP
    void    VerifySyncTableEntry();
#endif
};


// At a negative offset from each Object is an ObjHeader.  The 'size' of the
// object includes these bytes.  However, we rely on the previous object allocation
// to zero out the ObjHeader for the current allocation.  And the limits of the
// GC space are initialized to respect this "off by one" error.

// m_SyncBlockValue is carved up into an index and a set of bits.  Steal bits by
// reducing the mask.  We use the very high bit, in _DEBUG, to be sure we never forget
// to mask the Value to obtain the Index

	// These first three are only used on strings (If the first one is on, we know whether 
	// the string has high byte characters, and the second bit tells which way it is. 
	// Note that we are reusing the FINALIZER_RUN bit since strings don't have finalizers,
	// so the value of this bit does not matter for strings
#define BIT_SBLK_STRING_HAS_NO_HIGH_CHARS 	0x80000000

// Used as workaround for infinite loop case.  Will set this bit in the sblk if we have already
// seen this sblk in our agile checking logic.  Problem is seen when object 1 has a ref to object 2
// and object 2 has a ref to object 1.  The agile checker will infinitely loop on these references.
#define BIT_SBLK_AGILE_IN_PROGRESS                  0x80000000
#define BIT_SBLK_STRING_HIGH_CHARS_KNOWN 	0x40000000
#define BIT_SBLK_STRING_HAS_SPECIAL_SORT    0xC0000000
#define BIT_SBLK_STRING_HIGH_CHAR_MASK      0xC0000000

#define BIT_SBLK_FINALIZER_RUN      		0x40000000
#define BIT_SBLK_GC_RESERVE         		0x20000000
// see  BIT_SBLK_SPIN_LOCK below       		0x10000000
#define BIT_SBLK_IS_SYNCBLOCKINDEX   		0x08000000

// if BIT_SBLK_IS_SYNCBLOCKINDEX is clear, the rest of the header dword is layed out as follows:
// - lower ten bits (bits 0 thru 9) is thread id used for the thin locks
//   value is zero if no thread is holding the lock
// - following six bits (bits 10 thru 15) is recursion level used for the thin locks
//   value is zero if lock is not taken or only taken once by the same thread
// - following 11 bits (bits 16 thru 26) is app domain index
//   value is zero if no app domain index is set for the object
#define SBLK_MASK_LOCK_THREADID             0x000003FF   // special value of 0 + 1023 thread ids
#define SBLK_MASK_LOCK_RECLEVEL             0x0000FC00   // 64 recursion levels
#define SBLK_LOCK_RECLEVEL_INC              0x00000400   // each level is this much higher than the previous one
#define SBLK_APPDOMAIN_SHIFT                16           // shift right this much to get appdomain index
#define SBLK_RECLEVEL_SHIFT                 10           // shift right this much to get recursion level
#define SBLK_MASK_APPDOMAININDEX            0x000007FF   // 2048 appdomain indices

// add more bits here... (adjusting the following mask to make room)

// if BIT_SBLK_IS_SYNCBLOCKINDEX is set, rest of the dword is sync block index (bits 0 thru 26)
#define MASK_SYNCBLOCKINDEX             0x07FFFFFF

// we share our spin lock with the array lock bit. This lock is only taken when we need to
// modify the index value in m_SyncBlockValue. It should not be taken if the object already
// has a real syncblock index. In order to avoid conflicts with the use as an array lock, we
// force objects that try to take this lock to have a sync block index (but not a sync block - 
// unless they already have an appdomain index set).
#define     BIT_SBLK_SPIN_LOCK          0x10000000

// Spin for about 1000 cycles before waiting longer.
#define     BIT_SBLK_SPIN_COUNT         1000

// The GC is highly dependent on SIZE_OF_OBJHEADER being exactly the sizeof(ObjHeader)
// We define this macro so that the preprocessor can calculate padding structures.
#define SIZEOF_OBJHEADER    4
 
class ObjHeader
{
    friend FCDECL1(void, JIT_MonEnter, OBJECTREF or);
    friend FCDECL1(BOOL, JIT_MonTryEnter, OBJECTREF or);
    friend FCDECL1(void, JIT_MonExit, OBJECTREF or);

  private:
    // !!! Notice: m_SyncBlockValue *MUST* be the last field in ObjHeader.
    DWORD  m_SyncBlockValue;      // the Index and the Bits

  public:

    // Access to the Sync Block Index, by masking the Value.
    DWORD GetHeaderSyncBlockIndex()
    {
        // pull the value out before checking it to avoid race condition
        DWORD value = m_SyncBlockValue;
        if ((value & BIT_SBLK_IS_SYNCBLOCKINDEX) == 0)
            return 0;
        return value & MASK_SYNCBLOCKINDEX;
    }
    // Ditto for setting the index, which is careful not to disturb the underlying
    // bit field -- even in the presence of threaded access.
    // 
    // This service can only be used to transition from a 0 index to a non-0 index.
    void SetIndex(DWORD indx)
    {
#ifdef _DEBUG
        _ASSERTE(GetHeaderSyncBlockIndex() == 0);
        _ASSERTE(m_SyncBlockValue & BIT_SBLK_SPIN_LOCK);
        // if we have an index here, make sure we already transferred it to the syncblock
        // before we clear it out
        DWORD adIndex = GetRawAppDomainIndex();
        if (adIndex)
        {
            SyncBlock *pSyncBlock = SyncTableEntry::GetSyncTableEntry() [indx & ~BIT_SBLK_IS_SYNCBLOCKINDEX].m_SyncBlock;

            _ASSERTE(pSyncBlock && pSyncBlock->GetAppDomainIndex() == adIndex);
        }
#endif
        void* newValue;
        void* oldValue;
        while (TRUE) {
            oldValue = (void*)(size_t)*(volatile LONG*)&m_SyncBlockValue;
            _ASSERTE(GetHeaderSyncBlockIndex() == 0);
            // or in the old value except any index that is there - 
            // note that indx could be carrying the BIT_SBLK_IS_SYNCBLOCKINDEX bit that we need to preserve
            newValue = (void*)(size_t)(indx | 
                ((size_t)oldValue & ~(BIT_SBLK_IS_SYNCBLOCKINDEX | MASK_SYNCBLOCKINDEX)));
            if (FastInterlockCompareExchange((LPVOID*)&m_SyncBlockValue, 
                                             newValue, 
                                             oldValue)
                == oldValue)
            {
                return;
            }
        }
    }

    // Used only during shutdown
    void ResetIndex()
    {
        _ASSERTE(m_SyncBlockValue & BIT_SBLK_SPIN_LOCK);
        FastInterlockAnd(&m_SyncBlockValue, ~(BIT_SBLK_IS_SYNCBLOCKINDEX | MASK_SYNCBLOCKINDEX));
    }

    // Used only GC
    void GCResetIndex()
    {
        m_SyncBlockValue &=~(BIT_SBLK_IS_SYNCBLOCKINDEX | MASK_SYNCBLOCKINDEX);
    }

    void SetAppDomainIndex(DWORD);
    DWORD GetRawAppDomainIndex();
    DWORD GetAppDomainIndex();

    // For now, use interlocked operations to twiddle bits in the bitfield portion.
    // If we ever have high-performance requirements where we can guarantee that no
    // other threads are accessing the ObjHeader, this can be reconsidered for those
    // particular bits.
    void SetBit(DWORD bit)
    {
        _ASSERTE((bit & MASK_SYNCBLOCKINDEX) == 0);
        FastInterlockOr(&m_SyncBlockValue, bit);
    }
    void ClrBit(DWORD bit)
    {
        _ASSERTE((bit & MASK_SYNCBLOCKINDEX) == 0);
        FastInterlockAnd(&m_SyncBlockValue, ~bit);
    }
    //GC accesses this bit when all threads are stopped. 
    void SetGCBit()
    {
        m_SyncBlockValue |= BIT_SBLK_GC_RESERVE;
    }
    void ClrGCBit()
    {
        m_SyncBlockValue &= ~BIT_SBLK_GC_RESERVE;
    }

    // Don't bother masking out the index since anyone who wants bits will presumably
    // restrict the bits they consider.
    DWORD GetBits()
    {
        return m_SyncBlockValue;
    }


    // TRUE if the header has a real SyncBlockIndex (i.e. it has an entry in the
    // SyncTable, though it doesn't necessarily have an entry in the SyncBlockCache)
    BOOL HasSyncBlockIndex()
    {
        return (GetHeaderSyncBlockIndex() != 0);
    }

    // retrieve or allocate a sync block for this object
    SyncBlock *GetSyncBlock();

    // retrieve sync block but don't allocate
    SyncBlock *GetRawSyncBlock();

    SyncBlock *PassiveGetSyncBlock()
    {
        return g_pSyncTable [GetHeaderSyncBlockIndex()].m_SyncBlock;
    }

    // COM Interop has special access to sync blocks
    // check .cpp file for more info
    SyncBlock* GetSyncBlockSpecial();

    DWORD GetSyncBlockIndex();

    // this enters the monitor of an object
    void EnterObjMonitor();

    // non-blocking version of above
    BOOL TryEnterObjMonitor(INT32 timeOut = 0);

    // must be created here already
    void LeaveObjMonitor();

    // should be called only from unwind code; used in the
    // case where EnterObjMonitor failed to allocate the
    // sync-object.
    void LeaveObjMonitorAtException()
    {
        if (PassiveGetSyncBlock() != NULL)
            LeaveObjMonitor();
        else if (m_SyncBlockValue & SBLK_MASK_LOCK_THREADID)
        {
            GetSyncBlock();
            _ASSERTE(PassiveGetSyncBlock() != NULL);
            LeaveObjMonitor();
        }
    }

    // must be entered
    LONG LeaveObjMonitorCompletely()
    {
        _ASSERTE(GetHeaderSyncBlockIndex());
        return PassiveGetSyncBlock()->LeaveMonitorCompletely();
    }

    BOOL DoesCurrentThreadOwnMonitor()
    {
        return GetSyncBlock()->DoesCurrentThreadOwnMonitor();
    }

    Object *GetBaseObject()
    {
        return (Object *) (this + 1);
    }

    BOOL Wait(INT32 timeOut, BOOL exitContext);
    void Pulse();
    void PulseAll();

    void EnterSpinLock();
    void ReleaseSpinLock();
};


// A SyncBlock contains an m_Link field that is used for two purposes.  One
// is to manage a FIFO queue of threads that are waiting on this synchronization
// object.  The other is to thread free SyncBlocks into a list for recycling.
// We don't want to burn anything else on the SyncBlock instance, so we can't
// use an SList or similar data structure.  So here's the encapsulation for the
// queue of waiting threads.
//
// Note that Enqueue is slower than it needs to be, because we don't want to
// burn extra space in the SyncBlock to remember the head and the tail of the Q.
// An alternate approach would be to treat the list as a LIFO stack, which is not
// a fair policy because it permits to starvation.

struct ThreadQueue
{
    // Given a link in the chain, get the Thread that it represents
    static WaitEventLink *WaitEventLinkForLink(SLink *pLink);

    // Unlink the head of the Q.  We are always in the SyncBlock's critical
    // section.
    static WaitEventLink *DequeueThread(SyncBlock *psb);

    // Enqueue is the slow one.  We have to find the end of the Q since we don't
    // want to burn storage for this in the SyncBlock.
    static void         EnqueueThread(WaitEventLink *pWaitEventLink, SyncBlock *psb);
    
    // Wade through the SyncBlock's list of waiting threads and remove the
    // specified thread.
    static BOOL         RemoveThread (Thread *pThread, SyncBlock *psb);
};


// The true size of an object is whatever C++ thinks, plus the ObjHeader we
// allocate before it.

#define ObjSizeOf(c)    (sizeof(c) + sizeof(ObjHeader))

// non-zero return value if this function causes the OS to switch to another thread
BOOL __SwitchToThread (DWORD dwSleepMSec);
BOOL InitSwitchToThread();


// Provide access to the object associated with this awarelock, so client can
// protect it.
inline OBJECTREF AwareLock::GetOwningObject()
{
    return (OBJECTREF) SyncTableEntry::GetSyncTableEntry()
                [(m_dwSyncIndex & ~SyncBlock::SyncBlockPrecious)].m_Object;
}

inline void AwareLock::SetPrecious()
{
    m_dwSyncIndex |= SyncBlock::SyncBlockPrecious;
}

#pragma pack(pop)

#endif _SYNCBLK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\syncblk.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// SYNCBLK.CPP
//
// Definition of a SyncBlock and the SyncBlockCache which manages it
//

#include "common.h"

#include "vars.hpp"
#include "ComPlusWrapper.h"
#include "util.hpp"
#include "class.h"
#include "object.h"
#include "threads.h"
#include "excep.h"
#include "threads.h"
#include "syncblk.h"
#include "UTSem.h"
#include "interoputil.h"
#include "encee.h"
#include "PerfCounters.h"
#include "nexport.h"
#include "EEConfig.h"

// Allocate 1 page worth. Typically enough 
#define MAXSYNCBLOCK (PAGE_SIZE-sizeof(void*))/sizeof(SyncBlock)
#define SYNC_TABLE_INITIAL_SIZE 250

//#define DUMP_SB

class  SyncBlockArray
{
  public:
    SyncBlockArray *m_Next;
    BYTE            m_Blocks[MAXSYNCBLOCK * sizeof (SyncBlock)];
};

// For in-place constructor
BYTE g_SyncBlockCacheInstance[sizeof(SyncBlockCache)];

SyncBlockCache* SyncBlockCache::s_pSyncBlockCache = NULL;
SyncTableEntry* SyncTableEntry::s_pSyncTableEntry = NULL;


SyncTableEntry*& SyncTableEntry::GetSyncTableEntry()
{   
    //@todo fix this
    return g_pSyncTable;
    //return s_pSyncTableEntry;
}

SyncBlockCache*& SyncBlockCache::GetSyncBlockCache()
{
    return s_pSyncBlockCache;
}
    
//----------------------------------------------------------------------------
//
//   ThreadQueue Implementation
//
//----------------------------------------------------------------------------

// Given a link in the chain, get the Thread that it represents
inline WaitEventLink *ThreadQueue::WaitEventLinkForLink(SLink *pLink)
{
    return (WaitEventLink *) (((BYTE *) pLink) - offsetof(WaitEventLink, m_LinkSB));
}


// Unlink the head of the Q.  We are always in the SyncBlock's critical
// section.
inline WaitEventLink *ThreadQueue::DequeueThread(SyncBlock *psb)
{
    SyncBlockCache::GetSyncBlockCache()->EnterCacheLock();
    WaitEventLink      *ret = NULL;
    SLink       *pLink = psb->m_Link.m_pNext;

    if (pLink)
    {
        psb->m_Link.m_pNext = pLink->m_pNext;
#ifdef _DEBUG
        pLink->m_pNext = (SLink *)POISONC;
#endif
        ret = WaitEventLinkForLink(pLink);
        _ASSERTE(ret->m_WaitSB == psb);
        COUNTER_ONLY(GetPrivatePerfCounters().m_LocksAndThreads.cQueueLength--);
        COUNTER_ONLY(GetGlobalPerfCounters().m_LocksAndThreads.cQueueLength--);
    }

    SyncBlockCache::GetSyncBlockCache()->LeaveCacheLock();
    return ret;
}

// Enqueue is the slow one.  We have to find the end of the Q since we don't
// want to burn storage for this in the SyncBlock.
inline void ThreadQueue::EnqueueThread(WaitEventLink *pWaitEventLink, SyncBlock *psb)
{
    COUNTER_ONLY(GetPrivatePerfCounters().m_LocksAndThreads.cQueueLength++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_LocksAndThreads.cQueueLength++);

    _ASSERTE (pWaitEventLink->m_LinkSB.m_pNext == NULL);
    SyncBlockCache::GetSyncBlockCache()->EnterCacheLock();

    SLink       *pPrior = &psb->m_Link;
    
    while (pPrior->m_pNext)
    {
        // We shouldn't already be in the waiting list!
        _ASSERTE(pPrior->m_pNext != &pWaitEventLink->m_LinkSB);

        pPrior = pPrior->m_pNext;
    }
    pPrior->m_pNext = &pWaitEventLink->m_LinkSB;
    
    SyncBlockCache::GetSyncBlockCache()->LeaveCacheLock();
}


// Wade through the SyncBlock's list of waiting threads and remove the
// specified thread.
BOOL ThreadQueue::RemoveThread (Thread *pThread, SyncBlock *psb)
{
    BOOL res = FALSE;
    SyncBlockCache::GetSyncBlockCache()->EnterCacheLock();
    SLink       *pPrior = &psb->m_Link;
    SLink       *pLink;
    WaitEventLink *pWaitEventLink;

    while ((pLink = pPrior->m_pNext) != NULL)
    {
        pWaitEventLink = WaitEventLinkForLink(pLink);
        if (pWaitEventLink->m_Thread == pThread)
        {
            pPrior->m_pNext = pLink->m_pNext;
#ifdef _DEBUG
            pLink->m_pNext = (SLink *)POISONC;
#endif
            _ASSERTE(pWaitEventLink->m_WaitSB == psb);
            res = TRUE;
            break;
        }
        pPrior = pLink;
    }
    SyncBlockCache::GetSyncBlockCache()->LeaveCacheLock();
    return res;
}

// ***************************************************************************
//
//              Ephemeral Bitmap Helper
//
// ***************************************************************************

#define card_size 32

#define card_word_width 32

size_t CardIndex (size_t card)
{ 
    return card_size * card;
}

size_t CardOf (size_t idx)
{
    return idx / card_size;
}

size_t CardWord (size_t card)
{
    return card / card_word_width;
}
inline
unsigned CardBit (size_t card)
{
    return (unsigned)(card % card_word_width);
}

inline
void SyncBlockCache::SetCard (size_t card)
{
    m_EphemeralBitmap [CardWord (card)] =
        (m_EphemeralBitmap [CardWord (card)] | (1 << CardBit (card)));
}

inline
void SyncBlockCache::ClearCard (size_t card)
{
    m_EphemeralBitmap [CardWord (card)] =
        (m_EphemeralBitmap [CardWord (card)] & ~(1 << CardBit (card)));
}

inline
BOOL  SyncBlockCache::CardSetP (size_t card)
{
    return ( m_EphemeralBitmap [ CardWord (card) ] & (1 << CardBit (card)));
}

inline
void SyncBlockCache::CardTableSetBit (size_t idx)
{
    SetCard (CardOf (idx));
}


size_t BitMapSize (size_t cacheSize)
{
    return (cacheSize + card_size * card_word_width - 1)/ (card_size * card_word_width);
}
    
// ***************************************************************************
//
//              SyncBlockCache class implementation
//
// ***************************************************************************

SyncBlockCache::SyncBlockCache()
    : m_FreeBlockList(NULL),
      m_pCleanupBlockList(NULL),
      m_CacheLock("SyncBlockCache", CrstSyncBlockCache),
      m_FreeCount(0),
      m_ActiveCount(0),
      m_SyncBlocks(0),
      m_FreeSyncBlock(0),
      m_FreeSyncTableIndex(1),
      m_FreeSyncTableList(0),
      m_SyncTableSize(SYNC_TABLE_INITIAL_SIZE),
      m_OldSyncTables(0),
      m_bSyncBlockCleanupInProgress(FALSE),
      m_EphemeralBitmap(0)
{
}


SyncBlockCache::~SyncBlockCache()
{
    // Clear the list the fast way.
    m_FreeBlockList = NULL;
    //@todo we can clear this fast too I guess
    m_pCleanupBlockList = NULL;

    // destruct all arrays
    while (m_SyncBlocks)
    {
        SyncBlockArray *next = m_SyncBlocks->m_Next;
        delete m_SyncBlocks;
        m_SyncBlocks = next;
    }

    // Also, now is a good time to clean up all the old tables which we discarded
    // when we overflowed them.
    SyncTableEntry* arr;
    while ((arr = m_OldSyncTables) != 0)
    {
        m_OldSyncTables = (SyncTableEntry*)arr[0].m_Object;
        delete arr;
    }
}

void SyncBlockCache::CleanupSyncBlocks()
{   
    // assert this call happens only in the finalizer thread
    _ASSERTE(GetThread() == GCHeap::GetFinalizerThread());
    // assert we run in cooperative mode
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

    // Set the flag indicating sync block cleanup is in progress. 
    // IMPORTANT: This must be set before the sync block cleanup bit is reset on the thread.
    m_bSyncBlockCleanupInProgress = TRUE;

    // reset the flag
    GCHeap::GetFinalizerThread()->ResetSyncBlockCleanup();   

    // walk the cleanup list and cleanup 'em up
    SyncBlock* psb;
    while ((psb = GetNextCleanupSyncBlock()) != NULL)
    {
        // We need to add the RCW's to the cleanup list to minimize the number
        // of context transitions we will need to do to clean them up.
        if (psb->m_pComData && IsComPlusWrapper(psb->m_pComData))
        {

            // Add the RCW to the clean up list and set the COM data to null
            // so that DeleteSyncBlock does not clean it up.
            size_t l = (size_t)psb->m_pComData ^ 1;
            if (l)
            {
                // We should have initialized the cleanup list with the
                // first ComPlusWrapper cache we created
                _ASSERTE(g_pRCWCleanupList != NULL);

                if (g_pRCWCleanupList->AddWrapper((ComPlusWrapper*)l))
                    psb->m_pComData = NULL;
            }
        }

        // Delete the sync block.
        DeleteSyncBlock(psb);
        // pulse GC mode to allow GC to perform its work
        if (GCHeap::GetFinalizerThread()->CatchAtSafePoint())
        {
            GCHeap::GetFinalizerThread()->PulseGCMode();
        }
    }

    // Now clean up the rcw's sorted by context
    if (g_pRCWCleanupList != NULL)
        g_pRCWCleanupList->CleanUpWrappers();

    // We are finished cleaning up the sync blocks.
    m_bSyncBlockCleanupInProgress = FALSE;
}

// create the sync block cache
BOOL SyncBlockCache::Attach()
{
#ifdef _X86_
    AwareLock::AllocLockCrst = new (&AwareLock::AllocLockCrstInstance) Crst("Global AwareLock Allocation",
                                        CrstAwareLockAlloc, FALSE, FALSE);
    return (AwareLock::AllocLockCrst != NULL);
#else
    return TRUE;
#endif
  
}

/* private class to reduce syncblock scanning for generation 0 */
/* the class keeps a list of newly created index since the last GC */
/* the list is fixed size and is used only is it hasn't overflowed */
/* it is cleared at the end of each GC */
class Gen0List 
{
public:
    static const int size = 400;
    static int index;
    static BOOL overflowed_p;
    static int list[];
    static void ClearList()
    {
        index = 0;
        overflowed_p = FALSE;
    }


    static void Add (Object* obj, int slotindex)
    {
        obj;
        if (index < size)
        {
            list [index++] = slotindex;
        }
        else
            overflowed_p = TRUE;
    }
};

int Gen0List::index = 0;
BOOL Gen0List::overflowed_p = FALSE;
int Gen0List::list[Gen0List::size];



// destroy the sync block cache
void SyncBlockCache::DoDetach()
{
    Object *pObj;
    ObjHeader  *pHeader;

    //disable the gen0 list
    Gen0List::overflowed_p = TRUE;

    // Ensure that all the critical sections are released.  This is particularly
    // important in DEBUG, because all critical sections are threaded onto a global
    // list which would otherwise be corrupted.
    for (DWORD i=0; i<m_FreeSyncTableIndex; i++)
        if (((size_t)SyncTableEntry::GetSyncTableEntry()[i].m_Object & 1) == 0)
            if (SyncTableEntry::GetSyncTableEntry()[i].m_SyncBlock)
            {
                // @TODO -- If threads are executing during this detach, they will
                // fail in various ways:
                //
                // 1) They will race between us tearing these data structures down
                //    as they navigate through them.
                //
                // 2) They will unexpectedly see the syncblock destroyed, even though
                //    they hold the synchronization lock, or have been exposed out
                //    to COM, etc.
                //
                // 3) The instance's hash code may change during the shutdown.
                //
                // The correct solution involves suspending the threads earlier, but
                // changing our suspension code so that it allows pumping if we are
                // in a shutdown case.
                //
                // cwb/rajak

                // Make sure this gets updated because the finalizer thread & others
                // will continue to run for a short while more during our shutdown.
                pObj = SyncTableEntry::GetSyncTableEntry()[i].m_Object;
                pHeader = pObj->GetHeader();
                
                pHeader->EnterSpinLock();
                DWORD appDomainIndex = pHeader->GetAppDomainIndex();
                if (! appDomainIndex)
                {
                    SyncBlock* syncBlock = pObj->PassiveGetSyncBlock();
                    if (syncBlock)
                        appDomainIndex = syncBlock->GetAppDomainIndex();
                }

                pHeader->ResetIndex();

                if (appDomainIndex)
                {
                    pHeader->SetIndex(appDomainIndex<<SBLK_APPDOMAIN_SHIFT);
                }
                pHeader->ReleaseSpinLock();

                SyncTableEntry::GetSyncTableEntry()[i].m_Object = (Object *)(m_FreeSyncTableList | 1);
                m_FreeSyncTableList = i << 1;
                
                DeleteSyncBlock(SyncTableEntry::GetSyncTableEntry()[i].m_SyncBlock);
            }
}

// destroy the sync block cache
void SyncBlockCache::Detach()
{
    SyncBlockCache::GetSyncBlockCache()->DoDetach();

#ifdef _X86_
    if (AwareLock::AllocLockCrst)
    {
        delete AwareLock::AllocLockCrst;
        AwareLock::AllocLockCrst = 0;
    }
#endif
}


// create the sync block cache
BOOL SyncBlockCache::Start()
{
    DWORD* bm = new DWORD [BitMapSize(SYNC_TABLE_INITIAL_SIZE+1)];
    if (bm == 0)
        return NULL;

    memset (bm, 0, BitMapSize (SYNC_TABLE_INITIAL_SIZE+1)*sizeof(DWORD));

    SyncTableEntry::GetSyncTableEntry() = new SyncTableEntry[SYNC_TABLE_INITIAL_SIZE+1];
    
    if (!SyncTableEntry::GetSyncTableEntry())
        return NULL;

    SyncTableEntry::GetSyncTableEntry()[0].m_SyncBlock = 0;
    SyncBlockCache::GetSyncBlockCache() = new (&g_SyncBlockCacheInstance) SyncBlockCache;
    if (SyncBlockCache::GetSyncBlockCache() == 0)
        return NULL;
    SyncBlockCache::GetSyncBlockCache()->m_EphemeralBitmap = bm;
    return 1;
}


// destroy the sync block cache
void SyncBlockCache::Stop()
{
    // cache must be destroyed first, since it can traverse the table to find all the
    // sync blocks which are live and thus must have their critical sections destroyed.
    if (SyncBlockCache::GetSyncBlockCache())
    {
        delete SyncBlockCache::GetSyncBlockCache();
        SyncBlockCache::GetSyncBlockCache() = 0;
    }

    if (SyncTableEntry::GetSyncTableEntry())
    {
        delete SyncTableEntry::GetSyncTableEntry();
        SyncTableEntry::GetSyncTableEntry() = 0;
    }

}


void    SyncBlockCache::InsertCleanupSyncBlock(SyncBlock* psb)
{
    // free up the threads that are waiting before we use the link 
    // for other purposes
    if (psb->m_Link.m_pNext != NULL)
    {
        while (ThreadQueue::DequeueThread(psb) != NULL)
            continue;
    }

    if (psb->m_pComData)
    {
        // called during GC
        // so do only minorcleanup
        MinorCleanupSyncBlockComData(psb->m_pComData);
    }

    // This method will be called only by the GC thread
    //@todo add an assert for the above statement
    // we don't need to lock here
    //EnterCacheLock();
    
    psb->m_Link.m_pNext = m_pCleanupBlockList;
    m_pCleanupBlockList = &psb->m_Link;
        
    // we don't need a lock here
    //LeaveCacheLock();
}

SyncBlock* SyncBlockCache::GetNextCleanupSyncBlock()
{
    // we don't need a lock here,
    // as this is called only on the finalizer thread currently
    
    SyncBlock       *psb = NULL;    
    if (m_pCleanupBlockList)
    {
        // get the actual sync block pointer
        psb = (SyncBlock *) (((BYTE *) m_pCleanupBlockList) - offsetof(SyncBlock, m_Link));  
        m_pCleanupBlockList = m_pCleanupBlockList->m_pNext;
    }
    return psb;
}

// returns and removes the next free syncblock from the list
// the cache lock must be entered to call this
SyncBlock *SyncBlockCache::GetNextFreeSyncBlock()
{
    SyncBlock       *psb;
    SLink           *plst = m_FreeBlockList;
    
    COUNTER_ONLY(GetGlobalPerfCounters().m_GC.cSinkBlocks ++);
    COUNTER_ONLY(GetPrivatePerfCounters().m_GC.cSinkBlocks ++);
    m_ActiveCount++;

    if (plst)
    {
        m_FreeBlockList = m_FreeBlockList->m_pNext;

        // shouldn't be 0
        m_FreeCount--;

        // get the actual sync block pointer
        psb = (SyncBlock *) (((BYTE *) plst) - offsetof(SyncBlock, m_Link));

        return psb;
    }
    else
    {
        if ((m_SyncBlocks == NULL) || (m_FreeSyncBlock >= MAXSYNCBLOCK))
        {
#ifdef DUMP_SB
//            LogSpewAlways("Allocating new syncblock array\n");
//            DumpSyncBlockCache();
#endif
            SyncBlockArray* newsyncblocks = new(SyncBlockArray);
            if (!newsyncblocks)
                return NULL;

            newsyncblocks->m_Next = m_SyncBlocks;
            m_SyncBlocks = newsyncblocks;
            m_FreeSyncBlock = 0;
        }
        return &(((SyncBlock*)m_SyncBlocks->m_Blocks)[m_FreeSyncBlock++]);
    }

}


inline DWORD SyncBlockCache::NewSyncBlockSlot(Object *obj)
{
    DWORD indexNewEntry;
    if (m_FreeSyncTableList)
    {
        indexNewEntry = (DWORD)(m_FreeSyncTableList >> 1);
        _ASSERTE ((size_t)SyncTableEntry::GetSyncTableEntry()[indexNewEntry].m_Object & 1);
        m_FreeSyncTableList = (size_t)SyncTableEntry::GetSyncTableEntry()[indexNewEntry].m_Object & ~1;
    }
    else if ((indexNewEntry = (DWORD)(m_FreeSyncTableIndex++)) >= m_SyncTableSize)
    {
        // We chain old table because we can't delete
        // them before all the threads are stoppped
        // (next GC)
        SyncTableEntry::GetSyncTableEntry() [0].m_Object = (Object *)m_OldSyncTables;
        m_OldSyncTables = SyncTableEntry::GetSyncTableEntry();
        SyncTableEntry* newSyncTable = NULL;

        // Compute the size of the new synctable. Normally, we double it - unless
        // doing so would create slots with indices too high to fit within the
        // mask. If so, we create a synctable up to the mask limit. If we're
        // already at the mask limit, then caller is out of luck. 
        DWORD newSyncTableSize;
        DWORD* newBitMap = 0;;
        if (m_SyncTableSize <= (MASK_SYNCBLOCKINDEX >> 1))
        {
            newSyncTableSize = m_SyncTableSize * 2;
        }
        else
        {
            newSyncTableSize = MASK_SYNCBLOCKINDEX;
        }

        if (newSyncTableSize > m_SyncTableSize) // Make sure we actually found room to grow!
   
        {
            newSyncTable = new(SyncTableEntry[newSyncTableSize]);
            newBitMap = new(DWORD[BitMapSize (newSyncTableSize)]);
        }
        if (!newSyncTable || !newBitMap)
        {
            m_FreeSyncTableIndex--;
            return 0;
        }
        memset (newBitMap, 0, BitMapSize (newSyncTableSize)*sizeof (DWORD));
        CopyMemory (newSyncTable, SyncTableEntry::GetSyncTableEntry(),
                    m_SyncTableSize*sizeof (SyncTableEntry));

        CopyMemory (newBitMap, m_EphemeralBitmap,
                    BitMapSize (m_SyncTableSize)*sizeof (DWORD));

        delete m_EphemeralBitmap;
        m_EphemeralBitmap = newBitMap;

        m_SyncTableSize = newSyncTableSize;

		_ASSERTE((m_SyncTableSize & MASK_SYNCBLOCKINDEX) == m_SyncTableSize);
        SyncTableEntry::GetSyncTableEntry() = newSyncTable;
#ifndef _DEBUG
    }
#else
        static int dumpSBOnResize = g_pConfig->GetConfigDWORD(L"SBDumpOnResize", 0);
        if (dumpSBOnResize)
        {
            LogSpewAlways("SyncBlockCache resized\n");
            DumpSyncBlockCache();
        }
    } 
    else
    {
        static int dumpSBOnNewIndex = g_pConfig->GetConfigDWORD(L"SBDumpOnNewIndex", 0);
        if (dumpSBOnNewIndex)
        {
            LogSpewAlways("SyncBlockCache index incremented\n");
            DumpSyncBlockCache();
        }
    }
#endif

    Gen0List::Add (obj, indexNewEntry);

    CardTableSetBit (indexNewEntry);

    SyncTableEntry::GetSyncTableEntry() [indexNewEntry].m_Object = obj;
    SyncTableEntry::GetSyncTableEntry() [indexNewEntry].m_SyncBlock = NULL;

    _ASSERTE(indexNewEntry != 0);

    return indexNewEntry;
}


// free a used sync block
void SyncBlockCache::DeleteSyncBlock(SyncBlock *psb)
{
    // clean up comdata 
    if (psb->m_pComData)
        CleanupSyncBlockComData(psb->m_pComData);
   
#ifdef EnC_SUPPORTED
    // clean up EnC info
    if (psb->m_pEnCInfo)
        psb->m_pEnCInfo->Cleanup();
#endif // EnC_SUPPORTED

    // Destruct the SyncBlock, but don't reclaim its memory.  (Overridden
    // operator delete).
    delete psb;
    
    COUNTER_ONLY(GetGlobalPerfCounters().m_GC.cSinkBlocks --);
    COUNTER_ONLY(GetPrivatePerfCounters().m_GC.cSinkBlocks --);

    //synchronizer with the consumers, 
    // @todo we don't really need a lock here, we can come up
    // with some simple algo to avoid taking a lock :rajak
    EnterCacheLock();
    
    m_ActiveCount--;
    m_FreeCount++;

    psb->m_Link.m_pNext = m_FreeBlockList;
    m_FreeBlockList = &psb->m_Link;
    
    LeaveCacheLock();
}

// free a used sync block
void SyncBlockCache::GCDeleteSyncBlock(SyncBlock *psb)
{
    // Destruct the SyncBlock, but don't reclaim its memory.  (Overridden
    // operator delete).
    delete psb;
    
    COUNTER_ONLY(GetGlobalPerfCounters().m_GC.cSinkBlocks --);
    COUNTER_ONLY(GetPrivatePerfCounters().m_GC.cSinkBlocks --);

    
    m_ActiveCount--;
    m_FreeCount++;

    psb->m_Link.m_pNext = m_FreeBlockList;
    m_FreeBlockList = &psb->m_Link;
    
}

void SyncBlockCache::GCWeakPtrScan(HANDLESCANPROC scanProc, LPARAM lp1, LPARAM lp2)
{
    // First delete the obsolete arrays since we have exclusive access
    BOOL fSetSyncBlockCleanup = FALSE;
    
    SyncTableEntry* arr;
    while ((arr = m_OldSyncTables) != NULL)
    {
        m_OldSyncTables = (SyncTableEntry*)arr[0].m_Object;
        delete arr;
    }

#ifdef DUMP_SB
    LogSpewAlways("GCWeakPtrScan starting\n");
#endif

    //if we are doing gen0 collection and the list hasn't overflowed, 
    //scan only the list
    if ((g_pGCHeap->GetCondemnedGeneration() == 0) && (Gen0List::overflowed_p != TRUE))
    {
        //scan only the list 
        int i = 0;
        while (i < Gen0List::index)
        {
			if (GCWeakPtrScanElement (Gen0List::list[i], scanProc, lp1, lp2, fSetSyncBlockCleanup))
            {
                Gen0List::list[i] = Gen0List::list[--Gen0List::index];
            }
            else
                i++;
        }
    }
    else if (g_pGCHeap->GetCondemnedGeneration() < g_pGCHeap->GetMaxGeneration())
    {
        size_t max_gen = g_pGCHeap->GetMaxGeneration();
        //scan the bitmap 
        size_t dw = 0; 
        while (1)
        {
            while (dw < BitMapSize (m_SyncTableSize) && (m_EphemeralBitmap[dw]==0))
            {
                dw++;
            }
            if (dw < BitMapSize (m_SyncTableSize))
            {
                //found one 
                for (int i = 0; i < card_word_width; i++)
                {
                    size_t card = i+dw*card_word_width;
                    if (CardSetP (card))
                    {
                        BOOL clear_card = TRUE;
                        for (int idx = 0; idx < card_size; idx++)
                        {
                            size_t nb = CardIndex (card) + idx;
                            if (( nb < m_FreeSyncTableIndex) && (nb > 0))
                            {
                                Object* o = SyncTableEntry::GetSyncTableEntry()[nb].m_Object;
                                SyncBlock* pSB = SyncTableEntry::GetSyncTableEntry()[nb].m_SyncBlock;
                                if (o && !((size_t)o & 1))
                                {
                                    if (g_pGCHeap->IsEphemeral (o))
                                    {
                                        clear_card = FALSE;
                                        GCWeakPtrScanElement ((int)nb, scanProc, 
                                                              lp1, lp2, fSetSyncBlockCleanup);
                                    }
                                }
                            }
                        }
                        if (clear_card)
                            ClearCard (card);
                    }
                }
                dw++;
            }
            else
                break;
        }
    }
    else 
    {
        for (DWORD nb = 1; nb < m_FreeSyncTableIndex; nb++)
        {
            GCWeakPtrScanElement (nb, scanProc, lp1, lp2, fSetSyncBlockCleanup);
        }

        //we have a possibility of demotion, which we won't know until too late
        //if concurrent gc is on. Get rid of all of the deleted entries while we can during promotion
        if ((((ScanContext*)lp1)->promotion) &&
            (g_pGCHeap->GetCondemnedGeneration() == g_pGCHeap->GetMaxGeneration()))
        {
            int i = 0;
            while (i < Gen0List::index)
            {
                Object* o = SyncTableEntry::GetSyncTableEntry()[Gen0List::list[i]].m_Object;
                if ((size_t)o & 1)
                {
                    Gen0List::list[i] = Gen0List::list[--Gen0List::index];
                }
                else
                    i++;
            }
        }

    }

    if (fSetSyncBlockCleanup)
    {
        // mark the finalizer thread saying requires cleanup
        GCHeap::GetFinalizerThread()->SetSyncBlockCleanup();
        GCHeap::EnableFinalization();
    }

#if defined(VERIFY_HEAP)
    if (g_pConfig->IsHeapVerifyEnabled())
    {
        if (((ScanContext*)lp1)->promotion)
        {

            for (int nb = 1; nb < (int)m_FreeSyncTableIndex; nb++)
            {
                Object* o = SyncTableEntry::GetSyncTableEntry()[nb].m_Object;
                if (((size_t)o & 1) == 0)
                {
                    o->Validate();
                }
            }
        }
    }
#endif // VERIFY_HEAP
}

/* Scan the weak pointers in the SyncBlockEntry and report them to the GC.  If the
   reference is dead, then return TRUE */

BOOL SyncBlockCache::GCWeakPtrScanElement (int nb, HANDLESCANPROC scanProc, LPARAM lp1, LPARAM lp2, 
                                           BOOL& cleanup)
{
    Object **keyv = (Object **) &SyncTableEntry::GetSyncTableEntry()[nb].m_Object;

#ifdef DUMP_SB
    char *name;
    __try {
        if (! *keyv)
            name = "null";
        else if ((size_t) *keyv & 1)
            name = "free";
        else {
            name = (*keyv)->GetClass()->m_szDebugClassName;
            if (strlen(name) == 0)
                name = "<INVALID>";
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        name = "<INVALID>";
    }
    LogSpewAlways("[%4.4d]: %8.8x, %s\n", nb, *keyv, name);
#endif
    if (((size_t) *keyv & 1) == 0)
    {
        (*scanProc) (keyv, NULL, lp1, lp2);
        SyncBlock   *pSB = SyncTableEntry::GetSyncTableEntry()[nb].m_SyncBlock;
        if ((*keyv == 0 ) || (pSB && pSB->IsIDisposable()))
        {
            if (*keyv)
            {
                _ASSERTE (pSB);
                GCDeleteSyncBlock(pSB);
                //clean the object syncblock header
                ((Object*)(*keyv))->GetHeader()->GCResetIndex();
            }
            else if (pSB)
            {

                cleanup = TRUE;
                // insert block into cleanup list
                InsertCleanupSyncBlock (SyncTableEntry::GetSyncTableEntry()[nb].m_SyncBlock);
#ifdef DUMP_SB
                LogSpewAlways("       Cleaning up block at %4.4d\n", nb);
#endif
            }

            // delete the entry
#ifdef DUMP_SB
            LogSpewAlways("       Deleting block at %4.4d\n", nb);
#endif
            SyncTableEntry::GetSyncTableEntry()[nb].m_Object = (Object *)(m_FreeSyncTableList | 1);
            m_FreeSyncTableList = nb << 1;
			return TRUE;
        }
        else
        {
#ifdef DUMP_SB
            LogSpewAlways("       Keeping block at %4.4d with oref %8.8x\n", nb, *keyv);
#endif
        }
    }
	return FALSE;
}

void SyncBlockCache::GCDone(BOOL demoting)
{
    if (demoting)
    {
        if (!Gen0List::overflowed_p &&
            (g_pGCHeap->GetCondemnedGeneration() == 0))
        {
            //We need to keep all gen0 indices and delete all deleted entries
            // to improve compaction of the list remove all elements not in generation 0;
        
            int i = 0;
            while (i < Gen0List::index)
            {
                Object* o = SyncTableEntry::GetSyncTableEntry()[Gen0List::list[i]].m_Object;
                if (((size_t)o & 1) || (GCHeap::WhichGeneration (o) != 0))
                {
                    Gen0List::list[i] = Gen0List::list[--Gen0List::index];
                }
                else
                    i++;
            }
        }
        else
        {
            //we either scan the whole list to find 1->0 demotion
            //or we just overflow. 
            Gen0List::overflowed_p = TRUE;
        }

    }
    else
        Gen0List::ClearList();
}


#if defined (VERIFY_HEAP)

#ifndef _DEBUG
#ifdef _ASSERTE
#undef _ASSERTE
#endif
#define _ASSERTE(c) if (!(c)) DebugBreak()
#endif

void SyncBlockCache::VerifySyncTableEntry()
{
    for (DWORD nb = 1; nb < m_FreeSyncTableIndex; nb++)
    {
        Object* o = SyncTableEntry::GetSyncTableEntry()[nb].m_Object;
        if (((size_t)o & 1) == 0) {
            o->Validate();
            _ASSERTE (o->GetHeader()->GetHeaderSyncBlockIndex() == nb);
            if (!Gen0List::overflowed_p && Gen0List::index > 0 && GCHeap::WhichGeneration(o) == 0) {
                int i;
                for (i = 0; i < Gen0List::index; i++) {
                    if ((size_t) Gen0List::list[i] == nb) {
                        break;
                    }
                }
                _ASSERTE ((i != Gen0List::index) || !"A SyncTableEntry is in Gen0, but not in Gen0List");
            }
        }
    }
}

#ifndef _DEBUG
#undef _ASSERTE
#define _ASSERTE(expr) ((void)0)
#endif   // _DEBUG

#endif // VERIFY_HEAP

#if CHECK_APP_DOMAIN_LEAKS 
void SyncBlockCache::CheckForUnloadedInstances(DWORD unloadingIndex)
{
    // Can only do in leak mode because agile objects will be in the domain with
    // their index set to their creating domain and check will fail.
    if (! g_pConfig->AppDomainLeaks())
        return;

    for (DWORD nb = 1; nb < m_FreeSyncTableIndex; nb++)
    {
        SyncTableEntry *pEntry = &SyncTableEntry::GetSyncTableEntry()[nb];
        Object *oref = (Object *) pEntry->m_Object;
        if (((size_t) oref & 1) != 0)
            continue;

        DWORD idx = 0;
        if (oref)
            idx = pEntry->m_Object->GetHeader()->GetRawAppDomainIndex();
        if (! idx && pEntry->m_SyncBlock)
            idx = pEntry->m_SyncBlock->GetAppDomainIndex();
        // if the following assert fires, someobody is holding a reference to an object in an unloaded appdomain
        if (idx == unloadingIndex)
            // object must be agile to have survived the unload. If can't make it agile, that's a bug
            if (!oref->SetAppDomainAgile(FALSE))
                _ASSERTE(!"Detected instance of unloaded appdomain that survived GC\n");
    }
}
#endif

#ifdef _DEBUG

void DumpSyncBlockCache()
{
    SyncBlockCache *pCache = SyncBlockCache::GetSyncBlockCache();

    LogSpewAlways("Dumping SyncBlockCache size %d\n", pCache->m_FreeSyncTableIndex);

    static int dumpSBStyle = -1;
    if (dumpSBStyle == -1)
        dumpSBStyle = g_pConfig->GetConfigDWORD(L"SBDumpStyle", 0);
    if (dumpSBStyle == 0)
        return;

    BOOL isString;
    DWORD objectCount = 0;
    DWORD slotCount = 0;

    for (DWORD nb = 1; nb < pCache->m_FreeSyncTableIndex; nb++)
    {
        isString = FALSE;
        char buffer[1024], buffer2[1024];
        char *descrip = "null";
        SyncTableEntry *pEntry = &SyncTableEntry::GetSyncTableEntry()[nb];
        Object *oref = (Object *) pEntry->m_Object;
        if (((size_t) oref & 1) != 0)
        {
            descrip = "free";
            oref = 0;
        }
        else 
        {
            ++slotCount;
            if (oref) 
            {
                ++objectCount;
                __try 
                {
                    descrip = oref->GetClass()->m_szDebugClassName;
                    if (strlen(descrip) == 0)
                        descrip = "<INVALID>";
                    else if (oref->GetMethodTable() == g_pStringClass)
                    {
                        sprintf(buffer2, "%s (%S)", descrip, ObjectToSTRINGREF((StringObject*)oref)->GetBuffer());
                        descrip = buffer2;
                        isString = TRUE;
                    }
                } __except(EXCEPTION_EXECUTE_HANDLER) {
                    descrip = "<INVALID>";
                }
            }
            DWORD idx = 0;
            if (oref)
                idx = pEntry->m_Object->GetHeader()->GetRawAppDomainIndex();
            if (! idx && pEntry->m_SyncBlock)
                idx = pEntry->m_SyncBlock->GetAppDomainIndex();
            if (idx && ! SystemDomain::System()->TestGetAppDomainAtIndex(idx))
            {
                sprintf(buffer, "** unloaded (%3.3x) %s", idx, descrip);
                descrip = buffer;
            }
            else 
            {
                sprintf(buffer, "(AD %3.3x) %s", idx, descrip);
                descrip = buffer;
            }
        }
        if (dumpSBStyle < 2)
            LogSpewAlways("[%4.4d]: %8.8x %s\n", nb, oref, descrip);
        else if (dumpSBStyle == 2 && ! isString)
            LogSpewAlways("[%4.4d]: %s\n", nb, descrip);
    }
    LogSpewAlways("Done dumping SyncBlockCache used slots: %d, objects: %d\n", slotCount, objectCount);
}
#endif

// ***************************************************************************
//
//              ObjHeader class implementation
//
// ***************************************************************************

// this enters the monitor of an object
void ObjHeader::EnterObjMonitor()
{
    GetSyncBlock()->EnterMonitor();
}

// Non-blocking version of above
BOOL ObjHeader::TryEnterObjMonitor(INT32 timeOut)
{
    return GetSyncBlock()->TryEnterMonitor(timeOut);
}

// must be created here already
void ObjHeader::LeaveObjMonitor()
{
    _ASSERTE(GetHeaderSyncBlockIndex());

    PassiveGetSyncBlock()->LeaveMonitor();
}

#ifdef MP_LOCKS
void ObjHeader::EnterSpinLock()
{
#ifdef _DEBUG
    int i = 0;
#endif

    while (TRUE)
    {
#ifdef _DEBUG
        if (i++ > 10000)
            _ASSERTE(!"ObjHeader::EnterLock timed out");
#endif
        // get the value so that it doesn't get changed under us. 
        // Must cast through volatile to ensure the lock is refetched from memory.
        LONG curValue = *(volatile LONG*)&m_SyncBlockValue;

        // check if lock taken
        if (! (curValue & BIT_SBLK_SPIN_LOCK))
        {
            // try to take the lock
            LONG newValue = curValue | BIT_SBLK_SPIN_LOCK;
#pragma warning(disable:4312)
#pragma warning(disable:4311)
			// TODO: WIN64: Threse pragma's should be removed.
			// TODO: WIN64: should m_SyncBlockValue be size_t
            LONG result = (LONG)FastInterlockCompareExchange((LPVOID*)&m_SyncBlockValue, (LPVOID)newValue, (LPVOID)curValue);
#pragma warning(default:4311)
#pragma warning(disable:4312)
            if (result == curValue)
                return;
        }
        if  (g_SystemInfo.dwNumberOfProcessors > 1)
        {
            for (int spinCount = 0; spinCount < BIT_SBLK_SPIN_COUNT; spinCount++)
            {
                if  (! (*(volatile LONG*)&m_SyncBlockValue & BIT_SBLK_SPIN_LOCK))
                    break;
				pause();			// indicate to the processor that we are spining 
            }
            if  (*(volatile LONG*)&m_SyncBlockValue & BIT_SBLK_SPIN_LOCK)
                __SwitchToThread(0);
        }
        else
            __SwitchToThread(0);
    } 
}
#else
void ObjHeader::EnterSpinLock()
{
#ifdef _DEBUG
    int i = 0;
#endif
    unsigned int spinCount = 0;

    while (TRUE)
    {
#ifdef _DEBUG
        if (i++ > 10000)
            _ASSERTE(!"ObjHeader::EnterLock timed out");
#endif
        // get the value so that it doesn't get changed under us. 
        // Must cast through volatile to ensure the lock is refetched from memory.
        void* curValue = (void*)(size_t)*(volatile LONG*)&m_SyncBlockValue; //WIN64 converted to void* for use with FastInterlockCompareExchange below

        // check if lock taken
        if (! ((size_t)curValue & BIT_SBLK_SPIN_LOCK))
        {
            // try to take the lock
            void* newValue = (void*)((size_t)curValue | BIT_SBLK_SPIN_LOCK);
            void* result = FastInterlockCompareExchange((LPVOID*)&m_SyncBlockValue, (LPVOID)newValue, (LPVOID)curValue);
            if (result == curValue)
                return;
        }
        __SwitchToThread(0);
    } 
}
#endif //MP_LOCKS

void ObjHeader::ReleaseSpinLock()
{
    FastInterlockAnd(&m_SyncBlockValue, ~BIT_SBLK_SPIN_LOCK);
}

DWORD ObjHeader::GetRawAppDomainIndex()
{
    // pull the value out before checking it to avoid race condition
    DWORD value = m_SyncBlockValue;
    if ((value & BIT_SBLK_IS_SYNCBLOCKINDEX) == 0)
        return (value >> SBLK_APPDOMAIN_SHIFT) & SBLK_MASK_APPDOMAININDEX;
    return 0;
}

DWORD ObjHeader::GetAppDomainIndex()
{
    DWORD indx = GetRawAppDomainIndex();
    if (indx)
        return indx;
    SyncBlock* syncBlock = GetBaseObject()->PassiveGetSyncBlock();
    if (! syncBlock)
        return 0;

    return syncBlock->GetAppDomainIndex();
}

void ObjHeader::SetAppDomainIndex(DWORD indx)
{
    // 
    // This should only be called during the header initialization,
    // so don't worry about races.
    // 

    BOOL done = FALSE;

#ifdef _DEBUG
    static int forceSB = g_pConfig->GetConfigDWORD(L"ADForceSB", 0);
    if (forceSB)
		// force a synblock so we get one for every object.
		GetSyncBlock();
#endif

    if (GetHeaderSyncBlockIndex() == 0 && indx < SBLK_MASK_APPDOMAININDEX) 
    {
        EnterSpinLock();
        //Try one more time
        if (GetHeaderSyncBlockIndex() == 0)
        {
            // can store it in the object header
            FastInterlockOr(&m_SyncBlockValue, indx << SBLK_APPDOMAIN_SHIFT);
            done = TRUE;
        }
        ReleaseSpinLock();
    } 
        
    if (!done)
    {
        // must create a syncblock entry and store the appdomain indx there
        SyncBlock *psb = GetSyncBlock();
        _ASSERTE(psb);
        psb->SetAppDomainIndex(indx);
    }
}

DWORD ObjHeader::GetSyncBlockIndex()
{
    THROWSCOMPLUSEXCEPTION();

    DWORD   indx;

    if ((indx = GetHeaderSyncBlockIndex()) == 0)
    {
        if (GetAppDomainIndex())
        {
            // if have an appdomain set then must create a sync block to store it
            GetSyncBlock();
        } 
        else
        {
            //Need to get it from the cache
            SyncBlockCache::GetSyncBlockCache()->EnterCacheLock();

            //Try one more time
            if (GetHeaderSyncBlockIndex() != 0)
            {
                SyncBlockCache::GetSyncBlockCache()->LeaveCacheLock();
            } 
            else
            {
                EnterSpinLock();
                // Now the header will be stable - check whether appdomain index or lock information is stored in it.
                DWORD bits = GetBits();
                if ((bits & BIT_SBLK_IS_SYNCBLOCKINDEX) == 0 &&
                    (bits & ((SBLK_MASK_APPDOMAININDEX<<SBLK_APPDOMAIN_SHIFT)|SBLK_MASK_LOCK_RECLEVEL|SBLK_MASK_LOCK_THREADID)) != 0)
                {
                    // Need a sync block to store this info
                    ReleaseSpinLock();
                    SyncBlockCache::GetSyncBlockCache()->LeaveCacheLock();
                    GetSyncBlock();
                }
                else
                {
                    SetIndex(BIT_SBLK_IS_SYNCBLOCKINDEX | SyncBlockCache::GetSyncBlockCache()->NewSyncBlockSlot(GetBaseObject()));
                    ReleaseSpinLock();
                    SyncBlockCache::GetSyncBlockCache()->LeaveCacheLock();
                }
            }
        }
        if ((indx = GetHeaderSyncBlockIndex()) == 0)
            COMPlusThrowOM();
    }

    return indx;
}

// get the sync block for an existing object
SyncBlock *ObjHeader::GetSyncBlock()
{   
    THROWSCOMPLUSEXCEPTION();
    SyncBlock* syncBlock = GetBaseObject()->PassiveGetSyncBlock();
    DWORD      indx = 0;
    BOOL indexHeld = FALSE;

    if (syncBlock)
    {
        // Has our backpointer been correctly updated through every GC?
        _ASSERTE(SyncTableEntry::GetSyncTableEntry()[GetHeaderSyncBlockIndex()].m_Object == GetBaseObject());
        return syncBlock;
    }

    //Need to get it from the cache
    SyncBlockCache::GetSyncBlockCache()->EnterCacheLock();


    //Try one more time
    syncBlock = GetBaseObject()->PassiveGetSyncBlock();
    if (syncBlock)
        goto Done;

    if ((indx = GetHeaderSyncBlockIndex()) == 0)
    {
        indx = SyncBlockCache::GetSyncBlockCache()->NewSyncBlockSlot(GetBaseObject());
        if (indx == 0)
            goto Die;
    }
    else
    {
        //We already have an index, we need to hold the syncblock
        indexHeld = TRUE;
    }

    syncBlock = new (SyncBlockCache::GetSyncBlockCache()->GetNextFreeSyncBlock()) SyncBlock(indx);

    if (!syncBlock)
    {
Die:
        SyncBlockCache::GetSyncBlockCache()->LeaveCacheLock();
        COMPlusThrowOM();
        _ASSERTE(FALSE);
    }

    // after this point, nobody can update the index in the header to give an AD index
    EnterSpinLock();

    {
        // If there's an appdomain index stored in the header, transfer it to the syncblock

		DWORD dwAppDomainIndex = GetAppDomainIndex();
		if (dwAppDomainIndex)
			syncBlock->SetAppDomainIndex(dwAppDomainIndex);
                
        // If the thin lock in the header is in use, transfer the information to the syncblock
        DWORD bits = GetBits();
        if ((bits & BIT_SBLK_IS_SYNCBLOCKINDEX) == 0)
        {
            DWORD lockThreadId = bits & SBLK_MASK_LOCK_THREADID;
            DWORD recursionLevel = (bits & SBLK_MASK_LOCK_RECLEVEL) >> SBLK_RECLEVEL_SHIFT;
            if (lockThreadId != 0 || recursionLevel != 0)
            {
                // recursionLevel can't be non-zero if thread id is 0
                _ASSERTE(lockThreadId != 0);

                Thread *pThread = g_pThinLockThreadIdDispenser->IdToThread(lockThreadId);

                _ASSERTE(pThread != NULL);
                syncBlock->SetAwareLock(pThread, recursionLevel + 1);
            }
        }
    }

    SyncTableEntry::GetSyncTableEntry() [indx].m_SyncBlock = syncBlock;

    // in order to avoid a race where some thread tries to get the AD index and we've already nuked it,
    // make sure the syncblock etc is all setup with the AD index prior to replacing the index
    // in the header
    if (GetHeaderSyncBlockIndex() == 0)
    {
        // We have transferred the AppDomain into the syncblock above. 
        SetIndex(BIT_SBLK_IS_SYNCBLOCKINDEX | indx);
    }

    //If we had already an index, hold the syncblock 
    //for the lifetime of the object. 
    if (indexHeld)
        syncBlock->SetPrecious();

    ReleaseSpinLock();

Done:

    SyncBlockCache::GetSyncBlockCache()->LeaveCacheLock();

    return syncBlock;
}


// COM Interop has special access to sync blocks
// for now check if we already have a sync block
// other wise create one, 
// returns NULL in case of exceptions
SyncBlock* ObjHeader::GetSyncBlockSpecial()
{
    SyncBlock* syncBlock = GetBaseObject()->PassiveGetSyncBlock();
    if (syncBlock == NULL)
    {
        COMPLUS_TRY
        {
            syncBlock = GetSyncBlock();
        }
        COMPLUS_CATCH
        {
            syncBlock = NULL;
        }
        COMPLUS_END_CATCH
    }
    return syncBlock;
}

SyncBlock* ObjHeader::GetRawSyncBlock()
{
    return GetBaseObject()->PassiveGetSyncBlock();
}

BOOL ObjHeader::Wait(INT32 timeOut, BOOL exitContext)
{
    THROWSCOMPLUSEXCEPTION();

    //  The following code may cause GC, so we must fetch the sync block from
    //  the object now in case it moves.
    SyncBlock *pSB = GetBaseObject()->GetSyncBlock();

    // make sure we have a sync block
    // and make sure we own the crst
    if ((pSB == NULL) || !pSB->DoesCurrentThreadOwnMonitor())
        COMPlusThrow(kSynchronizationLockException);

    return pSB->Wait(timeOut,exitContext);
}

void ObjHeader::Pulse()
{
    THROWSCOMPLUSEXCEPTION();

    //  The following code may cause GC, so we must fetch the sync block from
    //  the object now in case it moves.
    SyncBlock *pSB = GetBaseObject()->GetSyncBlock();

    // make sure we have a sync block
    // and make sure we own the crst
    if ((pSB == NULL) || !pSB->DoesCurrentThreadOwnMonitor())
        COMPlusThrow(kSynchronizationLockException);

    pSB->Pulse();
}

void ObjHeader::PulseAll()
{
    THROWSCOMPLUSEXCEPTION();

    //  The following code may cause GC, so we must fetch the sync block from
    //  the object now in case it moves.
    SyncBlock *pSB = GetBaseObject()->GetSyncBlock();

    // make sure we have a sync block
    // and make sure we own the crst
    if ((pSB == NULL) || !pSB->DoesCurrentThreadOwnMonitor())
        COMPlusThrow(kSynchronizationLockException);

    pSB->PulseAll();
}


// ***************************************************************************
//
//              AwareLock class implementation (GC-aware locking)
//
// ***************************************************************************

// There are two implementations of AwareLock.  For _X86_ we do the interlocked
// increment and decrement ourselves.

Crst *AwareLock::AllocLockCrst = NULL;
BYTE  AwareLock::AllocLockCrstInstance[sizeof(Crst)];

void AwareLock::AllocLockSemEvent()
{
    THROWSCOMPLUSEXCEPTION();

    // Before we switch from cooperative, ensure that this syncblock won't disappear
    // under us.  For something as expensive as an event, do it permanently rather
    // than transiently.
    SetPrecious();

    Thread *pCurThread = GetThread();
    BOOL    toggleGC = pCurThread->PreemptiveGCDisabled();
    HANDLE  h;

    if (toggleGC)
    {
        pCurThread->EnablePreemptiveGC();
    }

    AllocLockCrst->Enter();

    // once we've actually entered, someone else might have got in ahead of us and
    // allocated it.
    h = (m_SemEvent == INVALID_HANDLE_VALUE
         ? ::WszCreateEvent(NULL, FALSE/*AutoReset*/, FALSE/*NotSignalled*/, NULL)
         : NULL);

    if (h != NULL)
        m_SemEvent = h;

    AllocLockCrst->Leave();

    if (toggleGC)
    {
        pCurThread->DisablePreemptiveGC();
    }

    if (m_SemEvent == INVALID_HANDLE_VALUE)
        COMPlusThrowOM();
}

void AwareLock::Enter()
{
    THROWSCOMPLUSEXCEPTION();

    Thread  *pCurThread = GetThread();

#ifdef _X86_
    // Need to do this to get round bug in __asm.
    enum { m_HoldingThreadOffset = offsetof(AwareLock, m_HoldingThread) };

    // todo rudim: zap lock prefixes in uni-processor case.
    __asm {
      retry:
        mov             ecx, this
        mov             eax, [ecx]AwareLock.m_MonitorHeld
        test            eax, eax
        jne             have_waiters
        // Common case: lock not held, no waiters. Attempt to acquire lock by
        // switching lock bit.
        mov             ebx, 1
        lock cmpxchg    [ecx]AwareLock.m_MonitorHeld, ebx
        jne             retry_helper
        jmp             locked
      have_waiters:
        // It's possible to get here with waiters but no lock held, but in this
        // case a signal is about to be fired which will wake up a waiter. So
        // for fairness sake we should wait too.
        // Check first for recursive lock attempts on the same thread.
        mov             edx, pCurThread
        cmp             [ecx+m_HoldingThreadOffset], edx
        jne             prepare_to_wait
        jmp             Recursion
        // Attempt to increment this count of waiters then goto contention
        // handling code.
      prepare_to_wait:
        lea             ebx, [eax+2]
        lock cmpxchg    [ecx]AwareLock.m_MonitorHeld, ebx
        jne             retry_helper
        jmp             MustWait
      retry_helper:
        jmp             retry
      locked:
    }
#else
    for (;;) {

        // Read existing lock state.
        LONG state = m_MonitorHeld;

        if (state == 0) {

            // Common case: lock not held, no waiters. Attempt to acquire lock by
            // switching lock bit.
            if (FastInterlockCompareExchange((void**)&m_MonitorHeld,
                                             (void*)1,
                                             (void*)0) == (void*)0)
                break;

        } else {

            // It's possible to get here with waiters but no lock held, but in this
            // case a signal is about to be fired which will wake up a waiter. So
            // for fairness sake we should wait too.
            // Check first for recursive lock attempts on the same thread.
            if (m_HoldingThread == pCurThread)
                goto Recursion;

            // Attempt to increment this count of waiters then goto contention
            // handling code.
            if (FastInterlockCompareExchange((void**)&m_MonitorHeld,
                                             (void*)(state + 2),
                                             (void*)state) == (void*)state)
                goto MustWait;
        }

    } 
#endif

    // We get here if we successfully acquired the mutex.
    m_HoldingThread = pCurThread;
    m_Recursion = 1;
    pCurThread->IncLockCount();

#if defined(_DEBUG) && defined(TRACK_SYNC)
    {
        // The best place to grab this is from the ECall frame
        Frame   *pFrame = pCurThread->GetFrame();
        int      caller = (pFrame && pFrame != FRAME_TOP
                            ? (int) pFrame->GetReturnAddress()
                            : -1);
        pCurThread->m_pTrackSync->EnterSync(caller, this);
    }
#endif

    return;

 MustWait:
    // Didn't manage to get the mutex, must wait.
    EnterEpilog(pCurThread);
    return;

 Recursion:
    // Got the mutex via recursive locking on the same thread.
    _ASSERTE(m_Recursion >= 1);
    m_Recursion++;
#if defined(_DEBUG) && defined(TRACK_SYNC)
    // The best place to grab this is from the ECall frame
    Frame   *pFrame = pCurThread->GetFrame();
    int      caller = (pFrame && pFrame != FRAME_TOP
                       ? (int) pFrame->GetReturnAddress()
                       : -1);
    pCurThread->m_pTrackSync->EnterSync(caller, this);
#endif
}

BOOL AwareLock::TryEnter(INT32 timeOut)
{
    THROWSCOMPLUSEXCEPTION();

    Thread  *pCurThread = GetThread();

#ifdef _X86_
    // Need to do this to get round bug in __asm.
    enum { m_HoldingThreadOffset = offsetof(AwareLock, m_HoldingThread) };

    // @todo rudim: zap lock prefixes in uni-processor case.
    retry:
   __asm {
        mov             ecx, this
        mov             eax, [ecx]AwareLock.m_MonitorHeld
        test            eax, eax
        jne             have_waiters
        // Common case: lock not held, no waiters. Attempt to acquire lock by
        // switching lock bit.
        mov             ebx, 1
        lock cmpxchg    [ecx]AwareLock.m_MonitorHeld, ebx
        jne             retry_helper
        jmp             locked
      have_waiters:
        // It's possible to get here with waiters but no lock held, but in this
        // case a signal is about to be fired which will wake up a waiter. So
        // for fairness sake we should wait too.
        // Check first for recursive lock attempts on the same thread.
        mov             edx, pCurThread
        cmp             [ecx+m_HoldingThreadOffset], edx
        jne             WouldBlock
        jmp             Recursion
      retry_helper:
        jmp             retry
      locked:
    }
#else
retry:
	for (;;) {

        // Read existing lock state.
        LONG state = m_MonitorHeld;

        if (state == 0) {

            // Common case: lock not held, no waiters. Attempt to acquire lock by
            // switching lock bit.
            if (FastInterlockCompareExchange((void**)&m_MonitorHeld,
                                             (void*)1,
                                             (void*)0) == (void*)0)
                break;

        } else {

            // It's possible to get here with waiters but no lock held, but in this
            // case a signal is about to be fired which will wake up a waiter. So
            // for fairness sake we should wait too.
            // Check first for recursive lock attempts on the same thread.
            if (m_HoldingThread == pCurThread)
                goto Recursion;

            goto WouldBlock;

        }

    } 
#endif

    // We get here if we successfully acquired the mutex.
    m_HoldingThread = pCurThread;
    m_Recursion = 1;
    pCurThread->IncLockCount(); 

#if defined(_DEBUG) && defined(TRACK_SYNC)
    {
        // The best place to grab this is from the ECall frame
        Frame   *pFrame = pCurThread->GetFrame();
        int      caller = (pFrame && pFrame != FRAME_TOP
                            ? (int) pFrame->GetReturnAddress()
                            : -1);
        pCurThread->m_pTrackSync->EnterSync(caller, this);
    }
#endif

    return true;

 WouldBlock:
    // Didn't manage to get the mutex, return failure if no timeout, else wait
    // for at most timeout milliseconds for the mutex.
    if (!timeOut)
        return false;

    // The precondition for EnterEpilog is that the count of waiters be bumped
    // to account for this thread
    for (;;)
    {
        // Read existing lock state.
        volatile void* state = m_MonitorHeld;
		
		if ( state == 0) 
			goto retry;
        if (FastInterlockCompareExchange((void**)&m_MonitorHeld,
                                         (void*)((size_t)state + 2),
                                         (void*)state) == state)
            break;
    }
    return EnterEpilog(pCurThread, timeOut);

 Recursion:
    // Got the mutex via recursive locking on the same thread.
    _ASSERTE(m_Recursion >= 1);
    m_Recursion++;
#if defined(_DEBUG) && defined(TRACK_SYNC)
    // The best place to grab this is from the ECall frame
    Frame   *pFrame = pCurThread->GetFrame();
    int      caller = (pFrame && pFrame != FRAME_TOP
                       ? (int) pFrame->GetReturnAddress()
                       : -1);
    pCurThread->m_pTrackSync->EnterSync(caller, this);
#endif

    return true;
}

BOOL AwareLock::EnterEpilog(Thread* pCurThread, INT32 timeOut)
{
    DWORD ret = 0;
    BOOL finished = false;
    DWORD start, end, duration;

    // Require all callers to be in cooperative mode.  If they have switched to preemptive
    // mode temporarily before calling here, then they are responsible for protecting
    // the object associated with this lock.
    _ASSERTE(pCurThread->PreemptiveGCDisabled());

    OBJECTREF    obj = GetOwningObject();

    // We cannot allow the AwareLock to be cleaned up underneath us by the GC.
    IncrementTransientPrecious();

    GCPROTECT_BEGIN(obj);
    {
        if (m_SemEvent == INVALID_HANDLE_VALUE)
        {
            AllocLockSemEvent();
            _ASSERTE(m_SemEvent != INVALID_HANDLE_VALUE);
        }

        pCurThread->EnablePreemptiveGC();

        for (;;)
        {
            // We might be interrupted during the wait (Thread.Interrupt), so we need an
            // exception handler round the call.
            EE_TRY_FOR_FINALLY
            {
                // Measure the time we wait so that, in the case where we wake up
                // and fail to acquire the mutex, we can adjust remaining timeout
                // accordingly.
                start = ::GetTickCount();
                ret = pCurThread->DoAppropriateWait(1, &m_SemEvent, TRUE, timeOut, TRUE);
                _ASSERTE((ret == WAIT_OBJECT_0) || (ret == WAIT_TIMEOUT));
                // When calculating duration we consider a couple of special cases.
                // If the end tick is the same as the start tick we make the
                // duration a millisecond, to ensure we make forward progress if
                // there's a lot of contention on the mutex. Secondly, we have to
                // cope with the case where the tick counter wrapped while we where
                // waiting (we can cope with at most one wrap, so don't expect three
                // month timeouts to be very accurate). Luckily for us, the latter
                // case is taken care of by 32-bit modulo arithmetic automatically.
                if (timeOut != INFINITE)
                {
                    end = ::GetTickCount();
                    if (end == start)
                        duration = 1;
                    else
                        duration = end - start;
                    duration = min(duration, (DWORD)timeOut);
                    timeOut -= duration;
                }
            }
            EE_FINALLY
            {
                if (GOT_EXCEPTION())
                {
                    // We must decrement the waiter count.
                    for (;;)
                    {
                        volatile void* state = m_MonitorHeld;
                        _ASSERTE(((size_t)state >> 1) != 0);
                        if (FastInterlockCompareExchange((void**)&m_MonitorHeld,
                                                         (void*)((size_t)state - 2),
                                                         (void*)state) == state)
                            break;
                    }
                    // And signal the next waiter, else they'll wait forever.
                    ::SetEvent(m_SemEvent);
                }
            } EE_END_FINALLY;

            if (ret == WAIT_OBJECT_0)
            {
                // Attempt to acquire lock (this also involves decrementing the waiter count).
                for (;;) {
                    volatile void* state = m_MonitorHeld;
                    _ASSERTE(((size_t)state >> 1) != 0);
                    if ((size_t)state & 1)
                        break;
                    if (FastInterlockCompareExchange((void**)&m_MonitorHeld,
                                                     (void*)(((size_t)state - 2) | 1),
                                                     (void*)state) == state) {
                        finished = true;
                        break;
                    }
                }
            }
            else
            {
                // We timed out, decrement waiter count.
                for (;;) {
                    volatile void* state = m_MonitorHeld;
                    _ASSERTE(((size_t)state >> 1) != 0);
                    if (FastInterlockCompareExchange((void**)&m_MonitorHeld,
                                                     (void*)((size_t)state - 2),
                                                     (void*)state) == state) {
                        finished = true;
                        break;
                    }
                }
            }

            if (finished)
                break;
        }

        pCurThread->DisablePreemptiveGC();
    }
    GCPROTECT_END();
    DecrementTransientPrecious();

    if (ret == WAIT_TIMEOUT)
	return FALSE;

    m_HoldingThread = pCurThread;
    m_Recursion = 1;
    pCurThread->IncLockCount(); 

#if defined(_DEBUG) && defined(TRACK_SYNC)
    // The best place to grab this is from the ECall frame
    Frame   *pFrame = pCurThread->GetFrame();
    int      caller = (pFrame && pFrame != FRAME_TOP
                        ? (int) pFrame->GetReturnAddress()
                        : -1);
    pCurThread->m_pTrackSync->EnterSync(caller, this);
#endif

    return ret != WAIT_TIMEOUT;
}


void AwareLock::Leave()
{
    THROWSCOMPLUSEXCEPTION();

#if defined(_DEBUG) && defined(TRACK_SYNC)
    // The best place to grab this is from the ECall frame
    {
        Thread  *pCurThread = GetThread();
        Frame   *pFrame = pCurThread->GetFrame();
        int      caller = (pFrame && pFrame != FRAME_TOP
                            ? (int) pFrame->GetReturnAddress()
                            : -1);
        pCurThread->m_pTrackSync->LeaveSync(caller, this);
    }
#endif

    // There's a strange case where we are waiting to enter a contentious region when
    // a Thread.Interrupt occurs.  The finally protecting the leave will attempt to
    // remove us from a region we never entered.  We don't have to worry about leaving
    // the wrong entry for a recursive case, because recursive cases can never be
    // contentious, so the Thread.Interrupt will never be serviced at that spot.
    if (m_HoldingThread == GetThread())
    {
        _ASSERTE((size_t)m_MonitorHeld & 1);
        _ASSERTE(m_Recursion >= 1);
    
        if (--m_Recursion == 0)
        {
            m_HoldingThread->DecLockCount(); 
            m_HoldingThread = NULL;
            // Clear lock bit. If wait count is non-zero on successful clear, we
            // must signal the event.
    #ifdef _X86_
            // @todo rudim: zap lock prefix on uni-processor.
            __asm {
              retry:
                mov             ecx, this
                mov             eax, [ecx]AwareLock.m_MonitorHeld
                lea             ebx, [eax-1]
                lock cmpxchg    [ecx]AwareLock.m_MonitorHeld, ebx
                jne             retry_helper
                test            eax, 0xFFFFFFFE
                jne             MustSignal
                jmp             unlocked
              retry_helper:
                jmp             retry
              unlocked:
            }
    #else
            for (;;) {
                LONG state = m_MonitorHeld;
                if (FastInterlockCompareExchange((void**)&m_MonitorHeld,
                                                 (void*)(state - 1),
                                                 (void*)state) == (void*)state)
                    if (state & ~1)
                        goto MustSignal;
                    else
                        break;
            }
    #endif
        }
    
        return;
    
MustSignal:
        Signal();
    }
}


// Signal a waiting thread that we are done with the lock.
void AwareLock::Signal()
{
    if (m_SemEvent == INVALID_HANDLE_VALUE)
        AllocLockSemEvent();

#ifdef _DEBUG
    BOOL    ok =
#endif
    ::SetEvent(m_SemEvent);
    _ASSERTE(ok);
}


LONG AwareLock::EnterCount()
{
    LONG    cnt;

    Enter();
    cnt = m_Recursion - 1;
    Leave();

    return cnt;
}


LONG AwareLock::LeaveCompletely()
{
    LONG Tmp, EC;

    Tmp = EnterCount();
    _ASSERTE(Tmp > 0);            // otherwise we were never in the lock

    for (EC = Tmp; EC > 0; EC--)
        Leave();

    return Tmp;
}


BOOL AwareLock::OwnedByCurrentThread()
{
    return (GetThread() == m_HoldingThread);
}


// ***************************************************************************
//
//              SyncBlock class implementation
//
// ***************************************************************************

SyncBlock::~SyncBlock()
{
    // destruct critical section

    if (!g_fEEShutDown && m_pUMEntryThunk != NULL)
    {
        UMEntryThunk::FreeUMEntryThunk((UMEntryThunk*)m_pUMEntryThunk); 
    }
    m_pUMEntryThunk = NULL;
}

bool SyncBlock::SetUMEntryThunk(void *pUMEntryThunk)
{
    SetPrecious();
    return (VipInterlockedCompareExchange( (void*volatile*)&m_pUMEntryThunk,
                                                            pUMEntryThunk,
                                                            NULL) == NULL);
}


// We maintain two queues for SyncBlock::Wait.  
// 1. Inside SyncBlock we queue all threads that are waiting on the SyncBlock.
//    When we pulse, we pick the thread from this queue using FIFO.
// 2. We queue all SyncBlocks that a thread is waiting for in Thread::m_WaitEventLink.
//    When we pulse a thread, we find the event from this queue to set, and we also
//    or in a 1 bit in the syncblock value saved in the queue, so that we can return 
//    immediately from SyncBlock::Wait if the syncblock has been pulsed.
BOOL SyncBlock::Wait(INT32 timeOut, BOOL exitContext)
{
    Thread  *pCurThread = GetThread();
    BOOL     isTimedOut;
    BOOL     isEnqueued = FALSE;
    WaitEventLink waitEventLink;
    WaitEventLink *pWaitEventLink;

    // As soon as we flip the switch, we are in a race with the GC, which could clean
    // up the SyncBlock underneath us -- unless we report the object.
    _ASSERTE(pCurThread->PreemptiveGCDisabled());

    // Does this thread already wait for this SyncBlock?
    WaitEventLink *walk = pCurThread->WaitEventLinkForSyncBlock(this);
    if (walk->m_Next) {
        if (walk->m_Next->m_WaitSB == this) {
            // Wait on the same lock again.
            walk->m_Next->m_RefCount ++;
            pWaitEventLink = walk->m_Next;
        }
        else if ((SyncBlock*)(((DWORD_PTR)walk->m_Next->m_WaitSB) & ~1)== this) {
            // This thread has been pulsed.  No need to wait.
            return TRUE;
        }
    }
    else {
        // First time this thread is going to wait for this SyncBlock.
        HANDLE hEvent;
        if (pCurThread->m_WaitEventLink.m_Next == NULL) {
            hEvent = pCurThread->m_EventWait;
        }
        else {
            hEvent = GetEventFromEventStore();
            if (hEvent == INVALID_HANDLE_VALUE) {
                FailFast(GetThread(), FatalOutOfMemory);
            }
        }
        waitEventLink.m_WaitSB = this;
        waitEventLink.m_EventWait = hEvent;
        waitEventLink.m_Thread = pCurThread;
        waitEventLink.m_Next = NULL;
        waitEventLink.m_LinkSB.m_pNext = NULL;
        waitEventLink.m_RefCount = 1;
        pWaitEventLink = &waitEventLink;
        walk->m_Next = pWaitEventLink;

        // Before we enqueue it (and, thus, before it can be dequeued), reset the event
        // that will awaken us.
        ::ResetEvent(hEvent);
        
        // This thread is now waiting on this sync block
        ThreadQueue::EnqueueThread(pWaitEventLink, this);

        isEnqueued = TRUE;
    }

    _ASSERTE ((SyncBlock*)((DWORD_PTR)walk->m_Next->m_WaitSB & ~1)== this);

    PendingSync   syncState(walk);

    OBJECTREF     obj = m_Monitor.GetOwningObject();

    m_Monitor.IncrementTransientPrecious();

    GCPROTECT_BEGIN(obj);
    {
        pCurThread->EnablePreemptiveGC();

        // remember how many times we synchronized
        syncState.m_EnterCount = LeaveMonitorCompletely();
        _ASSERTE(syncState.m_EnterCount > 0);

        Context* targetContext = pCurThread->GetContext();
        _ASSERTE(targetContext);
        Context* defaultContext = pCurThread->GetDomain()->GetDefaultContext();
        _ASSERTE(defaultContext);

        if (exitContext && 
            targetContext != defaultContext)
        {       
            Context::MonitorWaitArgs waitArgs = {timeOut, &syncState, &isTimedOut};
            Context::CallBackInfo callBackInfo = {Context::MonitorWait_callback, (void*) &waitArgs};
            Context::RequestCallBack(defaultContext, &callBackInfo);
        }
        else
        {
            isTimedOut = pCurThread->Block(timeOut, &syncState);
        }

        pCurThread->DisablePreemptiveGC();
    }
    GCPROTECT_END();
    m_Monitor.DecrementTransientPrecious();

    return !isTimedOut;
}

void SyncBlock::Pulse()
{
    WaitEventLink  *pWaitEventLink;

    if ((pWaitEventLink = ThreadQueue::DequeueThread(this)) != NULL)
        ::SetEvent (pWaitEventLink->m_EventWait);
}

void SyncBlock::PulseAll()
{
    WaitEventLink  *pWaitEventLink;

    while ((pWaitEventLink = ThreadQueue::DequeueThread(this)) != NULL)
        ::SetEvent (pWaitEventLink->m_EventWait);
}


ComCallWrapper* SyncBlock::GetComCallWrapper()
{
    _ASSERTE(!IsComPlusWrapper(m_pComData));
    return (ComCallWrapper*)(m_pComData);
}

void SyncBlock::SetComCallWrapper(ComCallWrapper *pComData)
{
    _ASSERTE(pComData == NULL || m_pComData == NULL);
    SetPrecious();
    m_pComData = pComData;
}

ComPlusWrapper* SyncBlock::GetComPlusWrapper()
{
    return ::GetComPlusWrapper(m_pComData);
}

void SyncBlock::SetComPlusWrapper(ComPlusWrapper* pPlusWrap)
{
    // set the low bit
    pPlusWrap = (ComPlusWrapper*)((size_t)pPlusWrap | 0x1);
    if (m_pComData != NULL)
    {
        if(!IsComPlusWrapper(m_pComData))
        {
            ComCallWrapper* pComWrap = (ComCallWrapper*)m_pComData;
            LinkWrappers(pComWrap, pPlusWrap);
            return;
        }
    }
    SetPrecious();
    m_pComData = pPlusWrap;
}


// Static function used by _SwitchToThread().
typedef BOOL (* pFuncSwitchToThread) ( void );
pFuncSwitchToThread s_pSwitchToThread = NULL;

// non-zero return value if this function causes the OS to switch to another thread
BOOL __SwitchToThread (DWORD dwSleepMSec)
{
    if (dwSleepMSec > 0)
    {   
        Sleep (dwSleepMSec);
        return TRUE;
    }
    
    if (s_pSwitchToThread)
    {
        return ( (*s_pSwitchToThread)() );
    }
    else
    {
        Sleep ( 1 );
        return TRUE;
    }
}

BOOL InitSwitchToThread()
{
    _ASSERTE(!s_pSwitchToThread);

    // There is a SwitchToThread on Win98 Golden's kernel32.dll.  But it seems to
    // cause deadlocks or extremely slow behavior when we call it.  Better to just
    // use Sleep, the old-fashioned way, on such downlevel platforms.
    if (RunningOnWinNT())
    {
        // Try to load kernel32.dll.
        HMODULE hMod = WszGetModuleHandle(L"kernel32.dll");

        // Try to find the entrypoints we need.
        if (hMod)
            s_pSwitchToThread = (pFuncSwitchToThread) GetProcAddress(hMod, "SwitchToThread");
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\stubmgr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// StubMgr.h
//
// The stub manager exists so that the debugger can accurately step through 
// the myriad stubs & wrappers which exist in the EE, without imposing undue 
// overhead on the stubs themselves.
//
// Each type of stub (except those which the debugger can treat as atomic operations)
// needs to have a stub manager to represent it.  The stub manager is responsible for
// (a) identifying the stub as such, and
// (b) tracing into the stub & reporting what the stub will call.  This
//        report can consist of
//              (i) a managed code address
//              (ii) an unmanaged code address
//              (iii) another stub address
//              (iv) a "frame patch" address - that is, an address in the stub, 
//                      which the debugger can patch. When the patch is hit, the debugger
//                      will query the topmost frame to trace itself.  (Thus this is 
//                      a way of deferring the trace logic to the frame which the stub
//                      will push.)
//
// The set of stub managers is extensible, but should be kept to a reasonable number
// as they are currently linearly searched & queried for each stub.
//

#ifndef __stubmgr_h__
#define __stubmgr_h__

enum TraceType
{
    TRACE_STUB,
    TRACE_UNMANAGED,
    TRACE_MANAGED,
    TRACE_FRAME_PUSH,
    TRACE_UNJITTED_METHOD, //means that address will actually be a MethodDesc*
    TRACE_MGR_PUSH,
    TRACE_OTHER
};

class StubManager;

struct TraceDestination
{
    TraceType                       type;
    const BYTE                      *address;
    StubManager                     *stubManager;
};

class StubManager
{
  public:

        static BOOL IsStub(const BYTE *stubAddress);
        
        static BOOL TraceStub(const BYTE *stubAddress, TraceDestination *trace);

        static BOOL FollowTrace(TraceDestination *trace);

        static void AddStubManager(StubManager *mgr);

        static MethodDesc *MethodDescFromEntry(const BYTE *stubStartAddress, MethodTable*pMT);
        StubManager();
        ~StubManager();

        // Not every stub manager needs to override this method.
        virtual BOOL TraceManager(Thread *thread, TraceDestination *trace,
                                  CONTEXT *pContext, BYTE **pRetAddr)
        {
            _ASSERTE(!"Default impl of TraceManager should never be called!");
            return FALSE;
        }
    
  protected:

        virtual BOOL CheckIsStub(const BYTE *stubStartAddress) = 0;

        virtual BOOL DoTraceStub(const BYTE *stubStartAddress, 
                                 TraceDestination *trace) = 0;

        virtual MethodDesc *Entry2MethodDesc(const BYTE *stubStartAddress, MethodTable *pMT) = 0;



  private:
        static StubManager *g_pFirstManager;
        StubManager *m_pNextManager;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\syncclean.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"

#include "SyncClean.hpp"

Crst *SyncClean::m_Crst = NULL;
Bucket* SyncClean::m_HashMap = NULL;
EEHashEntry** SyncClean::m_EEHashTable;

HRESULT SyncClean::Init(BOOL fFailFast)
{
    if (m_Crst == NULL) {
        Crst *tmp = ::new Crst("SyncClean",CrstSyncClean);
        if (tmp == NULL) {
            if (g_fEEInit) {
                return E_OUTOFMEMORY;
            }
            else {
                FailFast(GetThread(), FatalOutOfMemory);
            }
        }
        if (FastInterlockCompareExchange((void**)&m_Crst,(LPVOID)tmp,(LPVOID)NULL) != (LPVOID)NULL) {
            delete tmp;
        }
    }
    return S_OK;
}

void SyncClean::Terminate()
{
    CleanUp();
    delete m_Crst;
#ifdef _DEBUG
    m_Crst = NULL;
#endif
}

void SyncClean::AddHashMap (Bucket *bucket)
{
    _ASSERTE (GetThread() == NULL || GetThread()->PreemptiveGCDisabled());
    SyncClean::Init();
    CLR_CRST(m_Crst);
    NextObsolete (bucket) = m_HashMap;
    m_HashMap = bucket;
}

void SyncClean::AddEEHashTable (EEHashEntry** entry)
{
    _ASSERTE (GetThread() == NULL || GetThread()->PreemptiveGCDisabled());
    SyncClean::Init();
    CLR_CRST(m_Crst);
    entry[-1] = (EEHashEntry*)m_EEHashTable;
    m_EEHashTable = entry;
}

void SyncClean::CleanUp ()
{
    // Only GC thread can call this.
    _ASSERTE (g_fProcessDetach ||
              (g_pGCHeap->IsGCInProgress() && GetThread() == g_pGCHeap->GetGCThread()));
    if (m_HashMap || m_EEHashTable) {
        CLR_CRST(m_Crst);
        Bucket* pBucket = m_HashMap;
        while (pBucket) {
            Bucket* pNextBucket = NextObsolete (pBucket);
            delete [] pBucket;
            pBucket = pNextBucket;
        }
        m_HashMap = NULL;

        EEHashEntry **pVictim = m_EEHashTable;
        while (pVictim) {
            EEHashEntry **pTemp = (EEHashEntry **)pVictim[-1];
            pVictim --;
            delete [] pVictim;
            pVictim = pTemp;
        }
        m_EEHashTable = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\syncclean.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _SYNCCLEAN_HPP_
#define _SYNCCLEAN_HPP_

// We keep a list of memory blocks to be freed at the end of GC, but before we resume EE.
// To make this work, we need to make sure that these data are accessed in cooperative GC
// mode.

class Bucket;
struct EEHashEntry;
class Crst;

class SyncClean {
public:
    static HRESULT Init (BOOL fFailFast=TRUE);
    static void Terminate ();

    static void AddHashMap (Bucket *bucket);
    static void AddEEHashTable (EEHashEntry** entry);
    static void CleanUp ();

private:
    static Crst *m_Crst;                 // Lock for adding to our cleanup list.
    static Bucket* m_HashMap;            // Cleanup list for HashMap
    static EEHashEntry** m_EEHashTable;  // Cleanup list for EEHashTable
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\tdb.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// TDB.H -
//
// Thread Data Blocks provide a place for MSCOREE to store information on a per 
// Win32 thread basis. It is not yet decided whether there will be a one-to-one
// mapping between Win32 threads and what the COM+ programmer sees as threads.
// So this data structure should only be used for internal things that really
// need to be tied to the OS thread.
//


#ifndef __tdb_h__
#define __tdb_h__

#include "util.hpp"
#include "list.h"
#include "spinlock.h"

//***************************************************************************
// Public functions
//		TDBManager* GetTDBManager() - returns the global TDBManager
//										used to create managed threads
//      TDB* GetTDB()      - returns previously created TDB for current thread
//      TDB* SetupTDB()    - creates TDB for current thread if not previously created
// 
// Public functions for ASM code generators
//
//      int GetTDBTLSIndex()       - returns TLS index used to point to TDB
//
// Public functions for one-time init/cleanup
//
//      BOOL InitTDBManager()      - onetime init
//      VOID TerminateTDBManager() - onetime cleanup
//***************************************************************************


//***************************************************************************
// Public functions
//***************************************************************************

class TDB;
class TDBManager;

//----------------------------------------------------------------------------
// TDBManager* GetTDBManager()
// return the global TDBManager, used to create managed threads
// the TDBManager internally pools threads
//-----------------------------------------------------------------------------
TDBManager* GetTDBManager();


//---------------------------------------------------------------------------
// Creates TDB for current thread if not previously created. Returns NULL for failure.
// Entry points from native clients to the COM+ runtime should call this to ensure
// that a TDB has been set up.
//---------------------------------------------------------------------------
TDB* SetupTDB();


//---------------------------------------------------------------------------
// Returns the TDB for the current thread. Must have already been created. This function
// will never fail.
//---------------------------------------------------------------------------
extern TDB* (*GetTDB)();


//---------------------------------------------------------------------------
// Returns the TLS index for the TDB. This is strictly for the use of
// our ASM stub generators that generate inline code to access the TDB.
// Normally, you should use GetTDB().
//---------------------------------------------------------------------------
DWORD GetTDBTLSIndex();

//---------------------------------------------------------------------------
// One-time initialization. Called during Dll initialization.
//---------------------------------------------------------------------------
BOOL  InitTDBManager();


//---------------------------------------------------------------------------
// One-time cleanup. Called during Dll cleanup.
//---------------------------------------------------------------------------
VOID  TerminateTDBManager();


enum ThreadState
{
	Thread_Idle,	// idle
	Thread_Blocked,	// blocked on a call out, or user initiated wait operation
	Thread_Running,	// running
	Thread_Exit,	// marked to exit
	Thread_Dead		// dead
};


//@todo : this class will change, 
//	this is only for test purposes

class CallContext
{
public:
	int		m_id;
	CallContext(int i)
	{
		m_id = i;
	}
	DLink	m_link; // link to chain callcontexts in task queue
	virtual void Run()  =0;
	~CallContext(){}
};


//+----------------------------------------------------------------------------------
// class CEvent : event class used by class TDB
//+----------------------------------------------------------------------------------
class CEvent
{
	HANDLE		m_hEvent;
	bool		m_fAutoReset;

public:

	CEvent()
	{
		// create an event, with manual reset option
		m_hEvent = WszCreateEvent(NULL, FALSE, FALSE, NULL);
		_ASSERTE(m_hEvent != NULL); // @todo need to bail out clean
		
		// auto reset option
		m_fAutoReset = false;
	}

	~CEvent()
	{
		_ASSERTE(m_hEvent != NULL);
		if (m_hEvent)
			CloseHandle(m_hEvent);
	}

	// returns if event object is valid
	bool Init(bool fInitialState, bool fAutoReset)
	{
		m_fAutoReset = fAutoReset;
		if (m_hEvent != NULL)
		{
			if (fInitialState)
				Signal();
			else
				Reset();
			return true;
		}
		else
			return false; // event didn't initialize correctly
	}

	//ResetEvent
	void Reset()
	{
		ResetEvent(m_hEvent);
	}

	// Wait, returns trues when the event is signalled
	//				returns false if timeout occurs

	bool Wait(DWORD timeout) // timeout in milliseconds 
	{
   		DWORD status = WaitForSingleObjectEx(m_hEvent,timeout, 0);
		// assert either event was signaled (or) timeout occurred
		_ASSERTE(status ==  WAIT_OBJECT_0 || status == WAIT_TIMEOUT);

		if (m_fAutoReset)
			Reset();
		return status == WAIT_OBJECT_0;
	}
	
	// Signal the event
	void Signal()
	{
		SetEvent(m_hEvent);
	}
};


//+----------------------------------------------------------------------------------
// class TDB : TDB class identifies a physical OS thread, for runtime controlled threads
//				m_pThreadMgr owns this threads and pools them
//+----------------------------------------------------------------------------------

class TDB {

	friend TDBManager;

	// start routine for newly spawned threads
	static DWORD WINAPI ThreadStartRoutine(void *param);

protected:
	
	//	Idle thread, add self to free list
	//	 and wait for event
	void	DoIdle();

	 // dispatch methods
    void	Dispatch()
	{
		// dispatch is valid only on idle threads
		_ASSERTE(m_fState == Thread_Idle);
		if (m_pCallInfo)
		{
			// set state to running
			m_fState = Thread_Running; 
			//@todo handle the call
			m_pCallInfo->Run();
		}
	}

public:
    // Linked list data member
	SLink			m_link;			// use this to instantiate the linked list 

	// constructor, takes a call context to dispatch the initial call
	//  pTDBMgr identifies the owning thread manager
	// m_pTDBMgr is NULL for external threads walking into the runtime
	TDB(TDBManager* pTDBMgr, CallContext *pCallInfo);
	
	// destructor, 
	// Perform final cleanup (post thread termination.)
	// for runtime managed threads waits for the thread to die
	~TDB();

	// Failable initialization occurs here.
    BOOL Init();   
        
    // Lifetime management. The TDB can outlive its associated thread
    // (because other objects need a way to name the thread) for as long
    // as there is an outstanding IncRef.
    void IncRef();
    void DecRef();

	// wake up an idle/blocked thread 
	// for an idle thread assign a task to it
	void Resume(CallContext *pCallInfo)
	{
		// handle is non null
		_ASSERTE(m_hThread != NULL);
		// thread should be either idle or blocked
		_ASSERTE(m_fState == Thread_Idle || m_fState == Thread_Blocked);
		// waking up an idle thread, requires a new task
		_ASSERTE(m_fState != Thread_Idle || pCallInfo != NULL);
		// only managed threads can be idle
		_ASSERTE(m_fState != Thread_Idle || m_pTDBMgr != NULL);

		// store the new call info, if its non-null
		if (pCallInfo != NULL)
			m_pCallInfo = pCallInfo;
		// resume the thread
		m_hEvent.Signal();
	}

	// thread pool owner, marks the thread to die 
	void MarkToExit()
	{
		_ASSERTE(m_hThread != NULL);
		// can kill only managed threads
		_ASSERTE(m_pTDBMgr != NULL);
		// thread can't be in a dead state
		_ASSERTE(m_fState != Thread_Dead);

		// change the state to Thread_Exit
		// if the thread is Idle, it kills self when it wakes up
		// if the thread is currently running a task, it kills self
		// when the task completes
		m_fState = Thread_Exit;

		m_hEvent.Signal(); // if the thread is idle, wake it up
	}

	// check if the thread has been marked to exit
	bool IsMarkedToExit()
	{
		return m_fState == Thread_Exit;
	}


    // Perform thread-exit cleanup (runs on the actual thread).
    // ThreadExit can be called by:
    //
    //    - The thread was created as a COM thread using a COM+
    //      component as a COM object, in which case we can hook into
    //      CoUninitialize. @todo: will have to figure out what to do
    //      with MTA's that never initialize COM: one possibility is
    //      to keep track of IP wrappers hosted in the MTA and try to
    //      GC & destroy when the last IP wrapper is released.
    //    - The thread was created from the COM+ world in which case
    //      the EE implements the ThreadFunc (so it can stick in the
    //      ThreadExit call.) This implies that COM+ programmers no longer
    //      have direct access to CreateThread() (but this seems to be
    //      the current thinking.)
    void ThreadExit();
        
 private:
        ULONG			m_refCount;
		DWORD			m_threadID;
		CEvent			m_hEvent;	// wakeup event
		TDBManager*		m_pTDBMgr; // owner of this thread
		HANDLE			m_hThread; 	//  thread handle, physical thread
		ThreadState		m_fState;	// indicates the state of the thread
		CallContext *	m_pCallInfo;	//  call info, current task

#ifdef _DEBUG
        BOOL    OnCorrectThread();
#endif //_DEBUG
};

class TDBManager;


typedef SList<TDB, offsetof(TDB,m_link), true> THREADLIST;
typedef Queue<SList<CallContext, offsetof(CallContext, m_link), false> > TASKQUEUE;
//+-------------------------------------------------------------------
//
//  Class:	TDBManager
//		Maintains a pool of threads, creates a new TDB
//				if the pool is empty, maintain the pool LRU order
//
//+-------------------------------------------------------------------
class TDBManager
{
	TASKQUEUE		m_taskQueue;	// queue of tasks 
    THREADLIST		m_FreeList; 	// list of free threads

    SpinLock		m_lock;			// fast lock for synchronization
	
	LONG			m_cbThreads;	// current count of threads that belong to this pool
	LONG			m_cbMaxThreads; // free threads threshold, used to limit number of threads

	// clean up functions
	void ClearFreeList();
	void ClearDeadList();

public:

    void *operator new(size_t, void *pInPlace);
    void operator delete(void *p);

	// track the number of threads that belong to the pool	 
	void IncRef()
	{
		FastInterlockIncrement(&m_cbThreads); // AddRef the count of threads
	}

	void DecRef()
	{
		FastInterlockDecrement(&m_cbThreads); //Reduce the count of threads
	}

	void Init();

	void Init(unsigned cbMaxThreads)
	{
		m_cbMaxThreads = cbMaxThreads;
	}
	// no destructor

    //	dispatch methods

	// direct dispatch, if a free thread is available use it
	// otherwise create a new thread and dispatch the call on it
    bool	Dispatch(CallContext *pCallInfo);

	// queued dispatch, if a free thread is available use it
	// otherwise create new threads (upto max threshold) 
	// otherwise queue up the task to be scheduled when a free thread is available
	void	ScheduleTask(CallContext* pCallInfo);

	// if there are no tasks in the queue, add thread to free list and return null
	// otherwise return the new task
    CallContext*	AddToFreeList(TDB *pThread);

	// find and mark a thread to die
    bool	FindAndKillThread(TDB *pThread); 

	// mark all free threads to die
	void	Cleanup();

	LONG ThreadsAlive()
	{
		// are there any threads still alive
		return m_cbThreads;
	}
};

#ifdef _DEBUG

class CThreadStats
{
	LONG	m_cbThreadsCreated;
	LONG	m_cbThreadsDied;
public:
	CThreadStats()
	{
		m_cbThreadsCreated = 0;
		m_cbThreadsDied = 0;
	}

	void IncRef()
	{
		FastInterlockIncrement(&m_cbThreadsCreated);
	}

	void DecRef()
	{
		FastInterlockIncrement(&m_cbThreadsDied);
	}

	LONG TotalThreadsCreated()
	{
		return m_cbThreadsCreated;
	}

	LONG TotalThreadsDied()
	{
		return m_cbThreadsDied;
	}
};

extern CThreadStats g_ThreadStats;
#endif // _DEBUG



#endif //__tdb_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\tdb.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*  TDB.CPP:
 *
 *  TDB = Thread Data Block: the EE will maintain one of these per 
 *  native thread. 
 */

#include "common.h"

#include "list.h"
#include "spinlock.h"
#include "tls.h"
#include "tdb.h"

typedef TDB* (*POPTIMIZEDTDBGETTER)();

// PUBLIC GLobals
TDBManager *g_pTDBMgr;
BYTE g_TDBManagerInstance[sizeof(TDBManager)];

//-------------------------------------------------------------------------
// Public function: GetTDBManager()
// Returns the global TDBManager
//-------------------------------------------------------------------------

TDBManager* GetTDBManager()
{
    _ASSERTE(g_pTDBMgr != NULL);
    return g_pTDBMgr;
}

void *TDBManager::operator new(size_t, void *pInPlace)
{
    return pInPlace;
}

void TDBManager::operator delete(void *p)
{
}


//************************************************************************
// PRIVATE GLOBALS
//************************************************************************
static DWORD         gTLSIndex = ((DWORD)(-1));            // index ( (-1) == uninitialized )

#define TDBInited() (gTLSIndex != ((DWORD)(-1)))


//-------------------------------------------------------------------------
// Public function: GetTDB()
// Returns TDB for current thread. Cannot fail since it's illegal to call this
// without having called SetupTDB.
//-------------------------------------------------------------------------
TDB* (*GetTDB)();    // Points to platform-optimized GetTDB() function.


#ifdef _DEBUG

CThreadStats    g_ThreadStats;

BOOL TDB::OnCorrectThread()
{
    return GetCurrentThreadId() == m_threadID;
}
#endif _DEBUG

//-------------------------------------------------------------------------
// Public function: SetupTDB()
// Creates TDB for current thread if not previously created.
// usually called for external threads
// Returns NULL for failure (usually due to out-of-memory.)
//-------------------------------------------------------------------------
TDB* SetupTDB()
{
    _ASSERTE(TDBInited());
    TDB* pTDB;

    if (NULL == (pTDB = GetTDB())) {
        pTDB = new TDB(NULL, NULL);
        if (pTDB->Init()) {
            TlsSetValue(gTLSIndex, (VOID*)pTDB);
        } else {
            delete pTDB;
            pTDB = NULL;
        }
    } 
    return pTDB;
}


//---------------------------------------------------------------------------
// Returns the TLS index for the TDB. This is strictly for the use of
// our ASM stub generators that generate inline code to access the TDB.
// Normally, you should use GetTDB().
//---------------------------------------------------------------------------
DWORD GetTDBTLSIndex()
{
    _ASSERTE(TDBInited());
    return gTLSIndex;
}


//---------------------------------------------------------------------------
// Portable GetTDB() function: used if no platform-specific optimizations apply.
//---------------------------------------------------------------------------
static
TDB* GetTDBGeneric()
{
    _ASSERTE(TDBInited());

    return (TDB*)TlsGetValue(gTLSIndex);
}


//---------------------------------------------------------------------------
// One-time initialization. Called during Dll initialization. So
// be careful what you do in here!
//---------------------------------------------------------------------------
BOOL InitTDBManager()
{
    g_pTDBMgr = new (&g_TDBManagerInstance) TDBManager();
    if (g_pTDBMgr == NULL)
        return FALSE;

    g_pTDBMgr->Init();

    _ASSERTE( gTLSIndex == ((DWORD)(-1)));

    DWORD idx = TlsAlloc();
    if (idx == ((DWORD)(-1))) {
        //WARNING_OUT(("COM+ EE could not allocate TLS index."));
        return FALSE;
    }

    gTLSIndex = idx;

    GetTDB = (POPTIMIZEDTDBGETTER)MakeOptimizedTlsGetter(gTLSIndex, (POPTIMIZEDTLSGETTER)GetTDBGeneric);

    if (!GetTDB) {
        TlsFree(gTLSIndex);
        gTLSIndex = (DWORD)(-1);
        return FALSE;
    }
    
    return TRUE; 
}


//---------------------------------------------------------------------------
// One-time cleanup. Called during Dll cleanup. So
// be careful what you do in here!
//---------------------------------------------------------------------------
VOID TerminateTDBManager()
{
    if (gTLSIndex != ((DWORD)(-1))) {
        TlsFree(gTLSIndex);
// #ifdef _DEBUG
//         gTLSIndex = ((DWORD)(0xcccccccc));
// #endif
        gTLSIndex = -1;
    }
    if (GetTDB) {
        FreeOptimizedTlsGetter( gTLSIndex, (POPTIMIZEDTLSGETTER)GetTDB );
    }

    if (g_pTDBMgr != NULL)
    {
        delete(g_pTDBMgr);
        g_pTDBMgr = NULL;
    }
}



//************************************************************************
// TDB members
//************************************************************************


//+-------------------------------------------------------------------
//  TDB::TDB
//  Constructor for a thread object,Allocates wakeup and completion events, 
//  and creates a thread, Called by the owner threadpool instance.
//  fSuccess argument is used to detect failures in spawning a thread
//
//+-------------------------------------------------------------------
TDB::TDB(TDBManager* pTDBMgr, CallContext* pCallInfo) :
    m_pTDBMgr(pTDBMgr),
    m_pCallInfo(pCallInfo),
    m_hThread(NULL),
    m_refCount(0),
    m_threadID(0)
{       
                            // gets corrected in the Init() method
    // addref the owner pool
    if (m_pTDBMgr)
        m_pTDBMgr->IncRef();

    #ifdef _DEBUG
        // total number of threads
        g_ThreadStats.IncRef();
    #endif
}

//--------------------------------------------------------------------
// Failable initialization occurs here.
//--------------------------------------------------------------------
BOOL TDB::Init()
{
    bool fSuccess = false;
    // check for external threads
    if (!(fSuccess=m_hEvent.Init(FALSE, TRUE)))
    {
        return fSuccess;
    }

    if (m_pTDBMgr != NULL)
    {
        
        // spawn a managed thread
        m_hThread = CreateThread(NULL, 0,
                  ThreadStartRoutine,
                  (void *) this, 0,
                  &m_threadID);  // initialize the thread id
        // check if the handle is valid, and set the state
        if (m_hThread != NULL)
        {
            fSuccess = true;
            m_fState    = Thread_Idle; 
        }
        else
        {   
            fSuccess = false;
            m_fState = Thread_Dead;
        }

    }
    else
    {   // external thread  
        //@todo , should we also get the handle for this thread and hold it ??
        m_threadID = GetCurrentThreadId(); 
        m_fState    = Thread_Running; // external threads are in run state
    }
    
    return fSuccess;
}



//--------------------------------------------------------------------
// IncRef
//--------------------------------------------------------------------
void TDB::IncRef()
{
    FastInterlockIncrement((LPLONG) &m_refCount);    
}



//--------------------------------------------------------------------
// DecRef
//--------------------------------------------------------------------
void TDB::DecRef()
{
    if (0 == FastInterlockDecrement((LPLONG) &m_refCount)) {
        if (m_fState == Thread_Dead) {
            delete this;
        }
    }
}


//--------------------------------------------------------------------
// ThreadExit, Always runs on the associated native thread.
// This method runs outside of DLL locks so it can do things
// like release leftover COM objects.
//--------------------------------------------------------------------
void TDB::ThreadExit()
{
    _ASSERTE(OnCorrectThread());
    // thread can't be in Dead state
    _ASSERTE(m_fState != Thread_Dead);

    IncRef();       // Avoid problems with recursive decrements
    // Nothing to do yet.
    m_fState = Thread_Dead;
    TlsSetValue(gTLSIndex, NULL);
    DecRef();       // THIS MAY DESTROY "THIS" SO THIS MUST BE THE LAST OPERATION.
}




//+-------------------------------------------------------------------
//
//  bool TDB::DoIdle()
//  add self to the free list and wait for a new task
//  if Timeout occurs, move self to deleted list and wait for the
//  owner pool to do the clean up
//  returns true, if a new task was assigned to this thread
//  returns false, if the thread was marked to die
//+-------------------------------------------------------------------
    
void TDB::DoIdle()
{
    _ASSERTE(OnCorrectThread());
    _ASSERTE(m_hThread != NULL);
    _ASSERTE(m_pTDBMgr != NULL);

    // thread can't be in marked to Exit state
    _ASSERTE(m_fState != Thread_Exit);
    // thread can't be in Dead state
    _ASSERTE(m_fState != Thread_Dead);

    //@todo fix this
    if (m_pCallInfo)
        delete m_pCallInfo;
    m_pCallInfo = NULL;
    
    // set thread state  to Idle
    m_fState = Thread_Idle;

    //  add the thread object to the free list
    CallContext* pCallInfo = m_pTDBMgr->AddToFreeList(this);

    if (pCallInfo == NULL)
    {
    // suspend the thread till somebody resumes us
        m_hEvent.Wait(INFINITE);
    }
    else
    {
        // new task has been assigned for this thread
        // return without blocking
        m_pCallInfo = pCallInfo;
    }
}

//+-------------------------------------------------------------------
//
//  TDB::~TDB
//  Called ONLY by owner thread pool instance.
//
//+-------------------------------------------------------------------
TDB::~TDB()
{
    // check the thread is in dead state 
    _ASSERTE(m_fState == Thread_Dead);

    if (m_hThread) // close the handle if we have a handle 
        CloseHandle(m_hThread);
    // release the refcount on the owner pool
    if (m_pTDBMgr)
        m_pTDBMgr->DecRef();

    #ifdef _DEBUG
        // total number of threads
        g_ThreadStats.DecRef();
    #endif
}


//+-------------------------------------------------------------------
//
//  TDB::ThreadStartRoutine
//   startup routine for newly spawned threads
//
//+-------------------------------------------------------------------
DWORD WINAPI TDB::ThreadStartRoutine(void *param)
{
    TDB *pTDB = (TDB *)param;
    pTDB->IncRef(); // hold a reference to the object

    _ASSERTE(pTDB != NULL);
    _ASSERTE(TDBInited());
    _ASSERTE(pTDB->m_pTDBMgr != NULL);

    // store the TDB object in the Tls
    TlsSetValue(gTLSIndex, (VOID*)pTDB);

    // loop and handle tasks
    while (!pTDB->IsMarkedToExit()) // still alive
    {
        pTDB->Dispatch(); // dispatch the call
        pTDB->DoIdle(); // wait for new task, or the owner asked to kill self
    }

    pTDB->ThreadExit(); // call the thread clean up function 

    pTDB->DecRef();     // THIS should be placed here, pTDB could get deleted after this
    //ExitThread(0);        // exit the thread
    return 0;
}

//+-------------------------------------------------------------------
//
//  TDBManager::Init(void) 
//  intialize lists and task queue
//  initialize default values
//
//+-------------------------------------------------------------------
void TDBManager::Init() 
{ 
    // default max threads @todo select suitable value
    m_cbMaxThreads = 5;
    m_cbThreads = 0; 
// Initialize thread pool lists
    m_FreeList.Init();
    m_taskQueue.Init(); // intialize task queue
    m_lock.Init(LOCK_THREAD_POOL); // initialize the lock, with approp. lock type
}

//+-------------------------------------------------------------------
//
//  TDBManager::ScheduleTask(CallContext* pCallInfo)
//  Finds a free thread, and dispatches the request
//      to that thread, or create a new thread if the free list is empty.
//
//
//+-------------------------------------------------------------------

void TDBManager::ScheduleTask(CallContext* pCallInfo)
{
    m_lock.GetLock();
    if (!m_taskQueue.IsEmpty())
    {
        // task queue is not empty
        // enqueue this task to be scheduled later
        m_taskQueue.Enqueue(pCallInfo);
        m_lock.FreeLock();
        return;
    }

    // task queue is empty, see if we can find a thread to schedule this task
    TDB *pTDB = m_FreeList.RemoveHead();

    if (pTDB != NULL)
    {
        // found a free thread
        m_lock.FreeLock();  // release lock
        pTDB->Resume(pCallInfo); // dispatch to the thread
        return;
    }

    // approx. check for number of threads in use
    if (m_cbThreads >= m_cbMaxThreads)
    {
        // too many threads, enqueue this request to be scheduled later
        m_taskQueue.Enqueue(pCallInfo);
        m_lock.FreeLock();
        return;
    }
    // okay we can spawn a new thread, release lock and do a direct dispatch
    m_lock.FreeLock();
    Dispatch(pCallInfo); // do a direct dispatch
}

//+-------------------------------------------------------------------
//
//  TDBManager::AddToFreeList
//  add thread to free list
//
//
//+-------------------------------------------------------------------

CallContext*    TDBManager::AddToFreeList(TDB *pTDB)
{
    //assert owner
    _ASSERTE(pTDB->m_pTDBMgr == this); 
    // assert the state of thread is idle
    _ASSERTE(pTDB->m_fState == Thread_Idle);

    m_lock.GetLock();       //lock
    CallContext *pCallInfo = m_taskQueue.Dequeue();
    if (pCallInfo == NULL)
    {
        // no tasks in the queue , add this thread to free list
        m_FreeList.InsertHead(pTDB);
        m_lock.FreeLock();      // unlock
        return NULL;
    }
    // found a task
    m_lock.FreeLock(); // unlock
    return pCallInfo; // return the new task to this thread
}

//+-------------------------------------------------------------------
//
//  TDBManager::Dispatch
//  Finds a free thread, and dispatches the request
//      to that thread, or create a new thread if the free list is empty.
//
//
//+-------------------------------------------------------------------
bool TDBManager::Dispatch(CallContext *pCallInfo)
{
    m_lock.GetLock();

    TDB *pTDB = m_FreeList.RemoveHead();

    if (pTDB != NULL)
    {
        m_lock.FreeLock();
        pTDB->Resume(pCallInfo); // dispatch to the thread
        return true;
    }

    m_lock.FreeLock();

    pTDB = new TDB(this, pCallInfo);
    // wait for a while
    if (!pTDB->Init())
    {
        delete pTDB;
        return false;
    }
    return true;
}

//+-------------------------------------------------------------------
//
// bool TDBManager::FindAndKillThread(TDB *pTDB)
//  Find and Remove the thread if it is in the free list
//  mark the thread to die 
//
//+-------------------------------------------------------------------
bool TDBManager::FindAndKillThread(TDB *pTDB)
{
    // assert that this pool is the owner of the thread
    _ASSERTE(pTDB->m_pTDBMgr == this); 
    m_lock.GetLock();

    bool fSuccess = false;
    TDB *pFreeTDB = m_FreeList.FindAndRemove(pTDB);

    if (pFreeTDB != NULL)
    {
        pFreeTDB->MarkToExit(); // mark the thread to die
        fSuccess = true;
    }
    // didn't find the thread in the free list
    m_lock.FreeLock();
    return fSuccess;
}


//+-------------------------------------------------------------------
//  TDBManager::Cleanup
//
//+-------------------------------------------------------------------
void TDBManager::Cleanup(void)
{
    m_lock.GetLock();
    bool fNoTasks = m_taskQueue.IsEmpty();
    m_lock.FreeLock();
    if (fNoTasks)
    {
        // no tasks in the queue, clean up free threads
        ClearFreeList();
    }
}

//+-------------------------------------------------------------------
//  private method: TDBManager::ClearFreeList
//  remove the threads from the free list
//   and mark them to die,
//+-------------------------------------------------------------------
void TDBManager::ClearFreeList(void)
{
    TDB* pTDB;
    m_lock.GetLock();
    do
    {
        pTDB = m_FreeList.RemoveHead();
        if (pTDB)
        {
            pTDB->MarkToExit(); // mark the thread to die
        }
        
    }  
    while (pTDB);
    m_lock.FreeLock(); // free the lock
    // give other threads a chance
    __SwitchToThread(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\tlbexport.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//===========================================================================
//  File: TlbExport.h
//  All Rights Reserved.
//
//  Notes: Create a TypeLib from COM+ metadata.
//---------------------------------------------------------------------------

class ITypeCreateTypeLib2;
struct ICreateTypeInfo2;
struct ITypeInfo;
struct ITypeLibExporterNotifySink;

class CDescPool;
struct ComMTMethodProps;
class ComMTMemberInfoMap;

static LPCSTR szVariantClassFullQual= g_VariantClassName;


//*****************************************************************************
// Signature utilities.
//*****************************************************************************
class MetaSigExport : public MetaSig
{
public:
    MetaSigExport(PCCOR_SIGNATURE szMetaSig, Module* pModule, BOOL fConvertSigAsVarArg = FALSE, MetaSigKind kind = sigMember)
        : MetaSig(szMetaSig, pModule, fConvertSigAsVarArg, sigMember) {}
    BOOL IsVbRefType()
    {
        // Get the arg, and skip decorations.
        SigPointer pt = GetArgProps();
        CorElementType mt = pt.PeekElemType();
        while (mt == ELEMENT_TYPE_BYREF || mt == ELEMENT_TYPE_PTR)
        {
            // Eat the one just examined, and peek at the next one.
            mt = pt.GetElemType();
            mt = pt.PeekElemType();
        }
        // Is it just Object?
        if (mt == ELEMENT_TYPE_OBJECT)
            return true;
        // A particular class?
        if (mt == ELEMENT_TYPE_CLASS)
        {
            // Exclude "string".
            if (pt.IsStringType(m_pModule))
                return false;
            return true;
        }
        // A particular valuetype?
        if (mt == ELEMENT_TYPE_VALUETYPE)
        {
            // Include "variant".
            if (pt.IsClass(m_pModule, szVariantClassFullQual))
                return true;
            return false;
        }
        // An array, a string, or POD.
        return false;
    }
}; // class MetaSigExport : public MetaSig


//*************************************************************************
// Helper functions.
//*************************************************************************
HRESULT Utf2Quick(
    LPCUTF8     pStr,                   // The string to convert.
    CQuickArray<WCHAR> &rStr,           // The QuickArray<WCHAR> to convert it into.
    int         iCurLen = 0);           // Inital characters in the array to leave (default 0).


//*************************************************************************
// Class to convert COM+ metadata to a TypeLib.
//*************************************************************************
class TypeLibExporter
{
private:
    class CExportedTypesInfo;

public:
    TypeLibExporter(); 
    ~TypeLibExporter();

    HRESULT Convert(Assembly *pAssembly, LPCWSTR szTlbName, ITypeLibExporterNotifySink *pNotify=0, int flags=0);
    HRESULT LayOut();
    HRESULT Save();
    HRESULT GetTypeLib(REFGUID iid, IUnknown **ppTlb);
    void ReleaseResources();

protected:
	HRESULT PreLoadNames();

    // TypeLib emit functions.
    HRESULT TokenToHref(ICreateTypeInfo2 *pTI, EEClass *pClass, mdToken tk, BOOL bWarnOnUsingIUnknown, HREFTYPE *pHref);
    HRESULT GetWellKnownInterface(EEClass *pClass, ITypeInfo **ppTI);
    HRESULT EEClassToHref(ICreateTypeInfo2 *pTI, EEClass *pClass, BOOL bWarnOnUsingIUnknown, HREFTYPE *pHref);
    HRESULT StdOleTypeToHRef(ICreateTypeInfo2 *pCTI, REFGUID rGuid, HREFTYPE *pHref);
    HRESULT ExportReferencedAssembly(Assembly *pAssembly);
    
    // Metadata import functions.
    HRESULT AddModuleTypes(Module *pModule);
    HRESULT AddAssemblyTypes(Assembly *pAssembly);

    HRESULT ConvertAllTypeDefs();
    HRESULT ConvertOneTypeDef(EEClass *pClass);

    HRESULT CreateITypeInfo(CExportedTypesInfo *pData, bool bNamespace=false, bool bResolveDup=true);
    HRESULT CreateIClassXITypeInfo(CExportedTypesInfo *pData, bool bNamespace=false, bool bResolveDup=true);
    HRESULT ConvertImplTypes(CExportedTypesInfo *pData);
    HRESULT ConvertDetails(CExportedTypesInfo *pData);
    
    HRESULT ConvertInterfaceImplTypes(ICreateTypeInfo2 *pICTI, EEClass *pClass);
    HRESULT ConvertInterfaceDetails(ICreateTypeInfo2 *pICTI, EEClass *pClass, int bAutoProxy);
    HRESULT ConvertRecord(CExportedTypesInfo *pData);
    HRESULT ConvertRecordBaseClass(CExportedTypesInfo *pData, EEClass *pSubClass, ULONG &ixVar);
    HRESULT ConvertEnum(ICreateTypeInfo2 *pICTI, ICreateTypeInfo2 *pDefault, EEClass *pClass);
    HRESULT ConvertClassImplTypes(ICreateTypeInfo2 *pICTI, ICreateTypeInfo2 *pIDefault, EEClass *pClass);
    HRESULT ConvertClassDetails(ICreateTypeInfo2 *pICTI, ICreateTypeInfo2 *pIDefault, EEClass *pClass, int bAutoProxy);

    BOOL HasDefaultCtor(EEClass *pClass);

    HRESULT ConvertIClassX(ICreateTypeInfo2 *pICTI, EEClass *pClass, int bAutoProxy);
    HRESULT ConvertMethod(ICreateTypeInfo2 *pTI, ComMTMethodProps *pProps, ULONG iMD, ULONG ulIface);
    HRESULT ConvertFieldAsMethod(ICreateTypeInfo2 *pTI, ComMTMethodProps *pProps, ULONG iMD);
    HRESULT ConvertVariable(ICreateTypeInfo2 *pTI, EEClass *pClass, mdFieldDef md, LPWSTR szName, ULONG iMD);
    HRESULT ConvertEnumMember(ICreateTypeInfo2 *pTI, EEClass *pClass, mdFieldDef md, LPWSTR szName, ULONG iMD);

    // Error/status functions.
    HRESULT TlbPostError(HRESULT hrRpt, ...); 
    struct CErrorContext;
    HRESULT FormatErrorContextString(CErrorContext *pContext, LPWSTR pBuf, ULONG cch);
    HRESULT FormatErrorContextString(LPWSTR pBuf, ULONG cch);
    HRESULT ReportEvent(int ev, int hr, ...);
    HRESULT ReportWarning(HRESULT hrReturn, HRESULT hrRpt, ...); 
    HRESULT PostClassLoadError(LPCUTF8 pszName, OBJECTREF *pThrowable);
    
    // Utility functions.
    typedef enum {CLASS_AUTO_NONE, CLASS_AUTO_DISPATCH, CLASS_AUTO_DUAL} ClassAutoType;
    ClassAutoType ClassHasIClassX(EEClass *pClass);
    HRESULT LoadClass(Module *pModule, mdToken tk, EEClass **ppClass);
    HRESULT LoadClass(Module *pModule, LPCUTF8 pszName, EEClass **ppClass);
    HRESULT CorSigToTypeDesc(ICreateTypeInfo2 *pTI, EEClass *pClass, PCCOR_SIGNATURE pbSig, PCCOR_SIGNATURE pbNativeSig, ULONG cbNativeSig, 
                             ULONG *cbElem, TYPEDESC *ptdesc, CDescPool *ppool, BOOL bMethodSig, BOOL bArrayType=false, BOOL *pbByRef=0);
    BOOL IsVbRefType(PCCOR_SIGNATURE pbSig, IMDInternalImport *pInternalImport);
    HRESULT InitMemberInfoMap(ComMTMemberInfoMap *pMemberMap);

    HRESULT GetDescriptionString(EEClass *pClass, mdToken tk, BSTR &bstrDescr);
    HRESULT GetStringCustomAttribute(IMDInternalImport *pImport, LPCSTR szName, mdToken tk, BSTR &bstrDescr);
    
    HRESULT GetAutomationProxyAttribute(IMDInternalImport *pImport, mdToken tk, int *bValue);
    HRESULT GetTypeLibVersionFromAssembly(Assembly *pAssembly, USHORT *pMajorVersion, USHORT *pMinorVersion);

    TYPEKIND TKindFromClass(EEClass *pClass);

private:
    ClassLoader *m_pLoader;             // Domain where the Module being converted was loaded
    ITypeInfo   *m_pIUnknown;           // TypeInfo for IUnknown.
    HREFTYPE    m_hIUnknown;            // href for IUnknown.
    ITypeInfo   *m_pIDispatch;          // TypeInfo for IDispatch.
    ITypeInfo   *m_pIManaged;           // TypeInfo for IManagedObject
    ITypeInfo   *m_pGuid;               // TypeInfo for GUID.
    
    ITypeLibExporterNotifySink *m_pNotify;   // Notification callback.

    ICreateTypeLib2 *m_pICreateTLB;     // The created typelib.
    
    int         m_flags;                // Conversion flags.
    int         m_bAutomationProxy;     // Should interfaces be marked such that oleaut32 is the proxy?
    int         m_bWarnedOfNonPublic;

    class CExportedTypesInfo
    {
    public:
        EEClass     *pClass;            // The EE class being exported.
        ICreateTypeInfo2 *pCTI;         // The ICreateTypeInfo2 for the EE class.
        ICreateTypeInfo2 *pCTIDefault;  // The ICreateTypeInfo2 for the IClassX.
        TYPEKIND    tkind;              // Typekind of the exported class.
        bool        bAutoProxy;         // If true, oleaut32 is the interface's proxy.
    };
    class CExportedTypesHash : public CClosedHashEx<CExportedTypesInfo, CExportedTypesHash>
    {
    public:
        typedef CClosedHashEx<CExportedTypesInfo, CExportedTypesHash> Base;
        typedef CExportedTypesInfo T;
        
        CExportedTypesHash() : Base(1009), m_iCount(0), m_Array(NULL) {}
        ~CExportedTypesHash() { Clear(); delete[] m_Array;}
        virtual void Clear();
        
        unsigned long Hash(const T *pData);
        unsigned long Compare(const T *p1, T *p2);
        ELEMENTSTATUS Status(T *p);
        void SetStatus(T *p, ELEMENTSTATUS s);
        void *GetKey(T *p);
        
        //@todo: move to CClosedHashEx
        T* GetFirst() { return (T*)CClosedHashBase::GetFirst(); }
        T* GetNext(T*prev) {return (T*)CClosedHashBase::GetNext((BYTE*)prev); }
    
    public:
        HRESULT InitArray();
        T* operator[](ULONG ix) { _ASSERTE(ix < m_iCount); return m_Array[ix]; }
        int Count() { return m_iCount; } 

        void SortByName();
        void SortByToken();
        
    protected:
        friend class CSortByToken;
        class CSortByToken : public CQuickSort<CExportedTypesInfo*>
        {
        public:
            CSortByToken(CExportedTypesInfo **pBase, int iCount)
              : CQuickSort<CExportedTypesInfo*>(pBase, iCount) {}
            virtual int Compare(CExportedTypesInfo **ps1, CExportedTypesInfo **ps2);
        };
        friend class CSortByName;
        class CSortByName : public CQuickSort<CExportedTypesInfo*>
        {
        public:
            CSortByName(CExportedTypesInfo **pBase, int iCount)
              : CQuickSort<CExportedTypesInfo*>(pBase, iCount) {}
            virtual int Compare(CExportedTypesInfo **ps1, CExportedTypesInfo **ps2);
        };
        
        
        CExportedTypesInfo  **m_Array;        
        ULONG               m_iCount;
    };
    CExportedTypesHash  m_Exports;
    CExportedTypesHash  m_InjectedExports;
    
protected:
    class CHrefOfTIHashKey
    {
    public:
        ITypeInfo   *pITI;
        HREFTYPE    href;
    };

    class CHrefOfTIHash : public CClosedHash<class CHrefOfTIHashKey>
    {
    public:
        typedef CHrefOfTIHashKey T;

        CHrefOfTIHash() : CClosedHash<class CHrefOfTIHashKey>(101) {}
        ~CHrefOfTIHash() { Clear(); }

        virtual void Clear();
        
        unsigned long Hash(const void *pData) {return Hash((const T*)pData);}
        unsigned long Hash(const T *pData);

        unsigned long Compare(const void *p1, BYTE *p2) {return Compare((const T*)p1, (T*)p2);}
        unsigned long Compare(const T *p1, T *p2);

        ELEMENTSTATUS Status(BYTE *p) {return Status((T*)p);}
        ELEMENTSTATUS Status(T *p);

        void SetStatus(BYTE *p, ELEMENTSTATUS s) {SetStatus((T*)p, s);}
        void SetStatus(T *p, ELEMENTSTATUS s);

        void* GetKey(BYTE *p) {return GetKey((T*)p);}
        void *GetKey(T *p);
        
    };

    CHrefOfTIHash       m_HrefHash;         // Hashed table of HREFTYPEs of ITypeInfos
    HRESULT GetRefTypeInfo(ICreateTypeInfo2 *pContainer, ITypeInfo *pReferenced, HREFTYPE *pHref);

    class CHrefOfClassHashKey
    {
    public:
        EEClass     *pClass;
        HREFTYPE    href;
    };

    class CHrefOfClassHash : public CClosedHash<class CHrefOfClassHashKey>
    {
    public:
        typedef CHrefOfClassHashKey T;

        CHrefOfClassHash() : CClosedHash<class CHrefOfClassHashKey>(101) {}
        ~CHrefOfClassHash() { Clear(); }

        virtual void Clear();
        
        unsigned long Hash(const void *pData) {return Hash((const T*)pData);}
        unsigned long Hash(const T *pData);

        unsigned long Compare(const void *p1, BYTE *p2) {return Compare((const T*)p1, (T*)p2);}
        unsigned long Compare(const T *p1, T *p2);

        ELEMENTSTATUS Status(BYTE *p) {return Status((T*)p);}
        ELEMENTSTATUS Status(T *p);

        void SetStatus(BYTE *p, ELEMENTSTATUS s) {SetStatus((T*)p, s);}
        void SetStatus(T *p, ELEMENTSTATUS s);

        void* GetKey(BYTE *p) {return GetKey((T*)p);}
        void *GetKey(T *p);
        
    };

    CHrefOfClassHash       m_HrefOfClassHash;         // Hashed table of HREFTYPEs of ITypeInfos
    
    struct CErrorContext
    {
        // The following variables hold context info for error reporting.
        CErrorContext   *m_prev;        // A previous context.
        LPCUTF8         m_szAssembly;   // Current assembly name.
        LPCUTF8         m_szNamespace;  // Current type's namespace.
        LPCUTF8         m_szName;       // Current type's name.
        LPCUTF8         m_szMember;     // Current member's name.
        LPCUTF8         m_szParam;      // Current param's name.
        int             m_ixParam;      // Current param index.
        
        CErrorContext() : m_prev(0), m_szAssembly(0), m_szNamespace(0), m_szName(0), m_szMember(0), m_szParam(0), m_ixParam(-1) {}
    };
    CErrorContext       m_ErrorContext;
};


// eof ------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\tlbexport.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//===========================================================================
//  File: TlbExport.CPP
//  All Rights Reserved.
//
//  Notes: Create a TypeLib from COM+ metadata.
//---------------------------------------------------------------------------
#include "common.h"
#include "ComCallWrapper.h"
#include "Field.h"
#include "ndirect.h"
#include "nstruct.h"
#include "eeconfig.h"
#include "comdelegate.h"
#include "comdatetime.h"
#include <NSUtilPriv.h>
#include <TlbImpExp.h>
#include <mlang.h>

#include "TlbExport.h"
#include "ComMTMemberInfoMap.h"

#include <CorError.h>
#include <PostError.h>

#if defined(VALUE_MASK)
#undef VALUE_MASK
#endif

#include <guidfromname.h>
#include <utilcode.h>

#include <stgpool.h>
#include <sighelper.h>
#include <siginfo.hpp>

#include "PerfCounters.h"

#define EMPTY_DISPINTERFACE_ICLASSX     // Define to export an empty dispinterface for an AutoDispatch IClassX

//#define DO_EXPORT_ABSTRACT    // Define to export abstract classes & to mark abstract and ! .ctor() as noncreatable.

#ifndef IfNullGo
#define IfNullGo(x) do {if (!(x)) IfFailGo(E_OUTOFMEMORY);} while (0)
#endif

#define S_USEIUNKNOWN 2

//-----------------------------------------------------------------------------
// Silly wrapper to get around all the try/_try restrictions.
//-----------------------------------------------------------------------------
HRESULT ConvertI8ToDate(I8 ticks, double *pout)
{
    HRESULT hr = S_OK;
    COMPLUS_TRY
    {
        *pout = COMDateTime::TicksToDoubleDate(ticks);
    }
    COMPLUS_CATCH
    {
        hr = COR_E_ARGUMENTOUTOFRANGE;
    }
    COMPLUS_END_CATCH
    return hr;

}

                                        
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// This value determines whether, by default, we add the TYPEFLAG_FPROXY bit 
//  to exported interfaces.  If the value is true, Automation proxy is the 
//  default, and we do not set the bit.  If the value is false, no Automation
//  proxy is the default and we DO set the bit.
#define DEFAULT_AUTOMATION_PROXY_VALUE true
//-----------------------------------------------------------------------------

//#define _TRACE

#if defined(_DEBUG) && defined(_TRACE)
#define TRACE printf
#else
#define TRACE NullFn
inline void NullFn(const char *pf,...) {}
#endif

#if defined(_DEBUG)
#define IfFailPost(EXPR) \
    do { hr = (EXPR); if(FAILED(hr)) { DebBreakHr(hr); TlbPostError(hr); goto ErrExit; } } while (0)
#else // _DEBUG
#define IfFailPost(EXPR) \
    do { hr = (EXPR); if(FAILED(hr)) { TlbPostError(hr); goto ErrExit; } } while (0)
#endif // _DEBUG

#if defined(_DEBUG)
#define IfFailPostGlobal(EXPR) \
    do { hr = (EXPR); if(FAILED(hr)) { DebBreakHr(hr); PostError(hr); goto ErrExit; } } while (0)
#else // _DEBUG
#define IfFailPostGlobal(EXPR) \
    do { hr = (EXPR); if(FAILED(hr)) { PostError(hr); goto ErrExit; } } while (0)
#endif // _DEBUG

//*****************************************************************************
// Error reporting function.
//*****************************************************************************
extern HRESULT _cdecl PostError(HRESULT hrRpt, ...); 

//*****************************************************************************
// Constants.
//*****************************************************************************
static LPWSTR szRetVal = L"pRetVal";
static LPCWSTR szTypeLibExt = L".TLB";

static LPCWSTR szTypeLibKeyName = L"TypeLib";
static LPCWSTR szClsidKeyName = L"CLSID";

static LPCWSTR   szIClassX = L"_%ls";
static const int cbIClassX = 1;             
static WCHAR     szAlias[] = {L"_MIDL_COMPAT_%ls"};
static const int cbAlias = lengthof(szAlias) - 1;
static LPCWSTR   szParamName = L"p%d";

static LPCWSTR szGuidName           = L"GUID";

static LPCSTR szObjectClass         = "Object";
static LPCSTR szArrayClass          = "Array";
static LPCSTR szDateTimeClass       = "DateTime";
static LPCSTR szDecimalClass        = "Decimal";
static LPCSTR szGuidClass           = "Guid";
static LPCSTR szVariantClass        = "Variant";
static LPCSTR szStringClass         = g_StringName;
static LPCSTR szStringBufferClass   = g_StringBufferName;
static LPCSTR szIEnumeratorClass    = "IEnumerator";
static LPCSTR szColor               = "Color";

static const char szRuntime[]       = {"System."};
static const cbRuntime              = (lengthof(szRuntime)-1);

static const char szText[]          = {"System.Text."};
static const cbText                 = (lengthof(szText)-1);

static const char szCollections[]   = {"System.Collections."};
static const cbCollections          = (lengthof(szCollections)-1);

static const char szDrawing[]       = {"System.Drawing."};
static const cbDrawing              = (lengthof(szDrawing)-1);

// The length of the following string(w/o the terminator): "HKEY_CLASSES_ROOT\\CLSID\\{00000000-0000-0000-0000-000000000000}".
static const int cCOMCLSIDRegKeyLength = 62;

// The length of the following string(w/o the terminator): "{00000000-0000-0000-0000-000000000000}".
static const int cCLSIDStrLength = 38;

// {17093CC8-9BD2-11cf-AA4F-304BF89C0001}
static const GUID GUID_TRANS_SUPPORTED     = {0x17093CC8,0x9BD2,0x11cf,{0xAA,0x4F,0x30,0x4B,0xF8,0x9C,0x00,0x01}};

// {00020430-0000-0000-C000-000000000046}
static const GUID LIBID_STDOLE2 = { 0x00020430, 0x0000, 0x0000, { 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 } };

// {66504301-BE0F-101A-8BBB-00AA00300CAB}
static const GUID GUID_OleColor = { 0x66504301, 0xBE0F, 0x101A, { 0x8B, 0xBB, 0x00, 0xAA, 0x00, 0x30, 0x0C, 0xAB } };

// LIBID mscoree
static const GUID LIBID_MSCOREE = {0x5477469e,0x83b1,0x11d2,{0x8b,0x49,0x00,0xa0,0xc9,0xb7,0xc9,0xc4}};

static const char XXX_DESCRIPTION_TYPE[] = {"System.ComponentModel.DescriptionAttribute"};
static const char XXX_ASSEMBLY_DESCRIPTION_TYPE[] = {"System.Reflection.AssemblyDescriptionAttribute"};

// Forward declaration.
double _TicksToDoubleDate(const __int64 ticks);

//*****************************************************************************
// Convert a UTF8 string to Unicode, into a CQuickArray<WCHAR>.
//*****************************************************************************
HRESULT Utf2Quick(
    LPCUTF8     pStr,                   // The string to convert.
    CQuickArray<WCHAR> &rStr,           // The QuickArray<WCHAR> to convert it into.
    int         iCurLen)                // Inital characters in the array to leave (default 0).
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    int         iReqLen;                // Required additional length.
    int         bAlloc = 0;             // If non-zero, allocation was required.

    // Attempt the conversion.
    iReqLen = WszMultiByteToWideChar(CP_UTF8, 0, pStr, -1, rStr.Ptr()+iCurLen, (int)(rStr.MaxSize()-iCurLen));
    // If the buffer was too small, determine what is required.
    if (iReqLen == 0) 
        bAlloc = iReqLen = WszMultiByteToWideChar(CP_UTF8, 0, pStr, -1, 0, 0);
    // Resize the buffer.  If the buffer was large enough, this just sets the internal
    //  counter, but if it was too small, this will attempt a reallocation.  Note that 
    //  the length includes the terminating L'/0'.
    IfFailGo(rStr.ReSize(iCurLen+iReqLen));
    // If we had to realloc, then do the conversion again, now that the buffer is 
    //  large enough.
    if (bAlloc)
        VERIFY(iReqLen == WszMultiByteToWideChar(CP_UTF8, 0, pStr, -1, rStr.Ptr()+iCurLen, (int)(rStr.MaxSize())-iCurLen));
ErrExit:
    return hr;
} // HRESULT Utf2Quick()


//*****************************************************************************
// Convert a UTF8 string to Unicode, into a CQuickArray<WCHAR>.
//*****************************************************************************
HRESULT Utf2QuickCat(LPCUTF8 pStr, CQuickArray<WCHAR> &rStr)
{
    return Utf2Quick(pStr, rStr, (int)wcslen(rStr.Ptr()));
} // HRESULT Utf2Quick()


//*****************************************************************************
// Get the name of a typelib or typeinfo, add it to error text.
//*****************************************************************************
HRESULT PostTypeLibError(
    IUnknown    *pUnk,                  // An interface on the typeinfo.
    HRESULT     hrT,                    // The TypeInfo error.
    HRESULT     hrX)                    // The Exporter error.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr;                     // A result.
    ITypeInfo   *pITI=0;                // The ITypeInfo * on the typeinfo.
    ITypeLib    *pITLB=0;               // The ITypeLib *.
    BSTR        name=0;                 // The name of the TypeInfo.
    LPWSTR      pName;                  // Pointer to the name.
    WCHAR       rcErr[1024];            // Buffer for error message.

    // Try to get a name.
    hr = pUnk->QueryInterface(IID_ITypeInfo, (void**)&pITI);
    if (SUCCEEDED(hr))
        IfFailPostGlobal(pITI->GetDocumentation(MEMBERID_NIL, &name, 0,0,0));
    else
    {
        hr = pUnk->QueryInterface(IID_ITypeLib, (void**)&pITLB);
        if (SUCCEEDED(hr))
            IfFailPostGlobal(pITLB->GetDocumentation(MEMBERID_NIL, &name, 0,0,0));
    }
    pName = name ? name : L"???";
    
    // Format the typelib error.
    FormatRuntimeError(rcErr, lengthof(rcErr), hrT);
    
    // Post the TypeLib error as a parameter to the error.
    // ""The TypeLib exporter received error %ls (%x) while attempting to lay out the TypeInfo '%ls'."
    PostError(hrX, pName, hrT, rcErr);

ErrExit:
    if (pITI)
        pITI->Release();
    if (pITLB)
        pITLB->Release();
    if (name)
        ::SysFreeString(name);
    // Ignore any other errors, return the triggering error.
    return hrX;
} // HRESULT PostTypeLibError()


//*****************************************************************************
// Driver function for module tlb exports.
//*****************************************************************************
HRESULT ExportTypeLibFromModule(
    LPCWSTR     szModule,               // The module name.
    LPCWSTR     szTlb,                  // The typelib name.
    int         bRegister)              // If true, register the library.
{
    if (g_fEEInit) {
        // Cannot call this during EE startup
        return MSEE_E_ASSEMBLYLOADINPROGRESS;
    }

    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;
    int         bInited=false;          // Did we do CoInitializeEE?
    Module      *pModule=0;             // The new module.
    ITypeLib    *pTlb=0;                // temp pointer to typelib.
    ICreateTypeLib2 *pCTlb2=0;          // The ICreateTypeLib2 pointer.
    HMODULE     hMod = NULL;            // Handle of the module to be imported.
    Thread      *pThread = NULL;
    AppDomain   *pDomain = NULL;

    if (SystemDomain::System() == NULL)
    {
        IfFailGo(CoInitializeEE(COINITEE_DEFAULT));
        bInited = true;
    }

    pThread = SetupThread();
    IfNullGo(pThread);

    {
    ExportTypeLibFromLoadedAssembly_Args args = {pModule->GetAssembly(), szTlb, &pTlb, 0, 0, S_OK};
    IfFailGo(SystemDomain::ExternalCreateDomain(szModule, &pModule, &pDomain, 
             (SystemDomain::ExternalCreateDomainWorker)ExportTypeLibFromLoadedAssembly_Wrapper, &args));

    if (!pModule)
    {
        IfFailGo(PostError(TLBX_E_CANT_LOAD_MODULE, szModule));
    }

    hr = args.hr;
    }

    IfFailGo(hr);

    // Save the typelib to disk.
    IfFailPostGlobal(pTlb->QueryInterface(IID_ICreateTypeLib2, (void**)&pCTlb2));
    if (FAILED(hr=pCTlb2->SaveAllChanges()))
        IfFailGo(PostTypeLibError(pCTlb2, hr, TLBX_E_CANT_SAVE));

ErrExit:
    if (pTlb)
        pTlb->Release();
    if (pCTlb2)
        pCTlb2->Release();
    // If we initialized the EE, we should uninitialize it.
    if (bInited)
        CoUninitializeEE(FALSE);
    return hr;
} // HRESULT ExportTypeLibFromModule()

//*****************************************************************************
// Exports a loaded library.
//*****************************************************************************

void ExportTypeLibFromLoadedAssembly_Wrapper(ExportTypeLibFromLoadedAssembly_Args *args)
{
    args->hr = ExportTypeLibFromLoadedAssembly(args->pAssembly, args->szTlb, args->ppTlb, args->pINotify, args->flags);
}

HRESULT ExportTypeLibFromLoadedAssembly(
    Assembly    *pAssembly,             // The assembly.
    LPCWSTR     szTlb,                  // The typelib name.
    ITypeLib    **ppTlb,                // If not null, also return ITypeLib here.
    ITypeLibExporterNotifySink *pINotify,// Notification callback.
    int         flags)                  // Export flags.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;
    HRESULT     hrConv;
    TypeLibExporter exporter;           // Exporter object.
    LPCWSTR     szModule=0;             // Module filename.
    WCHAR       rcDrive[_MAX_DRIVE];
    WCHAR       rcDir[_MAX_DIR];
    WCHAR       rcFile[_MAX_FNAME];
    WCHAR       rcTlb[_MAX_PATH+5];     // Buffer for the tlb filename.
    int         bDynamic=0;             // If true, dynamic module.
    Module      *pModule;               // The Assembly's SecurityModule.
    Thread      *pThread = GetThread(); 
    BOOL        bPreemptive;            // Was thread in preemptive mode?

    // Exporting a typelib is unmanaged, and makes numerous COM calls.  Switch to preemptive, if not already.
    bPreemptive = !pThread->PreemptiveGCDisabled();
    if (!bPreemptive)
        pThread->EnablePreemptiveGC();

    _ASSERTE(ppTlb);
    _ASSERTE(pAssembly);
    
    pModule = pAssembly->GetSecurityModule();
    _ASSERTE(pModule);

    // Retrieve the module filename.
    szModule = pModule->GetFileName();   

    // Validate that the module is valid.
    if (pModule->GetILBase() == 0 && !pModule->IsInMemory())
        IfFailPostGlobal(TLBX_E_NULL_MODULE);
    
    // Make sure the assembly has not been imported from COM.
    if (pAssembly->GetManifestImport()->GetCustomAttributeByName(TokenFromRid(1, mdtAssembly), INTEROP_IMPORTEDFROMTYPELIB_TYPE, 0, 0) == S_OK)
        IfFailGo(PostError(TLBX_E_CIRCULAR_EXPORT, szModule));

    // If the module is dynamic then it will not have a file name.  We
    //  assign a dummy name for typelib name (if the scope does not have
    //  a name), but won't create a typelib on disk.
    if (*szModule == 0)
    {
        bDynamic = TRUE;
        szModule = L"Dynamic";
    }

    // Create the typelib name, if none provided.  Don't create one for Dynamic modules.
    if (!szTlb || !*szTlb)
    {
        if (bDynamic)
            szTlb = L"";
        else
        {
            SplitPath(szModule, rcDrive, rcDir, rcFile, 0);
            MakePath(rcTlb, rcDrive, rcDir, rcFile, szTypeLibExt);
            szTlb = rcTlb;
        }
    }

    // Do the conversion.  
    IfFailGo(exporter.Convert(pAssembly, szTlb, pINotify, flags));
    hrConv = hr;    // Save warnings.

    // Get a copy of the ITypeLib*
    IfFailGo(exporter.GetTypeLib(IID_ITypeLib, (IUnknown**)ppTlb));

    // Then free all other resources.
    exporter.ReleaseResources();

    if (hr == S_OK)
        hr = hrConv;

ErrExit:
    // Switch back to cooperative, if caller was cooperative.
    if (!bPreemptive)
        pThread->DisablePreemptiveGC();


    return hr;
} // HRESULT ExportTypeLibFromLoadedAssembly()

//*****************************************************************************
// Table to map COM+ calling conventions to TypeLib calling conventions.
//*****************************************************************************
CALLCONV Clr2TlbCallConv[] = {
    CC_STDCALL,         //  IMAGE_CEE_CS_CALLCONV_DEFAULT   = 0x0,  
    CC_CDECL,           //  IMAGE_CEE_CS_CALLCONV_C         = 0x1,  
    CC_STDCALL,         //  IMAGE_CEE_CS_CALLCONV_STDCALL   = 0x2,  
    CC_STDCALL,         //  IMAGE_CEE_CS_CALLCONV_THISCALL  = 0x3,  
    CC_FASTCALL,        //  IMAGE_CEE_CS_CALLCONV_FASTCALL  = 0x4,  
    CC_CDECL,           //  IMAGE_CEE_CS_CALLCONV_VARARG    = 0x5,  
    CC_MAX              //  IMAGE_CEE_CS_CALLCONV_FIELD     = 0x6,  
                        //  IMAGE_CEE_CS_CALLCONV_MAX       = 0x7   
    };

//*****************************************************************************
// Default notification class.
//*****************************************************************************
class CDefaultNotify : public ITypeLibExporterNotifySink
{
public:
    //-------------------------------------------------------------------------
    virtual HRESULT __stdcall ReportEvent(
        ImporterEventKind EventKind,        // Type of event.
        long        EventCode,              // HR of event.
        BSTR        EventMsg)               // Text message for event.
    {
        CANNOTTHROWCOMPLUSEXCEPTION();

        // Ignore the event.

        return S_OK;
    } // virtual HRESULT __stdcall ReportEvent()
    
    //-------------------------------------------------------------------------
    virtual HRESULT __stdcall ResolveRef(
        IUnknown    *Asm, 
        IUnknown    **pRetVal) 
    {
        HRESULT     hr;                     // A result.
        Assembly    *pAssembly=0;           // The referenced Assembly.
        ITypeLib    *pTLB=0;                // The created TypeLib.
        MethodTable *pAssemblyClass = NULL; //@todo -- get this.
        Thread      *pThread = GetThread(); 
        LPVOID      RetObj = NULL;          // The object to return.
        BOOL        bPreemptive;            // Was thread in preemptive mode?
        
        BEGINCANNOTTHROWCOMPLUSEXCEPTION();

        COMPLUS_TRY
        {
            // This method manipulates object ref's so we need to switch to cooperative GC mode.
            bPreemptive = !pThread->PreemptiveGCDisabled();
            if (bPreemptive)
                pThread->DisablePreemptiveGC();
 
            // Get the Referenced Assembly from the IUnknown.
            pAssembly = ((ASSEMBLYREF)GetObjectRefFromComIP(Asm, pAssemblyClass))->GetAssembly();

            // Switch to preemptive GC before we call out to COM.
            pThread->EnablePreemptiveGC();

            // Default resolution provides no notification, flags are 0.
            hr = ExportTypeLibFromLoadedAssembly(pAssembly, 0, &pTLB, 0 /*pINotify*/, 0 /* flags*/);

            // Switch back to cooperative now that we are finished calling out.
            if (!bPreemptive)
                pThread->DisablePreemptiveGC();

        }
        COMPLUS_CATCH
        {
            hr = SetupErrorInfo(GETTHROWABLE());
        }
        COMPLUS_END_CATCH

        *pRetVal = pTLB;
        
        ENDCANNOTTHROWCOMPLUSEXCEPTION();

        return hr;
    } // virtual HRESULT __stdcall ResolveRef()
    
    //-------------------------------------------------------------------------
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(// S_OK or E_NOINTERFACE
        REFIID      riid,                   // Desired interface.
        void        **ppvObject)            // Put interface pointer here.
    {
        CANNOTTHROWCOMPLUSEXCEPTION();

        *ppvObject = 0;
        if (riid == IID_IUnknown || riid == IID_ITypeLibExporterNotifySink)
        {
            *ppvObject = this;
            return S_OK;
        }
        return E_NOINTERFACE;
    } // virtual HRESULT QueryInterface()
    
    //-------------------------------------------------------------------------
    virtual ULONG STDMETHODCALLTYPE AddRef(void) 
    {
        return 1;
    } // virtual ULONG STDMETHODCALLTYPE AddRef()
    
    //-------------------------------------------------------------------------
    virtual ULONG STDMETHODCALLTYPE Release(void) 
    {
        return 1;
    } // virtual ULONG STDMETHODCALLTYPE Release()
};

static CDefaultNotify g_Notify;

//*****************************************************************************
// CTOR/DTOR.  
//*****************************************************************************
TypeLibExporter::TypeLibExporter()
 :  m_pICreateTLB(0), 
    m_pIUnknown(0), 
    m_pIDispatch(0),
    m_pIManaged(0),
    m_pGuid(0),
    m_hIUnknown(-1)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

#if defined(_DEBUG)
    static int i;
    ++i;    // So a breakpoint can be set.
#endif
} // TypeLibExporter::TypeLibExporter()

TypeLibExporter::~TypeLibExporter()
{
    ReleaseResources();
} // TypeLibExporter::~TypeLibExporter()

//*****************************************************************************
// Get an interface pointer from the ICreateTypeLib interface.
//*****************************************************************************
HRESULT TypeLibExporter::GetTypeLib(
    REFGUID     iid,
    IUnknown    **ppITypeLib)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    return m_pICreateTLB->QueryInterface(iid, (void**)ppITypeLib);
} // HRESULT TypeLibExporter::GetTypeLib()

//*****************************************************************************
// LayOut a TypeLib.  Call LayOut on all ICreateTypeInfo2s first.
//*****************************************************************************
HRESULT TypeLibExporter::LayOut()       // S_OK or error.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    int         cTypes;                 // Count of exported types.
    int         ix;                     // Loop control.
    CExportedTypesInfo *pData;          // For iterating the entries.

    cTypes = m_Exports.Count();
    
    // Call LayOut on all ICreateTypeInfo2*s.
    for (ix=0; ix<cTypes; ++ix)
    {
        pData = m_Exports[ix];
        if (pData->pCTI && FAILED(hr = pData->pCTI->LayOut()))
            return PostTypeLibError(pData->pCTI, hr, TLBX_E_LAYOUT_ERROR);
    }
    
    for (ix=0; ix<cTypes; ++ix)
    {
        pData = m_Exports[ix];
        if (pData->pCTIDefault && FAILED(hr = pData->pCTIDefault->LayOut()))
            return PostTypeLibError(pData->pCTIDefault, hr, TLBX_E_LAYOUT_ERROR);
    }
    
    // Repeat for injected types.
    cTypes = m_InjectedExports.Count();
    for (ix=0; ix<cTypes; ++ix)
    {
        pData = m_InjectedExports[ix];
        if (pData->pCTI && FAILED(hr = pData->pCTI->LayOut()))
            return PostTypeLibError(pData->pCTI, hr, TLBX_E_LAYOUT_ERROR);
    }
    
    for (ix=0; ix<cTypes; ++ix)
    {
        pData = m_InjectedExports[ix];
        if (pData->pCTIDefault && FAILED(hr = pData->pCTIDefault->LayOut()))
            return PostTypeLibError(pData->pCTIDefault, hr, TLBX_E_LAYOUT_ERROR);
    }
    
    return hr;
} // HRESULT TypeLibExporter::LayOut()

//*****************************************************************************
// Save a TypeLib.
//*****************************************************************************
HRESULT TypeLibExporter::Save()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;

    // Save the TypeLib.
    hr = m_pICreateTLB->SaveAllChanges();
    return hr;
} // HRESULT TypeLibExporter::Save()

//*****************************************************************************
// Release all pointers.
//*****************************************************************************
void TypeLibExporter::ReleaseResources()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    // Release the ITypeInfo* pointers.
    m_Exports.Clear();
    m_InjectedExports.Clear();

    // Clean up the created TLB.
    if (m_pICreateTLB)
        m_pICreateTLB->Release();
    m_pICreateTLB = 0;

    // Clean up the ITypeInfo*s for well-known interfaces.
    if (m_pIUnknown)
        m_pIUnknown->Release();
    m_pIUnknown = 0;
    if (m_pIDispatch)
        m_pIDispatch->Release();
    m_pIDispatch = 0;

    if (m_pIManaged)
        m_pIManaged->Release();
    m_pIManaged = 0;  

    if (m_pGuid)
        m_pGuid->Release();
    m_pGuid = 0;
} // void TypeLibExporter::ReleaseResources()

//*****************************************************************************
// Enumerate the Types in a Module, add to the list.
//*****************************************************************************
HRESULT TypeLibExporter::AddModuleTypes(
    Module     *pModule)                // The module to convert.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr;                     // A result.
    bool        bEnum=false;            // If true, enumerator needs closing.
    ULONG       cTD;                    // Count of typedefs.
    HENUMInternal eTD;                  // To enum TypeDefs
    mdTypeDef   td;                     // A TypeDef.
    EEClass     *pClass;                // An EEClass for a TypeDef.
    ULONG       ix;                     // Loop control.
    CExportedTypesInfo *pExported;   // For adding classes to the exported types cache.
    CExportedTypesInfo sExported;    // For adding classes to the exported types cache.
    
    // Convert all the types visible to COM.
    // Get an enumerator on TypeDefs in the scope.
    IfFailGo(pModule->GetMDImport()->EnumTypeDefInit(&eTD));
    cTD = pModule->GetMDImport()->EnumTypeDefGetCount(&eTD);

    // Add all the classes to the hash.
    for (ix=0; ix<cTD; ++ix)
    {   
        // Get the TypeDef.
        if (!pModule->GetMDImport()->EnumTypeDefNext(&eTD, &td))
            return (E_UNEXPECTED);
        
        // Get the class, perform the step.
        IfFailGo(LoadClass(pModule, td, &pClass));
        // See if this class is already in the list.
        sExported.pClass = pClass;
        pExported = m_Exports.Find(&sExported);
        if (pExported != 0)
            continue;
        // New class, add to list.
        IfNullGo(pExported = m_Exports.Add(&sExported));        
        pExported->pClass = pClass;
        pExported->pCTI = 0;
        pExported->pCTIDefault = 0;
    }
    
ErrExit:
    if (bEnum)
        pModule->GetMDImport()->EnumTypeDefClose(&eTD);
    return hr;
} // HRESULT TypeLibExporter::AddModuleTypes()

//*****************************************************************************
// Enumerate the Modules in an assembly, add the types to the list.
//*****************************************************************************
HRESULT TypeLibExporter::AddAssemblyTypes(
    Assembly    *pAssembly)              // The assembly to convert.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    Module      *pModule;               // A module in the assembly.
    mdFile      mf;                     // A file token.
    bool        bEnum=false;            // If true, enumerator needs closing.
    HENUMInternal phEnum;               // Enumerator over the modules of the assembly.

    if (pAssembly->GetManifestImport())
    {
        IfFailGo(pAssembly->GetManifestImport()->EnumInit(mdtFile, mdTokenNil, &phEnum));
        bEnum = true;

        // Get the module for the assembly.
        pModule = pAssembly->GetSecurityModule();
        IfFailGo(AddModuleTypes(pModule));
        
        while (pAssembly->GetManifestImport()->EnumNext(&phEnum, &mf))
        {
            IfFailGo(pAssembly->FindInternalModule(mf, 
                         tdNoTypes,
                         &pModule, 
                         NULL));

            if (pModule)
                IfFailGo(AddModuleTypes(pModule));
        }
    }

ErrExit:
    if (bEnum)
        pAssembly->GetManifestImport()->EnumClose(&phEnum);
    return hr;    
} // HRESULT TypeLibExporter::AddAssemblyTypes()
    
//*****************************************************************************
// Convert COM+ metadata to a typelib.
//*****************************************************************************
HRESULT TypeLibExporter::Convert(
    Assembly    *pAssembly,             // The Assembly to convert
    LPCWSTR     szTlbName,              // Name of resulting TLB
    ITypeLibExporterNotifySink *pNotify,// Notification callback.
    int         flags)                  // Conversion flags
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    ULONG       i;                      // Loop control.
    LPCUTF8     pszName;                // Library name in UTF8.
    CQuickArray<WCHAR> rName;           // Library name.
    LPWSTR      pName;                  // Pointer to library name.
    LPWSTR      pch=0;                  // Pointer into lib name.
    GUID        guid;                   // Library guid.
    VARIANT     vt = {0};               // Variant for ExportedFromComPlus.
    AssemblySpec spec;                  // To get Assembly identity.
    CQuickArray<BYTE> rBuf;             // Serialize spec to a buffer.
    //DWORD cbReq;                        // Bytes needed for buffer.
    HENUMInternal eTD;                  // To enum TypeDefs
    CQuickArray<WCHAR> qLocale;         // Wide string for locale.
    IMultiLanguage *pIML=0;             // For locale->lcid conversion.
    LCID        lcid;                   // LCID for typelib, default 0.
    BSTR        szDescription=0;        // Assembly Description.
    
    // Set PerfCounters
    COUNTER_ONLY(GetPrivatePerfCounters().m_Interop.cTLBExports++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Interop.cTLBExports++);

    ITypeLib    *pITLB=0;               // TypeLib for IUnknown, IDispatch.
    ITypeLib    *pITLBmscoree = 0;      // TypeLib for IManagedObject, ICatalogServices
    BSTR        szTIName=0;             // Name of a TypeInfo.

    // Error reporting information.
    pAssembly->GetName(&m_ErrorContext.m_szAssembly);
    
    m_flags = flags;
    
    // Set the callback.
    m_pNotify = pNotify ? pNotify : &g_Notify;
    
    
    // Get some well known TypeInfos.
    IfFailPost(LoadRegTypeLib(LIBID_STDOLE2, -1, -1, 0, &pITLB));
    IfFailPost(pITLB->GetTypeInfoOfGuid(IID_IUnknown, &m_pIUnknown));
    IfFailPost(pITLB->GetTypeInfoOfGuid(IID_IDispatch, &m_pIDispatch));
    
    // Look for GUID (which unfortunately has no GUID).
    for (i=0; i<pITLB->GetTypeInfoCount() && !m_pGuid; ++i)
    {
        IfFailPost(pITLB->GetDocumentation(i, &szTIName, 0, 0, 0));
        if (_wcsicmp(szTIName, szGuidName) == 0)
            IfFailPost(pITLB->GetTypeInfo(i, &m_pGuid));
        SysFreeString(szTIName);
        szTIName = 0;
    }

    // Get IManagedObject and ICatalogServices from mscoree.tlb.
    if (FAILED(hr = LoadRegTypeLib(LIBID_MSCOREE, -1, -1, 0, &pITLBmscoree)))
        IfFailGo(PostError(TLBX_E_NO_MSCOREE_TLB));
    if (FAILED(hr = pITLBmscoree->GetTypeInfoOfGuid(IID_IManagedObject, &m_pIManaged)))
    {
        IfFailGo(PostError(TLBX_E_BAD_MSCOREE_TLB));
    }
   
    // Create the output typelib.

    // Win2K: passing in too long a filename triggers a nasty buffer overrun bug
    // when the SaveAll() method is called. We'll avoid triggering this here.
    // 
    if (szTlbName && (wcslen(szTlbName) > MAX_PATH))
    {
        IfFailPost(HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE));
    }

    IfFailPost(CreateTypeLib2(SYS_WIN32, szTlbName, &m_pICreateTLB));

    // Set the typelib GUID.
    IfFailPost(GetTypeLibGuidForAssembly(pAssembly, &guid));
    IfFailPost(m_pICreateTLB->SetGuid(guid));

    // Retrieve the type library's version number.
    USHORT usMaj, usMin;
    IfFailPost(GetTypeLibVersionFromAssembly(pAssembly, &usMaj, &usMin));

    // Set the TLB's version number.
    IfFailPost(m_pICreateTLB->SetVersion(usMaj, usMin));

    // Set the LCID.  If no locale, set to 0, otherwise typelib defaults to 409.
    lcid = 0;
    if (pAssembly->m_Context->szLocale && *pAssembly->m_Context->szLocale)
    {
        hr = Utf2Quick(pAssembly->m_Context->szLocale, qLocale);
        if (SUCCEEDED(hr))
            hr = ::CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage, (void**)&pIML);
        if (SUCCEEDED(hr))
            pIML->GetLcidFromRfc1766(&lcid, qLocale.Ptr());
    }
    HRESULT hr2 = m_pICreateTLB->SetLcid(lcid);
    if (hr2 == TYPE_E_UNKNOWNLCID)
    {

        ReportWarning(TYPE_E_UNKNOWNLCID, TYPE_E_UNKNOWNLCID);
        hr2 = m_pICreateTLB->SetLcid(0);
    }
    IfFailPost(hr2);

    // Get the list of types in the assembly.
    IfFailGo(AddAssemblyTypes(pAssembly));
    m_Exports.InitArray();

    // Get the assembly value for AutomationProxy.
    m_bAutomationProxy = DEFAULT_AUTOMATION_PROXY_VALUE;
    IfFailGo(GetAutomationProxyAttribute(pAssembly->GetSecurityModule()->GetMDImport(), TokenFromRid(1, mdtAssembly), &m_bAutomationProxy));

    // Pre load any caller-specified names into the typelib namespace.
    IfFailGo(PreLoadNames());

    // Convert all the types.
    IfFailGo(ConvertAllTypeDefs());

    // Set library level properties.
     pAssembly->GetName(&pszName);
    IfFailGo(Utf2Quick(pszName, rName));
    pName = rName.Ptr();
    
    // Make it a legal typelib name.
    for (pch=pName; *pch; ++pch)
        if (*pch == '.' || *pch == ' ')
            *pch = '_';
    IfFailPost(m_pICreateTLB->SetName((LPWSTR)pName));

    // If the assembly has a description CA, set that as the library Doc string.
    IfFailGo(GetStringCustomAttribute(pAssembly->GetManifestImport(), XXX_ASSEMBLY_DESCRIPTION_TYPE, TokenFromRid(mdtAssembly, 1), szDescription));
    if (hr == S_OK)
        m_pICreateTLB->SetDocString((LPWSTR)szDescription);

    // Mark this typelib as exported.
    //@todo: get the better string from Craig.
    LPCWSTR pszFullName;
    IfFailGo(pAssembly->GetFullName(&pszFullName));
    vt.vt = VT_BSTR;
    //vt.bstrVal = SysAllocStringLen(0, (int)rBuf.Size());
    vt.bstrVal = SysAllocString(pszFullName);
    //WszMultiByteToWideChar(CP_ACP,0, (char*)rBuf.Ptr(), (DWORD)rBuf.Size(), vt.bstrVal, (DWORD)rBuf.Size());
    IfFailPost(m_pICreateTLB->SetCustData(GUID_ExportedFromComPlus, &vt));
     
    // Lay out the TypeInfos.
    IfFailGo(LayOut());
    
ErrExit:
    if (pIML)
        pIML->Release();
    if (pITLB)
        pITLB->Release();
    if(pITLBmscoree)
        pITLBmscoree->Release();
    if (szDescription)
        ::SysFreeString(szDescription);
    if (szTIName)
        ::SysFreeString(szTIName);
    return hr;
} // HRESULT TypeLibExporter::Convert()

//*****************************************************************************
//*****************************************************************************
HRESULT TypeLibExporter::PreLoadNames()
{
    ITypeLibExporterNameProvider    *pINames = 0;
    HRESULT     hr = S_OK;              // A result.
    SAFEARRAY   *pNames = 0;            // Names provided by caller.
    VARTYPE     vt;                     // Type of data.
    long        lBound, uBound, ix;     // Loop control.
    BSTR        name;

    // Look for names provider, but don't require it.
    m_pNotify->QueryInterface(IID_ITypeLibExporterNameProvider, (void**)&pINames);
    if (pINames == 0)
        goto ErrExit;

    // There is a provider, so get the list of names.
    IfFailGo(pINames->GetNames(&pNames));

    // Better have a single dimension array of strings.
    if (pNames == 0)
        IfFailGo(TLBX_E_BAD_NAMES);
    if (SafeArrayGetDim(pNames) != 1)
        IfFailGo(TLBX_E_BAD_NAMES);
    IfFailGo(SafeArrayGetVartype(pNames, &vt));
    if (vt != VT_BSTR)
        IfFailGo(TLBX_E_BAD_NAMES);

    // Get names bounds.
    IfFailGo(SafeArrayGetLBound(pNames, 1, &lBound));
    IfFailGo(SafeArrayGetUBound(pNames, 1, &uBound));

    // Enumerate the names.
    for (ix=lBound; ix<=uBound; ++ix)
    {
        IfFailGo(SafeArrayGetElement(pNames, &ix, (void*)&name));
        m_pICreateTLB->SetName(name);
    }


ErrExit:
    if (pINames)
        pINames->Release();
    if (pNames)
        SafeArrayDestroy(pNames);

    return hr;
}

//*****************************************************************************
//*****************************************************************************
HRESULT TypeLibExporter::FormatErrorContextString(
    CErrorContext *pContext,            // The context to format.
    LPWSTR      pOut,                   // Buffer to format into.
    ULONG       cchOut)                 // Size of the buffer, wide chars.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    WCHAR       rcSub[1024];
    WCHAR       rcName[1024];
    LPWSTR      pBuf;
    ULONG       cchBuf;
    ULONG       ch;
    
    // Nested contexts?
    if (pContext->m_prev == 0)
    {   // No, just convert into caller's buffer.
        pBuf = pOut;
        cchBuf = cchOut-1;
    }
    else
    {   // Yes, convert locally, then concatenate.
        pBuf = rcName;
        cchBuf = lengthof(rcName)-1;
    }
    
    // More?
    if (((pContext->m_szNamespace && *pContext->m_szNamespace) || pContext->m_szName) && cchBuf > 2)
    {   
        // Namespace?
        if (pContext->m_szNamespace && *pContext->m_szNamespace)
        {
            ch = ::WszMultiByteToWideChar(CP_UTF8,0, pContext->m_szNamespace,-1, pBuf,cchBuf);
            // If the string fit, add the separator, and update pointers.
            if (ch != 0)
            {
                --ch;
                cchBuf -= ch;
                pBuf += ch;
                *pBuf = NAMESPACE_SEPARATOR_CHAR;
                ++pBuf;
                --cchBuf;
            }
        }
        // Name.
        if (cchBuf > 2)
        {
            ch = ::WszMultiByteToWideChar(CP_UTF8,0, pContext->m_szName,-1, pBuf,cchBuf);
            // If the string fit, add the separator, and update pointers.
            if (ch != 0)
            {
                --ch;
                cchBuf -= ch;
                pBuf += ch;
            }
        }
        
        // Member?
        if (pContext->m_szMember && cchBuf>2)
        {
            *pBuf = NAMESPACE_SEPARATOR_CHAR;
            ++pBuf;
            --cchBuf;
            
            ch = ::WszMultiByteToWideChar(CP_UTF8,0, pContext->m_szMember,-1, pBuf,cchBuf);
            // If the string fit, add the separator, and update pointers.
            if (ch != 0)
            {
                --ch;
                cchBuf -= ch;
                pBuf += ch;
            }

            // Param?
            if (pContext->m_szParam && cchBuf>3)
            {
                *pBuf = '(';
                ++pBuf;
                --cchBuf;
                
                ch = ::WszMultiByteToWideChar(CP_UTF8,0, pContext->m_szParam,-1, pBuf,cchBuf);
                // If the string fit, add the separator, and update pointers.
                if (ch != 0)
                {
                    --ch;
                    cchBuf -= ch;
                    pBuf += ch;
                }

                if (cchBuf>2)
                {
                    *pBuf = ')';
                    ++pBuf;
                    --cchBuf;
                }
            }
            else
            if (pContext->m_ixParam > -1 && cchBuf>3)
            {
                ch = _snwprintf(pBuf, cchBuf, L"(#%d)", pContext->m_ixParam); 
                if( ch >= 0) {
                    cchBuf -= ch;	//cchbuf can be 0
                    pBuf += ch;                	
                }                	
            }
        } // member

        //cchBuf can be 0 here under some case 
	 // an example will be strlen(m_szNamespace)+1 == cchBuf.
        if( cchBuf >=1 ) {
            // Separator.
            *pBuf = ASSEMBLY_SEPARATOR_CHAR;
            ++pBuf;
             --cchBuf;
        }

        if( cchBuf >=1 ) {
            // Space.
           *pBuf = ' ';
           ++pBuf;
            --cchBuf;
        }
    } // Type name

    // if cchBuf is 0 here. We can't convert assembly name
    if( cchBuf > 0) {
        // Put in assembly name.
        ch = ::WszMultiByteToWideChar(CP_UTF8,0, pContext->m_szAssembly,-1, pBuf,cchBuf);
        // If the string fit, add the separator, and update pointers.
       if (ch != 0)
       {
            --ch;
            cchBuf -= ch;
            pBuf += ch;   
       }
    }  

    // NUL terminate.
    *pBuf = 0;
    
    // If there is a nested context, put it all together.
    if (pContext->m_prev)
    {   // Format the context this one was nested inside.
        FormatErrorContextString(pContext->m_prev, rcSub, lengthof(rcSub));
        // put them together with text.
        FormatRuntimeError(pOut, cchOut, TLBX_E_CTX_NESTED, rcName, rcSub);
    }
    
    return S_OK;
    
} // HRESULT TypeLibExporter::FormatErrorContextString()

//*****************************************************************************
//*****************************************************************************
HRESULT TypeLibExporter::FormatErrorContextString(
    LPWSTR      pBuf,                   // Buffer to format into.
    ULONG       cch)                    // Size of the buffer, wide chars.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    return FormatErrorContextString(&m_ErrorContext, pBuf, cch);
} // HRESULT TypeLibExporter::FormatErrorContextString()

//*****************************************************************************
// Error reporting helper.
//*****************************************************************************
HRESULT TypeLibExporter::ReportEvent(   // Returns the original HR.
    int         ev,                     // The event kind.
    int         hr,                     // HR.
    ...)                                // Variable args.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    WCHAR       rcMsg[1024];            // Buffer for message.
    va_list     marker;                 // User text.
    BSTR        bstrMsg=0;              // BSTR for message.
    
    // Format the message.
    va_start(marker, hr);
    hr = FormatRuntimeErrorVa(rcMsg, lengthof(rcMsg), hr, marker);
    va_end(marker);
    
    // Convert to a BSTR.
    bstrMsg = ::SysAllocString(rcMsg);
    
    // Display it, and clean up.
    if (bstrMsg)
    {
        m_pNotify->ReportEvent(static_cast<ImporterEventKind>(ev), hr, bstrMsg);
        ::SysFreeString(bstrMsg);
    }
    
    return hr;
} // HRESULT CImportTlb::ReportEvent()

//*****************************************************************************
// Warning reporting helper.
//*****************************************************************************
HRESULT TypeLibExporter::ReportWarning( // Original error code.
    HRESULT hrReturn,                   // HR to return.
    HRESULT hrRpt,                      // Error code.
    ...)                                // Args to message.
{
    WCHAR       rcErr[1024];            // Buffer for error message.
    WCHAR       rcName[1024];           // Buffer for context.
    va_list     marker;                 // User text.
    BSTR        bstrMsg=0;              // BSTR for message.
    BSTR        bstrBuf=0;              // Buffer for message.
    UINT        iLen;                   // Length of allocated buffer.
    
    // Format the message.
    va_start(marker, hrRpt);
    FormatRuntimeErrorVa(rcErr, lengthof(rcErr), hrRpt, marker);
    va_end(marker);
    
    // Format the context.
    *rcName = 0;
    FormatErrorContextString(rcName, lengthof(rcName));
                        
    // Put them together.
    bstrBuf = ::SysAllocStringLen(0, iLen=(UINT)(wcslen(rcErr)+wcslen(rcName)+200));
    
    if (bstrBuf)
    {
        FormatRuntimeError(bstrBuf, iLen, TLBX_W_WARNING_MESSAGE, rcName, rcErr);
        // Have to copy to another BSTR, because the runtime will also print the trash after the 
        //  terminating nul.
        bstrMsg = ::SysAllocString(bstrBuf);
        ::SysFreeString(bstrBuf);
        if (bstrMsg)
        {
            m_pNotify->ReportEvent(NOTIF_CONVERTWARNING, hrRpt, bstrMsg);
            ::SysFreeString(bstrMsg);
        }
    }
    
    return hrReturn;
} // HRESULT TypeLibExporter::ReportWarning()

//*****************************************************************************
// Function to provide context information for a posted error.
//*****************************************************************************
HRESULT TypeLibExporter::TlbPostError(  // Original error code.
    HRESULT hrRpt,                      // Error code.
    ...)                                // Args to message.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    WCHAR       rcErr[1024];            // Buffer for error message.
    WCHAR       rcName[1024];           // Buffer for context.
    va_list     marker;                 // User text.
    BSTR        bstrMsg=0;              // BSTR for message.
    
    // Format the message.
    va_start(marker, hrRpt);
    FormatRuntimeErrorVa(rcErr, lengthof(rcErr), hrRpt, marker);
    va_end(marker);
    
    // Format the context.
    FormatErrorContextString(rcName, lengthof(rcName));

    // Create the IErrorInfo
    ::PostError(TLBX_E_ERROR_MESSAGE, rcName, rcErr);
    
    return hrRpt;
} // HRESULT TypeLibExporter::TlbPostError()


//*****************************************************************************
// Post a class load error on failure.
//*****************************************************************************
HRESULT TypeLibExporter::PostClassLoadError(
    LPCUTF8     pszName,                // Name of the class.
    OBJECTREF   *pThrowable)            // Exception thrown by class load failure.
{
    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = E_FAIL;            // A result.  Failure->Post error with name.
    BOOL        bToggleGC = FALSE;      // If true, return to preemptive gc.
    Thread      *pThread;               // Thread for current thread.

    // Try to set up Thread.
    IfNullGo(pThread = SetupThread());

    // This method manipulates object ref's so we need to switch to cooperative GC mode.
    bToggleGC = !pThread->PreemptiveGCDisabled();
    if (bToggleGC)
        pThread->DisablePreemptiveGC();
 
    // If there isn't an exception object, just use name.
    IfNullGo(*pThrowable);

    {
    
    CQuickWSTRNoDtor message;

    COMPLUS_TRY 
    {
        GetExceptionMessage(*pThrowable, &message);
        // See if we got anything back.
        if (message.Size() > 0) {
            // Post the class load exception as an error.
            TlbPostError(TLBX_E_CLASS_LOAD_EXCEPTION, pszName, message.Ptr());
            // Successfully posted the richer error.
            hr = S_OK;
        }
    } 
    COMPLUS_CATCH 
    {
        // Just use the default error with class name.
    }
    COMPLUS_END_CATCH

    message.Destroy();

    }

ErrExit:
    // Switch back to the original GC mode.
    if (bToggleGC)
        pThread->EnablePreemptiveGC();

    // If there was a failure getting the richer error, post an error with the class name.
    if (FAILED(hr))
        TlbPostError(TLBX_E_CANT_LOAD_CLASS, pszName);

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return TLBX_E_CANT_LOAD_CLASS;
} // HRESULT TypeLibExporter::PostClassLoadError()

//*****************************************************************************
// Determine the type, if any, of auto-interface for a class.
//  May be none, dispatch, or dual.
//*****************************************************************************
TypeLibExporter::ClassAutoType TypeLibExporter::ClassHasIClassX(  // None, dual, dispatch
    EEClass     *pClass)                // The class.
{
    _ASSERTE(!pClass->IsInterface());

    DefaultInterfaceType DefItfType;
    TypeHandle hndDefItfClass;
    HRESULT     hr;
    ClassAutoType rslt = CLASS_AUTO_NONE;


    // If the class is a COM import then it does not have an IClassX.
    if (pClass->IsComImport())
        return rslt;

    // Check to see if we need to set up an IClassX for the class.
    hr = TryGetDefaultInterfaceForClass(TypeHandle(pClass->GetMethodTable()), &hndDefItfClass, &DefItfType);

    // The results apply to this class if the result is S_OK, and the hndDefItfClass is this class itself,
    //  not a parent class.
    if (hr == S_OK && hndDefItfClass.GetClass() == pClass)
    {                
        if (DefItfType == DefaultInterfaceType_AutoDual)
            rslt = CLASS_AUTO_DUAL;
#ifdef EMPTY_DISPINTERFACE_ICLASSX
        else
        if (DefItfType == DefaultInterfaceType_AutoDispatch)
            rslt = CLASS_AUTO_DISPATCH;
#endif
    }

    return rslt;
} // TypeLibExporter::ClassAutoType TypeLibExporter::ClassHasIClassX()

//*****************************************************************************
// Load a class by token, post an error on failure.
//*****************************************************************************
HRESULT TypeLibExporter::LoadClass(
    Module      *pModule,               // Module with Loader to use to load the class.
    mdToken     tk,                     // The token to load.
    EEClass     **ppClass)              // Put EEClass* here.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    OBJECTREF   Throwable = 0;          // A possible error.

    BEGIN_ENSURE_COOPERATIVE_GC();
    GCPROTECT_BEGIN(Throwable)
    {
        // Get the EEClass for the token.
        NameHandle name(pModule, tk);
        *ppClass = pModule->GetClassLoader()->LoadTypeHandle(&name, &Throwable).GetClass();

        if (*ppClass == 0)
        {   // Format a hopefully useful error message.
            LPCUTF8 pNS, pName;
            CQuickArray<char> rName;
            if (TypeFromToken(tk) == mdtTypeDef)
                pModule->GetMDImport()->GetNameOfTypeDef(tk, &pName, &pNS);
            else
            {
                _ASSERTE(TypeFromToken(tk) == mdtTypeRef);
                pModule->GetMDImport()->GetNameOfTypeRef(tk, &pNS, &pName);
            }

            if (pNS && *pNS && SUCCEEDED(rName.ReSize((int)(strlen(pName)+strlen(pNS)+2))))
            {   // If there is a buffer available, format the entire namespace + name.
                strcat(strcat(strcpy(rName.Ptr(), pNS), NAMESPACE_SEPARATOR_STR), pName);
                pName = rName.Ptr();
            }

            IfFailGo(PostClassLoadError(pName, &Throwable));
        }

ErrExit:;
    }
    GCPROTECT_END();
    END_ENSURE_COOPERATIVE_GC();

    return hr;
} // HRESULT TypeLibExporter::LoadClass()

//*****************************************************************************
// Load a class by name, post an error on failure.
//*****************************************************************************
HRESULT TypeLibExporter::LoadClass(
    Module      *pModule,               // Module with Loader to use to load the class.
    LPCUTF8     pszName,                // Name of class to load.
    EEClass     **ppClass)              // Put EEClass* here.
{
    CANNOTTHROWCOMPLUSEXCEPTION();


    HRESULT     hr = S_OK;              // A result.

    BEGIN_ENSURE_COOPERATIVE_GC();

    OBJECTREF   Throwable = 0;          // A possible error.

    GCPROTECT_BEGIN(Throwable)
    {
        // Get the EEClass for the token.
        *ppClass = pModule->GetClassLoader()->LoadClass(pszName, &Throwable);

        if (*ppClass == 0)
        {   
            IfFailGo(PostClassLoadError(pszName, &Throwable));
        }

ErrExit:;
    }
    GCPROTECT_END();

    END_ENSURE_COOPERATIVE_GC();

    return hr;
} // HRESULT TypeLibExporter::LoadClass()

//*****************************************************************************
// Enumerate the TypeDefs and convert them to TypeInfos.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertAllTypeDefs()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    CExportedTypesInfo *pData;          // For iterating the entries.
    int         cTypes;                 // Count of types.
    int         ix;                     // Loop control.
    
    LPCSTR pName1, pNS1;                // Names of a type.
    LPCSTR pName2, pNS2;                // Names of another type.
    EEClass     *pc1;                   // A Type.
    EEClass     *pc2;                   // Another type.
    CQuickArray<BYTE> bNamespace;       // Array of flags for namespace decoration.
        
    cTypes = m_Exports.Count();

    // If there are no types in the assembly, then we are done.
    if (cTypes <= 0)
        return S_OK;
    
    // Order by name, then look for duplicates.
    m_Exports.SortByName();                    
    
    // Resize the array for namespace flags now, but use the ICreateTypeInfo*, so that
    //  the flags will be sorted.
    IfFailGo(bNamespace.ReSize(cTypes));
    
    // Get names of first type.
    pc1 = m_Exports[0]->pClass;
    pc1->GetMDImport()->GetNameOfTypeDef(pc1->GetCl(), &pName1, &pNS1);
    
    // Iterate through the types, looking for duplicate type names.
    for (ix=0; ix<cTypes-1; ++ix)
    {
        // Get the Type pointers and the types' names.
        pc2 = m_Exports[ix+1]->pClass;
        pc2->GetMDImport()->GetNameOfTypeDef(pc2->GetCl(), &pName2, &pNS2);
        
        // If the types match (case insensitive). mark both types for namespace
        //  decoration.  
        if (_stricmp(pName1, pName2) == 0)
        {
            m_Exports[ix]->pCTI = reinterpret_cast<ICreateTypeInfo2*>(1);
            m_Exports[ix+1]->pCTI = reinterpret_cast<ICreateTypeInfo2*>(1);
        }
        else
        {   // Didn't match, so advance "class 1" pointer.
            pc1 = pc2;
            pName1 = pName2;
            pNS1 = pNS2;
        }
    }
    
    // Put into token order for actual creation.
    m_Exports.SortByToken();
    
    // Fill the flag array, from the ICreateTypeInfo* pointers.
    memset(bNamespace.Ptr(), 0, bNamespace.Size()*sizeof(BYTE));
    for (ix=0; ix<cTypes; ++ix)
    {
        if (m_Exports[ix]->pCTI)
            bNamespace[ix] = 1, m_Exports[ix]->pCTI = 0;
    }
    
    // Pass 1.  Create the TypeInfos.
    // There are four steps in the process:
    //  a) Creates the TypeInfos for the types themselves.  When a duplicate
    //     is encountered, skip the type until later, so that we don't create
    //     a decorated name that will conflict with a subsequent non-decorated
    //     name.  We want to preserve a type's given name as much as possible.
    //  b) Create the TypeInfos for the types that were duplicates in step a.
    //     Perform decoration of the names as necessary to eliminate duplicates.
    //  c) Create the TypeInfos for the IClassXs.  When there is a duplicate,
    //     skip, as in step a.
    //  d) Create the remaining TypeInfos for IClassXs.  Perform decoration of 
    //     the names as necessary to eliminate duplicates.
    
    // Step a, Create the TypeInfos for the TypeDefs, no decoration.
    for (ix=0; ix<cTypes; ++ix)
    {
        int     bAutoProxy = m_bAutomationProxy;
        pData = m_Exports[ix];
        pData->tkind = TKindFromClass(pData->pClass);
        IfFailGo(GetAutomationProxyAttribute(pData->pClass->GetMDImport(), pData->pClass->GetCl(), &bAutoProxy));
        pData->bAutoProxy = (bAutoProxy != 0);
        
        IfFailGo(CreateITypeInfo(pData, (bNamespace[ix]!=0), false));
    }
    // Step b, Create the TypeInfos for the TypeDefs, decoration as needed.
    for (ix=0; ix<cTypes; ++ix)
    {
        pData = m_Exports[ix];
        if (pData->pCTI == 0)
            IfFailGo(CreateITypeInfo(pData, (bNamespace[ix]!=0), true));
    }
    
    // Step c, Create the TypeInfos for the IClassX interfaces.  No decoration.
    for (ix=0; ix<cTypes; ++ix)
    {
        pData = m_Exports[ix];
        IfFailGo(CreateIClassXITypeInfo(pData, (bNamespace[ix]!=0), false));
    }
    // Step d, Create the TypeInfos for the IClassX interfaces.  Decoration as required.
    for (ix=0; ix<cTypes; ++ix)
    {
        pData = m_Exports[ix];
        if (pData->pCTIDefault == 0)
            IfFailGo(CreateIClassXITypeInfo(pData, (bNamespace[ix]!=0), true));
    }
    
    // Pass 2, add the ImplTypes to the CoClasses.
    for (ix=0; ix<cTypes; ++ix)
    {
        pData = m_Exports[ix];
        IfFailGo(ConvertImplTypes(pData));
    }

    
    // Pass 3, fill in the TypeInfo details...
    for (ix=0; ix<cTypes; ++ix)
    {
        pData = m_Exports[ix];
        IfFailGo(ConvertDetails(pData));
    }

    hr = S_OK;

ErrExit:

    return (hr);
} // HRESULT TypeLibExporter::ConvertAllTypeDefs()

//*****************************************************************************
// Convert one TypeDef.  Useful for one-off TypeDefs in other scopes where 
//  that other scope's typelib doesn't contain a TypeInfo.  This happens
//  for the event information with imported typelibs.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertOneTypeDef(
    EEClass     *pClass)                // The one class to convert.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    ICreateTypeInfo2 *pCTI=0;           // The TypeInfo to create.
    ICreateTypeInfo2 *pDefault=0;       // A possible IClassX TypeInfo.
    CErrorContext SavedContext;         // Previous error context.
    CExportedTypesInfo *pExported;      // For adding classes to the exported types cache.
    CExportedTypesInfo sExported;       // For adding classes to the exported types cache.

    // Save error reporting context.
    SavedContext = m_ErrorContext;
    pClass->GetAssembly()->GetName(&m_ErrorContext.m_szAssembly);
    m_ErrorContext.m_szNamespace = 0;
    m_ErrorContext.m_szName      = 0;
    m_ErrorContext.m_szMember    = 0;
    m_ErrorContext.m_szParam     = 0;
    m_ErrorContext.m_ixParam     = -1;
    m_ErrorContext.m_prev = &SavedContext;
    
    // See if this class is already in the list.
    sExported.pClass = pClass;
    pExported = m_InjectedExports.Find(&sExported);
    if (pExported == 0)
    {
        // Get the AutoProxy value for an isolated class.
        int     bAutoProxy = DEFAULT_AUTOMATION_PROXY_VALUE;
        IfFailGo(GetAutomationProxyAttribute(pClass->GetMDImport(), pClass->GetCl(), &bAutoProxy));
        if (hr == S_FALSE)
            IfFailGo(GetAutomationProxyAttribute(pClass->GetAssembly()->GetSecurityModule()->GetMDImport(), TokenFromRid(1, mdtAssembly), &bAutoProxy));

        // New class, add to list.
        IfNullGo(pExported = m_InjectedExports.Add(&sExported));        
        pExported->pClass = pClass;
        pExported->pCTI = 0;
        pExported->pCTIDefault = 0;
        pExported->tkind = TKindFromClass(pClass);
        pExported->bAutoProxy = (bAutoProxy != 0);

        // Step 1, Create the TypeInfos for the TypeDefs.
        IfFailGo(CreateITypeInfo(pExported));
    
        // Step 1a, Create the TypeInfos for the IClassX interfaces.
        IfFailGo(CreateIClassXITypeInfo(pExported));
    
        // Step 2, add the ImplTypes to the CoClasses.
        IfFailGo(ConvertImplTypes(pExported));
    
        // Step 3, fill in the TypeInfo details...
        IfFailGo(ConvertDetails(pExported));
    }
    
ErrExit:

    // Restore error reporting context.
    m_ErrorContext = SavedContext;
    
    return (hr);
} // HRESULT TypeLibExporter::ConvertOneTypeDef()

//*****************************************************************************
// Helper to wrap GetGuid in COMPLUS_TRY/COMPLUS_CATCH
//*****************************************************************************
static HRESULT SafeGetGuid(EEClass* pClass, GUID* pGUID, BOOL b) 
{
    HRESULT hr = S_OK;

    COMPLUS_TRY 
    {
        pClass->GetGuid(pGUID, b);
    } 
    COMPLUS_CATCH 
    {
        Thread *pThread = GetThread();
        int fNOTGCDisabled = pThread && !pThread->PreemptiveGCDisabled();
        if (fNOTGCDisabled)
            pThread->DisablePreemptiveGC();

        hr = SetupErrorInfo(GETTHROWABLE());

        if (fNOTGCDisabled)
            pThread->EnablePreemptiveGC();
    }
    COMPLUS_END_CATCH

    return hr;
} // static HRESULT SafeGetGuid()

//*****************************************************************************
// Create the ITypeInfo for a type.  Well, sort of.  This function will create
//  the first of possibly two typeinfos for the type.  If the type is a class
//  we will create a COCLASS typeinfo now, and an INTERFACE typeinfo later,
//  which typeinfo will be the default interface for the coclass.  If this
//  typeinfo needs to be aliased, we will create the ALIAS now (with the 
//  real name) and the aliased typeinfo later, with the real attributes, but
//  with a mangled name. 
//*****************************************************************************
HRESULT TypeLibExporter::CreateITypeInfo(
    CExportedTypesInfo *pData,          // Conversion data.
    bool        bNamespace,             // If true, use namespace + name
    bool        bResolveDup)            // If true, decorate name to resolve dups.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    
    HRESULT     hr = S_OK;              // A result.
    LPCUTF8     pName;                  // Name in UTF8.
    LPCUTF8     pNS;                    // Namespace in UTF8.
    int         iLen;                   // Length of a name.
    CQuickArray<WCHAR> rName;           // Name of the TypeDef.
    TYPEKIND    tkind;                  // The TYPEKIND of a TypeDef.
    GUID        clsid;                  // A TypeDef's clsid.
    DWORD       dwFlags;                // A TypeDef's flags.
    LPWSTR      pSuffix;                // Pointer into the name.
    int         iSuffix = 0;            // Counter for suffix.
    mdTypeDef   td;                     // Token for the class.
    VARIANT     vt;                     // For defining custom attribute.
    ICreateTypeInfo *pCTITemp=0;        // For creating a typeinfo.
    ICreateTypeInfo2 *pCTI2=0;          // For creating the typeinfo.
    ITypeInfo   *pITemp=0;              // An ITypeInfo to get a name.
    BSTR        sName=0;                // An ITypeInfo's name.
    ITypeLib    *pITLB=0;               // For dup IID reporting.
    ITypeInfo   *pITIDup=0;             // For dup IID reporting.
    BSTR        bstrDup=0;              // For dup IID reporting.
    BSTR        bstrDescr=0;            // For description.
    
    ::VariantInit(&vt);
     DefineFullyQualifiedNameForClassW();

    // Get the TypeDef and some info about it.
    td = pData->pClass->GetCl();
    pData->pClass->GetMDImport()->GetTypeDefProps(td, &dwFlags, 0);
    tkind = pData->tkind;

    // Error reporting info.
    pData->pClass->GetMDImport()->GetNameOfTypeDef(td, &m_ErrorContext.m_szName, &m_ErrorContext.m_szNamespace);
    
    pData->pCTI = 0;
    pData->pCTIDefault = 0;

    // If it is ComImport, do not export it.
    if (IsTdImport(dwFlags))
        goto ErrExit;
    
    // Check to see if the type is supposed to be visible from COM. If it
    // is not then we go to the next type.
    if (!IsTypeVisibleFromCom(TypeHandle(pData->pClass->GetMethodTable())))
        goto ErrExit;

    // Warn about exporting reference types as structs.
    if ((pData->tkind == TKIND_RECORD || pData->tkind == TKIND_UNION) && !pData->pClass->IsValueClass())
        ReportWarning(TLBX_I_REF_TYPE_AS_STRUCT, TLBX_I_REF_TYPE_AS_STRUCT);

    // Get the GUID for the class.  Will generate from name if no defined GUID,
    //  will also use signatures if interface.
    IfFailGo(SafeGetGuid(pData->pClass, &clsid, TRUE));

    // Get the name.
    pData->pClass->GetMDImport()->GetNameOfTypeDef(td, &pName, &pNS);

    // Hack for microsoft.wfc.interop.dll -- skip their IDispatch.
    if (clsid == IID_IDispatch || clsid == IID_IUnknown)
    {
        ReportEvent(NOTIF_CONVERTWARNING, TLBX_S_NOSTDINTERFACE, pName);
        goto ErrExit;
    }

    if (bNamespace)
    {
        iLen = ns::GetFullLength(pNS, pName);
        IfFailGo(rName.ReSize(iLen+2));
        VERIFY(ns::MakePath(rName.Ptr(), iLen+2, pNS, pName));
        for (LPWSTR pch=rName.Ptr(); *pch; ++pch)
            if (*pch == '.')
                *pch = '_';
    }
    else
    {   // Convert name to wide chars.
        IfFailGo(Utf2Quick(pName, rName));
    }

    // Create the typeinfo for this typedef.
    pSuffix = 0;
    for (;;)
    {   // Attempt to create the TypeDef.
        hr = m_pICreateTLB->CreateTypeInfo(rName.Ptr(), tkind, &pCTITemp);
        // If a name conflict, decorate, otherwise, done.
        if (hr != TYPE_E_NAMECONFLICT)
            break;
        if (!bResolveDup)
        {
            hr = S_FALSE;
            goto ErrExit;
        }
        if (pSuffix == 0)
        {
            IfFailGo(rName.ReSize((int)(wcslen(rName.Ptr()) + cbDuplicateDecoration)));
            pSuffix = rName.Ptr() + wcslen(rName.Ptr());
            iSuffix = 2;
        }
        _snwprintf(pSuffix, cchDuplicateDecoration, szDuplicateDecoration, iSuffix++);
    }
    IfFailPost(hr);
    IfFailPost(pCTITemp->QueryInterface(IID_ICreateTypeInfo2, (void**)&pCTI2));
    pCTITemp->Release();
    pCTITemp=0;
    
    // Set the guid.
    _ASSERTE(clsid != GUID_NULL);
    hr = pCTI2->SetGuid(clsid);
    if (FAILED(hr))
    {
        if (hr == TYPE_E_DUPLICATEID)
        {
            HRESULT hr; // local HR; don't lose value of error that got us here.
            IfFailPost(m_pICreateTLB->QueryInterface(IID_ITypeLib, (void**)&pITLB));
            IfFailPost(pITLB->GetTypeInfoOfGuid(clsid, &pITIDup));
            IfFailPost(pITIDup->GetDocumentation(MEMBERID_NIL, &bstrDup, 0,0,0));
            TlbPostError(TLBX_E_DUPLICATE_IID, rName.Ptr(), bstrDup);
        }
        goto ErrExit;
    }
    TRACE("TypeInfo %x: %ls, {%08x-%04x-%04x-%04x-%02x%02x%02x%02x}\n", pCTI2, rName.Ptr(), 
        clsid.Data1, clsid.Data2, clsid.Data3, clsid.Data4[0]<<8|clsid.Data4[1], clsid.Data4[2], clsid.Data4[3], clsid.Data4[4], clsid.Data4[5]); 

    IfFailPost(pCTI2->SetVersion(1, 0));

    // Record the fully qualified type name in a custom attribute.

    LPWSTR szName = GetFullyQualifiedNameForClassNestedAwareW(pData->pClass);
    vt.vt = VT_BSTR;
    vt.bstrVal = ::SysAllocString(szName);
    IfFailPost(pCTI2->SetCustData(GUID_ManagedName, &vt));

    // If the class is decorated with a description, apply it to the typelib.
    IfFailGo(GetDescriptionString(pData->pClass, td, bstrDescr));
    if (hr == S_OK)
        IfFailGo(pCTI2->SetDocString(bstrDescr));
    
    // Transfer ownership of the pointer.
    pData->pCTI = pCTI2;
    pCTI2 = 0;
    
    
    hr = S_OK;

ErrExit:
    ::VariantClear(&vt);

    if (pCTITemp)
        pCTITemp->Release();
    if (pITemp)
        pITemp->Release();
    if (sName)
        ::SysFreeString(sName);
    if (pITLB)
        pITLB->Release();
    if (pITIDup)
        pITIDup->Release();
    if (bstrDup)
        ::SysFreeString(bstrDup);
    if (bstrDescr)
        ::SysFreeString(bstrDescr);
    if (pCTI2)
        pCTI2->Release();
    
    // Error reporting info.
    m_ErrorContext.m_szName = m_ErrorContext.m_szNamespace = 0;
    
    return(hr);
} // HRESULT TypeLibExporter::CreateITypeInfo()

//*****************************************************************************
// See if an object has a Description, and get it as a BSTR.
//*****************************************************************************
HRESULT TypeLibExporter::GetDescriptionString(
    EEClass     *pClass,                // Class containing the token.
    mdToken     tk,                     // Token of the object.
    BSTR        &bstrDescr)             // Put description here.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    // Check for a description custom attribute.
    return GetStringCustomAttribute(pClass->GetMDImport(), XXX_DESCRIPTION_TYPE, tk, bstrDescr);

} // HRESULT TypeLibExporter::GetDescriptionString()

//*****************************************************************************
// See if an object has a custom attribute, and get it as a BSTR.
//*****************************************************************************
HRESULT TypeLibExporter::GetStringCustomAttribute(
    IMDInternalImport *pImport, 
    LPCSTR     szName, 
    mdToken     tk, 
    BSTR        &bstrDescr)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr;                     // A result.
    const void  *pvData;                // Pointer to a custom attribute data.
    ULONG       cbData;                 // Size of custom attribute data.
    
    // Look for the desired custom attribute.
    IfFailGo(pImport->GetCustomAttributeByName(tk, szName,  &pvData,&cbData));
    if (hr == S_OK && cbData > 2)
    {
        LPCUTF8 pbData = reinterpret_cast<LPCUTF8>(pvData);
        pbData += 2;
        cbData -=2;
        ULONG cbStr = 0;
        ULONG cbcb = 0;
        ULONG cch;
        cbcb = CorSigUncompressData((PCCOR_SIGNATURE)pbData, &cbStr);
        pbData += cbcb;
        cbData -= cbcb;
        IfNullGo(bstrDescr = ::SysAllocStringLen(0, cbStr+1));
        cch = WszMultiByteToWideChar(CP_UTF8,0, pbData,cbStr, bstrDescr,cbStr+1);
        bstrDescr[cch] = L'\0';
    }
    else
        hr = S_FALSE;                   // No string, so return false.
    
ErrExit:
    return hr;
} // HRESULT GetStringCustomAttribute()

//*****************************************************************************
// Get the value for AutomationProxy for an object.  Return the default
//  if there is no attribute.
//*****************************************************************************
HRESULT TypeLibExporter::GetAutomationProxyAttribute(
    IMDInternalImport *pImport, 
    mdToken     tk, 
    int         *bValue)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr;                     // A result.
    const void  *pvData;                // Pointer to a custom attribute data.
    ULONG       cbData;                 // Size of custom attribute data.
    
    IfFailGo(pImport->GetCustomAttributeByName(tk, INTEROP_AUTOPROXY_TYPE,  &pvData,&cbData));

    if (hr == S_OK && cbData > 2)
        *bValue = ((const BYTE*)pvData)[2] != 0;

ErrExit:
    return hr;        
} // HRESULT TypeLibExporter::GetAutomationProxyAttribute()

//*****************************************************************************
// Get the value for AutomationProxy for an object.  Return the default
//  if there is no attribute.
//*****************************************************************************
HRESULT TypeLibExporter::GetTypeLibVersionFromAssembly(
    Assembly    *pAssembly, 
    USHORT      *pMajorVersion,
    USHORT      *pMinorVersion)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr;                     // A result.
    const BYTE  *pbData;                // Pointer to a custom attribute data.
    ULONG       cbData;                 // Size of custom attribute data.

    // Check to see if the TypeLibVersionAttribute is set.
    IfFailGo(pAssembly->GetManifestImport()->GetCustomAttributeByName(TokenFromRid(1, mdtAssembly), INTEROP_TYPELIBVERSION_TYPE, (const void**)&pbData, &cbData));
    if (hr == S_OK && cbData >= (2 + 2 * sizeof(INT16)))
    {
        // Assert that the metadata blob is valid and of the right format.
        _ASSERTE("TypeLibVersion custom attribute does not have the right format" && (*pbData == 0x01) && (*(pbData + 1) == 0x00));

        // Skip the header describing the type of custom attribute blob.
        pbData += 2;
        cbData -= 2;

        // Retrieve the major and minor version from the attribute.
        *pMajorVersion = GET_VERSION_USHORT_FROM_INT(*((INT32*)pbData));
        *pMinorVersion = GET_VERSION_USHORT_FROM_INT(*((INT32*)pbData + 1));
    }
    else
    {
        // Use the assembly's major and minor version number.
        hr = S_OK;
        *pMajorVersion = pAssembly->m_Context->usMajorVersion;
        *pMinorVersion = pAssembly->m_Context->usMinorVersion;
    }

    // VB6 doesn't deal very well with a typelib a version of 0.0 so if that happens
    // we change it to 1.0.
    if (*pMajorVersion == 0 && *pMinorVersion == 0)
        *pMajorVersion = 1;

ErrExit:
    return hr;        
} // HRESULT TypeLibExporter::GetAutomationProxyAttribute()

//*****************************************************************************
// Create the IClassX ITypeInfo.
//*****************************************************************************
HRESULT TypeLibExporter::CreateIClassXITypeInfo(
    CExportedTypesInfo *pData,          // Conversion data.
    bool        bNamespace,             // If true, use namespace + name
    bool        bResolveDup)            // If true, decorate name to resolve dups.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    LPCUTF8     pName;                  // Name in UTF8.
    LPCUTF8     pNS;                    // Namespace in UTF8.
    int         iLen;                   // Length of a name.
    CQuickArray<WCHAR> rName;           // Name of the TypeDef.
    CQuickArray<WCHAR> rNameTypeInfo;   // Name of the IClassX.
    TYPEKIND    tkind;                  // The TYPEKIND of a TypeDef.
    GUID        clsid;                  // A TypeDef's clsid.
    DWORD       dwFlags;                // A TypeDef's flags.
    LPWSTR      pSuffix;                // Pointer into the name.
    int         iSuffix = 0;            // Counter for suffix.
    GUID        guid = {0};             // A default interface's IID.
    HREFTYPE    href;                   // href of base interface of IClassX.
    mdTypeDef   td;                     // Token for the class.
    VARIANT     vt;                     // For defining custom attribute.
    ICreateTypeInfo *pCTITemp=0;        // For creating a typeinfo.
    ICreateTypeInfo2 *pCTI2=0;          // For creating the typeinfo.
    ITypeInfo   *pITemp=0;              // An ITypeInfo to get a name.
    BSTR        sName=0;                // An ITypeInfo's name.
    ITypeLib    *pITLB=0;               // For dup IID reporting.
    ITypeInfo   *pITIDup=0;             // For dup IID reporting.
    BSTR        bstrDup=0;              // For dup IID reporting.
    BSTR        bstrDescr=0;            // For description.

    ::VariantInit(&vt);
        
    EEClass* pClassOuter = pData->pClass;

    DefineFullyQualifiedNameForClassW();
        
    // Get the TypeDef and some info about it.
    td = pData->pClass->GetCl();
    pData->pClass->GetMDImport()->GetTypeDefProps(td, &dwFlags, 0);
    tkind = pData->tkind;

    // Error reporting info.
    pData->pClass->GetMDImport()->GetNameOfTypeDef(td, &m_ErrorContext.m_szName, &m_ErrorContext.m_szNamespace);
    
    // A CoClass needs an IClassX, and an alias kind needs an alias.
    if (tkind != TKIND_COCLASS)
        goto ErrExit;

    // Check to see if the type is supposed to be visible from COM. If it
    // is not then we go to the next type.
    if (!IsTypeVisibleFromCom(TypeHandle(pClassOuter->GetMethodTable())))
        goto ErrExit;

    // Imported types don't need an IClassX.
    if (IsTdImport(dwFlags))
        goto ErrExit;

    // Check to see if we need to set up an IClassX for the class.
    if (ClassHasIClassX(pData->pClass) == CLASS_AUTO_NONE)
        goto ErrExit;

    // Get full name from metadata.
    pData->pClass->GetMDImport()->GetNameOfTypeDef(td, &pName, &pNS);

    // Get the GUID for the class.  Used to generate IClassX guid.
    hr = SafeGetGuid(pData->pClass, &clsid, TRUE);
    IfFailGo(hr);

    // Get the name of the class.  Use the ITypeInfo if there is one, except don't 
    //  use the typeinfo for types which are Aliased.
    if (pData->pCTI)
    {
        IfFailPost(pData->pCTI->QueryInterface(IID_ITypeInfo, (void**)&pITemp));
        IfFailPost(pITemp->GetDocumentation(MEMBERID_NIL, &sName, 0,0,0));
        pITemp->Release();
        pITemp=0;
        IfFailGo(rName.ReSize((int)wcslen(sName) +1 ));
        wcscpy(rName.Ptr(), sName);
    }
    else
    {   // No ITypeInfo, get from metadata.
        if (bNamespace)
        {
            iLen = ns::GetFullLength(pNS, pName);
            IfFailGo(rName.ReSize(iLen+2));
            VERIFY(ns::MakePath(rName.Ptr(), iLen+2, pNS, pName));
            for (LPWSTR pch=rName.Ptr(); *pch; ++pch)
                if (*pch == '.')
                    *pch = '_';
        }
        else
        {   // Convert name to wide chars.
            IfFailGo(Utf2Quick(pName, rName));
        }
    }

    // Create the typeinfo name for the IClassX
    IfFailGo(rNameTypeInfo.ReSize((int)(rName.Size() + cbIClassX + cbDuplicateDecoration)));
    _snwprintf(rNameTypeInfo.Ptr(), rNameTypeInfo.MaxSize(), szIClassX, rName.Ptr());
    tkind = TKIND_INTERFACE;
    pSuffix = 0;
    for (;;)
    {   // Try to create the TypeInfo.
        hr = m_pICreateTLB->CreateTypeInfo(rNameTypeInfo.Ptr(), tkind, &pCTITemp);
        // If a name conflict, decorate, otherwise, done.
        if (hr != TYPE_E_NAMECONFLICT)
            break;
        if (!bResolveDup)
        {
            hr = S_FALSE;
            goto ErrExit;
        }
        if (pSuffix == 0)
            pSuffix = rNameTypeInfo.Ptr() + wcslen(rNameTypeInfo.Ptr()), iSuffix = 2;
        _snwprintf(pSuffix, cchDuplicateDecoration, szDuplicateDecoration, iSuffix++);
    }
    IfFailPost(hr);
    IfFailPost(pCTITemp->QueryInterface(IID_ICreateTypeInfo2, (void**)&pCTI2));
    pCTITemp->Release();
    pCTITemp=0;
    
    // Generate the "IClassX" UUID and set it.
    IfFailGo(TryGenerateClassItfGuid(TypeHandle(pData->pClass), &guid));
    hr = pCTI2->SetGuid(guid);
    if (FAILED(hr))
    {
        if (hr == TYPE_E_DUPLICATEID)
        {
            HRESULT hr; // local HR; don't lose value of error that got us here.
            IfFailPost(m_pICreateTLB->QueryInterface(IID_ITypeLib, (void**)&pITLB));
            IfFailPost(pITLB->GetTypeInfoOfGuid(guid, &pITIDup));
            IfFailPost(pITIDup->GetDocumentation(MEMBERID_NIL, &bstrDup, 0,0,0));
            TlbPostError(TLBX_E_DUPLICATE_IID, rNameTypeInfo.Ptr(), bstrDup);
        }
        goto ErrExit;
    }

    // Adding methods may cause an href to this typeinfo, which will cause it to be layed out.
    //  Set the inheritance, so that nesting will be correct when that layout happens.
    // Add IDispatch as impltype 0.
    IfFailGo(GetRefTypeInfo(pCTI2, m_pIDispatch, &href));
    IfFailPost(pCTI2->AddImplType(0, href));

    // Record the fully qualified type name in a custom attribute.
    LPWSTR szName = GetFullyQualifiedNameForClassNestedAwareW(pData->pClass);
    vt.vt = VT_BSTR;
    vt.bstrVal = ::SysAllocString(szName);
    IfFailPost(pCTI2->SetCustData(GUID_ManagedName, &vt));

    TRACE("IClassX  %x: %ls, {%08x-%04x-%04x-%04x-%02x%02x%02x%02x}\n", pCTI2, rName.Ptr(), 
        guid.Data1, guid.Data2, guid.Data3, guid.Data4[0]<<8|guid.Data4[1], guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5]); 

    // If the class is decorated with a description, apply it to the typelib.
    IfFailGo(GetDescriptionString(pData->pClass, td, bstrDescr));
    if (hr == S_OK)
        IfFailGo(pCTI2->SetDocString(bstrDescr));
    
    // Transfer ownership of the pointer.
    _ASSERTE(pData->pCTIDefault == 0);
    pData->pCTIDefault = pCTI2;
    pCTI2 = 0;
    
    hr = S_OK;

ErrExit:
    ::VariantClear(&vt);

    if (pCTITemp)
        pCTITemp->Release();
    if (pITemp)
        pITemp->Release();
    if (sName)
        ::SysFreeString(sName);
    if (bstrDescr)
        ::SysFreeString(bstrDescr);
    if (pITLB)
        pITLB->Release();
    if (pITIDup)
        pITIDup->Release();
    if (bstrDup)
        ::SysFreeString(bstrDup);
    if (pCTI2)
        pCTI2->Release();

    // Error reporting info.
    m_ErrorContext.m_szName = m_ErrorContext.m_szNamespace = 0;
    
    return(hr);
} // HRESULT TypeLibExporter::CreateIClassXITypeInfo()

//*****************************************************************************
// Add the impltypes to an ITypeInfo.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertImplTypes(
    CExportedTypesInfo *pData)          // Conversion data.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    DWORD       dwFlags;                // A TypeDef's flags.
    mdTypeDef   td;                     // Token for the class.

    // Get the TypeDef and some info about it.
    td = pData->pClass->GetCl();
    pData->pClass->GetMDImport()->GetTypeDefProps(td, &dwFlags, 0);

    // Error reporting info.
    pData->pClass->GetMDImport()->GetNameOfTypeDef(td, &m_ErrorContext.m_szName, &m_ErrorContext.m_szNamespace);
    
    // If there is no ITypeInfo, skip it.
    if(pData->pCTI == 0)
        goto ErrExit;

    // Check to see if the type is supposed to be visible from COM. If it
    // is not then we go to the next type.
    if(!IsTypeVisibleFromCom(TypeHandle(pData->pClass->GetMethodTable())))
        goto ErrExit;

    // Add the ImplTypes to the CoClass.
    switch(pData->tkind)
    {
    case TKIND_INTERFACE:
    case TKIND_DISPATCH:
        // Add the base type to the interface.
        IfFailGo(ConvertInterfaceImplTypes(pData->pCTI, pData->pClass));
        break;
    case TKIND_RECORD:
    case TKIND_UNION:
    case TKIND_ENUM:
        // Nothing to do at this step.
        break;
    case TKIND_COCLASS:
        // Add the ImplTypes to the CoClass.
        IfFailGo(ConvertClassImplTypes(pData->pCTI, pData->pCTIDefault, pData->pClass));
        break;
    default:
        _ASSERTE(!"Unknown TYPEKIND");
        IfFailPost(E_INVALIDARG);
        break;
    }

ErrExit:

    // Error reporting info.
    m_ErrorContext.m_szName = m_ErrorContext.m_szNamespace = 0;
    
    return (hr);
} // HRESULT TypeLibExporter::ConvertImplTypes()

//*****************************************************************************
// Convert the details (members) of an ITypeInfo.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertDetails(
    CExportedTypesInfo *pData)          // Conversion data.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    DWORD       dwFlags;                // A TypeDef's flags.
    mdTypeDef   td;                     // Token for the class.

    // Get the TypeDef and some info about it.
    td = pData->pClass->GetCl();
    pData->pClass->GetMDImport()->GetTypeDefProps(td, &dwFlags, 0);

    // Error reporting info.
    pData->pClass->GetMDImport()->GetNameOfTypeDef(td, &m_ErrorContext.m_szName, &m_ErrorContext.m_szNamespace);
    
    // If there is no TypeInfo, skip it, but for CoClass need to populate IClassX.
    if(pData->pCTI == 0 && pData->tkind != TKIND_COCLASS)
        goto ErrExit;

    // Check to see if the type is supposed to be visible from COM. If it
    // is not then we go to the next type.
    if(!IsTypeVisibleFromCom(TypeHandle(pData->pClass->GetMethodTable())))
        goto ErrExit;

    // Fill in the rest of the typeinfo for this typedef.
    switch(pData->tkind)
    {
    case TKIND_INTERFACE:
    case TKIND_DISPATCH:
        IfFailGo(ConvertInterfaceDetails(pData->pCTI, pData->pClass, pData->bAutoProxy));
        break;
    case TKIND_RECORD:
    case TKIND_UNION:
        IfFailGo(ConvertRecord(pData));
        break;
    case TKIND_ENUM:
        IfFailGo(ConvertEnum(pData->pCTI, pData->pCTIDefault, pData->pClass));
        break;
    case TKIND_COCLASS:
        // Populate the methods on the IClassX interface.
        IfFailGo(ConvertClassDetails(pData->pCTI, pData->pCTIDefault, pData->pClass, pData->bAutoProxy));
        break;
    default:
        _ASSERTE(!"Unknown TYPEKIND");
        IfFailPost(E_INVALIDARG);
        break;
    } // Switch (tkind)

    hr = S_OK;

    // Report that this type has been converted.
    ReportEvent(NOTIF_TYPECONVERTED, TLBX_I_TYPE_EXPORTED, m_ErrorContext.m_szName);
    
ErrExit:

    // Error reporting info.
    m_ErrorContext.m_szName = m_ErrorContext.m_szNamespace = 0;
    
    return (hr);
} // HRESULT TypeLibExporter::ConvertDetails()

//*****************************************************************************
// Add the ImplTypes to the TypeInfo.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertInterfaceImplTypes(
    ICreateTypeInfo2 *pThisTypeInfo,    // The typeinfo being created.
    EEClass     *pClass)                // EEClass for the TypeInfo.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;
    ULONG       ulIface;                // Is this interface [dual]?
    HREFTYPE    href;                   // href of base interface.

    // IDispatch or IUnknown derived?
    IfFailGo(pClass->GetMDImport()->GetIfaceTypeOfTypeDef(pClass->GetCl(), &ulIface));

    // Parent interface.
    if (ulIface != ifVtable)
    {   // Get the HREFTYPE for IDispatch.
        IfFailGo(GetRefTypeInfo(pThisTypeInfo, m_pIDispatch, &href));
    }
    else
    {   // Get the HREFTYPE for IUnknown.
        IfFailGo(GetRefTypeInfo(pThisTypeInfo, m_pIUnknown, &href));
    }

    // Add the HREF as an interface.
    IfFailPost(pThisTypeInfo->AddImplType(0, href));

ErrExit:
    return (hr);
} // HRESULT TypeLibExporter::ConvertInterfaceImplTypes()

//*****************************************************************************
// Helper function to initialize the member info map.
//*****************************************************************************
HRESULT TypeLibExporter::InitMemberInfoMap(ComMTMemberInfoMap *pMemberMap)
{
    HRESULT hr = S_OK;

    COMPLUS_TRY
    {
        pMemberMap->Init();
    }
    COMPLUS_CATCH
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SetupErrorInfo(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH

    return hr;
} // HRESULT TypeLibExporter::InitMemberInfoMap()

//*****************************************************************************
// Create the TypeInfo for an interface by iterating over functions.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertInterfaceDetails (
    ICreateTypeInfo2 *pThisTypeInfo,    // The typeinfo being created.
    EEClass     *pClass,                // EEClass for the TypeInfo.
    int         bAutoProxy)             // If true, oleaut32 is the interface's marshaller.
{
    HRESULT     hr = S_OK;
    ULONG       iMD;                    // Loop control.
    ULONG       ulIface;                // Is this interface [dual]?
    DWORD       dwTIFlags=0;            // TypeLib flags.
    int         cVisibleMembers = 0;    // The count of methods that are visible to COM.

    CANNOTTHROWCOMPLUSEXCEPTION();

    // Retrieve the map of members.
    ComMTMemberInfoMap MemberMap(pClass->GetMethodTable());

    // IDispatch or IUnknown derived?
    IfFailGo(pClass->GetMDImport()->GetIfaceTypeOfTypeDef(pClass->GetCl(), &ulIface));
    if (ulIface != ifVtable)
    {   // IDispatch derived.
        dwTIFlags |= TYPEFLAG_FDISPATCHABLE;
        if (ulIface == ifDual)
            dwTIFlags |= TYPEFLAG_FDUAL | TYPEFLAG_FOLEAUTOMATION;
        else
            _ASSERTE(ulIface == ifDispatch);
    }
    else
    {   // IUnknown derived.
        dwTIFlags |= TYPEFLAG_FOLEAUTOMATION;
    }
    if (!bAutoProxy)
        dwTIFlags |= TYPEFLAG_FPROXY;

    // Set appropriate flags.
    IfFailPost(pThisTypeInfo->SetTypeFlags(dwTIFlags));

    // Retrieve the method properties.
    IfFailGo(InitMemberInfoMap(&MemberMap));
    if (MemberMap.HadDuplicateDispIds())
        ReportWarning(TLBX_I_DUPLICATE_DISPID, TLBX_I_DUPLICATE_DISPID);

    // We need a scope to bypass the inialization skipped by goto ErrExit 
    // compiler error.
    {
        CQuickArray<ComMTMethodProps> &rProps = MemberMap.GetMethods();

        // Now add the methods to the TypeInfo.
        for (iMD=0; iMD<pClass->GetNumVtableSlots(); ++iMD)
        {
            // Only convert the method if it is visible from COM.
            if (rProps[iMD].bMemberVisible)
            {
                if (FAILED(hr = ConvertMethod(pThisTypeInfo, &rProps[iMD], cVisibleMembers, ulIface)))
                {
                    // Bad signature has already been reported as warning, and can now be ignored.  Anything else is fatal.
                    if (hr == TLBX_E_BAD_SIGNATURE)
                        hr = S_OK;
                    else
                        IfFailGo(hr);
                }
                else
                    cVisibleMembers++;
            }
        }
    }

ErrExit:
    return (hr);
} // HRESULT TypeLibExporter::ConvertInterfaceDetails()

//*****************************************************************************
// Export a Record to a TypeLib.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertRecordBaseClass(
    CExportedTypesInfo *pData,          // Conversion data.
    EEClass     *pSubClass,             // The base class.
    ULONG       &ixVar)                 // Variable index in the typelib.
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    
    ICreateTypeInfo2 *pThisTypeInfo=pData->pCTI;     // The typeinfo being created.

    HRESULT     hr = S_OK;              // A result.
    HENUMInternal eFDi;                 // To enum fields.
    mdFieldDef  fd;                     // A Field def.
    ULONG       iFD;                    // Loop control.
    ULONG       cFD;                    // Count of total MemberDefs.
    DWORD       dwFlags;                // Field flags.
    LPCUTF8     szName;                 // Name in UTF8.
    LPCUTF8     szNamespace;            // A Namespace in UTF8.
    CQuickArray<WCHAR> rName;           // Name in Unicode.
    int         cchPrefix=0;            // Length of name prefix.

    // If there is no class here, or if the class is Object, don't add members.
    if (pSubClass == 0 ||
        GetAppDomain()->IsSpecialObjectClass(pSubClass->GetMethodTable()) ||
        pSubClass->GetMethodTable() == g_pObjectClass) 
        return S_OK;

    // If this class has a base class, export those members first.
    IfFailGo(ConvertRecordBaseClass(pData, pSubClass->GetParentClass(), ixVar));

    // Build the member name prefix.
    pSubClass->GetMDImport()->GetNameOfTypeDef(pSubClass->GetCl(), &szName, &szNamespace);
    IfFailGo(Utf2Quick(szName, rName));
    IfFailGo(rName.ReSize((int)(wcslen(rName.Ptr()) + 2)));
    wcscat(rName.Ptr(), L"_");
    cchPrefix = (int)wcslen(rName.Ptr());
    
    // Get an enumerator for the MemberDefs in the TypeDef.
    IfFailGo(pSubClass->GetMDImport()->EnumInit(mdtFieldDef, pSubClass->GetCl(), &eFDi));
    cFD = pSubClass->GetMDImport()->EnumGetCount(&eFDi);

    // For each MemberDef...
    for (iFD=0; iFD<cFD; ++iFD)
    {
        // Get the next field.
        if (!pSubClass->GetMDImport()->EnumNext(&eFDi, &fd))
            IfFailGo(E_UNEXPECTED);

        dwFlags = pSubClass->GetMDImport()->GetFieldDefProps(fd);
        // Only non-static fields.
        if (!IsFdStatic(dwFlags))
        {
            szName = pSubClass->GetMDImport()->GetNameOfFieldDef(fd);
            IfFailGo(Utf2Quick(szName, rName, cchPrefix));
            if (FAILED(hr = ConvertVariable(pThisTypeInfo, pSubClass, fd, rName.Ptr(), ixVar)))
            {
                // Bad signature has already been reported as warning, and can now be ignored.  Anything else is fatal.
                if (hr == TLBX_E_BAD_SIGNATURE)
                    hr = S_OK;
                else
                    IfFailGo(hr);
            }
            else
                ixVar++;
        }
    }

ErrExit:
    pSubClass->GetMDImport()->EnumClose(&eFDi);

    return (hr);
} // HRESULT TypeLibExporter::ConvertRecordBaseClass()

HRESULT TypeLibExporter::ConvertRecord(
    CExportedTypesInfo *pData)          // Conversion data.
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    
    ICreateTypeInfo2 *pThisTypeInfo=pData->pCTI;     // The typeinfo being created.
    EEClass     *pClass=pData->pClass;               // EEClass for the TypeInfo.

    HRESULT     hr = S_OK;              // A result.
    HENUMInternal eFDi;                 // To enum fields.
    mdFieldDef  fd;                     // A Field def.
    ULONG       iFD;                    // Loop control.
    ULONG       ixVar=0;                // Index of current var converted.
    ULONG       cFD;                    // Count of total MemberDefs.
    DWORD       dwFlags;                // Field flags.
    DWORD       dwPack;                 // Class pack size.
    mdToken     tkExtends;              // A class's parent.
    LPCUTF8     szName;                 // Name in UTF8.
    CQuickArray<WCHAR> rName;           // Name in Unicode.

    // If the type is a struct, but it has explicit layout, don't export the members, 
    //  because we can't export them accurately (unless they're really sequential).
    if (pData->tkind == TKIND_RECORD)
    {
        pClass->GetMDImport()->GetTypeDefProps(pClass->GetCl(), &dwFlags, &tkExtends);
        if (IsTdExplicitLayout(dwFlags))
        {
            ReportWarning(S_OK, TLBX_I_NONSEQUENTIALSTRUCT);
            goto ErrExit;
        }
    }

    // Set the packing size, if there is one.
    dwPack = 0;
    pClass->GetMDImport()->GetClassPackSize(pClass->GetCl(), &dwPack);
    if (!dwPack)
        dwPack = DEFAULT_PACKING_SIZE;
    IfFailGo(pThisTypeInfo->SetAlignment((USHORT)dwPack));

    // Haven't seen any non-public members yet.
    m_bWarnedOfNonPublic = FALSE;

    // If this class has a base class, export those members first.
    IfFailGo(ConvertRecordBaseClass(pData, pClass->GetParentClass(), ixVar));

    // Get an enumerator for the MemberDefs in the TypeDef.
    IfFailGo(pClass->GetMDImport()->EnumInit(mdtFieldDef, pClass->GetCl(), &eFDi));
    cFD = pClass->GetMDImport()->EnumGetCount(&eFDi);

    // For each MemberDef...
    for (iFD=0; iFD<cFD; ++iFD)
    {
        // Get the next field.
        if (!pClass->GetMDImport()->EnumNext(&eFDi, &fd))
            IfFailGo(E_UNEXPECTED);

        dwFlags = pClass->GetMDImport()->GetFieldDefProps(fd);
        // Skip static fields.
        if (IsFdStatic(dwFlags) == 0)
        {
            szName = pClass->GetMDImport()->GetNameOfFieldDef(fd);
            IfFailGo(Utf2Quick(szName, rName));
            if (FAILED(hr = ConvertVariable(pThisTypeInfo, pClass, fd, rName.Ptr(), ixVar)))
            {
                // Bad signature has already been reported as warning, and can now be ignored.  Anything else is fatal.
                if (hr == TLBX_E_BAD_SIGNATURE)
                    hr = S_OK;
                else
                    IfFailGo(hr);
            }
            else
                ixVar++;
        }
    }

ErrExit:
    pClass->GetMDImport()->EnumClose(&eFDi);

    return (hr);
} // HRESULT TypeLibExporter::ConvertRecord()

//*****************************************************************************
// Export an Enum to a typelib.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertEnum(
    ICreateTypeInfo2 *pThisTypeInfo,    // The typeinfo being created.
    ICreateTypeInfo2 *pDefault,         // The default typeinfo being created.
    EEClass     *pClass)                // EEClass for the TypeInfo.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    HENUMInternal eFDi;                 // To enum fields.
    mdFieldDef  fd;                     // A Field def.
    DWORD       dwTIFlags=0;            // TypeLib flags.
    ULONG       dwFlags;                // A field's flags.
    ULONG       iFD;                    // Loop control.
    ULONG       cFD;                    // Count of total MemberDefs.
    ULONG       iVar=0;                 // Count of vars actually converted.
    ITypeInfo   *pThisTI=0;             // TypeInfo for this ICreateITypeInfo.
    BSTR        szThisTypeInfo=0;       // Name of this ITypeInfo.
    LPCUTF8     szName;                 // Name in UTF8.
    CQuickArray<WCHAR> rName;           // Name in Unicode.
    int         cchPrefix=0;            // Length of name prefix.

    // Explicitly set the flags.
    IfFailPost(pThisTypeInfo->SetTypeFlags(dwTIFlags));

    // Get an enumerator for the MemberDefs in the TypeDef.
    IfFailGo(pClass->GetMDImport()->EnumInit(mdtFieldDef, pClass->GetCl(), &eFDi));
    cFD = pClass->GetMDImport()->EnumGetCount(&eFDi);

    // Build the member name prefix.  If generating an enum, get the real name from the default interface.
    IfFailPost(pThisTypeInfo->QueryInterface(IID_ITypeInfo, (void**)&pThisTI));
    IfFailPost(pThisTI->GetDocumentation(MEMBERID_NIL, &szThisTypeInfo, 0,0,0));
    IfFailGo(rName.ReSize((int)(wcslen(szThisTypeInfo) + 2)));
    wcscpy(rName.Ptr(), szThisTypeInfo);
    wcscat(rName.Ptr(), L"_");
    cchPrefix = (int)wcslen(rName.Ptr());
    
    // For each MemberDef...
    for (iFD=0; iFD<cFD; ++iFD)
    {
        // Get the next field.
        if (!pClass->GetMDImport()->EnumNext(&eFDi, &fd))
            IfFailGo(E_UNEXPECTED);

        // Only convert static fields.
        dwFlags = pClass->GetMDImport()->GetFieldDefProps(fd);
        if (IsFdStatic(dwFlags) == 0)
            continue;

        szName = pClass->GetMDImport()->GetNameOfFieldDef(fd);
        IfFailGo(Utf2Quick(szName, rName, cchPrefix));

        if (FAILED(hr = ConvertEnumMember(pThisTypeInfo, pClass, fd, rName.Ptr(), iVar)))
        {
            // Bad signature has already been reported as warning, and can now be ignored.  Anything else is fatal.
            if (hr == TLBX_E_BAD_SIGNATURE)
                hr = S_OK;
            else
                IfFailGo(hr);
        }
        else
            iVar++;
    }

ErrExit:
    if (pThisTI)
        pThisTI->Release();
    if (szThisTypeInfo)
        ::SysFreeString(szThisTypeInfo);

    pClass->GetMDImport()->EnumClose(&eFDi);

    return (hr);
} // HRESULT TypeLibExporter::ConvertEnum()

//*****************************************************************************
// Does a class have a default ctor?
//*****************************************************************************
BOOL TypeLibExporter::HasDefaultCtor(
    EEClass     *pClass)                // The class in question.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr;                     // A result.
    mdMethodDef md;                     // A method of the type.
    DWORD       dwFlags;                // Method's flags.
    HENUMInternal eMDi;                 // To enum methods.
    ULONG       cMD;                    // Count of returned tokens.
    ULONG       iMD;                    // Loop control.
    PCCOR_SIGNATURE pSig;               // The signature.
    ULONG       ixSig;                  // Index into signature.
    ULONG       cbSig;                  // Size of the signature.
    ULONG       callconv;               // Method's calling convention.
    ULONG       cParams;                // Method's count of parameters.
    BOOL        rslt=FALSE;             // Was one found?
    LPCUTF8     pName;                  // Method name.

    // Get an enumerator for the MemberDefs in the TypeDef.
    IfFailGo(pClass->GetMDImport()->EnumInit(mdtMethodDef, pClass->GetCl(), &eMDi));
    cMD = pClass->GetMDImport()->EnumGetCount(&eMDi);

    // For each MemberDef...
    for (iMD=0; iMD<cMD; ++iMD)
    {
        // Get the next field.
        if (!pClass->GetMDImport()->EnumNext(&eMDi, &md))
            IfFailGo(E_UNEXPECTED);

        // Is the name special?  Is the method public?
        dwFlags = pClass->GetMDImport()->GetMethodDefProps(md);
        if (!IsMdRTSpecialName(dwFlags) || !IsMdPublic(dwFlags))
            continue;
        
        // Yes, is the name a ctor?
        pName = pClass->GetMDImport()->GetNameOfMethodDef(md);
        if (!IsMdInstanceInitializer(dwFlags, pName))
            continue;
        
        // It is a ctor.  Is it a default ctor?
        pSig = pClass->GetMDImport()->GetSigOfMethodDef(md, &cbSig);
        
        // Skip the calling convention, and get the param count.
        ixSig = CorSigUncompressData(pSig, &callconv);
        CorSigUncompressData(&pSig[ixSig], &cParams);
        // Default ctor has zero params.
        if (cParams == 0)
        {
            rslt = TRUE;
            break;
        }
    }

ErrExit:
    
    pClass->GetMDImport()->EnumClose(&eMDi);
    
    return rslt;
} // BOOL TypeLibExporter::HasDefaultCtor()

//*****************************************************************************
// Export a class to a TypeLib.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertClassImplTypes(
    ICreateTypeInfo2 *pThisTypeInfo,    // The typeinfo being created.
    ICreateTypeInfo2 *pDefaultTypeInfo, // The ICLassX for the TypeInfo.
    EEClass     *pClass)                // EEClass for the TypeInfo.
{
    HRESULT     hr = S_OK;
    HREFTYPE    href;                   // HREF to a TypeInfo.
    DWORD       dwFlags;                // Metadata flags.
    int         flags=0;                // Flags for the interface impl or CoClass.
    UINT        ix;                     // Loop control.
    UINT        iImpl=0;                // Current Impl index.
    UINT        cInterfaces;            // Count of interfaces on a class.
    MethodTable *mt;                    // MethodTable on the EEClass.
    InterfaceInfo_t *pIfaces;           // Interfaces from the MethodTable.
    ITypeInfo   *pTI=0;                 // TypeInfo for default dispinterface.
    ICreateTypeInfo2 *pCTI2 = NULL;     // The ICreateTypeInfo2 interface used to define custom data.
    EEClass     *pIDefault = 0;         // Default interface, if any.
    MethodTable *pDefItfMT = 0;         // Default interface method table, if any.
    CQuickArray<MethodTable *> SrcItfList; // List of event sources.
    DefaultInterfaceType DefItfType;
    TypeHandle hndDefItfClass;

    // We should never be converting the class impl types of COM imported CoClasses.
    _ASSERTE(!pClass->IsComImport());
    
        
    if (pThisTypeInfo)
    {   
        pClass->GetMDImport()->GetTypeDefProps(pClass->GetCl(), &dwFlags, 0);
        
        // If abstract class, or no default ctor, don't make it creatable.
        if (!IsTdAbstract(dwFlags) && HasDefaultCtor(pClass))
            flags |= TYPEFLAG_FCANCREATE;
        
        // PreDeclid as appropriate.
        IfFailPost(pThisTypeInfo->SetTypeFlags(flags));

#ifdef ENABLE_MTS_SUPPORT
        // Set the custom data to indicate that this component is transactable.
        hr = pThisTypeInfo->QueryInterface(IID_ICreateTypeInfo22, (void**)&pCTI2);
        if (SUCCEEDED(hr))
        {
            VARIANT Var;
            Var.vt = VT_I4;
            Var.intVal = 0;
            IfFailPost(pCTI2->SetCustData(GUID_TRANS_SUPPORTED, &Var)); 
        }
#endif
    }    


    // Retrieve the EEClass that represents the default interface.
    IfFailPost(TryGetDefaultInterfaceForClass(TypeHandle(pClass->GetMethodTable()), &hndDefItfClass, &DefItfType));
    if (DefItfType == DefaultInterfaceType_AutoDual || DefItfType == DefaultInterfaceType_Explicit)
    {
        // Remember the EEClass of the default interface.
        pIDefault = hndDefItfClass.GetClass();
    }
    else if (DefItfType == DefaultInterfaceType_AutoDispatch && !pDefaultTypeInfo)
    {
        // Set IDispatch as the default interface.
        IfFailGo(GetRefTypeInfo(pThisTypeInfo, m_pIDispatch, &href));
        IfFailPost(pThisTypeInfo->AddImplType(iImpl, href));
        IfFailPost(pThisTypeInfo->SetImplTypeFlags(iImpl, IMPLTYPEFLAG_FDEFAULT));
        iImpl++;
    }

    // For some classes we synthesize an IClassX.  We don't do that for 
    // configured class, classes imported from COM, 
    // or for classes with an explicit default interface.
    if (1)
    {
        if (pDefaultTypeInfo)
        {   
            // Set the interface as the default for the class.
            IfFailPost(pDefaultTypeInfo->QueryInterface(IID_ITypeInfo, (void**)&pTI));
            IfFailGo(GetRefTypeInfo(pThisTypeInfo, pTI, &href));
            pTI->Release();
            pTI = 0;
            IfFailPost(pThisTypeInfo->AddImplType(iImpl, href));
            IfFailPost(pThisTypeInfo->SetImplTypeFlags(iImpl, IMPLTYPEFLAG_FDEFAULT));
            ++iImpl;
        }

        // Go up the class hierarchy and add the IClassX's of the parent classes 
        // as interfaces implemented by the COM component.
        EEClass *pParentClass = pClass->GetParentComPlusClass();
        while (pParentClass)
        {
            // If the parent class has an IClassX interface then add it.
            if (ClassHasIClassX(pParentClass) == CLASS_AUTO_DUAL)
            {
                IfFailGo(EEClassToHref(pThisTypeInfo, pParentClass, FALSE, &href));

                // If not IUnknown, add the HREF as an interface.
                if (hr != S_USEIUNKNOWN)
                {
                    IfFailPost(pThisTypeInfo->AddImplType(iImpl, href));
                    if (pParentClass == pIDefault)
                        IfFailPost(pThisTypeInfo->SetImplTypeFlags(iImpl, IMPLTYPEFLAG_FDEFAULT));
                    ++iImpl;
                }
            }

            // Process the next class up the hierarchy.
            pParentClass = pParentClass->GetParentComPlusClass();
        }
    }

    // Add the rest of the interfaces.
    mt = pClass->GetMethodTable();
    
    pIfaces = mt->GetInterfaceMap();
    cInterfaces = mt->GetNumInterfaces();

    ComCallWrapperTemplate *pClassTemplate = ComCallWrapperTemplate::GetTemplate(pClass->GetMethodTable());

    for (ix=0; ix<cInterfaces; ++ix)
    {
        flags = 0;
        
        // Get the EEClass for an implemented interface.
        EEClass *pIClass = pIfaces[ix].m_pMethodTable->GetClass();
        
        // Retrieve the ComMethodTable for the interface.
        ComMethodTable *pItfComMT = pClassTemplate->GetComMTForItf(pIfaces[ix].m_pMethodTable);

        // If the interface is visible from COM, add it.
        if (IsTypeVisibleFromCom(TypeHandle(pIClass->GetMethodTable())) && !pItfComMT->IsComClassItf())
        {
#if defined(_DEBUG)
            TRACE("Class %s implements %s\n", pClass->m_szDebugClassName, pIClass->m_szDebugClassName);
#endif
            // Get an href for the EEClass.
            IfFailGo(EEClassToHref(pThisTypeInfo, pIClass, FALSE, &href));
            
            // If not IUnknown, add the HREF as an interface.
            if (hr != S_USEIUNKNOWN)
            {
                if (pIClass == pIDefault)
                    flags |= IMPLTYPEFLAG_FDEFAULT;

                IfFailPost(pThisTypeInfo->AddImplType(iImpl, href));
                IfFailPost(pThisTypeInfo->SetImplTypeFlags(iImpl, flags));
                ++iImpl;
            }
        }
    }
    
    // Retrieve the list of COM source interfaces for the managed class.
    IfFailGo(TryGetComSourceInterfacesForClass(pClass->GetMethodTable(), SrcItfList));
        
    // Add all the source interfaces to the CoClass.
    flags = IMPLTYPEFLAG_FSOURCE | IMPLTYPEFLAG_FDEFAULT;
    for (UINT i = 0; i < SrcItfList.Size(); i++)
    {
        IfFailGo(EEClassToHref(pThisTypeInfo, SrcItfList[i]->GetClass(), FALSE, &href));

        // If not IUnknown, add the HREF as an interface.
        if (hr != S_USEIUNKNOWN)
        {
            IfFailPost(pThisTypeInfo->AddImplType(iImpl, href));
            IfFailPost(pThisTypeInfo->SetImplTypeFlags(iImpl, flags));
            ++iImpl;
            flags = IMPLTYPEFLAG_FSOURCE;
        }
    }
        
ErrExit:
    if (pTI)
        pTI->Release();
    if (pCTI2)
        pCTI2->Release();

    return (hr);
} // HRESULT TypeLibExporter::ConvertClassImplTypes()

//*****************************************************************************
// Export a class to a TypeLib.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertClassDetails(
    ICreateTypeInfo2 *pThisTypeInfo,    // The typeinfo being created.
    ICreateTypeInfo2 *pDefaultTypeInfo, // The ICLassX for the TypeInfo.
    EEClass     *pClass,                // EEClass for the TypeInfo.
    int         bAutoProxy)             // If true, oleaut32 is the proxy.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;
    
    
    if (ClassHasIClassX(pClass) == CLASS_AUTO_DUAL)
    {
        // Set up the IClassX interface.
        IfFailGo(ConvertIClassX(pDefaultTypeInfo, pClass, bAutoProxy));
    }
    else
    if (pDefaultTypeInfo)
    {
        DWORD dwTIFlags = TYPEFLAG_FDUAL | TYPEFLAG_FOLEAUTOMATION | TYPEFLAG_FDISPATCHABLE | TYPEFLAG_FHIDDEN;
        if (!bAutoProxy)
            dwTIFlags |= TYPEFLAG_FPROXY;
        IfFailPost(pDefaultTypeInfo->SetTypeFlags(dwTIFlags));
    }

ErrExit:
    return (hr);
} // HRESULT TypeLibExporter::ConvertClassDetails()

//*****************************************************************************
// Create the DispInterface for the vtable that describes an entire class.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertIClassX(
    ICreateTypeInfo2 *pThisTypeInfo,     // The TypeInfo for the IClassX.
    EEClass     *pClass,                // The EEClass object for the class.
    int         bAutoProxy)             // If true, oleaut32 is the proxy.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    DWORD       dwTIFlags=0;            // TypeLib flags.
    DWORD       nSlots;                 // Number of vtable slots.
    UINT        i;                      // Loop control.
    CQuickArray<WCHAR> rName;           // A name.
    int         cVisibleMembers = 0;    // The count of methods that are visible to COM.
    ComMTMemberInfoMap MemberMap(pClass->GetMethodTable()); // The map of members.

    // Should be an actual class.
    _ASSERTE(!pClass->IsInterface());

    // Retrieve the method properties.
    IfFailGo(InitMemberInfoMap(&MemberMap));
    if (MemberMap.HadDuplicateDispIds())
        ReportWarning(TLBX_I_DUPLICATE_DISPID, TLBX_I_DUPLICATE_DISPID);

    // We need a scope to bypass the inialization skipped by goto ErrExit 
    // compiler error.
    {
        CQuickArray<ComMTMethodProps> &rProps = MemberMap.GetMethods();
        nSlots = (DWORD)rProps.Size();

        dwTIFlags |= TYPEFLAG_FDUAL | TYPEFLAG_FOLEAUTOMATION | TYPEFLAG_FDISPATCHABLE | TYPEFLAG_FHIDDEN | TYPEFLAG_FNONEXTENSIBLE;
        if (!bAutoProxy)
            dwTIFlags |= TYPEFLAG_FPROXY;
        IfFailPost(pThisTypeInfo->SetTypeFlags(dwTIFlags));

        // Assign slot numbers.
        for (i=0; i<nSlots; ++i)
            rProps[i].oVft = (short)((7 + i) * sizeof(void*));

        // Now add the methods to the TypeInfo.
        for (i=0; i<nSlots; ++i)
        {
            TRACE("[%d] %10ls pMeth:%08x, prop:%d, semantic:%d, dispid:0x%x, oVft:%d\n", i, rProps[i].pName, rProps[i].pMeth, 
                    rProps[i].property, rProps[i].semantic, rProps[i].dispid, rProps[i].oVft);
            if (rProps[i].bMemberVisible)
            {
                if (rProps[i].semantic < FieldSemanticOffset)
                    hr = ConvertMethod(pThisTypeInfo, &rProps[i], cVisibleMembers, ifDual);
                else
                    hr = ConvertFieldAsMethod(pThisTypeInfo, &rProps[i], cVisibleMembers);

                if (FAILED(hr))
                {
                    // Bad signature has already been reported as warning, and can now be ignored.  Anything else is fatal.
                    if (hr == TLBX_E_BAD_SIGNATURE)
                        hr = S_OK;
                    else
                        IfFailGo(hr);
                }
                else
                    cVisibleMembers++;
            }
        }
    }

ErrExit:
    return hr;
} // HRESULT TypeLibExporter::ConvertIClassX()

// forward declartion
extern HRESULT  _FillVariant(
    MDDefaultValue  *pMDDefaultValue,
    VARIANT     *pvar); 

extern HRESULT _FillMDDefaultValue(
    BYTE        bType,
    void const *pValue,
    MDDefaultValue  *pMDDefaultValue);

//*****************************************************************************
// Export a Method's metadata to a typelib.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertMethod(
    ICreateTypeInfo2 *pCTI,             // ICreateTypeInfo2 to get the method.
    ComMTMethodProps *pProps,           // Some properties of the method.
    ULONG       iMD,                    // Index of the member
    ULONG       ulIface)                // Is this interface : IUnknown, [dual], or DISPINTERFACE?
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    HRESULT     hrSignature = S_OK;     // A failure HR;
    LPCUTF8     pszName;                // Name in UTF8.
    CQuickArray<WCHAR>  rName;          // For converting name from UTF8.
    LPWSTR      rcName = NULL;          // The function's name.
    ULONG       dwImplFlags;            // The function's impl flags.
    PCCOR_SIGNATURE pbSig;              // Pointer to Cor signature.
    ULONG       cbSig;                  // Size of Cor signature.
    ULONG       ixSig;                  // Index into signature.
    ULONG       cbElem;                 // Size of an element in the signature.
    ULONG       callconv;               // A member's calling convention.
    ULONG       ret;                    // The return type.
    ULONG       elem;                   // A signature element.
    TYPEDESC    *pRetVal=0;             // Return type's TYPEDESC.
    ULONG       cSrcParams;             // Count of source params.
    ULONG       cDestParams = 0;        // Count of dest parameters.
    USHORT      iSrcParam;              // Loop control, over params.
    USHORT      iDestParam;             // Loop control, over params.
    USHORT      iLCIDParam;             // The index of the LCID param.
    ULONG       dwParamFlags;           // A parameter's flags.
    int         bFreeDefaultVals=false; // True if any arg has a BSTR default value.
    CDescPool   sPool;                  // Pool of memory in which to build funcdesc.
    CDescPool   sVariants;              // Pool of variants for default values.
    PARAMDESCEX *pParamDesc;            // Pointer to one param default value.
    int         bHrMunge=true;          // Munge return type to HRESULT?
    CQuickArray<BSTR> rNames;           // Array of names to function and parameters.
    ULONG       cNames=0;               // Count of function and parameter names.
    FUNCDESC    *pfunc = NULL;          // A funcdesc.
    MethodDesc  *pMeth;                 // A MethodDesc.
    IMDInternalImport *pInternalImport; // Internal interface containing the method.
    MDDefaultValue defaultValue;        // place holder for default value
    PCCOR_SIGNATURE pvNativeType;       // native parameter type
    ULONG           cbNativeType = 0;   // native parameter type length
    EEClass     *pClass;                // Class containing the method.
    int         bHasOptorDefault=false; // If true, the method has optional params or default values -- no vararg
    BSTR        bstrDescr=0;            // Description of the method.
    const void  *pvData;                // Pointer to a custom attribute.
    ULONG       cbData;                 // Size of custom attribute.
    BOOL        bByRef;                 // Is a parameter byref?
    VARIANT     vtManagedName;          // Variant used to set the managed name of the member.

    // Initialize the variant containing the managed name.
    VariantInit(&vtManagedName);

    // Get info about the method.
    pMeth = pProps->pMeth;
    pMeth->GetSig(&pbSig, &cbSig);
    pInternalImport = pMeth->GetMDImport();
    pClass = pMeth->GetClass();
    pInternalImport->GetMethodImplProps(pMeth->GetMemberDef(), 0, &dwImplFlags);
    
    // Error reporting info.
    m_ErrorContext.m_szMember = pInternalImport->GetNameOfMethodDef(pMeth->GetMemberDef());
    
    // Allocate one variant.
    pParamDesc = reinterpret_cast<PARAMDESCEX*>(sVariants.AllocZero(sizeof(PARAMDESCEX)));
    IfNullGo(pParamDesc);

    // Prepare to parse signature and build the FUNCDESC.
    pfunc = reinterpret_cast<FUNCDESC*>(sPool.AllocZero(sizeof(FUNCDESC)));
    IfNullGo(pfunc);
    ixSig = 0;

    // Get the calling convention.
    ixSig += CorSigUncompressData(&pbSig[ixSig], &callconv);
    _ASSERTE((callconv & IMAGE_CEE_CS_CALLCONV_MASK) != IMAGE_CEE_CS_CALLCONV_FIELD);
    pfunc->callconv = Clr2TlbCallConv[callconv & IMAGE_CEE_CS_CALLCONV_MASK];

    //@todo: I'd like this check here, but the C compiler doesn't turn on the bit.
    //_ASSERTE(callconv & IMAGE_CEE_CS_CALLCONV_HASTHIS);

    // vtable offset.
    pfunc->oVft = pProps->oVft;

    // Get the argument count.  Allow for an extra in case of [retval].
    ixSig += CorSigUncompressData(&pbSig[ixSig], &cSrcParams);
    cDestParams = cSrcParams;
    IfFailGo(rNames.ReSize(cDestParams+3));
    memset(rNames.Ptr(), 0, (cDestParams+3) * sizeof(BSTR));

    // Set some method properties.
    pfunc->memid = pProps->dispid;
    if (pfunc->memid == -11111) //@hackola: fix for msvbalib.dll
        pfunc->memid = -1;
    pfunc->funckind = FUNC_PUREVIRTUAL;

    // Set the invkind based on whether the function is an accessor.
    if (pProps->semantic == 0)
        pfunc->invkind = INVOKE_FUNC;
    else
    if (pProps->semantic == msGetter)
        pfunc->invkind = INVOKE_PROPERTYGET;
    else
    if (pProps->semantic == msSetter)
        pfunc->invkind = INVOKE_PROPERTYPUTREF;
    else
    if (pProps->semantic == msOther)
        pfunc->invkind = INVOKE_PROPERTYPUT;
    else
        pfunc->invkind = INVOKE_FUNC; // non-accessor property function.

    rNames[0] = pProps->pName;
    cNames = 1;
    
    // Convert return type to elemdesc.  If we are doing HRESULT munging, we need to 
    //  examine the return type, and if it is not VOID, create an additional final 
    //  parameter as a pointer to the type.

    // Get the return type.  
    cbElem = CorSigUncompressData(&pbSig[ixSig], &ret);

    // Error reporting info.
    m_ErrorContext.m_ixParam = 0;
    
    // Get native type of return if available
    mdParamDef pdParam;
    pvNativeType = NULL;
    hr = pInternalImport->FindParamOfMethod(pMeth->GetMemberDef(), 
                                             0, &pdParam);
    if (hr == S_OK)
        pInternalImport->GetFieldMarshal(pdParam,
                                          &pvNativeType, &cbNativeType);

    // Determine if we need to do HRESULT munging.
    bHrMunge = !IsMiPreserveSig(dwImplFlags);

    // Reset some properties for DISPINTERFACES.
    if (ulIface == ifDispatch)
    {
        pfunc->callconv = CC_STDCALL;
        pfunc->funckind = FUNC_DISPATCH;
        // Never munge a dispinterface.
        bHrMunge = false;
    }
    
    if (bHrMunge)
    {   // Munge the return type into a new last param, set return type to HRESULT.
        pfunc->elemdescFunc.tdesc.vt = VT_HRESULT;
        // Does the function actually return anything?
        if (ret == ELEMENT_TYPE_VOID)
        {   // Skip over the return value, no [retval].
            pRetVal = 0;
            ixSig += cbElem;
        }
        else
        {   // Allocate a TYPEDESC to be pointed to, convert type into it.
            pRetVal = reinterpret_cast<TYPEDESC*>(sPool.AllocZero(sizeof(TYPEDESC)));       
            IfNullGo(pRetVal);
            hr = CorSigToTypeDesc(pCTI, pClass, &pbSig[ixSig], pvNativeType, cbNativeType, &cbElem, pRetVal, &sPool, TRUE);
            if (hr == TLBX_E_BAD_SIGNATURE && hrSignature == S_OK)
                hrSignature = hr, hr = S_OK;
            IfFailGo(hr);
            ixSig += cbElem;
            ++cDestParams;
            // It is pretty weird for a property putter to return something, but apparenly legal.
            //_ASSERTE(pfunc->invkind != INVOKE_PROPERTYPUT && pfunc->invkind != INVOKE_PROPERTYPUTREF);

            // Hackola.  When the C compiler tries to import a typelib with a C 
            // array return type (even if it's a retval), 
            // it generates a wrapper method with a signature like "int [] foo()", 
            // which isn't valid C, so it barfs.  So, we'll change the return type 
            // to a pointer by hand.
            if (pRetVal->vt == VT_CARRAY)
            {
                pRetVal->vt = VT_PTR;
                pRetVal->lptdesc = &pRetVal->lpadesc->tdescElem;
            }
        }
    }
    else
    {   // No munging, convert return type.
        pRetVal = 0;
        hr = CorSigToTypeDesc(pCTI, pClass, &pbSig[ixSig], pvNativeType, cbNativeType, &cbElem, &pfunc->elemdescFunc.tdesc, &sPool, TRUE);
        if (hr == TLBX_E_BAD_SIGNATURE && hrSignature == S_OK)
            hrSignature = hr, hr = S_OK;
        IfFailGo(hr);
        ixSig += cbElem;
    }

    // Error reporting info.
    m_ErrorContext.m_ixParam = -1;
    
    // Check to see if there is an LCIDConversion attribute on the method.
    iLCIDParam = (USHORT)GetLCIDParameterIndex(pInternalImport, pMeth->GetMemberDef());
    if (iLCIDParam != (USHORT)-1)
    {
        BOOL bValidLCID = TRUE;

        // Make sure the parameter index is valid.
        if (iLCIDParam > cSrcParams)
        {
            ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_INVALIDLCIDPARAM);
            bValidLCID = FALSE;
        }

        // LCID's are not allowed on pure dispatch interfaces.
        if (ulIface == ifDispatch)
        {
            ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_LCIDONDISPONLYITF);
            bValidLCID = FALSE;
        }

        if (bValidLCID)
        {
            // Take the LCID parameter into account in the exported method.
        ++cDestParams;
    }
        else
        {
            // The LCID is invalid so we will ignore it.
            iLCIDParam = -1;
        }
    }

    // for each parameter
    pfunc->lprgelemdescParam = reinterpret_cast<ELEMDESC*>(sPool.AllocZero(cDestParams * sizeof(ELEMDESC)));
    IfNullGo(pfunc->lprgelemdescParam);
    pfunc->cParams = static_cast<short>(cDestParams);
    for (iSrcParam=1, iDestParam=0; iDestParam<cDestParams; ++iSrcParam, ++iDestParam)
    {   
        // Check to see if we need to insert the LCID param before the current param.
        if (iLCIDParam == iDestParam)
        {
            // Set the flags and the type of the parameter.
            pfunc->lprgelemdescParam[iDestParam].paramdesc.wParamFlags = PARAMFLAG_FIN | PARAMFLAG_FLCID;
            pfunc->lprgelemdescParam[iDestParam].tdesc.vt = VT_I4;

            // Generate a parameter name.
            rcName = rName.Alloc(MAX_CLASSNAME_LENGTH);
            _snwprintf(rcName, MAX_CLASSNAME_LENGTH, szParamName, iDestParam + 1);
            rcName[MAX_CLASSNAME_LENGTH-1] = L'\0';

            rNames[iDestParam + 1] = ::SysAllocString(rcName);
            IfNullGo(rNames[iDestParam + 1]);
            ++cNames;

            // Increment the current destination parameter.
            ++iDestParam;
        }

        // If we are past the end of the source parameters then we are done.
        if (iSrcParam > cSrcParams)
            break;

        // Get additional parameter metadata.
        dwParamFlags = 0;
        rcName = NULL;

        // Error reporting info.
        m_ErrorContext.m_ixParam = iSrcParam;
        
        // See if there is a ParamDef for this param.
        mdParamDef pdParam;
        hr = pInternalImport->FindParamOfMethod(pMeth->GetMemberDef(), iSrcParam, &pdParam);

        pvNativeType = NULL;
        if (hr == S_OK)
        {   
            // Get info about the param.        
            pszName = pInternalImport->GetParamDefProps(pdParam, &iSrcParam, &dwParamFlags);

            // Error reporting info.
            m_ErrorContext.m_szParam = pszName;
            
            // Turn off reserved (internal use) bits.
            dwParamFlags &= ~pdReservedMask;

            // Convert name from UTF8 to unicode.
            IfFailGo(Utf2Quick(pszName, rName));
            rcName = rName.Ptr();

            // Param default value, if any.
            IfFailGo(pInternalImport->GetDefaultValue(pdParam, &defaultValue));

            IfFailGo( _FillVariant(&defaultValue, &pParamDesc->varDefaultValue) );
            // If no default value, check for decimal custom attribute.
            if (pParamDesc->varDefaultValue.vt == VT_EMPTY)
            {
                IfFailGo(pClass->GetMDImport()->GetCustomAttributeByName(pdParam, INTEROP_DECIMALVALUE_TYPE,  &pvData,&cbData));
                if (hr == S_OK && cbData >= (2 + sizeof(BYTE)+sizeof(BYTE)+sizeof(UINT)+sizeof(UINT)+sizeof(UINT)))
                {
                    const BYTE *pbData = (const BYTE *)pvData;
                    pParamDesc->varDefaultValue.vt = VT_DECIMAL;
                    pParamDesc->varDefaultValue.decVal.scale = *(BYTE*)(pbData+2);
                    pParamDesc->varDefaultValue.decVal.sign= *(BYTE*)(pbData+3);
                    pParamDesc->varDefaultValue.decVal.Hi32= *(UINT*)(pbData+4);
                    pParamDesc->varDefaultValue.decVal.Mid32= *(UINT*)(pbData+8);
                    pParamDesc->varDefaultValue.decVal.Lo32= *(UINT*)(pbData+12);
                }
            }
            // If still no default value, check for date time custom attribute.
            if (pParamDesc->varDefaultValue.vt == VT_EMPTY)
            {
                IfFailGo(pClass->GetMDImport()->GetCustomAttributeByName(pdParam, INTEROP_DATETIMEVALUE_TYPE,  &pvData,&cbData));
                if (hr == S_OK && cbData >= (2 + sizeof(__int64)))
                {
                    const BYTE *pbData = (const BYTE *)pvData;
                    pParamDesc->varDefaultValue.vt = VT_DATE;
                    pParamDesc->varDefaultValue.date = _TicksToDoubleDate(*(__int64*)(pbData+2));
                }
            }
            // If still no default value, check for IDispatch custom attribute.
            if (pParamDesc->varDefaultValue.vt == VT_EMPTY)
            {
                IfFailGo(pClass->GetMDImport()->GetCustomAttributeByName(pdParam, INTEROP_IDISPATCHVALUE_TYPE,  &pvData,&cbData));
                if (hr == S_OK)
                {
                    pParamDesc->varDefaultValue.vt = VT_DISPATCH;
                    pParamDesc->varDefaultValue.pdispVal = 0;
                }
            }
            // If still no default value, check for IUnknown custom attribute.
            if (pParamDesc->varDefaultValue.vt == VT_EMPTY)
            {
                IfFailGo(pClass->GetMDImport()->GetCustomAttributeByName(pdParam, INTEROP_IUNKNOWNVALUE_TYPE,  &pvData,&cbData));
                if (hr == S_OK)
                {
                    pParamDesc->varDefaultValue.vt = VT_UNKNOWN;
                    pParamDesc->varDefaultValue.punkVal = 0;
                }
            }
            if (pParamDesc->varDefaultValue.vt != VT_EMPTY)
            {
                pfunc->lprgelemdescParam[iDestParam].paramdesc.pparamdescex = pParamDesc;
                dwParamFlags |= PARAMFLAG_FHASDEFAULT;

                if (pParamDesc->varDefaultValue.vt == VT_I8)
                {
                    HRESULT hr;
                    double d;
                    hr = ConvertI8ToDate( *(I8*)&(pParamDesc->varDefaultValue.lVal), &d );
                    IfFailPost(hr);
                    *(double*)&(pParamDesc->varDefaultValue.lVal) = d;
                    pParamDesc->varDefaultValue.vt = VT_DATE;
                }
                // Note that we will need to clean up.
                if (pParamDesc->varDefaultValue.vt == VT_BSTR)
                    bFreeDefaultVals = true;
                // Allocate another paramdesc.
                pParamDesc = reinterpret_cast<PARAMDESCEX*>(sVariants.AllocZero(sizeof(PARAMDESCEX)));
                IfNullGo(pParamDesc);
                bHasOptorDefault = true;
            }

            // native marshal type, if any.
            pInternalImport->GetFieldMarshal(pdParam, &pvNativeType, &cbNativeType);
            
            // Remember if there are optional params.
            if (dwParamFlags & PARAMFLAG_FOPT)
                bHasOptorDefault = true;
        }
        else
            pdParam = 0, m_ErrorContext.m_szParam = 0;

        // Do we need a name for this parameter?
        if ((pfunc->invkind & (INVOKE_PROPERTYPUT | INVOKE_PROPERTYPUTREF)) == 0 ||
            iSrcParam < cSrcParams)
        {   // Yes, so make one up if we don't have one.
            if (!rcName || !*rcName) 
            {
                rcName = rName.Alloc(MAX_CLASSNAME_LENGTH);
                _snwprintf(rcName, MAX_CLASSNAME_LENGTH, szParamName, iDestParam + 1);
                rcName[MAX_CLASSNAME_LENGTH-1] = L'\0';
            }
            rNames[iDestParam + 1] = ::SysAllocString(rcName);
            IfNullGo(rNames[iDestParam + 1]);
            ++cNames;
        }

        // Save the element type.
        CorSigUncompressData(&pbSig[ixSig], &elem);
        // Convert the param info to elemdesc.
        bByRef = FALSE;
        hr = CorSigToTypeDesc(pCTI, pClass, &pbSig[ixSig], pvNativeType, cbNativeType, &cbElem, 
                            &pfunc->lprgelemdescParam[iDestParam].tdesc, &sPool, TRUE, FALSE, &bByRef);
        if (hr == TLBX_E_BAD_SIGNATURE && hrSignature == S_OK)
            hrSignature = hr, hr = S_OK;
        IfFailGo(hr);
        ixSig += cbElem;

        // If there is no [in,out], set one, based on the parameter.
        if ((dwParamFlags & (PARAMFLAG_FOUT | PARAMFLAG_FIN)) == 0)
        {   // If param is by reference, make in/out
            if (bByRef)
                dwParamFlags |= PARAMFLAG_FIN | PARAMFLAG_FOUT;
            else
                dwParamFlags |= PARAMFLAG_FIN;
        }

        // If this is the last param, and it an array of objects, and has a ParamArrayAttribute,
        //  the function is varargs.
        if ((iSrcParam == cSrcParams) && !IsNilToken(pdParam) && !bHasOptorDefault) 
        {
            if (pfunc->lprgelemdescParam[iDestParam].tdesc.vt == VT_SAFEARRAY &&
                pfunc->lprgelemdescParam[iDestParam].tdesc.lpadesc->tdescElem.vt == VT_VARIANT)
            {
                if (pInternalImport->GetCustomAttributeByName(pdParam, INTEROP_PARAMARRAY_TYPE, 0,0) == S_OK)
                    pfunc->cParamsOpt = -1;
            }
        }
        
        pfunc->lprgelemdescParam[iDestParam].paramdesc.wParamFlags = static_cast<USHORT>(dwParamFlags);
    }

    // Is there a [retval]?
    if (pRetVal)
    {
        // Error reporting info.
        m_ErrorContext.m_ixParam = 0;
        m_ErrorContext.m_szParam = 0;
        
        _ASSERTE(bHrMunge);
        _ASSERTE(cDestParams > cSrcParams);
        pfunc->lprgelemdescParam[cDestParams-1].tdesc.vt = VT_PTR;
        pfunc->lprgelemdescParam[cDestParams-1].tdesc.lptdesc = pRetVal;
        pfunc->lprgelemdescParam[cDestParams-1].paramdesc.wParamFlags = PARAMFLAG_FOUT | PARAMFLAG_FRETVAL;
        rNames[cDestParams] = szRetVal;
        IfNullGo(rNames[cDestParams]);
        ++cNames;
    }

    // Error reporting info.
    m_ErrorContext.m_ixParam = -1;
    
    // Was there a signature error?  If so, exit now that all sigs have been reported.
    IfFailGo(hrSignature);
    
    IfFailPost(pCTI->AddFuncDesc(iMD, pfunc));

    IfFailPost(pCTI->SetFuncAndParamNames(iMD, rNames.Ptr(), cNames));

    if (pProps->bFunction2Getter)
    {
        VARIANT vtOne;
        vtOne.vt = VT_I4;
        vtOne.lVal = 1;
        IfFailPost(pCTI->SetFuncCustData(iMD, GUID_Function2Getter, &vtOne));
    }

    // If the managed name of the method is different from the unmanaged name, then
    // we need to capture the managed name in a custom value. We only apply this
    // attribute for methods since properties cannot be overloaded.
    if (pProps->semantic == 0)
    {
        IfFailGo(Utf2Quick(pMeth->GetName(), rName));
        if (wcscmp(rName.Ptr(), pProps->pName) != 0)
        {
            vtManagedName.vt = VT_BSTR;
            IfNullGo(vtManagedName.bstrVal = SysAllocString(rName.Ptr()));
            IfFailPost(pCTI->SetFuncCustData(iMD, GUID_ManagedName, &vtManagedName));
        }
    }

    // Check for a description.
    IfFailGo(GetDescriptionString(pClass, pMeth->GetMemberDef(), bstrDescr));
    if (hr == S_OK)
        IfFailGo(pCTI->SetFuncDocString(iMD, bstrDescr));
    

ErrExit:
    // Clean up any default values.
    if (bFreeDefaultVals)
    {
        for (UINT i=0; i<cDestParams; ++i)
        {
            if (pfunc->lprgelemdescParam[i].paramdesc.wParamFlags & PARAMFLAG_FHASDEFAULT)
            {
                VARIANT *pVariant = &pfunc->lprgelemdescParam[i].paramdesc.pparamdescex->varDefaultValue;
                if (pVariant->vt == VT_BSTR)
                    ::VariantClear(pVariant);
            }
        }
    }
    // Free names.  First name was passed in.  Last one may be a constant.
    for (int i=cNames-(pRetVal?2:1); i>0; --i)
        if (rNames[i])
            ::SysFreeString(rNames[i]);
    
    // Clear the variant containing the managed name.
    VariantClear(&vtManagedName);

    // Error reporting info.
    m_ErrorContext.m_szMember = 0;
    m_ErrorContext.m_szParam = 0;
    m_ErrorContext.m_ixParam = -1;

    if (bstrDescr)
        ::SysFreeString(bstrDescr);
    
    return hr;
} // HRESULT TypeLibExporter::ConvertMethod()

//*****************************************************************************
// Export a Field as getter/setter method's to a typelib.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertFieldAsMethod(
    ICreateTypeInfo2 *pCTI,             // ICreateTypeInfo2 to get the method.
    ComMTMethodProps *pProps,           // Some properties of the method.
    ULONG       iMD)                    // Index of the member
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    PCCOR_SIGNATURE pbSig;              // Pointer to Cor signature.
    ULONG       cbSig;                  // Size of Cor signature.
    ULONG       ixSig;                  // Index into signature.
    ULONG       cbElem;                 // Size of an element in the signature.

    ULONG       callconv;               // A member's calling convention.
    TYPEDESC    *pType;                 // TYPEDESC for the field type.
    CDescPool   sPool;                  // Pool of memory in which to build funcdesc.
    BSTR        rNames[2];              // Array of names to function and parameters.
    ULONG       cNames;                 // Count of function and parameter names.
    FUNCDESC    *pfunc;                 // A funcdesc.
    ComCallMethodDesc   *pFieldMeth;    // A MethodDesc for a field call.
    FieldDesc   *pField;                // A FieldDesc.
    IMDInternalImport *pInternalImport; // Internal interface containing the field.
    PCCOR_SIGNATURE pvNativeType;       // native field type
    ULONG           cbNativeType;       // native field type length
    EEClass     *pClass;                // Class containing the field.
    BSTR        bstrDescr=0;            // Description of the method.

    // Get info about the method.
    pFieldMeth = reinterpret_cast<ComCallMethodDesc*>(pProps->pMeth);
    pField = pFieldMeth->GetFieldDesc();
    pField->GetSig(&pbSig, &cbSig);
    pInternalImport = pField->GetMDImport();
    pClass = pField->GetEnclosingClass();

    // Error reporting info.
    m_ErrorContext.m_szMember = pClass->GetMDImport()->GetNameOfFieldDef(pField->GetMemberDef());
    
    // Prepare to parse signature and build the FUNCDESC.
    pfunc = reinterpret_cast<FUNCDESC*>(sPool.AllocZero(sizeof(FUNCDESC)));
    IfNullGo(pfunc);
    ixSig = 0;

    // Get the calling convention.
    ixSig += CorSigUncompressData(&pbSig[ixSig], &callconv);
    _ASSERTE(callconv == IMAGE_CEE_CS_CALLCONV_FIELD);
    pfunc->callconv = CC_STDCALL;

    // vtable offset.
    pfunc->oVft = pProps->oVft;

    // Set some method properties.
    pfunc->memid = pProps->dispid;
    pfunc->funckind = FUNC_PUREVIRTUAL;

    // Set the invkind based on whether the function is an accessor.
    if ((pProps->semantic - FieldSemanticOffset) == msGetter)
        pfunc->invkind = INVOKE_PROPERTYGET;
    else
    if ((pProps->semantic - FieldSemanticOffset) == msSetter)
    {
        if (IsVbRefType(&pbSig[ixSig], pInternalImport))
            pfunc->invkind = INVOKE_PROPERTYPUTREF;
        else
            pfunc->invkind = INVOKE_PROPERTYPUT;
    }
    else
        _ASSERTE(!"Incorrect semantic in ConvertFieldAsMethod");

    // Name of the function.
    rNames[0] = pProps->pName;
    cNames = 1;

    // Return type is HRESULT.
    pfunc->elemdescFunc.tdesc.vt = VT_HRESULT;

    // Set up the one and only parameter.
    pfunc->lprgelemdescParam = reinterpret_cast<ELEMDESC*>(sPool.AllocZero(sizeof(ELEMDESC)));
    IfNullGo(pfunc->lprgelemdescParam);
    pfunc->cParams = 1;

    // Do we need a name for the parameter?  If PROPERTYGET, we do.
    if (pfunc->invkind == INVOKE_PROPERTYGET)
    {   // Yes, so make one up.
        rNames[1] = szRetVal;
        ++cNames;
    }

    // If Getter, convert param as ptr, otherwise convert directly.
    if (pfunc->invkind == INVOKE_PROPERTYGET)
    {
        pType = reinterpret_cast<TYPEDESC*>(sPool.AllocZero(sizeof(TYPEDESC)));
        IfNullGo(pType);
        pfunc->lprgelemdescParam[0].tdesc.vt = VT_PTR;
        pfunc->lprgelemdescParam[0].tdesc.lptdesc = pType;
        pfunc->lprgelemdescParam[0].paramdesc.wParamFlags = PARAMFLAG_FOUT | PARAMFLAG_FRETVAL;
    }
    else
    {
        pType = &pfunc->lprgelemdescParam[0].tdesc;
        pfunc->lprgelemdescParam[0].paramdesc.wParamFlags = PARAMFLAG_FIN;
    }

    // Get native field type
    pvNativeType = NULL;
    pInternalImport->GetFieldMarshal(pField->GetMemberDef(),
                                      &pvNativeType, &cbNativeType);

    // Convert the field type to elemdesc.
    IfFailGo(CorSigToTypeDesc(pCTI, pClass, &pbSig[ixSig], pvNativeType, cbNativeType, &cbElem, pType, &sPool, TRUE));
    ixSig += cbElem;

    // It is unfortunate that we can not handle this better.  Fortunately
    //  this should be very rare.
    // This is a weird case - if we're getting a CARRAY, we cannot add
    // a VT_PTR in the sig, as it will cause the C getter to return an
    // array, which is bad.  So we omit the extra pointer, which at least
    // makes the compiler happy.
    if (pfunc->invkind == INVOKE_PROPERTYGET
        && pType->vt == VT_CARRAY)
    {
        pfunc->lprgelemdescParam[0].tdesc.vt = pType->vt;
        pfunc->lprgelemdescParam[0].tdesc.lptdesc = pType->lptdesc;
    }

    // A property put of an object should be a propertyputref
    if (pfunc->invkind == INVOKE_PROPERTYPUT &&
        (pType->vt == VT_UNKNOWN || pType->vt == VT_DISPATCH))
    {
        pfunc->invkind = INVOKE_PROPERTYPUTREF;
    }
    
    IfFailPost(pCTI->AddFuncDesc(iMD, pfunc));

    IfFailPost(pCTI->SetFuncAndParamNames(iMD, rNames, cNames));

    // Check for a description.
    IfFailGo(GetDescriptionString(pClass, pField->GetMemberDef(), bstrDescr));
    if (hr == S_OK)
        IfFailGo(pCTI->SetFuncDocString(iMD, bstrDescr));
    
ErrExit:
    // Error reporting info.
    m_ErrorContext.m_szMember = 0;

    if (bstrDescr)
        ::SysFreeString(bstrDescr);
    
    return hr;
} // HRESULT TypeLibExporter::ConvertFieldAsMethod()

//*****************************************************************************
// Export a variable's metadata to a typelib.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertVariable(
    ICreateTypeInfo2 *pCTI,             // ICreateTypeInfo2 to get the variable.
    EEClass     *pClass,                // The class containing the variable.
    mdFieldDef  md,                     // The member definition.
    LPWSTR      szName,                 // Name of the member.
    ULONG       iMD)                    // Index of the member
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    PCCOR_SIGNATURE pbSig;              // Pointer to Cor signature.
    ULONG       cbSig;                  // Size of Cor signature.
    ULONG       ixSig;                  // Index into signature.
    ULONG       cbElem;                 // Size of an element in the signature.

    DWORD       dwFlags;                // A member's flags.
    ULONG       callconv;               // A member's calling convention.

    VARIANT     vtVariant;              // A Variant.
    MDDefaultValue defaultValue;        // default value
    ULONG       dispid=DISPID_UNKNOWN;  // The variable's dispid.
    CDescPool   sPool;                  // Pool of memory in which to build vardesc.

    VARDESC     *pvar;                  // A vardesc.

    PCCOR_SIGNATURE pvNativeType;       // native field type
    ULONG           cbNativeType;       // native field type length
    BSTR        bstrDescr=0;            // Description of the method.
    const void  *pvData;                // Pointer to a custom attribute.
    ULONG       cbData;                 // Size of custom attribute.

    CQuickArray<WCHAR> rName;           // Name of the member, if decorated.
    LPWSTR      pSuffix;                // Pointer into the name.
    int         iSuffix = 0;            // Counter for suffix.

    vtVariant.vt = VT_EMPTY;

    // Error reporting info.
    m_ErrorContext.m_szMember = pClass->GetMDImport()->GetNameOfFieldDef(md);
    
    // Get info about the field.
    IfFailGo(pClass->GetMDImport()->GetDispIdOfMemberDef(md, &dispid));
    dwFlags = pClass->GetMDImport()->GetFieldDefProps(md);
    if (IsFdHasDefault(dwFlags))
    {
        IfFailGo(pClass->GetMDImport()->GetDefaultValue(md, &defaultValue));
        IfFailGo( _FillVariant(&defaultValue, &vtVariant) ); 
    }

    // If exporting a non-public member of a struct, warn the user.
    if (!IsFdPublic(dwFlags) && !m_bWarnedOfNonPublic)
    {
        m_bWarnedOfNonPublic = TRUE;
        ReportWarning(TLBX_E_NONPUBLIC_FIELD, TLBX_E_NONPUBLIC_FIELD);
    }

    pbSig = pClass->GetMDImport()->GetSigOfFieldDef(md, &cbSig);
    

    // Prepare to parse signature and build the VARDESC.
    pvar = reinterpret_cast<VARDESC*>(sPool.AllocZero(sizeof(VARDESC)));
    IfNullGo(pvar);
    ixSig = 0;

    // Get the calling convention.
    ixSig += CorSigUncompressData(&pbSig[ixSig], &callconv);
    _ASSERTE(callconv == IMAGE_CEE_CS_CALLCONV_FIELD);

    // Get native field type
    pvNativeType = NULL;
    pClass->GetMDImport()->GetFieldMarshal(md, &pvNativeType, &cbNativeType);

    // Convert the type to elemdesc.
    IfFailGo(CorSigToTypeDesc(pCTI, pClass, &pbSig[ixSig], pvNativeType, cbNativeType, &cbElem, &pvar->elemdescVar.tdesc, &sPool, FALSE));
    ixSig += cbElem;

    pvar->wVarFlags = 0;
    pvar->varkind = VAR_PERINSTANCE;
    pvar->memid = dispid;

    // Constant value.
    if (vtVariant.vt != VT_EMPTY)
        pvar->lpvarValue = &vtVariant;
    else
    {
        IfFailGo(pClass->GetMDImport()->GetCustomAttributeByName(md, INTEROP_DECIMALVALUE_TYPE,  &pvData,&cbData));
        if (hr == S_OK && cbData >= (2 + sizeof(BYTE)+sizeof(BYTE)+sizeof(UINT)+sizeof(UINT)+sizeof(UINT)))
        {
            const BYTE *pbData = (const BYTE *)pvData;
            vtVariant.vt = VT_DECIMAL;
            vtVariant.decVal.scale = *(BYTE*)(pbData+2);
            vtVariant.decVal.sign= *(BYTE*)(pbData+3);
            vtVariant.decVal.Hi32= *(UINT*)(pbData+4);
            vtVariant.decVal.Mid32= *(UINT*)(pbData+8);
            vtVariant.decVal.Lo32= *(UINT*)(pbData+12);
            pvar->lpvarValue = &vtVariant;
        }
        // If still no default value, check for date time custom attribute.
        if (vtVariant.vt == VT_EMPTY)
        {
            IfFailGo(pClass->GetMDImport()->GetCustomAttributeByName(md, INTEROP_DATETIMEVALUE_TYPE,  &pvData,&cbData));
            if (hr == S_OK && cbData >= (2 + sizeof(__int64)))
            {
                const BYTE *pbData = (const BYTE *)pvData;
                vtVariant.vt = VT_DATE;
                vtVariant.date = _TicksToDoubleDate(*(__int64*)(pbData+2));
            }
        }
        // If still no default value, check for IDispatch custom attribute.
        if (vtVariant.vt == VT_EMPTY)
        {
            IfFailGo(pClass->GetMDImport()->GetCustomAttributeByName(md, INTEROP_IDISPATCHVALUE_TYPE,  &pvData,&cbData));
            if (hr == S_OK)
            {
                vtVariant.vt = VT_DISPATCH;
                vtVariant.pdispVal = 0;
            }
        }
        // If still no default value, check for IUnknown custom attribute.
        if (vtVariant.vt == VT_EMPTY)
        {
            IfFailGo(pClass->GetMDImport()->GetCustomAttributeByName(md, INTEROP_IUNKNOWNVALUE_TYPE,  &pvData,&cbData));
            if (hr == S_OK)
            {
                vtVariant.vt = VT_UNKNOWN;
                vtVariant.punkVal = 0;
            }
        }
    }

    IfFailPost(pCTI->AddVarDesc(iMD, pvar));
    // Set the name for the member; decorate if necessary.
    pSuffix = 0;
    for (;;)
    {   // Attempt to set the name.
        hr = pCTI->SetVarName(iMD, szName);
        // If a name conflict, decorate, otherwise, done.
        if (hr != TYPE_E_AMBIGUOUSNAME)
            break;
        if (pSuffix == 0)
        {
            IfFailGo(rName.ReSize((int)(wcslen(szName) + cbDuplicateDecoration)));
            wcscpy(rName.Ptr(), szName);
            szName = rName.Ptr();
            pSuffix = szName + wcslen(szName);
            iSuffix = 2;
        }
        _snwprintf(pSuffix, cchDuplicateDecoration, szDuplicateDecoration, iSuffix++);
    }
    IfFailPost(hr);

    // Check for a description.
    IfFailGo(GetDescriptionString(pClass, md, bstrDescr));
    if (hr == S_OK)
        IfFailGo(pCTI->SetVarDocString(iMD, bstrDescr));
    
ErrExit:
    // Error reporting info.
    m_ErrorContext.m_szMember = 0;

    if (bstrDescr)
        ::SysFreeString(bstrDescr);
    
    // If the variant has a string, that string was ::SysAlloc'd
    if (vtVariant.vt == VT_BSTR)
        VariantClear(&vtVariant);

    return hr;
} // HRESULT TypeLibExporter::ConvertVariable()

//*****************************************************************************
// Export a variable's metadata to a typelib.
//*****************************************************************************
HRESULT TypeLibExporter::ConvertEnumMember(
    ICreateTypeInfo2 *pCTI,              // ICreateTypeInfo2 to get the variable.
    EEClass     *pClass,                // The Class containing the member.
    mdFieldDef  md,                     // The member definition.
    LPWSTR      szName,                 // Name of the member.
    ULONG       iMD)                    // Index of the member
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;              // A result.
    LPCUTF8     pName, pNS;             // To format name.
    DWORD       dwFlags;                // A member's flags.
    VARIANT     vtVariant;              // A Variant.
    MDDefaultValue defaultValue;        // default value
    ULONG       dispid=DISPID_UNKNOWN;  // The variable's dispid.
    CDescPool   sPool;                  // Pool of memory in which to build vardesc.
    VARDESC     *pvar;                  // A vardesc.
    BSTR        bstrDescr=0;            // Description of the method.

    vtVariant.vt = VT_EMPTY;

    // Error reporting info.
    m_ErrorContext.m_szMember = pClass->GetMDImport()->GetNameOfFieldDef(md);
    
    // Get info about the field.
    IfFailGo(pClass->GetMDImport()->GetDispIdOfMemberDef(md, &dispid));
    dwFlags = pClass->GetMDImport()->GetFieldDefProps(md);

    // We do not need to handle decimal's here since enum's can only be integral types.
    IfFailGo(pClass->GetMDImport()->GetDefaultValue(md, &defaultValue));

    // Prepare to parse signature and build the VARDESC.
    pvar = reinterpret_cast<VARDESC*>(sPool.AllocZero(sizeof(VARDESC)));
    IfNullGo(pvar);

    IfFailGo( _FillVariant(&defaultValue, &vtVariant) ); 

    // Don't care what the metadata says the type is -- the type is I4 in the typelib.
    pvar->elemdescVar.tdesc.vt = VT_I4;

    pvar->wVarFlags = 0;
    pvar->varkind = VAR_CONST;
    pvar->memid = dispid;

    // Constant value.
    if (vtVariant.vt != VT_EMPTY)
    {
        pvar->lpvarValue = &vtVariant;
        // If this is an I8 or UI8, do the conversion manually, because some 
        //  systems' oleaut32 don't support 64-bit integers.
        if (vtVariant.vt == VT_I8)
        {  
            // If withing range of 32-bit signed number, OK.
            if (vtVariant.llVal <= LONG_MAX && vtVariant.llVal >= LONG_MIN)
                vtVariant.vt = VT_I4, hr = S_OK;
            else
                hr = E_FAIL;
        }
        else
        if (vtVariant.vt == VT_UI8)
        {
            // If withing range of 32-bit unsigned number, OK.
            if (vtVariant.ullVal <= ULONG_MAX)
                vtVariant.vt = VT_UI4, hr = S_OK;
            else
                hr = E_FAIL;
        }
        else
            hr = VariantChangeTypeEx(&vtVariant, &vtVariant, 0, 0, VT_I4);
        if (FAILED(hr))
        {
            pClass->GetMDImport()->GetNameOfTypeDef(pClass->GetCl(), &pName, &pNS);
            IfFailGo(TlbPostError(TLBX_E_ENUM_VALUE_INVALID, pName, szName));
        }
    }
    else
    {   // No value assigned, use 0.
        pvar->lpvarValue = &vtVariant;
        vtVariant.vt = VT_I4;
        vtVariant.lVal = 0;
    }

    IfFailPost(pCTI->AddVarDesc(iMD, pvar));
    IfFailPost(pCTI->SetVarName(iMD, szName));

    // Check for a description.
    IfFailGo(GetDescriptionString(pClass, md, bstrDescr));
    if (hr == S_OK)
        IfFailGo(pCTI->SetVarDocString(iMD, bstrDescr));
    
ErrExit:
    // Error reporting info.
    m_ErrorContext.m_szMember = 0;

    if (bstrDescr)
        ::SysFreeString(bstrDescr);
    
    return hr;
} // HRESULT TypeLibExporter::ConvertEnumMember()

//*****************************************************************************
// Given a COM+ signature of a field or property, determine if it should
//  be a PROPERTYPUT or PROPERTYPUTREF.
//*****************************************************************************
BOOL TypeLibExporter::IsVbRefType(
    PCCOR_SIGNATURE pbSig,
    IMDInternalImport *pInternalImport)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr;
    BOOL        bRslt = false;
    ULONG       elem=0;                 // An element from a COM+ signature.
    ULONG       cb;
    ULONG       cbElem=0;
    mdToken     tkTypeRef;              // Token for TypeRef or TypeDef.
    CQuickArray<char> rName;            // Buffer to build a name from NS/Name.
    LPCUTF8     pclsname;               // Class name for ELEMENT_TYPE_CLASS.

    cbElem = CorSigUncompressData(pbSig, &elem);
    if (elem == ELEMENT_TYPE_PTR || elem == ELEMENT_TYPE_BYREF)
        return IsVbRefType(&pbSig[cbElem], pInternalImport);
    else
        switch (elem)
        {
        // For documentation -- arrays are NOT ref types here.
        //case ELEMENT_TYPE_SDARRAY:
        //case ELEMENT_TYPE_ARRAY:
        //case ELEMENT_TYPE_SZARRAY:
        // Look for variant.
        case ELEMENT_TYPE_VALUETYPE:
            cb = CorSigUncompressToken(&pbSig[cbElem], &tkTypeRef);
            cbElem += cb;
        
            LPCUTF8 pNS;
            if (TypeFromToken(tkTypeRef) == mdtTypeDef)
                // Get the name of the TypeDef.
                pInternalImport->GetNameOfTypeDef(tkTypeRef, &pclsname, &pNS);
            else
            {   // Get the name of the TypeRef.
                _ASSERTE(TypeFromToken(tkTypeRef) == mdtTypeRef);
                pInternalImport->GetNameOfTypeRef(tkTypeRef, &pNS, &pclsname);
            }

            if (pNS)
            {   // Pre-pend the namespace to the class name.
                IfFailGo(rName.ReSize((int)(strlen(pclsname)+strlen(pNS)+2)));
                strcat(strcat(strcpy(rName.Ptr(), pNS), NAMESPACE_SEPARATOR_STR), pclsname);
                pclsname = rName.Ptr();
            }

            // Is it System.something? 
            _ASSERTE(strlen(szRuntime) == cbRuntime);  // If you rename System, fix this invariant.
            if (_strnicmp(pclsname, szRuntime, cbRuntime) == 0)
            {   
                // Which one?
                LPCUTF8 pcls = pclsname + cbRuntime;
                if (_stricmp(pcls, szVariantClass) == 0)
                    return true;
            }
            return false;

        case ELEMENT_TYPE_CLASS:
            return true;
            
        case ELEMENT_TYPE_OBJECT:
            return false;

        default:
            break;
        }
ErrExit:
    return bRslt;
} // BOOL TypeLibExporter::IsVbRefType()

//*****************************************************************************
// Read a COM+ signature element and create a TYPEDESC that corresponds 
//  to it.
//*****************************************************************************
HRESULT TypeLibExporter::CorSigToTypeDesc(
    ICreateTypeInfo2 *pCTI,              // Typeinfo being created.
    EEClass     *pClass,                // EEClass with the token.
    PCCOR_SIGNATURE pbSig,              // Pointer to the Cor Signature.
    PCCOR_SIGNATURE pbNativeSig,        // Pointer to the native sig, if any
    ULONG       cbNativeSig,            // Count of bytes in native sig.
    ULONG       *pcbElem,               // Put # bytes consumed here.
    TYPEDESC    *ptdesc,                // Build the typedesc here.
    CDescPool   *ppool,                 // Pool for additional storage as required.
    BOOL        bMethodSig,             // TRUE if the sig is for a method, FALSE for a field.
    BOOL        bArrayType,             // If TRUE, called for an array element type (mustn't be an array).
    BOOL        *pbByRef)               // If not null, and the type is byref, set to true.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr=S_OK;
    ULONG       elem;                   // The element type.
    ULONG       cbElem = 0;             // Bytes in the element.
    ULONG       cb;                     // Bytes in a sub-element.
    ULONG       cbNativeElem = 0;       // # of bytes parsed off of native type.
    ULONG       nativeElem = 0;         // The native element type
    ULONG       nativeCount;            // The native element size
    mdToken     tkTypeRef;              // Token for a TypeRef/TypeDef
    CQuickArray<char> rName;            // Buffer to build a name from NS/Name.
    LPCUTF8     pclsname;               // Class name for ELEMENT_TYPE_CLASS.
    HREFTYPE    hRef = 0;                   // HREF to some type.
    IMDInternalImport *pInternalImport; // Internal interface containing the signature.
    int         i;                      // Loop control.
    BOOL        fIsStringBuilder = FALSE;

    pInternalImport = pClass->GetMDImport();

    // Just be sure the count is zero if the pointer is.
    if (pbNativeSig == NULL)
        cbNativeSig = 0;

    // Grab the native marshaling type.
    if (cbNativeSig > 0)
    {
        cbNativeElem = CorSigUncompressData(pbNativeSig, &nativeElem);
        pbNativeSig += cbNativeElem;
        cbNativeSig -= cbNativeElem;

        // AsAny makes no sense for COM Interop.  Ignore it.
        if (nativeElem == NATIVE_TYPE_ASANY)
        {
            ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_ASANY);
            nativeElem = 0;
        }
    }

    // @TODO(DM): Flag invalid combinations.

    // Get the element type.
TryAgain:
    cbElem += CorSigUncompressData(pbSig+cbElem, &elem);

    // Handle the custom marshaler native type separately.
    if (elem != ELEMENT_TYPE_BYREF && nativeElem == NATIVE_TYPE_CUSTOMMARSHALER)
    {
        switch(elem)
        {
            case ELEMENT_TYPE_VAR:
            case ELEMENT_TYPE_CLASS:
            case ELEMENT_TYPE_OBJECT:
            // @TODO(DM): Ask the custom marshaler for the ITypeInfo to use for the unmanaged type.
            ptdesc->vt = VT_UNKNOWN;
            break;

            case ELEMENT_TYPE_STRING:
            case ELEMENT_TYPE_SZARRAY:
            case ELEMENT_TYPE_ARRAY:
            ptdesc->vt = VT_I4;
            break;

            default:
            IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
            break;
        }

        // Eat the rest of the signature.  The extra -1's are to account
        // for the byte parsed off above.
        SigPointer p(&pbSig[cbElem-1]);
        p.Skip();
        cbElem += (ULONG)(p.GetPtr() - &pbSig[cbElem]);  // Note I didn't use -1 here.
        goto ErrExit;
    }

// This label is used to try again with a new element type, but without consuming more signature.
//  Usage is to set 'elem' to a new value, goto this label.
TryWithElemType:
    switch (elem)
    {
    case ELEMENT_TYPE_END:            // 0x0,
        IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_UNKNOWN_SIGNATURE));
        break;
    case ELEMENT_TYPE_VOID:           // 0x1,
        ptdesc->vt = VT_VOID;  
        break;
    case ELEMENT_TYPE_BOOLEAN:        // 0x2,
        switch (nativeElem)
        {
        case 0:
            ptdesc->vt = bMethodSig ? VT_BOOL : VT_I4;
            break;
        case NATIVE_TYPE_VARIANTBOOL:
            ptdesc->vt = VT_BOOL;
            break;
        case NATIVE_TYPE_BOOLEAN:
            ptdesc->vt = VT_I4;
            break;
        case NATIVE_TYPE_U1:
        case NATIVE_TYPE_I1:
            ptdesc->vt = VT_UI1;
            break;
        default:
            DEBUG_STMT(DbgWriteEx(L"Bad Native COM attribute specified!\n"));
            IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
        }   
        break;
    case ELEMENT_TYPE_CHAR:           // 0x3,
        if (nativeElem == 0)
        {
            if (bMethodSig)
            {
                ptdesc->vt = VT_UI2;
            }
            else
            {
                ULONG dwTypeFlags;
                pInternalImport->GetTypeDefProps(pClass->GetCl(), &dwTypeFlags, NULL);
    
                if (IsTdAnsiClass(dwTypeFlags))
                {
                    ptdesc->vt = VT_UI1;
                }
                else if (IsTdUnicodeClass(dwTypeFlags))
                {
                    ptdesc->vt = VT_UI2;
                }
                else if (IsTdAutoClass(dwTypeFlags))
                {
                    // Types with a char set of auto are not allowed to be exported to COM.
                    DefineFullyQualifiedNameForClassW();
                    LPWSTR szName = GetFullyQualifiedNameForClassW(pClass);
                    _ASSERTE(szName);
                    if (FAILED(hr))
                        IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_AUTO_CS_NOT_ALLOWED, szName));
                } 
                else 
                {
                    _ASSERTE(!"Bad stringformat value in wrapper class.");
                    IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, E_FAIL));  // bad metadata
                }
            }
        }
        else
        {
            switch (nativeElem)
            {
            case 0:
            case NATIVE_TYPE_U2:
    //        case NATIVE_TYPE_I2: // @todo: questionable
                ptdesc->vt = VT_UI2;
                break;
            case NATIVE_TYPE_U1:
                ptdesc->vt = VT_UI1;
                break;
            default:
                DEBUG_STMT(DbgWriteEx(L"Bad Native COM attribute specified!\n"));
                IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
            }
        }
        break;
    case ELEMENT_TYPE_I1:             // 0x4,
        ptdesc->vt = VT_I1;
        break;
    case ELEMENT_TYPE_U1:             // 0x5,
        ptdesc->vt = VT_UI1;
        break;
    case ELEMENT_TYPE_I2:             // 0x6,
        ptdesc->vt = VT_I2;
        break;
    case ELEMENT_TYPE_U2:             // 0x7,
        ptdesc->vt = VT_UI2;
        break;
    case ELEMENT_TYPE_I4:             // 0x8,
        switch (nativeElem)
        {
        case 0:
        case NATIVE_TYPE_I4:
        case NATIVE_TYPE_U4: case NATIVE_TYPE_INTF: //@todo: Fix Microsoft.Win32.Interop.dll and remove this line.
            ptdesc->vt = VT_I4;
            break;
        case NATIVE_TYPE_ERROR:
            ptdesc->vt = VT_HRESULT;
            break;
        default:
            DEBUG_STMT(DbgWriteEx(L"Bad Native COM attribute specified!\n"));
            IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
        }
        break;
    case ELEMENT_TYPE_U4:             // 0x9,
        switch (nativeElem)
        {
        case 0:
        case NATIVE_TYPE_U4:
            ptdesc->vt = VT_UI4;
            break;
        case NATIVE_TYPE_ERROR:
            ptdesc->vt = VT_HRESULT;
            break;
        default:
            DEBUG_STMT(DbgWriteEx(L"Bad Native COM attribute specified!\n"));
            IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
        }
        break;
    case ELEMENT_TYPE_I8:             // 0xa,
        ptdesc->vt = VT_I8;
        break;
    case ELEMENT_TYPE_U8:             // 0xb,
        ptdesc->vt = VT_UI8;
        break;
    case ELEMENT_TYPE_R4:             // 0xc,
        ptdesc->vt = VT_R4;
        break;
    case ELEMENT_TYPE_R8:             // 0xd,
        ptdesc->vt = VT_R8;
        break;
    case ELEMENT_TYPE_VAR:
    case ELEMENT_TYPE_OBJECT:
        goto IsObject;
    case ELEMENT_TYPE_STRING:         // 0xe,
    IsString:
        if (nativeElem == 0)
        {
            if (bMethodSig)
            {
                ptdesc->vt = VT_BSTR;
            }
            else
            {
                ULONG dwTypeFlags;
                pInternalImport->GetTypeDefProps(pClass->GetCl(), &dwTypeFlags, NULL);

                if (IsTdAnsiClass(dwTypeFlags))
                {
                    ptdesc->vt = VT_LPSTR;
                }
                else if (IsTdUnicodeClass(dwTypeFlags))
                {
                    ptdesc->vt = VT_LPWSTR;
                }
                else if (IsTdAutoClass(dwTypeFlags))
                {
                    // Types with a char set of auto are not allowed to be exported to COM.
                    DefineFullyQualifiedNameForClassW();
                    LPWSTR szName = GetFullyQualifiedNameForClassW(pClass);
                    _ASSERTE(szName);
                    if (FAILED(hr))
                        IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_AUTO_CS_NOT_ALLOWED, szName));
                } 
                else 
                {
                    _ASSERTE(!"Bad stringformat value in wrapper class.");
                    IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, E_FAIL));  // bad metadata
                }
            }
        }
        else
        {
            switch (nativeElem)
            {
            case NATIVE_TYPE_BSTR:
                if (fIsStringBuilder)
                {
                    IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
                }
                ptdesc->vt = VT_BSTR;
                break;
            case NATIVE_TYPE_LPSTR:
                ptdesc->vt = VT_LPSTR;
                break;
            case NATIVE_TYPE_LPWSTR:
                ptdesc->vt = VT_LPWSTR;
                break;
            case NATIVE_TYPE_LPTSTR:
                {
                    // NATIVE_TYPE_LPTSTR is not allowed to be exported to COM.
                    DefineFullyQualifiedNameForClassW();
                    LPWSTR szName = GetFullyQualifiedNameForClassW(pClass);
                    _ASSERTE(szName);
                    IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_LPTSTR_NOT_ALLOWED, szName));
                    break;
                }
            case NATIVE_TYPE_FIXEDSYSSTRING:
                // NATIVE_TYPE_FIXEDSYSSTRING is only allowed on fields.
                if (bMethodSig)
                    IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));

                // Retrieve the count of characters.
                if (cbNativeSig != 0)
                {
                    cb = CorSigUncompressData(pbNativeSig, &nativeCount);
                    pbNativeSig += cb;
                    cbNativeSig -= cb;
                }
                else
                {
                    nativeCount = 0;
                }

                // Fixed strings become embedded array's of characters.
                ptdesc->vt = VT_CARRAY;
                ptdesc->lpadesc = reinterpret_cast<ARRAYDESC*>(ppool->AllocZero(sizeof(ARRAYDESC)));
                IfNullGo(ptdesc->lpadesc);

                // Set the count of characters.
                ptdesc->lpadesc->cDims = 1;
                ptdesc->lpadesc->rgbounds[0].cElements = nativeCount;
                ptdesc->lpadesc->rgbounds[0].lLbound = 0;

                // Retrieve the char set of the containing value class.
                ULONG dwTypeFlags;
                pInternalImport->GetTypeDefProps(pClass->GetCl(), &dwTypeFlags, NULL);

                // Set the array element type to either UI1 or UI2 depending on the
                // char set of the containing value class.
                if (IsTdAnsiClass(dwTypeFlags))
                {
                    ptdesc->lpadesc->tdescElem.vt = VT_UI1;
                }
                else if (IsTdUnicodeClass(dwTypeFlags))
                {
                    ptdesc->lpadesc->tdescElem.vt = VT_UI2;
                }
                else if (IsTdAutoClass(dwTypeFlags))
                {
                    // Types with a char set of auto are not allowed to be exported to COM.
                    DefineFullyQualifiedNameForClassW();
                    LPWSTR szName = GetFullyQualifiedNameForClassW(pClass);
                    _ASSERTE(szName);
                    if (FAILED(hr))
                        IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_AUTO_CS_NOT_ALLOWED, szName));
                } 
                else 
                {
                    _ASSERTE(!"Bad stringformat value in wrapper class.");
                    IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, E_FAIL));  // bad metadata
                }
                break;

            default:
                DEBUG_STMT(DbgWriteEx(L"Bad Native COM attribute specified!\n"));
                IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
            }   
        }
        break;

    // every type above PTR will be simple type
    case ELEMENT_TYPE_PTR:            // 0xf,
    case ELEMENT_TYPE_BYREF:          // 0x10,
        // TYPEDESC is a pointer.
        ptdesc->vt = VT_PTR;
        if (pbByRef)
            *pbByRef = TRUE;
        // Pointer to what?
        ptdesc->lptdesc = reinterpret_cast<TYPEDESC*>(ppool->AllocZero(sizeof(TYPEDESC)));
        IfNullGo(ptdesc->lptdesc);
        IfFailGo(CorSigToTypeDesc(pCTI, pClass, &pbSig[cbElem], pbNativeSig-cbNativeElem, 
                cbNativeSig+cbNativeElem, &cb, ptdesc->lptdesc, ppool, bMethodSig));
        cbElem += cb;
        break;

    case ELEMENT_TYPE_CLASS:          // 0x12,
    case ELEMENT_TYPE_VALUETYPE:
        // Get the TD/TR.
        cb = CorSigUncompressToken(&pbSig[cbElem], &tkTypeRef);
        cbElem += cb;
        
        LPCUTF8 pNS;
        if (TypeFromToken(tkTypeRef) == mdtTypeDef)
            // Get the name of the TypeDef.
            pInternalImport->GetNameOfTypeDef(tkTypeRef, &pclsname, &pNS);
        else
        {   // Get the name of the TypeRef.
            _ASSERTE(TypeFromToken(tkTypeRef) == mdtTypeRef);
            pInternalImport->GetNameOfTypeRef(tkTypeRef, &pNS, &pclsname);
        }

        if (pNS)
        {   // Pre-pend the namespace to the class name.
            IfFailGo(rName.ReSize((int)(strlen(pclsname)+strlen(pNS)+2)));
            strcat(strcat(strcpy(rName.Ptr(), pNS), NAMESPACE_SEPARATOR_STR), pclsname);
            pclsname = rName.Ptr();
        }

        _ASSERTE(strlen(szRuntime) == cbRuntime);  // If you rename System, fix this invariant.
        _ASSERTE(strlen(szText) == cbText);  // If you rename System.Text, fix this invariant.

        // Is it System.something? 
        if (_strnicmp(pclsname, szRuntime, cbRuntime) == 0)
        {   
            // Which one?
            LPCUTF8 pcls; pcls = pclsname + cbRuntime;
            if (_stricmp(pcls, szStringClass) == 0)
                goto IsString;
            else
            if (_stricmp(pcls, szVariantClass) == 0)
            {
                switch (nativeElem)
                {
                case NATIVE_TYPE_LPSTRUCT:
                    // Make this a pointer to . . .
                    ptdesc->vt = VT_PTR;
                    ptdesc->lptdesc = reinterpret_cast<TYPEDESC*>(ppool->AllocZero(sizeof(TYPEDESC)));
                    IfNullGo(ptdesc->lptdesc);
                    // a VARIANT
                    ptdesc->lptdesc->vt = VT_VARIANT;
                    break;
                case 0:
                case NATIVE_TYPE_STRUCT:
                    // a VARIANT
                    ptdesc->vt = VT_VARIANT;
                    break;
                default:
                    DEBUG_STMT(DbgWriteEx(L"Bad Native COM attribute specified!\n"));
                    IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
                }
                goto ErrExit;
            }
            else
            if (_stricmp(pcls, szDateTimeClass) == 0)
            {
                ptdesc->vt = VT_DATE;
                goto ErrExit;
            }
            else
            if (_stricmp(pcls, szDecimalClass) == 0)
            {
                switch (nativeElem)
                {
                case NATIVE_TYPE_CURRENCY:
                    // Make this a currency.
                    ptdesc->vt = VT_CY;
                    break;
                case 0:
                    // Make this a decimal
                ptdesc->vt = VT_DECIMAL;
                    break;
                default:
                    DEBUG_STMT(DbgWriteEx(L"Bad Native COM attribute specified!\n"));
                    IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
                }
                goto ErrExit;
            }
            else
            if (_stricmp(pcls, szGuidClass) == 0)
            {
                switch (nativeElem)
                {
                case NATIVE_TYPE_LPSTRUCT:
                    // Make this a pointer to . . .
                    ptdesc->vt = VT_PTR;
                    if (pbByRef)
                        *pbByRef = TRUE;
                    ptdesc->lptdesc = reinterpret_cast<TYPEDESC*>(ppool->AllocZero(sizeof(TYPEDESC)));
                    IfNullGo(ptdesc->lptdesc);
                    // . . . a user defined type for GUID
                    ptdesc->lptdesc->vt = VT_USERDEFINED;
                    hr = GetRefTypeInfo(pCTI, m_pGuid, &ptdesc->lptdesc->hreftype);
                    break;
                case 0:
                case NATIVE_TYPE_STRUCT:
                    // a user defined type for GUID
                    ptdesc->vt = VT_USERDEFINED;
                    hr = GetRefTypeInfo(pCTI, m_pGuid, &ptdesc->hreftype);
                    break;
                default:
                    DEBUG_STMT(DbgWriteEx(L"Bad Native COM attribute specified!\n"));
                    IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
                }
                goto ErrExit;
            }
            else
            if (_stricmp(pcls, szArrayClass) == 0)
            {
                // If no native type is specified then assume its a NATIVE_TYPE_INTF.
                if (nativeElem == 0)
                    nativeElem = NATIVE_TYPE_INTF;

                if (nativeElem == NATIVE_TYPE_FIXEDARRAY)
                {               
                    // Retrieve the size of the fixed array
                    ULONG cElems;
                    if (cbNativeSig == 0)
                    {
                        IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
                    }

                    cb = CorSigUncompressData(pbNativeSig, &cElems);
                    pbNativeSig += cb;
                    cbNativeSig -= cb;

                    // Retrieve the fixed array element type.
                    ULONG FixedArrayElemType = NATIVE_TYPE_MAX;
                    if (cbNativeSig == 0)
                    {
                        IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
                    }
                    
                    cb = CorSigUncompressData(pbNativeSig, &FixedArrayElemType);
                    pbNativeSig += cb;
                    cbNativeSig -= cb;

                    if (FixedArrayElemType != NATIVE_TYPE_BSTR)
                    {
                        IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));                        
                    }

                    // Set the data
                    ptdesc->vt = VT_CARRAY;
                    ptdesc->lpadesc = NULL;
                    ptdesc->lpadesc = reinterpret_cast<ARRAYDESC*>(ppool->AllocZero(sizeof(ARRAYDESC)));
                    IfNullGo(ptdesc->lpadesc);

                    ptdesc->lpadesc->tdescElem.vt = VT_BSTR;
                    ptdesc->lpadesc->cDims = 1;
                    ptdesc->lpadesc->rgbounds->cElements = cElems;
                    ptdesc->lpadesc->rgbounds->lLbound = 0;

                    goto ErrExit;
                }

                if (nativeElem == NATIVE_TYPE_SAFEARRAY)
                {
                    ULONG SafeArrayElemVT;
                    SafeArrayElemVT = VT_VARIANT;

                    // Retrieve the safe array element type.
                    if (cbNativeSig != 0)
                    {
                        cb = CorSigUncompressData(pbNativeSig, &SafeArrayElemVT);
                        pbNativeSig += cb;
                        cbNativeSig -= cb;
                    }


                    // TYPEDESC is an array.
                    ptdesc->vt = VT_SAFEARRAY;
                    ptdesc->lptdesc = NULL;
                    ptdesc->lptdesc = reinterpret_cast<TYPEDESC*>(ppool->AllocZero(sizeof(TYPEDESC)));
                    IfNullGo(ptdesc->lptdesc);
                    if (SafeArrayElemVT == VT_RECORD)
                    {
                        // SafeArray of VT_RECORD.  Translate to a UDT.
                        ULONG cbClass;
                        CQuickArray<char> rClass;
                        EEClass *pSubType;

                        // Get the type name.
                        cb = CorSigUncompressData(pbNativeSig, &cbClass);
                        pbNativeSig += cb;
                        cbNativeSig -= cb;
                        IfFailGo(rClass.ReSize(cbClass+1));
                        memcpy(rClass.Ptr(), pbNativeSig, cbClass);
                        rClass[cbClass] = 0;

                        // Load the type and get its href.
                        IfFailGo(LoadClass(pClass->GetModule(), rClass.Ptr(), &pSubType));
                        IfFailGo(EEClassToHref(pCTI, pSubType, FALSE, &ptdesc->lptdesc->hreftype));

                        ptdesc->lptdesc->vt = VT_USERDEFINED;
                    }
                    else
                        ptdesc->lptdesc->vt = (VARENUM)SafeArrayElemVT;
                    goto ErrExit;
                }
                else if (nativeElem != NATIVE_TYPE_INTF)
                {
                    IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
                }

                // If the native type is NATIVE_TYPE_INTF then we fall through and convert 
                // System.Array to its IClassX interface.
            }
            else
            if (_stricmp(pcls, szObjectClass) == 0)
            {
    IsObject:
                // This next statement is to work around a "feature" that marshals an object inside
                //  a struct as an interface, instead of as a variant.  fielemarshal metadata
                //  can override that.
                if (nativeElem == 0 && !bMethodSig)
                    nativeElem = NATIVE_TYPE_IUNKNOWN;

                switch (nativeElem)
                {
                case NATIVE_TYPE_INTF:
                case NATIVE_TYPE_IUNKNOWN:
                    // an IUnknown based interface.
                    ptdesc->vt = VT_UNKNOWN;
                    break;
                case NATIVE_TYPE_IDISPATCH:
                    // an IDispatch based interface.
                    ptdesc->vt = VT_DISPATCH;
                    break;
                case 0:
                case NATIVE_TYPE_STRUCT:
                    // a VARIANT
                    ptdesc->vt = VT_VARIANT;
                    break;
                default:
                    IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
                }
                goto ErrExit;
            }
        } // System
        if (_strnicmp(pclsname, szText, cbText) == 0)
        {
            LPCUTF8 pcls; pcls = pclsname + cbText;
            if (_stricmp(pcls, szStringBufferClass) == 0)
            {
                fIsStringBuilder = TRUE;
                // If there is no fieldmarshal information, marshal as a LPWSTR
                if (nativeElem == 0)
                    nativeElem = NATIVE_TYPE_LPWSTR;
                // Marshaller treats stringbuilders as [in, out] by default.
                if (pbByRef)
                    *pbByRef = TRUE;
                goto IsString;
            }
        } // System.Text
        if (_strnicmp(pclsname, szCollections, cbCollections) == 0)
        {
            LPCUTF8 pcls; pcls = pclsname + cbCollections;
            if (_stricmp(pcls, szIEnumeratorClass) == 0)
            {
                IfFailGo(StdOleTypeToHRef(pCTI, IID_IEnumVARIANT, &hRef));
                ptdesc->vt = VT_PTR;
                ptdesc->lptdesc = reinterpret_cast<TYPEDESC*>(ppool->AllocZero(sizeof(TYPEDESC)));
                IfNullGo(ptdesc->lptdesc);
                ptdesc->lptdesc->vt = VT_USERDEFINED;
                ptdesc->lptdesc->hreftype = hRef;
                goto ErrExit;
            }
        } // System.Collections
        if (_strnicmp(pclsname, szDrawing, cbDrawing) == 0)
        {
            LPCUTF8 pcls; pcls = pclsname + cbDrawing;
            if (_stricmp(pcls, szColor) == 0)
            {
                IfFailGo(StdOleTypeToHRef(pCTI, GUID_OleColor, &hRef));
                ptdesc->vt = VT_USERDEFINED;
                ptdesc->hreftype = hRef;
                goto ErrExit;
            }
        } // System.Drawing

        // It is not a built-in VT type, so build the typedesc.

        // Determine whether the type is a reference type (IUnknown derived) or a struct type.
        // Get the EEClass for the referenced class.
        EEClass     *pRefdClass;            // EEClass object for referenced TypeDef.
        IfFailGo(LoadClass(pClass->GetModule(), tkTypeRef, &pRefdClass));

        // Is the type a ref type or a struct type.  Note that a ref type that has layout
        //  is exported as a TKIND_RECORD but is referenced as a **Foo, whereas a
        //  value type is also exported as a TKIND_RECORD but is referenced as a *Foo.
        if (elem == ELEMENT_TYPE_CLASS)
        {   // A ref type.
            if (GetAppDomain()->IsSpecialStringClass(pRefdClass->GetMethodTable())
                || GetAppDomain()->IsSpecialStringBuilderClass(pRefdClass->GetMethodTable()))
                goto IsString;
            
            // Check if it is a delegate (which can be marshaled as a function pointer).
            if (COMDelegate::IsDelegate(pRefdClass))
            {
                if (nativeElem == NATIVE_TYPE_FUNC)
                {
                    ptdesc->vt = VT_INT;
                    goto ErrExit;
                }
                else if (nativeElem != 0 && nativeElem != NATIVE_TYPE_INTF)
                    IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
            }

            // If this is a reference type in a struct (but without layout), it must have
            //  NATIVE_TYPE_INTF
            if (!bMethodSig && !pRefdClass->HasLayout() && nativeElem != NATIVE_TYPE_INTF)
                (ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_CLASS_NEEDS_NT_INTF));

            // A reference to some non-system-defined/non delegate derived type.  Get the reference to the
            //  type, unless it is an imported COM type, in which case, we'll just use
            //  IUnknown.
            // If the type is not visible from COM then we return S_USEIUNKNOWN.
            if (!IsTypeVisibleFromCom(TypeHandle(pRefdClass->GetMethodTable())))
                hr = S_USEIUNKNOWN;
            else
                IfFailGo(EEClassToHref(pCTI, pRefdClass, TRUE, &hRef));
            if (hr == S_USEIUNKNOWN)
            {   
                // Not a known type, so use IUnknown
                ptdesc->vt = VT_UNKNOWN;
                goto ErrExit;
            }
       
            // Not a known class, so make this a pointer to . . .
            ptdesc->vt = VT_PTR;
            ptdesc->lptdesc = reinterpret_cast<TYPEDESC*>(ppool->AllocZero(sizeof(TYPEDESC)));
            IfNullGo(ptdesc->lptdesc);
            // . . . a user defined type . . .
            ptdesc->lptdesc->vt = VT_USERDEFINED;
            // . . . based on the token.
            ptdesc->lptdesc->hreftype = hRef;
        }
        else  // It's a value type.
        {   
            // If it is an enum, check the underlying type.  All COM enums are 32 bits,
            //  so if the .Net enum is not a 32 bit enum, convert to the underlying type
            //  instead of the enum type.
            if (pRefdClass->IsEnum())
            {
                // Get the element type of the underlying type.
                CorElementType et = pRefdClass->GetMethodTable()->GetNormCorElementType();
                // If it is not a 32-bit type, convert as the underlying type.
                if (et != ELEMENT_TYPE_I4 && et != ELEMENT_TYPE_U4)
                {
                    elem = et;
                    goto TryWithElemType;
                }
                // Fall through to convert as the enum type.
            }

            // A reference to some non-system-defined type. Get the reference to the
            // type. Since this is a value class we must get a valid href. Otherwise
            // we fail the conversion.
            hr = TokenToHref(pCTI, pClass, tkTypeRef, FALSE, &hRef);
            if (hr == S_USEIUNKNOWN)
            {
                CQuickArray<WCHAR> rName;
                IfFailGo(Utf2Quick(pclsname, rName));


                LPCWSTR szVCName = (LPCWSTR)(rName.Ptr());
                if (NAMESPACE_SEPARATOR_WCHAR == *szVCName)
                {
                    szVCName++;
                }

                IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_NONVISIBLEVALUECLASS, szVCName));
            }

            // Value class is like other UserDefined types, except passed by value, ie
            //  on the stack, instead of by pointer.
            // . . . a user defined type . . .
            ptdesc->vt = VT_USERDEFINED;
            // . . . based on the token.
            ptdesc->hreftype = hRef;
        }
        break;

    case ELEMENT_TYPE_SZARRAY:          // 0x1d
        if (bArrayType)
        {
            LPCUTF8 pName, pNS;
            pClass->GetMDImport()->GetNameOfTypeDef(pClass->GetCl(), &pName, &pNS);
            IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_NO_NESTED_ARRAYS, pName));
        }

        // Fields may only contain NATIVE_TYEE_FIXEDARRAY or NATIVE_TYPE_SAFEARRAY.  The marshaller doesn't
        //  support anything else.
        if ((!bMethodSig) && nativeElem && (nativeElem != NATIVE_TYPE_FIXEDARRAY) && (nativeElem != NATIVE_TYPE_SAFEARRAY))
            (ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_ARRAY_NEEDS_NT_FIXED));

        switch (nativeElem)
        {
        case 0:
        case NATIVE_TYPE_SAFEARRAY:
        {
            ULONG SafeArrayElemVT  = VT_EMPTY;

            // Retrieve the safe array element type.
            if (cbNativeSig != 0)
            {
                cb = CorSigUncompressData(pbNativeSig, &SafeArrayElemVT);
                pbNativeSig += cb;
                cbNativeSig -= cb;
            }

            ptdesc->vt = VT_SAFEARRAY;
            ptdesc->lptdesc = reinterpret_cast<TYPEDESC*>(ppool->AllocZero(sizeof(TYPEDESC)));
            IfNullGo(ptdesc->lptdesc);
            IfFailGo(CorSigToTypeDesc(pCTI, pClass, &pbSig[cbElem], pbNativeSig, cbNativeSig,
                                      &cb, ptdesc->lptdesc, ppool, true, true));
            cbElem += cb;

            // If a safe array element type is specified then check to see if we need
            // to update the typedesc's VT.
            if (SafeArrayElemVT != VT_EMPTY)
            {
                // @TODO(DM): Validate that the safe array element VT is valid for the sig.
                ptdesc->lptdesc->vt = (VARENUM)SafeArrayElemVT;
            }
        }
        break;

        case NATIVE_TYPE_FIXEDARRAY:
        {
            // NATIVE_TYPE_FIXEDARRAY is only allowed on fields.
            if (bMethodSig)
                IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));

            ptdesc->vt = VT_CARRAY;
            ptdesc->lpadesc = reinterpret_cast<ARRAYDESC*>(ppool->AllocZero(sizeof(ARRAYDESC)));
            IfNullGo(ptdesc->lpadesc);

            if (cbNativeSig != 0)
            {
                cb = CorSigUncompressData(pbNativeSig, &nativeCount);
                pbNativeSig += cb;
                cbNativeSig -= cb;
            }
            else
                nativeCount = 0;

            IfFailGo(CorSigToTypeDesc(pCTI, pClass, &pbSig[cbElem], pbNativeSig, cbNativeSig, 
                                      &cb, &ptdesc->lpadesc->tdescElem, ppool, bMethodSig, true));
            cbElem += cb;

            ptdesc->lpadesc->cDims = 1;
            ptdesc->lpadesc->rgbounds[0].cElements = nativeCount;
            ptdesc->lpadesc->rgbounds[0].lLbound = 0;
        }
        break;

        case NATIVE_TYPE_ARRAY:
        {
            // NATIVE_TYPE_ARRAY is followed by a type token.  If NATIVE_TYPE_MAX, no type is specified,
            //  but the token is there as filler.
            PCCOR_SIGNATURE pbNativeSig2=0;        // Pointer to the native sig, if any
            ULONG           cbNativeSig2=0;        // Count of bytes in native sig.
            if (cbNativeSig != 0)
            {   // If there is a native sig subtype, get it.
                CorSigUncompressData(pbNativeSig, &nativeElem);
                if (nativeElem != NATIVE_TYPE_MAX)
                {   // If the subtype is not NATIVE_TYPE_MAX, use it.
                    pbNativeSig2 = pbNativeSig;
                    cbNativeSig2 = cbNativeSig;
                }
            }
    
            ptdesc->vt = VT_PTR;
            ptdesc->lptdesc = reinterpret_cast<TYPEDESC*>(ppool->AllocZero(sizeof(TYPEDESC)));
            IfNullGo(ptdesc->lptdesc);
            IfFailGo(CorSigToTypeDesc(pCTI, pClass, &pbSig[cbElem], pbNativeSig2, cbNativeSig2,
                                      &cb, ptdesc->lptdesc, ppool, bMethodSig, true));
            cbElem += cb;
        }
        break;

        default:
            IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
        }
        break;

    case ELEMENT_TYPE_ARRAY:            // 0x14,
        if (bArrayType)
        {
            LPCUTF8 pName, pNS;
            pClass->GetMDImport()->GetNameOfTypeDef(pClass->GetCl(), &pName, &pNS);
            IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_NO_NESTED_ARRAYS, pName));
        }
        
        // Fields may only contain NATIVE_TYEE_FIXEDARRAY or NATIVE_TYPE_SAFEARRAY.  The marshaller doesn't
        //  support anything else.
        if ((!bMethodSig) && nativeElem && (nativeElem != NATIVE_TYPE_FIXEDARRAY) && (nativeElem != NATIVE_TYPE_SAFEARRAY))
            (ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_ARRAY_NEEDS_NT_FIXED));

        switch (nativeElem)
        {
        case 0:
        case NATIVE_TYPE_SAFEARRAY:
        {
            ULONG SafeArrayElemVT  = VT_EMPTY;

            // Retrieve the safe array element type.
            if (cbNativeSig != 0)
            {
                cb = CorSigUncompressData(pbNativeSig, &SafeArrayElemVT);
                pbNativeSig += cb;
                cbNativeSig -= cb;
            }

            ptdesc->vt = VT_SAFEARRAY;
            ptdesc->lptdesc = reinterpret_cast<TYPEDESC*>(ppool->AllocZero(sizeof(TYPEDESC)));
            IfNullGo(ptdesc->lptdesc);
            IfFailGo(CorSigToTypeDesc(pCTI, pClass, &pbSig[cbElem], pbNativeSig, cbNativeSig,
                                      &cb, ptdesc->lptdesc, ppool, bMethodSig, true));
            cbElem += cb;

            // If a safe array element type is specified then check to see if we need
            // to update the typedesc's VT.
            if (SafeArrayElemVT != VT_EMPTY)
            {
                // If this is not an array of user defined types then replace the
                // type determined the from the managed sig with the user specified one.
                if (ptdesc->lptdesc->vt != VT_USERDEFINED)
                {
                    // @TODO(DM): Validate that the safe array element VT is valid for the sig.
                    ptdesc->lptdesc->vt = (VARENUM)SafeArrayElemVT;
                }
                else
                {
                    // The sub type better make sense.
                    if (SafeArrayElemVT != VT_UNKNOWN && SafeArrayElemVT != VT_DISPATCH && SafeArrayElemVT != VT_RECORD)
                        IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
                }
            }
        }
        break;

        case NATIVE_TYPE_FIXEDARRAY:
        {
            // NATIVE_TYPE_FIXEDARRAY is only allowed on fields.
            if (bMethodSig)
                IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));

            ptdesc->vt = VT_CARRAY;
            ptdesc->lpadesc = reinterpret_cast<ARRAYDESC*>(ppool->AllocZero(sizeof(ARRAYDESC)));
            IfNullGo(ptdesc->lpadesc);

            if (cbNativeSig != 0)
            {
                cb = CorSigUncompressData(pbNativeSig, &nativeCount);
                pbNativeSig += cb;
                cbNativeSig -= cb;
            }
            else
                nativeCount = 0;

            IfFailGo(CorSigToTypeDesc(pCTI, pClass, &pbSig[cbElem], pbNativeSig, cbNativeSig, 
                                      &cb, &ptdesc->lpadesc->tdescElem, ppool, bMethodSig, true));
            cbElem += cb;

            ptdesc->lpadesc->cDims = 1;
            ptdesc->lpadesc->rgbounds[0].cElements = nativeCount;
            ptdesc->lpadesc->rgbounds[0].lLbound = 0;
        }
        break;

        case NATIVE_TYPE_ARRAY:
        {
            // NATIVE_TYPE_ARRAY is followed by a type token.  If NATIVE_TYPE_MAX, no type is specified,
            //  but the token is there as filler.
            PCCOR_SIGNATURE pbNativeSig2=0;        // Pointer to the native sig, if any
            ULONG           cbNativeSig2=0;        // Count of bytes in native sig.
            if (cbNativeSig != 0)
            {   // If there is a native sig subtype, get it.
                CorSigUncompressData(pbNativeSig, &nativeElem);
                if (nativeElem != NATIVE_TYPE_MAX)
                {   // If the subtype is not NATIVE_TYPE_MAX, use it.
                    pbNativeSig2 = pbNativeSig;
                    cbNativeSig2 = cbNativeSig;
                }
            }
    
            ptdesc->vt = VT_PTR;
            ptdesc->lptdesc = reinterpret_cast<TYPEDESC*>(ppool->AllocZero(sizeof(TYPEDESC)));
            IfNullGo(ptdesc->lptdesc);
            IfFailGo(CorSigToTypeDesc(pCTI, pClass, &pbSig[cbElem], pbNativeSig2, cbNativeSig2,
                                      &cb, ptdesc->lptdesc, ppool, bMethodSig, true));
            cbElem += cb;
        }
        break;

        default:
            IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_BAD_NATIVETYPE));
        }

        // Eat the array description.

        // Eat the rank.
        cbElem += CorSigUncompressData(pbSig+cbElem, &elem);
                                            
        // Count of ubounds, ubounds.
        cbElem += CorSigUncompressData(pbSig+cbElem, &elem);
        for (i=elem; i>0; --i)
            cbElem += CorSigUncompressData(pbSig+cbElem, &elem);

        // Count of lbounds, lbounds.
        cbElem += CorSigUncompressData(pbSig+cbElem, &elem);
        for (i=elem; i>0; --i)
            cbElem += CorSigUncompressData(pbSig+cbElem, &elem);

        break;

    case ELEMENT_TYPE_TYPEDBYREF:       // 0x16
        ptdesc->vt = VT_VARIANT;
        break;

    //------------------------------------------
    // This really should be the commented out 
    //  block following.
    case ELEMENT_TYPE_I:
        ptdesc->vt = VT_I4;
        break;
    case ELEMENT_TYPE_U:              // 0x19,
        ptdesc->vt = VT_UI4;
        break;
    //case ELEMENT_TYPE_I:              // 0x18,
    //case ELEMENT_TYPE_U:              // 0x19,
    //    // TYPEDESC is a void*.
    //    ptdesc->vt = VT_PTR;
    //    ptdesc->lptdesc = reinterpret_cast<TYPEDESC*>(ppool->AllocZero(sizeof(TYPEDESC)));
    //    IfNullGo(ptdesc->lptdesc);
    //    ptdesc->lptdesc->vt = VT_VOID;
    //    break;
    //------------------------------------------

    case ELEMENT_TYPE_R:                // 0x1A
        IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_AGNOST_SIGNATURE));
        break;

    case ELEMENT_TYPE_CMOD_REQD:        // 0x1F     // required C modifier : E_T_CMOD_REQD <mdTypeRef/mdTypeDef>
        IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_UNKNOWN_SIGNATURE));
        break;

    case ELEMENT_TYPE_CMOD_OPT:         // 0x20     // optional C modifier : E_T_CMOD_OPT <mdTypeRef/mdTypeDef>
        cb = CorSigUncompressToken(&pbSig[cbElem], &tkTypeRef);
        cbElem += cb;
    goto TryAgain;

    case ELEMENT_TYPE_FNPTR:
        {
        ptdesc->vt = VT_INT;

        // Eat the rest of the signature.
        SigPointer p(&pbSig[cbElem-1]);
        p.Skip();
        cbElem += (ULONG)(p.GetPtr() - &pbSig[cbElem]);  // Note I didn't use -1 here.
        }
        break;

    default:
        IfFailGo(ReportWarning(TLBX_E_BAD_SIGNATURE, TLBX_E_UNKNOWN_SIGNATURE));
        break;
    }

ErrExit:
    if (!FAILED(hr))
        *pcbElem = cbElem;
    return hr;
} // HRESULT TypeLibExporter::CorSigToTypeDesc()


//*****************************************************************************
// Get an HREFTYPE for an ITypeInfo, in the context of a ICreateTypeInfo2.
//*****************************************************************************
HRESULT TypeLibExporter::TokenToHref(
    ICreateTypeInfo2 *pCTI,              // Typeinfo being created.
    EEClass     *pClass,                // EEClass with the token.
    mdToken     tk,                     // The TypeRef to resolve.
    BOOL        bWarnOnUsingIUnknown,   // A flag indicating if we should warn on substituting IUnknown.
    HREFTYPE    *pHref)                 // Put HREFTYPE here.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr = S_OK;
    EEClass     *pRefdClass;            // EEClass object for referenced TypeDef.

    // Get the EEClass for the referenced class, and see if it is being converted.
    IfFailGo(LoadClass(pClass->GetModule(), tk, &pRefdClass));

    // If the type is not visible from COM then we return S_USEIUNKNOWN.
    if (!IsTypeVisibleFromCom(TypeHandle(pRefdClass->GetMethodTable())))
    {
        hr = S_USEIUNKNOWN;
        goto ErrExit;
    }

    IfFailGo(EEClassToHref(pCTI, pRefdClass, bWarnOnUsingIUnknown, pHref));

ErrExit:
    return hr;
} // HRESULT TypeLibExporter::TokenToHref()

//*****************************************************************************
// Call the resolver to export the typelib for an assembly.
//*****************************************************************************
HRESULT TypeLibExporter::ExportReferencedAssembly(
    Assembly    *pAssembly)
{
    HRESULT     hr;                     // A result.
    IUnknown    *pIAssembly = 0;        // Assembly as IP.
    ITypeLib    *pTLB = 0;              // Exported typelib.
    Thread      *pThread = GetThread(); // Current thread.

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();
    
    COMPLUS_TRY
    {
        // Switch to cooperative to get an object ref.
        pThread->DisablePreemptiveGC();
        
        // Invoke the callback to resolve the reference.
        OBJECTREF orAssembly=0;
        GCPROTECT_BEGIN(orAssembly)
        {
            orAssembly = pAssembly->GetExposedObject();

            pIAssembly = (ITypeLibImporterNotifySink*)GetComIPFromObjectRef(&orAssembly, ComIpType_Unknown, NULL);
        }
        GCPROTECT_END();
        
        // Switch back to preemptive GC to call out.
        pThread->EnablePreemptiveGC();
        
        hr = m_pNotify->ResolveRef(pIAssembly, (IUnknown**)&pTLB);
        
    }
    COMPLUS_CATCH
    {
        hr = SetupErrorInfo(GETTHROWABLE());
    }
    COMPLUS_END_CATCH
        
    if (pIAssembly)
        pIAssembly->Release();
    
    // If we got a typelib, store it on the assembly.
    if (pTLB)
        pAssembly->SetTypeLib(pTLB);
    
    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
} // HRESULT TypeLibExporter::ExportReferencedAssembly()

//*****************************************************************************
// Determine if a class represents a well-known interface, and return that
//  interface (from its real typelib) if it does.
//*****************************************************************************
HRESULT TypeLibExporter::GetWellKnownInterface(
    EEClass     *pClass,                // EEClass to check.
    ITypeInfo   **ppTI)                 // Put ITypeInfo here, if found.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr;                     // A result.
    long        rslt;                   // Registry function result.
    GUID        guid;                   // The EEClass guid.
    HKEY        hInterface=0;           // Registry key HKCR/Interface
    HKEY        hGuid=0;                // Registry key of .../{xxx...xxx}
    HKEY        hTlb=0;                 // Registry key of .../TypeLib
    WCHAR       wzGuid[40];             // Guid in string format.
    LONG        cbGuid;                 // Size of guid buffer.
    GUID        guidTlb;                // The typelib guid.
    ITypeLib    *pTLB=0;                // The ITypeLib.

    // Get the GUID for the class.  Will generate from name if no defined GUID,
    //  will also use signatures if interface.
    hr = SafeGetGuid(pClass, &guid, TRUE);
    IfFailGo(hr);

    GuidToLPWSTR(guid, wzGuid, lengthof(wzGuid));

    // Look up that interface in the registry.
    rslt = WszRegOpenKeyEx(HKEY_CLASSES_ROOT, L"Interface",0,KEY_READ, &hInterface);
    IfFailGo(HRESULT_FROM_WIN32(rslt));
    rslt = WszRegOpenKeyEx(hInterface, wzGuid,0, KEY_READ, &hGuid);
    IfFailGo(HRESULT_FROM_WIN32(rslt));
    rslt = WszRegOpenKeyEx(hGuid, L"TypeLib",0,KEY_READ, &hTlb);
    IfFailGo(HRESULT_FROM_WIN32(rslt));
    
    cbGuid = sizeof(wzGuid);
    rslt = WszRegQueryValue(hTlb, L"", wzGuid, &cbGuid);
    IfFailGo(HRESULT_FROM_WIN32(rslt));
    CLSIDFromString(wzGuid, &guidTlb);

    IfFailGo(LoadRegTypeLib(guidTlb, -1,-1, 0, &pTLB));

    IfFailGo(pTLB->GetTypeInfoOfGuid(guid, ppTI));   

ErrExit:
    if (hTlb)
        RegCloseKey(hTlb);
    if (hGuid)
        RegCloseKey(hGuid);
    if (hInterface)
        RegCloseKey(hInterface);
    if (pTLB)
        pTLB->Release();
    
    return hr;
} // HRESULT TypeLibExporter::GetWellKnownInterface()

//*****************************************************************************
// Get an HREFTYPE for an ITypeInfo, in the context of a ICreateTypeInfo2.
//*****************************************************************************
HRESULT TypeLibExporter::EEClassToHref( // S_OK or error.
    ICreateTypeInfo2 *pCTI,             // Typeinfo being created.
    EEClass     *pClass,                // The EEClass * to resolve.
    BOOL        bWarnOnUsingIUnknown,   // A flag indicating if we should warn on substituting IUnknown.
    HREFTYPE    *pHref)                 // Put HREFTYPE here.
{
    HRESULT     hr=S_OK;                // A result.
    ITypeInfo   *pTI=0;                 // A TypeInfo; maybe for TypeDef, maybe for TypeRef.
    int         bUseIUnknown=false;     // Use IUnknown (if so, don't release pTI)?
    int         bUseIUnknownWarned=false; // If true, used IUnknown, but already issued a more specific warning.
    ITypeInfo   *pTIDef=0;              // A different typeinfo; default for pTI.
    CExportedTypesInfo sExported;       // Cached ICreateTypeInfo pointers.
    CExportedTypesInfo *pExported;      // Pointer to found or new cached pointers.
    CHrefOfClassHashKey sLookup;        // Hash structure to lookup.
    CHrefOfClassHashKey *pFound;        // Found structure.
    bool        bImportedAssembly;      // The assembly containing pClass is imported.

    // See if we already know this EEClass' href.
    sLookup.pClass = pClass;
    if ((pFound=m_HrefOfClassHash.Find(&sLookup)) != NULL)
    {
        *pHref = pFound->href;
        if (*pHref == m_hIUnknown)
            return S_USEIUNKNOWN;
        return S_OK;
    }

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    // See if the class is in the export list.
    sExported.pClass = pClass;
    pExported = m_Exports.Find(&sExported);

    // If not in the exported assembly, possibly it was injected?
    if (pExported == 0)
    {
        pExported = m_InjectedExports.Find(&sExported);
    }
    
    // Is there an export for this class?
    if (pExported)
    {   // Yes.  If there is a default interface ICreateTypeInfo, use it.
        if (pExported->pCTIDefault)
            IfFailPost(pExported->pCTIDefault->QueryInterface(IID_ITypeInfo, (void**)&pTI));
        else
        {   
            // For interfaces and value types (and enums), just use the typeinfo.
            if (pClass->IsValueClass() || pClass->IsEnum() || pClass->HasLayout())
            {
                // No default interface, so use the class itself.     
                if (pExported->pCTI)
                    IfFailPost(pExported->pCTI->QueryInterface(IID_ITypeInfo, (void**)&pTI));
            }
            else
            if (!pClass->IsInterface())
            {   // If there is an explicit default interface, get the class for it.
                TypeHandle hndDefItfClass;
                DefaultInterfaceType DefItfType;
                IfFailGo(TryGetDefaultInterfaceForClass(TypeHandle(pClass->GetMethodTable()), &hndDefItfClass, &DefItfType));
                switch (DefItfType)
                {
                    case DefaultInterfaceType_Explicit:
                    {
                        _ASSERTE(!hndDefItfClass.IsNull());

                        // Recurse to get the href for the default interface class.
                        hr = EEClassToHref(pCTI, hndDefItfClass.GetClass(), bWarnOnUsingIUnknown, pHref);
                        // Done.  Note that the previous call will have cached the href for 
                        //  the default interface class.  As this function exits, it will
                        //  also cache the SAME href for this class.
                        goto ErrExit;
                    }

                    case DefaultInterfaceType_AutoDual:
                    {
                        _ASSERTE(!hndDefItfClass.IsNull());

                        if (hndDefItfClass.GetClass() != pClass)
                        {
                            // Recurse to get the href for the default interface class.
                            hr = EEClassToHref(pCTI, hndDefItfClass.GetClass(), bWarnOnUsingIUnknown, pHref);
                            // Done.  Note that the previous call will have cached the href for 
                            //  the default interface class.  As this function exits, it will
                            //  also cache the SAME href for this class.
                            goto ErrExit;
                        }

                        // No default interface, so use the class itself.     
                        _ASSERTE(pExported->pCTI);
                        IfFailPost(pExported->pCTI->QueryInterface(IID_ITypeInfo, (void**)&pTI));
                        break;
                    }

                    case DefaultInterfaceType_IUnknown:
                    case DefaultInterfaceType_BaseComClass:
                    {
                        pTI = m_pIUnknown, bUseIUnknown=true;
                        break;
                    }

                    case DefaultInterfaceType_AutoDispatch:
                    {
                        pTI = m_pIUnknown, bUseIUnknown=true;
                        break;
                    }

                    default:
                    {
                        _ASSERTE(!"Invalid default interface type!");
                        hr = E_FAIL;
                        break;
                    }
                }
            }
            else
            {   // This is an interface, so use the typeinfo for the interface, if there is one.
                if (pExported->pCTI)
                    IfFailPost(pExported->pCTI->QueryInterface(IID_ITypeInfo, (void**)&pTI));
            }
        }
        if (pTI == 0)
        {   // This is a class from the module/assembly, yet it is not being exported.
            
            // Whatever happens, the result is OK.
            hr = S_OK;
            
            if (pClass->IsComImport())
            {   // If it is an imported type, get an href to it.
                GetWellKnownInterface(pClass, &pTI);
            }
            // If still didn't get a TypeInfo, use IUnknown.
            if (pTI == 0)
                pTI = m_pIUnknown, bUseIUnknown=true;
        }
    }
    else
    {   // Not local.  Try to get from the class' module's typelib.
        hr = GetITypeInfoForEEClass(pClass, &pTI, false/* interface, not coclass */, false/* do not create */, m_flags);
        // If getting the typeinfo from the class itself failed, there are 
        //  several possibilities:
        //  - typelib didn't exist, and couldn't be created.
        //  - typelib did exist, but didn't contain the typeinfo.
        // We can create a local (to the exported typelib) copy of the 
        //  typeinfo, and get a reference to that.
        // However, we don't want to export the whole tree into this typelib,
        //  so we only create the typeinfo if the typelib existed  but the
        // typeinfo wasn't found and the assembly is not an imported assembly.
        bImportedAssembly = (pClass->GetAssembly()->GetManifestImport()->GetCustomAttributeByName(TokenFromRid(1, mdtAssembly), INTEROP_IMPORTEDFROMTYPELIB_TYPE, 0, 0) == S_OK);
        if (FAILED(hr) && hr != TYPE_E_ELEMENTNOTFOUND && !bImportedAssembly)
        {
            // Invoke the callback to resolve the reference.
            
            Assembly *pAssembly = pClass->GetAssembly();
            
            hr = ExportReferencedAssembly(pAssembly);
            
            if (SUCCEEDED(hr))
                hr = GetITypeInfoForEEClass(pClass, &pTI, false/* interface, not coclass */, false/* do not create */, m_flags);
        }
        
        if (hr == TYPE_E_ELEMENTNOTFOUND)
        {   
            if (pClass->IsComImport())
            {   // If it is an imported type, get an href to it.
                
                // Whatever happens, the result is OK.
                hr = S_OK;

                GetWellKnownInterface(pClass, &pTI);
                // If still didn't get a TypeInfo, use IUnknown.
                if (pTI == 0)
                    pTI = m_pIUnknown, bUseIUnknown=true;
            }
            else
            {   // Convert the single typedef from the other scope.
                IfFailGo(ConvertOneTypeDef(pClass));
                
                // Now that the type has been injected, recurse to let the default-interface code run.
                IfFailGo(EEClassToHref(pCTI, pClass, bWarnOnUsingIUnknown, pHref));
                
                // This class should already have been cached by the recursive call.  Don't want to add
                //  it again.
                goto ErrExit2;
            }
        }
        else if (FAILED(hr))
        {
            DefineFullyQualifiedNameForClassWOnStack();
            LPWSTR szName = GetFullyQualifiedNameForClassNestedAwareW(pClass);
            if (hr == TLBX_W_LIBNOTREGISTERED)
            {   // The imported typelib is not registered on this machine.  Give a warning, and substitute IUnknown.
                ReportEvent(NOTIF_CONVERTWARNING, hr, szName, pClass->GetAssembly()->GetSecurityModule()->GetFileName());
                hr = S_OK;
                pTI = m_pIUnknown;
                bUseIUnknown = true;
                bUseIUnknownWarned = true;
            }
            else if (hr == TLBX_E_CANTLOADLIBRARY)
            {   // The imported typelib is registered, but can't be loaded.  Corrupt?  Missing?
                IfFailGo(TlbPostError(hr, szName, pClass->GetAssembly()->GetSecurityModule()->GetFileName()));
            }
            IfFailGo(hr);
        }
    }

    // Make sure we could resolve the typeinfo.
    if (!pTI)
        IfFailPost(TYPE_E_ELEMENTNOTFOUND);

    // Assert that the containing typelib for pContainer is the typelib being created.
#if defined(_DEBUG)
    {
        ITypeInfo *pTI=0;
        ITypeLib *pTL=0;
        ITypeLib *pTLMe=0;
        UINT ix;
        pCTI->QueryInterface(IID_ITypeInfo, (void**)&pTI);
        m_pICreateTLB->QueryInterface(IID_ITypeLib, (void**)&pTLMe);
        pTI->GetContainingTypeLib(&pTL, &ix);
        _ASSERTE(pTL == pTLMe);
        pTL->Release();
        pTLMe->Release();
        pTI->Release();
    }
#endif

    // If there is an ITypeInfo, convert to HREFTYPE.
    if (pTI)
    {
        if (pTI != m_pIUnknown)
        {
            // Resolve to default.
            if (pTIDef)
                hr = S_OK;  // Already have default.
            else
                IfFailGo(GetDefaultInterfaceForCoclass(pTI, &pTIDef));
            if (hr == S_OK)
                hr = pCTI->AddRefTypeInfo(pTIDef, pHref);
            else
                hr = pCTI->AddRefTypeInfo(pTI, pHref);
        }
        else
        {   // pTI == m_pIUnknown
            if (m_hIUnknown == -1)
                hr = pCTI->AddRefTypeInfo(pTI, &m_hIUnknown);
            *pHref = m_hIUnknown;
        }
    }
    
ErrExit:
    // If we got the href...
    if (hr == S_OK)
    {   // Save for later use.
        IfNullGo(pFound=m_HrefOfClassHash.Add(&sLookup));
        //printf("c:%010d\n", pClass);
        pFound->pClass = pClass;
        pFound->href = *pHref;
    }

    // If substituting IUnknown, give a warning.
    if (hr == S_OK && bUseIUnknown && bWarnOnUsingIUnknown && !bUseIUnknownWarned)
    {
        DefineFullyQualifiedNameForClassWOnStack();
        LPWSTR szName = GetFullyQualifiedNameForClassNestedAwareW(pClass);
        ReportWarning(S_OK, TLBX_I_USEIUNKNOWN, szName);
    }
    
ErrExit2:    
    if (pTI && !bUseIUnknown)
        pTI->Release();

    if (pTIDef)
        pTIDef->Release();

    if (hr == S_OK && bUseIUnknown)
        hr = S_USEIUNKNOWN;

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
} // HRESULT TypeLibExporter::EEClassToHref()

//*****************************************************************************
// Retrieve an HRef to the a type defined in StdOle.
//*****************************************************************************
HRESULT TypeLibExporter::StdOleTypeToHRef(ICreateTypeInfo2 *pCTI, REFGUID rGuid, HREFTYPE *pHref)
{
    HRESULT hr = S_OK;
    ITypeLib *pITLB = NULL;
    ITypeInfo *pITI = NULL;
    MEMBERID MemID = 0;
    USHORT cFound = 0;

    IfFailPost(LoadRegTypeLib(LIBID_STDOLE2, -1, -1, 0, &pITLB));
    IfFailPost(pITLB->GetTypeInfoOfGuid(rGuid, &pITI));
    IfFailPost(pCTI->AddRefTypeInfo(pITI, pHref));

ErrExit:
    if (pITLB)
        pITLB->Release();
    if (pITI)
        pITI->Release();
    return hr;
} // HRESULT TypeLibExporter::ColorToHRef()

//*****************************************************************************
// Given a TypeDef's flags, determine the proper TYPEKIND.
//*****************************************************************************
TYPEKIND TypeLibExporter::TKindFromClass(
    EEClass     *pClass)                // EEClass.
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    ULONG       ulIface = ifDual;       // Is this interface [dual], IUnknown, or DISPINTERFACE.
    
    if (pClass->IsInterface())
    {
        // IDispatch or IUnknown derived?
        pClass->GetMDImport()->GetIfaceTypeOfTypeDef(pClass->GetCl(), &ulIface);
        if (ulIface == ifDispatch)
            return TKIND_DISPATCH;
        return TKIND_INTERFACE;
    }
    
    if (pClass->IsEnum())
        return TKIND_ENUM;

    if (pClass->IsValueClass() || pClass->HasLayout())
    {
        HRESULT     hr = S_OK;              // A result.
        TYPEKIND    tkResult=TKIND_RECORD;  // The resulting typekind.
        HENUMInternal eFDi;                 // To enum fields.
        mdFieldDef  fd;                     // A Field def.
        ULONG       cFD;                    // Count of fields.
        ULONG       iFD=0;                  // Loop control.
        ULONG       ulOffset;               // Field offset.
        bool        bNonZero=false;         // Found any non-zero?
        MD_CLASS_LAYOUT sLayout;            // For enumerating layouts.

        // Get an enumerator for the FieldDefs in the TypeDef.  Only need the counts.
        IfFailGo(pClass->GetMDImport()->EnumInit(mdtFieldDef, pClass->GetCl(), &eFDi));
        cFD = pClass->GetMDImport()->EnumGetCount(&eFDi);

        // Get an enumerator for the class layout.
        IfFailGo(pClass->GetMDImport()->GetClassLayoutInit(pClass->GetCl(), &sLayout));

        // Enumerate the layout.
        while (pClass->GetMDImport()->GetClassLayoutNext(&sLayout, &fd, &ulOffset) == S_OK)
        {
            if (ulOffset != 0)
            {
                bNonZero = true;
                break;
            }
            ++iFD;
        }

        // If there were fields, all had layout, and all layouts are zero, call it a union.
        if (cFD > 0 && iFD == cFD && !bNonZero)
            tkResult = TKIND_UNION;

    ErrExit:
        pClass->GetMDImport()->EnumClose(&eFDi);
        return tkResult;
    }
    
    return TKIND_COCLASS;

} // TYPEKIND TypeLibExporter::TKindFromClass()

//*****************************************************************************
// Generate a HREFTYPE in the output TypeLib for a TypeInfo.
//*****************************************************************************
HRESULT TypeLibExporter::GetRefTypeInfo(
    ICreateTypeInfo2   *pContainer, 
    ITypeInfo   *pReferenced, 
    HREFTYPE    *pHref)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    HRESULT     hr;                     // A result.
    CHrefOfTIHashKey sLookup;               // Hash structure to lookup.
    CHrefOfTIHashKey *pFound;               // Found structure.

    // See if we already know this TypeInfo.
    sLookup.pITI = pReferenced;
    if ((pFound=m_HrefHash.Find(&sLookup)) != NULL)
    {
        *pHref = pFound->href;
        return S_OK;
    }

    // Assert that the containing typelib for pContainer is the typelib being created.
#if defined(_DEBUG)
    {
    ITypeInfo *pTI=0;
    ITypeLib *pTL=0;
    ITypeLib *pTLMe=0;
    UINT ix;
    pContainer->QueryInterface(IID_ITypeInfo, (void**)&pTI);
    m_pICreateTLB->QueryInterface(IID_ITypeLib, (void**)&pTLMe);
    pTI->GetContainingTypeLib(&pTL, &ix);
    _ASSERTE(pTL == pTLMe);
    pTL->Release();
    pTLMe->Release();
    pTI->Release();
    }
#endif

    // Haven't seen it -- add the href.
    // NOTE: This code assumes that hreftypes are per-typelib.
    IfFailPost(pContainer->AddRefTypeInfo(pReferenced, pHref));

    // Save for later use.
    IfNullGo(pFound=m_HrefHash.Add(&sLookup));
    // printf("t:%010d\n", pReferenced);
    pFound->pITI = pReferenced;
    pFound->href = *pHref;
    pReferenced->AddRef();

ErrExit:
    return (hr);
} // HRESULT TypeLibExporter::GetRefTypeInfo()

//*****************************************************************************
// Stolen from classlib.
//*****************************************************************************
double _TicksToDoubleDate(const __int64 ticks)
{
    const INT64 MillisPerSecond = 1000;
    const INT64 MillisPerDay = MillisPerSecond * 60 * 60 * 24;
    const INT64 TicksPerMillisecond = 10000;
    const INT64 TicksPerSecond = TicksPerMillisecond * 1000;
    const INT64 TicksPerMinute = TicksPerSecond * 60;
    const INT64 TicksPerHour = TicksPerMinute * 60;
    const INT64 TicksPerDay = TicksPerHour * 24;
    const int DaysPer4Years = 365 * 4 + 1;
    const int DaysPer100Years = DaysPer4Years * 25 - 1;
    const int DaysPer400Years = DaysPer100Years * 4 + 1;
    const int DaysTo1899 = DaysPer400Years * 4 + DaysPer100Years * 3 - 367;
    const INT64 DoubleDateOffset = DaysTo1899 * TicksPerDay;
    const int DaysTo10000 = DaysPer400Years * 25 - 366;
    const INT64 MaxMillis = DaysTo10000 * MillisPerDay;
    const int DaysPerYear = 365; // non-leap year
    const INT64 OADateMinAsTicks = (DaysPer100Years - DaysPerYear) * TicksPerDay;

    if (ticks == 0)
         return 0.0;  // Returns OleAut's zero'ed date ticks.
    if (ticks < OADateMinAsTicks)
         return 0.0;
     // Currently, our max date == OA's max date (12/31/9999), so we don't 
     // need an overflow check in that direction.
     __int64 millis = (ticks  - DoubleDateOffset) / TicksPerMillisecond;
     if (millis < 0) 
     {
         __int64 frac = millis % MillisPerDay;
         if (frac != 0) millis -= (MillisPerDay + frac) * 2;
     }
     return (double)millis / MillisPerDay;
} // double _TicksToDoubleDate()

//*****************************************************************************
// Implementation of a hashed ITypeInfo to HREFTYPE association.
//*****************************************************************************
void TypeLibExporter::CHrefOfTIHash::Clear()
{
    CHrefOfTIHashKey *p;
#if defined(_DEBUG)
    // printf("ITypeInfo to HREFTYPE cache: %d buckets, %d used, %d collisions\n", Buckets(), Count(), Collisions());
#endif
    for (p=GetFirst();  p;  p=GetNext(p))
    {
        if (p->pITI)
            p->pITI->Release();
    }
    CClosedHash<class CHrefOfTIHashKey>::Clear();
} // void TypeLibExporter::CHrefOfTIHash::Clear()

unsigned long TypeLibExporter::CHrefOfTIHash::Hash(const CHrefOfTIHashKey *pData)
{
    // Tbe pointers are at least 4-byte aligned, so ignore bottom two bits.
    return (unsigned long)((size_t)(pData->pITI)>>2); // @TODO WIN64 - pointer truncation
} // unsigned long TypeLibExporter::CHrefOfTIHash::Hash()

unsigned long TypeLibExporter::CHrefOfTIHash::Compare(const CHrefOfTIHashKey *p1, CHrefOfTIHashKey *p2)
{
    if (p1->pITI == p2->pITI)
        return (0);
    return (1);
} // unsigned long TypeLibExporter::CHrefOfTIHash::Compare()

TypeLibExporter::CHrefOfTIHash::ELEMENTSTATUS TypeLibExporter::CHrefOfTIHash::Status(CHrefOfTIHashKey *p)
{
    if (p->pITI == reinterpret_cast<ITypeInfo*>(FREE))
        return (FREE);
    if (p->pITI == reinterpret_cast<ITypeInfo*>(DELETED))
        return (DELETED);
    return (USED);
} // TypeLibExporter::CHrefOfTIHash::ELEMENTSTATUS TypeLibExporter::CHrefOfTIHash::Status()

void TypeLibExporter::CHrefOfTIHash::SetStatus(CHrefOfTIHashKey *p, ELEMENTSTATUS s)
{
    p->pITI = reinterpret_cast<ITypeInfo*>(s);
} // void TypeLibExporter::CHrefOfTIHash::SetStatus()

void *TypeLibExporter::CHrefOfTIHash::GetKey(CHrefOfTIHashKey *p)
{
    return &p->pITI;
} // void *TypeLibExporter::CHrefOfTIHash::GetKey()


//*****************************************************************************
// Implementation of a hashed EEClass* to HREFTYPE association.
//*****************************************************************************
void TypeLibExporter::CHrefOfClassHash::Clear()
{
#if defined(_DEBUG)
    // printf("Class to HREFTYPE cache: %d buckets, %d used, %d collisions\n", Buckets(), Count(), Collisions());
#endif
    CClosedHash<class CHrefOfClassHashKey>::Clear();
} // void TypeLibExporter::CHrefOfClassHash::Clear()

unsigned long TypeLibExporter::CHrefOfClassHash::Hash(const CHrefOfClassHashKey *pData)
{
    // Tbe pointers are at least 4-byte aligned, so ignore bottom two bits.
    return (unsigned long)((size_t)(pData->pClass)>>2); // @TODO WIN64 - pointer truncation
} // unsigned long TypeLibExporter::CHrefOfClassHash::Hash()

unsigned long TypeLibExporter::CHrefOfClassHash::Compare(const CHrefOfClassHashKey *p1, CHrefOfClassHashKey *p2)
{
    if (p1->pClass == p2->pClass)
        return (0);
    return (1);
} // unsigned long TypeLibExporter::CHrefOfClassHash::Compare()

TypeLibExporter::CHrefOfClassHash::ELEMENTSTATUS TypeLibExporter::CHrefOfClassHash::Status(CHrefOfClassHashKey *p)
{
    if (p->pClass == reinterpret_cast<EEClass*>(FREE))
        return (FREE);
    if (p->pClass == reinterpret_cast<EEClass*>(DELETED))
        return (DELETED);
    return (USED);
} // TypeLibExporter::CHrefOfClassHash::ELEMENTSTATUS TypeLibExporter::CHrefOfClassHash::Status()

void TypeLibExporter::CHrefOfClassHash::SetStatus(CHrefOfClassHashKey *p, ELEMENTSTATUS s)
{
    p->pClass = reinterpret_cast<EEClass*>(s);
} // void TypeLibExporter::CHrefOfClassHash::SetStatus()

void *TypeLibExporter::CHrefOfClassHash::GetKey(CHrefOfClassHashKey *p)
{
    return &p->pClass;
} // void *TypeLibExporter::CHrefOfClassHash::GetKey()


//*****************************************************************************
// Implementation of a hashed EEClass* to conversion information association.
//*****************************************************************************
void TypeLibExporter::CExportedTypesHash::Clear()
{
#if defined(_DEBUG)
//    printf("Class to ICreateTypeInfo cache: %d buckets, %d used, %d collisions\n", Buckets(), Count(), Collisions());
#endif
    // Iterate over entries and free pointers.
    CExportedTypesInfo *pData;
    pData = GetFirst();
    while (pData)
    {
        SetStatus(pData, DELETED);
        pData = GetNext(pData);
    }

    CClosedHash<class CExportedTypesInfo>::Clear();
} // void TypeLibExporter::CExportedTypesHash::Clear()

unsigned long TypeLibExporter::CExportedTypesHash::Hash(const CExportedTypesInfo *pData)
{
    // Tbe pointers are at least 4-byte aligned, so ignore bottom two bits.
    return (unsigned long)((size_t)(pData->pClass)>>2); // @TODO WIN64 - pointer truncation
} // unsigned long TypeLibExporter::CExportedTypesHash::Hash()

unsigned long TypeLibExporter::CExportedTypesHash::Compare(const CExportedTypesInfo *p1, CExportedTypesInfo *p2)
{
    if (p1->pClass == p2->pClass)
        return (0);
    return (1);
} // unsigned long TypeLibExporter::CExportedTypesHash::Compare()

TypeLibExporter::CExportedTypesHash::ELEMENTSTATUS TypeLibExporter::CExportedTypesHash::Status(CExportedTypesInfo *p)
{
    if (p->pClass == reinterpret_cast<EEClass*>(FREE))
        return (FREE);
    if (p->pClass == reinterpret_cast<EEClass*>(DELETED))
        return (DELETED);
    return (USED);
} // TypeLibExporter::CExportedTypesHash::ELEMENTSTATUS TypeLibExporter::CExportedTypesHash::Status()

void TypeLibExporter::CExportedTypesHash::SetStatus(CExportedTypesInfo *p, ELEMENTSTATUS s)
{
    // If deleting a used entry, free the pointers.
    if (s == DELETED && Status(p) == USED)
    {
        if (p->pCTI) p->pCTI->Release(), p->pCTI=0;
        if (p->pCTIDefault) p->pCTIDefault->Release(), p->pCTIDefault=0;
    }
    p->pClass = reinterpret_cast<EEClass*>(s);
} // void TypeLibExporter::CExportedTypesHash::SetStatus()

void *TypeLibExporter::CExportedTypesHash::GetKey(CExportedTypesInfo *p)
{
    return &p->pClass;
} // void *TypeLibExporter::CExportedTypesHash::GetKey()

HRESULT TypeLibExporter::CExportedTypesHash::InitArray()
{
    HRESULT     hr = S_OK;
    CExportedTypesInfo *pData;       // For iterating the entries.
    
    // Make room for the data.
    m_iCount = 0;
    IfNullGo(m_Array = new CExportedTypesInfo*[Base::Count()]);
    
    // Fill the array.
    pData = GetFirst();
    while (pData)
    {
        m_Array[m_iCount++] = pData;
        pData = GetNext(pData);
    }
    
ErrExit:
    return hr;        
} // HRESULT TypeLibExporter::CExportedTypesHash::InitArray()

void TypeLibExporter::CExportedTypesHash::SortByName()
{
    CSortByName sorter(m_Array, (int)m_iCount);
    sorter.Sort();
} // void TypeLibExporter::CExportedTypesHash::SortByName()

void TypeLibExporter::CExportedTypesHash::SortByToken()
{
     CSortByToken sorter(m_Array, (int)m_iCount);
     sorter.Sort();
} // void TypeLibExporter::CExportedTypesHash::SortByToken()

int TypeLibExporter::CExportedTypesHash::CSortByToken::Compare(
    CExportedTypesInfo **p1,
    CExportedTypesInfo **p2)
{
    EEClass *pC1 = (*p1)->pClass;
    EEClass *pC2 = (*p2)->pClass;
    // Compare scopes.
    if (pC1->GetMDImport() < pC2->GetMDImport())
        return -1;
    if (pC1->GetMDImport() > pC2->GetMDImport())
        return 1;
    // Same scopes, compare tokens.
    if (pC1->GetCl() < pC2->GetCl())
        return -1;
    if (pC1->GetCl() > pC2->GetCl())
        return 1;
    // Hmmm.  Same class.
    return 0;
} // int TypeLibExporter::CExportedTypesHash::CSortByToken::Compare()

int TypeLibExporter::CExportedTypesHash::CSortByName::Compare(
    CExportedTypesInfo **p1,
    CExportedTypesInfo **p2)
{
    int iRslt;                          // A compare result.
    
    EEClass *pC1 = (*p1)->pClass;
    EEClass *pC2 = (*p2)->pClass;
    // Ignore scopes.  Need to see name collisions across scopes.
    // Same scopes, compare names.
    LPCSTR pName1, pNS1;
    LPCSTR pName2, pNS2;
    pC1->GetMDImport()->GetNameOfTypeDef(pC1->GetCl(), &pName1, &pNS1);
    pC2->GetMDImport()->GetNameOfTypeDef(pC2->GetCl(), &pName2, &pNS2);
    // Compare case-insensitive, because we want different capitalizations to sort together.
    iRslt = _stricmp(pName1, pName2);
    if (iRslt)
        return iRslt;
    // If names are spelled the same, ignoring capitalization, sort by namespace.
    //  We will attempt to use namespace for disambiguation.
    iRslt = _stricmp(pNS1, pNS2);
    return iRslt;
} // int TypeLibExporter::CExportedTypesHash::CSortByName::Compare()

// eof ------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\threads.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// THREADS.H -
//
// Currently represents a logical and physical COM+ thread.  Later, these concepts
// will be separated.
//

#ifndef __threads_h__
#define __threads_h__

#include "vars.hpp"
#include "util.hpp"
#include "EventStore.hpp"

#include "regdisp.h"
#include "mscoree.h"
#include <member-offset-info.h>

class     Thread;
class     ThreadStore;
class     MethodDesc;
class     Context;
struct    PendingSync;
class     ComPlusWrapperCache;
class     AppDomain;
class     NDirect;
class     Frame;
class     ThreadBaseObject;
class     LocalDataStore;
class     AppDomainStack;

#include "stackwalk.h"
#include "log.h"
#include "gc.h"
#include "stackingallocator.h"
#include "excep.h"


#define INVALID_THREAD_PRIORITY -1

// Capture all the synchronization requests, for debugging purposes
#if defined(_DEBUG) && defined(TRACK_SYNC)

// Each thread has a stack that tracks all enter and leave requests
struct Dbg_TrackSync
{
    virtual void EnterSync    (int caller, void *pAwareLock) = 0;
    virtual void LeaveSync    (int caller, void *pAwareLock) = 0;
};

void EnterSyncHelper    (int caller, void *pAwareLock);
void LeaveSyncHelper    (int caller, void *pAwareLock);

#endif  // TRACK_SYNC

// Special versions of GetThreadContext and SetThreadContext used to workaround
// a Win9X bug. See threads.cpp for more details.
extern BOOL (*EEGetThreadContext)(Thread *pThread, CONTEXT *pContext);
extern BOOL (*EESetThreadContext)(Thread *pThread, const CONTEXT *pContext);

//****************************************************************************************
// This is the type of the start function of a redirected thread pulled from a
// HandledJITCase during runtime suspension
typedef void (__stdcall *PFN_REDIRECTTARGET)();

// This is the type of a 'start' function to which a new thread can be dispatched
typedef ULONG (__stdcall * ThreadStartFunction) (void *args);

// Used to capture information about the state of execution of a *SUSPENDED*
// thread.
struct ExecutionState;

// Access to the Thread object in the TLS.
extern "C" Thread* (*GetThread)();

// Access to the Thread object in the TLS.
extern AppDomain* (*GetAppDomain)();

// Access to the current context in the TLS.  (It's done this way because it
// currently lives in the Thread object, but may move into the TLS for speed and
// interoperability with COM).
extern Context* (*GetCurrentContext)();

// manifest constant for waiting in the exposed classlibs
const INT32 INFINITE_TIMEOUT = -1;

// Describes the weird argument sets during hijacking
struct HijackObjectArgs;
struct HijackScalarArgs;

/***************************************************************************/
// Public enum shared between thread and threadpool
// These are two kinds of threadpool thread that the threadpool mgr needs 
// to keep track of
enum ThreadpoolThreadType
{
    WorkerThread,
    CompletionPortThread
};
//***************************************************************************
// Public functions
//
//      Thread* GetThread()             - returns current Thread
//      Thread* SetupThread()           - creates new Thread.
//      Thread* SetupUnstartedThread()  - creates new unstarted Thread which
//                                        (obviously) isn't in a TLS.
//      void    DestroyThread()         - the underlying logical thread is going
//                                        away.
//      void    DetachThread()          - the underlying logical thread is going
//                                        away but we don't want to destroy it yet.
//
// Public functions for ASM code generators
//
//      int GetThreadTLSIndex()         - returns TLS index used to point to Thread
//      int GetAppDomainTLSIndex()      - returns TLS index used to point to AppDomain
//
// Public functions for one-time init/cleanup
//
//      BOOL InitThreadManager()      - onetime init
//      void TerminateThreadManager() - onetime cleanup
//
// Public functions for taking control of a thread at a safe point
//
//      VOID OnStubScalarTripThread()   - stub is returning non-object ref to caller
//      VOID OnStubObjectTripThread()   - stub is returning object ref to caller
//      VOID OnHijackObjectTripThread() - we've hijacked a JIT object-ref return
//      VOID OnHijackScalarTripThread() - we've hijacked a JIT non-object ref return
//
//***************************************************************************


//***************************************************************************
// Public functions
//***************************************************************************

//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
Thread* SetupThread();
Thread* SetupThreadPoolThread(ThreadpoolThreadType tpType);
Thread* SetupUnstartedThread();
void    DestroyThread(Thread *th);
void    DetachThread(Thread *th);




//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
DWORD GetThreadTLSIndex();
DWORD GetAppDomainTLSIndex();


//---------------------------------------------------------------------------
// One-time initialization. Called during Dll initialization.
//---------------------------------------------------------------------------
BOOL  InitThreadManager();


//---------------------------------------------------------------------------
// One-time cleanup. Called during Dll cleanup.
//---------------------------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
void  TerminateThreadManager();
#endif /* SHOULD_WE_CLEANUP */


// When we want to take control of a thread at a safe point, the thread will
// eventually come back to us in one of the following trip functions:

void OnStubObjectTripThread();      // stub is returning an objref to caller
void OnStubInteriorPointerTripThread();      // stub is returning a byref
void OnStubScalarTripThread();      // stub is returning anything but an objref
void OnHijackObjectTripThread();    // hijacked JIT code is returning an objectref
void OnHijackInteriorPointerTripThread();    // hijacked JIT code is returning a byref
void OnHijackScalarTripThread();    // hijacked JIT code is returning a non-objectref
void OnDebuggerTripThread();        // thread was asked to stop for the debugger

// The following were used entirely by a hijacking pathway, but it turns out that
// context proxies need identical services to protect their return values if they
// trip during an unwind.  Note that OnStubObjectWorker returns an OBJECTREF rather
// than a "void *" but we cannot declare it as such because structs are passed as
// secret arguments.
void * __cdecl OnStubObjectWorker(OBJECTREF oref);
void   __cdecl CommonTripThread();


// When we resume a thread at a new location, to get an exception thrown, we have to
// pretend the exception originated elsewhere.
void ThrowControlForThread();


// RWLock state inside TLS
class CRWLock;
typedef struct tagLockEntry
{
    tagLockEntry *pNext;    // next entry
    tagLockEntry *pPrev;    // prev entry
    DWORD dwULockID;
    DWORD dwLLockID;        // owning lock
    WORD wReaderLevel;      // reader nesting level
} LockEntry;

// Stack of AppDomains executing on the current thread. Used in security optimization to avoid stackwalks
#ifdef _DEBUG
#define MAX_APPDOMAINS_TRACKED      2
#else
#define MAX_APPDOMAINS_TRACKED      10
#endif



//
// Macros to help manage the GC state
//

#define BEGIN_ENSURE_COOPERATIVE_GC()                           \
    {                                                           \
        DEBUG_ASSURE_NO_RETURN_IN_THIS_BLOCK                    \
        Thread *__pThread = GetThread();                        \
        _ASSERTE(__pThread != NULL &&                           \
                 "The current thread is not known by the EE");  \
        BOOL __fToggle = !__pThread->PreemptiveGCDisabled();    \
        if (__fToggle) __pThread->DisablePreemptiveGC();

#define END_ENSURE_COOPERATIVE_GC()                             \
        if (__fToggle) __pThread->EnablePreemptiveGC();         \
    }   

// use the following two macros when the thread's GC state is known 
// and expected   
#define BEGIN_COOPERATIVE_GC(pThread)                           \
    {                                                           \
        DEBUG_ASSURE_NO_RETURN_IN_THIS_BLOCK                    \
        pThread->DisablePreemptiveGC();

#define END_COOPERATIVE_GC(pThread);                            \
        pThread->EnablePreemptiveGC();                          \
    }

#define BEGIN_ENSURE_PREEMPTIVE_GC()                            \
    {                                                           \
        DEBUG_ASSURE_NO_RETURN_IN_THIS_BLOCK                    \
        Thread *__pThread = GetThread();                        \
        BOOL __fToggle = __pThread != NULL &&                   \
                        __pThread->PreemptiveGCDisabled();      \
        if (__fToggle) __pThread->EnablePreemptiveGC();

#define END_ENSURE_PREEMPTIVE_GC()                              \
        if (__fToggle) __pThread->DisablePreemptiveGC();        \
    }   

#define REQUIRE_COOPERATIVE_GC()                                \
    _ASSERTE(GetThread() != NULL &&                             \
             "The current thread is not known by the EE");      \
    _ASSERTE(GetThread()->PreemptiveGCDisabled());

#define REQUIRE_PREEMPTIVE_GC()                                 \
    _ASSERTE(GetThread() == NULL ||                             \
             !GetThread()->PreemptiveGCDisabled());



class AppDomainStack
{
public:
    AppDomainStack() :  m_numDomainsOnStack(0), m_isWellFormed( TRUE )
    {
    }

    AppDomainStack( const AppDomainStack& stack )
     : m_numDomainsOnStack( stack.m_numDomainsOnStack ), m_isWellFormed( stack.m_isWellFormed )
    {
        memcpy( this->m_pDomains, stack.m_pDomains, sizeof( DWORD ) * MAX_APPDOMAINS_TRACKED );
    }

    void PushDomain(AppDomain *pDomain);
    void PushDomain(DWORD domainIndex);
    void PushDomainNoDuplicates(DWORD domainIndex);
    AppDomain *PopDomain();

    void InitDomainIteration(DWORD *pIndex) const
    {
        *pIndex = m_numDomainsOnStack;
    }

    AppDomain *GetNextDomainOnStack(DWORD *pIndex) const;

    DWORD GetNextDomainIndexOnStack(DWORD *pIndex) const;

    FORCEINLINE BOOL IsWellFormed() const
    {
        return m_numDomainsOnStack < MAX_APPDOMAINS_TRACKED &&
               m_isWellFormed;
    }

    FORCEINLINE DWORD   GetNumDomains() const
    {
        return m_numDomainsOnStack;
    }

    void ClearDomainStack()
    {
        m_numDomainsOnStack = 0;
    }

    void AppendStack( const AppDomainStack& stack )
    {
        if (this->m_numDomainsOnStack < MAX_APPDOMAINS_TRACKED)
        {
            memcpy( &this->m_pDomains[this->m_numDomainsOnStack], stack.m_pDomains, sizeof( DWORD ) * (MAX_APPDOMAINS_TRACKED - this->m_numDomainsOnStack) );
        }
        this->m_numDomainsOnStack += stack.m_numDomainsOnStack;
    }

    void DeductStack( const AppDomainStack& stack )
    {
        _ASSERTE( this->m_numDomainsOnStack >= stack.m_numDomainsOnStack );

        if (stack.m_numDomainsOnStack < MAX_APPDOMAINS_TRACKED)
        {
            memcpy( this->m_pDomains, &this->m_pDomains[stack.m_numDomainsOnStack], sizeof( DWORD ) * (MAX_APPDOMAINS_TRACKED - stack.m_numDomainsOnStack) );
            for (DWORD i = this->m_numDomainsOnStack - stack.m_numDomainsOnStack; i < MAX_APPDOMAINS_TRACKED; ++i)
            {
                this->m_pDomains[i] = -1;
            }
        }
        else
        {
            for (DWORD i = 0; i < MAX_APPDOMAINS_TRACKED; ++i)
            {
                this->m_pDomains[i] = -1;
            }
        }

        if (this->m_numDomainsOnStack >= MAX_APPDOMAINS_TRACKED)
            this->m_isWellFormed = FALSE;

        this->m_numDomainsOnStack -= stack.m_numDomainsOnStack;
    }

private:
    // This class needs to remain blt-able or
    // you need to define the assignment operator

    DWORD       m_pDomains[MAX_APPDOMAINS_TRACKED];
    DWORD       m_numDomainsOnStack;
    BOOL        m_isWellFormed;

};

enum CompressedStackType
{
    ESharedSecurityDescriptor = 0,
    EApplicationSecurityDescriptor = 1,
    EFrameSecurityDescriptor = 2,
    ECompressedStack = 3,
    ECompressedStackObject = 4,
    EAppDomainTransition = 5
};

class CompressedStack;

struct CompressedStackEntry
{
    CompressedStackEntry( void* ptr, CompressedStackType type )
        : ptr_( ptr ),
          type_( type )
    {
    }

    CompressedStackEntry( DWORD index, CompressedStackType type )
        : type_( type )
    {
        indexStruct_.index_ = index;
    }

    CompressedStackEntry( OBJECTHANDLE handle, CompressedStackType type )
        : type_( type )
    {
        handleStruct_.handle_ = handle;
        handleStruct_.fullyTrusted_ = FALSE;
        handleStruct_.domainId_ = 0;
    }

    CompressedStackEntry( OBJECTHANDLE handle, BOOL fullyTrusted, DWORD domainId, CompressedStackType type )
        : type_( type )
    {
        handleStruct_.handle_ = handle;
        handleStruct_.fullyTrusted_ = fullyTrusted;
        handleStruct_.domainId_ = domainId;
    }

    CompressedStackEntry( OBJECTHANDLE handle, DWORD domainId, CompressedStackType type )
        : type_( type )
    {
        handleStruct_.handle_ = handle;
        handleStruct_.fullyTrusted_ = FALSE;
        handleStruct_.domainId_ = domainId;
    }

    CompressedStack* Destroy( CompressedStack* owner );
    void Cleanup( void );


    void* operator new( size_t size, CompressedStack* stack );
    void operator delete( void* ptr )
    {
    }

private:
    ~CompressedStackEntry( void )
    {
    }

public:
    union
    {
        void* ptr_;
        struct
        {
            DWORD index_;
        } indexStruct_;

        struct
        {
            OBJECTHANDLE handle_;
            BOOL fullyTrusted_;
            DWORD domainId_;
        } handleStruct_;
    };

    CompressedStackType type_;
};

#ifdef _DEBUG
#define MAX_COMPRESSED_STACK_DEPTH 20
#define SIZE_ALLOCATE_BUFFERS 4 * sizeof( CompressedStackEntry )
#define FREE_LIST_SIZE 128
#else
#define MAX_COMPRESSED_STACK_DEPTH 80
#define SIZE_ALLOCATE_BUFFERS 8 * sizeof( CompressedStackEntry )
#define FREE_LIST_SIZE 1024
#endif


class CompressedStack
{
friend class Thread;
friend struct CompressedStackEntry;

public:
    CompressedStack( void )
        : delayedCompressedStack_( NULL ),
          compressedStackObject_( NULL ),
          compressedStackObjectAppDomain_( NULL ),
          compressedStackObjectAppDomainId_( -1 ),
          pbObjectBlob_( NULL ),
          cbObjectBlob_( 0 ),
          containsOverridesOrCompressedStackObject_( FALSE ),
          refCount_( 1 ),
          isFullyTrustedDecision_( -1 ),
          depth_( 0 ),
          index_( 0 ),
          offset_( 0 ),
          plsOptimizationOn_( TRUE )
    {
#ifdef _DEBUG
        creatingThread_ = GetThread();
#endif
        this->entriesMemoryList_.Append( NULL );

        AddToList();
    };

    CompressedStack( OBJECTREF orStack );

    OBJECTREF GetPermissionListSet( AppDomain* domain = NULL );

    bool HandleAppDomainUnload( AppDomain* domain, DWORD domainId );

    void AddEntry( void* obj, CompressedStackType type );
    void AddEntry( void* obj, AppDomain* appDomain, CompressedStackType type );

    bool IsPersisted( void )
    {
        return pbObjectBlob_ != NULL;
    }

    bool LazyIsFullyTrusted( void );

    size_t GetDepth( void )
    {
        return this->depth_;
    }

    LONG AddRef( void );
    LONG Release( void );

    const AppDomainStack& GetAppDomainStack( void )
    {
        return appDomainStack_;
    }

    DWORD GetOverridesCount( void )
    {
        return overridesCount_;
    }

    BOOL GetPLSOptimizationState( void )
    {
        return plsOptimizationOn_;
    }

    void SetPLSOptimizationState( BOOL optimizationOn )
    {
        plsOptimizationOn_ = optimizationOn;
    }

    void CarryOverSecurityInfo(Thread *pFromThread);

    void CarryOverSecurityInfo( DWORD overrides, const AppDomainStack& ADStack )
    {
        overridesCount_ = overrides;
        appDomainStack_ = ADStack;
    }

    static void AllHandleAppDomainUnload( AppDomain* domain, DWORD domainId );

    static void Init( void );
    static void Shutdown( void );

private:
    ~CompressedStack( void );

    void* AllocateEntry( size_t size );

    CompressedStack* RemoveDuplicates( CompressedStack* current, CompressedStack* candidate );
    CompressedStackEntry* FindMatchingEntry( CompressedStackEntry* entry, CompressedStack* stack );

    OBJECTREF GetPermissionListSetInternal( AppDomain* targetDomain, AppDomain* unloadingDomain, DWORD domainId, BOOL unwindRecursion );
    OBJECTREF GeneratePermissionListSet( AppDomain* targetDomain, AppDomain* unloadingDomain, DWORD unloadingDomainId, BOOL unwindRecursion );
    OBJECTREF CreatePermissionListSet( AppDomain* targetDomain, AppDomain* unloadingDomain, DWORD unloadingDomainId );
    static AppDomain* GetAppDomainFromId( DWORD id, AppDomain* unloadingDomain, DWORD unloadingDomainId );

    ArrayList* delayedCompressedStack_;
    OBJECTHANDLE compressedStackObject_;
    AppDomain* compressedStackObjectAppDomain_;
    DWORD compressedStackObjectAppDomainId_;
    BYTE* pbObjectBlob_;
    DWORD cbObjectBlob_;
    BOOL containsOverridesOrCompressedStackObject_;

    LONG refCount_;
    LONG isFullyTrustedDecision_;
    size_t depth_;

    ArrayList entriesMemoryList_;
    DWORD index_, offset_;

    DWORD listIndex_;

    BOOL plsOptimizationOn_;
    AppDomainStack appDomainStack_;
    DWORD overridesCount_;

#ifdef _DEBUG
    Thread* creatingThread_;
#endif

    void AddToList( void );
    void RemoveFromList();

    static BOOL SetBlobIfAlive( CompressedStack* stack, BYTE* pbBlob, DWORD cbBlob );
    static BOOL IfAliveAddRef( CompressedStack* stack );

    static ArrayList allCompressedStacks_;
    static DWORD freeList_[FREE_LIST_SIZE];
    static DWORD freeListIndex_;
    static DWORD numUntrackedFreeIndices_;
    static Crst* listCriticalSection_;
};


// The Thread class represents a managed thread.  This thread could be internal
// or external (i.e. it wandered in from outside the runtime).  For internal
// threads, it could correspond to an exposed System.Thread object or it
// could correspond to an internal worker thread of the runtime.
//
// If there's a physical Win32 thread underneath this object (i.e. it isn't an
// unstarted System.Thread), then this instance can be found in the TLS
// of that physical thread.



class Thread
{
    friend struct ThreadQueue;  // used to enqueue & dequeue threads onto SyncBlocks
    friend class  ThreadStore;
    friend class  SyncBlock;
    friend class  Context;
    friend struct PendingSync;
    friend class  AppDomain;
    friend class  ThreadNative;
    friend class  CompressedStack;

    friend void __cdecl CommonTripThread();
    friend void __cdecl OnHijackObjectWorker(HijackObjectArgs args);
    friend void __cdecl OnHijackInteriorPointerWorker(HijackObjectArgs args);
    friend void __cdecl OnHijackScalarWorker(HijackScalarArgs args);
    friend BOOL         InitThreadManager();
#ifdef SHOULD_WE_CLEANUP
    friend void         TerminateThreadManager();
#endif /* SHOULD_WE_CLEANUP */
    friend void         ThreadBaseObject::SetDelegate(OBJECTREF delegate);
    friend HRESULT      InitializeMiniDumpBlock();
    friend struct MEMBER_OFFSET_INFO(Thread);

public:

    // If we are trying to suspend a thread, we set the appropriate pending bit to
    // indicate why we want to suspend it (TS_GCSuspendPending, TS_UserSuspendPending,
    // TS_DebugSuspendPending).
    //
    // If instead the thread has blocked itself, via WaitSuspendEvent, we indicate
    // this with TS_SyncSuspended.  However, we need to know whether the synchronous
    // suspension is for a user request, or for an internal one (GC & Debug).  That's
    // because a user request is not allowed to resume a thread suspended for
    // debugging or GC.  -- That's not stricly true.  It is allowed to resume such a
    // thread so long as it was ALSO suspended by the user.  In other words, this
    // ensures that user resumptions aren't unbalanced from user suspensions.
    // 
    enum ThreadState
    {
        TS_Unknown                = 0x00000000,    // threads are initialized this way

        TS_StopRequested          = 0x00000001,    // process stop at next opportunity
        TS_GCSuspendPending       = 0x00000002,    // waiting to get to safe spot for GC
        TS_UserSuspendPending     = 0x00000004,    // user suspension at next opportunity
        TS_DebugSuspendPending    = 0x00000008,    // Is the debugger suspending threads?
        TS_GCOnTransitions        = 0x00000010,    // Force a GC on stub transitions (GCStress only)

        TS_LegalToJoin            = 0x00000020,    // Is it now legal to attempt a Join()
        TS_Hijacked               = 0x00000080,    // Return address has been hijacked

        TS_Background             = 0x00000200,    // Thread is a background thread
        TS_Unstarted              = 0x00000400,    // Thread has never been started
        TS_Dead                   = 0x00000800,    // Thread is dead

        TS_WeOwn                  = 0x00001000,    // Exposed object initiated this thread
        TS_CoInitialized          = 0x00002000,    // CoInitialize has been called for this thread
        TS_InSTA                  = 0x00004000,    // Thread hosts an STA
        TS_InMTA                  = 0x00008000,    // Thread is part of the MTA

        // Some bits that only have meaning for reporting the state to clients.
        TS_ReportDead             = 0x00010000,    // in WaitForOtherThreads()

        TS_SyncSuspended          = 0x00080000,    // Suspended via WaitSuspendEvent
        TS_DebugWillSync          = 0x00100000,    // Debugger will wait for this thread to sync
        TS_RedirectingEntryPoint  = 0x00200000,    // Redirecting entrypoint. Do not call managed entrypoint when set 

        TS_SuspendUnstarted       = 0x00400000,    // latch a user suspension on an unstarted thread

        TS_ThreadPoolThread       = 0x00800000,    // is this a threadpool thread?
        TS_TPWorkerThread         = 0x01000000,    // is this a threadpool worker thread? (if not, it is a threadpool completionport thread)

        TS_Interruptible          = 0x02000000,    // sitting in a Sleep(), Wait(), Join()
        TS_Interrupted            = 0x04000000,    // was awakened by an interrupt APC

        TS_AbortRequested         = 0x08000000,    // same as TS_StopRequested in order to trip the thread
        TS_AbortInitiated         = 0x10000000,    // set when abort is begun
        TS_UserStopRequested      = 0x20000000,    // set when a user stop is requested. This is different from TS_StopRequested
        TS_GuardPageGone          = 0x40000000,    // stack overflow, not yet reset.
        TS_Detached               = 0x80000000,    // Thread was detached by DllMain

        // @TODO: We need to reclaim the bits that have no concurrency issues (i.e. they are only 
        //         manipulated by the owning thread) and move them off to a different DWORD

        // We require (and assert) that the following bits are less than 0x100.
        TS_CatchAtSafePoint = (TS_UserSuspendPending | TS_StopRequested |
                               TS_GCSuspendPending | TS_DebugSuspendPending | TS_GCOnTransitions),
    };

    // Thread flags that aren't really states in themselves but rather things the thread 
    // has to do.
    enum ThreadTasks
    {
        TT_CallCoInitialize       = 0x00000001, // CoInitialize needs to be called.
        TT_CleanupSyncBlock       = 0x00000002, // The synch block needs to be cleaned up.
    };

    // Thread flags that have no concurrency issues (i.e., they are only manipulated by the owning thread). Use these
    // state flags when you have a new thread state that doesn't belong in the ThreadState enum above. Note: though this
    // enum seems to hold only debugger-related bits right now, its purpose is to hold bits for any purpose.
    //
    // @TODO: its possible that the ThreadTasks from above and these flags should be merged.
    enum ThreadStateNoConcurrency
    {
        TSNC_Unknown                    = 0x00000000, // threads are initialized this way
        
        TSNC_DebuggerUserSuspend        = 0x00000001, // marked "suspended" by the debugger
        TSNC_DebuggerUserSuspendSpecial = 0x00000002, // a "suspended" thread is in a special case where we may need to
                                                      // release it briefly.
        TSNC_DebuggerReAbort            = 0x00000004, // thread needs to re-abort itself when resumed by the debugger
        TSNC_DebuggerIsStepping         = 0x00000008, // debugger is stepping this thread
        TSNC_DebuggerIsManagedException = 0x00000010, // EH is re-raising a managed exception.
        TSNC_DebuggerStoppedInRuntime   = 0x00000020, // The thread is stopped by an interop debugger in Runtime impl.
        TSNC_DebuggerForceStopped       = 0x00000040, // The thread was forced to stop with PGC disabled by the debugger.
        TSNC_UnsafeSkipEnterCooperative = 0x00000080, // This is a "fix" for deadlocks caused when cleaning up COM 
                                                      // IP's during shutdown. When we are doing this we cannot allow
                                                      // the hashtable's to enter cooperative GC mode.
    };

    void SetThreadStateNC(ThreadStateNoConcurrency tsnc)
    {
        m_StateNC = (ThreadStateNoConcurrency)((DWORD)m_StateNC | tsnc);
    }

    void ResetThreadStateNC(ThreadStateNoConcurrency tsnc)
    {
        m_StateNC = (ThreadStateNoConcurrency)((DWORD)m_StateNC & ~tsnc);
    }

    // helpers to toggle the bits
    void SetGuardPageGone() 
    {
        FastInterlockOr((ULONG *)&m_State, TS_GuardPageGone);
    }

    void ResetGuardPageGone() 
    {
        FastInterlockAnd((ULONG *)&m_State, ~TS_GuardPageGone);
    }

    DWORD IsGuardPageGone()
    {
        return (m_State & TS_GuardPageGone);
    }

    void SetRedirectingEntryPoint()
    {
         FastInterlockOr((ULONG *)&m_State, TS_RedirectingEntryPoint);
    }

    void ResetRedirectingEntryPoint()
    {
         FastInterlockAnd((ULONG *)&m_State, ~TS_RedirectingEntryPoint);
    }

    DWORD IsRedirectingEntryPoint()
    {
         return (m_State & TS_RedirectingEntryPoint);
    }

    DWORD IsCoInitialized()
    {
        return (m_State & TS_CoInitialized);
    }

    void SetCoInitialized()
    {
        FastInterlockOr((ULONG *)&m_State, TS_CoInitialized);
        FastInterlockAnd((ULONG *)&m_ThreadTasks, ~TT_CallCoInitialize);
    }

    void ResetCoInitialized()
    {
        FastInterlockAnd((ULONG *)&m_State,~TS_CoInitialized);
    }

    DWORD RequiresCoInitialize()
    {
        return (m_ThreadTasks & TT_CallCoInitialize);
    }
    
    void SetRequiresCoInitialize()
    {
        FastInterlockOr((ULONG *)&m_ThreadTasks, TT_CallCoInitialize);
    }

    void ResetRequiresCoInitialize()
    {
        FastInterlockAnd((ULONG *)&m_ThreadTasks,~TT_CallCoInitialize);
    }

    DWORD RequireSyncBlockCleanup()
    {
        return (m_ThreadTasks & TT_CleanupSyncBlock);
    }
    void SetSyncBlockCleanup()
    {
        FastInterlockOr((ULONG *)&m_ThreadTasks, TT_CleanupSyncBlock);
    }
    void ResetSyncBlockCleanup()
    {
        FastInterlockAnd((ULONG *)&m_ThreadTasks, ~TT_CleanupSyncBlock);
    }

    // returns if there is some extra work for the finalizer thread.
    BOOL HaveExtraWorkForFinalizer();

    // do the extra finalizer work.
    void DoExtraWorkForFinalizer();

    DWORD CatchAtSafePoint()  { return (m_State & TS_CatchAtSafePoint); }
    DWORD IsBackground()      { return (m_State & TS_Background); }
    DWORD IsUnstarted()       { return (m_State & TS_Unstarted); }
    DWORD IsDead()            { return (m_State & TS_Dead); }

    // Used by FCalls
    void NativeFramePushed()  { _ASSERTE(m_fNativeFrameSetup == FALSE);
                                m_fNativeFrameSetup = TRUE; }
    void NativeFramePopped()  { _ASSERTE(m_fNativeFrameSetup == TRUE);
                                m_fNativeFrameSetup = FALSE; }
    BOOL IsNativeFrameSetup() { return(m_fNativeFrameSetup); }


    // For reporting purposes, grab a consistent snapshot of the thread's state
    ThreadState GetSnapshotState();

    // For delayed destruction of threads
    DWORD           IsDetached()  { return (m_State & TS_Detached); }
    static long     m_DetachCount;
    static long     m_ActiveDetachCount;  // Count how many non-background detached

    // Offsets for the following variables need to fit in 1 byte, so keep near
    // the top of the object.
    volatile ThreadState m_State;   // Bits for the state of the thread

    // If TRUE, GC is scheduled cooperatively with this thread.
    // NOTE: This "byte" is actually a boolean - we don't allow
    // recursive disables.
    volatile ULONG       m_fPreemptiveGCDisabled;

    Frame               *m_pFrame;  // The Current Frame
    Frame               *m_pUnloadBoundaryFrame; 

    // Track the number of locks (critical section, spin lock, syncblock lock,
    // EE Crst, GC lock) held by the current thread.
    DWORD                m_dwLockCount;

    // Unique thread id used for thin locks - kept as small as possible, as we have limited space
    // in the object header to store it - PeterSol
    DWORD                m_dwThinLockThreadId;

    // RWLock state 
    BOOL                 m_fNativeFrameSetup;
    LockEntry           *m_pHead;
    LockEntry            m_embeddedEntry;

    // on MP systems, each thread has its own allocation chunk so we can avoid
    // lock prefixes and expensive MP cache snooping stuff
    alloc_context        m_alloc_context;

    // Allocator used during marshaling for temporary buffers, much faster than
    // heap allocation.
    StackingAllocator    m_MarshalAlloc;

    // Flags used to indicate tasks the thread has to do.
    ThreadTasks          m_ThreadTasks;

    // Flags for thread states that have no concurrency issues.
    ThreadStateNoConcurrency m_StateNC;
    
    // The context within which this thread is executing.  As the thread crosses
    // context boundaries, the context mechanism adjusts this so it's always
    // current.
    // @TODO cwb: When we add COM+ 1.0 Context Interop, this should get moved out
    // of the Thread object and into its own slot in the TLS.
    // The address of the context object is also used as the ContextID!
    Context        *m_Context;

    inline void IncLockCount()
    {
        _ASSERTE (GetThread() == this);
        m_dwLockCount ++;
        _ASSERTE (m_dwLockCount != 0);
    }
    inline void DecLockCount()
    {
        _ASSERTE (GetThread() == this);
        _ASSERTE (m_dwLockCount > 0);
        m_dwLockCount --;
    }
    
    inline BOOL IsAbortRequested()
    { return (m_State & TS_AbortRequested); }

    inline BOOL IsAbortInitiated()
    { return (m_State & TS_AbortInitiated); }

    inline void SetAbortInitiated()
    {
        FastInterlockOr((ULONG *)&m_State, TS_AbortInitiated);
        // The following should be factored better, but I'm looking for a minimal V1 change.
        IsUserInterrupted(TRUE /*=reset*/);
    }
    inline void ResetAbortInitiated()
    {
        FastInterlockAnd((ULONG *)&m_State, ~TS_AbortInitiated);
    }

    BOOL MarkThreadForAbort();          // returns false if the thread was already marked to be aborted or
                                        // has some pending exceptions.
    
    inline BOOL  IsWorkerThread()
    { 
        return (m_State & TS_TPWorkerThread); 
    }
    //--------------------------------------------------------------
    // Constructor.
    //--------------------------------------------------------------
    Thread();

    //--------------------------------------------------------------
    // Failable initialization occurs here.
    //--------------------------------------------------------------
    BOOL InitThread();
    BOOL AllocHandles();

    //--------------------------------------------------------------
    // If the thread was setup through SetupUnstartedThread, rather
    // than SetupThread, complete the setup here when the thread is
    // actually running.
    //--------------------------------------------------------------
    BOOL HasStarted();

    // We don't want ::CreateThread() calls scattered throughout the source.
    // Create all new threads here.  The thread is created as suspended, so
    // you must ::ResumeThread to kick it off.  It is guaranteed to create the
    // thread, or throw.
    HANDLE CreateNewThread(DWORD stackSize, ThreadStartFunction start,
                           void *args, DWORD *pThreadId /* or NULL if you don't care */);


    //--------------------------------------------------------------
    // Destructor
    //--------------------------------------------------------------
    ~Thread();
        
    void            CoUninitalize();

    void        OnThreadTerminate(BOOL holdingLock,
                                  BOOL threadCleanupAllowed = TRUE);

    static void CleanupDetachedThreads(GCHeap::SUSPEND_REASON reason);

    //--------------------------------------------------------------
    // Returns innermost active Frame.
    //--------------------------------------------------------------
    Frame *GetFrame()
    {
#if defined(_DEBUG) && defined(_X86_)
        if (this == GetThread()) {
            void* curESP;
            __asm mov curESP, ESP
            _ASSERTE((curESP <= m_pFrame && m_pFrame < m_CacheStackBase)
                    || m_pFrame == (Frame*) -1);
        }
#endif
        return m_pFrame;
    }

    //--------------------------------------------------------------
    // Replaces innermost active Frames.
    //--------------------------------------------------------------
    void  SetFrame(Frame *pFrame)
#ifdef _DEBUG
        ;
#else
    {
        m_pFrame = pFrame;
    }
#endif
    ;

    void  SetUnloadBoundaryFrame(Frame *pFrame)
    {
        m_pUnloadBoundaryFrame = pFrame;
    }

    Frame *GetUnloadBoundaryFrame()
    {
        return m_pUnloadBoundaryFrame;
    }

    void SetWin32FaultAddress(DWORD eip)
    {
        m_Win32FaultAddress = eip;
    }

    void SetWin32FaultCode(DWORD code)
    {
        m_Win32FaultCode = code;
    }

    DWORD GetWin32FaultAddress()
    {
        return m_Win32FaultAddress;
    }

    DWORD GetWin32FaultCode()
    {
        return m_Win32FaultCode;
    }


    //**************************************************************
    // GC interaction
    //**************************************************************

    //--------------------------------------------------------------
    // Enter cooperative GC mode. NOT NESTABLE.
    //--------------------------------------------------------------
    void DisablePreemptiveGC()
    {
        _ASSERTE(this == GetThread());
        _ASSERTE(!m_fPreemptiveGCDisabled);
#ifdef _DEBUG
        SetReadyForSuspension ();
#endif
                //INDEBUG(TriggersGC(this);)

        // Logically, we just want to check whether a GC is in progress and halt
        // at the boundary if it is -- before we disable preemptive GC.  However
        // this opens up a race condition where the GC starts after we make the
        // check.  SysSuspendForGC will ignore such a thread because it saw it as
        // outside the EE.  So the thread would run wild during the GC.
        //
        // Instead, enter cooperative mode and then check if a GC is in progress.
        // If so, go back out and try again.  The reason we go back out before we
        // try again, is that SysSuspendForGC might have seen us as being in
        // cooperative mode if it checks us between the next two statements.
        // In that case, it will be trying to move us to a safe spot.  If
        // we don't let it see us leave, it will keep waiting on us indefinitely.

        // ------------------------------------------------------------------------
        //   ** WARNING ** WARNING ** WARNING ** WARNING ** WARNING ** WARNING **  |
        // ------------------------------------------------------------------------
        //
        //   DO NOT CHANGE THIS METHOD WITHOUT VISITING ALL THE STUB GENERATORS
        //   THAT EFFECTIVELY INLINE IT INTO THEIR STUBS
        //
        // ------------------------------------------------------------------------
        //   ** WARNING ** WARNING ** WARNING ** WARNING ** WARNING ** WARNING **  |
        // ------------------------------------------------------------------------

        m_fPreemptiveGCDisabled = 1;
    
        if (g_TrapReturningThreads)
        {
            RareDisablePreemptiveGC();
        }
    }

    void RareDisablePreemptiveGC();

    void HandleThreadAbort();
    
    //--------------------------------------------------------------
    // Leave cooperative GC mode. NOT NESTABLE.
    //--------------------------------------------------------------
    void EnablePreemptiveGC()
    {
        _ASSERTE(this == GetThread());
        _ASSERTE(m_fPreemptiveGCDisabled);
        _ASSERTE(!GCForbidden() 
                 || (m_StateNC & TSNC_DebuggerStoppedInRuntime) != 0);
        INDEBUG(TriggersGC(this);)

        // ------------------------------------------------------------------------
        //   ** WARNING ** WARNING ** WARNING ** WARNING ** WARNING ** WARNING **  |
        // ------------------------------------------------------------------------
        //
        //   DO NOT CHANGE THIS METHOD WITHOUT VISITING ALL THE STUB GENERATORS
        //   THAT EFFECTIVELY INLINE IT INTO THEIR STUBS
        //
        // ------------------------------------------------------------------------
        //   ** WARNING ** WARNING ** WARNING ** WARNING ** WARNING ** WARNING **  |
        // ------------------------------------------------------------------------

        m_fPreemptiveGCDisabled = 0;
#ifdef _DEBUG
        m_ulEnablePreemptiveGCCount ++;
#endif
        if (CatchAtSafePoint())
            RareEnablePreemptiveGC();
    }

#if defined(STRESS_HEAP) && defined(_DEBUG)
    void PerformPreemptiveGC();
#endif
    void RareEnablePreemptiveGC();
    void PulseGCMode();
    
    //--------------------------------------------------------------
    // Query mode
    //--------------------------------------------------------------
    BOOL PreemptiveGCDisabled()
    {
        _ASSERTE(this == GetThread());
        return (PreemptiveGCDisabledOther());
    }

    BOOL PreemptiveGCDisabledOther()
    {
        return (m_fPreemptiveGCDisabled);
    }

#ifdef _DEBUG
    void BeginForbidGC()
    {
        _ASSERTE(this == GetThread());
        _ASSERTE(PreemptiveGCDisabled() ||
                 CORProfilerPresent() ||    // This added to allow profiler to use GetILToNativeMapping
                                            // while in preemptive GC mode
                 (g_fEEShutDown & (ShutDown_Finalize2 | ShutDown_Profiler)) == ShutDown_Finalize2);
        m_ulGCForbidCount++;
    }

    void EndForbidGC()
    {
        _ASSERTE(this == GetThread());
        _ASSERTE(PreemptiveGCDisabled() ||
                 CORProfilerPresent() ||    // This added to allow profiler to use GetILToNativeMapping
                                            // while in preemptive GC mode
                 (g_fEEShutDown & (ShutDown_Finalize2 | ShutDown_Profiler)) == ShutDown_Finalize2);
        _ASSERTE(m_ulGCForbidCount != 0);
        m_ulGCForbidCount--;
    }

    BOOL GCForbidden()
    {
        _ASSERTE(this == GetThread());
        return m_ulGCForbidCount;
    }

    void SetReadyForSuspension()
    {
        m_ulReadyForSuspensionCount ++;
    }

    ULONG GetReadyForSuspensionCount()
    {
        return m_ulReadyForSuspensionCount;
    }
    
    VOID ValidateThrowable();

#endif

    //---------------------------------------------------------------
    // Expose key offsets and values for stub generation.
    //---------------------------------------------------------------
    static BYTE GetOffsetOfCurrentFrame()
    {
        size_t ofs = offsetof(class Thread, m_pFrame);
        _ASSERTE(FitsInI1(ofs));
        return (BYTE)ofs;
    }

    static BYTE GetOffsetOfState()
    {
        size_t ofs = offsetof(class Thread, m_State);
        _ASSERTE(FitsInI1(ofs));
        return (BYTE)ofs;
    }

    static BYTE GetOffsetOfGCFlag()
    {
        size_t ofs = offsetof(class Thread, m_fPreemptiveGCDisabled);
        _ASSERTE(FitsInI1(ofs));
        return (BYTE)ofs;
    }

    // The address of the context object is also used as the ContextID
    static BYTE GetOffsetOfContextID()
    {
        size_t ofs = offsetof(class Thread, m_Context);
        _ASSERTE(FitsInI1(ofs));
        return (BYTE)ofs;
    }

    static void StaticDisablePreemptiveGC( Thread *pThread)
    {
        _ASSERTE(pThread != NULL);
        pThread->DisablePreemptiveGC();
    }

    static void StaticEnablePreemptiveGC( Thread *pThread)
    {
        _ASSERTE(pThread != NULL);
        pThread->EnablePreemptiveGC();
    }


    //---------------------------------------------------------------
    // Expose offset of the app domain word for the interop and delegate callback
    //---------------------------------------------------------------
    static SIZE_T GetOffsetOfAppDomain()
    {
        return (SIZE_T)(offsetof(class Thread, m_pDomain));
    }

        //---------------------------------------------------------------
    // Expose offset of the first debugger word for the debugger
    //---------------------------------------------------------------
    static SIZE_T GetOffsetOfDbgWord1()
    {
        return (SIZE_T)(offsetof(class Thread, m_debuggerWord1));
    }

    //---------------------------------------------------------------
    // Expose offset of the second debugger word for the debugger
    //---------------------------------------------------------------
    static SIZE_T GetOffsetOfDbgWord2()
    {
        return (SIZE_T)(offsetof(class Thread, m_debuggerWord2));
    }

    //---------------------------------------------------------------
    // Expose offset of the debugger cant stop count for the debugger
    //---------------------------------------------------------------
    static SIZE_T GetOffsetOfCantStop()
    {
        return (SIZE_T)(offsetof(class Thread, m_debuggerCantStop));
    }

    //---------------------------------------------------------------
    // Expose offset of m_StateNC
    //---------------------------------------------------------------
    static SIZE_T GetOffsetOfStateNC()
    {
        return (SIZE_T)(offsetof(class Thread, m_StateNC));
    }

    //---------------------------------------------------------------
    // Last exception to be thrown
    //---------------------------------------------------------------
    void SetThrowable(OBJECTREF pThrowable);

    OBJECTREF GetThrowable()
    {
        if (m_handlerInfo.m_pThrowable)
            return ObjectFromHandle(m_handlerInfo.m_pThrowable);
        else
            return NULL;
    }

    OBJECTHANDLE *GetThrowableAsHandle()
    {
        return &m_handlerInfo.m_pThrowable;
    }

    // special null test (for use when we're in the wrong GC mode)
    BOOL IsThrowableNull()
    {
        if (m_handlerInfo.m_pThrowable)
            return ObjectHandleIsNull(m_handlerInfo.m_pThrowable);
        else
            return TRUE;
    }



        BOOL IsExceptionInProgress()
        {
                return (m_handlerInfo.m_pBottomMostHandler != NULL);
        }

    //---------------------------------------------------------------
    // Per-thread information used by handler 
    //---------------------------------------------------------------
    // exception handling info stored in thread
    // can't allocate this as needed because can't make exception-handling depend upon memory allocation

    // Stores the most recently thrown exception. We need to have a handle in case a GC occurs before
    // we catch so we don't lose the object. Having a static allows others to catch outside of COM+ w/o leaking
    // a handler and allows rethrow outside of COM+ too.
    // Differs from m_pThrowable in that it doesn't stack on nested exceptions.
    ExInfo *GetHandlerInfo()
    {
        return &m_handlerInfo;
    }

    // Access to the Context this thread is executing in.
    Context *GetContext()
    {
        // if another thread is asking about our thread, we could be in the middle of an AD transition so 
        // the context and AD may not match if have set one but not the other. Can live without checking when
        // another thread is asking it as this method is mostly called on our own thread so will mostly get the 
        // checking. If are int the middle of a transition, this could return either the old or the new AD. 
        // But no matter what we do, such as lock on the transition, by the time are done could still have 
        // changed right after we asked, so really no point.
        _ASSERTE(this != GetThread() || (m_Context == NULL && m_pDomain == NULL) || m_Context->GetDomain() == m_pDomain || g_fEEShutDown);
        return m_Context;
    }

    void SetExposedContext(Context *c);

    // This callback is used when we are executing in the EE and discover that we need
    // to switch appdomains.
    void DoADCallBack(Context *pContext, LPVOID pTarget, LPVOID args);

    // Except for security and the call in from the remoting code in mscorlib, you should never do an
    // AppDomain transition directly through these functions. Rather, you should use DoADCallBack above
    // to call into managed code to perform the transition for you so that the correct policy code etc
    // is run on the transition,
    void EnterContextRestricted(Context *c, Frame *pFrame, BOOL fLinkFrame);
    void ReturnToContext(Frame *pFrame, BOOL fLinkFrame);
    void EnterContext(Context *c, Frame *pFrame, BOOL fLinkFrame);

    // ClearContext are to be called only during shutdown
    void ClearContext();

    // Used by security to prevent recursive stackwalking.
    BOOL IsSecurityStackwalkInProgess() { return m_fSecurityStackwalk; }
    void SetSecurityStackwalkInProgress(BOOL fSecurityStackwalk) { m_fSecurityStackwalk = fSecurityStackwalk; }

private:
    // don't ever call these except when creating thread!!!!!
    void InitContext();

    BOOL m_fSecurityStackwalk;

public:
    AppDomain* GetDomain()
    {
        // if another thread is asking about our thread, we could be in the middle of an AD transition so 
        // the context and AD may not match if have set one but not the other. Can live without checking when
        // another thread is asking it as this method is mostly called on our own thread so will mostly get the 
        // checking. If are int the middle of a transition, this could return either the old or the new AD. 
        // But no matter what we do, such as lock on the transition, by the time are done could still have 
        // changed right after we asked, so really no point.
#ifdef _DEBUG
        if (!g_fEEShutDown && this == GetThread()) 
        {
            _ASSERTE((m_Context == NULL && m_pDomain == NULL) || m_Context->GetDomain() == m_pDomain);
            AppDomain* valueInTLSSlot = GetAppDomain();
            _ASSERTE(valueInTLSSlot == 0 || valueInTLSSlot == m_pDomain);
        }
#endif
        return m_pDomain;
    }
   
    Frame *IsRunningIn(AppDomain *pDomain, int *count);
    Frame *GetFirstTransitionInto(AppDomain *pDomain, int *count);

    BOOL ShouldChangeAbortToUnload(Frame *pFrame, Frame *pUnloadBoundaryFrame=NULL);

    // Get outermost (oldest) AppDomain for this thread.
    AppDomain *GetInitialDomain();

    //---------------------------------------------------------------
    // Track use of the thread block.  See the general comments on
    // thread destruction in threads.cpp, for details.
    //---------------------------------------------------------------
    int         IncExternalCount();
    void        DecExternalCount(BOOL holdingLock);

    
    // Get and Set the exposed System.Thread object which corresponds to
    // this thread.  Also the thread handle and Id.
    OBJECTREF   GetExposedObject();
    OBJECTREF   GetExposedObjectRaw();
    void        SetExposedObject(OBJECTREF exposed);
    OBJECTHANDLE *GetExposedObjectHandleForDebugger()
    {
        return &m_ExposedObject;
    }

    // Query whether the exposed object exists
    BOOL IsExposedObjectSet()
    {
        return (ObjectFromHandle(m_ExposedObject) != NULL) ;
    }

    // Access to the inherited security info
    OBJECTREF GetInheritedSecurityStack();
    CompressedStack* GetDelayedInheritedSecurityStack();
    void SetInheritedSecurityStack(OBJECTREF orStack);
    void SetDelayedInheritedSecurityStack(CompressedStack* pStack);
    bool CleanupInheritedSecurityStack(AppDomain *pDomain, DWORD domainId);

    // Access to thread handle and ThreadId.
    HANDLE      GetThreadHandle()
    {
        return m_ThreadHandle;
    }

    void        SetThreadHandle(HANDLE h)
    {
        _ASSERTE(m_ThreadHandle == INVALID_HANDLE_VALUE);
        m_ThreadHandle = h;
    }

    DWORD       GetThreadId()
    {
        return m_ThreadId;
    }

    void        SetThreadId(DWORD tid)
    {
        m_ThreadId = tid;
    }

    BOOL        IsThreadPoolThread() {return (m_State & TS_ThreadPoolThread); }

    // public suspend functions.  System ones are internal, like for GC.  User ones
    // correspond to suspend/resume calls on the exposed System.Thread object.
    void           UserSuspendThread();
    static HRESULT SysSuspendForGC(GCHeap::SUSPEND_REASON reason);
    static void    SysResumeFromGC(BOOL bFinishedGC, BOOL SuspendSucceded);
    static bool    SysStartSuspendForDebug(AppDomain *pAppDomain);
    static bool    SysSweepThreadsForDebug(bool forceSync);
    static void    SysResumeFromDebug(AppDomain *pAppDomain);
    BOOL           UserResumeThread();

    void           UserSleep(INT32 time);
    void           UserAbort(THREADBASEREF orThreadBase);
    void           UserResetAbort();
    void           UserInterrupt();
    void           ResetStopRequest();
    void           SetStopRequest();
    void           SetAbortRequest();

    // Tricks for resuming threads from fully interruptible code with a ThreadStop.
    void           ResumeUnderControl();

    enum InducedThrowReason {
        InducedThreadStop = 1,
        InducedStackOverflow = 2
    };

    DWORD          m_ThrewControlForThread;     // flag that is set when the thread deliberately raises an exception for stop/abort

    inline DWORD ThrewControlForThread()
    {
        return m_ThrewControlForThread;
    }

    inline void SetThrowControlForThread(InducedThrowReason reason)
    {
        m_ThrewControlForThread = reason;
    }

    inline void ResetThrowControlForThread()
    {
        m_ThrewControlForThread = 0;
    }

        PCONTEXT m_OSContext;       // ptr to a Context structure used to record the OS specific ThreadContext for a thread
                                    // this is used for thread stop/abort and is intialized on demand

    // These will only ever be called from the debugger's helper
    // thread.
    //
    // When a thread is being created after a debug suspension has
    // started, we get the event on the debugger helper thread. It
    // will turn around and call this to set the debug suspend pending
    // flag on the newly created flag, since it was missed by
    // SysStartSuspendForGC as it didn't exist when that function was
    // run.
    void           MarkForDebugSuspend();

    // When the debugger uses the trace flag to single step a thread,
    // it also calls this function to mark this info in the thread's
    // state. The out-of-process portion of the debugger will read the
    // thread's state for a variety of reasons, including looking for
    // this flag.
    void           MarkDebuggerIsStepping(bool onOff)
    {
        if (onOff)
            SetThreadStateNC(Thread::TSNC_DebuggerIsStepping);
        else
            ResetThreadStateNC(Thread::TSNC_DebuggerIsStepping);
    }

    // The debugger needs to be able to perform a UserStop on a
    // runtime thread. Since this will only ever happen from the
    // helper thread, we can't call the normal UserStop, since that
    // can throw a COM+ exception. This is a minor variant on UserStop
    // that does the same thing.
    void UserStopForDebugger();
    
    // Helpers to ensure that the bits for suspension and the number of active
    // traps remain coordinated.  GC uses a single trap for all the interesting
    // threads, so it should avoid these services.
    void           MarkForSuspension(ULONG bit);
    void           UnmarkForSuspension(ULONG mask);

    // Indicate whether this thread should run in the background.  Background threads
    // don't interfere with the EE shutting down.  Whereas a running non-background
    // thread prevents us from shutting down (except through System.Exit(), of course)
    void           SetBackground(BOOL isBack);

    // Retrieve the apartment state of the current thread. There are three possible
    // states: thread hosts an STA, thread is part of the MTA or thread state is
    // undecided. The last state may indicate that the apartment has not been set at
    // all (nobody has called CoInitializeEx) or that the EE does not know the
    // current state (EE has not called CoInitializeEx).
    enum ApartmentState { AS_InSTA, AS_InMTA, AS_Unknown };
    ApartmentState GetApartment();

    // Sets the apartment state if it has not already been set and
    // returns the state.
    ApartmentState GetFinalApartment();

    // Attempt to set current thread's apartment state. The actual apartment state
    // achieved is returned and may differ from the input state if someone managed to
    // call CoInitializeEx on this thread first (note that calls to SetApartment made
    // before the thread has started are guaranteed to succeed).
    // Note that even if we fail to set the requested state, we will still addref
    // COM by calling CoInitializeEx again with the other state.
    ApartmentState SetApartment(ApartmentState state);

    // when we get apartment tear-down notification, 
    // we want reset the apartment state we cache on the thread
    VOID ResetApartment();

    // When the thread starts running, make sure it is running in the correct apartment
    // and context.
    BOOL           PrepareApartmentAndContext();

    // If we are creating an object that requires a new apartment, create one.
    static Thread *CreateNewApartment();

    // All objects that require affinity, but can't match existing context requirements,
    // get created in a communal apartment.  Obviously that apartment gets carved up
    // into multiple different contexts -- but with a single thread servicing it all.
    static Thread *GetCommunalApartment();

    // For apartments that the EE is responsible for (as opposed to ones the application
    // is responsible for), pump the apartment.
    void           PumpApartment();

    // Either perform WaitForSingleObject or MsgWaitForSingleObject as appropriate.
    DWORD          DoAppropriateWait(int countHandles, HANDLE *handles, BOOL waitAll,
                                     DWORD millis, BOOL alertable,
                                     PendingSync *syncInfo = 0);
    DWORD          DoAppropriateWaitWorker(int countHandles, HANDLE *handles, BOOL waitAll,
                                           DWORD millis, BOOL alertable);

    DWORD          DoAppropriateAptStateWait(int numWaiters, HANDLE* pHandles, BOOL bWaitAll, DWORD timeout, BOOL alertable);

    //************************************************************************
    // Enumerate all frames.
    //************************************************************************
    
    /* Flags used for StackWalkFramesEx */
    
    #define FUNCTIONSONLY   0x1
    #define POPFRAMES       0x2
    
    /* use the following  flag only if you REALLY know what you are doing !!! */
    
    #define QUICKUNWIND     0x4           // do not restore all registers during unwind

    #define HANDLESKIPPEDFRAMES 0x10    // temporary to handle skipped frames for appdomain unload
                                        // stack crawl. Eventually need to always do this but it
                                        // breaks the debugger right now.

    StackWalkAction StackWalkFramesEx(
                        PREGDISPLAY pRD,        // virtual register set at crawl start
                        PSTACKWALKFRAMESCALLBACK pCallback,
                        VOID *pData,
                        unsigned flags,
                        Frame *pStartFrame = NULL);

    StackWalkAction StackWalkFrames(
                        PSTACKWALKFRAMESCALLBACK pCallback,
                        VOID *pData,
                        unsigned flags = 0,
                        Frame *pStartFrame = NULL);

    bool InitRegDisplay(const PREGDISPLAY, const PCONTEXT, bool validContext);

    bool UpdateThreadContext(const PCONTEXT);

    // Access the base and limit of this stack.  (I.e. the memory ranges that
    // the thread has reserved for its stack).
    //
    // Note that the base is at a higher address than the limit, since the stack
    // grows downwards.
    void         UpdateCachedStackInfo(ScanContext *sc);
    static void *GetNonCurrentStackBase(ScanContext *sc);
    static void *GetNonCurrentStackLimit(ScanContext *sc);

    // These access the stack base and limit values that are cached during InitThread
    void *GetCachedStackBase() { return (m_CacheStackBase); }
    void *GetCachedStackLimit() { return (m_CacheStackLimit); }

    // During a <clinit>, this thread must not be asynchronously
    // stopped or interrupted.  That would leave the class unavailable
    // and is therefore a security hole.  We don't have to worry about
    // multithreading, since we only manipulate the current thread's count.
    void        IncPreventAsync()
    {
        _ASSERTE(GetThread() == this);  // not using FastInterlockInc
        m_PreventAsync++;
    }
    void        DecPreventAsync()
    {
        _ASSERTE(GetThread() == this);  // no using FastInterlockInc
        m_PreventAsync--;
    }

    // The ThreadStore manages a list of all the threads in the system.  I
    // can't figure out how to expand the ThreadList template type without
    // making m_LinkStore public.
    SLink       m_LinkStore;

    // For N/Direct calls with the "setLastError" bit, this field stores
    // the errorcode from that call.
    DWORD       m_dwLastError;

    // Debugger per-thread flag for enabling notification on "manual" 
    // method calls,  for stepping logic
    void IncrementTraceCallCount();
    void DecrementTraceCallCount();
    
    FORCEINLINE int IsTraceCall()
    {
        return m_TraceCallCount;
    }

    // Functions to get culture information for thread.
    int GetParentCultureName(LPWSTR szBuffer, int length, BOOL bUICulture);
    int GetCultureName(LPWSTR szBuffer, int length, BOOL bUICulture);
    LCID GetCultureId(BOOL bUICulture);
    OBJECTREF GetCulture(BOOL bUICulture);

    // Functions to set the culture on the thread.
    void SetCultureId(LCID lcid, BOOL bUICulture);
    void SetCulture(OBJECTREF CultureObj, BOOL bUICulture);

private:
    // Used by the culture accesors.
    INT64 CallPropertyGet(BinderMethodID id, OBJECTREF pObject);
    INT64 CallPropertySet(BinderMethodID id, OBJECTREF pObject, OBJECTREF pValue);

    // Used in suspension code to redirect a thread at a HandledJITCase
    BOOL RedirectThreadAtHandledJITCase(PFN_REDIRECTTARGET pTgt);

    // Will Redirect the thread using RedirectThreadAtHandledJITCase if necessary
    BOOL CheckForAndDoRedirect(PFN_REDIRECTTARGET pRedirectTarget);
    BOOL CheckForAndDoRedirectForDbg();
    BOOL CheckForAndDoRedirectForGC();
    BOOL CheckForAndDoRedirectForUserSuspend();

    // Exception handling must be very aware of redirection, so we provide a helper
    // to identifying redirection targets
    static BOOL IsAddrOfRedirectFunc(void * pFuncAddr);


private:
    static void * GetStackLowerBound();
    static void * GetStackUpperBound();

public:

    // This will return the remaining stack space for a suspended thread,
    // excluding the guard pages
    size_t GetRemainingStackSpace(size_t esp);
    BOOL GuardPageOK();
    VOID FixGuardPage();        // Will fail fast w/ fatal stack overflow if there is < 1 page free stack.


private:
    // Redirecting of threads in managed code at suspension
    
    enum SuspendReason {
        GCSuspension,
        DebugSuspension,
        UserSuspend
    };
    static void __stdcall RedirectedHandledJITCase(SuspendReason reason);
    static void __stdcall RedirectedHandledJITCaseForDbgThreadControl();
    static void __stdcall RedirectedHandledJITCaseForGCThreadControl();
    static void __stdcall RedirectedHandledJITCaseForUserSuspend();

    friend void CPFH_AdjustContextForThreadSuspensionRace(CONTEXT *pContext, Thread *pThread);

private:
    //-------------------------------------------------------------
    // Waiting & Synchronization
    //-------------------------------------------------------------

    // For suspends.  The thread waits on this event.  A client sets the event to cause
    // the thread to resume.
    void    WaitSuspendEvent(BOOL fDoWait = TRUE);
    void    SetSuspendEvent();
    void    ClearSuspendEvent();

    // For getting a thread to a safe point.  A client waits on the event, which is
    // set by the thread when it reaches a safe spot.
    void    FinishSuspendingThread();
    void    SetSafeEvent();
    void    ClearSafeEvent();

    // Add and remove hijacks for JITted calls.
    void    HijackThread(VOID *pvHijackAddr, ExecutionState *esb);
    void    UnhijackThread();
    BOOL    HandledJITCase();

    VOID          *m_pvHJRetAddr;             // original return address (before hijack)
    VOID         **m_ppvHJRetAddrPtr;         // place we bashed a new return address
    MethodDesc  *m_HijackedFunction;        // remember what we hijacked


    DWORD       m_Win32FaultAddress;
    DWORD       m_Win32FaultCode;


    // Support for Wait/Notify
    BOOL        Block(INT32 timeOut, PendingSync *syncInfo);
    void        Wake(SyncBlock *psb);
    DWORD       Wait(HANDLE *objs, int cntObjs, INT32 timeOut, PendingSync *syncInfo);

    // support for Thread.Interrupt() which breaks out of Waits, Sleeps, Joins
    LONG         m_UserInterrupt;
    DWORD        IsUserInterrupted(BOOL reset);

#ifdef _WIN64
    static void UserInterruptAPC(ULONG_PTR ignore);
#else // !_WIN64
    static void UserInterruptAPC(DWORD ignore);
#endif // _WIN64


#if defined(_DEBUG) && defined(TRACK_SYNC)

// Each thread has a stack that tracks all enter and leave requests
public:
    Dbg_TrackSync   *m_pTrackSync;

#endif // TRACK_SYNC

private:
    

#ifdef _DEBUG
    ULONG  m_ulGCForbidCount;
    ULONG  m_ulEnablePreemptiveGCCount;
    ULONG  m_ulReadyForSuspensionCount;
#endif

#ifdef _DEBUG
public:
    // Used by THROWSCOMPLUSEXCEPTION() macro to locate COMPLUS_TRY during a
    // stack crawl.
    LPVOID m_ComPlusCatchDepth;
#endif

private:
    // For suspends:
    HANDLE          m_SafeEvent;
    HANDLE          m_SuspendEvent;

    // For Object::Wait, Notify and NotifyAll, we use an Event inside the
    // thread and we queue the threads onto the SyncBlock of the object they
    // are waiting for.
    HANDLE          m_EventWait;
    WaitEventLink   m_WaitEventLink;
    WaitEventLink* WaitEventLinkForSyncBlock (SyncBlock *psb)
    {
        WaitEventLink *walk = &m_WaitEventLink;
        while (walk->m_Next) {
            _ASSERTE (walk->m_Next->m_Thread == this);
            if ((SyncBlock*)(((DWORD_PTR)walk->m_Next->m_WaitSB) & ~1)== psb) {
                break;
            }
            walk = walk->m_Next;
        }
        return walk;
    }

    // We maintain a correspondence between this object, the ThreadId and ThreadHandle
    // in Win32, and the exposed Thread object.
    HANDLE          m_ThreadHandle;
    HANDLE          m_ThreadHandleForClose;
    DWORD           m_ThreadId;
    OBJECTHANDLE    m_ExposedObject;
    OBJECTHANDLE    m_StrongHndToExposedObject;

    DWORD           m_Priority;     // initialized to INVALID_THREAD_PRIORITY, set to actual priority when a 
                                    // thread does a busy wait for GC, reset to INVALID_THREAD_PRIORITY after wait is over 
    friend class NDirect; // Quick access to thread stub creation
    friend BOOL OnGcCoverageInterrupt(PCONTEXT regs);  // Needs to call UnhijackThread

    ULONG           m_ExternalRefCount;

    LONG                    m_TraceCallCount;
    
    //-----------------------------------------------------------
    // Bytes promoted on this thread since the last GC?
    //-----------------------------------------------------------
    DWORD           m_fPromoted;
public:
    void SetHasPromotedBytes ();
    DWORD GetHasPromotedBytes () { return m_fPromoted; }

private:
    //-----------------------------------------------------------
    // Last exception to be thrown.
    //-----------------------------------------------------------
    friend class EEDbgInterfaceImpl;
    //---------------------------------------------------------------
    // Exception handler info
    //---------------------------------------------------------------
    
private:
    OBJECTHANDLE m_LastThrownObjectHandle;      // Unsafe to use directly.  Use accessors instead.

public:
    OBJECTREF LastThrownObject() {
        if (m_LastThrownObjectHandle == NULL)
            return NULL;
        else
            return ObjectFromHandle(m_LastThrownObjectHandle);
    }

    void SetLastThrownObject(OBJECTREF throwable);

    void SetLastThrownObjectHandleAndLeak(OBJECTHANDLE h) {
        m_LastThrownObjectHandle = h;
    }

    void SetKickOffDomain(AppDomain *pDomain);
    AppDomain *GetKickOffDomain();

private:
    DWORD m_pKickOffDomainId; 

    ExInfo m_handlerInfo;
    
    //-----------------------------------------------------------
    // Inherited code-access security permissions for the thread.
    //-----------------------------------------------------------
    CompressedStack* m_compressedStack;

    //-----------------------------------------------------------
    // If the thread has wandered in from the outside this is
    // its Domain. This is temporary until domains are true contexts
    //-----------------------------------------------------------
    AppDomain      *m_pDomain;

    //---------------------------------------------------------------
    // Context pointer, set in exception filter (used by debugger)
    //---------------------------------------------------------------
    friend class EEDbgInterfaceImpl;

    //---------------------------------------------------------------
    // m_debuggerWord1 holds the threads "filter context" for the
    // debugger.
    //---------------------------------------------------------------
    void *m_debuggerWord1;

    //---------------------------------------------------------------
    // m_debuggerCantStop holds a count of entries into "can't stop"
    // areas that the Interop Debugging Services must know about.
    //---------------------------------------------------------------
    DWORD m_debuggerCantStop;
    
    //---------------------------------------------------------------
    // A word reserved for use by the CLR Debugging Services during
    // managed/unmanaged debugging.
    //---------------------------------------------------------------
    DWORD    m_debuggerWord2;

    //-------------------------------------------------------------------------
    // Number of Deny and PermitOnly security actions on the current call stack
    //-------------------------------------------------------------------------
    DWORD   m_dNumAccessOverrides;

    //-------------------------------------------------------------------------
    // AppDomains on the current call stack
    //-------------------------------------------------------------------------
    AppDomainStack  m_ADStack;

    //-------------------------------------------------------------------------
    // State of the PLS Optimization on this thread (on = true, off = false)
    //-------------------------------------------------------------------------
    BOOL m_fPLSOptimizationState;

    //-------------------------------------------------------------------------
    // Support creation of assemblies in DllMain (see ceemain.cpp)
    //-------------------------------------------------------------------------
    IAssembly* m_pFusionAssembly;    // Will be set when creating an assembly
    Assembly*  m_pAssembly;          // Will be set when loading a module in an assembly
    mdFile     m_pModuleToken;       // Module token when loading a module.
protected:
    // Hash table that maps a domain id to a LocalDataStore*
    EEIntHashTable* m_pDLSHash;

    // MethodTable and constructor MethodDesc used to set the culture
    // ID for the thread.
    static TypeHandle m_CultureInfoType;
    static MethodDesc *m_CultureInfoConsMD;

public:

    void SetPLSOptimizationState( BOOL state )
    {
        // The only synchronization here is that we only change
        // this setting ourselves.

        _ASSERTE( this == GetThread() && "You can only change this threading on yourself" );

        m_fPLSOptimizationState = state;
    }

    BOOL GetPLSOptimizationState( void )
    {
        return m_fPLSOptimizationState;
    }

    void SetOverridesCount(DWORD numAccessOverrides)
    {
        m_dNumAccessOverrides = numAccessOverrides;
    }

    DWORD IncrementOverridesCount()
    {
        return ++m_dNumAccessOverrides;
    }

    DWORD DecrementOverridesCount()
    {
        _ASSERTE(m_dNumAccessOverrides > 0);
        if (m_dNumAccessOverrides > 0)
            return --m_dNumAccessOverrides;
        return 0;
    }

    DWORD GetOverridesCount()
    {
        return m_dNumAccessOverrides;
    }

    void PushDomain(AppDomain *pDomain)
    {
        m_ADStack.PushDomain(pDomain);
    }

    AppDomain * PopDomain()
    {
        return m_ADStack.PopDomain();
    }

    DWORD GetNumAppDomainsOnThread()
    {
        return m_ADStack.GetNumDomains();
    }

    void InitDomainIteration(DWORD *pIndex)
    {
        m_ADStack.InitDomainIteration(pIndex);
    }

    AppDomain *GetNextDomainOnStack(DWORD *pIndex)
    {
        return m_ADStack.GetNextDomainOnStack(pIndex);
    }

    const AppDomainStack& GetAppDomainStack( void )
    {
        return m_ADStack;
    }

    void CarryOverSecurityInfo(Thread *pFromThread)
    {
        SetOverridesCount(pFromThread->GetOverridesCount());
        m_ADStack = pFromThread->m_ADStack;
    }

    void CarryOverSecurityInfo( DWORD overrides, const AppDomainStack& ADStack )
    {
        SetOverridesCount( overrides );
        m_ADStack = ADStack;
    }

    void AppendSecurityInfo( DWORD overrides, const AppDomainStack& ADStack )
    {
        SetOverridesCount( GetOverridesCount() + overrides );

        // We want to form the new stack such that the existing entries
        // on the thread appear on the top of the stack.  Therefore, we
        // copy the input stack and push the entries from the thread on top
        // taking care to push them in the correct order.

        AppDomainStack newStack = ADStack;

        newStack.AppendStack( this->m_ADStack );

        m_ADStack = newStack;
    }

    void DeductSecurityInfo( DWORD overrides, const AppDomainStack& ADStack )
    {
        _ASSERTE( this->GetOverridesCount() >= overrides );
        _ASSERTE( GetThread() == this );

        SetOverridesCount( GetOverridesCount() - overrides );

        m_ADStack.DeductStack( ADStack );
    }

    void ResetSecurityInfo( void )
    {
        SetOverridesCount( 0 );
        m_ADStack.ClearDomainStack();
    }

    void SetFilterContext(CONTEXT *pContext);
    CONTEXT *GetFilterContext(void);
    
    void SetDebugCantStop(bool fCantStop);
    bool GetDebugCantStop(void);
    
    static LPVOID GetStaticFieldAddress(FieldDesc *pFD);
    LPVOID GetStaticFieldAddrForDebugger(FieldDesc *pFD);
    static BOOL UniqueStack();

    void SetFusionAssembly(IAssembly* pAssembly)
    {
        if(m_pFusionAssembly)
            m_pFusionAssembly->Release();

        m_pFusionAssembly = pAssembly;

        if(m_pFusionAssembly)
            m_pFusionAssembly->AddRef();
    }

    IAssembly* GetFusionAssembly()
    {
        if(m_pFusionAssembly)
            m_pFusionAssembly->AddRef();

        return m_pFusionAssembly;
    }

    void SetAssembly(Assembly* pAssembly)
    {
        m_pAssembly = pAssembly;
    }
    
    Assembly* GetAssembly()
    {
        return m_pAssembly;
    }

    void SetAssemblyModule(mdFile kFile)
    {
        m_pModuleToken = kFile;
    }

    mdFile GetAssemblyModule()
    {
        return m_pModuleToken;
    }

#ifdef _DEBUG
    // Verify that the cached stack base is for the current thread.
    BOOL HasRightCacheStackBase()
    {
        return m_CacheStackBase == GetStackUpperBound();
    }
#endif

private:
    // Don't allow a thread to be asynchronously stopped or interrupted (e.g. because
    // it is performing a <clinit>)
    int         m_PreventAsync;

    // Access the base and limit of the stack.  (I.e. the memory ranges that
    // the thread has reserved for its stack).
    //
    // Note that the base is at a higher address than the limit, since the stack
    // grows downwards.
    //
    // Note that we generally access the stack of the thread we are crawling, which
    // is cached in the ScanContext
    void       *m_CacheStackBase;
    void       *m_CacheStackLimit;

    static long m_DebugWillSyncCount;

    // Are we shutting down the process?
    static BOOL    IsAtProcessExit();

    // IP cache used by QueueCleanupIP.
    #define CLEANUP_IPS_PER_CHUNK 4
    struct CleanupIPs {
        IUnknown    *m_Slots[CLEANUP_IPS_PER_CHUNK];
        CleanupIPs  *m_Next;
        CleanupIPs() { memset(this, 0, sizeof(*this)); }
    };
    CleanupIPs   m_CleanupIPs;
    
#define BEGIN_FORBID_TYPELOAD() INDEBUG(GetThread() == 0 || GetThread()->m_ulForbidTypeLoad++) 
#define END_FORBID_TYPELOAD()   _ASSERTE(GetThread() == 0 || GetThread()->m_ulForbidTypeLoad--) 
#define TRIGGERS_TYPELOAD()     _ASSERTE(GetThread() == 0 || !GetThread()->m_ulForbidTypeLoad) 

#ifdef _DEBUG
public:
    DWORD m_GCOnTransitionsOK;
    ULONG  m_ulForbidTypeLoad;


/****************************************************************************/
/* The code below an attempt to catch people who don't protect GC pointers that
   they should be protecting.  Basically, OBJECTREF's constructor, adds the slot
   to a table.   When we protect a slot, we remove it from the table.  When GC 
   could happen, all entries in the table are marked as bad.  When access to 
   an OBJECTREF happens (the -> operator) we assert the slot is not bad.  To make
   this fast, the table is not perfect (there can be collisions), but this should
   not cause false positives, but it may allow errors to go undetected  */
        
        // For debugging, you may want to make this number very large, (8K)
        // should basically insure that no collisions happen 
#define OBJREF_TABSIZE              256      
        size_t dangerousObjRefs[OBJREF_TABSIZE];      // Really objectRefs with lower bit stolen

        static unsigned int OBJREF_HASH;
        // Remembers that this object ref pointer is 'alive' and unprotected (Bad if GC happens)
        static void ObjectRefNew(const OBJECTREF* ref) {
            Thread* curThread = GetThread();
            if (curThread == 0) return;
            
            curThread->dangerousObjRefs[((size_t)ref >> 2) % OBJREF_HASH] = (size_t)ref;
        }
        
        static void ObjectRefAssign(const OBJECTREF* ref) {
            Thread* curThread = GetThread();
            if (curThread == 0) return;
            
            unsigned* slot = &curThread->dangerousObjRefs[((size_t) ref >> 2) % OBJREF_HASH];
            if ((*slot & ~3) == (size_t) ref)
                *slot = (unsigned) *slot & ~1;                  // Don't care about GC's that have happened
        }
        
        // If an object is protected, it can be removed from the 'dangerous table' 
        static void ObjectRefProtected(const OBJECTREF* ref) {
            _ASSERTE(IsObjRefValid(ref));
            Thread* curThread = GetThread();
            if (curThread == 0) return;
            
            size_t* slot = &curThread->dangerousObjRefs[((size_t) ref >> 2) % OBJREF_HASH];
            if ((*slot & ~3) == (size_t) ref)
                *slot = (size_t) ref | 2;                             // mark has being protected
        }
        
        static bool IsObjRefValid(const OBJECTREF* ref) {
            Thread* curThread = GetThread();
            if (curThread == 0) return(true);
            
            // If the object ref is NULL, we'll let it pass.
            if (*((int *) ref) == 0)
                return(true);
            
            size_t val = curThread->dangerousObjRefs[((size_t) ref >> 2) % OBJREF_HASH];
            // if not in the table, or not the case that it was unprotected and GC happened, return true. 
            if((val & ~3) != (size_t) ref || (val & 3) != 1)
                return(true);
            // If the pointer lives in the GC heap, than it is protected, and thus valid.  
            if ((size_t)g_lowest_address <= val && val < (size_t)g_highest_address)
                return(true);
            return(false);
        }
        
        // Clears the table.  Useful to do when crossing the managed-code - EE boundary
        // as you ususally only care about OBJECTREFS that have been created after that
        static void ObjectRefFlush(Thread* thread);
        
        // Marks all Objrefs in the table as bad (since they are unprotected)
        static void TriggersGC(Thread* thread) {
            for(unsigned i = 0; i < OBJREF_TABSIZE; i++)
                thread->dangerousObjRefs[i] |= 1;                       // mark all slots as GC happened
        }
#endif

private:
        _NT_TIB* m_pTEB;
public:
        _NT_TIB* GetTEB() {
            return m_pTEB;
        }

private:
    PCONTEXT m_pCtx;

public:

    PCONTEXT GetSavedRedirectContext() { return (m_pCtx); }
    void     SetSavedRedirectContext(PCONTEXT pCtx) { m_pCtx = pCtx; }
    inline STATIC_DATA *GetSharedStaticData() { return m_pSharedStaticData; }
    inline STATIC_DATA *GetUnsharedStaticData() { return m_pUnsharedStaticData; }

protected:
    static MethodDesc *GetDLSRemoveMethod();
    LocalDataStore *RemoveDomainLocalStore(int iAppDomainId);
    void RemoveAllDomainLocalStores();
    static void RemoveDLSFromList(LocalDataStore* pLDS);
    void DeleteThreadStaticData(AppDomain *pDomain);
    void DeleteThreadStaticClassData(_STATIC_DATA* pData, BOOL fClearFields);

private:
    static MethodDesc *s_pReserveSlotMD;
    // The following variables are used to store thread local static data
    STATIC_DATA  *m_pUnsharedStaticData;
    STATIC_DATA  *m_pSharedStaticData;

    EEPtrHashTable *m_pStaticDataHash;

    static void AllocateStaticFieldObjRefPtrs(FieldDesc *pFD, MethodTable *pMT, LPVOID pvAddress);
    static MethodDesc *GetMDofReserveSlot();
    static LPVOID CalculateAddressForManagedStatic(int slot, Thread *pThread);
    static void FreeThreadStaticSlot(int slot, Thread *pThread);
    static BOOL GetStaticFieldAddressSpecial(FieldDesc *pFD, MethodTable *pMT, int *pSlot, LPVOID *ppvAddress);
    STATIC_DATA_LIST *SetStaticData(AppDomain *pDomain, STATIC_DATA *pSharedData, STATIC_DATA *pUnsharedData);    
    STATIC_DATA_LIST *SafeSetStaticData(AppDomain *pDomain, STATIC_DATA *pSharedData, STATIC_DATA *pUnsharedData);    
    void DeleteThreadStaticData();

#ifdef _DEBUG
private:
    // When we create an object, or create an OBJECTREF, or create an Interior Pointer, or enter EE from managed
    // code, we will set this flag.
    // Inside GCHeap::StressHeap, we only do GC if this flag is TRUE.  Then we reset it to zero.
    BOOL m_fStressHeapCount;
public:
    void EnableStressHeap()
    {
        m_fStressHeapCount = TRUE;
    }
    void DisableStressHeap()
    {
        m_fStressHeapCount = FALSE;
    }
    BOOL StressHeapIsEnabled()
    {
        return m_fStressHeapCount;
    }

    size_t *m_pCleanedStackBase;
#endif

#ifdef STRESS_THREAD
public:
    LONG  m_stressThreadCount;
#endif
};



// ---------------------------------------------------------------------------
//
//      The ThreadStore manages all the threads in the system.
//
// There is one ThreadStore in the system, available through g_pThreadStore.
// ---------------------------------------------------------------------------

typedef SList<Thread, offsetof(Thread, m_LinkStore)> ThreadList;


// The ThreadStore is a singleton class
#define CHECK_ONE_STORE()       _ASSERTE(this == g_pThreadStore);

class ThreadStore
{
    friend class Thread;
    friend Thread* SetupThread();
    friend class AppDomain;
    friend HRESULT InitializeMiniDumpBlock();
    friend struct MEMBER_OFFSET_INFO(ThreadStore);

public:

    ThreadStore();

    static BOOL InitThreadStore();
#ifdef SHOULD_WE_CLEANUP
        static void ReleaseExposedThreadObjects();
#endif /* SHOULD_WE_CLEANUP */
#ifdef SHOULD_WE_CLEANUP
    static void TerminateThreadStore();
#endif /* SHOULD_WE_CLEANUP */
#ifdef SHOULD_WE_CLEANUP
    void        Shutdown();
#endif /* SHOULD_WE_CLEANUP */

    static void LockThreadStore(GCHeap::SUSPEND_REASON reason = GCHeap::SUSPEND_OTHER,
                                BOOL threadCleanupAllowed = TRUE);
    static void UnlockThreadStore();

    static void LockDLSHash();
    static void UnlockDLSHash();

    // Add a Thread to the ThreadStore
    static void AddThread(Thread *newThread);

    // RemoveThread finds the thread in the ThreadStore and discards it.
    static BOOL RemoveThread(Thread *target);

    // Transfer a thread from the unstarted to the started list.
    static void TransferStartedThread(Thread *target);

    // Before using the thread list, be sure to take the critical section.  Otherwise
    // it can change underneath you, perhaps leading to an exception after Remove.
    // Prev==NULL to get the first entry in the list.
    static Thread *GetAllThreadList(Thread *Prev, ULONG mask, ULONG bits);
    static Thread *GetThreadList(Thread *Prev);

    // Every EE process can lazily create a GUID that uniquely identifies it (for
    // purposes of remoting).  
    const GUID    &GetUniqueEEId();

    enum ThreadStoreState
    {
        TSS_Normal       = 0,
        TSS_ShuttingDown = 1,

    }              m_StoreState;

    // We shut down the EE when the last non-background thread terminates.  This event
    // is used to signal the main thread when this condition occurs.
    void            WaitForOtherThreads();
    static void     CheckForEEShutdown();
    HANDLE          m_TerminationEvent;

    // Have all the foreground threads completed?  In other words, can we release
    // the main thread?
    BOOL        OtherThreadsComplete()
    {
        _ASSERTE(m_ThreadCount - m_UnstartedThreadCount - m_DeadThreadCount - Thread::m_ActiveDetachCount >= m_BackgroundThreadCount);

        return (m_ThreadCount - m_UnstartedThreadCount - m_DeadThreadCount
                - Thread::m_ActiveDetachCount + m_PendingThreadCount
                == m_BackgroundThreadCount);
    }

    // If you want to trap threads re-entering the EE (be this for GC, or debugging,
    // or Thread.Suspend() or whatever, you need to TrapReturningThreads(TRUE).  When
    // you are finished snagging threads, call TrapReturningThreads(FALSE).  This
    // counts internally.
    //
    // Of course, you must also fix RareDisablePreemptiveGC to do the right thing
    // when the trap occurs.
    static void     TrapReturningThreads(BOOL yes);

    // This is used to avoid thread starvation if non-GC threads are competing for
    // the thread store lock when there is a real GC-thread waiting to get in.
    // This is initialized lazily when the first non-GC thread backs out because of
    // a waiting GC thread.  The s_hAbortEvtCache is used to store the handle when
    // it is not being used.
    static HANDLE s_hAbortEvt;
    static HANDLE s_hAbortEvtCache;

    Crst *GetDLSHashCrst()
    {
#ifndef _DEBUG
        return NULL;
#else
        return &m_HashCrst;
#endif
    }

private:

    // Enter and leave the critical section around the thread store.  Clients should
    // use LockThreadStore and UnlockThreadStore.
    void Enter()
    {
        CHECK_ONE_STORE();
        m_Crst.Enter();
    }

    void Leave()
    {
        CHECK_ONE_STORE();
        m_Crst.Leave();
    }

    // Critical section for adding and removing threads to the store
    Crst        m_Crst;

    // Critical section for adding and removing domain local stores for
    // a thread's hash table.
    Crst        m_HashCrst;
    void EnterDLSHashLock()
    {
        CHECK_ONE_STORE();
        m_HashCrst.Enter();
    }

    void LeaveDLSHashLock()
    {
        CHECK_ONE_STORE();
        m_HashCrst.Leave();
    }

    // List of all the threads known to the ThreadStore (started & unstarted).
    ThreadList  m_ThreadList;

    // m_ThreadCount is the count of all threads in m_ThreadList.  This includes
    // background threads / unstarted threads / whatever.
    //
    // m_UnstartedThreadCount is the subset of m_ThreadCount that have not yet been
    // started.
    //
    // m_BackgroundThreadCount is the subset of m_ThreadCount that have been started
    // but which are running in the background.  So this is a misnomer in the sense
    // that unstarted background threads are not reflected in this count.
    //
    // m_PendingThreadCount is used to solve a race condition.  The main thread could
    // start another thread running and then exit.  The main thread might then start
    // tearing down the EE before the new thread moves itself out of m_UnstartedThread-
    // Count in TransferUnstartedThread.  This count is atomically bumped in
    // CreateNewThread, and atomically reduced within a locked thread store.
    //
    // m_DeadThreadCount is the subset of m_ThreadCount which have died.  The Win32
    // thread has disappeared, but something (like the exposed object) has kept the
    // refcount non-zero so we can't destruct yet.

protected:
    LONG        m_ThreadCount;
#ifdef _DEBUG
public:
    LONG        ThreadCountInEE ()
    {
        return m_ThreadCount;
    }
#endif
private:
    LONG        m_UnstartedThreadCount;
    LONG        m_BackgroundThreadCount;
    LONG        m_PendingThreadCount;
    LONG        m_DeadThreadCount;

    // Space for the lazily-created GUID.
    GUID        m_EEGuid;
    BOOL        m_GuidCreated;

    // Even in the release product, we need to know what thread holds the lock on
    // the ThreadStore.  This is so we never deadlock when the GC thread halts a
    // thread that holds this lock.
    Thread     *m_HoldingThread;
    DWORD       m_holderthreadid;   // current holder (or NULL)

    // An incarnation number incremented every time that state of the thread
    // store changes (threads are added or removed). This is useful for
    // synchronization in those cases where it's not possible to hold the thread
    // store lock over store enumerations.
    DWORD       m_dwIncarnation;

public:
    static BOOL HoldingThreadStore()
    {
        // Note that GetThread() may be 0 if it is the debugger thread
        // or perhaps a concurrent GC thread.
        return HoldingThreadStore(GetThread());
    }

    static BOOL HoldingThreadStore(Thread *pThread);
    
    static DWORD GetIncarnation();

#ifdef _DEBUG
public:
    BOOL        DbgFindThread(Thread *target);
    LONG        DbgBackgroundThreadCount()
    {
        return m_BackgroundThreadCount;
    }

    BOOL IsCrstForThreadStore (const BaseCrst* const pBaseCrst)
    {
        return (void *)pBaseCrst == (void*)&m_Crst;
    }
    
#endif
};

// This class dispenses small thread ids for the thin lock mechanism
class IdDispenser
{
private:
    DWORD       m_highestId;          // highest id given out so far
    DWORD      *m_recycleBin;         // vector of ids given back to us
    DWORD       m_recycleCount;       // number of ids available
    DWORD       m_recycleCapacity;    // capacity of recycle bin
    Crst        m_Crst;               // lock to protect our data structures
    Thread    **m_idToThread;         // map thread ids to threads
    DWORD       m_idToThreadCapacity; // capacity of the map

    void GrowIdToThread()
    {                
        DWORD newCapacity = m_idToThreadCapacity == 0 ? 16 : m_idToThreadCapacity*2;
        Thread **newIdToThread = new Thread*[newCapacity];

        for (DWORD i = 0; i < m_idToThreadCapacity; i++)
        {
            newIdToThread[i] = m_idToThread[i];
        }
        for (DWORD j = m_idToThreadCapacity; j < newCapacity; j++)
        {
            newIdToThread[j] = NULL;
        }
        delete m_idToThread;
        m_idToThread = newIdToThread;
        m_idToThreadCapacity = newCapacity;
    }

    void GrowRecycleBin()
    {
        DWORD newCapacity = m_recycleCapacity <= 0 ? 10 : m_recycleCapacity*2;
        DWORD* newRecycleBin = new DWORD[newCapacity];

        for (DWORD i = 0; i < m_recycleCount; i++)
            newRecycleBin[i] = m_recycleBin[i];
        delete[] m_recycleBin;
        m_recycleBin = newRecycleBin;
        m_recycleCapacity = newCapacity;
    }

public:
    IdDispenser() : m_Crst("ThreadIdDispenser", CrstThreadIdDispenser)
    {
        m_highestId = 0;
        m_recycleBin = NULL;
        m_recycleCount = 0;
        m_recycleCapacity = 0;
        m_idToThreadCapacity = 0;
        m_idToThread = NULL;
    }

    ~IdDispenser()
    {
        delete[] m_recycleBin;
        delete[] m_idToThread;
    }

    bool IsValidId(DWORD id)
    {
        return (id > 0) && (id <= m_highestId);
    }

    DWORD NewId(Thread *pThread)
    {
        m_Crst.Enter();
        DWORD result;
        if (m_recycleCount > 0)
        {
            result = m_recycleBin[--m_recycleCount];
        }
        else
        {
            // we make sure ids don't wrap around - before they do, we always return the highest possible
            // one and rely on our caller to detect this situation
            if (m_highestId + 1 > m_highestId)
                m_highestId = m_highestId + 1;
            result = m_highestId;
        }

        if (result >= m_idToThreadCapacity)
            GrowIdToThread();
        _ASSERTE(result < m_idToThreadCapacity);
        if (result < m_idToThreadCapacity)
            m_idToThread[result] = pThread;

        m_Crst.Leave();

        return result;
    }

    void DisposeId(DWORD id)
    {
        m_Crst.Enter();
        _ASSERTE(IsValidId(id));
        if (id == m_highestId)
        {
            m_highestId--;
        }
        else
        {
            if (m_recycleCount >= m_recycleCapacity)
                GrowRecycleBin();
            _ASSERTE(m_recycleCount < m_recycleCapacity);
            m_recycleBin[m_recycleCount++] = id;
        }
        m_Crst.Leave();
    }

    Thread *IdToThread(DWORD id)
    {
        m_Crst.Enter();
        Thread *result = NULL;
        if (id < m_idToThreadCapacity)
            result = m_idToThread[id];
        m_Crst.Leave();

        return result;
    }
};

// Dispenser of small thread ids for thin lock mechanism
extern IdDispenser *g_pThinLockThreadIdDispenser;


// forward declaration
DWORD MsgWaitHelper(int numWaiters, HANDLE* phEvent, BOOL bWaitAll, DWORD millis, BOOL alertable = FALSE);

// When a thread is being created after a debug suspension has started, it sends an event up to the
// debugger. Afterwards, with the Debugger Lock still held, it will check to see if we had already asked to suspend the
// Runtime. If we have, then it will turn around and call this to set the debug suspend pending flag on the newly
// created thread, since it was missed by SysStartSuspendForDebug as it didn't exist when that function was run.
//
inline void Thread::MarkForDebugSuspend(void)
{
    if (!(m_State & TS_DebugSuspendPending))
    {
        FastInterlockOr((ULONG *) &m_State, TS_DebugSuspendPending);
        ThreadStore::TrapReturningThreads(TRUE);
    }
}

// Debugger per-thread flag for enabling notification on "manual"
// method calls, for stepping logic.

inline void Thread::IncrementTraceCallCount()
{
    FastInterlockIncrement(&m_TraceCallCount);
    ThreadStore::TrapReturningThreads(TRUE);
}
    
inline void Thread::DecrementTraceCallCount()
{
    FastInterlockDecrement(&m_TraceCallCount);
    ThreadStore::TrapReturningThreads(FALSE);
}
    
// When we enter an Object.Wait() we are logically inside the synchronized
// region of that object.  Of course, we've actually completely left the region,
// or else nobody could Notify us.  But if we throw ThreadInterruptedException to
// break out of the Wait, all the catchers are going to expect the synchronized
// state to be correct.  So we carry it around in case we need to restore it.
struct PendingSync
{
    LONG            m_EnterCount;
    WaitEventLink  *m_WaitEventLink;
#ifdef _DEBUG
    Thread         *m_OwnerThread;
#endif

    PendingSync(WaitEventLink *s) : m_WaitEventLink(s)
    {
#ifdef _DEBUG
        m_OwnerThread = GetThread();
#endif
    }
    void Restore(BOOL bRemoveFromSB);
};

// Per-domain local data store
class LocalDataStore
{
public:
    friend class ThreadNative;

    LocalDataStore() 
    {
        m_ExposedTypeObject = CreateGlobalHandle(NULL);
    }

    ~LocalDataStore()
    {
        // Destroy the class object...
        if(m_ExposedTypeObject != NULL) {
            DestroyGlobalHandle(m_ExposedTypeObject);
            m_ExposedTypeObject = NULL;
        }
    }

    OBJECTREF GetRawExposedObject()
    {
        return ObjectFromHandle(m_ExposedTypeObject);
    }

protected:

    OBJECTHANDLE   m_ExposedTypeObject;
};

#define INCTHREADLOCKCOUNT()                                    \
{                                                               \
        Thread *thread = GetThread();                           \
        if (thread)                                             \
            thread->IncLockCount();                             \
}

#define DECTHREADLOCKCOUNT( )                                   \
{                                                               \
        Thread *thread = GetThread();                           \
        if (thread)                                             \
            thread->DecLockCount();                             \
}

class AutoCooperativeGC
{
public:
    AutoCooperativeGC(BOOL fConditional = TRUE)
    {
        if (!fConditional)
            fToggle = FALSE;
        else {
            pThread = GetThread();
            fToggle = pThread && !pThread->PreemptiveGCDisabled();
            if (fToggle) {
                pThread->DisablePreemptiveGC();
            }
        }
    }

    ~AutoCooperativeGC()
    {
        if (fToggle) {
            pThread->EnablePreemptiveGC();
        }
    }

private:
    Thread *pThread;
    BOOL fToggle;
};

class AutoPreemptiveGC
{
public:
    AutoPreemptiveGC(BOOL fConditional = TRUE)
    {
        if (!fConditional)
            fToggle = FALSE;
        else {
            pThread = GetThread();
            fToggle = pThread && pThread->PreemptiveGCDisabled();
            if (fToggle) {
                pThread->EnablePreemptiveGC();
            }
        }
    }

    ~AutoPreemptiveGC()
    {
        if (fToggle) {
            pThread->DisablePreemptiveGC();
        }
    }

private:
    Thread *pThread;
    BOOL fToggle;
};

#ifdef _DEBUG

// Normally, any thread we operate on has a Thread block in its TLS.  But there are
// a few special threads we don't normally execute managed code on.
BOOL dbgOnly_IsSpecialEEThread();
void dbgOnly_IdentifySpecialEEThread();
void dbgOnly_RemoveSpecialEEThread();

#define BEGINFORBIDGC() {if (GetThread() != NULL) GetThread()->BeginForbidGC();}
#define ENDFORBIDGC()   {if (GetThread() != NULL) GetThread()->EndForbidGC();}
#define TRIGGERSGC()    do {                                                \
                            Thread* curThread = GetThread();                \
                            _ASSERTE(!curThread->GCForbidden());            \
                            Thread::TriggersGC(curThread);                  \
                        } while(0)


#define ASSERT_PROTECTED(objRef)        Thread::ObjectRefProtected(objRef)

inline BOOL GC_ON_TRANSITIONS(BOOL val) {
        Thread* thread = GetThread();
        if (thread == 0) return(FALSE);
        BOOL ret = thread->m_GCOnTransitionsOK;
        thread->m_GCOnTransitionsOK = val;
        return(ret);
}

#else

#define BEGINFORBIDGC()
#define ENDFORBIDGC()
#define TRIGGERSGC()
#define ASSERT_PROTECTED(objRef)

#define GC_ON_TRANSITIONS(val)  FALSE

#endif

#ifdef _DEBUG
inline void ENABLESTRESSHEAP() {
    Thread *thread = GetThread();                                             
    if (thread) {                                                            
        thread->EnableStressHeap();                                           
    }        
}

void CleanStackForFastGCStress ();
#define CLEANSTACKFORFASTGCSTRESS()                                         \
if (g_pConfig->GetGCStressLevel() && g_pConfig->FastGCStressLevel() > 1) {   \
    CleanStackForFastGCStress ();                                            \
}

#else
#define CLEANSTACKFORFASTGCSTRESS()

#endif

#endif //__threads_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\threads.inl ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Threads.inl
**
** Purpose: Implements Thread inline functions
**
** Date:  August 7, 2000
**
===========================================================*/
#ifndef _THREADS_INL
#define _THREADS_INL

#include "threads.h"
#include "appdomain.hpp"

inline void Thread::SetThrowable(OBJECTREF throwable)
{
    if (m_handlerInfo.m_pThrowable != NULL)
        DestroyHandle(m_handlerInfo.m_pThrowable);
    if (throwable != NULL) {
        m_handlerInfo.m_pThrowable = GetDomain()->CreateHandle(throwable);
    } else {
        m_handlerInfo.m_pThrowable = NULL;
    }

#ifdef _DEBUG
    if (throwable != NULL)
        ValidateThrowable();
#endif
}

inline void Thread::SetKickOffDomain(AppDomain *pDomain)
{
	_ASSERTE(pDomain);
	m_pKickOffDomainId = pDomain->GetId();
}

inline AppDomain *Thread::GetKickOffDomain()
{
	_ASSERTE(m_pKickOffDomainId != 0);
    return SystemDomain::GetAppDomainAtId(m_pKickOffDomainId);
}

inline void AppDomainStack::PushDomain(AppDomain *pDomain)
{
    _ASSERTE(pDomain);
    LOG((LF_APPDOMAIN, LL_INFO100, "Thread::PushDomain [%d], count now %d\n", pDomain->GetId(), m_numDomainsOnStack+1));
    if (m_numDomainsOnStack < MAX_APPDOMAINS_TRACKED)
    {
        m_pDomains[m_numDomainsOnStack] = pDomain->GetId();
#ifdef _DEBUG
        for (int i=min(m_numDomainsOnStack, MAX_APPDOMAINS_TRACKED); i >= 0; i--) {
            AppDomain *pDomain;
            
            if (m_pDomains[i] == -1)
            {
                pDomain = NULL;
            }
            else
            {
                pDomain = SystemDomain::GetAppDomainAtId( m_pDomains[i] );
                if (!pDomain)
                    pDomain = SystemDomain::AppDomainBeingUnloaded();
            }
            LOG((LF_APPDOMAIN, LL_INFO100, "    stack[%d]: [%d]\n", i, pDomain ? pDomain->GetId() : -1));
        }
#endif
    }
    m_numDomainsOnStack++;
}

inline void AppDomainStack::PushDomain(DWORD domainId)
{
    LOG((LF_APPDOMAIN, LL_INFO100, "Thread::PushDomain %S, count now %d\n", SystemDomain::GetAppDomainAtId( domainId )->GetFriendlyName(FALSE), m_numDomainsOnStack+1));
    if (m_numDomainsOnStack < MAX_APPDOMAINS_TRACKED)
    {
        m_pDomains[m_numDomainsOnStack] = domainId;

        if (domainId == -1)
            m_isWellFormed = FALSE;

#ifdef _DEBUG
        for (int i=min(m_numDomainsOnStack, MAX_APPDOMAINS_TRACKED); i >= 0; i--) {
            AppDomain *pDomain;
            
            if (m_pDomains[i] == -1)
            {
                pDomain = NULL;
            }
            else
            {
                pDomain = SystemDomain::GetAppDomainAtId( m_pDomains[i] );
                if (!pDomain)
                    pDomain = SystemDomain::AppDomainBeingUnloaded();
            }
            LOG((LF_APPDOMAIN, LL_INFO100, "    stack[%d]: %S\n", i, pDomain ? pDomain->GetFriendlyName(FALSE) : L"NULL"));
        }
#endif
    }
    m_numDomainsOnStack++;
}

inline void AppDomainStack::PushDomainNoDuplicates(DWORD domainId)
{
    LOG((LF_APPDOMAIN, LL_INFO100, "Thread::PushDomain %S, count now %d\n", SystemDomain::GetAppDomainAtId( domainId )->GetFriendlyName(FALSE), m_numDomainsOnStack+1));
    if (m_numDomainsOnStack < MAX_APPDOMAINS_TRACKED)
    {
        for (int i=min(m_numDomainsOnStack, MAX_APPDOMAINS_TRACKED) - 1; i >= 0; i--) {
            if (m_pDomains[i] == domainId)
                return;
        }
        m_pDomains[m_numDomainsOnStack] = domainId;

        if (domainId == -1)
            m_isWellFormed = FALSE;

#ifdef _DEBUG
        for (int i=min(m_numDomainsOnStack, MAX_APPDOMAINS_TRACKED); i >= 0; i--) {
            AppDomain *pDomain;
            
            if (m_pDomains[i] == -1)
            {
                pDomain = NULL;
            }
            else
            {
                pDomain = SystemDomain::GetAppDomainAtId( m_pDomains[i] );
                if (!pDomain)
                    pDomain = SystemDomain::AppDomainBeingUnloaded();
            }
            LOG((LF_APPDOMAIN, LL_INFO100, "    stack[%d]: %S\n", i, pDomain ? pDomain->GetFriendlyName(FALSE) : L"NULL"));
        }
#endif
    }
    m_numDomainsOnStack++;
}


inline AppDomain *AppDomainStack::PopDomain()
{
    _ASSERTE(m_numDomainsOnStack > 0);
    m_numDomainsOnStack--;
    if (m_numDomainsOnStack >= 0 && m_numDomainsOnStack < MAX_APPDOMAINS_TRACKED)
    {
        AppDomain *pRet;
        
        if (m_pDomains[m_numDomainsOnStack] == -1)
        {
            pRet = NULL;
        }
        else
        {
            pRet = SystemDomain::GetAppDomainAtId( m_pDomains[m_numDomainsOnStack] );
            if (!pRet)
                pRet = SystemDomain::AppDomainBeingUnloaded();
        }

        if (!m_isWellFormed)
        {
            BOOL isWellFormed = TRUE;

			for (int i=min(m_numDomainsOnStack-1, MAX_APPDOMAINS_TRACKED); i >= 0; i--)
            {
                if (m_pDomains[i] == -1)
                {
                    isWellFormed = FALSE;
                    break;
                }
            }

            m_isWellFormed = isWellFormed;
        }

	    LOG((LF_APPDOMAIN, LL_INFO100, "Thread::PopDomain popping [%d] count now %d\n", 
            pRet ? pRet->GetId() : -1, m_numDomainsOnStack));
#ifdef _DEBUG
		if (m_numDomainsOnStack > 0)
		{
			for (int i=min(m_numDomainsOnStack-1, MAX_APPDOMAINS_TRACKED); i >= 0; i--)
            {
                AppDomain *pDomain;
            
                if (m_pDomains[i] == -1)
                {
                    pDomain = NULL;
                }
                else
                {
                    pDomain = SystemDomain::GetAppDomainAtId( m_pDomains[i] );
                    if (!pDomain)
                        pDomain = SystemDomain::AppDomainBeingUnloaded();
                }
                LOG((LF_APPDOMAIN, LL_INFO100, "    stack[%d]: [%d]\n", i, pDomain ? pDomain->GetId() : -1));
            }
		}
        m_pDomains[m_numDomainsOnStack] = -1;
#endif
        return pRet;
    }
    else
	{
	    LOG((LF_APPDOMAIN, LL_INFO100, "Thread::PopDomain count now %d\n", m_numDomainsOnStack));
        return NULL;
	}
}

inline AppDomain *AppDomainStack::GetNextDomainOnStack(DWORD *pIndex) const
{
    if (*pIndex > 0 && *pIndex <= MAX_APPDOMAINS_TRACKED)
    {
        (*pIndex) --;
        return SystemDomain::GetAppDomainAtId( m_pDomains[*pIndex] );
    }
    else
        return NULL;
}

inline DWORD AppDomainStack::GetNextDomainIndexOnStack(DWORD *pIndex) const
{
    if (*pIndex > 0 && *pIndex <= MAX_APPDOMAINS_TRACKED)
    {
        (*pIndex) --;
        return m_pDomains[*pIndex];
    }
    else
        return -1;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\tls.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*  TLS.CPP:
 *
 *  Encapsulates TLS access for maximum performance. 
 *
 */

#include "common.h"

#include "tls.h"





#ifdef _DEBUG


static DWORD gSaveIdx;
LPVOID GenericTlsGetValue()
{
    return TlsGetValue(gSaveIdx);
}


VOID ExerciseTlsStuff()
{

    // Exercise the TLS stub generator for as many indices as we can.
    // Ideally, we'd like to test:
    //
    //      0  (boundary case)
    //      31 (boundary case for Win95)
    //      32 (boundary case for Win95)
    //      63 (boundary case for WinNT 5)
    //      64 (boundary case for WinNT 5)
    //
    // Since we can't choose what index we get, we'll just
    // do as many as we can.
    DWORD tls[128];
    int i;
    __try {
        for (i = 0; i < 128; i++) {
            tls[i] = ((DWORD)(-1));
        }

        for (i = 0; i < 128; i++) {
            tls[i] = TlsAlloc();

            if (tls[i] == ((DWORD)(-1))) {
                __leave;
            }
            LPVOID data = (LPVOID)(DWORD_PTR)(0x12345678+i*8);
            TlsSetValue(tls[i], data);
            gSaveIdx = tls[i];
            POPTIMIZEDTLSGETTER pGetter1 = MakeOptimizedTlsGetter(tls[i], GenericTlsGetValue);
            if (!pGetter1) {
                __leave;
            }


            _ASSERTE(data == pGetter1());

            FreeOptimizedTlsGetter(tls[i], pGetter1);
    
        }


    } __finally {
        for (i = 0; i < 128; i++) {
            if (tls[i] != ((DWORD)(-1))) {
                TlsFree(tls[i]);
            }
        }
    }
}

#endif _DEBUG


//---------------------------------------------------------------------------
// Win95 and WinNT store the TLS in different places relative to the
// fs:[0]. This api reveals which. Can also return TLSACCESS_GENERIC if
// no info is available about the Thread location (you have to use the TlsGetValue
// api.) This is intended for use by stub generators that want to inline TLS
// access.
//---------------------------------------------------------------------------
TLSACCESSMODE GetTLSAccessMode(DWORD tlsIndex)
{
    TLSACCESSMODE tlsAccessMode = TLSACCESS_GENERIC;
    THROWSCOMPLUSEXCEPTION();

#ifdef _X86_

    OSVERSIONINFO osverinfo;
    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(WszGetVersionEx(&osverinfo))
    {
        if (osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            if (osverinfo.dwMajorVersion >= 5 && tlsIndex > 63 )
                tlsAccessMode = TLSACCESS_GENERIC;//TLSACCESS_X86_WNT_HIGH;
            else
            if (osverinfo.dwMajorVersion >= 3)
                tlsAccessMode = TLSACCESS_X86_WNT;
            else
            {
                // At least on Win2K if the "Win32 Version" of the PE file is bashed from
                // a 0 to a 1, whether accidentally or maliciously, the OS tell us that:
                //
                //      a) we are on NT and
                //      b) the OS major version is 1.
                //
                // We cannot operate successfully under these circumstances, since
                // subsystems like COM and TLS access rely on our correctly detecting
                // Win2K and up.
                //
                // Ideally this check would be in WszGetVersionEx, but we can't throw
                // managed exceptions from there.  And we are guaranteed to come thru
                // GetTLSAccessMode during startup, so the following is good enough for
                // V1 on corrupt images.
                //
                // @TODO post V1 push this into utilcode.
                COMPlusThrowBoot(COR_E_PLATFORMNOTSUPPORTED);
            }
            
        } else if (osverinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
            tlsAccessMode = TLSACCESS_X86_W95;
    }

#endif // _X86_


#ifdef _DEBUG
    {
        static BOOL firstTime = TRUE;
        if (firstTime) {
            firstTime = FALSE;
            ExerciseTlsStuff();
        }
    }
#endif

    return tlsAccessMode;
}


//---------------------------------------------------------------------------
// Creates a platform-optimized version of TlsGetValue compiled
// for a particular index. 
//
// LIMITATION: We make the client provide the function ("pGenericGetter") when the 
// access mode is TLSACCESS_GENERIC (all it has to do is call TlsGetValue
// for the specific TLS index.) This is because the generic getter has to
// be platform independent and the TLS manager can't create that at runtime.
// While it's possible to simulate these, it requires more machinery and code
// than is worth given that this service has only one or two clients.
//---------------------------------------------------------------------------
POPTIMIZEDTLSGETTER MakeOptimizedTlsGetter(DWORD tlsIndex, POPTIMIZEDTLSGETTER pGenericGetter)
{
    _ASSERTE(pGenericGetter != NULL);

    LPBYTE pCode = NULL;
    switch (GetTLSAccessMode(tlsIndex)) {
#ifdef _X86_
        case TLSACCESS_X86_WNT:
            pCode = new BYTE[7];
            if (pCode) {
                *((WORD*)  (pCode + 0)) = 0xa164;       //  mov  eax, fs:[IMM32]
                *((DWORD*) (pCode + 2)) = WINNT_TLS_OFFSET + tlsIndex * 4;
                *((BYTE*)  (pCode + 6)) = 0xc3;         //  retn
            }
            break;

        case TLSACCESS_X86_WNT_HIGH:
            _ASSERTE(tlsIndex > 63);
            
            pCode = new BYTE[14];
            if (pCode) {
                *((WORD*)  (pCode + 0)) = 0xa164;       //  mov  eax, fs:[f94]
                *((DWORD*) (pCode + 2)) = WINNT5_TLSEXPANSIONPTR_OFFSET;
            
                if ((tlsIndex - 64) < 32) {
                    *((WORD*)  (pCode + 6))  = 0x408b;   //  mov eax, [eax+IMM8]
                    *((BYTE*)  (pCode + 8))  = (BYTE)((tlsIndex - 64) << 2);
                    *((BYTE*)  (pCode + 9)) = 0xc3;     //  retn
                } else {
                    *((WORD*)  (pCode + 6))  = 0x808b;   //  mov eax, [eax+IMM32]
                    *((DWORD*) (pCode + 8))  = (tlsIndex - 64) << 2;
                    *((BYTE*)  (pCode + 12)) = 0xc3;     //  retn
                }
            }
            break;
            
        case TLSACCESS_X86_W95:
            pCode = new BYTE[14];
            if (pCode) {
                *((WORD*)  (pCode + 0)) = 0xa164;       //  mov  eax, fs:[2c]
                *((DWORD*) (pCode + 2)) = WIN95_TLSPTR_OFFSET;
            
                if (tlsIndex < 32) {
                    *((WORD*)  (pCode + 6))  = 0x408b;   //  mov eax, [eax+IMM8]
                    *((BYTE*)  (pCode + 8))  = (BYTE)(tlsIndex << 2);
                    *((BYTE*)  (pCode + 9)) = 0xc3;     //  retn
                } else {
                    *((WORD*)  (pCode + 6))  = 0x808b;   //  mov eax, [eax+IMM32]
                    *((DWORD*) (pCode + 8))  = tlsIndex << 2;
                    *((BYTE*)  (pCode + 12)) = 0xc3;     //  retn
                }
            }
            break;
#endif // _X86_

        case TLSACCESS_GENERIC:
            pCode = (LPBYTE)pGenericGetter;
            break;
    }
    return (POPTIMIZEDTLSGETTER)pCode;
}


//---------------------------------------------------------------------------
// Frees a function created by MakeOptimizedTlsGetter(). If the access
// mode was TLSACCESS_GENERIC, this function safely does nothing since
// the function was actually provided by the client.
//---------------------------------------------------------------------------
VOID FreeOptimizedTlsGetter(DWORD tlsIndex, POPTIMIZEDTLSGETTER pOptimizedTlsGetter)
{
    if (GetTLSAccessMode(tlsIndex) != TLSACCESS_GENERIC) {
        delete (LPBYTE)pOptimizedTlsGetter;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\threads.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// @TODO cwb: resolve the partitioning between statics on Thread, instance member
// on ThreadStore and statics on ThreadStore.  There is no pattern.

/*  THREADS.CPP:
 *
 */

#include "common.h"

#include "tls.h"
#include "frames.h"
#include "threads.h"
#include "stackwalk.h"
#include "excep.h"
#include "COMSynchronizable.h"
#include "log.h"
#include "gcscan.h"
#include "gc.h"
#include "mscoree.h"
#include "DbgInterface.h"
#include "CorProf.h"                // profiling
#include "COMPlusWrapper.h"
#include "EEProfInterfaces.h"
#include "EEConfig.h"
#include "PerfCounters.h"
#include "corhost.h"
#include "Win32Threadpool.h"
#include "COMString.h"
#include "jitinterface.h"
#include "threads.inl"
#include "ndphlpr.h"

#include "oletls.h"
#include "permset.h"
#include "appdomainhelper.h"
#include "COMUtilNative.h"
#include "fusion.h"

#ifdef CUSTOMER_CHECKED_BUILD
    #include "CustomerDebugHelper.h"
    void CCBApartmentProbeOutput(CustomerDebugHelper *pCdh, DWORD threadID, Thread::ApartmentState state, BOOL fAlreadySet);
#endif // CUSTOMER_CHECKED_BUILD

// Fix for Win9X when getting and setting thread contexts. Basically, a blocked
// thread can be hijacked by the OS for use in reflecting v86 interrupts. If a
// GetThreadContext is performed at this stage, the results are corrupted. To
// get around this, we install a VxD on Win9X that provides GetThreadContext
// functionality but with an additional error case for when an incorrect context
// would have been returned. Upon a GetThreadContext failure we should resume
// and resuspend the thread (this is required to shift some stubborn v86
// interrupt handlers). The following APIs are set up in InitThreadManager.
BOOL (*EEGetThreadContext)(Thread *pThread, CONTEXT *pContext) = NULL;
BOOL (*EESetThreadContext)(Thread *pThread, const CONTEXT *pContext) = NULL;
HANDLE g_hNdpHlprVxD = INVALID_HANDLE_VALUE;

typedef Thread* (*POPTIMIZEDTHREADGETTER)();
typedef AppDomain* (*POPTIMIZEDAPPDOMAINGETTER)();
TypeHandle Thread::m_CultureInfoType;
MethodDesc *Thread::m_CultureInfoConsMD = NULL;
MethodDesc *Thread::s_pReserveSlotMD= NULL;

HANDLE ThreadStore::s_hAbortEvt = NULL;
HANDLE ThreadStore::s_hAbortEvtCache = NULL;


// Here starts the unmanaged portion of the compressed stack code.
// The mission of this code is to provide us with an intermediate
// step between the stackwalk that has to happen when we make an
// async call and the formation of the managed PermissionListSet
// object since the latter is a very expensive operation.
//
// The basic structure of the compressed stack at this point is
// a list of compressed stack entries, where each entry represents
// one piece of "interesting" information found during the stackwalk.
// At this time, the "interesting" bits are appdomain transitions, 
// assembly security, descriptors, appdomain security descriptors,
// frame security descriptors, and other compressed stacks.  Of course,
// if that's all there was to it, there wouldn't be an explanatory
// comment even close to this size before you even started reading
// the code.  Since we need to form a compressed stack whenever an
// async operation is registered, it is a very perf critical piece
// of code.  As such, things get very much more complicated than
// the simple list of objects described above.  The special bonus
// feature is that we need to handle appdomain unloads since the
// list tracks appdomain specific data.  Keep reading to find out
// more.


void*
CompressedStackEntry::operator new( size_t size, CompressedStack* stack )
{
    _ASSERTE( stack != NULL );
    return stack->AllocateEntry( size );
}

CompressedStack*
CompressedStackEntry::Destroy( CompressedStack* owner )
{
    CompressedStack* retval = NULL;

    Cleanup();

    if (this->type_ == ECompressedStack)
    {
        retval = (CompressedStack*)this->ptr_;
    }

    delete this;

    return retval;
}

void
CompressedStackEntry::Cleanup( void )
{
    if ((type_ == EFrameSecurityDescriptor || type_ == ECompressedStackObject) &&
        handleStruct_.handle_ != NULL)
    {
        if (!g_fProcessDetach)
        {
            if (handleStruct_.domainId_ == 0 || SystemDomain::GetAppDomainAtId( handleStruct_.domainId_ ) != NULL)
            {
                // There is a race condition between doing cleanup of CompressedStacks
                // and unloading appdomains.  This is because there can be threads doing
                // cleanup of CompressedStacks where the CompressedStack references an
                // appdomain, but the thread itself is not in that appdomain and is
                // therefore free to continue normally while that appdomain unloads.
                // We try to narrow the race to the smallest possible window through
                // the GetAppDomainAtId call above, but it is still necessary to handle
                // the race here, which we do by catching and ignoring any exceptions.

                __try
                {
                    DestroyHandle( handleStruct_.handle_ );
                }
                __except(TRUE)
                {
                }
            }

            handleStruct_.handle_ = NULL;
        }
    }
}


CompressedStack::CompressedStack( OBJECTREF orStack )
: delayedCompressedStack_( NULL ),
  compressedStackObject_( GetAppDomain()->CreateHandle( orStack ) ),
  compressedStackObjectAppDomain_( GetAppDomain() ),
  compressedStackObjectAppDomainId_( GetAppDomain()->GetId() ),
  pbObjectBlob_( NULL ),
  cbObjectBlob_( 0 ),
  containsOverridesOrCompressedStackObject_( TRUE ),
  refCount_( 1 ),
  isFullyTrustedDecision_( -1 ),
  depth_( 0 ),
  index_( 0 ),
  offset_( 0 ),
  plsOptimizationOn_( TRUE )
{
#ifdef _DEBUG
    creatingThread_ = GetThread();
#endif
    this->entriesMemoryList_.Append( NULL );

    AddToList();
}


void
CompressedStack::CarryOverSecurityInfo(Thread *pFromThread)
{
    overridesCount_ = pFromThread->GetOverridesCount();
    appDomainStack_ = pFromThread->m_ADStack;
}

// In order to improve locality and decrease the number of
// calls to the global new operator, each compressed stack
// keeps a buffer from which it allocates space for its child
// entries.  Notice the implicit assumption that only one thread
// is ever allocating at a time.  We currently guarantee
// this by not handing out references to the compressed stack
// until the stack walk is completed.

void*
CompressedStack::AllocateEntry( size_t size )
{
    void* buffer = this->entriesMemoryList_.Get( index_ );

    if (buffer == NULL)
    {
        buffer = new BYTE[SIZE_ALLOCATE_BUFFERS];
        this->entriesMemoryList_.Set( this->index_, buffer );
    }

    if (this->offset_ + size > SIZE_ALLOCATE_BUFFERS)
    {
        buffer = new BYTE[SIZE_ALLOCATE_BUFFERS];
        this->entriesMemoryList_.Append( buffer );
        ++this->index_;
        this->offset_ = 0;
    }

    void* retval = (BYTE*)buffer + this->offset_;
    this->offset_ += (DWORD)size;

    return retval;
}

CompressedStackEntry*
CompressedStack::FindMatchingEntry( CompressedStackEntry* entry, CompressedStack* stack )
{
    if (entry == NULL)
        return NULL;

    ArrayList::Iterator iter = stack->delayedCompressedStack_->Iterate();

    _ASSERTE( entry->type_ == EApplicationSecurityDescriptor || entry->type_ == ESharedSecurityDescriptor );

    while (iter.Next())
    {
        CompressedStackEntry* currentEntry = (CompressedStackEntry*)iter.GetElement();

        if (currentEntry->type_ == EApplicationSecurityDescriptor ||
            currentEntry->type_ == ESharedSecurityDescriptor)
        {
            if (currentEntry->ptr_ == entry->ptr_)
                return currentEntry;
        }
    }
    
    return NULL;
}

// Due to the "recursive" nature of a certain class of async
// operations, it is important that we limit the growth of
// our compressed stack objects.  To explain this "recursion",
// think about the async pattern illustrated below:
//
// void Foo()
// {
//     ReadDataFromStream();
//
//     if (StillNeedMoreData())
//         RegisterWaitOnStreamWithFooAsCallback();
//     else
//         WereDoneProcessData();
// }
//
// Notice, that this is just a non-blocking form of:
//
// void Foo()
// {
//     ReadDataFromStream();
//    
//     if (StillNeedMoreData())
//         Foo();
//     else
//         WereDoneProcessData();
// }
//
// This second function will create an runtime call
// stack with repeated entries for Foo().  Similarly,
// the logical call stack for the first function will
// have repeated entries for Foo(), the being that
// all those entries for Foo() will not be on the runtime
// call stack but instead in the compressed stack.  Knowing
// this, and knowing that repeated entries of Foo() make
// no difference to the security state of the stack, it is
// easy to see that we can limit the growth of the stack
// while not altering the semantic by removing duplicate
// entries.  This is somewhat complicated by the possible
// presence of stack modifiers.  Given that, it is important
// that when choosing which of two duplicate entries to
// remove that you remove the one that appears earlier in
// the call chain (since it would be processed second).

static CompressedStackEntry* SafeCreateEntry( CompressedStack* stack, AppDomain* domain, OBJECTHANDLE handle, BOOL fullyTrusted, DWORD domainId, CompressedStackType type )
{
    CompressedStackEntry* entry;

    __try
    {
        entry = new( stack ) CompressedStackEntry( domain->CreateHandle( ObjectFromHandle( handle ) ), fullyTrusted, domainId, type );
    }
    __except(TRUE)
    {
        entry = NULL;
    }

    return entry;
}

CompressedStack*
CompressedStack::RemoveDuplicates( CompressedStack* current, CompressedStack* candidate )
{
    // If there are no delayed compressed stack lists, then we can just skip out.
    // We can also skip out if the candidate stack already has a PLS.

    CompressedStack* retval = NULL;
    ArrayList::Iterator iter;
    CompressedStackEntry* entry = NULL;
    CompressedStackEntry* matchingEntry;
    CompressedStack* newStack;
    DWORD domainId = -1;
    AppDomain* domain = NULL;
    CompressedStackEntry* storedObj = NULL;

    CompressedStack::listCriticalSection_->Enter();

    if (current->delayedCompressedStack_ == NULL ||
        candidate->delayedCompressedStack_ == NULL ||
        candidate->compressedStackObject_ != NULL ||
        candidate->pbObjectBlob_)
    {
        candidate->AddRef();
        retval = candidate;
        goto Exit;
    }

    
    // Check to make sure they have at least one matching entry.
    // Note: for now I just grab the first appdomain security descriptor
    // and check for a matching one in the other compressed stack.

    iter = current->delayedCompressedStack_->Iterate();

    while (iter.Next())
    {
        CompressedStackEntry* currentEntry = (CompressedStackEntry*)iter.GetElement();

        if (currentEntry->type_ == EApplicationSecurityDescriptor ||
            currentEntry->type_ == ESharedSecurityDescriptor)
        {
            entry = currentEntry;
            break;
        }
    }

    // No match, let's not try any more compression.

    matchingEntry = FindMatchingEntry( entry, candidate );

    if (matchingEntry == NULL)
    {
        candidate->AddRef();
        retval = candidate;
        goto Exit;
    }

    // Compression is possible.  Let's get rockin'.

    newStack = new (nothrow) CompressedStack();

    if (newStack == NULL)
    {
        candidate->AddRef();
        retval = candidate;
        goto Exit;
    }

    newStack->delayedCompressedStack_ = new ArrayList();
    newStack->containsOverridesOrCompressedStackObject_ = candidate->containsOverridesOrCompressedStackObject_;
    newStack->isFullyTrustedDecision_ = candidate->isFullyTrustedDecision_;

    // This isn't exactly correct, but we'll copy over all the overrides
    // and appdomains from the previous stack into this one eventhough
    // we may make some of those appdomains go away
    newStack->appDomainStack_ = candidate->appDomainStack_;
    newStack->overridesCount_ = candidate->overridesCount_;
    newStack->plsOptimizationOn_ = candidate->plsOptimizationOn_;

    iter = candidate->delayedCompressedStack_->Iterate();

    while (iter.Next())
    {
        CompressedStackEntry* currentEntry = (CompressedStackEntry*)iter.GetElement();

        if (currentEntry == NULL)
            continue;

        switch (currentEntry->type_)
        {
        case EAppDomainTransition:
            {
                CompressedStackEntry* lastEntry;
                if (newStack->delayedCompressedStack_->GetCount() > 0 &&
                    (lastEntry = (CompressedStackEntry*)newStack->delayedCompressedStack_->Get( newStack->delayedCompressedStack_->GetCount() - 1 )) != NULL &&
                    lastEntry->type_ == EAppDomainTransition)
                {
                    newStack->delayedCompressedStack_->Set( newStack->delayedCompressedStack_->GetCount() - 1, new( newStack ) CompressedStackEntry( currentEntry->indexStruct_.index_, currentEntry->type_ ) );
                    storedObj = NULL;
                }
                else
                {
                    storedObj = new( newStack ) CompressedStackEntry( currentEntry->indexStruct_.index_, currentEntry->type_ );
                }

                domainId = currentEntry->indexStruct_.index_;
                domain = SystemDomain::GetAppDomainAtId( domainId );
                if (domain == NULL || domain->IsUnloading())
                {
                    newStack->Release();
                    candidate->AddRef();
                    retval = candidate;
                    goto Exit;
                }
           
            }
            break;
    
        case ESharedSecurityDescriptor:
            matchingEntry = FindMatchingEntry( currentEntry, current );
            if (matchingEntry == NULL)
            {
                newStack->depth_++;
                storedObj = new( newStack ) CompressedStackEntry( currentEntry->ptr_, currentEntry->type_ );
            }
            else
            {
                storedObj = NULL;
            }
            break;

        case EApplicationSecurityDescriptor:
            matchingEntry = FindMatchingEntry( currentEntry, current );
            if (matchingEntry == NULL)
            {
                newStack->depth_++;
                storedObj = new( newStack ) CompressedStackEntry( currentEntry->ptr_, currentEntry->type_ );
            }
            else
            {
                storedObj = NULL;
            }
            break;

        case ECompressedStack:
            {
                CompressedStack* compressedStack = (CompressedStack*)currentEntry->ptr_;
                compressedStack->AddRef();
                storedObj = new( newStack ) CompressedStackEntry( compressedStack, ECompressedStack );
                newStack->depth_ += compressedStack->GetDepth();
            }
            break;

        case EFrameSecurityDescriptor:
            newStack->depth_++;
            _ASSERTE( domain );
            _ASSERTE( currentEntry->handleStruct_.domainId_ == 0 || domain->GetId() == currentEntry->handleStruct_.domainId_ );
            storedObj = SafeCreateEntry( newStack,
                                         domain,
                                         currentEntry->handleStruct_.handle_ ,
                                         currentEntry->handleStruct_.fullyTrusted_,
                                         currentEntry->handleStruct_.domainId_,
                                         currentEntry->type_ );

            if (storedObj == NULL)
            {
                newStack->Release();
                candidate->AddRef();
                retval = candidate;
                goto Exit;
            }

            break;

        case ECompressedStackObject:
            newStack->containsOverridesOrCompressedStackObject_ = TRUE;
            newStack->depth_++;
            _ASSERTE( domain );
            _ASSERTE( currentEntry->handleStruct_.domainId_ == 0 || domain->GetId() == currentEntry->handleStruct_.domainId_ );
            storedObj = SafeCreateEntry( newStack,
                                         domain,
                                         currentEntry->handleStruct_.handle_,
                                         currentEntry->handleStruct_.fullyTrusted_,
                                         currentEntry->handleStruct_.domainId_,
                                         currentEntry->type_ );

            if (storedObj == NULL)
            {
                newStack->Release();
                candidate->AddRef();
                retval = candidate;
                goto Exit;
            }

            break;
    
        default:
            _ASSERTE( !"Unknown CompressedStackType" );
            break;
        }

        if (storedObj != NULL)
            newStack->delayedCompressedStack_->Append( storedObj );
    }

    // As an additional optimization, if we find that we've removed the
    // number of duplicates to the point where we have just one entry
    // and that entry is an appdomain transition, then we don't need
    // the new stack at all.  Similarly, if we remove all but an appdomain
    // transition and another compressed stack, the new stack we care
    // about is simply the compressed stack in the list so return it instead.

    if (newStack->delayedCompressedStack_->GetCount() <= 2)
    {
        if (newStack->delayedCompressedStack_->GetCount() == 1)
        {
            CompressedStackEntry* entry = (CompressedStackEntry*)newStack->delayedCompressedStack_->Get( 0 );

            if (entry->type_ == EAppDomainTransition)
            {
                newStack->Release();
                retval = NULL;;
                goto Exit;
            }
        }
        else if (newStack->delayedCompressedStack_->GetCount() == 2)
        {
            CompressedStackEntry* firstEntry = (CompressedStackEntry*)newStack->delayedCompressedStack_->Get( 0 );
            CompressedStackEntry* secondEntry = (CompressedStackEntry*)newStack->delayedCompressedStack_->Get( 1 );

            if (firstEntry->type_ == EAppDomainTransition &&
                secondEntry->type_ == ECompressedStack)
            {
                CompressedStack* previousStack = (CompressedStack*)secondEntry->ptr_;
                previousStack->AddRef();
                newStack->Release();
                retval = previousStack;
                goto Exit;
            }
        }
    }

    retval = newStack;

Exit:
    CompressedStack::listCriticalSection_->Leave();

    return retval;
}



ArrayList CompressedStack::allCompressedStacks_;
DWORD CompressedStack::freeList_[FREE_LIST_SIZE];
DWORD CompressedStack::freeListIndex_ = -1;
DWORD CompressedStack::numUntrackedFreeIndices_ = 0;
Crst* CompressedStack::listCriticalSection_ = NULL;

#define MAX_LOOP 2

void CompressedStack::Init( void )
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE( CompressedStack::listCriticalSection_ == NULL );

    listCriticalSection_ = ::new Crst("CompressedStackLock", CrstCompressedStack, TRUE, TRUE);
    if (listCriticalSection_ == NULL)
        COMPlusThrowOM();
}

void CompressedStack::Shutdown( void )
{
    if (listCriticalSection_)
    {
        ::delete listCriticalSection_;
        listCriticalSection_ = NULL;
    }
}

// In order to handle appdomain unloads, we keep a list of all
// compressed stacks.  This is complicated by the fact that 
// compressed stacks often get deleted and we create a lot of
// them, so we need to reuse slots in the list.  Therefore,
// we maintain a fixed-size array of free indices within
// the list.  As a backup, we also track the number of indices
// in the list that are free but are not tracked in the array
// of free indices.

void
CompressedStack::AddToList( void )
{
    CompressedStack::listCriticalSection_->Enter();

    // If there is an entry in the free list, simply use it.

    if (CompressedStack::freeListIndex_ != -1)
    {
USE_FREE_LIST:
        this->listIndex_ = CompressedStack::freeList_[CompressedStack::freeListIndex_];
        _ASSERTE( CompressedStack::allCompressedStacks_.Get( this->listIndex_ ) == NULL && "The free list points to an index that is in use" );
        CompressedStack::allCompressedStacks_.Set( this->listIndex_, this );
        this->freeListIndex_--;
    }

    // If there are no free list entries, but there are untracked free indices,
    // let's find them by iterating down the list.

    else if (CompressedStack::numUntrackedFreeIndices_ != 0)
    {
        BOOL done = FALSE;
        DWORD count = 0;

        do
        {
            DWORD index = -1;

            CompressedStack::listCriticalSection_->Leave();

            ArrayList::Iterator iter = CompressedStack::allCompressedStacks_.Iterate();

            while (iter.Next())
            {
                if (iter.GetElement() == NULL)
                {
                    index = iter.GetIndex();
                    break;
                }
            }

            CompressedStack::listCriticalSection_->Enter();

            // There's a possibility that while we weren't holding the lock that
            // someone deleted an entry from the list behind the point of our
            // iteration so we didn't detect it.  We detect this and restart the
            // iteration in the code below, but we also don't want to "starve" a
            // thread by having it search for an open spot forever so we limit
            // the number of times you can go through the loop.

            count++;
            if (index == -1)
            {
                if (CompressedStack::numUntrackedFreeIndices_ == 0 || count >= MAX_LOOP)
                    goto APPEND;
            }
            else if (CompressedStack::allCompressedStacks_.Get( index ) == NULL)
            {
                // If anything has been added to the free list while we didn't
                // hold the lock, then we'll check whether the index we found
                // if one of the untracked ones or not.  If it is an untracked
                // index, we should use it as to not waste the search.  However
                // if it is in the free list we'll just use the last free list
                // entry.  Note that this means that we don't necessarily use
                // the index we just found, but it should be an index that is
                // NULL which is all we really care about.

                if (CompressedStack::freeListIndex_ != -1)
                {
                    for (DWORD i = 0; i <= CompressedStack::freeListIndex_; ++i)
                    {
                        if (CompressedStack::freeList_[i] == index)
                            goto USE_FREE_LIST;
                    }
                }

                CompressedStack::numUntrackedFreeIndices_--;
                this->listIndex_ = index;
                CompressedStack::allCompressedStacks_.Set( index, this );
                done = TRUE;
            }
            else if (CompressedStack::numUntrackedFreeIndices_ == 0 || count >= MAX_LOOP)
            {
                goto APPEND;
            }
        }
        while (!done);
    }

    // Otherwise we place this new entry at that end of the list.

    else
    {
APPEND:
        this->listIndex_ = CompressedStack::allCompressedStacks_.GetCount();
        CompressedStack::allCompressedStacks_.Append( this );
    }

    CompressedStack::listCriticalSection_->Leave();
}


void
CompressedStack::RemoveFromList()
{
    CompressedStack::listCriticalSection_->Enter();

    _ASSERTE( this->listIndex_ < CompressedStack::allCompressedStacks_.GetCount() );
    _ASSERTE( CompressedStack::allCompressedStacks_.Get( this->listIndex_ ) == this && "Index tracking failed for this object" );

    CompressedStack::allCompressedStacks_.Set( this->listIndex_, NULL );

    if (CompressedStack::freeListIndex_ == -1 || CompressedStack::freeListIndex_ < FREE_LIST_SIZE - 1)
    {
        CompressedStack::freeList_[++CompressedStack::freeListIndex_] = this->listIndex_;
    }
    else
    {
        CompressedStack::numUntrackedFreeIndices_++;
    }

    CompressedStack::listCriticalSection_->Leave();
}

BOOL
CompressedStack::SetBlobIfAlive( CompressedStack* stack, BYTE* pbBlob, DWORD cbBlob )
{
    ArrayList::Iterator iter = CompressedStack::allCompressedStacks_.Iterate();

    DWORD index = -1;

    while (iter.Next())
    {
        if (iter.GetElement() == stack)
        {
            index = iter.GetIndex();
            break;
        }
    }

    if (index == -1)
        return FALSE;

    BOOL retval = FALSE;

    COMPLUS_TRY
    {
        CompressedStack::listCriticalSection_->Enter();

        if (CompressedStack::allCompressedStacks_.Get( index ) == stack)
        {
            stack->pbObjectBlob_ = pbBlob;
            stack->cbObjectBlob_ = cbBlob;
            retval = TRUE;
        }
        else
        {
            retval = FALSE;
        }

        CompressedStack::listCriticalSection_->Leave();
    }
    COMPLUS_CATCH
    {
        _ASSERTE( FALSE && "Don't really expect an exception here" );
        CompressedStack::listCriticalSection_->Leave();
    }
    COMPLUS_END_CATCH

    return retval;

}

BOOL
CompressedStack::IfAliveAddRef( CompressedStack* stack )
{
    _ASSERTE( CompressedStack::listCriticalSection_->OwnedByCurrentThread() );

    ArrayList::Iterator iter = CompressedStack::allCompressedStacks_.Iterate();

    DWORD index = -1;

    while (iter.Next())
    {
        if (iter.GetElement() == stack)
        {
            index = iter.GetIndex();
            break;
        }
    }

    if (index != -1)
    {
        stack->AddRef();
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


void
CompressedStack::AllHandleAppDomainUnload( AppDomain* pDomain, DWORD domainId )
{
    ArrayList::Iterator iter = CompressedStack::allCompressedStacks_.Iterate();

    while (iter.Next())
    {
        CompressedStack* stack = (CompressedStack*)iter.GetElement();

        if (stack != NULL)
            stack->HandleAppDomainUnload( pDomain, domainId );
    }
}


bool
CompressedStack::HandleAppDomainUnload( AppDomain* pDomain, DWORD domainId )
{
    // Nothing to do if the stack is owned by a different domain, doesn't cache
    // an object or has already serialized the stack. (Though if we've
    // serialized the blob but currently own a cached copy, we must junk that).

    // Note that this function is used for two very different cases and must
    // handle both.  The first is the case where a thread has the appdomain somewhere
    // on it's stack.  The second is the case where the appdomain appears somewhere in
    // this compressed stack.  In both cases we need to make sure that we have
    // generated a permission list set and that it is not in the appdomain that is
    // getting unloaded.  If you are making changes to this function you need to make
    // sure that we detect both cases and don't bail out early in either of the conditions
    // below.

    bool retval = false;

    // Serialize a copy of the stack so that others can use it. We must drop the
    // thread store lock while we're doing this, and the thread might go away,
    // so cache all the info we need to make the call.
    Thread     *pThread = GetThread();
    BYTE       *pbBlob;
    DWORD       cbBlob;
    DWORD       dwIncarnation = ThreadStore::GetIncarnation();

    OBJECTREF   orCached = NULL;
    ArrayList::Iterator iter;

    CompressedStack::listCriticalSection_->Enter();

    if (!IfAliveAddRef( this ))
    {
        CompressedStack::listCriticalSection_->Leave();
        return false;
    }

    if (this->pbObjectBlob_ != NULL)
    {
        goto CLEANUP;
    }

    CompressedStack::listCriticalSection_->Leave();

    GCPROTECT_BEGIN(orCached);

    orCached = this->GetPermissionListSetInternal( pDomain, pDomain, domainId, TRUE );

    AppDomainHelper::MarshalObject(pDomain,
                                   &orCached,
                                   &pbBlob,
                                   &cbBlob);

    GCPROTECT_END();

    CompressedStack::listCriticalSection_->Enter();

    if (this->pbObjectBlob_ == NULL)
    {
        this->pbObjectBlob_ = pbBlob;
        this->cbObjectBlob_ = cbBlob;
    }
    else
    {
        FreeM( pbBlob );
    }

    retval = true;

CLEANUP:

    _ASSERTE( CompressedStack::listCriticalSection_->OwnedByCurrentThread() );

    if (this->delayedCompressedStack_ != NULL)
    {
        iter = this->delayedCompressedStack_->Iterate();

        while (iter.Next())
        {
            ((CompressedStackEntry*)iter.GetElement())->Cleanup();
        }
    }

    CompressedStack::listCriticalSection_->Leave();

    // Now we're done so we can release our extra ref.
    // Note: if this deletes the object the blob we
    // just allocated will get cleaned up by the destructor.

    this->Release();

    return retval;
}


void
CompressedStack::AddEntry( void* obj, CompressedStackType type )
{
    AddEntry( obj, NULL, type );
}

// This is the callback used by the stack walk mechanism to build
// up the entries in the compressed stack.  Most of this is pretty
// straightforward, just adding an entry of the correct type to the
// list.  The complicated portion comes in the handling of an entry
// for a compressed stack.  In that case, we try to remove duplicates
// in order to limit the total size of the compressed stack chain.
// However, if after compression we are still beyond our limit then
// we replace the compressed stack entry with a managed permission
// list set object.

void
CompressedStack::AddEntry( void* obj, AppDomain* domain, CompressedStackType type )
{
    _ASSERTE( (compressedStackObject_ == NULL || ObjectFromHandle( compressedStackObject_ ) == NULL) && "The CompressedStack cannot be altered once a PLS has been generated" );

#ifdef _DEBUG
    // Probably stupid to wrap the assert in an #ifdef, but I want to be consistent
    _ASSERTE( this->creatingThread_ == GetThread() && "Only the creating thread should add entries." );
#endif

    if (this->delayedCompressedStack_ == NULL)
        this->delayedCompressedStack_ = new ArrayList();

    if (domain == NULL)
        domain = GetAppDomain();

    CompressedStackEntry* storedObj = NULL;
    CompressedStack* compressedStack;

    switch (type)
    {
    case EAppDomainTransition:
        storedObj = new( this ) CompressedStackEntry( ((AppDomain*)obj)->GetId(), type );
        break;
    
    case ESharedSecurityDescriptor:
        if (((SharedSecurityDescriptor*)obj)->IsSystem())
            return;
        this->depth_++;
        storedObj = new( this ) CompressedStackEntry( obj, type );
        break;

    case EApplicationSecurityDescriptor:
        if (((ApplicationSecurityDescriptor*)obj)->GetProperties( CORSEC_DEFAULT_APPDOMAIN ))
            return;
        this->depth_++;
        storedObj = new( this ) CompressedStackEntry( obj, type );
        break;

    case ECompressedStack:
        {
            compressedStack = (CompressedStack*)obj;
            _ASSERTE( compressedStack );
            compressedStack->AddRef();

            CompressedStack* newCompressedStack;
            if ((compressedStack->GetDepth() - this->GetDepth() <= 5 ||
                 this->GetDepth() - compressedStack->GetDepth() <= 5) &&
                this->GetDepth() < 30)
            {
                newCompressedStack = RemoveDuplicates( this, compressedStack );
            }
            else
            {
                compressedStack->AddRef();
                newCompressedStack = compressedStack;
            }

            if (newCompressedStack != NULL)
            {
                this->overridesCount_ += newCompressedStack->overridesCount_;

                if (newCompressedStack->appDomainStack_.IsWellFormed() && newCompressedStack->plsOptimizationOn_)
                {
                    DWORD dwIndex;
                    newCompressedStack->appDomainStack_.InitDomainIteration(&dwIndex);
                    DWORD domainId;
                    while ((domainId = newCompressedStack->appDomainStack_.GetNextDomainIndexOnStack(&dwIndex)) != -1)
                    {
                        this->appDomainStack_.PushDomainNoDuplicates( domainId );
                    }

                    if (!this->appDomainStack_.IsWellFormed())
                        this->plsOptimizationOn_ = FALSE;
                }
                else
                {
                    this->plsOptimizationOn_ = FALSE;
                }

                if (newCompressedStack->GetDepth() + this->depth_ >= MAX_COMPRESSED_STACK_DEPTH)
                {
                    BOOL fullyTrusted = newCompressedStack->LazyIsFullyTrusted();
                    this->depth_++;
                    storedObj = new( this ) CompressedStackEntry( domain->CreateHandle( newCompressedStack->GetPermissionListSet( domain ) ), fullyTrusted, domain->GetId(), ECompressedStackObject );
                    if (!fullyTrusted)
                        this->containsOverridesOrCompressedStackObject_ = TRUE;
                    newCompressedStack->Release();
                }
                else
                {
                    storedObj = new( this ) CompressedStackEntry( newCompressedStack, ECompressedStack );
                    this->depth_ += newCompressedStack->GetDepth();
                }
            }
            else
            {
                storedObj = NULL;
            }

            compressedStack->Release();
        }
        break;

    case EFrameSecurityDescriptor:
        if ((*(FRAMESECDESCREF*)obj)->HasDenials() || (*(FRAMESECDESCREF*)obj)->HasPermitOnly())
        {
            this->containsOverridesOrCompressedStackObject_ = TRUE;
            this->plsOptimizationOn_ = FALSE;
        }
        this->depth_++;
        storedObj = new( this ) CompressedStackEntry( domain->CreateHandle( *(OBJECTREF*)obj ), domain->GetId(), type );
        break;

    case ECompressedStackObject:
        this->containsOverridesOrCompressedStackObject_ = TRUE;
        this->depth_++;
        storedObj = new( this ) CompressedStackEntry( domain->CreateHandle( *(OBJECTREF*)obj ), domain->GetId(), type );
        break;
    
    default:
        _ASSERTE( !"Unknown CompressedStackType" );
        break;
    }

    if (storedObj != NULL)
        this->delayedCompressedStack_->Append( storedObj );
}

OBJECTREF
CompressedStack::GetPermissionListSet( AppDomain* domain )
{
    if (domain == NULL)
        domain = GetAppDomain();

    return GetPermissionListSetInternal( domain, NULL, -1, TRUE );
}


OBJECTREF
CompressedStack::GetPermissionListSetInternal( AppDomain* domain, AppDomain* unloadingDomain, DWORD unloadingDomainId, BOOL unwindRecursion )
{
    AppDomain* pCurrentDomain = GetAppDomain();

    BOOL lockHeld = FALSE;
    OBJECTREF orTemp = NULL;

    BEGIN_ENSURE_COOPERATIVE_GC();

    EE_TRY_FOR_FINALLY
    {
        BOOL useExistingObject = FALSE;

        CompressedStack::listCriticalSection_->Enter();
        lockHeld = TRUE;

        if (this->compressedStackObject_ != NULL)
        {
            AppDomain* domain = SystemDomain::GetAppDomainAtId( this->compressedStackObjectAppDomainId_ );

            useExistingObject = (domain != NULL && !domain->IsUnloading());
        }

        if (useExistingObject && this->compressedStackObject_ != NULL)
        {
            if ((domain == NULL && this->compressedStackObjectAppDomain_ != pCurrentDomain) || (domain != NULL && this->compressedStackObjectAppDomain_ != domain))
            {
                Thread* pThread = GetThread();
                ContextTransitionFrame frame;
                OBJECTREF temp = NULL;
                OBJECTREF retval;
                GCPROTECT_BEGIN( temp );
                temp = ObjectFromHandle( this->compressedStackObject_ );
                CompressedStack::listCriticalSection_->Leave();
                lockHeld = FALSE;

                if (pCurrentDomain != domain)
                {
                    pThread->EnterContextRestricted(domain->GetDefaultContext(), &frame, TRUE);
                    retval = AppDomainHelper::CrossContextCopyFrom( this->compressedStackObjectAppDomain_, &temp );
                    pThread->ReturnToContext(&frame, TRUE);
                }
                else
                {
                    retval = AppDomainHelper::CrossContextCopyFrom( this->compressedStackObjectAppDomain_, &temp );
                }
                GCPROTECT_END();
                orTemp = retval;
            }
            else
                orTemp = ObjectFromHandle( this->compressedStackObject_ );
        }
        else
        {
            BOOL unmarshalObject = (this->pbObjectBlob_ != NULL);
            DWORD appDomainId = domain->GetId();

            CompressedStack::listCriticalSection_->Leave();
            lockHeld = FALSE;

            GCPROTECT_BEGIN( orTemp );

            if (unmarshalObject)
            {
                AppDomainHelper::UnmarshalObject(domain,
                                                 this->pbObjectBlob_,
                                                 this->cbObjectBlob_,
                                                 &orTemp);
            }
            else
            {
                orTemp = GeneratePermissionListSet( domain, unloadingDomain, unloadingDomainId, unwindRecursion );
            }

            GCPROTECT_END();

            lockHeld = TRUE;
            CompressedStack::listCriticalSection_->Enter();

            if (this->compressedStackObject_ == NULL)
            {
                this->compressedStackObject_ = domain->CreateHandle(orTemp);
                this->compressedStackObjectAppDomain_ = domain;
                this->compressedStackObjectAppDomainId_ = appDomainId;
            }
        }
    }
    EE_FINALLY
    {
        if (lockHeld)
            CompressedStack::listCriticalSection_->Leave();
    }
    EE_END_FINALLY

    END_ENSURE_COOPERATIVE_GC();        

    return orTemp;

}


AppDomain*
CompressedStack::GetAppDomainFromId( DWORD id, AppDomain* unloadingDomain, DWORD unloadingDomainId )
{
    if (id == unloadingDomainId)
    {
        _ASSERTE( unloadingDomain != NULL );
        return unloadingDomain;
    }

    AppDomain* domain = SystemDomain::GetAppDomainAtId( id );

    _ASSERTE( domain != NULL && "Domain has been already been unloaded" );

    return domain;
}


OBJECTREF
CompressedStack::GeneratePermissionListSet( AppDomain* targetDomain, AppDomain* unloadingDomain, DWORD unloadingDomainId, BOOL unwindRecursion )
{
    struct _gc
    {
        OBJECTREF permListSet;
    } gc;
    ZeroMemory( &gc, sizeof( gc ) );

    GCPROTECT_BEGIN( gc );

    // Role up the delayedCompressedStack as necessary.  Things get a little wacky
    // here since we want to avoid the recursion that would be necessary if we
    // need to generate a permission list set the child compresseed stack.  Therefore,
    // we're going to search down the virtual linked list of compressed stacks looking
    // for the first one that already has a permission list set (in live or serialized
    // form) and then travel back up the list generating them in backwards order
    // until we reach the <this> compressed stack again.

    if (this->delayedCompressedStack_ != NULL)
    {
        if (!unwindRecursion)
        {
            gc.permListSet = this->CreatePermissionListSet( targetDomain, unloadingDomain, unloadingDomainId );
        }
        else
        {
            ArrayList compressedStackList;

            compressedStackList.Append( this );

            DWORD index = 0;

            while (index < compressedStackList.GetCount())
            {
                CompressedStack* stack = (CompressedStack*)compressedStackList.Get( index );

                if (stack->delayedCompressedStack_ == NULL)
                    break;

                ArrayList::Iterator iter = stack->delayedCompressedStack_->Iterate();

                while (iter.Next())
                {
                    CompressedStackEntry* entry = (CompressedStackEntry*)iter.GetElement();

                    switch (entry->type_)
                    {
                    case ECompressedStack:
                        if (stack->compressedStackObject_ == NULL &&
                            stack->pbObjectBlob_ == NULL &&
                            stack->delayedCompressedStack_ != NULL)
                        {
                            compressedStackList.Append( entry->ptr_ );
                        }
                        break;

                    default:
                        break;
                    }

                }

                index++;
            }

            for (DWORD index = compressedStackList.GetCount() - 1; index > 0; --index)
            {
                ((CompressedStack*)compressedStackList.Get( index ))->GetPermissionListSetInternal( targetDomain, unloadingDomain, unloadingDomainId, FALSE );
            }

            gc.permListSet = ((CompressedStack*)compressedStackList.Get( 0 ))->CreatePermissionListSet( targetDomain, unloadingDomain, unloadingDomainId );
        }   
    }

    if (gc.permListSet == NULL)
    {
        ContextTransitionFrame frame;
        AppDomain* currentDomain = GetAppDomain();
        Thread* pThread = GetThread();

        if (targetDomain != currentDomain)
        {
            pThread->EnterContextRestricted(targetDomain->GetDefaultContext(), &frame, TRUE);
        }

        MethodTable *pMT = g_Mscorlib.GetClass(CLASS__PERMISSION_LIST_SET);
        MethodDesc *pCtor = g_Mscorlib.GetMethod(METHOD__PERMISSION_LIST_SET__CTOR);

        gc.permListSet = AllocateObject(pMT);

        INT64 arg[1] = { 
            ObjToInt64(gc.permListSet)
        };

        pCtor->Call(arg, METHOD__PERMISSION_LIST_SET__CTOR);

        if (targetDomain != currentDomain)
        {
            pThread->ReturnToContext(&frame, TRUE);
        }
    }

    GCPROTECT_END();

    return gc.permListSet;
}


OBJECTREF
CompressedStack::CreatePermissionListSet( AppDomain* targetDomain, AppDomain* unloadingDomain, DWORD unloadingDomainId )
{
    struct _gc
    {
        OBJECTREF permListSet;
        OBJECTREF grant;
        OBJECTREF denied;
        OBJECTREF frame;
        OBJECTREF compressedStack;
    } gc;
    ZeroMemory( &gc, sizeof( gc ) );

    ApplicationSecurityDescriptor* pAppSecDesc;
    SharedSecurityDescriptor* pSharedSecDesc;
    AssemblySecurityDescriptor* pAsmSecDesc;

    // Do all the work in the current appdomain, marshalling
    // things over as necessary.

    // First, generate a new, empty permission list set

    GCPROTECT_BEGIN( gc );

    MethodDesc *pCompress = g_Mscorlib.GetMethod(METHOD__SECURITY_ENGINE__STACK_COMPRESS_WALK_HELPER);
    MethodDesc *pAppend = g_Mscorlib.GetMethod(METHOD__PERMISSION_LIST_SET__APPEND_STACK);
    MethodTable *pMT = g_Mscorlib.GetClass(CLASS__PERMISSION_LIST_SET);
    MethodDesc *pCtor = g_Mscorlib.GetMethod(METHOD__PERMISSION_LIST_SET__CTOR);

    gc.permListSet = AllocateObject(pMT);

    INT64 arg[1] = { 
        ObjToInt64(gc.permListSet)
    };

    pCtor->Call(arg, METHOD__PERMISSION_LIST_SET__CTOR);

    DWORD sourceDomainId = -1;
    AppDomain* sourceDomain = NULL;
    DWORD possibleStackIndex = -1;
    AppDomain* currentDomain = GetAppDomain();
    AppDomain* oldSourceDomain = NULL;
    AppDomain* currentPLSDomain = currentDomain;
    Thread* pThread = GetThread();

    ContextTransitionFrame frame;

    INT64 appendArgs[2];
    INT64 compressArgs[5];

    _ASSERTE( this->delayedCompressedStack_ != NULL );

    BOOL done = FALSE;

    COMPLUS_TRY
    {
        ArrayList::Iterator iter = this->delayedCompressedStack_->Iterate();

        while (!done && iter.Next())
        {
            CompressedStackEntry* entry = (CompressedStackEntry*)iter.GetElement();

            if (entry == NULL)
                continue;

            switch (entry->type_)
            {
            case EApplicationSecurityDescriptor:
                pAppSecDesc = (ApplicationSecurityDescriptor*)entry->ptr_;
                gc.grant = pAppSecDesc->GetGrantedPermissionSet( &gc.denied );
                // No need to marshal since the grant set will already be in the proper domain.
                compressArgs[4] = ObjToInt64(gc.permListSet);
                compressArgs[3] = (INT64)FALSE;
                compressArgs[2] = ObjToInt64(gc.grant);
                compressArgs[1] = ObjToInt64(gc.denied);
                compressArgs[0] = NULL;
                if (sourceDomain != currentDomain)
                {
                    _ASSERTE( sourceDomain != NULL );
                    pThread->EnterContextRestricted(sourceDomain->GetDefaultContext(), &frame, TRUE);
                    pCompress->Call( compressArgs, METHOD__SECURITY_ENGINE__STACK_COMPRESS_WALK_HELPER );
                    pThread->ReturnToContext(&frame, TRUE);
                }
                else
                {
                    pCompress->Call( compressArgs, METHOD__SECURITY_ENGINE__STACK_COMPRESS_WALK_HELPER );
                }
                break;

            case ESharedSecurityDescriptor:
                pSharedSecDesc = (SharedSecurityDescriptor*)entry->ptr_;
                _ASSERTE( !pSharedSecDesc->IsSystem() );
                pAsmSecDesc = pSharedSecDesc->GetAssembly()->GetSecurityDescriptor( sourceDomain );
                _ASSERTE( pAsmSecDesc );
                gc.grant = pAsmSecDesc->GetGrantedPermissionSet( &gc.denied );
                compressArgs[4] = ObjToInt64(gc.permListSet);
                compressArgs[3] = (INT64)FALSE;
                compressArgs[2] = ObjToInt64(gc.grant);
                compressArgs[1] = ObjToInt64(gc.denied);
                compressArgs[0] = NULL;
                if (sourceDomain != currentDomain)
                {
                    _ASSERTE( sourceDomain != NULL );
                    pThread->EnterContextRestricted(sourceDomain->GetDefaultContext(), &frame, TRUE);
                    pCompress->Call( compressArgs, METHOD__SECURITY_ENGINE__STACK_COMPRESS_WALK_HELPER );
                    pThread->ReturnToContext(&frame, TRUE);
                }
                else
                {
                    pCompress->Call( compressArgs, METHOD__SECURITY_ENGINE__STACK_COMPRESS_WALK_HELPER );
                }
                break;

            case EFrameSecurityDescriptor:
                gc.frame = ObjectFromHandle( entry->handleStruct_.handle_ );
                // The frame security descriptor will already be in the correct context
                // so no need to marshal.
                compressArgs[4] = ObjToInt64(gc.permListSet);
                compressArgs[3] = (INT64)TRUE;
                compressArgs[2] = NULL;
                compressArgs[1] = NULL;
                compressArgs[0] = ObjToInt64(gc.frame);
                if (sourceDomain != currentDomain)
                {
                    _ASSERTE( sourceDomain != NULL );
                    pThread->EnterContextRestricted(sourceDomain->GetDefaultContext(), &frame, TRUE);
                    pCompress->Call( compressArgs, METHOD__SECURITY_ENGINE__STACK_COMPRESS_WALK_HELPER );
                    pThread->ReturnToContext(&frame, TRUE);
                }
                else
                {
                    pCompress->Call( compressArgs, METHOD__SECURITY_ENGINE__STACK_COMPRESS_WALK_HELPER );
                }
                break;
        
            case ECompressedStack:
                gc.compressedStack = ((CompressedStack*)entry->ptr_)->GetPermissionListSetInternal( sourceDomain, unloadingDomain, unloadingDomainId, TRUE );
                // GetPermissionListSet will give us the object in the proper
                // appdomain so no need to marshal.
                appendArgs[1] = ObjToInt64(gc.compressedStack);
                appendArgs[0] = ObjToInt64(gc.permListSet);
                if (sourceDomain != currentDomain)
                {
                    _ASSERTE( sourceDomain != NULL );
                    pThread->EnterContextRestricted(sourceDomain->GetDefaultContext(), &frame, TRUE);
                    pAppend->Call(appendArgs, METHOD__PERMISSION_LIST_SET__APPEND_STACK);
                    pThread->ReturnToContext(&frame, TRUE);
                }
                else
                {
                    pAppend->Call(appendArgs, METHOD__PERMISSION_LIST_SET__APPEND_STACK);
                }
                break;
        
            case ECompressedStackObject:
                gc.compressedStack = ObjectFromHandle( entry->handleStruct_.handle_ );
                // The compressed stack object will already be in the sourceDomain so
                // no need to marshal.
                appendArgs[1] = ObjToInt64(gc.compressedStack);
                appendArgs[0] = ObjToInt64(gc.permListSet);
                if (sourceDomain != currentDomain)
                {
                    _ASSERTE( sourceDomain != NULL );
                    pThread->EnterContextRestricted(sourceDomain->GetDefaultContext(), &frame, TRUE);
                    pAppend->Call(appendArgs, METHOD__PERMISSION_LIST_SET__APPEND_STACK);
                    pThread->ReturnToContext(&frame, TRUE);
                }
                else
                {
                    pAppend->Call(appendArgs, METHOD__PERMISSION_LIST_SET__APPEND_STACK);
                }
                break;

            case EAppDomainTransition:
                oldSourceDomain = sourceDomain;
                sourceDomainId = entry->indexStruct_.index_;
                sourceDomain = CompressedStack::GetAppDomainFromId( sourceDomainId, unloadingDomain, unloadingDomainId );
                if (sourceDomain == NULL)
                {
                    _ASSERTE( !"An appdomain on the stack has been unloaded and the compressed stack cannot be formed" );

                    // If we hit this case in non-debug builds, we still need to play it safe, so
                    // we'll push an empty grant set onto the compressed stack.
                    gc.grant = SecurityHelper::CreatePermissionSet(FALSE);
                    if (oldSourceDomain != currentPLSDomain)
                        gc.grant = AppDomainHelper::CrossContextCopyTo( currentPLSDomain, &gc.grant );
                    compressArgs[4] = ObjToInt64(gc.permListSet);
                    compressArgs[3] = (INT64)FALSE;
                    compressArgs[2] = ObjToInt64(gc.grant);
                    compressArgs[1] = NULL;
                    compressArgs[0] = NULL;
                    if (currentPLSDomain != currentDomain)
                    {
                        pThread->EnterContextRestricted(currentPLSDomain->GetDefaultContext(), &frame, TRUE);
                        pCompress->Call( compressArgs, METHOD__SECURITY_ENGINE__STACK_COMPRESS_WALK_HELPER );
                        pThread->ReturnToContext(&frame, TRUE);
                    }
                    else
                    {
                        pCompress->Call( compressArgs, METHOD__SECURITY_ENGINE__STACK_COMPRESS_WALK_HELPER );
                    }
                    done = TRUE;
                }
                else if (sourceDomain != currentPLSDomain)
                {
                    // marshal the permission list set into the sourceDomain of the upcoming object on the stack.
                    pThread->EnterContextRestricted(currentPLSDomain->GetDefaultContext(), &frame, TRUE);
                    gc.permListSet = AppDomainHelper::CrossContextCopyTo( sourceDomain, &gc.permListSet );
                    pThread->ReturnToContext(&frame, TRUE);
                    currentPLSDomain = sourceDomain;
                }

                break;

            default:
                _ASSERTE( !"Unrecognized CompressStackType" );
            }
        }
    }
    COMPLUS_CATCH
    {
        // We're not actually expecting any exceptions to occur during any of this code.

        _ASSERTE( !"Unexpected exception while generating compressed security stack" );

        // If an exception does occur, let's play it safe and push an empty grant set
        // onto the compressed stack.

        gc.grant = SecurityHelper::CreatePermissionSet(FALSE);
        if (currentPLSDomain != currentDomain)
            gc.permListSet = AppDomainHelper::CrossContextCopyFrom( currentPLSDomain, &gc.permListSet );
        compressArgs[4] = ObjToInt64(gc.permListSet);
        compressArgs[3] = (INT64)FALSE;
        compressArgs[2] = ObjToInt64(gc.grant);
        compressArgs[1] = NULL;
        compressArgs[0] = NULL;
        pCompress->Call( compressArgs, METHOD__SECURITY_ENGINE__STACK_COMPRESS_WALK_HELPER );
        currentPLSDomain = currentDomain;
    }
    COMPLUS_END_CATCH

    if (currentPLSDomain != targetDomain)
    {
        pThread->EnterContextRestricted(currentPLSDomain->GetDefaultContext(), &frame, TRUE);
        gc.permListSet = AppDomainHelper::CrossContextCopyTo( targetDomain, &gc.permListSet );
        pThread->ReturnToContext(&frame, TRUE);
    }


    GCPROTECT_END();

    return gc.permListSet;
}

// This piece of code tries to take advantage of
// the quick cache or other resolves that might
// have already taken place.  It is only complicated by
// the need to unwind the recursion.


bool
CompressedStack::LazyIsFullyTrusted()
{
    if (this->isFullyTrustedDecision_ != -1)
        return this->isFullyTrustedDecision_ == 1;

    ArrayList virtualStack;

    virtualStack.Append( this );

    ArrayList::Iterator virtualStackIter = virtualStack.Iterate();

    DWORD currentIndex = 0;

    while (currentIndex < virtualStack.GetCount())
    {
        CompressedStack* stack = (CompressedStack*)virtualStack.Get( currentIndex );
        currentIndex++;

        // If we have already compressed the stack, we cannot make
        // a determination of full trust lazily since we cannot
        // be sure that the delayedCompressedStack list is still
        // valid.

        if (stack->isFullyTrustedDecision_ == 0)
        {
            this->isFullyTrustedDecision_ = 0;
            return false;
        }

        if (stack->isFullyTrustedDecision_ == 1)
            continue;

        if (stack->compressedStackObject_ != NULL || stack->pbObjectBlob_ != NULL)
        {
            this->isFullyTrustedDecision_ = 0;
            return false;
        }

        // If we don't have a delayed compressed stack then
        // we cannot make a lazy determination.

        if (stack->delayedCompressedStack_ == NULL)
        {
            this->isFullyTrustedDecision_ = 0;
            return false;
        }

        // If the stack contains overrides than we just
        // give up.

        if (stack->containsOverridesOrCompressedStackObject_)
        {
            this->isFullyTrustedDecision_ = 0;
            return false;
        }

        ApplicationSecurityDescriptor* pAppSecDesc;
        SharedSecurityDescriptor* pSharedSecDesc;
        FRAMESECDESCREF objRef;

        AppDomain* domain = GetAppDomain();


        ArrayList::Iterator iter = stack->delayedCompressedStack_->Iterate();

        while (iter.Next())
        {
            CompressedStackEntry* entry = (CompressedStackEntry*)iter.GetElement();

            if (entry == NULL)
                continue;

            switch (entry->type_)
            {
            // In the case where we have security descriptors, just ask
            // them if they are fully trusted.

            case EApplicationSecurityDescriptor:
                pAppSecDesc = (ApplicationSecurityDescriptor*)entry->ptr_;
                if (!pAppSecDesc->IsFullyTrusted())
                {
                    this->isFullyTrustedDecision_ = 0;
                    stack->isFullyTrustedDecision_ = 0;
                    return false;
                }
                break;

            case ESharedSecurityDescriptor:
                pSharedSecDesc = (SharedSecurityDescriptor*)entry->ptr_;
                if (!pSharedSecDesc->IsFullyTrusted())
                {
                    this->isFullyTrustedDecision_ = 0;
                    stack->isFullyTrustedDecision_ = 0;
                    return false;
                }
                break;

            case ECompressedStackObject:
                if (!entry->handleStruct_.fullyTrusted_)
                {
                    this->isFullyTrustedDecision_ = 0;
                    stack->isFullyTrustedDecision_ = 0;
                    return false;
                }
                break;
    
            case EFrameSecurityDescriptor:
                objRef = (FRAMESECDESCREF)ObjectFromHandle( entry->handleStruct_.handle_ );
                _ASSERTE( !objRef->HasDenials() &&
                          !objRef->HasPermitOnly() );
                break;
        
            case ECompressedStack:
                virtualStack.Append( entry->ptr_ );
                break;
    
            case EAppDomainTransition:
                break;

            default:
                _ASSERT( !"Unrecognized CompressStackType" );
            }
        }
    }

    this->isFullyTrustedDecision_ = 1;
    return true;
}


LONG
CompressedStack::AddRef()
{
    CompressedStack::listCriticalSection_->Enter();

    LONG retval = ++this->refCount_;

    CompressedStack::listCriticalSection_->Leave();

    _ASSERTE( retval > 0 && "We overflowed the AddRef for this object.  That's no good!" );

    return retval;
}


LONG
CompressedStack::Release( void )
{
    Thread* pThread = SetupThread();

    CompressedStack::listCriticalSection_->Enter();

    LONG firstRetval = --this->refCount_;

    if (firstRetval == 0)
    {
        ArrayList virtualStack;
        virtualStack.Append( this );

        DWORD currentIndex = 0;

        while (currentIndex < virtualStack.GetCount())
        {
            CompressedStack* stack = (CompressedStack*)virtualStack.Get( currentIndex );

            LONG retval;
            
            if (currentIndex == 0)
            {
                retval = firstRetval;
            }
            else
            {
                retval = --stack->refCount_;
            }

            _ASSERTE( retval >= 0 && "We underflowed the Release for this object.  That's no good!" );

            if (retval == 0)
            {
                stack->RemoveFromList();

                if (stack->delayedCompressedStack_ != NULL)
                {
                    ArrayList::Iterator iter = stack->delayedCompressedStack_->Iterate();

                    while (iter.Next())
                    {
                        CompressedStackEntry* entry = (CompressedStackEntry*)iter.GetElement();

                        CompressedStack* stackToPush = entry->Destroy( stack );

                        if (stackToPush != NULL)
                        {
                            virtualStack.Append( stackToPush );
                        }
                    }

                    delete stack->delayedCompressedStack_;
                }
                FreeM( stack->pbObjectBlob_ );

                CompressedStack::listCriticalSection_->Leave();

                BEGIN_ENSURE_COOPERATIVE_GC();

                if (stack->compressedStackObject_ != NULL)
                {
                    AppDomain* domain = SystemDomain::GetAppDomainAtId( stack->compressedStackObjectAppDomainId_ );

                    if (domain != NULL && !domain->IsUnloading())
                        DestroyHandle( stack->compressedStackObject_ );
                    stack->compressedStackObject_ = NULL;
                    stack->compressedStackObjectAppDomain_ = NULL;
                    stack->compressedStackObjectAppDomainId_ = -1;
                }

                END_ENSURE_COOPERATIVE_GC();

                CompressedStack::listCriticalSection_->Enter();                

                delete stack;
            }

            currentIndex++;
        }
    }

    CompressedStack::listCriticalSection_->Leave();

    return firstRetval;
}


CompressedStack::~CompressedStack( void )
{
    ArrayList::Iterator iter = this->entriesMemoryList_.Iterate();

    while (iter.Next())
    {
        delete [] iter.GetElement();
    }

}

// #define     NEW_TLS     1

#ifdef _DEBUG
void  Thread::SetFrame(Frame *pFrame) {
    m_pFrame = pFrame;
    _ASSERTE(PreemptiveGCDisabled());
#if defined(_X86_)
    if (this == GetThread()) {
        static int ctr = 0;
        if (--ctr == 0)
            --ctr;          // just a statement to put a breakpoint on

        Frame* espVal;
        __asm mov espVal, ESP
        while (pFrame != (Frame*) -1) {

            static Frame* stopFrame = 0;
            if (pFrame == stopFrame)
                _ASSERTE(!"SetFrame frame == stopFrame");

            _ASSERTE (espVal < pFrame && pFrame < m_CacheStackBase &&
                      pFrame->GetFrameType() < Frame::TYPE_COUNT);
            pFrame = pFrame->m_Next;
        }
    }
#endif
}
#endif

//************************************************************************
// PRIVATE GLOBALS
//************************************************************************
DWORD         gThreadTLSIndex = ((DWORD)(-1));            // index ( (-1) == uninitialized )
DWORD         gAppDomainTLSIndex = ((DWORD)(-1));         // index ( (-1) == uninitialized )


#define ThreadInited()          (gThreadTLSIndex != ((DWORD)(-1)))

// Every PING_JIT_TIMEOUT ms, check to see if a thread in JITted code has wandered
// into some fully interruptible code (or should have a different hijack to improve
// our chances of snagging it at a safe spot).
#define PING_JIT_TIMEOUT        250

// When we find a thread in a spot that's not safe to abort -- how long to wait before
// we try again.
#define ABORT_POLL_TIMEOUT      10
#ifdef _DEBUG
#define ABORT_FAIL_TIMEOUT      40000
#endif


// For now, give our suspension attempts 40 seconds to succeed before trapping to
// the debugger.   Note that we should probably lower this when the JIT is run in
// preemtive mode, as we really should not be starving the GC for 10's of seconds

#ifdef _DEBUG
unsigned DETECT_DEADLOCK_TIMEOUT=40000;
#endif

#ifdef _DEBUG
    #define MAX_WAIT_OBJECTS 2
#else
    #define MAX_WAIT_OBJECTS MAXIMUM_WAIT_OBJECTS
#endif


#define IS_VALID_WRITE_PTR(addr, size)      _ASSERTE( ! ::IsBadWritePtr(addr, size))
#define IS_VALID_CODE_PTR(addr)             _ASSERTE( ! ::IsBadCodePtr(addr))


// This is the code we pass around for Thread.Interrupt, mainly for assertions
#define APC_Code    0xEECEECEE


// Class static data:
long    Thread::m_DebugWillSyncCount = -1;
long    Thread::m_DetachCount = 0;
long    Thread::m_ActiveDetachCount = 0;

//-------------------------------------------------------------------------
// Public function: SetupThread()
// Creates Thread for current thread if not previously created.
// Returns NULL for failure (usually due to out-of-memory.)
//-------------------------------------------------------------------------
Thread* SetupThread()
{
    _ASSERTE(ThreadInited());
    Thread* pThread;

    if ((pThread = GetThread()) != NULL)
        return pThread;

        // Normally, HasStarted is called from the thread's entrypoint to introduce it to
        // the runtime.  But sometimes that thread is used for DLL_THREAD_ATTACH notifications
        // that call into managed code.  In that case, a call to SetupThread here must
        // find the correct Thread object and install it into TLS.
        if (g_pThreadStore->m_PendingThreadCount != 0)
        {
            DWORD  ourThreadId = ::GetCurrentThreadId();

            ThreadStore::LockThreadStore();
            {
                _ASSERTE(pThread == NULL);
                while ((pThread = g_pThreadStore->GetAllThreadList(pThread, Thread::TS_Unstarted, Thread::TS_Unstarted)) != NULL)
                    if (pThread->GetThreadId() == ourThreadId)
                        break;
            }
            ThreadStore::UnlockThreadStore();

            // It's perfectly reasonable to not find this guy.  It's just an unrelated
            // thread spinning up.
            if (pThread)
                return (pThread->HasStarted()
                        ? pThread
                        : NULL);
        }

        // First time we've seen this thread in the runtime:
        pThread = new Thread();
        if (pThread)
        {
            if (!pThread->PrepareApartmentAndContext())
                goto fail;

            if (pThread->InitThread())
            {
                TlsSetValue(gThreadTLSIndex, (VOID*)pThread);
                TlsSetValue(gAppDomainTLSIndex, (VOID*)pThread->GetDomain());
                
                // reset any unstarted bits on the thread object
                FastInterlockAnd((ULONG *) &pThread->m_State, ~Thread::TS_Unstarted);
                FastInterlockOr((ULONG *) &pThread->m_State, Thread::TS_LegalToJoin);
                ThreadStore::AddThread(pThread);
            
#ifdef DEBUGGING_SUPPORTED
                //
                // If we're debugging, let the debugger know that this
                // thread is up and running now.
                //
                if (CORDebuggerAttached())
                {
                    g_pDebugInterface->ThreadCreated(pThread);
                }
                else
                {
                    LOG((LF_CORDB, LL_INFO10000, "ThreadCreated() not called due to CORDebuggerAttached() being FALSE for thread 0x%x\n", pThread->GetThreadId()));
                }
#endif // DEBUGGING_SUPPORTED

#ifdef PROFILING_SUPPORTED
                // If a profiler is present, then notify the profiler that a
                // thread has been created.
                if (CORProfilerTrackThreads())
                {
                    g_profControlBlock.pProfInterface->ThreadCreated(
                        (ThreadID)pThread);

                    DWORD osThreadId = ::GetCurrentThreadId();

                    g_profControlBlock.pProfInterface->ThreadAssignedToOSThread(
                        (ThreadID)pThread, osThreadId);
                }
#endif // PROFILING_SUPPORTED

                _ASSERTE(!pThread->IsBackground()); // doesn't matter, but worth checking
                pThread->SetBackground(TRUE);

            }
            else
            {
fail:           delete pThread;
                pThread = NULL;
            }
			
        }

    return pThread;
}

//-------------------------------------------------------------------------
// Public function: SetupThreadPoolThread()
// Just like SetupThread, but also sets a bit to indicate that this is a threadpool thread
Thread* SetupThreadPoolThread(ThreadpoolThreadType typeTPThread)
{
    _ASSERTE(ThreadInited());
    Thread* pThread;

    if (NULL == (pThread = GetThread()))
    {
        pThread = SetupThread();
    }
    if ((pThread->m_State & Thread::TS_ThreadPoolThread) == 0)
    {

        if (typeTPThread == WorkerThread)
            FastInterlockOr((ULONG *) &pThread->m_State, Thread::TS_ThreadPoolThread | Thread::TS_TPWorkerThread);
        else
            FastInterlockOr((ULONG *) &pThread->m_State, Thread::TS_ThreadPoolThread);

    }
    return pThread;
}

void STDMETHODCALLTYPE CorMarkThreadInThreadPool()
{
    // this is no longer needed after our switch to  
    // the Win32 threadpool.
    // @TODO: remove the exposed dll entry and get rid of it
}


//-------------------------------------------------------------------------
// Public function: SetupUnstartedThread()
// This sets up a Thread object for an exposed System.Thread that
// has not been started yet.  This allows us to properly enumerate all threads
// in the ThreadStore, so we can report on even unstarted threads.  Clearly
// there is no physical thread to match, yet.
//
// When there is, complete the setup with Thread::HasStarted()
//-------------------------------------------------------------------------
Thread* SetupUnstartedThread()
{
    _ASSERTE(ThreadInited());
    Thread* pThread = new Thread();

    if (pThread)
    {
        FastInterlockOr((ULONG *) &pThread->m_State,
                        (Thread::TS_Unstarted | Thread::TS_WeOwn));

        ThreadStore::AddThread(pThread);
    }

    return pThread;
}


//-------------------------------------------------------------------------
// Public function: DestroyThread()
// Destroys the specified Thread object, for a thread which is about to die.
//-------------------------------------------------------------------------
void DestroyThread(Thread *th)
{
    _ASSERTE(g_fEEShutDown || th->m_dwLockCount == 0);
    th->OnThreadTerminate(FALSE);
}


//-------------------------------------------------------------------------
// Public function: DetachThread()
// Marks the thread as needing to be destroyed, but doesn't destroy it yet.
//-------------------------------------------------------------------------
void DetachThread(Thread *th)
{
    _ASSERTE(!th->PreemptiveGCDisabled());
    _ASSERTE(g_fEEShutDown || th->m_dwLockCount == 0);

    FastInterlockIncrement(&Thread::m_DetachCount);
    FastInterlockOr((ULONG*)&th->m_State, (long) Thread::TS_Detached);
    if (!(GetThread()->IsBackground()))
    {
        FastInterlockIncrement(&Thread::m_ActiveDetachCount);
        ThreadStore::CheckForEEShutdown();
    }
}


//-------------------------------------------------------------------------
// Public function: GetThread()
// Returns Thread for current thread. Cannot fail since it's illegal to call this
// without having called SetupThread.
//-------------------------------------------------------------------------
Thread* DummyGetThread()
{
    return NULL;
}

Thread* (*GetThread)() = DummyGetThread;    // Points to platform-optimized GetThread() function.


//---------------------------------------------------------------------------
// Returns the TLS index for the Thread. This is strictly for the use of
// our ASM stub generators that generate inline code to access the Thread.
// Normally, you should use GetThread().
//---------------------------------------------------------------------------
DWORD GetThreadTLSIndex()
{
    return gThreadTLSIndex;
}

//---------------------------------------------------------------------------
// Portable GetThread() function: used if no platform-specific optimizations apply.
// This asm crap is here because we count on edx not getting trashed on calls
// to this function.
//---------------------------------------------------------------------------
#ifdef _X86_
__declspec(naked) static Thread* GetThreadGeneric()
{
        __asm {
        push    ecx                                                     // Callers assume this is preserved.
        push    edx                                                     // Callers assume this is preserved.
        push    esi                                                     // Checked build stack balancing uses this.
        }

        _ASSERTE(ThreadInited());

        TlsGetValue(gThreadTLSIndex);
        // No code can occur before the __asm because we rely on eax.
        __asm {
        pop             esi
        pop             edx
        pop             ecx
        ret
        }
}
#else
static Thread* GetThreadGeneric()
{
    _ASSERTE(ThreadInited());

    return (Thread*)TlsGetValue(gThreadTLSIndex);
}
#endif

//-------------------------------------------------------------------------
// Public function: GetAppDomain()
// Returns AppDomain for current thread. Cannot fail since it's illegal to call this
// without having called SetupThread.
//-------------------------------------------------------------------------
AppDomain* (*GetAppDomain)() = NULL;   // Points to platform-optimized GetThread() function.

//---------------------------------------------------------------------------
// Returns the TLS index for the AppDomain. This is strictly for the use of
// our ASM stub generators that generate inline code to access the AppDomain.
// Normally, you should use GetAppDomain().
//---------------------------------------------------------------------------
DWORD GetAppDomainTLSIndex()
{
    return gAppDomainTLSIndex;
}

//---------------------------------------------------------------------------
// Portable GetAppDomain() function: used if no platform-specific optimizations apply.
// This asm crap is here because we count on edx not getting trashed on calls
// to this function.
//---------------------------------------------------------------------------
#ifdef _X86_
__declspec(naked) static AppDomain* GetAppDomainGeneric()
{
        __asm {
        push    ecx                                                     // Callers assume this is preserved.
        push    edx                                                     // Callers assume this is preserved.
        push    esi                                                     // Checked build stack balancing uses this.
        }

        _ASSERTE(ThreadInited());

        TlsGetValue(gAppDomainTLSIndex);
        // No code can occur before the __asm because we rely on eax.
        __asm {
        pop             esi
        pop             edx
        pop             ecx
        ret
        }
}
#else
static AppDomain* GetAppDomainGeneric()
{
    _ASSERTE(ThreadInited());

    return (AppDomain*)TlsGetValue(gAppDomainTLSIndex);
}
#endif


//-------------------------------------------------------------------------
// Public function: GetCurrentContext()
// Returns the current context.  InitThreadManager initializes this at startup
// to point to GetCurrentContextGeneric().  See that for explanation.
//-------------------------------------------------------------------------
Context* (*GetCurrentContext)() = NULL;


//---------------------------------------------------------------------------
// Portable GetCurrentContext() function: always used for now.  But may be
// replaced later if we move the Context directly into the TLS (for speed &
// COM Interop reasons).
// @TODO context cwb: either move it, or make this an inline.
//---------------------------------------------------------------------------
static Context* GetCurrentContextGeneric()
{
    return GetThread()->GetContext();
}

#ifdef _DEBUG
unsigned int Thread::OBJREF_HASH = OBJREF_TABSIZE;
#endif

// Win9X specific versions of GetThreadContext and SetThreadContext, see
// InitThreadManager for details.
BOOL Win9XGetThreadContext(Thread *pThread, CONTEXT *pContext)
{
    NDPHLPR_CONTEXT sCtx;
    sCtx.NDPHLPR_status = 0;
    sCtx.NDPHLPR_data = 0;
    sCtx.NDPHLPR_threadId = pThread->GetThreadId();
    sCtx.NDPHLPR_ctx.ContextFlags = pContext->ContextFlags;

    DWORD dwDummy;
    BOOL fRet = DeviceIoControl(g_hNdpHlprVxD,
                                NDPHLPR_GetThreadContext,
                                &sCtx,
                                sizeof(NDPHLPR_CONTEXT),
                                &sCtx,
                                sizeof(NDPHLPR_CONTEXT),
                                &dwDummy,
                                NULL);
    if (!fRet)
        return FALSE;

    memcpy(pContext, &sCtx.NDPHLPR_ctx, sizeof(CONTEXT));

    return TRUE;
}

BOOL Win9XSetThreadContext(Thread *pThread, const CONTEXT *pContext)
{
    NDPHLPR_CONTEXT sCtx;
    sCtx.NDPHLPR_status = 0;
    sCtx.NDPHLPR_data = 0;
    sCtx.NDPHLPR_threadId = pThread->GetThreadId();
    memcpy(&sCtx.NDPHLPR_ctx, pContext, sizeof(CONTEXT));

    DWORD dwDummy;
    return DeviceIoControl(g_hNdpHlprVxD,
                           NDPHLPR_SetThreadContext,
                           &sCtx,
                           sizeof(NDPHLPR_CONTEXT),
                           &sCtx,
                           sizeof(NDPHLPR_CONTEXT),
                           &dwDummy,
                           NULL);
}

INDEBUG(void* forceStackA;)

BOOL NTGetThreadContext(Thread *pThread, CONTEXT *pContext)
{
#ifdef _DEBUG 
    int suspendCount = ::SuspendThread(pThread->GetThreadHandle());
    forceStackA = &suspendCount;
    _ASSERTE(suspendCount > 0);
    if (suspendCount >= 0) 
        ::ResumeThread(pThread->GetThreadHandle());
#endif

    BOOL ret =  ::GetThreadContext(pThread->GetThreadHandle(), pContext);
    STRESS_LOG4(LF_SYNC, LL_INFO1000, "Got thread context ret = %d EIP = %x ESP = %x EBP = %x\n",
        ret, pContext->Eip, pContext->Esp, pContext->Ebp);
    return ret;
        
}

BOOL NTSetThreadContext(Thread *pThread, const CONTEXT *pContext)
{
#ifdef _DEBUG 
    int suspendCount = ::SuspendThread(pThread->GetThreadHandle());
    forceStackA = &suspendCount;
    _ASSERTE(suspendCount > 0);
    if (suspendCount >= 0) 
        ::ResumeThread(pThread->GetThreadHandle());
#endif

    BOOL ret = ::SetThreadContext(pThread->GetThreadHandle(), pContext);
    STRESS_LOG4(LF_SYNC, LL_INFO1000, "Set thread context ret = %d EIP = %x ESP = %x EBP = %x\n",
        ret, pContext->Eip, pContext->Esp, pContext->Ebp);
    return ret;
}

//---------------------------------------------------------------------------
// One-time initialization. Called during Dll initialization. So
// be careful what you do in here!
//---------------------------------------------------------------------------
BOOL InitThreadManager()
{
    _ASSERTE(gThreadTLSIndex == ((DWORD)(-1)));
    _ASSERTE(g_TrapReturningThreads == 0);

#ifdef _DEBUG
    // Randomize OBJREF_HASH to handle hash collision.
    Thread::OBJREF_HASH = OBJREF_TABSIZE - (DbgGetEXETimeStamp()%10);
#endif
    
    DWORD idx = TlsAlloc();
    if (idx == ((DWORD)(-1)))
    {
        _ASSERTE(FALSE);
        return FALSE;
    }

    gThreadTLSIndex = idx;

    GetThread = (POPTIMIZEDTHREADGETTER)MakeOptimizedTlsGetter(gThreadTLSIndex, (POPTIMIZEDTLSGETTER)GetThreadGeneric);

    if (!GetThread)
    {
        TlsFree(gThreadTLSIndex);
        gThreadTLSIndex = (DWORD)(-1);
        return FALSE;
    }

    idx = TlsAlloc();
    if (idx == ((DWORD)(-1)))
    {
        TlsFree(gThreadTLSIndex);
        FreeOptimizedTlsGetter( gThreadTLSIndex, (POPTIMIZEDTLSGETTER)GetThread );
        GetThread = DummyGetThread;
        gThreadTLSIndex = (DWORD)(-1);
        _ASSERTE(FALSE);
        return FALSE;
    }

    gAppDomainTLSIndex = idx;

    GetAppDomain = (POPTIMIZEDAPPDOMAINGETTER)MakeOptimizedTlsGetter(gAppDomainTLSIndex, (POPTIMIZEDTLSGETTER)GetAppDomainGeneric);

    if (!GetAppDomain)
    {
        TlsFree(gThreadTLSIndex);
        FreeOptimizedTlsGetter( gThreadTLSIndex, (POPTIMIZEDTLSGETTER)GetThread );
        GetThread = DummyGetThread;
        TlsFree(gAppDomainTLSIndex);
        gThreadTLSIndex = (DWORD)(-1);
        return FALSE;
    }

    // For now, access GetCurrentContext() as a function pointer even though it is
    // just pulled out of the Thread object.  That's because it may move directly
    // into the TLS later, for speed and COM interoperability reasons.  This avoids
    // having to change all the clients, if it does.
    GetCurrentContext = GetCurrentContextGeneric;

    // Fix for Win9X when getting and setting thread contexts. Basically, a blocked
    // thread can be hijacked by the OS for use in reflecting v86 interrupts. If a
    // GetThreadContext is performed at this stage, the results are corrupted. To
    // get around this, we install a VxD on Win9X that provides GetThreadContext
    // functionality but with an additional error case for when an incorrect context
    // would have been returned. Upon a GetThreadContext failure we should resume
    // and resuspend the thread (this is required to shift some stubborn v86
    // interrupt handlers).

    if (RunningOnWin95())
    {
        // There appears to be a timing window bug when loading dynamic VxDs
        // simultaneously from different processed (the OS ends up with two
        // versions loaded and mixes up the ref-counting and event routing).
        // To work around this, we're going to serialize connecting to the VxD
        // machine wide using a named mutex.

        HANDLE hMutex;
        if ((hMutex = WszCreateMutex(NULL, TRUE, L"__NDPHLPR_Load_Mutex")) != NULL)
        {
            // If we didn't create the mutex (and since we asked for ownership
            // on creation this is the only time we get here without ownership)
            // wait to acquire it here.
            if (GetLastError() == ERROR_ALREADY_EXISTS)
                WaitForSingleObject(hMutex, INFINITE);

            // Open a link to the Vxd that provides the new functionality.
            g_hNdpHlprVxD = CreateFileA(NDPHLPR_DEVNAME,
                                        GENERIC_READ,
                                        FILE_SHARE_READ,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,
                                        NULL);
            if (g_hNdpHlprVxD != INVALID_HANDLE_VALUE)
            {
                // Initialize the device (in case we're the first process to use
                // it).
                DWORD dwProcID = GetCurrentProcessId();
                DWORD dwVersion;
                DWORD dwDummy;
                if (DeviceIoControl(g_hNdpHlprVxD,
                                    NDPHLPR_Init,
                                    &dwProcID,
                                    sizeof(DWORD),
                                    &dwVersion,
                                    sizeof(DWORD),
                                    &dwDummy,
                                    NULL))
                {
                    // Check the device version (in case the protocol changes in
                    // later builds).
                    if (dwVersion == NDPHLPR_Version)
                    {
                        EEGetThreadContext = Win9XGetThreadContext;
                        EESetThreadContext = Win9XSetThreadContext;
                    }
                    else
                        _ASSERTE(!"NDPHLPR VxD is incorrect version");
                }
                else
                    _ASSERTE(!"Failed to initialize NDPHLPR VxD");
            }
            else
                _ASSERTE(!"Failed to find NDPHLPR VxD");

            // Release mutex and close the handle.
            ReleaseMutex(hMutex);
            CloseHandle(hMutex);
        }
        else
            _ASSERTE(!"Failed to create/acquire the NDPHLPR load mutex");

        if (EEGetThreadContext == NULL)
        {
            FreeOptimizedTlsGetter(gAppDomainTLSIndex , (POPTIMIZEDTLSGETTER)GetAppDomain);
            TlsFree(gThreadTLSIndex);
            FreeOptimizedTlsGetter(gThreadTLSIndex, (POPTIMIZEDTLSGETTER)GetThread);
            GetThread = DummyGetThread;
            TlsFree(gAppDomainTLSIndex);
            gThreadTLSIndex = (DWORD)(-1);
            return FALSE;
        }
    }
    else
    {
        EEGetThreadContext = NTGetThreadContext;
        EESetThreadContext = NTSetThreadContext;
    }

    return ThreadStore::InitThreadStore();
}


//---------------------------------------------------------------------------
// One-time cleanup. Called during Dll cleanup. So
// be careful what you do in here!
//---------------------------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
VOID TerminateThreadManager()
{
    ThreadStore::TerminateThreadStore();

    if (GetAppDomain)
    {
        FreeOptimizedTlsGetter( gAppDomainTLSIndex, (POPTIMIZEDTLSGETTER)GetAppDomain );
        GetAppDomain = NULL;
    }

    if (gAppDomainTLSIndex != ((DWORD)(-1)))
    {
        TlsFree(gAppDomainTLSIndex);
    }

    if (GetThread != DummyGetThread)
    {
        FreeOptimizedTlsGetter( gThreadTLSIndex, (POPTIMIZEDTLSGETTER)GetThread );
        GetThread = DummyGetThread;
    }

    if (gThreadTLSIndex != ((DWORD)(-1)))
    {
        TlsFree(gThreadTLSIndex);
        gThreadTLSIndex = -1;
    }
    
}
#endif /* SHOULD_WE_CLEANUP */


//************************************************************************
// Thread members
//************************************************************************


#if defined(_DEBUG) && defined(TRACK_SYNC)

// One outstanding synchronization held by this thread:
struct Dbg_TrackSyncEntry
{
    int          m_caller;
    AwareLock   *m_pAwareLock;

    BOOL        Equiv      (int caller, void *pAwareLock)
    {
        return (m_caller == caller) && (m_pAwareLock == pAwareLock);
    }

    BOOL        Equiv      (void *pAwareLock)
    {
        return (m_pAwareLock == pAwareLock);
    }
};

// Each thread has a stack that tracks all enter and leave requests
struct Dbg_TrackSyncStack : public Dbg_TrackSync
{
    enum
    {
        MAX_TRACK_SYNC  = 20,       // adjust stack depth as necessary
    };

    void    EnterSync  (int caller, void *pAwareLock);
    void    LeaveSync  (int caller, void *pAwareLock);

    Dbg_TrackSyncEntry  m_Stack [MAX_TRACK_SYNC];
    int                 m_StackPointer;
    BOOL                m_Active;

    Dbg_TrackSyncStack() : m_StackPointer(0),
                           m_Active(TRUE)
    {
    }
};

// A pain to do all this from ASM, but watch out for trashed registers
void EnterSyncHelper    (int caller, void *pAwareLock)
{
    GetThread()->m_pTrackSync->EnterSync(caller, pAwareLock);
}
void LeaveSyncHelper    (int caller, void *pAwareLock)
{
    GetThread()->m_pTrackSync->LeaveSync(caller, pAwareLock);
}

void Dbg_TrackSyncStack::EnterSync(int caller, void *pAwareLock)
{
    if (m_Active)
    {
        if (m_StackPointer >= MAX_TRACK_SYNC)
        {
            _ASSERTE(!"Overflowed synchronization stack checking.  Disabling");
            m_Active = FALSE;
            return;
        }
    }
    m_Stack[m_StackPointer].m_caller = caller;
    m_Stack[m_StackPointer].m_pAwareLock = (AwareLock *) pAwareLock;

    m_StackPointer++;
}

void Dbg_TrackSyncStack::LeaveSync(int caller, void *pAwareLock)
{
    if (m_Active)
    {
        if (m_StackPointer == 0)
            _ASSERTE(!"Underflow in leaving synchronization");
        else
        if (m_Stack[m_StackPointer - 1].Equiv(pAwareLock))
        {
            m_StackPointer--;
        }
        else
        {
            for (int i=m_StackPointer - 2; i>=0; i--)
            {
                if (m_Stack[i].Equiv(pAwareLock))
                {
                    _ASSERTE(!"Locks are released out of order.  This might be okay...");
                    memcpy(&m_Stack[i], &m_Stack[i+1],
                           sizeof(m_Stack[0]) * (m_StackPointer - i - 1));

                    return;
                }
            }
            _ASSERTE(!"Trying to release a synchronization lock which isn't held");
        }
    }
}

#endif  // TRACK_SYNC


//--------------------------------------------------------------------
// Thread construction
//--------------------------------------------------------------------
Thread::Thread()
{
    m_pFrame                = FRAME_TOP;
    m_pUnloadBoundaryFrame  = NULL;

    m_fPreemptiveGCDisabled = 0;
#ifdef _DEBUG
    m_ulForbidTypeLoad      = 0;
    m_ulGCForbidCount       = 0;
    m_GCOnTransitionsOK             = TRUE;
    m_ulEnablePreemptiveGCCount       = 0;
    m_ulReadyForSuspensionCount       = 0;
    m_ComPlusCatchDepth = (LPVOID) -1;
#endif

    m_dwLockCount = 0;
    
    // Initialize lock state
    m_fNativeFrameSetup = FALSE;
    m_pHead = &m_embeddedEntry;
    m_embeddedEntry.pNext = m_pHead;
    m_embeddedEntry.pPrev = m_pHead;
    m_embeddedEntry.dwLLockID = 0;
    m_embeddedEntry.dwULockID = 0;
    m_embeddedEntry.wReaderLevel = 0;

    m_UserInterrupt = 0;
    m_SafeEvent = m_SuspendEvent = INVALID_HANDLE_VALUE;
    m_EventWait = INVALID_HANDLE_VALUE;
    m_WaitEventLink.m_Next = NULL;
    m_WaitEventLink.m_LinkSB.m_pNext = NULL;
    m_ThreadHandle = INVALID_HANDLE_VALUE;
    m_ThreadHandleForClose = INVALID_HANDLE_VALUE;
    m_dwThinLockThreadId = g_pThinLockThreadIdDispenser->NewId(this);
    m_ThreadId = 0;
    m_Priority = INVALID_THREAD_PRIORITY;
    m_ExternalRefCount = 1;
    m_State = TS_Unstarted;
    m_StateNC = TSNC_Unknown;

    // It can't be a LongWeakHandle because we zero stuff out of the exposed
    // object as it is finalized.  At that point, calls to GetCurrentThread()
    // had better get a new one,!
    m_ExposedObject = CreateGlobalShortWeakHandle(NULL);
    m_StrongHndToExposedObject = CreateGlobalStrongHandle(NULL);

    m_LastThrownObjectHandle = NULL;

    m_debuggerWord1 = NULL; // Zeros out both filter CONTEXT* and the extra state flags.
    m_debuggerCantStop = 0;

#ifdef _DEBUG
    m_CacheStackBase = 0;
    m_CacheStackLimit = 0;
    m_pCleanedStackBase = NULL;
    m_ppvHJRetAddrPtr = (VOID**) 0xCCCCCCCCCCCCCCCC;
    m_pvHJRetAddr = (VOID*) 0xCCCCCCCCCCCCCCCC;
#endif

#if defined(_DEBUG) && defined(TRACK_SYNC)
    m_pTrackSync = new Dbg_TrackSyncStack;
#endif  // TRACK_SYNC

    m_PreventAsync = 0;
    m_pDomain = NULL;
    m_Context = NULL;
    m_TraceCallCount = 0;
    m_ThrewControlForThread = 0;
    m_OSContext = NULL;
    m_ThreadTasks = (ThreadTasks)0;

    Thread *pThread = GetThread();
    _ASSERTE(SystemDomain::System()->DefaultDomain()->GetDefaultContext());
    InitContext();
    _ASSERTE(m_Context);
    if (pThread) 
    {
        _ASSERTE(pThread->GetDomain() && pThread->GetDomain()->GetDefaultContext());
        // Start off the new thread in the default context of
        // the creating thread's appDomain. This could be changed by SetDelegate
        SetKickOffDomain(pThread->GetDomain());
    } else
        SetKickOffDomain(SystemDomain::System()->DefaultDomain());

    // The state and the tasks must be 32-bit aligned for atomicity to be guaranteed.
    _ASSERTE((((size_t) &m_State) & 3) == 0);
    _ASSERTE((((size_t) &m_ThreadTasks) & 3) == 0);

    m_dNumAccessOverrides = 0;
    // Track perf counter for the logical thread object.
    COUNTER_ONLY(GetPrivatePerfCounters().m_LocksAndThreads.cCurrentThreadsLogical++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_LocksAndThreads.cCurrentThreadsLogical++);

#ifdef STRESS_HEAP
        // ON all callbacks, call the trap code, which we now have
        // wired to cause a GC.  THus we will do a GC on all Transition Frame Transitions (and more).  
   if (g_pConfig->GetGCStressLevel() & EEConfig::GCSTRESS_TRANSITION)
        m_State = (ThreadState) (m_State | TS_GCOnTransitions); 
#endif

    m_pSharedStaticData = NULL;
    m_pUnsharedStaticData = NULL;
    m_pStaticDataHash = NULL;
    m_pDLSHash = NULL;
    m_pCtx = NULL;

    m_fSecurityStackwalk = FALSE;
    m_compressedStack = NULL;
    m_fPLSOptimizationState = TRUE;

    m_pFusionAssembly = NULL;
    m_pAssembly = NULL;
    m_pModuleToken = mdFileNil;

#ifdef STRESS_THREAD
    m_stressThreadCount = -1;
#endif

}


//--------------------------------------------------------------------
// Failable initialization occurs here.
//--------------------------------------------------------------------
BOOL Thread::InitThread()
{
    HANDLE  hDup = INVALID_HANDLE_VALUE;
    BOOL    ret = TRUE;
    BOOL    reverted = FALSE;
    HANDLE  threadToken = INVALID_HANDLE_VALUE;

		// This message actually serves a purpose (which is why it is always run)
		// The Stress log is run during hijacking, when other threads can be suspended  
		// at arbitrary locations (including when holding a lock that NT uses to serialize 
		// all memory allocations).  By sending a message now, we insure that the stress 
		// log will not allocate memory at these critical times an avoid deadlock. 
    STRESS_LOG2(LF_ALL, LL_ALWAYS, "SetupThread  managed Thread %p Thread Id = %x\n", this, m_ThreadId);

    if ((m_State & TS_WeOwn) == 0)
    {
        _ASSERTE(GetThreadHandle() == INVALID_HANDLE_VALUE);

        COUNTER_ONLY(GetPrivatePerfCounters().m_LocksAndThreads.cRecognizedThreads++);
        COUNTER_ONLY(GetGlobalPerfCounters().m_LocksAndThreads.cRecognizedThreads++);

        // For WinCE, all clients have the same handle for a thread.  Duplication is
        // not possible.  We make sure we never close this handle unless we created
        // the thread (TS_WeOwn).
        //
        // For Win32, each client has its own handle.  This is achieved by duplicating
        // the pseudo-handle from ::GetCurrentThread().  Unlike WinCE, this service
        // returns a pseudo-handle which is only useful for duplication.  In this case
        // each client is responsible for closing its own (duplicated) handle.
        //
        // We don't bother duplicating if WeOwn, because we created the handle in the
        // first place.
        // Thread is created when or after the physical thread started running
        HANDLE curProcess = ::GetCurrentProcess();

        // If we're impersonating on NT, then DuplicateHandle(GetCurrentThread()) is going to give us a handle with only
        // THREAD_TERMINATE, THREAD_QUERY_INFORMATION, and THREAD_SET_INFORMATION. This doesn't include
        // THREAD_SUSPEND_RESUME nor THREAD_GET_CONTEXT. We need to be able to suspend the thread, and we need to be
        // able to get its context. Therefore, if we're impersonating, we revert to self, dup the handle, then
        // re-impersonate before we leave this routine.
        if (RunningOnWinNT() && 
            OpenThreadToken(GetCurrentThread(),    // we are assuming that if this call fails, 
                            TOKEN_IMPERSONATE,     // we are not impersonating. There is no win32
                            TRUE,                  // api to figure this out. The only alternative 
                            &threadToken))         // is to use NtCurrentTeb->IsImpersonating().
        {
            reverted = RevertToSelf();
            _ASSERTE(reverted);                    // This reall should work...

            if (!reverted)
            {
                ret = FALSE;
                goto leav;
            }
        }
        
        if (::DuplicateHandle(curProcess, ::GetCurrentThread(), curProcess, &hDup,
                              0 /*ignored*/, FALSE /*inherit*/, DUPLICATE_SAME_ACCESS))
        {
            _ASSERTE(hDup != INVALID_HANDLE_VALUE);
    
            SetThreadHandle(hDup);
        }
        else
        {
            ret = FALSE;
            goto leav;
        }

        if (!AllocHandles())
        {
            ret = FALSE;
            goto leav;
        }
    }
    else
    {
        _ASSERTE(GetThreadHandle() != INVALID_HANDLE_VALUE);
        
        COUNTER_ONLY(GetPrivatePerfCounters().m_LocksAndThreads.cCurrentThreadsPhysical++);
        COUNTER_ONLY(GetGlobalPerfCounters().m_LocksAndThreads.cCurrentThreadsPhysical++);
    }

    // Set floating point mode to round to nearest
    // old = _controlfp(new,mask)
    //
    // BUGBUG: this is not found on WinCE
    //
    (void) _controlfp( _RC_NEAR, _RC_CHOP|_RC_UP|_RC_DOWN|_RC_NEAR );

    _ASSERTE(m_CacheStackBase == 0);
    _ASSERTE(m_CacheStackLimit == 0);

    m_CacheStackBase  = Thread::GetStackUpperBound();
    m_CacheStackLimit = Thread::GetStackLowerBound();

    m_pTEB = (struct _NT_TIB*)NtCurrentTeb();

leav:
    // If we reverted above, then go ahead and re-impersonate.
    if (reverted)
        SetThreadToken(NULL, threadToken);

    // If we opened the thread token above, close it.
    if (threadToken != INVALID_HANDLE_VALUE)
        CloseHandle(threadToken);
    
    if (!ret)
    {
        if (hDup != INVALID_HANDLE_VALUE)
            ::CloseHandle(hDup);
    }
    return ret;
}


// Allocate all the handles.  When we are kicking of a new thread, we can call
// here before the thread starts running.
BOOL Thread::AllocHandles()
{
    _ASSERTE(m_SafeEvent == INVALID_HANDLE_VALUE);
    _ASSERTE(m_SuspendEvent == INVALID_HANDLE_VALUE);
    _ASSERTE(m_EventWait == INVALID_HANDLE_VALUE);

    // create a manual reset event for getting the thread to a safe point
    m_SafeEvent = ::WszCreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_SafeEvent)
    {
        m_SuspendEvent = ::WszCreateEvent(NULL, TRUE, FALSE, NULL);
        if (m_SuspendEvent)
        {
            m_EventWait = ::WszCreateEvent(NULL, TRUE/*ManualReset*/,
                                           TRUE/*Signalled*/, NULL);
            if (m_EventWait)
            {
                return TRUE;
            }
            m_EventWait = INVALID_HANDLE_VALUE;

            ::CloseHandle(m_SuspendEvent);
            m_SuspendEvent = INVALID_HANDLE_VALUE;
        }
        ::CloseHandle(m_SafeEvent);
        m_SafeEvent = INVALID_HANDLE_VALUE;
    }

    // I should like to do COMPlusThrowWin32(), but the thread never got set up
    // correctly.
    return FALSE;
}

void Thread::SetInheritedSecurityStack(OBJECTREF orStack)
{
    THROWSCOMPLUSEXCEPTION();

    if (orStack == NULL)
    {
        // The only synchronization we use here is making
        // sure that only this thread alters itself.

        _ASSERTE(GetThread() == this || (this->GetSnapshotState() & TS_Unstarted));
        this->m_compressedStack->Release();
        this->m_compressedStack = NULL;
        return;
    }

    _ASSERTE( this->m_compressedStack == NULL);

    this->m_compressedStack = new CompressedStack( orStack );

    // If an appdomain unloaded has started for the current appdomain (but we
    // haven't got to the point where threads are refused admittance), we're
    // racing with cleanup code that will try and serialize compressed stacks
    // so they can be used in other appdomains if the thread survives the
    // unload. If it looks like this is the case for our thread, we could use
    // some elaborate synchronization to ensure that either the cleanup code or
    // this code serializes the data so it isn't missed in the race. But, since
    // this is a rare edge condition and since we're only just starting the new
    // thread (from the context of the appdomain being unloaded), we might as
    // well just throw an appdomain unloaded exception (if the creating thread
    // had been just a little slower, this would have been the result anyway).
    if (GetAppDomain()->IsUnloading())
    {
        this->m_compressedStack->Release();
        this->m_compressedStack = NULL;
        COMPlusThrow(kAppDomainUnloadedException);
    }
}

void Thread::SetDelayedInheritedSecurityStack(CompressedStack* pStack)
{
    THROWSCOMPLUSEXCEPTION();

    if (pStack == NULL)
    {
        // The only synchronization we use here is making
        // sure that only this thread alters itself.

        _ASSERTE(GetThread() == this || (this->GetSnapshotState() & TS_Unstarted));
        if (this->m_compressedStack != NULL)
        {
            this->m_compressedStack->Release();
            this->m_compressedStack = NULL;
        }
        return;
    }

    _ASSERTE(this->m_compressedStack == NULL);

    if (pStack != NULL)
    {
        pStack->AddRef();
        this->m_compressedStack = pStack;

        // If an appdomain unloaded has started for the current appdomain (but we
        // haven't got to the point where threads are refused admittance), we're
        // racing with cleanup code that will try and serialize compressed stacks
        // so they can be used in other appdomains if the thread survives the
        // unload. If it looks like this is the case for our thread, we could use
        // some elaborate synchronization to ensure that either the cleanup code or
        // this code serializes the data so it isn't missed in the race. But, since
        // this is a rare edge condition and since we're only just starting the new
        // thread (from the context of the appdomain being unloaded), we might as
        // well just throw an appdomain unloaded exception (if the creating thread
        // had been just a little slower, this would have been the result anyway).
        if (GetAppDomain()->IsUnloading())
        {
            this->m_compressedStack->Release();
            this->m_compressedStack = NULL;
            COMPlusThrow(kAppDomainUnloadedException);
        }
    }
}



OBJECTREF Thread::GetInheritedSecurityStack()
{
    // The only synchronization we have here is that this method is only called
    // by the thread on itself.
    _ASSERTE(GetThread() == this);

    if (this->m_compressedStack != NULL)
        return this->m_compressedStack->GetPermissionListSet();
    else
        return NULL;
}

CompressedStack* Thread::GetDelayedInheritedSecurityStack()
{
    // The only synchronization we have here is that this method is only called
    // by the thread on itself.
    _ASSERTE(GetThread() == this);

    return this->m_compressedStack;
    }


// Called when an appdomain is unloading to remove any appdomain specific
// resources from the inherited security stack.
// This routine is called with the thread store lock held, and may drop and
// re-acquire the lock as part of it's processing. The boolean returned
// indicates whether the caller may resume enumerating the thread list where
// they left off (true) or must restart the scan from the beginning (false).
bool Thread::CleanupInheritedSecurityStack(AppDomain *pDomain, DWORD domainId)
{
    if (this->m_compressedStack != NULL)
        return this->m_compressedStack->HandleAppDomainUnload( pDomain, domainId );
    else
        return true;
    }

//--------------------------------------------------------------------
// This is the alternate path to SetupThread/InitThread.  If we created
// an unstarted thread, we have SetupUnstartedThread/HasStarted.
//--------------------------------------------------------------------
BOOL Thread::HasStarted()
{
    _ASSERTE(!m_fPreemptiveGCDisabled);     // can't use PreemptiveGCDisabled() here

    // This is cheating a little.  There is a pathway here from SetupThread, but only
    // via IJW SystemDomain::RunDllMain.  Normally SetupThread returns a thread in
    // preemptive mode, ready for a transition.  But in the IJW case, it can return a
    // cooperative mode thread.  RunDllMain handles this "surprise" correctly.
    m_fPreemptiveGCDisabled = TRUE;

    // Normally, HasStarted is called from the thread's entrypoint to introduce it to
    // the runtime.  But sometimes that thread is used for DLL_THREAD_ATTACH notifications
    // that call into managed code.  In that case, the second HasStarted call is
    // redundant and should be ignored.
    if (GetThread() == this)
        return TRUE;

    _ASSERTE(GetThread() == 0);
    _ASSERTE(GetThreadHandle() != INVALID_HANDLE_VALUE);

    BOOL    res = PrepareApartmentAndContext();

    if (res)
        res = InitThread();

    // Interesting to debug.  Presumably the system has run out of resources.
    _ASSERTE(res);

    ThreadStore::TransferStartedThread(this);

#ifdef DEBUGGING_SUPPORTED
    //
    // If we're debugging, let the debugger know that this
    // thread is up and running now.
    //
    if (CORDebuggerAttached())
    {
        g_pDebugInterface->ThreadCreated(this);
    }    
    else
    {
        LOG((LF_CORDB, LL_INFO10000, "ThreadCreated() not called due to CORDebuggerAttached() being FALSE for thread 0x%x\n", GetThreadId()));
    }
    
#endif // DEBUGGING_SUPPORTED

#ifdef PROFILING_SUPPORTED
    // If a profiler is running, let them know about the new thread.
    if (CORProfilerTrackThreads())
    {
            g_profControlBlock.pProfInterface->ThreadCreated((ThreadID) this);

            DWORD osThreadId = ::GetCurrentThreadId();

            g_profControlBlock.pProfInterface->ThreadAssignedToOSThread(
                (ThreadID) this, osThreadId);
    }
#endif // PROFILING_SUPPORTED

    if (res)
    {
        // we've been told to stop, before we get properly started
        if (m_State & TS_StopRequested)
            res = FALSE;
        else
        {
            // Is there a pending user suspension?
            if (m_State & TS_SuspendUnstarted)
            {
                BOOL    doSuspend = FALSE;

                ThreadStore::LockThreadStore();

                // Perhaps we got resumed before it took effect?
                if (m_State & TS_SuspendUnstarted)
                {
                    FastInterlockAnd((ULONG *) &m_State, ~TS_SuspendUnstarted);
                    ClearSuspendEvent();
                    MarkForSuspension(TS_UserSuspendPending);
                    doSuspend = TRUE;
                }

                ThreadStore::UnlockThreadStore();
                if (doSuspend)
                {
                    EnablePreemptiveGC();
                    WaitSuspendEvent();
                    DisablePreemptiveGC();
                }
            }
        }
    }
    
    return res;
}


// We don't want ::CreateThread() calls scattered throughout the source.  So gather
// them all here.
HANDLE Thread::CreateNewThread(DWORD stackSize, ThreadStartFunction start,
                               void *args, DWORD *pThreadId)
{
    DWORD   ourId;
    HANDLE  h = ::CreateThread(NULL     /*=SECURITY_ATTRIBUTES*/,
                               stackSize,
                               start,
                               args,
                               CREATE_SUSPENDED,
                               (pThreadId ? pThreadId : &ourId));
    if (h == NULL)
        goto fail;

    _ASSERTE(!m_fPreemptiveGCDisabled);     // leave in preemptive until HasStarted.

    // Make sure we have all our handles, in case someone tries to suspend us
    // as we are starting up.
    if (!AllocHandles())
    {
        ::CloseHandle(h);
fail:   // OS is out of handles?
        return INVALID_HANDLE_VALUE;
    }

    SetThreadHandle(h);

    FastInterlockIncrement(&g_pThreadStore->m_PendingThreadCount);

    return h;
}


// General comments on thread destruction.
//
// The C++ Thread object can survive beyond the time when the Win32 thread has died.
// This is important if an exposed object has been created for this thread.  The
// exposed object will survive until it is GC'ed.
//
// A client like an exposed object can place an external reference count on that
// object.  We also place a reference count on it when we construct it, and we lose
// that count when the thread finishes doing useful work (OnThreadTerminate).
//
// One way OnThreadTerminate() is called is when the thread finishes doing useful
// work.  This case always happens on the correct thread.
//
// The other way OnThreadTerminate()  is called is during product shutdown.  We do
// a "best effort" to eliminate all threads except the Main thread before shutdown
// happens.  But there may be some background threads or external threads still
// running.
//
// When the final reference count disappears, we destruct.  Until then, the thread
// remains in the ThreadStore, but is marked as "Dead".

// @TODO cwb: for a typical shutdown, only background threads are still around.
// Should we interrupt them?  What about the non-typical shutdown?

int Thread::IncExternalCount()
{
    // !!! The caller of IncExternalCount should not hold the ThreadStoreLock.
    Thread *pCurThread = GetThread();
    _ASSERTE (pCurThread == NULL || g_fProcessDetach
              || !ThreadStore::HoldingThreadStore(pCurThread));

    // Must synchronize count and exposed object handle manipulation. We use the
    // thread lock for this, which implies that we must be in pre-emptive mode
    // to begin with and avoid any activity that would invoke a GC (this
    // acquires the thread store lock).
    BOOL ToggleGC = pCurThread->PreemptiveGCDisabled();
    if (ToggleGC)
        pCurThread->EnablePreemptiveGC();

    int RetVal;
    ThreadStore::LockThreadStore();

    _ASSERTE(m_ExternalRefCount > 0);
    m_ExternalRefCount++;
    RetVal = m_ExternalRefCount;

    // If we have an exposed object and the refcount is greater than one
    // we must make sure to keep a strong handle to the exposed object
    // so that we keep it alive even if nobody has a reference to it.
    if (((*((void**)m_ExposedObject)) != NULL) && (m_ExternalRefCount > 1))
    {
        // The exposed object exists and needs a strong handle so check
        // to see if it has one.
        if ((*((void**)m_StrongHndToExposedObject)) == NULL)
        {
            // Switch to cooperative mode before using OBJECTREF's.
            pCurThread->DisablePreemptiveGC();

            // Store the object in the strong handle.
            StoreObjectInHandle(m_StrongHndToExposedObject, ObjectFromHandle(m_ExposedObject));

            ThreadStore::UnlockThreadStore();

            // Switch back to the initial GC mode.
            if (!ToggleGC)
                pCurThread->EnablePreemptiveGC();

            return RetVal;
        }

    }

    ThreadStore::UnlockThreadStore();

    // Switch back to the initial GC mode.
    if (ToggleGC)
        pCurThread->DisablePreemptiveGC();

    return RetVal;
}

void Thread::DecExternalCount(BOOL holdingLock)
{
    // Note that it's possible to get here with a NULL current thread (during
    // shutdown of the thread manager).
    Thread *pCurThread = GetThread();
    _ASSERTE (pCurThread == NULL || g_fProcessDetach || g_fFinalizerRunOnShutDown
              || (!holdingLock && !ThreadStore::HoldingThreadStore(pCurThread))
              || (holdingLock && ThreadStore::HoldingThreadStore(pCurThread)));
    
    BOOL ToggleGC = FALSE;
    BOOL SelfDelete = FALSE;

    // Must synchronize count and exposed object handle manipulation. We use the
    // thread lock for this, which implies that we must be in pre-emptive mode
    // to begin with and avoid any activity that would invoke a GC (this
    // acquires the thread store lock).
    if (pCurThread)
    {
        ToggleGC = pCurThread->PreemptiveGCDisabled();
        if (ToggleGC)
            pCurThread->EnablePreemptiveGC();
    }
    if (!holdingLock)
    {
        LOG((LF_SYNC, INFO3, "DecExternal obtain lock\n"));
        ThreadStore::LockThreadStore();
    }
    
    _ASSERTE(m_ExternalRefCount >= 1);
    _ASSERTE(!holdingLock ||
             g_pThreadStore->m_Crst.GetEnterCount() > 0 ||
             g_fProcessDetach);

    m_ExternalRefCount--;

    if (m_ExternalRefCount == 0)
    {
        HANDLE h = m_ThreadHandle;
        if (h == INVALID_HANDLE_VALUE)
        {
            h = m_ThreadHandleForClose;
            m_ThreadHandleForClose = INVALID_HANDLE_VALUE;
        }
        // Can not assert like this.  We have already removed the Unstarted bit.
        //_ASSERTE (IsUnstarted() || h != INVALID_HANDLE_VALUE);
        if (h != INVALID_HANDLE_VALUE)
        {
            ::CloseHandle(h);
        }

        // Switch back to cooperative mode to manipulate the thread.
        if (pCurThread)
            pCurThread->DisablePreemptiveGC();

        // during process detach the thread might still be in the thread list
        // if it hasn't seen its DLL_THREAD_DETACH yet.  Use the following
        // tweak to decide if the thread has terminated yet.
        if (GetThreadHandle() == INVALID_HANDLE_VALUE)
        {
            SelfDelete = this == pCurThread;
           m_handlerInfo.FreeStackTrace();
             if (SelfDelete) {
                TlsSetValue(gThreadTLSIndex, (VOID*)NULL);
            }
            delete this;
        }

        if (!holdingLock)
            ThreadStore::UnlockThreadStore();

        // It only makes sense to restore the GC mode if we didn't just destroy
        // our own thread object.
        if (pCurThread && !SelfDelete && !ToggleGC)
            pCurThread->EnablePreemptiveGC();

        return;
    }
    else if (pCurThread == NULL)
    {
        // We're in shutdown, too late to be worrying about having a strong
        // handle to the exposed thread object, we've already performed our
        // final GC.
        return;
    }
    else
    {
        // Check to see if the external ref count reaches exactly one. If this
        // is the case and we have an exposed object then it is that exposed object
        // that is holding a reference to us. To make sure that we are not the
        // ones keeping the exposed object alive we need to remove the strong 
        // reference we have to it.
        if ((m_ExternalRefCount == 1) && ((*((void**)m_StrongHndToExposedObject)) != NULL))
        {
            // Switch back to cooperative mode to manipulate the object.

            // Clear the handle and leave the lock.
            // We do not have to to DisablePreemptiveGC here, because
            // we just want to put NULL into a handle.
            StoreObjectInHandle(m_StrongHndToExposedObject, NULL);          

            if (!holdingLock)
                ThreadStore::UnlockThreadStore();

            // Switch back to the initial GC mode.
            if (ToggleGC)
                pCurThread->DisablePreemptiveGC();

            return;
        }
    }

    if (!holdingLock)
        ThreadStore::UnlockThreadStore();

    // Switch back to the initial GC mode.
    if (ToggleGC)
        pCurThread->DisablePreemptiveGC();
}


//--------------------------------------------------------------------
// Destruction. This occurs after the associated native thread
// has died.
//--------------------------------------------------------------------
Thread::~Thread()
{
    _ASSERTE(m_ThrewControlForThread == 0);

#if defined(_DEBUG) && defined(TRACK_SYNC)
    _ASSERTE(IsAtProcessExit() || ((Dbg_TrackSyncStack *) m_pTrackSync)->m_StackPointer == 0);
    delete m_pTrackSync;
#endif // TRACK_SYNC

    _ASSERTE(IsDead() || IsAtProcessExit());

    if (m_WaitEventLink.m_Next != NULL && !IsAtProcessExit())
    {
        WaitEventLink *walk = &m_WaitEventLink;
        while (walk->m_Next) {
            ThreadQueue::RemoveThread(this, (SyncBlock*)((DWORD_PTR)walk->m_Next->m_WaitSB & ~1));
            StoreEventToEventStore (walk->m_Next->m_EventWait);
        }
        m_WaitEventLink.m_Next = NULL;
    }

#ifdef _DEBUG
    BOOL    ret = 
#endif
    ThreadStore::RemoveThread(this);
    _ASSERTE(ret);
    
#ifdef _DEBUG
    m_pFrame = (Frame *)POISONC;
#endif

    // Update Perfmon counters.
    COUNTER_ONLY(GetPrivatePerfCounters().m_LocksAndThreads.cCurrentThreadsLogical--);
    COUNTER_ONLY(GetGlobalPerfCounters().m_LocksAndThreads.cCurrentThreadsLogical--);
    
    // Current recognized threads are non-runtime threads that are alive and ran under the 
    // runtime. Check whether this Thread was one of them.
    if ((m_State & TS_WeOwn) == 0)
    {
        COUNTER_ONLY(GetPrivatePerfCounters().m_LocksAndThreads.cRecognizedThreads--);
        COUNTER_ONLY(GetGlobalPerfCounters().m_LocksAndThreads.cRecognizedThreads--);
    } 
    else
    {
        COUNTER_ONLY(GetPrivatePerfCounters().m_LocksAndThreads.cCurrentThreadsPhysical--);
        COUNTER_ONLY(GetGlobalPerfCounters().m_LocksAndThreads.cCurrentThreadsPhysical--);
    } 


    
    _ASSERTE(GetThreadHandle() == INVALID_HANDLE_VALUE);

    if (m_SafeEvent != INVALID_HANDLE_VALUE)
    {
        ::CloseHandle(m_SafeEvent);
        m_SafeEvent = INVALID_HANDLE_VALUE;
    }
    if (m_SuspendEvent != INVALID_HANDLE_VALUE)
    {
        ::CloseHandle(m_SuspendEvent);
        m_SuspendEvent = INVALID_HANDLE_VALUE;
    }
    if (m_EventWait != INVALID_HANDLE_VALUE)
    {
        ::CloseHandle(m_EventWait);
        m_EventWait = INVALID_HANDLE_VALUE;
    }
    if (m_OSContext != NULL)
        delete m_OSContext;

    if (GetSavedRedirectContext())
    {
        delete GetSavedRedirectContext();
        SetSavedRedirectContext(NULL);
    }

#if 0
    VirtualFree(m_handlerInfo.m_pAuxStack, 0, MEM_RELEASE);
#endif

    if (!g_fProcessDetach)
    {
        if (m_LastThrownObjectHandle != NULL)
            DestroyHandle(m_LastThrownObjectHandle);
        if (m_handlerInfo.m_pThrowable != NULL) 
            DestroyHandle(m_handlerInfo.m_pThrowable);
        DestroyShortWeakHandle(m_ExposedObject);
        DestroyStrongHandle(m_StrongHndToExposedObject);
    }

    if (m_compressedStack != NULL)
        m_compressedStack->Release();

    g_pThinLockThreadIdDispenser->DisposeId(m_dwThinLockThreadId);

    ClearContext();

    DeleteThreadStaticData();
    if (g_fProcessDetach)
        RemoveAllDomainLocalStores();

    if(SystemDomain::BeforeFusionShutdown()) {
        SetFusionAssembly(NULL);
    }
}


void Thread::CoUninitalize()
{
          // Running threads might have performed a CoInitialize which must
    // now be balanced.
    if (!g_fProcessDetach && IsCoInitialized())
    {
        if(!RunningOnWin95())
        {
            BOOL fGCDisabled = PreemptiveGCDisabled();
            if (fGCDisabled)
                EnablePreemptiveGC();
            ::CoUninitialize();
            if (fGCDisabled)
                DisablePreemptiveGC();
        }
        FastInterlockAnd((ULONG *)&m_State, ~Thread::TS_CoInitialized);
    }
}

void Thread::CleanupDetachedThreads(GCHeap::SUSPEND_REASON reason)
{
    _ASSERTE(ThreadStore::HoldingThreadStore());

    Thread *thread = ThreadStore::GetThreadList(NULL);

    while (m_DetachCount > 0 && thread != NULL)
    {
        Thread *next = ThreadStore::GetThreadList(thread);

        if (thread->IsDetached())
        {
            // Unmark that the thread is detached while we have the
            // thread store lock. This will ensure that no other
            // thread will race in here and try to delete it, too.
            FastInterlockAnd((ULONG*)&(thread->m_State), ~TS_Detached);
            FastInterlockDecrement(&m_DetachCount);
            if (!thread->IsBackground())
                FastInterlockDecrement(&m_ActiveDetachCount);
            
            // If the debugger is attached, then we need to unlock the
            // thread store before calling OnThreadTerminate. That
            // way, we won't be holding the thread store lock if we
            // need to block sending a detach thread event.
            BOOL debuggerAttached = 
#ifdef DEBUGGING_SUPPORTED
                CORDebuggerAttached();
#else // !DEBUGGING_SUPPORTED
                FALSE;
#endif // !DEBUGGING_SUPPORTED
            
            if (debuggerAttached)
                ThreadStore::UnlockThreadStore();
            
            thread->OnThreadTerminate(debuggerAttached ? FALSE : TRUE,
                                      FALSE);

#ifdef DEBUGGING_SUPPORTED
            // When we re-lock, we make sure to pass FALSE as the
            // second parameter to ensure that CleanupDetachedThreads
            // wont get called again. Because we've unlocked the
            // thread store, this may block due to a collection, but
            // that's okay.
            if (debuggerAttached)
            {
                ThreadStore::LockThreadStore(reason, FALSE);

                // We remember the next Thread in the thread store
                // list before deleting the current one. But we can't
                // use that Thread pointer now that we release the
                // thread store lock in the middle of the loop. We
                // have to start from the beginning of the list every
                // time. If two threads T1 and T2 race into
                // CleanupDetachedThreads, then T1 will grab the first
                // Thread on the list marked for deletion and release
                // the lock. T2 will grab the second one on the
                // list. T2 may complete destruction of its Thread,
                // then T1 might re-acquire the thread store lock and
                // try to use the next Thread in the thread store. But
                // T2 just deleted that next Thread.
                thread = ThreadStore::GetThreadList(NULL);
            }
            else
#endif // DEBUGGING_SUPPORTED
            {
                thread = next;
        }
        }
        else
            thread = next;
    }
}

// See general comments on thread destruction above.
void Thread::OnThreadTerminate(BOOL holdingLock,
                               BOOL threadCleanupAllowed)
{
    DWORD CurrentThreadID = ::GetCurrentThreadId();
    DWORD ThisThreadID = GetThreadId();
    
    // If the currently running thread is the thread that died and it is an STA thread, then we
    // need to release all the RCW's in the current context. However, we cannot do this if we 
    // are in the middle of process detach.
    if (!g_fProcessDetach && this == GetThread() && GetFinalApartment() == Thread::AS_InSTA)
    {
        ComPlusWrapperCache::ReleaseComPlusWrappers(GetCurrentCtxCookie());
        
        // Running threads might have performed a CoInitialize which must
        // now be balanced. However only the thread that called COInitialize can
        // call CoUninitialize.
        if (IsCoInitialized())
        {
            ::CoUninitialize();
            ResetCoInitialized();
        }            
    }                    

    // We took a count during construction, and we rely on the count being
    // non-zero as we terminate the thread here.
    _ASSERTE(m_ExternalRefCount > 0);
    
    if  (g_pGCHeap)
    {
        // Guaranteed to NOT be a shutdown case, because we tear down the heap before
        // we tear down any threads during shutdown.
        if (ThisThreadID == CurrentThreadID)
        {
            BOOL toggleGC = !PreemptiveGCDisabled();

            COMPLUS_TRY
            {
                if (toggleGC)
                    DisablePreemptiveGC();
            }
            COMPLUS_CATCH
            {
                // continue with the shutdown.  The 'try' scope must terminate before the
                // DecExternalCount() below, because the current thread might destruct
                // inside it.    We cannot tear down the SEH after the thread destructs, since
                // we use TLS and the Thread object itself during the tear down.
            }
            COMPLUS_END_CATCH
            g_pGCHeap->FixAllocContext(&m_alloc_context, FALSE, NULL);

            // there is a race here, if a thread is dead but it is still in thread store list
            // concurrent gc thread may call repair_allocation on its allocation context
            // This will cause problem when this thread is removed from the thread store list later
            // and GC thread try to verify heap again.
            m_alloc_context.init();
	     
            if (toggleGC)
                EnablePreemptiveGC();
        }
    }

    // cleanup the security handle now because if we wait for the destructor (triggered by the finalization 
    // of the managed thread object), the appdomain might already have been unloaded by then.
    if (m_compressedStack != NULL)
    {
        m_compressedStack->Release();
        m_compressedStack = NULL;
    }

    // We switch a thread to dead when it has finished doing useful work.  But it
    // remains in the thread store so long as someone keeps it alive.  An exposed
    // object will do this (it releases the refcount in its finalizer).  If the
    // thread is never released, we have another look during product shutdown and
    // account for the unreleased refcount of the uncollected exposed object:
    if (IsDead())
    {
        _ASSERTE(IsAtProcessExit());
        ClearContext();
        if (m_ExposedObject != NULL)
            DecExternalCount(holdingLock);             // may destruct now
    }
    else
    {
#ifdef PROFILING_SUPPORTED
        // If a profiler is present, then notify the profiler of thread destroy
        if (CORProfilerTrackThreads())
            g_profControlBlock.pProfInterface->ThreadDestroyed((ThreadID) this);

        if (CORProfilerInprocEnabled())
            g_pDebugInterface->InprocOnThreadDestroy(this);
#endif // PROFILING_SUPPORTED

#ifdef DEBUGGING_SUPPORTED
        //
        // If we're debugging, let the debugger know that this thread is
        // gone.
        //
        if (CORDebuggerAttached())
        {    
            g_pDebugInterface->DetachThread(this, holdingLock);
        }
#endif // DEBUGGING_SUPPORTED

        if (!holdingLock)
        {
            LOG((LF_SYNC, INFO3, "OnThreadTerminate obtain lock\n"));
            ThreadStore::LockThreadStore(GCHeap::SUSPEND_OTHER,
                                         threadCleanupAllowed);
        }

        if  (g_pGCHeap && ThisThreadID != CurrentThreadID)
        {
            // We must be holding the ThreadStore lock in order to clean up alloc context.
            // We should never call FixAllocContext during GC.
            g_pGCHeap->FixAllocContext(&m_alloc_context, FALSE, NULL);

            m_alloc_context.init();
        }    
        
        FastInterlockOr((ULONG *) &m_State, TS_Dead);
        g_pThreadStore->m_DeadThreadCount++;

        if (IsUnstarted())
            g_pThreadStore->m_UnstartedThreadCount--;
        else
        {
            if (IsBackground())
                g_pThreadStore->m_BackgroundThreadCount--;
        }

        FastInterlockAnd((ULONG *) &m_State, ~(TS_Unstarted | TS_Background));

        //
        // If this thread was told to trip for debugging between the
        // sending of the detach event above and the locking of the
        // thread store lock, then remove the flag and decrement the
        // global trap returning threads count.
        //
        if (!IsAtProcessExit())
        {
            // A thread can't die during a GCPending, because the thread store's
            // lock is held by the GC thread.
            if (m_State & TS_DebugSuspendPending)
                UnmarkForSuspension(~TS_DebugSuspendPending);

            if (m_State & TS_UserSuspendPending)
                UnmarkForSuspension(~TS_UserSuspendPending);
        }
        
        if (m_ThreadHandle != INVALID_HANDLE_VALUE)
        {
            _ASSERTE (m_ThreadHandleForClose == INVALID_HANDLE_VALUE);
            m_ThreadHandleForClose = m_ThreadHandle;
            m_ThreadHandle = INVALID_HANDLE_VALUE;
        }

        m_ThreadId = NULL;

        // Perhaps threads are waiting to suspend us.  This is as good as it gets.
        SetSafeEvent();

        // If nobody else is holding onto the thread, we may destruct it here:
        ULONG   oldCount = m_ExternalRefCount;

        DecExternalCount(TRUE);
        oldCount--;
        // If we are shutting down the process, we only have one thread active in the
        // system.  So we can disregard all the reasons that hold this thread alive --
        // TLS is about to be reclaimed anyway.
        if (IsAtProcessExit())
            while (oldCount > 0)
            {
                DecExternalCount(TRUE);
                oldCount--;
            }

        // ASSUME THAT THE THREAD IS DELETED, FROM HERE ON

        _ASSERTE(g_pThreadStore->m_ThreadCount >= 0);
        _ASSERTE(g_pThreadStore->m_BackgroundThreadCount >= 0);
        _ASSERTE(g_pThreadStore->m_ThreadCount >= g_pThreadStore->m_BackgroundThreadCount);
        _ASSERTE(g_pThreadStore->m_ThreadCount >= g_pThreadStore->m_UnstartedThreadCount);
        _ASSERTE(g_pThreadStore->m_ThreadCount >= g_pThreadStore->m_DeadThreadCount);

        // One of the components of OtherThreadsComplete() has changed, so check whether
        // we should now exit the EE.
        ThreadStore::CheckForEEShutdown();

        if (!holdingLock)
        {
            _ASSERTE(g_pThreadStore->m_HoldingThread == this || !threadCleanupAllowed || g_fProcessDetach);
            LOG((LF_SYNC, INFO3, "OnThreadTerminate releasing lock\n"));
            ThreadStore::UnlockThreadStore();
            _ASSERTE(g_pThreadStore->m_HoldingThread != this || g_fProcessDetach);
        }

        if (ThisThreadID == CurrentThreadID)
        {
            // NULL out the thread block  in the tls.  We can't do this if we aren't on the
            // right thread.  But this will only happen during a shutdown.  And we've made
            // a "best effort" to reduce to a single thread before we begin the shutdown.
            TlsSetValue(gThreadTLSIndex, (VOID*)NULL);
            TlsSetValue(gAppDomainTLSIndex, (VOID*)NULL);
        }
    }
}

// Helper functions to check for duplicate handles. we only do this check if
// a waitfor multiple fails.
int __cdecl compareHandles( const void *arg1, const void *arg2 )
{
    HANDLE h1 = *(HANDLE*)arg1;
    HANDLE h2 = *(HANDLE*)arg2;
    return  (h1 == h2) ? 0 : ((h1 < h2) ? -1 : 1);
}

BOOL CheckForDuplicateHandles(int countHandles, HANDLE *handles)
{
    qsort(handles,countHandles,sizeof(HANDLE),compareHandles);
    for (int i=0; i < countHandles-1; i++)
    {
        if (handles[i] == handles[i+1])
            return TRUE;
    }
    return FALSE;
}
//--------------------------------------------------------------------
// Based on whether this thread has a message pump, do the appropriate
// style of Wait.
//--------------------------------------------------------------------
DWORD Thread::DoAppropriateWait(int countHandles, HANDLE *handles, BOOL waitAll,
                                DWORD millis, BOOL alertable, PendingSync *syncState)
{
    _ASSERTE(alertable || syncState == 0);
    THROWSCOMPLUSEXCEPTION(); // ThreadInterruptedException
    
    DWORD dwRet = -1;

    EE_TRY_FOR_FINALLY {
        dwRet =DoAppropriateWaitWorker(countHandles, handles, waitAll, millis, alertable);
    }
    EE_FINALLY {
        if (syncState) {
            if (!__GotException &&
                dwRet >= WAIT_OBJECT_0 && dwRet < WAIT_OBJECT_0 + countHandles) {
                // This thread has been removed from syncblk waiting list by the signalling thread
                syncState->Restore(FALSE);
            }
            else
                syncState->Restore(TRUE);
        }
    
        if (!__GotException && dwRet == WAIT_IO_COMPLETION)
        {
            if (!PreemptiveGCDisabled())
                DisablePreemptiveGC();
            // if an interrupt and abort happen at the same time, give priority to abort
            if (IsAbortRequested() && 
                    !IsAbortInitiated() &&
                    (GetThrowable() == NULL))
            {
                    SetAbortInitiated();
                    COMPlusThrow(kThreadAbortException);
            }

            COMPlusThrow(kThreadInterruptedException);
        }
    }
    EE_END_FINALLY;
    
    return(dwRet);
}

// On Win2K, we can use the OLE32 service that correctly combines waiting & pumping
DWORD NT5WaitRoutine(BOOL bWaitAll, DWORD millis, int numWaiters, HANDLE *phEvent, BOOL bAlertable)
{
    DWORD dwReturn;

    _ASSERTE(RunningOnWinNT5());

    // type pointer to CoGetObjectContext function in ole32
    typedef HRESULT ( __stdcall *TCoWaitForMultipleHandles) (DWORD dwFlags,
                                                             DWORD dwTimeout,
                                                             ULONG cHandles,
                                                             LPHANDLE pHandles,
                                                             LPDWORD  lpdwindex);

    //call CoGetObjectContext so that we don't run into null contexts
    static TCoWaitForMultipleHandles g_pCoWaitForMultipleHandles = NULL;
    if (g_pCoWaitForMultipleHandles == NULL)
    {
        //  We will load the Ole32.DLL and look for CoGetObjectContext fn.
        HINSTANCE   hiole32;         // the handle to ole32.dll

        hiole32 = WszGetModuleHandle(L"OLE32.DLL");
        if (hiole32)
        {
            // we got the handle now let's get the address
            g_pCoWaitForMultipleHandles = (TCoWaitForMultipleHandles) GetProcAddress(hiole32, "CoWaitForMultipleHandles");
            _ASSERTE(g_pCoWaitForMultipleHandles != NULL);
        }
        else
        {
            _ASSERTE(!"OLE32.dll not loaded ");
        }
    }

    _ASSERTE(g_pCoWaitForMultipleHandles != NULL);  
    DWORD flags = 0;
    
    if (bWaitAll)
        flags |= 1; // COWAIT_WAITALL

    if (bAlertable)
        flags |= 2; // COWAIT_ALERTABLE

    HRESULT hr = (*g_pCoWaitForMultipleHandles)(flags, millis, numWaiters, phEvent, &dwReturn);

    if (hr == RPC_S_CALLPENDING)
        dwReturn = WAIT_TIMEOUT;
    else
    if (FAILED(hr))
    {
        // The silly service behaves differently on an STA vs. MTA in how much
        // error information it propagates back, and in which form.  We currently
        // only get here in the STA case, so bias this logic that way.
        dwReturn = WAIT_FAILED;
    }
    else
        dwReturn += WAIT_OBJECT_0;  // success -- bias back

    return dwReturn;
}


// How many RPC secret windows can a particular apartment have?
#define MAX_WINDOWS_TO_PUMP     6

// @TODO: CTS, we need to find out from IE on what really needs to be done.
typedef struct __OldOlePumping
{
    BOOL fIEGuiThread;
    HWND *pWindowsToPump;
} OldOlePumping;

// Gather the list of secret windows for pumping
BOOL CALLBACK EnumThreadWindowsProc(HWND hwnd, LPARAM lparamWindowsToPump)
{
    static LPWSTR IEKnownWindows[] =
    {
        L"Internet Explorer_",
        L"IEFrame",
    };

    static LPWSTR RpcClassPrefixes[] =
    {
        L"WIN95 RPC Wmsg ",
        L"OleMainThreadWndClass",
        L"OleObjectRpcWindow",
    };

    HWND *pWindowsToPump = ((OldOlePumping*) lparamWindowsToPump)->pWindowsToPump;
    WCHAR ClassName[100];

    if (0 != WszGetClassName(hwnd, ClassName, sizeof(ClassName)/sizeof(ClassName[0])))
    {
        DWORD i;
#if 0
        for (i = 0; i < sizeof(IEKnownWindows)/sizeof(*IEKnownWindows); i++) {
            LPWSTR szWindow = IEKnownWindows[i];
            LPWSTR szCandidate = ClassName;
            while (*szWindow != '\0') {
                if(*szCandidate == '\0' ||
                   *szCandidate != *szWindow) {
                    break;
                }
                szWindow++;
                szCandidate++;
            }
            if(*szWindow == '\0') {
                ((OldOlePumping*) lparamWindowsToPump)->fIEGuiThread = TRUE;
                return FALSE;
            }
        }
#endif                    

        for (i = 0; i < sizeof(RpcClassPrefixes)/sizeof(*RpcClassPrefixes); i++)
        {
            LPWSTR szRpcPrefix = RpcClassPrefixes[i];
            LPWSTR szCandidate = ClassName;

            while (*szRpcPrefix != '\0')
            {
                if (*szCandidate == '\0' ||
                    *szCandidate != *szRpcPrefix)
                {
                    break;
                }
                ++szRpcPrefix;
                ++szCandidate;
            }
            // If we didn't break prematurely, the prefix matched.
            if ('\0' == *szRpcPrefix)
            {
                LOG((LF_SYNC, INFO3, "Found RPC window \"%S\"\n", ClassName));
                DWORD k;
                for (k = 0; k < MAX_WINDOWS_TO_PUMP && pWindowsToPump[k] != NULL; k++)
                {
                    if(pWindowsToPump[k] == hwnd)
                        break;
                }

                _ASSERTE(k < MAX_WINDOWS_TO_PUMP && "Increase MAX_WINDOWS_TO_PUMP?");
                if (pWindowsToPump[k] == NULL && k < MAX_WINDOWS_TO_PUMP)
                {
                    pWindowsToPump[k] = hwnd;
                    break;
                }
            }
        }
    }

    // We don't need to do this, the secret window is at top level
    // ::EnumChildWindows(hwnd, EnumThreadWindowsProc, lparamWindowsToPump);
    if(((OldOlePumping*) lparamWindowsToPump)->fIEGuiThread)
        return FALSE;
    else
        return TRUE;
}

// If we aren't on Win2K, we have to use our knowledge of the windows associated with
// this thread, so we can manually pump RPC for OLE32, without accidentally pumping some
// Windows messages on GUI windows.
DWORD NonNT5WaitRoutine(BOOL bWaitAll, DWORD millis, int numWaiters, HANDLE *phEvent, BOOL bAlertable)
{
    _ASSERTE(!RunningOnWinNT5());

    MSG QuitMsg = {0};            
    BOOL fSawQuit = FALSE;
    int  i;
    DWORD dwReturn;

    // Gather the list of secret windows for pumping
    HWND WindowsToPump[MAX_WINDOWS_TO_PUMP];
    OldOlePumping info;
    info.fIEGuiThread = FALSE;
    info.pWindowsToPump = WindowsToPump;

    for (i=0; i<MAX_WINDOWS_TO_PUMP; i++)
        WindowsToPump[i] = 0;

    ::EnumThreadWindows(::GetCurrentThreadId(), EnumThreadWindowsProc, (LPARAM)&info);

    while (true)
    {
        MSG msg;

            if (RunningOnWin95())
            {
                // MsgWaitForMultipleObjectsEx is unavailable.  No alertable waits.
                dwReturn = MsgWaitForMultipleObjects(numWaiters,
                                                     phEvent,
                                                     bWaitAll,
                                                     millis,
                                                     QS_ALLPOSTMESSAGE
                                                    ); 
            }
            else
            {
                // type pointer to MsgWaitForMultipleObjectsEx function in USER32
                typedef DWORD (__stdcall *TMsgWaitForMultipleObjectsEx) (DWORD nCount,
                                                                         LPHANDLE pHandles,
                                                                         DWORD dwTimeout,
                                                                         DWORD dwWakeMask,
                                                                         DWORD dwFlags);

                static TMsgWaitForMultipleObjectsEx g_pMsgWaitForMultipleObjectsEx = NULL;
                if (g_pMsgWaitForMultipleObjectsEx == NULL)
                {
                    //  We will load USER32.DLL and look for the fn.
                    HINSTANCE   hiuser32;         // The handle to user32.dll

                    hiuser32 = WszGetModuleHandle(L"USER32.DLL");
                    if (hiuser32)
                    {
                        // we got the handle now let's get the address
                        g_pMsgWaitForMultipleObjectsEx = (TMsgWaitForMultipleObjectsEx)
                                                         ::GetProcAddress(hiuser32, "MsgWaitForMultipleObjectsEx");

                        _ASSERTE(g_pMsgWaitForMultipleObjectsEx != NULL);
                    }
                    else
                    {
                        _ASSERTE(!"USER32.dll not loaded ");
                    }
                }

                _ASSERTE(g_pMsgWaitForMultipleObjectsEx != NULL);

                DWORD dwFlags = 0;

                // Normally a wait any, use wait on all handles plus a message if requested.
                if (bWaitAll)
                    dwFlags |= MWMO_WAITALL;

                // Optionally support APC for Thread.Interrupt.
                if (bAlertable)
                    dwFlags |= MWMO_ALERTABLE;

                dwReturn = (*g_pMsgWaitForMultipleObjectsEx) (numWaiters,
                                                              phEvent,
                                                              millis,
                                                              QS_ALLPOSTMESSAGE,
                                                              dwFlags
                                                             );
        }

        // if we got a message, dispatch it
        if (dwReturn == (DWORD)(WAIT_OBJECT_0 + numWaiters))
        {
            BOOL fMessageFound;

                if (info.fIEGuiThread)
                {                               
                    while (WszPeekMessage(&msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD))
                    {
                        LOG((LF_SYNC, INFO3, "Processing IE message 0x%x\n", msg));
                    
                        if (msg.message == WM_QUIT)
                        {
                            fSawQuit = TRUE;
                            QuitMsg = msg;
                        }
                        else
                        {
                            TranslateMessage(&msg);
                            WszDispatchMessage(&msg);
                        }
                    }
                }
                else {
                
                    do
                    {
                        fMessageFound = FALSE;
                        
                        for (i=0;
                             i<MAX_WINDOWS_TO_PUMP && WindowsToPump[i] != 0;
                             i++)
                        {
                            if (WszPeekMessage(&msg, WindowsToPump[i], 0, 0, PM_REMOVE | PM_NOYIELD))
                            {
                                fMessageFound = TRUE;
                                
                                //printf("Window message %d\n",msg.message);
                                
                                if (msg.message == WM_QUIT)
                                {
                                    fSawQuit = TRUE;
                                    QuitMsg = msg;
                                }
                                else
                                {
                                    TranslateMessage(&msg);
                                    WszDispatchMessage(&msg);
                                }
                            }
                        }
                    } while (fMessageFound);
                        
                }

            // MsgWaitForMultipleObjects/MsgWaitForMultipleObjectsEX always return if there is a message in 
            // the message queue.  Let us check if handles are signalled now.
            dwReturn = WaitForMultipleObjects (numWaiters,
                                               phEvent,
                                               bWaitAll,
                                               0);
            if (dwReturn != WAIT_TIMEOUT) {
                break;
            }

            // We woke up for message pumping.  Re-enter the wait.
            continue;
        }

        // We woke up for something other than a message, so terminate the wait.
        break;
    }

    if (fSawQuit)
    {
        VERIFY(WszPostMessage(QuitMsg.hwnd, QuitMsg.message,QuitMsg.wParam, QuitMsg.lParam));
    }

    return dwReturn;
}


//--------------------------------------------------------------------
// helper to do message wait
//--------------------------------------------------------------------
DWORD MsgWaitHelper(int numWaiters, HANDLE* phEvent, BOOL bWaitAll, DWORD millis, BOOL bAlertable)
{
    DWORD dwReturn;

    Thread* pThread = GetThread();
    // If pThread is NULL, we'd better shut down.
    if (pThread == NULL)
        _ASSERTE (g_fEEShutDown);

    // First, check to see if we can take the opportunity and clean up any handles for the 
    // finalizer thread.
    // if (g_pRCWCleanupList != NULL)
    //     g_pRCWCleanupList->CleanUpCurrentWrappers(FALSE);

    // If we're going to pump, we cannot use WAIT_ALL.  That's because the wait would
    // only be satisfied if a message arrives while the handles are signalled.  If we
    // want true WAIT_ALL, we need to fire up a different thread in the MTA and wait
    // on his result.  This isn't implemented yet.
    //
    // A change was added to WaitHandleNative::CorWaitMultipleNative to disable WaitAll
    // in an STA with more than one handle.
    if (bWaitAll)
    {
        if (numWaiters == 1)
            bWaitAll = FALSE;
        else
            _ASSERTE(!"WaitAll in an STA with more than one handle will deadlock");
    }

    BOOL toggleGC = (pThread != NULL && pThread->PreemptiveGCDisabled());

    if (toggleGC)
        pThread->EnablePreemptiveGC();

    dwReturn = (RunningOnWinNT5()
                ? NT5WaitRoutine(bWaitAll, millis, numWaiters, phEvent, bAlertable)
                : NonNT5WaitRoutine(bWaitAll, millis, numWaiters, phEvent, bAlertable));

    if (toggleGC)
        pThread->DisablePreemptiveGC();

    return dwReturn;
}

//--------------------------------------------------------------------
// Do appropriate wait based on apartment state (STA or MTA)
DWORD Thread::DoAppropriateAptStateWait(int numWaiters, HANDLE* pHandles, BOOL bWaitAll, 
                                         DWORD timeout,BOOL alertable)
{
    ApartmentState as = GetFinalApartment();
    DWORD res;
    if (AS_InMTA == as || !alertable)
    {
        res = ::WaitForMultipleObjectsEx(numWaiters, pHandles,bWaitAll, timeout,alertable);
    }
    else
    {
        res = MsgWaitHelper(numWaiters,pHandles,bWaitAll,timeout,alertable);
    }
    return res;

}

//--------------------------------------------------------------------
// Based on whether this thread has a message pump, do the appropriate
// style of Wait.
//--------------------------------------------------------------------
DWORD Thread::DoAppropriateWaitWorker(int countHandles, HANDLE *handles, BOOL waitAll,
                                      DWORD millis, BOOL alertable)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(!GetThread()->GCForbidden());

    // During a <clinit>, this thread must not be asynchronously
    // stopped or interrupted.  That would leave the class unavailable
    // and is therefore a security hole.  We don't have to worry about
    // multithreading, since we only manipulate the current thread's count.
    if(alertable && m_PreventAsync > 0)
        alertable = FALSE;

    // disable GC (toggle)
    BOOL toggleGC = PreemptiveGCDisabled();
    if(toggleGC)
        EnablePreemptiveGC();

    // @TODO cwb: we don't know whether a thread has a message pump or
    // how to pump its messages, currently.
    // @TODO cwb: WinCE isn't going to support Thread.Interrupt() correctly until
    // we get alertable waits on that platform.
    DWORD ret;
    if(alertable)
    {
        // A word about ordering for Interrupt.  If someone tries to interrupt a thread
        // that's in the interruptible state, we queue an APC.  But if they try to interrupt
        // a thread that's not in the interruptible state, we just record that fact.  So
        // we have to set TS_Interruptible before we test to see whether someone wants to
        // interrupt us or else we have a race condition that causes us to skip the APC.
        FastInterlockOr((ULONG *) &m_State, TS_Interruptible);

        // If someone has interrupted us, we should not enter the wait.
        if (IsUserInterrupted(TRUE /*=reset*/))
        {
            // It is safe to clear the following two bits of state while
            // m_UserInterrupt is clear since both bits are only manipulated
            // within the context of the thread (TS_Interrupted is set via APC,
            // but these are not half as asynchronous as their name implies). If
            // an APC was queued, it has either gone off (and set the
            // TS_Interrupted bit which we're about to clear) or will execute at
            // some arbitrary later time. This is OK. If it executes while an
            // interrupt is not being requested it will simply become a no-op.
            // Otherwise it will serve it's original intended purpose (we don't
            // care which APC matches up with which interrupt attempt).
            FastInterlockAnd((ULONG *) &m_State, ~(TS_Interruptible | TS_Interrupted));

            if (toggleGC)
                DisablePreemptiveGC();

            return(WAIT_IO_COMPLETION);
        }
        // Safe to clear the interrupted state, no APC could have fired since we
        // reset m_UserInterrupt (which inhibits our APC callback from doing
        // anything).
        FastInterlockAnd((ULONG *) &m_State, ~TS_Interrupted);
    }

    DWORD dwStart, dwEnd;    
retry:
    dwStart = ::GetTickCount();
    BOOL blocked = FALSE;
    if (g_Win32Threadpool && (m_State & TS_ThreadPoolThread)) 
    {
        blocked = ThreadpoolMgr::ThreadAboutToBlock(this);    // inform the threadpool that this thread is about to block
    }
    ret = DoAppropriateAptStateWait(countHandles, handles, waitAll, millis, alertable);
    if (blocked) 
    {
        ThreadpoolMgr::ThreadAboutToUnblock();  // inform the threadpool that a previously blocked thread is now ready to run
    }
    if (ret == WAIT_IO_COMPLETION)
    {
                // We could be woken by some spurious APC or an EE APC queued to
        // interrupt us. In the latter case the TS_Interrupted bit will be set
        // in the thread state bits. Otherwise we just go back to sleep again.
        if (!(m_State & TS_Interrupted))
        {
            // Compute the new timeout value by assume that the timeout 
            // is not large enough for more than one wrap
            dwEnd = ::GetTickCount();
            if (millis != INFINITE)
            {
                DWORD newTimeout;
                if(dwStart <= dwEnd)
                    newTimeout = millis - (dwEnd - dwStart);
                else
                    newTimeout = millis - (0xFFFFFFFF - dwStart - dwEnd);
                // check whether the delta is more than millis
                if (newTimeout > millis)    
                {
                    ret = WAIT_TIMEOUT;
                    goto WaitCompleted;
                }
                else
                    millis = newTimeout;
            }
            goto retry;
        }
    }
    _ASSERTE((ret >= WAIT_OBJECT_0 && ret < WAIT_OBJECT_0 + countHandles) ||
             (ret >= WAIT_ABANDONED && ret < WAIT_ABANDONED + countHandles) ||
             (ret == WAIT_TIMEOUT) || (ret == WAIT_IO_COMPLETION) || (ret == WAIT_FAILED));

    // We support precisely one WAIT_FAILED case, where we attempt to wait on a
    // thread handle and the thread is in the process of dying we might get a
    // invalid handle substatus. Turn this into a successful wait.
    // There are three cases to consider:
    //  1)  Only waiting on one handle: return success right away.
    //  2)  Waiting for all handles to be signalled: retry the wait without the
    //      affected handle.
    //  3)  Waiting for one of multiple handles to be signalled: return with the
    //      first handle that is either signalled or has become invalid.
    if (ret == WAIT_FAILED)
    {
        DWORD errorCode = ::GetLastError();
        if (errorCode == ERROR_INVALID_PARAMETER) 
        {
            if (toggleGC)
                DisablePreemptiveGC();
            if (CheckForDuplicateHandles(countHandles, handles))
                COMPlusThrow(kDuplicateWaitObjectException);
            else
                COMPlusThrowWin32();
        }

        _ASSERTE(errorCode == ERROR_INVALID_HANDLE);

        if (countHandles == 1)
            ret = WAIT_OBJECT_0;
        else if (waitAll)
        {
            // Probe all handles with a timeout of zero. When we find one that's
            // invalid, move it out of the list and retry the wait.
#ifdef _DEBUG
            BOOL fFoundInvalid = FALSE;
#endif
            for (int i = 0; i < countHandles; i++)
            {
                DWORD subRet = WaitForSingleObject(handles[i], 0);
                if (subRet != WAIT_FAILED)
                    continue;
                _ASSERTE(::GetLastError() == ERROR_INVALID_HANDLE);
                if ((countHandles - i - 1) > 0)
                    memmove(&handles[i], &handles[i+1], (countHandles - i - 1) * sizeof(HANDLE));
                countHandles--;
#ifdef _DEBUG
                fFoundInvalid = TRUE;
#endif
                break;
            }
            _ASSERTE(fFoundInvalid);

            // Compute the new timeout value by assume that the timeout 
            // is not large enough for more than one wrap
            dwEnd = ::GetTickCount();
            if (millis != INFINITE)
            {
                DWORD newTimeout;
                if(dwStart <= dwEnd)
                    newTimeout = millis - (dwEnd - dwStart);
                else
                    newTimeout = millis - (0xFFFFFFFF - dwStart - dwEnd);
                if (newTimeout > millis)
                    goto WaitCompleted;
                else
                    millis = newTimeout;
            }
            goto retry;
        }
        else
        {
            // Probe all handles with a timeout as zero, succeed with the first
            // handle that doesn't timeout.
            ret = WAIT_OBJECT_0;
            for (int i = 0; i < countHandles; i++)
            {
            TryAgain:
                DWORD subRet = WaitForSingleObject(handles[i], 0);
                if ((subRet == WAIT_OBJECT_0) || (subRet == WAIT_FAILED))
                    break;
                if (subRet == WAIT_ABANDONED)
                {
                    ret = (ret - WAIT_OBJECT_0) + WAIT_ABANDONED;
                    break;
                }
                // If we get alerted it just masks the real state of the current
                // handle, so retry the wait.
                if (subRet == WAIT_IO_COMPLETION)
                    goto TryAgain;
                _ASSERTE(subRet == WAIT_TIMEOUT);
                ret++;
            }
            _ASSERTE(i != countHandles);
        }
    }

WaitCompleted:

    _ASSERTE((ret != WAIT_TIMEOUT) || (millis != INFINITE));

    if (toggleGC)
        DisablePreemptiveGC();

    if (alertable)
        FastInterlockAnd((ULONG *) &m_State, ~(TS_Interruptible | TS_Interrupted));

    // Make one last check to see if an interrupt request was made (and clear it
    // atomically). It's OK to clear the previous two bits first because they're
    // only accessed from this thread context.
    if (IsUserInterrupted(TRUE /*=reset*/))
        ret = WAIT_IO_COMPLETION;

    return ret;
}




// Called out of SyncBlock::Wait() to block this thread until the Notify occurs.
BOOL Thread::Block(INT32 timeOut, PendingSync *syncState)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(this == GetThread());

    // Before calling Block, the SyncBlock queued us onto it's list of waiting threads.
    // However, before calling Block the SyncBlock temporarily left the synchronized
    // region.  This allowed threads to enter the region and call Notify, in which
    // case we may have been signalled before we entered the Wait.  So we aren't in the
    // m_WaitSB list any longer.  Not a problem: the following Wait will return
    // immediately.  But it means we cannot enforce the following assertion:
//    _ASSERTE(m_WaitSB != NULL);

    return (Wait(&syncState->m_WaitEventLink->m_Next->m_EventWait, 1, timeOut, syncState) != WAIT_OBJECT_0);
}


// Return whether or not a timeout occured.  TRUE=>we waited successfully
DWORD Thread::Wait(HANDLE *objs, int cntObjs, INT32 timeOut, PendingSync *syncInfo)
{
    DWORD   dwResult;
    DWORD   dwTimeOut32;

    _ASSERTE(timeOut >= 0 || timeOut == INFINITE_TIMEOUT);

    dwTimeOut32 = (timeOut == INFINITE_TIMEOUT
                   ? INFINITE
                   : (DWORD) timeOut);

    dwResult = DoAppropriateWait(cntObjs, objs, FALSE /*=waitAll*/, dwTimeOut32,
                                 TRUE /*alertable*/, syncInfo);

    // Either we succeeded in the wait, or we timed out
    _ASSERTE((dwResult >= WAIT_OBJECT_0 && dwResult < WAIT_OBJECT_0 + cntObjs) ||
             (dwResult == WAIT_TIMEOUT));

    return dwResult;
}

void Thread::Wake(SyncBlock *psb)
{
    HANDLE hEvent = INVALID_HANDLE_VALUE;
    WaitEventLink *walk = &m_WaitEventLink;
    while (walk->m_Next) {
        if (walk->m_Next->m_WaitSB == psb) {
            hEvent = walk->m_Next->m_EventWait;
            // We are guaranteed that only one thread can change walk->m_Next->m_WaitSB
            // since the thread is helding the syncblock.
            walk->m_Next->m_WaitSB = (SyncBlock*)((DWORD_PTR)walk->m_Next->m_WaitSB | 1);
            break;
        }
#ifdef _DEBUG
        else if ((SyncBlock*)((DWORD_PTR)walk->m_Next & ~1) == psb) {
            _ASSERTE (!"Can not wake a thread on the same SyncBlock more than once");
        }
#endif
    }
    _ASSERTE (hEvent != INVALID_HANDLE_VALUE);
    ::SetEvent(hEvent);
}


// This is the service that backs us out of a wait that we interrupted.  We must
// re-