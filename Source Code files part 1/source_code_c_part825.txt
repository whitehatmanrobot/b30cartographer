:
            bResult = SetDecimalIntIniSwitch(pcvIniSwitch);
            break;

        case IST_UNS_DEC_INT:
            bResult = SetUnsignedDecimalIntIniSwitch(pcvIniSwitch);
            break;

        default:
            ERROR_OUT((TEXT("SetIniSwitch(): Unrecognized .ini switch type %d."),
                        *(PCINISWITCHTYPE)pcvIniSwitch));
            bResult = FALSE;
            break;
    }

    return(bResult);
}


/*
 ** IsYesString()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsYesString(LPCTSTR pcsz)
{
    ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

    return(IsStringInList(pcsz, MrgcpcszTrue, ARRAY_ELEMENTS(MrgcpcszTrue)));
}


/*
 ** IsNoString()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsNoString(LPCTSTR pcsz)
{
    ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

    return(IsStringInList(pcsz, MrgcpcszFalse, ARRAY_ELEMENTS(MrgcpcszFalse)));
}


/*
 ** IsStringInList()
 **
 ** Determines whether or not a given string matches a string in a list of
 ** strings.
 **
 ** Arguments:     pcsz - pointer to string to be checked
 **
 ** Returns:       
 **
 ** Side Effects:  none
 **
 ** N.b., string comparison is case-insensitive.
 */
PRIVATE_CODE BOOL IsStringInList(LPCTSTR pcsz, const LPCTSTR *pcpcszList,
        UINT ucbStrings)
{
    UINT u;
    BOOL bFound = FALSE;

    ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
    ASSERT(IS_VALID_READ_BUFFER_PTR(pcpcszList, LPCTSTR, ucbStrings * sizeof(*pcpcszList)));

    /* Search the list for the given string. */

    for (u = 0; u < ucbStrings; u++)
    {
        ASSERT(IS_VALID_STRING_PTR(pcpcszList[u], CSTR));

        if (! lstrcmpi(pcsz, pcpcszList[u]))
        {
            bFound = TRUE;
            break;
        }
    }

    return(bFound);
}


/*
 ** IsValidPCBOOLINIKEY()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCBOOLINISWITCH(PCBOOLINISWITCH pcbis)
{
    return(IS_VALID_READ_PTR(pcbis, CBOOLINISWITCH) &&
            EVAL(pcbis->istype == IST_BOOL) &&
            IS_VALID_STRING_PTR(pcbis->pcszKeyName, CSTR) &&
            IS_VALID_WRITE_PTR(pcbis->pdwParentFlags, DWORD) &&
            EVAL(pcbis->dwFlag));
}


/*
 ** IsValidPCDECINTINISWITCH()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCDECINTINISWITCH(PCDECINTINISWITCH pcdiis)
{
    return(IS_VALID_READ_PTR(pcdiis, CDECINTINISWITCH) &&
            EVAL(pcdiis->istype == IST_DEC_INT) &&
            IS_VALID_STRING_PTR(pcdiis->pcszKeyName, CSTR) &&
            IS_VALID_WRITE_PTR(pcdiis->pnValue, INT));
}


/*
 ** IsValidPCUNSDECINTINISWITCH()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCUNSDECINTINISWITCH(PCUNSDECINTINISWITCH pcudiis)
{
    return(IS_VALID_READ_PTR(pcudiis, CUNSDECINTINISWITCH) &&
            EVAL(pcudiis->istype == IST_UNS_DEC_INT) &&
            IS_VALID_STRING_PTR(pcudiis->pcszKeyName, CSTR) &&
            IS_VALID_WRITE_PTR(pcudiis->puValue, UINT));
}

#endif


/****************************** Public Functions *****************************/


#ifdef DEBUG

/*
 ** SetIniSwitches()
 **
 ** Set flags from initialization file.
 **
 ** Arguments:     ppcvIniSwitches - pointer to array of pointers to .ini switch
 **                                  structures describing .ini switches to set
 **                ucSwitches - number of .ini switch pointers in
 **                             ppcvIniSwitches array
 **
 ** Returns:       TRUE if .ini switch processing is successful.  FALSE if not.
 **
 ** Side Effects:  none
 **
 ** N.b, the global variables GpcszIniFile and GpcszIniSection must be filled in
 ** before calling SetIniSwitches().
 */
PUBLIC_CODE BOOL SetIniSwitches(const PCVOID *pcpcvIniSwitches, UINT ucSwitches)
{
    BOOL bResult = TRUE;
    UINT u;

    ASSERT(IS_VALID_READ_BUFFER_PTR(pcpcvIniSwitches, const PCVOID, ucSwitches * sizeof(*pcpcvIniSwitches)));

    /* Process .ini switches. */

    for (u = 0; u < ucSwitches; u++)
        bResult = SetIniSwitch(pcpcvIniSwitches[u]) && bResult;

    return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\irecinit.h ===
/*
 * irecinit.h - IReconcileInitiator implementation description.
 */


/* Prototypes
 *************/

/* irecinit.c */

extern HRESULT IReconcileInitiator_Constructor(HBRFCASE, RECSTATUSPROC, LPARAM, PIReconcileInitiator *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\init.c ===
/*
 * init.c - DLL startup routines module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "init.h"


/****************************** Public Functions *****************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** LibMain()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL APIENTRY LibMain(HANDLE hModule, DWORD dwReason, PVOID pvReserved)
{
   BOOL bResult;

   DebugEntry(LibMain);

   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
         bResult = AttachProcess(hModule);
         break;

      case DLL_PROCESS_DETACH:
         bResult = DetachProcess(hModule);
         break;

      case DLL_THREAD_ATTACH:
         bResult = AttachThread(hModule);
         break;

      case DLL_THREAD_DETACH:
         bResult = DetachThread(hModule);
         break;

      default:
         ERROR_OUT((TEXT("LibMain() called with unrecognized dwReason %lu."),
                    dwReason));
         bResult = FALSE;
         break;
   }

   DebugExitBOOL(LibMain, bResult);

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\irecinit.c ===
/*
 * irecinit.c - CReconcileInitiator implementation.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "oleutil.h"
#include "irecinit.h"


/* Types
 ********/

/* ReconcileInitiator class */

typedef struct _creconcileinitiator
{
   /* IReconcileInitiator */

   IReconcileInitiator irecinit;

   /* IBriefcaseInitiator */

   IBriefcaseInitiator ibcinit;

   /* reference count */

   ULONG ulcRef;

   /* handle to parent briefcase */

   HBRFCASE hbr;

   /* status callback function */

   RECSTATUSPROC rsp;

   /* status callback function data */

   LPARAM lpCallbackData;

   /* IUnknown to release to abort reconciliation. */

   PIUnknown piunkForAbort;
}
CReconcileInitiator;
DECLARE_STANDARD_TYPES(CReconcileInitiator);


/* Module Prototypes
 ********************/

PRIVATE_CODE HRESULT ReconcileInitiator_QueryInterface(PCReconcileInitiator, REFIID, PVOID *);
PRIVATE_CODE ULONG ReconcileInitiator_AddRef(PCReconcileInitiator);
PRIVATE_CODE ULONG ReconcileInitiator_Release(PCReconcileInitiator);
PRIVATE_CODE HRESULT ReconcileInitiator_SetAbortCallback(PCReconcileInitiator, PIUnknown);
PRIVATE_CODE HRESULT ReconcileInitiator_SetProgressFeedback(PCReconcileInitiator, ULONG, ULONG);

PRIVATE_CODE HRESULT AbortReconciliation(PCReconcileInitiator);

PRIVATE_CODE HRESULT RI_IReconcileInitiator_QueryInterface(PIReconcileInitiator, REFIID, PVOID *);
PRIVATE_CODE ULONG RI_IReconcileInitiator_AddRef(PIReconcileInitiator);
PRIVATE_CODE ULONG RI_IReconcileInitiator_Release(PIReconcileInitiator);
PRIVATE_CODE HRESULT RI_IReconcileInitiator_SetAbortCallback(PIReconcileInitiator, PIUnknown);
PRIVATE_CODE HRESULT RI_IReconcileInitiator_SetProgressFeedback( PIReconcileInitiator, ULONG, ULONG);

PRIVATE_CODE HRESULT RI_IBriefcaseInitiator_QueryInterface(PIBriefcaseInitiator, REFIID, PVOID *);
PRIVATE_CODE ULONG RI_IBriefcaseInitiator_AddRef(PIBriefcaseInitiator);
PRIVATE_CODE ULONG RI_IBriefcaseInitiator_Release(PIBriefcaseInitiator);
PRIVATE_CODE HRESULT RI_IBriefcaseInitiator_IsMonikerInBriefcase(PIBriefcaseInitiator, PIMoniker);

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCCReconcileInitiator(PCCReconcileInitiator);
PRIVATE_CODE BOOL IsValidPCIBriefcaseInitiator(PCIBriefcaseInitiator);

#endif


/* Module Variables
 *******************/

/* IReconcileInitiator vtable */

PRIVATE_DATA IReconcileInitiatorVtbl Mcirecinitvtbl =
{
   &RI_IReconcileInitiator_QueryInterface,
   &RI_IReconcileInitiator_AddRef,
   &RI_IReconcileInitiator_Release,
   &RI_IReconcileInitiator_SetAbortCallback,
   &RI_IReconcileInitiator_SetProgressFeedback
};

/* IBriefcaseInitiator vtable */

PRIVATE_DATA IBriefcaseInitiatorVtbl Mcibcinitvtbl =
{
   &RI_IBriefcaseInitiator_QueryInterface,
   &RI_IBriefcaseInitiator_AddRef,
   &RI_IBriefcaseInitiator_Release,
   &RI_IBriefcaseInitiator_IsMonikerInBriefcase
};


/***************************** Private Functions *****************************/


/*
** ReconcileInitiator_QueryInterface()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT ReconcileInitiator_QueryInterface(
                                                PCReconcileInitiator precinit,
                                                REFIID riid, PVOID *ppvObject)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));
   //ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   if (IsEqualIID(riid, &IID_IUnknown) ||
       IsEqualIID(riid, &IID_IReconcileInitiator))
   {
      *ppvObject = &(precinit->irecinit);
      precinit->irecinit.lpVtbl->AddRef(&(precinit->irecinit));
      hr = S_OK;
   }
   else if (IsEqualIID(riid, &IID_IBriefcaseInitiator))
   {
      *ppvObject = &(precinit->ibcinit);
      precinit->ibcinit.lpVtbl->AddRef(&(precinit->ibcinit));
      hr = S_OK;
   }
   else
      hr = E_NOINTERFACE;

   return(hr);
}


/*
** ReconcileInitiator_AddRef()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG ReconcileInitiator_AddRef(PCReconcileInitiator precinit)
{
   ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));

   ASSERT(precinit->ulcRef < ULONG_MAX);
   return(++(precinit->ulcRef));
}


/*
** ReconcileInitiator_Release()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG ReconcileInitiator_Release(PCReconcileInitiator precinit)
{
   ULONG ulcRef;

   ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));

   if (EVAL(precinit->ulcRef > 0))
      precinit->ulcRef--;

   ulcRef = precinit->ulcRef;

   if (! precinit->ulcRef)
      FreeMemory(precinit);

   return(ulcRef);
}


/*
** ReconcileInitiator_SetAbortCallback()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT ReconcileInitiator_SetAbortCallback(
                                                PCReconcileInitiator precinit,
                                                PIUnknown piunkForAbort)
{
   ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));
   /* piunkForAbort can be legally NULL */
   ASSERT(NULL == piunkForAbort || IS_VALID_STRUCT_PTR(piunkForAbort, CIUnknown));

   precinit->piunkForAbort = piunkForAbort;

   return(S_OK);
}


/*
** ReconcileInitiator_SetProgressFeedback()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT ReconcileInitiator_SetProgressFeedback(
                                                PCReconcileInitiator precinit,
                                                ULONG ulProgress,
                                                ULONG ulProgressMax)
{
   RECSTATUSUPDATE rsu;

   /* ulProgress may be any value. */
   /* ulProgressMax may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));

   rsu.ulScale = ulProgressMax;
   rsu.ulProgress = ulProgress;

   if (! NotifyReconciliationStatus(precinit->rsp, RS_DELTA_MERGE,
                                    (LPARAM)&rsu, precinit->lpCallbackData))
      AbortReconciliation(precinit);

   return(S_OK);
}


/*
** ReconcileInitiator_IsMonikerInBriefcase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT ReconcileInitiator_IsMonikerInBriefcase(
                                          PCReconcileInitiator precinit,
                                          PIMoniker pimk)
{
   HRESULT hr;
   PIMoniker pimkBriefcase;

   ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));
   ASSERT(IS_VALID_STRUCT_PTR(pimk, CIMoniker));

   hr = GetBriefcaseRootMoniker(precinit->hbr, &pimkBriefcase);

   if (SUCCEEDED(hr))
   {
      PIMoniker pimkCommonPrefix;

      hr = pimk->lpVtbl->CommonPrefixWith(pimk, pimkBriefcase,
                                          &pimkCommonPrefix);

      if (SUCCEEDED(hr))
      {
         switch (hr)
         {
            case MK_S_US:
               WARNING_OUT(((TEXT("ReconcileInitiator_IsMonikerInBriefcase(): Called on briefcase root."))));
               /* Fall through... */
            case MK_S_HIM:
               hr = S_OK;
               break;

            default:
               ASSERT(hr == S_OK ||
                      hr == MK_S_ME);
               hr = S_FALSE;
               break;
         }

#ifdef DEBUG

         {
            PIBindCtx pibindctx;
            BOOL bGotMoniker = FALSE;
            BOOL bGotBriefcase = FALSE;
            PWSTR pwszMoniker;
            PWSTR pwszBriefcase;
            PIMalloc pimalloc;

            if (SUCCEEDED(CreateBindCtx(0, &pibindctx)))
            {
               bGotMoniker = SUCCEEDED(pimk->lpVtbl->GetDisplayName(
                                                               pimk, pibindctx,
                                                               NULL,
                                                               &pwszMoniker));

               bGotBriefcase = SUCCEEDED(pimkBriefcase->lpVtbl->GetDisplayName(
                                                            pimkBriefcase,
                                                            pibindctx, NULL,
                                                            &pwszBriefcase));

               pibindctx->lpVtbl->Release(pibindctx);
            }

            if (! bGotMoniker)
               pwszMoniker = (PWSTR)L"UNAVAILABLE DISPLAY NAME";

            if (! bGotBriefcase)
               pwszBriefcase = (PWSTR)L"UNAVAILABLE DISPLAY NAME";

            TRACE_OUT(((TEXT("ReconcileInitiator_IsMonikerInBriefcase(): Moniker %ls is %s briefcase %ls.")),
                       pwszMoniker,
                       (hr == S_OK) ? "in" : "not in",
                       pwszBriefcase));

            if (EVAL(GetIMalloc(&pimalloc)))
            {
               if (bGotMoniker)
                  pimalloc->lpVtbl->Free(pimalloc, pwszMoniker);

               if (bGotBriefcase)
                  pimalloc->lpVtbl->Free(pimalloc, pwszBriefcase);

               /* Do not release pimalloc. */
            }
         }

#endif

         /* Do not release pimkBriefcase. */
      }
   }

   return(hr);
}


/*
** AbortReconciliation()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT AbortReconciliation(PCReconcileInitiator precinit)
{
   ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));

   if (precinit->piunkForAbort)
      precinit->piunkForAbort->lpVtbl->Release(precinit->piunkForAbort);

   return(S_OK);
}


/*
** RI_IReconcileInitiator_QueryInterface()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT RI_IReconcileInitiator_QueryInterface(
                                                PIReconcileInitiator pirecinit,
                                                REFIID riid, PVOID *ppvObject)
{
   ASSERT(IS_VALID_STRUCT_PTR(pirecinit, CIReconcileInitiator));
   //ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   return(ReconcileInitiator_QueryInterface(
            ClassFromIface(CReconcileInitiator, irecinit, pirecinit),
            riid, ppvObject));
}


/*
** RI_IReconcileInitiator_AddRef()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG RI_IReconcileInitiator_AddRef(
                                                PIReconcileInitiator pirecinit)
{
   ASSERT(IS_VALID_STRUCT_PTR(pirecinit, CIReconcileInitiator));

   return(ReconcileInitiator_AddRef(
            ClassFromIface(CReconcileInitiator, irecinit, pirecinit)));
}


/*
** RI_IReconcileInitiator_Release()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG RI_IReconcileInitiator_Release(
                                                PIReconcileInitiator pirecinit)
{
   ASSERT(IS_VALID_STRUCT_PTR(pirecinit, CIReconcileInitiator));

   return(ReconcileInitiator_Release(
            ClassFromIface(CReconcileInitiator, irecinit, pirecinit)));
}


/*
** RI_IReconcileInitiator_SetAbortCallback()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT RI_IReconcileInitiator_SetAbortCallback(
                                                PIReconcileInitiator pirecinit,
                                                PIUnknown piunkForAbort)
{
   ASSERT(IS_VALID_STRUCT_PTR(pirecinit, CIReconcileInitiator));
   /* piunkForAbort can be legally NULL */
   ASSERT(NULL == piunkForAbort || IS_VALID_STRUCT_PTR(piunkForAbort, CIUnknown));

   return(ReconcileInitiator_SetAbortCallback(
            ClassFromIface(CReconcileInitiator, irecinit, pirecinit),
            piunkForAbort));
}


/*
** RI_IReconcileInitiator_SetProgressFeedback()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT RI_IReconcileInitiator_SetProgressFeedback(
                                                PIReconcileInitiator pirecinit,
                                                ULONG ulProgress,
                                                ULONG ulProgressMax)
{
   /* ulProgress may be any value. */
   /* ulProgressMax may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pirecinit, CIReconcileInitiator));

   return(ReconcileInitiator_SetProgressFeedback(
            ClassFromIface(CReconcileInitiator, irecinit, pirecinit),
            ulProgress, ulProgressMax));
}


/*
** RI_IBriefcaseInitiator_QueryInterface()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT RI_IBriefcaseInitiator_QueryInterface(
                                                PIBriefcaseInitiator pibcinit,
                                                REFIID riid, PVOID *ppvObject)
{
   ASSERT(IS_VALID_STRUCT_PTR(pibcinit, CIBriefcaseInitiator));
   //ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   return(ReconcileInitiator_QueryInterface(
            ClassFromIface(CReconcileInitiator, ibcinit, pibcinit),
            riid, ppvObject));
}


/*
** RI_IBriefcaseInitiator_AddRef()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG RI_IBriefcaseInitiator_AddRef(PIBriefcaseInitiator pibcinit)
{
   ASSERT(IS_VALID_STRUCT_PTR(pibcinit, CIBriefcaseInitiator));

   return(ReconcileInitiator_AddRef(
            ClassFromIface(CReconcileInitiator, ibcinit, pibcinit)));
}


/*
** RI_IBriefcaseInitiator_Release()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG RI_IBriefcaseInitiator_Release(
                                                PIBriefcaseInitiator pibcinit)
{
   ASSERT(IS_VALID_STRUCT_PTR(pibcinit, CIBriefcaseInitiator));

   return(ReconcileInitiator_Release(
            ClassFromIface(CReconcileInitiator, ibcinit, pibcinit)));
}


/*
** RI_IBriefcaseInitiator_IsMonikerInBriefcase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT RI_IBriefcaseInitiator_IsMonikerInBriefcase(
                                                PIBriefcaseInitiator pibcinit,
                                                PIMoniker pmk)
{
   ASSERT(IS_VALID_STRUCT_PTR(pibcinit, CIBriefcaseInitiator));
   ASSERT(IS_VALID_STRUCT_PTR(pmk, CIMoniker));

   return(ReconcileInitiator_IsMonikerInBriefcase(
            ClassFromIface(CReconcileInitiator, ibcinit, pibcinit),
            pmk));
}


#ifdef DEBUG

/*
** IsValidPCCReconcileInitiator()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCCReconcileInitiator(PCCReconcileInitiator pcrecinit)
{
   /* ulcRef may be any value. */
   /* lpCallbackData may be any value. */

   return(IS_VALID_READ_PTR(pcrecinit, CCReconcileInitiator) &&
          IS_VALID_STRUCT_PTR(&(pcrecinit->irecinit), CIReconcileInitiator) &&
          IS_VALID_STRUCT_PTR(&(pcrecinit->ibcinit), CIBriefcaseInitiator) &&
          IS_VALID_HANDLE(pcrecinit->hbr, BRFCASE) &&
          (! pcrecinit->rsp ||
           IS_VALID_CODE_PTR(pcrecinit->rsp, RECSTATUSPROC)) &&
          (! pcrecinit->piunkForAbort ||
           IS_VALID_STRUCT_PTR(pcrecinit->piunkForAbort, CIUnknown)));
}


/*
** IsValidPCIBriefcaseInitiator()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCIBriefcaseInitiator(PCIBriefcaseInitiator pcibcinit)
{
   return(IS_VALID_READ_PTR(pcibcinit, CIBriefcaseInitiator) &&
          IS_VALID_READ_PTR(pcibcinit->lpVtbl, sizeof(*(pcibcinit->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcibcinit, CIUnknown) &&
          IS_VALID_CODE_PTR(pcibcinit->lpVtbl->IsMonikerInBriefcase, IsMonikerInBriefcase));
}

#endif


/****************************** Public Functions *****************************/


/*
** IReconcileInitiator_Constructor()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT IReconcileInitiator_Constructor(
                                             HBRFCASE hbr, RECSTATUSPROC rsp,
                                             LPARAM lpCallbackData,
                                             PIReconcileInitiator *ppirecinit)
{
   HRESULT hr;
   PCReconcileInitiator precinit;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
   ASSERT(IS_VALID_WRITE_PTR(ppirecinit, PIReconcileInitiator));

   if (AllocateMemory(sizeof(*precinit), &precinit))
   {
      precinit->irecinit.lpVtbl = &Mcirecinitvtbl;
      precinit->ibcinit.lpVtbl = &Mcibcinitvtbl;
      precinit->ulcRef = 0;
      precinit->hbr = hbr;
      precinit->rsp = rsp;
      precinit->lpCallbackData = lpCallbackData;
      precinit->piunkForAbort = NULL;

      ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));

      hr = precinit->irecinit.lpVtbl->QueryInterface(
               &(precinit->irecinit), &IID_IReconcileInitiator, ppirecinit);

      ASSERT(hr == S_OK);
   }
   else
      hr = E_OUTOFMEMORY;

   ASSERT(FAILED(hr) ||
          IS_VALID_STRUCT_PTR(*ppirecinit, CIReconcileInitiator));

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\init.h ===
/*
 * init.h - DLL startup routines module description.
 */


/* Prototypes
 *************/

/* functions to be provided by client */

extern BOOL AttachProcess(HANDLE);
extern BOOL DetachProcess(HANDLE);
extern BOOL AttachThread(HANDLE);
extern BOOL DetachThread(HANDLE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\list.c ===
/*
 * list.c - List ADT module.
 */

/*

Motivation
----------

   Unfortunately, C7 doesn't fully support templates.  As a result, to link ADT
structures together, we could either embed linked list pointers in those
structures, or create a separate linked list ADT in which each node contains a
pointer to the associated structure.

   If we embed linked list pointers in other ADT structures, we lose the linked
list ADT barrier, and with it, the ability to easily change the linked list
implementation.  However, we no longer need to store an extra pointer to the
data associated with each linked node.

   If we create a separate linked list ADT, we are forced to store a pointer to
the structure associated with the node.  However, we retain the ability to
alter the linked list ADT in the future.

   Let's support the abstraction barrier, and create a separate linked list
ADT.

   In the object synchronization engine, the linked list ADT is used to store
lists of links, link handlers, and strings.


Architecture
------------

   The nodes in each doubly-linked list of nodes are allocated by
AllocateMemory().  A caller-supplied DWORD is stored in each list node.  NULL
is used as a sentinel pointer value for the head and tail of a list.

   A list handle is a pointer to a LIST allocated by AllocateMemory().  A list
node handle is a pointer to a list node.


         head            node            node            tail
        (LIST)          (NODE)          (NODE)          (NODE)
      Ŀ     Ŀ     Ŀ     Ŀ
      pnodeNext --> pnodeNext --> pnodeNext --> pnodeNext --0
                                                         
  0-- pnodePrev <-- pnodePrev <-- pnodePrev <-- pnodePrev
                                                         
        XXXXXX         pcv           pcv           pcv   
      Ĵ               
               
         ....  


   pnodeNext is non-NULL for all list nodes except the tail.  pnodeNext in
the head is only NULL for an empty list.  pnodePrev is non-NULL for all list
nodes.  pnodePrev in the head is always NULL.  Be careful not to use pnodePrev
from the first list node as another list node!

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Macros
 *********/

/* Add nodes to list in sorted order? */

#define ADD_NODES_IN_SORTED_ORDER(plist)  IS_FLAG_SET((plist)->dwFlags, LIST_FL_SORTED_ADD)


/* Types
 ********/

/* list node types */

typedef struct _node
{
   struct _node *pnodeNext;      /* next node in list */
   struct _node *pnodePrev;      /* previous node in list */
   PCVOID pcv;                   /* node data */
}
NODE;
DECLARE_STANDARD_TYPES(NODE);

/* list flags */

typedef enum _listflags
{
   /* Insert nodes in sorted order. */

   LIST_FL_SORTED_ADD      = 0x0001,

   /* flag combinations */

   ALL_LIST_FLAGS          = LIST_FL_SORTED_ADD
}
LISTFLAGS;

/*
 * A LIST is just a special node at the head of a list.  N.b., the _node
 * structure MUST appear first in the _list structure because a pointer to a
 * list is sometimes used as a pointer to a node.
 */

typedef struct _list
{
   NODE node;

   DWORD dwFlags;
}
LIST;
DECLARE_STANDARD_TYPES(LIST);

/* SearchForNode() return codes */

typedef enum _addnodeaction
{
   ANA_FOUND,
   ANA_INSERT_BEFORE_NODE,
   ANA_INSERT_AFTER_NODE,
   ANA_INSERT_AT_HEAD
}
ADDNODEACTION;
DECLARE_STANDARD_TYPES(ADDNODEACTION);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE ADDNODEACTION SearchForNode(HLIST, COMPARESORTEDNODESPROC, PCVOID, PHNODE);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCLIST(PCLIST);
PRIVATE_CODE BOOL IsValidPCNODE(PCNODE);

#endif

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCNEWLIST(PCNEWLIST);
PRIVATE_CODE BOOL IsValidADDNODEACTION(ADDNODEACTION);
PRIVATE_CODE HLIST GetList(HNODE);

#endif

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL IsListInSortedOrder(PCLIST, COMPARESORTEDNODESPROC);

#endif


/*
** SearchForNode()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ADDNODEACTION SearchForNode(HLIST hlist,
                                         COMPARESORTEDNODESPROC csnp,
                                         PCVOID pcv, PHNODE phnode)
{
   ADDNODEACTION ana;
   ULONG ulcNodes;

   /* pcv may be any value */

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_CODE_PTR(csnp, COMPARESORTEDNODESPROC));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   ASSERT(ADD_NODES_IN_SORTED_ORDER((PCLIST)hlist));
   ASSERT(IsListInSortedOrder((PCLIST)hlist, csnp));

   /* Yes.  Are there any nodes in this list? */

   ulcNodes = GetNodeCount(hlist);

   ASSERT(ulcNodes < LONG_MAX);

   if (ulcNodes > 0)
   {
      LONG lLow = 0;
      LONG lMiddle = 0;
      LONG lHigh = ulcNodes - 1;
      LONG lCurrent = 0;
      int nCmpResult = 0;

      /* Yes.  Search for target. */

      EVAL(GetFirstNode(hlist, phnode));

      while (lLow <= lHigh)
      {
         lMiddle = (lLow + lHigh) / 2;

         /* Which way should we seek in the list to get the lMiddle node? */

         if (lCurrent < lMiddle)
         {
            /* Forward from the current node. */

            while (lCurrent < lMiddle)
            {
               EVAL(GetNextNode(*phnode, phnode));
               lCurrent++;
            }
         }
         else if (lCurrent > lMiddle)
         {
            /* Backward from the current node. */

            while (lCurrent > lMiddle)
            {
               EVAL(GetPrevNode(*phnode, phnode));
               lCurrent--;
            }
         }

         nCmpResult = (*csnp)(pcv, GetNodeData(*phnode));

         if (nCmpResult < 0)
            lHigh = lMiddle - 1;
         else if (nCmpResult > 0)
            lLow = lMiddle + 1;
         else
            /* Found a match at *phnode. */
            break;
      }

      /*
       * If (nCmpResult >  0), insert after *phnode.
       *
       * If (nCmpResult <  0), insert before *phnode.
       *
       * If (nCmpResult == 0), string found at *phnode.
       */

      if (nCmpResult > 0)
         ana = ANA_INSERT_AFTER_NODE;
      else if (nCmpResult < 0)
         ana = ANA_INSERT_BEFORE_NODE;
      else
         ana = ANA_FOUND;
   }
   else
   {
      /* No.  Insert the target as the only node in the list. */

      *phnode = NULL;
      ana = ANA_INSERT_AT_HEAD;
   }

   ASSERT(EVAL(IsValidADDNODEACTION(ana)) &&
          (ana == ANA_INSERT_AT_HEAD ||
           IS_VALID_HANDLE(*phnode, NODE)));

   return(ana);
}


#ifdef VSTF

/*
** IsValidPCLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCLIST(PCLIST pcl)
{
   BOOL bResult = FALSE;

   if (IS_VALID_READ_PTR(pcl, CLIST) &&
       FLAGS_ARE_VALID(pcl->dwFlags, ALL_LIST_FLAGS) &&
       EVAL(! pcl->node.pnodePrev))
   {
      PNODE pnode;

      for (pnode = pcl->node.pnodeNext;
           pnode && IS_VALID_STRUCT_PTR(pnode, CNODE);
           pnode = pnode->pnodeNext)
         ;

      bResult = (! pnode);
   }

   return(bResult);
}


/*
** IsValidPCNODE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCNODE(PCNODE pcn)
{
   /*
    * All valid nodes must have a valid pnodePrev pointer.  The first node's
    * pnodePrev pointer points at the list head.  A node's pnodeNext pointer
    * may be a valid pointer or NULL.
    */

   return(IS_VALID_READ_PTR(pcn, CNODE) &&
          EVAL(IS_VALID_READ_PTR(pcn->pnodePrev, CNODE) &&
               pcn->pnodePrev->pnodeNext == pcn) &&
          EVAL(! pcn->pnodeNext ||
               (IS_VALID_READ_PTR(pcn->pnodeNext, CNODE) &&
                pcn->pnodeNext->pnodePrev == pcn)));
}

#endif


#ifdef DEBUG

/*
** IsValidPCNEWLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCNEWLIST(PCNEWLIST pcnl)
{
   return(IS_VALID_READ_PTR(pcnl, CNEWLIST) &&
          FLAGS_ARE_VALID(pcnl->dwFlags, ALL_NL_FLAGS));
}


/*
** IsValidADDNODEACTION()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidADDNODEACTION(ADDNODEACTION ana)
{
   BOOL bResult;

   switch (ana)
   {
      case ANA_FOUND:
      case ANA_INSERT_BEFORE_NODE:
      case ANA_INSERT_AFTER_NODE:
      case ANA_INSERT_AT_HEAD:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidADDNODEACTION(): Invalid ADDNODEACTION %d."),
                    ana));
         break;
   }

   return(bResult);
}


/*
** GetList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HLIST GetList(HNODE hnode)
{
   PCNODE pcnode;

   ASSERT(IS_VALID_HANDLE(hnode, NODE));

   ASSERT(((PCNODE)hnode)->pnodePrev);

   for (pcnode = (PCNODE)hnode; pcnode->pnodePrev; pcnode = pcnode->pnodePrev)
      ;

   return((HLIST)pcnode);
}

#endif


#if defined(DEBUG) || defined(VSTF)

/*
** IsListInSortedOrder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsListInSortedOrder(PCLIST pclist, COMPARESORTEDNODESPROC csnp)
{
   BOOL bResult = TRUE;
   PNODE pnode;

   /* Don't validate pclist here. */

   ASSERT(ADD_NODES_IN_SORTED_ORDER(pclist));
   ASSERT(IS_VALID_CODE_PTR(csnp, COMPARESORTEDNODESPROC));

   pnode = pclist->node.pnodeNext;

   while (pnode)
   {
      PNODE pnodeNext;

      pnodeNext = pnode->pnodeNext;

      if (pnodeNext)
      {
         if ( (*csnp)(pnode->pcv, pnodeNext->pcv) == CR_FIRST_LARGER)
         {
            bResult = FALSE;
            ERROR_OUT((TEXT("IsListInSortedOrder(): Node [%ld] %#lx > following node [%ld] %#lx."),
                       pnode,
                       pnode->pcv,
                       pnodeNext,
                       pnodeNext->pcv));
            break;
         }

         pnode = pnodeNext;
      }
      else
         break;
   }

   return(bResult);
}

#endif


/****************************** Public Functions *****************************/


/*
** CreateList()
**
** Creates a new list.
**
** Arguments:     void
**
** Returns:       Handle to new list, or NULL if unsuccessful.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreateList(PCNEWLIST pcnl, PHLIST phlist)
{
   PLIST plist;

   ASSERT(IS_VALID_STRUCT_PTR(pcnl, CNEWLIST));
   ASSERT(IS_VALID_WRITE_PTR(phlist, HLIST));

   /* Try to allocate new list structure. */

   *phlist = NULL;

   if (AllocateMemory(sizeof(*plist), &plist))
   {
      /* List allocated successfully.  Initialize list fields. */

      plist->node.pnodeNext = NULL;
      plist->node.pnodePrev = NULL;
      plist->node.pcv = NULL;

      plist->dwFlags = 0;

      if (IS_FLAG_SET(pcnl->dwFlags, NL_FL_SORTED_ADD))
      {
         SET_FLAG(plist->dwFlags, LIST_FL_SORTED_ADD);
      }

      *phlist = (HLIST)plist;

      ASSERT(IS_VALID_HANDLE(*phlist, LIST));
   }

   return(*phlist != NULL);
}


/*
** DestroyList()
**
** Deletes a list.
**
** Arguments:     hlist - handle to list to be deleted
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyList(HLIST hlist)
{
   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   DeleteAllNodes(hlist);

   /* Delete list. */

   FreeMemory((PLIST)hlist);

   return;
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** AddNode()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL AddNode(HLIST hlist, COMPARESORTEDNODESPROC csnp, PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   if (ADD_NODES_IN_SORTED_ORDER((PCLIST)hlist))
   {
      ADDNODEACTION ana;

      ana = SearchForNode(hlist, csnp, pcv, phnode);

      ASSERT(ana != ANA_FOUND);

      switch (ana)
      {
         case ANA_INSERT_BEFORE_NODE:
            bResult = InsertNodeBefore(*phnode, csnp, pcv, phnode);
            break;

         case ANA_INSERT_AFTER_NODE:
            bResult = InsertNodeAfter(*phnode, csnp, pcv, phnode);
            break;

         default:
            ASSERT(ana == ANA_INSERT_AT_HEAD);
            bResult = InsertNodeAtFront(hlist, csnp, pcv, phnode);
            break;
      }
   }
   else
      bResult = InsertNodeAtFront(hlist, csnp, pcv, phnode);

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}


/*
** InsertNodeAtFront()
**
** Inserts a node at the front of a list.
**
** Arguments:     hlist - handle to list that node is to be inserted at head of
**                pcv - data to be stored in node
**
** Returns:       Handle to new node, or NULL if unsuccessful.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InsertNodeAtFront(HLIST hlist, COMPARESORTEDNODESPROC csnp, PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

#ifdef DEBUG

   /* Make sure the correct index was given for insertion. */

   if (ADD_NODES_IN_SORTED_ORDER((PCLIST)hlist))
   {
      HNODE hnodeNew;
      ADDNODEACTION anaNew;

      anaNew = SearchForNode(hlist, csnp, pcv, &hnodeNew);

      ASSERT(anaNew != ANA_FOUND);
      ASSERT(anaNew == ANA_INSERT_AT_HEAD ||
             (anaNew == ANA_INSERT_BEFORE_NODE &&
              hnodeNew == (HNODE)(((PCLIST)hlist)->node.pnodeNext)));
   }

#endif

   bResult = AllocateMemory(sizeof(*pnode), &pnode);

   if (bResult)
   {
      /* Add new node to front of list. */

      pnode->pnodePrev = (PNODE)hlist;
      pnode->pnodeNext = ((PLIST)hlist)->node.pnodeNext;
      pnode->pcv = pcv;

      ((PLIST)hlist)->node.pnodeNext = pnode;

      /* Any more nodes in list? */

      if (pnode->pnodeNext)
         pnode->pnodeNext->pnodePrev = pnode;

      *phnode = (HNODE)pnode;
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}


/*
** InsertNodeBefore()
**
** Inserts a new node in a list before a given node.
**
** Arguments:     hnode - handle to node that new node is to be inserted before
**                pcv - data to be stored in node
**
** Returns:       Handle to new node, or NULL if unsuccessful.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InsertNodeBefore(HNODE hnode, COMPARESORTEDNODESPROC csnp, PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hnode, NODE));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

#ifdef DEBUG

   {
      HLIST hlistParent;

      /* Make sure the correct index was given for insertion. */

      hlistParent = GetList(hnode);

      if (ADD_NODES_IN_SORTED_ORDER((PCLIST)hlistParent))
      {
         HNODE hnodeNew;
         ADDNODEACTION anaNew;

         anaNew = SearchForNode(hlistParent, csnp, pcv, &hnodeNew);

         ASSERT(anaNew != ANA_FOUND);
         ASSERT((anaNew == ANA_INSERT_BEFORE_NODE &&
                 hnodeNew == hnode) ||
                (anaNew == ANA_INSERT_AFTER_NODE &&
                 hnodeNew == (HNODE)(((PCNODE)hnode)->pnodePrev)) ||
                (anaNew == ANA_INSERT_AT_HEAD &&
                 hnode == (HNODE)(((PCLIST)hlistParent)->node.pnodeNext)));
      }
   }

#endif

   bResult = AllocateMemory(sizeof(*pnode), &pnode);

   if (bResult)
   {
      /* Insert new node before given node. */

      pnode->pnodePrev = ((PNODE)hnode)->pnodePrev;
      pnode->pnodeNext = (PNODE)hnode;
      pnode->pcv = pcv;

      ((PNODE)hnode)->pnodePrev->pnodeNext = pnode;

      ((PNODE)hnode)->pnodePrev = pnode;

      *phnode = (HNODE)pnode;
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}


/*
** InsertNodeAfter()
**
** Inserts a new node in a list after a given node.
**
** Arguments:     hnode - handle to node that new node is to be inserted after
**                pcv - data to be stored in node
**
** Returns:       Handle to new node, or NULL if unsuccessful.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InsertNodeAfter(HNODE hnode, COMPARESORTEDNODESPROC csnp, PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hnode, NODE));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

#ifdef DEBUG

   /* Make sure the correct index was given for insertion. */

   {
      HLIST hlistParent;

      /* Make sure the correct index was given for insertion. */

      hlistParent = GetList(hnode);

      if (ADD_NODES_IN_SORTED_ORDER((PCLIST)hlistParent))
      {
         HNODE hnodeNew;
         ADDNODEACTION anaNew;

         anaNew = SearchForNode(hlistParent, csnp, pcv, &hnodeNew);

         ASSERT(anaNew != ANA_FOUND);
         ASSERT((anaNew == ANA_INSERT_AFTER_NODE &&
                 hnodeNew == hnode) ||
                (anaNew == ANA_INSERT_BEFORE_NODE &&
                 hnodeNew == (HNODE)(((PCNODE)hnode)->pnodeNext)));
      }
   }

#endif

   bResult = AllocateMemory(sizeof(*pnode), &pnode);

   if (bResult)
   {
      /* Insert new node after given node. */

      pnode->pnodePrev = (PNODE)hnode;
      pnode->pnodeNext = ((PNODE)hnode)->pnodeNext;
      pnode->pcv = pcv;

      /* Are we inserting after the tail of the list? */

      if (((PNODE)hnode)->pnodeNext)
         /* No. */
         ((PNODE)hnode)->pnodeNext->pnodePrev = pnode;

      ((PNODE)hnode)->pnodeNext = pnode;

      *phnode = (HNODE)pnode;
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** DeleteNode()
**
** Removes a node from a list.
**
** Arguments:     hnode - handle to node to be removed
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void DeleteNode(HNODE hnode)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));

   /*
    * There is always a previous node for normal list nodes.  Even the head
    * list node is preceded by the list's leading LIST node.
    */

   ((PNODE)hnode)->pnodePrev->pnodeNext = ((PNODE)hnode)->pnodeNext;

   /* Any more nodes in list? */

   if (((PNODE)hnode)->pnodeNext)
      ((PNODE)hnode)->pnodeNext->pnodePrev = ((PNODE)hnode)->pnodePrev;

   FreeMemory((PNODE)hnode);

   return;
}


/*
** DeleteAllNodes()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DeleteAllNodes(HLIST hlist)
{
   PNODE pnodePrev;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   /* Walk list, starting with first node after head, deleting each node. */

   pnodePrev = ((PLIST)hlist)->node.pnodeNext;

   /*
    * Deleting the tail node in the loop forces us to add an extra
    * comparison to the body of the loop.  Trade speed for size here.
    */

   while (pnodePrev)
   {
      pnode = pnodePrev->pnodeNext;

      FreeMemory(pnodePrev);

      pnodePrev = pnode;

      if (pnode)
         pnode = pnode->pnodeNext;
   }

   ((PLIST)hlist)->node.pnodeNext = NULL;

   return;
}


/*
** GetNodeData()
**
** Gets the data stored in a node.
**
** Arguments:     hnode - handle to node whose data is to be returned
**
** Returns:       Pointer to node's data.
**
** Side Effects:  none
*/
PUBLIC_CODE PVOID GetNodeData(HNODE hnode)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));

   return((PVOID)(((PNODE)hnode)->pcv));
}


/*
** SetNodeData()
**
** Sets the data stored in a node.
**
** Arguments:     hnode - handle to node whose data is to be set
**                pcv - node data
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void SetNodeData(HNODE hnode, PCVOID pcv)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));

   ((PNODE)hnode)->pcv = pcv;

   return;
}


/*
** GetNodeCount()
**
** Counts the number of nodes in a list.
**
** Arguments:     hlist - handle to list whose nodes are to be counted
**
** Returns:       Number of nodes in list.
**
** Side Effects:  none
**
** N.b., this is an O(n) operation since we don't explicitly keep track of the
** number of nodes in a list.
*/
PUBLIC_CODE ULONG GetNodeCount(HLIST hlist)
{
   PNODE pnode;
   ULONG ulcNodes;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   ulcNodes = 0;

   for (pnode = ((PLIST)hlist)->node.pnodeNext;
        pnode;
        pnode = pnode->pnodeNext)
   {
      ASSERT(ulcNodes < ULONG_MAX);
      ulcNodes++;
   }

   return(ulcNodes);
}


/*
** IsListEmpty()
**
** Determines whether or not a list is empty.
**
** Arguments:     hlist - handle to list to be checked
**
** Returns:       TRUE if list is empty, or FALSE if not.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsListEmpty(HLIST hlist)
{
   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   return(((PLIST)hlist)->node.pnodeNext == NULL);
}


/*

   To walk a list:
   ---------------

   {
      BOOL bContinue;
      HNODE hnode;

      for (bContinue = GetFirstNode(hlist, &hnode);
           bContinue;
           bContinue = GetNextNode(hnode, &hnode))
         DoSomethingWithNode(hnode);
   }

   or:
   ---

   {
      HNODE hnode;

      if (GetFirstNode(hlist, &hnode))
      {
         do
         {
            DoSomethingWithNode(hnode);
         }
         while (GetNextNode(hnode, &hnode));
      }
   }

   To compare nodes by adjacent pairs:
   -----------------------------------

   {
      HNODE hnodePrev;

      if (GetFirstNode(hlist, &hnodePrev))
      {
         PFOO pfooPrev;
         HNODE hnodeNext;

         pfooPrev = GetNodeData(hnodePrev);

         while (GetNextNode(hnodePrev, &hnodeNext))
         {
            PFOO pfooNext;

            pfooNext = GetNodeData(hnodeNext);

            CompareFoos(pfooPrev, pfooNext);

            hnodePrev = hnodeNext;
            pfooPrev = pfooNext;
         }
      }
   }

   To destroy nodes in a list:
   ---------------------------

   {
      BOOL bContinue;
      HNODE hnodePrev;

      bContinue = GetFirstNode(hlist, &hnodePrev);

      while (bContinue)
      {
         HNODE hnodeNext;

         bContinue = GetNextNode(hnodePrev, &hnodeNext);

         DeleteNode(hnodePrev);

         hnodePrev = hnodeNext;
      }
   }

*/


/*
** GetFirstNode()
**
** Gets the head node in a list.
**
** Arguments:     hlist - handle to list whose head node is to be retrieved
**
** Returns:       Handle to head list node, or NULL if list is empty.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetFirstNode(HLIST hlist, PHNODE phnode)
{
   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   *phnode = (HNODE)(((PLIST)hlist)->node.pnodeNext);

   ASSERT(! *phnode || IS_VALID_HANDLE(*phnode, NODE));

   return(*phnode != NULL);
}


/*
** GetNextNode()
**
** Gets the next node in a list.
**
** Arguments:     hnode - handle to current node
**                phnode - pointer to HNODE to be filled in with handle to next
**                         node in list, *phnode is only valid if GetNextNode()
**                         returns TRUE
**
** Returns:       TRUE if there is another node in the list, or FALSE if there
**                are no more nodes in the list.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetNextNode(HNODE hnode, PHNODE phnode)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   *phnode = (HNODE)(((PNODE)hnode)->pnodeNext);

   ASSERT(! *phnode || IS_VALID_HANDLE(*phnode, NODE));

   return(*phnode != NULL);
}


/*
** GetPrevNode()
**
** Gets the previous node in a list.
**
** Arguments:     hnode - handle to current node
**
** Returns:       Handle to previous node in list, or NULL if there are no
**                previous nodes in the list.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetPrevNode(HNODE hnode, PHNODE phnode)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   /* Is this the first node in the list? */

   if (((PNODE)hnode)->pnodePrev->pnodePrev)
   {
      *phnode = (HNODE)(((PNODE)hnode)->pnodePrev);
      ASSERT(IS_VALID_HANDLE(*phnode, NODE));
   }
   else
      *phnode = NULL;

   return(*phnode != NULL);
}


/*
** AppendList()
**
** Appends one list on to another, leaving the source list empty.
**
** Arguments:     hlistDest - handle to destination list to append to
**                hlistSrc - handle to source list to truncate
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., all HNODEs from both lists remain valid.
*/
PUBLIC_CODE void AppendList(HLIST hlistDest, HLIST hlistSrc)
{
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlistDest, LIST));
   ASSERT(IS_VALID_HANDLE(hlistSrc, LIST));

   if (hlistSrc != hlistDest)
   {
      /* Find last node in destination list to append to. */

      /*
       * N.b., start with the actual LIST node here, not the first node in the
       * list, in case the list is empty.
       */

      for (pnode = &((PLIST)hlistDest)->node;
           pnode->pnodeNext;
           pnode = pnode->pnodeNext)
         ;

      /* Append the source list to the last node in the destination list. */

      pnode->pnodeNext = ((PLIST)hlistSrc)->node.pnodeNext;

      if (pnode->pnodeNext)
         pnode->pnodeNext->pnodePrev = pnode;

      ((PLIST)hlistSrc)->node.pnodeNext = NULL;
   }
   else
      WARNING_OUT((TEXT("AppendList(): Source list same as destination list (%#lx)."),
                   hlistDest));

   return;
}


/*
** SearchSortedList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SearchSortedList(HLIST hlist, COMPARESORTEDNODESPROC csnp,
                                  PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;

   /* pcv may be any value */

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_CODE_PTR(csnp, COMPARESORTEDNODESPROC));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   ASSERT(ADD_NODES_IN_SORTED_ORDER((PCLIST)hlist));

   bResult = (SearchForNode(hlist, csnp, pcv, phnode) == ANA_FOUND);

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}


/*
** SearchUnsortedList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SearchUnsortedList(HLIST hlist, COMPAREUNSORTEDNODESPROC cunp,
                                    PCVOID pcv, PHNODE phn)
{
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_CODE_PTR(cunp, COMPAREUNSORTEDNODESPROC));
   ASSERT(IS_VALID_WRITE_PTR(phn, HNODE));

   *phn = NULL;

   for (pnode = ((PLIST)hlist)->node.pnodeNext;
        pnode;
        pnode = pnode->pnodeNext)
   {
      if ((*cunp)(pcv, pnode->pcv) == CR_EQUAL)
      {
         *phn = (HNODE)pnode;
         break;
      }
   }

   return(*phn != NULL);
}


/*
** WalkList()
**
** Walks a list, calling a callback function with each list node's data and
** caller supplied data.
**
** Arguments:     hlist - handle to list to be searched
**                wlp - callback function to be called with each list node's
**                      data, called as:
**
**                         bContinue = (*wlwdp)(pv, pvRefData);
**
**                      wlp should return TRUE to continue the walk, or FALSE
**                      to halt the walk
**                pvRefData - data to pass to callback function
**
** Returns:       FALSE if callback function aborted the walk.  TRUE if the
**                walk completed.
**
** N.b., the callback function is allowed to delete the node it is passed.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL WalkList(HLIST hlist, WALKLIST wlp, PVOID pvRefData)
{
   BOOL bResult = TRUE;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_CODE_PTR(wlp, WALKLISTPROC));

   pnode = ((PLIST)hlist)->node.pnodeNext;

   while (pnode)
   {
      PNODE pnodeNext;

      pnodeNext = pnode->pnodeNext;

      if ((*wlp)((PVOID)(pnode->pcv), pvRefData))
         pnode = pnodeNext;
      else
      {
         bResult = FALSE;
         break;
      }
   }

   return(bResult);
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidHLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHLIST(HLIST hlist)
{
   return(IS_VALID_STRUCT_PTR((PLIST)hlist, CLIST));
}


/*
** IsValidHNODE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHNODE(HNODE hnode)
{
   return(IS_VALID_STRUCT_PTR((PNODE)hnode, CNODE));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\list.h ===
/*
 * list.h - List ADT description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HLIST);
DECLARE_STANDARD_TYPES(HLIST);

DECLARE_HANDLE(HNODE);
DECLARE_STANDARD_TYPES(HNODE);

/*
 * sorted list node comparison callback function
 *
 * The first pointer is reference data and the second pointer is a list node
 * data element.
 */

typedef COMPARISONRESULT (*COMPARESORTEDNODESPROC)(PCVOID, PCVOID);

/*
 * unsorted list node comparison callback function
 *
 * The first pointer is reference data and the second pointer is a list node
 * data element.
 */

typedef BOOL (*COMPAREUNSORTEDNODESPROC)(PCVOID, PCVOID);

/*
 * WalkList() callback function - called as:
 *
 *    bContinue = WalkList(pvNodeData, pvRefData);
 */

typedef BOOL (*WALKLIST)(PVOID, PVOID);

/* new list flags */

typedef enum _newlistflags
{
   /* Insert nodes in sorted order. */

   NL_FL_SORTED_ADD        = 0x0001,

   /* flag combinations */

   ALL_NL_FLAGS            = NL_FL_SORTED_ADD
}
NEWLISTFLAGS;

/* new list description */

typedef struct _newlist
{
   DWORD dwFlags;
}
NEWLIST;
DECLARE_STANDARD_TYPES(NEWLIST);


/* Prototypes
 *************/

/* list.c */

extern BOOL CreateList(PCNEWLIST, PHLIST);
extern void DestroyList(HLIST);
extern BOOL AddNode(HLIST, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL InsertNodeAtFront(HLIST, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL InsertNodeBefore(HNODE, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL InsertNodeAfter(HNODE, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern void DeleteNode(HNODE);
extern void DeleteAllNodes(HLIST);
extern PVOID GetNodeData(HNODE);
extern void SetNodeData(HNODE, PCVOID);
extern ULONG GetNodeCount(HLIST);
extern BOOL IsListEmpty(HLIST);
extern BOOL GetFirstNode(HLIST, PHNODE);
extern BOOL GetNextNode(HNODE, PHNODE);
extern BOOL GetPrevNode(HNODE, PHNODE);
extern void AppendList(HLIST, HLIST);
extern BOOL SearchSortedList(HLIST, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL SearchUnsortedList(HLIST, COMPAREUNSORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL WalkList(HLIST, WALKLIST, PVOID);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidHLIST(HLIST);
extern BOOL IsValidHNODE(HNODE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\merge.h ===
/*
 * merge.h - File merge handler module description.
 */


/* Prototypes
 *************/

/* merge.c */

extern void BeginMerge(void);
extern void EndMerge(void);
extern HRESULT MergeHandler(PRECNODE, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND, PRECNODE *);
extern HRESULT MyCreateFileMoniker(LPCTSTR, LPCTSTR, PIMoniker *);
extern void ReleaseIUnknowns(ULONG, PIUnknown *);
extern HRESULT OLECopy(PRECNODE, PCCLSID, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\merge.c ===
/*
 * merge.c - File merge handler module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"
#include "oleutil.h"
#include "irecinit.h"


/* Module Variables
 *******************/

/* lock count for reconciliation handler cache */

PRIVATE_DATA ULONG MulcRecHandlerCacheLock = 0;

/* handle to reconciliation handler cache */

PRIVATE_DATA HCLSIFACECACHE MhcicRecHandlerCache = NULL;


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE HRESULT CreateRecHandlerCache(void);
PRIVATE_CODE void DestroyRecHandlerCache(void);
PRIVATE_CODE HRESULT OLEMerge(PRECNODE, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND, PRECNODE *);
PRIVATE_CODE BOOL GetRecNodeByIndex(PCRECITEM, LONG, PRECNODE *);
PRIVATE_CODE HRESULT CreateMergeSourceMonikers(PRECNODE, PULONG, PIMoniker **);
PRIVATE_CODE HRESULT CreateCopyDestinationMonikers(PCRECITEM, PULONG, PIMoniker **);

#ifdef DEBUG

PRIVATE_CODE BOOL RecHandlerCacheIsOk(void);
PRIVATE_CODE BOOL VerifyRECITEMAndDestRECNODE(PCRECNODE);

#endif


/*
 ** CreateRecHandlerCache()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE HRESULT CreateRecHandlerCache(void)
{
    HRESULT hr;

    ASSERT(RecHandlerCacheIsOk());

    /* Has the merge handler cache already been created? */

    if (MhcicRecHandlerCache)
        /* Yes. */
        hr = S_OK;
    else
    {
        /* No.  Create it. */

        if (CreateClassInterfaceCache(&MhcicRecHandlerCache))
        {
            hr = S_OK;

            TRACE_OUT((TEXT("CreateRecHandlerCache(): Merge handler cache created.")));
        }
        else
            hr = E_OUTOFMEMORY;
    }

    ASSERT(RecHandlerCacheIsOk());

    return(hr);
}


/*
 ** DestroyRecHandlerCache()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DestroyRecHandlerCache(void)
{
    ASSERT(RecHandlerCacheIsOk());

    /* Has the merge handler cache already been created? */

    if (MhcicRecHandlerCache)
    {
        /* Yes.  Destroy it. */

        DestroyClassInterfaceCache(MhcicRecHandlerCache);
        MhcicRecHandlerCache = NULL;

        TRACE_OUT((TEXT("DestroyRecHandlerCache(): Merge handler cache destroyed.")));
    }

    ASSERT(RecHandlerCacheIsOk());

    return;
}


/*
 ** OLEMerge()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE HRESULT OLEMerge(PRECNODE prnDest, RECSTATUSPROC rsp,
        LPARAM lpCallbackData, DWORD dwInFlags,
        HWND hwndOwner, HWND hwndProgressFeedback,
        PRECNODE *pprnMergedResult)
{
    HRESULT hr;
    TCHAR rgchMergeDestPath[MAX_PATH_LEN];
    CLSID clsidReconcilableObject;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(prnDest, CRECNODE));
    ASSERT(! rsp ||
            IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
    ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_RI_FLAGS));
    ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_ALLOW_UI) ||
            IS_VALID_HANDLE(hwndOwner, WND));
    ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
            IS_VALID_HANDLE(hwndProgressFeedback, WND));
    ASSERT(IS_VALID_WRITE_PTR(pprnMergedResult, PRECNODE));

    ComposePath(rgchMergeDestPath, prnDest->pcszFolder, prnDest->priParent->pcszName, 
            ARRAYSIZE(rgchMergeDestPath));
    ASSERT(lstrlen(rgchMergeDestPath) < ARRAYSIZE(rgchMergeDestPath));

    hr = GetReconcilerClassID(rgchMergeDestPath, &clsidReconcilableObject);

    if (SUCCEEDED(hr))
    {
        PIReconcilableObject piro;

        hr = GetClassInterface(MhcicRecHandlerCache, &clsidReconcilableObject,
                &IID_IReconcilableObject, &piro);

        if (SUCCEEDED(hr))
        {
            HSTGIFACE hstgi;

            hr = GetStorageInterface((PIUnknown)piro, &hstgi);

            if (SUCCEEDED(hr))
            {
                hr = LoadFromStorage(hstgi, rgchMergeDestPath);

                if (SUCCEEDED(hr))
                {
                    PIReconcileInitiator pirecinit;

                    hr = IReconcileInitiator_Constructor(
                            GetTwinBriefcase((HTWIN)(prnDest->hObjectTwin)), rsp,
                            lpCallbackData, &pirecinit);

                    if (SUCCEEDED(hr))
                    {
                        ULONG ulcMergeSources;
                        PIMoniker *ppimkMergeSources;

                        hr = CreateMergeSourceMonikers(prnDest, &ulcMergeSources,
                                &ppimkMergeSources);

                        if (SUCCEEDED(hr))
                        {
                            DWORD dwOLEFlags;
                            LONG liMergedResult;

                            dwOLEFlags = (RECONCILEF_NORESIDUESOK |
                                    RECONCILEF_OMITSELFRESIDUE |
                                    RECONCILEF_YOUMAYDOTHEUPDATES);

                            if (IS_FLAG_SET(dwInFlags, RI_FL_ALLOW_UI))
                                SET_FLAG(dwOLEFlags, RECONCILEF_MAYBOTHERUSER);

                            if (IS_FLAG_SET(dwInFlags, RI_FL_FEEDBACK_WINDOW_VALID))
                                SET_FLAG(dwOLEFlags, RECONCILEF_FEEDBACKWINDOWVALID);

                            hr = piro->lpVtbl->Reconcile(piro, pirecinit, dwOLEFlags,
                                    hwndOwner,
                                    hwndProgressFeedback,
                                    ulcMergeSources,
                                    ppimkMergeSources,
                                    &liMergedResult, NULL, NULL);

                            if (SUCCEEDED(hr))
                            {
                                if (hr == REC_S_IDIDTHEUPDATES)
                                {
                                    /* Return original merge destination RECNODE. */

                                    *pprnMergedResult = prnDest;

                                    TRACE_OUT((TEXT("OLEMerge(): IReconcilableObject::Reconcile() returned %s.  Not saving merged result to %s\\%s."),
                                                GetHRESULTString(hr),
                                                prnDest->pcszFolder,
                                                prnDest->priParent->pcszName));
                                }
                                else
                                {
                                    /*
                                     * Only save the merged result if it's different
                                     * than all of the replicas.
                                     */

                                    if (liMergedResult < 0)
                                    {
                                        ASSERT(liMergedResult == -1);

                                        hr = SaveToStorage(hstgi);

                                        if (SUCCEEDED(hr))
                                        {
                                            *pprnMergedResult = prnDest;

                                            TRACE_OUT((TEXT("OLEMerge(): Merge into %s completed successfully."),
                                                        rgchMergeDestPath));
                                        }
                                        else
                                            WARNING_OUT((TEXT("OLEMerge(): Failed to save merged result to %s."),
                                                        rgchMergeDestPath));
                                    }
                                    else if (! liMergedResult)
                                    {
                                        *pprnMergedResult = prnDest;

                                        TRACE_OUT((TEXT("OLEMerge(): Merged result identical to %s."),
                                                    rgchMergeDestPath));
                                    }
                                    else
                                    {
                                        if (GetRecNodeByIndex(prnDest->priParent,
                                                    liMergedResult,
                                                    pprnMergedResult))
                                            TRACE_OUT((TEXT("OLEMerge(): Merged result identical to %s\\%s."),
                                                        (*pprnMergedResult)->pcszFolder,
                                                        (*pprnMergedResult)->priParent->pcszName));
                                        else
                                        {
                                            hr = E_UNEXPECTED;

                                            WARNING_OUT((TEXT("OLEMerge(): Merge handler returned bad merge result index %ld.  No such RECNODE for %s."),
                                                        liMergedResult,
                                                        prnDest->priParent->pcszName));
                                        }
                                    }
                                }
                            }
                            else
                                WARNING_OUT((TEXT("OLEMerge(): Merge to %s failed."),
                                            rgchMergeDestPath));

                            ReleaseIUnknowns(ulcMergeSources,
                                    (PIUnknown *)ppimkMergeSources);
                        }
                        else
                            WARNING_OUT((TEXT("OLEMerge(): Failed to create merge source monikers for merge destination %s."),
                                        rgchMergeDestPath));

                        EVAL(! pirecinit->lpVtbl->Release(pirecinit));
                    }
                    else
                        WARNING_OUT((TEXT("OLEMerge(): Failed to create ReconcileInitiator for merge destination %s."),
                                    rgchMergeDestPath));
                }
                else
                    WARNING_OUT((TEXT("OLEMerge(): Failed to load replica %s from storage."),
                                rgchMergeDestPath));

                ReleaseStorageInterface(hstgi);
            }
            else
                WARNING_OUT((TEXT("OLEMerge(): Failed to get storage interface for replica %s."),
                            rgchMergeDestPath));
        }
        else
            TRACE_OUT((TEXT("OLEMerge(): Failed to get IReconcilableObject for replica %s."),
                        rgchMergeDestPath));
    }
    else
        TRACE_OUT((TEXT("OLEMerge(): Failed to get reconciliation handler class ID for replica %s."),
                    rgchMergeDestPath));

    ASSERT(FAILED(hr) ||
            (IS_VALID_STRUCT_PTR(*pprnMergedResult, CRECNODE) &&
             (*pprnMergedResult)->priParent == prnDest->priParent));

    return(hr);
}


/*
 ** GetRecNodeByIndex()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** The first RECNODE in the RECITEM's list of RECNODEs is index 1, the second
 ** RECNODE is index 2, etc.
 */
PRIVATE_CODE BOOL GetRecNodeByIndex(PCRECITEM pcri, LONG li, PRECNODE *pprn)
{
    BOOL bFound;

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
    ASSERT(IS_VALID_WRITE_PTR(pprn, PRECNODE));

    if (EVAL(li > 0))
    {
        PRECNODE prn;

        for (prn = pcri->prnFirst; prn && --li > 0; prn = prn->prnNext)
            ;

        bFound = EVAL(prn && ! li);

        if (bFound)
            *pprn = prn;
    }
    else
        bFound = FALSE;

    ASSERT(! bFound ||
            (IS_VALID_STRUCT_PTR(*pprn, CRECNODE) &&
             (*pprn)->priParent == pcri));

    return(bFound);
}


/*
 ** CreateMergeSourceMonikers()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE HRESULT CreateMergeSourceMonikers(PRECNODE prnDest,
        PULONG pulcMergeSources,
        PIMoniker **pppimk)
{
    HRESULT hr;
    ULONG ulcMergeSources;
    PCRECNODE pcrn;

    ASSERT(IS_VALID_STRUCT_PTR(prnDest, CRECNODE));
    ASSERT(IS_VALID_WRITE_PTR(pulcMergeSources, ULONG));
    ASSERT(IS_VALID_WRITE_PTR(pppimk, PIMoniker *));

    ulcMergeSources = 0;

    for (pcrn = prnDest->priParent->prnFirst; pcrn; pcrn = pcrn->prnNext)
    {
        if (pcrn->rnaction == RNA_MERGE_ME &&
                pcrn != prnDest)
            ulcMergeSources++;
    }

    if (AllocateMemory(ulcMergeSources * sizeof(**pppimk), (PVOID *)pppimk))
    {
        hr = S_OK;
        *pulcMergeSources = 0;

        for (pcrn = prnDest->priParent->prnFirst; pcrn; pcrn = pcrn->prnNext)
        {
            if (pcrn->rnaction == RNA_MERGE_ME &&
                    pcrn != prnDest)
            {
                hr = MyCreateFileMoniker(pcrn->pcszFolder,
                        pcrn->priParent->pcszName,
                        &((*pppimk)[*pulcMergeSources]));

                if (SUCCEEDED(hr))
                {
                    ASSERT(*pulcMergeSources < ulcMergeSources);
                    (*pulcMergeSources)++;
                }
                else
                    break;
            }
        }

        if (FAILED(hr))
            ReleaseIUnknowns(*pulcMergeSources, *(PIUnknown **)pppimk);
    }
    else
        hr = E_OUTOFMEMORY;

    return(hr);
}


/*
 ** CreateCopyDestinationMonikers()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE HRESULT CreateCopyDestinationMonikers(PCRECITEM pcri,
        PULONG pulcCopyDestinations,
        PIMoniker **pppimk)
{
    HRESULT hr;
    ULONG ulcCopyDestinations;
    PCRECNODE pcrn;

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
    ASSERT(IS_VALID_WRITE_PTR(pulcCopyDestinations, ULONG));
    ASSERT(IS_VALID_WRITE_PTR(pppimk, PIMoniker *));

    ulcCopyDestinations = 0;

    for (pcrn = pcri->prnFirst; pcrn; pcrn = pcrn->prnNext)
    {
        if (pcrn->rnaction == RNA_COPY_TO_ME)
            ulcCopyDestinations++;
    }

    if (AllocateMemory(ulcCopyDestinations * sizeof(**pppimk), (PVOID *)pppimk))
    {
        hr = S_OK;
        *pulcCopyDestinations = 0;

        for (pcrn = pcri->prnFirst; pcrn; pcrn = pcrn->prnNext)
        {
            if (pcrn->rnaction == RNA_COPY_TO_ME)
            {
                ASSERT(pcrn->priParent == pcri);

                hr = MyCreateFileMoniker(pcrn->pcszFolder,
                        pcrn->priParent->pcszName,
                        &((*pppimk)[*pulcCopyDestinations]));

                if (SUCCEEDED(hr))
                {
                    ASSERT(*pulcCopyDestinations < ulcCopyDestinations);
                    (*pulcCopyDestinations)++;
                }
                else
                    break;
            }
        }

        if (FAILED(hr))
            ReleaseIUnknowns(*pulcCopyDestinations, *(PIUnknown **)pppimk);
    }
    else
        hr = E_OUTOFMEMORY;

    return(hr);
}


#ifdef DEBUG

/*
 ** RecHandlerCacheIsOk()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL RecHandlerCacheIsOk(void)
{
    /* Are the module merge handler cache variables in a correct state? */

    return(! MhcicRecHandlerCache ||
            IS_VALID_HANDLE(MhcicRecHandlerCache, CLSIFACECACHE));
}


/*
 ** VerifyRECITEMAndDestRECNODE()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL VerifyRECITEMAndDestRECNODE(PCRECNODE pcrnSrc)
{
    /* Do the RECITEM and source RECNODE actions match? */

    return(pcrnSrc->priParent->riaction == RIA_MERGE &&
            pcrnSrc->rnaction == RNA_MERGE_ME);
}

#endif


/****************************** Public Functions *****************************/


/*
 ** BeginMerge()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void BeginMerge(void)
{
    ASSERT(RecHandlerCacheIsOk());

    ASSERT(MulcRecHandlerCacheLock < ULONG_MAX);
    MulcRecHandlerCacheLock++;

    ASSERT(RecHandlerCacheIsOk());

    return;
}


/*
 ** EndMerge()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void EndMerge(void)
{
    ASSERT(RecHandlerCacheIsOk());

    /* Is the merge handler cache still locked? */

    if (! --MulcRecHandlerCacheLock)
        DestroyRecHandlerCache();

    ASSERT(RecHandlerCacheIsOk());

    return;
}


/*
 ** MergeHandler()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HRESULT MergeHandler(PRECNODE prnDest, RECSTATUSPROC rsp,
        LPARAM lpCallbackData, DWORD dwInFlags,
        HWND hwndOwner, HWND hwndProgressFeedback,
        PRECNODE *pprnMergedResult)
{
    HRESULT hr;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(prnDest, CRECNODE));
    ASSERT(! rsp ||
            IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
    ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_RI_FLAGS));
    ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_ALLOW_UI) ||
            IS_VALID_HANDLE(hwndOwner, WND));
    ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
            IS_VALID_HANDLE(hwndProgressFeedback, WND));
    ASSERT(IS_VALID_WRITE_PTR(pprnMergedResult, PRECNODE));

    ASSERT(VerifyRECITEMAndDestRECNODE(prnDest));

    BeginMerge();

    /* Make sure the merge handler cache has been created. */

    hr = CreateRecHandlerCache();

    if (SUCCEEDED(hr))
    {
        RECSTATUSUPDATE rsu;

        /* 0% complete. */

        rsu.ulScale = 1;
        rsu.ulProgress = 0;

        if (NotifyReconciliationStatus(rsp, RS_BEGIN_MERGE, (LPARAM)&rsu,
                    lpCallbackData))
        {
            hr = OLEMerge(prnDest, rsp, lpCallbackData, dwInFlags, hwndOwner,
                    hwndProgressFeedback, pprnMergedResult);

            if (SUCCEEDED(hr))
            {
                /* 100% complete. */

                rsu.ulScale = 1;
                rsu.ulProgress = 1;

                /* Don't allow abort. */

                NotifyReconciliationStatus(rsp, RS_END_MERGE, (LPARAM)&rsu,
                        lpCallbackData);
            }
        }
        else
            hr = E_ABORT;
    }

    EndMerge();

    ASSERT(FAILED(hr) ||
            (IS_VALID_STRUCT_PTR(*pprnMergedResult, CRECNODE) &&
             (*pprnMergedResult)->priParent == prnDest->priParent));

    return(hr);
}


/*
 ** MyCreateFileMoniker()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HRESULT MyCreateFileMoniker(LPCTSTR pcszPath, LPCTSTR pcszSubPath,
        PIMoniker *ppimk)
{
    HRESULT hr;
    TCHAR rgchPath[MAX_PATH_LEN];
    WCHAR rgwchUnicodePath[MAX_PATH_LEN];

    ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(ppimk, PIMoniker));

    ComposePath(rgchPath, pcszPath, pcszSubPath, ARRAYSIZE(rgchPath));
    ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

#ifdef UNICODE

    hr = CreateFileMoniker(rgchPath, ppimk);

#else

    /* Translate ANSI string into Unicode for OLE. */

    if (MultiByteToWideChar(CP_ACP, 0, rgchPath, -1, rgwchUnicodePath,
                ARRAY_ELEMENTS(rgwchUnicodePath)))
    {
        hr = CreateFileMoniker(rgwchUnicodePath, ppimk);
    }
    else
    {
        hr = MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
    }

#endif

    if (FAILED(hr))
        WARNING_OUT((TEXT("MyCreateFileMoniker(): CreateFileMoniker() on %s failed, returning %s."),
                    pcszPath,
                    GetHRESULTString(hr)));

    return(hr);
}


/*
 ** ReleaseIUnknowns()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void ReleaseIUnknowns(ULONG ulcIUnknowns, PIUnknown *ppiunk)
{
    ULONG uli;

    /* ulcIUnknowns may be any value. */

    ASSERT(IS_VALID_READ_BUFFER_PTR(ppiunk, PIUnknown, ulcIUnknowns * sizeof(*ppiunk)));

    for (uli = 0; uli < ulcIUnknowns; uli++)
    {
        ASSERT(IS_VALID_STRUCT_PTR(ppiunk[uli], CIUnknown));

        ppiunk[uli]->lpVtbl->Release(ppiunk[uli]);
    }

    FreeMemory(ppiunk);

    return;
}


/*
 ** OLECopy()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HRESULT OLECopy(PRECNODE prnSrc, PCCLSID pcclsidReconcilableObject,
        RECSTATUSPROC rsp, LPARAM lpCallbackData,
        DWORD dwFlags, HWND hwndOwner,
        HWND hwndProgressFeedback)
{
    HRESULT hr;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(prnSrc, CRECNODE));
    ASSERT(IS_VALID_STRUCT_PTR(pcclsidReconcilableObject, CCLSID));
    ASSERT(! rsp ||
            IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
    ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_RI_FLAGS));
    ASSERT(IS_FLAG_CLEAR(dwFlags, RI_FL_ALLOW_UI) ||
            IS_VALID_HANDLE(hwndOwner, WND));
    ASSERT(IS_FLAG_CLEAR(dwFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
            IS_VALID_HANDLE(hwndProgressFeedback, WND));

    BeginMerge();

    /* Make sure the merge handler cache has been created. */

    hr = CreateRecHandlerCache();

    if (SUCCEEDED(hr))
    {
        TCHAR rgchCopySrcPath[MAX_PATH_LEN];
        PIReconcilableObject piro;

        ComposePath(rgchCopySrcPath, prnSrc->pcszFolder, prnSrc->priParent->pcszName, 
                ARRAYSIZE(rgchCopySrcPath));
        ASSERT(lstrlen(rgchCopySrcPath) < ARRAYSIZE(rgchCopySrcPath));

        hr = GetClassInterface(MhcicRecHandlerCache, pcclsidReconcilableObject,
                &IID_IReconcilableObject, &piro);

        if (SUCCEEDED(hr))
        {
            HSTGIFACE hstgi;

            hr = GetStorageInterface((PIUnknown)piro, &hstgi);

            if (SUCCEEDED(hr))
            {
                hr = LoadFromStorage(hstgi, rgchCopySrcPath);

                if (SUCCEEDED(hr))
                {
                    PIReconcileInitiator pirecinit;

                    hr = IReconcileInitiator_Constructor(
                            GetTwinBriefcase((HTWIN)(prnSrc->hObjectTwin)), rsp,
                            lpCallbackData, &pirecinit);

                    if (SUCCEEDED(hr))
                    {
                        ULONG ulcCopyDestinations;
                        PIMoniker *ppimkCopyDestinations;

                        hr = CreateCopyDestinationMonikers(prnSrc->priParent,
                                &ulcCopyDestinations,
                                &ppimkCopyDestinations);

                        if (SUCCEEDED(hr))
                        {
                            DWORD dwOLEFlags;
                            LONG liMergedResult;

                            dwOLEFlags = (RECONCILEF_YOUMAYDOTHEUPDATES |
                                    RECONCILEF_ONLYYOUWERECHANGED);

                            if (IS_FLAG_SET(dwFlags, RI_FL_ALLOW_UI))
                                SET_FLAG(dwOLEFlags, RECONCILEF_MAYBOTHERUSER);

                            if (IS_FLAG_SET(dwFlags, RI_FL_FEEDBACK_WINDOW_VALID))
                                SET_FLAG(dwOLEFlags, RECONCILEF_FEEDBACKWINDOWVALID);

                            hr = piro->lpVtbl->Reconcile(piro, pirecinit, dwOLEFlags,
                                    hwndOwner,
                                    hwndProgressFeedback,
                                    ulcCopyDestinations,
                                    ppimkCopyDestinations,
                                    &liMergedResult, NULL, NULL);

                            if (SUCCEEDED(hr))
                            {
                                ASSERT(liMergedResult == -1);

                                if (hr == S_FALSE)
                                    /* Release storage for internal copy routine. */
                                    HandsOffStorage(hstgi);
                                else
                                    ASSERT(hr == REC_S_IDIDTHEUPDATES);
                            }
                            else
                                WARNING_OUT((TEXT("OLECopy(): Copy from %s failed."),
                                            rgchCopySrcPath));

                            ReleaseIUnknowns(ulcCopyDestinations,
                                    (PIUnknown *)ppimkCopyDestinations);
                        }
                        else
                            WARNING_OUT((TEXT("OLECopy(): Failed to create copy destination monikers for copy source %s."),
                                        rgchCopySrcPath));

                        EVAL(! pirecinit->lpVtbl->Release(pirecinit));
                    }
                    else
                        WARNING_OUT((TEXT("OLECopy(): Failed to create ReconcileInitiator for copy source %s."),
                                    rgchCopySrcPath));
                }
                else
                    WARNING_OUT((TEXT("OLECopy(): Failed to load copy source %s from storage."),
                                rgchCopySrcPath));

                ReleaseStorageInterface(hstgi);
            }
            else
                WARNING_OUT((TEXT("OLECopy(): Failed to get storage interface for copy source %s."),
                            rgchCopySrcPath));
        }
        else
            TRACE_OUT((TEXT("OLECopy(): Failed to get reconciliation handler class ID for replica %s."),
                        rgchCopySrcPath));
    }

    EndMerge();

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\memmgr.h ===
/*
 * memmgr.h - Memory manager module description.
 */


/* Macros
 *********/

#ifdef DEBUG
#define AllocateMemory(size, ppv)   (GpcszElemHdrSize = TEXT(#size), GpcszElemHdrFile = TEXT(__FILE__), GulElemHdrLine = __LINE__, MyAllocateMemory(size, ppv))
#else
#define AllocateMemory(size, ppv)   MyAllocateMemory(size, ppv)
#endif   /* DEBUG */


/* Types
 ********/

#ifdef DEBUG

/* SpewHeapSummary() flags */

typedef enum _spewheapsummaryflags
{
   /* Spew description of each remaining used element. */

   SHS_FL_SPEW_USED_INFO            = 0x0001,

   /* flag combinations */

   ALL_SHS_FLAGS                    = SHS_FL_SPEW_USED_INFO
}
SPEWHEAPSUMMARYFLAGS;

#endif


/* Prototypes
 *************/

/* memmgr.c */

extern BOOL InitMemoryManagerModule(void);
extern void ExitMemoryManagerModule(void);

extern COMPARISONRESULT MyMemComp(PCVOID, PCVOID, DWORD);
extern BOOL MyAllocateMemory(DWORD, PVOID *);
extern void FreeMemory(PVOID);
extern BOOL ReallocateMemory(PVOID, DWORD, PVOID *);
extern DWORD GetMemorySize(PVOID);

#ifdef DEBUG

extern BOOL SetMemoryManagerModuleIniSwitches(void);
extern void SpewHeapSummary(DWORD);

#endif


/* Global Variables
 *******************/

#ifdef DEBUG

/* parameters used by debug version of AllocateMemory() */

extern LPCTSTR GpcszElemHdrSize;
extern LPCTSTR GpcszElemHdrFile;
extern ULONG GulElemHdrLine;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\memmgr.c ===
/*
 * memmgr.c - Memory manager module.
 */

/*

   The memory manager implementation in this module uses either a private
shared heap (if PRIVATE_HEAP is #defined) or the non-shared process heap (if
PRIVATE_HEAP is not #defined).  Thde debug implementation of this memory
manager keeps track of memory blocks allocated from the heap using a
doubly-linked list of heap element nodes.  Each node describes one allocated
heap element.

   Debug heap elements are allocated with extra space at the beginning and end
of the element.  Prefix and suffix sentinels surround each allocated heap
element.  New heap elements are filled with UNINITIALIZED_BYTE_VALUE.  Freed
heap elements are filled with FREED_BYTE_VALUE.  The new tails of grown heap
elements are filled with UNINITIALIZED_BYTE_VALUE.

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Constants
 ************/

#ifdef PRIVATE_HEAP

/* undocumented flag for HeapCreate() from kernel32.h */


#define HEAP_SHARED                 (0x04000000)

/*
 * Set maximum shared heap size used for CreateHeap() to 0 since we don't know
 * how big the heap may get, and we don't want to restrict its size
 * artificially.  BrianSm says this is ok.
 */

#define MAX_SHARED_HEAP_SIZE        (0)

#endif   /* PRIVATE_HEAP */

#ifdef DEBUG

/* heap element byte fill values */

#define UNINITIALIZED_BYTE_VALUE    (0xcc)
#define FREED_BYTE_VALUE            (0xdd)

#endif   /* DEBUG */


/* Macros
 *********/

/* atomic memory management function wrappers for translation */

#ifdef PRIVATE_HEAP

#define GetHeap()                   (Mhheap)
#define MEMALLOCATE(size)           HeapAlloc(GetHeap(), 0, (size))
#define MEMREALLOCATE(pv, size)     HeapReAlloc(GetHeap(), 0, (pv), (size))
#define MEMFREE(pv)                 HeapFree(GetHeap(), 0, (pv))
#define MEMSIZE(pv)                 (DWORD)HeapSize(GetHeap(), 0, (pv))

#else

#define MEMALLOCATE(size)           LocalAlloc(LMEM_FIXED, (size))
#define MEMREALLOCATE(pv, size)     LocalReAlloc((pv), (size), 0)
#define MEMFREE(pv)                 (! LocalFree(pv))
#define MEMSIZE(pv)                 (DWORD)LocalSize(pv)

#endif


/* Types
 ********/

#ifdef DEBUG

/* heap element descriptor structure */

typedef struct _heapelemdesc
{
   TCHAR rgchSize[6];       /* enough for 99,999 lines */
   TCHAR rgchFile[24];      
   ULONG ulLine;
}
HEAPELEMDESC;
DECLARE_STANDARD_TYPES(HEAPELEMDESC);

/* heap node */

typedef struct _heapnode
{
   PCVOID pcv;
   DWORD dwcbSize;
   struct _heapnode *phnPrev;
   struct _heapnode *phnNext;
   HEAPELEMDESC hed;
}
HEAPNODE;
DECLARE_STANDARD_TYPES(HEAPNODE);

/* heap */

typedef struct _heap
{
   HEAPNODE hnHead;
}
HEAP;
DECLARE_STANDARD_TYPES(HEAP);

/* heap summary filled in by AnalyzeHeap() */

typedef struct _heapsummary
{
   ULONG ulcUsedElements;
   DWORD dwcbUsedSize;
}
HEAPSUMMARY;
DECLARE_STANDARD_TYPES(HEAPSUMMARY);

/* debug flags */

typedef enum _memmgrdebugflags
{
   MEMMGR_DFL_VALIDATE_HEAP_ON_ENTRY   = 0x0001,

   MEMMGR_DFL_VALIDATE_HEAP_ON_EXIT    = 0x0002,

   ALL_MEMMGR_DFLAGS                   = (MEMMGR_DFL_VALIDATE_HEAP_ON_ENTRY |
                                          MEMMGR_DFL_VALIDATE_HEAP_ON_EXIT)
}
MEMMGRDEBUGFLAGS;

#endif   /* DEBUG */


/* Global Variables
 *******************/

#ifdef DEBUG

/* parameters used by debug AllocateMemory() macro */

PUBLIC_DATA LPCTSTR GpcszElemHdrSize = NULL;
PUBLIC_DATA LPCTSTR GpcszElemHdrFile = NULL;
PUBLIC_DATA ULONG GulElemHdrLine = 0;

#endif   /* DEBUG */


/* Module Variables
 *******************/

#ifdef PRIVATE_HEAP

/* handle to global shared heap */

PRIVATE_DATA HANDLE Mhheap = NULL;

#endif   /* PRIVATE_HEAP */

#ifdef DEBUG

/* heap */

PRIVATE_DATA PHEAP Mpheap = NULL;

/* debug flags */

PRIVATE_DATA DWORD MdwMemoryManagerModuleFlags = 0;

/* heap element sentinels */

PRIVATE_DATA CONST struct
{
   BYTE rgbyte[4];
}
MchsPrefix =
{
   { TEXT('H'), TEXT('E'), TEXT('A'), TEXT('D') }
};

PRIVATE_DATA CONST struct
{
   BYTE rgbyte[4];
}
MchsSuffix =
{
   { TEXT('T'), TEXT('A'), TEXT('I'), TEXT('L') }
};

/* .ini file switch descriptions */

PRIVATE_DATA CBOOLINISWITCH cbisValidateHeapOnEntry =
{
   IST_BOOL,
   TEXT("ValidateHeapOnEntry"),
   &MdwMemoryManagerModuleFlags,
   MEMMGR_DFL_VALIDATE_HEAP_ON_ENTRY
};

PRIVATE_DATA CBOOLINISWITCH cbisValidateHeapOnExit =
{
   IST_BOOL,
   TEXT("ValidateHeapOnExit"),
   &MdwMemoryManagerModuleFlags,
   MEMMGR_DFL_VALIDATE_HEAP_ON_EXIT
};

PRIVATE_DATA const PCVOID MrgcpcvisMemoryManagerModule[] =
{
   &cbisValidateHeapOnEntry,
   &cbisValidateHeapOnExit
};

#endif   /* DEBUG */


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE DWORD CalculatePrivateSize(DWORD);
PRIVATE_CODE PVOID GetPrivateHeapPtr(PVOID);
PRIVATE_CODE PVOID GetPublicHeapPtr(PVOID);
PRIVATE_CODE DWORD GetHeapSize(PCVOID);
PRIVATE_CODE BOOL AddHeapElement(PCVOID, DWORD);
PRIVATE_CODE void RemoveHeapElement(PCVOID);
PRIVATE_CODE void ModifyHeapElement(PCVOID, PCVOID, DWORD);
PRIVATE_CODE BOOL FindHeapElement(PCVOID, PHEAPNODE *);
PRIVATE_CODE void FillNewMemory(PBYTE, DWORD, DWORD);
PRIVATE_CODE void FillFreedMemory(PBYTE, DWORD);
PRIVATE_CODE void FillGrownMemory(PBYTE, DWORD, DWORD, DWORD);
PRIVATE_CODE void FillShrunkenMemory(PBYTE, DWORD, DWORD, DWORD);
PRIVATE_CODE BOOL IsValidHeapPtr(PCVOID);
PRIVATE_CODE BOOL IsHeapOK(void);
PRIVATE_CODE BOOL IsValidPCHEAPNODE(PCHEAPNODE);
PRIVATE_CODE BOOL IsValidPCHEAPELEMDESC(PCHEAPELEMDESC);
PRIVATE_CODE BOOL IsValidHeapElement(PCBYTE, DWORD, DWORD);
PRIVATE_CODE void SpewHeapElementInfo(PCHEAPNODE);
PRIVATE_CODE void AnalyzeHeap(PHEAPSUMMARY, DWORD);

#endif   /* DEBUG */


#ifdef PRIVATE_HEAP

/*
** InitPrivateHeapModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL InitPrivateHeapModule(void)
{
   BOOL bResult;
   SYSTEM_INFO si;

   ASSERT(! Mhheap);

   /* Create shared heap. */

   GetSystemInfo(&si);

   Mhheap = HeapCreate(0, si.dwPageSize, MAX_SHARED_HEAP_SIZE);

   if (Mhheap)
   {

#ifdef DEBUG

      ASSERT(! Mpheap);

      Mpheap = MEMALLOCATE(sizeof(*Mpheap));
      
      if (Mpheap)
      {
         FillMemory(Mpheap, sizeof(*Mpheap), 0);
         bResult = TRUE;

         TRACE_OUT((TEXT("InitMemoryManagerModule(): Created shared heap, initial size == %lu, maximum size == %lu."),
                    si.dwPageSize,
                    MAX_SHARED_HEAP_SIZE));
      }
      else
      {
         EVAL(HeapDestroy(Mhheap));
         Mhheap = NULL;
         bResult = FALSE;

         WARNING_OUT((TEXT("InitMemoryManagerModule(): Failed to create shared heap head.")));
      }

#else    /* DEBUG */

      bResult = TRUE;

#endif   /* DEBUG */
         
   }
   else
   {
      bResult = FALSE;

      WARNING_OUT((TEXT("InitMemoryManagerModule(): Failed to create shared heap.")));
   }

   return(bResult);
}


#else    /* PRIVATE_HEAP */


/*
** InitHeapModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL InitHeapModule(void)
{
   BOOL bResult;

#ifdef DEBUG

   ASSERT(! Mpheap);

   Mpheap = MEMALLOCATE(sizeof(*Mpheap));
   
   if (Mpheap)
   {
      FillMemory(Mpheap, sizeof(*Mpheap), 0);

      TRACE_OUT((TEXT("InitMemoryManagerModule(): Created heap.")));
   }
   else
      WARNING_OUT((TEXT("InitMemoryManagerModule(): Failed to create heap head.")));
         
   bResult = (Mpheap != NULL);

#else

   bResult = TRUE;

#endif

   return(bResult);
}


#endif   /* PRIVATE_HEAP */


#ifdef DEBUG

/*
** CalculatePrivateSize()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE DWORD CalculatePrivateSize(DWORD dwcbPublicSize)
{
   ASSERT(dwcbPublicSize <= DWORD_MAX - sizeof(MchsPrefix) - sizeof(MchsSuffix));

   return(dwcbPublicSize + sizeof(MchsPrefix) + sizeof(MchsSuffix));
}


/*
** GetPrivateHeapPtr()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE PVOID GetPrivateHeapPtr(PVOID pvPublic)
{
   ASSERT((ULONG_PTR)pvPublic > sizeof(MchsPrefix));

   return((PBYTE)pvPublic - sizeof(MchsPrefix));
}


/*
** GetPublicHeapPtr()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE PVOID GetPublicHeapPtr(PVOID pvPrivate)
{
   ASSERT((PCBYTE)pvPrivate <= (PCBYTE)PTR_MAX - sizeof(MchsPrefix));

   return((PBYTE)pvPrivate + sizeof(MchsPrefix));
}


/*
** GetHeapSize()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE DWORD GetHeapSize(PCVOID pcv)
{
   PHEAPNODE phn;
   DWORD dwcbSize;

   if (EVAL(FindHeapElement(pcv, &phn)))
      dwcbSize = phn->dwcbSize;
   else
      dwcbSize = 0;

   return(dwcbSize);
}


/*
** AddHeapElement()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Assumes that the global variables GpcszElemHdrSize, GpcszElemHdrFile, and
** GulElemHdrLine are filled in.
*/
PRIVATE_CODE BOOL AddHeapElement(PCVOID pcvNew, DWORD dwcbSize)
{
   PHEAPNODE phnNew;

   /* Is the new heap element already in the list? */

   ASSERT(! FindHeapElement(pcvNew, &phnNew));

   if (Mpheap)
   {
      /* Create new heap node. */

      phnNew = MEMALLOCATE(sizeof(*phnNew));

      if (phnNew)
      {
         /* Fill in heap node fields. */

         phnNew->pcv = pcvNew;
         phnNew->dwcbSize = dwcbSize;

         /* Insert heap node at front of list. */

         phnNew->phnNext = Mpheap->hnHead.phnNext;
         phnNew->phnPrev = &(Mpheap->hnHead);
         Mpheap->hnHead.phnNext = phnNew;

         if (phnNew->phnNext)
            phnNew->phnNext->phnPrev = phnNew;

         /* Fill in heap element descriptor fields. */

         MyLStrCpyN(phnNew->hed.rgchSize, GpcszElemHdrSize, ARRAYSIZE(phnNew->hed.rgchSize));
         MyLStrCpyN(phnNew->hed.rgchFile, GpcszElemHdrFile, ARRAYSIZE(phnNew->hed.rgchFile));
         phnNew->hed.ulLine = GulElemHdrLine;

         ASSERT(IS_VALID_STRUCT_PTR(phnNew, CHEAPNODE));
      }
   }
   else
      phnNew = NULL;

   return(phnNew != NULL);
}


/*
** RemoveHeapElement()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void RemoveHeapElement(PCVOID pcvOld)
{
   PHEAPNODE phnOld;

   if (EVAL(FindHeapElement(pcvOld, &phnOld)))
   {
      /* Remove heap node from list. */

      phnOld->phnPrev->phnNext = phnOld->phnNext;

      if (phnOld->phnNext)
         phnOld->phnNext->phnPrev = phnOld->phnPrev;

      MEMFREE(phnOld);
   }

   return;
}


/*
** ModifyHeapElement()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void ModifyHeapElement(PCVOID pcvOld, PCVOID pcvNew, DWORD dwcbNewSize)
{
   PHEAPNODE phn;

   if (EVAL(FindHeapElement(pcvOld, &phn)))
   {
      phn->pcv = pcvNew;
      phn->dwcbSize = dwcbNewSize;
   }

   return;
}


/*
** FindHeapElement()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FindHeapElement(PCVOID pcvTarget, PHEAPNODE *pphn)
{
   BOOL bFound = FALSE;
   PHEAPNODE phn;

   ASSERT(IS_VALID_WRITE_PTR(pphn, PHEAPNODE));

   if (Mpheap)
   {
      for (phn = Mpheap->hnHead.phnNext;
           phn;
           phn = phn->phnNext)
      {
         /*
          * Verify each HEAPNODE structure carefully.  We may be in the middle of
          * a ModifyHeapElement() call, in which case just the target HEAPNODE may
          * be invalid, e.g., after MEMREALLOCATE() in ReallocateMemory().
          */

         ASSERT((IS_VALID_READ_PTR(phn, CHEAPNODE) && phn->pcv == pcvTarget) ||
                IS_VALID_STRUCT_PTR(phn, CHEAPNODE));

         if (phn->pcv == pcvTarget)
         {
            *pphn = phn;
            bFound = TRUE;
            break;
         }
      }
   }

   return(bFound);
}


/*
** FillNewMemory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void FillNewMemory(PBYTE pbyte, DWORD dwcbRequestedSize,
                           DWORD dwcbAllocatedSize)
{
   ASSERT(dwcbRequestedSize >= sizeof(MchsPrefix) + sizeof(MchsSuffix));
   ASSERT(dwcbAllocatedSize >= dwcbRequestedSize);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pbyte, BYTE, (UINT)dwcbAllocatedSize));

   /* Fill new heap element with the uninitialized byte value. */

   FillMemory(pbyte, dwcbAllocatedSize, UNINITIALIZED_BYTE_VALUE);

   /* Copy prefix and suffix heap element sentinels. */

   CopyMemory(pbyte, &MchsPrefix, sizeof(MchsPrefix));
   CopyMemory(pbyte + dwcbRequestedSize - sizeof(MchsSuffix), &MchsSuffix,
              sizeof(MchsSuffix));

   return;
}


/*
** FillFreedMemory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void FillFreedMemory(PBYTE pbyte, DWORD dwcbAllocatedSize)
{
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pbyte, BYTE, (UINT)dwcbAllocatedSize));

   /* Fill old heap element with the freed byte value. */

   FillMemory(pbyte, dwcbAllocatedSize, FREED_BYTE_VALUE);

   return;
}


/*
** FillGrownMemory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void FillGrownMemory(PBYTE pbyte, DWORD dwcbOldRequestedSize,
                             DWORD dwcbNewRequestedSize,
                             DWORD dwcbNewAllocatedSize)
{
   ASSERT(dwcbOldRequestedSize >= sizeof(MchsPrefix) + sizeof(MchsSuffix));
   ASSERT(dwcbNewRequestedSize > dwcbOldRequestedSize);
   ASSERT(dwcbNewAllocatedSize >= dwcbNewRequestedSize);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pbyte, BYTE, (UINT)dwcbNewAllocatedSize));

   ASSERT(MyMemComp(pbyte, &MchsPrefix, sizeof(MchsPrefix)) == CR_EQUAL);

   /* Fill new heap element tail with the uninitialized byte value. */

   FillMemory(pbyte + dwcbOldRequestedSize - sizeof(MchsSuffix),
              dwcbNewRequestedSize - dwcbOldRequestedSize,
              UNINITIALIZED_BYTE_VALUE);

   /* Copy suffix heap element sentinel. */

   CopyMemory(pbyte + dwcbNewRequestedSize - sizeof(MchsSuffix), &MchsSuffix,
              sizeof(MchsSuffix));

   return;
}


/*
** FillShrunkenMemory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void FillShrunkenMemory(PBYTE pbyte, DWORD dwcbOldRequestedSize,
                                DWORD dwcbNewRequestedSize,
                                DWORD dwcbNewAllocatedSize)
{
   ASSERT(dwcbNewRequestedSize >= sizeof(MchsPrefix) + sizeof(MchsSuffix));
   ASSERT(dwcbNewRequestedSize < dwcbOldRequestedSize);
   ASSERT(dwcbNewAllocatedSize >= dwcbNewRequestedSize);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pbyte, BYTE, (UINT)dwcbNewAllocatedSize));

   ASSERT(MyMemComp(pbyte, &MchsPrefix, sizeof(MchsPrefix)) == CR_EQUAL);

   /* Fill old heap element tail with the freed byte value. */

   FillMemory(pbyte + dwcbNewRequestedSize,
              dwcbOldRequestedSize - dwcbNewRequestedSize, FREED_BYTE_VALUE);

   /* Copy suffix heap element sentinel. */

   CopyMemory(pbyte + dwcbNewRequestedSize - sizeof(MchsSuffix), &MchsSuffix,
              sizeof(MchsSuffix));

   return;
}


/*
** IsValidHeapPtr()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidHeapPtr(PCVOID pcv)
{
   PHEAPNODE phnUnused;

   return(FindHeapElement(pcv, &phnUnused));
}


/*
** IsHeapOK()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsHeapOK(void)
{
   PHEAPNODE phn;

   if (Mpheap)
   {
      for (phn = Mpheap->hnHead.phnNext;
           phn && IS_VALID_STRUCT_PTR(phn, CHEAPNODE);
           phn = phn->phnNext)
         ;
   }
   else
      phn = (PHEAPNODE)0xFFFF;

   return(phn == NULL);
}


/*
** IsValidPCHEAPNODE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCHEAPNODE(PCHEAPNODE pchn)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pchn, CHEAPNODE) &&
       IS_VALID_READ_PTR(pchn->phnPrev, CHEAPNODE) &&
       EVAL(pchn->phnPrev->phnNext == pchn) &&
       EVAL(! pchn->phnNext ||
            (IS_VALID_READ_PTR(pchn->phnNext, CHEAPNODE) &&
             EVAL(pchn->phnNext->phnPrev == pchn))) &&
       EVAL(IsValidHeapElement(pchn->pcv, pchn->dwcbSize, MEMSIZE((PVOID)(pchn->pcv)))) &&
       IS_VALID_STRUCT_PTR(&(pchn->hed), CHEAPELEMDESC))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}


/*
** IsValidPCHEAPELEMDESC()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCHEAPELEMDESC(PCHEAPELEMDESC pched)
{
   BOOL bResult;

   /* Any value for pched->ulLine is valid. */

   if (IS_VALID_READ_PTR(pched, CHEAPELEMDESC))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}


/*
** IsValidHeapElement()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidHeapElement(PCBYTE pcbyte, DWORD dwcbRequestedSize,
                                DWORD dwcbAllocatedSize)
{
   BOOL bResult;

   if (EVAL(dwcbRequestedSize >= sizeof(MchsPrefix) + sizeof(MchsSuffix)) &&
       EVAL(dwcbAllocatedSize >= dwcbRequestedSize) &&
       IS_VALID_READ_PTR(pcbyte, dwcbAllocatedSize) &&
       EVAL(MyMemComp(pcbyte, &MchsPrefix, sizeof(MchsPrefix)) == CR_EQUAL) &&
       EVAL(MyMemComp(pcbyte + dwcbRequestedSize - sizeof(MchsSuffix), &MchsSuffix, sizeof(MchsSuffix)) == CR_EQUAL))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}


/*
** SpewHeapElementInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void SpewHeapElementInfo(PCHEAPNODE pchn)
{
   ASSERT(IS_VALID_STRUCT_PTR(pchn, CHEAPNODE));

   TRACE_OUT((TEXT("Used heap element at %#lx:\r\n")
              TEXT("     %lu bytes requested\r\n")
              TEXT("     %lu bytes allocated\r\n")
              TEXT("     originally allocated as '%s' bytes in file %s at line %lu"),
              pchn->pcv,
              pchn->dwcbSize,
              MEMSIZE((PVOID)(pchn->pcv)),
              pchn->hed.rgchSize,
              pchn->hed.rgchFile,
              pchn->hed.ulLine));

   return;
}


/*
** AnalyzeHeap()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void AnalyzeHeap(PHEAPSUMMARY phs, DWORD dwFlags)
{
   PCHEAPNODE pchn;
   ULONG ulcHeapElements = 0;
   DWORD dwcbUsed = 0;

   ASSERT(IS_VALID_WRITE_PTR(phs, HEAPSUMMARY));
   ASSERT(FLAGS_ARE_VALID(dwFlags, SHS_FL_SPEW_USED_INFO));

   ASSERT(IsHeapOK());

   TRACE_OUT((TEXT("Starting private heap analysis.")));

   if (Mpheap)
   {
      for (pchn = Mpheap->hnHead.phnNext;
           pchn;
           pchn = pchn->phnNext)
      {
         ASSERT(IS_VALID_STRUCT_PTR(pchn, CHEAPNODE));

         ASSERT(ulcHeapElements < ULONG_MAX);
         ulcHeapElements++;

         ASSERT(dwcbUsed < DWORD_MAX - pchn->dwcbSize);
         dwcbUsed += pchn->dwcbSize;

         if (IS_FLAG_SET(dwFlags, SHS_FL_SPEW_USED_INFO))
            SpewHeapElementInfo(pchn);
      }

      phs->ulcUsedElements = ulcHeapElements;
      phs->dwcbUsedSize = dwcbUsed;
   }
   else
      WARNING_OUT((TEXT("Private heap not allocated!")));

   TRACE_OUT((TEXT("Private heap analysis complete.")));

   return;
}

#endif   /* DEBUG */


/****************************** Public Functions *****************************/


/*
** InitMemoryManagerModule()
**
** When PRIVATE_HEAP is defined, this function should be called only
** once, when the DLL is being first initialized.  When PRIVATE_HEAP
** is not defined, this function should be called for every 
** DLL_PROCESS_ATTACH.
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InitMemoryManagerModule(void)
{
   BOOL bResult;

#ifdef PRIVATE_HEAP

   bResult = InitPrivateHeapModule();

#else  /* PRIVATE_HEAP */

   bResult = InitHeapModule();

#endif

   return(bResult);
}

/*
** ExitMemoryManagerModule()
**
** When PRIVATE_HEAP is defined, this function should be called only
** once, when the DLL is finally being terminated.  When PRIVATE_HEAP
** is not defined, this function should be called for every 
** DLL_PROCESS_DETACH.
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ExitMemoryManagerModule(void)
{

#ifdef DEBUG

   if (Mpheap)
   {
      MEMFREE(Mpheap);
      Mpheap = NULL;
   }
   else
      WARNING_OUT((TEXT("ExitMemoryManagerModule() called when Mpheap is NULL.")));

#endif

#ifdef PRIVATE_HEAP

   if (Mhheap)
   {
      EVAL(HeapDestroy(Mhheap));
      Mhheap = NULL;
   }
   else
      WARNING_OUT((TEXT("ExitMemoryManagerModule() called when Mhheap is NULL.")));

#endif

   return;
}


/*
** MyMemComp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT MyMemComp(PCVOID pcv1, PCVOID pcv2, DWORD dwcbSize)
{
   int nResult = 0;
   PCBYTE pcbyte1 = pcv1;
   PCBYTE pcbyte2 = pcv2;

   ASSERT(IS_VALID_READ_BUFFER_PTR(pcv1, BYTE, (UINT)dwcbSize));
   ASSERT(IS_VALID_READ_BUFFER_PTR(pcv2, BYTE, (UINT)dwcbSize));

   while (dwcbSize > 0 &&
          ! (nResult = *pcbyte1 - *pcbyte2))
   {
      pcbyte1++;
      pcbyte2++;
      dwcbSize--;
   }

   return(MapIntToComparisonResult(nResult));
}


/*
** MyAllocateMemory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL MyAllocateMemory(DWORD dwcbSize, PVOID *ppvNew)
{

#ifdef DEBUG

   DWORD dwcbRequestedSize = dwcbSize;

   // ASSERT(dwcbSize >= 0); // DWORDs are nonnegative by definition
   ASSERT(IS_VALID_WRITE_PTR(ppvNew, PVOID));

   dwcbSize = CalculatePrivateSize(dwcbSize);

   if (IS_FLAG_SET(MdwMemoryManagerModuleFlags, MEMMGR_DFL_VALIDATE_HEAP_ON_ENTRY))
      ASSERT(IsHeapOK());

#endif

   *ppvNew = MEMALLOCATE(dwcbSize);

#ifdef DEBUG

   if (*ppvNew)
   {
      FillNewMemory(*ppvNew, dwcbSize, MEMSIZE(*ppvNew));

      if (AddHeapElement(*ppvNew, dwcbSize))
      {
         *ppvNew = GetPublicHeapPtr(*ppvNew);

         ASSERT(IS_VALID_WRITE_BUFFER_PTR(*ppvNew, BYTE, (UINT)dwcbRequestedSize));
      }
      else
      {
         EVAL(MEMFREE(*ppvNew));
         *ppvNew = NULL;
      }
   }

   if (IS_FLAG_SET(MdwMemoryManagerModuleFlags, MEMMGR_DFL_VALIDATE_HEAP_ON_EXIT))
      ASSERT(IsHeapOK());

#endif

   return(*ppvNew != NULL);
}


/*
** FreeMemory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void FreeMemory(PVOID pvOld)
{

#ifdef DEBUG

   if (IS_FLAG_SET(MdwMemoryManagerModuleFlags, MEMMGR_DFL_VALIDATE_HEAP_ON_ENTRY))
      ASSERT(IsHeapOK());

   pvOld = GetPrivateHeapPtr(pvOld);

   ASSERT(IsValidHeapPtr(pvOld));

   RemoveHeapElement(pvOld);

   FillFreedMemory(pvOld, MEMSIZE(pvOld));

#endif

   EVAL(MEMFREE(pvOld));

#ifdef DEBUG

   if (IS_FLAG_SET(MdwMemoryManagerModuleFlags, MEMMGR_DFL_VALIDATE_HEAP_ON_EXIT))
      ASSERT(IsHeapOK());

#endif   /* DEBUG */

   return;
}


/*
** ReallocateMemory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL ReallocateMemory(PVOID pvOld, DWORD dwcbNewSize, PVOID *ppvNew)
{

#ifdef DEBUG

   DWORD dwcbRequestedSize = dwcbNewSize;
   DWORD dwcbOldSize;

   ASSERT(IS_VALID_WRITE_PTR(ppvNew, PVOID));

   if (IS_FLAG_SET(MdwMemoryManagerModuleFlags, MEMMGR_DFL_VALIDATE_HEAP_ON_ENTRY))
      ASSERT(IsHeapOK());

   pvOld = GetPrivateHeapPtr(pvOld);

   ASSERT(IsValidHeapPtr(pvOld));

   dwcbNewSize = CalculatePrivateSize(dwcbNewSize);

   dwcbOldSize = GetHeapSize(pvOld);

   if (dwcbNewSize == dwcbOldSize)
      WARNING_OUT((TEXT("ReallocateMemory(): Size of heap element %#lx is already %lu bytes."),
                   GetPublicHeapPtr(pvOld),
                   dwcbNewSize));

#endif

   *ppvNew = MEMREALLOCATE(pvOld, dwcbNewSize);

#ifdef DEBUG

   if (*ppvNew)
   {
      /* Bigger or smaller? */

      if (dwcbNewSize > dwcbOldSize)
         /* Bigger. */
         FillGrownMemory(*ppvNew, dwcbOldSize, dwcbNewSize, MEMSIZE(*ppvNew));
      else
         /* Smaller. */
         FillShrunkenMemory(*ppvNew, dwcbOldSize, dwcbNewSize, MEMSIZE(*ppvNew));

      ModifyHeapElement(pvOld, *ppvNew, dwcbNewSize);

      *ppvNew = GetPublicHeapPtr(*ppvNew);

      ASSERT(IS_VALID_WRITE_BUFFER_PTR(*ppvNew, BYTE, (UINT)dwcbRequestedSize));
   }

   if (IS_FLAG_SET(MdwMemoryManagerModuleFlags, MEMMGR_DFL_VALIDATE_HEAP_ON_EXIT))
      ASSERT(IsHeapOK());

#endif

   return(*ppvNew != NULL);
}


/*
** GetMemorySize()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE DWORD GetMemorySize(PVOID pv)
{
   ASSERT(IsValidHeapPtr(GetPrivateHeapPtr(pv)));

   return(MEMSIZE(pv));
}


#ifdef DEBUG

/*
** SetMemoryManagerModuleIniSwitches()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SetMemoryManagerModuleIniSwitches(void)
{
   BOOL bResult;

   bResult = SetIniSwitches(MrgcpcvisMemoryManagerModule,
                            ARRAY_ELEMENTS(MrgcpcvisMemoryManagerModule));

   ASSERT(FLAGS_ARE_VALID(MdwMemoryManagerModuleFlags, ALL_MEMMGR_DFLAGS));

   return(bResult);
}


/*
** SpewHeapSummary()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void SpewHeapSummary(DWORD dwFlags)
{
   HEAPSUMMARY hs;

   ASSERT(FLAGS_ARE_VALID(dwFlags, SHS_FL_SPEW_USED_INFO));

   AnalyzeHeap(&hs, dwFlags);

   TRACE_OUT((TEXT("Heap summary: %lu bytes in %lu used elements."),
              hs.dwcbUsedSize,
              hs.ulcUsedElements));

   return;
}

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\olepig.c ===
/*
 * olepig.c - Module for indirect calling of OLE32.DLL functions.
 */


/*

    OLE32.DLL should be redesigned and reimplemented so that it can
be dynalinked to like a well-behaved DLL.  OLE32.DLL is currently so slow and
piggy that we are forced to delay loading it until absolutely necessary.

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include <ole2ver.h>


/* Constants
 ************/

#define OLE_PIG_MODULE              TEXT("ole32.dll")


/* Types
 ********/

/* OLE APIs */

typedef struct _olevtbl
{
   DWORD   (STDAPICALLTYPE *CoBuildVersion)(void);
   HRESULT (STDAPICALLTYPE *CoCreateInstance)(REFCLSID, PIUnknown, DWORD, REFIID, PVOID *);
   HRESULT (STDAPICALLTYPE *CoGetMalloc)(DWORD, PIMalloc *);
   HRESULT (STDAPICALLTYPE *CreateBindCtx)(DWORD, PIBindCtx *);
   HRESULT (STDAPICALLTYPE *CreateFileMoniker)(LPCOLESTR, PIMoniker *);
   HRESULT (STDAPICALLTYPE *OleInitialize)(PIMalloc);
   HRESULT (STDAPICALLTYPE *StgOpenStorage)(const OLECHAR *, PIStorage, DWORD, SNB, DWORD, PIStorage *);
}
OLEVTBL;
DECLARE_STANDARD_TYPES(OLEVTBL);


/* Module Variables
 *******************/

/* OLE module handle */

PRIVATE_DATA HANDLE MhmodOLE = NULL;

/* pointer to vtable of OLE functions */

PRIVATE_DATA POLEVTBL Mpolevtbl = NULL;

/* TLS slot used to store OLE thread initialization state */

PRIVATE_DATA DWORD MdwOLEInitSlot = TLS_OUT_OF_INDEXES;


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL IsOLELoaded(void);
PRIVATE_CODE BOOL LoadOLE(void);
PRIVATE_CODE void UnloadOLE(void);
PRIVATE_CODE BOOL InitializeOLE(void);
PRIVATE_CODE BOOL GetOLEProc(LPSTR, PROC *);
PRIVATE_CODE BOOL FillOLEVTable(void);

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCOLEVTBL(PCOLEVTBL);
PRIVATE_CODE BOOL OLELoadedStateOK(void);
PRIVATE_CODE BOOL OLENotLoadedStateOK(void);
PRIVATE_CODE BOOL OLEStateOk(void);

#endif


/*
** IsOLELoaded()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsOLELoaded(void)
{
   ASSERT(OLEStateOk());

   return(MhmodOLE != NULL);
}


/*
** LoadOLE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL LoadOLE(void)
{
   BOOL bResult;

   if (IsOLELoaded())
      bResult = TRUE;
   else
   {
      bResult = FALSE;

      MhmodOLE = LoadLibrary(OLE_PIG_MODULE);

      if (MhmodOLE)
      {
         if (FillOLEVTable())
         {
            DWORD dwBuildVersion;

            dwBuildVersion = Mpolevtbl->CoBuildVersion();

            /* Require same major version and same or newer minor version. */

            if (HIWORD(dwBuildVersion) == rmm &&
                LOWORD(dwBuildVersion) >= rup)
            {
               bResult = TRUE;

               TRACE_OUT((TEXT("LoadOLE(): %s loaded.  Oink oink!"),
                          OLE_PIG_MODULE));
            }
            else
               WARNING_OUT((TEXT("LoadOLE(): Bad %s version %u.%u.  This module was built with %s version %u.%u."),
                            OLE_PIG_MODULE,
                            (UINT)HIWORD(dwBuildVersion),
                            (UINT)LOWORD(dwBuildVersion),
                            OLE_PIG_MODULE,
                            (UINT)rmm,
                            (UINT)rup));
         }
         else
            WARNING_OUT((TEXT("LoadOLE(): FillOLEVTable() failed.")));
      }
      else
         WARNING_OUT((TEXT("LoadOLE(): LoadLibrary(%s) failed."),
                      OLE_PIG_MODULE));

      if (! bResult)
         UnloadOLE();
   }

   if (bResult)
   {
      bResult = InitializeOLE();

      if (! bResult)
         WARNING_OUT((TEXT("LoadOLE(): %s loaded, but InitializeOLE() failed."),
                      OLE_PIG_MODULE));
   }

   ASSERT(OLEStateOk());

   return(bResult);
}


/*
** UnloadOLE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void UnloadOLE(void)
{
   if (Mpolevtbl)
   {
      FreeMemory(Mpolevtbl);
      Mpolevtbl = NULL;

      TRACE_OUT((TEXT("UnloadOLE(): Freed %s vtable."),
                 OLE_PIG_MODULE));
   }

   if (MhmodOLE)
   {
      /* Don't call CoUninitialize() here.  OLE32.DLL will. */

      FreeLibrary(MhmodOLE);
      MhmodOLE = NULL;

      TRACE_OUT((TEXT("UnloadOLE(): Freed %s."),
                 OLE_PIG_MODULE));
   }

   ASSERT(OLENotLoadedStateOK());

   return;
}


/*
** InitializeOLE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL InitializeOLE(void)
{
   BOOL bResult;

   ASSERT(IsOLELoaded());
   ASSERT(MdwOLEInitSlot != TLS_OUT_OF_INDEXES);

   if (TlsGetValue(MdwOLEInitSlot))
      bResult = TRUE;
   else
   {
      HRESULT hr;

      hr = Mpolevtbl->OleInitialize(NULL);

      bResult = (SUCCEEDED(hr) ||
                 hr == CO_E_ALREADYINITIALIZED);

      if (hr == CO_E_ALREADYINITIALIZED)
         WARNING_OUT((TEXT("InitializeOLE(): OLE already initialized for thread %lx.  OleInitialize() returned %s."),
                      GetCurrentThreadId(),
                      GetHRESULTString(hr)));

      if (bResult)
      {
         EVAL(TlsSetValue(MdwOLEInitSlot, (PVOID)TRUE));

         TRACE_OUT((TEXT("InitializeOLE(): OLE initialized for thread %lx.  Using apartment threading model."),
                    GetCurrentThreadId()));
      }
      else
         WARNING_OUT((TEXT("InitializeOLE(): OleInitialize() failed for thread %lx, returning %s."),
                      GetCurrentThreadId(),
                      GetHRESULTString(hr)));
   }

   return(bResult);
}


/*
** GetOLEProc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL GetOLEProc(LPSTR pcszProc, PROC *pfp)
{
   //ASSERT(IS_VALID_STRING_PTR(pcszProc, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pfp, PROC));

   ASSERT(IS_VALID_HANDLE(MhmodOLE, MODULE));

   *pfp = GetProcAddress(MhmodOLE, pcszProc);

   if (*pfp)
      TRACE_OUT((TEXT("GetOLEProc(): Got address of %s!%s."),
                 OLE_PIG_MODULE,
                 pcszProc));
   else
      WARNING_OUT((TEXT("GetOLEProc(): Failed to get address of %s!%s."),
                   OLE_PIG_MODULE,
                   pcszProc));

   ASSERT(! *pfp ||
          IS_VALID_CODE_PTR(*pfp, PROC));

   return(*pfp != NULL);
}


/*
** FillOLEVTable()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FillOLEVTable(void)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(MhmodOLE, MODULE));

   bResult = AllocateMemory(sizeof(*Mpolevtbl), &Mpolevtbl);

   if (bResult)
   {
      bResult = (GetOLEProc("CoBuildVersion",      &(PROC)(Mpolevtbl->CoBuildVersion)) &&
                 GetOLEProc("CoCreateInstance",    &(PROC)(Mpolevtbl->CoCreateInstance)) &&
                 GetOLEProc("CoGetMalloc",         &(PROC)(Mpolevtbl->CoGetMalloc)) &&
                 GetOLEProc("CreateBindCtx",       &(PROC)(Mpolevtbl->CreateBindCtx)) &&
                 GetOLEProc("CreateFileMoniker",   &(PROC)(Mpolevtbl->CreateFileMoniker)) &&
                 GetOLEProc("OleInitialize",       &(PROC)(Mpolevtbl->OleInitialize)) &&
                 GetOLEProc("StgOpenStorage",      &(PROC)(Mpolevtbl->StgOpenStorage)));


      if (bResult)
         TRACE_OUT((TEXT("FillOLEVTable(): OLE vtable filled successfully.")));
      else
      {
         FreeMemory(Mpolevtbl);
         Mpolevtbl = NULL;

         WARNING_OUT((TEXT("FillOLEVTable(): Failed to fill OLE vtable.")));
      }
   }
   else
      WARNING_OUT((TEXT("FillOLEVTable(): Out of memory.")));

   ASSERT(! bResult ||
          OLELoadedStateOK());

   return(bResult);
}


#ifdef DEBUG

/*
** IsValidPCOLEVTBL()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCOLEVTBL(PCOLEVTBL pcolevtbl)
{
   return(IS_VALID_READ_PTR(pcolevtbl, PCOLEVTBL) &&
          IS_VALID_CODE_PTR(pcolevtbl->CoBuildVersion, CoBuildVersion) &&
          IS_VALID_CODE_PTR(pcolevtbl->CoCreateInstance, CoCreateInstance) &&
          IS_VALID_CODE_PTR(pcolevtbl->CoGetMalloc, CoGetMalloc) &&
          IS_VALID_CODE_PTR(pcolevtbl->CreateBindCtx, CreateBindCtx) &&
          IS_VALID_CODE_PTR(pcolevtbl->CreateFileMoniker, CreateFileMoniker) &&
          IS_VALID_CODE_PTR(pcolevtbl->OleInitialize, OleInitialize) &&
          IS_VALID_CODE_PTR(pcolevtbl->StgOpenStorage, StgOpenStorage));
}


/*
** OLELoadedStateOK()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL OLELoadedStateOK(void)
{
   return(IS_VALID_HANDLE(MhmodOLE, MODULE) &&
          IS_VALID_STRUCT_PTR(Mpolevtbl, COLEVTBL));
}


/*
** OLENotLoadedStateOK()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL OLENotLoadedStateOK(void)
{
   return(! MhmodOLE &&
          ! Mpolevtbl);
}


/*
** OLEStateOk()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL OLEStateOk(void)
{
   return(OLELoadedStateOK() ||
          OLENotLoadedStateOK);
}

#endif


/****************************** Public Functions *****************************/


/*
** ProcessInitOLEPigModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL ProcessInitOLEPigModule(void)
{
   BOOL bResult;

   ASSERT(MdwOLEInitSlot == TLS_OUT_OF_INDEXES);

   MdwOLEInitSlot = TlsAlloc();

   bResult = (MdwOLEInitSlot != TLS_OUT_OF_INDEXES);

   if (bResult)
   {
      EVAL(TlsSetValue(MdwOLEInitSlot, (PVOID)FALSE));

      TRACE_OUT((TEXT("ProcessInitOLEPigModule(): Using thread local storage slot %lu for OLE initialization state."),
                 MdwOLEInitSlot));
   }
   else
      ERROR_OUT((TEXT("ProcessInitOLEPigModule(): TlsAlloc() failed to allocate thread local storage for OLE initialization state.")));

   return(bResult);
}


/*
** ProcessExitOLEPigModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ProcessExitOLEPigModule(void)
{
   UnloadOLE();

   if (MdwOLEInitSlot != TLS_OUT_OF_INDEXES)
   {
      EVAL(TlsFree(MdwOLEInitSlot));
      MdwOLEInitSlot= TLS_OUT_OF_INDEXES;
   }

   return;
}


/*
** CoCreateInstance()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
HRESULT STDAPICALLTYPE CoCreateInstance(REFCLSID rclsid, PIUnknown piunkOuter,
                                        DWORD dwClsCtx, REFIID riid,
                                        PVOID *ppv)
{
   HRESULT hr;

   if (LoadOLE())
      hr = Mpolevtbl->CoCreateInstance(rclsid, piunkOuter, dwClsCtx, riid, ppv);
   else
      hr = E_FAIL;

   return(hr);
}


/*
** CoGetMalloc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
HRESULT STDAPICALLTYPE CoGetMalloc(DWORD dwMemContext, PIMalloc *ppimalloc)
{
   HRESULT hr;

   if (LoadOLE())
      hr = Mpolevtbl->CoGetMalloc(dwMemContext, ppimalloc);
   else
      hr = E_FAIL;

   return(hr);
}


/*
** CreateBindCtx()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
HRESULT STDAPICALLTYPE CreateBindCtx(DWORD dwReserved, PIBindCtx *ppibindctx)
{
   HRESULT hr;

   if (LoadOLE())
      hr = Mpolevtbl->CreateBindCtx(dwReserved, ppibindctx);
   else
      hr = E_FAIL;

   return(hr);
}


/*
** CreateFileMoniker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
HRESULT STDAPICALLTYPE CreateFileMoniker(LPCOLESTR pwszPath, PIMoniker *ppimk)
{
   HRESULT hr;

   if (LoadOLE())
      hr = Mpolevtbl->CreateFileMoniker(pwszPath, ppimk);
   else
      hr = E_FAIL;

   return(hr);
}


/*
** StgOpenStorage()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
HRESULT STDAPICALLTYPE StgOpenStorage(LPCOLESTR pwszName,
                                      PIStorage pistgPriority, DWORD dwMode,
                                      SNB snbExclude, DWORD dwReserved,
                                      PIStorage *ppistgOpen)
{
   HRESULT hr;

   if (LoadOLE())
      hr = Mpolevtbl->StgOpenStorage(pwszName, pistgPriority, dwMode,
                                     snbExclude, dwReserved, ppistgOpen);
   else
      hr = E_FAIL;

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\olepig.h ===
/*
 * olepig.h - Module for indirect calling of OLE32.DLL functions description.
 */


/* Prototypes
 *************/

/* olepig.c */

extern BOOL ProcessInitOLEPigModule(void);
extern void ProcessExitOLEPigModule(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\olestock.h ===
/*
 * olestock.h - Stock OLE header file.
 */


/* Types
 ********/

/* IDs */

DECLARE_STANDARD_TYPES(GUID);
DECLARE_STANDARD_TYPES(CLSID);
DECLARE_STANDARD_TYPES(IID);

typedef PROC *Interface;
DECLARE_STANDARD_TYPES(Interface);

/* interfaces */

DECLARE_STANDARD_TYPES(IAdviseSink);
DECLARE_STANDARD_TYPES(IBindCtx);
DECLARE_STANDARD_TYPES(IClassFactory);
DECLARE_STANDARD_TYPES(IDataObject);
DECLARE_STANDARD_TYPES(IEnumFORMATETC);
DECLARE_STANDARD_TYPES(IEnumSTATDATA);
DECLARE_STANDARD_TYPES(IMalloc);
DECLARE_STANDARD_TYPES(IMoniker);
DECLARE_STANDARD_TYPES(IPersist);
DECLARE_STANDARD_TYPES(IPersistFile);
DECLARE_STANDARD_TYPES(IPersistStorage);
DECLARE_STANDARD_TYPES(IPersistStream);
DECLARE_STANDARD_TYPES(IStorage);
DECLARE_STANDARD_TYPES(IStream);
DECLARE_STANDARD_TYPES(IUnknown);

/* structures */

DECLARE_STANDARD_TYPES(FORMATETC);
DECLARE_STANDARD_TYPES(STGMEDIUM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\oleutil.c ===
/*
 * oleutil.c - OLE utility functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "oleutil.h"


/* Macros
 *********/

/* macro for translating an HRESULT to a TWINRESULT */

#define HRESULTToTWINRESULT(hr, TR)    case hr: tr = TR; break


/* Constants
 ************/

/* maximum allowed registry lengths */

#define MAX_REG_KEY_LEN                MAX_PATH_LEN
#define MAX_REG_VALUE_LEN              MAX_PATH_LEN

/* subkeys and associated lengths */

#define CLSID_SUBKEY                   TEXT("CLSID")
/* CLSID subkey length in bytes, including null terminator */
#define CLSID_SUBKEY_LEN               (5 + 1)

#define IN_PROC_SERVER_SUBKEY          TEXT("InProcServer32")
/* InProcServer32 subkey length in bytes, including null terminator */
#define IN_PROC_SERVER_SUBKEY_LEN      (14 + 1)

#define LOCAL_SERVER_SUBKEY            TEXT("LocalServer32")
/* LocalServer32 subkey length in bytes, including null terminator */
#define LOCAL_SERVER_SUBKEY_LEN        (13 + 1)

#define RECONCILER_SUBKEY              TEXT("Roles\\Reconciler")
/* InProcServer32 subkey length in bytes, including null terminator */
#define RECONCILER_SUBKEY_LEN          (5 + 1 + 10 + 1)

#define NOTIFY_SUBKEY                  TEXT("Roles\\NotifyReplica")
/* InProcServer32 subkey length in bytes, including null terminator */
#define NOTIFY_SUBKEY_LEN              (5 + 1 + 13 + 1)

#define COPY_SUBKEY                    TEXT("SingleChangeHook")
/* copy subkey length in bytes, including null terminator */
#define COPY_SUBKEY_LEN                (16 + 1)

/*
 * length of GUID subkey string in bytes, including null terminator
 *
 * "{12345678-1234-1234-1234-123456789012}"
 */

#define GUID_SUBKEY_LEN                (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

/*
 * class ID key length in bytes, including null terminator
 *
 * "CLSID\{12345678-1234-1234-1234-123456789012}"
 */

#define CLSID_REG_KEY_LEN              (CLSID_SUBKEY_LEN + GUID_SUBKEY_LEN)

/*
 * InProcServer32 key length in bytes, including null terminator
 *
 * "CLSID\{12345678-1234-1234-1234-123456789012}\InProcServer32"
 */

#define IN_PROC_SERVER_REG_KEY_LEN     (CLSID_REG_KEY_LEN + IN_PROC_SERVER_SUBKEY_LEN)

/*
 * LocalServer32 key length in bytes, including null terminator
 *
 * "CLSID\{12345678-1234-1234-1234-123456789012}\LocalServer32"
 */

#define LOCAL_SERVER_REG_KEY_LEN       (CLSID_REG_KEY_LEN + LOCAL_SERVER_SUBKEY_LEN)

/*
 * reconciler key length in bytes, including null terminator
 *
 * "CLSID\{12345678-1234-1234-1234-123456789012}\Roles\Reconciler"
 */

#define RECONCILER_REG_KEY_LEN         (CLSID_REG_KEY_LEN + RECONCILER_SUBKEY_LEN)

/*
 * notify replica key length in bytes, including null terminator
 *
 * "CLSID\{12345678-1234-1234-1234-123456789012}\Roles\NotifyReplica"
 */

#define NOTIFY_REG_KEY_LEN             (CLSID_REG_KEY_LEN + NOTIFY_SUBKEY_LEN)

/*
 * copy key length in bytes, including null terminator
 *
 * "CLSID\{12345678-1234-1234-1234-123456789012}\SingleChangeHook"
 */

#define COPY_REG_KEY_LEN               (CLSID_REG_KEY_LEN + COPY_SUBKEY_LEN)


/* Macros
 *********/

/*
 * Determine whether or not an integer value is within a given inclusive range.
 */

#define IsWithin(test, first, last)    ((UINT)((test) - (first)) <= (UINT)((last) - (first)))


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE void MakeClsIDSubKey(PCGUID, LPCTSTR, LPTSTR, int);
PRIVATE_CODE BOOL HexStringToDWORD(LPCTSTR *, PDWORD, UINT, TCHAR);
PRIVATE_CODE BOOL StringToGUID(LPCTSTR, PGUID);
PRIVATE_CODE HRESULT GetClassID(LPCTSTR, LPCTSTR, PCLSID);


/*
 ** MakeClsIDSubKey()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void MakeClsIDSubKey(PCGUID pcguid, LPCTSTR pcszSubKey,
        LPTSTR pszRegKeyBuf, int cchMax)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcguid, CGUID));
    ASSERT(IS_VALID_STRING_PTR(pcszSubKey, CSTR));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRegKeyBuf, STR, CLSID_REG_KEY_LEN + lstrlen(pcszSubKey) + 1));

    /* (- 1) for null terminator. */

    EVAL(wnsprintf(pszRegKeyBuf, cchMax, 
                TEXT("CLSID\\{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\\%s"),
                pcguid->Data1,
                pcguid->Data2,
                pcguid->Data3,
                pcguid->Data4[0],
                pcguid->Data4[1],
                pcguid->Data4[2],
                pcguid->Data4[3],
                pcguid->Data4[4],
                pcguid->Data4[5],
                pcguid->Data4[6],
                pcguid->Data4[7],
                pcszSubKey)
            == CLSID_REG_KEY_LEN + lstrlen(pcszSubKey));

    return;
}


/*
 ** HexStringToDWORD()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL HexStringToDWORD(LPCTSTR *ppcsz, PDWORD pdwValue, UINT ucDigits,
        TCHAR chDelimiter)
{
    BOOL bResult = TRUE;
    UINT u;

    /* chDelimiter may be any value. */

    ASSERT(IS_VALID_WRITE_PTR(ppcsz, LPCTSTR));
    ASSERT(IS_VALID_STRING_PTR(*ppcsz, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(pdwValue, DWORD));
    ASSERT(ucDigits <= 8);

    *pdwValue = 0;

    for (u = 0; u < ucDigits; u++)
    {
        TCHAR ch = (*ppcsz)[u];

        if (IsWithin(ch, TEXT('0'), TEXT('9')))
            *pdwValue = (*pdwValue << 4) + ch - TEXT('0');
        else if (IsWithin((ch |= (TEXT('a') - TEXT('A'))), TEXT('a'), TEXT('f')))
            *pdwValue = (*pdwValue << 4) + ch - TEXT('a') + 10;
        else
        {
            WARNING_OUT((TEXT("HexStringToDWORD(): Found unrecognized hex digit %c."),
                        ch));

            bResult = FALSE;
            break;
        }
    }

    if (bResult)
    {
        if (chDelimiter)
        {
            bResult = ((*ppcsz)[u++] == chDelimiter);

            if (! bResult)
                WARNING_OUT((TEXT("HexStringToDWORD(): Character %c does not match required delimiter %c."),
                            (*ppcsz)[u],
                            chDelimiter));
        }

        *ppcsz += u;
    }

    ASSERT(IS_VALID_STRING_PTR(*ppcsz, CSTR));

    return(bResult);
}


/*
 ** StringToGUID()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL StringToGUID(LPCTSTR pcszGUID, PGUID pguid)
{
    BOOL bResult = FALSE;
    DWORD dwValue;
    LPCTSTR pcszNext = pcszGUID;

    ASSERT(IS_VALID_STRING_PTR(pcszGUID, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(pguid, GUID));

    if (*pcszNext++ == TEXT('{') &&
            HexStringToDWORD(&pcszNext, &(pguid->Data1), sizeof(DWORD) * 2, TEXT('-')) &&
            HexStringToDWORD(&pcszNext, &dwValue, sizeof(WORD) * 2, TEXT('-')))
    {
        pguid->Data2 = (WORD)dwValue;

        if (HexStringToDWORD(&pcszNext, &dwValue, sizeof(WORD) * 2, TEXT('-')))
        {
            UINT u;
            static const TCHAR SrgcchDelimiters[] = { 0, TEXT('-'), 0, 0, 0, 0, 0, TEXT('}') };

            pguid->Data3 = (WORD)dwValue;

            bResult = TRUE;

            for (u = 0; u < ARRAY_ELEMENTS(pguid->Data4); u++)
            {
                if (HexStringToDWORD(&pcszNext, &dwValue, sizeof(BYTE) * 2,
                            SrgcchDelimiters[u]))
                    pguid->Data4[u] = (BYTE)dwValue;
                else
                {
                    bResult = FALSE;
                    break;
                }
            }

            if (bResult)
            {
                ASSERT(u == ARRAY_ELEMENTS(pguid->Data4));

                if (*pcszNext)
                {
                    bResult = FALSE;

                    WARNING_OUT((TEXT("StringToGUID(): Found %c instead of }."),
                                *pcszNext));
                }
            }
            else
                WARNING_OUT((TEXT("StringToGUID(): Bad GUID string %s."),
                            pcszGUID));
        }
    }

    ASSERT(! bResult ||
            IS_VALID_STRUCT_PTR(pguid, CGUID));

    return(bResult);
}


/*
 ** GetClassID()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE HRESULT GetClassID(LPCTSTR pcszPath, LPCTSTR pcszSubKey, PCLSID pclsid)
{
    HRESULT hr;
    CLSID clsidFile;

    ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
    ASSERT(IS_VALID_STRING_PTR(pcszSubKey, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(pclsid, CLSID));

    /* Verify string length constants. */

    /* (+ 1) for each null terminator. */

    ASSERT(lstrlen(CLSID_SUBKEY)           + 1 == CLSID_SUBKEY_LEN);
    ASSERT(lstrlen(IN_PROC_SERVER_SUBKEY)  + 1 == IN_PROC_SERVER_SUBKEY_LEN);
    ASSERT(lstrlen(LOCAL_SERVER_SUBKEY)    + 1 == LOCAL_SERVER_SUBKEY_LEN);
    ASSERT(lstrlen(RECONCILER_SUBKEY)      + 1 == RECONCILER_SUBKEY_LEN);
    ASSERT(lstrlen(NOTIFY_SUBKEY)          + 1 == NOTIFY_SUBKEY_LEN);
    ASSERT(lstrlen(COPY_SUBKEY)            + 1 == COPY_SUBKEY_LEN);

    ASSERT(lstrlen(       TEXT("{12345678-1234-1234-1234-123456789012}"))                        + 1 == GUID_SUBKEY_LEN);
    ASSERT(lstrlen(TEXT("CLSID\\{12345678-1234-1234-1234-123456789012}"))                        + 1 == CLSID_REG_KEY_LEN);
    ASSERT(lstrlen(TEXT("CLSID\\{12345678-1234-1234-1234-123456789012}\\InProcServer32"))        + 1 == IN_PROC_SERVER_REG_KEY_LEN);
    ASSERT(lstrlen(TEXT("CLSID\\{12345678-1234-1234-1234-123456789012}\\LocalServer32"))         + 1 == LOCAL_SERVER_REG_KEY_LEN);
    ASSERT(lstrlen(TEXT("CLSID\\{12345678-1234-1234-1234-123456789012}\\Roles\\Reconciler"))     + 1 == RECONCILER_REG_KEY_LEN);
    ASSERT(lstrlen(TEXT("CLSID\\{12345678-1234-1234-1234-123456789012}\\Roles\\NotifyReplica"))  + 1 == NOTIFY_REG_KEY_LEN);
    ASSERT(lstrlen(TEXT("CLSID\\{12345678-1234-1234-1234-123456789012}\\SingleChangeHook"))      + 1 == COPY_REG_KEY_LEN);

    hr = GetClassFileByExtension(pcszPath, &clsidFile);

    if (SUCCEEDED(hr))
    {
        TCHAR rgchRecRegKey[MAX_REG_KEY_LEN];
        TCHAR rgchRecGUID[GUID_SUBKEY_LEN];
        DWORD dwcbLen = sizeof(rgchRecGUID);

        hr = REGDB_E_CLASSNOTREG;

        MakeClsIDSubKey(&clsidFile, pcszSubKey, rgchRecRegKey, ARRAYSIZE(rgchRecRegKey));

        if (GetDefaultRegKeyValue(HKEY_CLASSES_ROOT, rgchRecRegKey, rgchRecGUID,
                    &dwcbLen) == ERROR_SUCCESS)
        {
            /* (+ 1) for null terminator. */

            ASSERT((DWORD)(lstrlen(rgchRecGUID) + 1) * sizeof(TCHAR)  == dwcbLen);
            ASSERT(dwcbLen * sizeof(TCHAR) <= sizeof(rgchRecGUID));

            if (StringToGUID(rgchRecGUID, pclsid))
            {
                hr = S_OK;

#ifdef DEBUG

                {
                    TCHAR rgchInProcServerKey[IN_PROC_SERVER_REG_KEY_LEN];
                    TCHAR rgchInProcServerValue[MAX_REG_VALUE_LEN];
                    DWORD dwcbInProcLen = sizeof(rgchInProcServerValue);

                    /* Display the path to the registered reconciler. */

                    wnsprintf(rgchInProcServerKey, ARRAYSIZE(rgchInProcServerKey), TEXT("%s\\%s\\%s"), CLSID_SUBKEY,
                            rgchRecGUID, IN_PROC_SERVER_SUBKEY);

                    if (GetDefaultRegKeyValue(HKEY_CLASSES_ROOT,
                                rgchInProcServerKey,
                                rgchInProcServerValue, &dwcbInProcLen)
                            == ERROR_SUCCESS)
                        TRACE_OUT((TEXT("GetClassID(): Found registered %s reconciler %s for file %s."),
                                    IN_PROC_SERVER_SUBKEY,
                                    rgchInProcServerValue,
                                    pcszPath));
                    else
                    {
                        dwcbInProcLen = sizeof(rgchInProcServerValue);

                        wnsprintf(rgchInProcServerKey, ARRAYSIZE(rgchInProcServerKey), TEXT("%s\\%s\\%s"), CLSID_SUBKEY,
                                rgchRecGUID, LOCAL_SERVER_SUBKEY);

                        if (GetDefaultRegKeyValue(HKEY_CLASSES_ROOT,
                                    rgchInProcServerKey,
                                    rgchInProcServerValue,
                                    &dwcbInProcLen)
                                == ERROR_SUCCESS)
                            TRACE_OUT((TEXT("GetClassID(): Found registered %s reconciler %s for file %s."),
                                        LOCAL_SERVER_SUBKEY,
                                        rgchInProcServerValue,
                                        pcszPath));
                        else
                            WARNING_OUT((TEXT("GetClassID(): Unregistered class ID %s listed as reconciler in %s for file %s."),
                                        rgchRecGUID,
                                        rgchRecRegKey,
                                        pcszPath));
                    }
                }

#endif

            }
            else
                WARNING_OUT((TEXT("GetClassID(): Bad reconciler class ID %s specified for key %s."),
                            rgchRecGUID,
                            rgchRecRegKey));
        }
        else
            TRACE_OUT((TEXT("GetClassID(): No reconciler registered for file %s."),
                        pcszPath));
    }
    else
        TRACE_OUT((TEXT("GetClassID(): No class ID registered for file %s."),
                    pcszPath));

    ASSERT(FAILED(hr) ||
            IS_VALID_STRUCT_PTR(pclsid, CCLSID));

    return(hr);
}


/****************************** Public Functions *****************************/


/*
 ** GetClassFileByExtension()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HRESULT GetClassFileByExtension(LPCTSTR pcszFile, PCLSID pclsid)
{
    HRESULT hr = MK_E_INVALIDEXTENSION;
    LPCTSTR pcszExtension;

    ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(pclsid, CLSID));

    pcszExtension = ExtractExtension(pcszFile);

    if (*pcszExtension)
    {
        TCHAR rgchFileType[MAX_REG_VALUE_LEN];
        DWORD dwcbBufLen = sizeof(rgchFileType);

        ASSERT(*pcszExtension == PERIOD);

        if (GetDefaultRegKeyValue(HKEY_CLASSES_ROOT, pcszExtension, rgchFileType,
                    &dwcbBufLen) == ERROR_SUCCESS)
        {
            /* dwcbBufLen includes rgchFileType's null terminator. */

            if (dwcbBufLen + sizeof(CLSID_SUBKEY) <= sizeof(rgchFileType))
            {
                TCHAR rgchFileClsID[GUID_SUBKEY_LEN];
                DWORD dwcbFileClsIDBufLen = sizeof(rgchFileClsID);

                CatPath(rgchFileType, CLSID_SUBKEY, ARRAYSIZE(rgchFileType));

                if (GetDefaultRegKeyValue(HKEY_CLASSES_ROOT, rgchFileType,
                            rgchFileClsID, &dwcbFileClsIDBufLen)
                        == ERROR_SUCCESS)
                {
                    if (StringToGUID(rgchFileClsID, pclsid))
                    {
                        hr = S_OK;

                        TRACE_OUT((TEXT("GetClassFileByExtension(): Retrieved class ID %s for file %s."),
                                    rgchFileClsID,
                                    pcszFile));
                    }
                    else
                        WARNING_OUT((TEXT("GetClassFileByExtension(): Invalid class ID \"%s\" in %s\\%s.  No class ID will be used."),
                                    rgchFileClsID,
                                    rgchFileType,
                                    CLSID_SUBKEY));
                }
                else
                    TRACE_OUT((TEXT("GetClassFileByExtension(): No %s subkey for file type key \"%s\".  No class ID will be used."),
                                CLSID_SUBKEY,
                                rgchFileType));
            }
            else
                WARNING_OUT((TEXT("GetClassFileByExtension(): File type \"%s\" for extension %s of file %s is too long.  No class ID will be used."),
                            rgchFileType,
                            pcszExtension,
                            pcszFile));
        }
        else
            TRACE_OUT((TEXT("GetClassFileByExtension(): No file type for extension %s of file %s.  No class ID will be used."),
                        pcszExtension,
                        pcszFile));
    }
    else
        TRACE_OUT((TEXT("GetClassFileByExtension(): File %s has no extension.  No class ID will be used."),
                    pcszFile));

    ASSERT(FAILED(hr) ||
            IS_VALID_STRUCT_PTR(pclsid, CCLSID));

    return(hr);
}


/*
 ** GetReconcilerClassID()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HRESULT GetReconcilerClassID(LPCTSTR pcszPath, PCLSID pclsid)
{
    ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(pclsid, CLSID));

    return(GetClassID(pcszPath, RECONCILER_SUBKEY, pclsid));
}


/*
 ** GetCopyHandlerClassID()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HRESULT GetCopyHandlerClassID(LPCTSTR pcszPath, PCLSID pclsid)
{
    HRESULT hr;

    ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(pclsid, CLSID));

    hr = GetReconcilerClassID(pcszPath, pclsid);

    if (SUCCEEDED(hr))
    {
        TCHAR rgchCopyRegKey[COPY_REG_KEY_LEN];

        MakeClsIDSubKey(pclsid, COPY_SUBKEY, rgchCopyRegKey, ARRAYSIZE(rgchCopyRegKey));

        if (RegKeyExists(HKEY_CLASSES_ROOT, rgchCopyRegKey))
            hr = S_OK;
        else
            hr = REGDB_E_CLASSNOTREG;
    }

    return(hr);
}


/*
 ** GetReplicaNotificationClassID()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HRESULT GetReplicaNotificationClassID(LPCTSTR pcszPath, PCLSID pclsid)
{
    ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(pclsid, CLSID));

    return(GetClassID(pcszPath, NOTIFY_SUBKEY, pclsid));
}


/*
 ** CompareGUIDs()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE COMPARISONRESULT CompareGUIDs(PCGUID pcguid1, PCGUID pcguid2)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcguid1, CGUID));
    ASSERT(IS_VALID_STRUCT_PTR(pcguid2, CGUID));

    return(MyMemComp(pcguid1, pcguid2, sizeof(*pcguid1)));
}


/*
 ** TranslateHRESULTToTWINRESULT()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT TranslateHRESULTToTWINRESULT(HRESULT hr)
{
    TWINRESULT tr;

    switch (hr)
    {
        HRESULTToTWINRESULT(S_OK, TR_SUCCESS);

        HRESULTToTWINRESULT(REC_S_NOTCOMPLETE, TR_MERGE_INCOMPLETE);
        HRESULTToTWINRESULT(REC_S_NOTCOMPLETEBUTPROPAGATE, TR_MERGE_INCOMPLETE);

        HRESULTToTWINRESULT(E_ABORT, TR_ABORT);
        HRESULTToTWINRESULT(E_OUTOFMEMORY, TR_OUT_OF_MEMORY);
        HRESULTToTWINRESULT(E_FAIL, TR_RH_LOAD_FAILED);

        HRESULTToTWINRESULT(REC_E_ABORTED, TR_ABORT);
        HRESULTToTWINRESULT(REC_E_TOODIFFERENT, TR_TOO_DIFFERENT);

        default:
        if (SUCCEEDED(hr))
        {
            tr = TR_SUCCESS;

            WARNING_OUT((TEXT("TranslateHRESULTToTWINRESULT(): Translating unlisted success HRESULT %s into TWINRESULT %s."),
                        GetHRESULTString(hr),
                        GetTWINRESULTString(tr)));
        }
        else
        {
            tr = TR_RH_LOAD_FAILED;

            WARNING_OUT((TEXT("TranslateHRESULTToTWINRESULT(): Translating unlisted failure HRESULT %s into TWINRESULT %s."),
                        GetHRESULTString(hr),
                        GetTWINRESULTString(tr)));
        }
        break;
    }

    return(tr);
}


#if defined(DEBUG) || defined(VSTF)

/*
 ** IsValidPCINotifyReplica()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidPCINotifyReplica(PCINotifyReplica pcinr)
{
    return(IS_VALID_READ_PTR(pcinr, CINotifyReplica) &&
            IS_VALID_READ_PTR(pcinr->lpVtbl, sizeof(*(pcinr->lpVtbl))) &&
            IS_VALID_STRUCT_PTR((PCIUnknown)pcinr, CIUnknown) &&
            IS_VALID_CODE_PTR(pcinr->lpVtbl->YouAreAReplica, YouAreAReplica));
}


/*
 ** IsValidPCIReconcileInitiator()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidPCIReconcileInitiator(PCIReconcileInitiator pciri)
{
    return(IS_VALID_READ_PTR(pciri, CIReconcileInitiator) &&
            IS_VALID_READ_PTR(pciri->lpVtbl, sizeof(*(pciri->lpVtbl))) &&
            IS_VALID_STRUCT_PTR((PCIUnknown)pciri, CIUnknown) &&
            IS_VALID_CODE_PTR(pciri->lpVtbl->SetAbortCallback, SetAbortCallback) &&
            IS_VALID_CODE_PTR(pciri->lpVtbl->SetProgressFeedback, SetProgressFeedback));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\olevalid.h ===
/*
 * olevalid.h - OLE validation functions description.
 */


/* Prototypes
 *************/

/* olevalid.c */

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidPCGUID(PCGUID);
extern BOOL IsValidPCCLSID(PCCLSID);
extern BOOL IsValidPCIID(PCIID);
extern BOOL IsValidREFIID(REFIID);
extern BOOL IsValidREFCLSID(REFCLSID);
extern BOOL IsValidPCInterface(PCVOID);
extern BOOL IsValidPCIClassFactory(PCIClassFactory);
extern BOOL IsValidPCIDataObject(PCIDataObject);
extern BOOL IsValidPCIMalloc(PCIMalloc);
extern BOOL IsValidPCIMoniker(PCIMoniker);
extern BOOL IsValidPCIPersist(PCIPersist);
extern BOOL IsValidPCIPersistFile(PCIPersistFile);
extern BOOL IsValidPCIPersistStorage(PCIPersistStorage);
extern BOOL IsValidPCIPersistStream(PCIPersistStream);
extern BOOL IsValidPCIStorage(PCIStorage);
extern BOOL IsValidPCIStream(PCIStream);
extern BOOL IsValidPCIUnknown(PCIUnknown);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\oleutil.h ===
/*
 * oleutil.h - OLE utility functions description.
 */


/* Macros
 *********/

/* interface pointer to class pointer conversion macros */

#define IfaceOffset(class, iface)            ((UINT_PTR)&(((class *)0)->iface))
#define ClassFromIface(class, iface, piface) ((class *)(((PBYTE)piface) - IfaceOffset(class, iface)))

/* macro wrappers for CompareGUIDs() */

#define CompareClassIDs(pcclsid1, pcclsid2)  CompareGUIDs(pcclsid1, pcclsid2)
#define CompareInterfaceIDs(pciid1, pciid2)  CompareGUIDs(pciid1, pciid2)


/* Types
 ********/

/* interfaces */

DECLARE_STANDARD_TYPES(INotifyReplica);
DECLARE_STANDARD_TYPES(IReconcileInitiator);
DECLARE_STANDARD_TYPES(IReconcilableObject);
DECLARE_STANDARD_TYPES(IBriefcaseInitiator);


/* Prototypes
 *************/

/* oleutil.c */

extern HRESULT GetClassFileByExtension(LPCTSTR, PCLSID);
extern HRESULT GetReconcilerClassID(LPCTSTR, PCLSID);
extern HRESULT GetCopyHandlerClassID(LPCTSTR, PCLSID);
extern HRESULT GetReplicaNotificationClassID(LPCTSTR, PCLSID);
extern COMPARISONRESULT CompareGUIDs(PCGUID, PCGUID);
extern TWINRESULT TranslateHRESULTToTWINRESULT(HRESULT);

#ifdef DEBUG

extern BOOL IsValidPCINotifyReplica(PCINotifyReplica);
extern BOOL IsValidPCIReconcileInitiator(PCIReconcileInitiator);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\olevalid.c ===
/*
 * olevalid.c - OLE validation functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop



/****************************** Public Functions *****************************/


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidPCGUID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCGUID(PCGUID pcguid)
{
   /* All values are valid GUIDs. */

   return(IS_VALID_READ_PTR(pcguid, CGUID));
}


/*
** IsValidPCCLSID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCCLSID(PCCLSID pcclsid)
{
   return(IS_VALID_STRUCT_PTR(pcclsid, CGUID));
}


/*
** IsValidPCIID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIID(PCIID pciid)
{
   return(IS_VALID_STRUCT_PTR(pciid, CGUID));
}


/*
** IsValidREFIID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidREFIID(REFIID riid)
{
   return(IS_VALID_STRUCT_PTR(riid, CIID));
}


/*
** IsValidREFCLSID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidREFCLSID(REFCLSID rclsid)
{
   return(IS_VALID_STRUCT_PTR(rclsid, CCLSID));
}


/*
** IsValidPCInterface()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCInterface(PCVOID pcvi)
{
   return(IS_VALID_READ_PTR((PROC *)pcvi, PROC) &&
          IS_VALID_CODE_PTR(*((PROC *)pcvi), Method));
}


/*
** IsValidPCIClassFactory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIClassFactory(PCIClassFactory pcicf)
{
   return(IS_VALID_READ_PTR(pcicf, CIClassFactory) &&
          IS_VALID_READ_PTR(pcicf->lpVtbl, sizeof(*(pcicf->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcicf, CIUnknown) &&
          IS_VALID_CODE_PTR(pcicf->lpVtbl->CreateInstance, CreateInstance) &&
          IS_VALID_CODE_PTR(pcicf->lpVtbl->LockServer, LockServer));
}


/*
** IsValidPCIDataObject()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIDataObject(PCIDataObject pcido)
{
   return(IS_VALID_READ_PTR(pcido, CIDataObject) &&
          IS_VALID_READ_PTR(pcido->lpVtbl, sizeof(*(pcido->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcido, CIUnknown) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->GetData, GetData) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->GetDataHere, GetDataHere) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->QueryGetData, QueryGetData) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->GetCanonicalFormatEtc, GetCanonicalFormatEtc) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->SetData, SetData) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->EnumFormatEtc, EnumFormatEtc) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->DAdvise, DAdvise) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->DUnadvise, DUnadvise) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->EnumDAdvise, EnumDAdvise));
}


/*
** IsValidPCIMalloc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIMalloc(PCIMalloc pcimalloc)
{
   return(IS_VALID_READ_PTR(pcimalloc, CIMalloc) &&
          IS_VALID_READ_PTR(pcimalloc->lpVtbl, sizeof(*(pcimalloc->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcimalloc, CIUnknown) &&
          IS_VALID_CODE_PTR(pcimalloc->lpVtbl->Alloc, Alloc) &&
          IS_VALID_CODE_PTR(pcimalloc->lpVtbl->Realloc, Realloc) &&
          IS_VALID_CODE_PTR(pcimalloc->lpVtbl->Free, Free) &&
          IS_VALID_CODE_PTR(pcimalloc->lpVtbl->GetSize, GetSize) &&
          IS_VALID_CODE_PTR(pcimalloc->lpVtbl->DidAlloc, DidAlloc) &&
          IS_VALID_CODE_PTR(pcimalloc->lpVtbl->HeapMinimize, HeapMinimize));
}


/*
** IsValidPCIMoniker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIMoniker(PCIMoniker pcimk)
{
   return(IS_VALID_READ_PTR(pcimk, CIMoniker) &&
          IS_VALID_READ_PTR(pcimk->lpVtbl, sizeof(*(pcimk->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIPersistStream)pcimk, CIPersistStream) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->BindToObject, BindToObject) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->BindToStorage, BindToStorage) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->Reduce, Reduce) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->ComposeWith, ComposeWith) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->Enum, Enum) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->IsEqual, IsEqual) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->Hash, Hash) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->IsRunning, IsRunning) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->GetTimeOfLastChange, GetTimeOfLastChange) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->Inverse, Inverse) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->CommonPrefixWith, CommonPrefixWith) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->RelativePathTo, RelativePathTo) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->GetDisplayName, GetDisplayName) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->ParseDisplayName, ParseDisplayName) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->IsSystemMoniker, IsSystemMoniker));
}


/*
** IsValidPCIPersist()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIPersist(PCIPersist pcip)
{
   return(IS_VALID_READ_PTR(pcip, CIUnknown) &&
          IS_VALID_READ_PTR(pcip->lpVtbl, sizeof(*(pcip->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcip, CIUnknown) &&
          IS_VALID_CODE_PTR(pcip->lpVtbl->GetClassID, GetClassID));
}


/*
** IsValidPCIPersistFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIPersistFile(PCIPersistFile pcipfile)
{
   return(IS_VALID_READ_PTR(pcipfile, CIPersistFile) &&
          IS_VALID_READ_PTR(pcipfile->lpVtbl, sizeof(*(pcipfile->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIPersist)pcipfile, CIPersist) &&
          IS_VALID_CODE_PTR(pcipfile->lpVtbl->IsDirty, IsDirty) &&
          IS_VALID_CODE_PTR(pcipfile->lpVtbl->Load, Load) &&
          IS_VALID_CODE_PTR(pcipfile->lpVtbl->Save, Save) &&
          IS_VALID_CODE_PTR(pcipfile->lpVtbl->SaveCompleted, SaveCompleted) &&
          IS_VALID_CODE_PTR(pcipfile->lpVtbl->GetCurFile, GetCurFile));
}


/*
** IsValidPCIPersistStorage()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIPersistStorage(PCIPersistStorage pcipstg)
{
   return(IS_VALID_READ_PTR(pcipstg, CIPersistStorage) &&
          IS_VALID_READ_PTR(pcipstg->lpVtbl, sizeof(*(pcipstg->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIPersist)pcipstg, CIPersist) &&
          IS_VALID_CODE_PTR(pcipstg->lpVtbl->IsDirty, IsDirty) &&
          IS_VALID_CODE_PTR(pcipstg->lpVtbl->InitNew, InitNew) &&
          IS_VALID_CODE_PTR(pcipstg->lpVtbl->Load, Load) &&
          IS_VALID_CODE_PTR(pcipstg->lpVtbl->Save, Save) &&
          IS_VALID_CODE_PTR(pcipstg->lpVtbl->SaveCompleted, SaveCompleted) &&
          IS_VALID_CODE_PTR(pcipstg->lpVtbl->HandsOffStorage, HandsOffStorage));
}


/*
** IsValidPCIPersistStream()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIPersistStream(PCIPersistStream pcipstr)
{
   return(IS_VALID_READ_PTR(pcipstr, CIPersistStream) &&
          IS_VALID_READ_PTR(pcipstr->lpVtbl, sizeof(*(pcipstr->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIPersist)pcipstr, CIPersist) &&
          IS_VALID_CODE_PTR(pcipstr->lpVtbl->IsDirty, IsDirty) &&
          IS_VALID_CODE_PTR(pcipstr->lpVtbl->Load, Load) &&
          IS_VALID_CODE_PTR(pcipstr->lpVtbl->Save, Save) &&
          IS_VALID_CODE_PTR(pcipstr->lpVtbl->GetSizeMax, GetSizeMax));
}


/*
** IsValidPCIStorage()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIStorage(PCIStorage pcistg)
{
   return(IS_VALID_READ_PTR(pcistg, CIStorage) &&
          IS_VALID_READ_PTR(pcistg->lpVtbl, sizeof(*(pcistg->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcistg, CIUnknown) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->CreateStream, CreateStream) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->OpenStream, OpenStream) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->CreateStorage, CreateStorage) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->OpenStorage, OpenStorage) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->CopyTo, CopyTo) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->MoveElementTo, MoveElementTo) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->Commit, Commit) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->Revert, Revert) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->EnumElements, EnumElements) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->DestroyElement, DestroyElement) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->RenameElement, RenameElement) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->SetElementTimes, SetElementTimes) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->SetClass, SetClass) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->SetStateBits, SetStateBits) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->Stat, Stat));
}


/*
** IsValidPCIStream()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIStream(PCIStream pcistr)
{
   return(IS_VALID_READ_PTR(pcistr, CIStorage) &&
          IS_VALID_READ_PTR(pcistr->lpVtbl, sizeof(*(pcistr->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcistr, CIUnknown) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->Read, Read) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->Write, Write) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->Seek, Seek) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->SetSize, SetSize) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->CopyTo, CopyTo) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->Commit, Commit) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->Revert, Revert) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->LockRegion, LockRegion) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->UnlockRegion, UnlockRegion) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->Stat, Stat) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->Clone, Clone));
}


/*
** IsValidPCIUnknown()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIUnknown(PCIUnknown pciunk)
{
   return(IS_VALID_READ_PTR(pciunk, CIUnknown) &&
          IS_VALID_READ_PTR(pciunk->lpVtbl, sizeof(*(pciunk->lpVtbl))) &&
          IS_VALID_CODE_PTR(pciunk->lpVtbl->QueryInterface, QueryInterface) &&
          IS_VALID_CODE_PTR(pciunk->lpVtbl->AddRef, AddRef) &&
          IS_VALID_CODE_PTR(pciunk->lpVtbl->Release, Release));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\pch.c ===
/*
 * pch.c - Precompiled header file source.
 */

#include "project.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\path.h ===
/*
 * path.h - Path ADT module description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HPATHLIST);
DECLARE_STANDARD_TYPES(HPATHLIST);

DECLARE_HANDLE(HPATH);
DECLARE_STANDARD_TYPES(HPATH);

/* path results returned by AddPath() */

typedef enum _pathresult
{
   PR_SUCCESS,

   PR_UNAVAILABLE_VOLUME,

   PR_OUT_OF_MEMORY,

   PR_INVALID_PATH
}
PATHRESULT;
DECLARE_STANDARD_TYPES(PATHRESULT);


/* Prototypes
 *************/

/* path.c */

extern BOOL CreatePathList(DWORD, HWND, PHPATHLIST);
extern void DestroyPathList(HPATHLIST);
extern void InvalidatePathListInfo(HPATHLIST);
extern void ClearPathListInfo(HPATHLIST);
extern PATHRESULT AddPath(HPATHLIST, LPCTSTR, PHPATH);
extern BOOL AddChildPath(HPATHLIST, HPATH, LPCTSTR, PHPATH);
extern void DeletePath(HPATH);
extern BOOL CopyPath(HPATH, HPATHLIST, PHPATH);
extern void GetPathString(HPATH, LPTSTR, int);
extern void GetPathRootString(HPATH, LPTSTR, int);
extern void GetPathSuffixString(HPATH, LPTSTR);
extern BOOL AllocatePathString(HPATH, LPTSTR *);

#ifdef DEBUG

extern LPCTSTR DebugGetPathString(HPATH);
extern ULONG GetPathCount(HPATHLIST);

#endif

extern BOOL IsPathVolumeAvailable(HPATH);
extern HVOLUMEID GetPathVolumeID(HPATH);
extern BOOL MyIsPathOnVolume(LPCTSTR, HPATH);
extern COMPARISONRESULT ComparePaths(HPATH, HPATH);
extern COMPARISONRESULT ComparePathVolumes(HPATH, HPATH);
extern BOOL IsPathPrefix(HPATH, HPATH);
extern BOOL SubtreesIntersect(HPATH, HPATH);
extern LPTSTR FindEndOfRootSpec(LPCTSTR, HPATH);
extern COMPARISONRESULT ComparePointers(PCVOID, PCVOID);
extern LPTSTR FindChildPathSuffix(HPATH, HPATH, LPTSTR);
extern TWINRESULT TWINRESULTFromLastError(TWINRESULT);
extern BOOL IsValidHPATH(HPATH);
extern BOOL IsValidHVOLUMEID(HVOLUMEID);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidHPATHLIST(HPATHLIST);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\path.c ===
/*
 * path.c - Path ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "volume.h"


/* Constants
 ************/

/* PATHLIST PTRARRAY allocation parameters */

#define NUM_START_PATHS          (32)
#define NUM_PATHS_TO_ADD         (32)

/* PATHLIST string table allocation parameters */

#define NUM_PATH_HASH_BUCKETS    (67)


/* Types
 ********/

/* path list */

typedef struct _pathlist
{
    /* array of pointers to PATHs */

    HPTRARRAY hpa;

    /* list of volumes */

    HVOLUMELIST hvl;

    /* table of path suffix strings */

    HSTRINGTABLE hst;
}
PATHLIST;
DECLARE_STANDARD_TYPES(PATHLIST);

/* path structure */

typedef struct _path
{
    /* reference count */

    ULONG ulcLock;

    /* handle to parent volume */

    HVOLUME hvol;

    /* handle to path suffix string */

    HSTRING hsPathSuffix;

    /* pointer to PATH's parent PATHLIST */

    PPATHLIST pplParent;
}
PATH;
DECLARE_STANDARD_TYPES(PATH);

/* PATH search structure used by PathSearchCmp() */

typedef struct _pathsearchinfo
{
    HVOLUME hvol;

    LPCTSTR pcszPathSuffix;
}
PATHSEARCHINFO;
DECLARE_STANDARD_TYPES(PATHSEARCHINFO);

/* database path list header */

typedef struct _dbpathlistheader
{
    /* number of paths in list */

    LONG lcPaths;
}
DBPATHLISTHEADER;
DECLARE_STANDARD_TYPES(DBPATHLISTHEADER);

/* database path structure */

typedef struct _dbpath
{
    /* old handle to path */

    HPATH hpath;

    /* old handle to parent volume */

    HVOLUME hvol;

    /* old handle to path suffix string */

    HSTRING hsPathSuffix;
}
DBPATH;
DECLARE_STANDARD_TYPES(DBPATH);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE COMPARISONRESULT PathSortCmp(PCVOID, PCVOID);
PRIVATE_CODE COMPARISONRESULT PathSearchCmp(PCVOID, PCVOID);
PRIVATE_CODE BOOL UnifyPath(PPATHLIST, HVOLUME, LPCTSTR, PPATH *);
PRIVATE_CODE BOOL CreatePath(PPATHLIST, HVOLUME, LPCTSTR, PPATH *);
PRIVATE_CODE void DestroyPath(PPATH);
PRIVATE_CODE void UnlinkPath(PCPATH);
PRIVATE_CODE void LockPath(PPATH);
PRIVATE_CODE BOOL UnlockPath(PPATH);
PRIVATE_CODE PATHRESULT TranslateVOLUMERESULTToPATHRESULT(VOLUMERESULT);
PRIVATE_CODE TWINRESULT WritePath(HCACHEDFILE, PPATH);
PRIVATE_CODE TWINRESULT ReadPath(HCACHEDFILE, PPATHLIST, HHANDLETRANS, HHANDLETRANS, HHANDLETRANS);

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL IsValidPCPATHLIST(PCPATHLIST);
PRIVATE_CODE BOOL IsValidPCPATH(PCPATH);

#endif

#if defined(DEBUG)

PRIVATE_CODE BOOL IsValidPCPATHSEARCHINFO(PCPATHSEARCHINFO);

#endif


/*
 ** PathSortCmp()
 **
 ** Pointer comparison function used to sort the module array of paths.
 **
 ** Arguments:     pcpath1 - pointer to first path
 **                pcpath2 - pointer to second path
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** The internal paths are sorted by:
 **    1) volume
 **    2) path suffix
 **    3) pointer value
 */
PRIVATE_CODE COMPARISONRESULT PathSortCmp(PCVOID pcpath1, PCVOID pcpath2)
{
    COMPARISONRESULT cr;

    ASSERT(IS_VALID_STRUCT_PTR(pcpath1, CPATH));
    ASSERT(IS_VALID_STRUCT_PTR(pcpath2, CPATH));

    cr = CompareVolumes(((PCPATH)pcpath1)->hvol,
            ((PCPATH)pcpath2)->hvol);

    if (cr == CR_EQUAL)
    {
        cr = ComparePathStringsByHandle(((PCPATH)pcpath1)->hsPathSuffix,
                ((PCPATH)pcpath2)->hsPathSuffix);

        if (cr == CR_EQUAL)
            cr = ComparePointers(pcpath1, pcpath2);
    }

    return(cr);
}


/*
 ** PathSearchCmp()
 **
 ** Pointer comparison function used to search for a path.
 **
 ** Arguments:     pcpathsi - pointer to PATHSEARCHINFO describing path to
 **                           search for
 **                pcpath - pointer to path to examine
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** The internal paths are searched by:
 **    1) volume
 **    2) path suffix string
 */
PRIVATE_CODE COMPARISONRESULT PathSearchCmp(PCVOID pcpathsi, PCVOID pcpath)
{
    COMPARISONRESULT cr;

    ASSERT(IS_VALID_STRUCT_PTR(pcpathsi, CPATHSEARCHINFO));
    ASSERT(IS_VALID_STRUCT_PTR(pcpath, CPATH));

    cr = CompareVolumes(((PCPATHSEARCHINFO)pcpathsi)->hvol,
            ((PCPATH)pcpath)->hvol);

    if (cr == CR_EQUAL)
        cr = ComparePathStrings(((PCPATHSEARCHINFO)pcpathsi)->pcszPathSuffix,
                GetString(((PCPATH)pcpath)->hsPathSuffix));

    return(cr);
}


/*
 ** UnifyPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL UnifyPath(PPATHLIST ppl, HVOLUME hvol, LPCTSTR pcszPathSuffix,
        PPATH *pppath)
{
    BOOL bResult = FALSE;

    ASSERT(IS_VALID_STRUCT_PTR(ppl, CPATHLIST));
    ASSERT(IS_VALID_HANDLE(hvol, VOLUME));
    ASSERT(IsValidPathSuffix(pcszPathSuffix));
    ASSERT(IS_VALID_WRITE_PTR(pppath, PPATH));

    /* Allocate space for PATH structure. */

    if (AllocateMemory(sizeof(**pppath), pppath))
    {
        if (CopyVolume(hvol, ppl->hvl, &((*pppath)->hvol)))
        {
            if (AddString(pcszPathSuffix, ppl->hst, GetHashBucketIndex, &((*pppath)->hsPathSuffix)))
            {
                ARRAYINDEX aiUnused;

                /* Initialize remaining PATH fields. */

                (*pppath)->ulcLock = 0;
                (*pppath)->pplParent = ppl;

                /* Add new PATH to array. */

                if (AddPtr(ppl->hpa, PathSortCmp, *pppath, &aiUnused))
                    bResult = TRUE;
                else
                {
                    DeleteString((*pppath)->hsPathSuffix);
UNIFYPATH_BAIL1:
                    DeleteVolume((*pppath)->hvol);
UNIFYPATH_BAIL2:
                    FreeMemory(*pppath);
                }
            }
            else
                goto UNIFYPATH_BAIL1;
        }
        else
            goto UNIFYPATH_BAIL2;
    }

    ASSERT(! bResult ||
            IS_VALID_STRUCT_PTR(*pppath, CPATH));

    return(bResult);
}


/*
 ** CreatePath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CreatePath(PPATHLIST ppl, HVOLUME hvol, LPCTSTR pcszPathSuffix,
        PPATH *pppath)
{
    BOOL bResult;
    ARRAYINDEX aiFound;
    PATHSEARCHINFO pathsi;

    ASSERT(IS_VALID_STRUCT_PTR(ppl, CPATHLIST));
    ASSERT(IS_VALID_HANDLE(hvol, VOLUME));
    ASSERT(IsValidPathSuffix(pcszPathSuffix));
    ASSERT(IS_VALID_WRITE_PTR(pppath, CPATH));

    /* Does a path for the given volume and path suffix already exist? */

    pathsi.hvol = hvol;
    pathsi.pcszPathSuffix = pcszPathSuffix;

    bResult = SearchSortedArray(ppl->hpa, &PathSearchCmp, &pathsi, &aiFound);

    if (bResult)
        /* Yes.  Return it. */
        *pppath = GetPtr(ppl->hpa, aiFound);
    else
        bResult = UnifyPath(ppl, hvol, pcszPathSuffix, pppath);

    if (bResult)
        LockPath(*pppath);

    ASSERT(! bResult ||
            IS_VALID_STRUCT_PTR(*pppath, CPATH));

    return(bResult);
}


/*
 ** DestroyPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DestroyPath(PPATH ppath)
{
    ASSERT(IS_VALID_STRUCT_PTR(ppath, CPATH));

    DeleteVolume(ppath->hvol);
    DeleteString(ppath->hsPathSuffix);
    FreeMemory(ppath);

    return;
}


/*
 ** UnlinkPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void UnlinkPath(PCPATH pcpath)
{
    HPTRARRAY hpa;
    ARRAYINDEX aiFound;

    ASSERT(IS_VALID_STRUCT_PTR(pcpath, CPATH));

    hpa = pcpath->pplParent->hpa;

    if (EVAL(SearchSortedArray(hpa, &PathSortCmp, pcpath, &aiFound)))
    {
        ASSERT(GetPtr(hpa, aiFound) == pcpath);

        DeletePtr(hpa, aiFound);
    }

    return;
}


/*
 ** LockPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void LockPath(PPATH ppath)
{
    ASSERT(IS_VALID_STRUCT_PTR(ppath, CPATH));

    ASSERT(ppath->ulcLock < ULONG_MAX);
    ppath->ulcLock++;

    return;
}


/*
 ** UnlockPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL UnlockPath(PPATH ppath)
{
    ASSERT(IS_VALID_STRUCT_PTR(ppath, CPATH));

    if (EVAL(ppath->ulcLock > 0))
        ppath->ulcLock--;

    return(ppath->ulcLock > 0);
}


/*
 ** TranslateVOLUMERESULTToPATHRESULT()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE PATHRESULT TranslateVOLUMERESULTToPATHRESULT(VOLUMERESULT vr)
{
    PATHRESULT pr;

    switch (vr)
    {
        case VR_SUCCESS:
            pr = PR_SUCCESS;
            break;

        case VR_UNAVAILABLE_VOLUME:
            pr = PR_UNAVAILABLE_VOLUME;
            break;

        case VR_OUT_OF_MEMORY:
            pr = PR_OUT_OF_MEMORY;
            break;

        default:
            ASSERT(vr == VR_INVALID_PATH);
            pr = PR_INVALID_PATH;
            break;
    }

    return(pr);
}


/*
 ** WritePath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT WritePath(HCACHEDFILE hcf, PPATH ppath)
{
    TWINRESULT tr;
    DBPATH dbpath;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_STRUCT_PTR(ppath, CPATH));

    /* Write database path. */

    dbpath.hpath = (HPATH)ppath;
    dbpath.hvol = ppath->hvol;
    dbpath.hsPathSuffix = ppath->hsPathSuffix;

    if (WriteToCachedFile(hcf, (PCVOID)&dbpath, sizeof(dbpath), NULL))
        tr = TR_SUCCESS;
    else
        tr = TR_BRIEFCASE_WRITE_FAILED;

    return(tr);
}


/*
 ** ReadPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT ReadPath(HCACHEDFILE hcf, PPATHLIST ppl,
        HHANDLETRANS hhtVolumes,
        HHANDLETRANS hhtStrings,
        HHANDLETRANS hhtPaths)
{
    TWINRESULT tr;
    DBPATH dbpath;
    DWORD dwcbRead;
    HVOLUME hvol;
    HSTRING hsPathSuffix;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_STRUCT_PTR(ppl, CPATHLIST));
    ASSERT(IS_VALID_HANDLE(hhtVolumes, HANDLETRANS));
    ASSERT(IS_VALID_HANDLE(hhtStrings, HANDLETRANS));
    ASSERT(IS_VALID_HANDLE(hhtPaths, HANDLETRANS));

    if (ReadFromCachedFile(hcf, &dbpath, sizeof(dbpath), &dwcbRead) &&
            dwcbRead == sizeof(dbpath) &&
            TranslateHandle(hhtVolumes, (HGENERIC)(dbpath.hvol), (PHGENERIC)&hvol) &&
            TranslateHandle(hhtStrings, (HGENERIC)(dbpath.hsPathSuffix), (PHGENERIC)&hsPathSuffix))
    {
        PPATH ppath;

        if (CreatePath(ppl, hvol, GetString(hsPathSuffix), &ppath))
        {
            /*
             * To leave read paths with 0 initial lock count, we must undo
             * the LockPath() performed by CreatePath().
             */

            UnlockPath(ppath);

            if (AddHandleToHandleTranslator(hhtPaths,
                        (HGENERIC)(dbpath.hpath),
                        (HGENERIC)ppath))
                tr = TR_SUCCESS;
            else
            {
                UnlinkPath(ppath);
                DestroyPath(ppath);

                tr = TR_OUT_OF_MEMORY;
            }
        }
        else
            tr = TR_OUT_OF_MEMORY;
    }
    else
        tr = TR_CORRUPT_BRIEFCASE;

    return(tr);
}


#if defined(DEBUG) || defined(VSTF)

/*
 ** IsValidPCPATHLIST()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCPATHLIST(PCPATHLIST pcpl)
{
    return(IS_VALID_READ_PTR(pcpl, CPATHLIST) &&
            IS_VALID_HANDLE(pcpl->hpa, PTRARRAY) &&
            IS_VALID_HANDLE(pcpl->hvl, VOLUMELIST) &&
            IS_VALID_HANDLE(pcpl->hst, STRINGTABLE));
}


/*
 ** IsValidPCPATH()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCPATH(PCPATH pcpath)
{
    return(IS_VALID_READ_PTR(pcpath, CPATH) &&
            IS_VALID_HANDLE(pcpath->hvol, VOLUME) &&
            IS_VALID_HANDLE(pcpath->hsPathSuffix, STRING) &&
            IsValidPathSuffix(GetString(pcpath->hsPathSuffix)) &&
            IS_VALID_READ_PTR(pcpath->pplParent, CPATHLIST));
}

#endif


#if defined(DEBUG)

/*
 ** IsValidPCPATHSEARCHINFO()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCPATHSEARCHINFO(PCPATHSEARCHINFO pcpathsi)
{
    return(IS_VALID_READ_PTR(pcpathsi, CPATHSEARCHINFO) &&
            IS_VALID_HANDLE(pcpathsi->hvol, VOLUME) &&
            IsValidPathSuffix(pcpathsi->pcszPathSuffix));
}

#endif


/****************************** Public Functions *****************************/


/*
 ** CreatePathList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL CreatePathList(DWORD dwFlags, HWND hwndOwner, PHPATHLIST phpl)
{
    BOOL bResult = FALSE;
    PPATHLIST ppl;

    ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_RLI_IFLAGS));
    ASSERT(IS_FLAG_CLEAR(dwFlags, RLI_IFL_ALLOW_UI) ||
            IS_VALID_HANDLE(hwndOwner, WND));
    ASSERT(IS_VALID_WRITE_PTR(phpl, HPATHLIST));

    if (AllocateMemory(sizeof(*ppl), &ppl))
    {
        NEWPTRARRAY npa;

        /* Create pointer array of paths. */

        npa.aicInitialPtrs = NUM_START_PATHS;
        npa.aicAllocGranularity = NUM_PATHS_TO_ADD;
        npa.dwFlags = NPA_FL_SORTED_ADD;

        if (CreatePtrArray(&npa, &(ppl->hpa)))
        {
            if (CreateVolumeList(dwFlags, hwndOwner, &(ppl->hvl)))
            {
                NEWSTRINGTABLE nszt;

                /* Create string table for path suffix strings. */

                nszt.hbc = NUM_PATH_HASH_BUCKETS;

                if (CreateStringTable(&nszt, &(ppl->hst)))
                {
                    *phpl = (HPATHLIST)ppl;
                    bResult = TRUE;
                }
                else
                {
                    DestroyVolumeList(ppl->hvl);
CREATEPATHLIST_BAIL1:
                    DestroyPtrArray(ppl->hpa);
CREATEPATHLIST_BAIL2:
                    FreeMemory(ppl);
                }
            }
            else
                goto CREATEPATHLIST_BAIL1;
        }
        else
            goto CREATEPATHLIST_BAIL2;
    }

    ASSERT(! bResult ||
            IS_VALID_HANDLE(*phpl, PATHLIST));

    return(bResult);
}


/*
 ** DestroyPathList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DestroyPathList(HPATHLIST hpl)
{
    ARRAYINDEX aicPtrs;
    ARRAYINDEX ai;

    ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));

    /* First free all paths in array. */

    aicPtrs = GetPtrCount(((PCPATHLIST)hpl)->hpa);

    for (ai = 0; ai < aicPtrs; ai++)
        DestroyPath(GetPtr(((PCPATHLIST)hpl)->hpa, ai));

    /* Now wipe out the array. */

    DestroyPtrArray(((PCPATHLIST)hpl)->hpa);

    ASSERT(! GetVolumeCount(((PCPATHLIST)hpl)->hvl));
    DestroyVolumeList(((PCPATHLIST)hpl)->hvl);

    ASSERT(! GetStringCount(((PCPATHLIST)hpl)->hst));
    DestroyStringTable(((PCPATHLIST)hpl)->hst);

    FreeMemory((PPATHLIST)hpl);

    return;
}


/*
 ** InvalidatePathListInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void InvalidatePathListInfo(HPATHLIST hpl)
{
    InvalidateVolumeListInfo(((PCPATHLIST)hpl)->hvl);

    return;
}


/*
 ** ClearPathListInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void ClearPathListInfo(HPATHLIST hpl)
{
    ClearVolumeListInfo(((PCPATHLIST)hpl)->hvl);

    return;
}


/*
 ** AddPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */

PUBLIC_CODE PATHRESULT AddPath(HPATHLIST hpl, LPCTSTR pcszPath, PHPATH phpath)
{
    PATHRESULT pr;
    HVOLUME hvol;
    TCHAR rgchPathSuffix[MAX_PATH_LEN];
    LPCTSTR     pszPath;

#ifdef UNICODE
    WCHAR szUnicode[MAX_PATH];
#endif

    ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
    ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(phpath, HPATH));

    // On NT, we want to convert a unicode string to an ANSI shortened path for
    // the sake of interop

#if defined(UNICODE) 
    {
        CHAR szAnsi[MAX_PATH];
        szUnicode[0] = L'\0';

        WideCharToMultiByte(CP_ACP, 0, pcszPath, -1, szAnsi, ARRAYSIZE(szAnsi), NULL, NULL);
        MultiByteToWideChar(CP_ACP, 0, szAnsi,   -1, szUnicode, ARRAYSIZE(szUnicode));
        if (lstrcmp(szUnicode, pcszPath))
        {
            // Cannot convert losslessly from Unicode -> Ansi, so get the short path

            lstrcpyn(szUnicode, pcszPath, ARRAYSIZE(szUnicode));
            SheShortenPath(szUnicode, TRUE);
            pszPath = szUnicode;
        }
        else
        {
            // It will convert OK, so just use the original

            pszPath = pcszPath;
        }
    }
#else
    pszPath = pcszPath;
#endif

    pr = TranslateVOLUMERESULTToPATHRESULT(
            AddVolume(((PCPATHLIST)hpl)->hvl, pszPath, &hvol, rgchPathSuffix, ARRAYSIZE(rgchPathSuffix)));

    if (pr == PR_SUCCESS)
    {
        PPATH ppath;

        if (CreatePath((PPATHLIST)hpl, hvol, rgchPathSuffix, &ppath))
            *phpath = (HPATH)ppath;
        else
            pr = PR_OUT_OF_MEMORY;

        DeleteVolume(hvol);
    }

    ASSERT(pr != PR_SUCCESS ||
            IS_VALID_HANDLE(*phpath, PATH));

    return(pr);
}


/*
 ** AddChildPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL AddChildPath(HPATHLIST hpl, HPATH hpathParent,
        LPCTSTR pcszSubPath, PHPATH phpathChild)
{
    BOOL bResult;
    TCHAR rgchChildPathSuffix[MAX_PATH_LEN];
    LPCTSTR pcszPathSuffix;
    LPTSTR pszPathSuffixEnd;
    PPATH ppathChild;

    ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
    ASSERT(IS_VALID_HANDLE(hpathParent, PATH));
    ASSERT(IS_VALID_STRING_PTR(pcszSubPath, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(phpathChild, HPATH));

    ComposePath(rgchChildPathSuffix, 
            GetString(((PCPATH)hpathParent)->hsPathSuffix), 
            pcszSubPath, ARRAYSIZE(rgchChildPathSuffix));

    pcszPathSuffix = rgchChildPathSuffix;

    if (IS_SLASH(*pcszPathSuffix))
        pcszPathSuffix++;

    pszPathSuffixEnd = CharPrev(pcszPathSuffix,
            pcszPathSuffix + lstrlen(pcszPathSuffix));

    if (IS_SLASH(*pszPathSuffixEnd))
        *pszPathSuffixEnd = TEXT('\0');

    ASSERT(IsValidPathSuffix(pcszPathSuffix));

    bResult = CreatePath((PPATHLIST)hpl, ((PCPATH)hpathParent)->hvol,
            pcszPathSuffix, &ppathChild);

    if (bResult)
        *phpathChild = (HPATH)ppathChild;

    ASSERT(! bResult ||
            IS_VALID_HANDLE(*phpathChild, PATH));

    return(bResult);
}


/*
 ** DeletePath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DeletePath(HPATH hpath)
{
    ASSERT(IS_VALID_HANDLE(hpath, PATH));

    if (! UnlockPath((PPATH)hpath))
    {
        UnlinkPath((PPATH)hpath);
        DestroyPath((PPATH)hpath);
    }

    return;
}


/*
 ** CopyPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL CopyPath(HPATH hpathSrc, HPATHLIST hplDest, PHPATH phpathCopy)
{
    BOOL bResult;
    PPATH ppath;

    ASSERT(IS_VALID_HANDLE(hpathSrc, PATH));
    ASSERT(IS_VALID_HANDLE(hplDest, PATHLIST));
    ASSERT(IS_VALID_WRITE_PTR(phpathCopy, HPATH));

    /* Is the destination path list the source path's path list? */

    if (((PCPATH)hpathSrc)->pplParent == (PCPATHLIST)hplDest)
    {
        /* Yes.  Use the source path. */

        LockPath((PPATH)hpathSrc);
        ppath = (PPATH)hpathSrc;
        bResult = TRUE;
    }
    else
        bResult = CreatePath((PPATHLIST)hplDest, ((PCPATH)hpathSrc)->hvol,
                GetString(((PCPATH)hpathSrc)->hsPathSuffix),
                &ppath);

    if (bResult)
        *phpathCopy = (HPATH)ppath;

    ASSERT(! bResult ||
            IS_VALID_HANDLE(*phpathCopy, PATH));

    return(bResult);
}


/*
 ** GetPathString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void GetPathString(HPATH hpath, LPTSTR pszPathBuf, int cchMax)
{
    ASSERT(IS_VALID_HANDLE(hpath, PATH));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPathBuf, STR, cchMax));

    GetPathRootString(hpath, pszPathBuf, cchMax);
    CatPath(pszPathBuf, GetString(((PPATH)hpath)->hsPathSuffix), cchMax);

    ASSERT(IsCanonicalPath(pszPathBuf));

    return;
}


/*
 ** GetPathRootString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void GetPathRootString(HPATH hpath, LPTSTR pszPathRootBuf, int cchMax)
{
    ASSERT(IS_VALID_HANDLE(hpath, PATH));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPathRootBuf, STR, cchMax));

    GetVolumeRootPath(((PPATH)hpath)->hvol, pszPathRootBuf, cchMax);

    ASSERT(IsCanonicalPath(pszPathRootBuf));

    return;
}


/*
 ** GetPathSuffixString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void GetPathSuffixString(HPATH hpath, LPTSTR pszPathSuffixBuf)
{
    ASSERT(IS_VALID_HANDLE(hpath, PATH));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPathSuffixBuf, STR, MAX_PATH_LEN));

    ASSERT(lstrlen(GetString(((PPATH)hpath)->hsPathSuffix)) < MAX_PATH_LEN);
    MyLStrCpyN(pszPathSuffixBuf, GetString(((PPATH)hpath)->hsPathSuffix), MAX_PATH_LEN);

    ASSERT(IsValidPathSuffix(pszPathSuffixBuf));

    return;
}


/*
 ** AllocatePathString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL AllocatePathString(HPATH hpath, LPTSTR *ppszPath)
{
    TCHAR rgchPath[MAX_PATH_LEN];

    ASSERT(IS_VALID_HANDLE(hpath, PATH));
    ASSERT(IS_VALID_WRITE_PTR(ppszPath, LPTSTR));

    GetPathString(hpath, rgchPath, ARRAYSIZE(rgchPath));

    return(StringCopy(rgchPath, ppszPath));
}


#ifdef DEBUG

/*
 ** DebugGetPathString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** N.b., DebugGetPathString() must be non-intrusive.
 */
PUBLIC_CODE LPCTSTR DebugGetPathString(HPATH hpath)
{
    /* Allow 4 debug paths. */
    static TCHAR SrgrgchPaths[][MAX_PATH_LEN] = { TEXT(""), TEXT(""), TEXT(""), TEXT("") };
    static UINT SuiPath = 0;
    LPTSTR pszPath;

    ASSERT(IS_VALID_HANDLE(hpath, PATH));

    pszPath = SrgrgchPaths[SuiPath];

    DebugGetVolumeRootPath(((PPATH)hpath)->hvol, pszPath, ARRAYSIZE(SrgrchPaths[SuiPath]));
    CatPath(pszPath, GetString(((PPATH)hpath)->hsPathSuffix), ARRAYSIZE(SrgrchPaths[SuiPath]));

    SuiPath++;
    SuiPath %= ARRAY_ELEMENTS(SrgrgchPaths);

    return(pszPath);
}


/*
 ** GetPathCount()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE ULONG GetPathCount(HPATHLIST hpl)
{
    ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));

    return(GetPtrCount(((PCPATHLIST)hpl)->hpa));
}

#endif


/*
 ** IsPathVolumeAvailable()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsPathVolumeAvailable(HPATH hpath)
{
    ASSERT(IS_VALID_HANDLE(hpath, PATH));

    return(IsVolumeAvailable(((PCPATH)hpath)->hvol));
}


/*
 ** GetPathVolumeID()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HVOLUMEID GetPathVolumeID(HPATH hpath)
{
    ASSERT(IS_VALID_HANDLE(hpath, PATH));

    return((HVOLUMEID)hpath);
}


/*
 ** MyIsPathOnVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** MyIsPathOnVolume() will fail for a new root path alias for a volume.  E.g.,
 ** if the same net resource is connected to both X: and Y:, MyIsPathOnVolume()
 ** will only return TRUE for the drive root path that the net resource was
 ** connected to through the given HVOLUME.
 */
PUBLIC_CODE BOOL MyIsPathOnVolume(LPCTSTR pcszPath, HPATH hpath)
{
    BOOL bResult;
    TCHAR rgchVolumeRootPath[MAX_PATH_LEN];

    ASSERT(IsFullPath(pcszPath));
    ASSERT(IS_VALID_HANDLE(hpath, PATH));

    rgchVolumeRootPath[0] = TEXT('\0');
    if (IsVolumeAvailable(((PPATH)hpath)->hvol))
    {
        GetVolumeRootPath(((PPATH)hpath)->hvol, rgchVolumeRootPath, ARRAYSIZE(rgchVolumeRootPath));

        bResult = (MyLStrCmpNI(pcszPath, rgchVolumeRootPath,
                    lstrlen(rgchVolumeRootPath))
                == CR_EQUAL);
    }
    else
    {
        TRACE_OUT((TEXT("MyIsPathOnVolume(): Failing on unavailable volume %s."),
                    DebugGetVolumeRootPath(((PPATH)hpath)->hvol, rgchVolumeRootPath, 
                        ARRAYSIZE(rgchVolumeRootPath))));

        bResult = FALSE;
    }

    return(bResult);
}


/*
 ** ComparePaths()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** PATHs are compared by:
 **    1) volume
 **    2) path suffix
 */
PUBLIC_CODE COMPARISONRESULT ComparePaths(HPATH hpath1, HPATH hpath2)
{
    COMPARISONRESULT cr;

    ASSERT(IS_VALID_HANDLE(hpath1, PATH));
    ASSERT(IS_VALID_HANDLE(hpath2, PATH));

    /* This comparison works across path lists. */

    cr = ComparePathVolumes(hpath1, hpath2);

    if (cr == CR_EQUAL)
        cr = ComparePathStringsByHandle(((PCPATH)hpath1)->hsPathSuffix,
                ((PCPATH)hpath2)->hsPathSuffix);

    return(cr);
}


/*
 ** ComparePathVolumes()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE COMPARISONRESULT ComparePathVolumes(HPATH hpath1, HPATH hpath2)
{
    ASSERT(IS_VALID_HANDLE(hpath1, PATH));
    ASSERT(IS_VALID_HANDLE(hpath2, PATH));

    return(CompareVolumes(((PCPATH)hpath1)->hvol, ((PCPATH)hpath2)->hvol));
}


/*
 ** IsPathPrefix()
 **
 ** Determines whether or not one path is a prefix of another.
 **
 ** Arguments:     hpathChild - whole path (longer or same length)
 **                hpathParent - prefix path to test (shorter or same length)
 **
 ** Returns:       TRUE if the second path is a prefix of the first path.  FALSE
 **                if not.
 **
 ** Side Effects:  none
 **
 ** Read 'IsPathPrefix(A, B)' as 'Is A in B's subtree?'.
 */
PUBLIC_CODE BOOL IsPathPrefix(HPATH hpathChild, HPATH hpathParent)
{
    BOOL bResult;

    ASSERT(IS_VALID_HANDLE(hpathParent, PATH));
    ASSERT(IS_VALID_HANDLE(hpathChild, PATH));

    if (ComparePathVolumes(hpathParent, hpathChild) == CR_EQUAL)
    {
        TCHAR rgchParentSuffix[MAX_PATH_LEN];
        TCHAR rgchChildSuffix[MAX_PATH_LEN];
        int nParentSuffixLen;
        int nChildSuffixLen;

        /* Ignore path roots when comparing path strings. */

        GetPathSuffixString(hpathParent, rgchParentSuffix);
        GetPathSuffixString(hpathChild, rgchChildSuffix);

        /* Only root paths should have no path suffix off the root. */

        nParentSuffixLen = lstrlen(rgchParentSuffix);
        nChildSuffixLen = lstrlen(rgchChildSuffix);

        /*
         * The parent path is a path prefix of the child path iff:
         *    1) The parent's path suffix string is shorter than or the same
         *       length as the child's path suffix string.
         *    2) The two path suffix strings match through the length of the
         *       parent's path suffix string.
         *    3) The prefix of the child's path suffix string is followed
         *       immediately by a null terminator or a path separator.
         */

        bResult = (nChildSuffixLen >= nParentSuffixLen &&
                MyLStrCmpNI(rgchParentSuffix, rgchChildSuffix,
                    nParentSuffixLen) == CR_EQUAL &&
                (nChildSuffixLen == nParentSuffixLen ||          /* same paths */
                 ! nParentSuffixLen ||                           /* root parent */
                 IS_SLASH(rgchChildSuffix[nParentSuffixLen])));  /* non-root parent */
    }
    else
        bResult = FALSE;

    return(bResult);
}


/*
 ** SubtreesIntersect()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** N.b., two subtrees cannot both intersect a third subtree unless they
 ** intersect each other.
 */
PUBLIC_CODE BOOL SubtreesIntersect(HPATH hpath1, HPATH hpath2)
{
    ASSERT(IS_VALID_HANDLE(hpath1, PATH));
    ASSERT(IS_VALID_HANDLE(hpath2, PATH));

    return(IsPathPrefix(hpath1, hpath2) ||
            IsPathPrefix(hpath2, hpath1));
}


/*
 ** FindEndOfRootSpec()
 **
 ** Finds the end of the root specification in a path string.
 **
 ** Arguments:     pcszPath - path to examine for root specification
 **                hpath - handle to PATH that path string was generated from
 **
 ** Returns:       pointer to first character after end of root specification
 **
 ** Side Effects:  none
 **
 ** Examples:
 **
 **    input path                    output string
 **    ----------                    -------------
 **    c:\                           <empty string>
 **    c:\foo                        foo
 **    c:\foo\bar                    foo\bar
 **    \\pyrex\user\                 <empty string>
 **    \\pyrex\user\foo              foo
 **    \\pyrex\user\foo\bar          foo\bar
 */
PUBLIC_CODE LPTSTR FindEndOfRootSpec(LPCTSTR pcszFullPath, HPATH hpath)
{
    LPCTSTR pcsz;
    UINT ucchPathLen;
    UINT ucchSuffixLen;

    ASSERT(IsCanonicalPath(pcszFullPath));
    ASSERT(IS_VALID_HANDLE(hpath, PATH));

    ucchPathLen = lstrlen(pcszFullPath);
    ucchSuffixLen = lstrlen(GetString(((PCPATH)hpath)->hsPathSuffix));

    pcsz = pcszFullPath + ucchPathLen;

    if (ucchPathLen > ucchSuffixLen)
        pcsz -= ucchSuffixLen;
    else
        /* Assume path is root path. */
        ERROR_OUT((TEXT("FindEndOfRootSpec(): Path suffix %s is longer than full path %s."),
                    GetString(((PCPATH)hpath)->hsPathSuffix),
                    pcszFullPath));

    ASSERT(IsValidPathSuffix(pcsz));

    return((LPTSTR)pcsz);
}


/*
 ** FindPathSuffix()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE LPTSTR FindChildPathSuffix(HPATH hpathParent, HPATH hpathChild,
        LPTSTR pszChildSuffixBuf)
{
    LPCTSTR pcszChildSuffix;
    TCHAR rgchParentSuffix[MAX_PATH_LEN];

    ASSERT(IS_VALID_HANDLE(hpathParent, PATH));
    ASSERT(IS_VALID_HANDLE(hpathChild, PATH));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszChildSuffixBuf, STR, MAX_PATH_LEN));

    ASSERT(IsPathPrefix(hpathChild, hpathParent));

    GetPathSuffixString(hpathParent, rgchParentSuffix);
    GetPathSuffixString(hpathChild, pszChildSuffixBuf);

    ASSERT(lstrlen(rgchParentSuffix) <= lstrlen(pszChildSuffixBuf));
    pcszChildSuffix = pszChildSuffixBuf + lstrlen(rgchParentSuffix);

    if (IS_SLASH(*pcszChildSuffix))
        pcszChildSuffix++;

    ASSERT(IsValidPathSuffix(pcszChildSuffix));

    return((LPTSTR)pcszChildSuffix);
}


/*
 ** ComparePointers()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE COMPARISONRESULT ComparePointers(PCVOID pcv1, PCVOID pcv2)
{
    COMPARISONRESULT cr;

    /* pcv1 and pcv2 may be any value. */

    if (pcv1 < pcv2)
        cr = CR_FIRST_SMALLER;
    else if (pcv1 > pcv2)
        cr = CR_FIRST_LARGER;
    else
        cr = CR_EQUAL;

    return(cr);
}


/*
 ** TWINRESULTFromLastError()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT TWINRESULTFromLastError(TWINRESULT tr)
{
    switch (GetLastError())
    {
        case ERROR_OUTOFMEMORY:
            tr = TR_OUT_OF_MEMORY;
            break;

        default:
            break;
    }

    return(tr);
}


/*
 ** WritePathList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT WritePathList(HCACHEDFILE hcf, HPATHLIST hpl)
{
    TWINRESULT tr;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));

    tr = WriteVolumeList(hcf, ((PCPATHLIST)hpl)->hvl);

    if (tr == TR_SUCCESS)
    {
        tr = WriteStringTable(hcf, ((PCPATHLIST)hpl)->hst);

        if (tr == TR_SUCCESS)
        {
            DWORD dwcbDBPathListHeaderOffset;

            tr = TR_BRIEFCASE_WRITE_FAILED;

            /* Save initial file position. */

            dwcbDBPathListHeaderOffset = GetCachedFilePointerPosition(hcf);

            if (dwcbDBPathListHeaderOffset != INVALID_SEEK_POSITION)
            {
                DBPATHLISTHEADER dbplh;

                /* Leave space for path list header. */

                ZeroMemory(&dbplh, sizeof(dbplh));

                if (WriteToCachedFile(hcf, (PCVOID)&dbplh, sizeof(dbplh), NULL))
                {
                    ARRAYINDEX aicPtrs;
                    ARRAYINDEX ai;
                    LONG lcPaths = 0;

                    tr = TR_SUCCESS;

                    aicPtrs = GetPtrCount(((PCPATHLIST)hpl)->hpa);

                    /* Write all paths. */

                    for (ai = 0; ai < aicPtrs; ai++)
                    {
                        PPATH ppath;

                        ppath = GetPtr(((PCPATHLIST)hpl)->hpa, ai);

                        /*
                         * As a sanity check, don't save any path with a lock count
                         * of 0.  A 0 lock count implies that the path has not been
                         * referenced since it was restored from the database, or
                         * something is broken.
                         */

                        if (ppath->ulcLock > 0)
                        {
                            tr = WritePath(hcf, ppath);

                            if (tr == TR_SUCCESS)
                            {
                                ASSERT(lcPaths < LONG_MAX);
                                lcPaths++;
                            }
                            else
                                break;
                        }
                        else
                            ERROR_OUT((TEXT("WritePathList(): PATH for path %s has 0 lock count and will not be written."),
                                        DebugGetPathString((HPATH)ppath)));
                    }

                    /* Save path list header. */

                    if (tr == TR_SUCCESS)
                    {
                        dbplh.lcPaths = lcPaths;

                        tr = WriteDBSegmentHeader(hcf, dwcbDBPathListHeaderOffset, &dbplh,
                                sizeof(dbplh));

                        TRACE_OUT((TEXT("WritePathList(): Wrote %ld paths."),
                                    dbplh.lcPaths));
                    }
                }
            }
        }
    }

    return(tr);
}


/*
 ** ReadPathList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT ReadPathList(HCACHEDFILE hcf, HPATHLIST hpl,
        PHHANDLETRANS phht)
{
    TWINRESULT tr;
    HHANDLETRANS hhtVolumes;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
    ASSERT(IS_VALID_WRITE_PTR(phht, HHANDLETRANS));

    tr = ReadVolumeList(hcf, ((PCPATHLIST)hpl)->hvl, &hhtVolumes);

    if (tr == TR_SUCCESS)
    {
        HHANDLETRANS hhtStrings;

        tr = ReadStringTable(hcf, ((PCPATHLIST)hpl)->hst, &hhtStrings);

        if (tr == TR_SUCCESS)
        {
            DBPATHLISTHEADER dbplh;
            DWORD dwcbRead;

            tr = TR_CORRUPT_BRIEFCASE;

            if (ReadFromCachedFile(hcf, &dbplh, sizeof(dbplh), &dwcbRead) &&
                    dwcbRead == sizeof(dbplh))
            {
                HHANDLETRANS hht;

                if (CreateHandleTranslator(dbplh.lcPaths, &hht))
                {
                    LONG l;

                    tr = TR_SUCCESS;

                    TRACE_OUT((TEXT("ReadPathList(): Reading %ld paths."),
                                dbplh.lcPaths));

                    for (l = 0; l < dbplh.lcPaths; l++)
                    {
                        tr = ReadPath(hcf, (PPATHLIST)hpl, hhtVolumes, hhtStrings,
                                hht);

                        if (tr != TR_SUCCESS)
                            break;
                    }

                    if (tr == TR_SUCCESS)
                    {
                        PrepareForHandleTranslation(hht);
                        *phht = hht;

                        ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
                        ASSERT(IS_VALID_HANDLE(*phht, HANDLETRANS));
                    }
                    else
                        DestroyHandleTranslator(hht);
                }
                else
                    tr = TR_OUT_OF_MEMORY;
            }

            DestroyHandleTranslator(hhtStrings);
        }

        DestroyHandleTranslator(hhtVolumes);
    }

    return(tr);
}


/*
 ** IsValidHPATH()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidHPATH(HPATH hp)
{
    return(IS_VALID_STRUCT_PTR((PCPATH)hp, CPATH));
}


/*
 ** IsValidHVOLUMEID()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidHVOLUMEID(HVOLUMEID hvid)
{
    return(IS_VALID_HANDLE((HPATH)hvid, PATH));
}


#if defined(DEBUG) || defined(VSTF)

/*
 ** IsValidHPATHLIST()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidHPATHLIST(HPATHLIST hpl)
{
    return(IS_VALID_STRUCT_PTR((PCPATHLIST)hpl, CPATHLIST));
}

#endif


/***************************** Exported Functions ****************************/


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | IsPathOnVolume | Determines whether or not a given path is on
  a given volume.

  @parm PCSTR | pcszPath | A pointer to a string indicating the path to be
  checked.

  @parm HVOLUMEID | hvid | A handle to a volume ID.

  @parm PBOOL | pbOnVolume | A pointer to a BOOL to be filled in with TRUE if the
  given path is on the given volume, or FALSE if not.  *pbOnVolume is only valid
  if TR_SUCCESS is returned.

  @rdesc If the volume check was successful, TR_SUCCESS is returned.  Otherwise,
  the volume check was not successful, and the return value indicates the error
  that occurred.

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI IsPathOnVolume(LPCTSTR pcszPath, HVOLUMEID hvid,
        PBOOL pbOnVolume)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(IsPathOnVolume);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_STRING_PTR(pcszPath, CSTR) &&
                IS_VALID_HANDLE(hvid, VOLUMEID) &&
                IS_VALID_WRITE_PTR(pbOnVolume, BOOL))
#endif
        {
            TCHAR rgchFullPath[MAX_PATH_LEN];
            LPTSTR pszFileName;
            DWORD dwPathLen;

            dwPathLen = GetFullPathName(pcszPath, ARRAYSIZE(rgchFullPath),
                    rgchFullPath, &pszFileName);

            if (dwPathLen > 0 && dwPathLen < ARRAYSIZE(rgchFullPath))
            {
                *pbOnVolume = MyIsPathOnVolume(rgchFullPath, (HPATH)hvid);

                tr = TR_SUCCESS;
            }
            else
            {
                ASSERT(! dwPathLen);

                tr = TR_INVALID_PARAMETER;
            }
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(IsPathOnVolume, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | GetVolumeDescription | Retrieves some descriptive information
  for a volume, if that information is available.

  @parm HVOLUMEID | hvid | A handle to a volume ID.

  @parm PVOLUMEDESC | pvoldesc | A pointer to a VOLUMEDESC to be filled in with
  information describing the volume.  The ulSize field of the VOLUMEDESC
  structure should be filled in with sizeof(VOLUMEDESC) before calling
  GetVolumeDescription().

  @rdesc If the volume was described successfully, TR_SUCCESS is returned.
  Otherwise, the volume was not described successfully, and the return value
  indicates the error that occurred.

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI GetVolumeDescription(HVOLUMEID hvid,
        PVOLUMEDESC pvoldesc)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(GetVolumeDescription);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hvid, VOLUMEID) &&
                IS_VALID_WRITE_PTR(pvoldesc, VOLUMEDESC) &&
                EVAL(pvoldesc->ulSize == sizeof(*pvoldesc)))
#endif
        {
            DescribeVolume(((PCPATH)hvid)->hvol, pvoldesc);

            tr = TR_SUCCESS;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(GetVolumeDescription, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\project.h ===
/*
 * project.h - Project header file for object synchronization engine.
 */


/* System Headers
 *****************/

#define BUILDDLL              /* for windows.h */
#define STRICT                /* for windows.h (robustedness) */
#define _OLE32_               /* for objbase.h - HACKHACK: Remove DECLSPEC_IMPORT from WINOLEAPI. */
#define INC_OLE2              /* for windows.h */
#define CONST_VTABLE          /* for objbase.h */

/*
 * RAIDRAID: (16282) Get rid of warnings about unused Int64 inline
 * functions in winnt.h for all modules.  Emasculate other warnings only for
 * windows.h.
 */

#pragma warning(disable:4514) /* "unreferenced inline function" warning */

#pragma warning(disable:4001) /* "single line comment" warning */
#pragma warning(disable:4115) /* "named type definition in parentheses" warning */
#pragma warning(disable:4201) /* "nameless struct/union" warning */
#pragma warning(disable:4209) /* "benign typedef redefinition" warning */
#pragma warning(disable:4214) /* "bit field types other than int" warning */
#pragma warning(disable:4218) /* "must specify at least a storage class or type" warning */

#include <windows.h>
#pragma warning(disable:4001) /* "single line comment" warning - windows.h enabled it */
#include <shlobj.h>           /* for ShellChangeNotify(), etc. */
#include <shlapip.h>
#include <shlwapi.h>

#pragma warning(default:4218) /* "must specify at least a storage class or type" warning */
#pragma warning(default:4214) /* "bit field types other than int" warning */
#pragma warning(default:4209) /* "benign typedef redefinition" warning */
#pragma warning(default:4201) /* "nameless struct/union" warning */
#pragma warning(default:4115) /* "named type definition in parentheses" warning */
#pragma warning(default:4001) /* "single line comment" warning */

#include <limits.h>
#include <string.h>

#include <linkinfo.h>
#include <reconcil.h>

#define _SYNCENG_             /* for synceng.h */
#include <synceng.h>


/* Project Headers
 ******************/

/* The order of the following include files is significant. */

#include "stock.h"
#include "olestock.h"

#ifdef DEBUG

#include "inifile.h"
#include "resstr.h"

#endif

#include "debug.h"
#include "valid.h"
#include "olevalid.h"
#include "memmgr.h"
#include "ptrarray.h"
#include "list.h"
#include "hndtrans.h"
#include "string2.h"
#include "comc.h"
#include "util.h"
#include "path.h"
#include "fcache.h"
#include "brfcase.h"
#include "storage.h"
#include "clsiface.h"
#include "twin.h"
#include "foldtwin.h"
#include "expandft.h"
#include "twinlist.h"
#include "reclist.h"
#include "copy.h"
#include "merge.h"
#include "recon.h"
#include "db.h"
#include "serial.h"

/* RAIDRAID: (16283) Remove the OLE pig module hack if possible. */

#include "olepig.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\recon.h ===
/*
 * recon.h - Reconciliation routines description.
 */


/* Prototypes
 *************/

/* recon.c */

extern void CopyFileStampFromFindData(PCWIN32_FIND_DATA, PFILESTAMP);
extern void MyGetFileStamp(LPCTSTR, PFILESTAMP);
extern void MyGetFileStampByHPATH(HPATH, LPCTSTR, PFILESTAMP);
extern COMPARISONRESULT MyCompareFileStamps(PCFILESTAMP, PCFILESTAMP);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\resstr.c ===
/*
 * resstr.c - Return code to string translation routines.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#ifdef DEBUG

#include "debugstr.h"
#include <shlwapi.h>
#endif


/* Macros
 *********/

/*
 * macro for simplifying result to string translation, assumes result string
 * pointer pcsz
 */

#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


/****************************** Public Functions *****************************/


#ifdef DEBUG

/*
 ** GetINTString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE LPCTSTR GetINTString(int n)
{
    static TCHAR SrgchINT[] = TEXT("-2147483646");

    wnsprintf(SrgchINT, ARRAYSIZE(SrgchINT), TEXT("%d"), n);

    ASSERT(IS_VALID_STRING_PTR(SrgchINT, CSTR));

    return(SrgchINT);
}


/*
 ** GetULONGString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE LPCTSTR GetULONGString(ULONG ul)
{
    static TCHAR SrgchULONG[] = TEXT("4294967295");

    wnsprintf(SrgchULONG, ARRAYSIZE(SrgchULONG), TEXT("%lx"), ul);

    ASSERT(IS_VALID_STRING_PTR(SrgchULONG, CSTR));

    return(SrgchULONG);
}


/*
 ** GetBOOLString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE LPCTSTR GetBOOLString(BOOL bResult)
{
    LPCTSTR pcsz;

    if (bResult)
        pcsz = TEXT("TRUE");
    else
        pcsz = TEXT("FALSE");

    ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

    return(pcsz);
}


/*
 ** GetCOMPARISONRESULTString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE LPCTSTR GetCOMPARISONRESULTString(COMPARISONRESULT cr)
{
    LPCTSTR pcsz;

    switch (cr)
    {
        STRING_CASE(CR_FIRST_SMALLER);
        STRING_CASE(CR_FIRST_LARGER);
        STRING_CASE(CR_EQUAL);

        default:
        ERROR_OUT((TEXT("GetCOMPARISONRESULTString() called on unknown COMPARISONRESULT %d."),
                    cr));
        pcsz = TEXT("UNKNOWN COMPARISONRESULT");
        break;
    }

    ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

    return(pcsz);
}


#ifdef INC_OLE2

/*
 ** GetHRESULTString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE LPCTSTR GetHRESULTString(HRESULT hr)
{
    LPCTSTR pcsz;
    static TCHAR SrgchHRESULT[] = TEXT("0x12345678");

    switch (hr)
    {
        STRING_CASE(S_OK);
        STRING_CASE(S_FALSE);

        STRING_CASE(E_UNEXPECTED);
        STRING_CASE(E_NOTIMPL);
        STRING_CASE(E_OUTOFMEMORY);
        STRING_CASE(E_INVALIDARG);
        STRING_CASE(E_NOINTERFACE);
        STRING_CASE(E_POINTER);
        STRING_CASE(E_HANDLE);
        STRING_CASE(E_ABORT);
        STRING_CASE(E_FAIL);
        STRING_CASE(E_ACCESSDENIED);

        STRING_CASE(CLASS_E_NOAGGREGATION);

        STRING_CASE(CO_E_NOTINITIALIZED);
        STRING_CASE(CO_E_ALREADYINITIALIZED);
        STRING_CASE(CO_E_INIT_ONLY_SINGLE_THREADED);

#ifdef __RECONCIL_H__

        STRING_CASE(REC_S_IDIDTHEUPDATES);
        STRING_CASE(REC_S_NOTCOMPLETE);
        STRING_CASE(REC_S_NOTCOMPLETEBUTPROPAGATE);

        STRING_CASE(REC_E_ABORTED);
        STRING_CASE(REC_E_NOCALLBACK);
        STRING_CASE(REC_E_NORESIDUES);
        STRING_CASE(REC_E_TOODIFFERENT);
        STRING_CASE(REC_E_INEEDTODOTHEUPDATES);

#endif   /* __RECONCIL_H__ */

        default:
        wnsprintf(SrgchHRESULT, ARRAYSIZE(SrgchHRESULT), TEXT("%#lx"), hr);
        pcsz = SrgchHRESULT;
        break;
    }

    ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

    return(pcsz);
}

#endif   /* INC_OLE2 */


#ifdef __SYNCENG_H__

/*
 ** GetTWINRESULTString()
 **
 ** Returns a pointer to the string name of a TWINRESULT return code.
 **
 ** Arguments:     tr - return code to be translated
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE LPCTSTR GetTWINRESULTString(TWINRESULT tr)
{
    LPCTSTR pcsz;

    ASSERT(tr >= 0);

    if (tr < ARRAY_ELEMENTS(rgcpcszTwinResult))
        pcsz = rgcpcszTwinResult[tr];
    else
    {
        ERROR_OUT((TEXT("GetTWINRESULTString() called on unrecognized TWINRESULT %ld."),
                    tr));
        pcsz = TEXT("UNKNOWN TWINRESULT");
    }

    ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

    return(pcsz);
}


/*
 ** GetCREATERECLISTPROCMSGString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE LPCTSTR GetCREATERECLISTPROCMSGString(UINT uCreateRecListMsg)
{
    LPCTSTR pcsz;

    ASSERT(uCreateRecListMsg >= 0);

    if (uCreateRecListMsg < ARRAY_ELEMENTS(rgcpcszCreateRecListMsg))
        pcsz = rgcpcszCreateRecListMsg[uCreateRecListMsg];
    else
    {
        ERROR_OUT((TEXT("GetCREATERECLISTPROCMSGString() called on unrecognized RECSTATUSPROC message %u."),
                    uCreateRecListMsg));
        pcsz = TEXT("UNKNOWN RECSTATUSPROC MESSAGE");
    }

    ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

    return(pcsz);
}


/*
 ** GetRECSTATUSPROCMSGString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE LPCTSTR GetRECSTATUSPROCMSGString(UINT uRecStatusMsg)
{
    LPCTSTR pcsz;

    ASSERT(uRecStatusMsg >= 0);

    if (uRecStatusMsg < ARRAY_ELEMENTS(rgcpcszRecStatusMsg))
        pcsz = rgcpcszRecStatusMsg[uRecStatusMsg];
    else
    {
        ERROR_OUT((TEXT("GetRECSTATUSPROCMSGString() called on unrecognized RECSTATUSPROC message %u."),
                    uRecStatusMsg));
        pcsz = TEXT("UNKNOWN RECSTATUSPROC MESSAGE");
    }

    ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

    return(pcsz);
}


/*
 ** GetRECNODESTATEString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE LPCTSTR GetRECNODESTATEString(RECNODESTATE rnstate)
{
    LPCTSTR pcsz;

    switch (rnstate)
    {
        STRING_CASE(RNS_NEVER_RECONCILED);
        STRING_CASE(RNS_UNAVAILABLE);
        STRING_CASE(RNS_DOES_NOT_EXIST);
        STRING_CASE(RNS_DELETED);
        STRING_CASE(RNS_NOT_RECONCILED);
        STRING_CASE(RNS_UP_TO_DATE);
        STRING_CASE(RNS_CHANGED);

        default:
        ERROR_OUT((TEXT("GetRECNODESTATEString() called on unknown RECNODESTATE %d."),
                    rnstate));
        pcsz = TEXT("UNKNOWN RECNODESTATE");
        break;
    }

    ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

    return(pcsz);
}


/*
 ** GetRECNODEACTIONString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE LPCTSTR GetRECNODEACTIONString(RECNODEACTION rnaction)
{
    LPCTSTR pcsz;

    switch (rnaction)
    {
        STRING_CASE(RNA_NOTHING);
        STRING_CASE(RNA_COPY_FROM_ME);
        STRING_CASE(RNA_COPY_TO_ME);
        STRING_CASE(RNA_MERGE_ME);
        STRING_CASE(RNA_DELETE_ME);

        default:
        ERROR_OUT((TEXT("GetRECNODEACTIONString() called on unknown RECNODEACTION %d."),
                    rnaction));
        pcsz = TEXT("UNKNOWN RECNODEACTION");
        break;
    }

    ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

    return(pcsz);
}

#endif   /* __SYNCENG_H__ */

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\reclist.h ===
/*
 * reclist.h - Reconciliation list ADT description.
 */


/* Macros
 *********/

#define RECNODE_EXISTS(prn)           ((prn)->fsCurrent.fscond == FS_COND_EXISTS)
#define RECNODE_DOES_NOT_EXIST(prn)   ((prn)->fsCurrent.fscond == FS_COND_DOES_NOT_EXIST)
#define RECNODE_IS_AVAILABLE(prn)     (RECNODE_EXISTS(prn) || RECNODE_DOES_NOT_EXIST(prn))
#define RECNODE_WAS_RECONCILED(prn)   (RECNODE_EXISTS(prn) && prn->rnaction != RNA_NOTHING)


/* Prototypes
 *************/

/* reclist.c */

extern BOOL IsReconciledFileStamp(PCFILESTAMP);
extern BOOL LastKnownNonExistent(PCFILESTAMP, PCFILESTAMP);
extern void DetermineDeletionPendingState(PCRECITEM);
extern BOOL DeleteTwinsFromRecItem(PCRECITEM);
extern BOOL DeleteTwinsFromRecList(PCRECLIST);
extern TWINRESULT FindCopySource(PCRECITEM, PRECNODE *);
extern void ChooseMergeDestination(PCRECITEM, PRECNODE *);
extern void ClearFlagInArrayOfStubs(HPTRARRAY, DWORD);
extern BOOL NotifyCreateRecListStatus(CREATERECLISTPROC, UINT, LPARAM, LPARAM);
extern COMPARISONRESULT CompareInts(int, int);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidFILESTAMPCONDITION(FILESTAMPCONDITION);
extern BOOL IsValidPCFILESTAMP(PCFILESTAMP);
extern BOOL IsFolderObjectTwinFileStamp(PCFILESTAMP);
extern BOOL IsValidPCRECNODE(PCRECNODE);
extern BOOL IsValidPCRECITEM(PCRECITEM);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\reclist.c ===
/*
 * reclist.c - Reconciliation list ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"
#include "oleutil.h"


/* Constants
 ************/

/* RECITEMACTION weights for folders returned by WeighFolderAction(). */

/* (RECITEMACTION weights for files are the RECITEMACTION values.) */

#define RIA_WT_COPY        (-2)
#define RIA_WT_NOTHING     (-1)
#define RIA_WT_DELETE      (+5)


/* Types
 ********/

/* used to count the number of RECNODEs of each RECNODESTATE in a RECITEM */

typedef struct _recnodestatecounter
{
    ULONG ulcUnavailable;
    ULONG ulcDoesNotExist;
    ULONG ulcDeleted;
    ULONG ulcNotReconciled;
    ULONG ulcUpToDate;
    ULONG ulcChanged;
    ULONG ulcNeverReconciled;
}
RECNODESTATECOUNTER;
DECLARE_STANDARD_TYPES(RECNODESTATECOUNTER);

/* DoesTwinFamilyNeedRec() callback structure */

typedef struct _twinfamilyrecinfo
{
    TWINRESULT tr;

    BOOL bNeedsRec;
}
TWINFAMILYRECINFO;
DECLARE_STANDARD_TYPES(TWINFAMILYRECINFO);


/***************************** Private Functions *****************************/


/* Module Prototypes
 ********************/

PRIVATE_CODE RECNODESTATE DetermineRecNodeState(PCRECNODE);
PRIVATE_CODE void AddRecNodeState(RECNODESTATE, PRECNODESTATECOUNTER);
PRIVATE_CODE void CountRecNodeStates(PCRECITEM, PRECNODESTATECOUNTER, PULONG);
PRIVATE_CODE void DetermineRecActions(PRECITEM);
PRIVATE_CODE void BreakMergeIfNecessary(PRECITEM);
PRIVATE_CODE TWINRESULT AddRecItemsToRecList(HTWINLIST, CREATERECLISTPROC, LPARAM, PRECLIST);
PRIVATE_CODE void LinkUpRecList(PRECLIST, HPTRARRAY);
PRIVATE_CODE int WeighFileAction(RECITEMACTION);
PRIVATE_CODE int WeighFolderAction(RECITEMACTION);
PRIVATE_CODE COMPARISONRESULT RecItemSortCmp(PCVOID, PCVOID);
PRIVATE_CODE void DestroyArrayOfRecItems(HPTRARRAY);
PRIVATE_CODE BOOL MarkTwinFamilyUsed(POBJECTTWIN, PVOID);
PRIVATE_CODE ULONG MarkIntersectingTwinFamiliesUsed(HTWIN);
PRIVATE_CODE void DestroyRecItem(PRECITEM);
PRIVATE_CODE void DestroyRecNode(PRECNODE);
PRIVATE_CODE void DestroyListOfRecItems(PRECITEM);
PRIVATE_CODE void DestroyListOfRecNodes(PRECNODE);
PRIVATE_CODE void MyDestroyRecList(PRECLIST);
PRIVATE_CODE BOOL DeleteDeletedObjectTwins(PCRECITEM, PBOOL);
PRIVATE_CODE BOOL FindAGeneratedObjectTwinProc(POBJECTTWIN, PVOID);
PRIVATE_CODE BOOL FolderTwinShouldBeImplicitlyDeleted(PFOLDERPAIR);
PRIVATE_CODE BOOL DeleteDeletedFolderTwins(HPTRARRAY);
PRIVATE_CODE TWINRESULT CreateRecItem(PTWINFAMILY, PRECITEM *);
PRIVATE_CODE TWINRESULT AddObjectTwinRecNode(PRECITEM, POBJECTTWIN);
PRIVATE_CODE BOOL DoesTwinFamilyNeedRec(POBJECTTWIN, PVOID);
PRIVATE_CODE TWINRESULT GetFolderPairStatus(PFOLDERPAIR, CREATERECLISTPROC, LPARAM, PFOLDERTWINSTATUS);

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidCreateRecListProcMsg(UINT);
PRIVATE_CODE BOOL IsValidFOLDERTWINSTATUS(FOLDERTWINSTATUS);
PRIVATE_CODE BOOL IsValidPCRECNODESTATECOUNTER(PCRECNODESTATECOUNTER);

#endif

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL IsValidRECNODESTATE(RECNODESTATE);
PRIVATE_CODE BOOL IsValidRECNODEACTION(RECNODEACTION);
PRIVATE_CODE BOOL IsValidRECITEMACTION(RECITEMACTION);
PRIVATE_CODE BOOL IsValidPCRECLIST(PCRECLIST);

#endif


/*
 ** DetermineRecNodeState()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE RECNODESTATE DetermineRecNodeState(PCRECNODE pcrn)
{
    RECNODESTATE rnstate;

    ASSERT(IS_VALID_WRITE_PTR(pcrn, RECNODE));

    if (pcrn->fsCurrent.fscond != FS_COND_UNAVAILABLE)
    {
        if (IsReconciledFileStamp(&(pcrn->fsLast)))
        {
            if (pcrn->fsCurrent.fscond == FS_COND_EXISTS)
            {
                BOOL bReconciledLastTime;

                bReconciledLastTime = (IsStubFlagClear(&(((PCOBJECTTWIN)(pcrn->hObjectTwin))->stub),
                            STUB_FL_NOT_RECONCILED));

                if (MyCompareFileStamps(&(pcrn->fsLast), &(pcrn->fsCurrent))
                        == CR_EQUAL)
                {
                    if (bReconciledLastTime)
                        rnstate = RNS_UP_TO_DATE;
                    else
                        rnstate = RNS_NOT_RECONCILED;
                }
                else
                {
                    if (bReconciledLastTime)
                        rnstate = RNS_CHANGED;
                    else
                        /* Divergent version. */
                        rnstate = RNS_NEVER_RECONCILED;
                }
            }
            else
            {
                ASSERT(pcrn->fsCurrent.fscond == FS_COND_DOES_NOT_EXIST);

                rnstate = RNS_DELETED;
            }
        }
        else
        {
            if (pcrn->fsCurrent.fscond == FS_COND_EXISTS)
                rnstate = RNS_NEVER_RECONCILED;
            else
            {
                ASSERT(pcrn->fsCurrent.fscond == FS_COND_DOES_NOT_EXIST);
                rnstate = RNS_DOES_NOT_EXIST;
            }
        }
    }
    else
    {
        /* Deleted wins over unavailable. */

        if (pcrn->fsLast.fscond == FS_COND_DOES_NOT_EXIST)
            rnstate = RNS_DELETED;
        else
            rnstate = RNS_UNAVAILABLE;
    }

    /* Collapse folder RECNODE states. */

    if (IsFolderObjectTwinName(pcrn->priParent->pcszName))
    {
        switch (rnstate)
        {
            case RNS_NEVER_RECONCILED:
            case RNS_NOT_RECONCILED:
            case RNS_CHANGED:
                rnstate = RNS_UP_TO_DATE;
                break;
        }
    }

    ASSERT(IsValidRECNODESTATE(rnstate));

    return(rnstate);
}


/*
 ** AddRecNodeState()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void AddRecNodeState(RECNODESTATE rnstate,
        PRECNODESTATECOUNTER prnscntr)
{
    ASSERT(IsValidRECNODESTATE(rnstate));
    ASSERT(IS_VALID_STRUCT_PTR(prnscntr, CRECNODESTATECOUNTER));

    switch (rnstate)
    {
        case RNS_UNAVAILABLE:
            ASSERT(prnscntr->ulcUnavailable < ULONG_MAX);
            prnscntr->ulcUnavailable++;
            break;

        case RNS_DOES_NOT_EXIST:
            ASSERT(prnscntr->ulcDoesNotExist < ULONG_MAX);
            prnscntr->ulcDoesNotExist++;
            break;

        case RNS_DELETED:
            ASSERT(prnscntr->ulcDeleted < ULONG_MAX);
            prnscntr->ulcDeleted++;
            break;

        case RNS_NOT_RECONCILED:
            ASSERT(prnscntr->ulcNotReconciled < ULONG_MAX);
            prnscntr->ulcNotReconciled++;
            break;

        case RNS_UP_TO_DATE:
            ASSERT(prnscntr->ulcUpToDate < ULONG_MAX);
            prnscntr->ulcUpToDate++;
            break;

        case RNS_CHANGED:
            ASSERT(prnscntr->ulcChanged < ULONG_MAX);
            prnscntr->ulcChanged++;
            break;

        default:
            ASSERT(rnstate == RNS_NEVER_RECONCILED);
            ASSERT(prnscntr->ulcNeverReconciled < ULONG_MAX);
            prnscntr->ulcNeverReconciled++;
            break;
    }

    return;
}


/*
 ** CountRecNodeStates()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void CountRecNodeStates(PCRECITEM pcri,
        PRECNODESTATECOUNTER prnscntr,
        PULONG pulcToDelete)
{
    PCRECNODE pcrn;

    ASSERT(IS_VALID_READ_PTR(pcri, CRECITEM));
    ASSERT(IS_VALID_STRUCT_PTR(prnscntr, CRECNODESTATECOUNTER));
    ASSERT(IS_VALID_WRITE_PTR(pulcToDelete, ULONG));

    ZeroMemory(prnscntr, sizeof(*prnscntr));
    *pulcToDelete = 0;

    for (pcrn = pcri->prnFirst; pcrn; pcrn = pcrn->prnNext)
    {
        AddRecNodeState(pcrn->rnstate, prnscntr);

        if (pcrn->rnstate == RNS_UP_TO_DATE &&
                IsStubFlagClear(&(((PCOBJECTTWIN)(pcrn->hObjectTwin))->stub),
                    STUB_FL_KEEP))
        {
            ASSERT(*pulcToDelete < ULONG_MAX);
            (*pulcToDelete)++;
        }
    }

    ASSERT(IS_VALID_STRUCT_PTR(prnscntr, CRECNODESTATECOUNTER));
    ASSERT(prnscntr->ulcUnavailable +
            prnscntr->ulcDoesNotExist +
            prnscntr->ulcDeleted +
            prnscntr->ulcNotReconciled +
            prnscntr->ulcUpToDate +
            prnscntr->ulcChanged +
            prnscntr->ulcNeverReconciled == pcri->ulcNodes);
    ASSERT(*pulcToDelete <= prnscntr->ulcUpToDate);

    return;
}


/*
 ** DetermineRecActions()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DetermineRecActions(PRECITEM pri)
{
    RECNODESTATECOUNTER rnscntr;
    ULONG ulcToDelete;
    RECITEMACTION riaSummary = RIA_NOTHING;
    RECNODEACTION rnaDoesNotExist = RNA_NOTHING;
    RECNODEACTION rnaNotReconciled = RNA_NOTHING;
    RECNODEACTION rnaUpToDateSrc = RNA_NOTHING;
    RECNODEACTION rnaUpToDate = RNA_NOTHING;
    RECNODEACTION rnaChanged = RNA_NOTHING;
    RECNODEACTION rnaNeverReconciled = RNA_NOTHING;
    BOOL bNeedUpToDateCopySrc = FALSE;
    BOOL bNeedNotReconciledCopySrc = FALSE;
    PRECNODE prn;

    ASSERT(IS_VALID_WRITE_PTR(pri, RECITEM));

    ZeroMemory(&rnscntr, sizeof(rnscntr));
    CountRecNodeStates(pri, &rnscntr, &ulcToDelete);

    if (rnscntr.ulcNeverReconciled > 0)
    {
        if (rnscntr.ulcChanged > 0)
        {
            riaSummary = RIA_MERGE;

            rnaNeverReconciled = RNA_MERGE_ME;
            rnaChanged = RNA_MERGE_ME;

            rnaUpToDate = RNA_COPY_TO_ME;
            rnaNotReconciled = RNA_COPY_TO_ME;
            rnaDoesNotExist = RNA_COPY_TO_ME;
        }
        else if (rnscntr.ulcUpToDate > 0)
        {
            riaSummary = RIA_MERGE;

            rnaNeverReconciled = RNA_MERGE_ME;
            rnaUpToDate = RNA_MERGE_ME;

            rnaNotReconciled = RNA_COPY_TO_ME;
            rnaDoesNotExist = RNA_COPY_TO_ME;
        }
        else if (rnscntr.ulcNotReconciled > 0)
        {
            riaSummary = RIA_MERGE;

            rnaNeverReconciled = RNA_MERGE_ME;
            rnaNotReconciled = RNA_MERGE_ME;

            rnaDoesNotExist = RNA_COPY_TO_ME;
        }
        else if (rnscntr.ulcNeverReconciled >= 2)
        {
            riaSummary = RIA_MERGE;

            rnaNeverReconciled = RNA_MERGE_ME;

            rnaDoesNotExist = RNA_COPY_TO_ME;
        }
        else if (rnscntr.ulcDoesNotExist > 0)
        {
            ASSERT(rnscntr.ulcNeverReconciled == 1);

            riaSummary = RIA_COPY;

            rnaNeverReconciled = RNA_COPY_FROM_ME;

            rnaDoesNotExist = RNA_COPY_TO_ME;
        }
    }
    else if (rnscntr.ulcChanged >= 2)
    {
        riaSummary = RIA_MERGE;

        rnaChanged = RNA_MERGE_ME;

        rnaUpToDate = RNA_COPY_TO_ME;
        rnaNotReconciled = RNA_COPY_TO_ME;
        rnaDoesNotExist = RNA_COPY_TO_ME;
    }
    else if (rnscntr.ulcChanged == 1)
    {
        if (rnscntr.ulcUpToDate > 0 ||
                rnscntr.ulcNotReconciled > 0 ||
                rnscntr.ulcDoesNotExist > 0)
        {
            riaSummary = RIA_COPY;

            rnaChanged = RNA_COPY_FROM_ME;

            rnaUpToDate = RNA_COPY_TO_ME;
            rnaNotReconciled = RNA_COPY_TO_ME;
            rnaDoesNotExist = RNA_COPY_TO_ME;
        }
    }
    else if (IsTwinFamilyDeletionPending((PCTWINFAMILY)(pri->hTwinFamily)))
    {
        if (ulcToDelete > 0)
        {
            riaSummary = RIA_DELETE;

            rnaNotReconciled = RNA_DELETE_ME;
            rnaUpToDate = RNA_DELETE_ME;
        }
    }
    else if (rnscntr.ulcUpToDate > 0)
    {
        if (rnscntr.ulcNotReconciled > 0 ||
                rnscntr.ulcDoesNotExist > 0)
        {
            riaSummary = RIA_COPY;

            bNeedUpToDateCopySrc = TRUE;

            rnaNotReconciled = RNA_COPY_TO_ME;
            rnaDoesNotExist = RNA_COPY_TO_ME;
        }
    }
    else if (rnscntr.ulcNotReconciled > 0)
    {
        if (rnscntr.ulcDoesNotExist > 0)
        {
            riaSummary = RIA_COPY;

            bNeedNotReconciledCopySrc = TRUE;

            rnaDoesNotExist = RNA_COPY_TO_ME;
        }
    }

    /* Apply determined actions. */

    ASSERT(! (bNeedUpToDateCopySrc && bNeedNotReconciledCopySrc));

    for (prn = pri->prnFirst; prn; prn = prn->prnNext)
    {
        switch (prn->rnstate)
        {
            case RNS_NEVER_RECONCILED:
                prn->rnaction = rnaNeverReconciled;
                break;

            case RNS_DOES_NOT_EXIST:
                prn->rnaction = rnaDoesNotExist;
                break;

            case RNS_NOT_RECONCILED:
                if (bNeedNotReconciledCopySrc)
                {
                    prn->rnaction = RNA_COPY_FROM_ME;
                    bNeedNotReconciledCopySrc = FALSE;
                }
                else
                    prn->rnaction = rnaNotReconciled;
                break;

            case RNS_UP_TO_DATE:
                if (bNeedUpToDateCopySrc)
                {
                    prn->rnaction = RNA_COPY_FROM_ME;
                    bNeedUpToDateCopySrc = FALSE;
                }
                else
                    prn->rnaction = rnaUpToDate;
                break;

            case RNS_CHANGED:
                prn->rnaction = rnaChanged;
                break;

            default:
                ASSERT(prn->rnstate == RNS_UNAVAILABLE ||
                        prn->rnstate == RNS_DELETED);
                prn->rnaction = RNA_NOTHING;
                break;
        }

        if (prn->rnaction == RNA_DELETE_ME)
        {
            if (IsStubFlagClear(&(((PCOBJECTTWIN)(prn->hObjectTwin))->stub),
                        STUB_FL_KEEP))
                SET_FLAG(prn->dwFlags, RN_FL_DELETION_SUGGESTED);
            else
                prn->rnaction = RNA_NOTHING;
        }
    }

    pri->riaction = riaSummary;

    /* Break a merge if no reconciliation handler is registered. */

    if (pri->riaction == RIA_MERGE)
        BreakMergeIfNecessary(pri);

    ASSERT(IS_VALID_STRUCT_PTR(pri, CRECITEM));

    return;
}


/*
 ** BreakMergeIfNecessary()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void BreakMergeIfNecessary(PRECITEM pri)
{
    PRECNODE prnMergeDest;
    TCHAR rgchPath[MAX_PATH_LEN];
    CLSID clsidReconciler;

    ASSERT(IS_VALID_STRUCT_PTR(pri, CRECITEM));

    ASSERT(pri->riaction == RIA_MERGE);

    /* Is a class reconciler registered for this RECITEM? */

    ChooseMergeDestination(pri, &prnMergeDest);
    ASSERT(prnMergeDest->priParent == pri);

    ComposePath(rgchPath, prnMergeDest->pcszFolder, prnMergeDest->priParent->pcszName, ARRAYSIZE(rgchPath));
    ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

    if (FAILED(GetReconcilerClassID(rgchPath, &clsidReconciler)))
    {
        pri->riaction = RIA_BROKEN_MERGE;

        TRACE_OUT((TEXT("MassageMergeCase(): Breaking merge RECITEM for %s.  No registered reconciliation handler."),
                    pri->pcszName));
    }

    return;
}


/*
 ** AddRecItemsToRecList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT AddRecItemsToRecList(HTWINLIST htl,
        CREATERECLISTPROC crlp,
        LPARAM lpCallbackData,
        PRECLIST prl)
{
    TWINRESULT tr = TR_SUCCESS;
    HBRFCASE hbr;
    HPTRARRAY hpaTwinFamilies;
    ARRAYINDEX aicTwins;
    ARRAYINDEX ai;
    ULONG ulcMarkedTwinFamilies = 0;
    NEWPTRARRAY npa;
    HPTRARRAY hpaRecItems;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_HANDLE(htl, TWINLIST));
    ASSERT(! crlp ||
            IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));
    ASSERT(IS_VALID_STRUCT_PTR(prl, CRECLIST));

    /*
     * "Used" twin families are twin families that are to be added to the
     * reconciliation list as RECITEMs.
     */

    /* Mark all twin families unused. */

    hbr = GetTwinListBriefcase(htl);

    hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(hbr);

    ClearFlagInArrayOfStubs(hpaTwinFamilies, STUB_FL_USED);

    /* Mark twin families that intersect twins in twin list as used. */

    aicTwins = GetTwinListCount(htl);

    for (ai = 0; ai < aicTwins; ai++)
    {
        ULONG ulcNewlyMarked;

        ulcNewlyMarked = MarkIntersectingTwinFamiliesUsed(GetTwinFromTwinList(htl, ai));

        ASSERT(ulcMarkedTwinFamilies <= ULONG_MAX - ulcNewlyMarked);
        ulcMarkedTwinFamilies += ulcNewlyMarked;
    }

    /* Create a PTRARRAY to keep track of the RECITEMs created. */

    npa.aicInitialPtrs = ulcMarkedTwinFamilies;
    npa.aicAllocGranularity = 1;
    npa.dwFlags = 0;

    if (CreatePtrArray(&npa, &hpaRecItems))
    {
        ARRAYINDEX aicPtrs;

        /* Add the marked twin families to the RECLIST as RECITEMS. */

        aicPtrs = GetPtrCount(hpaTwinFamilies);

        ai = 0;

        while (ai < aicPtrs && ulcMarkedTwinFamilies > 0)
        {
            PTWINFAMILY ptf;

            ptf = GetPtr(hpaTwinFamilies, ai);

            ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

            if (IsStubFlagSet(&(ptf->stub), STUB_FL_USED))
            {
                PRECITEM priNew;

                ulcMarkedTwinFamilies--;

                tr = CreateRecItem(ptf, &priNew);

                if (tr == TR_SUCCESS)
                {
                    ARRAYINDEX ai;

                    if (AddPtr(hpaRecItems, NULL, priNew, &ai))
                    {
                        if (! NotifyCreateRecListStatus(crlp, CRLS_DELTA_CREATE_REC_LIST,
                                    0, lpCallbackData))
                            tr = TR_ABORT;
                    }
                    else
                        tr = TR_OUT_OF_MEMORY;
                }

                if (tr != TR_SUCCESS)
                    break;
            }

            ai++;
        }

        if (tr == TR_SUCCESS)
        {
            ASSERT(! ulcMarkedTwinFamilies);
            LinkUpRecList(prl, hpaRecItems);
        }
        else
            DestroyArrayOfRecItems(hpaRecItems);

        DestroyPtrArray(hpaRecItems);
    }
    else
        tr = TR_OUT_OF_MEMORY;

    return(tr);
}


/*
 ** WeighFileAction()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE int WeighFileAction(RECITEMACTION riaction)
{
    ASSERT(IsValidRECITEMACTION(riaction));

    return(riaction);
}


/*
 ** WeighFolderAction()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE int WeighFolderAction(RECITEMACTION riaction)
{
    int nWeight;

    ASSERT(IsValidRECITEMACTION(riaction));

    switch (riaction)
    {
        case RIA_COPY:
            nWeight = RIA_WT_COPY;
            break;

        case RIA_NOTHING:
            nWeight = RIA_WT_NOTHING;
            break;

        default:
            ASSERT(riaction == RIA_DELETE);
            nWeight = RIA_WT_DELETE;
            break;
    }

    return(nWeight);
}


/*
 ** RecItemSortCmp()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** RECITEMs are sorted in the following order:
 **    1) create folder
 **    2) do nothing to folder
 **    3) do nothing to file
 **    4) delete file
 **    5) copy file
 **    6) merge file
 **    7) broken merge file
 **    8) delete folder
 ** and then by:
 **    1) name
 */
PRIVATE_CODE COMPARISONRESULT RecItemSortCmp(PCVOID pcriFirst,
        PCVOID pcriSecond)
{
    COMPARISONRESULT cr;
    BOOL bFirstFile;
    BOOL bSecondFile;
    int nFirstWeight;
    int nSecondWeight;

    ASSERT(IS_VALID_STRUCT_PTR(pcriFirst, CRECITEM));
    ASSERT(IS_VALID_STRUCT_PTR(pcriSecond, CRECITEM));

    bFirstFile = (*(((PCRECITEM)pcriFirst)->pcszName) != TEXT('\0'));
    bSecondFile = (*(((PCRECITEM)pcriSecond)->pcszName) != TEXT('\0'));

    if (bFirstFile)
        nFirstWeight = WeighFileAction(((PCRECITEM)pcriFirst)->riaction);
    else
        nFirstWeight = WeighFolderAction(((PCRECITEM)pcriFirst)->riaction);

    if (bSecondFile)
        nSecondWeight = WeighFileAction(((PCRECITEM)pcriSecond)->riaction);
    else
        nSecondWeight = WeighFolderAction(((PCRECITEM)pcriSecond)->riaction);

    cr = CompareInts(nFirstWeight, nSecondWeight);

    if (cr == CR_EQUAL)
        cr = CompareNameStrings(((PCRECITEM)pcriFirst)->pcszName,
                ((PCRECITEM)pcriSecond)->pcszName);

    return(cr);
}


/*
 ** LinkUpRecList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void LinkUpRecList(PRECLIST prl, HPTRARRAY hpaRecItems)
{
    ARRAYINDEX ai;
    ARRAYINDEX aicPtrs;

    ASSERT(IS_VALID_STRUCT_PTR(prl, CRECLIST));
    ASSERT(IS_VALID_HANDLE(hpaRecItems, PTRARRAY));

    SortPtrArray(hpaRecItems, &RecItemSortCmp);

    aicPtrs = GetPtrCount(hpaRecItems);

    for (ai = aicPtrs; ai > 0; ai--)
    {
        PRECITEM pri;

        pri = GetPtr(hpaRecItems, ai - 1);

        pri->priNext = prl->priFirst;
        prl->priFirst = pri;
    }

    prl->ulcItems = aicPtrs;

    ASSERT(IS_VALID_STRUCT_PTR(prl, CRECLIST));

    return;
}


/*
 ** DestroyArrayOfRecItems()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DestroyArrayOfRecItems(HPTRARRAY hpaRecItems)
{
    ARRAYINDEX ai;
    ARRAYINDEX aicPtrs;

    ASSERT(IS_VALID_HANDLE(hpaRecItems, PTRARRAY));

    aicPtrs = GetPtrCount(hpaRecItems);

    for (ai = 0; ai < aicPtrs; ai++)
        DestroyRecItem(GetPtr(hpaRecItems, ai));

    return;
}


/*
 ** MarkTwinFamilyUsed()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */

#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE BOOL MarkTwinFamilyUsed(POBJECTTWIN pot, PVOID pulcNewlyMarked)
{
    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
    ASSERT(IS_VALID_WRITE_PTR(pulcNewlyMarked, ULONG));

    if (IsStubFlagClear(&(pot->ptfParent->stub), STUB_FL_USED))
    {
        /* Mark the twin family used. */

        SetStubFlag(&(pot->ptfParent->stub), STUB_FL_USED);

        ASSERT(*(PULONG)pulcNewlyMarked < ULONG_MAX);
        (*(PULONG)pulcNewlyMarked)++;
    }

    return(TRUE);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
 ** MarkIntersectingTwinFamiliesUsed()
 **
 ** Marks the twin families that intersect a twin as used.
 **
 ** Arguments:     htwin - handle to intersecting twin
 **
 ** Returns:       Number of twin families newly marked used.
 **
 ** Side Effects:  none
 */
PRIVATE_CODE ULONG MarkIntersectingTwinFamiliesUsed(HTWIN htwin)
{
    ULONG ulcNewlyMarked = 0;

    ASSERT(IS_VALID_HANDLE(htwin, TWIN));

    /* Skip deleted twins. */

    if (IsStubFlagClear((PCSTUB)htwin, STUB_FL_UNLINKED))
    {
        /* Determine intersecting twin families based upon type of twin. */

        switch (((PSTUB)htwin)->st)
        {
            case ST_OBJECTTWIN:
                if (IsStubFlagClear(&(((POBJECTTWIN)htwin)->ptfParent->stub),
                            STUB_FL_USED))
                {
                    /* Mark the twin family of the object twin as used. */

                    SetStubFlag(&(((POBJECTTWIN)htwin)->ptfParent->stub),
                            STUB_FL_USED);

                    ulcNewlyMarked++;
                }
                break;

            case ST_TWINFAMILY:
                if (IsStubFlagClear(&(((PTWINFAMILY)htwin)->stub), STUB_FL_USED))
                {
                    /* Mark the twin family used. */

                    SetStubFlag(&(((PTWINFAMILY)htwin)->stub), STUB_FL_USED);

                    ulcNewlyMarked++;
                }
                break;

            default:
                /*
                 * Mark the twin families of the generated object twins from one of
                 * the folder twins as used.  (Only one of the two lists of object
                 * twins needs to be added since the other list should contain
                 * object twins in exactly the same twin families as the first.)
                 */
                ASSERT(((PSTUB)htwin)->st == ST_FOLDERPAIR);
                EVAL(EnumGeneratedObjectTwins((PCFOLDERPAIR)htwin,
                            &MarkTwinFamilyUsed,
                            &ulcNewlyMarked));
                break;
        }
    }

    return(ulcNewlyMarked);
}


/*
 ** DestroyRecItem()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DestroyRecItem(PRECITEM pri)
{
    ASSERT(IS_VALID_STRUCT_PTR(pri, CRECITEM));

    /* Destroy the RECITEM's list of RECNODES. */

    DestroyListOfRecNodes(pri->prnFirst);

    /* Now unlock the twin family stub associated with the RECITEM. */

    UnlockStub(&(((PTWINFAMILY)(pri->hTwinFamily))->stub));

    FreeMemory(pri);

    return;
}


/*
 ** DestroyRecNode()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DestroyRecNode(PRECNODE prn)
{
    ASSERT(IS_VALID_STRUCT_PTR(prn, CRECNODE));

    /* Unlock the object twin stub associated with the RECNODE. */

    UnlockStub(&(((POBJECTTWIN)(prn->hObjectTwin))->stub));

    FreeMemory((LPTSTR)(prn->pcszFolder));
    FreeMemory(prn);

    return;
}


/*
 ** DestroyListOfRecItems()
 **
 ** Destroys a list of reconciliation items.
 **
 ** Arguments:     priHead - pointer to first reconciliation item in list
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DestroyListOfRecItems(PRECITEM priHead)
{
    while (priHead)
    {
        PRECITEM priPrev;

        ASSERT(IS_VALID_STRUCT_PTR(priHead, CRECITEM));

        priPrev = priHead;
        priHead = priHead->priNext;

        DestroyRecItem(priPrev);
    }

    return;
}


/*
 ** DestroyListOfRecNodes()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DestroyListOfRecNodes(PRECNODE prnHead)
{
    while (prnHead)
    {
        PRECNODE prnPrev;

        ASSERT(IS_VALID_STRUCT_PTR(prnHead, CRECNODE));

        prnPrev = prnHead;
        prnHead = prnHead->prnNext;

        DestroyRecNode(prnPrev);
    }

    return;
}


/*
 ** MyDestroyRecList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void MyDestroyRecList(PRECLIST prl)
{
    ASSERT(IS_VALID_STRUCT_PTR(prl, CRECLIST));

    DestroyListOfRecItems(prl->priFirst);
    FreeMemory(prl);

    return;
}


/*
 ** DeleteDeletedObjectTwins()
 **
 ** Performs garbage collection of obsolete object twins.
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  May implicitly delete twin family.  Marks generating folder
 **                twins used.
 **
 ** Deletes the following:
 **    1) Any reconciled object twin last known non-existent whose twin family
 **       is not in the deletion pending state.  This may cause the parent twin
 **       family to be implicitly deleted as a result.
 **    2) Any twin family all of whose object twins are last known non-existent.
 */
PRIVATE_CODE BOOL DeleteDeletedObjectTwins(PCRECITEM pcri,
        PBOOL pbAnyFolderTwinsMarked)
{
    BOOL bAnyDeleted = FALSE;

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
    ASSERT(IS_VALID_WRITE_PTR(pbAnyFolderTwinsMarked, BOOL));

    *pbAnyFolderTwinsMarked = FALSE;

    if (! IsTwinFamilyDeletionPending((PCTWINFAMILY)(pcri->hTwinFamily)))
    {
        ULONG ulcNonExistent = 0;
        PRECNODE prn;
        PTWINFAMILY ptf;

        for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
        {
            if (LastKnownNonExistent(&(prn->fsLast), &(prn->fsCurrent)))
            {
                ASSERT(ulcNonExistent < ULONG_MAX);
                ulcNonExistent++;

                if (IsReconciledFileStamp(&(prn->fsLast)))
                {
                    POBJECTTWIN pot;

                    pot = (POBJECTTWIN)(prn->hObjectTwin);

                    if (! pot->ulcSrcFolderTwins)
                    {
                        DestroyStub(&(pot->stub));

                        TRACE_OUT((TEXT("DeleteDeletedObjectTwins(): Implicitly removed object twin for deleted file %s\\%s."),
                                    prn->pcszFolder,
                                    prn->priParent->pcszName));
                    }
                    else
                    {
                        ULONG ulcFolderTwins;

                        ClearStubFlag(&(pot->stub), STUB_FL_FROM_OBJECT_TWIN);

                        EVAL(EnumGeneratingFolderTwins(
                                    pot,
                                    (ENUMGENERATINGFOLDERTWINSPROC)&SetStubFlagWrapper,
                                    IntToPtr(STUB_FL_USED), &ulcFolderTwins));

                        *pbAnyFolderTwinsMarked = (ulcFolderTwins > 0);
                    }

                    bAnyDeleted = TRUE;
                }
            }
        }

        ptf = (PTWINFAMILY)(pcri->hTwinFamily);

        if (ulcNonExistent == pcri->ulcNodes &&
                IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED))
        {
            ClearTwinFamilySrcFolderTwinCount(ptf);

            EVAL(DestroyStub(&(ptf->stub)) == TR_SUCCESS);

            TRACE_OUT((TEXT("DeleteDeletedObjectTwins(): Implicitly removed twin family for %s since all members are last known non-existent."),
                        pcri->pcszName));
        }
    }

    return(bAnyDeleted);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
 ** FindAGeneratedObjectTwinProc()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** An obsolete generated object twin is an object twin that is last known
 ** non-existent, and whose twin family is not in the deletion pending state.
 */
PRIVATE_CODE BOOL FindAGeneratedObjectTwinProc(POBJECTTWIN pot, PVOID pvUnused)
{
    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
    ASSERT(! pvUnused);

    return(pot->fsLastRec.fscond == FS_COND_DOES_NOT_EXIST &&
            ! IsTwinFamilyDeletionPending(pot->ptfParent));
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
 ** FolderTwinShouldBeImplicitlyDeleted()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** A folder twin should be implicitly deleted when it meets all the following
 ** conditions:
 **    1) The folder root is last known non-existent.
 **    2) One or more of its generated object twins has just been implicitly
 **       deleted.
 **    3) It no longer generates any non-obsolete object twins.
 */
PRIVATE_CODE BOOL FolderTwinShouldBeImplicitlyDeleted(PFOLDERPAIR pfp)
{
    BOOL bDelete;

    ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

    if (IsStubFlagSet(&(pfp->stub), STUB_FL_DELETION_PENDING) &&
            IsStubFlagSet(&(pfp->stub), STUB_FL_USED) &&
            EnumGeneratedObjectTwins(pfp, &FindAGeneratedObjectTwinProc, NULL))
    {
        TRACE_OUT((TEXT("FolderTwinShouldBeImplicitlyDeleted(): Folder twin %s should be implicitly deleted."),
                    DebugGetPathString(pfp->hpath)));

        bDelete = TRUE;
    }
    else
        bDelete = FALSE;

    return(bDelete);
}


/*
 ** DeleteDeletedFolderTwins()
 **
 ** Performs garbage collection of obsolete folder twins.
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL DeleteDeletedFolderTwins(HPTRARRAY hpaFolderPairs)
{
    BOOL bAnyDeleted = FALSE;
    ARRAYINDEX aicPtrs;
    ARRAYINDEX ai;

    ASSERT(IS_VALID_HANDLE(hpaFolderPairs, PTRARRAY));

    aicPtrs = GetPtrCount(hpaFolderPairs);
    ASSERT(! (aicPtrs % 2));

    ai = 0;

    while (ai < aicPtrs)
    {
        PFOLDERPAIR pfp;

        pfp = GetPtr(hpaFolderPairs, ai);

        if (FolderTwinShouldBeImplicitlyDeleted(pfp) ||
                FolderTwinShouldBeImplicitlyDeleted(pfp->pfpOther))
        {
            TRACE_OUT((TEXT("DeleteDeletedFolderTwins(): Implicitly deleting %s twin pair %s and %s, files %s."),
                        IsStubFlagSet(&(pfp->stub), STUB_FL_SUBTREE) ? TEXT("subtree") : TEXT("folder"),
                        DebugGetPathString(pfp->hpath),
                        DebugGetPathString(pfp->pfpOther->hpath),
                        GetString(pfp->pfpd->hsName)));

            DestroyStub(&(pfp->stub));

            aicPtrs -= 2;
            ASSERT(! (aicPtrs % 2));
            ASSERT(aicPtrs == GetPtrCount(hpaFolderPairs));

            bAnyDeleted = TRUE;
        }
        else
        {
            /* Don't check this pair of folder twins again. */

            ClearStubFlag(&(pfp->stub), STUB_FL_USED);
            ClearStubFlag(&(pfp->pfpOther->stub), STUB_FL_USED);

            ai++;
        }
    }

    return(bAnyDeleted);
}


/*
 ** CreateRecItem()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT CreateRecItem(PTWINFAMILY ptf, PRECITEM *ppri)
{
    TWINRESULT tr;

    ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));
    ASSERT(IS_VALID_WRITE_PTR(ppri, PRECITEM));

    /* Create a new RECITEM for the twin family. */

    if (AllocateMemory(sizeof(**ppri), ppri))
    {
        LPCTSTR pcszName;
        BOOL bContinue;
        HNODE hnode;

        /* Get twin family's object name. */

        tr = TR_SUCCESS;

        pcszName = GetString(ptf->hsName);

        /* Fill in the fields required for adding new RECNODEs. */

        /* N.b., SYNCUI depends on dwUser to be initialized to 0. */

        (*ppri)->pcszName = pcszName;
        (*ppri)->ulcNodes = 0;
        (*ppri)->prnFirst = NULL;
        (*ppri)->hTwinFamily = (HTWINFAMILY)ptf;
        (*ppri)->dwUser = 0;

        TRACE_OUT((TEXT("CreateRecItem(): Creating a RECITEM for %s."),
                    pcszName));

        /* Add object twins to the RECITEM one at a time as RECNODEs. */

        for (bContinue = GetFirstNode(ptf->hlistObjectTwins, &hnode);
                bContinue;
                bContinue = GetNextNode(hnode, &hnode))
        {
            POBJECTTWIN pot;

            pot = (POBJECTTWIN)GetNodeData(hnode);

            tr = AddObjectTwinRecNode(*ppri, pot);

            if (tr != TR_SUCCESS)
            {
                DestroyRecItem(*ppri);
                break;
            }
        }

        if (tr == TR_SUCCESS)
        {
            DetermineDeletionPendingState(*ppri);

            DetermineRecActions(*ppri);

            LockStub(&(ptf->stub));

#ifdef DEBUG

            {
                LPCTSTR pcszAction;

                switch ((*ppri)->riaction)
                {
                    case RIA_COPY:
                        pcszAction = TEXT("Copy");
                        break;

                    case RIA_MERGE:
                        pcszAction = TEXT("Merge");
                        break;

                    case RIA_BROKEN_MERGE:
                        pcszAction = TEXT("Broken merge for");
                        break;

                    case RIA_DELETE:
                        pcszAction = TEXT("Delete");
                        break;

                    default:
                        ASSERT((*ppri)->riaction == RIA_NOTHING);
                        pcszAction = TEXT("Do nothing to");
                        break;
                }

                TRACE_OUT((TEXT("CreateRecItem(): %s %s."),
                            pcszAction,
                            (*ppri)->pcszName));
            }

#endif

        }
    }
    else
        tr = TR_OUT_OF_MEMORY;

    ASSERT(tr != TR_SUCCESS ||
            IS_VALID_READ_PTR(*ppri, CRECITEM));

    return(tr);
}


/*
 ** AddObjectTwinRecNode()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT AddObjectTwinRecNode(PRECITEM pri, POBJECTTWIN pot)
{
    TWINRESULT tr = TR_OUT_OF_MEMORY;
    PRECNODE prnNew;

    ASSERT(IS_VALID_READ_PTR(pri, CRECITEM));
    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));

    ASSERT(pri->ulcNodes < ULONG_MAX);

    /* Try to allocate a new reconciliation node. */

    if (AllocateMemory(sizeof(*prnNew), &prnNew))
    {
        LPTSTR pszFolder;

        if (AllocatePathString(pot->hpath, &pszFolder))
        {
            /* Fill in RECNODE fields. */

            /* N.b., we don't touch the dwUser field. */

            /*
             * The rnaction field may be changed later during the call to
             * DetermineRecActions().
             */

            prnNew->hvid = (HVOLUMEID)(pot->hpath);
            prnNew->pcszFolder = pszFolder;
            prnNew->hObjectTwin = (HOBJECTTWIN)pot;
            prnNew->priParent = pri;
            prnNew->fsLast = pot->fsLastRec;
            prnNew->rnaction = RNA_NOTHING;
            prnNew->dwFlags = 0;

            /* Set flags. */

            if (IsStubFlagSet(&(pot->stub), STUB_FL_FROM_OBJECT_TWIN))
                SET_FLAG(prnNew->dwFlags, RN_FL_FROM_OBJECT_TWIN);

            if (pot->ulcSrcFolderTwins > 0)
                SET_FLAG(prnNew->dwFlags, RN_FL_FROM_FOLDER_TWIN);

            /* Determine RECNODE file stamp. */

            if (IsStubFlagSet(&(pot->stub), STUB_FL_FILE_STAMP_VALID))
            {
                prnNew->fsCurrent = pot->fsCurrent;

                TRACE_OUT((TEXT("AddObjectTwinRecNode(): Used cached file stamp for object twin %s\\%s."),
                            prnNew->pcszFolder,
                            prnNew->priParent->pcszName));
            }
            else
            {
                MyGetFileStampByHPATH(pot->hpath, prnNew->priParent->pcszName,
                        &(prnNew->fsCurrent));

                TRACE_OUT((TEXT("AddObjectTwinRecNode(): Determined uncached file stamp for object twin %s\\%s."),
                            prnNew->pcszFolder,
                            prnNew->priParent->pcszName));
            }

            prnNew->rnstate = DetermineRecNodeState(prnNew);

            /* Tie the new RECNODE in to the parent RECITEM's list of RECNODEs. */

            prnNew->prnNext = pri->prnFirst;
            pri->prnFirst = prnNew;

            ASSERT(pri->ulcNodes < ULONG_MAX);
            pri->ulcNodes++;

            LockStub(&(pot->stub));

            tr = TR_SUCCESS;

            ASSERT(IS_VALID_STRUCT_PTR(prnNew, CRECNODE));

            TRACE_OUT((TEXT("AddObjectTwinRecNode(): Adding a RECNODE for object %s\\%s.  RECNODE state is %s."),
                        pszFolder,
                        pri->pcszName,
                        GetRECNODESTATEString(prnNew->rnstate)));
        }
        else
            FreeMemory(prnNew);
    }

    return(tr);
}


/*
 ** DoesTwinFamilyNeedRec()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL DoesTwinFamilyNeedRec(POBJECTTWIN pot, PVOID ptfri)
{
    BOOL bContinue = FALSE;
    TWINRESULT tr;
    PRECITEM priTemp;

    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
    ASSERT(IS_VALID_WRITE_PTR((PTWINFAMILYRECINFO)ptfri, TWINFAMILYRECINFO));

    /*
     * Create a temporary RECITEM for this object twin's twin family to
     * determine whether or not the twin family requires reconciliation.
     */

    tr = CreateRecItem(pot->ptfParent, &priTemp);

    if (tr == TR_SUCCESS)
    {
        if (priTemp->riaction == RIA_NOTHING)
        {
            ((PTWINFAMILYRECINFO)ptfri)->bNeedsRec = FALSE;

            bContinue = TRUE;

            TRACE_OUT((TEXT("DoesTwinFamilyNeedRec(): Twin family for object %s is up-to-date."),
                        priTemp->pcszName));
        }
        else
        {
            ((PTWINFAMILYRECINFO)ptfri)->bNeedsRec = TRUE;

            TRACE_OUT((TEXT("DoesTwinFamilyNeedRec(): Twin family for object %s needs to be reconciled."),
                        priTemp->pcszName));
        }

        DestroyRecItem(priTemp);
    }

    ((PTWINFAMILYRECINFO)ptfri)->tr = tr;

    return(bContinue);
}


/*
 ** GetFolderPairStatus()
 **
 ** Determines the status of a folder pair.
 **
 ** Arguments:     pfp - pointer to folder pair whose status is to be
 **                      determined
 **                pfts - pointer to FOLDERTWINSTATUS to be filled in with
 **                       reconciliation action that should be taken on the
 **                       folder pair, *pfts is filled in with one of the
 **                       following values:
 **
 **                         FTS_DO_NOTHING - no reconciliation required
 **                         FTS_DO_SOMETHING - reconciliation required
 **                         FTS_UNAVAILABLE - one or both of the folders is
 **                                           unavailable
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  Expands intersecting folder twins to object twins.  This may
 **                be S-L-O-W.
 */
PRIVATE_CODE TWINRESULT GetFolderPairStatus(PFOLDERPAIR pfp,
        CREATERECLISTPROC crlp,
        LPARAM lpCallbackData,
        PFOLDERTWINSTATUS pfts)
{
    TWINRESULT tr;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));
    ASSERT(! crlp ||
            IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));
    ASSERT(IS_VALID_WRITE_PTR(pfts, UINT));

    if (IsPathVolumeAvailable(pfp->hpath))
    {
        tr = ExpandIntersectingFolderTwins(pfp, crlp, lpCallbackData);

        if (tr == TR_SUCCESS)
        {
            TWINFAMILYRECINFO tfri;

            /*
             * Walk the list of generated object twins for one half of this folder
             * pair.  Prepare a RECITEM for each object twin's twin family.
             * Continue until one of the RECITEMs requires reconciliation, or we
             * run out of object twins.
             *
             * Both of the lists of object twins in this folder pair should hit
             * exactly the same twin families.
             */

            /* Set defaults in case there are no generated object twins. */

            tfri.tr = TR_SUCCESS;
            tfri.bNeedsRec = FALSE;

            /*
             * EnumGeneratedObjectTwins() returns TRUE if enumeration finished
             * without being stopped by the callback function.
             */

            if (EnumGeneratedObjectTwins(pfp, &DoesTwinFamilyNeedRec, &tfri))
                ASSERT(tfri.tr == TR_SUCCESS && ! tfri.bNeedsRec);
            else
                ASSERT((tfri.tr != TR_SUCCESS) ||
                        (tfri.tr == TR_SUCCESS && tfri.bNeedsRec));

            tr = tfri.tr;

            if (tr == TR_SUCCESS)
            {
                if (tfri.bNeedsRec)
                    *pfts = FTS_DO_SOMETHING;
                else
                    *pfts = FTS_DO_NOTHING;
            }
        }
    }
    else
    {
        *pfts = FTS_UNAVAILABLE;
        tr = TR_SUCCESS;
    }

    ASSERT(tr != TR_SUCCESS ||
            IsValidFOLDERTWINSTATUS(*pfts));

    return(tr);
}


#ifdef DEBUG

/*
 ** IsValidCreateRecListProcMsg()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidCreateRecListProcMsg(UINT uMsg)
{
    BOOL bResult;

    switch (uMsg)
    {
        case CRLS_BEGIN_CREATE_REC_LIST:
        case CRLS_DELTA_CREATE_REC_LIST:
        case CRLS_END_CREATE_REC_LIST:
            bResult = TRUE;
            break;

        default:
            bResult = FALSE;
            ERROR_OUT((TEXT("IsValidCreateRecListProcMsg(): Invalid CreateRecListProc() message %u."),
                        uMsg));
            break;
    }

    return(bResult);
}


/*
 ** IsValidFOLDERTWINSTATUS()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidFOLDERTWINSTATUS(FOLDERTWINSTATUS fts)
{
    BOOL bResult;

    switch (fts)
    {
        case FTS_DO_NOTHING:
        case FTS_DO_SOMETHING:
        case FTS_UNAVAILABLE:
            bResult = TRUE;
            break;

        default:
            bResult = FALSE;
            ERROR_OUT((TEXT("IsValidFOLDERTWINSTATUS(): Invalid FOLDERTWINSTATUS %d."),
                        fts));
            break;
    }

    return(bResult);
}


/*
 ** IsValidPCRECNODESTATECOUNTER()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCRECNODESTATECOUNTER(PCRECNODESTATECOUNTER pcrnscntr)
{
    /* The fields may be any values. */

    return(IS_VALID_READ_PTR(pcrnscntr, CRECNODESTATECOUNTER));
}

#endif


#if defined(DEBUG) || defined(VSTF)

/*
 ** IsValidRECNODESTATE()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidRECNODESTATE(RECNODESTATE rnstate)
{
    BOOL bResult;

    switch (rnstate)
    {
        case RNS_NEVER_RECONCILED:
        case RNS_UNAVAILABLE:
        case RNS_DOES_NOT_EXIST:
        case RNS_DELETED:
        case RNS_NOT_RECONCILED:
        case RNS_UP_TO_DATE:
        case RNS_CHANGED:
            bResult = TRUE;
            break;

        default:
            bResult = FALSE;
            ERROR_OUT((TEXT("IsValidRECNODESTATE(): Invalid RECNODESTATE %d."),
                        rnstate));
            break;
    }

    return(bResult);
}


/*
 ** IsValidRECNODEACTION()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidRECNODEACTION(RECNODEACTION rnaction)
{
    BOOL bResult;

    switch (rnaction)
    {
        case RNA_NOTHING:
        case RNA_COPY_FROM_ME:
        case RNA_COPY_TO_ME:
        case RNA_MERGE_ME:
        case RNA_DELETE_ME:
            bResult = TRUE;
            break;

        default:
            bResult = FALSE;
            ERROR_OUT((TEXT("IsValidRECNODEACTION(): Invalid RECNODEACTION %d."),
                        rnaction));
            break;
    }

    return(bResult);
}


/*
 ** IsValidRECITEMACTION()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidRECITEMACTION(RECITEMACTION riaction)
{
    BOOL bResult;

    switch (riaction)
    {
        case RIA_NOTHING:
        case RIA_DELETE:
        case RIA_COPY:
        case RIA_MERGE:
        case RIA_BROKEN_MERGE:
            bResult = TRUE;
            break;

        default:
            bResult = FALSE;
            ERROR_OUT((TEXT("IsValidRECITEMACTION(): Invalid RECITEMACTION %d."),
                        riaction));
            break;
    }

    return(bResult);
}


/*
 ** IsValidPCRECLIST()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCRECLIST(PCRECLIST pcrl)
{
    BOOL bResult = FALSE;

    if (IS_VALID_READ_PTR(pcrl, CRECLIST) &&
            IS_VALID_HANDLE(pcrl->hbr, BRFCASE))
    {
        PRECITEM pri;
        ULONG ulcRecItems = 0;

        for (pri = pcrl->priFirst;
                pri && IS_VALID_STRUCT_PTR(pri, CRECITEM);
                pri = pri->priNext)
        {
            ASSERT(ulcRecItems < ULONG_MAX);
            ulcRecItems++;
        }

        if (! pri && EVAL(ulcRecItems == pcrl->ulcItems))
            bResult = TRUE;
    }

    return(bResult);
}

#endif


/****************************** Public Functions *****************************/


/*
 ** IsReconciledFileStamp()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsReconciledFileStamp(PCFILESTAMP pcfs)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcfs, CFILESTAMP));

    return(pcfs->fscond != FS_COND_UNAVAILABLE);
}


/*
 ** LastKnownNonExistent()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL LastKnownNonExistent(PCFILESTAMP pcfsLast,
        PCFILESTAMP pcfsCurrent)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcfsLast, CFILESTAMP));
    ASSERT(IS_VALID_STRUCT_PTR(pcfsCurrent, CFILESTAMP));

    return(pcfsCurrent->fscond == FS_COND_DOES_NOT_EXIST ||
            (pcfsCurrent->fscond == FS_COND_UNAVAILABLE &&
             pcfsLast->fscond == FS_COND_DOES_NOT_EXIST));
}


/*
 ** DetermineDeletionPendingState()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       void
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DetermineDeletionPendingState(PCRECITEM pcri)
{
    PCRECNODE pcrn;
    ULONG ulcDeleted = 0;
    ULONG ulcToDelete = 0;
    ULONG ulcChanged = 0;
    ULONG ulcJustDeleted = 0;
    ULONG ulcNeverReconciledTotal = 0;

    /*
     * Don't fully validate *pcri here since we may be called from
     * CreateRecItem() with an incomplete RECITEM.
     */

    ASSERT(IS_VALID_READ_PTR(pcri, CRECITEM));

    /* Count RECNODE states. */

    for (pcrn = pcri->prnFirst; pcrn; pcrn= pcrn->prnNext)
    {
        if (LastKnownNonExistent(&(pcrn->fsLast), &(pcrn->fsCurrent)))
        {
            ASSERT(ulcDeleted < ULONG_MAX);
            ulcDeleted++;

            TRACE_OUT((TEXT("DetermineDeletionPendingState(): %s\\%s last known non-existent."),
                        pcrn->pcszFolder,
                        pcri->pcszName));
        }
        else if (IsStubFlagClear(&(((PCOBJECTTWIN)(pcrn->hObjectTwin))->stub),
                    STUB_FL_KEEP))
        {
            ASSERT(ulcToDelete < ULONG_MAX);
            ulcToDelete++;

            TRACE_OUT((TEXT("DetermineDeletionPendingState(): %s\\%s not explicitly kept."),
                        pcrn->pcszFolder,
                        pcri->pcszName));
        }

        if (IsReconciledFileStamp(&(pcrn->fsLast)))
        {
            if (pcrn->fsCurrent.fscond == FS_COND_EXISTS &&
                    MyCompareFileStamps(&(pcrn->fsLast), &(pcrn->fsCurrent)) != CR_EQUAL)
            {
                ASSERT(ulcChanged < ULONG_MAX);
                ulcChanged++;

                TRACE_OUT((TEXT("DetermineDeletionPendingState(): %s\\%s changed."),
                            pcrn->pcszFolder,
                            pcri->pcszName));
            }

            if (pcrn->fsLast.fscond == FS_COND_EXISTS &&
                    pcrn->fsCurrent.fscond == FS_COND_DOES_NOT_EXIST)
            {
                ASSERT(ulcJustDeleted < ULONG_MAX);
                ulcJustDeleted++;

                TRACE_OUT((TEXT("DetermineDeletionPendingState(): %s\\%s just deleted."),
                            pcrn->pcszFolder,
                            pcri->pcszName));
            }
        }
        else
        {
            ASSERT(ulcNeverReconciledTotal < ULONG_MAX);
            ulcNeverReconciledTotal++;

            TRACE_OUT((TEXT("DetermineDeletionPendingState(): %s\\%s never reconciled."),
                        pcrn->pcszFolder,
                        pcri->pcszName));
        }
    }

    /*
     * Take twin family out of the deletion pending state if any object twin
     * has changed, or if no object twins are awaiting deletion (i.e., all
     * object twins are deleted or kept).
     *
     * Take twin family in to the deletion pending state if any object twin has
     * just been deleted.
     */

    if (ulcNeverReconciledTotal > 0 ||
            ulcChanged > 0 ||
            ! ulcDeleted ||
            ! ulcToDelete)
    {
        UnmarkTwinFamilyDeletionPending((PTWINFAMILY)(pcri->hTwinFamily));

        if (ulcJustDeleted > 0)
            TRACE_OUT((TEXT("DetermineDeletionPendingState(): One or more object twins of %s deleted, but deletion not pending (%lu never reconciled, %lu changed, %lu deleted, %lu to delete, %lu just deleted)."),
                        pcri->pcszName,
                        ulcNeverReconciledTotal,
                        ulcChanged,
                        ulcDeleted,
                        ulcToDelete,
                        ulcJustDeleted));
    }
    else if (ulcJustDeleted > 0)
        MarkTwinFamilyDeletionPending((PTWINFAMILY)(pcri->hTwinFamily));

    return;
}


/*
 ** DeleteTwinsFromRecItem()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  May implicitly delete object twins, twin families, and pairs
 **                of folder twins.
 */
PUBLIC_CODE BOOL DeleteTwinsFromRecItem(PCRECITEM pcri)
{
    BOOL bObjectTwinsDeleted;
    BOOL bCheckFolderTwins;
    BOOL bFolderTwinsDeleted;
    HPTRARRAY hpaFolderPairs;

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));

    /*
     * DetermineDeletionPendingState() has already been performed by
     * MyReconcileItem() for the twin family of this RECITEM.
     */

    hpaFolderPairs = GetBriefcaseFolderPairPtrArray(((PCTWINFAMILY)(pcri->hTwinFamily))->hbr);

    ClearFlagInArrayOfStubs(hpaFolderPairs, STUB_FL_USED);

    bObjectTwinsDeleted = DeleteDeletedObjectTwins(pcri, &bCheckFolderTwins);

    if (bObjectTwinsDeleted)
        TRACE_OUT((TEXT("DeleteTwinsFromRecItem(): One or more object twins implicitly deleted from twin family for %s."),
                    pcri->pcszName));

    if (bCheckFolderTwins)
    {
        TRACE_OUT((TEXT("DeleteTwinsFromRecItem(): Checking for folder twins to implicitly delete.")));

        bFolderTwinsDeleted = DeleteDeletedFolderTwins(hpaFolderPairs);

        if (bFolderTwinsDeleted)
            TRACE_OUT((TEXT("DeleteTwinsFromRecItem(): One or more pairs of folder twins implicitly deleted.")));
    }
    else
        bFolderTwinsDeleted = FALSE;

    return(bObjectTwinsDeleted || bFolderTwinsDeleted);
}


/*
 ** DeleteTwinsFromRecList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  May implicitly delete object twins, twin families, and pairs
 **                of folder twins.
 */
PUBLIC_CODE BOOL DeleteTwinsFromRecList(PCRECLIST pcrl)
{
    PCRECITEM pcri;
    BOOL bObjectTwinsDeleted = FALSE;
    BOOL bCheckFolderTwins = FALSE;
    BOOL bFolderTwinsDeleted;
    HPTRARRAY hpaFolderPairs;

    ASSERT(IS_VALID_STRUCT_PTR(pcrl, CRECLIST));

    /*
     * DetermineDeletionPendingState() has already been performed by
     * CreateRecItem() for the twin family of each RECITEM in the RECLIST.
     */

    hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pcrl->hbr);

    ClearFlagInArrayOfStubs(hpaFolderPairs, STUB_FL_USED);

    for (pcri = pcrl->priFirst; pcri; pcri = pcri->priNext)
    {
        BOOL bLocalCheckFolderTwins;

        if (DeleteDeletedObjectTwins(pcri, &bLocalCheckFolderTwins))
        {
            TRACE_OUT((TEXT("DeleteTwinsFromRecList(): One or more object twins implicitly deleted from twin family for %s."),
                        pcri->pcszName));

            bObjectTwinsDeleted = TRUE;
        }

        if (bLocalCheckFolderTwins)
            bCheckFolderTwins = TRUE;
    }

    if (bCheckFolderTwins)
    {
        TRACE_OUT((TEXT("DeleteTwinsFromRecList(): Checking for folder twins to implicitly delete.")));

        bFolderTwinsDeleted = DeleteDeletedFolderTwins(hpaFolderPairs);

        if (bFolderTwinsDeleted)
            TRACE_OUT((TEXT("DeleteTwinsFromRecItem(): One or more pairs of folder twins implicitly deleted.")));
    }
    else
        bFolderTwinsDeleted = FALSE;

    return(bObjectTwinsDeleted || bFolderTwinsDeleted);
}


/*
 ** FindCopySource()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT FindCopySource(PCRECITEM pcri, PRECNODE *pprnCopySrc)
{
    TWINRESULT tr = TR_INVALID_PARAMETER;
    PRECNODE prn;

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
    ASSERT(IS_VALID_WRITE_PTR(pprnCopySrc, PRECNODE));

    ASSERT(pcri->riaction == RIA_COPY);

    for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
    {
        if (prn->rnaction == RNA_COPY_FROM_ME)
        {
            *pprnCopySrc = prn;
            tr = TR_SUCCESS;
            break;
        }
    }

    ASSERT(tr != TR_SUCCESS ||
            (*pprnCopySrc)->rnaction == RNA_COPY_FROM_ME);

    return(tr);
}


/*
 ** ChooseMergeDestination()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void ChooseMergeDestination(PCRECITEM pcri,
        PRECNODE *pprnMergeDest)
{
    PRECNODE prn;

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
    ASSERT(IS_VALID_WRITE_PTR(pprnMergeDest, PRECNODE));

    ASSERT(pcri->riaction == RIA_MERGE);

    for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
    {
        if (prn->rnaction == RNA_MERGE_ME)
        {
            *pprnMergeDest = prn;
            break;
        }
    }

    ASSERT(IS_VALID_STRUCT_PTR(*pprnMergeDest, CRECNODE));
    ASSERT((*pprnMergeDest)->rnaction == RNA_MERGE_ME);

    return;
}


/*
 ** ClearFlagInArrayOfStubs()
 **
 ** Clears flags in all the stubs pointed to by an array of pointers to stubs.
 **
 ** Arguments:     hpa - handle to array of pointers to stubs
 **                dwClearFlags - flags to be cleared
 **
 ** Returns:       void
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void ClearFlagInArrayOfStubs(HPTRARRAY hpa, DWORD dwClearFlags)
{
    ARRAYINDEX aicPtrs;
    ARRAYINDEX ai;

    ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
    ASSERT(FLAGS_ARE_VALID(dwClearFlags, ALL_STUB_FLAGS));

    aicPtrs = GetPtrCount(hpa);

    for (ai = 0; ai < aicPtrs; ai++)
        ClearStubFlag(GetPtr(hpa, ai), dwClearFlags);

    return;
}


/*
 ** NotifyCreateRecListStatus()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL NotifyCreateRecListStatus(CREATERECLISTPROC crlp, UINT uMsg,
        LPARAM lp, LPARAM lpCallbackData)
{
    BOOL bContinue;

    /* lpCallbackData may be any value. */

    ASSERT(! crlp ||
            IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));
    ASSERT(IsValidCreateRecListProcMsg(uMsg));
    ASSERT(! lp);

    if (crlp)
    {
        TRACE_OUT((TEXT("NotifyReconciliationStatus(): Calling CREATERECLISTPROC with message %s, LPARAM %#lx, callback data %#lx."),
                    GetCREATERECLISTPROCMSGString(uMsg),
                    lp,
                    lpCallbackData));

        bContinue = (*crlp)(uMsg, lp, lpCallbackData);
    }
    else
    {
        TRACE_OUT((TEXT("NotifyReconciliationStatus(): Not calling NULL CREATERECLISTPROC with message %s, LPARAM %#lx, callback data %#lx."),
                    GetCREATERECLISTPROCMSGString(uMsg),
                    lp,
                    lpCallbackData));

        bContinue = TRUE;
    }

    if (! bContinue)
        WARNING_OUT((TEXT("NotifyCreateRecListStatus(): Client callback aborted RecList creation.")));

    return(bContinue);
}


/*
 ** CompareInts()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE COMPARISONRESULT CompareInts(int nFirst, int nSecond)
{
    COMPARISONRESULT cr;

    /* nFirst and nSecond may be any value. */

    if (nFirst < nSecond)
        cr = CR_FIRST_SMALLER;
    else if (nFirst > nSecond)
        cr = CR_FIRST_LARGER;
    else
        cr = CR_EQUAL;

    return(cr);
}


#if defined(DEBUG) || defined(VSTF)

/*
 ** IsValidFILESTAMPCONDITION()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidFILESTAMPCONDITION(FILESTAMPCONDITION fsc)
{
    BOOL bResult;

    switch (fsc)
    {
        case FS_COND_EXISTS:
        case FS_COND_DOES_NOT_EXIST:
        case FS_COND_UNAVAILABLE:
            bResult = TRUE;
            break;

        default:
            bResult = FALSE;
            ERROR_OUT((TEXT("IsValidFILESTAMPCONDITION(): Unknown FILESTAMPCONDITION %d."),
                        fsc));
            break;
    }

    return(bResult);
}


/*
 ** IsValidPCFILESTAMP()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidPCFILESTAMP(PCFILESTAMP pcfs)
{
    /* dwcbLowLength may be any value. */

    return(IS_VALID_READ_PTR(pcfs, CFILESTAMP) &&
            EVAL(IsValidFILESTAMPCONDITION(pcfs->fscond)) &&
            IS_VALID_STRUCT_PTR(&(pcfs->ftMod), CFILETIME) &&
            IS_VALID_STRUCT_PTR(&(pcfs->ftModLocal), CFILETIME) &&
            ! pcfs->dwcbHighLength);
}


/*
 ** IsFolderObjectTwinFileStamp()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsFolderObjectTwinFileStamp(PCFILESTAMP pcfs)
{
    return(EVAL(! pcfs->ftMod.dwLowDateTime) &&
            EVAL(! pcfs->ftMod.dwHighDateTime) &&
            EVAL(! pcfs->dwcbLowLength) &&
            EVAL(! pcfs->dwcbHighLength));
}


/*
 ** IsValidPCRECNODE()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidPCRECNODE(PCRECNODE pcrn)
{
    return(IS_VALID_READ_PTR(pcrn, CRECNODE) &&
            IS_VALID_HANDLE(pcrn->hvid, VOLUMEID) &&
            IS_VALID_STRING_PTR(pcrn->pcszFolder, CSTR) &&
            IS_VALID_HANDLE(pcrn->hObjectTwin, OBJECTTWIN) &&
            IS_VALID_STRUCT_PTR(&(pcrn->fsLast), CFILESTAMP) &&
            IS_VALID_STRUCT_PTR(&(pcrn->fsCurrent), CFILESTAMP) &&
            FLAGS_ARE_VALID(pcrn->dwFlags, ALL_RECNODE_FLAGS) &&
            EVAL(IsValidRECNODESTATE(pcrn->rnstate)) &&
            EVAL(IsValidRECNODEACTION(pcrn->rnaction)) &&
            EVAL(*(pcrn->priParent->pcszName) ||
                (IsFolderObjectTwinFileStamp(&(pcrn->fsLast)) &&
                 IsFolderObjectTwinFileStamp(&(pcrn->fsCurrent)))) &&
            EVAL(IsReconciledFileStamp(&(pcrn->fsCurrent)) ||
                MyCompareFileStamps(&(pcrn->fsLast), &(((PCOBJECTTWIN)(pcrn->hObjectTwin))->fsLastRec)) == CR_EQUAL));
}


/*
 ** IsValidPCRECITEM()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidPCRECITEM(PCRECITEM pcri)
{
    BOOL bResult = FALSE;

    /* Does the twin family associated with this RECITEM still exist? */

    if (IS_VALID_READ_PTR(pcri, CRECITEM) &&
            IS_VALID_STRING_PTR(pcri->pcszName, CSTR) &&
            IS_VALID_HANDLE(pcri->hTwinFamily, TWINFAMILY))
    {
        if (IsStubFlagSet(&(((PTWINFAMILY)(pcri->hTwinFamily))->stub),
                    STUB_FL_UNLINKED))
            bResult = TRUE;
        else
        {
            ULONG ulcRecNodes = 0;
            PRECNODE prn;

            /*
             * Yes.  Verify the parent pointers, node count, and flags in this
             * RECITEM.
             */

            /* All unavailable RECNODEs should contain action RNA_NOTHING. */

            for (prn = pcri->prnFirst;
                    prn && IS_VALID_STRUCT_PTR(prn, CRECNODE);
                    prn = prn->prnNext)
            {
                /* Does the object twin associated with this RECNODE still exist? */

                if (IsStubFlagClear(&(((PTWINFAMILY)(pcri->hTwinFamily))->stub),
                            STUB_FL_UNLINKED))
                {
                    /* Yes.  Verify its parent RECITEM pointer. */

                    if (prn->priParent != pcri)
                    {
                        ERROR_OUT((TEXT("IsValidPCRECITEM(): Bad parent pointer found in RECNODE - parent pointer (%#lx), actual parent (%#lx)."),
                                    prn->priParent,
                                    pcri));

                        break;
                    }
                }

                ASSERT(ulcRecNodes < ULONG_MAX);
                ulcRecNodes++;
            }

            if (! prn)
            {
                /* Check RECNODE count. */

                if (ulcRecNodes == pcri->ulcNodes)
                {
                    if (ulcRecNodes >= 2)
                    {
                        /* Now verify the RECITEM's actions. */

                        switch (pcri->riaction)
                        {
                            case RIA_NOTHING:

                                /* All RECNODEs should contain action RNA_NOTHING. */

                                for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
                                {
                                    if (prn->rnaction != RNA_NOTHING)
                                    {
                                        ERROR_OUT((TEXT("IsValidPCRECITEM(): Nop RECITEM with non-nop RECNODE action %d."),
                                                    prn->rnaction));
                                        break;
                                    }
                                }

                                if (! prn)
                                    bResult = TRUE;

                                break;

                            case RIA_COPY:
                                {
                                    PRECNODE prnSrc = NULL;
                                    ULONG ulcCopyDests = 0;

                                    /*
                                     * There should only be one available RECNODE
                                     * containing action RNA_COPY_FROM_ME.
                                     *
                                     * The other available RECNODEs should contain action
                                     * RNA_COPY_TO_ME or RNA_NOTHING.
                                     */

                                    for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
                                    {
                                        if (RECNODE_IS_AVAILABLE(prn))
                                        {
                                            switch (prn->rnaction)
                                            {
                                                case RNA_COPY_TO_ME:
                                                    ASSERT(ulcCopyDests < ULONG_MAX);
                                                    ulcCopyDests++;
                                                    break;

                                                case RNA_NOTHING:
                                                    break;

                                                case RNA_COPY_FROM_ME:
                                                    if (! prnSrc)
                                                        prnSrc = prn;
                                                    else
                                                        ERROR_OUT((TEXT("IsValidPCRECITEM(): Copy RECITEM with multiple source file RECNODEs.")));
                                                    break;

                                                case RNA_MERGE_ME:
                                                    ERROR_OUT((TEXT("IsValidPCRECITEM(): Copy RECITEM with merge RECNODE.")));
                                                    break;

                                                default:
                                                    ERROR_OUT((TEXT("IsValidPCRECITEM(): Copy RECITEM with unknown RECNODE action %d."),
                                                                prn->rnaction));
                                                    break;
                                            }
                                        }
                                    }

                                    if (! prn)
                                    {
                                        /* Did we find a copy source? */

                                        if (prnSrc)
                                        {
                                            /* Yes. */

                                            /* Did we find one or more copy destinations? */

                                            if (ulcCopyDests > 0)
                                                /* Yes. */
                                                bResult = TRUE;
                                            else
                                                /* No. */
                                                ERROR_OUT((TEXT("IsValidPCRECITEM(): Copy RECITEM with no copy destination RECNODEs.")));
                                        }
                                        else
                                            /* No. */
                                            ERROR_OUT((TEXT("IsValidPCRECITEM(): Copy RECITEM with no copy source RECNODE.")));
                                    }

                                    break;
                                }

                            case RIA_MERGE:
                            case RIA_BROKEN_MERGE:
                                {
                                    PRECNODE prn;
                                    ULONG ulcMergeBuddies = 0;
#ifdef DEBUG
                                    LPCTSTR pcszAction = (pcri->riaction == RIA_MERGE) ?
                                        TEXT("merge") :
                                        TEXT("broken merge");
#endif

                                    /*
                                     * There should be multiple available RECNODEs
                                     * containing action RNA_MERGE_ME.
                                     *
                                     * The other available RECNODEs should contain action
                                     * RNA_COPY_TO_ME.
                                     */

                                    for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
                                    {
                                        if (RECNODE_IS_AVAILABLE(prn))
                                        {
                                            switch (prn->rnaction)
                                            {
                                                case RNA_COPY_TO_ME:
                                                    break;

                                                case RNA_NOTHING:
                                                    ERROR_OUT((TEXT("IsValidPCRECITEM(): %s RECITEM with RNA_NOTHING RECNODE."),
                                                                pcszAction));
                                                    break;

                                                case RNA_COPY_FROM_ME:
                                                    ERROR_OUT((TEXT("IsValidPCRECITEM(): %s RECITEM with RNA_COPY_FROM_ME RECNODE."),
                                                                pcszAction));
                                                    break;

                                                case RNA_MERGE_ME:
                                                    ASSERT(ulcMergeBuddies < ULONG_MAX);
                                                    ulcMergeBuddies++;
                                                    break;

                                                default:
                                                    ERROR_OUT((TEXT("IsValidPCRECITEM(): %s RECITEM with unknown RECNODE action %d."),
                                                                pcszAction,
                                                                prn->rnaction));
                                                    break;
                                            }
                                        }
                                    }

                                    if (! prn)
                                    {
                                        /* Are there multiple merge source RECNODEs? */

                                        if (ulcMergeBuddies > 1)
                                            bResult = TRUE;
                                        else
                                            ERROR_OUT((TEXT("IsValidPCRECITEM(): %s RECITEM with too few (%lu) merge source RECNODEs."),
                                                        pcszAction,
                                                        ulcMergeBuddies));
                                    }

                                    break;
                                }

                            case RIA_DELETE:
                                {
                                    BOOL bDelete = FALSE;

                                    /*
                                     * There should be at least one available RECNODE
                                     * marked RNA_DELETE_ME.  All other RECNODEs should be
                                     * marked RNA_NOTHING.
                                     */

                                    for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
                                    {
                                        if (RECNODE_IS_AVAILABLE(prn) &&
                                                prn->rnaction == RNA_DELETE_ME)
                                            bDelete = TRUE;
                                        else if (prn->rnaction != RNA_NOTHING)
                                            ERROR_OUT((TEXT("IsValidPCRECITEM(): Delete RECITEM with RECNODE marked %s."),
                                                        GetRECNODEACTIONString(prn->rnaction)));
                                    }

                                    if (bDelete)
                                        bResult = TRUE;
                                    else
                                        ERROR_OUT((TEXT("IsValidPCRECITEM(): Delete RECITEM with no RECNODEs marked RNA_DELETE_ME.")));

                                    break;
                                }

                            default:
                                ERROR_OUT((TEXT("IsValidPCRECITEM(): Unrecognized RECITEMACTION %d."),
                                            pcri->riaction));
                                break;
                        }
                    }
                    else
                        ERROR_OUT((TEXT("IsValidPCRECITEM(): RECITEM only has %lu RECNODEs."),
                                    ulcRecNodes));
                }
                else
                    ERROR_OUT((TEXT("IsValidPCRECITEM(): RECITEM has bad RECNODE count.  (%lu actual RECNODEs for RECITEM claiming %lu RECNODEs.)"),
                                ulcRecNodes,
                                pcri->ulcNodes));
            }
        }
    }

    return(bResult);
}

#endif


/***************************** Exported Functions ****************************/

/* RAIDRAID: (16203) AutoDoc CREATERECLISTPROC messages below. */

/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | CreateRecList | Creates a reconciliation list for all twins
  or for marked twins.

  @parm HTWINLIST | htl | A handle to the twin list that the reconciliation list
  is to be created from.  All twins in the twin list generate RECITEMs in the
  reconciliation list.

  @parm CREATERECLISTPROC | crlp | A procedure instance address of a callback
  function to be called with status information during the creation of the
  RECLIST.  crlp may be NULL to indicate that no RECLIST creation status callback
  function is to be called.

  @parm LPARAM | lpCallbackData | Callback data to be supplied to the RECLIST
  creation status callback function.  If crlp is NULL, lpCallbackData is ignored.

  @parm PRECLIST * | pprl | A pointer to a RECLIST to be filled in with a
  pointer to the new reconciliation list.  *pprl is only valid if TR_SUCCESS is
  returned.

  @rdesc If the reconciliation list was created successfully, TR_SUCCESS is
  returned.  Otherwise, the reconciliation list was not created successfully, and
  the return value indicates the error that occurred.

  @xref DestroyRecList MarkTwin

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI CreateRecList(HTWINLIST htl,
        CREATERECLISTPROC crlp,
        LPARAM lpCallbackData,
        PRECLIST *pprl)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(CreateRecList);

#ifdef EXPV
        /* Verify parameters. */

        /* lpCallbackData may be any value. */

        if (IS_VALID_HANDLE(htl, TWINLIST) &&
                (! crlp ||
                 IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC)) &&
                IS_VALID_WRITE_PTR(pprl, PRECLIST))
#endif
        {
            if (NotifyCreateRecListStatus(crlp, CRLS_BEGIN_CREATE_REC_LIST, 0,
                        lpCallbackData))
            {
                HBRFCASE hbr;

                /* Expand the required folder twins to object twins. */

                hbr = GetTwinListBriefcase(htl);

                InvalidatePathListInfo(GetBriefcasePathList(hbr));

                tr = ExpandFolderTwinsIntersectingTwinList(htl, crlp,
                        lpCallbackData);

                if (tr == TR_SUCCESS)
                {
                    PRECLIST prlNew;

                    /* Try to create a new reconciliation list. */

                    if (AllocateMemory(sizeof(*prlNew), &prlNew))
                    {
                        /* Initialize RECLIST structure fields. */

                        prlNew->ulcItems = 0;
                        prlNew->priFirst = NULL;
                        prlNew->hbr = hbr;

                        tr = AddRecItemsToRecList(htl, crlp, lpCallbackData, prlNew);

                        if (tr == TR_SUCCESS)
                        {
                            if (DeleteTwinsFromRecList(prlNew))
                            {
                                TRACE_OUT((TEXT("CreateRecList(): Twins implicitly deleted.  Recalculating RECLIST.")));

                                DestroyListOfRecItems(prlNew->priFirst);

                                prlNew->ulcItems = 0;
                                prlNew->priFirst = NULL;
                                ASSERT(prlNew->hbr == hbr);

                                tr = AddRecItemsToRecList(htl, crlp, lpCallbackData,
                                        prlNew);
                            }
                        }

                        if (tr == TR_SUCCESS)
                        {
                            *pprl = prlNew;

                            /* Don't allow abort. */

                            NotifyCreateRecListStatus(crlp, CRLS_END_CREATE_REC_LIST,
                                    0, lpCallbackData);

                            ASSERT(IS_VALID_STRUCT_PTR(*pprl, CRECLIST));
                        }
                        else
                            /*
                             * Destroy RECLIST and any RECITEMs that have been created
                             * so far.
                             */
                            MyDestroyRecList(prlNew);
                    }
                }
            }
            else
                tr = TR_ABORT;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(CreateRecList, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | DestroyRecList | Destroys a reconciliation list created by
  CreateRecList().

  @parm PRECLIST | prl | A pointer to the reconciliation list to be destroyed.
  The RECLIST pointed by pRecList is not valid after DestroyRecList() is called.

  @rdesc If the specified reconciliation list was freed successfully, TR_SUCCESS
  is returned.  Otherwise, the specified reconciliation list was not freed
  successfully, and the return value indicates the error that occurred.

  @xref CreateRecList

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI DestroyRecList(PRECLIST prl)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(DestroyRecList);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_STRUCT_PTR(prl, CRECLIST))
#endif
        {
            MyDestroyRecList(prl);

            tr = TR_SUCCESS;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(DestroyRecList, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | GetFolderTwinStatus | Determines the reconciliation status of
  a folder twin.

  @parm HFOLDERTWIN | hFolderTwin | A handle to the folder twin whose
  reconciliation status is to be determined.

  @parm CREATERECLISTPROC | crlp | A procedure instance address of a callback
  function to be called with status information during the creation of the
  RECLIST.  crlp may be NULL to indicate that no RECLIST creation status callback
  function is to be called.

  @parm LPARAM | lpCallbackData | Callback data to be supplied to the RECLIST
  creation status callback function.  If crlp is NULL, lpCallbackData is ignored.

  @parm PFOLDERTWINSTATUS | pfts | A pointer to a UINT to be filled in with the
  reconciliation status of the folder twin.  *pfts is only valid if TR_SUCCESS is
  returned.  *pfts may be one of the following values:

  @flag FTS_DO_NOTHING | This folder twin is up-to-date.  No reconciliation
  action needs to be taken on it.  N.b., the folder may still contain object
  twins that were not generated by the folder twin that are out-of-date.

  @flag FTS_DO_SOMETHING | This folder twin is out-of-date.  Some reconciliation
  action needs to be taken on it.

  @flag FTS_UNAVAILABLE | This folder twin is unavailable for reconciliation.

  @rdesc If the reconcilation status of the folder twin was determined
  successfully, *pfts is filled in with the status of the folder twin, and
  TR_SUCCESS is returned.  Otherwise, the reconciliation status of the folder
  twin was not determined successfully, *pfts is undefined, and the return
  value indicates the error that occurred.

  @comm If GetFolderTwinStatus() is called with a valid handle to a folder twin
  that has been deleted, TR_DELETED_TWIN will be returned.  N.b., in general,
  calling GetFolderTwinStatus() for a folder twin will not be any slower than
  calling CreateRecList() for that folder twin, and may be significantly faster
  if the folder twin requires reconciliation.

  @xref AddFolderTwin CreateFolderTwinList

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI GetFolderTwinStatus(HFOLDERTWIN hFolderTwin,
        CREATERECLISTPROC crlp,
        LPARAM lpCallbackData,
        PFOLDERTWINSTATUS pfts)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(GetFolderTwinStatus);

#ifdef EXPV
        /* Verify parameters. */

        /* lpCallbackData may be any value. */

        if (IS_VALID_HANDLE(hFolderTwin, FOLDERTWIN) &&
                EVAL(! crlp ||
                    IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC)) &&
                IS_VALID_WRITE_PTR(pfts, FOLDERTWINSTATUS))
#endif
        {
            /* Has this folder twin already been deleted? */

            if (IsStubFlagClear(&(((PFOLDERPAIR)hFolderTwin)->stub),
                        STUB_FL_UNLINKED))
            {
                if (NotifyCreateRecListStatus(crlp, CRLS_BEGIN_CREATE_REC_LIST, 0,
                            lpCallbackData))
                {
                    /* No. Determine its status. */

                    InvalidatePathListInfo(
                            GetBriefcasePathList(((PCFOLDERPAIR)hFolderTwin)->pfpd->hbr));

                    tr = GetFolderPairStatus((PFOLDERPAIR)hFolderTwin, crlp,
                            lpCallbackData, pfts);

                    if (tr == TR_SUCCESS)
                    {
                        /* Don't allow abort. */

                        NotifyCreateRecListStatus(crlp, CRLS_END_CREATE_REC_LIST, 0,
                                lpCallbackData);

                        if (IsStubFlagSet(&(((PFOLDERPAIR)hFolderTwin)->stub),
                                    STUB_FL_UNLINKED))
                        {
                            WARNING_OUT((TEXT("GetFolderTwinStatus(): Folder twin deleted during status determination.")));

                            tr = TR_DELETED_TWIN;
                        }

#ifdef DEBUG

                        {
                            LPCTSTR pcszStatus;

                            switch (*pfts)
                            {
                                case FTS_DO_NOTHING:
                                    pcszStatus = TEXT("FTS_DO_NOTHING");
                                    break;

                                case FTS_DO_SOMETHING:
                                    pcszStatus = TEXT("FTS_DO_SOMETHING");
                                    break;

                                default:
                                    ASSERT(*pfts == FTS_UNAVAILABLE);
                                    pcszStatus = TEXT("FTS_UNAVAILABLE");
                                    break;
                            }

                            TRACE_OUT((TEXT("GetFolderTwinStatus(): Status of folder %s is %s."),
                                        DebugGetPathString(((PFOLDERPAIR)hFolderTwin)->hpath),
                                        pcszStatus));
                        }

#endif

                    }
                }
                else
                    tr = TR_ABORT;
            }
            else
            {
                /* Yes.  Bail. */

                WARNING_OUT((TEXT("GetFolderTwinStatus(): Called on deleted folder twin.")));

                tr = TR_DELETED_TWIN;
            }
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        ASSERT(tr != TR_SUCCESS ||
                IsValidFOLDERTWINSTATUS(*pfts));

        DebugExitTWINRESULT(GetFolderTwinStatus, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\ptrarray.h ===
/*
 * ptrarray.h - Pointer array ADT description.
 */


/* Constants
 ************/

/*
 * ARRAYINDEX_MAX is set such that (ARRAYINDEX_MAX + 1) does not overflow an
 * ARRAYINDEX.  This guarantee allows GetPtrCount() to return a count of
 * pointers as an ARRAYINDEX.
 */

#define ARRAYINDEX_MAX           (LONG_MAX - 1)


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HPTRARRAY);
DECLARE_STANDARD_TYPES(HPTRARRAY);

/* array index */

typedef LONG ARRAYINDEX;
DECLARE_STANDARD_TYPES(ARRAYINDEX);

/*
 * pointer comparison callback function
 *
 * In sorting functions, both pointers are pointer array elements.  In
 * searching functions, the first pointer is reference data and the second
 * pointer is a pointer array element.
 */

typedef COMPARISONRESULT (*COMPARESORTEDPTRSPROC)(PCVOID, PCVOID);

/*
 * pointer comparison callback function
 *
 * In searching functions, the first pointer is reference data and the second
 * pointer is a pointer array element.
 */

typedef BOOL (*COMPAREUNSORTEDPTRSPROC)(PCVOID, PCVOID);

/* new pointer array flags */

typedef enum _newptrarrayflags
{
   /* Insert elements in sorted order. */

   NPA_FL_SORTED_ADD       = 0x0001,

   /* flag combinations */

   ALL_NPA_FLAGS           = NPA_FL_SORTED_ADD
}
NEWPTRARRAYFLAGS;

/* new pointer array description */

typedef struct _newptrarray
{
   DWORD dwFlags;

   ARRAYINDEX aicInitialPtrs;

   ARRAYINDEX aicAllocGranularity;
}
NEWPTRARRAY;
DECLARE_STANDARD_TYPES(NEWPTRARRAY);


/* Prototypes
 *************/

/* ptrarray.c */

extern BOOL CreatePtrArray(PCNEWPTRARRAY, PHPTRARRAY);
extern void DestroyPtrArray(HPTRARRAY);
extern BOOL InsertPtr(HPTRARRAY, COMPARESORTEDPTRSPROC, ARRAYINDEX, PCVOID);
extern BOOL AddPtr(HPTRARRAY, COMPARESORTEDPTRSPROC, PCVOID, PARRAYINDEX);
extern void DeletePtr(HPTRARRAY, ARRAYINDEX);
extern void DeleteAllPtrs(HPTRARRAY);
extern ARRAYINDEX GetPtrCount(HPTRARRAY);
extern PVOID GetPtr(HPTRARRAY, ARRAYINDEX);
extern void SortPtrArray(HPTRARRAY, COMPARESORTEDPTRSPROC);
extern BOOL SearchSortedArray(HPTRARRAY, COMPARESORTEDPTRSPROC, PCVOID, PARRAYINDEX);
extern BOOL LinearSearchArray(HPTRARRAY, COMPAREUNSORTEDPTRSPROC, PCVOID, PARRAYINDEX);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidHPTRARRAY(HPTRARRAY);

#endif

#ifdef VSTF

extern BOOL IsValidHGLOBAL(HGLOBAL);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\recon.c ===
/*
 * recon.c - Reconciliation routines.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"
#include "oleutil.h"


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE void GenerateShellEvents(PCRECITEM);
PRIVATE_CODE TWINRESULT MyReconcileItem(PCRECITEM, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
PRIVATE_CODE void UpdateObjectTwinStates(PCRECITEM);
PRIVATE_CODE TWINRESULT CopyFolder(PCRECITEM, RECSTATUSPROC, LPARAM);
PRIVATE_CODE TWINRESULT DeleteFolder(PCRECITEM, RECSTATUSPROC, LPARAM);
PRIVATE_CODE TWINRESULT DealWithCopy(PCRECITEM, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
PRIVATE_CODE TWINRESULT DealWithMerge(PCRECITEM, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
PRIVATE_CODE TWINRESULT DealWithDelete(PCRECITEM, RECSTATUSPROC, LPARAM);
PRIVATE_CODE ULONG CountRECNODEs(PCRECITEM, RECNODEACTION);
PRIVATE_CODE TWINRESULT UpdateRecNodeFileStamps(PCRECITEM);
PRIVATE_CODE BOOL DeletedTwinsInRecItem(PCRECITEM);


/*
 ** GenerateShellEvents()
 **
 ** Notifies the Shell about reconciliation events for a RECITEM.
 **
 ** Arguments:     pcri - reconciled RECITEM to notify Shell about
 **
 ** Returns:       void
 **
 ** Side Effects:  None
 */
PRIVATE_CODE void GenerateShellEvents(PCRECITEM pcri)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));

    /* Any reconciliation events to report? */

    if (pcri->riaction == RIA_NOTHING ||
            pcri->riaction == RIA_COPY ||
            pcri->riaction == RIA_MERGE ||
            pcri->riaction == RIA_DELETE)
    {
        PRECNODE prn;

        /*
         * Yes.  Send an appropriate notification to the Shell about the file
         * operations assumed carried out during reconciliation.  The file system
         * unfortunately does not support notifications for some of the
         * interesting reconciliation operations.  We also generate a specious
         * update notification for the source file in a copy operation to cause
         * the Briefcase ui to recalculate the status string for that file, even
         * though the file itself has not changed.
         */

        for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
        {
            BOOL bNotify;
            NOTIFYSHELLEVENT nse;
            LPCTSTR pcszPath;
            TCHAR rgchPath[MAX_PATH_LEN];

            /* How shall I notify you?  Let me enumerate the ways. */

            bNotify = TRUE;

            if (IsFolderObjectTwinName(pcri->pcszName))
            {
                nse = NSE_UPDATE_FOLDER;

                pcszPath = prn->pcszFolder;

                switch (prn->rnaction)
                {
                    /*
                     * Notifications about folders that were copied or deleted
                     * during reconciliation were sent during reconciliation.  Don't
                     * send redundant notifications.
                     */
                    case RNA_COPY_TO_ME:
                    case RNA_DELETE_ME:
                        bNotify = FALSE;
                        break;

                    default:
                        ASSERT(prn->rnaction == RNA_NOTHING ||
                                prn->rnaction == RNA_COPY_FROM_ME);
                        break;
                }
            }
            else
            {
                nse = NSE_UPDATE_ITEM;

                ComposePath(rgchPath, prn->pcszFolder, pcri->pcszName, ARRAYSIZE(rgchPath));
                pcszPath = rgchPath;

                switch (prn->rnaction)
                {
                    case RNA_COPY_TO_ME:
                        if (prn->rnstate == RNS_DOES_NOT_EXIST ||
                                prn->rnstate == RNS_DELETED)
                            nse = NSE_CREATE_ITEM;
                        break;

                    case RNA_DELETE_ME:
                        nse = NSE_DELETE_ITEM;
                        break;

                    default:
                        ASSERT(prn->rnaction == RNA_NOTHING ||
                                prn->rnaction == RNA_COPY_FROM_ME ||
                                prn->rnaction == RNA_MERGE_ME);
                        break;
                }
            }

            if (bNotify)
                NotifyShell(pcszPath, nse);
        }
    }
}


/*
 ** MyReconcileItem()
 **
 ** Reconciles a reconciliation item.
 **
 ** Arguments:     pcri - pointer to reconciliation item to be reconciled
 **
 ** Side Effects:
 */
PRIVATE_CODE TWINRESULT MyReconcileItem(PCRECITEM pcri, RECSTATUSPROC rsp,
        LPARAM lpCallbackData, DWORD dwFlags,
        HWND hwndOwner,
        HWND hwndProgressFeedback)
{
    TWINRESULT tr;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
    ASSERT(! rsp ||
            IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
    ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_RI_FLAGS));
    ASSERT(IS_FLAG_CLEAR(dwFlags, RI_FL_ALLOW_UI) ||
            IS_VALID_HANDLE(hwndOwner, WND));
    ASSERT(IS_FLAG_CLEAR(dwFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
            IS_VALID_HANDLE(hwndProgressFeedback, WND));

#ifdef DEBUG

    {
        LPCTSTR pcszGerund;

        switch (pcri->riaction)
        {
            case RIA_NOTHING:
                pcszGerund = TEXT("Taking no action on");
                break;

            case RIA_COPY:
                pcszGerund = TEXT("Copying");
                break;

            case RIA_MERGE:
                pcszGerund = TEXT("Merging");
                break;

            case RIA_BROKEN_MERGE:
                pcszGerund = TEXT("Broken merge for");
                break;

            case RIA_DELETE:
                pcszGerund = TEXT("Deleting");
                break;

            default:
                pcszGerund = TEXT("Unknown action specifed for");
                break;
        }

        TRACE_OUT((TEXT("MyReconcileItem(): %s %s."),
                    pcszGerund,
                    *(pcri->pcszName) ? pcri->pcszName : TEXT("folder")));
    }

#endif

    switch (pcri->riaction)
    {
        case RIA_NOTHING:
            tr = TR_SUCCESS;
            break;

        case RIA_COPY:
            if (*(pcri->pcszName))
                tr = DealWithCopy(pcri, rsp, lpCallbackData, dwFlags, hwndOwner,
                        hwndProgressFeedback);
            else
                tr = CopyFolder(pcri, rsp, lpCallbackData);

            if (tr == TR_SUCCESS)
                tr = UpdateRecNodeFileStamps(pcri);
            break;

        case RIA_MERGE:
            tr = DealWithMerge(pcri, rsp, lpCallbackData, dwFlags, hwndOwner,
                    hwndProgressFeedback);

            if (tr == TR_SUCCESS || tr == TR_MERGE_INCOMPLETE)
                tr = UpdateRecNodeFileStamps(pcri);
            break;

        case RIA_DELETE:
            if (*(pcri->pcszName))
                tr = DealWithDelete(pcri, rsp, lpCallbackData);
            else
            {
                tr = DeleteFolder(pcri, rsp, lpCallbackData);

                if (tr == TR_DEST_WRITE_FAILED)
                    tr = TR_SUCCESS;
            }

            if (tr == TR_SUCCESS)
                tr = UpdateRecNodeFileStamps(pcri);
            break;

        default:
            ASSERT(pcri->riaction == RIA_BROKEN_MERGE);
            tr = TR_NO_MERGE_HANDLER;
            break;
    }

    /*
     * Only update briefcase time stamps if the entire reconciliation operation
     * on this RECITEM is successful.  However, the RECNODE time stamps in the
     * given RECITEM have been updated as they were changed.
     */

    if (tr == TR_SUCCESS)
    {
        UpdateObjectTwinStates(pcri);

        DetermineDeletionPendingState(pcri);

        DeleteTwinsFromRecItem(pcri);
    }
    else if (tr == TR_MERGE_INCOMPLETE)
        tr = TR_SUCCESS;

    if (tr == TR_SUCCESS)
        GenerateShellEvents(pcri);

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));

    return(tr);
}


/*
 ** UpdateObjectTwinStates()
 **
 ** Updates the last reconciliation time stamp of the twin family and the object
 ** twins associated with a RECITEM that has just been successfully reconciled.
 **
 ** Arguments:     pri - pointer to reconciliation item that has just been
 **                      reconciled
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  Implicitly deletes twin family if the last known state of
 **                every component object twins is non-existence.
 **
 ** N.b., this function assumes that the actions specified in the RECNODEs of
 ** the RECITEM were carried out successfully.
 **
 ** This function assumes that all available RECNODES were reconciled.
 **
 ** This function assumes that the time stamp fields of the RECNODEs associated
 ** with objects that were modified during reconciliation were filled in
 ** immediately after each of those RECNODEs was reconciled.  I.e., that all
 ** time stamp fields in reconciled RECNODEs are up-to-date with respect to any
 ** modifications that may have been made to them during reconciliation.
 */
PRIVATE_CODE void UpdateObjectTwinStates(PCRECITEM pcri)
{
    PRECNODE prn;
    BOOL bNewVersion = FALSE;

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));

    /*
     * There is a new version if any changed or never reconciled RECNODEs were
     * reconciled as RNA_NOTHING, RNA_COPY_FROM_ME, or RNA_MERGE_ME.
     */

    for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
    {
        if ((prn->rnstate == RNS_NEVER_RECONCILED ||
                    prn->rnstate == RNS_CHANGED) &&
                (prn->rnaction == RNA_NOTHING ||
                 prn->rnaction == RNA_COPY_FROM_ME ||
                 prn->rnaction == RNA_MERGE_ME))
            bNewVersion = TRUE;
    }

    /*
     * Save file stamps of available files.  Mark unavailable object twins not
     * reconciled if any new versions exist in the reconciled set of files.
     */

    for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
    {
        POBJECTTWIN pot;

        pot = (POBJECTTWIN)(prn->hObjectTwin);

        if (prn->fsCurrent.fscond != FS_COND_UNAVAILABLE)
        {
            ClearStubFlag(&(pot->stub), STUB_FL_NOT_RECONCILED);
            pot->fsLastRec = prn->fsCurrent;

            /*
             * Remember not to delete object twins as requested.  Treat any folder
             * that could not be deleted as implicitly kept as well.
             */

            if (IS_FLAG_SET(prn->dwFlags, RN_FL_DELETION_SUGGESTED) &&
                    IsTwinFamilyDeletionPending((PCTWINFAMILY)(pcri->hTwinFamily)) &&
                    (pcri->riaction == RIA_NOTHING ||
                     pcri->riaction == RIA_DELETE) &&
                    (prn->rnaction != RNA_DELETE_ME ||
                     IsFolderObjectTwinName(pcri->pcszName)))
            {
                SetStubFlag(&(pot->stub), STUB_FL_KEEP);

                TRACE_OUT((TEXT("UpdateObjectTwinStates(): Object twin %s\\%s will be kept and not deleted."),
                            prn->pcszFolder,
                            prn->priParent->pcszName));
            }
        }
        else if (bNewVersion &&
                IsReconciledFileStamp(&(prn->fsLast)))
        {
            SetStubFlag(&(pot->stub), STUB_FL_NOT_RECONCILED);

            WARNING_OUT((TEXT("UpdateObjectTwinStates(): Marked %s\\%s not reconciled."),
                        prn->pcszFolder,
                        pcri->pcszName));
        }
    }

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));

    return;
}


/*
 ** CopyFolder()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT CopyFolder(PCRECITEM pcri, RECSTATUSPROC rsp,
        LPARAM lpCallbackData)
{
    TWINRESULT tr;
    RECSTATUSUPDATE rsu;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
    ASSERT(! rsp ||
            IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));

    ASSERT(IsFolderObjectTwinName(pcri->pcszName));

    rsu.ulScale = CountRECNODEs(pcri, RNA_COPY_TO_ME);
    ASSERT(rsu.ulScale > 0);
    rsu.ulProgress = 0;

    if (NotifyReconciliationStatus(rsp, RS_BEGIN_COPY, (LPARAM)&rsu,
                lpCallbackData))
    {
        PRECNODE prn;

        tr = TR_SUCCESS;

        for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
        {
            if (prn->rnaction == RNA_COPY_TO_ME)
                tr = CreateFolders(prn->pcszFolder, (HPATH)(prn->hvid));
        }

        if (tr == TR_SUCCESS)
        {
            /* 100% complete. */

            rsu.ulProgress = rsu.ulScale;

            /* Don't allow abort. */

            NotifyReconciliationStatus(rsp, RS_END_COPY, (LPARAM)&rsu,
                    lpCallbackData);
        }
    }
    else
        tr = TR_ABORT;

    return(tr);
}


/*
 ** DeleteFolder()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT DeleteFolder(PCRECITEM pcri, RECSTATUSPROC rsp,
        LPARAM lpCallbackData)
{
    TWINRESULT tr;
    RECSTATUSUPDATE rsu;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
    ASSERT(! rsp ||
            IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));

    ASSERT(IsFolderObjectTwinName(pcri->pcszName));

    rsu.ulScale = CountRECNODEs(pcri, RNA_DELETE_ME);
    ASSERT(rsu.ulScale > 0);
    rsu.ulProgress = 0;

    if (NotifyReconciliationStatus(rsp, RS_BEGIN_DELETE, (LPARAM)&rsu,
                lpCallbackData))
    {
        PRECNODE prn;

        tr = TR_SUCCESS;

        for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
        {
            if (prn->rnaction == RNA_DELETE_ME)
                tr = DestroySubtree(prn->pcszFolder, (HPATH)(prn->hvid));
        }

        if (tr == TR_SUCCESS)
        {
            /* 100% complete. */

            rsu.ulProgress = rsu.ulScale;

            /* Don't allow abort. */

            NotifyReconciliationStatus(rsp, RS_END_DELETE, (LPARAM)&rsu,
                    lpCallbackData);
        }
    }
    else
        tr = TR_ABORT;

    return(tr);
}


/*
 ** DealWithCopy()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT DealWithCopy(PCRECITEM pcri, RECSTATUSPROC rsp,
        LPARAM lpCallbackData, DWORD dwInFlags,
        HWND hwndOwner, HWND hwndProgressFeedback)
{
    TWINRESULT tr;
    PRECNODE prnCopySrc;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
    ASSERT(! rsp ||
            IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
    ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_RI_FLAGS));
    ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_ALLOW_UI) ||
            IS_VALID_HANDLE(hwndOwner, WND));
    ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
            IS_VALID_HANDLE(hwndProgressFeedback, WND));

    tr = FindCopySource(pcri, &prnCopySrc);

    if (EVAL(tr == TR_SUCCESS))
        tr = CopyHandler(prnCopySrc, rsp, lpCallbackData, dwInFlags, hwndOwner,
                hwndProgressFeedback);

    return(tr);
}


/*
 ** DealWithMerge()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT DealWithMerge(PCRECITEM pcri, RECSTATUSPROC rsp,
        LPARAM lpCallbackData, DWORD dwInFlags,
        HWND hwndOwner,
        HWND hwndProgressFeedback)
{
    TWINRESULT tr;
    HRESULT hr;
    PRECNODE prnMergeDest;
    PRECNODE prnMergedResult;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
    ASSERT(! rsp ||
            IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
    ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_RI_FLAGS));
    ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_ALLOW_UI) ||
            IS_VALID_HANDLE(hwndOwner, WND));
    ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
            IS_VALID_HANDLE(hwndProgressFeedback, WND));

    ChooseMergeDestination(pcri, &prnMergeDest);

    hr = MergeHandler(prnMergeDest, rsp, lpCallbackData, dwInFlags, hwndOwner,
            hwndProgressFeedback, &prnMergedResult);

    if (hr == S_OK ||
            hr == REC_S_NOTCOMPLETEBUTPROPAGATE)
    {
        tr = CopyHandler(prnMergedResult, rsp, lpCallbackData, dwInFlags,
                hwndOwner, hwndProgressFeedback);

        if (tr == TR_SUCCESS)
            TRACE_OUT((TEXT("DealWithMerge(): Propagated merged result %s\\%s successfully."),
                        prnMergedResult->pcszFolder,
                        pcri->pcszName));
        else
            WARNING_OUT((TEXT("DealWithMerge(): Propagating merged result %s\\%s failed."),
                        prnMergedResult->pcszFolder,
                        pcri->pcszName));
    }
    else
        tr = TR_SUCCESS;

    return((tr == TR_SUCCESS) ? TranslateHRESULTToTWINRESULT(hr)
            : tr);
}


/*
 ** DealWithDelete()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT DealWithDelete(PCRECITEM pcri, RECSTATUSPROC rsp,
        LPARAM lpCallbackData)
{
    TWINRESULT tr;
    RECSTATUSUPDATE rsu;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
    ASSERT(! rsp ||
            IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));

    rsu.ulScale = CountRECNODEs(pcri, RNA_DELETE_ME);
    ASSERT(rsu.ulScale > 0);
    rsu.ulProgress = 0;

    if (NotifyReconciliationStatus(rsp, RS_BEGIN_DELETE, (LPARAM)&rsu,
                lpCallbackData))
    {
        PRECNODE prn;

        tr = TR_SUCCESS;

        for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
        {
            if (prn->rnaction == RNA_DELETE_ME)
            {
                TCHAR rgchPath[MAX_PATH_LEN];

                ComposePath(rgchPath, prn->pcszFolder, prn->priParent->pcszName, ARRAYSIZE(rgchPath));
                ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

                if (MyIsPathOnVolume(rgchPath, (HPATH)(prn->hvid)))
                {
                    if (DeleteFile(rgchPath))
                        WARNING_OUT((TEXT("DealWithDelete(): Deleted file %s."),
                                    rgchPath));
                    else
                    {
                        tr = TR_DEST_OPEN_FAILED;

                        WARNING_OUT((TEXT("DealWithDelete(): Failed to delete file %s."),
                                    rgchPath));
                    }
                }
                else
                    tr = TR_UNAVAILABLE_VOLUME;
            }
        }

        if (tr == TR_SUCCESS)
        {
            /* 100% complete. */

            rsu.ulProgress = rsu.ulScale;

            /* Don't allow abort. */

            NotifyReconciliationStatus(rsp, RS_END_DELETE, (LPARAM)&rsu,
                    lpCallbackData);
        }
    }
    else
        tr = TR_ABORT;

    return(tr);
}


/*
 ** CountRECNODEs()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE ULONG CountRECNODEs(PCRECITEM pcri, RECNODEACTION rnaction)
{
    ULONG ulc = 0;
    PRECNODE prn;

    for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
    {
        if (prn->rnaction == rnaction)
        {
            ASSERT(ulc < ULONG_MAX);
            ulc++;
        }
    }

    return(ulc);
}


/*
 ** UpdateRecNodeFileStamps()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT UpdateRecNodeFileStamps(PCRECITEM pcri)
{
    TWINRESULT tr;
    PRECNODE prn;

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));

    tr = TR_SUCCESS;

    for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
    {
        ASSERT(IS_VALID_HANDLE(prn->hObjectTwin, OBJECTTWIN));

        /* Was the RECNODE supposed to be reconciled? */

        /*
         * FEATURE: We should avoid updating file stamps of copy sources here in
         * the SimpleCopy() case.
         */

        if (prn->rnaction != RNA_NOTHING)
        {
            ASSERT(prn->fsCurrent.fscond != FS_COND_UNAVAILABLE);

            /* Leave prn->fsLast as pot->fsLastRec here. */

            MyGetFileStampByHPATH(((PCOBJECTTWIN)(prn->hObjectTwin))->hpath,
                    GetString(((PCOBJECTTWIN)(prn->hObjectTwin))->ptfParent->hsName),
                    &(prn->fsCurrent));
        }
    }

    return(tr);
}


/*
 ** DeletedTwinsInRecItem()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL DeletedTwinsInRecItem(PCRECITEM pcri)
{
    BOOL bResult = TRUE;

    ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));

    /* Has the associated twin family been deleted? */

    if (IsStubFlagClear(&(((PTWINFAMILY)(pcri->hTwinFamily))->stub), STUB_FL_UNLINKED))
    {
        PRECNODE prn;

        /* No.  Have any of the associated object twins been deleted? */

        for (prn = pcri->prnFirst;
                prn && IsStubFlagClear(&(((PCOBJECTTWIN)(prn->hObjectTwin))->stub), STUB_FL_UNLINKED);
                prn = prn->prnNext)
            ;

        if (! prn)
            bResult = FALSE;
    }

    return(bResult);
}


/****************************** Public Functions *****************************/


/*
 ** CopyFileStampFromFindData()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void CopyFileStampFromFindData(PCWIN32_FIND_DATA pcwfdSrc,
        PFILESTAMP pfsDest)
{
    ASSERT(IS_VALID_READ_PTR(pcwfdSrc, CWIN32_FIND_DATA));
    ASSERT(IS_VALID_WRITE_PTR(pfsDest, FILESTAMP));

    pfsDest->dwcbHighLength = pcwfdSrc->nFileSizeHigh;
    pfsDest->dwcbLowLength = pcwfdSrc->nFileSizeLow;

    /* Convert to local time and save that too */

    if ( !FileTimeToLocalFileTime(&pcwfdSrc->ftLastWriteTime, &pfsDest->ftModLocal) )
    {
        /* Just copy the time if FileTimeToLocalFileTime failed */

        pfsDest->ftModLocal = pcwfdSrc->ftLastWriteTime;
    }
    pfsDest->ftMod = pcwfdSrc->ftLastWriteTime;
    pfsDest->fscond = FS_COND_EXISTS;

    ASSERT(IS_VALID_STRUCT_PTR(pfsDest, CFILESTAMP));

    return;
}


/*
 ** MyGetFileStamp()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void MyGetFileStamp(LPCTSTR pcszFile, PFILESTAMP pfs)
{
    WIN32_FIND_DATA wfd;
    HANDLE hff;

    ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(pfs, FILESTAMP));

    ZeroMemory(pfs, sizeof(*pfs));

    hff = FindFirstFile(pcszFile, &wfd);

    if (hff != INVALID_HANDLE_VALUE)
    {
        if (! IS_ATTR_DIR(wfd.dwFileAttributes))
            CopyFileStampFromFindData(&wfd, pfs);
        else
            pfs->fscond = FS_COND_EXISTS;

        EVAL(FindClose(hff));
    }
    else
        pfs->fscond = FS_COND_DOES_NOT_EXIST;

    ASSERT(IS_VALID_STRUCT_PTR(pfs, CFILESTAMP));

    return;
}


/*
 ** MyGetFileStampByHPATH()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:
 */
PUBLIC_CODE void MyGetFileStampByHPATH(HPATH hpath, LPCTSTR pcszSubPath,
        PFILESTAMP pfs)
{
    ASSERT(IS_VALID_HANDLE(hpath, PATH));
    ASSERT(! pcszSubPath ||
            IS_VALID_STRING_PTR(pcszSubPath, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(pfs, FILESTAMP));

    if (IsPathVolumeAvailable(hpath))
    {
        TCHAR rgchPath[MAX_PATH_LEN];

        /* The root of the file's path is accessible. */

        rgchPath[0] = TEXT('\0');
        GetPathString(hpath, rgchPath, ARRAYSIZE(rgchPath));
        if (pcszSubPath)
            CatPath(rgchPath, pcszSubPath, ARRAYSIZE(rgchPath));
        ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

        MyGetFileStamp(rgchPath, pfs);
    }
    else
    {
        ZeroMemory(pfs, sizeof(*pfs));
        pfs->fscond = FS_COND_UNAVAILABLE;
    }

    ASSERT(IS_VALID_STRUCT_PTR(pfs, CFILESTAMP));

    return;
}


/*
 ** MyCompareFileStamps()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** Any FS_COND_UNAVAILABLE == any FS_COND_UNAVAILABLE.
 ** Any FS_COND_UNAVAILABLE < any FS_COND_DOES_NOT_EXIST.
 ** Any FS_COND_DOES_NOT_EXIST == any FS_COND_DOES_NOT_EXIST.
 ** Any FS_COND_DOES_NOT_EXIST < any FS_COND_EXISTS.
 ** Two FS_COND_EXISTS are compared by date and time.
 **
 ** Hack Warning: This function depends upon the constant values of
 ** FS_COND_UNAVAILABLE, FS_COND_DOES_NOT_EXIST, and FS_COND_EXISTS being in
 ** increasing order, i.e.,
 **
 ** FS_COND_UNAVAILABLE < FS_COND_DOES_NOT_EXIST < FS_COND_EXISTS
 */
PUBLIC_CODE COMPARISONRESULT MyCompareFileStamps(PCFILESTAMP pcfs1, PCFILESTAMP pcfs2)
{
    int nResult;

    ASSERT(IS_VALID_STRUCT_PTR(pcfs1, CFILESTAMP));
    ASSERT(IS_VALID_STRUCT_PTR(pcfs2, CFILESTAMP));

    nResult = (int)(pcfs1->fscond - pcfs2->fscond);

    if (! nResult && pcfs1->fscond == FS_COND_EXISTS)
    {
        /* File times are stored as UTC times.  However, files on FAT
         ** file systems only store the local time.  This means the UTC
         ** is derived from the local time, and fudged depending on the
         ** current timezone info.  This means that the UTC time will
         ** differ between timezone changes.
         **
         ** For remote files, the time's derivation depends on the server.
         ** NTFS servers provide the absolute UTC time, regardless of timezone.
         ** These are the best.  Likewise, NWServer keeps track of the 
         ** timezone and puts the UTC time on the wire like NTFS.  FAT
         ** systems convert the local time to UTC time based on the server's
         ** timezone, and places the UTC time on the wire.  Netware 3.31
         ** and some SMB servers put the local time on the wire and have
         ** the client convert to UTC time, so it uses the client's timezone.
         **
         ** One way to cover most of the holes that occur due to timezone
         ** changes is store both the UTC time and the local time.  If either
         ** are the same, then the file has not changed.
         */

        BOOL bModEqual = (pcfs1->ftMod.dwHighDateTime == pcfs2->ftMod.dwHighDateTime);
        BOOL bModLocalEqual = (pcfs1->ftModLocal.dwHighDateTime == pcfs2->ftModLocal.dwHighDateTime);

        if (bModEqual || bModLocalEqual)
        {
            if (bModEqual && pcfs1->ftMod.dwLowDateTime == pcfs2->ftMod.dwLowDateTime ||
                    bModLocalEqual && pcfs1->ftModLocal.dwLowDateTime == pcfs2->ftModLocal.dwLowDateTime)
            {
                if (pcfs1->dwcbHighLength == pcfs2->dwcbHighLength)
                {
                    if (pcfs1->dwcbLowLength == pcfs2->dwcbLowLength)
                        nResult = CR_EQUAL;
                    else if (pcfs1->dwcbLowLength < pcfs2->dwcbLowLength)
                        nResult = CR_FIRST_SMALLER;
                    else
                        nResult = CR_FIRST_LARGER;
                }
                else if (pcfs1->dwcbHighLength < pcfs2->dwcbHighLength)
                    nResult = CR_FIRST_SMALLER;
                else
                    nResult = CR_FIRST_LARGER;
            }
            else if (pcfs1->ftMod.dwLowDateTime < pcfs2->ftMod.dwLowDateTime)
                nResult = CR_FIRST_SMALLER;
            else
                nResult = CR_FIRST_LARGER;
        }
        else if (pcfs1->ftMod.dwHighDateTime < pcfs2->ftMod.dwHighDateTime)
            nResult = CR_FIRST_SMALLER;
        else
            nResult = CR_FIRST_LARGER;
    }

    return(MapIntToComparisonResult(nResult));
}


/***************************** Exported Functions ****************************/

/* RAIDRAID: (16205) AutoDoc RECSTATUSPROC messages below. */

/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | ReconcileItem | Reconciles a reconciliation item created by
  CreateRecList().

  @parm PCRECITEM | pcri | A pointer to a reconciliation item to be reconciled.

  @parm RECSTATUSPROC | rsp | A procedure instance address of a callback function
  to be called with status information during the reconciliation of the given
  RECITEM.  rsp may be NULL to indicate that no reconciliation status callback
  function is to be called.  (See the reconciliation handler SPI documentation
  for details.)

  @parm LPARAM | lpCallbackData | Callback data to be supplied to the
  reconciliation status callback function.  If rsp is NULL, lpCallbackData is
  ignored.

  @parm DWORD | dwFlags | A bit mask of flags.  This parameter may be any
  combination of the following values:
  RI_FL_ALLOW_UI - Allow interaction with the user during reconciliation.
  RI_FL_FEEDBACK_WINDOW_VALID - hwndProgressFeedback is valid, and may be used
  to communicate reconciliation progress information to the user during
  reconciliation.

  @parm HWND | hwndOwner | A handle to the parent window to be used when
  requesting user interaction.  This parameter is ignored if the RI_FL_ALLOW_UI
  flag is clear.

  @parm HWND | hwndProgressFeedback | A handle to the window to be used to
  provide progress information to the user during reconciliation.  This parameter
  is ignored if the RI_FL_FEEDBACK_WINDOW_VALID flag is clear.

  @rdesc If the reconciliation item was reconciled successfully, TR_SUCCESS is
  returned.  Otherwise, the reconciliation item was not reconciled successfully,
  and the return value indicates the error that occurred.

  @comm All the fields in the given RECITEM and its child structures are left
  unchanged by ReconcileItem(), except for the fsCurrent fields of RECNODEs
  associated with objects that are overwritten during reconciliation.  The
  fsCurrent field of each RECNODE associated with an object that is overwritten
  during reconciliation (i.e., RECNODEs with rnaction set to RNA_COPY_TO_ME or
  RNA_MERGE_ME) is updated to reflect the current time stamp of the object after
  it is overwritten.  If ReconcileItem() returns TR_SUCCESS, all the available
  RECNODEs (i.e., all RECNODEs whose uState field is not RNS_UNAVAILABLE) in the
  RECITEM may be assumed to be up-to-date.  If ReconcileItem() does not return
  TR_SUCCESS, no assumption may be made about the states of the RECNODEs in the
  RECITEM.  If ReconcileItem() is called on a RECITEM that references a twin
  family that has been deleted or one or more object twins that have been
  deleted, TR_DELETED_TWIN is returned.  In this case, no assumption may be made
  about what reconciliation actions have been carried out on the RECITEM.  If
  TR_DELETED_TWIN is returned, the client may attempt to create a RECLIST for the
  twin family associated with the RECITEM in order to retry the reconciliation
  operation.  (The client would call MarkTwin(), followed by CreateRecList().) If
  TR_DELETED_TWIN is returned by MarkTwin(), the entire twin family has been
  deleted.  If TR_SUCCESS is returned by MarkTwin(), the client should be able to
  call CreateRecList() to create a RECLIST containing a more up-to-date RECITEM
  for the twin family.

  @xref CreateRecList

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI ReconcileItem(PCRECITEM pcri, RECSTATUSPROC rsp,
        LPARAM lpCallbackData,
        DWORD dwFlags, HWND hwndOwner,
        HWND hwndProgressFeedback)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(ReconcileItem);

#ifdef EXPV
        /* Verify parameters. */

        /* lpCallbackData may be any value. */

        if (IS_VALID_STRUCT_PTR(pcri, CRECITEM) &&
                (! rsp ||
                 IS_VALID_CODE_PTR(rsp, RECSTATUSPROC)) &&
                FLAGS_ARE_VALID(dwFlags, ALL_RI_FLAGS) &&
                (IS_FLAG_CLEAR(dwFlags, RI_FL_ALLOW_UI) ||
                 IS_VALID_HANDLE(hwndOwner, WND)) &&
                (IS_FLAG_CLEAR(dwFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
                 IS_VALID_HANDLE(hwndProgressFeedback, WND)))
#endif
        {
            /* Check for any deleted twins referenced by this RECITEM. */

            if (! DeletedTwinsInRecItem(pcri))
            {
                InvalidatePathListInfo(GetBriefcasePathList(((PCTWINFAMILY)(pcri->hTwinFamily))->hbr));

                tr = MyReconcileItem(pcri, rsp, lpCallbackData, dwFlags,
                        hwndOwner, hwndProgressFeedback);

                ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
            }
            else
                tr = TR_DELETED_TWIN;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(ReconcileItem, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | BeginReconciliation | Indicates to the synchronization engine
  that the caller is about to make multiple calls to ReconcileItem().

  @parm HBRFCASE | hbr | A handle to the open briefcase about to be reconciled.

  @rdesc If reconciliation for the given briefcase was initialized successfully,
  TR_SUCCESS is returned.  Otherwise, reconciliation for the given briefcase was
  not initialized successfully, and the return value indicates the error that
  occurred.

  @comm Synchronization engine clients need not call BeginReconciliation() before
  calling ReconcileItem().  BeginReconciliation() is simply provided to allow
  synchronization engine clients to give the synchronization engine a hint that
  multiple calls to ReconcileItem() are about to occur.  Each call to
  EndReconciliation() should be followed by a call to EndReconciliation().

  @xref EndReconciliation ReconcileItem

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI BeginReconciliation(HBRFCASE hbr)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(BeginReconciliation);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hbr, BRFCASE))
#endif
        {
            BeginCopy();
            BeginMerge();

            tr = TR_SUCCESS;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(BeginReconciliation, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | EndReconciliation | Indicates to the synchronization engine
  that the client has finished making multiple calls to ReconcileItem(),
  preceded by a call to BeginReconciliation().

  @parm HBRFCASE | hbr | A handle to the open briefcase whose reconciliation has
  been completed.

  @rdesc If reconciliation for the given briefcase was terminaterd successfully,
  TR_SUCCESS is returned.  Otherwise, reconciliation for the given briefcase was
  not terminated successfully, and the return value indicates the error that
  occurred.

  @comm EndReconciliation() should only be called after a call to
  BeginReconciliation().  Each call to BeginReconciliation() should be followed
  by a matching call to EndReconciliation().

  @xref BeginReconciliation ReconcileItem

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI EndReconciliation(HBRFCASE hbr)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(EndReconciliation);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hbr, BRFCASE))
#endif
        {
            EndMerge();
            EndCopy();

            tr = TR_SUCCESS;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(EndReconciliation, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | GetFileStamp | Retrieves the file stamp for an open file.

  @parm PCSTR | pcszFile | A pointer to a string indicating the file whose file
  stamp is to be retrieved.

  @parm PFILESTAMP | pcr | A pointer to a FILESTAMP to be filled in with the
  file stamp of the given open file.

  @rdesc If the comparison was successful, TR_SUCCESS is returned.  Otherwise,
  the comparison was not successful, and the return value indicates the error
  that occurred.

  @xref CompareFileStamps

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI GetFileStamp(LPCTSTR pcszFile, PFILESTAMP pfs)
{
    TWINRESULT tr;

    /* No need for exclusive access here. */

    DebugEntry(GetFileStamp);

#ifdef EXPV
    /* Verify parameters. */

    if (IS_VALID_STRING_PTR(pcszFile, CSTR) &&
            IS_VALID_WRITE_PTR(pfs, FILESTAMP))
#endif
    {
        MyGetFileStamp(pcszFile, pfs);

        tr = TR_SUCCESS;
    }
#ifdef EXPV
    else
        tr = TR_INVALID_PARAMETER;
#endif

    DebugExitTWINRESULT(GetFileStamp, tr);

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api COMPARISONRESULT | CompareFileStamps | Compares two file stamps.

  @parm PCFILESTAMP | pcfs1 | A pointer to the first FILESTAMP to be compared.

  @parm PCFILESTAMP | pcfs2 | A pointer to the second FILESTAMP to be compared.

  @parm PCOMPARISONRESULT | pcr | A pointer to a COMPARISONRESULT to be filled in
  with the result of the file stamp comparison.  *pcr is only valid if TR_SUCCESS
  is returned.

  @rdesc If the file stamp was retrieved successfully, TR_SUCCESS is returned.
  Otherwise, the file stamp was not retrieved successfully, and the return value
  indicates the error that occurred.

  @comm File stamps are compared by fields as follows:
  1) condition
  Any FS_COND_UNAVAILABLE equals any FS_COND_UNAVAILABLE.
  Any FS_COND_UNAVAILABLE is less than any FS_COND_DOES_NOT_EXIST.
  Any FS_COND_DOES_NOT_EXIST equals any FS_COND_DOES_NOT_EXIST.
  Any FS_COND_DOES_NOT_EXIST is less than any FS_COND_EXISTS.
  Two FS_COND_EXISTS are compared by date and time.
  2) date and time of last modification
  3) length

  @xref GetFileStamp

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI CompareFileStamps(PCFILESTAMP pcfs1,
        PCFILESTAMP pcfs2,
        PCOMPARISONRESULT pcr)
{
    TWINRESULT tr;

    /* No need for exclusive access here. */

    DebugEntry(CompareFileStamps);

#ifdef EXPV
    /* Verify parameters. */

    if (IS_VALID_STRUCT_PTR(pcfs1, CFILESTAMP) &&
            IS_VALID_STRUCT_PTR(pcfs2, CFILESTAMP) &&
            IS_VALID_WRITE_PTR(pcr, COMPARISONRESULT))
#endif
    {
        *pcr = MyCompareFileStamps(pcfs1, pcfs2);
        tr = TR_SUCCESS;
    }
#ifdef EXPV
    else
        tr = TR_INVALID_PARAMETER;
#endif

    DebugExitTWINRESULT(CompareFileStamps, tr);

    return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\resstr.h ===
/*
 * resstr.h - Common return code to string translation routines description.
 */


/* Prototypes
 *************/

/* resstr.c */

#ifdef DEBUG

extern LPCTSTR GetINTString(int);
extern LPCTSTR GetULONGString(ULONG);
extern LPCTSTR GetBOOLString(BOOL);
extern LPCTSTR GetCOMPARISONRESULTString(COMPARISONRESULT);

#ifdef INC_OLE2

extern LPCTSTR GetHRESULTString(HRESULT);

#endif   /* INC_OLE2 */

#ifdef __SYNCENG_H__

extern LPCTSTR GetTWINRESULTString(TWINRESULT);
extern LPCTSTR GetCREATERECLISTPROCMSGString(UINT);
extern LPCTSTR GetRECSTATUSPROCMSGString(UINT);
extern LPCTSTR GetRECNODESTATEString(RECNODESTATE);
extern LPCTSTR GetRECNODEACTIONString(RECNODEACTION);

#endif   /* __SYNCENG_H__ */

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\ptrarray.c ===
/*
 * ptrarray.c - Pointer array ADT module.
 */

/*

   Pointer array structures are allocated by AllocateMemory().  Handles to
pointer arrays are pointers to ARRAYs.  Each ARRAY contains a pointer to an
rray of pointers in the pointer array.  Each array of pointers is allocated by
GlobalAlloc() to allow it to grow to greater than 64 Kb in size.  Pointer
arrays are 0-based.  Array elements are accessed using pointers.  If this
proves to be too slow, we'll go to pointers with a 64 Kb limit on total array
size.

   Pointer arrays are created with pointer comparison functions for sorting and
searching.  The sorting comparison function is used to insert new pointers into
the pointer array in sorted order.  The searching comparison function is used
to search the sorted pointer array for a pointer.  The sorting comparison
function is passed the pointer to be added to the pointer array and a pointer
from the pointer array for comparison.  The searching comparison function is
passed a pointer to the information being searched for and a pointer from the
pointer array for comparison.

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Macros
 *********/

/* extract array element */

#define ARRAY_ELEMENT(ppa, ai)            (((ppa)->ppcvArray)[(ai)])

/* Add pointers to array in sorted order? */

#define ADD_PTRS_IN_SORTED_ORDER(ppa)     IS_FLAG_SET((ppa)->dwFlags, PA_FL_SORTED_ADD)


/* Types
 ********/

/* pointer array flags */

typedef enum _ptrarrayflags
{
   /* Insert elements in sorted order. */

   PA_FL_SORTED_ADD        = 0x0001,

   /* flag combinations */

   ALL_PA_FLAGS            = PA_FL_SORTED_ADD
}
PTRARRAYFLAGS;

/* pointer array structure */

/*
 * Free elements in the ppcvArray[] array lie between indexes (aicPtrsUsed)
 * and (aiLast), inclusive.
 */

typedef struct _ptrarray
{
   /* elements to grow array by after it fills up */

   ARRAYINDEX aicPtrsToGrowBy;

   /* array flags */

   DWORD dwFlags;

   /* pointer to base of array */

   PCVOID *ppcvArray;

   /* index of last element allocated in array */

   ARRAYINDEX aicPtrsAllocated;

   /*
    * (We keep a count of the number of elements used instead of the index of
    * the last element used so that this value is 0 for an empty array, and not
    * some non-zero sentinel value.)
    */

   /* number of elements used in array */

   ARRAYINDEX aicPtrsUsed;
}
PTRARRAY;
DECLARE_STANDARD_TYPES(PTRARRAY);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL AddAFreePtrToEnd(PPTRARRAY);
PRIVATE_CODE void PtrHeapSwap(PPTRARRAY, ARRAYINDEX, ARRAYINDEX);
PRIVATE_CODE void PtrHeapSift(PPTRARRAY, ARRAYINDEX, ARRAYINDEX, COMPARESORTEDPTRSPROC);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCNEWPTRARRAY(PCNEWPTRARRAY);
PRIVATE_CODE BOOL IsValidPCPTRARRAY(PCPTRARRAY);

#endif

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL IsPtrArrayInSortedOrder(PCPTRARRAY, COMPARESORTEDPTRSPROC);

#endif


/*
** AddAFreePtrToEnd()
**
** Adds a free element to the end of an array.
**
** Arguments:     pa - pointer to array
**
** Returns:       TRUE if successful, or FALSE if not.
**
** Side Effects:  May grow the array.
*/
PRIVATE_CODE BOOL AddAFreePtrToEnd(PPTRARRAY pa)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pa, CPTRARRAY));

   /* Are there any free elements in the array? */

   if (pa->aicPtrsUsed < pa->aicPtrsAllocated)
      /* Yes.  Return the next free pointer. */
      bResult = TRUE;
   else
   {
      ARRAYINDEX aicNewPtrs = pa->aicPtrsAllocated + pa->aicPtrsToGrowBy;
      PCVOID *ppcvArray;

      bResult = FALSE;

      /* Try to grow the array. */

      /* Blow off unlikely overflow conditions as ASSERT()s. */

      ASSERT(pa->aicPtrsAllocated <= ARRAYINDEX_MAX + 1);
      ASSERT(ARRAYINDEX_MAX + 1 - pa->aicPtrsToGrowBy >= pa->aicPtrsAllocated);
#ifdef DBLCHECK
      ASSERT((double)aicNewPtrs * (double)(sizeof(PVOID)) <= (double)DWORD_MAX);
#endif

      /* Try to grow the array. */

      if (ReallocateMemory((PVOID)(pa->ppcvArray), aicNewPtrs * sizeof(*ppcvArray), (PVOID *)(&ppcvArray)))
      {
         /*
          * Array reallocated successfully.  Set up PTRARRAY fields, and return
          * the first free index.
          */

         pa->ppcvArray = ppcvArray;
         pa->aicPtrsAllocated = aicNewPtrs;

         bResult = TRUE;
      }
   }

   return(bResult);
}


/*
** PtrHeapSwap()
**
** Swaps two elements in an array.
**
** Arguments:     pa - pointer to array
**                aiFirst - index of first element
**                aiSecond - index of second element
**
** Returns:       void
**
** Side Effects:  none
*/
PRIVATE_CODE void PtrHeapSwap(PPTRARRAY pa, ARRAYINDEX ai1, ARRAYINDEX ai2)
{
   PCVOID pcvTemp;

   ASSERT(IS_VALID_STRUCT_PTR(pa, CPTRARRAY));
   ASSERT(ai1 >= 0);
   ASSERT(ai1 < pa->aicPtrsUsed);
   ASSERT(ai2 >= 0);
   ASSERT(ai2 < pa->aicPtrsUsed);

   pcvTemp = ARRAY_ELEMENT(pa, ai1);
   ARRAY_ELEMENT(pa, ai1) = ARRAY_ELEMENT(pa, ai2);
   ARRAY_ELEMENT(pa, ai2) = pcvTemp;

   return;
}


/*
** PtrHeapSift()
**
** Sifts an element down in an array until the partially ordered tree property
** is retored.
**
** Arguments:     pa - pointer to array
**                aiFirst - index of element to sift down
**                aiLast - index of last element in subtree
**                cspp - element comparison callback function to be called to
**                      compare elements
**
** Returns:       void
**
** Side Effects:  none
*/
PRIVATE_CODE void PtrHeapSift(PPTRARRAY pa, ARRAYINDEX aiFirst, ARRAYINDEX aiLast,
                         COMPARESORTEDPTRSPROC cspp)
{
   ARRAYINDEX ai;
   PCVOID pcvTemp;

   ASSERT(IS_VALID_STRUCT_PTR(pa, CPTRARRAY));
   ASSERT(IS_VALID_CODE_PTR(cspp, COMPARESORTEDPTRSPROC));

   ASSERT(aiFirst >= 0);
   ASSERT(aiFirst < pa->aicPtrsUsed);
   ASSERT(aiLast >= 0);
   ASSERT(aiLast < pa->aicPtrsUsed);

   ai = aiFirst * 2;

   pcvTemp = ARRAY_ELEMENT(pa, aiFirst);

   while (ai <= aiLast)
   {
      if (ai < aiLast &&
          (*cspp)(ARRAY_ELEMENT(pa, ai), ARRAY_ELEMENT(pa, ai + 1)) == CR_FIRST_SMALLER)
         ai++;

      if ((*cspp)(pcvTemp, ARRAY_ELEMENT(pa, ai)) != CR_FIRST_SMALLER)
         break;

      ARRAY_ELEMENT(pa, aiFirst) = ARRAY_ELEMENT(pa, ai);

      aiFirst = ai;

      ai *= 2;
   }

   ARRAY_ELEMENT(pa, aiFirst) = pcvTemp;

   return;
}


#ifdef VSTF

/*
** IsValidPCNEWPTRARRAY()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCNEWPTRARRAY(PCNEWPTRARRAY pcnpa)
{
   BOOL bResult;

   /*
    * Given the current value of ARRAYINDEX_MAX (ULONG_MAX - 1), we don't
    * really need a check like:
    *
    *    (pcna->aicInitialPtrs - 1 <= ARRAYINDEX_MAX)
    *
    * since the maximum value of the aicInitialPtrs field (ULONG_MAX) still
    * yields a valid top index:
    *
    *    (ULONG_MAX) - 1 == (ULONG_MAX - 1)
    *
    *    ARRAYINDEX_MAX == (ULONG_MAX - 1)
    *
    * But we'll leave the clause here anyway in case things change.
    */

   if (IS_VALID_READ_PTR(pcnpa, CNEWPTRARRAY) &&
       EVAL(pcnpa->aicInitialPtrs >= 0) &&
       EVAL(pcnpa->aicInitialPtrs < ARRAYINDEX_MAX) &&
       EVAL(pcnpa->aicAllocGranularity > 0) &&
       FLAGS_ARE_VALID(pcnpa->dwFlags, ALL_NPA_FLAGS))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}


/*
** IsValidPCPTRARRAY()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCPTRARRAY(PCPTRARRAY pcpa)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pcpa, CPTRARRAY) &&
       EVAL(pcpa->aicPtrsToGrowBy > 0) &&
       FLAGS_ARE_VALID(pcpa->dwFlags, ALL_PA_FLAGS) &&
       EVAL(pcpa->aicPtrsAllocated >= 0) &&
       IS_VALID_READ_BUFFER_PTR(pcpa->ppcvArray, PCVOID, (pcpa->aicPtrsAllocated) * sizeof(*(pcpa->ppcvArray))) &&
       (EVAL(pcpa->aicPtrsUsed >= 0) &&
        EVAL(pcpa->aicPtrsUsed <= pcpa->aicPtrsAllocated)))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}

#endif


#if defined(DEBUG) || defined(VSTF)

/*
** IsPtrArrayInSortedOrder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsPtrArrayInSortedOrder(PCPTRARRAY pcpa,
                                          COMPARESORTEDPTRSPROC cspp)
{
   BOOL bResult = TRUE;

   /* Don't validate pcpa here. */

   ASSERT(IS_VALID_CODE_PTR(cspp, COMPARESORTEDPTRSPROC));

   if (pcpa->aicPtrsUsed > 1)
   {
      ARRAYINDEX ai;

      for (ai = 0; ai < pcpa->aicPtrsUsed - 1; ai++)
      {
         if ((*cspp)(ARRAY_ELEMENT(pcpa, ai), ARRAY_ELEMENT(pcpa, ai + 1))
             == CR_FIRST_LARGER)
         {
            bResult = FALSE;
            ERROR_OUT((TEXT("IsPtrArrayInSortedOrder(): Element [%ld] %#lx > following element [%ld] %#lx."),
                       ai,
                       ARRAY_ELEMENT(pcpa, ai),
                       ai + 1,
                       ARRAY_ELEMENT(pcpa, ai + 1)));
            break;
         }
      }
   }

   return(bResult);
}

#endif


/****************************** Public Functions *****************************/


/*
** CreatePtrArray()
**
** Creates a pointer array.
**
** Arguments:     pcna - pointer to NEWPTRARRAY describing the array to be
**                        created
**
** Returns:       Handle to the new array if successful, or NULL if
**                unsuccessful.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreatePtrArray(PCNEWPTRARRAY pcna, PHPTRARRAY phpa)
{
   PCVOID *ppcvArray;

   ASSERT(IS_VALID_STRUCT_PTR(pcna, CNEWPTRARRAY));
   ASSERT(IS_VALID_WRITE_PTR(phpa, HPTRARRAY));

   /* Try to allocate the initial array. */

   *phpa = NULL;

   if (AllocateMemory(pcna->aicInitialPtrs * sizeof(*ppcvArray), (PVOID *)(&ppcvArray)))
   {
      PPTRARRAY pa;

      /* Try to allocate PTRARRAY structure. */

      if (AllocateMemory(sizeof(*pa), &pa))
      {
         /* Initialize PTRARRAY fields. */

         pa->aicPtrsToGrowBy = pcna->aicAllocGranularity;
         pa->ppcvArray = ppcvArray;
         pa->aicPtrsAllocated = pcna->aicInitialPtrs;
         pa->aicPtrsUsed = 0;

         /* Set flags. */

         if (IS_FLAG_SET(pcna->dwFlags, NPA_FL_SORTED_ADD))
            pa->dwFlags = PA_FL_SORTED_ADD;
         else
            pa->dwFlags = 0;

         *phpa = (HPTRARRAY)pa;

         ASSERT(IS_VALID_HANDLE(*phpa, PTRARRAY));
      }
      else
         /* Unlock and free array (ignoring return values). */
         FreeMemory((PVOID)(ppcvArray));
   }

   return(*phpa != NULL);
}


/*
** DestroyPtrArray()
**
** Destroys an array.
**
** Arguments:     hpa - handle to array to be destroyed
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyPtrArray(HPTRARRAY hpa)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   /* Free the array. */

   ASSERT(((PCPTRARRAY)hpa)->ppcvArray);

   FreeMemory((PVOID)(((PCPTRARRAY)hpa)->ppcvArray));

   /* Free PTRARRAY structure. */

   FreeMemory((PPTRARRAY)hpa);

   return;
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** InsertPtr()
**
** Adds an element to an array at a given index.
**
** Arguments:     hpa - handle to array that element is to be added to
**                aiInsert - index where new element is to be inserted
**                pcvNew - pointer to element to add to array
**
** Returns:       TRUE if the element was inserted successfully, or FALSE if
**                not.
**
** Side Effects:  The array may be grown.
**
** N.b., for an array marked PA_FL_SORTED_ADD, this index should only be
** retrieved using SearchSortedArray(), or the sorted order will be destroyed.
*/
PUBLIC_CODE BOOL InsertPtr(HPTRARRAY hpa, COMPARESORTEDPTRSPROC cspp, ARRAYINDEX aiInsert, PCVOID pcvNew)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(aiInsert >= 0);
   ASSERT(aiInsert <= ((PCPTRARRAY)hpa)->aicPtrsUsed);

#ifdef DEBUG

   /* Make sure the correct index was given for insertion. */

   if (ADD_PTRS_IN_SORTED_ORDER((PCPTRARRAY)hpa))
   {
      ARRAYINDEX aiNew;

      EVAL(! SearchSortedArray(hpa, cspp, pcvNew, &aiNew));

      ASSERT(aiInsert == aiNew);
   }

#endif

   /* Get a free element in the array. */

   bResult = AddAFreePtrToEnd((PPTRARRAY)hpa);

   if (bResult)
   {
      ASSERT(((PCPTRARRAY)hpa)->aicPtrsUsed < ARRAYINDEX_MAX);

      /* Open a slot for the new element. */

      MoveMemory((PVOID)& ARRAY_ELEMENT((PPTRARRAY)hpa, aiInsert + 1),
                 & ARRAY_ELEMENT((PPTRARRAY)hpa, aiInsert),
                 (((PCPTRARRAY)hpa)->aicPtrsUsed - aiInsert) * sizeof(ARRAY_ELEMENT((PCPTRARRAY)hpa, 0)));

      /* Put the new element in the open slot. */

      ARRAY_ELEMENT((PPTRARRAY)hpa, aiInsert) = pcvNew;

      ((PPTRARRAY)hpa)->aicPtrsUsed++;
   }

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** AddPtr()
**
** Adds an element to an array, in sorted order if so specified at
** CreatePtrArray() time.
**
** Arguments:     hpa - handle to array that element is to be added to
**                pcvNew - pointer to element to be added to array
**                pai - pointer to ARRAYINDEX to be filled in with index of
**                      new element, may be NULL
**
** Returns:       TWINRESULT
**
** Side Effects:  The array may be grown.
*/
PUBLIC_CODE BOOL AddPtr(HPTRARRAY hpa, COMPARESORTEDPTRSPROC cspp, PCVOID pcvNew, PARRAYINDEX pai)
{
   BOOL bResult;
   ARRAYINDEX aiNew;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(! pai || IS_VALID_WRITE_PTR(pai, ARRAYINDEX));

   /* Find out where the new element should go. */

   if (ADD_PTRS_IN_SORTED_ORDER((PCPTRARRAY)hpa))
      EVAL(! SearchSortedArray(hpa, cspp, pcvNew, &aiNew));
   else
      aiNew = ((PCPTRARRAY)hpa)->aicPtrsUsed;

   bResult = InsertPtr(hpa, cspp, aiNew, pcvNew);

   if (bResult && pai)
      *pai = aiNew;

   return(bResult);
}


/*
** DeletePtr()
**
** Removes an element from an element array.
**
** Arguments:     ha - handle to array
**                aiDelete - index of element to be deleted
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE void DeletePtr(HPTRARRAY hpa, ARRAYINDEX aiDelete)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(aiDelete >= 0);
   ASSERT(aiDelete < ((PCPTRARRAY)hpa)->aicPtrsUsed);

   /*
    * Compact the element array by moving down all elements past the one being
    * deleted.
    */

   MoveMemory((PVOID)& ARRAY_ELEMENT((PPTRARRAY)hpa, aiDelete),
              & ARRAY_ELEMENT((PPTRARRAY)hpa, aiDelete + 1),
              (((PCPTRARRAY)hpa)->aicPtrsUsed - aiDelete - 1) * sizeof(ARRAY_ELEMENT((PCPTRARRAY)hpa, 0)));

   /* One less element used. */

   ((PPTRARRAY)hpa)->aicPtrsUsed--;

   return;
}


/*
** DeleteAllPtrs()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DeleteAllPtrs(HPTRARRAY hpa)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   ((PPTRARRAY)hpa)->aicPtrsUsed = 0;

   return;
}


/*
** GetPtrCount()
**
** Retrieves the number of elements in an element array.
**
** Arguments:     hpa - handle to array
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE ARRAYINDEX GetPtrCount(HPTRARRAY hpa)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   return(((PCPTRARRAY)hpa)->aicPtrsUsed);
}


/*
** GetPtr()
**
** Retrieves an element from an array.
**
** Arguments:     hpa - handle to array
**                ai - index of element to be retrieved
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE PVOID GetPtr(HPTRARRAY hpa, ARRAYINDEX ai)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(ai >= 0);
   ASSERT(ai < ((PCPTRARRAY)hpa)->aicPtrsUsed);

   return((PVOID)ARRAY_ELEMENT((PCPTRARRAY)hpa, ai));
}


/*
** SortPtrArray()
**
** Sorts an array.
**
** Arguments:     hpa - handle to element list to be sorted
**                cspp - pointer comparison callback function
**
** Returns:       void
**
** Side Effects:  none
**
** Uses heap sort.
*/
PUBLIC_CODE void SortPtrArray(HPTRARRAY hpa, COMPARESORTEDPTRSPROC cspp)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   /* Are there any elements to sort (2 or more)? */

   if (((PCPTRARRAY)hpa)->aicPtrsUsed > 1)
   {
      ARRAYINDEX ai;
      ARRAYINDEX aiLastUsed = ((PCPTRARRAY)hpa)->aicPtrsUsed - 1;

      /* Yes.  Create partially ordered tree. */

      for (ai = aiLastUsed / 2; ai >= 0; ai--)
         PtrHeapSift((PPTRARRAY)hpa, ai, aiLastUsed, cspp);

      for (ai = aiLastUsed; ai >= 1; ai--)
      {
         /* Remove minimum from front of heap. */

         PtrHeapSwap((PPTRARRAY)hpa, 0, ai);

         /* Reestablish partially ordered tree. */

         PtrHeapSift((PPTRARRAY)hpa, 0, ai - 1, cspp);
      }
   }

   ASSERT(IsPtrArrayInSortedOrder((PCPTRARRAY)hpa, cspp));

   return;
}


/*
** SearchSortedArray()
**
** Searches an array for a target element using binary search.  If several
** adjacent elements match the target element, the index of the first matching
** element is returned.
**
** Arguments:     hpa - handle to array to be searched
**                cspp - element comparison callback function to be called to
**                      compare the target element with an element from the
**                      array, the callback function is called as:
**
**                         (*cspp)(pcvTarget, pcvPtrFromList)
**
**                pcvTarget - pointer to target element to search for
**                pbFound - pointer to BOOL to be filled in with TRUE if the
**                          target element is found, or FALSE if not
**                paiTarget - pointer to ARRAYINDEX to be filled in with the
**                            index of the first element matching the target
**                            element if found, otherwise filled in with the
**                            index where the target element should be
**                            inserted
**
** Returns:       TRUE if target element is found.  FALSE if not.
**
** Side Effects:  none
**
** We use a private version of SearchSortedArray() instead of the CRT bsearch()
** function since we want it to return the insertion index of the target
** element if the target element is not found.
*/
PUBLIC_CODE BOOL SearchSortedArray(HPTRARRAY hpa, COMPARESORTEDPTRSPROC cspp,
                                   PCVOID pcvTarget, PARRAYINDEX paiTarget)
{
   BOOL bFound;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(IS_VALID_CODE_PTR(cspp, COMPARESORTEDPTRSPROC));
   ASSERT(IS_VALID_WRITE_PTR(paiTarget, ARRAYINDEX));

   ASSERT(ADD_PTRS_IN_SORTED_ORDER((PCPTRARRAY)hpa));
#if 0
   ASSERT(IsPtrArrayInSortedOrder((PCPTRARRAY)hpa, ((PCPTRARRAY)hpa)->cspp));
#endif

   bFound = FALSE;

   /* Are there any elements to search through? */

   if (((PCPTRARRAY)hpa)->aicPtrsUsed > 0)
   {
      ARRAYINDEX aiLow = 0;
      ARRAYINDEX aiMiddle = 0;
      ARRAYINDEX aiHigh = ((PCPTRARRAY)hpa)->aicPtrsUsed - 1;
      COMPARISONRESULT cr = CR_EQUAL;

      /* Yes.  Search for the target element. */

      /*
       * At the end of the penultimate iteration of this loop:
       *
       * aiLow == aiMiddle == aiHigh.
       */

      ASSERT(aiHigh <= ARRAYINDEX_MAX);

      while (aiLow <= aiHigh)
      {
         aiMiddle = (aiLow + aiHigh) / 2;

         cr = (*cspp)(pcvTarget, ARRAY_ELEMENT((PCPTRARRAY)hpa, aiMiddle));

         if (cr == CR_FIRST_SMALLER)
            aiHigh = aiMiddle - 1;
         else if (cr == CR_FIRST_LARGER)
            aiLow = aiMiddle + 1;
         else
         {
            /*
             * Found a match at index aiMiddle.  Search back for first match.
             */

            bFound = TRUE;

            while (aiMiddle > 0)
            {
               if ((*cspp)(pcvTarget, ARRAY_ELEMENT((PCPTRARRAY)hpa, aiMiddle - 1)) != CR_EQUAL)
                  break;
               else
                  aiMiddle--;
            }

            break;
         }
      }

      /*
       * Return the index of the target if found, or the index where the target
       * should be inserted if not found.
       */

      /*
       * If (cr == CR_FIRST_LARGER), the insertion index is aiLow.
       *
       * If (cr == CR_FIRST_SMALLER), the insertion index is aiMiddle.
       *
       * If (cr == CR_EQUAL), the insertion index is aiMiddle.
       */

      if (cr == CR_FIRST_LARGER)
         *paiTarget = aiLow;
      else
         *paiTarget = aiMiddle;
   }
   else
      /*
       * No.  The target element cannot be found in an empty array.  It should
       * be inserted as the first element.
       */
      *paiTarget = 0;

   ASSERT(*paiTarget <= ((PCPTRARRAY)hpa)->aicPtrsUsed);

   return(bFound);
}


/*
** LinearSearchArray()
**
** Searches an array for a target element using binary search.  If several
** adjacent elements match the target element, the index of the first matching
** element is returned.
**
** Arguments:     hpa - handle to array to be searched
**                cupp - element comparison callback function to be called to
**                       compare the target element with an element from the
**                       array, the callback function is called as:
**
**                         (*cupp)(pvTarget, pvPtrFromList)
**
**                      the callback function should return a value based upon
**                      the result of the element comparison as follows:
**
**                         FALSE, pvTarget == pvPtrFromList
**                         TRUE,  pvTarget != pvPtrFromList
**
**                pvTarget - far element to target element to search for
**                paiTarget - far element to ARRAYINDEX to be filled in with
**                            the index of the first matching element if
**                            found, otherwise filled in with index where
**                            element should be inserted
**
** Returns:       TRUE if target element is found.  FALSE if not.
**
** Side Effects:  none
**
** We use a private version of LinearSearchForPtr() instead of the CRT _lfind()
** function since we want it to return the insertion index of the target
** element if the target element is not found.
**
** If the target element is not found the insertion index returned is the first
** element after the last used element in the array.
*/
PUBLIC_CODE BOOL LinearSearchArray(HPTRARRAY hpa, COMPAREUNSORTEDPTRSPROC cupp,
                                   PCVOID pcvTarget, PARRAYINDEX paiTarget)
{
   BOOL bFound;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY) &&
          (! cupp || IS_VALID_CODE_PTR(cupp, COMPPTRSPROC)) &&
          IS_VALID_WRITE_PTR(paiTarget, ARRAYINDEX));

   bFound = FALSE;

   for (ai = 0; ai < ((PCPTRARRAY)hpa)->aicPtrsUsed; ai++)
   {
      if (! (*cupp)(pcvTarget, ARRAY_ELEMENT((PCPTRARRAY)hpa, ai)))
      {
         bFound = TRUE;
         break;
      }
   }

   if (bFound)
      *paiTarget = ai;

   return(bFound);
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidHPTRARRAY()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHPTRARRAY(HPTRARRAY hpa)
{
   return(IS_VALID_STRUCT_PTR((PCPTRARRAY)hpa, CPTRARRAY));
}

#endif


#ifdef VSTF

/*
** IsValidHGLOBAL()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHGLOBAL(HGLOBAL hg)
{
   return(EVAL(hg != NULL));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\serial.h ===
/*
 * serial.h - Access serialization routines description.
 */


/* Types
 ********/

typedef struct _serialcontrol
{
   BOOL (*AttachProcess)(HMODULE);
   BOOL (*DetachProcess)(HMODULE);
   BOOL (*AttachThread)(HMODULE);
   BOOL (*DetachThread)(HMODULE);
}
SERIALCONTROL;
DECLARE_STANDARD_TYPES(SERIALCONTROL);

typedef struct _nonreentrantcriticalsection
{
   CRITICAL_SECTION critsec;

#ifdef DEBUG
   DWORD dwOwnerThread;
#endif   /* DEBUG */

   BOOL bEntered;
}
NONREENTRANTCRITICALSECTION;
DECLARE_STANDARD_TYPES(NONREENTRANTCRITICALSECTION);


/* Prototypes
 *************/

/* serial.c */

#ifdef DEBUG

extern BOOL SetSerialModuleIniSwitches(void);

#endif   /* DEBUG */

extern void ReinitializeNonReentrantCriticalSection(PNONREENTRANTCRITICALSECTION);
extern BOOL EnterNonReentrantCriticalSection(PNONREENTRANTCRITICALSECTION);
extern void LeaveNonReentrantCriticalSection(PNONREENTRANTCRITICALSECTION);

#ifdef DEBUG

extern BOOL NonReentrantCriticalSectionIsOwned(PCNONREENTRANTCRITICALSECTION);

#endif

extern BOOL BeginExclusiveAccess(void);
extern void EndExclusiveAccess(void);

#ifdef DEBUG

extern BOOL AccessIsExclusive(void);

#endif   /* DEBUG */

extern HMODULE GetThisModulesHandle(void);

/* functions to be provided by client */

extern BOOL InitializeDLL(void);
extern BOOL TerminateDLL(void);

#ifdef DEBUG

extern BOOL SetAllIniSwitches(void);

#endif


/* Global Variables
 *******************/

/* serialization control structure */

extern CSERIALCONTROL g_cserctrl;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\sortsrch.h ===
/*
 * sortsrch.c - Generic array sorting and searching description.
 */


/* Types
 ********/

/* array element comparison callback function */

typedef COMPARISONRESULT (*COMPARESORTEDELEMSPROC)(PCVOID, PCVOID);


/* Prototypes
 *************/

/* sortsrch.c */

extern void HeapSort(PVOID, LONG, size_t, COMPARESORTEDELEMSPROC, PVOID);
extern BOOL BinarySearch(PVOID, LONG, size_t, COMPARESORTEDELEMSPROC, PCVOID, PLONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\serial.c ===
/*
 * serial.c - Access serialization routines module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "init.h"


/* Types
 ********/

/* process information */

typedef struct _processinfo
{
    HANDLE hModule;
}
PROCESSINFO;
DECLARE_STANDARD_TYPES(PROCESSINFO);

#ifdef DEBUG

/* debug flags */

typedef enum _serialdebugflags
{
    SERIAL_DFL_BREAK_ON_PROCESS_ATTACH  = 0x0001,

    SERIAL_DFL_BREAK_ON_THREAD_ATTACH   = 0x0002,

    ALL_SERIAL_DFLAGS                   = (SERIAL_DFL_BREAK_ON_PROCESS_ATTACH |
            SERIAL_DFL_BREAK_ON_THREAD_ATTACH)
}
SERIALDEBUGFLAGS;

#endif   /* DEBUG */


/* Module Variables
 *******************/

/*
 * RAIDRAID: (16273) The use of Mnrcs in a shared data section is broken under
 * NT.  To run under NT, this code should be changed to use a shared mutex
 * referenced by hMutex in Mpi.
 */

/* critical section used for access serialization */

PRIVATE_DATA NONREENTRANTCRITICALSECTION Mnrcs =
{
    { 0 },

#ifdef DEBUG
    INVALID_THREAD_ID,
#endif   /* DEBUG */

    FALSE
};

/* number of attached processes */

PRIVATE_DATA ULONG MulcProcesses = 0;

/* information about current process */

/*
 * Initialize Mpi so it is actually put in the .instanc section instead of the
 * .bss section.
 */

PRIVATE_DATA PROCESSINFO Mpi =
{
    NULL
};

#ifdef DEBUG

/* debug flags */

PRIVATE_DATA DWORD MdwSerialModuleFlags = 0;

/* .ini file switch descriptions */

PRIVATE_DATA CBOOLINISWITCH cbisBreakOnProcessAttach =
{
    IST_BOOL,
    TEXT( "BreakOnProcessAttach"),
    &MdwSerialModuleFlags,
    SERIAL_DFL_BREAK_ON_PROCESS_ATTACH
};

PRIVATE_DATA CBOOLINISWITCH cbisBreakOnThreadAttach =
{
    IST_BOOL,
    TEXT("BreakOnThreadAttach"),
    &MdwSerialModuleFlags,
    SERIAL_DFL_BREAK_ON_THREAD_ATTACH
};

PRIVATE_DATA const PCVOID MrgcpcvisSerialModule[] =
{
    &cbisBreakOnProcessAttach,
    &cbisBreakOnThreadAttach
};

#endif   /* DEBUG */


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCSERIALCONTROL(PCSERIALCONTROL);
PRIVATE_CODE BOOL IsValidPCPROCESSINFO(PCPROCESSINFO);
PRIVATE_CODE BOOL IsValidPCCRITICAL_SECTION(PCCRITICAL_SECTION);
PRIVATE_CODE BOOL IsValidThreadId(DWORD);
PRIVATE_CODE BOOL IsValidPCNONREENTRANTCRITICALSECTION(PCNONREENTRANTCRITICALSECTION);

#endif


#ifdef DEBUG

/*
 ** IsValidPCSERIALCONTROL()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCSERIALCONTROL(PCSERIALCONTROL pcserctrl)
{
    return(IS_VALID_READ_PTR(pcserctrl, CSERIALCONTROL) &&
            (! pcserctrl->AttachProcess ||
             IS_VALID_CODE_PTR(pcserctrl->AttachProcess, AttachProcess)) &&
            (! pcserctrl->DetachProcess ||
             IS_VALID_CODE_PTR(pcserctrl->DetachProcess, DetachProcess)) &&
            (! pcserctrl->AttachThread ||
             IS_VALID_CODE_PTR(pcserctrl->AttachThread, AttachThread)) &&
            (! pcserctrl->DetachThread||
             IS_VALID_CODE_PTR(pcserctrl->DetachThread, DetachThread)));
}


/*
 ** IsValidPCPROCESSINFO()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCPROCESSINFO(PCPROCESSINFO pcpi)
{
    return(IS_VALID_READ_PTR(pcpi, CPROCESSINFO) &&
            IS_VALID_HANDLE(pcpi->hModule, MODULE));
}


/*
 ** IsValidPCCRITICAL_SECTION()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCCRITICAL_SECTION(PCCRITICAL_SECTION pccritsec)
{
    return(IS_VALID_READ_PTR(pccritsec, CCRITICAL_SECTION));
}


/*
 ** IsValidThreadId()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidThreadId(DWORD dwThreadId)
{
    return(dwThreadId != INVALID_THREAD_ID);
}


/*
 ** IsValidPCNONREENTRANTCRITICALSECTION()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCNONREENTRANTCRITICALSECTION(
        PCNONREENTRANTCRITICALSECTION pcnrcs)
{
    /* bEntered may be any value. */

    return(IS_VALID_READ_PTR(pcnrcs, CNONREENTRANTCRITICALSECTION) &&
            IS_VALID_STRUCT_PTR(&(pcnrcs->critsec), CCRITICAL_SECTION) &&
            EVAL(pcnrcs->dwOwnerThread == INVALID_THREAD_ID ||
                IsValidThreadId(pcnrcs->dwOwnerThread)));
}

#endif


/****************************** Public Functions *****************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

#ifdef DEBUG

/*
 ** SetSerialModuleIniSwitches()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL SetSerialModuleIniSwitches(void)
{
    BOOL bResult;

    bResult = SetIniSwitches(MrgcpcvisSerialModule,
            ARRAY_ELEMENTS(MrgcpcvisSerialModule));

    ASSERT(FLAGS_ARE_VALID(MdwSerialModuleFlags, ALL_SERIAL_DFLAGS));

    return(bResult);
}

#endif


/*
 ** AttachProcess()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL AttachProcess(HMODULE hmod)
{
    BOOL bResult;

    ReinitializeNonReentrantCriticalSection(&Mnrcs);

    bResult = EnterNonReentrantCriticalSection(&Mnrcs);

    if (bResult)
    {

#ifdef DEBUG

        ASSERT(SetAllIniSwitches());

        TRACE_OUT((TEXT("AttachProcess(): Called for module %#lx."),
                    hmod));

        if (IS_FLAG_SET(MdwSerialModuleFlags, SERIAL_DFL_BREAK_ON_PROCESS_ATTACH))
        {
            WARNING_OUT((TEXT("AttachProcess(): Breaking on process attach, as requested.")));
            DebugBreak();
        }

#endif   /* DEBUG */

        Mpi.hModule = hmod;

        ASSERT(MulcProcesses < ULONG_MAX);

        if (! MulcProcesses++)
        {
            TRACE_OUT((TEXT("AttachProcess(): First process attached.  Calling InitializeDLL().")));

            bResult = InitializeDLL();
        }
        else
        {

#ifdef PRIVATE_HEAP

            bResult = TRUE;

#else
            /* 
             * Initialize the per-instance memory manager heap for 
             * subsequent processes.
             */

            bResult = InitMemoryManagerModule();

#endif

        }

        if (bResult)
        {
            ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

            if (g_cserctrl.AttachProcess)
                bResult = g_cserctrl.AttachProcess(hmod);
        }

        TRACE_OUT((TEXT("AttachProcess(): There are now %lu processes attached."),
                    MulcProcesses));

        LeaveNonReentrantCriticalSection(&Mnrcs);
    }

    return(bResult);
}


/*
 ** DetachProcess()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL DetachProcess(HMODULE hmod)
{
    BOOL bResult;

    bResult = EnterNonReentrantCriticalSection(&Mnrcs);

    if (bResult)
    {
        ASSERT(hmod == Mpi.hModule);

        ASSERT(MulcProcesses > 0);

        TRACE_OUT((TEXT("DetachProcess(): Called for module %#lx."),
                    hmod));

        ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

        if (g_cserctrl.DetachProcess)
            bResult = g_cserctrl.DetachProcess(hmod);

        if (--MulcProcesses)
        {
            bResult = TRUE;

#ifndef PRIVATE_HEAP

            /* 
             * Terminate the per-instance memory manager heap.
             */

            ExitMemoryManagerModule();

#endif
        }
        else
        {
            TRACE_OUT((TEXT("DetachProcess(): Last process detached.  Calling TerminateDLL().")));

            bResult = TerminateDLL();
        }

        TRACE_OUT((TEXT("DetachProcess(): There are now %lu processes attached."),
                    MulcProcesses));

        LeaveNonReentrantCriticalSection(&Mnrcs);
    }

    /*
     * TODO: Clean up all this Mnrcs nonsense.  It's all leftover goo
     * from Windows 95 and shared data sections (which we don't ues any
     * more).
     */
    DeleteCriticalSection(&Mnrcs.critsec);

    return(bResult);
}


/*
 ** AttachThread()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL AttachThread(HMODULE hmod)
{
    BOOL bResult;

    bResult = EnterNonReentrantCriticalSection(&Mnrcs);

    if (bResult)
    {

#ifdef DEBUG

        ASSERT(SetAllIniSwitches());

        TRACE_OUT((TEXT("AttachThread() called for module %#lx, thread ID %#lx."),
                    hmod,
                    GetCurrentThreadId()));

        if (IS_FLAG_SET(MdwSerialModuleFlags, SERIAL_DFL_BREAK_ON_THREAD_ATTACH))
        {
            WARNING_OUT((TEXT("AttachThread(): Breaking on thread attach, as requested.")));
            DebugBreak();
        }

#endif

        ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

        if (g_cserctrl.AttachThread)
            bResult = g_cserctrl.AttachThread(hmod);
        else
            bResult = TRUE;

        LeaveNonReentrantCriticalSection(&Mnrcs);
    }

    return(bResult);
}


/*
 ** DetachThread()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL DetachThread(HMODULE hmod)
{
    BOOL bResult;

    bResult = EnterNonReentrantCriticalSection(&Mnrcs);

    if (bResult)
    {
        TRACE_OUT((TEXT("DetachThread() called for module %#lx, thread ID %#lx."),
                    hmod,
                    GetCurrentThreadId()));

        ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

        if (g_cserctrl.DetachThread)
            bResult = g_cserctrl.DetachThread(hmod);
        else
            bResult = TRUE;

        LeaveNonReentrantCriticalSection(&Mnrcs);
    }

    return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
 ** ReinitializeNonReentrantCriticalSection()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void ReinitializeNonReentrantCriticalSection(
        PNONREENTRANTCRITICALSECTION pnrcs)
{
    ASSERT(IS_VALID_STRUCT_PTR(pnrcs, CNONREENTRANTCRITICALSECTION));

    InitializeCriticalSectionAndSpinCount(&(pnrcs->critsec), 0);

    return;
}


/*
 ** EnterNonReentrantCriticalSection()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL EnterNonReentrantCriticalSection(
        PNONREENTRANTCRITICALSECTION pnrcs)
{
    BOOL bEntered;

#ifdef DEBUG

    BOOL bBlocked;

    ASSERT(IS_VALID_STRUCT_PTR(pnrcs, CNONREENTRANTCRITICALSECTION));

    /* Is the critical section already owned by another thread? */

    /* Use pnrcs->bEntered and pnrcs->dwOwnerThread unprotected here. */

    bBlocked = (pnrcs->bEntered &&
            GetCurrentThreadId() != pnrcs->dwOwnerThread);

    if (bBlocked)
        WARNING_OUT((TEXT("EnterNonReentrantCriticalSection(): Blocking thread %lx.  Critical section is already owned by thread %#lx."),
                    GetCurrentThreadId(),
                    pnrcs->dwOwnerThread));

#endif

    EnterCriticalSection(&(pnrcs->critsec));

    bEntered = (! pnrcs->bEntered);

    if (bEntered)
    {
        pnrcs->bEntered = TRUE;

#ifdef DEBUG

        pnrcs->dwOwnerThread = GetCurrentThreadId();

        if (bBlocked)
            WARNING_OUT((TEXT("EnterNonReentrantCriticalSection(): Unblocking thread %lx.  Critical section is now owned by this thread."),
                        pnrcs->dwOwnerThread));
#endif

    }
    else
    {
        LeaveCriticalSection(&(pnrcs->critsec));

        ERROR_OUT((TEXT("EnterNonReentrantCriticalSection(): Thread %#lx attempted to reenter non-reentrant code."),
                    GetCurrentThreadId()));
    }

    return(bEntered);
}


/*
 ** LeaveNonReentrantCriticalSection()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void LeaveNonReentrantCriticalSection(
        PNONREENTRANTCRITICALSECTION pnrcs)
{
    ASSERT(IS_VALID_STRUCT_PTR(pnrcs, CNONREENTRANTCRITICALSECTION));

    if (EVAL(pnrcs->bEntered))
    {
        pnrcs->bEntered = FALSE;
#ifdef DEBUG
        pnrcs->dwOwnerThread = INVALID_THREAD_ID;
#endif

        LeaveCriticalSection(&(pnrcs->critsec));
    }

    return;
}


#ifdef DEBUG

/*
 ** NonReentrantCriticalSectionIsOwned()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL NonReentrantCriticalSectionIsOwned(
        PCNONREENTRANTCRITICALSECTION pcnrcs)
{
    return(pcnrcs->bEntered);
}

#endif


/*
 ** BeginExclusiveAccess()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL BeginExclusiveAccess(void)
{
    return(EnterNonReentrantCriticalSection(&Mnrcs));
}


/*
 ** EndExclusiveAccess()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void EndExclusiveAccess(void)
{
    LeaveNonReentrantCriticalSection(&Mnrcs);

    return;
}


#ifdef DEBUG

/*
 ** AccessIsExclusive()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL AccessIsExclusive(void)
{
    return(NonReentrantCriticalSectionIsOwned(&Mnrcs));
}

#endif   /* DEBUG */


/*
 ** GetThisModulesHandle()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HMODULE GetThisModulesHandle(void)
{
    ASSERT(IS_VALID_STRUCT_PTR((PCPROCESSINFO)&Mpi, CPROCESSINFO));

    return(Mpi.hModule);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\storage.c ===
/*
 * storage.c - Storage ADT module.
 */

/*

   The HSTGIFACE ADT is provided to insulate the caller from the details of
which storage interface is used for serialization, and how it is called.
Storage interfaces are tried in the following order:

1) IPersistFile
2) IPersistStorage

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Constants
 ************/

/* flags specified when opening a storage */

#define STORAGE_OPEN_MODE_FLAGS        (STGM_TRANSACTED |\
                                        STGM_READWRITE |\
                                        STGM_SHARE_EXCLUSIVE)


/* Macros
 *********/

/* access STGIFACE fields */

#define STGI_TYPE(pstgi)               ((pstgi)->stgit)
#define STGI_IPERSISTFILE(pstgi)       ((pstgi)->stgi.pipfile)
#define STGI_ISTORAGE(pstgi)           ((pstgi)->stgi.stg.pistg)
#define STGI_IPERSISTSTORAGE(pstgi)    ((pstgi)->stgi.stg.pipstg)


/* Types
 ********/

/* storage interface types */

typedef enum _storageinterfacetype
{
   STGIT_IPERSISTFILE,

   STGIT_IPERSISTSTORAGE
}
STGIFACETYPE;

/* storage interface structure */

typedef struct _storageinterface
{
   STGIFACETYPE stgit;

   union
   {
      PIPersistFile pipfile;

      struct
      {
         PIStorage pistg;

         PIPersistStorage pipstg;
      } stg;
   } stgi;
}
STGIFACE;
DECLARE_STANDARD_TYPES(STGIFACE);


/* Module Variables
 *******************/

/* memory manager interface */

PRIVATE_DATA PIMalloc Mpimalloc = NULL;


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCSTGIFACE(PCSTGIFACE);

#endif


#ifdef DEBUG

/*
** IsValidPCSTGIFACE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCSTGIFACE(PCSTGIFACE pcstgi)
{
   BOOL bResult = FALSE;

   if (IS_VALID_READ_PTR(pcstgi, CSTGIFACE))
   {
      switch (STGI_TYPE(pcstgi))
      {
         case STGIT_IPERSISTSTORAGE:
            bResult = ((! STGI_ISTORAGE(pcstgi) ||
                        IS_VALID_STRUCT_PTR(STGI_ISTORAGE(pcstgi), CIStorage)) &&
                       IS_VALID_STRUCT_PTR(STGI_IPERSISTSTORAGE(pcstgi), CIPersistStorage));
            break;

         default:
            ASSERT(STGI_TYPE(pcstgi) == STGIT_IPERSISTFILE);
            bResult = IS_VALID_STRUCT_PTR(STGI_IPERSISTFILE(pcstgi), CIPersistFile);
            break;
      }
   }

   return(bResult);
}

#endif


/****************************** Public Functions *****************************/


/*
** ProcessInitStorageModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL ProcessInitStorageModule(void)
{
   return(TRUE);
}


/*
** ProcessExitStorageModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ProcessExitStorageModule(void)
{
   ASSERT(! Mpimalloc ||
          IS_VALID_STRUCT_PTR(Mpimalloc, CIMalloc));

   if (Mpimalloc)
   {
      Mpimalloc->lpVtbl->Release(Mpimalloc);
      Mpimalloc = NULL;

      TRACE_OUT((TEXT("ProcessExitStorageModule(): Released IMalloc.")));
   }

   return;
}


/*
** GetStorageInterface()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT GetStorageInterface(PIUnknown piunk, PHSTGIFACE phstgi)
{
   HRESULT hr;
   PSTGIFACE pstgi;

   ASSERT(IS_VALID_STRUCT_PTR(piunk, CIUnknown));
   ASSERT(IS_VALID_WRITE_PTR(phstgi, HSTGIFACE));

   if (AllocateMemory(sizeof(*pstgi), &pstgi))
   {
      PVOID pvInterface;

      /* Ask for a storage interface. */

      hr = piunk->lpVtbl->QueryInterface(piunk, &IID_IPersistFile,
                                         &pvInterface);

      if (SUCCEEDED(hr))
      {
         /* Use IPersistFile. */

         STGI_TYPE(pstgi) = STGIT_IPERSISTFILE;
         STGI_IPERSISTFILE(pstgi) = pvInterface;
      }
      else
      {
         hr = piunk->lpVtbl->QueryInterface(piunk, &IID_IPersistStorage,
                                            &pvInterface);

         if (SUCCEEDED(hr))
         {
            /* Use IPersistStorage. */

            STGI_TYPE(pstgi) = STGIT_IPERSISTSTORAGE;
            STGI_ISTORAGE(pstgi) = NULL;
            STGI_IPERSISTSTORAGE(pstgi) = pvInterface;
         }
         else
            FreeMemory(pstgi);
      }

      if (SUCCEEDED(hr))
         *phstgi = (HSTGIFACE)pstgi;
   }
   else
      hr = E_OUTOFMEMORY;

   ASSERT(FAILED(hr) ||
          IS_VALID_HANDLE(*phstgi, STGIFACE));

   return(hr);
}


/*
** ReleaseStorageInterface()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ReleaseStorageInterface(HSTGIFACE hstgi)
{
   PCSTGIFACE pcstgi;

   ASSERT(IS_VALID_HANDLE(hstgi, STGIFACE));

   pcstgi = (PCSTGIFACE)hstgi;

   switch (STGI_TYPE(pcstgi))
   {
      case STGIT_IPERSISTSTORAGE:
         STGI_IPERSISTSTORAGE(pcstgi)->lpVtbl->Release(STGI_IPERSISTSTORAGE(pcstgi));
         if (STGI_ISTORAGE(pcstgi))
            STGI_ISTORAGE(pcstgi)->lpVtbl->Release(STGI_ISTORAGE(pcstgi));
         break;

      default:
         ASSERT(STGI_TYPE(pcstgi) == STGIT_IPERSISTFILE);
         STGI_IPERSISTFILE(pcstgi)->lpVtbl->Release(STGI_IPERSISTFILE(pcstgi));
         break;
   }

   FreeMemory(hstgi);

   return;
}


/*
** LoadFromStorage()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT LoadFromStorage(HSTGIFACE hstgi, LPCTSTR pcszPath)
{
   HRESULT hr = S_OK;
   WCHAR rgwchUnicodePath[MAX_PATH_LEN];

   ASSERT(IS_VALID_HANDLE(hstgi, STGIFACE));
   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));

#ifdef UNICODE
   
   // REVIEW useless strcpy

   lstrcpyn(rgwchUnicodePath, pcszPath, ARRAYSIZE(rgwchUnicodePath));
   
#else

   /* Translate ANSI string into Unicode for OLE. */

   if (MultiByteToWideChar(CP_ACP, 0, pcszPath, -1, rgwchUnicodePath,
                           ARRAY_ELEMENTS(rgwchUnicodePath)))
   {
       hr = MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
   }

#endif

   if (S_OK == hr)
   {
      PSTGIFACE pstgi;

      pstgi = (PSTGIFACE)hstgi;

      switch (STGI_TYPE(pstgi))
      {
         case STGIT_IPERSISTSTORAGE:
         {
            PIStorage pistg;

            hr = StgOpenStorage(rgwchUnicodePath, NULL,
                                STORAGE_OPEN_MODE_FLAGS, NULL, 0, &pistg);

            if (SUCCEEDED(hr))
            {
               hr = STGI_IPERSISTSTORAGE(pstgi)->lpVtbl->Load(STGI_IPERSISTSTORAGE(pstgi),
                                                              pistg);

               if (SUCCEEDED(hr))
                  STGI_ISTORAGE(pstgi) = pistg;
               else
                  pistg->lpVtbl->Release(pistg);
            }
            else
               WARNING_OUT((TEXT("LoadFromStorage(): StgOpenStorage() on %s failed, returning %s."),
                            pcszPath,
                            GetHRESULTString(hr)));

            break;
         }

         default:
            ASSERT(STGI_TYPE(pstgi) == STGIT_IPERSISTFILE);
            hr = STGI_IPERSISTFILE(pstgi)->lpVtbl->Load(STGI_IPERSISTFILE(pstgi),
                                                        rgwchUnicodePath,
                                                        STORAGE_OPEN_MODE_FLAGS);
            break;
      }
   }
   
   return(hr);
}


/*
** SaveToStorage()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT SaveToStorage(HSTGIFACE hstgi)
{
   HRESULT hr;
   PCSTGIFACE pcstgi;

   ASSERT(IS_VALID_HANDLE(hstgi, STGIFACE));

   pcstgi = (PCSTGIFACE)hstgi;

   switch (STGI_TYPE(pcstgi))
   {
      case STGIT_IPERSISTSTORAGE:
         hr = STGI_IPERSISTSTORAGE(pcstgi)->lpVtbl->IsDirty(STGI_IPERSISTSTORAGE(pcstgi));
         if (hr == S_OK)
         {
            hr = STGI_IPERSISTSTORAGE(pcstgi)->lpVtbl->Save(STGI_IPERSISTSTORAGE(pcstgi),
                                                            STGI_ISTORAGE(pcstgi),
                                                            TRUE);

            if (SUCCEEDED(hr))
            {
               HRESULT hrNext;

               HandsOffStorage((HSTGIFACE)pcstgi);

               hr = STGI_ISTORAGE(pcstgi)->lpVtbl->Commit(STGI_ISTORAGE(pcstgi),
                                                          STGC_DEFAULT);

               hrNext = STGI_IPERSISTSTORAGE(pcstgi)->lpVtbl->SaveCompleted(STGI_IPERSISTSTORAGE(pcstgi),
                                                                            NULL);

               if (SUCCEEDED(hr))
                  hr = hrNext;
            }
         }
         break;

      default:
         ASSERT(STGI_TYPE(pcstgi) == STGIT_IPERSISTFILE);
         hr = STGI_IPERSISTFILE(pcstgi)->lpVtbl->IsDirty(STGI_IPERSISTFILE(pcstgi));
         if (hr == S_OK)
         {
            LPOLESTR posPath;

            hr = STGI_IPERSISTFILE(pcstgi)->lpVtbl->GetCurFile(STGI_IPERSISTFILE(pcstgi),
                                                               &posPath);

            if (hr == S_OK)
            {
               PIMalloc pimalloc;

               hr = STGI_IPERSISTFILE(pcstgi)->lpVtbl->Save(STGI_IPERSISTFILE(pcstgi),
                                                            posPath, FALSE);

               if (SUCCEEDED(hr))
                  hr = STGI_IPERSISTFILE(pcstgi)->lpVtbl->SaveCompleted(STGI_IPERSISTFILE(pcstgi),
                                                                        posPath);

               if (EVAL(GetIMalloc(&pimalloc)))
                  pimalloc->lpVtbl->Free(pimalloc, posPath);
                  /* Do not release pimalloc. */
            }
         }
         break;
   }

   return(hr);
}


/*
** HandsOffStorage()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void HandsOffStorage(HSTGIFACE hstgi)
{
   PCSTGIFACE pcstgi;

   ASSERT(IS_VALID_HANDLE(hstgi, STGIFACE));

   pcstgi = (PCSTGIFACE)hstgi;

   switch (STGI_TYPE(pcstgi))
   {
      case STGIT_IPERSISTSTORAGE:
         EVAL(STGI_IPERSISTSTORAGE(pcstgi)->lpVtbl->HandsOffStorage(STGI_IPERSISTSTORAGE(pcstgi))
              == S_OK);
         break;

      default:
         ASSERT(STGI_TYPE(pcstgi) == STGIT_IPERSISTFILE);
         break;
   }

   return;
}


/*
** GetIMalloc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetIMalloc(PIMalloc *ppimalloc)
{
   BOOL bResult;

   ASSERT(IS_VALID_WRITE_PTR(ppimalloc, PIMalloc));

   ASSERT(! Mpimalloc ||
          IS_VALID_STRUCT_PTR(Mpimalloc, CIMalloc));

   if (! Mpimalloc)
   {
      HRESULT hr;

      hr = CoGetMalloc(MEMCTX_TASK, &Mpimalloc);

      if (SUCCEEDED(hr))
         ASSERT(IS_VALID_STRUCT_PTR(Mpimalloc, CIMalloc));
      else
      {
         ASSERT(! Mpimalloc);

         WARNING_OUT((TEXT("GetIMalloc(): CoGetMalloc() failed, returning %s."),
                      GetHRESULTString(hr)));
      }
   }

   if (Mpimalloc)
   {
      *ppimalloc = Mpimalloc;
      bResult = TRUE;
   }
   else
      bResult = FALSE;

   return(bResult);
}


#ifdef DEBUG

/*
** IsValidHSTGIFACE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHSTGIFACE(HSTGIFACE hstgi)
{
   return(IS_VALID_STRUCT_PTR((PCSTGIFACE)hstgi, CSTGIFACE));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\storage.h ===
/*
 * storage.h - Storage ADT description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HSTGIFACE);
DECLARE_STANDARD_TYPES(HSTGIFACE);


/* Prototypes
 *************/

/* storage.c */

extern BOOL ProcessInitStorageModule(void);
extern void ProcessExitStorageModule(void);
extern HRESULT GetStorageInterface(PIUnknown, PHSTGIFACE);
extern void ReleaseStorageInterface(HSTGIFACE);
extern HRESULT LoadFromStorage(HSTGIFACE, LPCTSTR);
extern HRESULT SaveToStorage(HSTGIFACE);
extern void HandsOffStorage(HSTGIFACE);
extern BOOL GetIMalloc(PIMalloc *);

#ifdef DEBUG

extern BOOL IsValidHSTGIFACE(HSTGIFACE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\sortsrch.c ===
/*
 * sortsrch.c - Generic array sorting and searching module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "sortsrch.h"


/* Macros
 *********/

#define ARRAY_ELEMENT(hpa, ai, es)     (((PBYTE)hpa)[(ai) * (es)])


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE void HeapSwap(PVOID, LONG, LONG, size_t, PVOID);
PRIVATE_CODE void HeapSift(PVOID, LONG, LONG, size_t, COMPARESORTEDELEMSPROC, PVOID);


/*
** HeapSwap()
**
** Swaps two elements of an array.
**
** Arguments:     pvArray - pointer to array
**                li1 - index of first element
**                li2 - index of second element
**                stElemSize - length of element in bytes
**                pvTemp - pointer to temporary buffer of at least stElemSize
**                          bytes used for swapping
**
** Returns:       void
**
** Side Effects:  none
*/
PRIVATE_CODE void HeapSwap(PVOID pvArray, LONG li1, LONG li2,
                           size_t stElemSize, PVOID pvTemp)
{
   ASSERT(li1 >= 0);
   ASSERT(li2 >= 0);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvArray, VOID, (max(li1, li2) + 1) * stElemSize));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvTemp, VOID, stElemSize));

   CopyMemory(pvTemp, & ARRAY_ELEMENT(pvArray, li1, stElemSize), stElemSize);
   CopyMemory(& ARRAY_ELEMENT(pvArray, li1, stElemSize), & ARRAY_ELEMENT(pvArray, li2, stElemSize), stElemSize);
   CopyMemory(& ARRAY_ELEMENT(pvArray, li2, stElemSize), pvTemp, stElemSize);

   return;
}


/*
** HeapSift()
**
** Sifts an element down in an array until the partially ordered tree property
** is restored.
**
** Arguments:     hppTable - pointer to array
**                liFirst - index of first element to sift down
**                liLast - index of last element in subtree
**                cep - pointer comparison callback function to be called to
**                      compare elements
**
** Returns:       void
**
** Side Effects:  none
*/
PRIVATE_CODE void HeapSift(PVOID pvArray, LONG liFirst, LONG liLast,
                           size_t stElemSize, COMPARESORTEDELEMSPROC cep, PVOID pvTemp)
{
   LONG li;

   ASSERT(liFirst >= 0);
   ASSERT(liLast >= 0);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvArray, VOID, (max(liFirst, liLast) + 1) * stElemSize));
   ASSERT(IS_VALID_CODE_PTR(cep, COMPARESORTEDELEMSPROC));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvTemp, VOID, stElemSize));

   li = liFirst * 2;

   CopyMemory(pvTemp, & ARRAY_ELEMENT(pvArray, liFirst, stElemSize), stElemSize);

   while (li <= liLast)
   {
      if (li < liLast &&
          (*cep)(& ARRAY_ELEMENT(pvArray, li, stElemSize), & ARRAY_ELEMENT(pvArray, li + 1, stElemSize)) == CR_FIRST_SMALLER)
         li++;

      if ((*cep)(pvTemp, & ARRAY_ELEMENT(pvArray, li, stElemSize)) != CR_FIRST_SMALLER)
         break;

      CopyMemory(& ARRAY_ELEMENT(pvArray, liFirst, stElemSize), & ARRAY_ELEMENT(pvArray, li, stElemSize), stElemSize);

      liFirst = li;

      li *= 2;
   }

   CopyMemory(& ARRAY_ELEMENT(pvArray, liFirst, stElemSize), pvTemp, stElemSize);

   return;
}


#ifdef DEBUG

/*
** InSortedOrder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL InSortedOrder(PVOID pvArray, LONG lcElements,
                                size_t stElemSize, COMPARESORTEDELEMSPROC cep)
{
   BOOL bResult = TRUE;

   ASSERT(lcElements >= 0);
   ASSERT(IS_VALID_READ_BUFFER_PTR(pvArray, VOID, lcElements * stElemSize));
   ASSERT(IS_VALID_CODE_PTR(cep, COMPARESORTEDELEMSPROC));

   if (lcElements > 1)
   {
      LONG li;

      for (li = 0; li < lcElements - 1; li++)
      {
         if ((*cep)(& ARRAY_ELEMENT(pvArray, li, stElemSize),
                    & ARRAY_ELEMENT(pvArray, li + 1, stElemSize))
             == CR_FIRST_LARGER)
         {
            bResult = FALSE;
            ERROR_OUT((TEXT("InSortedOrder(): Element [%ld] %#lx > following element [%ld] %#lx."),
                       li,
                       & ARRAY_ELEMENT(pvArray, li, stElemSize),
                       li + 1,
                       & ARRAY_ELEMENT(pvArray, li + 1, stElemSize)));
            break;
         }
      }
   }

   return(bResult);
}

#endif


/****************************** Public Functions *****************************/


/*
** HeapSort()
**
** Sorts an array.  Thanks to Rob's Dad for the cool heap sort algorithm.
**
** Arguments:     pvArray - pointer to base of array
**                lcElements - number of elements in array
**                stElemSize - length of element in bytes
**                cep - element comparison callback function
**                pvTemp - pointer to temporary buffer of at least stElemSize
**                          bytes used for swapping
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void HeapSort(PVOID pvArray, LONG lcElements, size_t stElemSize,
                          COMPARESORTEDELEMSPROC cep, PVOID pvTemp)
{
#ifdef DBLCHECK
   ASSERT((double)lcElements * (double)stElemSize <= (double)LONG_MAX);
#endif

   ASSERT(lcElements >= 0);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvArray, VOID, lcElements * stElemSize));
   ASSERT(IS_VALID_CODE_PTR(cep, COMPARESORTEDELEMSPROC));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvTemp, VOID, stElemSize));

   /* Are there any elements to sort (2 or more)? */

   if (lcElements > 1)
   {
      LONG li;
      LONG liLastUsed = lcElements - 1;

      /* Yes.  Create partially ordered tree. */

      for (li = liLastUsed / 2; li >= 0; li--)
         HeapSift(pvArray, li, liLastUsed, stElemSize, cep, pvTemp);

      for (li = liLastUsed; li >= 1; li--)
      {
         /* Remove minimum from front of heap. */

         HeapSwap(pvArray, 0, li, stElemSize, pvTemp);

         /* Reestablish partially ordered tree. */

         HeapSift(pvArray, 0, li - 1, stElemSize, cep, pvTemp);
      }
   }

   ASSERT(InSortedOrder(pvArray, lcElements, stElemSize, cep));

   return;
}


/*
** BinarySearch()
**
** Searches an array for a given element.
**
** Arguments:     pvArray - pointer to base of array
**                lcElements - number of elements in array
**                stElemSize - length of element in bytes
**                cep - element comparison callback function
**                pvTarget - pointer to target element to search for
**                pliTarget - pointer to LONG to be filled in with index of
**                             target element if found
**
** Returns:       TRUE if target element found, or FALSE if not.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL BinarySearch(PVOID pvArray, LONG lcElements,
                              size_t stElemSize, COMPARESORTEDELEMSPROC cep,
                              PCVOID pcvTarget, PLONG pliTarget)
{
   BOOL bFound = FALSE;

#ifdef DBLCHECK
   ASSERT((double)lcElements * (double)stElemSize <= (double)ULONG_MAX);
#endif

   ASSERT(lcElements >= 0);
   ASSERT(IS_VALID_READ_BUFFER_PTR(pvArray, VOID, lcElements * stElemSize));
   ASSERT(IS_VALID_CODE_PTR(cep, COMPARESORTEDELEMSPROC));
   ASSERT(IS_VALID_READ_BUFFER_PTR(pcvTarget, VOID, stElemSize));
   ASSERT(IS_VALID_WRITE_PTR(pliTarget, LONG));

   /* Are there any elements to search through? */

   if (lcElements > 0)
   {
      LONG liLow = 0;
      LONG liMiddle = 0;
      LONG liHigh = lcElements - 1;
      COMPARISONRESULT cr = CR_EQUAL;

      /* Yes.  Search for the target element. */

      /*
       * At the end of the penultimate iteration of this loop:
       *
       * liLow == liMiddle == liHigh.
       */

      while (liLow <= liHigh)
      {
         liMiddle = (liLow + liHigh) / 2;

         cr = (*cep)(pcvTarget, & ARRAY_ELEMENT(pvArray, liMiddle, stElemSize));

         if (cr == CR_FIRST_SMALLER)
            liHigh = liMiddle - 1;
         else if (cr == CR_FIRST_LARGER)
            liLow = liMiddle + 1;
         else
         {
            *pliTarget = liMiddle;
            bFound = TRUE;
            break;
         }
      }
   }

   return(bFound);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\stock.h ===
/*
 * stock.h - Stock header file.
 */


/* Constants
************/

#define FOREVER                  for (;;)

#define INVALID_SEEK_POSITION    (0xffffffff)

#define EMPTY_STRING             TEXT("")
#define SLASH_SLASH              TEXT("\\\\")

#define EQUAL                    TEXT('=')
#define SPACE                    TEXT(' ')
#define TAB                      TEXT('\t')
#define COLON                    TEXT(':')
#define COMMA                    TEXT(',')
#define PERIOD                   TEXT('.')
#define SLASH                    TEXT('\\')
#define BACKSLASH                TEXT('/')
#define ASTERISK                 TEXT('*')
#define QMARK                    TEXT('?')

/* linkage */

/* #pragma data_seg() doesn't work for variables defined extern. */
#define PUBLIC_CODE
#define PUBLIC_DATA
/* Make private functions and data public for profiling and debugging. */
#define PRIVATE_CODE             PUBLIC_CODE
#define PRIVATE_DATA             PUBLIC_DATA
#define INLINE                   __inline

/* limits */

#define WORD_MAX                 USHRT_MAX
#define DWORD_MAX                ULONG_MAX
#define SIZE_T_MAX               DWORD_MAX
#define PTR_MAX                  ((PCVOID)MAXULONG_PTR)

/* file system constants */

#define MAX_PATH_LEN             MAX_PATH
#define MAX_NAME_LEN             MAX_PATH
#define MAX_FOLDER_DEPTH         (MAX_PATH / 2)
#define DRIVE_ROOT_PATH_LEN      (4)

/* size macros */

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define SIZEOF(a)       sizeof(a)

/* invalid thread ID */

#define INVALID_THREAD_ID        (0xffffffff)

/* file-related flag combinations */

#define ALL_FILE_ACCESS_FLAGS          (GENERIC_READ |\
GENERIC_WRITE)

#define ALL_FILE_SHARING_FLAGS         (FILE_SHARE_READ |\
FILE_SHARE_WRITE)

#define ALL_FILE_ATTRIBUTES            (FILE_ATTRIBUTE_READONLY |\
                                        FILE_ATTRIBUTE_HIDDEN |\
                                        FILE_ATTRIBUTE_SYSTEM |\
                                        FILE_ATTRIBUTE_DIRECTORY |\
                                        FILE_ATTRIBUTE_ARCHIVE |\
                                        FILE_ATTRIBUTE_NORMAL |\
                                        FILE_ATTRIBUTE_TEMPORARY)

#define ALL_FILE_FLAGS                 (FILE_FLAG_WRITE_THROUGH |\
                                        FILE_FLAG_OVERLAPPED |\
                                        FILE_FLAG_NO_BUFFERING |\
                                        FILE_FLAG_RANDOM_ACCESS |\
                                        FILE_FLAG_SEQUENTIAL_SCAN |\
                                        FILE_FLAG_DELETE_ON_CLOSE |\
                                        FILE_FLAG_BACKUP_SEMANTICS |\
                                        FILE_FLAG_POSIX_SEMANTICS)

#define ALL_FILE_ATTRIBUTES_AND_FLAGS  (ALL_FILE_ATTRIBUTES |\
ALL_FILE_FLAGS)


/* Macros *********/

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
    typedef const type C##type; \
    typedef const type *PC##type;

#endif

/* character manipulation */

#define IS_SLASH(ch)                      ((ch) == SLASH || (ch) == BACKSLASH)

/* bit flag manipulation */

#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))
#define CLEAR_FLAG(dwAllFlags, dwFlag)    ((dwAllFlags) &= (~dwFlag))

#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))
#define IS_FLAG_CLEAR(dwAllFlags, dwFlag) (! (IS_FLAG_SET(dwAllFlags, dwFlag)))

/* array element count */

#define ARRAY_ELEMENTS(rg)                (sizeof(rg) / sizeof((rg)[0]))

/* file attribute manipulation */

#define IS_ATTR_DIR(attr)                 (IS_FLAG_SET((attr), FILE_ATTRIBUTE_DIRECTORY))
#define IS_ATTR_VOLUME(attr)              (IS_FLAG_SET((attr), FILE_ATTRIBUTE_VOLUME))


/* Types ********/

typedef const void *PCVOID;
typedef const INT CINT;
typedef const INT *PCINT;
typedef const UINT CUINT;
typedef const UINT *PCUINT;
typedef const BYTE CBYTE;
typedef const BYTE *PCBYTE;
typedef const WORD CWORD;
typedef const WORD *PCWORD;
typedef const DWORD CDWORD;
typedef const DWORD *PCDWORD;
typedef const CRITICAL_SECTION CCRITICAL_SECTION;
typedef const CRITICAL_SECTION *PCCRITICAL_SECTION;
typedef const FILETIME CFILETIME;
typedef const FILETIME *PCFILETIME;
typedef const SECURITY_ATTRIBUTES CSECURITY_ATTRIBUTES;
typedef const SECURITY_ATTRIBUTES *PCSECURITY_ATTRIBUTES;
typedef const WIN32_FIND_DATA CWIN32_FIND_DATA;
typedef const WIN32_FIND_DATA *PCWIN32_FIND_DATA;

DECLARE_STANDARD_TYPES(HICON);
DECLARE_STANDARD_TYPES(NMHDR);

#ifndef _COMPARISONRESULT_DEFINED_

/* comparison result */

typedef enum _comparisonresult
{
    CR_FIRST_SMALLER = -1,
        CR_EQUAL = 0,
        CR_FIRST_LARGER = +1
}
COMPARISONRESULT;
DECLARE_STANDARD_TYPES(COMPARISONRESULT);

#define _COMPARISONRESULT_DEFINED_

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\string.c ===
/*
 * string.c - String table ADT module.
 */

/*

   The string table ADT implemented in this module is set up as a hash table
   with HASH_TABLE_SIZE buckets.  A hash function is calculated for each string to
   determine its bucket.  Multiple strings in a single bucket are stored in a
   linked list.  The string hash table allows us to keep only one copy of a string
   that is used multiple times.  Strings are allocated in the heap by
   AllocateMemory().

   Every string has a list node structure associated with it.  A string is
   accessed through its associated list node.  Each hash bucket is a list of
   string nodes.  A handle to a string table is a pointer to the base of the
   string table's array of hash buckets.  String tables are allocated in the heap
   by AllocateMemory().  Each element in an array of hash buckets is a handle to a
   list of strings in the hash bucket.  A handle to a string is a handle to a node
   in the string's hash bucket's list.

   Hash table ADTs are predicated on the idea that hash buckets will typically
   be shallow, so the search of a hash bucket will not take horrendously long.
   The data objects in hash buckets should be stored in sorted order to reduce
   search time.  If hash buckets get too deep, increase the hash table size.
   Ideally, the hash table should be implemented as a container class that hashes
   arbitrary data objects given an initial hash table size, the size of the
   objects to be hashed, a hash function, and a data object comparison function.

   Currently the hash table ADT is restricted to strings, the strings in each
   hash bucket are stored in sorted order, and hash buckets are binary searched.

 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Types
 ********/

/* string table */

typedef struct _stringtable
{
    /* number of hash buckets in string table */

    HASHBUCKETCOUNT hbc;

    /* pointer to array of hash buckets (HLISTs) */

    PHLIST phlistHashBuckets;
}
STRINGTABLE;
DECLARE_STANDARD_TYPES(STRINGTABLE);

/* string heap structure */

typedef struct _string
{
    /* lock count of string */

    ULONG ulcLock;

    /* actual string */

    TCHAR string[1];
}
STRING;
DECLARE_STANDARD_TYPES(STRING);

/* string table database structure header */

typedef struct _stringtabledbheader
{
    /*
     * length of longest string in string table, not including null terminator
     */

    DWORD dwcbMaxStringLen;

    /* number of strings in string table */

    LONG lcStrings;
}
STRINGTABLEDBHEADER;
DECLARE_STANDARD_TYPES(STRINGTABLEDBHEADER);

/* database string header */

typedef struct _dbstringheader
{
    /* old handle to this string */

    HSTRING hsOld;
}
DBSTRINGHEADER;
DECLARE_STANDARD_TYPES(DBSTRINGHEADER);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE COMPARISONRESULT StringSearchCmp(PCVOID, PCVOID);
PRIVATE_CODE COMPARISONRESULT StringSortCmp(PCVOID, PCVOID);
PRIVATE_CODE BOOL UnlockString(PSTRING);
PRIVATE_CODE BOOL FreeStringWalker(PVOID, PVOID);
PRIVATE_CODE void FreeHashBucket(HLIST);
PRIVATE_CODE TWINRESULT WriteHashBucket(HCACHEDFILE, HLIST, PLONG, PDWORD);
PRIVATE_CODE TWINRESULT WriteString(HCACHEDFILE, HNODE, PSTRING, PDWORD);
PRIVATE_CODE TWINRESULT ReadString(HCACHEDFILE, HSTRINGTABLE, HHANDLETRANS, LPTSTR, DWORD);
PRIVATE_CODE TWINRESULT SlowReadString(HCACHEDFILE, LPTSTR, DWORD);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCNEWSTRINGTABLE(PCNEWSTRINGTABLE);
PRIVATE_CODE BOOL IsValidPCSTRING(PCSTRING);
PRIVATE_CODE BOOL IsValidPCSTRINGTABLE(PCSTRINGTABLE);

#endif


/*
 ** StringSearchCmp()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE COMPARISONRESULT StringSearchCmp(PCVOID pcszPath, PCVOID pcstring)
{
    ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
    ASSERT(IS_VALID_STRUCT_PTR(pcstring, CSTRING));

    return(MapIntToComparisonResult(lstrcmp((LPCTSTR)pcszPath,
                    (LPCTSTR)&(((PCSTRING)pcstring)->string))));
}


/*
 ** StringSortCmp()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE COMPARISONRESULT StringSortCmp(PCVOID pcstring1, PCVOID pcstring2)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcstring1, CSTRING));
    ASSERT(IS_VALID_STRUCT_PTR(pcstring2, CSTRING));

    return(MapIntToComparisonResult(lstrcmp((LPCTSTR)&(((PCSTRING)pcstring1)->string),
                    (LPCTSTR)&(((PCSTRING)pcstring2)->string))));
}


/*
 ** UnlockString()
 **
 ** Decrements a string's lock count.
 **
 ** Arguments:
 **
 ** Returns:       void
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL UnlockString(PSTRING pstring)
{
    ASSERT(IS_VALID_STRUCT_PTR(pstring, CSTRING));

    /* Is the lock count going to underflow? */

    if (EVAL(pstring->ulcLock > 0))
        pstring->ulcLock--;

    return(pstring->ulcLock > 0);
}


/*
 ** FreeStringWalker()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */

#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE BOOL FreeStringWalker(PVOID pstring, PVOID pvUnused)
{
    ASSERT(IS_VALID_STRUCT_PTR(pstring, CSTRING));
    ASSERT(! pvUnused);

    FreeMemory(pstring);

    return(TRUE);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
 ** FreeHashBucket()
 **
 ** Frees the strings in a hash bucket, and the hash bucket's string list.
 **
 ** Arguments:     hlistHashBucket - handle to hash bucket's list of strings
 **
 ** Returns:       void
 **
 ** Side Effects:  none
 **
 ** N.b., this function ignores the lock counts of the strings in the hash
 ** bucket.  All strings in the hash bucket are freed.
 */
PRIVATE_CODE void FreeHashBucket(HLIST hlistHashBucket)
{
    ASSERT(! hlistHashBucket || IS_VALID_HANDLE(hlistHashBucket, LIST));

    /* Are there any strings in this hash bucket to delete? */

    if (hlistHashBucket)
    {
        /* Yes.  Delete all strings in list. */

        EVAL(WalkList(hlistHashBucket, &FreeStringWalker, NULL));

        /* Delete hash bucket string list. */

        DestroyList(hlistHashBucket);
    }

    return;
}


/*
 ** MyGetStringLen()
 **
 ** Retrieves the length of a string in a string table.
 **
 ** Arguments:     pcstring - pointer to string whose length is to be
 **                            determined
 **
 ** Returns:       Length of string in bytes, not including null terminator.
 **
 ** Side Effects:  none
 */
PRIVATE_CODE int MyGetStringLen(PCSTRING pcstring)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcstring, CSTRING));

    return(lstrlen(pcstring->string) * sizeof(TCHAR));
}


/*
 ** WriteHashBucket()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT WriteHashBucket(HCACHEDFILE hcf,
        HLIST hlistHashBucket,
        PLONG plcStrings,
        PDWORD pdwcbMaxStringLen)
{
    TWINRESULT tr = TR_SUCCESS;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(! hlistHashBucket || IS_VALID_HANDLE(hlistHashBucket, LIST));
    ASSERT(IS_VALID_WRITE_PTR(plcStrings, LONG));
    ASSERT(IS_VALID_WRITE_PTR(pdwcbMaxStringLen, DWORD));

    /* Any strings in this hash bucket? */

    *plcStrings = 0;
    *pdwcbMaxStringLen = 0;

    if (hlistHashBucket)
    {
        BOOL bContinue;
        HNODE hnode;

        /* Yes.  Walk hash bucket, saving each string. */

        for (bContinue = GetFirstNode(hlistHashBucket, &hnode);
                bContinue;
                bContinue = GetNextNode(hnode, &hnode))
        {
            PSTRING pstring;

            pstring = (PSTRING)GetNodeData(hnode);

            ASSERT(IS_VALID_STRUCT_PTR(pstring, CSTRING));

            /*
             * As a sanity check, don't save any string with a lock count of 0.  A
             * 0 lock count implies that the string has not been referenced since
             * it was restored from the database, or something is broken.
             */

            if (pstring->ulcLock > 0)
            {
                DWORD dwcbStringLen;

                tr = WriteString(hcf, hnode, pstring, &dwcbStringLen);

                if (tr == TR_SUCCESS)
                {
                    if (dwcbStringLen > *pdwcbMaxStringLen)
                        *pdwcbMaxStringLen = dwcbStringLen;

                    ASSERT(*plcStrings < LONG_MAX);
                    (*plcStrings)++;
                }
                else
                    break;
            }
            else
                ERROR_OUT((TEXT("WriteHashBucket(): String \"%s\" has 0 lock count and will not be saved."),
                            pstring->string));
        }
    }

    return(tr);
}


/*
 ** WriteString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT WriteString(HCACHEDFILE hcf, HNODE hnodeOld,
        PSTRING pstring, PDWORD pdwcbStringLen)
{
    TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
    DBSTRINGHEADER dbsh;

    /* (+ 1) for null terminator. */

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_HANDLE(hnodeOld, NODE));
    ASSERT(IS_VALID_STRUCT_PTR(pstring, CSTRING));
    ASSERT(IS_VALID_READ_BUFFER_PTR(pstring, STRING, sizeof(STRING) + MyGetStringLen(pstring) + sizeof(TCHAR) - sizeof(pstring->string)));
    ASSERT(IS_VALID_WRITE_PTR(pdwcbStringLen, DWORD));

    /* Create string header. */

    dbsh.hsOld = (HSTRING)hnodeOld;

    /* Save string header and string. */

    if (WriteToCachedFile(hcf, (PCVOID)&dbsh, sizeof(dbsh), NULL))
    {
        LPSTR pszAnsi;

        /* (+ 1) for null terminator. */

        *pdwcbStringLen = MyGetStringLen(pstring) + SIZEOF(TCHAR);

        // If its unicode, convert the string to ansi before writing it out

#ifdef UNICODE
        {
            pszAnsi = LocalAlloc(LPTR, *pdwcbStringLen);
            if (NULL == pszAnsi)
            {
                return tr;
            }
            WideCharToMultiByte(CP_ACP, 0, pstring->string, -1, pszAnsi, *pdwcbStringLen, NULL, NULL);

            // We should always have a string at this point that can be converted losslessly

#if (defined(DEBUG) || defined(DBG)) && defined(UNICODE)
            {
                WCHAR szUnicode[MAX_PATH*2];
                MultiByteToWideChar(CP_ACP, 0, pszAnsi, -1, szUnicode, ARRAYSIZE(szUnicode));
                ASSERT(0 == lstrcmp(szUnicode, pstring->string));
            }
#endif

            if (WriteToCachedFile(hcf, (PCVOID) pszAnsi, lstrlenA(pszAnsi) + 1, NULL))
                tr = TR_SUCCESS;

            LocalFree(pszAnsi);
        }
#else

        if (WriteToCachedFile(hcf, (PCVOID)&(pstring->string), (UINT)*pdwcbStringLen, NULL))
            tr = TR_SUCCESS;

#endif

    }

    return(tr);
}


/*
 ** ReadString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT ReadString(HCACHEDFILE hcf, HSTRINGTABLE hst,
        HHANDLETRANS hht, LPTSTR pszStringBuf,
        DWORD dwcbStringBufLen)
{
    TWINRESULT tr;
    DBSTRINGHEADER dbsh;
    DWORD dwcbRead;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));
    ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszStringBuf, STR, (UINT)dwcbStringBufLen));

    if (ReadFromCachedFile(hcf, &dbsh, sizeof(dbsh), &dwcbRead) &&
            dwcbRead == sizeof(dbsh))
    {
        tr = SlowReadString(hcf, pszStringBuf, dwcbStringBufLen);

        if (tr == TR_SUCCESS)
        {
            HSTRING hsNew;

            if (AddString(pszStringBuf, hst, GetHashBucketIndex, &hsNew))
            {
                /*
                 * We must undo the LockString() performed by AddString() to
                 * maintain the correct string lock count.  N.b., the lock count of
                 * a string may be > 0 even after unlocking since the client may
                 * already have added the string to the given string table.
                 */

                UnlockString((PSTRING)GetNodeData((HNODE)hsNew));

                if (! AddHandleToHandleTranslator(hht, (HGENERIC)(dbsh.hsOld), (HGENERIC)hsNew))
                {
                    DeleteNode((HNODE)hsNew);

                    tr = TR_CORRUPT_BRIEFCASE;
                }
            }
            else
                tr = TR_OUT_OF_MEMORY;
        }
    }
    else
        tr = TR_CORRUPT_BRIEFCASE;

    return(tr);
}


/*
 ** SlowReadString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT SlowReadString(HCACHEDFILE hcf, LPTSTR pszStringBuf,
        DWORD dwcbStringBufLen)
{
    TWINRESULT tr = TR_CORRUPT_BRIEFCASE;
    LPTSTR pszStringBufEnd;
    DWORD dwcbRead;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszStringBuf, STR, (UINT)dwcbStringBufLen));

    pszStringBufEnd = pszStringBuf + dwcbStringBufLen;

    // The database strings are always written ANSI, so if we are running unicode,
    // we need to convert as we go

#ifdef UNICODE
    {
        LPSTR pszAnsiEnd;
        LPSTR pszAnsiStart;
        LPSTR pszAnsi = LocalAlloc(LPTR, dwcbStringBufLen);
        pszAnsiStart  = pszAnsi;
        pszAnsiEnd    = pszAnsi + dwcbStringBufLen;

        if (NULL == pszAnsi)
        {
            return tr;
        }

        while (pszAnsi < pszAnsiEnd &&
                ReadFromCachedFile(hcf, pszAnsi, sizeof(*pszAnsi), &dwcbRead) &&
                dwcbRead == sizeof(*pszAnsi))
        {
            if (*pszAnsi)
                pszAnsi++;
            else
            {
                tr = TR_SUCCESS;
                break;
            }
        }

        if (tr == TR_SUCCESS)
        {
            MultiByteToWideChar(CP_ACP, 0, pszAnsiStart, -1, pszStringBuf, dwcbStringBufLen / sizeof(TCHAR));
        }

        LocalFree(pszAnsiStart);
    }
#else

    while (pszStringBuf < pszStringBufEnd &&
            ReadFromCachedFile(hcf, pszStringBuf, sizeof(*pszStringBuf), &dwcbRead) &&
            dwcbRead == sizeof(*pszStringBuf))
    {
        if (*pszStringBuf)
            pszStringBuf++;
        else
        {
            tr = TR_SUCCESS;
            break;
        }
    }

#endif

    return(tr);
}


#ifdef VSTF

/*
 ** IsValidPCNEWSTRINGTABLE()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCNEWSTRINGTABLE(PCNEWSTRINGTABLE pcnst)
{
    BOOL bResult;

    if (IS_VALID_READ_PTR(pcnst, CNEWSTRINGTABLE) &&
            EVAL(pcnst->hbc > 0))
        bResult = TRUE;
    else
        bResult = FALSE;

    return(bResult);
}


/*
 ** IsValidPCSTRING()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCSTRING(PCSTRING pcs)
{
    BOOL bResult;

    if (IS_VALID_READ_PTR(pcs, CSTRING) &&
            IS_VALID_STRING_PTR(pcs->string, CSTR))
        bResult = TRUE;
    else
        bResult = FALSE;

    return(bResult);
}


/*
 ** IsValidStringWalker()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */

#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE BOOL IsValidStringWalker(PVOID pstring, PVOID pvUnused)
{
    ASSERT(! pvUnused);

    return(IS_VALID_STRUCT_PTR(pstring, CSTRING));
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
 ** IsValidPCSTRINGTABLE()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCSTRINGTABLE(PCSTRINGTABLE pcst)
{
    BOOL bResult = FALSE;

    if (IS_VALID_READ_PTR(pcst, CSTRINGTABLE) &&
            EVAL(pcst->hbc > 0) &&
            IS_VALID_READ_BUFFER_PTR(pcst->phlistHashBuckets, HLIST, pcst->hbc * sizeof((pcst->phlistHashBuckets)[0])))
    {
        HASHBUCKETCOUNT hbc;

        for (hbc = 0; hbc < pcst->hbc; hbc++)
        {
            HLIST hlistHashBucket;

            hlistHashBucket = (pcst->phlistHashBuckets)[hbc];

            if (hlistHashBucket)
            {
                if (! IS_VALID_HANDLE(hlistHashBucket, LIST) ||
                        ! WalkList(hlistHashBucket, &IsValidStringWalker, NULL))
                    break;
            }
        }

        if (hbc == pcst->hbc)
            bResult = TRUE;
    }

    return(bResult);
}

#endif


/****************************** Public Functions *****************************/

/*
 ** CreateStringTable()
 **
 ** Creates a new string table.
 **
 ** Arguments:     pcnszt - pointer to NEWSTRINGTABLE descibing string table to
 **                          be created
 **
 ** Returns:       Handle to new string table if successful, or NULL if
 **                unsuccessful.
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL CreateStringTable(PCNEWSTRINGTABLE pcnszt,
        PHSTRINGTABLE phst)
{
    PSTRINGTABLE pst;

    ASSERT(IS_VALID_STRUCT_PTR(pcnszt, CNEWSTRINGTABLE));
    ASSERT(IS_VALID_WRITE_PTR(phst, HSTRINGTABLE));

    /* Try to allocate new string table structure. */

    *phst = NULL;

    if (AllocateMemory(sizeof(*pst), &pst))
    {
        PHLIST phlistHashBuckets;

        /* Try to allocate hash bucket array. */

#ifdef DBLCHECK
        ASSERT((double)(pcnszt->hbc) * (double)(sizeof(*phlistHashBuckets)) <= (double)SIZE_T_MAX);
#endif

        if (AllocateMemory(pcnszt->hbc * sizeof(*phlistHashBuckets), (PVOID *)(&phlistHashBuckets)))
        {
            HASHBUCKETCOUNT bc;

            /* Successs!  Initialize STRINGTABLE fields. */

            pst->phlistHashBuckets = phlistHashBuckets;
            pst->hbc = pcnszt->hbc;

            /* Initialize all hash buckets to NULL. */

            for (bc = 0; bc < pcnszt->hbc; bc++)
                phlistHashBuckets[bc] = NULL;

            *phst = (HSTRINGTABLE)pst;

            ASSERT(IS_VALID_HANDLE(*phst, STRINGTABLE));
        }
        else
            /* Free string table structure. */
            FreeMemory(pst);
    }

    return(*phst != NULL);
}


/*
 ** DestroyStringTable()
 **
 ** Destroys a string table.
 **
 ** Arguments:     hst - handle to string table to be destroyed
 **
 ** Returns:       void
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DestroyStringTable(HSTRINGTABLE hst)
{
    HASHBUCKETCOUNT bc;

    ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));

    /* Traverse array of hash bucket heads, freeing hash bucket strings. */

    for (bc = 0; bc < ((PSTRINGTABLE)hst)->hbc; bc++)
        FreeHashBucket(((PSTRINGTABLE)hst)->phlistHashBuckets[bc]);

    /* Free array of hash buckets. */

    FreeMemory(((PSTRINGTABLE)hst)->phlistHashBuckets);

    /* Free string table structure. */

    FreeMemory((PSTRINGTABLE)hst);

    return;
}


/*
 ** AddString()
 **
 ** Adds a string to a string table.
 **
 ** Arguments:     pcsz - pointer to string to be added
 **                hst - handle to string table that string is to be added to
 **
 ** Returns:       Handle to new string if successful, or NULL if unsuccessful.
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL AddString(LPCTSTR pcsz, HSTRINGTABLE hst, 
        STRINGTABLEHASHFUNC pfnHashFunc, PHSTRING phs)
{
    BOOL bResult;
    HASHBUCKETCOUNT hbcNew;
    BOOL bFound;
    HNODE hnode;
    PHLIST phlistHashBucket;

    ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
    ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));
    ASSERT(IS_VALID_CODE_PTR(pfnHashFunc, STRINGTABLEHASHFUNC));
    ASSERT(IS_VALID_WRITE_PTR(phs, HSTRING));

    /* Find appropriate hash bucket. */

    hbcNew = pfnHashFunc(pcsz, ((PSTRINGTABLE)hst)->hbc);

    ASSERT(hbcNew < ((PSTRINGTABLE)hst)->hbc);

    phlistHashBucket = &(((PSTRINGTABLE)hst)->phlistHashBuckets[hbcNew]);

    if (*phlistHashBucket)
    {
        /* Search the hash bucket for the string. */

        bFound = SearchSortedList(*phlistHashBucket, &StringSearchCmp, pcsz,
                &hnode);
        bResult = TRUE;
    }
    else
    {
        NEWLIST nl;

        /* Create a string list for this hash bucket. */

        bFound = FALSE;

        nl.dwFlags = NL_FL_SORTED_ADD;

        bResult = CreateList(&nl, phlistHashBucket);
    }

    /* Do we have a hash bucket for the string? */

    if (bResult)
    {
        /* Yes.  Is the string already in the hash bucket? */

        if (bFound)
        {
            /* Yes. */

            LockString((HSTRING)hnode);
            *phs = (HSTRING)hnode;
        }
        else
        {
            /* No.  Create it. */

            PSTRING pstringNew;

            /* (+ 1) for null terminator. */

            bResult = AllocateMemory(sizeof(*pstringNew) - sizeof(pstringNew->string)
                    + (lstrlen(pcsz) + 1) * sizeof(TCHAR), &pstringNew);

            if (bResult)
            {
                HNODE hnodeNew;

                /* Set up STRING fields. */

                pstringNew->ulcLock = 1;
                lstrcpy(pstringNew->string, pcsz); // dynamically allocated above

                /* What's up with this string, Doc? */

                bResult = AddNode(*phlistHashBucket, StringSortCmp, pstringNew, &hnodeNew);

                /* Was the new string added to the hash bucket successfully? */

                if (bResult)
                    /* Yes. */
                    *phs = (HSTRING)hnodeNew;
                else
                    /* No. */
                    FreeMemory(pstringNew);
            }
        }
    }

    ASSERT(! bResult ||
            IS_VALID_HANDLE(*phs, STRING));

    return(bResult);
}


/*
 ** DeleteString()
 **
 ** Decrements a string's lock count.  If the lock count goes to 0, the string
 ** is deleted from its string table.
 **
 ** Arguments:     hs - handle to the string to be deleted
 **
 ** Returns:       void
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DeleteString(HSTRING hs)
{
    PSTRING pstring;

    ASSERT(IS_VALID_HANDLE(hs, STRING));

    pstring = (PSTRING)GetNodeData((HNODE)hs);

    /* Delete string completely? */

    if (! UnlockString(pstring))
    {
        /* Yes.  Remove the string node from the hash bucket's list. */

        DeleteNode((HNODE)hs);

        FreeMemory(pstring);
    }

    return;
}


/*
 ** LockString()
 **
 ** Increments a string's lock count.
 **
 ** Arguments:     hs - handle to string whose lock count is to be incremented
 **
 ** Returns:       void
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void LockString(HSTRING hs)
{
    PSTRING pstring;

    ASSERT(IS_VALID_HANDLE(hs, STRING));

    /* Increment lock count. */

    pstring = (PSTRING)GetNodeData((HNODE)hs);

    ASSERT(pstring->ulcLock < ULONG_MAX);
    pstring->ulcLock++;

    return;
}


/*
 ** CompareStrings()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE COMPARISONRESULT CompareStringsI(HSTRING hs1, HSTRING hs2)
{
    ASSERT(IS_VALID_HANDLE(hs1, STRING));
    ASSERT(IS_VALID_HANDLE(hs2, STRING));

    /* This comparison works across string tables. */

    return(MapIntToComparisonResult(lstrcmpi(((PCSTRING)GetNodeData((HNODE)hs1))->string,
                    ((PCSTRING)GetNodeData((HNODE)hs2))->string)));
}


/*
 ** GetString()
 **
 ** Retrieves a pointer to a string in a string table.
 **
 ** Arguments:     hs - handle to the string to be retrieved
 **
 ** Returns:       Pointer to string.
 **
 ** Side Effects:  none
 */
PUBLIC_CODE LPCTSTR GetString(HSTRING hs)
{
    PSTRING pstring;

    ASSERT(IS_VALID_HANDLE(hs, STRING));

    pstring = (PSTRING)GetNodeData((HNODE)hs);

    return((LPCTSTR)&(pstring->string));
}


/*
 ** WriteStringTable()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT WriteStringTable(HCACHEDFILE hcf, HSTRINGTABLE hst)
{
    TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
    DWORD dwcbStringTableDBHeaderOffset;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));

    /* Save initial file poisition. */

    dwcbStringTableDBHeaderOffset = GetCachedFilePointerPosition(hcf);

    if (dwcbStringTableDBHeaderOffset != INVALID_SEEK_POSITION)
    {
        STRINGTABLEDBHEADER stdbh;

        /* Leave space for the string table header. */

        ZeroMemory(&stdbh, sizeof(stdbh));

        if (WriteToCachedFile(hcf, (PCVOID)&stdbh, sizeof(stdbh), NULL))
        {
            HASHBUCKETCOUNT hbc;

            /* Save strings in each hash bucket. */

            stdbh.dwcbMaxStringLen = 0;
            stdbh.lcStrings = 0;

            tr = TR_SUCCESS;

            for (hbc = 0; hbc < ((PSTRINGTABLE)hst)->hbc; hbc++)
            {
                LONG lcStringsInHashBucket;
                DWORD dwcbStringLen;

                tr = WriteHashBucket(hcf,
                        (((PSTRINGTABLE)hst)->phlistHashBuckets)[hbc],
                        &lcStringsInHashBucket, &dwcbStringLen);

                if (tr == TR_SUCCESS)
                {
                    /* Watch out for overflow. */

                    ASSERT(stdbh.lcStrings <= LONG_MAX - lcStringsInHashBucket);

                    stdbh.lcStrings += lcStringsInHashBucket;

                    if (dwcbStringLen > stdbh.dwcbMaxStringLen)
                        stdbh.dwcbMaxStringLen = dwcbStringLen;
                }
                else
                    break;
            }

            if (tr == TR_SUCCESS)
            {
                /* Save string table header. */

                // The on-disk dwCBMaxString len always refers to ANSI chars,
                // whereas in memory it is for the TCHAR type, we adjust it
                // around the save

                stdbh.dwcbMaxStringLen /= sizeof(TCHAR);

                tr = WriteDBSegmentHeader(hcf, dwcbStringTableDBHeaderOffset,
                        &stdbh, sizeof(stdbh));

                stdbh.dwcbMaxStringLen *= sizeof(TCHAR);

                TRACE_OUT((TEXT("WriteStringTable(): Wrote %ld strings."),
                            stdbh.lcStrings));
            }
        }
    }

    return(tr);
}


/*
 ** ReadStringTable()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT ReadStringTable(HCACHEDFILE hcf, HSTRINGTABLE hst,
        PHHANDLETRANS phhtTrans)
{
    TWINRESULT tr;
    STRINGTABLEDBHEADER stdbh;
    DWORD dwcbRead;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));
    ASSERT(IS_VALID_WRITE_PTR(phhtTrans, HHANDLETRANS));

    if (ReadFromCachedFile(hcf, &stdbh, sizeof(stdbh), &dwcbRead) &&
            dwcbRead == sizeof(stdbh))
    {
        LPTSTR pszStringBuf;

        // The string header will have the ANSI cb max, whereas inmemory
        // we need the cb max based on the current character size

        stdbh.dwcbMaxStringLen *= sizeof(TCHAR);

        if (AllocateMemory(stdbh.dwcbMaxStringLen, &pszStringBuf))
        {
            HHANDLETRANS hht;

            if (CreateHandleTranslator(stdbh.lcStrings, &hht))
            {
                LONG lcStrings;

                tr = TR_SUCCESS;

                TRACE_OUT((TEXT("ReadStringTable(): Reading %ld strings, maximum length %lu."),
                            stdbh.lcStrings,
                            stdbh.dwcbMaxStringLen));

                for (lcStrings = 0;
                        lcStrings < stdbh.lcStrings && tr == TR_SUCCESS;
                        lcStrings++)
                    tr = ReadString(hcf, hst, hht, pszStringBuf, stdbh.dwcbMaxStringLen);

                if (tr == TR_SUCCESS)
                {
                    PrepareForHandleTranslation(hht);
                    *phhtTrans = hht;

                    ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));
                    ASSERT(IS_VALID_HANDLE(*phhtTrans, HANDLETRANS));
                }
                else
                    DestroyHandleTranslator(hht);
            }
            else
                tr = TR_OUT_OF_MEMORY;

            FreeMemory(pszStringBuf);
        }
        else
            tr = TR_OUT_OF_MEMORY;
    }
    else
        tr = TR_CORRUPT_BRIEFCASE;

    return(tr);
}


#if defined(DEBUG) || defined (VSTF)

/*
 ** IsValidHSTRING()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidHSTRING(HSTRING hs)
{
    BOOL bResult;

    if (IS_VALID_HANDLE((HNODE)hs, NODE))
        bResult = IS_VALID_STRUCT_PTR((PSTRING)GetNodeData((HNODE)hs), CSTRING);
    else
        bResult = FALSE;

    return(bResult);
}


/*
 ** IsValidHSTRINGTABLE()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidHSTRINGTABLE(HSTRINGTABLE hst)
{
    return(IS_VALID_STRUCT_PTR((PSTRINGTABLE)hst, CSTRINGTABLE));
}

#endif


#ifdef DEBUG

/*
 ** GetStringCount()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE ULONG GetStringCount(HSTRINGTABLE hst)
{
    ULONG ulcStrings = 0;
    HASHBUCKETCOUNT hbc;

    ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));

    for (hbc = 0; hbc < ((PCSTRINGTABLE)hst)->hbc; hbc++)
    {
        HLIST hlistHashBucket;

        hlistHashBucket = (((PCSTRINGTABLE)hst)->phlistHashBuckets)[hbc];

        if (hlistHashBucket)
        {
            ASSERT(ulcStrings <= ULONG_MAX - GetNodeCount(hlistHashBucket));
            ulcStrings += GetNodeCount(hlistHashBucket);
        }
    }

    return(ulcStrings);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\string2.h ===
/*
 * string.h - String table ADT description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HSTRING);
DECLARE_STANDARD_TYPES(HSTRING);
DECLARE_HANDLE(HSTRINGTABLE);
DECLARE_STANDARD_TYPES(HSTRINGTABLE);

/* count of hash buckets in a string table */

typedef UINT HASHBUCKETCOUNT;
DECLARE_STANDARD_TYPES(HASHBUCKETCOUNT);

/* string table hash function */

typedef HASHBUCKETCOUNT (*STRINGTABLEHASHFUNC)(LPCTSTR, HASHBUCKETCOUNT);

/* new string table */

typedef struct _newstringtable
{
   HASHBUCKETCOUNT hbc;
}
NEWSTRINGTABLE;
DECLARE_STANDARD_TYPES(NEWSTRINGTABLE);


/* Prototypes
 *************/

/* string.c */

extern BOOL CreateStringTable(PCNEWSTRINGTABLE, PHSTRINGTABLE);
extern void DestroyStringTable(HSTRINGTABLE);
extern BOOL AddString(LPCTSTR pcsz, HSTRINGTABLE hst, STRINGTABLEHASHFUNC pfnHashFunc, PHSTRING phs);
extern void DeleteString(HSTRING);
extern void LockString(HSTRING);
extern COMPARISONRESULT CompareStringsI(HSTRING, HSTRING);
extern LPCTSTR GetString(HSTRING);

#if defined(DEBUG) || defined (VSTF)

extern BOOL IsValidHSTRING(HSTRING);
extern BOOL IsValidHSTRINGTABLE(HSTRINGTABLE);

#endif

#ifdef DEBUG

extern ULONG GetStringCount(HSTRINGTABLE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\stub.c ===
/*
 * stub.c - Stub ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"


/* Macros
 *********/

/* get a pointer to the stub type descriptor for a STUB */

#define GetStubTypeDescriptor(pcs)     (&(Mrgcstd[pcs->st]))


/* Types
 ********/

/* stub functions */

typedef TWINRESULT (*UNLINKSTUBPROC)(PSTUB);
typedef void (*DESTROYSTUBPROC)(PSTUB);
typedef void (*LOCKSTUBPROC)(PSTUB);
typedef void (*UNLOCKSTUBPROC)(PSTUB);

/* stub type descriptor */

typedef struct _stubtypedescriptor
{
   UNLINKSTUBPROC UnlinkStub;

   DESTROYSTUBPROC DestroyStub;

   LOCKSTUBPROC LockStub;

   UNLOCKSTUBPROC UnlockStub;
}
STUBTYPEDESCRIPTOR;
DECLARE_STANDARD_TYPES(STUBTYPEDESCRIPTOR);


/* Module Prototypes
 ********************/

PRIVATE_CODE void LockSingleStub(PSTUB);
PRIVATE_CODE void UnlockSingleStub(PSTUB);

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL IsValidStubType(STUBTYPE);

#endif

#ifdef DEBUG

PRIVATE_CODE LPCTSTR GetStubName(PCSTUB);

#endif


/* Module Variables
 *******************/

/* stub type descriptors */

/* Cast off compiler complaints about pointer argument mismatch. */

PRIVATE_DATA CONST STUBTYPEDESCRIPTOR Mrgcstd[] =
{
   /* object twin STUB descriptor */

   {
      (UNLINKSTUBPROC)UnlinkObjectTwin,
      (DESTROYSTUBPROC)DestroyObjectTwin,
      LockSingleStub,
      UnlockSingleStub
   },

   /* twin family STUB descriptor */

   {
      (UNLINKSTUBPROC)UnlinkTwinFamily,
      (DESTROYSTUBPROC)DestroyTwinFamily,
      LockSingleStub,
      UnlockSingleStub
   },

   /* folder pair STUB descriptor */

   {
      (UNLINKSTUBPROC)UnlinkFolderPair,
      (DESTROYSTUBPROC)DestroyFolderPair,
      (LOCKSTUBPROC)LockFolderPair,
      (UNLOCKSTUBPROC)UnlockFolderPair
   }
};


/***************************** Private Functions *****************************/


/*
** LockSingleStub()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void LockSingleStub(PSTUB ps)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

   ASSERT(IsStubFlagClear(ps, STUB_FL_UNLINKED));

   ASSERT(ps->ulcLock < ULONG_MAX);
   ps->ulcLock++;

   return;
}


/*
** UnlockSingleStub()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void UnlockSingleStub(PSTUB ps)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

   if (EVAL(ps->ulcLock > 0))
   {
      ps->ulcLock--;

      if (! ps->ulcLock &&
          IsStubFlagSet(ps, STUB_FL_UNLINKED))
         DestroyStub(ps);
   }

   return;
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidStubType()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidStubType(STUBTYPE st)
{
   BOOL bResult;

   switch (st)
   {
      case ST_OBJECTTWIN:
      case ST_TWINFAMILY:
      case ST_FOLDERPAIR:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidStubType(): Invalid STUB type %d."),
                    st));
   }

   return(bResult);
}

#endif


#ifdef DEBUG

/*
** GetStubName()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE LPCTSTR GetStubName(PCSTUB pcs)
{
   LPCTSTR pcszStubName;

   ASSERT(IS_VALID_STRUCT_PTR(pcs, CSTUB));

   switch (pcs->st)
   {
      case ST_OBJECTTWIN:
         pcszStubName = TEXT("object twin");
         break;

      case ST_TWINFAMILY:
         pcszStubName = TEXT("twin family");
         break;

      case ST_FOLDERPAIR:
         pcszStubName = TEXT("folder twin");
         break;

      default:
         ERROR_OUT((TEXT("GetStubName() called on unrecognized stub type %d."),
                    pcs->st));
         pcszStubName = TEXT("UNKNOWN");
         break;
   }

   ASSERT(IS_VALID_STRING_PTR(pcszStubName, CSTR));

   return(pcszStubName);
}

#endif


/****************************** Public Functions *****************************/


/*
** InitStub()
**
** Initializes a stub.
**
** Arguments:     ps - pointer to stub to be initialized
**                st - type of stub
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void InitStub(PSTUB ps, STUBTYPE st)
{
   ASSERT(IS_VALID_WRITE_PTR(ps, STUB));
   ASSERT(IsValidStubType(st));

   ps->st = st;
   ps->ulcLock = 0;
   ps->dwFlags = 0;

   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

   return;
}


/*
** DestroyStub()
**
** Destroys a stub.
**
** Arguments:     ps - pointer to stub to be destroyed
**
** Returns:       TWINRESULT
**
** Side Effects:  Depends upon stub type.
*/
PUBLIC_CODE TWINRESULT DestroyStub(PSTUB ps)
{
   TWINRESULT tr;
   PCSTUBTYPEDESCRIPTOR pcstd;

   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

#ifdef DEBUG

   if (IsStubFlagSet(ps, STUB_FL_UNLINKED) &&
       ps->ulcLock > 0)
      WARNING_OUT((TEXT("DestroyStub() called on unlinked locked %s stub %#lx."),
                   GetStubName(ps),
                   ps));

#endif

   pcstd = GetStubTypeDescriptor(ps);

   /* Is the stub already unlinked? */

   if (IsStubFlagSet(ps, STUB_FL_UNLINKED))
      /* Yes. */
      tr = TR_SUCCESS;
   else
      /* No.  Unlink it. */
      tr = (*(pcstd->UnlinkStub))(ps);

   /* Is the stub still locked? */

   if (tr == TR_SUCCESS && ! ps->ulcLock)
      /* No.  Wipe it out. */
      (*(pcstd->DestroyStub))(ps);

   return(tr);
}


/*
** LockStub()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void LockStub(PSTUB ps)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

   (*(GetStubTypeDescriptor(ps)->LockStub))(ps);

   return;
}


/*
** UnlockStub()
**
** Unlocks a stub.  Carries out any pending deletion on the stub.
**
** Arguments:     ps - pointer to stub to be unlocked
**
** Returns:       void
**
** Side Effects:  If the stub is unlinked and the lock count decreases to 0
**                after unlocking, the stub is deleted.
*/
PUBLIC_CODE void UnlockStub(PSTUB ps)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

   (*(GetStubTypeDescriptor(ps)->UnlockStub))(ps);

   return;
}


/*
** GetStubFlags()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE DWORD GetStubFlags(PCSTUB pcs)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcs, CSTUB));

   return(pcs->dwFlags);
}


/*
** SetStubFlag()
**
** Sets given flag in a stub.  Other flags in stub are not affected.
**
** Arguments:     ps - pointer to stub whose flags are to be set
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void SetStubFlag(PSTUB ps, DWORD dwFlags)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_STUB_FLAGS));

   SET_FLAG(ps->dwFlags, dwFlags);

   return;
}


/*
** ClearStubFlag()
**
** Clears given flag in a stub.  Other flags in stub are not affected.
**
** Arguments:     ps - pointer to stub whose flags are to be set
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void ClearStubFlag(PSTUB ps, DWORD dwFlags)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_STUB_FLAGS));

   CLEAR_FLAG(ps->dwFlags, dwFlags);

   return;
}


/*
** IsStubFlagSet()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsStubFlagSet(PCSTUB pcs, DWORD dwFlags)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcs, CSTUB));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_STUB_FLAGS));

   return(IS_FLAG_SET(pcs->dwFlags, dwFlags));
}


/*
** IsStubFlagClear()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsStubFlagClear(PCSTUB pcs, DWORD dwFlags)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcs, CSTUB));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_STUB_FLAGS));

   return(IS_FLAG_CLEAR(pcs->dwFlags, dwFlags));
}


#ifdef VSTF

/*
** IsValidPCSTUB()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCSTUB(PCSTUB pcs)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pcs, CSTUB) &&
       IsValidStubType(pcs->st) &&
       FLAGS_ARE_VALID(pcs->dwFlags, ALL_STUB_FLAGS))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\stub.h ===
/*
 * stub.h - Stub ADT description.
 */


/* Types
 ********/

/* stub types */

typedef enum _stubtype
{
   ST_OBJECTTWIN,

   ST_TWINFAMILY,

   ST_FOLDERPAIR
}
STUBTYPE;
DECLARE_STANDARD_TYPES(STUBTYPE);

/* stub flags */

typedef enum _stubflags
{
   /* This stub was marked for deletion while it was locked. */

   STUB_FL_UNLINKED           = 0x0001,

   /* This stub has already been used for some operation. */

   STUB_FL_USED               = 0x0002,

   /*
    * The file stamp of this object twin stub is valid.  (Only used for object
    * twins to cache file stamp from folder twin expansion for RECNODE
    * creation.)
    */

   STUB_FL_FILE_STAMP_VALID   = 0x0004,

   /*
    * This twin family stub or folder twin stub is in the process of being
    * deleted.  (Only used for twin families and folder twins.)
    */

   STUB_FL_BEING_DELETED      = 0x0008,

   /*
    * This folder twin stub is in the process of being translated.  (Only used
    * for folder twins.)
    */

   STUB_FL_BEING_TRANSLATED   = 0x0010,

   /*
    * This object twin stub was explicitly added a an object twin through
    * AddObjectTwin().  (Only used for object twins.)
    */

   STUB_FL_FROM_OBJECT_TWIN   = 0x0100,

   /*
    * This object twin stub was not reconciled the last time its twin family
    * was reconciled, and some members of the twin family were known to have
    * changed.  (Only used for object twins.)
    */

   STUB_FL_NOT_RECONCILED     = 0x0200,

   /*
    * The subtree of the root folder of this folder twin stub is to be included
    * in reconciliation.  (Only used for folder twins.)
    */

   STUB_FL_SUBTREE            = 0x0400,

   /*
    * The object twins in this twin family are pending deletion because an
    * object twin was deleted, and no object twins have changed since that
    * object twins was deleted.  This folder twin is pending deletion because
    * its folder root is last known deleted.  (Only used for twin families and
    * folder twins.)
    */

   STUB_FL_DELETION_PENDING   = 0x0800,

   /*
    * The client indicated that this object twin should not be deleted.  (Only
    * used for object twins.)
    */

   STUB_FL_KEEP               = 0x1000,

   /* stub flag combinations */

   ALL_STUB_FLAGS             = (STUB_FL_UNLINKED |
                                 STUB_FL_USED |
                                 STUB_FL_FILE_STAMP_VALID |
                                 STUB_FL_BEING_DELETED |
                                 STUB_FL_BEING_TRANSLATED |
                                 STUB_FL_FROM_OBJECT_TWIN |
                                 STUB_FL_NOT_RECONCILED |
                                 STUB_FL_SUBTREE |
                                 STUB_FL_DELETION_PENDING |
                                 STUB_FL_KEEP),

   ALL_OBJECT_TWIN_FLAGS      = (STUB_FL_UNLINKED |
                                 STUB_FL_USED |
                                 STUB_FL_FILE_STAMP_VALID |
                                 STUB_FL_NOT_RECONCILED |
                                 STUB_FL_FROM_OBJECT_TWIN |
                                 STUB_FL_KEEP),

   ALL_TWIN_FAMILY_FLAGS      = (STUB_FL_UNLINKED |
                                 STUB_FL_USED |
                                 STUB_FL_BEING_DELETED |
                                 STUB_FL_DELETION_PENDING),

   ALL_FOLDER_TWIN_FLAGS      = (STUB_FL_UNLINKED |
                                 STUB_FL_USED |
                                 STUB_FL_BEING_DELETED |
                                 STUB_FL_BEING_TRANSLATED |
                                 STUB_FL_SUBTREE |
                                 STUB_FL_DELETION_PENDING),

   /* bit mask used to save stub flags in briefcase database */

   DB_STUB_FLAGS_MASK         = 0xff00
}
STUBFLAGS;

/*
 * common stub - These fields must appear at the start of TWINFAMILY,
 * OBJECTTWIN, and FOLDERPAIR in the same order.
 */

typedef struct _stub
{
   /* structure tag */

   STUBTYPE st;

   /* lock count */

   ULONG ulcLock;

   /* flags */

   DWORD dwFlags;
}
STUB;
DECLARE_STANDARD_TYPES(STUB);

/* object twin family */

typedef struct _twinfamily
{
   /* common stub */

   STUB stub;

   /* handle to name string */

   HSTRING hsName;

   /* handle to list of object twins */

   HLIST hlistObjectTwins;

   /* handle to parent briefcase */

   HBRFCASE hbr;
}
TWINFAMILY;
DECLARE_STANDARD_TYPES(TWINFAMILY);

/* object twin */

typedef struct _objecttwin
{
   /* common stub */

   STUB stub;

   /* handle to folder path */

   HPATH hpath;

   /* file stamp at last reconciliation time */

   FILESTAMP fsLastRec;

   /* pointer to parent twin family */

   PTWINFAMILY ptfParent;

   /* source folder twins count */

   ULONG ulcSrcFolderTwins;

   /*
    * current file stamp, only valid if STUB_FL_FILE_STAMP_VALID is set in
    * stub's flags
    */

   FILESTAMP fsCurrent;
}
OBJECTTWIN;
DECLARE_STANDARD_TYPES(OBJECTTWIN);

/* folder pair data */

typedef struct _folderpairdata
{
   /* handle to name of included objects - may contain wildcards */

   HSTRING hsName;

   /* attributes to match */

   DWORD dwAttributes;

   /* handle to parent briefcase */

   HBRFCASE hbr;
}
FOLDERPAIRDATA;
DECLARE_STANDARD_TYPES(FOLDERPAIRDATA);

/* folder pair */

typedef struct _folderpair
{
   /* common stub */

   STUB stub;

   /* handle to folder path */

   HPATH hpath;

   /* pointer to folder pair data */

   PFOLDERPAIRDATA pfpd;

   /* pointer to other half of folder pair */

   struct _folderpair *pfpOther;
}
FOLDERPAIR;
DECLARE_STANDARD_TYPES(FOLDERPAIR);

/*
 * EnumGeneratedObjectTwins() callback function
 *
 * Called as:
 *
 * bContinue = EnumGeneratedObjectTwinsProc(pot, pvRefData);
 */

typedef BOOL (*ENUMGENERATEDOBJECTTWINSPROC)(POBJECTTWIN, PVOID);

/*
 * EnumGeneratingFolderTwins() callback function
 *
 * Called as:
 *
 * bContinue = EnumGeneratingFolderTwinsProc(pfp, pvRefData);
 */

typedef BOOL (*ENUMGENERATINGFOLDERTWINSPROC)(PFOLDERPAIR, PVOID);


/* Prototypes
 *************/

/* stub.c */

extern void InitStub(PSTUB, STUBTYPE);
extern TWINRESULT DestroyStub(PSTUB);
extern void LockStub(PSTUB);
extern void UnlockStub(PSTUB);
extern DWORD GetStubFlags(PCSTUB);
extern void SetStubFlag(PSTUB, DWORD);
extern void ClearStubFlag(PSTUB, DWORD);
extern BOOL IsStubFlagSet(PCSTUB, DWORD);
extern BOOL IsStubFlagClear(PCSTUB, DWORD);

#ifdef VSTF

extern BOOL IsValidPCSTUB(PCSTUB);

#endif

/* twin.c */

extern BOOL FindObjectTwin(HBRFCASE, HPATH, LPCTSTR, PHNODE);
extern TWINRESULT TwinObjects(HBRFCASE, HCLSIFACECACHE, HPATH, HPATH, LPCTSTR, POBJECTTWIN *, POBJECTTWIN *);
extern BOOL CreateObjectTwin(PTWINFAMILY, HPATH, POBJECTTWIN *);
extern TWINRESULT UnlinkObjectTwin(POBJECTTWIN);
extern void DestroyObjectTwin(POBJECTTWIN);
extern TWINRESULT UnlinkTwinFamily(PTWINFAMILY);
extern void MarkTwinFamilyNeverReconciled(PTWINFAMILY);
extern void MarkObjectTwinNeverReconciled(PVOID);
extern void DestroyTwinFamily(PTWINFAMILY);
extern void MarkTwinFamilyDeletionPending(PTWINFAMILY);
extern void UnmarkTwinFamilyDeletionPending(PTWINFAMILY);
extern BOOL IsTwinFamilyDeletionPending(PCTWINFAMILY);
extern void ClearTwinFamilySrcFolderTwinCount(PTWINFAMILY);
extern BOOL EnumObjectTwins(HBRFCASE, ENUMGENERATEDOBJECTTWINSPROC, PVOID);
extern BOOL ApplyNewFolderTwinsToTwinFamilies(PCFOLDERPAIR);
extern TWINRESULT TransplantObjectTwin(POBJECTTWIN, HPATH, HPATH);
extern BOOL IsFolderObjectTwinName(LPCTSTR);


#ifdef VSTF

extern BOOL IsValidPCTWINFAMILY(PCTWINFAMILY);
extern BOOL IsValidPCOBJECTTWIN(PCOBJECTTWIN);

#endif

/* foldtwin.c */

extern void LockFolderPair(PFOLDERPAIR);
extern void UnlockFolderPair(PFOLDERPAIR);
extern TWINRESULT UnlinkFolderPair(PFOLDERPAIR);
extern void DestroyFolderPair(PFOLDERPAIR);
extern BOOL ApplyNewObjectTwinsToFolderTwins(HLIST);
extern BOOL BuildPathForMatchingObjectTwin(PCFOLDERPAIR, PCOBJECTTWIN, HPATHLIST, PHPATH);
extern BOOL EnumGeneratedObjectTwins(PCFOLDERPAIR, ENUMGENERATEDOBJECTTWINSPROC, PVOID);
extern BOOL EnumGeneratingFolderTwins(PCOBJECTTWIN, ENUMGENERATINGFOLDERTWINSPROC, PVOID, PULONG);
extern BOOL FolderTwinGeneratesObjectTwin(PCFOLDERPAIR, HPATH, LPCTSTR);

#ifdef VSTF

extern BOOL IsValidPCFOLDERPAIR(PCFOLDERPAIR);

#endif

extern void RemoveObjectTwinFromAllFolderPairs(POBJECTTWIN);

/* expandft.c */

extern BOOL ClearStubFlagWrapper(PSTUB, PVOID);
extern BOOL SetStubFlagWrapper(PSTUB, PVOID);
extern TWINRESULT ExpandIntersectingFolderTwins(PFOLDERPAIR, CREATERECLISTPROC, LPARAM);
extern TWINRESULT TryToGenerateObjectTwin(HBRFCASE, HPATH, LPCTSTR, PBOOL, POBJECTTWIN *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\subcycle.h ===
/*
 * subcycle.h - Subtree cycle detection routines description.
 */


/* Prototypes
 *************/

/* subcycle.c */

extern void BeginTranslateFolder(PFOLDERPAIR);
extern void EndTranslateFolder(PFOLDERPAIR);
extern TWINRESULT CheckForSubtreeCycles(HPTRARRAY, HPATH, HPATH, HSTRING);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\subcycle.c ===
/*
 * subcycle.c - Subtree cycle detection routines module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"
#include "subcycle.h"


/* Constants
 ************/

/* pointer array allocation constants */

#define NUM_CYCLE_PTRS_TO_ADD          (16)


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE TWINRESULT CheckHalfForSubtreeCycle(HPTRARRAY, HPATH, HPATH, LPCTSTR);


/*
** CheckHalfForSubtreeCycle()
**
** Checks to see if half of a proposed new folder subtree twin would create one
** or more cycles of folder subtree twins.
**
** Arguments:     hpaFolderPairs - handle to PTRARRAY containing pointers to
**                                 folder pairs
**                hpathStartFolder - root folder of initial half of proposed
**                                   new folder pair
**                hpathEndFolder - root folder of other half of proposed new
**                                 folder pair
**                pcszName - name specification of matching objects to be
**                           included in proposed new folder subtree pair
**
** Returns:       TWINRESULT
**
** Side Effects:  none
**
** N.b., this function should be called twice for each proposed new folder
** subtree pair.
*/
PRIVATE_CODE TWINRESULT CheckHalfForSubtreeCycle(HPTRARRAY hpaFolderPairs,
                                                 HPATH hpathStartFolder,
                                                 HPATH hpathEndFolder,
                                                 LPCTSTR pcszName)
{
   TWINRESULT tr;
   ARRAYINDEX aicFolderPairs;
   NEWPTRARRAY npa;
   HPTRARRAY hpaFolders;

   ASSERT(IS_VALID_HANDLE(hpaFolderPairs, PTRARRAY));
   ASSERT(IS_VALID_HANDLE(hpathStartFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hpathEndFolder, PATH));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));

   aicFolderPairs = GetPtrCount(hpaFolderPairs);

   /*
    * Try to create an unsorted pointer array to be used in checking for
    * cycles.
    */

   npa.aicInitialPtrs = aicFolderPairs;
   npa.aicAllocGranularity = NUM_CYCLE_PTRS_TO_ADD;
   npa.dwFlags = 0;

   if (CreatePtrArray(&npa, &hpaFolders))
   {
      ARRAYINDEX aicFolders;
      ARRAYINDEX aiCurFolder;
      HPATH hpathCurFolderRoot;

      /* Search all folder pairs connected to the first new folder twin. */

      /*
       * Mark all folder twins unused.  A "used" folder twin is one that has
       * already been visited while searching for subtree cycles.  I.e., a
       * used folder subtree pair half intersected the first folder of the
       * proposed new folder twin, and its other half was added to the list for
       * later comparison.
       */

      ClearFlagInArrayOfStubs(hpaFolderPairs, STUB_FL_USED);

      /*
       * Loop to process entire graph of folder subtree twins connected to the
       * first new folder twin.  Folder twins are only added to the hpaFolders
       * array if they don't already intersect the second of the two proposed
       * new folder subtree twins.
       */

      tr = TR_SUCCESS;
      aicFolders = 0;
      aiCurFolder = 0;

      /* Begin with start folder. */

      hpathCurFolderRoot = hpathStartFolder;

      FOREVER
      {
         ARRAYINDEX aiCheckFolderRoot;

         /*
          * Loop to find all subtree folder pairs that intersect
          * hpaFolders[aiCurFolder]'s subtree.
          */

         for (aiCheckFolderRoot = 0;
              aiCheckFolderRoot < aicFolderPairs;
              aiCheckFolderRoot++)
         {
            PFOLDERPAIR pfpCheck;

            /* Get this subtree folder pair's root folder. */

            pfpCheck = GetPtr(hpaFolderPairs, aiCheckFolderRoot);

            ASSERT(IS_VALID_STRUCT_PTR(pfpCheck, CFOLDERPAIR));

            /* Have we already visited this folder pair? */

            if (IsStubFlagSet(&(pfpCheck->stub), STUB_FL_SUBTREE) &&
                IsStubFlagClear(&(pfpCheck->stub), STUB_FL_BEING_TRANSLATED) &&
                IsStubFlagClear(&(pfpCheck->stub), STUB_FL_USED) &&
                IsStubFlagClear(&(pfpCheck->pfpOther->stub), STUB_FL_USED))
            {
               /*
                * No.  Does this subtree folder pair intersect the current
                * folder pair node's subtree, and the objects named in the
                * proposed new folder subtree twin?
                */

               ASSERT(IsStubFlagSet(&(pfpCheck->pfpOther->stub), STUB_FL_SUBTREE));
               ASSERT(IsStubFlagClear(&(pfpCheck->pfpOther->stub), STUB_FL_BEING_TRANSLATED));

               if (SubtreesIntersect(hpathCurFolderRoot, pfpCheck->hpath) &&
                   NamesIntersect(GetString(pfpCheck->pfpd->hsName), pcszName))
               {
                  HPATH hpathOtherCheckFolderRoot;

                  /* Yes.  Get the other side of the folder subtree pair. */

                  hpathOtherCheckFolderRoot = pfpCheck->pfpOther->hpath;

                  /*
                   * Does this pair connect back to the other side of the
                   * proposed new folder pair?
                   */

                  if (SubtreesIntersect(hpathOtherCheckFolderRoot,
                                        hpathEndFolder))
                  {
                     /*
                      * Yes.  Are the roots different parts of the common
                      * subtree?
                      */

                     if (ComparePaths(hpathEndFolder,
                                      hpathOtherCheckFolderRoot)
                         != CR_EQUAL)
                     {
                        /* Yes.  Found a cycle.  Bail out. */

                        WARNING_OUT((TEXT("CheckHalfForSubtreeCycle(): Subtree cycle found connecting folders %s and %s."),
                                     DebugGetPathString(hpathStartFolder),
                                     DebugGetPathString(hpathEndFolder)));

                        tr = TR_SUBTREE_CYCLE_FOUND;
                        break;
                     }

                     /*
                      * We don't need to include this root in the search if it
                      * is the same as the other side of the proposed new
                      * folder pair since it will be covered during the other
                      * call to CheckHalfForSubtreeCycle().
                      */
                  }
                  else
                  {
                     /* Add this subtree as another node to be examined. */

                     if (! InsertPtr(hpaFolders, NULL, aicFolders++,
                                     (PCVOID)(pfpCheck->pfpOther)))
                        tr = TR_OUT_OF_MEMORY;
                  }

                  /* Mark this folder twin as already visited. */

                  if (tr == TR_SUCCESS)
                     SetStubFlag(&(pfpCheck->stub), STUB_FL_USED);
                  else
                     break;
               }
            }
         }

         /* Any folder subtree twins left to investigate? */

         if (aiCurFolder < aicFolders)
         {
            PFOLDERPAIR pfpCur;

            /* Yes. */

            pfpCur = GetPtr(hpaFolders, aiCurFolder++);

            hpathCurFolderRoot = pfpCur->hpath;
         }
         else
            /* No. */
            break;
      }

      DestroyPtrArray(hpaFolders);
   }
   else
      tr = TR_OUT_OF_MEMORY;

   return(tr);
}


/****************************** Public Functions *****************************/


/*
** BeginTranslateFolder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void BeginTranslateFolder(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_BEING_TRANSLATED));
   ASSERT(IsStubFlagClear(&(pfp->pfpOther->stub), STUB_FL_BEING_TRANSLATED));

   SetStubFlag(&(pfp->stub), STUB_FL_BEING_TRANSLATED);
   SetStubFlag(&(pfp->pfpOther->stub), STUB_FL_BEING_TRANSLATED);

   return;
}


/*
** EndTranslateFolder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void EndTranslateFolder(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   ASSERT(IsStubFlagSet(&(pfp->stub), STUB_FL_BEING_TRANSLATED));
   ASSERT(IsStubFlagSet(&(pfp->pfpOther->stub), STUB_FL_BEING_TRANSLATED));

   ClearStubFlag(&(pfp->stub), STUB_FL_BEING_TRANSLATED);
   ClearStubFlag(&(pfp->pfpOther->stub), STUB_FL_BEING_TRANSLATED);

   return;
}


/*
** CheckForSubtreeCycles()
**
** Checks to see if a proposed new folder subtree twin would create one or more
** cycles of folder subtree twins.
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
**
** N.b., TR_SUBTREE_CYCLE_FOUND is returned if the folder subtree roots of the
** proposed new folder subtree twin are the same.
*/
PUBLIC_CODE TWINRESULT CheckForSubtreeCycles(HPTRARRAY hpaFolderPairs,
                                             HPATH hpathFirstFolder,
                                             HPATH hpathSecondFolder,
                                             HSTRING hsName)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hpaFolderPairs, PTRARRAY));
   ASSERT(IS_VALID_HANDLE(hpathFirstFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hpathSecondFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hsName, STRING));

   /* Are the folder twins cyclical on their own? */

   if (SubtreesIntersect(hpathFirstFolder, hpathSecondFolder))
   {
      /* Yes. */

      tr = TR_SUBTREE_CYCLE_FOUND;

      WARNING_OUT((TEXT("CheckForSubtreeCycles(): Subtree cycle found connecting folders %s and %s."),
                   DebugGetPathString(hpathFirstFolder),
                   DebugGetPathString(hpathSecondFolder)));
   }
   else
   {
      LPCTSTR pcszName;

      /* No.  Check for any indirect subtree cycle.  */

      pcszName = GetString(hsName);

      tr = CheckHalfForSubtreeCycle(hpaFolderPairs, hpathFirstFolder,
                                    hpathSecondFolder, pcszName);

      if (tr == TR_SUCCESS)
         tr = CheckHalfForSubtreeCycle(hpaFolderPairs, hpathSecondFolder,
                                       hpathFirstFolder, pcszName);
   }

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\twin.c ===
/*
 * twin.c - Twin ADT module.
 */

/*



 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"
#include "oleutil.h"


/* Constants
 ************/

/* twin family pointer array allocation constants */

#define NUM_START_TWIN_FAMILY_PTRS        (16)
#define NUM_TWIN_FAMILY_PTRS_TO_ADD       (16)


/* Types
 ********/

/* twin families database structure header */

typedef struct _twinfamiliesdbheader
{
    /* number of twin families */

    LONG lcTwinFamilies;
}
TWINFAMILIESDBHEADER;
DECLARE_STANDARD_TYPES(TWINFAMILIESDBHEADER);

/* individual twin family database structure header */

typedef struct _twinfamilydbheader
{
    /* stub flags */

    DWORD dwStubFlags;

    /* old string handle of name */

    HSTRING hsName;

    /* number of object twins in family */

    LONG lcObjectTwins;
}
TWINFAMILYDBHEADER;
DECLARE_STANDARD_TYPES(TWINFAMILYDBHEADER);

/* object twin database structure */

typedef struct _dbobjecttwin
{
    /* stub flags */

    DWORD dwStubFlags;

    /* old handle to folder string */

    HPATH hpath;

    /* time stamp at last reconciliation */

    FILESTAMP fsLastRec;
}
DBOBJECTTWIN;
DECLARE_STANDARD_TYPES(DBOBJECTTWIN);

/* GenerateSpinOffObjectTwin() callback structure */

typedef struct _spinoffobjecttwininfo
{
    PCFOLDERPAIR pcfp;

    HLIST hlistNewObjectTwins;
}
SPINOFFOBJECTTWININFO;
DECLARE_STANDARD_TYPES(SPINOFFOBJECTTWININFO);

typedef void (CALLBACK *COPYOBJECTTWINPROC)(POBJECTTWIN, PCDBOBJECTTWIN);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE TWINRESULT TwinJustTheseTwoObjects(HBRFCASE, HPATH, HPATH, LPCTSTR, POBJECTTWIN *, POBJECTTWIN *, HLIST);
PRIVATE_CODE BOOL CreateTwinFamily(HBRFCASE, LPCTSTR, PTWINFAMILY *);
PRIVATE_CODE void CollapseTwinFamilies(PTWINFAMILY, PTWINFAMILY);
PRIVATE_CODE BOOL GenerateSpinOffObjectTwin(PVOID, PVOID);
PRIVATE_CODE BOOL BuildBradyBunch(PVOID, PVOID);
PRIVATE_CODE BOOL CreateObjectTwinAndAddToList(PTWINFAMILY, HPATH, HLIST, POBJECTTWIN *, PHNODE);
PRIVATE_CODE BOOL CreateListOfGeneratedObjectTwins(PCFOLDERPAIR, PHLIST);
PRIVATE_CODE void NotifyNewObjectTwins(HLIST, HCLSIFACECACHE);
PRIVATE_CODE HRESULT NotifyOneNewObjectTwin(PINotifyReplica, PCOBJECTTWIN, LPCTSTR);
PRIVATE_CODE HRESULT CreateOtherReplicaMonikers(PCOBJECTTWIN, PULONG, PIMoniker **);
PRIVATE_CODE COMPARISONRESULT TwinFamilySortCmp(PCVOID, PCVOID);
PRIVATE_CODE COMPARISONRESULT TwinFamilySearchCmp(PCVOID, PCVOID);
PRIVATE_CODE BOOL ObjectTwinSearchCmp(PCVOID, PCVOID);
PRIVATE_CODE TWINRESULT WriteTwinFamily(HCACHEDFILE, PCTWINFAMILY);
PRIVATE_CODE TWINRESULT WriteObjectTwin(HCACHEDFILE, PCOBJECTTWIN);
PRIVATE_CODE TWINRESULT ReadTwinFamily(HCACHEDFILE, HBRFCASE, PCDBVERSION, HHANDLETRANS, HHANDLETRANS);
PRIVATE_CODE TWINRESULT ReadObjectTwin(HCACHEDFILE, PCDBVERSION, PTWINFAMILY, HHANDLETRANS);
PRIVATE_CODE void CopyTwinFamilyInfo(PTWINFAMILY, PCTWINFAMILYDBHEADER);
PRIVATE_CODE void CopyObjectTwinInfo(POBJECTTWIN, PCDBOBJECTTWIN);
PRIVATE_CODE void CopyM8ObjectTwinInfo(POBJECTTWIN, PCDBOBJECTTWIN);
PRIVATE_CODE BOOL DestroyObjectTwinStubWalker(PVOID, PVOID);
PRIVATE_CODE BOOL MarkObjectTwinNeverReconciledWalker(PVOID, PVOID);
PRIVATE_CODE BOOL LookForSrcFolderTwinsWalker(PVOID, PVOID);
PRIVATE_CODE BOOL IncrementSrcFolderTwinsWalker(PVOID, PVOID);
PRIVATE_CODE BOOL ClearSrcFolderTwinsWalker(PVOID, PVOID);
PRIVATE_CODE BOOL SetTwinFamilyWalker(PVOID, PVOID);
PRIVATE_CODE BOOL InsertNodeAtFrontWalker(POBJECTTWIN, PVOID);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidObjectTwinWalker(PVOID, PVOID);
PRIVATE_CODE BOOL IsValidPCNEWOBJECTTWIN(PCNEWOBJECTTWIN);
PRIVATE_CODE BOOL IsValidPCSPINOFFOBJECTTWININFO(PCSPINOFFOBJECTTWININFO);

#endif

#ifdef DEBUG

PRIVATE_CODE BOOL AreTwinFamiliesValid(HPTRARRAY);

#endif


/*
 ** TwinJustTheseTwoObjects()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT TwinJustTheseTwoObjects(HBRFCASE hbr, HPATH hpathFolder1,
        HPATH hpathFolder2, LPCTSTR pcszName,
        POBJECTTWIN *ppot1,
        POBJECTTWIN *ppot2,
        HLIST hlistNewObjectTwins)
{
    TWINRESULT tr = TR_OUT_OF_MEMORY;
    HNODE hnodeSearch;
    BOOL bFound1;
    BOOL bFound2;

    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
    ASSERT(IS_VALID_HANDLE(hpathFolder1, PATH));
    ASSERT(IS_VALID_HANDLE(hpathFolder2, PATH));
    ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(ppot1, POBJECTTWIN));
    ASSERT(IS_VALID_WRITE_PTR(ppot2, POBJECTTWIN));
    ASSERT(IS_VALID_HANDLE(hlistNewObjectTwins, LIST));

    /* Determine twin families of existing object twins. */

    bFound1 = FindObjectTwin(hbr, hpathFolder1, pcszName, &hnodeSearch);

    if (bFound1)
        *ppot1 = (POBJECTTWIN)GetNodeData(hnodeSearch);

    bFound2 = FindObjectTwin(hbr, hpathFolder2, pcszName, &hnodeSearch);

    if (bFound2)
        *ppot2 = (POBJECTTWIN)GetNodeData(hnodeSearch);

    /* Take action based upon existence of two object twins. */

    if (! bFound1 && ! bFound2)
    {
        PTWINFAMILY ptfNew;

        /* Neither object is already present.  Create a new twin family. */

        if (CreateTwinFamily(hbr, pcszName, &ptfNew))
        {
            HNODE hnodeNew1;

            if (CreateObjectTwinAndAddToList(ptfNew, hpathFolder1,
                        hlistNewObjectTwins, ppot1,
                        &hnodeNew1))
            {
                HNODE hnodeNew2;

                if (CreateObjectTwinAndAddToList(ptfNew, hpathFolder2,
                            hlistNewObjectTwins, ppot2,
                            &hnodeNew2))
                {
                    TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Created a twin family for object %s in folders %s and %s."),
                                pcszName,
                                DebugGetPathString(hpathFolder1),
                                DebugGetPathString(hpathFolder2)));

                    ASSERT(IsStubFlagClear(&(ptfNew->stub), STUB_FL_DELETION_PENDING));

                    tr = TR_SUCCESS;
                }
                else
                {
                    DeleteNode(hnodeNew1);
                    DestroyStub(&((*ppot1)->stub));
TWINJUSTTHESETWOOBJECTS_BAIL:
                    DestroyStub(&(ptfNew->stub));
                }
            }
            else
                goto TWINJUSTTHESETWOOBJECTS_BAIL;
        }
    }
    else if (bFound1 && bFound2)
    {
        /*
         * Both objects are already present.  Are they members of the same twin
         * family?
         */

        if ((*ppot1)->ptfParent == (*ppot2)->ptfParent)
        {
            /* Yes, same twin family.  Complain that these twins already exist. */

            TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Object %s is already twinned in folders %s and %s."),
                        pcszName,
                        DebugGetPathString(hpathFolder1),
                        DebugGetPathString(hpathFolder2)));

            tr = TR_DUPLICATE_TWIN;
        }
        else
        {
            /*
             * No, different twin families.  Collapse the two families.
             *
             * "That's the way they became the Brady bunch..."
             *
             * *ppot1 and *ppot2 remain valid across this call.
             */

            TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Collapsing separate twin families for object %s in folders %s and %s."),
                        pcszName,
                        DebugGetPathString(hpathFolder1),
                        DebugGetPathString(hpathFolder2)));

            CollapseTwinFamilies((*ppot1)->ptfParent, (*ppot2)->ptfParent);

            tr = TR_SUCCESS;
        }
    }
    else
    {
        PTWINFAMILY ptfParent;
        HNODE hnodeUnused;

        /*
         * Only one of the two objects is present.  Add the new object twin
         * to the existing object twin's family.
         */

        if (bFound1)
        {
            /* First object is already a twin. */

            ptfParent = (*ppot1)->ptfParent;

            if (CreateObjectTwinAndAddToList(ptfParent, hpathFolder2,
                        hlistNewObjectTwins, ppot2,
                        &hnodeUnused))
            {
                TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Adding twin of object %s\\%s to existing twin family including %s\\%s."),
                            DebugGetPathString(hpathFolder2),
                            pcszName,
                            DebugGetPathString(hpathFolder1),
                            pcszName));

                tr = TR_SUCCESS;
            }
        }
        else
        {
            /* Second object is already a twin. */

            ptfParent = (*ppot2)->ptfParent;

            if (CreateObjectTwinAndAddToList(ptfParent, hpathFolder1,
                        hlistNewObjectTwins, ppot1,
                        &hnodeUnused))
            {
                TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Adding twin of object %s\\%s to existing twin family including %s\\%s."),
                            DebugGetPathString(hpathFolder1),
                            pcszName,
                            DebugGetPathString(hpathFolder2),
                            pcszName));

                tr = TR_SUCCESS;
            }
        }
    }

    ASSERT((tr != TR_SUCCESS && tr != TR_DUPLICATE_TWIN) ||
            IS_VALID_STRUCT_PTR(*ppot1, COBJECTTWIN) && IS_VALID_STRUCT_PTR(*ppot2, COBJECTTWIN));

    return(tr);
}


/*
 ** CreateTwinFamily()
 **
 ** Creates a new empty twin family, and adds it to a briefcase.
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CreateTwinFamily(HBRFCASE hbr, LPCTSTR pcszName, PTWINFAMILY *pptf)
{
    BOOL bResult = FALSE;
    PTWINFAMILY ptfNew;

    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
    ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(pptf, PTWINFAMILY));

    /* Try to create a new TWINFAMILY structure. */

    if (AllocateMemory(sizeof(*ptfNew), &ptfNew))
    {
        NEWLIST nl;
        HLIST hlistObjectTwins;

        /* Create a list of object twins for the new twin family. */

        nl.dwFlags = 0;

        if (CreateList(&nl, &hlistObjectTwins))
        {
            HSTRING hsName;

            /* Add the object name to the name string table. */

            if (AddString(pcszName, GetBriefcaseNameStringTable(hbr), 
                        GetHashBucketIndex, &hsName))
            {
                ARRAYINDEX aiUnused;

                /* Fill in TWINFAMILY fields. */

                InitStub(&(ptfNew->stub), ST_TWINFAMILY);

                ptfNew->hsName = hsName;
                ptfNew->hlistObjectTwins = hlistObjectTwins;
                ptfNew->hbr = hbr;

                MarkTwinFamilyNeverReconciled(ptfNew);

                /* Add the twin family to the briefcase's list of twin families. */

                if (AddPtr(GetBriefcaseTwinFamilyPtrArray(hbr), TwinFamilySortCmp, ptfNew, &aiUnused))
                {
                    *pptf = ptfNew;
                    bResult = TRUE;

                    ASSERT(IS_VALID_STRUCT_PTR(*pptf, CTWINFAMILY));
                }
                else
                {
                    DeleteString(hsName);
CREATETWINFAMILY_BAIL1:
                    DestroyList(hlistObjectTwins);
CREATETWINFAMILY_BAIL2:
                    FreeMemory(ptfNew);
                }
            }
            else
                goto CREATETWINFAMILY_BAIL1;
        }
        else
            goto CREATETWINFAMILY_BAIL2;
    }

    return(bResult);
}


/*
 ** CollapseTwinFamilies()
 **
 ** Collapses two twin families into one.  N.b., this function should only be
 ** called on two twin families with the same object name!
 **
 ** Arguments:     ptf1 - pointer to destination twin family
 **                ptf2 - pointer to source twin family
 **
 ** Returns:       void
 **
 ** Side Effects:  Twin family *ptf2 is destroyed.
 */
PRIVATE_CODE void CollapseTwinFamilies(PTWINFAMILY ptf1, PTWINFAMILY ptf2)
{
    ASSERT(IS_VALID_STRUCT_PTR(ptf1, CTWINFAMILY));
    ASSERT(IS_VALID_STRUCT_PTR(ptf2, CTWINFAMILY));

    ASSERT(CompareNameStringsByHandle(ptf1->hsName, ptf2->hsName) == CR_EQUAL);

    /* Use the first twin family as the collapsed twin family. */

    /*
     * Change the parent twin family of the object twins in the second twin
     * family to the first twin family.
     */

    EVAL(WalkList(ptf2->hlistObjectTwins, &SetTwinFamilyWalker, ptf1));

    /* Append object list from second twin family on to first. */

    AppendList(ptf1->hlistObjectTwins, ptf2->hlistObjectTwins);

    MarkTwinFamilyNeverReconciled(ptf1);

    /* Wipe out the old twin family. */

    DestroyStub(&(ptf2->stub));

    ASSERT(IS_VALID_STRUCT_PTR(ptf1, CTWINFAMILY));

    return;
}


/*
 ** GenerateSpinOffObjectTwin()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL GenerateSpinOffObjectTwin(PVOID pot, PVOID pcsooti)
{
    BOOL bResult;
    HPATH hpathMatchingFolder;
    HNODE hnodeUnused;

    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
    ASSERT(IS_VALID_STRUCT_PTR(pcsooti, CSPINOFFOBJECTTWININFO));

    /*
     * Append the generated object twin's subpath to the matching folder twin's
     * base path for subtree twins.
     */

    if (BuildPathForMatchingObjectTwin(
                ((PCSPINOFFOBJECTTWININFO)pcsooti)->pcfp, pot,
                GetBriefcasePathList(((POBJECTTWIN)pot)->ptfParent->hbr),
                &hpathMatchingFolder))
    {
        /*
         * Does this generated object twin's twin family already contain an
         * object twin generated by the other half of the pair of folder twins?
         */

        if (! SearchUnsortedList(((POBJECTTWIN)pot)->ptfParent->hlistObjectTwins,
                    &ObjectTwinSearchCmp, hpathMatchingFolder,
                    &hnodeUnused))
        {
            /*
             * No.  Does the other object twin already exist in a different twin
             * family?
             */

            if (FindObjectTwin(((POBJECTTWIN)pot)->ptfParent->hbr,
                        hpathMatchingFolder,
                        GetString(((POBJECTTWIN)pot)->ptfParent->hsName),
                        &hnodeUnused))
            {
                /* Yes. */

                ASSERT(((PCOBJECTTWIN)GetNodeData(hnodeUnused))->ptfParent != ((POBJECTTWIN)pot)->ptfParent);

                bResult = TRUE;
            }
            else
            {
                POBJECTTWIN potNew;

                /*
                 * No.  Create a new object twin, and add it to the bookkeeping
                 * list of new object twins.
                 */

                bResult = CreateObjectTwinAndAddToList(
                        ((POBJECTTWIN)pot)->ptfParent, hpathMatchingFolder,
                        ((PCSPINOFFOBJECTTWININFO)pcsooti)->hlistNewObjectTwins,
                        &potNew, &hnodeUnused);

#ifdef DEBUG

                if (bResult)
                {
                    TRACE_OUT((TEXT("GenerateSpinOffObjectTwin(): Generated spin-off object twin for object %s\\%s."),
                                DebugGetPathString(potNew->hpath),
                                GetString(potNew->ptfParent->hsName)));
                }

#endif

            }
        }
        else
            bResult = TRUE;

        DeletePath(hpathMatchingFolder);
    }
    else
        bResult = FALSE;

    return(bResult);
}


/*
 ** BuildBradyBunch()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL BuildBradyBunch(PVOID pot, PVOID pcfp)
{
    BOOL bResult;
    HPATH hpathMatchingFolder;
    HNODE hnodeOther;

    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
    ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));

    /*
     * Append the generated object twin's subpath to the matching folder twin's
     * base path for subtree twins.
     */

    bResult = BuildPathForMatchingObjectTwin(
            pcfp, pot,
            GetBriefcasePathList(((POBJECTTWIN)pot)->ptfParent->hbr),
            &hpathMatchingFolder);

    if (bResult)
    {
        /*
         * Does this generated object twin's twin family already contain an object
         * twin generated by the other half of the pair of folder twins?
         */

        if (! SearchUnsortedList(((POBJECTTWIN)pot)->ptfParent->hlistObjectTwins,
                    &ObjectTwinSearchCmp, hpathMatchingFolder,
                    &hnodeOther))
        {
            /*
             * The other object twin should already exist in a different twin family.
             */

            if (EVAL(FindObjectTwin(((POBJECTTWIN)pot)->ptfParent->hbr,
                            hpathMatchingFolder,
                            GetString(((POBJECTTWIN)pot)->ptfParent->hsName),
                            &hnodeOther)))
            {
                PCOBJECTTWIN pcotOther;

                pcotOther = (PCOBJECTTWIN)GetNodeData(hnodeOther);

                if (EVAL(pcotOther->ptfParent != ((POBJECTTWIN)pot)->ptfParent))
                {
                    /* It does.  Crush them. */

                    CollapseTwinFamilies(((POBJECTTWIN)pot)->ptfParent,
                            pcotOther->ptfParent);

                    TRACE_OUT((TEXT("BuildBradyBunch(): Collapsed separate twin families for object %s\\%s and %s\\%s."),
                                DebugGetPathString(((POBJECTTWIN)pot)->hpath),
                                GetString(((POBJECTTWIN)pot)->ptfParent->hsName),
                                DebugGetPathString(pcotOther->hpath),
                                GetString(pcotOther->ptfParent->hsName)));
                }
            }
        }

        DeletePath(hpathMatchingFolder);
    }

    return(bResult);
}


/*
 ** CreateObjectTwinAndAddToList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CreateObjectTwinAndAddToList(PTWINFAMILY ptf, HPATH hpathFolder,
        HLIST hlistObjectTwins,
        POBJECTTWIN *ppot, PHNODE phnode)
{
    BOOL bResult = FALSE;

    ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));
    ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
    ASSERT(IS_VALID_HANDLE(hlistObjectTwins, LIST));
    ASSERT(IS_VALID_WRITE_PTR(ppot, POBJECTTWIN));
    ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

    if (CreateObjectTwin(ptf, hpathFolder, ppot))
    {
        if (InsertNodeAtFront(hlistObjectTwins, NULL, *ppot, phnode))
            bResult = TRUE;
        else
            DestroyStub(&((*ppot)->stub));
    }

    return(bResult);
}


/*
 ** CreateListOfGeneratedObjectTwins()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CreateListOfGeneratedObjectTwins(PCFOLDERPAIR pcfp,
        PHLIST phlistGeneratedObjectTwins)
{
    NEWLIST nl;
    BOOL bResult = FALSE;

    ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
    ASSERT(IS_VALID_WRITE_PTR(phlistGeneratedObjectTwins, HLIST));

    nl.dwFlags = 0;

    if (CreateList(&nl, phlistGeneratedObjectTwins))
    {
        if (EnumGeneratedObjectTwins(pcfp, &InsertNodeAtFrontWalker, *phlistGeneratedObjectTwins))
            bResult = TRUE;
        else
            DestroyList(*phlistGeneratedObjectTwins);
    }

    return(bResult);
}


/*
 ** NotifyNewObjectTwins()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void NotifyNewObjectTwins(HLIST hlistNewObjectTwins,
        HCLSIFACECACHE hcic)
{
    BOOL bContinue;
    HNODE hnode;

    ASSERT(IS_VALID_HANDLE(hlistNewObjectTwins, LIST));
    ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));

    for (bContinue = GetFirstNode(hlistNewObjectTwins, &hnode);
            bContinue;
            bContinue = GetNextNode(hnode, &hnode))
    {
        PCOBJECTTWIN pcot;
        TCHAR rgchPath[MAX_PATH_LEN];
        CLSID clsidReplicaNotification;

        pcot = (PCOBJECTTWIN)GetNodeData(hnode);

        rgchPath[0] = TEXT('\0');
        GetPathString(pcot->hpath, rgchPath, ARRAYSIZE(rgchPath));
        CatPath(rgchPath, GetString(pcot->ptfParent->hsName), ARRAYSIZE(rgchPath));
        ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

        if (SUCCEEDED(GetReplicaNotificationClassID(rgchPath,
                        &clsidReplicaNotification)))
        {
            PINotifyReplica pinr;

            if (SUCCEEDED(GetClassInterface(hcic, &clsidReplicaNotification,
                            &IID_INotifyReplica, &pinr)))
                /* Ignore return value. */
                NotifyOneNewObjectTwin(pinr, pcot, rgchPath);
            else
                TRACE_OUT((TEXT("NotifyNewObjectTwins(): Failed to get INotifyReplica for replica %s."),
                            rgchPath));
        }
        else
            TRACE_OUT((TEXT("NotifyNewObjectTwins(): Failed to get replica notification class ID for replica %s."),
                        rgchPath));
    }

    return;
}


/*
 ** NotifyOneNewObjectTwin()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE HRESULT NotifyOneNewObjectTwin(PINotifyReplica pinr, PCOBJECTTWIN pcot,
        LPCTSTR pcszPath)
{
    HRESULT hr;
    HSTGIFACE hstgi;

    ASSERT(IS_VALID_STRUCT_PTR(pinr, CINotifyReplica));
    ASSERT(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN));
    ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));

    hr = GetStorageInterface((PIUnknown)pinr, &hstgi);

    if (SUCCEEDED(hr))
    {
        hr = LoadFromStorage(hstgi, pcszPath);

        if (SUCCEEDED(hr))
        {
            ULONG ulcOtherReplicas;
            PIMoniker *ppimkOtherReplicas;

            /*
             * RAIDRAID: (16270) (Performance) We may create a file moniker for
             * the same object twin multiple times here.
             */

            hr = CreateOtherReplicaMonikers(pcot, &ulcOtherReplicas,
                    &ppimkOtherReplicas);

            if (SUCCEEDED(hr))
            {
                hr = pinr->lpVtbl->YouAreAReplica(pinr, ulcOtherReplicas,
                        ppimkOtherReplicas);

                if (SUCCEEDED(hr))
                {
                    hr = SaveToStorage(hstgi);

                    if (SUCCEEDED(hr))
                        TRACE_OUT((TEXT("NotifyOneNewObjectTwin(): Replica %s successfully notified."),
                                    pcszPath));
                    else
                        WARNING_OUT((TEXT("NotifyOneNewObjectTwin(): Failed to save replica %s to storage."),
                                    pcszPath));
                }
                else
                    WARNING_OUT((TEXT("NotifyOneNewObjectTwin(): Failed to notify replica %s."),
                                pcszPath));

                ReleaseIUnknowns(ulcOtherReplicas,
                        (PIUnknown *)ppimkOtherReplicas);
            }
            else
                WARNING_OUT((TEXT("NotifyOneNewObjectTwin(): Failed to create monikers for other replicas of replica %s."),
                            pcszPath));
        }
        else
            WARNING_OUT((TEXT("NotifyOneNewObjectTwin(): Failed to load replica %s from storage."),
                        pcszPath));

        ReleaseStorageInterface(hstgi);
    }
    else
        WARNING_OUT((TEXT("NotifyOneNewObjectTwin(): Failed to get storage interface for replica %s."),
                    pcszPath));

    return(hr);
}


/*
 ** CreateOtherReplicaMonikers()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE HRESULT CreateOtherReplicaMonikers(PCOBJECTTWIN pcotMaster,
        PULONG pulcOtherReplicas,
        PIMoniker **pppimk)
{
    HRESULT hr;
    HLIST hlist;
    ULONG ulcOtherReplicas;

    ASSERT(IS_VALID_STRUCT_PTR(pcotMaster, COBJECTTWIN));
    ASSERT(IS_VALID_WRITE_PTR(pulcOtherReplicas, ULONG));
    ASSERT(IS_VALID_WRITE_PTR(pppimk, PIMoniker *));

    hlist = pcotMaster->ptfParent->hlistObjectTwins;

    ulcOtherReplicas = GetNodeCount(hlist);
    ASSERT(ulcOtherReplicas > 0);
    ulcOtherReplicas--;

    if (AllocateMemory(ulcOtherReplicas * sizeof(**pppimk), (PVOID *)pppimk))
    {
        BOOL bContinue;
        HNODE hnode;

        hr = S_OK;
        *pulcOtherReplicas = 0;

        for (bContinue = GetFirstNode(hlist, &hnode);
                bContinue;
                bContinue = GetNextNode(hnode, &hnode))
        {
            PCOBJECTTWIN pcot;

            pcot = (PCOBJECTTWIN)GetNodeData(hnode);

            if (pcot != pcotMaster)
            {
                TCHAR rgchPath[MAX_PATH_LEN];

                rgchPath[0] = TEXT('\0');
                GetPathString(pcot->hpath, rgchPath, ARRAYSIZE(rgchPath));

                hr = MyCreateFileMoniker(rgchPath,
                        GetString(pcot->ptfParent->hsName),
                        &((*pppimk)[*pulcOtherReplicas]));

                if (SUCCEEDED(hr))
                {
                    ASSERT(*pulcOtherReplicas < ulcOtherReplicas);
                    (*pulcOtherReplicas)++;
                }
                else
                    break;
            }
        }

        if (FAILED(hr))
            ReleaseIUnknowns(*pulcOtherReplicas, *(PIUnknown **)pppimk);
    }
    else
        hr = E_OUTOFMEMORY;

    return(hr);
}


/*
 ** TwinFamilySortCmp()
 **
 ** Pointer comparison function used to sort the global array of twin families.
 **
 ** Arguments:     pctf1 - pointer to TWINFAMILY describing first twin family
 **                pctf2 - pointer to TWINFAMILY describing second twin family
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** Twin families are sorted by:
 **    1) name string
 **    2) pointer value
 */
PRIVATE_CODE COMPARISONRESULT TwinFamilySortCmp(PCVOID pctf1, PCVOID pctf2)
{
    COMPARISONRESULT cr;

    ASSERT(IS_VALID_STRUCT_PTR(pctf1, CTWINFAMILY));
    ASSERT(IS_VALID_STRUCT_PTR(pctf2, CTWINFAMILY));

    cr = CompareNameStringsByHandle(((PCTWINFAMILY)pctf1)->hsName, ((PCTWINFAMILY)pctf2)->hsName);

    if (cr == CR_EQUAL)
        /* Same name strings.  Now sort by pointer value. */
        cr = ComparePointers(pctf1, pctf2);

    return(cr);
}


/*
 ** TwinFamilySearchCmp()
 **
 ** Pointer comparison function used to search the global array of twin families
 ** for the first twin family for a given name.
 **
 ** Arguments:     pcszName - name string to search for
 **                pctf - pointer to TWINFAMILY to examine
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** Twin families are searched by:
 **    1) name string
 */
PRIVATE_CODE COMPARISONRESULT TwinFamilySearchCmp(PCVOID pcszName, PCVOID pctf)
{
    ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
    ASSERT(IS_VALID_STRUCT_PTR(pctf, CTWINFAMILY));

    return(CompareNameStrings(pcszName, GetString(((PCTWINFAMILY)pctf)->hsName)));
}


/*
 ** ObjectTwinSearchCmp()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL ObjectTwinSearchCmp(PCVOID hpath, PCVOID pcot)
{
    ASSERT(IS_VALID_HANDLE((HPATH)hpath, PATH));
    ASSERT(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN));

    return(ComparePaths((HPATH)hpath, ((PCOBJECTTWIN)pcot)->hpath));
}


/*
 ** WriteTwinFamily()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT WriteTwinFamily(HCACHEDFILE hcf, PCTWINFAMILY pctf)
{
    TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
    DWORD dwcbTwinFamilyDBHeaderOffset;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_STRUCT_PTR(pctf, CTWINFAMILY));

    /* Save initial file poisition. */

    dwcbTwinFamilyDBHeaderOffset = GetCachedFilePointerPosition(hcf);

    if (dwcbTwinFamilyDBHeaderOffset != INVALID_SEEK_POSITION)
    {
        TWINFAMILYDBHEADER tfdbh;

        /* Leave space for the twin family's header. */

        ZeroMemory(&tfdbh, sizeof(tfdbh));

        if (WriteToCachedFile(hcf, (PCVOID)&tfdbh, sizeof(tfdbh), NULL))
        {
            BOOL bContinue;
            HNODE hnode;
            LONG lcObjectTwins = 0;

            /* Save twin family's object twins. */

            ASSERT(GetNodeCount(pctf->hlistObjectTwins) >= 2);

            tr = TR_SUCCESS;

            for (bContinue = GetFirstNode(pctf->hlistObjectTwins, &hnode);
                    bContinue;
                    bContinue = GetNextNode(hnode, &hnode))
            {
                POBJECTTWIN pot;

                pot = (POBJECTTWIN)GetNodeData(hnode);

                tr = WriteObjectTwin(hcf, pot);

                if (tr == TR_SUCCESS)
                {
                    ASSERT(lcObjectTwins < LONG_MAX);
                    lcObjectTwins++;
                }
                else
                    break;
            }

            /* Save twin family's database header. */

            if (tr == TR_SUCCESS)
            {
                ASSERT(lcObjectTwins >= 2);

                tfdbh.dwStubFlags = (pctf->stub.dwFlags & DB_STUB_FLAGS_MASK);
                tfdbh.hsName = pctf->hsName;
                tfdbh.lcObjectTwins = lcObjectTwins;

                tr = WriteDBSegmentHeader(hcf, dwcbTwinFamilyDBHeaderOffset, &tfdbh, sizeof(tfdbh));
            }
        }
    }

    return(tr);
}


/*
 ** WriteObjectTwin()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT WriteObjectTwin(HCACHEDFILE hcf, PCOBJECTTWIN pcot)
{
    TWINRESULT tr;
    DBOBJECTTWIN dbot;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN));

    /* Set up object twin database structure. */

    dbot.dwStubFlags = (pcot->stub.dwFlags & DB_STUB_FLAGS_MASK);
    dbot.hpath = pcot->hpath;
    dbot.hpath = pcot->hpath;
    dbot.fsLastRec = pcot->fsLastRec;

    /* Save object twin database structure. */

    if (WriteToCachedFile(hcf, (PCVOID)&dbot, sizeof(dbot), NULL))
        tr = TR_SUCCESS;
    else
        tr = TR_BRIEFCASE_WRITE_FAILED;

    return(tr);
}


/*
 ** ReadTwinFamily()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT ReadTwinFamily(HCACHEDFILE hcf, HBRFCASE hbr,
        PCDBVERSION pcdbver,
        HHANDLETRANS hhtFolderTrans,
        HHANDLETRANS hhtNameTrans)
{
    TWINRESULT tr = TR_CORRUPT_BRIEFCASE;
    TWINFAMILYDBHEADER tfdbh;
    DWORD dwcbRead;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
    ASSERT(IS_VALID_READ_PTR(pcdbver, DBVERSION));
    ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));
    ASSERT(IS_VALID_HANDLE(hhtNameTrans, HANDLETRANS));

    if (ReadFromCachedFile(hcf, &tfdbh, sizeof(tfdbh), &dwcbRead) &&
            dwcbRead == sizeof(tfdbh))
    {
        if (tfdbh.lcObjectTwins >= 2)
        {
            HSTRING hsName;

            if (TranslateHandle(hhtNameTrans, (HGENERIC)(tfdbh.hsName), (PHGENERIC)&hsName))
            {
                PTWINFAMILY ptfParent;

                if (CreateTwinFamily(hbr, GetString(hsName), &ptfParent))
                {
                    LONG l;

                    CopyTwinFamilyInfo(ptfParent, &tfdbh);

                    tr = TR_SUCCESS;

                    for (l = tfdbh.lcObjectTwins;
                            l > 0 && tr == TR_SUCCESS;
                            l--)
                        tr = ReadObjectTwin(hcf, pcdbver, ptfParent, hhtFolderTrans);

                    if (tr != TR_SUCCESS)
                        DestroyStub(&(ptfParent->stub));
                }
                else
                    tr = TR_OUT_OF_MEMORY;
            }
        }
    }

    return(tr);
}


/*
 ** ReadObjectTwin()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT ReadObjectTwin(HCACHEDFILE hcf, 
        PCDBVERSION pcdbver,
        PTWINFAMILY ptfParent,
        HHANDLETRANS hhtFolderTrans)
{
    TWINRESULT tr;
    DBOBJECTTWIN dbot;
    DWORD dwcbRead;
    HPATH hpath;
    DWORD dwcbSize;
    COPYOBJECTTWINPROC pfnCopy;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_READ_PTR(pcdbver, DBVERSION));
    ASSERT(IS_VALID_STRUCT_PTR(ptfParent, CTWINFAMILY));
    ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));

    if (HEADER_M8_MINOR_VER == pcdbver->dwMinorVer)
    {
        /* The M8 database does not have the ftModLocal in the FILESTAMP
         ** structure.
         */

        dwcbSize = sizeof(dbot) - sizeof(FILETIME);
        pfnCopy = CopyM8ObjectTwinInfo;
    }
    else
    {
        ASSERT(HEADER_MINOR_VER == pcdbver->dwMinorVer);
        dwcbSize = sizeof(dbot);
        pfnCopy = CopyObjectTwinInfo;
    }

    if ((ReadFromCachedFile(hcf, &dbot, dwcbSize, &dwcbRead) &&
                dwcbRead == dwcbSize) &&
            TranslateHandle(hhtFolderTrans, (HGENERIC)(dbot.hpath), (PHGENERIC)&hpath))
    {
        POBJECTTWIN pot;

        /* Create the new object twin and add it to the twin family. */

        if (CreateObjectTwin(ptfParent, hpath, &pot))
        {
            pfnCopy(pot, &dbot);

            tr = TR_SUCCESS;
        }
        else
            tr = TR_OUT_OF_MEMORY;
    }
    else
        tr = TR_CORRUPT_BRIEFCASE;

    return(tr);
}


/*
 ** CopyTwinFamilyInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void CopyTwinFamilyInfo(PTWINFAMILY ptf,
        PCTWINFAMILYDBHEADER pctfdbh)
{
    ASSERT(IS_VALID_WRITE_PTR(ptf, TWINFAMILY));
    ASSERT(IS_VALID_READ_PTR(pctfdbh, CTWINFAMILYDBHEADER));

    ptf->stub.dwFlags = pctfdbh->dwStubFlags;

    return;
}


/*
 ** CopyObjectTwinInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void CopyObjectTwinInfo(POBJECTTWIN pot, PCDBOBJECTTWIN pcdbot)
{
    ASSERT(IS_VALID_WRITE_PTR(pot, OBJECTTWIN));
    ASSERT(IS_VALID_READ_PTR(pcdbot, CDBOBJECTTWIN));

    pot->stub.dwFlags = pcdbot->dwStubFlags;
    pot->fsLastRec = pcdbot->fsLastRec;

    return;
}


/*
 ** CopyM8ObjectTwinInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void CopyM8ObjectTwinInfo(POBJECTTWIN pot, PCDBOBJECTTWIN pcdbot)
{
    ASSERT(IS_VALID_WRITE_PTR(pot, OBJECTTWIN));
    ASSERT(IS_VALID_READ_PTR(pcdbot, CDBOBJECTTWIN));

    pot->stub.dwFlags = pcdbot->dwStubFlags;
    pot->fsLastRec = pcdbot->fsLastRec;

    /* The pot->fsLastRec.ftModLocal field is invalid, so fill it in */

    if ( !FileTimeToLocalFileTime(&pot->fsLastRec.ftMod, &pot->fsLastRec.ftModLocal) )
    {
        /* Just copy the time if FileTimeToLocalFileTime failed */

        pot->fsLastRec.ftModLocal = pot->fsLastRec.ftMod;
    }

    return;
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
 ** DestroyObjectTwinStubWalker()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL DestroyObjectTwinStubWalker(PVOID pot, PVOID pvUnused)
{
    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
    ASSERT(! pvUnused);

    /*
     * Set ulcSrcFolderTwins to 0 so UnlinkObjectTwin() succeeds.
     * DestroyStub() will unlink and destroy any new twin family created.
     */

    ((POBJECTTWIN)pot)->ulcSrcFolderTwins = 0;
    DestroyStub(&(((POBJECTTWIN)pot)->stub));

    return(TRUE);
}


/*
 ** MarkObjectTwinNeverReconciledWalker()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL MarkObjectTwinNeverReconciledWalker(PVOID pot, PVOID pvUnused)
{
    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
    ASSERT(! pvUnused);

    MarkObjectTwinNeverReconciled(pot);

    return(TRUE);
}


/*
 ** LookForSrcFolderTwinsWalker()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL LookForSrcFolderTwinsWalker(PVOID pot, PVOID pvUnused)
{
    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
    ASSERT(! pvUnused);

    return(! ((POBJECTTWIN)pot)->ulcSrcFolderTwins);
}


/*
 ** IncrementSrcFolderTwinsWalker()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IncrementSrcFolderTwinsWalker(PVOID pot, PVOID pvUnused)
{
    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
    ASSERT(! pvUnused);

    ASSERT(((POBJECTTWIN)pot)->ulcSrcFolderTwins < ULONG_MAX);
    ((POBJECTTWIN)pot)->ulcSrcFolderTwins++;

    return(TRUE);
}


/*
 ** ClearSrcFolderTwinsWalker()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL ClearSrcFolderTwinsWalker(PVOID pot, PVOID pvUnused)
{
    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
    ASSERT(! pvUnused);

    ((POBJECTTWIN)pot)->ulcSrcFolderTwins = 0;

    return(TRUE);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
 ** SetTwinFamilyWalker()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL SetTwinFamilyWalker(PVOID pot, PVOID ptfParent)
{
    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
    ASSERT(IS_VALID_STRUCT_PTR(ptfParent, CTWINFAMILY));

    ((POBJECTTWIN)pot)->ptfParent = ptfParent;

    return(TRUE);
}


/*
 ** InsertNodeAtFrontWalker()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL InsertNodeAtFrontWalker(POBJECTTWIN pot, PVOID hlist)
{
    HNODE hnodeUnused;

    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
    ASSERT(IS_VALID_HANDLE(hlist, LIST));

    return(InsertNodeAtFront(hlist, NULL, pot, &hnodeUnused));
}


#ifdef VSTF

/*
 ** IsValidObjectTwinWalker()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidObjectTwinWalker(PVOID pcot, PVOID pctfParent)
{
    return(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN) &&
            EVAL(((PCOBJECTTWIN)pcot)->ptfParent == pctfParent) &&
            EVAL(IsStubFlagClear(&(((PCOBJECTTWIN)pcot)->stub), STUB_FL_KEEP) ||
                IsStubFlagSet(&(((PCTWINFAMILY)pctfParent)->stub),
                    STUB_FL_DELETION_PENDING)));
}


/*
 ** IsValidPCNEWOBJECTTWIN()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCNEWOBJECTTWIN(PCNEWOBJECTTWIN pcnot)
{
    return(IS_VALID_READ_PTR(pcnot, CNEWOBJECTTWIN) &&
            EVAL(pcnot->ulSize == sizeof(*pcnot)) &&
            IS_VALID_STRING_PTR(pcnot->pcszFolder1, CSTR) &&
            IS_VALID_STRING_PTR(pcnot->pcszFolder2, CSTR) &&
            IS_VALID_STRING_PTR(pcnot->pcszName, CSTR));
}


/*
 ** IsValidPCSPINOFFOBJECTTWININFO()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCSPINOFFOBJECTTWININFO(PCSPINOFFOBJECTTWININFO pcsooti)
{
    return(IS_VALID_READ_PTR(pcsooti, CSPINOFFOBJECTTWININFO) &&
            IS_VALID_STRUCT_PTR(pcsooti->pcfp, CFOLDERPAIR) &&
            IS_VALID_HANDLE(pcsooti->hlistNewObjectTwins, LIST));
}

#endif


#ifdef DEBUG

/*
 ** AreTwinFamiliesValid()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL AreTwinFamiliesValid(HPTRARRAY hpaTwinFamilies)
{
    ARRAYINDEX aicPtrs;
    ARRAYINDEX ai;

    ASSERT(IS_VALID_HANDLE(hpaTwinFamilies, PTRARRAY));

    aicPtrs = GetPtrCount(hpaTwinFamilies);

    for (ai = 0; ai < aicPtrs; ai++)
    {
        PCTWINFAMILY pctf;

        pctf = GetPtr(hpaTwinFamilies, ai);

        if (! IS_VALID_STRUCT_PTR(pctf, CTWINFAMILY) ||
                ! EVAL(GetNodeCount(pctf->hlistObjectTwins) >= 2))
            break;
    }

    return(ai == aicPtrs);
}

#endif


/****************************** Public Functions *****************************/


/*
 ** CompareNameStrings()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE COMPARISONRESULT CompareNameStrings(LPCTSTR pcszFirst, LPCTSTR pcszSecond)
{
    ASSERT(IS_VALID_STRING_PTR(pcszFirst, CSTR));
    ASSERT(IS_VALID_STRING_PTR(pcszSecond, CSTR));

    return(MapIntToComparisonResult(lstrcmpi(pcszFirst, pcszSecond)));
}


/*
 ** CompareNameStringsByHandle()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE COMPARISONRESULT CompareNameStringsByHandle(HSTRING hsFirst,
        HSTRING hsSecond)
{
    ASSERT(IS_VALID_HANDLE(hsFirst, STRING));
    ASSERT(IS_VALID_HANDLE(hsSecond, STRING));

    return(CompareStringsI(hsFirst, hsSecond));
}


/*
 ** TranslatePATHRESULTToTWINRESULT()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT TranslatePATHRESULTToTWINRESULT(PATHRESULT pr)
{
    TWINRESULT tr;

    switch (pr)
    {
        case PR_SUCCESS:
            tr = TR_SUCCESS;
            break;

        case PR_UNAVAILABLE_VOLUME:
            tr = TR_UNAVAILABLE_VOLUME;
            break;

        case PR_OUT_OF_MEMORY:
            tr = TR_OUT_OF_MEMORY;
            break;

        default:
            ASSERT(pr == PR_INVALID_PATH);
            tr = TR_INVALID_PARAMETER;
            break;
    }

    return(tr);
}


/*
 ** CreateTwinFamilyPtrArray()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL CreateTwinFamilyPtrArray(PHPTRARRAY phpa)
{
    NEWPTRARRAY npa;

    ASSERT(IS_VALID_WRITE_PTR(phpa, HPTRARRAY));

    /* Try to create a twin family pointer array. */

    npa.aicInitialPtrs = NUM_START_TWIN_FAMILY_PTRS;
    npa.aicAllocGranularity = NUM_TWIN_FAMILY_PTRS_TO_ADD;
    npa.dwFlags = NPA_FL_SORTED_ADD;

    return(CreatePtrArray(&npa, phpa));
}


/*
 ** DestroyTwinFamilyPtrArray()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DestroyTwinFamilyPtrArray(HPTRARRAY hpa)
{
    ARRAYINDEX aicPtrs;
    ARRAYINDEX ai;

    ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

    /* First free all twin families in pointer array. */

    aicPtrs = GetPtrCount(hpa);

    for (ai = 0; ai < aicPtrs; ai++)
        DestroyTwinFamily(GetPtr(hpa, ai));

    /* Now wipe out the pointer array. */

    DestroyPtrArray(hpa);

    return;
}


/*
 ** GetTwinBriefcase()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HBRFCASE GetTwinBriefcase(HTWIN htwin)
{
    HBRFCASE hbr;

    ASSERT(IS_VALID_HANDLE(htwin, TWIN));

    switch (((PSTUB)htwin)->st)
    {
        case ST_OBJECTTWIN:
            hbr = ((PCOBJECTTWIN)htwin)->ptfParent->hbr;
            break;

        case ST_TWINFAMILY:
            hbr = ((PCTWINFAMILY)htwin)->hbr;
            break;

        case ST_FOLDERPAIR:
            hbr = ((PCFOLDERPAIR)htwin)->pfpd->hbr;
            break;

        default:
            ERROR_OUT((TEXT("GetTwinBriefcase() called on unrecognized stub type %d."),
                        ((PSTUB)htwin)->st));
            hbr = NULL;
            break;
    }

    return(hbr);
}


/*
 ** FindObjectTwinInList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL FindObjectTwinInList(HLIST hlist, HPATH hpath, PHNODE phnode)
{
    ASSERT(IS_VALID_HANDLE(hlist, LIST));
    ASSERT(IS_VALID_HANDLE(hpath, PATH));
    ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

    return(SearchUnsortedList(hlist, &ObjectTwinSearchCmp, hpath, phnode));
}


/*
 ** EnumTwins()
 **
 ** Enumerates folder twins and twin families in a briefcase.
 **
 ** Arguments:
 **
 ** Returns:       TRUE if halted.  FALSE if not.
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL EnumTwins(HBRFCASE hbr, ENUMTWINSPROC etp, LPARAM lpData,
        PHTWIN phtwinStop)
{
    HPTRARRAY hpa;
    ARRAYINDEX aicPtrs;
    ARRAYINDEX ai;

    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
    ASSERT(IS_VALID_CODE_PTR(etp, ENUMTWINSPROC));
    ASSERT(IS_VALID_WRITE_PTR(phtwinStop, HTWIN));

    /* Enumerate folder pairs. */

    *phtwinStop = NULL;

    hpa = GetBriefcaseFolderPairPtrArray(hbr);

    aicPtrs = GetPtrCount(hpa);

    for (ai = 0; ai < aicPtrs; ai++)
    {
        PCFOLDERPAIR pcfp;

        pcfp = GetPtr(hpa, ai);

        ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));

        if (! (*etp)((HTWIN)pcfp, lpData))
        {
            *phtwinStop = (HTWIN)pcfp;
            break;
        }
    }

    if (! *phtwinStop)
    {
        /* Enumerate twin families. */

        hpa = GetBriefcaseTwinFamilyPtrArray(hbr);

        aicPtrs = GetPtrCount(hpa);

        for (ai = 0; ai < aicPtrs; ai++)
        {
            PCTWINFAMILY pctf;

            pctf = GetPtr(hpa, ai);

            ASSERT(IS_VALID_STRUCT_PTR(pctf, CTWINFAMILY));

            if (! (*etp)((HTWIN)pctf, lpData))
            {
                *phtwinStop = (HTWIN)pctf;
                break;
            }
        }
    }

    return(*phtwinStop != NULL);
}


/*
 ** FindObjectTwin()
 **
 ** Looks for a twin family containing a specified object twin.
 **
 ** Arguments:     hpathFolder - folder containing object
 **                pcszName - name of object
 **
 ** Returns:       Handle to list node containing pointer to object twin if
 **                found, or NULL if not found.
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL FindObjectTwin(HBRFCASE hbr, HPATH hpathFolder,
        LPCTSTR pcszName, PHNODE phnode)
{
    BOOL bFound = FALSE;
    HPTRARRAY hpaTwinFamilies;
    ARRAYINDEX aiFirst;

    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
    ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
    ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

    /* Search for a matching twin family. */

    *phnode = NULL;

    hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(hbr);

    if (SearchSortedArray(hpaTwinFamilies, &TwinFamilySearchCmp, pcszName,
                &aiFirst))
    {
        ARRAYINDEX aicPtrs;
        ARRAYINDEX ai;
        PTWINFAMILY ptf;

        /*
         * aiFirst holds the index of the first twin family with a common object
         * name matching pcszName.
         */

        /*
         * Now search each of these twin families for a folder matching
         * pcszFolder.
         */

        aicPtrs = GetPtrCount(hpaTwinFamilies);

        ASSERT(aicPtrs > 0);
        ASSERT(aiFirst >= 0);
        ASSERT(aiFirst < aicPtrs);

        for (ai = aiFirst; ai < aicPtrs; ai++)
        {
            ptf = GetPtr(hpaTwinFamilies, ai);

            ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

            /* Is this a twin family of objects of the given name? */

            if (CompareNameStrings(GetString(ptf->hsName), pcszName) == CR_EQUAL)
            {
                bFound = SearchUnsortedList(ptf->hlistObjectTwins,
                        &ObjectTwinSearchCmp, hpathFolder,
                        phnode);

                if (bFound)
                    break;
            }
            else
                /* No.  Stop searching. */
                break;
        }
    }

    return(bFound);
}


/*
 ** TwinObjects()
 **
 ** Twins two objects.
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 **
 ** N.b., *ppot1 and *ppot2 are valid if TR_SUCCESS or TR_DUPLICATE_TWIN is
 ** returned.
 */
PUBLIC_CODE TWINRESULT TwinObjects(HBRFCASE hbr, HCLSIFACECACHE hcic,
        HPATH hpathFolder1, HPATH hpathFolder2,
        LPCTSTR pcszName, POBJECTTWIN *ppot1,
        POBJECTTWIN *ppot2)
{
    TWINRESULT tr;

    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
    ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));
    ASSERT(IS_VALID_HANDLE(hpathFolder1, PATH));
    ASSERT(IS_VALID_HANDLE(hpathFolder2, PATH));
    ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(ppot1, POBJECTTWIN));
    ASSERT(IS_VALID_WRITE_PTR(ppot2, POBJECTTWIN));

    /* Fail twinning a file to itself. */

    if (ComparePaths(hpathFolder1, hpathFolder2) != CR_EQUAL)
    {
        NEWLIST nl;
        HLIST hlistNewObjectTwins;

        nl.dwFlags = 0;

        if (CreateList(&nl, &hlistNewObjectTwins))
        {
            /* Twin 'em. */

            tr = TwinJustTheseTwoObjects(hbr, hpathFolder1, hpathFolder2,
                    pcszName, ppot1, ppot2,
                    hlistNewObjectTwins);

            /*
             * Add any new object twins to the lists of generated object twins for
             * all intersecting folder twins.  Create new spin-off object twins
             * from the other folder twin connected to each intersecting folder
             * twin.  Spin-off object twins are added to the twin family as they
             * are created.
             */

            if (tr == TR_SUCCESS)
            {
                if (ApplyNewObjectTwinsToFolderTwins(hlistNewObjectTwins))
                {
                    /*
                     * Notify new object twins that they are object twins.  Don't
                     * notify folder object twins.
                     */

                    if (*pcszName)
                        NotifyNewObjectTwins(hlistNewObjectTwins, hcic);
                }
                else
                    tr = TR_OUT_OF_MEMORY;
            }

            if (tr != TR_SUCCESS)
                /*
                 * We must maintain a consistent internal state by deleting any new
                 * twin family and object twins on failure, independent of source
                 * folder twin count.
                 */
                EVAL(WalkList(hlistNewObjectTwins, &DestroyObjectTwinStubWalker,
                            NULL));

            DestroyList(hlistNewObjectTwins);
        }
        else
            tr = TR_OUT_OF_MEMORY;
    }
    else
        tr = TR_SAME_FOLDER;

    ASSERT((tr != TR_SUCCESS && tr != TR_DUPLICATE_TWIN) ||
            IS_VALID_STRUCT_PTR(*ppot1, COBJECTTWIN) && IS_VALID_STRUCT_PTR(*ppot2, COBJECTTWIN));

    return(tr);
}


/*
 ** CreateObjectTwin()
 **
 ** Creates a new object twin, and adds it to a twin family.
 **
 ** Arguments:     ptf - pointer to parent twin family
 **                hpathFolder - folder of new object twin
 **
 ** Returns:       Pointer to new object twin if successful, or NULL if
 **                unsuccessful.
 **
 ** Side Effects:  none
 **
 ** N.b., this function does not first check to see if the object twin already
 ** exists in the family.
 */
PUBLIC_CODE BOOL CreateObjectTwin(PTWINFAMILY ptf, HPATH hpathFolder,
        POBJECTTWIN *ppot)
{
    BOOL bResult = FALSE;
    POBJECTTWIN potNew;

    ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));
    ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
    ASSERT(IS_VALID_WRITE_PTR(ppot, POBJECTTWIN));

#ifdef DEBUG

    {
        HNODE hnodeUnused;

        /* Is this object twin already in a twin family? */

        if (FindObjectTwin(ptf->hbr, hpathFolder, GetString(ptf->hsName), &hnodeUnused))
            ERROR_OUT((TEXT("CreateObjectTwin(): An object twin for %s\\%s already exists."),
                        DebugGetPathString(hpathFolder),
                        GetString(ptf->hsName)));
    }

#endif

    /* Create a new OBJECTTWIN structure. */

    if (AllocateMemory(sizeof(*potNew), &potNew))
    {
        if (CopyPath(hpathFolder, GetBriefcasePathList(ptf->hbr), &(potNew->hpath)))
        {
            HNODE hnodeUnused;

            /* Fill in new OBJECTTWIN fields. */

            InitStub(&(potNew->stub), ST_OBJECTTWIN);

            potNew->ptfParent = ptf;
            potNew->ulcSrcFolderTwins = 0;

            MarkObjectTwinNeverReconciled(potNew);

            /* Add the object twin to the twin family's list of object twins. */

            if (InsertNodeAtFront(ptf->hlistObjectTwins, NULL, potNew, &hnodeUnused))
            {
                *ppot = potNew;
                bResult = TRUE;

                ASSERT(IS_VALID_STRUCT_PTR(*ppot, COBJECTTWIN));
            }
            else
            {
                DeletePath(potNew->hpath);
CREATEOBJECTTWIN_BAIL:
                FreeMemory(potNew);
            }
        }
        else
            goto CREATEOBJECTTWIN_BAIL;
    }

    return(bResult);
}


/*
 ** UnlinkObjectTwin()
 **
 ** Unlinks an object twin.
 **
 ** Arguments:     pot - pointer to object twin to unlink
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT UnlinkObjectTwin(POBJECTTWIN pot)
{
    TWINRESULT tr;

    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));

    ASSERT(IsStubFlagClear(&(pot->stub), STUB_FL_UNLINKED));

    TRACE_OUT((TEXT("UnlinkObjectTwin(): Unlinking object twin for folder %s."),
                DebugGetPathString(pot->hpath)));

    /* Is the object twin's twin family being deleted? */

    if (IsStubFlagSet(&(pot->ptfParent->stub), STUB_FL_BEING_DELETED))
        /* Yes.  No need to unlink the object twin. */
        tr = TR_SUCCESS;
    else
    {
        /* Are there any folder twin sources left for this object twin? */

        if (! pot->ulcSrcFolderTwins)
        {
            HNODE hnode;

            /*
             * Search the object twin's parent's list of object twins for the
             * object twin to be unlinked.
             */

            if (EVAL(FindObjectTwinInList(pot->ptfParent->hlistObjectTwins, pot->hpath, &hnode)) &&
                    EVAL(GetNodeData(hnode) == pot))
            {
                ULONG ulcRemainingObjectTwins;

                /* Unlink the object twin. */

                DeleteNode(hnode);

                SetStubFlag(&(pot->stub), STUB_FL_UNLINKED);

                /*
                 * If we have just unlinked the second last object twin in a twin
                 * family, destroy the twin family.
                 */

                ulcRemainingObjectTwins = GetNodeCount(pot->ptfParent->hlistObjectTwins);

                if (ulcRemainingObjectTwins < 2)
                {

#ifdef DEBUG

                    TCHAR rgchName[MAX_NAME_LEN];

                    lstrcpyn(rgchName, GetString(pot->ptfParent->hsName), ARRAYSIZE(rgchName));

#endif

                    /* It's the end of the family line. */

                    tr = DestroyStub(&(pot->ptfParent->stub));

#ifdef DEBUG

                    if (tr == TR_SUCCESS)
                        TRACE_OUT((TEXT("UnlinkObjectTwin(): Implicitly destroyed twin family for object %s."),
                                    rgchName));

#endif

                    if (ulcRemainingObjectTwins == 1 &&
                            tr == TR_HAS_FOLDER_TWIN_SRC)
                        tr = TR_SUCCESS;
                }
                else
                    tr = TR_SUCCESS;
            }
            else
                tr = TR_INVALID_PARAMETER;

            ASSERT(tr == TR_SUCCESS);
        }
        else
            tr = TR_HAS_FOLDER_TWIN_SRC;
    }

    return(tr);
}


/*
 ** DestroyObjectTwin()
 **
 ** Destroys an object twin.
 **
 ** Arguments:     pot - pointer to object twin to destroy
 **
 ** Returns:       void
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DestroyObjectTwin(POBJECTTWIN pot)
{
    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));

    TRACE_OUT((TEXT("DestroyObjectTwin(): Destroying object twin for folder %s."),
                DebugGetPathString(pot->hpath)));

    DeletePath(pot->hpath);
    FreeMemory(pot);

    return;
}


/*
 ** UnlinkTwinFamily()
 **
 ** Unlinks a twin family.
 **
 ** Arguments:     ptf - pointer to twin family to unlink
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT UnlinkTwinFamily(PTWINFAMILY ptf)
{
    TWINRESULT tr;

    ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

    ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED));
    ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_BEING_DELETED));

    /*
     * A twin family containing object twins generated by folder twins may not
     * be deleted, since those object twins may not be directly deleted.
     */

    if (WalkList(ptf->hlistObjectTwins, &LookForSrcFolderTwinsWalker, NULL))
    {
        HPTRARRAY hpaTwinFamilies;
        ARRAYINDEX aiUnlink;

        TRACE_OUT((TEXT("UnlinkTwinFamily(): Unlinking twin family for object %s."),
                    GetString(ptf->hsName)));

        /* Search for the twin family to be unlinked. */

        hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(ptf->hbr);

        if (EVAL(SearchSortedArray(hpaTwinFamilies, &TwinFamilySortCmp, ptf,
                        &aiUnlink)))
        {
            /* Unlink the twin family. */

            ASSERT(GetPtr(hpaTwinFamilies, aiUnlink) == ptf);

            DeletePtr(hpaTwinFamilies, aiUnlink);

            SetStubFlag(&(ptf->stub), STUB_FL_UNLINKED);
        }

        tr = TR_SUCCESS;
    }
    else
        tr = TR_HAS_FOLDER_TWIN_SRC;

    return(tr);
}


/*
 ** DestroyTwinFamily()
 **
 ** Destroys a twin family.
 **
 ** Arguments:     ptf - pointer to twin family to destroy
 **
 ** Returns:       void
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DestroyTwinFamily(PTWINFAMILY ptf)
{
    ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

    ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_BEING_DELETED));

    TRACE_OUT((TEXT("DestroyTwinFamily(): Destroying twin family for object %s."),
                GetString(ptf->hsName)));

    SetStubFlag(&(ptf->stub), STUB_FL_BEING_DELETED);

    /*
     * Destroy the object twins in the family one by one.  Be careful not to use
     * an object twin after it has been destroyed.
     */

    EVAL(WalkList(ptf->hlistObjectTwins, &DestroyObjectTwinStubWalker, NULL));

    /* Destroy TWINFAMILY fields. */

    DestroyList(ptf->hlistObjectTwins);
    DeleteString(ptf->hsName);
    FreeMemory(ptf);

    return;
}


/*
 ** MarkTwinFamilyNeverReconciled()
 **
 ** Marks a twin family as never reconciled.
 **
 ** Arguments:     ptf - pointer to twin family to be marked never reconciled
 **
 ** Returns:       void
 **
 ** Side Effects:  Clears the twin family's last reconciliation time stamp.
 **                Marks all the object twins in the family never reconciled.
 */
PUBLIC_CODE void MarkTwinFamilyNeverReconciled(PTWINFAMILY ptf)
{
    /*
     * If we're being called from CreateTwinFamily(), the fields we're about to
     * set may currently be invalid.  Don't fully verify the TWINFAMILY
     * structure.
     */

    ASSERT(IS_VALID_WRITE_PTR(ptf, TWINFAMILY));

    /* Mark all object twins in twin family as never reconciled. */

    EVAL(WalkList(ptf->hlistObjectTwins, MarkObjectTwinNeverReconciledWalker, NULL));

    return;
}


/*
 ** MarkObjectTwinNeverReconciled()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void MarkObjectTwinNeverReconciled(PVOID pot)
{
    /*
     * If we're being called from CreateObjectTwin(), the fields we're about to
     * set may currently be invalid.  Don't fully verify the OBJECTTWIN
     * structure.
     */

    ASSERT(IS_VALID_WRITE_PTR((PCOBJECTTWIN)pot, COBJECTTWIN));

    ASSERT(IsStubFlagClear(&(((PCOBJECTTWIN)pot)->stub), STUB_FL_NOT_RECONCILED));

    ZeroMemory(&(((POBJECTTWIN)pot)->fsLastRec),
            sizeof(((POBJECTTWIN)pot)->fsLastRec));

    ((POBJECTTWIN)pot)->fsLastRec.fscond = FS_COND_UNAVAILABLE;

    return;
}


/*
 ** MarkTwinFamilyDeletionPending()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void MarkTwinFamilyDeletionPending(PTWINFAMILY ptf)
{
    ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

    if (IsStubFlagClear(&(ptf->stub), STUB_FL_DELETION_PENDING))
        TRACE_OUT((TEXT("MarkTwinFamilyDeletionPending(): Deletion now pending for twin family for %s."),
                    GetString(ptf->hsName)));

    SetStubFlag(&(ptf->stub), STUB_FL_DELETION_PENDING);

    return;
}


/*
 ** UnmarkTwinFamilyDeletionPending()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void UnmarkTwinFamilyDeletionPending(PTWINFAMILY ptf)
{
    BOOL bContinue;
    HNODE hnode;

    ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

    if (IsStubFlagSet(&(ptf->stub), STUB_FL_DELETION_PENDING))
    {
        for (bContinue = GetFirstNode(ptf->hlistObjectTwins, &hnode);
                bContinue;
                bContinue = GetNextNode(hnode, &hnode))
        {
            POBJECTTWIN pot;

            pot = GetNodeData(hnode);

            ClearStubFlag(&(pot->stub), STUB_FL_KEEP);
        }

        ClearStubFlag(&(ptf->stub), STUB_FL_DELETION_PENDING);

        TRACE_OUT((TEXT("UnmarkTwinFamilyDeletionPending(): Deletion no longer pending for twin family for %s."),
                    GetString(ptf->hsName)));
    }

    return;
}


/*
 ** IsTwinFamilyDeletionPending()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsTwinFamilyDeletionPending(PCTWINFAMILY pctf)
{
    ASSERT(IS_VALID_STRUCT_PTR(pctf, CTWINFAMILY));

    return(IsStubFlagSet(&(pctf->stub), STUB_FL_DELETION_PENDING));
}


/*
 ** ClearTwinFamilySrcFolderTwinCount()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void ClearTwinFamilySrcFolderTwinCount(PTWINFAMILY ptf)
{
    ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

    EVAL(WalkList(ptf->hlistObjectTwins, &ClearSrcFolderTwinsWalker, NULL));

    return;
}


/*
 ** EnumObjectTwins()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL EnumObjectTwins(HBRFCASE hbr,
        ENUMGENERATEDOBJECTTWINSPROC egotp,
        PVOID pvRefData)
{
    BOOL bResult = TRUE;
    HPTRARRAY hpaTwinFamilies;
    ARRAYINDEX aicPtrs;
    ARRAYINDEX ai;

    /* pvRefData may be any value. */

    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
    ASSERT(IS_VALID_CODE_PTR(egotp, ENUMGENERATEDOBJECTTWINPROC));

    /* Walk the array of twin families. */

    hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(hbr);

    aicPtrs = GetPtrCount(hpaTwinFamilies);
    ai = 0;

    while (ai < aicPtrs)
    {
        PTWINFAMILY ptf;
        BOOL bContinue;
        HNODE hnodePrev;

        ptf = GetPtr(hpaTwinFamilies, ai);

        ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));
        ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED));

        /* Lock the twin family so it isn't deleted out from under us. */

        LockStub(&(ptf->stub));

        /*
         * Walk each twin family's list of object twins, calling the callback
         * function with each object twin.
         */

        bContinue = GetFirstNode(ptf->hlistObjectTwins, &hnodePrev);

        while (bContinue)
        {
            HNODE hnodeNext;
            POBJECTTWIN pot;

            bContinue = GetNextNode(hnodePrev, &hnodeNext);

            pot = (POBJECTTWIN)GetNodeData(hnodePrev);

            ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));

            bResult = (*egotp)(pot, pvRefData);

            if (! bResult)
                break;

            hnodePrev = hnodeNext;
        }

        /* Was the twin family unlinked? */

        if (IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED))
            /* No. */
            ai++;
        else
        {
            /* Yes. */
            aicPtrs--;
            ASSERT(aicPtrs == GetPtrCount(hpaTwinFamilies));
            TRACE_OUT((TEXT("EnumObjectTwins(): Twin family for object %s unlinked by callback."),
                        GetString(ptf->hsName)));
        }

        UnlockStub(&(ptf->stub));

        if (! bResult)
            break;
    }

    return(bResult);
}


/*
 ** ApplyNewFolderTwinsToTwinFamilies()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** If FALSE is returned, the array of twin families is in the same state it was
 ** in before ApplyNewFolderTwinsToTwinFamilies() was called.  No clean-up is
 ** required by the caller in case of failure.
 **
 ** This function collapses a pair of separate twin families when an object twin
 ** in one twin family intersects one of the folder twins in the pair of new
 ** folder twins and an object twin in the other twin family intersects the
 ** other folder twin in the pair of new folder twins.
 **
 ** This function generates a spinoff object twin when an existing object twin
 ** intersects one of the folder twins in the pair of new folder twins, and no
 ** corresponding object twin for the other folder twin in the pair of new
 ** folder twins exists in the briefcase.  The spinoff object twin is added to
 ** the generating object twin's twin family.  A spinoff object twins cannot
 ** cause any existing pairs of twin families to be collapsed because the
 ** spinoff object twin did not previously exist in a twin family.
 **
 ** A new folder twin may collapse pairs of existing twin families.  E.g.,
 ** consider the following scenario:
 **
 ** 1) Twin families (c:\, d:\, foo), (e:\, f:\, foo), (c:\, d:\, bar), and
 **    (e:\, f:\, bar) exist.
 ** 2) New folder twin (d:\, e:\, *.*) is added.
 ** 3) Twin families (c:\, d:\, foo) and (e:\, f:\, foo) must be collpased into
 **    a single twin family because of the (d:\, e:\, *.*) folder twin.
 ** 4) Twin families (c:\, d:\, bar) and (e:\, f:\, bar) must be collpased into
 **    a single twin family because of the (d:\, e:\, *.*) folder twin.
 **
 ** So we see that new folder twin (d:\, e:\, *.*) must collapse two pairs of
 ** existing twin families a single twin family each.  Twin family
 ** (c:\, d:\, foo) plus twin family (e:\, f:\, foo) becomes twin family
 ** (c:\, d:\, e:\, f:\, foo).  Twin family (c:\, d:\, bar) plus twin family
 ** (e:\, f:\, bar) becomes twin family (c:\, d:\, e:\, f:\, bar).
 */
PUBLIC_CODE BOOL ApplyNewFolderTwinsToTwinFamilies(PCFOLDERPAIR pcfp)
{
    BOOL bResult = FALSE;
    HLIST hlistGeneratedObjectTwins;

    ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));

    /*
     * Create lists to contain existing object twins generated by both folder
     * twins.
     */

    if (CreateListOfGeneratedObjectTwins(pcfp, &hlistGeneratedObjectTwins))
    {
        HLIST hlistOtherGeneratedObjectTwins;

        if (CreateListOfGeneratedObjectTwins(pcfp->pfpOther,
                    &hlistOtherGeneratedObjectTwins))
        {
            NEWLIST nl;
            HLIST hlistNewObjectTwins;

            /* Create list to contain spin-off object twins. */

            nl.dwFlags = 0;

            if (CreateList(&nl, &hlistNewObjectTwins))
            {
                SPINOFFOBJECTTWININFO sooti;

                /*
                 * Generate list of new object twins generated by new folder twins
                 * to seed ApplyNewObjectTwinToFolderTwins().
                 */

                sooti.pcfp = pcfp;
                sooti.hlistNewObjectTwins = hlistNewObjectTwins;

                if (WalkList(hlistGeneratedObjectTwins, &GenerateSpinOffObjectTwin,
                            &sooti))
                {
                    sooti.pcfp = pcfp->pfpOther;
                    ASSERT(sooti.hlistNewObjectTwins == hlistNewObjectTwins);

                    if (WalkList(hlistOtherGeneratedObjectTwins,
                                &GenerateSpinOffObjectTwin, &sooti))
                    {
                        /*
                         * ApplyNewObjectTwinsToFolderTwins() sets ulcSrcFolderTwins
                         * for all object twins in hlistNewObjectTwins.
                         */

                        if (ApplyNewObjectTwinsToFolderTwins(hlistNewObjectTwins))
                        {
                            /*
                             * Collapse separate twin families joined by new folder
                             * twin.
                             */

                            EVAL(WalkList(hlistGeneratedObjectTwins, &BuildBradyBunch,
                                        (PVOID)pcfp));

                            /*
                             * We don't need to call BuildBradyBunch() for
                             * pcfp->pfpOther and hlistOtherGeneratedObjectTwins since
                             * one twin family from each collapsed pair of twin
                             * families must come from each list of generated object
                             * twins.
                             */

                            /*
                             * Increment source folder twin count for all pre-existing
                             * object twins generated by the new folder twins.
                             */

                            EVAL(WalkList(hlistGeneratedObjectTwins,
                                        &IncrementSrcFolderTwinsWalker, NULL));
                            EVAL(WalkList(hlistOtherGeneratedObjectTwins,
                                        &IncrementSrcFolderTwinsWalker, NULL));

                            bResult = TRUE;
                        }
                    }
                }

                /* Wipe out any new object twins on failure. */

                if (! bResult)
                    EVAL(WalkList(hlistNewObjectTwins, &DestroyObjectTwinStubWalker,
                                NULL));

                DestroyList(hlistNewObjectTwins);
            }

            DestroyList(hlistOtherGeneratedObjectTwins);
        }

        DestroyList(hlistGeneratedObjectTwins);
    }

    return(bResult);
}


/*
 ** TransplantObjectTwin()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT TransplantObjectTwin(POBJECTTWIN pot,
        HPATH hpathOldFolder,
        HPATH hpathNewFolder)
{
    TWINRESULT tr;

    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
    ASSERT(IS_VALID_HANDLE(hpathOldFolder, PATH));
    ASSERT(IS_VALID_HANDLE(hpathNewFolder, PATH));

    /* Is this object twin rooted in the renamed folder's subtree? */

    if (IsPathPrefix(pot->hpath, hpathOldFolder))
    {
        TCHAR rgchPathSuffix[MAX_PATH_LEN];
        LPCTSTR pcszSubPath;
        HPATH hpathNew;

        /* Yes.  Change the object twin's root. */

        pcszSubPath = FindChildPathSuffix(hpathOldFolder, pot->hpath,
                rgchPathSuffix);

        if (AddChildPath(GetBriefcasePathList(pot->ptfParent->hbr),
                    hpathNewFolder, pcszSubPath, &hpathNew))
        {
            TRACE_OUT((TEXT("TransplantObjectTwin(): Transplanted object twin %s\\%s to %s\\%s."),
                        DebugGetPathString(pot->hpath),
                        GetString(pot->ptfParent->hsName),
                        DebugGetPathString(hpathNew),
                        GetString(pot->ptfParent->hsName)));

            DeletePath(pot->hpath);
            pot->hpath = hpathNew;

            tr = TR_SUCCESS;
        }
        else
            tr = TR_OUT_OF_MEMORY;
    }
    else
        tr = TR_SUCCESS;

    return(tr);
}


/*
 ** IsFolderObjectTwinName()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsFolderObjectTwinName(LPCTSTR pcszName)
{
    ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));

    return(! *pcszName);
}


/*
 ** IsValidHTWIN()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidHTWIN(HTWIN htwin)
{
    BOOL bValid = FALSE;

    if (IS_VALID_STRUCT_PTR((PCSTUB)htwin, CSTUB))
    {
        switch (((PSTUB)htwin)->st)
        {
            case ST_OBJECTTWIN:
                bValid = IS_VALID_HANDLE((HOBJECTTWIN)htwin, OBJECTTWIN);
                break;

            case ST_TWINFAMILY:
                bValid = IS_VALID_HANDLE((HTWINFAMILY)htwin, TWINFAMILY);
                break;

            case ST_FOLDERPAIR:
                bValid = IS_VALID_HANDLE((HFOLDERTWIN)htwin, FOLDERTWIN);
                break;

            default:
                ERROR_OUT((TEXT("IsValidHTWIN() called on unrecognized stub type %d."),
                            ((PSTUB)htwin)->st));
                break;
        }
    }
    else
        ERROR_OUT((TEXT("IsValidHTWIN() called on bad twin handle %#lx."),
                    htwin));

    return(bValid);
}


/*
 ** IsValidHTWINFAMILY()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidHTWINFAMILY(HTWINFAMILY htf)
{
    return(IS_VALID_STRUCT_PTR((PTWINFAMILY)htf, CTWINFAMILY));
}


/*
 ** IsValidHOBJECTTWIN()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidHOBJECTTWIN(HOBJECTTWIN hot)
{
    return(IS_VALID_STRUCT_PTR((POBJECTTWIN)hot, COBJECTTWIN));
}


#ifdef VSTF

/*
 ** IsValidPCTWINFAMILY()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidPCTWINFAMILY(PCTWINFAMILY pctf)
{
    BOOL bResult;

    /* All the fields of an unlinked twin family should be valid. */

    /* Don't validate hbr. */

    /*
     * In some cases there may be fewer than two object twins in a twin family,
     * e.g., when two twin families are being collapsed, when a twin family is
     * being deleted, and when a twin family is being read in from a database.
     */

    if (IS_VALID_READ_PTR(pctf, CTWINFAMILY) &&
            IS_VALID_STRUCT_PTR(&(pctf->stub), CSTUB) &&
            FLAGS_ARE_VALID(GetStubFlags(&(pctf->stub)), ALL_TWIN_FAMILY_FLAGS) &&
            IS_VALID_HANDLE(pctf->hsName, STRING) &&
            IS_VALID_HANDLE(pctf->hlistObjectTwins, LIST))
        bResult = WalkList(pctf->hlistObjectTwins, &IsValidObjectTwinWalker, (PVOID)pctf);
    else
        bResult = FALSE;

    return(bResult);
}


/*
 ** IsValidPCOBJECTTWIN()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidPCOBJECTTWIN(PCOBJECTTWIN pcot)
{
    /*
     * All the fields of an unlinked object twin should be valid, except
     * possibly ptfParent and fsCurrent.
     */

    /*
     *   Winner of the 1995 "I think the compiler generates better code
     *                       if its takes up less space on the screen" award.
     *
     *   Running up in the  "Make the debugger execute 2K of code as an
     *                       atomic operation while debugger" category.
     *
     */

    return(IS_VALID_READ_PTR(pcot, COBJECTTWIN) &&
            IS_VALID_STRUCT_PTR(&(pcot->stub), CSTUB) &&
            FLAGS_ARE_VALID(GetStubFlags(&(pcot->stub)), ALL_OBJECT_TWIN_FLAGS) &&
            IS_VALID_HANDLE(pcot->hpath, PATH) &&
            (IsStubFlagSet(&(pcot->stub), STUB_FL_UNLINKED) ||
             IS_VALID_READ_PTR(pcot->ptfParent, CTWINFAMILY)) &&
            IS_VALID_STRUCT_PTR(&(pcot->fsLastRec), CFILESTAMP) &&
            (IsStubFlagClear(&(pcot->stub), STUB_FL_FILE_STAMP_VALID) ||
             (IS_VALID_STRUCT_PTR(&(pcot->fsCurrent), CFILESTAMP))) &&
            EVAL(! (! IsReconciledFileStamp(&(pcot->fsLastRec)) &&
                    IsStubFlagSet(&(pcot->stub), STUB_FL_NOT_RECONCILED))));
}

#endif


/*
 ** WriteTwinFamilies()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT WriteTwinFamilies(HCACHEDFILE hcf, HPTRARRAY hpaTwinFamilies)
{
    TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
    DWORD dwcbTwinFamiliesDBHeaderOffset;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_HANDLE(hpaTwinFamilies, PTRARRAY));

    /* Save initial file poisition. */

    dwcbTwinFamiliesDBHeaderOffset = GetCachedFilePointerPosition(hcf);

    if (dwcbTwinFamiliesDBHeaderOffset != INVALID_SEEK_POSITION)
    {
        TWINFAMILIESDBHEADER tfdbh;

        /* Leave space for the twin families' header. */

        ZeroMemory(&tfdbh, sizeof(tfdbh));

        if (WriteToCachedFile(hcf, (PCVOID)&tfdbh, sizeof(tfdbh), NULL))
        {
            ARRAYINDEX aicPtrs;
            ARRAYINDEX ai;

            tr = TR_SUCCESS;

            aicPtrs = GetPtrCount(hpaTwinFamilies);

            for (ai = 0;
                    ai < aicPtrs && tr == TR_SUCCESS;
                    ai++)
                tr = WriteTwinFamily(hcf, GetPtr(hpaTwinFamilies, ai));

            if (tr == TR_SUCCESS)
            {
                /* Save twin families' header. */

                tfdbh.lcTwinFamilies = aicPtrs;

                tr = WriteDBSegmentHeader(hcf, dwcbTwinFamiliesDBHeaderOffset,
                        &tfdbh, sizeof(tfdbh));

                if (tr == TR_SUCCESS)
                    TRACE_OUT((TEXT("WriteTwinFamilies(): Wrote %ld twin families."),
                                tfdbh.lcTwinFamilies));
            }
        }
    }

    return(tr);
}


/*
 ** ReadTwinFamilies()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT ReadTwinFamilies(HCACHEDFILE hcf, HBRFCASE hbr,
        PCDBVERSION pcdbver,
        HHANDLETRANS hhtFolderTrans,
        HHANDLETRANS hhtNameTrans)
{
    TWINRESULT tr;
    TWINFAMILIESDBHEADER tfdbh;
    DWORD dwcbRead;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
    ASSERT(IS_VALID_READ_PTR(pcdbver, DBVERSION));
    ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));
    ASSERT(IS_VALID_HANDLE(hhtNameTrans, HANDLETRANS));

    if (ReadFromCachedFile(hcf, &tfdbh, sizeof(tfdbh), &dwcbRead) &&
            dwcbRead == sizeof(tfdbh))
    {
        LONG l;

        tr = TR_SUCCESS;

        TRACE_OUT((TEXT("ReadTwinFamilies(): Reading %ld twin families."),
                    tfdbh.lcTwinFamilies));

        for (l = 0;
                l < tfdbh.lcTwinFamilies && tr == TR_SUCCESS;
                l++)
            tr = ReadTwinFamily(hcf, hbr, pcdbver, hhtFolderTrans, hhtNameTrans);

        ASSERT(AreTwinFamiliesValid(GetBriefcaseTwinFamilyPtrArray(hbr)));
    }
    else
        tr = TR_CORRUPT_BRIEFCASE;

    return(tr);
}


/***************************** Exported Functions ****************************/


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | AddObjectTwin | Twins two objects.

  @parm HBRFCASE | hbr | A handle to the open briefcase that the new object twins
  are to be added to.

  @parm PCNEWOBJECTTWIN | pcnot | A pointer to a CNEWOBJECTTWIN describing the
  objects to be twinned.

  @parm PHTWINFAMILY | phtf | A pointer to an HTWINFAMILY to be filled in with
  a handle to the twin family to which the object twins were added.  This handle
  may refer to a new or existing twin family.  *phtf is only valid if TR_SUCCESS
  is returned.

  @rdesc If the objects were twinned successfully, TR_SUCCESS is returned, and
 *phTwinFamily contains a handle to the associated twin family.  Otherwise, the
 objects were not twinned successfully, the return value indicates the error
 that occurred, and *phtf is undefined.  If one or both of the volumes
 specified by the NEWOBJECTTWIN structure is not present, TR_UNAVAILABLE_VOLUME
 will be returned, and the object twin will not be added.

 @comm Once the caller is finshed with the twin handle returned by
 AddObjectTwin(), ReleaseTwinHandle() should be called to release the twin
 handle.  DeleteTwin() does not release a twin handle returned by
 AddObjectTwin().

 @xref ReleaseTwinHandle DeleteTwin

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI AddObjectTwin(HBRFCASE hbr, PCNEWOBJECTTWIN pcnot,
        PHTWINFAMILY phtf)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(AddObjectTwin);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hbr, BRFCASE) &&
                IS_VALID_STRUCT_PTR(pcnot, CNEWOBJECTTWIN) &&
                EVAL(pcnot->ulSize == sizeof(*pcnot)) &&
                IS_VALID_WRITE_PTR(phtf, HTWINFAMILY))
#endif
        {
            HCLSIFACECACHE hcic;

            if (CreateClassInterfaceCache(&hcic))
            {
                HPATHLIST hplBriefcase;
                HPATH hpathFolder1;

                InvalidatePathListInfo(GetBriefcasePathList(hbr));

                hplBriefcase = GetBriefcasePathList(hbr);

                tr = TranslatePATHRESULTToTWINRESULT(AddPath(hplBriefcase,
                            pcnot->pcszFolder1,
                            &hpathFolder1));

                if (tr == TR_SUCCESS)
                {
                    HPATH hpathFolder2;

                    tr = TranslatePATHRESULTToTWINRESULT(AddPath(hplBriefcase,
                                pcnot->pcszFolder2,
                                &hpathFolder2));

                    if (tr == TR_SUCCESS)
                    {
                        POBJECTTWIN pot1;
                        POBJECTTWIN pot2;

                        tr = TwinObjects(hbr, hcic, hpathFolder1, hpathFolder2,
                                pcnot->pcszName, &pot1, &pot2);

                        /*
                         * These twins are not really duplicates unless they were already
                         * connected as object twins.
                         */

                        if (tr == TR_DUPLICATE_TWIN &&
                                (IsStubFlagClear(&(pot1->stub), STUB_FL_FROM_OBJECT_TWIN) ||
                                 IsStubFlagClear(&(pot2->stub), STUB_FL_FROM_OBJECT_TWIN)))
                            tr = TR_SUCCESS;

                        if (tr == TR_SUCCESS)
                        {
                            /* Success! */

                            ASSERT(pot1->ptfParent == pot2->ptfParent);
                            ASSERT(IS_VALID_HANDLE((HTWINFAMILY)(pot1->ptfParent), TWINFAMILY));

                            LockStub(&(pot1->ptfParent->stub));

                            SetStubFlag(&(pot1->stub), STUB_FL_FROM_OBJECT_TWIN);
                            SetStubFlag(&(pot2->stub), STUB_FL_FROM_OBJECT_TWIN);

                            *phtf = (HTWINFAMILY)(pot1->ptfParent);
                        }

                        DeletePath(hpathFolder2);
                    }

                    DeletePath(hpathFolder1);
                }

                DestroyClassInterfaceCache(hcic);
            }
            else
                tr = TR_OUT_OF_MEMORY;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(AddObjectTwin, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | ReleaseTwinHandle | Releases a twin handle returned by
  AddObjectTwin(), AddFolderTwin(), or GetObjectTwinHandle().

  @parm HTWIN | hTwin | The twin handle that is to be released.

  @rdesc If the twin handle was released successfully, TR_SUCCESS is returned.
  Otherwise, the twin handle was not released successfully, and the return value
  indicates the error that occurred.  hTwin is no longer a valid twin handle
  after ReleaseTwinHandle() is called.

  @comm If the lock count of the twin drops to 0 and deletion is pending against
  the twin, the twin is deleted.  If ReleaseTwinHandle() is called with a valid
  handle to a twin that has been deleted, TR_SUCCESS will be returned.
  DeleteTwin() does not release a twin handle returned by AddObjectTwin(),
  AddFolderTwin(), or GetObjectTwinHandle().  ReleaseTwinHandle() should be
  called to release a twin handle returned by AddObjectTwin(), AddFolderTwin(),
  or GetObjectTwinHandle().  DeleteTwin() should be called before
  ReleaseTwinHandle() if the twin is to be deleted.

  @xref AddObjectTwin AddFolderTwin DeleteTwin

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI ReleaseTwinHandle(HTWIN hTwin)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(ReleaseTwinHandle);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hTwin, TWIN))
#endif
        {
            UnlockStub((PSTUB)hTwin);

            tr = TR_SUCCESS;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(ReleaseTwinHandle, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | DeleteTwin | Deletes a twin from the synchronization
  database.  A twin is added to the synchronization database by AddObjectTwin()
  or AddFolderTwin().

  @parm HTWIN | htwin | A handle to the twin being deleted.

  @rdesc If the twin was deleted successfully, TR_SUCCESS is returned.
  Otherwise, the twin was not deleted successfully, and the return value
  indicates the error that occurred.

  @comm If DeleteTwin() is called with a valid handle to a twin that has been
  deleted, TR_SUCCESS will be returned.  DeleteTwin() does not release a twin
  handle returned by AddObjectTwin(), AddFolderTwin(), or GetObjectTwinHandle().
  ReleaseTwinHandle() should be called to release a twin handle returned by
  AddObjectTwin(), AddFolderTwin(), or GetObjectTwinHandle().  DeleteTwin()
  should be called before ReleaseTwinHandle() if the twin is to be deleted.
  DeleteTwin() will always succeed on a valid HFOLDERTWIN.  DeleteTwin() will
  fail on a valid HOBJECTTWIN for any object twin that has source folder twins,
  returning TR_HAS_FOLDER_TWIN_SRC.  DeleteTwin() will also fail on a valid
  HTWINFAMILY for any twin family that contains two or more object twins with
  source folder twins, returning TR_HAS_FOLDER_TWIN_SRC.  A twin family cannot
  contain only one object twin with source folder twins.  Twin families can only
  contain 0, 2, or more object twins with source folder twins.

  @xref AddObjectTwin AddFolderTwin ReleaseTwinHandle IsOrphanObjectTwin
  CountSourceFolderTwins

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI DeleteTwin(HTWIN hTwin)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(DeleteTwin);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hTwin, TWIN))
#endif
        {
            tr = DestroyStub((PSTUB)hTwin);
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(DeleteTwin, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | GetObjectTwinHandle | Determines whether or not an object is
  a twin.  If the object is a twin, a twin handle for the twinned object is
  returned.

  @parm HBRFCASE | hbr | A handle to the open briefcase to be checked for the
  object twin.

  @parm PCSTR | pcszFolder | A pointer to a string indicating the object's
  folder.

  @parm PCSTR | pcszName | A pointer to a string indicating the object's name.

  @parm PHOBJECTTWIN | phot | A pointer to an HOBJECTTWIN to be filled in with
  a handle to the object twin or NULL.  If the object is a twin, *phObjectTwin
  is filled in with a handle to the object twin.  If the object is not a twin,
 *phObjectTwin is filled in with NULL.  *phObjectTwin is only valid if
 TR_SUCCESS is returned.

 @rdesc If the lookup was successful, TR_SUCCESS is returned.  Otherwise, the
 lookup was not successful, and the return value indicates the error that
 occurred.

 @comm Once the caller is finshed with the twin handle returned by
 GetObjectTwinHandle(), ReleaseTwinHandle() should be called to release the twin
 handle.  N.b., DeleteTwin() does not release a twin handle returned by
 GetObjectTwinHandle().

 @xref AddObjectTwin ReleaseTwinHandle DeleteTwin

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI GetObjectTwinHandle(HBRFCASE hbr,
        LPCTSTR pcszFolder,
        LPCTSTR pcszName,
        PHOBJECTTWIN phot)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(GetObjectTwinHandle);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hbr, BRFCASE) &&
                IS_VALID_STRING_PTR(pcszFolder, CSTR) &&
                IS_VALID_STRING_PTR(pcszName, CSTR) &&
                IS_VALID_WRITE_PTR(phot, HOBJECTTWIN))
#endif
        {
            HPATH hpath;

            InvalidatePathListInfo(GetBriefcasePathList(hbr));

            tr = TranslatePATHRESULTToTWINRESULT(
                    AddPath(GetBriefcasePathList(hbr), pcszFolder, &hpath));

            if (tr == TR_SUCCESS)
            {
                BOOL bFound;
                HNODE hnode;
                POBJECTTWIN pot;

                /* Is this object already an object twin? */

                bFound = FindObjectTwin(hbr, hpath, pcszName, &hnode);

                if (bFound)
                    /* Yes. */
                    pot = (POBJECTTWIN)GetNodeData(hnode);
                else
                    /*
                     * No.  Expand folder twins, and check for a generating folder
                     * twin.
                     */
                    tr = TryToGenerateObjectTwin(hbr, hpath, pcszName, &bFound,
                            &pot);

                if (tr == TR_SUCCESS)
                {
                    if (bFound)
                    {
                        LockStub(&(pot->stub));

                        TRACE_OUT((TEXT("GetObjectTwinHandle(): %s\\%s is an object twin."),
                                    DebugGetPathString(hpath),
                                    pcszName));

                        *phot = (HOBJECTTWIN)pot;

                        ASSERT(IS_VALID_HANDLE(*phot, OBJECTTWIN));
                    }
                    else
                    {
                        TRACE_OUT((TEXT("GetObjectTwinHandle(): %s\\%s is not an object twin."),
                                    DebugGetPathString(hpath),
                                    pcszName));

                        *phot = NULL;
                    }
                }

                DeletePath(hpath);
            }
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(GetObjectTwinHandle, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | IsOrphanObjectTwin | Determines whether or not an object twin
  was added to the synchronization database through a call to AddObjectTwin().

  @parm HOBJECTTWIN | hot | A handle to the object twin whose orphan status is to
  be determined.

  @parm PBOOL | pbIsOrphanObjectTwin | A pointer to a BOOL to be filled in with
  TRUE if the object twin was added through AddObjectTwin().
 *pbIsOrphanObjectTwin is only valid if TR_SUCCESS is returned.

 @rdesc If the lookup was successful, TR_SUCCESS is returned.  Otherwise, the
 lookup was not successful, and the return value indicates the error that
 occurred.

 @comm If IsOrphanObjectTwin() is called with a valid handle to an object twin
 that has been deleted, TR_DELETED_TWIN will be returned.

 @xref AddObjectTwin

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI IsOrphanObjectTwin(HOBJECTTWIN hot,
        PBOOL pbIsOrphanObjectTwin)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(IsOrphanObjectTwin);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hot, OBJECTTWIN) &&
                IS_VALID_WRITE_PTR(pbIsOrphanObjectTwin, BOOL))
#endif
        {
            /* Has this object twin been deleted? */

            if (IsStubFlagClear(&(((POBJECTTWIN)(hot))->stub), STUB_FL_UNLINKED))
            {
                /* No. */

                if (IsStubFlagSet(&(((POBJECTTWIN)hot)->stub), STUB_FL_FROM_OBJECT_TWIN))
                {
                    *pbIsOrphanObjectTwin = TRUE;

                    TRACE_OUT((TEXT("IsOrphanObjectTwin(): Object twin %s\\%s is an orphan object twin."),
                                DebugGetPathString(((POBJECTTWIN)hot)->hpath),
                                GetString(((POBJECTTWIN)hot)->ptfParent->hsName)));
                }
                else
                {
                    *pbIsOrphanObjectTwin = FALSE;

                    TRACE_OUT((TEXT("IsOrphanObjectTwin(): Object twin %s\\%s is not an orphan object twin."),
                                DebugGetPathString(((POBJECTTWIN)hot)->hpath),
                                GetString(((POBJECTTWIN)hot)->ptfParent->hsName)));
                }

                ASSERT(*pbIsOrphanObjectTwin ||
                        ((POBJECTTWIN)hot)->ulcSrcFolderTwins);

                tr = TR_SUCCESS;
            }
            else
                /* Yes. */
                tr = TR_DELETED_TWIN;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(IsOrphanObjectTwin, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | CountSourceFolderTwins | Determines the number of folder
  twins that generate an object twin.

  @parm HOBJECTTWIN | hot | A handle to the object twin whose folder twin sources
  are to be counted.

  @parm PULONG | pulcSrcFolderTwins | A pointer to a ULONG to be filled in with
  the number of folder twins that generate the object twin.  *pulcSrcFolderTwins
  is only valid if TR_SUCCESS is returned.

  @rdesc If the lookup was successful, TR_SUCCESS is returned.  Otherwise, the
  lookup was not successful, and the return value indicates the error that
  occurred.

  @comm If CountSourceFolderTwins() is called with a valid handle to a folder
  twin that has been deleted, TR_DELETED_TWIN will be returned.

  @xref AddFolderTwin

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI CountSourceFolderTwins(HOBJECTTWIN hot,
        PULONG pulcSrcFolderTwins)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(CountSourceFolderTwins);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hot, OBJECTTWIN) &&
                IS_VALID_WRITE_PTR(pulcSrcFolderTwins, ULONG))
#endif
        {
            /* Has this object twin been deleted? */

            if (IsStubFlagClear(&(((POBJECTTWIN)(hot))->stub), STUB_FL_UNLINKED))
            {
                /* No. */

                *pulcSrcFolderTwins = ((POBJECTTWIN)hot)->ulcSrcFolderTwins;

                ASSERT(*pulcSrcFolderTwins > 0 ||
                        IsStubFlagSet(&(((POBJECTTWIN)hot)->stub), STUB_FL_FROM_OBJECT_TWIN));

                TRACE_OUT((TEXT("CountSourceFolderTwins(): Object twin %s\\%s has %lu source folder twins."),
                            DebugGetPathString(((POBJECTTWIN)hot)->hpath),
                            GetString(((POBJECTTWIN)hot)->ptfParent->hsName),
                            *pulcSrcFolderTwins));

                tr = TR_SUCCESS;
            }
            else
                /* Yes. */
                tr = TR_DELETED_TWIN;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(CountSourceFolderTwins, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api BOOL | AnyTwins | Determines whether or not any twins currently exist in a
  briefcase.

  @parm HBRFCASE | hbr | A handle to the open briefcase to be checked for twins.

  @parm PBOOL | pbAnyTwins | A pointer to a BOOL to be filled in with TRUE if
  the given briefcase contains any twins or FALSE if not.  *pbAnyTwins is only
  valid if TR_SUCCESS is returned.

  @rdesc If the lookup was successful, TR_SUCCESS is returned.  Otherwise, the
  lookup was not successful, and the return value indicates the error that
  occurred.

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI AnyTwins(HBRFCASE hbr, PBOOL pbAnyTwins)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(AnyTwins);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hbr, BRFCASE) &&
                IS_VALID_WRITE_PTR(pbAnyTwins, BOOL))
#endif
        {
            if (GetPtrCount(GetBriefcaseTwinFamilyPtrArray(hbr)) ||
                    GetPtrCount(GetBriefcaseFolderPairPtrArray(hbr)))
            {
                *pbAnyTwins = TRUE;

                TRACE_OUT((TEXT("AnyTwins(): There are twins in briefcase %#lx."),
                            hbr));
            }
            else
            {
                *pbAnyTwins = FALSE;

                TRACE_OUT((TEXT("AnyTwins(): There are not any twins in briefcase %#lx."),
                            hbr));
            }

            tr = TR_SUCCESS;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(AnyTwins, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\twinlist.h ===
/*
 * twinlist.h - Twin list ADT description.
 */


/* Prototypes
 *************/

/* twinlist.c */

extern HBRFCASE GetTwinListBriefcase(HTWINLIST);
extern ARRAYINDEX GetTwinListCount(HTWINLIST);
extern HTWIN GetTwinFromTwinList(HTWINLIST, ARRAYINDEX);
extern BOOL IsValidHTWINLIST(HTWINLIST);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\twinlist.c ===
/*
 * twinlist.c - Twin list ADT module.
 */

/*



*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"


/* Constants
 ************/

/* twin list pointer array allocation parameters */

#define NUM_START_TWIN_HANDLES      (1)
#define NUM_TWIN_HANDLES_TO_ADD     (16)


/* Types
 ********/

/* twin list */

typedef struct _twinlist
{
   /* handle to array of HTWINs in list */

   /* A NULL hpa implies that all twins in the briefcase are in the list. */

   HPTRARRAY hpa;

   /* handle to briefcase that twin list is associated with */

   HBRFCASE hbr;
}
TWINLIST;
DECLARE_STANDARD_TYPES(TWINLIST);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE COMPARISONRESULT TwinListSortCmp(PCVOID, PCVOID);
PRIVATE_CODE TWINRESULT MyAddTwinToTwinList(PCTWINLIST, HTWIN);
PRIVATE_CODE TWINRESULT MyRemoveTwinFromTwinList(PCTWINLIST, HTWIN);
PRIVATE_CODE void MyRemoveAllTwinsFromTwinList(PCTWINLIST);
PRIVATE_CODE BOOL AddTwinToTwinListProc(HTWIN, LPARAM);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCTWINLIST(PCTWINLIST);

#endif


/*
** TwinListSortCmp()
**
** Handle comparison function used to sort twin lists.
**
** Arguments:     htwin1 - first twin handle
**                htwin2 - second twin handle
**
** Returns:
**
** Side Effects:  none
**
** Twin handles are sorted by:
**    1) handle value
*/
PRIVATE_CODE COMPARISONRESULT TwinListSortCmp(PCVOID htwin1, PCVOID htwin2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_HANDLE((HTWIN)htwin1, TWIN));
   ASSERT(IS_VALID_HANDLE((HTWIN)htwin2, TWIN));

   if (htwin1 < htwin2)
      cr = CR_FIRST_SMALLER;
   else if (htwin1 > htwin2)
      cr = CR_FIRST_LARGER;
   else
      cr = CR_EQUAL;

   return(cr);
}


/*
** MyAddTwinToTwinList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT MyAddTwinToTwinList(PCTWINLIST pctl, HTWIN htwin)
{
   TWINRESULT tr;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_STRUCT_PTR(pctl, CTWINLIST));
   ASSERT(IS_VALID_HANDLE(htwin, TWIN));

   if (! SearchSortedArray(pctl->hpa, &TwinListSortCmp, htwin, &ai))
   {
      if (InsertPtr(pctl->hpa, TwinListSortCmp, ai, htwin))
      {
         LockStub((PSTUB)htwin);

         tr = TR_SUCCESS;
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
   {
      ASSERT(GetPtr(pctl->hpa, ai) == htwin);
      ASSERT(GetTwinBriefcase(htwin) == pctl->hbr);

      WARNING_OUT((TEXT("MyAddTwinToTwinList(): Twin %#lx has already been added to twin list %#lx."),
                   htwin,
                   pctl));

      tr = TR_DUPLICATE_TWIN;
   }

   return(tr);
}


/*
** MyRemoveTwinFromTwinList()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT MyRemoveTwinFromTwinList(PCTWINLIST pctl,
                                                    HTWIN htwin)
{
   TWINRESULT tr;
   ARRAYINDEX ai;

   if (SearchSortedArray(pctl->hpa, &TwinListSortCmp, htwin, &ai))
   {
      ASSERT(GetPtr(pctl->hpa, ai) == htwin);
      ASSERT(GetTwinBriefcase(htwin) == pctl->hbr);

      DeletePtr(pctl->hpa, ai);

      UnlockStub((PSTUB)htwin);

      tr = TR_SUCCESS;
   }
   else
   {
      WARNING_OUT((TEXT("MyRemoveTwinFromTwinList(): Twin %#lx is not in twin list %#lx."),
                   htwin,
                   pctl));

      tr = TR_INVALID_PARAMETER;
   }

   return(tr);
}


/*
** MyRemoveAllTwinsFromTwinList()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void MyRemoveAllTwinsFromTwinList(PCTWINLIST pctl)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   /* Unlock all twins in array. */

   aicPtrs = GetPtrCount(pctl->hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      UnlockStub(GetPtr(pctl->hpa, ai));

   /* Now wipe out the array. */

   DeleteAllPtrs(pctl->hpa);

   return;
}


/*
** AddTwinToTwinListProc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL AddTwinToTwinListProc(HTWIN htwin, LPARAM htl)
{
   BOOL bResult;
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(htwin, TWIN));
   ASSERT(IS_VALID_HANDLE((HTWINLIST)htl, TWINLIST));

   tr = MyAddTwinToTwinList((PCTWINLIST)htl, htwin);

   switch (tr)
   {
      case TR_SUCCESS:
      case TR_DUPLICATE_TWIN:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         break;
   }

   return(bResult);
}


#ifdef VSTF

/*
** IsValidPCTWINLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCTWINLIST(PCTWINLIST pctl)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pctl, CTWINLIST) &&
       (! pctl->hpa || IS_VALID_HANDLE(pctl->hpa, PTRARRAY)) &&
       IS_VALID_HANDLE(pctl->hbr, BRFCASE))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}

#endif


/****************************** Public Functions *****************************/


/*
** GetTwinListBriefcase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HBRFCASE GetTwinListBriefcase(HTWINLIST htl)
{
   ASSERT(IS_VALID_HANDLE(htl, TWINLIST));

   return(((PCTWINLIST)htl)->hbr);
}


/*
** GetTwinListCount()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE ARRAYINDEX GetTwinListCount(HTWINLIST htl)
{
   ASSERT(IS_VALID_HANDLE(htl, TWINLIST));

   return(GetPtrCount(((PCTWINLIST)htl)->hpa));
}


/*
** GetTwinFromTwinList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HTWIN GetTwinFromTwinList(HTWINLIST htl, ARRAYINDEX ai)
{
   HTWIN htwin;

   ASSERT(IS_VALID_HANDLE(htl, TWINLIST));

   ASSERT(ai < GetPtrCount(((PCTWINLIST)htl)->hpa));

   htwin = GetPtr(((PCTWINLIST)htl)->hpa, ai);

   ASSERT(IS_VALID_HANDLE(htwin, TWIN));

   return(htwin);
}


/*
** IsValidHTWINLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHTWINLIST(HTWINLIST htl)
{
   return(IS_VALID_STRUCT_PTR((PCTWINLIST)htl, CTWINLIST));
}


/***************************** Exported Functions ****************************/


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | CreateTwinList | Creates a new empty twin list.

@parm HBRFCASE | hbr | A handle to the open briefcase that the twin list is to
be associated with.

@parm PHTWINLIST | phtl | A pointer to an HTWINLIST to be filled in with a
handle to the new twin list.  *phtl is only valid if TR_SUCCESS is returned.

@rdesc If the twin list was created successfully, TR_SUCCESS is returned, and
*phtl contains a handle to the new twin list.  Otherwise, the twin list was
not created successfully, the return value indicates the error that occurred,
and *phtl is undefined.

@xref DeleteTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI CreateTwinList(HBRFCASE hbr, PHTWINLIST phtl)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(CreateTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE) &&
          IS_VALID_WRITE_PTR(phtl, HTWINLIST))
#endif
      {
         PTWINLIST ptl;

         tr = TR_OUT_OF_MEMORY;

         if (AllocateMemory(sizeof(*ptl), &ptl))
         {
            NEWPTRARRAY npa;

            /* Try to create a twin list pointer array. */

            npa.aicInitialPtrs = NUM_START_TWIN_HANDLES;
            npa.aicAllocGranularity = NUM_TWIN_HANDLES_TO_ADD;
            npa.dwFlags = NPA_FL_SORTED_ADD;

            if (CreatePtrArray(&npa, &(ptl->hpa)))
            {
               ptl->hbr = hbr;

               *phtl = (HTWINLIST)ptl;
               tr = TR_SUCCESS;

               ASSERT(IS_VALID_HANDLE(*phtl, TWINLIST));
            }
            else
               FreeMemory(ptl);
         }
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(CreateTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | DestroyTwinList | Destroys a twin list.

@parm HTWINLIST | htl | A handle to the twin list to be destroyed.

@rdesc If the twin list was destroyed successfully, TR_SUCCESS is returned.
Otherwise, the twin list was not destroyed successfully, and the return value
indicates the error that occurred.

@xref CreateTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI DestroyTwinList(HTWINLIST htl)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(DestroyTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(htl, TWINLIST))
#endif
      {
         /* Unlock all twins. */

         MyRemoveAllTwinsFromTwinList((PCTWINLIST)htl);

         DestroyPtrArray(((PCTWINLIST)htl)->hpa);

         FreeMemory((PTWINLIST)htl);

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(DestroyTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | AddTwinToTwinList | Adds a twin to a twin list.

@parm HTWINLIST | htl | A handle to the twin list that the twin is to be added
to.

@parm HTWIN | htwin | A handle to the twin to be added to the twin list.

@rdesc If the twin was added to the twin list successfully, TR_SUCCESS is
returned.  Otherwise, the twin was not added to the twin list successfully, and
the return value indicates the error that occurred.

@comm If the twin associated with htwin is part of an open briefcase other than
the open briefcase associated with htl, TR_INVALID_PARAMETER is returned.  If
htwin has already been added to the twin list, TR_DUPLICATE_TWIN is returned.
If htwin refers to a deleted twin, TR_DELETED_TWIN is returned.

@xref RemoveTwinFromTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI AddTwinToTwinList(HTWINLIST htl, HTWIN htwin)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(AddTwinToTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(htl, TWINLIST) &&
          IS_VALID_HANDLE(htwin, TWIN))
#endif
      {
         if (IsStubFlagClear((PCSTUB)htwin, STUB_FL_UNLINKED))
         {
            if (GetTwinBriefcase(htwin) == ((PCTWINLIST)htl)->hbr)
               tr = MyAddTwinToTwinList((PCTWINLIST)htl, htwin);
            else
               tr = TR_INVALID_PARAMETER;
         }
         else
            tr = TR_DELETED_TWIN;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(AddTwinToTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | AddAllTwinsToTwinList | Adds all the twins in an open
briefcase to a twin list.

@parm HTWINLIST | htl | A handle to the twin list that the twins are to be
added to.

@rdesc If the twins were added to the twin list successfully, TR_SUCCESS is
returned.  Otherwise, the twins were not added to the twin list successfully,
and the return value indicates the error that occurred.

@xref RemoveAllTwinsFromTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI AddAllTwinsToTwinList(HTWINLIST htl)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(AddAllTwinsToTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(htl, TWINLIST))
#endif
      {
         HTWIN htwinUnused;

         if (! EnumTwins(((PCTWINLIST)htl)->hbr, &AddTwinToTwinListProc, (LPARAM)htl, &htwinUnused))
            tr = TR_SUCCESS;
         else
            tr = TR_OUT_OF_MEMORY;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(AddAllTwinsToTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | RemoveTwinFromTwinList | Removes a twin from a twin list.

@parm HTWINLIST | htl | A handle to the twin list that the twin is to be
removed from.

@parm HTWIN | htwin | A handle to the twin to be removed from the twin list.

@rdesc If the twin was removed from the twin list successfully, TR_SUCCESS is
returned.  Otherwise, the twin was not removed from the twin list successfully,
and the return value indicates the error that occurred.

@comm If the twin associated with htwin is not in the twin list,
TR_INVALID_PARAMETER is returned.

@xref AddTwinToTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI RemoveTwinFromTwinList(HTWINLIST htl, HTWIN htwin)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(RemoveTwinFromTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(htl, TWINLIST) &&
          IS_VALID_HANDLE(htwin, TWIN))
#endif
      {
         tr = MyRemoveTwinFromTwinList((PCTWINLIST)htl, htwin);
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(RemoveTwinFromTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | RemoveAllTwinsFromTwinList | Removes all the twins from a
twin list.

@parm HTWINLIST | htl | A handle to the twin list to be emptied.

@rdesc If the twins were removed from the twin list successfully, TR_SUCCESS is
returned.  Otherwise, the twins were not removed from the twin list
successfully, and the return value indicates the error that occurred.

@xref AddAllTwinsToTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI RemoveAllTwinsFromTwinList(HTWINLIST htl)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(RemoveAllTwinsFromTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(htl, TWINLIST))
#endif
      {
         MyRemoveAllTwinsFromTwinList((PCTWINLIST)htl);

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(RemoveAllTwinsFromTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\twin.h ===
/*
 * twin.h - Twin ADT description.
 */


/* Types
 ********/

/*
 * EnumTwins() callback function - called as:
 *
 *    bContinue = EnumTwinsProc(htwin, pData);
 */

typedef BOOL (*ENUMTWINSPROC)(HTWIN, LPARAM);


/* Prototypes
 *************/

/* twin.c */

extern COMPARISONRESULT CompareNameStrings(LPCTSTR, LPCTSTR);
extern COMPARISONRESULT CompareNameStringsByHandle(HSTRING, HSTRING);
extern TWINRESULT TranslatePATHRESULTToTWINRESULT(PATHRESULT);
extern BOOL CreateTwinFamilyPtrArray(PHPTRARRAY);
extern void DestroyTwinFamilyPtrArray(HPTRARRAY);
extern HBRFCASE GetTwinBriefcase(HTWIN);
extern BOOL FindObjectTwinInList(HLIST, HPATH, PHNODE);
extern BOOL EnumTwins(HBRFCASE, ENUMTWINSPROC, LPARAM, PHTWIN);
extern BOOL IsValidHTWIN(HTWIN);
extern BOOL IsValidHTWINFAMILY(HTWINFAMILY);
extern BOOL IsValidHOBJECTTWIN(HOBJECTTWIN);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\util.h ===
/*
 * util.h - Miscellaneous utility functions module description.
 */


/* Constants
 ************/

/* maximum length of buffer required by SeparatePath() */

#define MAX_SEPARATED_PATH_LEN            (MAX_PATH_LEN + 1)

/* events for NotifyShell */

typedef enum _notifyshellevent
{
   NSE_CREATE_ITEM,
   NSE_DELETE_ITEM,
   NSE_CREATE_FOLDER,
   NSE_DELETE_FOLDER,
   NSE_UPDATE_ITEM,
   NSE_UPDATE_FOLDER
}
NOTIFYSHELLEVENT;
DECLARE_STANDARD_TYPES(NOTIFYSHELLEVENT);


/* Prototypes
 *************/

/* util.c */

extern void NotifyShell(LPCTSTR, NOTIFYSHELLEVENT);
extern COMPARISONRESULT ComparePathStringsByHandle(HSTRING, HSTRING);
extern COMPARISONRESULT MyLStrCmpNI(LPCTSTR, LPCTSTR, int);
extern void ComposePath(LPTSTR, LPCTSTR, LPCTSTR, int);
extern LPCTSTR ExtractFileName(LPCTSTR);
extern LPCTSTR ExtractExtension(LPCTSTR);
extern HASHBUCKETCOUNT GetHashBucketIndex(LPCTSTR, HASHBUCKETCOUNT);
extern COMPARISONRESULT MyCompareStrings(LPCTSTR, LPCTSTR, BOOL);
extern BOOL RegKeyExists(HKEY, LPCTSTR);
extern BOOL CopyLinkInfo(PCLINKINFO, PLINKINFO *);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidPCLINKINFO(PCLINKINFO);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\valid.h ===
/*
 * valid.h - Validation functions description.
 */


/* Prototypes
 *************/

/* valid.c */

extern BOOL IsValidHANDLE(HANDLE);
extern BOOL IsValidHFILE(HANDLE);
extern BOOL IsValidHWND(HWND);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidPCSECURITY_ATTRIBUTES(PCSECURITY_ATTRIBUTES);
extern BOOL IsValidFileCreationMode(DWORD);
extern BOOL IsValidHTEMPLATEFILE(HANDLE);
extern BOOL IsValidPCFILETIME(PCFILETIME);

#endif

#ifdef DEBUG

extern BOOL IsValidHINSTANCE(HINSTANCE);
extern BOOL IsValidHICON(HICON);
extern BOOL IsValidHKEY(HKEY);
extern BOOL IsValidHMODULE(HMODULE);
extern BOOL IsValidShowWindowCmd(int);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\volume.c ===
/*
 * volume.c - Volume ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "volume.h"


/* Constants
 ************/

/* VOLUMELIST PTRARRAY allocation parameters */

#define NUM_START_VOLUMES        (16)
#define NUM_VOLUMES_TO_ADD       (16)

/* VOLUMELIST string table allocation parameters */

#define NUM_VOLUME_HASH_BUCKETS  (31)


/* Types
 ********/

/* volume list */

typedef struct _volumelist
{
    /* array of pointers to VOLUMEs */

    HPTRARRAY hpa;

    /* table of volume root path strings */

    HSTRINGTABLE hst;

    /* flags from RESOLVELINKINFOINFLAGS */

    DWORD dwFlags;

    /*
     * handle to parent window, only valid if RLI_IFL_ALLOW_UI is set in dwFlags
     * field
     */

    HWND hwndOwner;
}
VOLUMELIST;
DECLARE_STANDARD_TYPES(VOLUMELIST);

/* VOLUME flags */

typedef enum _volumeflags
{
    /* The volume root path string indicated by hsRootPath is valid. */

    VOLUME_FL_ROOT_PATH_VALID  = 0x0001,

    /*
     * The net resource should be disconnected by calling DisconnectLinkInfo()
     * when finished.
     */

    VOLUME_FL_DISCONNECT       = 0x0002,

    /* Any cached volume information should be verified before use. */

    VOLUME_FL_VERIFY_VOLUME    = 0x0004,

    /* flag combinations */

    ALL_VOLUME_FLAGS           = (VOLUME_FL_ROOT_PATH_VALID |
            VOLUME_FL_DISCONNECT |
            VOLUME_FL_VERIFY_VOLUME)
}
VOLUMEFLAGS;

/* VOLUME states */

typedef enum _volumestate
{
    VS_UNKNOWN,

    VS_AVAILABLE,

    VS_UNAVAILABLE
}
VOLUMESTATE;
DECLARE_STANDARD_TYPES(VOLUMESTATE);

/* volume structure */

typedef struct _volume
{
    /* reference count */

    ULONG ulcLock;

    /* bit mask of flags from VOLUMEFLAGS */

    DWORD dwFlags;

    /* volume state */

    VOLUMESTATE vs;

    /* pointer to LinkInfo structure indentifying volume */

    PLINKINFO pli;

    /*
     * handle to volume root path string, only valid if
     * VOLUME_FL_ROOT_PATH_VALID is set in dwFlags field
     */

    HSTRING hsRootPath;

    /* pointer to parent volume list */

    PVOLUMELIST pvlParent;
}
VOLUME;
DECLARE_STANDARD_TYPES(VOLUME);

/* database volume list header */

typedef struct _dbvolumelistheader
{
    /* number of volumes in list */

    LONG lcVolumes;

    /* length of longest LinkInfo structure in volume list in bytes */

    UINT ucbMaxLinkInfoLen;
}
DBVOLUMELISTHEADER;
DECLARE_STANDARD_TYPES(DBVOLUMELISTHEADER);

/* database volume structure */

typedef struct _dbvolume
{
    /* old handle to volume */

    HVOLUME hvol;

    /* old LinkInfo structure follows */

    /* first DWORD of LinkInfo structure is total size in bytes */
}
DBVOLUME;
DECLARE_STANDARD_TYPES(DBVOLUME);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE COMPARISONRESULT VolumeSortCmp(PCVOID, PCVOID);
PRIVATE_CODE COMPARISONRESULT VolumeSearchCmp(PCVOID, PCVOID);
PRIVATE_CODE BOOL SearchForVolumeByRootPathCmp(PCVOID, PCVOID);
PRIVATE_CODE BOOL UnifyVolume(PVOLUMELIST, PLINKINFO, PVOLUME *);
PRIVATE_CODE BOOL CreateVolume(PVOLUMELIST, PLINKINFO, PVOLUME *);
PRIVATE_CODE void UnlinkVolume(PCVOLUME);
PRIVATE_CODE BOOL DisconnectVolume(PVOLUME);
PRIVATE_CODE void DestroyVolume(PVOLUME);
PRIVATE_CODE void LockVolume(PVOLUME);
PRIVATE_CODE BOOL UnlockVolume(PVOLUME);
PRIVATE_CODE void InvalidateVolumeInfo(PVOLUME);
PRIVATE_CODE void ClearVolumeInfo(PVOLUME);
PRIVATE_CODE void GetUnavailableVolumeRootPath(PCLINKINFO, LPTSTR, int);
PRIVATE_CODE BOOL VerifyAvailableVolume(PVOLUME);
PRIVATE_CODE void ExpensiveResolveVolumeRootPath(PVOLUME, LPTSTR, int);
PRIVATE_CODE void ResolveVolumeRootPath(PVOLUME, LPTSTR, int);
PRIVATE_CODE VOLUMERESULT VOLUMERESULTFromLastError(VOLUMERESULT);
PRIVATE_CODE TWINRESULT WriteVolume(HCACHEDFILE, PVOLUME);
PRIVATE_CODE TWINRESULT ReadVolume(HCACHEDFILE, PVOLUMELIST, PLINKINFO, UINT, HHANDLETRANS);

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL IsValidPCVOLUMELIST(PCVOLUMELIST);
PRIVATE_CODE BOOL IsValidVOLUMESTATE(VOLUMESTATE);
PRIVATE_CODE BOOL IsValidPCVOLUME(PCVOLUME);

#endif

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCVOLUMEDESC(PCVOLUMEDESC);

#endif


/*
 ** VolumeSortCmp()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** Volumes are sorted by:
 **    1) LinkInfo volume
 **    2) pointer
 */
PRIVATE_CODE COMPARISONRESULT VolumeSortCmp(PCVOID pcvol1, PCVOID pcvol2)
{
    COMPARISONRESULT cr;

    ASSERT(IS_VALID_STRUCT_PTR(pcvol1, CVOLUME));
    ASSERT(IS_VALID_STRUCT_PTR(pcvol2, CVOLUME));

    cr = CompareLinkInfoVolumes(((PCVOLUME)pcvol1)->pli,
            ((PCVOLUME)pcvol2)->pli);

    if (cr == CR_EQUAL)
        cr = ComparePointers(pcvol1, pcvol1);

    return(cr);
}


/*
 ** VolumeSearchCmp()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** Volumes are searched by:
 **    1) LinkInfo volume
 */
PRIVATE_CODE COMPARISONRESULT VolumeSearchCmp(PCVOID pcli, PCVOID pcvol)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcli, CLINKINFO));
    ASSERT(IS_VALID_STRUCT_PTR(pcvol, CVOLUME));

    return(CompareLinkInfoVolumes(pcli, ((PCVOLUME)pcvol)->pli));
}


/*
 ** SearchForVolumeByRootPathCmp()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** Volumes are searched by:
 **    1) available volume root path
 */
PRIVATE_CODE BOOL SearchForVolumeByRootPathCmp(PCVOID pcszFullPath,
        PCVOID pcvol)
{
    BOOL bDifferent;

    ASSERT(IsFullPath(pcszFullPath));
    ASSERT(IS_VALID_STRUCT_PTR(pcvol, CVOLUME));

    if (((PCVOLUME)pcvol)->vs == VS_AVAILABLE &&
            IS_FLAG_SET(((PCVOLUME)pcvol)->dwFlags, VOLUME_FL_ROOT_PATH_VALID))
    {
        LPCTSTR pcszVolumeRootPath;

        pcszVolumeRootPath = GetString(((PCVOLUME)pcvol)->hsRootPath);

        bDifferent = MyLStrCmpNI(pcszFullPath, pcszVolumeRootPath,
                lstrlen(pcszVolumeRootPath));
    }
    else
        bDifferent = TRUE;

    return(bDifferent);
}


/*
 ** UnifyVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL UnifyVolume(PVOLUMELIST pvl, PLINKINFO pliRoot,
        PVOLUME *ppvol)
{
    BOOL bResult = FALSE;

    ASSERT(IS_VALID_STRUCT_PTR(pvl, CVOLUMELIST));
    ASSERT(IS_VALID_STRUCT_PTR(pliRoot, CLINKINFO));
    ASSERT(IS_VALID_WRITE_PTR(ppvol, PVOLUME));

    if (AllocateMemory(sizeof(**ppvol), ppvol))
    {
        if (CopyLinkInfo(pliRoot, &((*ppvol)->pli)))
        {
            ARRAYINDEX aiUnused;

            (*ppvol)->ulcLock = 0;
            (*ppvol)->dwFlags = 0;
            (*ppvol)->vs = VS_UNKNOWN;
            (*ppvol)->hsRootPath = NULL;
            (*ppvol)->pvlParent = pvl;

            if (AddPtr(pvl->hpa, VolumeSortCmp, *ppvol, &aiUnused))
                bResult = TRUE;
            else
            {
                FreeMemory((*ppvol)->pli);
UNIFYVOLUME_BAIL:
                FreeMemory(*ppvol);
            }
        }
        else
            goto UNIFYVOLUME_BAIL;
    }

    ASSERT(! bResult ||
            IS_VALID_STRUCT_PTR(*ppvol, CVOLUME));

    return(bResult);
}


/*
 ** CreateVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CreateVolume(PVOLUMELIST pvl, PLINKINFO pliRoot,
        PVOLUME *ppvol)
{
    BOOL bResult;
    PVOLUME pvol;
    ARRAYINDEX aiFound;

    ASSERT(IS_VALID_STRUCT_PTR(pvl, CVOLUMELIST));
    ASSERT(IS_VALID_STRUCT_PTR(pliRoot, CLINKINFO));
    ASSERT(IS_VALID_WRITE_PTR(ppvol, PVOLUME));

    /* Does a volume for the given root path already exist? */

    if (SearchSortedArray(pvl->hpa, &VolumeSearchCmp, pliRoot, &aiFound))
    {
        pvol = GetPtr(pvl->hpa, aiFound);
        bResult = TRUE;
    }
    else
        bResult = UnifyVolume(pvl, pliRoot, &pvol);

    if (bResult)
    {
        LockVolume(pvol);
        *ppvol = pvol;
    }

    ASSERT(! bResult ||
            IS_VALID_STRUCT_PTR(*ppvol, CVOLUME));

    return(bResult);
}


/*
 ** UnlinkVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void UnlinkVolume(PCVOLUME pcvol)
{
    HPTRARRAY hpa;
    ARRAYINDEX aiFound;

    ASSERT(IS_VALID_STRUCT_PTR(pcvol, CVOLUME));

    hpa = pcvol->pvlParent->hpa;

    if (EVAL(SearchSortedArray(hpa, &VolumeSortCmp, pcvol, &aiFound)))
    {
        ASSERT(GetPtr(hpa, aiFound) == pcvol);

        DeletePtr(hpa, aiFound);
    }

    return;
}


/*
 ** DisconnectVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL DisconnectVolume(PVOLUME pvol)
{
    BOOL bResult;

    ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

    if (IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_DISCONNECT))
    {
        bResult = DisconnectLinkInfo(pvol->pli);

        CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_DISCONNECT);
    }
    else
        bResult = TRUE;

    return(bResult);
}


/*
 ** DestroyVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DestroyVolume(PVOLUME pvol)
{
    ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

    ClearVolumeInfo(pvol);

    FreeMemory(pvol->pli);
    FreeMemory(pvol);

    return;
}


/*
 ** LockVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void LockVolume(PVOLUME pvol)
{
    ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

    ASSERT(pvol->ulcLock < ULONG_MAX);
    pvol->ulcLock++;

    return;
}


/*
 ** UnlockVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL UnlockVolume(PVOLUME pvol)
{
    ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

    if (EVAL(pvol->ulcLock > 0))
        pvol->ulcLock--;

    return(pvol->ulcLock > 0);
}


/*
 ** InvalidateVolumeInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void InvalidateVolumeInfo(PVOLUME pvol)
{
    ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

    SET_FLAG(pvol->dwFlags, VOLUME_FL_VERIFY_VOLUME);

    ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

    return;
}


/*
 ** ClearVolumeInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void ClearVolumeInfo(PVOLUME pvol)
{
    ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

    DisconnectVolume(pvol);

    if (IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID))
    {
        DeleteString(pvol->hsRootPath);

        CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID);
    }

    CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_VERIFY_VOLUME);

    pvol->vs = VS_UNKNOWN;

    ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

    return;
}


/*
 ** GetUnavailableVolumeRootPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void GetUnavailableVolumeRootPath(PCLINKINFO pcli,
        LPTSTR pszRootPathBuf,
        int cchMax)
{
    LPCSTR pcszLinkInfoData;

    ASSERT(IS_VALID_STRUCT_PTR(pcli, CLINKINFO));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRootPathBuf, STR, cchMax));

    /*
     * Try unavailable volume root paths in the following order:
     *    1) last redirected device
     *    2) net resource name
     *    3) local path           ...and take the _last_ good one!
     */

    if (GetLinkInfoData(pcli, LIDT_REDIRECTED_DEVICE, &pcszLinkInfoData) ||
            GetLinkInfoData(pcli, LIDT_NET_RESOURCE, &pcszLinkInfoData) ||
            GetLinkInfoData(pcli, LIDT_LOCAL_BASE_PATH, &pcszLinkInfoData))
    {
        //ASSERT(IS_VALID_STRING_PTR(pcszLinkInfoData, CSTR));
        ASSERT(lstrlenA(pcszLinkInfoData) < MAX_PATH_LEN);

        // REARCHITECT somewhere, someone might need to handle unicode base paths 

#ifdef UNICODE
        {
            WCHAR szTmp[MAX_PATH] = TEXT("");
            MultiByteToWideChar(CP_ACP, 0, pcszLinkInfoData, -1, szTmp, ARRAYSIZE(szTmp));
            ComposePath(pszRootPathBuf, szTmp, TEXT("\\"), cchMax);
        }
#else

        ComposePath(pszRootPathBuf, pcszLinkInfoData, TEXT("\\"), cchMax);

#endif

    }
    else
    {
        pszRootPathBuf[0] = TEXT('\0');

        ERROR_OUT((TEXT("GetUnavailableVolumeRootPath(): Net resource name and local base path unavailable.  Using empty string as unavailable root path.")));
    }

    ASSERT(IsRootPath(pszRootPathBuf) &&
            EVAL(lstrlen(pszRootPathBuf) < MAX_PATH_LEN));

    return;
}


/*
 ** VerifyAvailableVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL VerifyAvailableVolume(PVOLUME pvol)
{
    BOOL bResult = FALSE;
    PLINKINFO pli;

    ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

    ASSERT(pvol->vs == VS_AVAILABLE);
    ASSERT(IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID));

    WARNING_OUT((TEXT("VerifyAvailableVolume(): Calling CreateLinkInfo() to verify volume on %s."),
                GetString(pvol->hsRootPath)));

    if (CreateLinkInfo(GetString(pvol->hsRootPath), &pli))
    {
        bResult = (CompareLinkInfoReferents(pvol->pli, pli) == CR_EQUAL);

        DestroyLinkInfo(pli);

        if (bResult)
            TRACE_OUT((TEXT("VerifyAvailableVolume(): Volume %s has not changed."),
                        GetString(pvol->hsRootPath)));
        else
            WARNING_OUT((TEXT("VerifyAvailableVolume(): Volume %s has changed."),
                        GetString(pvol->hsRootPath)));
    }
    else
        WARNING_OUT((TEXT("VerifyAvailableVolume(): CreateLinkInfo() failed for %s."),
                    GetString(pvol->hsRootPath)));

    return(bResult);
}


/*
 ** ExpensiveResolveVolumeRootPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void ExpensiveResolveVolumeRootPath(PVOLUME pvol,
        LPTSTR pszVolumeRootPathBuf,
        int cchMax)
{
    BOOL bResult;
    DWORD dwOutFlags;
    PLINKINFO pliUpdated;
    HSTRING hsRootPath;

    ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszVolumeRootPathBuf, STR, cchMax));

    if (pvol->vs == VS_UNKNOWN ||
            pvol->vs == VS_AVAILABLE)
    {
        /*
         * Only request a connection if connections are still permitted in this
         * volume list.
         */

        WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Calling ResolveLinkInfo() to determine volume availability and root path.")));

        bResult = ResolveLinkInfo(pvol->pli, pszVolumeRootPathBuf,
                pvol->pvlParent->dwFlags,
                pvol->pvlParent->hwndOwner, &dwOutFlags,
                &pliUpdated);

        if (bResult)
        {
            pvol->vs = VS_AVAILABLE;

            if (IS_FLAG_SET(dwOutFlags, RLI_OFL_UPDATED))
            {
                PLINKINFO pliUpdatedCopy;

                ASSERT(IS_FLAG_SET(pvol->pvlParent->dwFlags, RLI_IFL_UPDATE));

                if (CopyLinkInfo(pliUpdated, &pliUpdatedCopy))
                {
                    FreeMemory(pvol->pli);
                    pvol->pli = pliUpdatedCopy;
                }

                DestroyLinkInfo(pliUpdated);

                WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Updating LinkInfo for volume %s."),
                            pszVolumeRootPathBuf));
            }

            if (IS_FLAG_SET(dwOutFlags, RLI_OFL_DISCONNECT))
            {
                SET_FLAG(pvol->dwFlags, VOLUME_FL_DISCONNECT);

                WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Volume %s must be disconnected when finished."),
                            pszVolumeRootPathBuf));
            }

            TRACE_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Volume %s is available."),
                        pszVolumeRootPathBuf));
        }
        else
            ASSERT(GetLastError() != ERROR_INVALID_PARAMETER);
    }
    else
    {
        ASSERT(pvol->vs == VS_UNAVAILABLE);
        bResult = FALSE;
    }

    if (! bResult)
    {
        pvol->vs = VS_UNAVAILABLE;

        if (GetLastError() == ERROR_CANCELLED)
        {
            ASSERT(IS_FLAG_SET(pvol->pvlParent->dwFlags, RLI_IFL_CONNECT));

            CLEAR_FLAG(pvol->pvlParent->dwFlags, RLI_IFL_CONNECT);

            WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Connection attempt cancelled.  No subsequent connections will be attempted.")));
        }

        GetUnavailableVolumeRootPath(pvol->pli, pszVolumeRootPathBuf, cchMax);

        WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Using %s as unavailable volume root path."),
                    pszVolumeRootPathBuf));
    }

    /* Add volume root path string to volume list's string table. */

    if (IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID))
    {
        CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID);
        DeleteString(pvol->hsRootPath);
    }

    if (AddString(pszVolumeRootPathBuf, pvol->pvlParent->hst, GetHashBucketIndex, &hsRootPath))
    {
        SET_FLAG(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID);
        pvol->hsRootPath = hsRootPath;
    }
    else
        WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Unable to save %s as volume root path."),
                    pszVolumeRootPathBuf));

    return;
}


/*
 ** ResolveVolumeRootPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void ResolveVolumeRootPath(PVOLUME pvol,
        LPTSTR pszVolumeRootPathBuf,
        int cchMax)
{
    ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszVolumeRootPathBuf, STR, MAX_PATH_LEN));

    /* Do we have a cached volume root path to use? */

    if (IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID) &&
            (IS_FLAG_CLEAR(pvol->dwFlags, VOLUME_FL_VERIFY_VOLUME) ||
             (pvol->vs == VS_AVAILABLE &&
              VerifyAvailableVolume(pvol))))
    {
        /* Yes. */

        MyLStrCpyN(pszVolumeRootPathBuf, GetString(pvol->hsRootPath), cchMax);
        ASSERT(lstrlen(pszVolumeRootPathBuf) < MAX_PATH_LEN);

        ASSERT(pvol->vs != VS_UNKNOWN);
    }
    else
        /* No.  Welcome in I/O City. */
        ExpensiveResolveVolumeRootPath(pvol, pszVolumeRootPathBuf, cchMax);

    CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_VERIFY_VOLUME);

    ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

    return;
}


/*
 ** VOLUMERESULTFromLastError()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE VOLUMERESULT VOLUMERESULTFromLastError(VOLUMERESULT vr)
{
    switch (GetLastError())
    {
        case ERROR_OUTOFMEMORY:
            vr = VR_OUT_OF_MEMORY;
            break;

        case ERROR_BAD_PATHNAME:
            vr = VR_INVALID_PATH;
            break;

        default:
            break;
    }

    return(vr);
}


/*
 ** WriteVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT WriteVolume(HCACHEDFILE hcf, PVOLUME pvol)
{
    TWINRESULT tr;
    DBVOLUME dbvol;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

    /* Write database volume followed by LinkInfo structure. */

    dbvol.hvol = (HVOLUME)pvol;

    if (WriteToCachedFile(hcf, (PCVOID)&dbvol, sizeof(dbvol), NULL) &&
            WriteToCachedFile(hcf, pvol->pli, *(PDWORD)(pvol->pli), NULL))
        tr = TR_SUCCESS;
    else
        tr = TR_BRIEFCASE_WRITE_FAILED;

    return(tr);
}


/*
 ** ReadVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT ReadVolume(HCACHEDFILE hcf, PVOLUMELIST pvl,
        PLINKINFO pliBuf, UINT ucbLinkInfoBufLen,
        HHANDLETRANS hhtVolumes)
{
    TWINRESULT tr = TR_CORRUPT_BRIEFCASE;
    DBVOLUME dbvol;
    DWORD dwcbRead;
    UINT ucbLinkInfoLen;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_STRUCT_PTR(pvl, CVOLUMELIST));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pliBuf, LINKINFO, ucbLinkInfoBufLen));
    ASSERT(IS_VALID_HANDLE(hhtVolumes, HANDLETRANS));

    if (ReadFromCachedFile(hcf, &dbvol, sizeof(dbvol), &dwcbRead) &&
            dwcbRead == sizeof(dbvol) &&
            ReadFromCachedFile(hcf, &ucbLinkInfoLen, sizeof(ucbLinkInfoLen), &dwcbRead) &&
            dwcbRead == sizeof(ucbLinkInfoLen) &&
            ucbLinkInfoLen <= ucbLinkInfoBufLen)
    {
        /* Read the remainder of the LinkInfo structure into memory. */

        DWORD dwcbRemainder;

        pliBuf->ucbSize = ucbLinkInfoLen;
        dwcbRemainder = ucbLinkInfoLen - sizeof(ucbLinkInfoLen);

        if (ReadFromCachedFile(hcf, (PBYTE)pliBuf + sizeof(ucbLinkInfoLen),
                    dwcbRemainder, &dwcbRead) &&
                dwcbRead == dwcbRemainder &&
                IsValidLinkInfo(pliBuf))
        {
            PVOLUME pvol;

            if (CreateVolume(pvl, pliBuf, &pvol))
            {
                /*
                 * To leave read volumes with 0 initial lock count, we must undo
                 * the LockVolume() performed by CreateVolume().
                 */

                UnlockVolume(pvol);

                if (AddHandleToHandleTranslator(hhtVolumes,
                            (HGENERIC)(dbvol.hvol),
                            (HGENERIC)pvol))
                    tr = TR_SUCCESS;
                else
                {
                    UnlinkVolume(pvol);
                    DestroyVolume(pvol);

                    tr = TR_OUT_OF_MEMORY;
                }
            }
            else
                tr = TR_OUT_OF_MEMORY;
        }
    }

    return(tr);
}


#if defined(DEBUG) || defined(VSTF)

/*
 ** IsValidPCVOLUMELIST()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCVOLUMELIST(PCVOLUMELIST pcvl)
{
    return(IS_VALID_READ_PTR(pcvl, CVOLUMELIST) &&
            IS_VALID_HANDLE(pcvl->hpa, PTRARRAY) &&
            IS_VALID_HANDLE(pcvl->hst, STRINGTABLE) &&
            FLAGS_ARE_VALID(pcvl->dwFlags, ALL_RLI_IFLAGS) &&
            (IS_FLAG_CLEAR(pcvl->dwFlags, RLI_IFL_ALLOW_UI) ||
             IS_VALID_HANDLE(pcvl->hwndOwner, WND)));
}


/*
 ** IsValidVOLUMESTATE()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidVOLUMESTATE(VOLUMESTATE vs)
{
    BOOL bResult;

    switch (vs)
    {
        case VS_UNKNOWN:
        case VS_AVAILABLE:
        case VS_UNAVAILABLE:
            bResult = TRUE;
            break;

        default:
            ERROR_OUT((TEXT("IsValidVOLUMESTATE(): Invalid VOLUMESTATE %d."),
                        vs));
            bResult = FALSE;
            break;
    }

    return(bResult);
}


/*
 ** IsValidPCVOLUME()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCVOLUME(PCVOLUME pcvol)
{
    return(IS_VALID_READ_PTR(pcvol, CVOLUME) &&
            FLAGS_ARE_VALID(pcvol->dwFlags, ALL_VOLUME_FLAGS) &&
            EVAL(IsValidVOLUMESTATE(pcvol->vs)) &&
            IS_VALID_STRUCT_PTR(pcvol->pli, CLINKINFO) &&
            (IS_FLAG_CLEAR(pcvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID) ||
             IS_VALID_HANDLE(pcvol->hsRootPath, STRING)) &&
            IS_VALID_STRUCT_PTR(pcvol->pvlParent, CVOLUMELIST));
}

#endif


#ifdef DEBUG

/*
 ** IsValidPCVOLUMEDESC()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCVOLUMEDESC(PCVOLUMEDESC pcvoldesc)
{
    /*
     * A set dwSerialNumber may be any value.  An unset dwSerialNumber must be
     * 0.  A set strings may be any valid string.  An unset string must be the
     * empty string.
     */

    return(IS_VALID_READ_PTR(pcvoldesc, CVOLUMEDESC) &&
            EVAL(pcvoldesc->ulSize == sizeof(*pcvoldesc)) &&
            FLAGS_ARE_VALID(pcvoldesc->dwFlags, ALL_VD_FLAGS) &&
            (IS_FLAG_SET(pcvoldesc->dwFlags, VD_FL_SERIAL_NUMBER_VALID) ||
             ! pcvoldesc->dwSerialNumber) &&
            ((IS_FLAG_CLEAR(pcvoldesc->dwFlags, VD_FL_VOLUME_LABEL_VALID) &&
              ! pcvoldesc->rgchVolumeLabel[0]) ||
             (IS_FLAG_SET(pcvoldesc->dwFlags, VD_FL_VOLUME_LABEL_VALID) &&
              IS_VALID_STRING_PTR(pcvoldesc->rgchVolumeLabel, CSTR) &&
              EVAL(lstrlen(pcvoldesc->rgchVolumeLabel) < ARRAYSIZE(pcvoldesc->rgchVolumeLabel)))) &&
            ((IS_FLAG_CLEAR(pcvoldesc->dwFlags, VD_FL_NET_RESOURCE_VALID) &&
              ! pcvoldesc->rgchNetResource[0]) ||
             (IS_FLAG_SET(pcvoldesc->dwFlags, VD_FL_NET_RESOURCE_VALID) &&
              IS_VALID_STRING_PTR(pcvoldesc->rgchNetResource, CSTR) &&
              EVAL(lstrlen(pcvoldesc->rgchNetResource) < ARRAYSIZE(pcvoldesc->rgchNetResource)))));
}

#endif


/****************************** Public Functions *****************************/


/*
 ** CreateVolumeList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL CreateVolumeList(DWORD dwFlags, HWND hwndOwner,
        PHVOLUMELIST phvl)
{
    BOOL bResult = FALSE;
    PVOLUMELIST pvl;

    ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_RLI_IFLAGS));
    ASSERT(IS_FLAG_CLEAR(dwFlags, RLI_IFL_ALLOW_UI) ||
            IS_VALID_HANDLE(hwndOwner, WND));
    ASSERT(IS_VALID_WRITE_PTR(phvl, HVOLUMELIST));

    if (AllocateMemory(sizeof(*pvl), &pvl))
    {
        NEWSTRINGTABLE nszt;

        /* Create string table for volume root path strngs. */

        nszt.hbc = NUM_VOLUME_HASH_BUCKETS;

        if (CreateStringTable(&nszt, &(pvl->hst)))
        {
            NEWPTRARRAY npa;

            /* Create pointer array of volumes. */

            npa.aicInitialPtrs = NUM_START_VOLUMES;
            npa.aicAllocGranularity = NUM_VOLUMES_TO_ADD;
            npa.dwFlags = NPA_FL_SORTED_ADD;

            if (CreatePtrArray(&npa, &(pvl->hpa)))
            {
                pvl->dwFlags = dwFlags;
                pvl->hwndOwner = hwndOwner;

                *phvl = (HVOLUMELIST)pvl;
                bResult = TRUE;
            }
            else
            {
                DestroyStringTable(pvl->hst);
CREATEVOLUMELIST_BAIL:
                FreeMemory(pvl);
            }
        }
        else
            goto CREATEVOLUMELIST_BAIL;
    }

    ASSERT(! bResult ||
            IS_VALID_HANDLE(*phvl, VOLUMELIST));

    return(bResult);
}


/*
 ** DestroyVolumeList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DestroyVolumeList(HVOLUMELIST hvl)
{
    ARRAYINDEX aicPtrs;
    ARRAYINDEX ai;

    ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

    /* First free all volumes in array. */

    aicPtrs = GetPtrCount(((PCVOLUMELIST)hvl)->hpa);

    for (ai = 0; ai < aicPtrs; ai++)
        DestroyVolume(GetPtr(((PCVOLUMELIST)hvl)->hpa, ai));

    /* Now wipe out the array. */

    DestroyPtrArray(((PCVOLUMELIST)hvl)->hpa);

    ASSERT(! GetStringCount(((PCVOLUMELIST)hvl)->hst));
    DestroyStringTable(((PCVOLUMELIST)hvl)->hst);

    FreeMemory((PVOLUMELIST)hvl);

    return;
}


/*
 ** InvalidateVolumeListInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void InvalidateVolumeListInfo(HVOLUMELIST hvl)
{
    ARRAYINDEX aicPtrs;
    ARRAYINDEX ai;

    ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

    aicPtrs = GetPtrCount(((PCVOLUMELIST)hvl)->hpa);

    for (ai = 0; ai < aicPtrs; ai++)
        InvalidateVolumeInfo(GetPtr(((PCVOLUMELIST)hvl)->hpa, ai));

    WARNING_OUT((TEXT("InvalidateVolumeListInfo(): Volume cache invalidated.")));

    return;
}


/*
 ** ClearVolumeListInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void ClearVolumeListInfo(HVOLUMELIST hvl)
{
    ARRAYINDEX aicPtrs;
    ARRAYINDEX ai;

    ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

    aicPtrs = GetPtrCount(((PCVOLUMELIST)hvl)->hpa);

    for (ai = 0; ai < aicPtrs; ai++)
        ClearVolumeInfo(GetPtr(((PCVOLUMELIST)hvl)->hpa, ai));

    WARNING_OUT((TEXT("ClearVolumeListInfo(): Volume cache cleared.")));

    return;
}


/*
 ** AddVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE VOLUMERESULT AddVolume(HVOLUMELIST hvl, LPCTSTR pcszPath,
        PHVOLUME phvol, LPTSTR pszPathSuffixBuf,
        int cchMax)
{
    VOLUMERESULT vr;
    TCHAR rgchPath[MAX_PATH_LEN];
    LPTSTR pszFileName;
    DWORD dwPathLen;

    ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));
    ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(phvol, HVOLUME));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPathSuffixBuf, STR, cchMax));

    dwPathLen = GetFullPathName(pcszPath, ARRAYSIZE(rgchPath), rgchPath,
            &pszFileName);

    if (dwPathLen > 0 && dwPathLen < ARRAYSIZE(rgchPath))
    {
        ARRAYINDEX aiFound;

        /* Does a volume for this root path already exist? */

        if (LinearSearchArray(((PVOLUMELIST)hvl)->hpa,
                    &SearchForVolumeByRootPathCmp, rgchPath,
                    &aiFound))
        {
            PVOLUME pvol;
            LPCTSTR pcszVolumeRootPath;

            /* Yes. */

            pvol = GetPtr(((PVOLUMELIST)hvl)->hpa, aiFound);

            LockVolume(pvol);

            ASSERT(pvol->vs == VS_AVAILABLE &&
                    IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID));

            pcszVolumeRootPath = GetString(pvol->hsRootPath);

            ASSERT(lstrlen(pcszVolumeRootPath) <= lstrlen(rgchPath));

            lstrcpyn(pszPathSuffixBuf, rgchPath + lstrlen(pcszVolumeRootPath), cchMax);

            *phvol = (HVOLUME)pvol;
            vr = VR_SUCCESS;
        }
        else
        {
            DWORD dwOutFlags;
            TCHAR rgchNetResource[MAX_PATH_LEN];
            LPTSTR pszRootPathSuffix;

            /* No.  Create a new volume. */

            if (GetCanonicalPathInfo(pcszPath, rgchPath, &dwOutFlags,
                        rgchNetResource, &pszRootPathSuffix))
            {
                PLINKINFO pli;

                lstrcpyn(pszPathSuffixBuf, pszRootPathSuffix, cchMax);
                *pszRootPathSuffix = TEXT('\0');

                WARNING_OUT((TEXT("AddVolume(): Creating LinkInfo for root path %s."),
                            rgchPath));

                if (CreateLinkInfo(rgchPath, &pli))
                {
                    PVOLUME pvol;

                    if (CreateVolume((PVOLUMELIST)hvl, pli, &pvol))
                    {
                        TCHAR rgchUnusedVolumeRootPath[MAX_PATH_LEN];

                        ResolveVolumeRootPath(pvol, rgchUnusedVolumeRootPath, ARRAYSIZE(rgchUnusedVolumeRootPath));

                        *phvol = (HVOLUME)pvol;
                        vr = VR_SUCCESS;
                    }
                    else
                        vr = VR_OUT_OF_MEMORY;

                    DestroyLinkInfo(pli);
                }
                else
                    /*
                     * Differentiate between VR_UNAVAILABLE_VOLUME and
                     * VR_OUT_OF_MEMORY.
                     */
                    vr = VOLUMERESULTFromLastError(VR_UNAVAILABLE_VOLUME);
            }
            else
                vr = VOLUMERESULTFromLastError(VR_INVALID_PATH);
        }
    }
    else
    {
        ASSERT(! dwPathLen);

        vr = VOLUMERESULTFromLastError(VR_INVALID_PATH);
    }

    ASSERT(vr != VR_SUCCESS ||
            (IS_VALID_HANDLE(*phvol, VOLUME) &&
             EVAL(IsValidPathSuffix(pszPathSuffixBuf))));

    return(vr);
}


/*
 ** DeleteVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DeleteVolume(HVOLUME hvol)
{
    ASSERT(IS_VALID_HANDLE(hvol, VOLUME));

    if (! UnlockVolume((PVOLUME)hvol))
    {
        UnlinkVolume((PVOLUME)hvol);
        DestroyVolume((PVOLUME)hvol);
    }

    return;
}


/*
 ** CompareVolumes()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE COMPARISONRESULT CompareVolumes(HVOLUME hvolFirst,
        HVOLUME hvolSecond)
{
    ASSERT(IS_VALID_HANDLE(hvolFirst, VOLUME));
    ASSERT(IS_VALID_HANDLE(hvolSecond, VOLUME));

    /* This comparison works across volume lists. */

    return(CompareLinkInfoVolumes(((PCVOLUME)hvolFirst)->pli,
                ((PCVOLUME)hvolSecond)->pli));
}


/*
 ** CopyVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL CopyVolume(HVOLUME hvolSrc, HVOLUMELIST hvlDest,
        PHVOLUME phvolCopy)
{
    BOOL bResult;
    PVOLUME pvol;

    ASSERT(IS_VALID_HANDLE(hvolSrc, VOLUME));
    ASSERT(IS_VALID_HANDLE(hvlDest, VOLUMELIST));
    ASSERT(IS_VALID_WRITE_PTR(phvolCopy, HVOLUME));

    /* Is the destination volume list the source volume's volume list? */

    if (((PCVOLUME)hvolSrc)->pvlParent == (PCVOLUMELIST)hvlDest)
    {
        /* Yes.  Use the source volume. */

        LockVolume((PVOLUME)hvolSrc);
        pvol = (PVOLUME)hvolSrc;
        bResult = TRUE;
    }
    else
        bResult = CreateVolume((PVOLUMELIST)hvlDest, ((PCVOLUME)hvolSrc)->pli,
                &pvol);

    if (bResult)
        *phvolCopy = (HVOLUME)pvol;

    ASSERT(! bResult ||
            IS_VALID_HANDLE(*phvolCopy, VOLUME));

    return(bResult);
}


/*
 ** IsVolumeAvailable()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsVolumeAvailable(HVOLUME hvol)
{
    TCHAR rgchUnusedVolumeRootPath[MAX_PATH_LEN];

    ASSERT(IS_VALID_HANDLE(hvol, VOLUME));

    ResolveVolumeRootPath((PVOLUME)hvol, rgchUnusedVolumeRootPath, ARRAYSIZE(rgchUnusedVolumeRootPath));

    ASSERT(IsValidVOLUMESTATE(((PCVOLUME)hvol)->vs) &&
            ((PCVOLUME)hvol)->vs != VS_UNKNOWN);

    return(((PCVOLUME)hvol)->vs == VS_AVAILABLE);
}


/*
 ** GetVolumeRootPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void GetVolumeRootPath(HVOLUME hvol, LPTSTR pszRootPathBuf, int cchMax)
{
    ASSERT(IS_VALID_HANDLE(hvol, VOLUME));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRootPathBuf, STR, cchMax));

    ResolveVolumeRootPath((PVOLUME)hvol, pszRootPathBuf, cchMax);

    ASSERT(IsRootPath(pszRootPathBuf));

    return;
}


#ifdef DEBUG

/*
 ** DebugGetVolumeRootPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** N.b., DebugGetVolumeRootPath() must be non-intrusive.
 */
PUBLIC_CODE LPTSTR DebugGetVolumeRootPath(HVOLUME hvol, LPTSTR pszRootPathBuf, int cchMax)
{
    ASSERT(IS_VALID_HANDLE(hvol, VOLUME));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRootPathBuf, STR, cchMax));

    if (IS_FLAG_SET(((PVOLUME)hvol)->dwFlags, VOLUME_FL_ROOT_PATH_VALID))
        MyLStrCpyN(pszRootPathBuf, GetString(((PVOLUME)hvol)->hsRootPath), cchMax);
    else
        GetUnavailableVolumeRootPath(((PVOLUME)hvol)->pli, pszRootPathBuf, cchMax);

    ASSERT(IsRootPath(pszRootPathBuf));

    return(pszRootPathBuf);
}


/*
 ** GetVolumeCount()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE ULONG GetVolumeCount(HVOLUMELIST hvl)
{
    ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

    return(GetPtrCount(((PCVOLUMELIST)hvl)->hpa));
}

#endif


/*
 ** DescribeVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DescribeVolume(HVOLUME hvol, PVOLUMEDESC pvoldesc)
{
    PCVOID pcv;

    ASSERT(IS_VALID_HANDLE(hvol, VOLUME));
    ASSERT(IS_VALID_WRITE_PTR(pvoldesc, VOLUMEDESC));

    ASSERT(pvoldesc->ulSize == sizeof(*pvoldesc));

    pvoldesc->dwFlags = 0;

    if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_VOLUME_SERIAL_NUMBER, &pcv))
    {
        pvoldesc->dwSerialNumber = *(PCDWORD)pcv;
        SET_FLAG(pvoldesc->dwFlags, VD_FL_SERIAL_NUMBER_VALID);
    }
    else
        pvoldesc->dwSerialNumber = 0;

    if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_VOLUME_LABELW, &pcv) && pcv)
    {
        lstrcpyn(pvoldesc->rgchVolumeLabel, pcv, ARRAYSIZE(pvoldesc->rgchVolumeLabel));
        SET_FLAG(pvoldesc->dwFlags, VD_FL_VOLUME_LABEL_VALID);
    }
    else if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_VOLUME_LABEL, &pcv) && pcv)
    {
        MultiByteToWideChar(CP_ACP, 0, pcv, -1, pvoldesc->rgchVolumeLabel, ARRAYSIZE(pvoldesc->rgchVolumeLabel));
        SET_FLAG(pvoldesc->dwFlags, VD_FL_VOLUME_LABEL_VALID);
    }
    else
    {
        pvoldesc->rgchVolumeLabel[0] = TEXT('\0');
    }

    if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_NET_RESOURCEW, &pcv) && pcv)
    {
        lstrcpyn(pvoldesc->rgchNetResource, pcv, ARRAYSIZE(pvoldesc->rgchNetResource));
        SET_FLAG(pvoldesc->dwFlags, VD_FL_NET_RESOURCE_VALID);
    }
    else if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_NET_RESOURCE, &pcv) && pcv)
    {
        MultiByteToWideChar(CP_ACP, 0, pcv, -1, pvoldesc->rgchNetResource, ARRAYSIZE(pvoldesc->rgchNetResource));
        SET_FLAG(pvoldesc->dwFlags, VD_FL_NET_RESOURCE_VALID);
    }
    else
        pvoldesc->rgchNetResource[0] = TEXT('\0');

    ASSERT(IS_VALID_STRUCT_PTR(pvoldesc, CVOLUMEDESC));

    return;
}


/*
 ** WriteVolumeList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT WriteVolumeList(HCACHEDFILE hcf, HVOLUMELIST hvl)
{
    TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
    DWORD dwcbDBVolumeListHeaderOffset;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

    /* Save initial file position. */

    dwcbDBVolumeListHeaderOffset = GetCachedFilePointerPosition(hcf);

    if (dwcbDBVolumeListHeaderOffset != INVALID_SEEK_POSITION)
    {
        DBVOLUMELISTHEADER dbvlh;

        /* Leave space for volume list header. */

        ZeroMemory(&dbvlh, sizeof(dbvlh));

        if (WriteToCachedFile(hcf, (PCVOID)&dbvlh, sizeof(dbvlh), NULL))
        {
            ARRAYINDEX aicPtrs;
            ARRAYINDEX ai;
            UINT ucbMaxLinkInfoLen = 0;
            LONG lcVolumes = 0;

            tr = TR_SUCCESS;

            aicPtrs = GetPtrCount(((PCVOLUMELIST)hvl)->hpa);

            /* Write all volumes. */

            for (ai = 0; ai < aicPtrs; ai++)
            {
                PVOLUME pvol;

                pvol = GetPtr(((PCVOLUMELIST)hvl)->hpa, ai);

                /*
                 * As a sanity check, don't save any volume with a lock count of 0.
                 * A 0 lock count implies that the volume has not been referenced
                 * since it was restored from the database, or something is broken.
                 */

                if (pvol->ulcLock > 0)
                {
                    tr = WriteVolume(hcf, pvol);

                    if (tr == TR_SUCCESS)
                    {
                        ASSERT(lcVolumes < LONG_MAX);
                        lcVolumes++;

                        if (pvol->pli->ucbSize > ucbMaxLinkInfoLen)
                            ucbMaxLinkInfoLen = pvol->pli->ucbSize;
                    }
                    else
                        break;
                }
                else
                    ERROR_OUT((TEXT("WriteVolumeList(): VOLUME has 0 lock count and will not be written.")));
            }

            /* Save volume list header. */

            if (tr == TR_SUCCESS)
            {
                dbvlh.lcVolumes = lcVolumes;
                dbvlh.ucbMaxLinkInfoLen = ucbMaxLinkInfoLen;

                tr = WriteDBSegmentHeader(hcf, dwcbDBVolumeListHeaderOffset,
                        &dbvlh, sizeof(dbvlh));

                TRACE_OUT((TEXT("WriteVolumeList(): Wrote %ld volumes; maximum LinkInfo length %u bytes."),
                            dbvlh.lcVolumes,
                            dbvlh.ucbMaxLinkInfoLen));
            }
        }
    }

    return(tr);
}


/*
 ** ReadVolumeList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT ReadVolumeList(HCACHEDFILE hcf, HVOLUMELIST hvl,
        PHHANDLETRANS phht)
{
    TWINRESULT tr;
    DBVOLUMELISTHEADER dbvlh;
    DWORD dwcbRead;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));
    ASSERT(IS_VALID_WRITE_PTR(phht, HHANDLETRANS));

    if (ReadFromCachedFile(hcf, &dbvlh, sizeof(dbvlh), &dwcbRead) &&
            dwcbRead == sizeof(dbvlh))
    {
        HHANDLETRANS hht;

        tr = TR_OUT_OF_MEMORY;

        if (CreateHandleTranslator(dbvlh.lcVolumes, &hht))
        {
            PLINKINFO pliBuf;

            if (AllocateMemory(dbvlh.ucbMaxLinkInfoLen, &pliBuf))
            {
                LONG l;

                tr = TR_SUCCESS;

                TRACE_OUT((TEXT("ReadPathList(): Reading %ld volumes; maximum LinkInfo length %u bytes."),
                            dbvlh.lcVolumes,
                            dbvlh.ucbMaxLinkInfoLen));

                for (l = 0; l < dbvlh.lcVolumes; l++)
                {
                    tr = ReadVolume(hcf, (PVOLUMELIST)hvl, pliBuf,
                            dbvlh.ucbMaxLinkInfoLen, hht);

                    if (tr != TR_SUCCESS)
                    {
                        break;
                    }
                }

                if (tr == TR_SUCCESS)
                {
                    PrepareForHandleTranslation(hht);
                    *phht = hht;

                    ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));
                    ASSERT(IS_VALID_HANDLE(*phht, HANDLETRANS));
                }
                FreeMemory(pliBuf);
            }

            if (tr != TR_SUCCESS)
            {
                DestroyHandleTranslator(hht);
                hht = NULL;
            }
        }
    }
    else
    {
        tr = TR_CORRUPT_BRIEFCASE;
    }

    ASSERT(tr != TR_SUCCESS ||
            (IS_VALID_HANDLE(hvl, VOLUMELIST) &&
             IS_VALID_HANDLE(*phht, HANDLETRANS)));

    return(tr);
}


/*
 ** IsValidHVOLUME()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidHVOLUME(HVOLUME hvol)
{
    return(IS_VALID_STRUCT_PTR((PCVOLUME)hvol, CVOLUME));
}


#if defined(DEBUG) || defined(VSTF)

/*
 ** IsValidHVOLUMELIST()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidHVOLUMELIST(HVOLUMELIST hvl)
{
    return(IS_VALID_STRUCT_PTR((PCVOLUMELIST)hvl, CVOLUMELIST));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\util.c ===
/*
 * util.c - Miscellaneous utility functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include <uastrfnc.h>  // for ualstrcpyn (used on unaligned UNICODE strings)

/****************************** Public Functions *****************************/


/*
** NotifyShell()
**
** Notifies the Shell of an event.
**
** Arguments:     pcszPath - path string related to event
**                nse - event
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void NotifyShell(LPCTSTR pcszPath, NOTIFYSHELLEVENT nse)
{

   /*
    * N.b., these events must match the enumerated NOTIFYSHELLEVENT values in
    * util.h.
    */
   static const LONG SrgclShellEvents[] =
   {
      SHCNE_CREATE,
      SHCNE_DELETE,
      SHCNE_MKDIR,
      SHCNE_RMDIR,
      SHCNE_UPDATEITEM,
      SHCNE_UPDATEDIR
   };

#ifdef DEBUG

   static const LPCTSTR SrgpcszShellEvents[] =
   {
      TEXT("create item"),
      TEXT("delete item"),
      TEXT("create folder"),
      TEXT("delete folder"),
      TEXT("update item"),
      TEXT("update folder")
   };

#endif

   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(nse < ARRAY_ELEMENTS(SrgclShellEvents));
   ASSERT(nse < ARRAY_ELEMENTS(SrgpcszShellEvents));

   TRACE_OUT((TEXT("NotifyShell(): Sending %s notification for %s."),
              SrgpcszShellEvents[nse],
              pcszPath));

   SHChangeNotify(SrgclShellEvents[nse], SHCNF_PATH, pcszPath, NULL);
}


/*
** ComparePathStringsByHandle()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT ComparePathStringsByHandle(HSTRING hsFirst,
                                                        HSTRING hsSecond)
{
   ASSERT(IS_VALID_HANDLE(hsFirst, STRING));
   ASSERT(IS_VALID_HANDLE(hsSecond, STRING));

   return(CompareStringsI(hsFirst, hsSecond));
}


/*
** MyLStrCmpNI()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT MyLStrCmpNI(LPCTSTR pcsz1, LPCTSTR pcsz2, int ncbLen)
{
   int n = 0;

   ASSERT(IS_VALID_STRING_PTR(pcsz1, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcsz2, CSTR));
   ASSERT(ncbLen >= 0);

   while (ncbLen > 0 &&
          ! (n = PtrToUlong(CharLower((LPTSTR)(ULONG_PTR)*pcsz1))
               - PtrToUlong(CharLower((LPTSTR)(ULONG_PTR)*pcsz2))) &&
          *pcsz1)
   {
      pcsz1++;
      pcsz2++;
      ncbLen--;
   }

   return(MapIntToComparisonResult(n));
}


/*

/*
** ComposePath()
**
** Composes a path string given a folder and a filename.
**
** Arguments:     pszBuffer - path string that is created
**                pcszFolder - path string of the folder
**                pcszName - path to append
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., truncates path to MAX_PATH_LEN bytes in length.
*/
PUBLIC_CODE void ComposePath(LPTSTR pszBuffer, LPCTSTR pcszFolder, LPCTSTR pcszName, int cchMax)
{
   ASSERT(IS_VALID_STRING_PTR(pszBuffer, STR));
   ASSERT(IS_VALID_STRING_PTR(pcszFolder, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszBuffer, STR, cchMax));

   //
   // REARCHITECT - BobDay - We should figure out who needs this unaligned thing
   // and remove it from here.  The function prototype doesn't mention any
   // unaligned stuff so we must have a bug somewhere.
   // Consider adding a debug check here for an unaligned pcszFolder pointer
   // and assert when it occurs so we can debug it.
   //
   ualstrcpyn(pszBuffer, pcszFolder, cchMax);

   CatPath(pszBuffer, pcszName, cchMax);

   ASSERT(IS_VALID_STRING_PTR(pszBuffer, STR));

   return;
}


/*
** ExtractFileName()
**
** Extracts the file name from a path name.
**
** Arguments:     pcszPathName - path string from which to extract file name
**
** Returns:       Pointer to file name in path string.
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR ExtractFileName(LPCTSTR pcszPathName)
{
   LPCTSTR pcszLastComponent;
   LPCTSTR pcsz;

   ASSERT(IS_VALID_STRING_PTR(pcszPathName, CSTR));

   for (pcszLastComponent = pcsz = pcszPathName;
        *pcsz;
        pcsz = CharNext(pcsz))
   {
      if (IS_SLASH(*pcsz) || *pcsz == COLON)
         pcszLastComponent = CharNext(pcsz);
   }

   ASSERT(IS_VALID_STRING_PTR(pcszLastComponent, CSTR));

   return(pcszLastComponent);
}


/*
** ExtractExtension()
**
** Extracts the extension from a file.
**
** Arguments:     pcszName - name whose extension is to be extracted
**
** Returns:       If the name contains an extension, a pointer to the period at
**                the beginning of the extension is returned.  If the name has
**                no extension, a pointer to the name's null terminator is
**                returned.
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR ExtractExtension(LPCTSTR pcszName)
{
   LPCTSTR pcszLastPeriod;

   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));

   /* Make sure we have an isolated file name. */

   pcszName = ExtractFileName(pcszName);

   pcszLastPeriod = NULL;

   while (*pcszName)
   {
      if (*pcszName == PERIOD)
         pcszLastPeriod = pcszName;

      pcszName = CharNext(pcszName);
   }

   if (! pcszLastPeriod)
   {
      /* Point at null terminator. */

      pcszLastPeriod = pcszName;
      ASSERT(! *pcszLastPeriod);
   }
   else
      /* Point at period at beginning of extension. */
      ASSERT(*pcszLastPeriod == PERIOD);

   ASSERT(IS_VALID_STRING_PTR(pcszLastPeriod, CSTR));

   return(pcszLastPeriod);
}


/*
** GetHashBucketIndex()
**
** Calculates the hash bucket index for a string.
**
** Arguments:     pcsz - pointer to string whose hash bucket index is to be
**                        calculated
**                hbc - number of hash buckets in string table
**
** Returns:       Hash bucket index for string.
**
** Side Effects:  none
**
** The hashing function used is the sum of the byte values in the string modulo
** the number of buckets in the hash table.
*/
PUBLIC_CODE HASHBUCKETCOUNT GetHashBucketIndex(LPCTSTR pcsz,
                                               HASHBUCKETCOUNT hbc)
{
   ULONG ulSum;

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
   ASSERT(hbc > 0);

   /* Don't worry about overflow here. */

   for (ulSum = 0; *pcsz; pcsz++)
      ulSum += *pcsz;

   return((HASHBUCKETCOUNT)(ulSum % hbc));
}


/*
** RegKeyExists()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL RegKeyExists(HKEY hkeyParent, LPCTSTR pcszSubKey)
{
   BOOL bResult;
   HKEY hkeySubKey;

   ASSERT(IS_VALID_HANDLE(hkeyParent, KEY));
   ASSERT(IS_VALID_STRING_PTR(pcszSubKey, CSTR));

   bResult = (RegOpenKeyEx(hkeyParent, pcszSubKey, 0, KEY_QUERY_VALUE,
                           &hkeySubKey)
              == ERROR_SUCCESS);

   if (bResult)
      EVAL(RegCloseKey(hkeySubKey) == ERROR_SUCCESS);

   return(bResult);
}


/*
** CopyLinkInfo()
**
** Copies LinkInfo into local memory.
**
** Arguments:     pcliSrc - source LinkInfo
**                ppliDest - pointer to PLINKINFO to be filled in with pointer
**                           to local copy
**
** Returns:       TRUE if successful.  FALSE if not.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CopyLinkInfo(PCLINKINFO pcliSrc, PLINKINFO *ppliDest)
{
   BOOL bResult;
   DWORD dwcbSize;

   ASSERT(IS_VALID_STRUCT_PTR(pcliSrc, CLINKINFO));
   ASSERT(IS_VALID_WRITE_PTR(ppliDest, PLINKINFO));

   dwcbSize = *(PDWORD)pcliSrc;

   bResult = AllocateMemory(dwcbSize, ppliDest);

   if (bResult)
      CopyMemory(*ppliDest, pcliSrc, dwcbSize);

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*ppliDest, CLINKINFO));

   return(bResult);
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidPCLINKINFO()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCLINKINFO(PCLINKINFO pcli)
{
   BOOL bResult;

   if (IS_VALID_READ_BUFFER_PTR(pcli, CDWORD, sizeof(DWORD)) &&
       IS_VALID_READ_BUFFER_PTR(pcli, CLINKINFO, (UINT)*(PDWORD)pcli))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\volume.h ===
/*
 * volume.h - Volume ADT module description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HVOLUMELIST);
DECLARE_STANDARD_TYPES(HVOLUMELIST);

DECLARE_HANDLE(HVOLUME);
DECLARE_STANDARD_TYPES(HVOLUME);

/* volume results returned by AddVolume() */

typedef enum _volumeresult
{
   VR_SUCCESS,

   VR_UNAVAILABLE_VOLUME,

   VR_OUT_OF_MEMORY,

   VR_INVALID_PATH
}
VOLUMERESULT;
DECLARE_STANDARD_TYPES(VOLUMERESULT);


/* Prototypes
 *************/

/* volume.c */

extern BOOL CreateVolumeList(DWORD, HWND, PHVOLUMELIST);
extern void DestroyVolumeList(HVOLUMELIST);
extern void InvalidateVolumeListInfo(HVOLUMELIST);
PUBLIC_CODE void ClearVolumeListInfo(HVOLUMELIST);
extern VOLUMERESULT AddVolume(HVOLUMELIST, LPCTSTR, PHVOLUME, LPTSTR, int);
extern void DeleteVolume(HVOLUME);
extern COMPARISONRESULT CompareVolumes(HVOLUME, HVOLUME);
extern BOOL CopyVolume(HVOLUME, HVOLUMELIST, PHVOLUME);
extern BOOL IsVolumeAvailable(HVOLUME);
extern void GetVolumeRootPath(HVOLUME, LPTSTR, int);

#ifdef DEBUG

extern LPTSTR DebugGetVolumeRootPath(HVOLUME, LPTSTR, int);
extern ULONG GetVolumeCount(HVOLUMELIST);

#endif

extern void DescribeVolume(HVOLUME, PVOLUMEDESC);
extern TWINRESULT WriteVolumeList(HCACHEDFILE, HVOLUMELIST);
extern TWINRESULT ReadVolumeList(HCACHEDFILE, HVOLUMELIST, PHHANDLETRANS);
extern BOOL IsValidHVOLUME(HVOLUME);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidHVOLUMELIST(HVOLUMELIST);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\valid.c ===
/*
 * valid.c - Validation functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/****************************** Public Functions *****************************/


/*
** IsValidHANDLE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHANDLE(HANDLE hnd)
{
   return(EVAL(hnd != INVALID_HANDLE_VALUE));
}


/*
** IsValidHFILE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHFILE(HANDLE hf)
{
   return(IsValidHANDLE(hf));
}


/*
** IsValidHWND()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHWND(HWND hwnd)
{
   /* Ask User if this is a valid window. */

   return(IsWindow(hwnd));
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidPCSECURITY_ATTRIBUTES()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCSECURITY_ATTRIBUTES(PCSECURITY_ATTRIBUTES pcsa)
{
   return(IS_VALID_READ_PTR(pcsa, CSECURITY_ATTRIBUTES));
}


/*
** IsValidFileCreationMode()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidFileCreationMode(DWORD dwMode)
{
   BOOL bResult;

   switch (dwMode)
   {
      case CREATE_NEW:
      case CREATE_ALWAYS:
      case OPEN_EXISTING:
      case OPEN_ALWAYS:
      case TRUNCATE_EXISTING:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidFileCreationMode(): Invalid file creation mode %#lx."),
                    dwMode));
         break;
   }

   return(bResult);
}


/*
** IsValidHTEMPLATEFILE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHTEMPLATEFILE(HANDLE htf)
{
   return(IsValidHANDLE(htf));
}


/*
** IsValidPCFILETIME()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCFILETIME(PCFILETIME pcft)
{
   return(IS_VALID_READ_PTR(pcft, CFILETIME));
}

#endif


#ifdef DEBUG

/*
** IsValidHINSTANCE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHINSTANCE(HINSTANCE hinst)
{
   return(EVAL(hinst));
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** IsValidHICON()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHICON(HICON hicon)

{
   /* Any value is a valid HICON. */

   return(TRUE);
}


/*
** IsValidHKEY()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHKEY(HKEY hkey)
{
   /* Any value is a valid HKEY. */

   return(TRUE);
}


/*
** IsValidHMODULE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHMODULE(HMODULE hmod)

{
   /* Any non-NULL value is a valid HMODULE. */

   return(hmod != NULL);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** IsValidShowWindowCmd()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidShowWindowCmd(int nShow)
{
   BOOL bResult;

   switch (nShow)
   {
      case SW_HIDE:
      case SW_SHOWNORMAL:
      case SW_SHOWMINIMIZED:
      case SW_SHOWMAXIMIZED:
      case SW_SHOWNOACTIVATE:
      case SW_SHOW:
      case SW_MINIMIZE:
      case SW_SHOWMINNOACTIVE:
      case SW_SHOWNA:
      case SW_RESTORE:
      case SW_SHOWDEFAULT:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidShowWindowCmd(): Invalid file creation mode %d."),
                    nShow));
         break;
   }

   return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\canon.h ===
/*
 * canon.h - Canonical path manipulation module description.
 */


/* Constants
 ************/

#define MAX_NETRESOURCE_LEN      (2 * MAX_PATH_LEN)


/* Types
 ********/

/* NETRESOURCE buffer */

typedef union _netresourcebuf
{
   NETRESOURCE nr;

   BYTE rgbyte[MAX_NETRESOURCE_LEN];
}
NETRESOURCEBUF;
DECLARE_STANDARD_TYPES(NETRESOURCEBUF);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\canon.c ===
/*
 * canon.c - Canonical path manipulation module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL GetCNRInfoForDevice(LPTSTR, LPTSTR, PDWORD, PDWORD);
PRIVATE_CODE BOOL GetDrivePathInfo(LPTSTR, PDWORD, LPTSTR, LPTSTR *);
PRIVATE_CODE BOOL GetRemotePathInfo(LPTSTR, PDWORD, LPTSTR, LPTSTR *);
PRIVATE_CODE void CanonicalizeTrailingSlash(LPTSTR);

#ifdef DEBUG

PRIVATE_CODE BOOL CheckFullPathInfo(LPCTSTR, PDWORD, LPCTSTR, LPCTSTR *);

#endif


/*
 ** GetCNRInfoForDevice()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       BOOL
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL GetCNRInfoForDevice(LPTSTR pszDeviceName, LPTSTR pszNameBuf,
        PDWORD pdwcbLen, PDWORD pdwOutFlags)
{
    DWORD dwNetResult;
    BOOL bResult;
    /* "X:" + null terminator */
    TCHAR rgchDrive[2 + 1];

    ASSERT(IS_VALID_STRING_PTR(pszDeviceName, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(pdwcbLen, DWORD));
    ASSERT(*pdwcbLen > 0);
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszNameBuf, TCHAR, (UINT)(*pdwcbLen)));
    ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));

    /* WNetGetConnection requires the device name to have no trailing
     ** backslash.
     */
    MyLStrCpyN(rgchDrive, pszDeviceName, ARRAYSIZE(rgchDrive));
    dwNetResult = WNetGetConnection(rgchDrive, pszNameBuf, pdwcbLen);

    switch (dwNetResult)
    {
        case NO_ERROR:
            *pdwOutFlags = GCPI_OFL_REMOTE;
            bResult = TRUE;
            TRACE_OUT((TEXT("GetCNRInfoForDevice(): %s is redirected to net resource \"%s\"."),
                        pszDeviceName,
                        pszNameBuf));
            break;

        case ERROR_NOT_CONNECTED:
            *pdwOutFlags = 0;
            bResult = TRUE;
            TRACE_OUT((TEXT("GetCNRInfoForDevice(): %s is not redirected."),
                        pszDeviceName));
            break;

        default:
            WARNING_OUT((TEXT("GetCNRInfoForDevice(): WNetGetConnection() on %s returned %lu."),
                        pszDeviceName,
                        dwNetResult));
            bResult = FALSE;
            break;
    }

    ASSERT(! bResult ||
            FLAGS_ARE_VALID(*pdwOutFlags, ALL_GCPI_OFLAGS) &&
            (IS_FLAG_CLEAR(*pdwOutFlags, GCPI_OFL_REMOTE) ||
             IsValidCNRName(pszNameBuf)));

    return(bResult);
}


/*
 ** GetDrivePathInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL GetDrivePathInfo(LPTSTR pszDrivePath, PDWORD pdwOutFlags,
        LPTSTR pszNetResourceNameBuf,
        LPTSTR *ppszRootPathSuffix)
{
    BOOL bResult;
    /* "X:\" + null terminator. */
    TCHAR rgchDriveRootPath[3 + 1];

    ASSERT(IsDrivePath(pszDrivePath));
    ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszNetResourceNameBuf, STR, MAX_PATH_LEN));
    ASSERT(IS_VALID_WRITE_PTR(ppszRootPathSuffix, LPTSTR));

    ASSERT(lstrlen(pszDrivePath) >= 3);

    *pdwOutFlags = 0;

    MyLStrCpyN(rgchDriveRootPath, pszDrivePath, ARRAYSIZE(rgchDriveRootPath));

    ASSERT(IsDriveRootPath(rgchDriveRootPath));

    /* Do we need to get the CNR name for this drive path? */

    if (GetDriveType(rgchDriveRootPath) != DRIVE_REMOTE)
        /* No. */
        bResult = TRUE;
    else
    {
        DWORD dwcbBufLen = MAX_PATH_LEN;

        /* Yes. */

        bResult = GetCNRInfoForDevice(rgchDriveRootPath, pszNetResourceNameBuf,
                &dwcbBufLen, pdwOutFlags);
    }

    *ppszRootPathSuffix = pszDrivePath + 3;

    ASSERT(! bResult ||
            CheckFullPathInfo(pszDrivePath, pdwOutFlags, pszNetResourceNameBuf,
                ppszRootPathSuffix));

    return(bResult);
}


/*
 ** GetRemotePathInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL GetRemotePathInfo(LPTSTR pszRemotePath, PDWORD pdwOutFlags,
        LPTSTR pszNetResourceNameBuf,
        LPTSTR *ppszRootPathSuffix)
{
    BOOL bResult;

    ASSERT(IsFullPath(pszRemotePath));
    ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszNetResourceNameBuf, STR, MAX_PATH_LEN));
    ASSERT(IS_VALID_WRITE_PTR(ppszRootPathSuffix, LPTSTR));

    /* Is this a "\\server\share" name? */

    bResult = IsUNCPath(pszRemotePath);

    if (bResult)
    {
        LPTSTR psz;

        *pdwOutFlags = 0;

        /*
         * Yes.  Skip two leading slashes and look for end of \\server\share
         * specification.
         */

        /* Assume (as above) that a slash cannot be a DBCS lead byte. */

        for (psz = pszRemotePath + 2; ! IS_SLASH(*psz); psz = CharNext(psz))
            ASSERT(*psz);

        ASSERT(IS_SLASH(*psz));

        /*
         * Found first slash after double slash.  Find end of string or next
         * slash as end of root specification.
         */

        for (psz = CharNext(psz); *psz; psz = CharNext(psz))
        {
            if (IS_SLASH(*psz))
                break;
        }

        ASSERT(psz >= pszRemotePath);

        /* Add trailing slash for UNC root path. */

        if (! *psz)
        {
            *psz = SLASH;
            *(psz + 1) = TEXT('\0');
        }

        *ppszRootPathSuffix = (LPTSTR)psz + 1;

        ASSERT(! IS_SLASH(**ppszRootPathSuffix));

        /* (+ 1) for null terminator. */

        MyLStrCpyN(pszNetResourceNameBuf, pszRemotePath, (int)(psz - pszRemotePath + 1));

        CharUpper(pszNetResourceNameBuf);

        SET_FLAG(*pdwOutFlags, GCPI_OFL_REMOTE);
        bResult = TRUE;
    }
    else
        /* Not a UNC path. */
        SetLastError(ERROR_BAD_PATHNAME);

    ASSERT(! bResult ||
            CheckFullPathInfo(pszRemotePath, pdwOutFlags, pszNetResourceNameBuf,
                ppszRootPathSuffix));

    return(bResult);
}


/*
 ** CanonicalizeTrailingSlash()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void CanonicalizeTrailingSlash(LPTSTR pszRootPathSuffix)
{
    LPTSTR pszLast;

    ASSERT(IS_VALID_STRING_PTR(pszRootPathSuffix, STR));

    ASSERT(! IS_SLASH(*pszRootPathSuffix));

    /* No path suffix should end in a slash. */

    pszLast = CharPrev(pszRootPathSuffix,
            pszRootPathSuffix + lstrlen(pszRootPathSuffix));

    if (IS_SLASH(*pszLast))
        *pszLast = TEXT('\0');

    ASSERT(IsValidPathSuffix(pszRootPathSuffix));

    return;
}


#ifdef DEBUG

/*
 ** CheckFullPathInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CheckFullPathInfo(LPCTSTR pcszFullPath,
        PDWORD pdwOutFlags,
        LPCTSTR pcszNetResourceName,
        LPCTSTR *ppcszRootPathSuffix)
{
    return(EVAL(IsFullPath(pcszFullPath)) &&
            FLAGS_ARE_VALID(*pdwOutFlags, ALL_GCPI_OFLAGS) &&
            (IS_FLAG_CLEAR(*pdwOutFlags, GCPI_OFL_REMOTE) ||
             (EVAL(IsValidCNRName(pcszNetResourceName)) &&
              EVAL(lstrlen(pcszNetResourceName) < MAX_PATH_LEN))) &&
            (IS_FLAG_SET(*pdwOutFlags, GCPI_OFL_REMOTE) ||
             EVAL(IsLocalDrivePath(pcszFullPath))) &&
            IS_VALID_STRING_PTR(*ppcszRootPathSuffix, CSTR) &&
            EVAL(IsStringContained(pcszFullPath, *ppcszRootPathSuffix)));
}

#endif


/***************************** Exported Functions ****************************/


/******************************************************************************

  @doc LINKINFOAPI

  @func BOOL | GetCanonicalPathInfo | Retrieves information about the canonical
  form of a path.

  @parm PCSTR | pcszPath | A pointer to the path string whose canonical form
  information is to be retrieved.

  @parm PSTR | pszCanonicalBuf | A pointer to a buffer to be filled in with the
  full canonical form of the path.  This buffer must be at least MAX_PATH_LEN
  bytes long.

  @parm PDWORD | pdwOutFlags | A pointer to a DWORD bit mask of flags to be
  filled in with flags from the <t GETCANONICALPATHINFOOUTFLAGS> enumeration.

  @parm PSTR | pszNetResourceNameBuf | A pointer to a buffer to be filled in with
  the name of the net resource parent of the path.  This buffer must be at least
  MAX_PATH_LEN bytes long.  This buffer is only filled in if GCPI_OFL_REMOTE is
  set in *pdwOutFlags.

  @parm PSTR * | ppszRootPathSuffix | A pointer to a PSTR to be filled in with a
  pointer to the file system root path suffix, not including the leading slash,
  of the canonical path in pszCanonicalBuf's buffer.

  @rdesc If the function completed successfully, TRUE is returned.  Otherwise,
  FALSE is returned.  The reason for failure may be determined by calling
  GetLastError().

 ******************************************************************************/

LINKINFOAPI BOOL WINAPI GetCanonicalPathInfo(LPCTSTR pcszPath,
        LPTSTR pszCanonicalBuf,
        PDWORD pdwOutFlags,
        LPTSTR pszNetResourceNameBuf,
        LPTSTR *ppszRootPathSuffix)
{
    BOOL bResult;
    LPTSTR pszFileName;
    DWORD dwPathLen;

    ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszCanonicalBuf, STR, MAX_PATH_LEN));
    ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));
    ASSERT(IS_VALID_WRITE_PTR(ppszRootPathSuffix, LPTSTR));

    dwPathLen = GetFullPathName(pcszPath, MAX_PATH_LEN, pszCanonicalBuf,
            &pszFileName);

    if (dwPathLen > 0 && dwPathLen < MAX_PATH_LEN)
    {
        /*
         * Assume that GetFullPathName() changed all back slashes ('/') to
         * forward slashes ('\\').
         */

        ASSERT(! MyStrChr(pszCanonicalBuf, TEXT('/'), NULL));

        if (IsDrivePath(pszCanonicalBuf))
            bResult = GetDrivePathInfo(pszCanonicalBuf, pdwOutFlags,
                    pszNetResourceNameBuf,
                    ppszRootPathSuffix);
        else
            bResult = GetRemotePathInfo(pszCanonicalBuf, pdwOutFlags,
                    pszNetResourceNameBuf,
                    ppszRootPathSuffix);

        if (bResult)
            CanonicalizeTrailingSlash(*ppszRootPathSuffix);
    }
    else
    {
        // BOGUS ASSERT:  We can also get here if the resulting full path
        // is bigger than MAX_PATH_LEN.
        // ASSERT(! dwPathLen);

        WARNING_OUT((TEXT("GetFullPathName() failed on path %s, returning %lu."),
                    pcszPath,
                    dwPathLen));

        bResult = FALSE;
    }

    ASSERT(! bResult ||
            (CheckFullPathInfo(pszCanonicalBuf, pdwOutFlags,
                               pszNetResourceNameBuf, ppszRootPathSuffix) &&
             IsValidPathSuffix(*ppszRootPathSuffix)));

    return(bResult);
}

#ifdef UNICODE
LINKINFOAPI BOOL WINAPI GetCanonicalPathInfoA(LPCSTR pcszPath,
        LPSTR pszCanonicalBuf,
        PDWORD pdwOutFlags,
        LPSTR pszNetResourceNameBuf,
        LPSTR *ppszRootPathSuffix)
{
    LPWSTR  pcszWidePath;
    UINT    cchPath;
    WCHAR   szWideCanonicalBuf[MAX_PATH];
    WCHAR   szWideNetResourceNameBuf[MAX_PATH];
    LPWSTR  pszWideRootPathSuffix;
    UINT_PTR chOffset;
    BOOL    fCanonical;

    cchPath = lstrlenA(pcszPath) + 1;

    pcszWidePath = (LPWSTR)_alloca(cchPath*SIZEOF(WCHAR));

    if (MultiByteToWideChar( CP_ACP, 0,
                pcszPath, cchPath,
                pcszWidePath, cchPath) == 0)
    {
        return FALSE;
    }
    fCanonical = GetCanonicalPathInfo( pcszWidePath,
            szWideCanonicalBuf,
            pdwOutFlags,
            szWideNetResourceNameBuf,
            &pszWideRootPathSuffix );
    if ( fCanonical )
    {
        if (WideCharToMultiByte( CP_ACP, 0,
                    szWideCanonicalBuf, -1,
                    pszCanonicalBuf, MAX_PATH,
                    NULL, NULL ) == 0)
        {
            return FALSE;
        }
        if ( *pdwOutFlags & GCPI_OFL_REMOTE )
        {
            if (WideCharToMultiByte( CP_ACP, 0,
                        szWideNetResourceNameBuf, -1,
                        pszNetResourceNameBuf, MAX_PATH,
                        NULL, NULL ) == 0)
            {
                return FALSE;
            }
        }
        chOffset = pszWideRootPathSuffix - szWideCanonicalBuf;
        *ppszRootPathSuffix = pszCanonicalBuf;
        while ( chOffset-- )
        {
            *ppszRootPathSuffix = CharNextA(*ppszRootPathSuffix);
        }
    }

    return(fCanonical);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\cnrlink.h ===
/*
 * cnrlink.h - CNRLink ADT module description.
 */


/* Types
 ********/

typedef struct _cnrlink
{
   int nUnused;
}
CNRLINK;
DECLARE_STANDARD_TYPES(CNRLINK);

typedef enum _cnrflags
{
   CNR_FL_LOCAL      = 0x0001,

   ALL_CNR_FLAGS     = CNR_FL_LOCAL
}
CNRFLAGS;


/* Prototypes
 *************/

/* cnrlink.c */

extern BOOL CreateLocalCNRLink(LPCTSTR, PCNRLINK *, PUINT, LPTSTR, int, LPCTSTR *);
extern BOOL CreateRemoteCNRLink(LPCTSTR, LPCTSTR, PCNRLINK *, PUINT);
extern void DestroyCNRLink(PCNRLINK);
extern COMPARISONRESULT CompareCNRLinks(PCCNRLINK, PCCNRLINK);
extern BOOL IsLocalCNRLink(PCCNRLINK, PBOOL);
extern BOOL GetLocalPathFromCNRLink(PCCNRLINK, LPTSTR, PDWORD);
extern void GetRemotePathFromCNRLink(PCCNRLINK, LPTSTR, int);
extern BOOL ConnectToCNR(PCCNRLINK, DWORD, HWND, LPTSTR, PDWORD);
extern BOOL DisconnectFromCNR(PCCNRLINK);
extern BOOL IsCNRAvailable(PCCNRLINK);
extern UINT GetCNRLinkLen(PCCNRLINK);
extern BOOL GetCNRNetType(PCCNRLINK, PCDWORD *);
extern BOOL GetCNRName(PCCNRLINK, LPCSTR *);
extern BOOL GetLastRedirectedDevice(PCCNRLINK, LPCSTR *);
#ifdef UNICODE
extern BOOL GetCNRNameW(PCCNRLINK, LPCWSTR *);
extern BOOL GetLastRedirectedDeviceW(PCCNRLINK, LPCWSTR *);
#endif

#if defined(DEBUG) || defined (VSTF)

extern BOOL IsValidPCCNRLINK(PCCNRLINK);

#endif

#ifdef DEBUG

extern void DumpCNRLink(PCCNRLINK);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\makefile.inc ===
#
# Copy shared source code.
#

SHARED_DIR=..\core

$(O)\init.c : $(SHARED_DIR)\init.c
    copy $? $@

$(O)\serial.c : $(SHARED_DIR)\serial.c
    copy $? $@

$(O)\memmgr.c : $(SHARED_DIR)\memmgr.c
    copy $? $@

$(O)\valid.c : $(SHARED_DIR)\valid.c
    copy $? $@

$(O)\comc.c : $(SHARED_DIR)\comc.c
    copy $? $@

$(O)\inifile.c : $(SHARED_DIR)\inifile.c
    copy $? $@

$(O)\resstr.c : $(SHARED_DIR)\resstr.c
    copy $? $@

$(O)\debug.c : $(SHARED_DIR)\debug.c
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\cnrlink.c ===
/*
 * cnrlink.c - CNRLink ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "cnrlink.h"
#include "server.h"


/* Constants
 ************/

/* WNetUseConnection() flag combinations */

#define ALL_CONNECT_IN_FLAGS     (CONNECT_UPDATE_PROFILE |\
        CONNECT_UPDATE_RECENT |\
        CONNECT_TEMPORARY |\
        CONNECT_INTERACTIVE |\
        CONNECT_PROMPT |\
        CONNECT_REDIRECT)

#define ALL_CONNECT_OUT_FLAGS    (CONNECT_REFCOUNT |\
        CONNECT_LOCALDRIVE)


/* Macros
 *********/

/* macros for accessing ICNRLINK data */

#define ICNRL_Remote_Name_PtrA(picnrl) \
((LPSTR)(((PBYTE)(picnrl)) + (picnrl)->ucbNetNameOffset))

#define ICNRL_Device_PtrA(picnrl) \
((LPSTR)(((PBYTE)(picnrl)) + (picnrl)->ucbDeviceOffset))

#define ICNRL_Remote_Name_PtrW(picnrl) \
((LPWSTR)(((PBYTE)(picnrl)) + (picnrl)->ucbNetNameOffsetW))

#define ICNRL_Device_PtrW(picnrl) \
((LPWSTR)(((PBYTE)(picnrl)) + (picnrl)->ucbDeviceOffsetW))

#define IS_ICNRL_ANSI(picnrl) \
((PBYTE)(picnrl) + ((PICNRLINKW)(picnrl))->ucbNetNameOffset) == (PBYTE)&(((PICNRLINKW)(picnrl))->ucbNetNameOffsetW)

#ifdef UNICODE
#define ICNRL_Remote_Name_Ptr(picnrl)   ICNRL_Remote_Name_PtrW(picnrl)
#define ICNRL_Device_Ptr(picnrl)        ICNRL_Device_PtrW(picnrl)
#else
#define ICNRL_Remote_Name_Ptr(picnrl)   ICNRL_Remote_Name_PtrA(picnrl)
#define ICNRL_Device_Ptr(picnrl)        ICNRL_Device_PtrA(picnrl)
#endif

    /* Types
     ********/

    /*
       @doc INTERNAL

       @enum ICNRLINKFLAGS | Internal CNRLink structure flags.
     */

    typedef enum _icnrlinkflags
{
    /*
       @emem ICNRL_FL_VALID_DEVICE | If set, last redirected drive is valid.  If
       clear, last redirected drive is not valid.
     */

    ICNRL_FL_VALID_DEVICE = 0x0001,

    /*
       @emem ICNRL_FL_VALID_NET_TYPE | If set, net type is valid.  If clear, net
       type is not valid.
     */

    ICNRL_FL_VALID_NET_TYPE = 0x0002,

    /* @emem ALL_ICNRL_FLAGS | All internal CNRLink structure flags. */

    ALL_ICNRL_FLAGS = (ICNRL_FL_VALID_DEVICE |
            ICNRL_FL_VALID_NET_TYPE)
}
ICNRLINKFLAGS;

/*
   @doc INTERNAL

   @struct ICNRLINK | Internal definition of relocatable connectable network
   resource (CNR) link structure.  An <t ILINKINFO> structure may contain an
   ICNRLINK structure.  An ICNRLINK structure consists of a header described as
   below, followed by variable-length data.
 */

typedef struct _icnrlinkA
{
    /*
       @field UINT | ucbSize | Length of ICNRLINK structure in bytes, including
       ucbSize field.
     */

    UINT ucbSize;

    /*
       @field DWORD | dwFlags | A bit mask of flags from the <t ICNRLINKFLAGS>
       enumeration.
     */

    DWORD dwFlags;

    /*
       @field UINT | ucbNetNameOffset | Offset in bytes of CNR name string from
       base of structure.  The CNR name string may be passed to
       WNetUseConnection() to add a connection to the CNR.<nl>
       Example CNRLink name string: "\\\\fredbird\\work".
     */

    UINT ucbNetNameOffset;

    /*
       @field UINT | ucbDeviceOffset | Offset in bytes of last redirected local
       device string from base of structure.  This field is only valid if
       ICNRL_FL_VALID_DEVICE is set in dwFlags.  The last redirected local
       device string may be passed to WNetUseConnection() to add a redirected
       device connection to the CNR.<nl>
       Example last redirected local device string: "D:".
     */

    UINT ucbDeviceOffset;

    /*
       @field DWORD | dwNetType | The network type as returned in a
       NETINFOSTRUCT.  This field is only valid if ICNRL_FL_VALID_NET_TYPE is
       set in dwFlags.  The net type is used to retrieve the host net resource's
       host NP's name to use in calling WNetUseConnection().<nl>
       Example net type: WNNC_NET_NETWARE.
     */

    DWORD dwNetType;
}
ICNRLINKA;
DECLARE_STANDARD_TYPES(ICNRLINKA);

#ifdef UNICODE
typedef struct _icnrlinkW
{
    /*
       @field UINT | ucbSize | Length of ICNRLINK structure in bytes, including
       ucbSize field.
     */

    UINT ucbSize;

    /*
       @field DWORD | dwFlags | A bit mask of flags from the <t ICNRLINKFLAGS>
       enumeration.
     */

    DWORD dwFlags;

    /*
       @field UINT | ucbNetNameOffset | Offset in bytes of CNR name string from
       base of structure.  The CNR name string may be passed to
       WNetUseConnection() to add a connection to the CNR.<nl>
       Example CNRLink name string: "\\\\fredbird\\work".
     */

    UINT ucbNetNameOffset;

    /*
       @field UINT | ucbDeviceOffset | Offset in bytes of last redirected local
       device string from base of structure.  This field is only valid if
       ICNRL_FL_VALID_DEVICE is set in dwFlags.  The last redirected local
       device string may be passed to WNetUseConnection() to add a redirected
       device connection to the CNR.<nl>
       Example last redirected local device string: "D:".
     */

    UINT ucbDeviceOffset;

    /*
       @field DWORD | dwNetType | The network type as returned in a
       NETINFOSTRUCT.  This field is only valid if ICNRL_FL_VALID_NET_TYPE is
       set in dwFlags.  The net type is used to retrieve the host net resource's
       host NP's name to use in calling WNetUseConnection().<nl>
       Example net type: WNNC_NET_NETWARE.
     */

    DWORD dwNetType;

    /*
       These members are for storing the unicode version of the strings
     */
    UINT ucbNetNameOffsetW;
    UINT ucbDeviceOffsetW;
}
ICNRLINKW;
DECLARE_STANDARD_TYPES(ICNRLINKW);
#endif

#ifdef UNICODE
#define ICNRLINK    ICNRLINKW
#define PICNRLINK   PICNRLINKW
#define CICNRLINK   CICNRLINKW
#define PCICNRLINK  PCICNRLINKW
#else
#define ICNRLINK    ICNRLINKA
#define PICNRLINK   PICNRLINKA
#define CICNRLINK   CICNRLINKA
#define PCICNRLINK  PCICNRLINKA
#endif

/* Exported from MPR.DLL, but not in winnetwk.h
 */
#ifdef UNICODE
DWORD APIENTRY WNetGetResourceInformationW (LPNETRESOURCE lpNetResource, LPVOID lpBuffer, LPDWORD cbBuffer, LPTSTR * lplpSystem);
#define WNetGetResourceInformation WNetGetResourceInformationW
#else
DWORD APIENTRY WNetGetResourceInformationA (LPNETRESOURCE lpNetResource, LPVOID lpBuffer, LPDWORD cbBuffer, LPTSTR * lplpSystem);
#define WNetGetResourceInformation WNetGetResourceInformationA
#endif


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL GetNetPathFromLocalPath(LPCTSTR, LPTSTR, LPCTSTR *, PBOOL, PDWORD);
PRIVATE_CODE BOOL UnifyICNRLinkInfo(LPCTSTR, DWORD, LPCTSTR, DWORD, PICNRLINK *, PUINT);
PRIVATE_CODE BOOL GetNetType(LPCTSTR, PDWORD);
PRIVATE_CODE BOOL GetNetProviderName(PCICNRLINK, LPTSTR);
PRIVATE_CODE COMPARISONRESULT CompareNetNames(LPCTSTR, LPCTSTR);
PRIVATE_CODE BOOL SearchForRedirectedConnection(PCICNRLINK, LPTSTR, int);

#if defined(DEBUG) || defined (VSTF)

PRIVATE_CODE BOOL IsValidDevice(LPCTSTR);
PRIVATE_CODE BOOL IsValidNetType(DWORD);
PRIVATE_CODE BOOL IsValidPCICNRLINK(PCICNRLINK);

#endif

#if defined(DEBUG)

PRIVATE_CODE BOOL IsValidNetProviderName(LPCTSTR);

#endif

#if 0 

DWORD APIENTRY
WNetGetNetworkInformationW(
        LPCWSTR          lpProvider,
        LPNETINFOSTRUCT   lpNetInfoStruct
        )
{
    if (wcsicmp(lpProvider, L"Microsoft Windows Network") == 0)
    {
        lpNetInfoStruct->wNetType = (WORD)WNNC_NET_LANMAN;
        return ERROR_SUCCESS;
    }
    else if (wcsicmp(lpProvider, L"Novell Network") == 0)
    {
        lpNetInfoStruct->wNetType = (WORD)WNNC_NET_NETWARE;
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_NOT_SUPPORTED;
    }
}
#endif

/*
 ** GetNetPathFromLocalPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL GetNetPathFromLocalPath(LPCTSTR pcszLocalPath,
        LPTSTR pszNetNameBuf,
        LPCTSTR *ppcszCommonPathSuffix,
        PBOOL pbIsShared, PDWORD pdwNetType)
{
    BOOL bResult = TRUE;
    PCSERVERVTABLE pcsvt;

    ASSERT(IsDrivePath(pcszLocalPath));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszNetNameBuf, STR, MAX_PATH_LEN));
    ASSERT(IS_VALID_WRITE_PTR(ppcszCommonPathSuffix, LPCTSTR));
    ASSERT(IS_VALID_WRITE_PTR(pbIsShared, BOOL));
    ASSERT(IS_VALID_WRITE_PTR(pdwNetType, DWORD));

    *pbIsShared = FALSE;

    if (GetServerVTable(&pcsvt))
    {
        TCHAR rgchSharedPath[MAX_PATH_LEN];

        ASSERT(lstrlen(pcszLocalPath) < ARRAYSIZE(rgchSharedPath));
        lstrcpyn(rgchSharedPath, pcszLocalPath, ARRAYSIZE(rgchSharedPath));

        FOREVER
        {
            if ((pcsvt->GetNetResourceFromLocalPath)(rgchSharedPath,
                        pszNetNameBuf, MAX_PATH_LEN,
                        pdwNetType))
            {
                ASSERT(lstrlen(pszNetNameBuf) < MAX_PATH_LEN);

                /* Determine common path suffix. */

                *ppcszCommonPathSuffix = pcszLocalPath + lstrlen(rgchSharedPath);

                /* Skip any leading slash. */

                if (IS_SLASH(**ppcszCommonPathSuffix))
                    *ppcszCommonPathSuffix = CharNext(*ppcszCommonPathSuffix);

                ASSERT(! IS_SLASH(**ppcszCommonPathSuffix));

                // if it is terminated with a $ it is a hidden share, in that
                // case don't consider this shared
                *pbIsShared = pszNetNameBuf[lstrlen(pszNetNameBuf) -1] != TEXT('$');

                break;
            }
            else
            {
                if (! DeleteLastDrivePathElement(rgchSharedPath))
                    break;
            }
        }
    }

    ASSERT(! bResult ||
            ! *pbIsShared ||
            (EVAL(IsUNCPath(pszNetNameBuf)) &&
             IS_VALID_STRING_PTR(*ppcszCommonPathSuffix, CSTR) &&
             EVAL(*ppcszCommonPathSuffix >= pcszLocalPath) &&
             EVAL(IsStringContained(pcszLocalPath, *ppcszCommonPathSuffix)) &&
             EVAL(IsValidNetType(*pdwNetType))));

    return(bResult);
}


/*
 ** UnifyICNRLinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL UnifyICNRLinkInfo(LPCTSTR pcszNetName, DWORD dwFlags,
        LPCTSTR pcszDevice, DWORD dwNetType,
        PICNRLINK *ppicnrl, PUINT pucbICNRLinkLen)
{
    BOOL bResult;
    UINT ucbDataOffset;
#ifdef UNICODE
    BOOL bUnicode;
    UINT cchChars;
    CHAR szAnsiNetName[MAX_PATH];
    CHAR szAnsiDevice[MAX_PATH];
    UINT cbAnsiNetName;
    UINT cbWideNetName;
    UINT cbAnsiDevice;
    UINT cbWideDevice;
    UINT cbChars;
#endif

    ASSERT(IsUNCPath(pcszNetName));
    ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_ICNRL_FLAGS));
    ASSERT(IS_FLAG_CLEAR(dwFlags, ICNRL_FL_VALID_DEVICE) ||
            IsValidDevice(pcszDevice));
    ASSERT(IS_FLAG_CLEAR(dwFlags, ICNRL_FL_VALID_NET_TYPE) ||
            IsValidNetType(dwNetType));
    ASSERT(IS_VALID_WRITE_PTR(ppicnrl, PCNRLINK));
    ASSERT(IS_VALID_WRITE_PTR(pucbICNRLinkLen, UINT));

#ifdef UNICODE
    bUnicode = FALSE;

    cbAnsiNetName = WideCharToMultiByte(CP_ACP, 0,
            pcszNetName, -1,
            szAnsiNetName, ARRAYSIZE(szAnsiNetName),
            0, 0);
    if ( cbAnsiNetName == 0 )
    {
        bUnicode = FALSE;
    }
    else
    {
        WCHAR szWideNetName[MAX_PATH];

        cbChars = MultiByteToWideChar(CP_ACP, 0,
                szAnsiNetName, -1,
                szWideNetName, ARRAYSIZE(szWideNetName));
        if ( cbChars == 0 || lstrcmp(pcszNetName,szWideNetName) != 0 )
        {
            bUnicode = TRUE;
        }
    }

    if (IS_FLAG_SET(dwFlags, ICNRL_FL_VALID_DEVICE))
    {
        cbAnsiDevice = WideCharToMultiByte(CP_ACP, 0,
                pcszDevice, -1,
                szAnsiDevice, ARRAYSIZE(szAnsiDevice),
                0, 0);
        if ( cbAnsiDevice == 0 )
        {
            bUnicode = FALSE;
        }
        else
        {
            WCHAR szWideDevice[MAX_PATH];

            cchChars = MultiByteToWideChar(CP_ACP, 0,
                    szAnsiDevice, -1,
                    szWideDevice, ARRAYSIZE(szWideDevice));
            if ( cchChars == 0 || lstrcmp(pcszDevice,szWideDevice) != 0 )
            {
                bUnicode = TRUE;
            }
        }
    }
    else
    {
        cbAnsiDevice = 0;
    }

    if ( bUnicode )
    {
        ucbDataOffset = SIZEOF(ICNRLINKW);

        /* (+ 1) for null terminator. */
        cbWideNetName = (lstrlen(pcszNetName) + 1) * sizeof(TCHAR);

        if (IS_FLAG_SET(dwFlags, ICNRL_FL_VALID_DEVICE))
            cbWideDevice = (lstrlen(pcszDevice) + 1) * sizeof(TCHAR);
        else
            cbWideDevice = 0;

    }
    else
    {
        ucbDataOffset = SIZEOF(ICNRLINKA);

        cbWideNetName = 0;
        cbWideDevice  = 0;
    }

    *pucbICNRLinkLen = ucbDataOffset +
        cbAnsiNetName +
        cbAnsiDevice;
    if ( bUnicode )
    {
        *pucbICNRLinkLen = ALIGN_WORD_CNT(*pucbICNRLinkLen) +
            cbWideNetName +
            cbWideDevice;
    }

#else

    /* Assume we won't overflow *pucbICNRLinkLen here. */

    /* (+ 1) for null terminator. */

    *pucbICNRLinkLen = SIZEOF(**ppicnrl) +
        (lstrlen(pcszNetName) + 1) * SIZEOF(TCHAR);

    if (IS_FLAG_SET(dwFlags, ICNRL_FL_VALID_DEVICE))
        /* (+ 1) for null terminator. */
        *pucbICNRLinkLen += (lstrlen(pcszDevice) + 1) * SIZEOF(TCHAR);

    ucbDataOffset = SIZEOF(ICNRLINKA);
#endif

    bResult = AllocateMemory(*pucbICNRLinkLen, ppicnrl);

    if (bResult)
    {
        (*ppicnrl)->ucbSize = *pucbICNRLinkLen;
        (*ppicnrl)->dwFlags = dwFlags;

        if (IS_FLAG_SET(dwFlags, ICNRL_FL_VALID_NET_TYPE))
            (*ppicnrl)->dwNetType = dwNetType;
        else
            (*ppicnrl)->dwNetType = 0;

        /* Append remote name. */

        (*ppicnrl)->ucbNetNameOffset = ucbDataOffset;

        // lstrcpy: Enough memory is allocated above to hold the strings
        // so no need to bound it here.
#ifdef UNICODE
        lstrcpyA(ICNRL_Remote_Name_PtrA(*ppicnrl), szAnsiNetName);
        ucbDataOffset += cbAnsiNetName;

        if (IS_FLAG_SET(dwFlags, ICNRL_FL_VALID_DEVICE))
        {
            /* Append device name. */

            (*ppicnrl)->ucbDeviceOffset = ucbDataOffset;
            lstrcpyA(ICNRL_Device_PtrA(*ppicnrl), szAnsiDevice);

            ucbDataOffset += cbAnsiDevice;
        }
        else
        {
            (*ppicnrl)->ucbDeviceOffset = 0;
        }

        if ( bUnicode )
        {
            ucbDataOffset = ALIGN_WORD_CNT(ucbDataOffset);

            (*ppicnrl)->ucbNetNameOffsetW = ucbDataOffset;

            lstrcpy(ICNRL_Remote_Name_PtrW(*ppicnrl), pcszNetName);
            ucbDataOffset += cbWideNetName;

            if (IS_FLAG_SET(dwFlags, ICNRL_FL_VALID_DEVICE))
            {
                /* Append device name. */

                (*ppicnrl)->ucbDeviceOffsetW = ucbDataOffset;
                lstrcpy(ICNRL_Device_Ptr(*ppicnrl), pcszDevice);

                /* (+ 1) for null terminator. */
                ucbDataOffset += cbWideDevice;
            }
            else
            {
                (*ppicnrl)->ucbDeviceOffsetW = 0;
            }

        }
#else
        lstrcpy(ICNRL_Remote_Name_Ptr(*ppicnrl), pcszNetName);
        /* (+ 1) for null terminator. */
        ucbDataOffset += lstrlen(pcszNetName) + 1;

        if (IS_FLAG_SET(dwFlags, ICNRL_FL_VALID_DEVICE))
        {
            /* Append device name. */

            (*ppicnrl)->ucbDeviceOffset = ucbDataOffset;
            lstrcpy(ICNRL_Device_Ptr(*ppicnrl), pcszDevice);
#ifdef DEBUG
            /* (+ 1) for null terminator. */
            ucbDataOffset += (lstrlen(pcszDevice) + 1) * SIZEOF(TCHAR);
#endif
        }
        else
            (*ppicnrl)->ucbDeviceOffset = 0;
#endif

        /* Do all the calculated lengths match? */

        ASSERT(ucbDataOffset == (*ppicnrl)->ucbSize);
        ASSERT(ucbDataOffset == *pucbICNRLinkLen);
    }

    ASSERT(! bResult ||
            (IS_VALID_STRUCT_PTR(*ppicnrl, CICNRLINK) &&
             EVAL(*pucbICNRLinkLen == GetCNRLinkLen((PCCNRLINK)*ppicnrl))));

    return(bResult);
}


/*
 ** GetNetType()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL GetNetType(LPCTSTR pcszCNRName, PDWORD pdwNetType)
{
    BOOL bResult = FALSE;
    NETRESOURCE nrIn;
    NETRESOURCEBUF nrbufOut;
    DWORD dwcbBufLen = SIZEOF(nrbufOut);
    LPTSTR pszFileSysPath;
    DWORD dwNetResult;
#ifdef DEBUG
    DWORD dwcmsTicks;
#endif

    ASSERT(IsValidCNRName(pcszCNRName));
    ASSERT(IS_VALID_WRITE_PTR(pdwNetType, DWORD));

    /* RAIDRAID: (15691) We only support disk resource connections here. */

    ZeroMemory(&nrIn, SIZEOF(nrIn));
    nrIn.lpRemoteName = (LPTSTR)pcszCNRName;
    nrIn.dwType = RESOURCETYPE_DISK;

#ifdef DEBUG
    dwcmsTicks = GetTickCount();
#endif

    dwNetResult = WNetGetResourceInformation(&nrIn, &(nrbufOut.rgbyte),
            &dwcbBufLen, &pszFileSysPath);

#ifdef DEBUG

    dwcmsTicks = GetTickCount() - dwcmsTicks;

    TRACE_OUT((TEXT("GetRemotePathInfo(): WNetGetResourceInformation() on net resource %s took %lu.%03lu seconds."),
                pcszCNRName,
                (dwcmsTicks / 1000),
                (dwcmsTicks % 1000)));

#endif

    if (dwNetResult == ERROR_SUCCESS)
    {
        if (nrbufOut.nr.lpProvider)
        {
            NETINFOSTRUCT nis;

            ASSERT(IS_VALID_STRING_PTR(nrbufOut.nr.lpProvider, STR));

            nis.cbStructure = SIZEOF(nis);

            dwNetResult = WNetGetNetworkInformation(nrbufOut.nr.lpProvider, &nis);

            if (dwNetResult == ERROR_SUCCESS)
            {
                *pdwNetType = ((nis.wNetType) << 16);
                bResult = TRUE;

                TRACE_OUT((TEXT("GetNetType(): Net type for CNR %s is %#08lx."),
                            pcszCNRName,
                            *pdwNetType));
            }
            else
                WARNING_OUT((TEXT("GetNetType(): WNetGetNetworkInformation() failed for %s NP, returning %lu."),
                            nrbufOut.nr.lpProvider,
                            dwNetResult));
        }
        else
            WARNING_OUT((TEXT("GetNetType(): WNetGetResourceInformation() was unable to determine the NP for CNR %s."),
                        pcszCNRName));
    }
    else
        WARNING_OUT((TEXT("GetNetType(): WNetGetResourceInformation() failed for CNR %s, returning %lu."),
                    pcszCNRName,
                    dwNetResult));

    ASSERT(! bResult ||
            IsValidNetType(*pdwNetType));

    return(bResult);
}


/*
 ** GetNetProviderName()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL GetNetProviderName(PCICNRLINK pcicnrl, LPTSTR pszNPNameBuf)
{
    BOOL bResult = FALSE;

    ASSERT(IS_VALID_STRUCT_PTR(pcicnrl, CICNRLINK));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszNPNameBuf, STR, MAX_PATH_LEN));

    if (IS_FLAG_SET(pcicnrl->dwFlags, ICNRL_FL_VALID_NET_TYPE))
    {
        DWORD dwcbNPNameBufLen;
        DWORD dwNetResult;

        dwcbNPNameBufLen = MAX_PATH_LEN;

        dwNetResult = WNetGetProviderName(pcicnrl->dwNetType, pszNPNameBuf,
                &dwcbNPNameBufLen);

        if (dwNetResult == ERROR_SUCCESS)
        {
            bResult = TRUE;

#ifdef UNICODE
            //
            // Unicode builds need to accept both ansi and unicode ICNRLINK structures.
            // Note the use of '%S' (upper case).  This will accept an ANSI string
            // in a UNICODE build environment.
            //
            if (IS_ICNRL_ANSI(pcicnrl))
                TRACE_OUT((TEXT("GetNetProviderName(): NP for CNR %S is %s."),
                            ICNRL_Remote_Name_PtrA(pcicnrl),
                            pszNPNameBuf));
            else
#endif
                TRACE_OUT((TEXT("GetNetProviderName(): NP for CNR %s is %s."),
                            ICNRL_Remote_Name_Ptr(pcicnrl),                       
                            pszNPNameBuf));
        }
        else
            WARNING_OUT((TEXT("GetNetProviderName(): WNetGetProviderName() failed for CNR %s's net type %#08lx, returning %lu."),
                        TEXT("<Remote Name>"), // ICNRL_Remote_Name_Ptr(pcicnrl),
                        pcicnrl->dwNetType,
                        dwNetResult));
    }
    else
        WARNING_OUT((TEXT("GetNetProviderName(): Net type for CNR %s is not known.  Unable to determine NP name."),
                    TEXT("<Remote Name>"))); // ICNRL_Remote_Name_Ptr(pcicnrl)));

                    ASSERT(! bResult ||
                            IsValidNetProviderName(pszNPNameBuf));

                    return(bResult);
}


/*
 ** CompareNetNames()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE COMPARISONRESULT CompareNetNames(LPCTSTR pcszFirstNetName,
        LPCTSTR pcszSecondNetName)
{
    ASSERT(IS_VALID_STRING_PTR(pcszFirstNetName, CSTR));
    ASSERT(IS_VALID_STRING_PTR(pcszSecondNetName, CSTR));

    return(MapIntToComparisonResult(lstrcmp(pcszFirstNetName,
                    pcszSecondNetName)));
}


/*
 ** SearchForRedirectedConnection()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL SearchForRedirectedConnection(PCICNRLINK pcicnrl,
        LPTSTR pszRootPathBuf,
        int cchMax)
{
    BOOL bResult = FALSE;
    HANDLE henum;
    DWORD dwNetResult;

    ASSERT(IS_VALID_STRUCT_PTR(pcicnrl, CICNRLINK));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRootPathBuf, STR, MAX_PATH_LEN));

#ifdef DEBUG
#ifdef UNICODE
    {
        LPWSTR pszWideNetName;
        WCHAR szWideNetName[MAX_PATH];

        if (IS_ICNRL_ANSI(pcicnrl))
        {
            pszWideNetName = szWideNetName;

            MultiByteToWideChar(CP_ACP, 0,
                    ICNRL_Remote_Name_PtrA(pcicnrl), -1,
                    szWideNetName, ARRAYSIZE(szWideNetName));
        } else {
            pszWideNetName = ICNRL_Remote_Name_PtrW(pcicnrl);
        }

        WARNING_OUT((TEXT("SearchForRedirectedConnection(): Enumerating local connections searching for redirected connection to CNR \"%s\"."),
                    pszWideNetName));
    }
#else
    WARNING_OUT((TEXT("SearchForRedirectedConnection(): Enumerating local connections searching for redirected connection to CNR \"%s\"."),
                ICNRL_Remote_Name_Ptr(pcicnrl)));
#endif
#endif

    /* RAIDRAID: (15691) We only support container resources here. */

    dwNetResult = WNetOpenEnum(RESOURCE_CONNECTED, RESOURCETYPE_DISK,
            RESOURCEUSAGE_CONTAINER | RESOURCEUSAGE_ATTACHED,
            NULL, &henum);

    if (dwNetResult == WN_SUCCESS)
    {
        DWORD dwc = 1;
        NETRESOURCEBUF nrbuf;
        DWORD dwcbBufLen = SIZEOF(nrbuf);

        while ((dwNetResult = WNetEnumResource(henum, &dwc, &(nrbuf.rgbyte),
                        &dwcbBufLen))
                == WN_SUCCESS)
        {
            /* Is this a redirected connection? */

            if (nrbuf.nr.lpRemoteName != NULL)
            {
                if (nrbuf.nr.lpLocalName != NULL)
                {
                    /* Yes.  Is it a redirected connection to the desired CNR? */

#ifdef UNICODE
                    WCHAR szWideNetName[MAX_PATH];
                    LPWSTR pszWideNetName;

                    if (IS_ICNRL_ANSI(pcicnrl))
                    {
                        pszWideNetName = szWideNetName;
                        MultiByteToWideChar(CP_ACP, 0,
                                ICNRL_Remote_Name_PtrA(pcicnrl), -1,
                                szWideNetName, ARRAYSIZE(szWideNetName));
                    }
                    else
                    {
                        pszWideNetName = ICNRL_Remote_Name_Ptr(pcicnrl);
                    }
                    if (CompareNetNames(pszWideNetName,
                                nrbuf.nr.lpRemoteName)
                            == CR_EQUAL)
#else
                        if (CompareNetNames(ICNRL_Remote_Name_Ptr(pcicnrl),
                                    nrbuf.nr.lpRemoteName)
                                == CR_EQUAL)
#endif
                        {
                            /* Yes. */

                            ASSERT(lstrlen(nrbuf.nr.lpLocalName) < MAX_PATH_LEN);

                            lstrcpyn(pszRootPathBuf, nrbuf.nr.lpLocalName, cchMax);
                            bResult = TRUE;

                            TRACE_OUT((TEXT("SearchForRedirectedConnection(): Found CNR \"%s\" connected to %s."),
                                        nrbuf.nr.lpRemoteName,
                                        pszRootPathBuf));

                            break;
                        }
                        else
                            /* No. */
                            TRACE_OUT((TEXT("SearchForRedirectedConnection(): Skipping unmatched enumerated connection to CNR \"%s\" on %s."),
                                        nrbuf.nr.lpRemoteName,
                                        nrbuf.nr.lpLocalName));
                }
                else
                    /* No. */
                    TRACE_OUT((TEXT("SearchForRedirectedConnection(): Skipping enumerated deviceless connection to CNR \"%s\"."),
                                nrbuf.nr.lpRemoteName));
            }
            else
                WARNING_OUT((TEXT("SearchForRedirectedConnection(): Skipping enumerated connection with no CNR name.")));
        }

        if (! bResult && dwNetResult != WN_NO_MORE_ENTRIES)
            WARNING_OUT((TEXT("SearchForRedirectedConnection(): WNetEnumResource() failed, returning %lu."),
                        dwNetResult));

        dwNetResult = WNetCloseEnum(henum);

        if (dwNetResult != WN_SUCCESS)
            WARNING_OUT((TEXT("SearchForRedirectedConnection(): WNetCloseEnum() failed, returning %lu."),
                        dwNetResult));
    }
    else
        WARNING_OUT((TEXT("SearchForRedirectedConnection(): WNetOpenEnum() failed, returning %lu."),
                    dwNetResult));

    return(bResult);
}


#if defined(DEBUG) || defined (VSTF)

/*
 ** IsValidDevice()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidDevice(LPCTSTR pcszDevice)
{
    /* Any valid string < MAX_PATH_LEN bytes long is a valid device name. */

    return(IS_VALID_STRING_PTR(pcszDevice, CSTR) &&
            EVAL(lstrlen(pcszDevice) < MAX_PATH_LEN));
}


/*
 ** IsValidNetType()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidNetType(DWORD dwNetType)
{
    BOOL bResult;

    switch (dwNetType & 0xffff0000)
    {
        default:
            WARNING_OUT((TEXT("IsValidNetType(): Unexpected net type %#08lx is neither NetWare nor LANMan."),
                        dwNetType));
            /* Fall through... */

        case WNNC_NET_LANMAN:
        case WNNC_NET_NETWARE:
            bResult = TRUE;
            break;

    }

    if (dwNetType & 0x0000ffff)
        WARNING_OUT((TEXT("IsValidNetType(): Low word of net type %#08lx is non-zero."),
                    dwNetType));

    return(bResult);
}


/*
 ** IsValidPCICNRLINK()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCICNRLINK(PCICNRLINK pcicnrl)
{
    BOOL bResult;

    if (IS_VALID_READ_PTR(pcicnrl, CICNRLINK) &&
            IS_VALID_READ_BUFFER_PTR(pcicnrl, CICNRLINK, pcicnrl->ucbSize) &&
            FLAGS_ARE_VALID(pcicnrl->dwFlags, ALL_ICNRL_FLAGS) &&
            EVAL(IsValidCNRName(ICNRL_Remote_Name_Ptr(pcicnrl))) &&
            EVAL(IsContained(pcicnrl, pcicnrl->ucbSize,
                    ICNRL_Remote_Name_PtrA(pcicnrl),
                    lstrlenA(ICNRL_Remote_Name_PtrA(pcicnrl)))) &&
            (IS_FLAG_CLEAR(pcicnrl->dwFlags, ICNRL_FL_VALID_NET_TYPE) ||
             EVAL(IsValidNetType(pcicnrl->dwNetType))))
    {
        if (IS_FLAG_CLEAR(pcicnrl->dwFlags, ICNRL_FL_VALID_DEVICE))
        {
            ASSERT(! pcicnrl->ucbDeviceOffset);
            bResult = TRUE;
        }
        else
            bResult = (EVAL(IsValidDevice(ICNRL_Device_Ptr(pcicnrl))) &&
                    EVAL(IsContained(pcicnrl, pcicnrl->ucbSize,
                            ICNRL_Device_PtrA(pcicnrl),
                            lstrlenA(ICNRL_Device_PtrA(pcicnrl)))));
    }
    else
        bResult = FALSE;

    return(bResult);
}

#endif


#if defined(DEBUG)

/*
 ** IsValidNetProviderName()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidNetProviderName(LPCTSTR pcszNetProvider)
{
    /* Any string < MAX_PATH_LEN characters long is a valid NP name. */

    return(IS_VALID_STRING_PTR(pcszNetProvider, CSTR) &&
            lstrlen(pcszNetProvider) < MAX_PATH_LEN);
}

#endif


/****************************** Public Functions *****************************/


/*
 ** CreateLocalCNRLink()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** If TRUE is returned:
 **    1) *ppcnrl is only valid if *pucbCNRLinkLen > 0.
 **    2) pszLocalBasePathBuf is valid.
 **    3) *ppcszCommonPathSuffix is valid.
 **
 ** If *pucbCNRLinkLen == 0, pszLocalBasePathBuf is a copy of pcszLocalPath, and
 ** *ppcszCommonPathSuffix points at the null terminator of pcszLocalPath.
 **
 ** If *pucbCNRLinkLen > 0, pszLocalBasePathBuf is the closest shared local base
 ** path, and *ppcszCommonPathSuffix points at that path's suffix in
 ** pcszLocalPath.
 */
PUBLIC_CODE BOOL CreateLocalCNRLink(LPCTSTR pcszLocalPath, PCNRLINK *ppcnrl,
        PUINT pucbCNRLinkLen,
        LPTSTR pszLocalBasePathBuf,
        int cchMax,
        LPCTSTR *ppcszCommonPathSuffix)
{
    BOOL bResult;
    TCHAR rgchNetName[MAX_PATH_LEN];
    BOOL bShared;
    DWORD dwNetType;

    ASSERT(IsDrivePath(pcszLocalPath));
    ASSERT(IS_VALID_WRITE_PTR(ppcnrl, PCNRLINK));
    ASSERT(IS_VALID_WRITE_PTR(pucbCNRLinkLen, UINT));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszLocalBasePathBuf, STR, MAX_PATH_LEN));
    ASSERT(IS_VALID_WRITE_PTR(ppcszCommonPathSuffix, LPCTSTR));

    bResult = GetNetPathFromLocalPath(pcszLocalPath, rgchNetName,
            ppcszCommonPathSuffix, &bShared,
            &dwNetType);

    if (bResult)
    {
        if (bShared)
        {
            bResult = UnifyICNRLinkInfo(rgchNetName, ICNRL_FL_VALID_NET_TYPE,
                    NULL, dwNetType, (PICNRLINK *)ppcnrl,
                    pucbCNRLinkLen);

            if (bResult)
            {
                UINT ucbLocalBasePathLen;

                /* Copy local base path into output buffer. */

                ASSERT(*ppcszCommonPathSuffix >= pcszLocalPath);
                ucbLocalBasePathLen = (UINT)(*ppcszCommonPathSuffix - pcszLocalPath);

                CopyMemory(pszLocalBasePathBuf, pcszLocalPath, ucbLocalBasePathLen * sizeof(TCHAR));
                pszLocalBasePathBuf[ucbLocalBasePathLen] = TEXT('\0');
            }
        }
        else
        {
            /* Not shared.  No CNRLink. */

            *pucbCNRLinkLen = 0;

            /* Copy entire local path into output buffer. */

            lstrcpyn(pszLocalBasePathBuf, pcszLocalPath, cchMax);

            /* Common path suffix is the empty string. */

            *ppcszCommonPathSuffix = pcszLocalPath + lstrlen(pcszLocalPath);
        }
    }

    ASSERT(! bResult ||
            (EVAL(IsDrivePath(pszLocalBasePathBuf)) &&
             IS_VALID_STRING_PTR(*ppcszCommonPathSuffix, CSTR) &&
             EVAL(IsStringContained(pcszLocalPath, *ppcszCommonPathSuffix)) &&
             (! *pucbCNRLinkLen ||
              (IS_VALID_STRUCT_PTR((PCICNRLINK)*ppcnrl, CICNRLINK) &&
               EVAL(*pucbCNRLinkLen == GetCNRLinkLen(*ppcnrl))))));

    return(bResult);
}


/*
 ** CreateRemoteCNRLink()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL CreateRemoteCNRLink(LPCTSTR pcszRemotePath, LPCTSTR pcszCNRName,
        PCNRLINK *ppcnrl, PUINT pucbCNRLinkLen)
{
    BOOL bResult;
    /* "D:" + null terminator. */
    TCHAR rgchDrive[3];
    DWORD dwNetType;

    ASSERT(IsCanonicalPath(pcszRemotePath));
    ASSERT(IsValidCNRName(pcszCNRName));
    ASSERT(IS_VALID_WRITE_PTR(ppcnrl, PCNRLINK));
    ASSERT(IS_VALID_WRITE_PTR(pucbCNRLinkLen, UINT));

    /* Determine net provider. */

    bResult = GetNetType(pcszCNRName, &dwNetType);

    if (bResult)
    {
        DWORD dwFlags = ICNRL_FL_VALID_NET_TYPE;

        /* Determine last redirected drive, if any. */

        if (IsDrivePath(pcszRemotePath))
        {
            MyLStrCpyN(rgchDrive, pcszRemotePath, ARRAYSIZE(rgchDrive));
            SET_FLAG(dwFlags, ICNRL_FL_VALID_DEVICE);
        }
        else
            rgchDrive[0] = TEXT('\0');

        bResult = UnifyICNRLinkInfo(pcszCNRName, dwFlags, rgchDrive, dwNetType,
                (PICNRLINK *)ppcnrl, pucbCNRLinkLen);
    }

    ASSERT(! bResult ||
            (IS_VALID_STRUCT_PTR((PCICNRLINK)*ppcnrl, CICNRLINK) &&
             EVAL(*pucbCNRLinkLen == GetCNRLinkLen(*ppcnrl))));

    return(bResult);
}


/*
 ** DestroyCNRLink()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DestroyCNRLink(PCNRLINK pcnrl)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcnrl, CCNRLINK));

    FreeMemory(pcnrl);

    return;
}


/*
 ** CompareCNRLinks()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** CNR link data is compared in the following order:
 **
 **    1) net name
 **
 ** N.b., net types are ignored when comparing CNRLinks.
 */
PUBLIC_CODE COMPARISONRESULT CompareCNRLinks(PCCNRLINK pccnrlFirst,
        PCCNRLINK pccnrlSecond)
{
#ifdef UNICODE
    WCHAR szWideNetNameFirst[MAX_PATH];
    LPWSTR pszWideNetNameFirst;
    WCHAR szWideNetNameSecond[MAX_PATH];
    LPWSTR pszWideNetNameSecond;
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pccnrlFirst, CCNRLINK));
    ASSERT(IS_VALID_STRUCT_PTR(pccnrlSecond, CCNRLINK));

#ifdef UNICODE
    if (IS_ICNRL_ANSI(pccnrlFirst))
    {
        pszWideNetNameFirst = szWideNetNameFirst;
        MultiByteToWideChar(CP_ACP, 0,
                ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrlFirst), -1,
                szWideNetNameFirst, ARRAYSIZE(szWideNetNameFirst));

    }
    else
    {
        pszWideNetNameFirst = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrlFirst);
    }

    if (IS_ICNRL_ANSI(pccnrlSecond))
    {
        pszWideNetNameSecond = szWideNetNameSecond;
        MultiByteToWideChar(CP_ACP, 0,
                ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrlSecond), -1,
                szWideNetNameSecond, ARRAYSIZE(szWideNetNameSecond));

    }
    else
    {
        pszWideNetNameSecond = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrlSecond);
    }

    return(CompareNetNames(pszWideNetNameFirst,pszWideNetNameSecond));
#else
    return(CompareNetNames(ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrlFirst),
                ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrlSecond)));
#endif
}


/*
 ** GetLocalPathFromCNRLink()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL GetLocalPathFromCNRLink(PCCNRLINK pccnrl,
        LPTSTR pszLocalPathBuf,
        PDWORD pdwOutFlags)
{
    BOOL bResult;
    PCSERVERVTABLE pcsvt;

    ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszLocalPathBuf, STR, MAX_PATH_LEN));
    ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));

    *pdwOutFlags = 0;

    bResult = GetServerVTable(&pcsvt);

    if (bResult)
    {
        DWORD dwNetType;
        BOOL bIsLocal;

        /*
         * Get local path for share.  N.b., the share name must be in upper case
         * here for MSSHRUI.DLL.
         */

        dwNetType = (IS_FLAG_SET(((PCICNRLINK)pccnrl)->dwFlags,
                    ICNRL_FL_VALID_NET_TYPE) ?
                ((PCICNRLINK)pccnrl)->dwNetType :
                0);

#ifdef UNICODE
        {
            WCHAR szWideNetName[MAX_PATH];
            LPWSTR pszWideNetName = szWideNetName;

            if (IS_ICNRL_ANSI(pccnrl))
            {
                MultiByteToWideChar(CP_ACP, 0,
                        ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl), -1,
                        szWideNetName, ARRAYSIZE(szWideNetName));

            }
            else
            {
                pszWideNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
            }
            bResult = (pcsvt->GetLocalPathFromNetResource)(
                    pszWideNetName, dwNetType,
                    pszLocalPathBuf, MAX_PATH_LEN, &bIsLocal);
        }
#else
        bResult = (pcsvt->GetLocalPathFromNetResource)(
                ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl), dwNetType,
                pszLocalPathBuf, MAX_PATH_LEN, &bIsLocal);
#endif

        if (bIsLocal)
            SET_FLAG(*pdwOutFlags, CNR_FL_LOCAL);
    }

    ASSERT(FLAGS_ARE_VALID(*pdwOutFlags, ALL_CNR_FLAGS) &&
            (! bResult ||
             (EVAL(IS_FLAG_SET(*pdwOutFlags, CNR_FL_LOCAL)) &&
              EVAL(IsLocalDrivePath(pszLocalPathBuf)))));

    return(bResult);
}


/*
 ** GetRemotePathFromCNRLink()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void GetRemotePathFromCNRLink(PCCNRLINK pccnrl,
        LPTSTR pszRemotePathBuf,
        int cchMax)
{
    ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRemotePathBuf, STR, MAX_PATH_LEN));

    /* It's ok that this is broken for non-UNC CNR names. */

    /* (- 1) for trailing slash. */

#ifdef UNICODE
    ASSERT(IS_ICNRL_ANSI(pccnrl) ? (lstrlenA(ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl)) < MAX_PATH_LEN - 1) :
            (lstrlenW(ICNRL_Remote_Name_PtrW((PCICNRLINK)pccnrl)) < MAX_PATH_LEN - 1));
#else
    ASSERT(lstrlenA(ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl)) < MAX_PATH_LEN - 1);
#endif

#ifdef UNICODE
    {
        WCHAR szWideNetName[MAX_PATH];
        LPWSTR pszWideNetName;

        if (IS_ICNRL_ANSI(pccnrl))
        {
            pszWideNetName = szWideNetName;
            MultiByteToWideChar(CP_ACP, 0,
                    ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl), -1,
                    szWideNetName, ARRAYSIZE(szWideNetName));

        }
        else
        {
            pszWideNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
        }
        lstrcpyn(pszRemotePathBuf, pszWideNetName, cchMax);
    }
#else
    lstrcpyn(pszRemotePathBuf, ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl), cchMax);
#endif
    CatPath(pszRemotePathBuf, TEXT("\\"), cchMax);

    return;
}


/*
 ** ConnectToCNR()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL ConnectToCNR(PCCNRLINK pccnrl, DWORD dwInFlags,
        HWND hwndOwner, LPTSTR pszRootPathBuf,
        PDWORD pdwOutFlags)
{
    BOOL bResult = FALSE;
    BOOL bValidDevice;
    BOOL bRedirect;
    BOOL bTryLastDevice = FALSE;
    DWORD dwcbRootPathBufLen;
    LPTSTR pszNetName;
    LPTSTR pszDevice;
#ifdef UNICODE
    WCHAR szWideNetName[MAX_PATH];
    WCHAR szWideDevice[MAX_PATH];
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));
    ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_CONNECT_IN_FLAGS));
    ASSERT(IS_FLAG_CLEAR(dwInFlags, CONNECT_INTERACTIVE) ||
            IS_VALID_HANDLE(hwndOwner, WND));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRootPathBuf, STR, MAX_PATH_LEN));
    ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));

    *pdwOutFlags = 0;

#ifdef UNICODE
    if (IS_ICNRL_ANSI(pccnrl))
    {
        pszNetName = szWideNetName;
        MultiByteToWideChar(CP_ACP, 0,
                ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl), -1,
                szWideNetName, ARRAYSIZE(szWideNetName));

    }
    else
    {
        pszNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
    }
#else
    pszNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
#endif

    /* Do we have an old redirected device to try? */

    bValidDevice = IS_FLAG_SET(((PCICNRLINK)pccnrl)->dwFlags,
            ICNRL_FL_VALID_DEVICE);

#ifdef UNICODE
    if ( bValidDevice )
    {
        if (IS_ICNRL_ANSI(pccnrl))
        {
            pszDevice = szWideDevice;
            MultiByteToWideChar(CP_ACP, 0,
                    ICNRL_Device_PtrA((PCICNRLINK)pccnrl), -1,
                    szWideDevice, ARRAYSIZE(szWideNetName));

        }
        else
        {
            pszDevice = ICNRL_Device_Ptr((PCICNRLINK)pccnrl);
        }
    }
#else
    pszDevice = ICNRL_Device_Ptr((PCICNRLINK)pccnrl);
#endif

    bRedirect = (bValidDevice || IS_FLAG_SET(dwInFlags, CONNECT_REDIRECT));

    if (bRedirect)
    {
        if (bValidDevice)
        {
            DWORD dwNetResult;
            /* "X:" + null terminator */
            TCHAR rgchDrive[2 + 1];

            /* Yes.  Is it already connected to the desired CNR? */

            TRACE_OUT((TEXT("ConnectToCNR(): Calling WNetGetConnection() to check %s for CNR \"%s\"."),
                        pszDevice, pszNetName));

            dwcbRootPathBufLen = MAX_PATH_LEN;

            /* WNetGetConnection requires the device name to have no trailing
             ** backslash.
             */
            MyLStrCpyN(rgchDrive, pszDevice, ARRAYSIZE(rgchDrive));
            dwNetResult = WNetGetConnection(rgchDrive, pszRootPathBuf, &dwcbRootPathBufLen);

            if (dwNetResult == WN_SUCCESS)
            {
                if (CompareNetNames(pszNetName, pszRootPathBuf)
                        == CR_EQUAL)
                {
                    TRACE_OUT((TEXT("ConnectToCNR(): Found matching CNR \"%s\" on %s."),
                                pszRootPathBuf,
                                pszDevice));

                    ASSERT(lstrlenA(ICNRL_Device_PtrA((PCICNRLINK)pccnrl)) < MAX_PATH_LEN);
                    lstrcpyn(pszRootPathBuf, pszDevice, MAX_PATH_LEN);

                    bResult = TRUE;
                }
                else
                    TRACE_OUT((TEXT("ConnectToCNR(): Found unmatched CNR \"%s\" on %s."),
                                pszRootPathBuf,
                                pszDevice));
            }
            else
            {
                TRACE_OUT((TEXT("ConnectToCNR(): WNetGetConnection() failed on %s."),
                            pszDevice));

                /*
                 * Only attempt a connection to the last redirected device if that
                 * device is not already in use.
                 */

                bTryLastDevice = (GetDriveType(pszDevice)
                        == DRIVE_NO_ROOT_DIR);
            }
        }

        if (! bResult)
            /* See if the desired CNR is connected to any local device. */
            bResult = SearchForRedirectedConnection((PCICNRLINK)pccnrl,
                    pszRootPathBuf, MAX_PATH_LEN);
        /*
         * Assume that no reference count is maintained for redirected device
         * connections, so we do not have to add a found redirected device
         * connection again.
         */
    }

    if (! bResult)
    {
        NETRESOURCE nr;
        TCHAR rgchNPName[MAX_PATH_LEN];

        /* RAIDRAID: (15691) We only support disk resource connections here. */

        ZeroMemory(&nr, SIZEOF(nr));
        nr.lpRemoteName = pszNetName;
        nr.dwType = RESOURCETYPE_DISK;
        if (GetNetProviderName((PCICNRLINK)pccnrl, rgchNPName))
            nr.lpProvider = rgchNPName;

        /* Shall we try the old device? */

        if (bTryLastDevice)
        {
            /* Yes. */

            ASSERT(bValidDevice);

            nr.lpLocalName = pszDevice;

            WARNING_OUT((TEXT("ConnectToCNR(): Calling WNetUseConnection() to attempt to connect %s to CNR \"%s\"."),
                        nr.lpLocalName,
                        nr.lpRemoteName));
        }
        else
        {
            /* No.  Shall we attempt to force a redirected connection? */

            if (bValidDevice)
            {
                /*
                 * Yes.  N.b., the caller may already have set CONNECT_REDIRECT in
                 * dwInFlags here.
                 */

                SET_FLAG(dwInFlags, CONNECT_REDIRECT);

                WARNING_OUT((TEXT("ConnectToCNR(): Calling WNetUseConnection() to establish auto-picked redirected connection to CNR \"%s\"."),
                            nr.lpRemoteName));
            }
            else
                /* No. */
                WARNING_OUT((TEXT("ConnectToCNR(): Calling WNetUseConnection() to establish connection to CNR \"%s\"."),
                            TEXT("<nr.lpRemoteName>"))); // nr.lpRemoteName));

                            ASSERT(! nr.lpLocalName);
        }

        dwcbRootPathBufLen = MAX_PATH_LEN;

        bResult = (WNetUseConnection(hwndOwner, &nr, NULL, NULL, dwInFlags,
                    pszRootPathBuf, &dwcbRootPathBufLen,
                    pdwOutFlags)
                == NO_ERROR);
    }

    if (bResult)
        CatPath(pszRootPathBuf, TEXT("\\"), MAX_PATH_LEN);

    ASSERT(! bResult ||
            (IS_VALID_STRING_PTR(pszRootPathBuf, STR) &&
             FLAGS_ARE_VALID(*pdwOutFlags, ALL_CONNECT_OUT_FLAGS)));

    return(bResult);
}


/*
 ** DisconnectFromCNR()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL DisconnectFromCNR(PCCNRLINK pccnrl)
{
    DWORD dwNetResult;
    LPTSTR pszNetName;
#ifdef UNICODE
    WCHAR szWideNetName[MAX_PATH];
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

#ifdef UNICODE
    if (IS_ICNRL_ANSI(pccnrl))
    {
        pszNetName = szWideNetName;
        MultiByteToWideChar(CP_ACP, 0,
                ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl), -1,
                szWideNetName, MAX_PATH);

    }
    else
    {
        pszNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
    }
#else
    pszNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
#endif

    dwNetResult = WNetCancelConnection2(pszNetName,
            CONNECT_REFCOUNT, FALSE);

    if (dwNetResult == NO_ERROR)
        WARNING_OUT((TEXT("DisconnectFromCNR(): Reduced connection reference count on CNR \"%s\"."),
                    pszNetName));
    else
        WARNING_OUT((TEXT("DisconnectFromCNR(): Failed to reduce connection reference count on CNR \"%s\".  WNetCancelConnection2() returned %lu."),
                    pszNetName));

    return(dwNetResult == NO_ERROR);
}


/*
 ** IsCNRAvailable()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsCNRAvailable(PCCNRLINK pccnrl)
{
    TCHAR rgchCNRRoot[MAX_PATH_LEN];
    LPTSTR pszNetName;
#ifdef UNICODE
    WCHAR szWideNetName[MAX_PATH];
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

#ifdef UNICODE
    if (IS_ICNRL_ANSI(pccnrl))
    {
        pszNetName = szWideNetName;
        MultiByteToWideChar(CP_ACP, 0,
                ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl), -1,
                szWideNetName, MAX_PATH);

    }
    else
    {
        pszNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
    }
#else
    pszNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
#endif

    ASSERT(lstrlen(pszNetName) < ARRAYSIZE(rgchCNRRoot) - 1);
    lstrcpyn(rgchCNRRoot, pszNetName, ARRAYSIZE(rgchCNRRoot));
    CatPath(rgchCNRRoot, TEXT("\\"), ARRAYSIZE(rgchCNRRoot));

    return(PathExists(rgchCNRRoot));
}


/*
 ** GetCNRLinkLen()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE UINT GetCNRLinkLen(PCCNRLINK pccnrl)
{
    ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

    return(((PCICNRLINK)pccnrl)->ucbSize);
}


/*
 ** GetCNRNetType()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL GetCNRNetType(PCCNRLINK pccnrl, PCDWORD *ppcdwNetType)
{
    BOOL bResult;

    ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

    bResult = IS_FLAG_SET(((PCICNRLINK)pccnrl)->dwFlags,
            ICNRL_FL_VALID_NET_TYPE);

    if (bResult)
        *ppcdwNetType = &(((PCICNRLINK)pccnrl)->dwNetType);

    ASSERT(! bResult ||
            IsValidNetType(**ppcdwNetType));

    return(bResult);
}


/*
 ** GetCNRName()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL GetCNRName(PCCNRLINK pccnrl, LPCSTR *ppcszCNRName)
{
    ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

    *ppcszCNRName = ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl);

    ASSERT(IS_VALID_STRING_PTRA(*ppcszCNRName, CSTR));

    return(TRUE);
}

#ifdef UNICODE
/*
 ** GetCNRNameW()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL GetCNRNameW(PCCNRLINK pccnrl, LPCWSTR *ppcszCNRName)
{
    ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

    if (IS_ICNRL_ANSI(pccnrl))
        *ppcszCNRName = NULL;
    else
    {
        *ppcszCNRName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
        ASSERT(IS_VALID_STRING_PTR(*ppcszCNRName, CSTR));
    }

    return(TRUE);
}
#endif

/*
 ** GetLastRedirectedDevice()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL GetLastRedirectedDevice(PCCNRLINK pccnrl, LPCSTR *ppcszDevice)
{
    BOOL bResult;

    ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

    bResult = IS_FLAG_SET(((PCICNRLINK)pccnrl)->dwFlags, ICNRL_FL_VALID_DEVICE);

    if (bResult)
        *ppcszDevice = ICNRL_Device_PtrA((PCICNRLINK)pccnrl);

    ASSERT(! bResult ||
            IS_VALID_STRING_PTRA(*ppcszDevice, CSTR));

    return(bResult);
}

#ifdef UNICODE
/*
 ** GetLastRedirectedDeviceW()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL GetLastRedirectedDeviceW(PCCNRLINK pccnrl, LPCWSTR *ppcszDevice)
{
    BOOL bResult;

    ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

    bResult = IS_FLAG_SET(((PCICNRLINK)pccnrl)->dwFlags, ICNRL_FL_VALID_DEVICE);

    if (bResult)
        if (IS_ICNRL_ANSI(pccnrl))
            *ppcszDevice = NULL;
        else
        {
            *ppcszDevice = ICNRL_Device_Ptr((PCICNRLINK)pccnrl);
            ASSERT(! bResult ||
                    IS_VALID_STRING_PTR(*ppcszDevice, CSTR));
        }

    return(bResult);
}
#endif

#if defined(DEBUG) || defined (VSTF)

/*
 ** IsValidPCCNRLINK()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidPCCNRLINK(PCCNRLINK pccnrl)
{
    return(IS_VALID_STRUCT_PTR((PCICNRLINK)pccnrl, CICNRLINK));
}

#endif


#ifdef DEBUG

/*
 ** DumpCNRLink()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DumpCNRLink(PCCNRLINK pccnrl)
{
    ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

    PLAIN_TRACE_OUT((TEXT("%s%s[CNR link] ucbSize %#x"),
                INDENT_STRING,
                INDENT_STRING,
                ((PCICNRLINK)pccnrl)->ucbSize));
    PLAIN_TRACE_OUT((TEXT("%s%s[CNR link] dwFLags = %#08lx"),
                INDENT_STRING,
                INDENT_STRING,
                ((PCICNRLINK)pccnrl)->dwFlags));
    PLAIN_TRACE_OUT((TEXT("%s%s[CNR link] CNR name \"%s\""),
                INDENT_STRING,
                INDENT_STRING,
                ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl)));
    if (IS_FLAG_SET(((PCICNRLINK)pccnrl)->dwFlags, ICNRL_FL_VALID_NET_TYPE))
        PLAIN_TRACE_OUT((TEXT("%s%s[CNR link] net type %#08lx"),
                    INDENT_STRING,
                    INDENT_STRING,
                    ((PCICNRLINK)pccnrl)->dwNetType));
    else
        PLAIN_TRACE_OUT((TEXT("%s%s[CNR link] net type unknown"),
                    INDENT_STRING,
                    INDENT_STRING));
    if (IS_FLAG_SET(((PCICNRLINK)pccnrl)->dwFlags, ICNRL_FL_VALID_DEVICE))
        PLAIN_TRACE_OUT((TEXT("%s%s[CNR link] last redirected local device \"%s\""),
                    INDENT_STRING,
                    INDENT_STRING,
                    ICNRL_Device_Ptr((PCICNRLINK)pccnrl)));
    else
        PLAIN_TRACE_OUT((TEXT("%s%s[CNR link] no last redirected local device"),
                    INDENT_STRING,
                    INDENT_STRING));

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\linkinfo.c ===
/*
 * linkinfo.c - LinkInfo ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "volumeid.h"
#include "cnrlink.h"
#include <uastrfnc.h>           // for ALIGNMENT_MACHINE


/* Macros
 *********/

/* macros for accessing ILINKINFO data */

#define ILI_Volume_ID_Ptr(pili) \
((PVOLUMEID)(((PBYTE)(pili)) + (pili)->ucbVolumeIDOffset))

#define ILI_Local_Base_Path_PtrA(pili) \
((LPSTR)(((PBYTE)(pili)) + (pili)->ucbLocalBasePathOffset))

#define ILI_CNR_Link_Ptr(pili) \
((PCNRLINK)(((PBYTE)(pili)) + (pili)->ucbCNRLinkOffset))

#define ILI_Common_Path_Suffix_PtrA(pili) \
((LPSTR)(((PBYTE)(pili)) + (pili)->ucbCommonPathSuffixOffset))

#define ILI_Local_Base_Path_PtrW(pili) \
((LPWSTR)(((PBYTE)(pili)) + (pili)->ucbLocalBasePathOffsetW))

#define ILI_Common_Path_Suffix_PtrW(pili) \
((LPWSTR)(((PBYTE)(pili)) + (pili)->ucbCommonPathSuffixOffsetW))

#ifdef UNICODE
#define ILI_Local_Base_Path_Ptr(pili)       ILI_Local_Base_Path_PtrW(pili)
#define ILI_Common_Path_Suffix_Ptr(pili)    ILI_Common_Path_Suffix_PtrW(pili)
#else
#define ILI_Local_Base_Path_Ptr(pili)       ILI_Local_Base_Path_PtrA(pili)
#define ILI_Common_Path_Suffix_Ptr(pili)    ILI_Common_Path_Suffix_PtrA(pili)
#endif

    /* Types
     ********/

    /******************************************************************************

      @doc LINKINFOAPI

      @struct LINKINFO | External definition of LinkInfo structure.

      @field UINT | ucbSize | The size of the LINKINFO structure in bytes, including
      the ucbSize field.  An ILINKINFO structure consists of a header described as
      below, followed by variable-length data that is opaque to the caller.

     ******************************************************************************/

    /*
       @doc INTERNAL

       @enum ILINKINFOFLAGS | Internal LinkInfo structure flags.
     */

    typedef enum _ilinkinfoflags
{
    /*
       @emem ILI_FL_LOCAL_INFO_VALID | If set, volume ID and local path are
       valid.  If clear, volume ID and local path are not valid.
     */

    ILI_FL_LOCAL_INFO_VALID    =  0x0001,

    /*
       @emem ILI_FL_REMOTE_INFO_VALID | If set, CNRLink and path suffix are
       valid.  If clear, CNRLink and path suffix not valid.
     */

    ILI_FL_REMOTE_INFO_VALID   =  0x0002,

    /* @emem ALL_ILINKINFO_FLAGS | All internal LinkInfo structure flags. */

    ALL_ILINKINFO_FLAGS        = (ILI_FL_LOCAL_INFO_VALID |\
            ILI_FL_REMOTE_INFO_VALID)
}
ILINKINFOFLAGS;

/*
   @doc INTERNAL

   @struct ILINKINFO | Internal definition of relocatable, extensible, internal
   LinkInfo structure.  An ILINKINFO structure may contain an <t IVOLUMEID>
   structure and an <t ICNRLINK> structure.  An ILINKINFO structure consists of
   a header described as below, followed by variable-length data.
 */

typedef struct _ilinkinfoA
{
    /* @field LINKINFO | li | External <t LINKINFO> sub-structure. */

    LINKINFO li;

    /*
       @field UINT | ucbHeaderSize | Size of the ILINKINFO header structure in
       bytes.
     */

    UINT ucbHeaderSize;

    /*
       @field DWORD | dwFlags | A bit mask of flags from the <t ILINKINFOFLAGS>
       enumeration.
     */

    DWORD dwFlags;

    /*
       @field UINT | ucbVolumeIDOffset | Offset in bytes of <t IVOLUMEID>
       sub-structure from base of structure.
     */

    UINT ucbVolumeIDOffset;

    /*
       @field UINT | ucbLocalBasePathOffset | Offset in bytes of local base path
       string from base of structure.  The local base path is a valid file
       system path.  The local base path string + the common path suffix string
       form the local path string, which is a valid file system path.  The local
       base path string refers to the same resource as the CNRLink's CNR name
       string.<nl>

       Example local base path string: "c:\\work".<nl>
       E.g., if local path "c:\\work" is shared as "\\\\fredbird\\work", an
       ILinkInfo structure would break local path
       "c:\\work\\footwear\\sneakers.doc" up into local base path "c:\\work",
       CNRLink CNR name "\\\\fredbird\\work", and common path suffix
       "footwear\\sneakers.doc".
     */

    UINT ucbLocalBasePathOffset;

    /*
       @field UINT | ucbCNRLinkOffset | Offset in bytes of <t CNRLINK>
       sub-structure from base of structure.  The file system name of the
       CNRLink's CNR name + the common path suffix string form the remote path
       string, which is a valid file system path.  The CNRLink's CNR name string
       refers to the same resource as the local base path string.
     */

    UINT ucbCNRLinkOffset;

    /*
       @field UINT | ucbCommonPathSuffixOffset | Offset in bytes of common path
       suffix string from base of structure.<nl> Example common path suffix
string: "footwear\\sneakers.doc".
     */

    UINT ucbCommonPathSuffixOffset;
}
ILINKINFOA;
DECLARE_STANDARD_TYPES(ILINKINFOA);

#ifdef UNICODE
typedef struct _ilinkinfoW
{
    /* @field LINKINFO | li | External <t LINKINFO> sub-structure. */

    LINKINFO li;

    /*
       @field UINT | ucbHeaderSize | Size of the ILINKINFO header structure in
       bytes.
     */

    UINT ucbHeaderSize;

    /*
       @field DWORD | dwFlags | A bit mask of flags from the <t ILINKINFOFLAGS>
       enumeration.
     */

    DWORD dwFlags;

    /*
       @field UINT | ucbVolumeIDOffset | Offset in bytes of <t IVOLUMEID>
       sub-structure from base of structure.
     */

    UINT ucbVolumeIDOffset;

    /*
       @field UINT | ucbLocalBasePathOffset | Offset in bytes of local base path
       string from base of structure.  The local base path is a valid file
       system path.  The local base path string + the common path suffix string
       form the local path string, which is a valid file system path.  The local
       base path string refers to the same resource as the CNRLink's CNR name
       string.<nl>

       Example local base path string: "c:\\work".<nl>
       E.g., if local path "c:\\work" is shared as "\\\\fredbird\\work", an
       ILinkInfo structure would break local path
       "c:\\work\\footwear\\sneakers.doc" up into local base path "c:\\work",
       CNRLink CNR name "\\\\fredbird\\work", and common path suffix
       "footwear\\sneakers.doc".
     */

    UINT ucbLocalBasePathOffset;

    /*
       @field UINT | ucbCNRLinkOffset | Offset in bytes of <t CNRLINK>
       sub-structure from base of structure.  The file system name of the
       CNRLink's CNR name + the common path suffix string form the remote path
       string, which is a valid file system path.  The CNRLink's CNR name string
       refers to the same resource as the local base path string.
     */

    UINT ucbCNRLinkOffset;

    /*
       @field UINT | ucbCommonPathSuffixOffset | Offset in bytes of common path
       suffix string from base of structure.<nl> Example common path suffix
string: "footwear\\sneakers.doc".
     */

    UINT ucbCommonPathSuffixOffset;

    /*
       These fields duplicate the above ones except that they are for the unicode
       versions of the strings.
     */
    UINT ucbLocalBasePathOffsetW;
    UINT ucbCommonPathSuffixOffsetW;

}
ILINKINFOW;
DECLARE_STANDARD_TYPES(ILINKINFOW);

#endif

#ifdef UNICODE
#define ILINKINFO   ILINKINFOW
#define PILINKINFO  PILINKINFOW
#define CILINKINFO  CILINKINFOW
#define PCILINKINFO PCILINKINFOW
#else
#define ILINKINFO   ILINKINFOA
#define PILINKINFO  PILINKINFOA
#define CILINKINFO  CILINKINFOA
#define PCILINKINFO PCILINKINFOA
#endif


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL CreateILinkInfo(LPCTSTR, PILINKINFO *);
PRIVATE_CODE BOOL CreateLocalILinkInfo(LPCTSTR, PILINKINFO *);
PRIVATE_CODE BOOL CreateRemoteILinkInfo(LPCTSTR, LPCTSTR, LPCTSTR, PILINKINFO *);
PRIVATE_CODE BOOL UnifyILinkInfo(PCVOLUMEID, UINT, LPCTSTR, PCCNRLINK, UINT, LPCTSTR, PILINKINFO *);
PRIVATE_CODE void DestroyILinkInfo(PILINKINFO);
PRIVATE_CODE BOOL UpdateILinkInfo(PCILINKINFO, LPCTSTR, PDWORD, PILINKINFO *);
PRIVATE_CODE BOOL UseNewILinkInfo(PCILINKINFO, PCILINKINFO);
PRIVATE_CODE BOOL ResolveLocalILinkInfo(PCILINKINFO, LPTSTR, int, DWORD);
PRIVATE_CODE BOOL ResolveRemoteILinkInfo(PCILINKINFO, LPTSTR, DWORD, HWND, PDWORD);
PRIVATE_CODE BOOL ResolveILinkInfo(PCILINKINFO, LPTSTR, int, DWORD, HWND, PDWORD);
PRIVATE_CODE BOOL ResolveLocalPathFromServer(PCILINKINFO, LPTSTR, PDWORD);
PRIVATE_CODE void GetLocalPathFromILinkInfo(PCILINKINFO, LPTSTR, int);
PRIVATE_CODE void GetRemotePathFromILinkInfo(PCILINKINFO, LPTSTR, int);
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoReferents(PCILINKINFO, PCILINKINFO);
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoLocalData(PCILINKINFO, PCILINKINFO);
PRIVATE_CODE COMPARISONRESULT CompareLocalPaths(PCILINKINFO, PCILINKINFO);
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoRemoteData(PCILINKINFO, PCILINKINFO);
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoVolumes(PCILINKINFO, PCILINKINFO);
PRIVATE_CODE BOOL CheckCombinedPathLen(LPCTSTR, LPCTSTR);
PRIVATE_CODE BOOL GetILinkInfoData(PCILINKINFO, LINKINFODATATYPE, PCVOID *);
PRIVATE_CODE BOOL DisconnectILinkInfo(PCILINKINFO);

#if defined(DEBUG) || defined(EXPV)

PRIVATE_CODE BOOL IsValidLINKINFODATATYPE(LINKINFODATATYPE);

#endif

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL CheckILIFlags(PCILINKINFO);
PRIVATE_CODE BOOL CheckILICommonPathSuffix(PCILINKINFO);
PRIVATE_CODE BOOL CheckILILocalInfo(PCILINKINFO);
PRIVATE_CODE BOOL CheckILIRemoteInfo(PCILINKINFO);
PRIVATE_CODE BOOL IsValidPCLINKINFO(PCLINKINFO);
PRIVATE_CODE BOOL IsValidPCILINKINFO(PCILINKINFO);

#endif

#ifdef DEBUG

PRIVATE_CODE void DumpILinkInfo(PCILINKINFO);

#endif


/*
 ** CreateILinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CreateILinkInfo(LPCTSTR pcszPath, PILINKINFO *ppili)
{
    BOOL bResult = FALSE;
    TCHAR rgchCanonicalPath[MAX_PATH_LEN];
    DWORD dwCanonicalPathFlags;
    TCHAR rgchCNRName[MAX_PATH_LEN];
    LPTSTR pszRootPathSuffix;

    ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(ppili, PILINKINFO));

    if (GetCanonicalPathInfo(pcszPath, rgchCanonicalPath, &dwCanonicalPathFlags,
                rgchCNRName, &pszRootPathSuffix))
    {
        if (IS_FLAG_SET(dwCanonicalPathFlags, GCPI_OFL_REMOTE))
            bResult = CreateRemoteILinkInfo(rgchCanonicalPath, rgchCNRName,
                    pszRootPathSuffix, ppili);
        else
            bResult = CreateLocalILinkInfo(rgchCanonicalPath, ppili);
    }

    return(bResult);
}


/*
 ** CreateLocalILinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CreateLocalILinkInfo(LPCTSTR pcszLocalPath, PILINKINFO *ppili)
{
    BOOL bResult;
    PVOLUMEID pvolid;
    UINT ucbVolumeIDLen;

    ASSERT(IsLocalDrivePath(pcszLocalPath));
    ASSERT(IS_VALID_WRITE_PTR(ppili, PILINKINFO));

    bResult = CreateVolumeID(pcszLocalPath, &pvolid, &ucbVolumeIDLen);

    if (bResult)
    {
        PCNRLINK pcnrl;
        UINT ucbCNRLinkLen;
        TCHAR rgchLocalBasePath[MAX_PATH_LEN];
        LPCTSTR pcszCommonPathSuffix;

        bResult = CreateLocalCNRLink(pcszLocalPath, &pcnrl, &ucbCNRLinkLen,
                rgchLocalBasePath, ARRAYSIZE(rgchLocalBasePath),
                &pcszCommonPathSuffix);

        if (bResult)
        {
            /* Wrap them up. */

            bResult = UnifyILinkInfo(pvolid, ucbVolumeIDLen, rgchLocalBasePath,
                    pcnrl, ucbCNRLinkLen, pcszCommonPathSuffix,
                    ppili);

            if (ucbCNRLinkLen > 0)
                DestroyCNRLink(pcnrl);
        }

        if (ucbVolumeIDLen > 0)
            DestroyVolumeID(pvolid);
    }

    ASSERT(! bResult ||
            IS_VALID_STRUCT_PTR(*ppili, CILINKINFO));

    return(bResult);
}


/*
 ** CreateRemoteILinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CreateRemoteILinkInfo(LPCTSTR pcszRemotePath,
        LPCTSTR pcszCNRName,
        LPCTSTR pcszRootPathSuffix,
        PILINKINFO *ppili)
{
    BOOL bResult;
    PCNRLINK pcnrl;
    UINT ucbCNRLinkLen;

    ASSERT(IsCanonicalPath(pcszRemotePath));
    ASSERT(IsValidCNRName(pcszCNRName));
    ASSERT(IS_VALID_STRING_PTR(pcszRootPathSuffix, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(ppili, PILINKINFO));

    bResult = CreateRemoteCNRLink(pcszRemotePath, pcszCNRName, &pcnrl,
            &ucbCNRLinkLen);

    if (bResult)
    {
        /* Wrap it up. */

        bResult = UnifyILinkInfo(NULL, 0, EMPTY_STRING, pcnrl, ucbCNRLinkLen,
                pcszRootPathSuffix, ppili);

        if (EVAL(ucbCNRLinkLen > 0))
            DestroyCNRLink(pcnrl);
    }

    ASSERT(! bResult ||
            IS_VALID_STRUCT_PTR(*ppili, CILINKINFO));

    return(bResult);
}


/*
 ** UnifyILinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL UnifyILinkInfo(PCVOLUMEID pcvolid, UINT ucbVolumeIDLen,
        LPCTSTR pcszLocalBasePath, PCCNRLINK pccnrl,
        UINT ucbCNRLinkLen, LPCTSTR pcszCommonPathSuffix,
        PILINKINFO *ppili)
{
    BOOL bResult;
    UINT ucbILinkInfoLen;
    UINT ucbDataOffset;
    UINT cbAnsiLocalBasePath;
    UINT cbAnsiCommonPathSuffix;
#ifdef UNICODE
    BOOL bUnicode;
    UINT cchChars;
    CHAR szAnsiLocalBasePath[MAX_PATH*2];
    CHAR szAnsiCommonPathSuffix[MAX_PATH*2];
    UINT cbWideLocalBasePath;
    UINT cbWideCommonPathSuffix;
    UINT cbChars;
#endif

    ASSERT(! ucbVolumeIDLen ||
            (IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID) &&
             IsDrivePath(pcszLocalBasePath)));
    ASSERT(! ucbCNRLinkLen ||
            IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));
    ASSERT(IS_VALID_STRING_PTR(pcszCommonPathSuffix, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(ppili, PILINKINFO));

#ifdef UNICODE
    bUnicode = FALSE;

    /*
     ** Convert the common-path string from UNICODE->ansi and back again
     ** to determine if the string contains any non-ansi characters.  If no
     ** characters are lost in the conversion then the string contains only 
     ** ansi chars.
     */
    cbAnsiCommonPathSuffix = WideCharToMultiByte(CP_ACP, 0, pcszCommonPathSuffix, -1,
            szAnsiCommonPathSuffix, ARRAYSIZE(szAnsiCommonPathSuffix),
            0, 0);
    if ( cbAnsiCommonPathSuffix == 0 )
    {
        bUnicode = FALSE;
    }
    else
    {
        WCHAR szWideCommonPathSuffix[MAX_PATH];

        cbChars = MultiByteToWideChar(CP_ACP, 0, szAnsiCommonPathSuffix, -1,
                szWideCommonPathSuffix, ARRAYSIZE(szWideCommonPathSuffix));
        if ( cbChars == 0 || lstrcmp(pcszCommonPathSuffix,szWideCommonPathSuffix) != 0 )
        {
            bUnicode = TRUE;
        }
    }

    if (ucbVolumeIDLen > 0)
    {
        /*
         ** Convert the localbase-path string from UNICODE->ansi and back again
         ** to determine if the string contains any non-ansi characters.  If no
         ** characters are lost in the conversion then the string contains only 
         ** ansi chars.
         */
        cbAnsiLocalBasePath = WideCharToMultiByte(CP_ACP, 0, pcszLocalBasePath, -1,
                szAnsiLocalBasePath, ARRAYSIZE(szAnsiLocalBasePath),
                0, 0);
        if ( cbAnsiLocalBasePath == 0 )
        {
            bUnicode = FALSE;
        }
        else
        {
            WCHAR szWideLocalBasePath[MAX_PATH];

            cchChars = MultiByteToWideChar(CP_ACP, 0, szAnsiLocalBasePath, -1,
                    szWideLocalBasePath, ARRAYSIZE(szWideLocalBasePath));
            if ( cchChars == 0 || lstrcmp(pcszLocalBasePath,szWideLocalBasePath) != 0 )
            {
                bUnicode = TRUE;
            }
        }
    }
    else
    {
        cbAnsiLocalBasePath = 0;
    }

    if ( bUnicode )
    {
        ucbDataOffset = SIZEOF(ILINKINFOW);

        /* (+ 1) for null terminator. */
        cbWideCommonPathSuffix = (lstrlen(pcszCommonPathSuffix) + 1) * sizeof(TCHAR);

        if (ucbVolumeIDLen > 0)
            cbWideLocalBasePath = (lstrlen(pcszLocalBasePath) + 1) * sizeof(TCHAR);
        else
            cbWideLocalBasePath = 0;

    }
    else
    {
        ucbDataOffset = SIZEOF(ILINKINFOA);

        cbWideCommonPathSuffix = 0;
        cbWideLocalBasePath  = 0;
    }

    ucbILinkInfoLen = ucbDataOffset +
        ucbVolumeIDLen +
        cbAnsiLocalBasePath;
    if ( bUnicode && ucbVolumeIDLen > 0 )
    {
        ucbILinkInfoLen = ALIGN_WORD_CNT(ucbILinkInfoLen);
        ucbILinkInfoLen += cbWideLocalBasePath;
    }
    if ( ucbCNRLinkLen > 0 )
    {
        ucbILinkInfoLen = ALIGN_DWORD_CNT(ucbILinkInfoLen);
        ucbILinkInfoLen += ucbCNRLinkLen;
    }
    ucbILinkInfoLen += cbAnsiCommonPathSuffix;
    if ( bUnicode )
    {
        ucbILinkInfoLen = ALIGN_WORD_CNT(ucbILinkInfoLen);
        ucbILinkInfoLen += cbWideCommonPathSuffix;
    }

#else

    /* Calculate total length. */

    /* Assume we don't overflow ucbILinkInfoLen here. */

    /*
     * Base structure size plus common path suffix length.  (+ 1) for null
     * terminator.
     */
    cbAnsiCommonPathSuffix = lstrlen(pcszCommonPathSuffix) + 1;

    ucbILinkInfoLen = SIZEOF(**ppili) +
        cbAnsiCommonPathSuffix;

    /* Plus size of local information. */

    if (ucbVolumeIDLen > 0)
    {
        /* (+ 1) for null terminator. */
        cbAnsiLocalBasePath = lstrlen(pcszLocalBasePath) + 1;

        ucbILinkInfoLen += ucbVolumeIDLen +
            cbAnsiLocalBasePath;
    }

    /* Plus size of remote information. */

    if (ucbCNRLinkLen > 0)
        /* (+ 1) for null terminator. */
        ucbILinkInfoLen += ucbCNRLinkLen;

    ucbDataOffset = SIZEOF(**ppili);
#endif

    /* Try to allocate a container. */

    bResult = AllocateMemory(ucbILinkInfoLen, ppili);

    if (bResult)
    {
        (*ppili)->li.ucbSize = ucbILinkInfoLen;

        (*ppili)->ucbHeaderSize = ucbDataOffset;
        (*ppili)->dwFlags = 0;

        /* Do we have local information? */

        if (ucbVolumeIDLen > 0)
        {
            /* Yes.  Add it to the structure. */

            ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));
            ASSERT(IsDrivePath(pcszLocalBasePath));

            /* Append local volume ID. */

            (*ppili)->ucbVolumeIDOffset = ucbDataOffset;
            CopyMemory(ILI_Volume_ID_Ptr(*ppili), pcvolid, ucbVolumeIDLen);
            ucbDataOffset += ucbVolumeIDLen;

            /* Append local path. */

            // lstrcpy: Enough memory is allocated above so unnecessary to do a 
            // bounded copy
            (*ppili)->ucbLocalBasePathOffset = ucbDataOffset;
#ifdef UNICODE
            lstrcpyA(ILI_Local_Base_Path_PtrA(*ppili), szAnsiLocalBasePath);
            ucbDataOffset += cbAnsiLocalBasePath;

            if ( bUnicode )
            {
                ucbDataOffset = ALIGN_WORD_CNT(ucbDataOffset);
                (*ppili)->ucbLocalBasePathOffsetW = ucbDataOffset;
                lstrcpy(ILI_Local_Base_Path_PtrW(*ppili), pcszLocalBasePath);
                ucbDataOffset += cbWideLocalBasePath;
            }
#else
            lstrcpy(ILI_Local_Base_Path_Ptr(*ppili), pcszLocalBasePath);
            ucbDataOffset += cbAnsiLocalBasePath;
#endif
            SET_FLAG((*ppili)->dwFlags, ILI_FL_LOCAL_INFO_VALID);
        }

        /* Do we have remote information? */

        if (ucbCNRLinkLen > 0)
        {
            ucbDataOffset = ALIGN_DWORD_CNT(ucbDataOffset);

            /* Yes.  Add it to the structure. */

            ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

            /* Append CNR link. */

            (*ppili)->ucbCNRLinkOffset = ucbDataOffset;
            CopyMemory(ILI_CNR_Link_Ptr(*ppili), pccnrl, ucbCNRLinkLen);
            ucbDataOffset += ucbCNRLinkLen;

            SET_FLAG((*ppili)->dwFlags, ILI_FL_REMOTE_INFO_VALID);
        }

        /* Append common path suffix. */

        ASSERT(IS_VALID_STRING_PTR(pcszCommonPathSuffix, CSTR));

        (*ppili)->ucbCommonPathSuffixOffset = ucbDataOffset;
#ifdef UNICODE
        lstrcpyA(ILI_Common_Path_Suffix_PtrA(*ppili), szAnsiCommonPathSuffix);
        ucbDataOffset += cbAnsiCommonPathSuffix;
        if ( bUnicode )
        {
            ucbDataOffset = ALIGN_WORD_CNT(ucbDataOffset);

            (*ppili)->ucbCommonPathSuffixOffsetW = ucbDataOffset;
            lstrcpy(ILI_Common_Path_Suffix_Ptr(*ppili), pcszCommonPathSuffix);
            ucbDataOffset += cbWideCommonPathSuffix;
        }
#else /* UNICODE */
        lstrcpy(ILI_Common_Path_Suffix_Ptr(*ppili), pcszCommonPathSuffix);
#ifdef DEBUG
        /*
         ** NOTE:  This same increment was present above in the UNICODE section
         **        enclosed in an #ifdef DEBUG block.
         **        It was causing the assertion below (ucbDataOffset == ucbILinkInfoLen)
         **        to fail.  I have left stmt instance in the ansi build untouched.
         **        If the assertion fails in the ansi build you should 
         **        try removing this next statement. [brianau - 4/15/99]
         */
        ucbDataOffset += cbAnsiCommonPathSuffix;
#endif
#endif

        /* Do all the calculated lengths match? */

        // ASSERT(ucbDataOffset == (*ppili)->li.ucbSize);
        ASSERT(ucbDataOffset == ucbILinkInfoLen);
    }

    ASSERT(! bResult ||
            IS_VALID_STRUCT_PTR(*ppili, CILINKINFO));

    return(bResult);
}


/*
 ** DestroyILinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DestroyILinkInfo(PILINKINFO pili)
{
    ASSERT(IS_VALID_STRUCT_PTR(pili, CILINKINFO));

    FreeMemory(pili);

    return;
}


/*
 ** UpdateILinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** An ILinkInfo structure is updated in the following cases:
 **
 ** local information:
 **
 **    1) the local path has changed
 **    2) remote information is available for the local path
 **
 ** remote information:
 **
 **    3) the remote information is local to this machine, and local information
 **       is available for the remote path
 */
PRIVATE_CODE BOOL UpdateILinkInfo(PCILINKINFO pcili, LPCTSTR pcszResolvedPath,
        PDWORD pdwOutFlags, PILINKINFO *ppiliUpdated)
{
    BOOL bResult;

    ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
    ASSERT(IS_VALID_STRING_PTR(pcszResolvedPath, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));
    ASSERT(IS_VALID_WRITE_PTR(ppiliUpdated, PILINKINFO));

    *pdwOutFlags = 0;

    bResult = CreateILinkInfo(pcszResolvedPath, ppiliUpdated);

    if (bResult)
    {
        if (UseNewILinkInfo(pcili, *ppiliUpdated))
        {
            SET_FLAG(*pdwOutFlags, RLI_OFL_UPDATED);

            WARNING_OUT((TEXT("UpdateILinkInfo(): Updating ILinkInfo for path %s."),
                        pcszResolvedPath));
        }
    }

    ASSERT(! bResult ||
            (IS_FLAG_CLEAR(*pdwOutFlags, RLI_OFL_UPDATED) ||
             IS_VALID_STRUCT_PTR(*ppiliUpdated, CILINKINFO)));

    return(bResult);
}


/*
 ** UseNewILinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TRUE if the new ILinkInfo structure contains more or
 **                different information than the old ILinkInfo structure.
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL UseNewILinkInfo(PCILINKINFO pciliOld, PCILINKINFO pciliNew)
{
    BOOL bUpdate = FALSE;

    ASSERT(IS_VALID_STRUCT_PTR(pciliOld, CILINKINFO));
    ASSERT(IS_VALID_STRUCT_PTR(pciliNew, CILINKINFO));

    /* Does the new ILinkInfo structure contain local information? */

    if (IS_FLAG_SET(pciliNew->dwFlags, ILI_FL_LOCAL_INFO_VALID))
    {
        /* Yes.  Does the old ILinkInfo structure contain local information? */

        if (IS_FLAG_SET(pciliOld->dwFlags, ILI_FL_LOCAL_INFO_VALID))
            /*
             * Yes.  Update the old ILinkInfo structure if local information
             * differs.
             */
            bUpdate = (CompareILinkInfoLocalData(pciliOld, pciliNew) != CR_EQUAL);
        else
            /* No.  Update the old ILinkInfo structure. */
            bUpdate = TRUE;
    }
    else
        /* No.  Do not update the old ILinkInfo structure. */
        bUpdate = FALSE;

    /*
     * Do we already need to update the old ILinkInfo structure based on local
     * information comparison?
     */

    if (! bUpdate)
    {
        /* No.  Compare remote information. */

        /* Does the new ILinkInfo structure contain remote information? */

        if (IS_FLAG_SET(pciliNew->dwFlags, ILI_FL_REMOTE_INFO_VALID))
        {
            /*
             * Yes.  Does the old ILinkInfo structure contain remote information?
             */

            if (IS_FLAG_SET(pciliOld->dwFlags, ILI_FL_REMOTE_INFO_VALID))
                /*
                 * Yes.  Update the old ILinkInfo structure if remote information
                 * differs.
                 */
                bUpdate = (CompareILinkInfoRemoteData(pciliOld, pciliNew)
                        != CR_EQUAL);
            else
                /* No.  Update the old ILinkInfo structure. */
                bUpdate = TRUE;
        }
    }

    return(bUpdate);
}


/*
 ** ResolveLocalILinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL ResolveLocalILinkInfo(PCILINKINFO pcili,
        LPTSTR pszResolvedPathBuf,
        int cchMax,
        DWORD dwInFlags)
{
    BOOL bResult;
    DWORD dwLocalSearchFlags;
    TCHAR rgchLocalPath[MAX_PATH_LEN];

    ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszResolvedPathBuf, STR, MAX_PATH_LEN));
    ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_RLI_IFLAGS));

    /* Search for local path. */

    TRACE_OUT((TEXT("ResolveLocalILinkInfo(): Attempting to resolve LinkInfo locally.")));

    GetLocalPathFromILinkInfo(pcili, rgchLocalPath, ARRAYSIZE(rgchLocalPath));

    if (IS_FLAG_SET(dwInFlags, RLI_IFL_LOCAL_SEARCH))
        dwLocalSearchFlags = SFLP_IFL_LOCAL_SEARCH;
    else
        dwLocalSearchFlags = 0;

    bResult = SearchForLocalPath(ILI_Volume_ID_Ptr(pcili), rgchLocalPath,
            dwLocalSearchFlags, pszResolvedPathBuf, cchMax);

    ASSERT(! bResult ||
            EVAL(IsCanonicalPath(pszResolvedPathBuf)));

    return(bResult);
}


/*
 ** ResolveRemoteILinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL ResolveRemoteILinkInfo(PCILINKINFO pcili,
        LPTSTR pszResolvedPathBuf,
        DWORD dwInFlags, HWND hwndOwner,
        PDWORD pdwOutFlags)
{
    BOOL bResult;

    ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszResolvedPathBuf, STR, MAX_PATH_LEN));
    ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_RLI_IFLAGS));
    ASSERT(IS_FLAG_CLEAR(dwInFlags, RLI_IFL_ALLOW_UI) ||
            IS_VALID_HANDLE(hwndOwner, WND));
    ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));

    ASSERT(IS_FLAG_CLEAR(dwInFlags, RLI_IFL_TEMPORARY) ||
            IS_FLAG_SET(dwInFlags, RLI_IFL_CONNECT));

    TRACE_OUT((TEXT("ResolveRemoteILinkInfo(): Attempting to resolve LinkInfo remotely.")));

    /* Connect if requested. */

    if (IS_FLAG_SET(dwInFlags, RLI_IFL_CONNECT))
    {
        DWORD dwConnectInFlags;
        DWORD dwConnectOutFlags;

        dwConnectInFlags = 0;

        if (IS_FLAG_SET(dwInFlags, RLI_IFL_TEMPORARY))
            dwConnectInFlags = CONNECT_TEMPORARY;

        if (IS_FLAG_SET(dwInFlags, RLI_IFL_ALLOW_UI))
            SET_FLAG(dwConnectInFlags, CONNECT_INTERACTIVE);

        if (IS_FLAG_SET(dwInFlags, RLI_IFL_REDIRECT))
            SET_FLAG(dwConnectInFlags, CONNECT_REDIRECT);

        bResult = ConnectToCNR(ILI_CNR_Link_Ptr(pcili), dwConnectInFlags,
                hwndOwner, pszResolvedPathBuf,
                &dwConnectOutFlags);

        if (bResult)
        {
#ifdef UNICODE
            WCHAR szWideCommonPathSuffix[MAX_PATH];
            LPWSTR pszWideCommonPathSuffix;

            if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
            {
                pszWideCommonPathSuffix = szWideCommonPathSuffix;
                MultiByteToWideChar(CP_ACP, 0,
                        ILI_Common_Path_Suffix_PtrA(pcili), -1,
                        szWideCommonPathSuffix, ARRAYSIZE(szWideCommonPathSuffix));
            }
            else
            {
                pszWideCommonPathSuffix = ILI_Common_Path_Suffix_Ptr(pcili);
            }
            CatPath(pszResolvedPathBuf, pszWideCommonPathSuffix, MAX_PATH_LEN);
#else
            CatPath(pszResolvedPathBuf, ILI_Common_Path_Suffix_Ptr(pcili), MAX_PATH_LEN);
#endif

            if (IS_FLAG_SET(dwConnectOutFlags, CONNECT_REFCOUNT))
            {
                ASSERT(IS_FLAG_CLEAR(dwConnectOutFlags, CONNECT_LOCALDRIVE));

                SET_FLAG(*pdwOutFlags, RLI_OFL_DISCONNECT);
            }
        }
    }
    else
    {
        /*
         * It's ok that IsCNRAvailable() and GetRemotePathFromILinkInfo() are
         * broken for NPs whose CNR names are not valid file system root paths.
         *
         * For NPs whose CNR names are valid file system root paths,
         * IsCNRAvailable() will succeed or fail, and
         * GetRemotePathFromILinkInfo() will be called only on success.
         *
         * For NPs whose CNR names are not valid file system root paths,
         * IsCNRAvailable() will fail and GetRemotePathFromILinkInfo() will not
         * be called.
         */

        bResult = IsCNRAvailable(ILI_CNR_Link_Ptr(pcili));

        if (bResult)
            GetRemotePathFromILinkInfo(pcili, pszResolvedPathBuf, MAX_PATH_LEN);
    }

    ASSERT(! bResult ||
            (EVAL(IsCanonicalPath(pszResolvedPathBuf)) &&
             FLAGS_ARE_VALID(*pdwOutFlags, ALL_RLI_OFLAGS)));

    return(bResult);
}


/*
 ** ResolveILinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL ResolveILinkInfo(PCILINKINFO pcili, LPTSTR pszResolvedPathBuf,
        int cchMax, DWORD dwInFlags, HWND hwndOwner,
        PDWORD pdwOutFlags)
{
    BOOL bResult;
    BOOL bLocalInfoValid;
    BOOL bRemoteInfoValid;
    BOOL bLocalShare;

    ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszResolvedPathBuf, STR, MAX_PATH_LEN));
    ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_RLI_IFLAGS));
    ASSERT(IS_FLAG_CLEAR(dwInFlags, RLI_IFL_ALLOW_UI) ||
            IS_VALID_HANDLE(hwndOwner, WND));
    ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));

    *pdwOutFlags = 0;

    /* Describe LinkInfo contents. */

    bRemoteInfoValid = IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID);
    bLocalInfoValid = IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID);

    ASSERT(bLocalInfoValid || bRemoteInfoValid);

    /*
     * RAIDRAID: (15703) We will resolve to the wrong local path for a share
     * that has been moved to another path here.
     */

    bLocalShare = FALSE;

    if (bRemoteInfoValid)
    {
        DWORD dwLocalShareFlags;

        /* Ask the server for the local path. */

        bResult = ResolveLocalPathFromServer(pcili, pszResolvedPathBuf,
                &dwLocalShareFlags);

        if (IS_FLAG_SET(dwLocalShareFlags, CNR_FL_LOCAL))
            bLocalShare = TRUE;

        if (bResult)
        {
            ASSERT(IS_FLAG_SET(dwLocalShareFlags, CNR_FL_LOCAL));

            TRACE_OUT((TEXT("ResolveILinkInfo(): Resolved local path from server.")));
        }
    }
    else
        /* Can't tell if the referent is local or not. */
        bResult = FALSE;

    if (! bResult)
    {
        /* Try local path. */

        if (bLocalInfoValid)
            bResult = ResolveLocalILinkInfo(pcili, pszResolvedPathBuf, cchMax, dwInFlags);

        if (! bResult)
        {
            /* Try remote path. */

            if (bRemoteInfoValid && ! bLocalShare)
                bResult = ResolveRemoteILinkInfo(pcili, pszResolvedPathBuf,
                        dwInFlags, hwndOwner,
                        pdwOutFlags);
        }
    }

    ASSERT(! bResult ||
            (EVAL(IsCanonicalPath(pszResolvedPathBuf)) &&
             FLAGS_ARE_VALID(*pdwOutFlags, ALL_RLI_OFLAGS)));

    return(bResult);
}


/*
 ** ResolveLocalPathFromServer()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL ResolveLocalPathFromServer(PCILINKINFO pcili,
        LPTSTR pszResolvedPathBuf,
        PDWORD pdwOutFlags)
{
    BOOL bResult;

    ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszResolvedPathBuf, STR, MAX_PATH_LEN));
    ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));

    ASSERT(IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID));

    /* Try to get local path from server. */

    bResult = GetLocalPathFromCNRLink(ILI_CNR_Link_Ptr(pcili),
            pszResolvedPathBuf, pdwOutFlags);

    if (bResult)
    {

#ifdef UNICODE
        WCHAR szWideCommonPathSuffix[MAX_PATH];
        LPWSTR pszWideCommonPathSuffix;

        ASSERT(IS_FLAG_SET(*pdwOutFlags, CNR_FL_LOCAL));

        if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
        {
            pszWideCommonPathSuffix = szWideCommonPathSuffix;
            MultiByteToWideChar(CP_ACP, 0, ILI_Common_Path_Suffix_PtrA(pcili), -1,
                    szWideCommonPathSuffix, MAX_PATH);
        }
        else
        {
            pszWideCommonPathSuffix = ILI_Common_Path_Suffix_Ptr(pcili);
        }
        CatPath(pszResolvedPathBuf, pszWideCommonPathSuffix, MAX_PATH_LEN);
#else
        ASSERT(IS_FLAG_SET(*pdwOutFlags, CNR_FL_LOCAL));

        CatPath(pszResolvedPathBuf, ILI_Common_Path_Suffix_Ptr(pcili), MAX_PATH_LEN);
#endif
    }

    ASSERT(FLAGS_ARE_VALID(*pdwOutFlags, ALL_CNR_FLAGS) &&
            (! bResult ||
             (EVAL(IS_FLAG_SET(*pdwOutFlags, CNR_FL_LOCAL)) &&
              EVAL(IsLocalDrivePath(pszResolvedPathBuf)))));

    return(bResult);
}


/*
 ** GetLocalPathFromILinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void GetLocalPathFromILinkInfo(PCILINKINFO pcili,
        LPTSTR pszResolvedPathBuf,
        int cchMax)
{
#ifdef UNICODE
    WCHAR szWideLocalBasePath[MAX_PATH];
    LPWSTR pszWideLocalBasePath;
    WCHAR szWideCommonPathSuffix[MAX_PATH];
    LPWSTR pszWideCommonPathSuffix;
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszResolvedPathBuf, STR, cchMax));

#ifdef UNICODE

    if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
    {
        pszWideLocalBasePath = szWideLocalBasePath;
        MultiByteToWideChar(CP_ACP, 0, ILI_Local_Base_Path_PtrA(pcili), -1,
                szWideLocalBasePath, ARRAYSIZE(szWideLocalBasePath));

        pszWideCommonPathSuffix = szWideCommonPathSuffix;
        MultiByteToWideChar(CP_ACP, 0, ILI_Common_Path_Suffix_PtrA(pcili), -1,
                szWideCommonPathSuffix, ARRAYSIZE(szWideCommonPathSuffix));
    }
    else
    {
        pszWideLocalBasePath    = ILI_Local_Base_Path_Ptr(pcili);
        pszWideCommonPathSuffix = ILI_Common_Path_Suffix_Ptr(pcili);
    }
    lstrcpyn(pszResolvedPathBuf, pszWideLocalBasePath, cchMax);
    CatPath(pszResolvedPathBuf, pszWideCommonPathSuffix, cchMax);
#else
    lstrcpyn(pszResolvedPathBuf, ILI_Local_Base_Path_Ptr(pcili), cchMax);
    CatPath(pszResolvedPathBuf, ILI_Common_Path_Suffix_Ptr(pcili), cchMax);
#endif

    ASSERT(lstrlen(pszResolvedPathBuf) < cchMax);
    ASSERT(IsDrivePath(pszResolvedPathBuf));

    return;
}


/*
 ** GetRemotePathFromILinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void GetRemotePathFromILinkInfo(PCILINKINFO pcili,
        LPTSTR pszResolvedPathBuf,
        int cchMax)
{
#ifdef UNICODE
    WCHAR szWideCommonPathSuffix[MAX_PATH];
    LPWSTR pszWideCommonPathSuffix;
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszResolvedPathBuf, STR, cchMax));

    /* It's ok that this is broken for non-UNC CNR names. */

    GetRemotePathFromCNRLink(ILI_CNR_Link_Ptr(pcili), pszResolvedPathBuf, cchMax);

#ifdef UNICODE
    if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
    {
        pszWideCommonPathSuffix = szWideCommonPathSuffix;
        MultiByteToWideChar(CP_ACP, 0, ILI_Common_Path_Suffix_PtrA(pcili), -1,
                szWideCommonPathSuffix, ARRAYSIZE(szWideCommonPathSuffix));
    }
    else
    {
        pszWideCommonPathSuffix = ILI_Common_Path_Suffix_Ptr(pcili);
    }
    CatPath(pszResolvedPathBuf, pszWideCommonPathSuffix, cchMax);
#else
    CatPath(pszResolvedPathBuf, ILI_Common_Path_Suffix_Ptr(pcili), cchMax);
#endif

    return;
}


/*
 ** CompareILinkInfoReferents()
 **
 ** Compares the referents of two ILINKINFO structures.
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** Comparison is performed on ILINKINFO data in only one of the following ways
 ** in the following order:
 **
 **    1) local data compared with local data
 **    2) remote data compared with remote data
 **    3) local data only < remote data only
 */
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoReferents(PCILINKINFO pciliFirst,
        PCILINKINFO pciliSecond)
{
    COMPARISONRESULT cr;

    ASSERT(IS_VALID_STRUCT_PTR(pciliFirst, CILINKINFO));
    ASSERT(IS_VALID_STRUCT_PTR(pciliSecond, CILINKINFO));

    /*
     * We can't just perform a binary comparison of the two ILinkInfos here.  We
     * may have two LinkInfos that refer to the same path, but differ in case on
     * a non-case-sensitive file system.
     */

    /* Compare ILinkInfos by local or remote data. */

    if (IS_FLAG_SET(pciliFirst->dwFlags, ILI_FL_LOCAL_INFO_VALID) &&
            IS_FLAG_SET(pciliSecond->dwFlags, ILI_FL_LOCAL_INFO_VALID))
        /* Compare local data. */
        cr = CompareILinkInfoLocalData(pciliFirst, pciliSecond);
    else if (IS_FLAG_SET(pciliFirst->dwFlags, ILI_FL_REMOTE_INFO_VALID) &&
            IS_FLAG_SET(pciliSecond->dwFlags, ILI_FL_REMOTE_INFO_VALID))
        /* Compare remote data. */
        cr = CompareILinkInfoRemoteData(pciliFirst, pciliSecond);
    else
    {
        /*
         * One contains only valid local information and the other contains only
         * valid remote information.
         */

        ASSERT(! ((pciliFirst->dwFlags & (ILI_FL_LOCAL_INFO_VALID | ILI_FL_REMOTE_INFO_VALID)) &
                    (pciliSecond->dwFlags & (ILI_FL_LOCAL_INFO_VALID | ILI_FL_REMOTE_INFO_VALID))));

        /* By fiat, local only < remote only. */

        if (IS_FLAG_SET(pciliFirst->dwFlags, ILI_FL_LOCAL_INFO_VALID))
            cr = CR_FIRST_SMALLER;
        else
            cr = CR_FIRST_LARGER;
    }

    ASSERT(IsValidCOMPARISONRESULT(cr));

    return(cr);
}


/*
 ** CompareILinkInfoLocalData()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** Local ILinkInfo data is compared in the following order:
 **
 **    1) volume ID
 **    2) sub path from root
 */
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoLocalData(PCILINKINFO pciliFirst,
        PCILINKINFO pciliSecond)
{
    COMPARISONRESULT cr;

    ASSERT(IS_VALID_STRUCT_PTR(pciliFirst, CILINKINFO));
    ASSERT(IS_VALID_STRUCT_PTR(pciliSecond, CILINKINFO));

    cr = CompareVolumeIDs(ILI_Volume_ID_Ptr(pciliFirst),
            ILI_Volume_ID_Ptr(pciliSecond));

    if (cr == CR_EQUAL)
        cr = CompareLocalPaths(pciliFirst, pciliSecond);

    ASSERT(IsValidCOMPARISONRESULT(cr));

    return(cr);
}


/*
 ** CompareLocalPaths()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE COMPARISONRESULT CompareLocalPaths(PCILINKINFO pciliFirst,
        PCILINKINFO pciliSecond)
{
    COMPARISONRESULT cr;
    TCHAR rgchFirstLocalPath[MAX_PATH_LEN];
    TCHAR rgchSecondLocalPath[MAX_PATH_LEN];

    ASSERT(IS_VALID_STRUCT_PTR(pciliFirst, CILINKINFO));
    ASSERT(IS_VALID_STRUCT_PTR(pciliSecond, CILINKINFO));

    GetLocalPathFromILinkInfo(pciliFirst, rgchFirstLocalPath, ARRAYSIZE(rgchFirstLocalPath));
    GetLocalPathFromILinkInfo(pciliSecond, rgchSecondLocalPath, ARRAYSIZE(rgchSecondLocalPath));

    cr = ComparePathStrings(rgchFirstLocalPath, rgchSecondLocalPath);

    ASSERT(IsValidCOMPARISONRESULT(cr));

    return(cr);
}


/*
 ** CompareILinkInfoRemoteData()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoRemoteData(PCILINKINFO pciliFirst,
        PCILINKINFO pciliSecond)
{
    COMPARISONRESULT cr;
#ifdef UNICODE
    WCHAR szWideCommonPathSuffixFirst[MAX_PATH];
    WCHAR szWideCommonPathSuffixSecond[MAX_PATH];
    LPWSTR pszWideCommonPathSuffixFirst;
    LPWSTR pszWideCommonPathSuffixSecond;
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pciliFirst, CILINKINFO));
    ASSERT(IS_VALID_STRUCT_PTR(pciliSecond, CILINKINFO));

    cr = CompareCNRLinks(ILI_CNR_Link_Ptr(pciliFirst),
            ILI_CNR_Link_Ptr(pciliSecond));

#ifdef UNICODE
    if (pciliFirst->ucbHeaderSize == SIZEOF(ILINKINFOA))
    {
        pszWideCommonPathSuffixFirst = szWideCommonPathSuffixFirst;
        MultiByteToWideChar(CP_ACP, 0, ILI_Common_Path_Suffix_PtrA(pciliFirst), -1,
                szWideCommonPathSuffixFirst, MAX_PATH);
    }
    else
    {
        pszWideCommonPathSuffixFirst = ILI_Common_Path_Suffix_Ptr(pciliFirst);
    }

    if (pciliSecond->ucbHeaderSize == SIZEOF(ILINKINFOA))
    {
        pszWideCommonPathSuffixSecond = szWideCommonPathSuffixSecond;
        MultiByteToWideChar(CP_ACP, 0, ILI_Common_Path_Suffix_PtrA(pciliSecond), -1,
                szWideCommonPathSuffixSecond, MAX_PATH);
    }
    else
    {
        pszWideCommonPathSuffixSecond = ILI_Common_Path_Suffix_Ptr(pciliSecond);
    }
#else
    if (cr == CR_EQUAL)
        cr = ComparePathStrings(ILI_Common_Path_Suffix_Ptr(pciliFirst),
                ILI_Common_Path_Suffix_Ptr(pciliSecond));
#endif

    ASSERT(IsValidCOMPARISONRESULT(cr));

    return(cr);
}


/*
 ** CompareILinkInfoVolumes()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoVolumes(PCILINKINFO pciliFirst,
        PCILINKINFO pciliSecond)
{
    COMPARISONRESULT cr;
    BOOL bFirstLocal;
    BOOL bFirstRemote;
    BOOL bSecondLocal;
    BOOL bSecondRemote;

    ASSERT(IS_VALID_STRUCT_PTR(pciliFirst, CILINKINFO));
    ASSERT(IS_VALID_STRUCT_PTR(pciliSecond, CILINKINFO));

    bFirstLocal = IS_FLAG_SET(((PCILINKINFO)pciliFirst)->dwFlags,
            ILI_FL_LOCAL_INFO_VALID);
    bFirstRemote = IS_FLAG_SET(((PCILINKINFO)pciliFirst)->dwFlags,
            ILI_FL_REMOTE_INFO_VALID);

    bSecondLocal = IS_FLAG_SET(((PCILINKINFO)pciliSecond)->dwFlags,
            ILI_FL_LOCAL_INFO_VALID);
    bSecondRemote = IS_FLAG_SET(((PCILINKINFO)pciliSecond)->dwFlags,
            ILI_FL_REMOTE_INFO_VALID);

    if (bFirstLocal && bSecondLocal)
        /* First and second have local information. */
        cr = CompareVolumeIDs(ILI_Volume_ID_Ptr((PCILINKINFO)pciliFirst),
                ILI_Volume_ID_Ptr((PCILINKINFO)pciliSecond));
    else if (bFirstRemote && bSecondRemote)
        /* First and second have remote information. */
        cr = CompareCNRLinks(ILI_CNR_Link_Ptr((PCILINKINFO)pciliFirst),
                ILI_CNR_Link_Ptr((PCILINKINFO)pciliSecond));
    else
    {
        /*
         * One contains only valid local information and the other contains only
         * valid remote information.
         */

        ASSERT(! ((pciliFirst->dwFlags & (ILI_FL_LOCAL_INFO_VALID | ILI_FL_REMOTE_INFO_VALID)) &
                    (pciliSecond->dwFlags & (ILI_FL_LOCAL_INFO_VALID | ILI_FL_REMOTE_INFO_VALID))));

        /* By fiat, local only < remote only. */

        if (bFirstLocal)
            /*
             * First has only local information.  Second has only remote
             * information.
             */
            cr = CR_FIRST_SMALLER;
        else
            /*
             * First has only remote information.  Second has only local
             * information.
             */
            cr = CR_FIRST_LARGER;
    }

    return(cr);
}


/*
 ** CheckCombinedPathLen()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CheckCombinedPathLen(LPCTSTR pcszBase, LPCTSTR pcszSuffix)
{
    BOOL bResult;

    ASSERT(IS_VALID_STRING_PTR(pcszBase, CSTR));
    ASSERT(IS_VALID_STRING_PTR(pcszSuffix, CSTR));

    bResult = EVAL(lstrlen(pcszBase) + lstrlen(pcszSuffix) < MAX_PATH_LEN);

    if (bResult)
    {
        TCHAR rgchCombinedPath[MAX_PATH_LEN + 1];

        lstrcpyn(rgchCombinedPath, pcszBase, ARRAYSIZE(rgchCombinedPath));
        CatPath(rgchCombinedPath, pcszSuffix, ARRAYSIZE(rgchCombinedPath));

        bResult = EVAL(lstrlen(rgchCombinedPath) < MAX_PATH_LEN);
    }

    return(bResult);
}


/*
 ** GetILinkInfoData()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL GetILinkInfoData(PCILINKINFO pcili, LINKINFODATATYPE lidt,
        PCVOID *ppcvData)
{
    BOOL bResult = FALSE;

    ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
    ASSERT(IsValidLINKINFODATATYPE(lidt));
    ASSERT(IS_VALID_WRITE_PTR(ppcvData, PCVOID));

    switch (lidt)
    {
        case LIDT_VOLUME_SERIAL_NUMBER:
            if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
                bResult = GetVolumeSerialNumber(ILI_Volume_ID_Ptr(pcili),
                        (PCDWORD *)ppcvData);
            break;

        case LIDT_DRIVE_TYPE:
            if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
                bResult = GetVolumeDriveType(ILI_Volume_ID_Ptr(pcili),
                        (PCUINT *)ppcvData);
            break;

        case LIDT_VOLUME_LABEL:
            if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
                bResult = GetVolumeLabel(ILI_Volume_ID_Ptr(pcili),
                        (LPCSTR *)ppcvData);
            break;

        case LIDT_VOLUME_LABELW:
#ifdef UNICODE
            if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
                bResult = GetVolumeLabelW(ILI_Volume_ID_Ptr(pcili),
                        (LPCTSTR *)ppcvData);
#endif
            break;

        case LIDT_LOCAL_BASE_PATH:
            if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
            {
                *ppcvData = ILI_Local_Base_Path_PtrA(pcili);
                bResult = TRUE;
            }
            break;

        case LIDT_LOCAL_BASE_PATHW:
#ifdef UNICODE
            if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
            {
                if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
                    *ppcvData = NULL;
                else
                    *ppcvData = ILI_Local_Base_Path_PtrW(pcili);
                bResult = TRUE;
            }
#endif
            break;

        case LIDT_NET_TYPE:
            if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
                bResult = GetCNRNetType(ILI_CNR_Link_Ptr(pcili),
                        (PCDWORD *)ppcvData);
            break;

        case LIDT_NET_RESOURCE:
            if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
                bResult = GetCNRName(ILI_CNR_Link_Ptr(pcili),
                        (LPCSTR *)ppcvData);
            break;

        case LIDT_NET_RESOURCEW:
#ifdef UNICODE
            if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
                bResult = GetCNRNameW(ILI_CNR_Link_Ptr(pcili),
                        (LPCWSTR *)ppcvData);
#endif
            break;

        case LIDT_REDIRECTED_DEVICE:
            if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
                bResult = GetLastRedirectedDevice(ILI_CNR_Link_Ptr(pcili),
                        (LPCSTR *)ppcvData);
            break;

        case LIDT_REDIRECTED_DEVICEW:
#ifdef UNICODE
            if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
                bResult = GetLastRedirectedDeviceW(ILI_CNR_Link_Ptr(pcili),
                        (LPCWSTR *)ppcvData);
#endif
            break;

        case LIDT_COMMON_PATH_SUFFIX:
            *ppcvData = ILI_Common_Path_Suffix_PtrA(pcili);
            bResult = TRUE;
            break;

        case LIDT_COMMON_PATH_SUFFIXW:
#ifdef UNICODE
            if (pcili->ucbHeaderSize == sizeof(ILINKINFOA))
            {
                *ppcvData = NULL;
            }
            else
            {
                *ppcvData = ILI_Common_Path_Suffix_PtrW(pcili);
            }
            bResult = TRUE;
#endif
            break;

        default:
            bResult = FALSE;
            ERROR_OUT((TEXT("GetILinkInfoData(): Bad LINKINFODATATYPE %d."),
                        lidt));
            break;
    }

    return(bResult);
}


/*
 ** DisconnectILinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL DisconnectILinkInfo(PCILINKINFO pcili)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));

    return(DisconnectFromCNR(ILI_CNR_Link_Ptr(pcili)));
}


#if defined(DEBUG) || defined(EXPV)

/*
 ** IsValidLINKINFODATATYPE()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidLINKINFODATATYPE(LINKINFODATATYPE lidt)
{
    BOOL bResult;

    switch (lidt)
    {
        case LIDT_VOLUME_SERIAL_NUMBER:
        case LIDT_DRIVE_TYPE:
        case LIDT_VOLUME_LABEL:
        case LIDT_VOLUME_LABELW:
        case LIDT_LOCAL_BASE_PATH:
        case LIDT_LOCAL_BASE_PATHW:
        case LIDT_NET_TYPE:
        case LIDT_NET_RESOURCE:
        case LIDT_NET_RESOURCEW:
        case LIDT_REDIRECTED_DEVICE:
        case LIDT_COMMON_PATH_SUFFIX:
        case LIDT_COMMON_PATH_SUFFIXW:
            bResult = TRUE;
            break;

        default:
            bResult = FALSE;
            ERROR_OUT((TEXT("IsValidLINKINFODATATYPE(): Invalid LINKINFODATATYPE %d."),
                        lidt));
            break;
    }

    return(bResult);
}

#endif


#if defined(DEBUG) || defined(VSTF)

/*
 ** CheckILIFlags()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CheckILIFlags(PCILINKINFO pcili)
{
    return(FLAGS_ARE_VALID(pcili->dwFlags, ALL_ILINKINFO_FLAGS) &&
            (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID) ||
             IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID)));
}


/*
 ** CheckILICommonPathSuffix()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CheckILICommonPathSuffix(PCILINKINFO pcili)
{
    return(IS_VALID_STRING_PTRA(ILI_Common_Path_Suffix_PtrA(pcili), CSTR) &&
            EVAL(IsContained(pcili, pcili->li.ucbSize,
                    ILI_Common_Path_Suffix_PtrA(pcili),
                    lstrlenA(ILI_Common_Path_Suffix_PtrA(pcili)))) &&
            EVAL(! IS_SLASH(*ILI_Common_Path_Suffix_PtrA(pcili))));
}


/*
 ** CheckILILocalInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CheckILILocalInfo(PCILINKINFO pcili)
{
#ifdef UNICODE
    WCHAR   szWideLocalBasePath[MAX_PATH];
    WCHAR   szWideCommonPathSuffix[MAX_PATH];
    LPWSTR  pszWideLocalBasePath;
    LPWSTR  pszWideCommonPathSuffix;

    if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
        return FALSE;
    if (!IS_VALID_STRUCT_PTR(ILI_Volume_ID_Ptr(pcili), CVOLUMEID))
        return FALSE;
    if (!EVAL(IsContained(pcili, pcili->li.ucbSize,ILI_Volume_ID_Ptr(pcili),
                    GetVolumeIDLen(ILI_Volume_ID_Ptr(pcili)))))
        return FALSE;

    if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
    {
        pszWideLocalBasePath = szWideLocalBasePath;
        MultiByteToWideChar(CP_ACP, 0, ILI_Local_Base_Path_PtrA(pcili), -1,
                szWideLocalBasePath, MAX_PATH);

        pszWideCommonPathSuffix = szWideCommonPathSuffix;
        MultiByteToWideChar(CP_ACP, 0, ILI_Common_Path_Suffix_PtrA(pcili), -1,
                szWideCommonPathSuffix, MAX_PATH);

    }
    else
    {
        pszWideLocalBasePath = ILI_Local_Base_Path_Ptr(pcili);
        pszWideCommonPathSuffix = ILI_Common_Path_Suffix_Ptr(pcili);
    }

    if (!EVAL(IsDrivePath(pszWideLocalBasePath)))
        return FALSE;
    if (!EVAL(IsContained(pcili, pcili->li.ucbSize,
                    ILI_Local_Base_Path_PtrA(pcili),
                    lstrlenA(ILI_Local_Base_Path_PtrA(pcili)))))
        return FALSE;
    if (!EVAL(CheckCombinedPathLen(pszWideLocalBasePath,
                    pszWideCommonPathSuffix)))
        return FALSE;

    return TRUE;
#else
    return(IS_FLAG_CLEAR(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID) ||

            /* Check volume ID. */

            (IS_VALID_STRUCT_PTR(ILI_Volume_ID_Ptr(pcili), CVOLUMEID) &&
             EVAL(IsContained(pcili, pcili->li.ucbSize,
                     ILI_Volume_ID_Ptr(pcili),
                     GetVolumeIDLen(ILI_Volume_ID_Ptr(pcili)))) &&

             /* Check local base path. */

             EVAL(IsDrivePath(ILI_Local_Base_Path_Ptr(pcili))) &&
             EVAL(IsContained(pcili, pcili->li.ucbSize,
                     ILI_Local_Base_Path_PtrA(pcili),
                     lstrlen(ILI_Local_Base_Path_Ptr(pcili)))) &&
             EVAL(CheckCombinedPathLen(ILI_Local_Base_Path_Ptr(pcili),
                     ILI_Common_Path_Suffix_Ptr(pcili)))));
#endif
}


/*
 ** CheckILIRemoteInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CheckILIRemoteInfo(PCILINKINFO pcili)
{
    BOOL bResult;

    if (IS_FLAG_CLEAR(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
        bResult = TRUE;
    else
    {
        /* Check CNR link. */

        if (IS_VALID_STRUCT_PTR(ILI_CNR_Link_Ptr(pcili), CCNRLINK) &&
                EVAL(IsContained(pcili, pcili->li.ucbSize,
                        ILI_CNR_Link_Ptr(pcili),
                        GetCNRLinkLen(ILI_CNR_Link_Ptr(pcili)))))
        {
            TCHAR rgchRemoteBasePath[MAX_PATH_LEN];
#ifdef UNICODE
            WCHAR szWideCommonPathSuffix[MAX_PATH];
            LPWSTR pszWideCommonPathSuffix;
#endif
            /* RAIDRAID: (15724) This is broken for non-UNC CNR names. */

            GetRemotePathFromCNRLink(ILI_CNR_Link_Ptr(pcili), rgchRemoteBasePath, ARRAYSIZE(rgchRemoteBasePath));

#ifdef UNICODE
            if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
            {
                pszWideCommonPathSuffix = szWideCommonPathSuffix;
                MultiByteToWideChar(CP_ACP, 0, ILI_Common_Path_Suffix_PtrA(pcili), -1,
                        szWideCommonPathSuffix, ARRAYSIZE(szWideCommonPathSuffix));
            }
            else
            {
                pszWideCommonPathSuffix = ILI_Common_Path_Suffix_Ptr(pcili);
            }
            bResult = EVAL(CheckCombinedPathLen(rgchRemoteBasePath,
                        pszWideCommonPathSuffix));
#else
            bResult = EVAL(CheckCombinedPathLen(rgchRemoteBasePath,
                        ILI_Common_Path_Suffix_Ptr(pcili)));
#endif

        }
        else
            bResult = FALSE;
    }

    return(bResult);
}


/*
 ** IsValidPCLINKINFO()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCLINKINFO(PCLINKINFO pcli)
{
    return(IS_VALID_STRUCT_PTR((PCILINKINFO)pcli, CILINKINFO));
}


/*
 ** IsValidPCILINKINFO()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCILINKINFO(PCILINKINFO pcili)
{
    /*
     * A "valid" LinkInfo structure has the following characteristics:
     *
     * 1) entire structure is readable
     * 2) size of ILINKINFO header structure >= SIZEOF(CILINKINFO)
     * 3) flags are valid
     * 4) either local info or remote info or both are valid
     * 5) contained structures and strings are valid and are entirely contained
     *    in LinkInfo structure
     * 6) lstrlen() of combined paths < MAX_PATH_LEN
     */

    return(IS_VALID_READ_PTR(pcili, CILINKINFO) &&
            IS_VALID_READ_BUFFER_PTR(pcili, CILINKINFO, pcili->li.ucbSize) &&
            EVAL(pcili->ucbHeaderSize >= SIZEOF(*pcili)) &&
            EVAL(CheckILIFlags(pcili)) &&
            EVAL(CheckILICommonPathSuffix(pcili)) &&
            EVAL(CheckILILocalInfo(pcili)) &&
            EVAL(CheckILIRemoteInfo(pcili)));
}


#endif


#ifdef DEBUG

/*
 ** DumpILinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DumpILinkInfo(PCILINKINFO pcili)
{
#ifdef UNICODE
    WCHAR   szWideCommonPathSuffix[MAX_PATH];
    LPWSTR  pszWideCommonPathSuffix;
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));

    PLAIN_TRACE_OUT((TEXT("%s[LinkInfo] ucbSize = %#x"),
                INDENT_STRING,
                pcili->li.ucbSize));
    PLAIN_TRACE_OUT((TEXT("%s%s[ILinkInfo] ucbHeaderSize = %#x"),
                INDENT_STRING,
                INDENT_STRING,
                pcili->ucbHeaderSize));
    PLAIN_TRACE_OUT((TEXT("%s%s[ILinkInfo] dwFLags = %#08lx"),
                INDENT_STRING,
                INDENT_STRING,
                pcili->dwFlags));

    if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
    {
#ifdef UNICODE
        WCHAR   szWideLocalBasePath[MAX_PATH];
        LPWSTR  pszWideLocalBasePath;
#endif
        DumpVolumeID(ILI_Volume_ID_Ptr(pcili));
#ifdef UNICODE
        if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
        {
            pszWideLocalBasePath = szWideLocalBasePath;
            MultiByteToWideChar(CP_ACP, 0, ILI_Local_Base_Path_PtrA(pcili), -1,
                    szWideLocalBasePath, ARRAYSIZE(szWideLocalBasePath));
        }
        else
        {
            pszWideLocalBasePath = ILI_Local_Base_Path_Ptr(pcili);
        }
        PLAIN_TRACE_OUT((TEXT("%s%s[ILinkInfo] local base path \"%s\""),
                    INDENT_STRING,
                    INDENT_STRING,
                    pszWideLocalBasePath));
#else
        PLAIN_TRACE_OUT((TEXT("%s%s[ILinkInfo] local base path \"%s\""),
                    INDENT_STRING,
                    INDENT_STRING,
                    ILI_Local_Base_Path_Ptr(pcili)));
#endif
    }

    if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
        DumpCNRLink(ILI_CNR_Link_Ptr(pcili));

#ifdef UNICODE
    if ( pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
    {
        pszWideCommonPathSuffix = szWideCommonPathSuffix;
        MultiByteToWideChar(CP_ACP, 0, ILI_Common_Path_Suffix_PtrA(pcili), -1,
                szWideCommonPathSuffix, ARRAYSIZE(szWideCommonPathSuffix));

    }
    else
    {
        pszWideCommonPathSuffix = ILI_Common_Path_Suffix_Ptr(pcili);
    }

    PLAIN_TRACE_OUT((TEXT("%s%s[ILinkInfo] common path suffix \"%s\""),
                INDENT_STRING,
                INDENT_STRING,
                pszWideCommonPathSuffix));
#else
    PLAIN_TRACE_OUT((TEXT("%s%s[ILinkInfo] common path suffix \"%s\""),
                INDENT_STRING,
                INDENT_STRING,
                ILI_Common_Path_Suffix_Ptr(pcili)));
#endif
    return;
}

#endif


/***************************** Exported Functions ****************************/


/******************************************************************************

  @doc LINKINFOAPI

  @func BOOL | CreateLinkInfo | Creates a LinkInfo structure for a path.

  @parm PCSTR | pcszPath | A pointer to the path string that a LinkInfo structure
  is to be created for.

  @parm PLINKINFO * | ppli | A pointer to a PLINKINFO to be filled in with a
  pointer to the new LinkInfo structure.  *ppli is only valid if TRUE is
  returned.

  @rdesc If a LinkInfo structure was created successfully, TRUE is returned, and
 *ppli contains a pointer to the new LinkInfo structure.  Otherwise, a LinkInfo
 structure was not created successfully, and *ppli is undefined.  The reason for
 failure may be determined by calling GetLastError().

 @comm Once the caller is finshed with the LinkInfo structure returned by
 CreateLinkInfo(), DestroyLinkInfo() should be called to free the LinkInfo
 structure.<nl>
 The contents of the LinkInfo structure returned are opaque to the caller, with
 the exception of the first field of the LinkInfo structure.  The first field of
 the LinkInfo structure, ucbSize, is a UINT containing the size of the LinkInfo
 structure in bytes, including the ucbSize field.<nl>
 The LinkInfo structure is created in memory that is private to the LinkInfo
 APIs.  The returned LinkInfo structure should be copied into the caller's
 memory, and the DestroyLinkInfo() should be called to free the LinkInfo
 structure from the LinkInfo APIs' private memory.

 @xref DestroyLinkInfo

 ******************************************************************************/

LINKINFOAPI BOOL WINAPI CreateLinkInfo(LPCTSTR pcszPath, PLINKINFO *ppli)
{
    BOOL bResult;

    DebugEntry(CreateLinkInfo);

#ifdef EXPV
    /* Verify parameters. */

    if (IS_VALID_STRING_PTR(pcszPath, CSTR) &&
            IS_VALID_WRITE_PTR(ppli, PLINKINFO))
#endif
    {
        bResult = CreateILinkInfo(pcszPath, (PILINKINFO *)ppli);

#ifdef DEBUG

        if (bResult)
        {
            TRACE_OUT((TEXT("CreateLinkInfo(): LinkInfo created for path %s:"),
                        pcszPath));
            DumpILinkInfo(*(PILINKINFO *)ppli);
        }

#endif

    }
#ifdef EXPV
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bResult = FALSE;
    }
#endif

    ASSERT(! bResult ||
            IS_VALID_STRUCT_PTR(*ppli, CLINKINFO));

    DebugExitBOOL(CreateLinkInfo, bResult);

    return(bResult);
}

#ifdef UNICODE
LINKINFOAPI BOOL WINAPI CreateLinkInfoA(LPCSTR pcszPath, PLINKINFO *ppli)
{
    LPWSTR  lpwstr;
    UINT    cchPath;

    cchPath = lstrlenA(pcszPath) + 1;

    lpwstr = (LPWSTR)_alloca(cchPath*SIZEOF(WCHAR));

    if (MultiByteToWideChar(CP_ACP, 0, pcszPath, cchPath,
                lpwstr, cchPath) == 0)
    {
        return FALSE;
    }
    else
    {
        return CreateLinkInfo(lpwstr,ppli);
    }
}
#endif

/******************************************************************************

  @doc LINKINFOAPI

  @func void | DestroyLinkInfo | Destroys a LinkInfo structure created by
  CreateLinkInfo().

  @parm PLINKINFO | pli | A pointer to the LinkInfo structure to be destroyed.

  @xref CreateLinkInfo

 ******************************************************************************/

LINKINFOAPI void WINAPI DestroyLinkInfo(PLINKINFO pli)
{
    DebugEntry(DestroyLinkInfo);

#ifdef EXPV
    /* Verify parameters. */
    if (
            IS_VALID_STRUCT_PTR(pli, CLINKINFO))
#endif
    {
        DestroyILinkInfo((PILINKINFO)pli);
    }

    DebugExitVOID(DestroyLinkInfo);

    return;
}


/******************************************************************************

  @doc LINKINFOAPI

  @func int | CompareLinkInfoReferents | Compares the referents of two LinkInfo
  structures.

  @parm PCLINKINFO | pcliFirst | A pointer to the first LinkInfo structure whose
  referent is to be compared.

  @parm PCLINKINFO | pcliSecond | A pointer to the second LinkInfo structure
  whose referent is to be compared.

  @rdesc If the referent of the first LinkInfo structure is less than the
  referent of the second LinkInfo structure, a negative value is returned.  If
  the referent of the first LinkInfo structure is the same as the referent of the
  second LinkInfo structure, zero is returned.  If the referent of the first
  LinkInfo structure is larger than the referent of the second LinkInfo
  structure, a positive value is returned.  An invalid LinkInfo structure is
  considered to have a referent that is less than the referent of any valid
  LinkInfo structure.  All invalid LinkInfo structures are considered to have the
  same referent.

  @comm The value returned is actually a COMPARISONRESULT, for clients that
  understand COMPARISONRESULTs, like SYNCENG.DLL.

  @xref CompareLinkInfoVolumes

 ******************************************************************************/

LINKINFOAPI int WINAPI CompareLinkInfoReferents(PCLINKINFO pcliFirst,
        PCLINKINFO pcliSecond)
{
    COMPARISONRESULT cr;
    BOOL bFirstValid;
    BOOL bSecondValid;

    DebugEntry(CompareLinkInfoReferents);

    bFirstValid = IS_VALID_STRUCT_PTR(pcliFirst, CLINKINFO);

    bSecondValid = IS_VALID_STRUCT_PTR(pcliSecond, CLINKINFO);

    if (bFirstValid)
    {
        if (bSecondValid)
            cr = CompareILinkInfoReferents((PCILINKINFO)pcliFirst,
                    (PCILINKINFO)pcliSecond);
        else
            cr = CR_FIRST_LARGER;
    }
    else
    {
        if (bSecondValid)
            cr = CR_FIRST_SMALLER;
        else
            cr = CR_EQUAL;
    }

    ASSERT(IsValidCOMPARISONRESULT(cr));

    DebugExitCOMPARISONRESULT(CompareLinkInfoReferents, cr);

    return(cr);
}


/******************************************************************************

  @doc LINKINFOAPI

  @func int | CompareLinkInfoVolumes | Compares the volumes of the referents of
  two LinkInfo structures.

  @parm PCLINKINFO | pcliFirst | A pointer to the first LinkInfo structure whose
  referent's volume is to be compared.

  @parm PCLINKINFO | pcliSecond | A pointer to the second LinkInfo structure
  referent's volume is to be compared.

  @rdesc If the volume of the referent of the first LinkInfo structure is less
  than the volume of the referent of the second LinkInfo structure, a negative
  value is returned.  If the volume of the referent of the first LinkInfo
  structure is the same as the volume of the referent of the second LinkInfo
  structure, zero is returned.  If the volume of the referent of the first
  LinkInfo structure is larger than the volume of the referent of the second
  LinkInfo structure, a positive value is returned.  An invalid LinkInfo
  structure is considered to have a referent's volume that is less than the
  referent's volume of any valid LinkInfo structure.  All invalid LinkInfo
  structures are considered to have the same referent's volume.

  @comm The value returned is actually a COMPARISONRESULT, for clients that
  understand COMPARISONRESULTs, like SYNCENG.DLL.

  @xref CompareLinkInfoReferents

 ******************************************************************************/

LINKINFOAPI int WINAPI CompareLinkInfoVolumes(PCLINKINFO pcliFirst,
        PCLINKINFO pcliSecond)
{
    COMPARISONRESULT cr;
    BOOL bFirstValid;
    BOOL bSecondValid;

    DebugEntry(CompareLinkInfoVolumes);

    bFirstValid = IS_VALID_STRUCT_PTR(pcliFirst, CLINKINFO);
    bSecondValid = IS_VALID_STRUCT_PTR(pcliSecond, CLINKINFO);

    if (bFirstValid)
    {
        if (bSecondValid)
            cr = CompareILinkInfoVolumes((PCILINKINFO)pcliFirst,
                    (PCILINKINFO)pcliSecond);
        else
            cr = CR_FIRST_LARGER;
    }
    else
    {
        if (bSecondValid)
            cr = CR_FIRST_SMALLER;
        else
            cr = CR_EQUAL;
    }

    ASSERT(IsValidCOMPARISONRESULT(cr));

    DebugExitCOMPARISONRESULT(CompareLinkInfoVolumes, cr);

    return(cr);
}


/******************************************************************************

  @doc LINKINFOAPI

  @func BOOL | ResolveLinkInfo | Resolves a LinkInfo structure into a file system
  path on an available volume.

  @parm PCLINKINFO | pcli | A pointer to the LinkInfo structure to be resolved.

  @parm PSTR | pszResolvedPathBuf | A pointer to a buffer to be filled in with
  the path resolved to the LinkInfo structure's referent.

  @parm DWORD | dwInFlags | A bit mask of flags.  This parameter may be any
  combination of the following values:

  @flag RLI_IFL_CONNECT | If set, connect to the referent's parent connectable
  network resource if necessary.  If clear, no connection is established.

  @flag RLI_IFL_ALLOW_UI | If set, interaction with the user is permitted, and
  the hwndOwner parameter identifies the parent window to be used for any ui
  required.  If clear, interaction with the user is not permitted.

  @flag RLI_IFL_REDIRECT | If set, the resolved path is a redirected logical
  device path.  If clear, the resolved path is only a redirected logical device
  path if the RLI_IFL_CONNECT flag is set, and the network requires a redirected
  logical device path to make a connection.

  @flag RLI_IFL_UPDATE | If set and the source LinkInfo structure needs updating,
  RLI_OFL_UPDATED will be set in *pdwOutFlags and *ppliUpdated will point to an
  updated LinkInfo structure.  If clear, RLI_OFL_UPDATED will be clear in
 *pdwOutFlags and *ppliUpdated is undefined.

 @flag RLI_IFL_LOCAL_SEARCH | If set, first the last known logical device for
 the referent's volume is checked for the volume, followed by all other local
 logical devices that handle the referent's volume's media type.  If clear, only
 the last known logical device for the referent's volume is checked for the
 volume.

 @parm HWND | hwndOwner | A handle to the parent window to be used to bring up
 any ui required.  This parameter is only used if RLI_IFL_ALLOW_UI is set in
 dwInFlags.  Otherwise, it is ignored.

 @parm PDWORD | pdwOutFlags | A pointer to a DWORD to be filled in with a bit
 mask of flags. *pdwOutFlags is only valid if TRUE is returned.  *pdwOutFlags
 may be any combination of the following values:

 @flag RLI_OFL_UPDATED | Only set if RLI_IFL_UPDATE was set in dwInFlags.  If
 set, the source LinkInfo structure needed updating, and *ppliUpdated points to
 an updated LinkInfo structure.  If clear, either RLI_IFL_UPDATE was clear in
 dwInFlags or the source LinkInfo structure didn't need updating, and
 *ppliUpdated is undefined.

 @parm PLINKINFO * | ppliUpdated | If RLI_IFL_UPDATE is set in dwInFlags,
 ppliUpdated is a pointer to a PLINKINFO to be filled in with a pointer to an
 updated LinkInfo structure, if necessary.  If RLI_IFL_UPDATE is clear in
 dwInFlags, ppliUpdated is ignored.  *ppliUpdated is only valid if
 RLI_OFL_UPDATED is set in *pdwOutFlags

 @rdesc If the LinkInfo was resolved to a path on an available successfully,
 TRUE is returned, pszResolvedPathBuf's buffer is filled in with a file system
 path to the LinkInfo structure's referent, and *pdwOutFlags is filled in as
 described above.  Otherwise, FALSE is returned, the contents of pszResolved's
 buffer are undefined, and the contents of *pdwOutFlags are undefined.  The
 reason for failure may be determined by calling GetLastError().

 @comm Once the caller is finshed with any new, updated LinkInfo structure
 returned by ResolveLinkInfo(), DestroyLinkInfo() should be called to free the
 LinkInfo structure.

 @xref DestroyLinkInfo DisconnectLinkInfo

 ******************************************************************************/

LINKINFOAPI BOOL WINAPI ResolveLinkInfo(PCLINKINFO pcli,
        LPTSTR pszResolvedPathBuf,          // MUST BE MAX_PATH_LEN SIZE
        DWORD dwInFlags, HWND hwndOwner,
        PDWORD pdwOutFlags,
        PLINKINFO *ppliUpdated)
{
    BOOL bResult;

    DebugEntry(ResolveLinkInfo);

#ifdef EXPV
    /* Verify parameters. */

    if (
            IS_VALID_STRUCT_PTR(pcli, CLINKINFO) &&
            IS_VALID_WRITE_BUFFER_PTR(pszResolvedPathBuf, STR, MAX_PATH_LEN) &&
            FLAGS_ARE_VALID(dwInFlags, ALL_RLI_IFLAGS) &&
            (IS_FLAG_CLEAR(dwInFlags, RLI_IFL_ALLOW_UI) ||
             IS_VALID_HANDLE(hwndOwner, WND)) &&
            IS_VALID_WRITE_PTR(pdwOutFlags, DWORD) &&
            (IS_FLAG_CLEAR(dwInFlags, RLI_IFL_UPDATE) ||
             IS_VALID_WRITE_PTR(ppliUpdated, PLINKINFO)) &&
            EVAL(IS_FLAG_CLEAR(dwInFlags, RLI_IFL_TEMPORARY) ||
                IS_FLAG_SET(dwInFlags, RLI_IFL_CONNECT)))
#endif
    {
        DWORD dwTempFlags;

        *pdwOutFlags = 0;

        bResult = ResolveILinkInfo((PCILINKINFO)pcli, pszResolvedPathBuf, MAX_PATH_LEN,
                dwInFlags, hwndOwner, &dwTempFlags);

        if (bResult)
        {
            *pdwOutFlags |= dwTempFlags;

            if (IS_FLAG_SET(dwInFlags, RLI_IFL_UPDATE))
            {
                bResult = UpdateILinkInfo((PCILINKINFO)pcli, pszResolvedPathBuf,
                        &dwTempFlags,
                        (PILINKINFO *)ppliUpdated);

                if (bResult)
                    *pdwOutFlags |= dwTempFlags;
            }
        }

#ifdef DEBUG

        TRACE_OUT((TEXT("ResolveLinkInfo(): flags %#08lx, given LinkInfo:"),
                    dwInFlags));
        DumpILinkInfo((PCILINKINFO)pcli);

        if (bResult)
        {
            TRACE_OUT((TEXT("ResolveLinkInfo(): Resolved path %s with flags %#08lx."),
                        pszResolvedPathBuf,
                        *pdwOutFlags));

            if (IS_FLAG_SET(*pdwOutFlags, RLI_OFL_UPDATED))
            {
                ASSERT(IS_FLAG_SET(dwInFlags, RLI_IFL_UPDATE));

                TRACE_OUT((TEXT("UpdateLinkInfo(): updated LinkInfo:")));
                DumpILinkInfo(*(PILINKINFO *)ppliUpdated);
            }
            else
            {
                if (IS_FLAG_SET(dwInFlags, RLI_IFL_UPDATE))
                    TRACE_OUT((TEXT("UpdateLinkInfo(): No update required.")));
                else
                    TRACE_OUT((TEXT("UpdateLinkInfo(): No update requested.")));
            }
        }
        else
            WARNING_OUT((TEXT("ResolveLinkInfo(): Referent's volume is unavailable.")));

#endif

    }
#ifdef EXPV
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bResult = FALSE;
    }
#endif

    ASSERT(! bResult ||
            (FLAGS_ARE_VALID(*pdwOutFlags, ALL_RLI_OFLAGS) &&
             EVAL(IsCanonicalPath(pszResolvedPathBuf)) &&
             EVAL(! (IS_FLAG_CLEAR(dwInFlags, RLI_IFL_UPDATE) &&
                     IS_FLAG_SET(*pdwOutFlags, RLI_OFL_UPDATED))) &&
             (IS_FLAG_CLEAR(*pdwOutFlags, RLI_OFL_UPDATED) ||
              IS_VALID_STRUCT_PTR(*ppliUpdated, CLINKINFO))));

    DebugExitBOOL(ResolveLinkInfo, bResult);

    return(bResult);
}

#ifdef UNICODE
LINKINFOAPI BOOL WINAPI ResolveLinkInfoA(PCLINKINFO pcli,
        LPSTR pszResolvedPathBuf,
        DWORD dwInFlags, HWND hwndOwner,
        PDWORD pdwOutFlags,
        PLINKINFO *ppliUpdated)
{
    WCHAR   szWideResolvedPathBuf[MAX_PATH];
    BOOL    fResolved;

    fResolved = ResolveLinkInfo(pcli, szWideResolvedPathBuf, dwInFlags, 
            hwndOwner, pdwOutFlags, ppliUpdated);
    if ( fResolved )
    {
        if (WideCharToMultiByte( CP_ACP, 0, szWideResolvedPathBuf, -1,
                    pszResolvedPathBuf, MAX_PATH, NULL, NULL ) == 0)
        {
            return FALSE;
        }
    }
    return fResolved;
}
#endif

/******************************************************************************

  @doc LINKINFOAPI

  @func BOOL | DisconnectLinkInfo | Cancels a connection to a net resource
  established by a previous call to ResolveLinkInfo().  DisconnectLinkInfo()
  should only be called if RLI_OFL_DISCONNECT was set in *pdwOutFlags on return
  from ResolveLinkInfo() on the given LinkInfo structure, or its updated
  equivalent.

  @parm PCLINKINFO | pcli | A pointer to the LinkInfo structure whose connection
  is to be canceled.

  @rdesc If the function completed successfully, TRUE is returned.  Otherwise,
  FALSE is returned.  The reason for failure may be determined by calling
  GetLastError().

  @xref ResolveLinkInfo

 ******************************************************************************/

LINKINFOAPI BOOL WINAPI DisconnectLinkInfo(PCLINKINFO pcli)
{
    BOOL bResult;

    DebugEntry(DisconnectLinkInfo);

#ifdef EXPV
    /* Verify parameters. */

    if (
            IS_VALID_STRUCT_PTR(pcli, CLINKINFO))
#endif
    {
        bResult = DisconnectILinkInfo((PCILINKINFO)pcli);
    }
#ifdef EXPV
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bResult = FALSE;
    }
#endif

    DebugExitBOOL(DisconnectLinkInfo, bResult);

    return(bResult);
}


/******************************************************************************

  @doc LINKINFOAPI

  @func BOOL | GetLinkInfoData | Retrieves a pointer to data in a LinkInfo
  structure.

  @parm PCLINKINFO | pcli | A pointer to the LinkInfo structure to retrieve data
  from.

  @parm LINKINFODATATYPE | lidt | The type of data to be retrieved from the
  LinkInfo structure.  lidt may be one of the following values:

  @flag LIDT_VOLUME_SERIAL_NUMBER | *ppcvData is a PCDWORD that points to the
  LinkInfo structure's referent's volume's serial number.

  @flag LIDT_DRIVE_TYPE | *ppcvData is a PCUINT that points to the LinkInfo
  structure's referent's volume's host drive type.

  @flag LIDT_VOLUME_LABEL | *ppcvData is a PCSTR that points to the LinkInfo
  structure's referent's volume's label.

  @flag LIDT_LOCAL_BASE_PATH | *ppcvData is a PCSTR that points to the LinkInfo
  structure's referent's local base path.

  @flag LIDT_NET_RESOURCE | *ppcvData is a PCSTR that points to the LinkInfo
  structure's referent's parent network resource's name.

  @flag LIDT_COMMON_PATH_SUFFIX | *ppcvData is a PCSTR that points to the
  LinkInfo structure's referent's common path suffix.

  @rdesc If the function completed successfully, TRUE is returned, and *ppcvData
  is filled in with a pointer to the data requested from LinkInfo structure or NULL
  if that was a valid field, but empty.
  Otherwise, FALSE is returned, and the contents of *ppcvData are undefined.  The
  reason for failure may be determined by calling GetLastError().

  @comm A LinkInfo structure may only contain some of the LinkInfo data listed
  above.

 ******************************************************************************/

LINKINFOAPI BOOL WINAPI GetLinkInfoData(PCLINKINFO pcli, LINKINFODATATYPE lidt,
        PCVOID *ppcvData)
{
    BOOL bResult;

    DebugEntry(GetLinkInfoData);

#ifdef EXPV
    /* Verify parameters. */

    if (
            IS_VALID_STRUCT_PTR(pcli, CLINKINFO) &&
            EVAL(IsValidLINKINFODATATYPE(lidt)) &&
            IS_VALID_WRITE_PTR(ppcvData, PCVOID))
#endif
    {
        bResult = GetILinkInfoData((PCILINKINFO)pcli, lidt, ppcvData);
    }
#ifdef EXPV
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bResult = FALSE;
    }
#endif

    ASSERT(!bResult || 
            ((NULL == *ppcvData) || IS_VALID_READ_BUFFER_PTR(*ppcvData, LinkInfoData, 1)));

    DebugExitBOOL(GetLinkInfoData, bResult);

    return(bResult);
}


/******************************************************************************

  @doc LINKINFOAPI

  @func BOOL | IsValidLinkInfo | Determines whether or not a LinkInfo structure
  is valid.

  @parm PCLINKINFO | pcli | A pointer to the LinkInfo structure to be checked for
  validity.

  @rdesc If the function completed successfully, TRUE is returned.  Otherwise,
  FALSE is returned.

 ******************************************************************************/

//
//  IS_ALIGNMENT_MACHINE_ALIGNED_DWORD_CNT validates alignment only on
//  alignment machines.  For machines that are not alignment-sensitive,
//  it declares that all values are aligned.
//

#ifdef ALIGNMENT_MACHINE
#define IS_ALIGNMENT_MACHINE_ALIGNED_DWORD_CNT(x)   IS_ALIGNED_DWORD_CNT(x)
#else
#define IS_ALIGNMENT_MACHINE_ALIGNED_DWORD_CNT(x)   TRUE
#endif

LINKINFOAPI BOOL WINAPI IsValidLinkInfo(PCLINKINFO pcli)
{
    BOOL bResult;
    PCILINKINFO pcili = (PCILINKINFO)pcli;

    DebugEntry(IsValidLinkInfo);

    // First make sure it's readable and not ridiculously small
    if ((pcli == NULL) ||  // read the ucbSize
            pcli->ucbSize < pcili->ucbHeaderSize ||  // header fits in buffer
            pcili->ucbHeaderSize < sizeof(ILINKINFOA)// smallest supported header
       )
    {
        bResult = FALSE;
        goto exit;
    }

    // Make sure no field points outside our buffer
    if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
    {
        if (pcili->ucbVolumeIDOffset         >= pcli->ucbSize ||
                pcili->ucbLocalBasePathOffset    >= pcli->ucbSize ||
                pcili->ucbCommonPathSuffixOffset >= pcli->ucbSize ||
                !IS_ALIGNMENT_MACHINE_ALIGNED_DWORD_CNT(pcili->ucbVolumeIDOffset))
        {
            bResult = FALSE;
            goto exit;
        }
    }

    // The ucbCNRLinkOffset field is valid only sometimes
    if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
    {
        if (pcili->ucbCNRLinkOffset >= pcli->ucbSize ||
                !IS_ALIGNMENT_MACHINE_ALIGNED_DWORD_CNT(pcili->ucbCNRLinkOffset))
        {
            bResult = FALSE;
            goto exit;
        }
    }

    // The UNICODE version has some more fields than the ANSI version.
    // Those UNICODE fields must be WORD-aligned.

    if (pcili->ucbHeaderSize >= sizeof(ILINKINFOW))
    {
        if (pcili->ucbLocalBasePathOffsetW    >= pcli->ucbSize ||
                pcili->ucbCommonPathSuffixOffsetW >= pcli->ucbSize ||
                !IS_ALIGNED_WORD_CNT(pcili->ucbLocalBasePathOffsetW) ||
                !IS_ALIGNED_WORD_CNT(pcili->ucbCommonPathSuffixOffsetW))
        {
            bResult = FALSE;
            goto exit;
        }
    }

    // Survived the validation ordeal!
    bResult = TRUE;

exit:;
     DebugExitBOOL(IsValidLinkInfo, bResult);

     return(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\dllinit.c ===
/*
 * dllinit.c - Initialization and termination routines.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "..\core\init.h"
#include "server.h"
#include "cnrlink.h"


/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL MyAttachProcess(HMODULE);
PRIVATE_CODE BOOL MyDetachProcess(HMODULE);


/* Global Variables
 *******************/

/* serialization control structure */
/* note no thread attach or thread detach procs here so we can optimize... */

PUBLIC_DATA CSERIALCONTROL g_cserctrl =
{
   MyAttachProcess,
   MyDetachProcess,
   NULL,
   NULL
};

#ifdef DEBUG

/* .ini file name and section used by inifile.c!SetIniSwitches() */

PUBLIC_DATA LPCTSTR GpcszIniFile = TEXT("rover.ini");
PUBLIC_DATA LPCTSTR GpcszIniSection = TEXT("LinkInfoDebugOptions");

/* module name used by debug.c!SpewOut() */

PUBLIC_DATA LPCTSTR GpcszSpewModule = TEXT("LinkInfo");

#endif


/***************************** Private Functions *****************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** MyAttachProcess()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL MyAttachProcess(HMODULE hmod)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hmod, MODULE));

   DebugEntry(MyAttachProcess);

   // Don't care about thread attach/detach.
   DisableThreadLibraryCalls(hmod);
   bResult = ProcessInitServerModule();

   DebugExitBOOL(MyAttachProcess, bResult);

   return(bResult);
}


/*
** MyDetachProcess()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL MyDetachProcess(HMODULE hmod)
{
   BOOL bResult = TRUE;

   ASSERT(IS_VALID_HANDLE(hmod, MODULE));

   DebugEntry(MyDetachProcess);

   ProcessExitServerModule();

   DebugExitBOOL(MyDetachProcess, bResult);

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/****************************** Public Functions *****************************/


#ifdef DEBUG

/*
** SetAllIniSwitches()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SetAllIniSwitches(void)
{
   BOOL bResult;

   bResult = SetDebugModuleIniSwitches();
   bResult |= SetSerialModuleIniSwitches();
   bResult |= SetMemoryManagerModuleIniSwitches();

   return(bResult);
}

#endif


/*
** InitializeDLL()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InitializeDLL(void)
{
   BOOL bResult;

   DebugEntry(InitializeDLL);

   bResult = InitMemoryManagerModule();

#ifdef DEBUG

   if (bResult)
   {
       SpewHeapSummary(0);
   }

#endif

   DebugExitBOOL(InitializeDLL, bResult);

   return(bResult);
}


/*
** TerminateDLL()
**
** 
**
** Arguments:
**
** Returns:       TRUE
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL TerminateDLL(void)
{
   BOOL bResult;

   DebugEntry(TerminateDLL);

   ExitMemoryManagerModule();

   bResult = TRUE;

   DebugExitBOOL(TerminateDLL, bResult);

   return(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\nothunk.c ===
#include "project.h"

// REARCHITECT - BobDay - This function needs to be added to KERNEL32. NOPE,
// according to markl we only need this because the critical section
// was located in shared memory.  Possible solution here might be to create
// a named event or mutex and synchronize via it. Another possible solution
// might be to move each of the objects for which there is a critical section
// out of the shared memory segment and maintain a per-process data structure.
VOID WINAPI NoThunkReinitializeCriticalSection(
        LPCRITICAL_SECTION lpCriticalSection
        ) {
    InitializeCriticalSectionAndSpinCount( lpCriticalSection, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\server.c ===
/*
 * server.c - Server vtable functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "server.h"


/* Module Variables
 *******************/

/*
 * Assume that we don't need to serialize access to MhinstServerDLL and Msvt
 * since they are only modified during first PROCESS_ATTACH.  Access to shared
 * data is protected during AttachProcess().
 */

PRIVATE_DATA HINSTANCE MhinstServerDLL = NULL;

PRIVATE_DATA SERVERVTABLE Msvt =
{
   NULL,
   NULL
};


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCSERVERVTABLE(PCSERVERVTABLE);

#endif


#ifdef DEBUG

/*
** IsValidPCSERVERVTABLE()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCSERVERVTABLE(PCSERVERVTABLE pcsvt)
{
   return(IS_VALID_READ_PTR(pcsvt, CSERVERVTABLE) &&
          IS_VALID_CODE_PTR(pcsvt->GetNetResourceFromLocalPath, PFNGETNETRESOURCEFROMLOCALPATH) &&
          IS_VALID_CODE_PTR(pcsvt->GetLocalPathFromNetResource, PFNGETLOCALPATHFROMNETRESOURCE));
}

#endif


/****************************** Public Functions *****************************/


/*
** ProcessInitServerModule()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL ProcessInitServerModule(void)
{
   TCHAR rgchDLLPath[MAX_PATH_LEN];
   LONG lcb;

   /* Load server DLL. */

   lcb = SIZEOF(rgchDLLPath);

   if (RegQueryValue(HKEY_CLASSES_ROOT, TEXT("Network\\SharingHandler"), rgchDLLPath,
                     &lcb) == ERROR_SUCCESS)
   {
      if (rgchDLLPath[0])
      {
         HINSTANCE hinst;

         hinst = LoadLibrary(rgchDLLPath);

         if (hinst)
         {
            PFNGETNETRESOURCEFROMLOCALPATH GetNetResourceFromLocalPath;
            PFNGETLOCALPATHFROMNETRESOURCE GetLocalPathFromNetResource;

            GetNetResourceFromLocalPath = (PFNGETNETRESOURCEFROMLOCALPATH)
					GetProcAddress(hinst, "GetNetResourceFromLocalPathW");
            GetLocalPathFromNetResource = (PFNGETLOCALPATHFROMNETRESOURCE)
					GetProcAddress(hinst, "GetLocalPathFromNetResourceW");

            if (GetNetResourceFromLocalPath && GetLocalPathFromNetResource)
            {
               ASSERT(AccessIsExclusive());

               Msvt.GetNetResourceFromLocalPath = GetNetResourceFromLocalPath;
               Msvt.GetLocalPathFromNetResource = GetLocalPathFromNetResource;

               MhinstServerDLL = hinst;

               ASSERT(IS_VALID_STRUCT_PTR((PCSERVERVTABLE)&Msvt, CSERVERVTABLE));
               ASSERT(IS_VALID_HANDLE(MhinstServerDLL, INSTANCE));

               TRACE_OUT((TEXT("ProcessInitServerModule(): Loaded sharing handler DLL %s."),
                          rgchDLLPath));
            }
         }
      }
   }

   return(TRUE);
}


/*
** ProcessExitServerModule()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ProcessExitServerModule(void)
{
   /* Unload server DLL. */

   if (MhinstServerDLL)
   {
      ASSERT(IS_VALID_HANDLE(MhinstServerDLL, INSTANCE));
      EVAL(FreeLibrary(MhinstServerDLL));
      MhinstServerDLL = NULL;

      TRACE_OUT((TEXT("ProcessExitServerModule(): Unloaded sharing handler DLL.")));
   }

   return;
}


/*
** GetServerVTable()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetServerVTable(PCSERVERVTABLE *ppcsvt)
{
   BOOL bResult;

   ASSERT(IS_VALID_WRITE_PTR(ppcsvt, PCSERVERVTABLE));

   if (MhinstServerDLL)
   {
      *ppcsvt = &Msvt;

      bResult = TRUE;
   }
   else
      bResult = FALSE;

   ASSERT(! bResult || IS_VALID_STRUCT_PTR(*ppcsvt, CSERVERVTABLE));

   return(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\server.h ===
/*
 * server.h - Server vtable functions module description.
 */


/* Types
 ********/

#include <msshrui.h>

typedef struct _servervtable
{
   PFNGETNETRESOURCEFROMLOCALPATH GetNetResourceFromLocalPath;
   PFNGETLOCALPATHFROMNETRESOURCE GetLocalPathFromNetResource;
}
SERVERVTABLE;
DECLARE_STANDARD_TYPES(SERVERVTABLE);


/* Prototypes
 *************/

/* server.c */

extern BOOL ProcessInitServerModule(void);
extern void ProcessExitServerModule(void);
extern BOOL GetServerVTable(PCSERVERVTABLE *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\project.h ===
/*
 * project.h - Project header file for LinkInfo DLL.
 */


/* System Headers
 *****************/

#define BUILDDLL              /* for windows.h */
#define STRICT                /* for windows.h (robustedness) */

#if DBG
#define DEBUG 1
#endif

/*
 * RAIDRAID: (16282) Get rid of warnings about unused Int64 inline
 * functions in winnt.h for all modules.  Emasculate other warnings only for
 * windows.h.
 */

#pragma warning(disable:4514) /* "unreferenced inline function" warning */

#pragma warning(disable:4001) /* "single line comment" warning */
#pragma warning(disable:4115) /* "named type definition in parentheses" warning */
#pragma warning(disable:4201) /* "nameless struct/union" warning */
#pragma warning(disable:4209) /* "benign typedef redefinition" warning */
#pragma warning(disable:4214) /* "bit field types other than int" warning */
#pragma warning(disable:4218) /* "must specify at least a storage class or type" warning */

#include <windows.h>

#pragma warning(default:4218) /* "must specify at least a storage class or type" warning */
#pragma warning(default:4214) /* "bit field types other than int" warning */
#pragma warning(default:4209) /* "benign typedef redefinition" warning */
#pragma warning(default:4201) /* "nameless struct/union" warning */
#pragma warning(default:4115) /* "named type definition in parentheses" warning */
#pragma warning(default:4001) /* "single line comment" warning */

#define ReinitializeCriticalSection NoThunkReinitializeCriticalSection
VOID WINAPI NoThunkReinitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );

#define ALIGN_CNT(x,y)    (((x)+(y)-1) & ~((y)-1))

#define ALIGN_PTR(x,y)      ALIGN_CNT((DWORD_PTR)(x),(y))
#define ALIGN_DWORD_CNT(x)  ALIGN_CNT((x),SIZEOF(DWORD))
#define ALIGN_DWORD_PTR(x)  ALIGN_PTR((x),SIZEOF(DWORD))
#define ALIGN_WORD_CNT(x)   ALIGN_CNT((x),SIZEOF(WORD))
#define ALIGN_WORD_PTR(x)   ALIGN_PTR((x),SIZEOF(WORD))

#define IS_ALIGNED_CNT(x,y)  (((x) & ((y)-1)) == 0)

#define IS_ALIGNED_DWORD_CNT(x) IS_ALIGNED_CNT(x, sizeof(DWORD))
#define IS_ALIGNED_WORD_CNT(x) IS_ALIGNED_CNT(x, sizeof(WORD))

#include <limits.h>

#define _LINKINFO_            /* for linkinfo.h */
#include <linkinfo.h>


/* Constants
 ************/

#ifdef DEBUG

#define INDENT_STRING         "    "

#endif


/* Project Headers
 ******************/

/* The order of the following include files is significant. */

#include "..\core\stock.h"
#include "..\core\serial.h"

#ifdef DEBUG

#include "..\core\inifile.h"
#include "..\core\resstr.h"

#endif

#include "..\core\debug.h"
#include "..\core\valid.h"
#include "..\core\memmgr.h"
#include "..\core\comc.h"

#include "util.h"
#include "canon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\util.c ===
/*
 * util.c - Miscellaneous utility functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/****************************** Public Functions *****************************/


/*
 ** IsLocalDrivePath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsLocalDrivePath(LPCTSTR pcszFullPath)
{
    BOOL bResult;

    ASSERT(IsFullPath(pcszFullPath));

    bResult = IsDrivePath(pcszFullPath);

    if (bResult)
    {
        TCHAR rgchRootPath[DRIVE_ROOT_PATH_LEN];

        ASSERT(IsCharAlpha(*pcszFullPath));

        lstrcpyn(rgchRootPath, TEXT("A:\\"), ARRAYSIZE(rgchRootPath));
        rgchRootPath[0] = *pcszFullPath;

        bResult = (GetDriveType(rgchRootPath) != DRIVE_REMOTE);
    }

    return(bResult);
}


/*
 ** IsUNCPath()
 **
 ** Determines whether or not a path is in "\\server\share" UNC form.
 **
 ** Arguments:     pcszPath - path to examine
 **
 ** Returns:       TRUE if path is a UNC path.  FALSE if not.
 **
 ** Side Effects:  none
 **
 ** A UNC path is a string of the form two slashes, one or more non-slashes, one
 ** slash, one or more non-slashes
 */
PUBLIC_CODE BOOL IsUNCPath(LPCTSTR pcszFullPath)
{
    BOOL bResult = FALSE;

    ASSERT(IsFullPath(pcszFullPath));

    if (lstrlen(pcszFullPath) >= 5 &&
            IS_SLASH(pcszFullPath[0]) &&
            IS_SLASH(pcszFullPath[1]) &&
            ! IS_SLASH(pcszFullPath[2]))
    {
        LPCTSTR pcsz;

        for (pcsz = &(pcszFullPath[2]); *pcsz; pcsz = CharNext(pcsz))
        {
            if (IS_SLASH(*pcsz))
            {
                bResult = (*(pcsz + 1) &&
                        ! IS_SLASH(*(pcsz + 1)));

                break;
            }
        }
    }

    return(bResult);
}


/*
 ** DeleteLastDrivePathElement()
 **
 ** Deletes the last path element from a drive path.
 **
 ** Arguments:     pszDrivePath - drive path whose last element is to be deleted
 **
 ** Returns:       TRUE if path element deleted.  FALSE if not, i.e., given path
 **                is root path.
 **
 ** Side Effects:  none
 **
 ** Examples:
 **
 **    input path                    output path
 **    ----------                    -----------
 **    c:\                           c:\
 **    c:\foo                        c:\
 **    c:\foo\bar                    c:\foo
 **    c:\foo\bar\                   c:\foo\bar
 **
 ** N.b., this function does not perform any validity tests on the format of the
 ** input path string.
 */
PUBLIC_CODE BOOL DeleteLastDrivePathElement(LPTSTR pszDrivePath)
{
    BOOL bHackIt;
    LPTSTR pszEndOfDriveSpec;

    ASSERT(IsDrivePath(pszDrivePath));

    pszEndOfDriveSpec = pszDrivePath + 3;

    /* Is this a a root path? */

    bHackIt = *pszEndOfDriveSpec;

    if (bHackIt)
        DeleteLastPathElement(pszEndOfDriveSpec);

    ASSERT(IsDrivePath(pszDrivePath));

    return(bHackIt);
}


#if defined(DEBUG) || defined(VSTF)

/*
 ** IsContained()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsContained(PCVOID pcvJar, UINT ucbJarLen, PCVOID pcvJelly,
        UINT ucbJellyLen)
{
    BOOL bResult = FALSE;

    ASSERT(IS_VALID_READ_BUFFER_PTR(pcvJar, CVOID, ucbJarLen));
    ASSERT(IS_VALID_READ_BUFFER_PTR(pcvJelly, CVOID, ucbJellyLen));

    if (EVAL(pcvJelly >= pcvJar))
    {
        UINT ucbJellyOffset;

        ucbJellyOffset = (UINT)((PCBYTE)pcvJelly - (PCBYTE)pcvJar);

        if (EVAL(ucbJellyOffset < ucbJarLen) &&
                EVAL(ucbJellyLen < ucbJarLen - ucbJellyOffset))
            bResult = TRUE;
    }

    return(bResult);
}


/*
 ** IsValidCNRName()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidCNRName(LPCTSTR pcszCNRName)
{
    BOOL bResult;

    /* Any valid string < MAX_PATH_LEN bytes long is a valid CNR name. */

    bResult = (IS_VALID_STRING_PTR(pcszCNRName, CSTR) &&
            EVAL(lstrlen(pcszCNRName) < MAX_PATH_LEN));

#ifdef DEBUG

    /*
     * RIP if a CNR name ends in a slash 
     */

    if (bResult)
    {
        if (IsUNCPath(pcszCNRName))
        {
            ASSERT(! IS_SLASH(*(CharPrev(pcszCNRName, pcszCNRName + lstrlen(pcszCNRName)))));
        }
    }

#endif

    return(bResult);
}

#endif


#ifdef DEBUG

/*
 ** IsDriveRootPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsDriveRootPath(LPCTSTR pcszPath)
{
    return(IsDrivePath(pcszPath) &&
            lstrlen(pcszPath) == 3);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\util.h ===
/*
 * util.h - Miscellaneous utility functions module description.
 */


/* Prototypes
 *************/

/* util.h */

extern BOOL IsLocalDrivePath(LPCTSTR);
extern BOOL IsUNCPath(LPCTSTR);
extern BOOL DeleteLastDrivePathElement(LPTSTR);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsContained(PCVOID, UINT, PCVOID, UINT);
extern BOOL IsValidCNRName(LPCTSTR);

#endif

#ifdef DEBUG

extern BOOL IsDriveRootPath(LPCTSTR);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\volumeid.c ===
/*
 * volumeid.c - Volume ID ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "volumeid.h"


/* Constants
 ************/

/* local root path constants */

#define MAX_LOCAL_DRIVES            (TEXT('z') - TEXT('a') + 1)


/* Macros
 *********/

/* macros for accessing IVOLUMEID data */

#define IVOLID_Volume_Label_PtrA(pivolid) \
((LPSTR)(((PBYTE)(pivolid)) + (pivolid)->ucbVolumeLabelOffset))

#ifdef UNICODE
#define IVOLID_Volume_Label_PtrW(pivolid) \
((LPTSTR)(((PBYTE)(pivolid)) + (pivolid)->ucbVolumeLabelOffsetW))
#endif

#ifdef UNICODE
#define IVOLID_Volume_Label_Ptr(pivolid)   IVOLID_Volume_Label_PtrW(pivolid)
#else
#define IVOLID_Volume_Label_Ptr(pivolid)   IVOLID_Volume_Label_PtrA(pivolid)
#endif

    /* Types
     ********/

    /*
       @doc INTERNAL

       @struct IVOLUMEID | Internal definition of relocatable volume ID structure.
       An <t ILINKINFO> structure may contain an IVOLUMEID structure.  An IVOLUMEID
       structure consists of a header described as below, followed by
       variable-length data.
     */

    typedef struct _ivolumeidA
{
    /*
       @field UINT | ucbSize | Length of IVOLUMEID structure in bytes, including
       ucbSize field.
     */

    UINT ucbSize;

    /*
       @field UINT | uDriveType | The volume's host drive type, as returned by
       GetDriveType()
     */

    UINT uDriveType;

    /* @field DWORD | dwSerialNumber | The volume's serial number. */

    DWORD dwSerialNumber;

    /*
       @field UINT | ucbVolumeLabelOffset | Offset in bytes of volume label
       string from base of structure.
     */

    UINT ucbVolumeLabelOffset;
}
IVOLUMEIDA;
DECLARE_STANDARD_TYPES(IVOLUMEIDA);

#ifdef UNICODE
typedef struct _ivolumeidW
{
    /*
       @field UINT | ucbSize | Length of IVOLUMEID structure in bytes, including
       ucbSize field.
     */

    UINT ucbSize;

    /*
       @field UINT | uDriveType | The volume's host drive type, as returned by
       GetDriveType()
     */

    UINT uDriveType;

    /* @field DWORD | dwSerialNumber | The volume's serial number. */

    DWORD dwSerialNumber;

    /*
       @field UINT | ucbVolumeLabelOffset | Offset in bytes of volume label
       string from base of structure.
     */

    UINT ucbVolumeLabelOffset;

    /*
       This member is for storing the unicode version of the string
     */

    UINT ucbVolumeLabelOffsetW;
}
IVOLUMEIDW;
DECLARE_STANDARD_TYPES(IVOLUMEIDW);
#endif

#ifdef UNICODE
#define IVOLUMEID   IVOLUMEIDW
#define PIVOLUMEID  PIVOLUMEIDW
#define CIVOLUMEID  CIVOLUMEIDW
#define PCIVOLUMEID PCIVOLUMEIDW
#else
#define IVOLUMEID   IVOLUMEIDA
#define PIVOLUMEID  PIVOLUMEIDA
#define CIVOLUMEID  CIVOLUMEIDA
#define PCIVOLUMEID PCIVOLUMEIDA
#endif

/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL UnifyIVolumeIDInfo(UINT, DWORD, LPCTSTR, PIVOLUMEID *, PUINT);
PRIVATE_CODE BOOL IsPathOnVolume(LPCTSTR, PCIVOLUMEID, PBOOL);
PRIVATE_CODE COMPARISONRESULT CompareUINTs(UINT, UINT);

#if defined(DEBUG) || defined (VSTF)

PRIVATE_CODE BOOL IsValidPCIVOLUMEID(PCIVOLUMEID);

#endif


/*
 ** UnifyIVolumeIDInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL UnifyIVolumeIDInfo(UINT uDriveType, DWORD dwSerialNumber,
        LPCTSTR pcszVolumeLabel, PIVOLUMEID *ppivolid,
        PUINT pucbIVolumeIDLen)
{
    BOOL bResult;
#ifdef UNICODE
    CHAR szAnsiVolumeLabel[MAX_PATH];
    BOOL bUnicode;
    UINT cchVolumeLabel;
    UINT cchChars;
#endif

    /* dwSerialNumber may be any value. */

    ASSERT(IsValidDriveType(uDriveType));
    ASSERT(IS_VALID_STRING_PTR(pcszVolumeLabel, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(ppivolid, PIVOLUMEID));
    ASSERT(IS_VALID_WRITE_PTR(pucbIVolumeIDLen, UINT));

    /* Assume we won't overflow *pucbIVolumeIDLen here. */

#ifdef UNICODE
    /* Determine whether we need a full fledged UNICODE volume ID */
    bUnicode = FALSE;
    cchVolumeLabel = WideCharToMultiByte(CP_ACP, 0, pcszVolumeLabel, -1,
            szAnsiVolumeLabel, ARRAYSIZE(szAnsiVolumeLabel), 0, 0);
    if ( cchVolumeLabel == 0 )
    {
        bUnicode = TRUE;
    }
    else
    {
        WCHAR szWideVolumeLabel[MAX_PATH];

        cchChars = MultiByteToWideChar(CP_ACP, 0, szAnsiVolumeLabel, -1,
                szWideVolumeLabel, ARRAYSIZE(szWideVolumeLabel));
        if ( cchChars == 0 || lstrcmp(pcszVolumeLabel,szWideVolumeLabel) != 0 )
        {
            bUnicode = TRUE;
        }
    }

    if ( bUnicode )
    {
        UINT ucbDataSize;

        /* (+ 1) for null terminator. */

        ucbDataSize = SIZEOF(IVOLUMEIDW) + cchVolumeLabel;
        ucbDataSize = ALIGN_WORD_CNT(ucbDataSize);
        ucbDataSize += (lstrlen(pcszVolumeLabel) + 1) * SIZEOF(TCHAR);
        *pucbIVolumeIDLen = ucbDataSize;
    }
    else
    {
        /* (+ 1) for null terminator. */

        *pucbIVolumeIDLen = SIZEOF(IVOLUMEIDA) +
            cchVolumeLabel;
    }
#else
    /* (+ 1) for null terminator. */

    *pucbIVolumeIDLen = SIZEOF(**ppivolid) +
        (lstrlen(pcszVolumeLabel) + 1) * SIZEOF(TCHAR);
#endif

    bResult = AllocateMemory(*pucbIVolumeIDLen, ppivolid);

    if (bResult)
    {
        (*ppivolid)->ucbSize = *pucbIVolumeIDLen;
        (*ppivolid)->uDriveType = uDriveType;
        (*ppivolid)->dwSerialNumber = dwSerialNumber;

        /* Append volume label. */

#ifdef UNICODE
        if ( bUnicode )
        {
            (*ppivolid)->ucbVolumeLabelOffset = SIZEOF(IVOLUMEIDW);
            (*ppivolid)->ucbVolumeLabelOffsetW = ALIGN_WORD_CNT(
                                                                SIZEOF(IVOLUMEIDW)+cchVolumeLabel);

            lstrcpy(IVOLID_Volume_Label_PtrW(*ppivolid), pcszVolumeLabel);
        }
        else
        {
            (*ppivolid)->ucbVolumeLabelOffset = SIZEOF(IVOLUMEIDA);
        }
        lstrcpyA(IVOLID_Volume_Label_PtrA(*ppivolid), szAnsiVolumeLabel);
#else

        lstrcpy(IVOLID_Volume_Label_Ptr(*ppivolid), pcszVolumeLabel);
#endif
    }

    ASSERT(! bResult ||
            (IS_VALID_STRUCT_PTR(*ppivolid, CIVOLUMEID) &&
             EVAL(*pucbIVolumeIDLen == GetVolumeIDLen((PCVOLUMEID)*ppivolid))));

    return(bResult);
}


/*
 ** IsPathOnVolume()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsPathOnVolume(LPCTSTR pcszDrivePath, PCIVOLUMEID pcivolid,
        PBOOL pbOnVolume)
{
    BOOL bResult;
    PVOLUMEID pvolid;
    UINT ucbVolumeIDLen;

    ASSERT(IsDrivePath(pcszDrivePath));
    ASSERT(IS_VALID_STRUCT_PTR(pcivolid, CIVOLUMEID));
    ASSERT(IS_VALID_WRITE_PTR(pcivolid, CIVOLUMEID));

    bResult = CreateVolumeID(pcszDrivePath, &pvolid, &ucbVolumeIDLen);

    if (bResult)
    {
        *pbOnVolume = (CompareVolumeIDs(pvolid, (PCVOLUMEID)pcivolid)
                == CR_EQUAL);

        DestroyVolumeID(pvolid);
    }

    return(bResult);
}


/*
 ** CompareUINTs()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE COMPARISONRESULT CompareUINTs(UINT uFirst, UINT uSecond)
{
    COMPARISONRESULT cr;

    /* Any UINTs are valid input. */

    if (uFirst < uSecond)
        cr = CR_FIRST_SMALLER;
    else if (uFirst > uSecond)
        cr = CR_FIRST_LARGER;
    else
        cr = CR_EQUAL;

    ASSERT(IsValidCOMPARISONRESULT(cr));

    return(cr);
}


#if defined(DEBUG) || defined (VSTF)

/*
 ** IsValidPCIVOLUMEID()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCIVOLUMEID(PCIVOLUMEID pcivolid)
{
    /* dwSerialNumber may be any value. */

    return(IS_VALID_READ_PTR(pcivolid, CIVOLUMEID) &&
            IS_VALID_READ_BUFFER_PTR(pcivolid, CIVOLUMEID, pcivolid->ucbSize) &&
            EVAL(IsValidDriveType(pcivolid->uDriveType)) &&
            EVAL(IsContained(pcivolid, pcivolid->ucbSize,
                    IVOLID_Volume_Label_Ptr(pcivolid),
                    lstrlen(IVOLID_Volume_Label_Ptr(pcivolid))*SIZEOF(TCHAR))));
}

#endif


/****************************** Public Functions *****************************/


/*
 ** CreateVolumeID()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL CreateVolumeID(LPCTSTR pcszDrivePath, PVOLUMEID *ppvolid,
        PUINT pucbVolumeIDLen)
{
    BOOL bResult;
    /* "C:\" + null terminator. */
    TCHAR rgchRootPath[3 + 1];
    TCHAR rgchVolumeLabel[MAX_PATH_LEN];
    DWORD dwSerialNumber;

    ASSERT(IsDrivePath(pcszDrivePath));
    ASSERT(IS_VALID_WRITE_PTR(ppvolid, PVOLUMEID));
    ASSERT(IS_VALID_WRITE_PTR(pucbVolumeIDLen, UINT));

    /* Get volume's label and serial number. */

    MyLStrCpyN(rgchRootPath, pcszDrivePath, ARRAYSIZE(rgchRootPath));

    bResult = GetVolumeInformation(rgchRootPath, rgchVolumeLabel,
            ARRAYSIZE(rgchVolumeLabel), &dwSerialNumber,
            NULL, NULL, NULL, 0);

    if (bResult)
        /* Wrap them up. */
        bResult = UnifyIVolumeIDInfo(GetDriveType(rgchRootPath), dwSerialNumber,
                rgchVolumeLabel, (PIVOLUMEID *)ppvolid,
                pucbVolumeIDLen);

    ASSERT(! bResult ||
            IS_VALID_STRUCT_PTR((PCIVOLUMEID)*ppvolid, CIVOLUMEID));

    return(bResult);
}


/*
 ** DestroyVolumeID()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DestroyVolumeID(PVOLUMEID pvolid)
{
    ASSERT(IS_VALID_STRUCT_PTR(pvolid, CVOLUMEID));

    FreeMemory(pvolid);

    return;
}


/*
 ** CompareVolumeIDs()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** Volume ID data is compared in the following order:
 **    1) drive type
 **    2) volume serial number
 **
 ** N.b., volume labels are ignored.
 */
PUBLIC_CODE COMPARISONRESULT CompareVolumeIDs(PCVOLUMEID pcvolidFirst,
        PCVOLUMEID pcvolidSecond)
{
    COMPARISONRESULT cr;

    ASSERT(IS_VALID_STRUCT_PTR(pcvolidFirst, CVOLUMEID));
    ASSERT(IS_VALID_STRUCT_PTR(pcvolidSecond, CVOLUMEID));

    /* Compare VOLUMEIDs piece by piece. */

    cr = CompareUINTs(((PCIVOLUMEID)pcvolidFirst)->uDriveType,
            ((PCIVOLUMEID)pcvolidSecond)->uDriveType);

    if (cr == CR_EQUAL)
        cr = CompareDWORDs(((PCIVOLUMEID)pcvolidFirst)->dwSerialNumber,
                ((PCIVOLUMEID)pcvolidSecond)->dwSerialNumber);

    return(cr);
}


/*
 ** SearchForLocalPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL SearchForLocalPath(PCVOLUMEID pcvolid, LPCTSTR pcszFullPath,
        DWORD dwInFlags, LPTSTR pszFoundPathBuf, int cchMax)
{
    BOOL bResult;
    BOOL bAvailable;
#if defined(DEBUG) && defined(UNICODE)
    WCHAR szWideVolumeLabel[MAX_PATH];
    LPWSTR pszWideVolumeLabel;
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));
    ASSERT(IsFullPath(pcszFullPath));
    ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_SFLP_IFLAGS));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszFoundPathBuf, STR, cchMax));

#if defined(DEBUG) && defined(UNICODE)
    if (((PCIVOLUMEID)pcvolid)->ucbVolumeLabelOffset == SIZEOF(IVOLUMEIDA))
    {
        pszWideVolumeLabel = szWideVolumeLabel;
        MultiByteToWideChar(CP_ACP, 0, IVOLID_Volume_Label_PtrA((PCIVOLUMEID)pcvolid), -1,
                szWideVolumeLabel, ARRAYSIZE(szWideVolumeLabel));
    }
    else
    {
        pszWideVolumeLabel = IVOLID_Volume_Label_Ptr((PCIVOLUMEID)pcvolid);
    }
#endif

    /* Were we given a local path to check first? */

    if (IsLocalDrivePath(pcszFullPath))
        /* Yes.  Check it. */
        bResult = IsPathOnVolume(pcszFullPath, (PCIVOLUMEID)pcvolid,
                &bAvailable);
    else
    {
        /* No. */

        bAvailable = FALSE;
        bResult = TRUE;
    }

    if (bResult)
    {
        /* Did we find the volume? */

        if (bAvailable)
        {
            /* Yes. */

            ASSERT(lstrlen(pcszFullPath) < MAX_PATH_LEN);
            lstrcpyn(pszFoundPathBuf, pcszFullPath, cchMax);
        }
        else
        {
            /*
             * No.  Should we search other matching local devices for the volume?
             */

            if (IS_FLAG_SET(dwInFlags, SFLP_IFL_LOCAL_SEARCH))
            {
                TCHAR chOriginalDrive;
                UINT uDrive;
                DWORD dwLogicalDrives;

                /* Yes. */

#ifdef UNICODE
                WARNING_OUT((TEXT("SearchForLocalPath(): Searching for local volume \"%s\", as requested."),
                            pszWideVolumeLabel));
#else
                WARNING_OUT((TEXT("SearchForLocalPath(): Searching for local volume \"%s\", as requested."),
                            IVOLID_Volume_Label_Ptr((PCIVOLUMEID)pcvolid)));
#endif

                ASSERT(IsCharAlpha(*pcszFullPath));
                chOriginalDrive = *pcszFullPath;

                ASSERT(lstrlen(pcszFullPath) < MAX_PATH_LEN);
                lstrcpyn(pszFoundPathBuf, pcszFullPath, cchMax);

                /* Get bit mask of local logical drives. */

                dwLogicalDrives = GetLogicalDrives();

                for (uDrive = 0; uDrive < MAX_LOCAL_DRIVES; uDrive++)
                {
                    if (IS_FLAG_SET(dwLogicalDrives, (1 << uDrive)))
                    {
                        TCHAR chDrive;

                        chDrive = (TCHAR)(TEXT('A') + uDrive);
                        ASSERT(IsCharAlpha(chDrive));

                        if (chDrive != chOriginalDrive)
                        {
                            TCHAR rgchLocalRootPath[DRIVE_ROOT_PATH_LEN];

                            lstrcpyn(rgchLocalRootPath, TEXT("A:\\"), ARRAYSIZE(rgchLocalRootPath));
                            rgchLocalRootPath[0] = chDrive;

                            /*
                             * Does this drive's type match the target volume's drive
                             * type?
                             */

                            if (GetDriveType(rgchLocalRootPath) == ((PCIVOLUMEID)pcvolid)->uDriveType)
                            {
                                /* Yes.  Check the volume. */

                                TRACE_OUT((TEXT("SearchForLocalPath(): Checking local root path %s."),
                                            rgchLocalRootPath));

                                bResult = IsPathOnVolume(rgchLocalRootPath,
                                        (PCIVOLUMEID)pcvolid,
                                        &bAvailable);

                                if (bResult)
                                {
                                    if (bAvailable)
                                    {
                                        ASSERT(lstrlen(pcszFullPath) < MAX_PATH_LEN);
                                        lstrcpyn(pszFoundPathBuf, pcszFullPath, cchMax);

                                        ASSERT(IsCharAlpha(*pszFoundPathBuf));
                                        *pszFoundPathBuf = chDrive;

                                        TRACE_OUT((TEXT("SearchForLocalPath(): Found matching volume on local path %s."),
                                                    pszFoundPathBuf));

                                        break;
                                    }
                                }
                                else
                                    break;
                            }
                        }
                    }
                }
            }
            else
                /* No. */
#ifdef UNICODE
                WARNING_OUT((TEXT("SearchForLocalPath(): Not searching for local volume \"%s\", as requested."),
                            pszWideVolumeLabel));
#else
            WARNING_OUT((TEXT("SearchForLocalPath(): Not searching for local volume \"%s\", as requested."),
                        IVOLID_Volume_Label_Ptr((PCIVOLUMEID)pcvolid)));
#endif
        }
    }

    ASSERT(! bResult ||
            ! bAvailable ||
            IsLocalDrivePath(pszFoundPathBuf));

    return(bResult && bAvailable);
}


/*
 ** GetVolumeIDLen()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE UINT GetVolumeIDLen(PCVOLUMEID pcvolid)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));

    return(((PCIVOLUMEID)pcvolid)->ucbSize);
}


/*
 ** GetVolumeSerialNumber()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL GetVolumeSerialNumber(PCVOLUMEID pcvolid,
        PCDWORD *ppcdwSerialNumber)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));
    ASSERT(IS_VALID_WRITE_PTR(ppcdwSerialNumber, PCDWORD));

    *ppcdwSerialNumber = &(((PCIVOLUMEID)pcvolid)->dwSerialNumber);

    ASSERT(IS_VALID_READ_PTR(*ppcdwSerialNumber, CDWORD));

    return(TRUE);
}


/*
 ** GetVolumeDriveType()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL GetVolumeDriveType(PCVOLUMEID pcvolid, PCUINT *ppcuDriveType)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));
    ASSERT(IS_VALID_WRITE_PTR(ppcuDriveType, PCUINT));

    *ppcuDriveType = &(((PCIVOLUMEID)pcvolid)->uDriveType);

    ASSERT(IS_VALID_READ_PTR(*ppcuDriveType, CUINT));

    return(TRUE);
}


/*
 ** GetVolumeLabel()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL GetVolumeLabel(PCVOLUMEID pcvolid, LPCSTR *ppcszVolumeLabel)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));
    ASSERT(IS_VALID_WRITE_PTR(ppcszVolumeLabel, LPCTSTR));

    *ppcszVolumeLabel = IVOLID_Volume_Label_PtrA((PCIVOLUMEID)pcvolid);

    ASSERT(IS_VALID_STRING_PTRA(*ppcszVolumeLabel, CSTR));

    return(TRUE);
}

#ifdef UNICODE
/*
 ** GetVolumeLabelW()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL GetVolumeLabelW(PCVOLUMEID pcvolid, LPCWSTR *ppcszVolumeLabel)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));
    ASSERT(IS_VALID_WRITE_PTR(ppcszVolumeLabel, LPCTSTR));

    if (((PCIVOLUMEID)pcvolid)->ucbVolumeLabelOffset == SIZEOF(IVOLUMEIDW))
    {
        *ppcszVolumeLabel = IVOLID_Volume_Label_PtrW((PCIVOLUMEID)pcvolid);

        ASSERT(IS_VALID_STRING_PTR(*ppcszVolumeLabel, CSTR));
    }
    else
    {
        *ppcszVolumeLabel = NULL;
    }

    return(TRUE);
}
#endif

/*
 ** CompareDWORDs()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE COMPARISONRESULT CompareDWORDs(DWORD dwFirst, DWORD dwSecond)
{
    COMPARISONRESULT cr;

    /* Any DWORDs are valid input. */

    if (dwFirst < dwSecond)
        cr = CR_FIRST_SMALLER;
    else if (dwFirst > dwSecond)
        cr = CR_FIRST_LARGER;
    else
        cr = CR_EQUAL;

    ASSERT(IsValidCOMPARISONRESULT(cr));

    return(cr);
}


#if defined(DEBUG) || defined (VSTF)

/*
 ** IsValidPCVOLUMEID()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidPCVOLUMEID(PCVOLUMEID pcvolid)
{
    return(IS_VALID_STRUCT_PTR((PCIVOLUMEID)pcvolid, CIVOLUMEID));
}

#endif


#ifdef DEBUG

/*
 ** DumpVolumeID()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DumpVolumeID(PCVOLUMEID pcvolid)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));

    PLAIN_TRACE_OUT((TEXT("%s%s[local volume ID] ucbSize = %#x"),
                INDENT_STRING,
                INDENT_STRING,
                ((PCIVOLUMEID)pcvolid)->ucbSize));
    PLAIN_TRACE_OUT((TEXT("%s%s[local volume ID] drive type %u"),
                INDENT_STRING,
                INDENT_STRING,
                ((PCIVOLUMEID)pcvolid)->uDriveType));
    PLAIN_TRACE_OUT((TEXT("%s%s[local volume ID] serial number %#08lx"),
                INDENT_STRING,
                INDENT_STRING,
                ((PCIVOLUMEID)pcvolid)->dwSerialNumber));
    PLAIN_TRACE_OUT((TEXT("%s%s[local volume ID] label \"%s\""),
                INDENT_STRING,
                INDENT_STRING,
                IVOLID_Volume_Label_Ptr((PCIVOLUMEID)pcvolid)));

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\linkinfo\volumeid.h ===
/*
 * volumeid.h - Volume ID ADT module description.
 */


/* Types
 ********/

typedef struct _volumeid
{
   int nUnused;
}
VOLUMEID;
DECLARE_STANDARD_TYPES(VOLUMEID);

/* SearchForLocalPath() input flags */

typedef enum _searchforlocalpathinflags
{
   /* Search matching local devices for missing volume. */

   SFLP_IFL_LOCAL_SEARCH = 0x0001,

   ALL_SFLP_IFLAGS = SFLP_IFL_LOCAL_SEARCH
}
SEARCHFORLOCALPATHINFLAGS;


/* Prototypes
 *************/

/* volumeid.c */

extern BOOL CreateVolumeID(LPCTSTR, PVOLUMEID *, PUINT);
extern void DestroyVolumeID(PVOLUMEID);
extern COMPARISONRESULT CompareVolumeIDs(PCVOLUMEID, PCVOLUMEID);
extern BOOL SearchForLocalPath(PCVOLUMEID, LPCTSTR, DWORD, LPTSTR, int);
extern UINT GetVolumeIDLen(PCVOLUMEID);
extern BOOL GetVolumeSerialNumber(PCVOLUMEID, PCDWORD *);
extern BOOL GetVolumeDriveType(PCVOLUMEID, PCUINT *);
extern BOOL GetVolumeLabel(PCVOLUMEID, LPCSTR *);
#ifdef UNICODE
extern BOOL GetVolumeLabelW(PCVOLUMEID, LPCWSTR *);
#endif
extern COMPARISONRESULT CompareDWORDs(DWORD, DWORD);

#if defined(DEBUG) || defined (VSTF)

extern BOOL IsValidPCVOLUMEID(PCVOLUMEID);

#endif

#ifdef DEBUG

extern void DumpVolumeID(PCVOLUMEID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncapp\syncapp.h ===
#ifndef STRICT
#define STRICT
#endif

#define _INC_OLE
#include <windows.h>
#undef _INC_OLE

#include <shlobj.h>
#include <shlapip.h>
#include <shsemip.h>

#define IDI_DEFAULT     100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncapp\syncapp.c ===
#include "syncapp.h"

#ifndef WIN32
#include <w32sys.h>             // for IsPEFormat definition
#endif

static TCHAR const g_szAppName [] = TEXT("SYNCAPP") ;
static TCHAR const c_szDLL[]      = TEXT("SYNCUI.DLL");
#ifdef UNICODE
#    define BRIEFCASE_CREATE_ENTRY  "Briefcase_CreateW"
#else
#    define BRIEFCASE_CREATE_ENTRY  "Briefcase_Create"
#endif

static CHAR  const c_szFunction[] = BRIEFCASE_CREATE_ENTRY; // Lib entry point (never UNICODE)

static HINSTANCE hInst;
static HICON g_hIcon;

static HINSTANCE g_hModule;
static RUNDLLPROC g_lpfnCommand;
static HWND g_hwndStub;

static TCHAR s_szRunDLL32[] = TEXT("SYNCAPP.EXE ");

static BOOL   ParseCommand(void)
{
        // Load the library and get the procedure address
        // Note that we try to get a module handle first, so we don't need
        // to pass full file names around
        //

        g_hModule = GetModuleHandle(c_szDLL);
        if (g_hModule)
        {
                TCHAR szName[MAXPATHLEN];

                GetModuleFileName(g_hModule, szName, ARRAYSIZE(szName));
                LoadLibrary(szName);
        }
        else
        {
                g_hModule = LoadLibrary(c_szDLL);
                if ((UINT_PTR)g_hModule <= 32)
                {
                        return(FALSE);
                }
        }

        g_lpfnCommand = (RUNDLLPROC)GetProcAddress(g_hModule, c_szFunction);
        if (!g_lpfnCommand)
        {
                FreeLibrary(g_hModule);
                return(FALSE);
        }

        return(TRUE);
}


LRESULT CALLBACK WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
        switch(iMessage)
        {
        case WM_CREATE:
                g_hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_DEFAULT));
                break;

        case WM_DESTROY:
                break;

        default:
                return DefWindowProc(hWnd, iMessage, wParam, lParam) ;
                break;
        }

        return 0L;
}


static BOOL   InitStubWindow(HINSTANCE hInst, HINSTANCE hPrevInstance)
{
        WNDCLASS wndclass;

        if (!hPrevInstance)
        {
                wndclass.style         = 0 ;
                wndclass.lpfnWndProc   = WndProc ;
                wndclass.cbClsExtra    = 0 ;
                wndclass.cbWndExtra    = 0 ;
                wndclass.hInstance     = hInst ;
                wndclass.hIcon         = LoadIcon(hInst, MAKEINTRESOURCE(IDI_DEFAULT)) ;
                wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
                wndclass.hbrBackground = GetStockObject (WHITE_BRUSH) ;
                wndclass.lpszMenuName  = NULL ;
                wndclass.lpszClassName = g_szAppName ;

                if (!RegisterClass(&wndclass))
                {
                        return(FALSE);
                }
        }

        g_hwndStub = CreateWindow(g_szAppName, TEXT(""), 0,
                0, 0, 0, 0, NULL, NULL, hInst, NULL);

        return(g_hwndStub != NULL);
}


static void   CleanUp(void)
{
        DestroyWindow(g_hwndStub);

        FreeLibrary(g_hModule);
}


int  WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszWinMainCmdLine, int nCmdShow)
{
        LPTSTR lpszCmdLine;
        hInst = hInstance;

        //
        // The command line passed to WinMain is always ANSI, so for UNICODE
        // builds we need to ask for the command line in UNICODE
        //

#ifdef UNICODE

        //
        // Since the command line returned from GetCommandLine includes
        // argv[0], but the one passed to Winmain does not, we have
        // to strip argv[0] in order to be equivalent
        //

        lpszCmdLine = GetCommandLine();
        
        //
        // Skip past program name (first token in command line).
        // Check for and handle quoted program name.
        //
        
        if ( *lpszCmdLine == '\"' ) 
        {
    
            //
            // Scan, and skip over, subsequent characters until
            // another double-quote or a null is encountered.
            //
    
            while ( *++lpszCmdLine && (*lpszCmdLine
                 != '\"') );
            //
            // If we stopped on a double-quote (usual case), skip
            // over it.
            //
    
            if ( *lpszCmdLine == '\"' )
                lpszCmdLine++;
        }
        else 
        {
            while (*lpszCmdLine > ' ')
                lpszCmdLine++;
        }

        //
        // Skip past any white space preceeding the second token.
        //
    
        while (*lpszCmdLine && (*lpszCmdLine <= ' ')) 
        {
            lpszCmdLine++;
        }

#else
        lpszCmdLine = lpszWinMainCmdLine;
#endif

        // turn off critical error stuff
        SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

        if (!ParseCommand())
        {
                goto Error0;
        }

        if (!InitStubWindow(hInstance, hPrevInstance))
        {
                goto Error1;
        }

        (*g_lpfnCommand)(g_hwndStub, hInstance, lpszCmdLine, nCmdShow);

Error1:
        CleanUp();
Error0:
        return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\brfprv.h ===
//
// brfprv.h:  Includes all files that are to be part of the precompiled
//             header.
//

#ifndef __BRFPRV_H__
#define __BRFPRV_H__

/////////////////////////////////////////////////////  INCLUDES

#define NEW_REC

#define STRICT
#define NOWINDOWSX
#define NOSHELLDEBUG
//#define NO_COMMCTRL_DA
#define NO_COMMCTRL_ALLOCFCNS
#define USE_MONIKER

#define _INC_OLE            // WIN32

#include <windows.h>
#include <windowsx.h>

#include <shellapi.h>       // for registration functions
#include <port32.h>

#include <shfusion.h>

#include <shlobj.h>         // WIN32
#include <shlobjp.h>
#include <shlapip.h>
#include <shsemip.h>
#include <winuserp.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <ccstock.h>

#ifdef CbFromCch
#undef CbFromCch
#endif // CbFromCch

#ifdef ZeroInit
#undef ZeroInit
#endif // ZeroInit

#ifdef InRange
#undef InRange
#endif // InRange

#include <ole2.h>           // object binding

// Internal Shell headers
#include <shellp.h>
#include <brfcasep.h>

#include <prsht.h>          // Property sheet stuff

#include <synceng.h>        // Twin Engine include file
#include <indirect.h>       // For type-safe indirect calling

#define PUBLIC
#define CPUBLIC          _cdecl
#define PRIVATE

#define MAXBUFLEN       260
#define MAXMSGLEN       520
#define MAXMEDLEN       64
#define MAXSHORTLEN     32

#define NULL_CHAR       TEXT('\0')

#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)

#define DPA_ERR         (-1)

#define CRL_FLAGS       CRL_FL_DELETE_DELETED_TWINS

//---------------------------------------------------------------------------
// misc.c
//---------------------------------------------------------------------------

// Structure for handling abort events
typedef struct
{
    UINT    uFlags;
} ABORTEVT, * PABORTEVT;

// Flags for ABORTEVT struct
#define AEF_DEFAULT     0x0000
#define AEF_SHARED      0x0001
#define AEF_ABORT       0x0002

BOOL PUBLIC AbortEvt_Create(PABORTEVT * ppabortevt, UINT uFlags);
void PUBLIC AbortEvt_Free(PABORTEVT this);
BOOL PUBLIC AbortEvt_Set(PABORTEVT this, BOOL bAbort);
BOOL PUBLIC AbortEvt_Query(PABORTEVT this);


// Structure for the update progress bar
typedef struct
{
    UINT uFlags;
    PABORTEVT pabortevt;
    HWND hwndParent;
    DWORD dwTickShow;   // Tick count at which to display dialog
    HCURSOR hcurSav;

} UPDBAR, * PUPDBAR;      // Update progress bar struct

HWND PUBLIC UpdBar_Show (HWND hwndParent, UINT uFlags, UINT nSecs);
void PUBLIC UpdBar_Kill (HWND hdlg);
void PUBLIC UpdBar_SetCount (HWND hdlg, ULONG ulcFiles);
void PUBLIC UpdBar_SetRange (HWND hdlg, WORD wRangeMax);
void PUBLIC UpdBar_DeltaPos (HWND hdlg, WORD wdelta);
void PUBLIC UpdBar_SetPos(HWND hdlg, WORD wPos);
void PUBLIC UpdBar_SetName (HWND hdlg, LPCTSTR lpcszName);
void PUBLIC UpdBar_SetDescription(HWND hdlg, LPCTSTR psz);
void PUBLIC UpdBar_SetAvi(HWND hdlg, UINT uFlags);
HWND PUBLIC UpdBar_GetStatusWindow(HWND hdlg);
PABORTEVT PUBLIC UpdBar_GetAbortEvt(HWND hdlg);
BOOL PUBLIC UpdBar_QueryAbort (HWND hdlg);

#define DELAY_UPDBAR    3       // 3 seconds

// Flags for UpdBar_Show
#define UB_UPDATEAVI    0x0001
#define UB_CHECKAVI     0x0002
#define UB_NOSHOW       0x0004
#define UB_NOCANCEL     0x0008
#define UB_TIMER        0x0010
#define UB_NOPROGRESS   0x0020

#define UB_CHECKING     (UB_CHECKAVI | UB_NOPROGRESS | UB_TIMER)
#define UB_UPDATING     UB_UPDATEAVI


// Additional MB_ flags
#define MB_WARNING  (MB_OK | MB_ICONWARNING)
#define MB_INFO     (MB_OK | MB_ICONINFORMATION)
#define MB_ERROR    (MB_OK | MB_ICONERROR)
#define MB_QUESTION (MB_YESNO | MB_ICONQUESTION)

int PUBLIC MsgBox(HWND hwndParent, LPCTSTR pszText, LPCTSTR pszCaption, HICON hicon, UINT uStyle, ...);

int PUBLIC ConfirmReplace_DoModal(HWND hwndOwner, LPCTSTR pszPathExisting, LPCTSTR pszPathOther, UINT uFlags);

// Flags for ConfirmReplace_DoModal
#define CRF_DEFAULT     0x0000
#define CRF_MULTI       0x0001
#define CRF_FOLDER      0x0002      // Internal

int PUBLIC Intro_DoModal(HWND hwndParent);


//---------------------------------------------------------------------------
// Local includes
//---------------------------------------------------------------------------

#include "mem.h"            // Shared heap functions
#include "da.h"             // Dynamic array functions
#include "cstrings.h"       // Read-only string constants
#include "init.h"           // Global DLL and initialization
#include "strings.h"        // Private string include
#include "comm.h"           // Common functions
#include "err.h"            // Error/debug code
#include "twin.h"           // Engine specific macros
#include "cache.h"          // Cache functions
#include "atoms.h"          // Atom functions

//---------------------------------------------------------------------------
// Critical section stuff
//---------------------------------------------------------------------------

// Notes:
//  1. Never "return" from the critical section.
//  2. Never "SendMessage" or "Yield" from the critical section.
//  3. Never call USER API which may yield.
//  4. Always make the critical section as small as possible.
//

void PUBLIC Brief_EnterExclusive(void);
void PUBLIC Brief_LeaveExclusive(void);
extern UINT g_cRefSyncUI;

#define ENTEREXCLUSIVE()    Brief_EnterExclusive()
#define LEAVEEXCLUSIVE()    Brief_LeaveExclusive()
#define ASSERTEXCLUSIVE()       ASSERT(0 < g_cRefSyncUI)
#define ASSERT_NOT_EXCLUSIVE()  ASSERT(0 == g_cRefSyncUI)

UINT PUBLIC Delay_Own(void);
UINT PUBLIC Delay_Release(void);


//---------------------------------------------------------------------------
// IDataObject prototypes
//---------------------------------------------------------------------------

BOOL    PUBLIC DataObj_KnowsBriefObj(LPDATAOBJECT pdtobj);
HRESULT PUBLIC DataObj_QueryBriefPath(LPDATAOBJECT pdtobj, LPTSTR pszBriefPath, int cchMax);
HRESULT PUBLIC DataObj_QueryPath(LPDATAOBJECT pdtobj, LPTSTR pszPath, int ccMax);
HRESULT PUBLIC DataObj_QueryFileList(LPDATAOBJECT pdtobj, LPTSTR * ppszList, LPUINT puCount);
void    PUBLIC DataObj_FreeList(LPTSTR pszList);

// Helper macros
#define NextString(psz)             while (*(psz)++)
#define DataObj_NextFile(psz)       NextString(psz)

//---------------------------------------------------------------------------
// path.c
//---------------------------------------------------------------------------

// Events for PathNotifyShell
typedef enum _notifyshellevent
{
    NSE_CREATE       = 0,
    NSE_MKDIR,
    NSE_UPDATEITEM,
    NSE_UPDATEDIR
} NOTIFYSHELLEVENT;

LPTSTR   PUBLIC MyPathRemoveBackslash(LPTSTR lpszPath);
LPTSTR   PUBLIC PathRemoveExt(LPCTSTR pszPath, LPTSTR pszBuf);
void    PUBLIC PathMakePresentable(LPTSTR pszPath);
LPTSTR   PUBLIC PathGetDisplayName(LPCTSTR pszPath, LPTSTR pszBuf, int cchMax);
void    PUBLIC BrfPathCanonicalize(LPCTSTR pszPath, LPTSTR pszBuf, int cchMax);
BOOL    PUBLIC PathCheckForBriefcase(LPCTSTR pszPath, DWORD dwAttrib);
BOOL    PUBLIC PathIsBriefcase(LPCTSTR pszPath);
BOOL    PUBLIC PathExists(LPCTSTR pszPath);
UINT    PUBLIC PathGetLocality(LPCTSTR pszPath, LPTSTR pszBuf, int cchMax);
void    PUBLIC PathNotifyShell(LPCTSTR pszPath, NOTIFYSHELLEVENT nse, BOOL bDoNow);
LPCTSTR  PUBLIC PathFindEndOfRoot(LPCTSTR pszPath);
LPTSTR   PUBLIC PathFindNextComponentI(LPCTSTR lpszPath);
BOOL    PUBLIC PathsTooLong(LPCTSTR pszFolder, LPCTSTR pszName);

// Path locality values, relative to a briefcase
//
#define PL_FALSE   0       // path is not related at all to a briefcase
#define PL_ROOT    1       // path directly references the root of a briefcase
#define PL_INSIDE  2       // path is somewhere inside a briefcase

//---------------------------------------------------------------------------
// state.c
//---------------------------------------------------------------------------

#ifdef DEBUG

BOOL PUBLIC ProcessIniFile(void);
BOOL PUBLIC CommitIniFile(void);

#else

#define ProcessIniFile()
#define CommitIniFile()

#endif

//---------------------------------------------------------------------------
// oledup.c
//---------------------------------------------------------------------------

HRESULT MyReleaseStgMedium(LPSTGMEDIUM pmedium);

//---------------------------------------------------------------------------
// thread.c
//---------------------------------------------------------------------------

BOOL PUBLIC RunDLLThread(HWND hwnd, LPCTSTR pszCmdLine, int nCmdShow);


//---------------------------------------------------------------------------
// ibrfext.c
//---------------------------------------------------------------------------

// This structure shares common data between all briefcase
// property pages
typedef struct tagPAGEDATA
{
    LPBRIEFCASESTG  pbrfstg;        // IBriefcaseStg instance
    int             atomPath;
    PCBS            pcbs;
    UINT            cRef;

    PRECLIST        prl;
    PFOLDERTWINLIST pftl;
    BOOL            bOrphan:1;      // TRUE: This is an orphan
    BOOL            bFolder:1;      // TRUE: This is a folder
    BOOL            bRecalc:1;      // TRUE: Need to recalc

    LPARAM          lParam;         // Page-specific data
} PAGEDATA, * PPAGEDATA;

HRESULT PUBLIC PageData_Init(PPAGEDATA this, HWND hwndOwner);
HRESULT PUBLIC PageData_Query(PPAGEDATA this, HWND hwndOwner, PRECLIST * pprl, PFOLDERTWINLIST * ppftl);
void    PUBLIC PageData_Orphanize(PPAGEDATA this);

#define PageData_GetHbrf(this)      ((this)->pcbs->hbrf)

HRESULT CALLBACK BriefExt_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID * ppvOut);


//---------------------------------------------------------------------------
// status.c
//---------------------------------------------------------------------------

INT_PTR _export CALLBACK Stat_WrapperProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void PUBLIC SelectItemInCabinet(HWND hwndCabinet, LPCITEMIDLIST pidl, BOOL bEdit);
void PUBLIC OpenCabinet(HWND hwnd, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl, BOOL bEdit);


//---------------------------------------------------------------------------
// info.c
//---------------------------------------------------------------------------

typedef struct
{
    int     atomTo;
    HDPA    hdpaTwins;    // handle to array of twin handles which will
    //  be filled by dialog.
    //  N.b.  Caller must release these twins!
    BOOL    bStandAlone;  // private: should only be set by Info_DoModal
} INFODATA, * PINFODATA;

INT_PTR _export CALLBACK Info_WrapperProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

HRESULT PUBLIC Info_DoModal(HWND hwndParent, LPCTSTR pszPath1, LPCTSTR pszPath2, HDPA hdpaTwin, PCBS pcbs);


//---------------------------------------------------------------------------
// ibrfstg.c
//---------------------------------------------------------------------------

void    PUBLIC TermCacheTables(void);
HRESULT CALLBACK BriefStg_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID * ppvOut);

//---------------------------------------------------------------------------
// update.c
//---------------------------------------------------------------------------

// Flags for Upd_DoModal
#define UF_SELECTION    0x0001
#define UF_ALL          0x0002

HRESULT PUBLIC Upd_DoModal(HWND hwndOwner, CBS * pcbs, LPCTSTR pszList, UINT cFiles, UINT uFlags);

//---------------------------------------------------------------------------
// init.c
//---------------------------------------------------------------------------

LPSHELLFOLDER PUBLIC GetDesktopShellFolder(void);


//---------------------------------------------------------------------------
// Semaphores
//---------------------------------------------------------------------------

// The BusySemaphore is used only for areas of code that do not
// rely on the sync engine v-table.  One example is the IContextMenu
// code.
//
// The BriefSemaphore is used for any code that opens/closes a
// Briefcase storage interface.
//
// These must be serialized.

extern UINT g_cBusyRef;            // Semaphore
extern UINT g_cBriefRef;           // Semaphore

#define IsBusySemaphore()       (g_cBusyRef > 0)
#define IncBusySemaphore()      (g_cBusyRef++)
#define DecBusySemaphore()      (g_cBusyRef--)

#define IncBriefSemaphore()     (g_cBriefRef++)
#define DecBriefSemaphore()     (g_cBriefRef--)
#define IsOpenBriefSemaphore()  (g_cBriefRef > 0)
#define IsFirstBriefSemaphore() (g_cBriefRef == 1)
#define IsLastBriefSemaphore()  (g_cBriefRef == 0)

#endif  //!__BRFPRV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\atoms.h ===
//
// atoms.h: Atom handling
//
//

#ifndef __ATOMS_H__
#define __ATOMS_H__


/////////////////////////////////////////////////////  DEFINES

// Atom Table 
//
// We have our own atoms for two reasons:
//
//  1) Gives us greater flexibility for partial string searches,
//      in-place string replacements, and table resize
//  2) We don't know yet if Windows' local atom tables are sharable
//      in separate instances in Win32.
//

BOOL    PUBLIC Atom_Init (void);
void    PUBLIC Atom_Term (void);
int     PUBLIC Atom_Add (LPCTSTR psz);
UINT    PUBLIC Atom_AddRef(int atom);
void    PUBLIC Atom_Delete (int atom);
BOOL    PUBLIC Atom_Replace (int atom, LPCTSTR pszNew);
int     PUBLIC Atom_Find (LPCTSTR psz);
LPCTSTR  PUBLIC Atom_GetName (int atom);
BOOL    PUBLIC Atom_IsPartialMatch(int atom1, int atom2);
BOOL    PUBLIC Atom_Translate(int atomOld, int atomNew);

#define Atom_IsChildOf(atom1, atom2)    Atom_IsPartialMatch(atom1, atom2)
#define Atom_IsParentOf(atom1, atom2)   Atom_IsPartialMatch(atom2, atom1)

#define ATOM_ERR    (-1)

#define Atom_IsValid(atom)      (ATOM_ERR != (atom) && 0 != (atom))

#ifdef DEBUG

void    PUBLIC Atom_ValidateFn(int atom);
void    PUBLIC Atom_DumpAll();

#define VALIDATE_ATOM(atom)     Atom_ValidateFn(atom)

#else  // DEBUG

#define VALIDATE_ATOM(atom)

#endif // DEBUG

#endif // __ATOMS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\atoms.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: atoms.c
//
//  This files contains the atom list code.
//
// History:
//  01-31-94 ScottH     Moved from cache.c
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers

/////////////////////////////////////////////////////  TYPEDEFS

typedef struct tagA_ITEM
{
    int atom;           // index into hdsa
    LPTSTR psz;          // allocated
    UINT ucRef;
} A_ITEM;       // item for atom table

typedef struct tagATOMTABLE
{
    CRITICAL_SECTION cs;
    HDSA hdsa;          // Actual list of A_ITEMs
    HDPA hdpa;          // List into hdsa (sorted).  Values are indexes, not pointers
    HDPA hdpaFree;      // Free list.  Values are indexes, not pointers.
} ATOMTABLE;

#define Atom_EnterCS(this)    EnterCriticalSection(&(this)->cs)
#define Atom_LeaveCS(this)    LeaveCriticalSection(&(this)->cs)

#define ATOM_GROW   32


#define Cache_Bogus(this)  (!(this)->hdpa || !(this)->hdpaFree || !(this)->hdsa)

// Given an index into the DPA, get the pointer to the DSA
//
#define MyGetPtr(this, idpa)     DSA_GetItemPtr((this)->hdsa, PtrToUlong(DPA_FastGetPtr((this)->hdpa, idpa)))

/////////////////////////////////////////////////////  MODULE DATA

static ATOMTABLE s_atomtable;

#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Validates the given atom is within the atomtable's range
Returns: --
Cond:    --
 */
void PUBLIC Atom_ValidateFn(
        int atom)
{
    ATOMTABLE  * this = &s_atomtable;
    BOOL bError = FALSE;

    Atom_EnterCS(this);
    {
        if (atom >= DSA_GetItemCount(this->hdsa) ||
                atom < 0)
        {
            bError = TRUE;
        }
    }
    Atom_LeaveCS(this);

    if (bError)
    {
        // This is a problem!
        //
        DEBUG_MSG(TF_ERROR, TEXT("err BRIEFCASE: atom %d is out of range!"), atom);
        DEBUG_BREAK(BF_ONVALIDATE);
    }
}


/*----------------------------------------------------------
Purpose: Dump the table contents
Returns: --
Cond:    For debugging purposes
 */
void PUBLIC Atom_DumpAll()
{
    ATOMTABLE  * this = &s_atomtable;
    Atom_EnterCS(this);
    {
        if (IsFlagSet(g_uDumpFlags, DF_ATOMS))
        {
            A_ITEM  * pitem;
            int idpa;
            int cItem;

            ASSERT(this);
            ASSERT(this->hdsa != NULL);

            cItem = DPA_GetPtrCount(this->hdpa);
            for (idpa = 0; idpa < cItem; idpa++)
            {
                pitem = MyGetPtr(this, idpa);

                // The zero'th entry is reserved, so skip it
                if (pitem->atom == 0)
                    continue;

                TRACE_MSG(TF_ALWAYS, TEXT("ATOM:  Atom %d [%u]: %s"),
                        pitem->atom, pitem->ucRef, pitem->psz);
            }
        }
    }
    Atom_LeaveCS(this);
}
#endif


/*----------------------------------------------------------
Purpose: Compare A_ITEMs
Returns: -1 if <, 0 if ==, 1 if >
Cond:    --
 */
int CALLBACK _export Atom_CompareIndexes(
        LPVOID lpv1,
        LPVOID lpv2,
        LPARAM lParam)
{
    int i1 = PtrToUlong(lpv1);
    int i2 = PtrToUlong(lpv2);
    HDSA hdsa = (HDSA)lParam;
    A_ITEM  * pitem1 = DSA_GetItemPtr(hdsa, i1);
    A_ITEM  * pitem2 = DSA_GetItemPtr(hdsa, i2);

    ASSERT(pitem1);
    ASSERT(pitem2);

    return lstrcmpi(pitem1->psz, pitem2->psz);
}


/*----------------------------------------------------------
Purpose: Compare A_ITEMs
Returns: -1 if <, 0 if ==, 1 if >
Cond:    --
 */
int CALLBACK _export Atom_Compare(
        LPVOID lpv1,
        LPVOID lpv2,
        LPARAM lParam)
{
    // HACK: we know the first param is the address to a struct
    //  that contains the search criteria.  The second is an index
    //  into the DSA.
    //
    int i2 = PtrToUlong(lpv2);
    HDSA hdsa = (HDSA)lParam;
    A_ITEM  * pitem1 = (A_ITEM  *)lpv1;
    A_ITEM  * pitem2 = DSA_GetItemPtr(hdsa, i2);

    ASSERT(pitem1);
    ASSERT(pitem2);

    return lstrcmpi(pitem1->psz, pitem2->psz);
}


/*----------------------------------------------------------
Purpose: Initialize the atom table
Returns: TRUE on success
Cond:    --
 */
BOOL PUBLIC Atom_Init()
{
    BOOL bRet;
    ATOMTABLE  * this = &s_atomtable;

    ASSERT(this);
    ZeroInit(this, ATOMTABLE);

    bRet = InitializeCriticalSectionAndSpinCount(&this->cs, 0);
    
    if (bRet)
    {
        Atom_EnterCS(this);
        {
            if ((this->hdsa = DSA_Create(sizeof(A_ITEM), ATOM_GROW)) != NULL)
            {
                if ((this->hdpa = DPA_Create(ATOM_GROW)) == NULL)
                {
                    DSA_Destroy(this->hdsa);
                    this->hdsa = NULL;
                }
                else
                {
                    if ((this->hdpaFree = DPA_Create(ATOM_GROW)) == NULL)
                    {
                        DPA_Destroy(this->hdpa);
                        DSA_Destroy(this->hdsa);
                        this->hdpa = NULL;
                        this->hdsa = NULL;
                    }
                    else
                    {
                        // We've successfully initialized.  Keep the zero'th
                        //  atom reserved.  This way null atoms will not accidentally
                        //  munge data.
                        //
                        int atom = Atom_Add(TEXT("SHDD"));
                        ASSERT(atom == 0);
                    }
                }
            }
            bRet = this->hdsa != NULL;
        }
        Atom_LeaveCS(this);
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Destroy the atom table
Returns: --
Cond:    --
 */
void PUBLIC Atom_Term()
{
    ATOMTABLE  * this = &s_atomtable;

    Atom_EnterCS(this);
    {
        if (this->hdpa != NULL)
        {
            A_ITEM  * pitem;
            int idpa;
            int cItem;

            ASSERT(this->hdsa != NULL);

            cItem = DPA_GetPtrCount(this->hdpa);
            for (idpa = 0; idpa < cItem; idpa++)
            {
                pitem = MyGetPtr(this, idpa);

                // The zero'th entry is reserved, so skip it
                if (pitem->atom == 0)
                    continue;

                Str_SetPtr(&pitem->psz, NULL);
            }
            DPA_Destroy(this->hdpa);
            this->hdpa = NULL;
        }

        if (this->hdpaFree != NULL)
        {
            DPA_Destroy(this->hdpaFree);
            this->hdpaFree = NULL;
        }

        if (this->hdsa != NULL)
        {
            DSA_Destroy(this->hdsa);
            this->hdsa = NULL;
        }
    }
    Atom_LeaveCS(this);

    DeleteCriticalSection(&this->cs);
}


/*----------------------------------------------------------
Purpose: Add a string to the atom table.  If the string already
exists, return its atom.
Returns: Atom
ATOM_ERR on failure

Cond:    Reference count is incremented always
 */
int PUBLIC Atom_Add(
        LPCTSTR psz)
{
    ATOMTABLE  * this = &s_atomtable;
    A_ITEM  * pitem = NULL;
    A_ITEM item;
    int atomRet = ATOM_ERR;
    int idpa;
    int cItem;
    int cFree;

    ASSERT(psz);

    Atom_EnterCS(this);
    {
        int iItem;

        DEBUG_CODE( iItem = -1; )

            // Search for the string in the atom table first.
            //  If we find it, return the atom.
            //
            item.psz = (LPTSTR)(LPVOID)psz;
        idpa = DPA_Search(this->hdpa, &item, 0, Atom_Compare, (LPARAM)this->hdsa, DPAS_SORTED);
        if (idpa != -1)
        {
            // String is already in table
            //
            pitem = MyGetPtr(this, idpa);
            pitem->ucRef++;
            atomRet = pitem->atom;

            ASSERT(IsSzEqual(psz, pitem->psz));

            VALIDATE_ATOM(pitem->atom);
        }
        else
        {
            // Add the string to the table.  Take any available entry
            //  from the free list first.  Otherwise allocate more space
            //  in the table.  Then add a ptr to the sorted ptr list.
            //
            cFree = DPA_GetPtrCount(this->hdpaFree);
            if (cFree > 0)
            {
                // Use a free entry
                //
                cFree--;
                iItem = PtrToUlong(DPA_DeletePtr(this->hdpaFree, cFree));
                pitem = DSA_GetItemPtr(this->hdsa, iItem);

                // atom field for pitem should already be set

                VALIDATE_ATOM(pitem->atom);
            }
            else
            {
                // Allocate a new entry.  item has bogus data in it.
                //  That's okay, we fill in good stuff below.
                //
                cItem = DSA_GetItemCount(this->hdsa);
                if ((iItem = DSA_InsertItem(this->hdsa, cItem+1, &item)) != -1)
                {
                    pitem = DSA_GetItemPtr(this->hdsa, iItem);
                    pitem->atom = iItem;

                    VALIDATE_ATOM(pitem->atom);
                }
            }

            // Fill in the info
            //
            if (pitem)
            {
                pitem->ucRef = 1;
                pitem->psz = 0;
                if (!Str_SetPtr(&pitem->psz, psz))
                    goto Add_Fail;

                // Add the new entry to the ptr list and sort
                //
                cItem = DPA_GetPtrCount(this->hdpa);
                if (DPA_InsertPtr(this->hdpa, cItem+1, IntToPtr(iItem)) == -1)
                    goto Add_Fail;
                DPA_Sort(this->hdpa, Atom_CompareIndexes, (LPARAM)this->hdsa);
                atomRet = pitem->atom;

                TRACE_MSG(TF_ATOM, TEXT("ATOM  Adding %d [%u]: %s"), atomRet, pitem->ucRef, pitem->psz);
            }
        }

Add_Fail:
        // Add the entry to the free list and fail.  If even this fails,
        //  then we simply lose some slight efficiency, but this is not
        //  a memory leak.
        //
#ifdef DEBUG
        if (atomRet == ATOM_ERR)
            TRACE_MSG(TF_ATOM, TEXT("ATOM  **Failed adding %s"), psz);
#endif
        if (atomRet == ATOM_ERR && pitem)
        {
            ASSERT(iItem != -1);

            DPA_InsertPtr(this->hdpaFree, cFree+1, IntToPtr(iItem));
        }
    }
    Atom_LeaveCS(this);

    return atomRet;
}


/*----------------------------------------------------------
Purpose: Increment the reference count of this atom.

Returns: Last count
0 if the atom doesn't exist
Cond:    --
 */
UINT PUBLIC Atom_AddRef(
        int atom)
{
    ATOMTABLE  * this = &s_atomtable;
    UINT cRef;

    if (!Atom_IsValid(atom))
    {
        ASSERT(0);
        return 0;
    }

    VALIDATE_ATOM(atom);

    Atom_EnterCS(this);
    {
        A_ITEM * pitem = DSA_GetItemPtr(this->hdsa, atom);
        if (pitem)
        {
            cRef = pitem->ucRef++;
        }
        else
        {
            cRef = 0;
        }
    }
    Atom_LeaveCS(this);

    return cRef;
}


/*----------------------------------------------------------
Purpose: Delete a string from the atom table.

If the reference count is not zero, we do nothing.
Returns: --

Cond:    N.b.  Decrements the reference count.
 */
void PUBLIC Atom_Delete(
        int atom)
{
    ATOMTABLE  * this = &s_atomtable;
    A_ITEM  * pitem;

    if (!Atom_IsValid(atom))
    {
        ASSERT(0);
        return;
    }

    VALIDATE_ATOM(atom);

    Atom_EnterCS(this);
    {
        pitem = DSA_GetItemPtr(this->hdsa, atom);
        if (pitem)
        {
            int idpa;
            int cFree;

            ASSERT(pitem->atom == atom);

            // Is the reference count already at zero?
            if (0 == pitem->ucRef)
            {
                // Yes; somebody is calling Atom_Delete one-too-many times!
                DEBUG_CODE( TRACE_MSG(TF_ATOM, TEXT("ATOM  Deleting %d once-too-many!!"),
                            pitem->atom); )
                    ASSERT(0);
            }
            else if (0 == --pitem->ucRef)
            {
                // Yes
                idpa = DPA_GetPtrIndex(this->hdpa, IntToPtr(atom));     // linear search

                DEBUG_CODE( TRACE_MSG(TF_ATOM, TEXT("ATOM  Deleting %d: %s"),
                            pitem->atom, pitem->psz ? pitem->psz : (LPCTSTR)TEXT("NULL")); )

                    ASSERT(atom == (int)DPA_GetPtr(this->hdpa, idpa));
                if (DPA_ERR != idpa)
                {
                    DPA_DeletePtr(this->hdpa, idpa);

                    ASSERT(pitem->psz);
                    Str_SetPtr(&pitem->psz, NULL);

                    DEBUG_CODE( pitem->psz = NULL; )
                }
                else
                {
                    ASSERT(0);      // Should never get here
                }

                // Add ptr to the free list.  If this fails, we simply
                //  lose some efficiency in reusing this portion of the cache.
                //  This is not a memory leak.
                //
                cFree = DPA_GetPtrCount(this->hdpaFree);
                DPA_InsertPtr(this->hdpaFree, cFree+1, IntToPtr(atom));
            }
        }
    }
    Atom_LeaveCS(this);
}


/*----------------------------------------------------------
Purpose: Replace the string corresponding with the atom with
another string.  The atom will not change.
Returns: TRUE on success
Cond:    --
 */
BOOL PUBLIC Atom_Replace(
        int atom,
        LPCTSTR pszNew)
{
    ATOMTABLE  * this = &s_atomtable;
    BOOL bRet = FALSE;
    A_ITEM  * pitem;

    ASSERT(pszNew);

    if (!Atom_IsValid(atom))
    {
        return FALSE;
    }

    VALIDATE_ATOM(atom);

    Atom_EnterCS(this);
    {
        pitem = DSA_GetItemPtr(this->hdsa, atom);
        if (pitem)
        {
            ASSERT(atom == pitem->atom);
            ASSERT(pitem->psz);
            DEBUG_CODE( TRACE_MSG(TF_ATOM, TEXT("ATOM  Change %d [%u]: %s -> %s"),
                        atom, pitem->ucRef, pitem->psz, pszNew); )

                if (Str_SetPtr(&pitem->psz, pszNew))
                {
                    DPA_Sort(this->hdpa, Atom_CompareIndexes, (LPARAM)this->hdsa);
                    bRet = TRUE;
                }
#ifdef DEBUG
                else
                    TRACE_MSG(TF_ATOM, TEXT("ATOM  **Change failed"));
#endif
        }
    }
    Atom_LeaveCS(this);
    return bRet;
}


/*----------------------------------------------------------
Purpose: Translate all atoms with that contain the partial
string atomOld with the partial string atomNew.
Returns: TRUE on success
Cond:    --
 */
BOOL PUBLIC Atom_Translate(
        int atomOld,
        int atomNew)
{
    BOOL bRet = FALSE;
    ATOMTABLE  * this = &s_atomtable;
    A_ITEM  * pitem;
    int idpa;
    int cItem;
    int atomSave = 0;
    int cchOld;
    LPCTSTR psz;
    LPCTSTR pszOld;
    LPCTSTR pszNew;
    LPCTSTR pszRest;
    TCHAR sz[MAXPATHLEN];

    if ( !(Atom_IsValid(atomOld) && Atom_IsValid(atomNew)) )
    {
        return FALSE;
    }

    Atom_EnterCS(this);
    {
        pszOld = Atom_GetName(atomOld);
        cchOld = lstrlen(pszOld);
        pszNew = Atom_GetName(atomNew);

        cItem = DPA_GetPtrCount(this->hdpa);
        for (idpa = 0; idpa < cItem; idpa++)
        {
            pitem = MyGetPtr(this, idpa);
            ASSERT(pitem);

            if (pitem->atom == 0)
                continue;                   // skip reserved atom

            if (atomOld == pitem->atom)
            {
                atomSave = pitem->atom;     // Save this one for last
                continue;
            }

            psz = Atom_GetName(pitem->atom);
            ASSERT(psz);

            if (PathIsPrefix(psz, pszOld) && lstrlen(psz) >= cchOld)
            {
                // Translate this atom
                //
                pszRest = psz + cchOld;     // whack up the path

                PathCombine(sz, pszNew, pszRest);

                DEBUG_CODE( TRACE_MSG(TF_ATOM, TEXT("ATOM  Translate %d [%u]: %s -> %s"),
                            pitem->atom, pitem->ucRef, pitem->psz, (LPCTSTR)sz); )

                    if (!Str_SetPtr(&pitem->psz, sz))
                        goto Translate_Fail;
            }
        }

        ASSERT(Atom_IsValid(atomSave));      // this means trouble

        VALIDATE_ATOM(atomSave);

        pitem = DSA_GetItemPtr(this->hdsa, atomSave);
        if (pitem)
        {
            ASSERT(atomSave == pitem->atom);
            ASSERT(pitem->psz);

            DEBUG_CODE( TRACE_MSG(TF_ATOM, TEXT("ATOM  Translate %d [%u]: %s -> %s"),
                        pitem->atom, pitem->ucRef, pitem->psz, pszNew); )

                if (!Str_SetPtr(&pitem->psz, pszNew))
                    goto Translate_Fail;
        }
        bRet = TRUE;

Translate_Fail:
        ASSERT(bRet);

        // Sort here, even on a fail, so we correctly sort whatever
        //  got translated before the failure.
        //
        DPA_Sort(this->hdpa, Atom_CompareIndexes, (LPARAM)this->hdsa);
    }
    Atom_LeaveCS(this);

    return bRet;
}


/*----------------------------------------------------------
Purpose: Search for a string in the atom table and return the atom
Returns: Atom
ATOM_ERR if the string is not in the table

Cond:    Reference count is NOT incremented
 */
int PUBLIC Atom_Find(
        LPCTSTR psz)
{
    ATOMTABLE  * this = &s_atomtable;
    A_ITEM item;
    A_ITEM  * pitem;
    int atomRet = ATOM_ERR;
    int idpa;

    ASSERT(psz);

    Atom_EnterCS(this);
    {
        item.psz = (LPTSTR)(LPVOID)psz;
        idpa = DPA_Search(this->hdpa, &item, 0, Atom_Compare, (LPARAM)this->hdsa,
                DPAS_SORTED);
        if (idpa != -1)
        {
            pitem = MyGetPtr(this, idpa);
            atomRet = pitem->atom;

            DEBUG_CODE( TRACE_MSG(TF_ATOM, TEXT("ATOM  Find %s.  Found %d [%u]: %s"),
                        psz, pitem->atom, pitem->ucRef, pitem->psz); )
                ASSERT(IsSzEqual(psz, pitem->psz));
        }
#ifdef DEBUG
        else
            TRACE_MSG(TF_ATOM, TEXT("ATOM  **Not found %s"), psz);
#endif
    }
    Atom_LeaveCS(this);

    return atomRet;
}


/*----------------------------------------------------------
Purpose: Get the string for this atom
Returns: Ptr to the string
NULL if the atom is bogus

Cond:    The caller must serialize this.
 */
LPCTSTR PUBLIC Atom_GetName(
        int atom)
{
    ATOMTABLE  * this = &s_atomtable;
    LPCTSTR pszRet = NULL;
    A_ITEM  * pitem;

    VALIDATE_ATOM(atom);

    Atom_EnterCS(this);
    {
        pitem = DSA_GetItemPtr(this->hdsa, atom);
        if (pitem)
        {
            pszRet = pitem->psz;

            DEBUG_CODE( TRACE_MSG(TF_ATOM, TEXT("ATOM  Getting name %d [%u]: %s"),
                        atom, pitem->ucRef, pszRet); )
                ASSERT(atom == pitem->atom);
        }
#ifdef DEBUG
        else
            TRACE_MSG(TF_ATOM, TEXT("ATOM  **Cannot get %d"), atom);
#endif
    }
    Atom_LeaveCS(this);

    return pszRet;
}


/*----------------------------------------------------------
Purpose: Return TRUE if atom2 is a partial path match of atom1.

Returns: boolean

Cond:    Requires atom1 and atom2 to be valid.
 */
BOOL PUBLIC Atom_IsPartialMatch(
        int atom1,
        int atom2)
{
    LPCTSTR psz1 = Atom_GetName(atom1);
    LPCTSTR psz2 = Atom_GetName(atom2);

    ASSERT(psz1);
    ASSERT(psz2);

    return PathIsPrefix(psz2, psz1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\cache.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cache.c
//
//  This files contains code for the common cache lists
//
// History:
//  09-02-93 ScottH     Created
//  01-31-94 ScottH     Split into separate files
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers

/////////////////////////////////////////////////////  TYPEDEFS

typedef struct tagCITEM
{
    int atomKey;        
    DEBUG_CODE( LPCTSTR pszKey; )

        LPVOID pvValue;
    UINT ucRef;
} CITEM;        // item for generic cache


#define Cache_EnterCS(this)    EnterCriticalSection(&(this)->cs)
#define Cache_LeaveCS(this)    LeaveCriticalSection(&(this)->cs)


#define CACHE_GROW  8

#define Cache_Bogus(this)  (!(this)->hdpa || !(this)->hdpaFree || !(this)->hdsa)

// Given an index into the DPA, get the pointer to the DSA
//  
#define MyGetPtr(this, idpa)     DSA_GetItemPtr((this)->hdsa, PtrToUlong(DPA_FastGetPtr((this)->hdpa, idpa)))

#define DSA_GetPtrIndex(hdsa, ptr, cbItem)      \
((int)( (DWORD_PTR)(ptr) - (DWORD_PTR)DSA_GetItemPtr(hdsa, 0) ) / (cbItem))


    /*----------------------------------------------------------
      Purpose: Compare two CRLs by pathname
      Returns: -1 if <, 0 if ==, 1 if >
      Cond:    --
     */
    int CALLBACK _export Cache_CompareIndexes(
            LPVOID lpv1,
            LPVOID lpv2,
            LPARAM lParam)      
{
    int i1 = PtrToUlong(lpv1);
    int i2 = PtrToUlong(lpv2);
    HDSA hdsa = (HDSA)lParam;
    CITEM  * pitem1 = (CITEM  *)DSA_GetItemPtr(hdsa, i1);
    CITEM  * pitem2 = (CITEM  *)DSA_GetItemPtr(hdsa, i2);

    if (pitem1->atomKey < pitem2->atomKey)
        return -1;
    else if (pitem1->atomKey == pitem2->atomKey)
        return 0;
    else 
        return 1;
}


/*----------------------------------------------------------
Purpose: Compare two CRLs by pathname
Returns: -1 if <, 0 if ==, 1 if >
Cond:    --
 */
int CALLBACK _export Cache_Compare(
        LPVOID lpv1,
        LPVOID lpv2,
        LPARAM lParam)      
{
    // HACK: we know the first param is the address to a struct
    //  that contains the search criteria.  The second is an index 
    //  into the DSA.
    //
    int i2 = PtrToUlong(lpv2);
    HDSA hdsa = (HDSA)lParam;
    CITEM  * pitem1 = (CITEM  *)lpv1;
    CITEM  * pitem2 = (CITEM  *)DSA_GetItemPtr(hdsa, i2);

    if (pitem1->atomKey < pitem2->atomKey)
        return -1;
    else if (pitem1->atomKey == pitem2->atomKey)
        return 0;
    else 
        return 1;
}


/*----------------------------------------------------------
Purpose: Initialize the cache structure
Returns: TRUE on success
Cond:    --
 */
BOOL PUBLIC Cache_Init(
        CACHE  * pcache)
{
    BOOL bRet;

    ASSERT(pcache);

    Cache_EnterCS(pcache);
    {
        if ((pcache->hdsa = DSA_Create(sizeof(CITEM), CACHE_GROW)) != NULL)
        {
            if ((pcache->hdpa = DPA_Create(CACHE_GROW)) == NULL)
            {
                DSA_Destroy(pcache->hdsa);
                pcache->hdsa = NULL;
            }
            else
            {
                if ((pcache->hdpaFree = DPA_Create(CACHE_GROW)) == NULL)
                {
                    DPA_Destroy(pcache->hdpa);
                    DSA_Destroy(pcache->hdsa);
                    pcache->hdpa = NULL;
                    pcache->hdsa = NULL;
                }
            }
        }
        bRet = pcache->hdsa != NULL;
    }
    Cache_LeaveCS(pcache);

    return bRet;
}


/*----------------------------------------------------------
Purpose: Initializes the cache's critical section.

Returns: --
Cond:    --
 */
void PUBLIC Cache_InitCS(
        CACHE  * pcache)
{
    ASSERT(pcache);
    ZeroInit(pcache, CACHE);
    InitializeCriticalSectionAndSpinCount(&pcache->cs, 0);
}


/*----------------------------------------------------------
Purpose: Destroy the cache 
Returns: --
Cond:    --
 */
void PUBLIC Cache_Term(
        CACHE  * pcache,
        HWND hwndOwner,
        PFNFREEVALUE pfnFree)
{
    ASSERT(pcache);

    Cache_EnterCS(pcache);
    {
        if (pcache->hdpa != NULL)
        {
            CITEM  * pitem;
            int idpa;
            int cItem;

            ASSERT(pcache->hdsa != NULL);

            cItem = DPA_GetPtrCount(pcache->hdpa);
            for (idpa = 0; idpa < cItem; idpa++)
            {
                pitem = MyGetPtr(pcache, idpa);

                if (pfnFree != NULL)
                    pfnFree(pitem->pvValue, hwndOwner);

                // Decrement reference count of atomKey
                Atom_Delete(pitem->atomKey);
            }
            DPA_Destroy(pcache->hdpa);
            pcache->hdpa = NULL;
        }

        if (pcache->hdpaFree != NULL)
        {
            DPA_Destroy(pcache->hdpaFree);
            pcache->hdpaFree = NULL;
        }

        if (pcache->hdsa != NULL)
        {
            DSA_Destroy(pcache->hdsa);
            pcache->hdsa = NULL;
        }
    }
    Cache_LeaveCS(pcache);
}


/*----------------------------------------------------------
Purpose: Deletes the cache's critical section.

Returns: --
Cond:    --
 */
void PUBLIC Cache_DeleteCS(
        CACHE  * pcache)
{
    // The cache should not be in use now (ie, it should be bogus)
    ASSERT(Cache_Bogus(pcache));

    if (Cache_Bogus(pcache))
    {
        DeleteCriticalSection(&pcache->cs);
    }
}


/*----------------------------------------------------------
Purpose: Add an item to the cache list.  
Returns: TRUE on success

Cond:    If this fails, pvValue is not automatically freed
 */
BOOL PUBLIC Cache_AddItem(
        CACHE  * pcache,
        int atomKey,
        LPVOID pvValue)
{
    BOOL bRet = FALSE;
    CITEM  * pitem = NULL;
    int cItem;
    int cFree;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
    {
        VALIDATE_ATOM(atomKey);

        if (!Cache_Bogus(pcache))
        {
            int iItem;

            // Add a new entry to the cache.  The cache has no set size limitation.
            //
            cFree = DPA_GetPtrCount(pcache->hdpaFree);
            if (cFree > 0)
            {
                // Use a free entry 
                //
                cFree--;
                iItem = PtrToUlong(DPA_DeletePtr(pcache->hdpaFree, cFree));
                pitem = DSA_GetItemPtr(pcache->hdsa, iItem);
            }
            else
            {
                CITEM itemDummy;

                // Allocate a new entry
                //
                cItem = DSA_GetItemCount(pcache->hdsa);
                if ((iItem = DSA_InsertItem(pcache->hdsa, cItem+1, &itemDummy)) != -1)
                    pitem = DSA_GetItemPtr(pcache->hdsa, iItem);
            }

            // Fill in the info
            //
            if (pitem)
            {
                pitem->ucRef = 0;
                pitem->pvValue = pvValue;
                pitem->atomKey = atomKey;
                DEBUG_CODE( pitem->pszKey = Atom_GetName(atomKey); )

                    // Now increment the reference count on this atomKey so it doesn't
                    //  get deleted from beneath us!
                    Atom_AddRef(atomKey);

                // Add the new entry to the ptr list and sort
                //
                cItem = DPA_GetPtrCount(pcache->hdpa);
                if (DPA_InsertPtr(pcache->hdpa, cItem+1, IntToPtr(iItem)) == -1)
                    goto Add_Fail;
                DPA_Sort(pcache->hdpa, Cache_CompareIndexes, (LPARAM)pcache->hdsa);

                // Reset the FindFirst/FindNext in case this gets called in the
                //  middle of an enumeration.
                //    
                pcache->atomPrev = ATOM_ERR;
                bRet = TRUE;
            }

Add_Fail:
            if (!bRet)
            {
                // Add the entry to the free list and fail.  If even this 
                //  fails, we simply lose some slight efficiency, but this is 
                //  not a memory leak.
                //
                DPA_InsertPtr(pcache->hdpaFree, cFree+1, IntToPtr(iItem));
            }
        }
    }
    Cache_LeaveCS(pcache);

    return bRet;
}


/*----------------------------------------------------------
Purpose: Delete an item from the cache.
If the reference count is 0, we do nothing.
This also frees the actual value as well, using the
pfnFreeValue function.

Returns: The reference count.  If 0, then we deleted it from cache.

Cond:    N.b.  Decrements the reference count.
 */
int PUBLIC Cache_DeleteItem(
        CACHE  * pcache,
        int atomKey,
        BOOL bNuke,         // TRUE to ignore reference count
        HWND hwndOwner,
        PFNFREEVALUE pfnFree)
{
    int nRet = 0;
    CITEM item;
    CITEM  * pitem;
    int idpa;
    int cFree;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
    {
        if (!Cache_Bogus(pcache))
        {
            item.atomKey = atomKey;
            idpa = DPA_Search(pcache->hdpa, &item, 0, Cache_Compare, (LPARAM)pcache->hdsa, 
                    DPAS_SORTED);
            if (idpa != -1)
            {
                VALIDATE_ATOM(atomKey);

                pitem = MyGetPtr(pcache, idpa);

                if (!bNuke && pitem->ucRef-- > 0)
                {
                    nRet = pitem->ucRef+1;
                }
                else
                {
                    int iItem;

                    DPA_DeletePtr(pcache->hdpa, idpa);

                    // Free old pointer
                    if (pfnFree != NULL)
                        pfnFree(pitem->pvValue, hwndOwner);        

                    Atom_Delete(pitem->atomKey);

                    DEBUG_CODE( pitem->atomKey = -1; )
                        DEBUG_CODE( pitem->pszKey = NULL; )
                        DEBUG_CODE( pitem->pvValue = NULL; )
                        DEBUG_CODE( pitem->ucRef = 0; )

                        // Reset the FindFirst/FindNext in case this gets 
                        //  called in the middle of an enumeration.
                        //    
                        pcache->atomPrev = ATOM_ERR;

                    // Add ptr to the free list.  If this fails, we simply lose 
                    //  some efficiency in reusing this portion of the cache.  
                    //  This is not a memory leak.
                    //
                    cFree = DPA_GetPtrCount(pcache->hdpaFree);
                    iItem = DSA_GetPtrIndex(pcache->hdsa, pitem, sizeof(CITEM));
                    DPA_InsertPtr(pcache->hdpaFree, cFree+1, IntToPtr(iItem));
                }
            }
        }
    }
    Cache_LeaveCS(pcache);

    return nRet;
}


/*----------------------------------------------------------
Purpose: Replace the contents of the value in the cache list.  
If a value does not exist for the given key, return FALSE.
Returns: TRUE if success
Cond:    --
 */
BOOL PUBLIC Cache_ReplaceItem(
        CACHE  * pcache,
        int atomKey,
        LPVOID pvBuf,
        int cbBuf)
{
    BOOL bRet = FALSE;
    CITEM item;
    CITEM  * pitem;
    int idpa;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
    {
        if (!Cache_Bogus(pcache))
        {
            // Search for an existing cache entry 
            //
            item.atomKey = atomKey;
            idpa = DPA_Search(pcache->hdpa, &item, 0, Cache_Compare, (LPARAM)pcache->hdsa, 
                    DPAS_SORTED);

            if (idpa != -1)
            {
                // Found a value for this key.  Replace the contents.
                //
                pitem = MyGetPtr(pcache, idpa);
                ASSERT(pitem);

                BltByte(pvBuf, pitem->pvValue, cbBuf);
                bRet = TRUE;

                // No need to sort because key hasn't changed.
            }
        }
    }
    Cache_LeaveCS(pcache);

    return bRet;
}


/*----------------------------------------------------------
Purpose: Get the value of the given key and return a ptr to it
Returns: Ptr to actual entry

Cond:    Reference count is incremented
 */
LPVOID PUBLIC Cache_GetPtr(
        CACHE  * pcache,
        int atomKey)
{
    LPVOID pvRet = NULL;
    CITEM item;
    CITEM  * pitem;
    int idpa;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
    {
        if (!Cache_Bogus(pcache))
        {
            item.atomKey = atomKey;
            idpa = DPA_Search(pcache->hdpa, &item, 0, Cache_Compare, (LPARAM)pcache->hdsa, 
                    DPAS_SORTED);
            if (idpa != -1)
            {
                pitem = MyGetPtr(pcache, idpa);
                ASSERT(pitem);

                pitem->ucRef++;
                pvRet = pitem->pvValue;
            }
        }
    }
    Cache_LeaveCS(pcache);

    return pvRet;
}


#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Get the current reference count
Returns: Ptr to actual entry

Cond:    Used for debugging
 */
UINT PUBLIC Cache_GetRefCount(
        CACHE  * pcache,
        int atomKey)
{
    UINT ucRef = (UINT)-1;
    CITEM item;
    CITEM  * pitem;
    int idpa;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
    {
        if (!Cache_Bogus(pcache))
        {
            item.atomKey = atomKey;
            idpa = DPA_Search(pcache->hdpa, &item, 0, Cache_Compare, (LPARAM)pcache->hdsa, 
                    DPAS_SORTED);
            if (idpa != -1)
            {
                pitem = MyGetPtr(pcache, idpa);
                ASSERT(pitem);

                ucRef = pitem->ucRef;
            }
        }
    }
    Cache_LeaveCS(pcache);

    return ucRef;
}
#endif


/*----------------------------------------------------------
Purpose: Get the value of the given key and return a copy of it
in the supplied buffer
Returns: Copy of value in buffer
TRUE if found, FALSE if not

Cond:    --
 */
BOOL PUBLIC Cache_GetItem(
        CACHE  * pcache,
        int atomKey,
        LPVOID pvBuf,
        int cbBuf)
{
    BOOL bRet = FALSE;
    CITEM item;
    CITEM  * pitem;
    int idpa;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
    {
        if (!Cache_Bogus(pcache))
        {
            item.atomKey = atomKey;
            idpa = DPA_Search(pcache->hdpa, &item, 0, Cache_Compare, (LPARAM)pcache->hdsa, 
                    DPAS_SORTED);
            if (idpa != -1)
            {
                pitem = MyGetPtr(pcache, idpa);
                ASSERT(pitem);

                BltByte(pvBuf, pitem->pvValue, cbBuf);
                bRet = TRUE;
            }
        }
    }
    Cache_LeaveCS(pcache);

    return bRet;
}


/*----------------------------------------------------------
Purpose: Get the first key in the cache.
Returns: Atom
ATOM_ERR if cache is empty
Cond:    --
 */
int PUBLIC Cache_FindFirstKey(
        CACHE  * pcache)
{
    int atomRet = ATOM_ERR;
    CITEM  * pitem;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
    {
        if (!Cache_Bogus(pcache))
        {
            int i;

            pcache->iPrev = 0;
            if (DPA_GetPtrCount(pcache->hdpa) > 0)
            {
                i = PtrToUlong(DPA_FastGetPtr(pcache->hdpa, 0));

                pitem = DSA_GetItemPtr(pcache->hdsa, i);

                pcache->atomPrev = pitem->atomKey;
                atomRet = pitem->atomKey;

                VALIDATE_ATOM(atomRet);
            }
        }
    }
    Cache_LeaveCS(pcache);

    return atomRet;
}


/*----------------------------------------------------------
Purpose: Get the next key in the cache.
Returns: Atom
ATOM_ERR if we're at the end of the cache
Cond:    --
 */
int PUBLIC Cache_FindNextKey(
        CACHE  * pcache,
        int atomPrev)
{
    int atomRet = ATOM_ERR;
    CITEM  * pitem;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
    {
        if (!Cache_Bogus(pcache))
        {
            if (atomPrev != ATOM_ERR)
            {
                int i;

                if (atomPrev != pcache->atomPrev)
                {
                    CITEM item;

                    // Search for atomPrev or next one nearest to it.  
                    //
                    item.atomKey = atomPrev;
                    pcache->iPrev = DPA_Search(pcache->hdpa, &item, 0, Cache_Compare, 
                            (LPARAM)pcache->hdsa, DPAS_SORTED | DPAS_INSERTBEFORE);
                }
                else
                    pcache->iPrev++;

                if (DPA_GetPtrCount(pcache->hdpa) > pcache->iPrev)
                {
                    i = PtrToUlong(DPA_FastGetPtr(pcache->hdpa, pcache->iPrev));
                    pitem = DSA_GetItemPtr(pcache->hdsa, i);

                    pcache->atomPrev = pitem->atomKey;
                    atomRet = pitem->atomKey;

                    VALIDATE_ATOM(atomRet);
                }
            }
        }
    }
    Cache_LeaveCS(pcache);

    return atomRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\cache.h ===
//
// cache.h: Declares data, defines and struct types for the
//          cache list module.
//
//

#ifndef __CACHE_H__
#define __CACHE_H__


/////////////////////////////////////////////////////////////
//  
//  Generic cache structures
//
/////////////////////////////////////////////////////////////


typedef void (CALLBACK *PFNFREEVALUE)(void * pv, HWND hwndOwner);

typedef struct tagCACHE
    {
    CRITICAL_SECTION cs;
    HDSA hdsa;          // Actual list of CITEMs
    HDPA hdpa;          // Sorted ptr list
    HDPA hdpaFree;      // Free list
    int iPrev;          // Index into hdpa.  Used by FindFirst/FindNext
    int atomPrev;
    } CACHE;

// Generic cache APIs
//
BOOL    PUBLIC Cache_Init (CACHE  * pcache);
void    PUBLIC Cache_InitCS(CACHE  * pcache);
void    PUBLIC Cache_Term (CACHE  * pcache, HWND hwndOwner, PFNFREEVALUE pfnFree);
void    PUBLIC Cache_DeleteCS(CACHE  * pcache);
BOOL    PUBLIC Cache_AddItem (CACHE  * pcache, int atomKey, LPVOID pvValue);
int     PUBLIC Cache_DeleteItem (CACHE  * pcache, int atomKey, BOOL bNuke, HWND hwndOwner, PFNFREEVALUE pfnFree);
BOOL    PUBLIC Cache_ReplaceItem (CACHE  * pcache, int atomKey, LPVOID pvBuf, int cbBuf);
LPVOID  PUBLIC Cache_GetPtr (CACHE  * pcache, int atomKey);
BOOL    PUBLIC Cache_GetItem(CACHE  * pcache, int atomKey, LPVOID pvBuf, int cbBuf);
int     PUBLIC Cache_FindFirstKey(CACHE  * pcache);
int     PUBLIC Cache_FindNextKey(CACHE  * pcache, int atomPrev);
UINT    PUBLIC Cache_GetRefCount(CACHE  * pcache, int atomKey);


/////////////////////////////////////////////////////////////
//  
//  Cached briefcase handle list
//
/////////////////////////////////////////////////////////////

// Cache briefcase structure 
//
typedef struct tagCBS
    {
    int      atomBrf;           // Useful for reference
    HBRFCASE hbrf;              // Opened on add, closed on delete
    HWND     hwndParent;        // Volatile
    PABORTEVT pabortevt;        // Abort event object
    UINT     uFlags;            // One of CBSF_ flags

    } CBS, * PCBS;

#define CBSF_LFNDRIVE       0x0002

extern CACHE g_cacheCBS;        // Briefcase structure cache


void CALLBACK CBS_Free(LPVOID lpv, HWND hwnd);

DEBUG_CODE( void PUBLIC CBS_DumpAll(); )

//      BOOL CBS_Init(void);
//
#define CBS_Init()                      Cache_Init(&g_cacheCBS)

//      void CBS_InitCS(void);
//
#define CBS_InitCS()                    Cache_InitCS(&g_cacheCBS)

//      void CBS_Term(HWND hwndOwner);
//
#define CBS_Term(hwndOwner)             Cache_Term(&g_cacheCBS, hwndOwner, CBS_Free)

//      void CBS_DeleteCS(void);
//
#define CBS_DeleteCS()                  Cache_DeleteCS(&g_cacheCBS)

//      HRESULT CBS_Add(PCBS * ppcbs, int atomPath, HWND hwndOwner);
//          Must call CBS_Delete for each call to this guy.
//
HRESULT PUBLIC CBS_Add(PCBS * ppcbs, int atomPath, HWND hwndOwner);

//      CBS FAR * CBS_Get(int atomPath);
//          Must call CBS_Delete for each call to this guy.
//
#define CBS_Get(atomPath)               Cache_GetPtr(&g_cacheCBS, atomPath)

//      int CBS_Delete(int atomPath, HWND hwndOwner);
//          Returns reference count (0 if deleted)
//
#define CBS_Delete(atomPath, hwndOwner) Cache_DeleteItem(&g_cacheCBS, atomPath, FALSE, hwndOwner, CBS_Free)

//      int CBS_Nuke(int atomPath, HWND hwndOwner);
//          Returns 0
//
#define CBS_Nuke(atomPath, hwndOwner)   Cache_DeleteItem(&g_cacheCBS, atomPath, TRUE, hwndOwner, CBS_Free)


/////////////////////////////////////////////////////////////
//  
//  Cached reclist 
//
/////////////////////////////////////////////////////////////

// Cache reclist structure
//
typedef struct tagCRL
    {
    int atomPath;           // Inside path for this CRL
    int atomOutside;        // Outside path of the sync copy pair
    UINT idsStatus;         // resource ID for status string

    PABORTEVT pabortevt;    // Abort event object, owned by CBS
    HBRFCASE hbrf;          // Briefcase this reclist belongs to
    int atomBrf;
    PRECLIST lprl;          // Created
    PFOLDERTWINLIST lpftl;  // Created.  May be NULL
    UINT ucUse;             // Use count (dirty entry is not cleaned until 
                            //   ucUse == 0)
    UINT uFlags;            // CRLF_* flags
    } CRL, * PCRL;

// Flags for CRL
#define CRLF_DIRTY          0x00000001      // cache item is dirty
#define CRLF_NUKE           0x00000002      // nuke when use count is 0
#define CRLF_SUBFOLDERTWIN  0x00000004      // folder is subfolder of subtree twin
#define CRLF_ISFOLDER       0x00000008      // atomPath is a folder
#define CRLF_ISLFNDRIVE     0x00000010      // is on an LFN drive
#define CRLF_ORPHAN         0x00000020      // item is orphan

extern CACHE g_cacheCRL;        // Reclist cache

void CALLBACK CRL_Free(LPVOID lpv, HWND hwndOwner);

DEBUG_CODE( void PUBLIC CRL_DumpAll(); )

#define CRL_IsOrphan(pcrl)              IsFlagSet((pcrl)->uFlags, CRLF_ORPHAN)
#define CRL_IsSubfolderTwin(pcrl)       IsFlagSet((pcrl)->uFlags, CRLF_SUBFOLDERTWIN)
#define CRL_IsFolder(pcrl)              IsFlagSet((pcrl)->uFlags, CRLF_ISFOLDER)

//      BOOL CRL_Init(void);
//
#define CRL_Init()                      Cache_Init(&g_cacheCRL)

//      void CRL_InitCS(void);
//
#define CRL_InitCS()                    Cache_InitCS(&g_cacheCRL)

//      void CRL_Term(void);
//
#define CRL_Term()             Cache_Term(&g_cacheCRL, NULL, CRL_Free)

//      void CRL_DeleteCS(void);
//
#define CRL_DeleteCS()                  Cache_DeleteCS(&g_cacheCRL)

BOOL PUBLIC IsSubfolderTwin(HBRFCASE hbrf, LPCTSTR pcszPath);

//      HRESULT CRL_Add(PCBS pcbs, int atomPath);
//          Must call CRL_Delete for each call to this function.
//
HRESULT     PUBLIC CRL_Add(PCBS pcbs, int atomPath);

//      HRESULT CRL_Get(int atomPath, PCRL * ppcrl);
//          Must call CRL_Delete for each successful call to this function.
//
HRESULT     PUBLIC CRL_Get(int atomPath, PCRL * ppcrl);

//      HRESULT CRL_Replace(int atomPath);
//
HRESULT     PUBLIC CRL_Replace(int atomPath);

//      void CRL_Delete(int atomPath);
//
void        PUBLIC CRL_Delete(int atomPath);

//      int CRL_Nuke(int atomPath);
//
void        PUBLIC CRL_Nuke(int atomPath);

//      BOOL CRL_Dirty(int atomPath);
BOOL        PUBLIC CRL_Dirty(int atomPath, int atomCabinetFolder, LONG lEvent, LPBOOL pbRefresh);

//      void CRL_DirtyAll(int atomBrf);
//
void        PUBLIC CRL_DirtyAll(int atomBrf);


/////////////////////////////////////////////////////////////
//  
//  Cached briefcase paths
//
/////////////////////////////////////////////////////////////

typedef struct tagCPATH
    {
    int atomPath;           // Useful for reference 

    } CPATH;

extern CACHE g_cacheCPATH;        // Volume ID cache

void CALLBACK CPATH_Free(LPVOID lpv, HWND hwndOwner);

DEBUG_CODE( void PUBLIC CPATH_DumpAll(); )

//      BOOL CPATH_Init(void);
//
#define CPATH_Init()                    Cache_Init(&g_cacheCPATH)

//      void CPATH_InitCS(void);
//
#define CPATH_InitCS()                  Cache_InitCS(&g_cacheCPATH)

//      void CPATH_Term();
//
#define CPATH_Term()                    Cache_Term(&g_cacheCPATH, NULL, CPATH_Free)

//      void CPATH_DeleteCS(void);
//
#define CPATH_DeleteCS()                Cache_DeleteCS(&g_cacheCPATH)

//      CPATH FAR * CPATH_Replace(int atomPath);
//          Must call CPATH_Delete for each call to this function.
//
CPATH  *  PUBLIC CPATH_Replace(int atomPath);

//      UINT CPATH_GetLocality(LPCSTR pszPath, LPSTR pszBuf);
//
UINT    PUBLIC CPATH_GetLocality(LPCTSTR pszPath, LPTSTR pszBuf, int cchMax);

#endif // __CACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\cbs.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cbs.c
//
//  This files contains code for the cached briefcase structs
//
// History:
//  09-02-93 ScottH     Created
//  01-31-94 ScottH     Moved from cache.c
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers
#include "res.h"


CACHE g_cacheCBS = {0, 0, 0};        // Briefcase structure cache

#define CBS_EnterCS()    EnterCriticalSection(&g_cacheCBS.cs)
#define CBS_LeaveCS()    LeaveCriticalSection(&g_cacheCBS.cs)

SETbl const c_rgseOpenBriefcase[] = {
    { E_TR_OUT_OF_MEMORY,         IDS_OOM_OPENBRIEFCASE,      MB_ERROR },
    { E_OUTOFMEMORY,              IDS_OOM_OPENBRIEFCASE,      MB_ERROR },
    { E_TR_BRIEFCASE_LOCKED,      IDS_ERR_BRIEFCASE_LOCKED,   MB_WARNING },
    { E_TR_BRIEFCASE_OPEN_FAILED, IDS_ERR_OPEN_ACCESS_DENIED, MB_WARNING },
    { E_TR_NEWER_BRIEFCASE,       IDS_ERR_NEWER_BRIEFCASE,    MB_INFO },
    { E_TR_SUBTREE_CYCLE_FOUND,   IDS_ERR_OPEN_SUBTREECYCLE,  MB_WARNING },
};


#ifdef DEBUG
void PRIVATE CBS_DumpEntry(
        CBS  * pcbs)
{
    ASSERT(pcbs);

    TRACE_MSG(TF_ALWAYS, TEXT("CBS:  Atom %d: %s"), pcbs->atomBrf, Atom_GetName(pcbs->atomBrf));
    TRACE_MSG(TF_ALWAYS, TEXT("               Ref [%u]  Hbrf = %lx  "), 
            Cache_GetRefCount(&g_cacheCBS, pcbs->atomBrf),
            pcbs->hbrf);
}


void PUBLIC CBS_DumpAll()
{
    CBS  * pcbs;
    int atom;
    BOOL bDump;

    ENTEREXCLUSIVE();
    {
        bDump = IsFlagSet(g_uDumpFlags, DF_CBS);
    }
    LEAVEEXCLUSIVE();

    if (!bDump)
        return ;

    atom = Cache_FindFirstKey(&g_cacheCBS);
    while (atom != ATOM_ERR)
    {
        pcbs = Cache_GetPtr(&g_cacheCBS, atom);
        ASSERT(pcbs);
        if (pcbs)
        {
            CBS_DumpEntry(pcbs);
            CBS_Delete(atom, NULL);         // Decrement count
        }

        atom = Cache_FindNextKey(&g_cacheCBS, atom);
    }
}
#endif


/*----------------------------------------------------------
Purpose: Save and close the briefcase.
Returns: --
Cond:    
This function is serialized by the caller (Cache_Term or
Cache_DeleteItem).
 */
void CALLBACK CBS_Free(
        LPVOID lpv,
        HWND hwndOwner)
{
    HBRFCASE hbrf;
    CBS  * pcbs = (CBS  *)lpv;
    CRL  * pcrl;
    int atomPath = pcbs->atomBrf;
    int atom;
    TWINRESULT tr1;
    TWINRESULT tr2;
    DECLAREHOURGLASS;

    hbrf = pcbs->hbrf;

    // Save the briefcase with the same name it was opened
    //
    DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Saving and closing Briefcase %s (0x%lx)"), 
                Atom_GetName(atomPath), hbrf); )

        // Search thru the CRL cache for entries 
        //  sharing the same partial path as this briefcase
        //  and nuke them.
        //
        atom = Cache_FindFirstKey(&g_cacheCRL);
    while (atom != ATOM_ERR)
    {
        pcrl = Cache_GetPtr(&g_cacheCRL, atom);
        ASSERT(pcrl);

        if (pcrl)
        {
            if (hbrf == pcrl->hbrf)
            {
                // This atomKey belongs to this briefcase.  Nuke it.
                //
                DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Nuking CRL %d"), atom); )
                    CRL_Nuke(atom);
            }
#ifdef DEBUG
            else
                DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  NOT Nuking CRL %d"), atom); )
#endif

                    Cache_DeleteItem(&g_cacheCRL, atom, FALSE, hwndOwner, CRL_Free);     // Decrement count
        }

        atom = Cache_FindNextKey(&g_cacheCRL, atom);
    }

    // Save the briefcase.  We normally (re)specify the database
    //  pathname to handle the rename case.  However, if the
    //  move bit has been set, then we use the NULL parameter
    //  (save under current name) because we will depend on the
    //  shell to move the database.
    //
    ASSERT(Sync_IsEngineLoaded());

    // First check if the disk is available.  If it isn't, Windows will
    // blue-screen because we cannot close the database file.  So before
    // that happens, bring up a friendlier retry messagebox.
    RETRY_BEGIN(FALSE)
    {
        // Is disk unavailable?
        if ( !PathExists(Atom_GetName(atomPath)) )
        {
            // Yes; ask user to retry/cancel
            int id = MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_CLOSE_UNAVAIL_VOL),
                    MAKEINTRESOURCE(IDS_CAP_SAVE), NULL, MB_RETRYCANCEL | MB_ICONWARNING);
            if (IDRETRY == id)
                RETRY_SET();
        }
    }
    RETRY_END()

        SetHourglass();
    tr1 = Sync_SaveBriefcase(pcbs->hbrf);
    tr2 = Sync_CloseBriefcase(pcbs->hbrf);
    if (TR_SUCCESS != tr1 || TR_SUCCESS != tr2)
    {
        DWORD dwError = GetLastError();

        switch (dwError)
        {
            case ERROR_ACCESS_DENIED:
                MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_SAVE_UNAVAIL_VOL), 
                        MAKEINTRESOURCE(IDS_CAP_SAVE), NULL, MB_ERROR);
                break;

            default:
                if (TR_BRIEFCASE_WRITE_FAILED == tr1 || TR_BRIEFCASE_WRITE_FAILED == tr2)
                {
                    LPTSTR psz;

                    static UINT rgids[2] = { IDS_ERR_1_FullDiskSave, IDS_ERR_2_FullDiskSave };

                    if (FmtString(&psz, IDS_ERR_F_FullDiskSave, rgids, ARRAYSIZE(rgids)))
                    {
                        MsgBox(hwndOwner, psz, MAKEINTRESOURCE(IDS_CAP_SAVE), NULL, MB_ERROR);
                        GFree(psz);
                    }
                }
                break;
        }
    }
    ResetHourglass();

    AbortEvt_Free(pcbs->pabortevt);

    SharedFree(&pcbs);
}


/*----------------------------------------------------------
Purpose: Actually opens the briefcase and adds the briefcase
handle to the given CBS struct.

Returns: standard hresult
Cond:    --
 */
HRESULT PRIVATE OpenTheBriefcase(
        LPCTSTR pszDatPath,
        int atomPath,
        CBS * pcbs,
        HWND hwndOwner)
{
    HRESULT hres;
    TWINRESULT tr;
    BOOL bRet = FALSE;
    DWORD dwFlags = OB_FL_OPEN_DATABASE | OB_FL_TRANSLATE_DB_FOLDER | OB_FL_ALLOW_UI;
    int nDrive;
    int nDriveType;

    // Determine if we want to record the existence of this briefcase.
    // We don't care about briefcases on remote or floppy drives.
    nDrive = PathGetDriveNumber(pszDatPath);

    // Record this briefcase?
    nDriveType = DriveType(nDrive);
    if (DRIVE_CDROM != nDriveType && DRIVE_REMOVABLE != nDriveType && 
            DRIVE_RAMDRIVE != nDriveType &&
            !PathIsUNC(pszDatPath) && !IsNetDrive(nDrive))
    {
        // Yes
        SetFlag(dwFlags, OB_FL_LIST_DATABASE);

        TRACE_MSG(TF_GENERAL, TEXT("Remembering briefcase %s"), pszDatPath);
    }

    RETRY_BEGIN(FALSE)
    {
        tr = Sync_OpenBriefcase(pszDatPath, dwFlags, GetDesktopWindow(), &pcbs->hbrf);
        hres = HRESULT_FROM_TR(tr);

        // Unavailable disk?
        if (FAILED(hres))
        {
            DWORD dwError = GetLastError();

            if (ERROR_INVALID_DATA == dwError || ERROR_ACCESS_DENIED == dwError)
            {
                // Yes; ask user to retry/cancel
                int id = MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_OPEN_UNAVAIL_VOL),
                        MAKEINTRESOURCE(IDS_CAP_OPEN), NULL, MB_RETRYCANCEL | MB_ICONWARNING);

                // Set specific error value
                hres = E_TR_UNAVAILABLE_VOLUME;

                if (IDRETRY == id)
                {
                    RETRY_SET();    // Try again
                }
            }
        }
    }
    RETRY_END()

        if (SUCCEEDED(hres))
        {
            if (!Cache_AddItem(&g_cacheCBS, atomPath, (LPVOID)pcbs))
            {
                Sync_CloseBriefcase(pcbs->hbrf);
                hres = ResultFromScode(E_OUTOFMEMORY);
            }
        }
    return hres;
}


/*----------------------------------------------------------
Purpose: This function handles the case when the engine fails 
to open the database because the database file is
corrupt.

Returns: standard hresult
Cond:    --
 */
HRESULT PRIVATE HandleCorruptDatabase(
        CBS * pcbs,
        int atomPath,
        LPCTSTR pszDatPath,      // Path of database file
        HWND hwndOwner)
{
    TCHAR szTemplate[MAXPATHLEN];
    TCHAR szNewFile[MAXPATHLEN];
    LPTSTR pszNewPath = szTemplate;
    LPCTSTR pszPath = Atom_GetName(atomPath);
    LPTSTR psz;
    DWORD dwAttr;
    HRESULT hr = E_FAIL;

    static UINT rgids[2] = { IDS_ERR_1_CorruptDB, IDS_ERR_2_CorruptDB };

    ASSERT(pszPath);

    // Create the new database name
    //
    SzFromIDS(IDS_BOGUSDBTEMPLATE, szTemplate, ARRAYSIZE(szTemplate));
    if (PathMakeUniqueName(szNewFile, ARRAYSIZE(szNewFile), TEXT("badbc.dat"), szTemplate,
            pszPath))
    {
        lstrcpyn(szTemplate, pszPath, ARRAYSIZE(szTemplate));
        if (PathAppend(pszNewPath, szNewFile))
        {

            // Move the database
            //
            MoveFile(pszDatPath, pszNewPath);

            // Unhide the corrupt database 
            //
            dwAttr = GetFileAttributes(pszNewPath);
            if (dwAttr != 0xFFFFFFFF)
            {
                ClearFlag(dwAttr, FILE_ATTRIBUTE_HIDDEN);
                SetFileAttributes(pszNewPath, dwAttr);
            }

            if (FmtString(&psz, IDS_ERR_F_CorruptDB, rgids, ARRAYSIZE(rgids)))
            {
                MsgBox(hwndOwner, psz, MAKEINTRESOURCE(IDS_CAP_OPEN), NULL, MB_ERROR);
                GFree(psz);
            }
            DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Renaming corrupt database to %s"), pszNewPath); )

                // Retry opening...
                //
                hr = OpenTheBriefcase(pszDatPath, atomPath, pcbs, hwndOwner);
        }
    }
    return hr;
}


/*----------------------------------------------------------
Purpose: Add the atomPath to the cache.  We open the briefcase
database if it needs opening.  If atomPath is already
in the cache, simply return the pointer to the entry.

Returns: standard hresult

Cond:    Must call CBS_Delete for every call to this function
 */
HRESULT PUBLIC CBS_Add(
        PCBS * ppcbs,
        int atomPath,
        HWND hwndOwner)
{
    HRESULT hres = NOERROR;
    TCHAR szDatPath[MAXPATHLEN];
    CBS  * pcbs;

    CBS_EnterCS();
    {
        pcbs = Cache_GetPtr(&g_cacheCBS, atomPath);
        if (NULL == pcbs)
        {
            // Allocate using commctrl's Alloc, so the structure will be in
            // shared heap space across processes.
            pcbs = SharedAllocType(CBS);
            if (NULL == pcbs)
            {
                hres = ResultFromScode(E_OUTOFMEMORY);
            }
            else
            {
                LPCTSTR pszPath = Atom_GetName(atomPath);
                LPCTSTR pszDBName;

                ASSERT(pszPath);

                pcbs->atomBrf = atomPath;
                pcbs->uFlags = 0;

                // Create an abort event object simply so we can programmatically
                // cancel a createreclist call in the worker thread.  This
                // would happen if the user closed the briefcase during
                // CreateRecList.  

                // (it is ok if this fails)
                AbortEvt_Create(&pcbs->pabortevt, AEF_SHARED);

                DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Opening Briefcase %s..."), pszPath); )

                    if (IsLFNDrive(pszPath))
                    {
                        pszDBName = g_szDBName;
                        SetFlag(pcbs->uFlags, CBSF_LFNDRIVE);
                    }
                    else
                        pszDBName = g_szDBNameShort;

                if (PathsTooLong(pszPath, pszDBName))
                {
                    MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_OPEN_TOOLONG), 
                            MAKEINTRESOURCE(IDS_CAP_OPEN), NULL, MB_ERROR);
                    hres = E_FAIL;
                }
                else
                {
                    PathCombine(szDatPath, pszPath, pszDBName);
                    hres = OpenTheBriefcase(szDatPath, atomPath, pcbs, hwndOwner);
                    if (FAILED(hres))
                    {
                        DEBUG_CODE( TRACE_MSG(TF_ERROR, TEXT("Open failed.  Error is %s"), SzFromTR(GET_TR(hres))); )

                            SEMsgBox(hwndOwner, IDS_CAP_OPEN, hres, c_rgseOpenBriefcase, ARRAYSIZE(c_rgseOpenBriefcase));

                        // Is this a corrupt briefcase?
                        if (E_TR_CORRUPT_BRIEFCASE == hres)
                        {
                            // Yes; try to create a new database
                            hres = HandleCorruptDatabase(pcbs, atomPath, szDatPath, hwndOwner);
                        }
                    }
                }
            }
        }

        // Did something fail above?
        if (FAILED(hres))
        {
            // Yes; cleanup
            if (pcbs)
            {
                if (pcbs->hbrf)
                    Sync_CloseBriefcase(pcbs->hbrf);

                SharedFree(&pcbs);
            }
        }

        *ppcbs = pcbs;
    }
    CBS_LeaveCS();

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\brfguidp.h ===
//
//  brfguidp.h
//

// Briefcase Extension OLE object class ID.  This is different
// from the CLSID_Briefcase, which is the container CLSID.  We
// have two separate CLSIDs because they exist in two DLLs: 
// SYNCUI and SHELL232.
//
DEFINE_GUID(CLSID_BriefcaseExt, 0x0B399E01L, 0x0129, 0x101B, 0x9A, 0x4B, 0x00, 0xDD, 0x01, 0x0C, 0xCC, 0x48);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\comm.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: comm.c
//
//  This files contains all common utility routines
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"     // common s
#include "res.h"


// Some of these are replacements for the C runtime routines.
//  This is so we don't have to link to the CRT libs.
//

/*----------------------------------------------------------
Purpose: memset

Swiped from the C 7.0 runtime sources.

Returns:
Cond:
 */
CHAR * PUBLIC lmemset(      // DO NO UNICODIZE
        CHAR * dst,
        CHAR val,
        UINT count)
{
    CHAR * start = dst;

    while (count--)
        *dst++ = val;
    return(start);
}


/*----------------------------------------------------------
Purpose: memmove

Swiped from the C 7.0 runtime sources.

Returns:
Cond:
 */
CHAR * PUBLIC lmemmove(
        CHAR *  dst,
        CHAR * src,
        int count)
{
    CHAR * ret = dst;

    if (dst <= src || dst >= (src + count)) {
        /*
         * Non-Overlapping Buffers
         * copy from lower addresses to higher addresses
         */
        while (count--)
            *dst++ = *src++;
    }
    else {
        /*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        dst += count - 1;
        src += count - 1;

        while (count--)
            *dst-- = *src--;
    }

    return(ret);
}


/*----------------------------------------------------------
Purpose: My verion of atoi.  Supports hexadecimal too.
Returns: integer
Cond:    --
 */
int PUBLIC AnsiToInt(
        LPCTSTR pszString)
{
    int n;
    BOOL bNeg = FALSE;
    LPCTSTR psz;
    LPCTSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString; *psz == TEXT(' ') || *psz == TEXT('\n') || *psz == TEXT('\t'); psz = CharNext(psz))
        ;

    // Determine possible explicit signage
    //
    if (*psz == TEXT('+') || *psz == TEXT('-'))
    {
        bNeg = (*psz == TEXT('+')) ? FALSE : TRUE;
        psz = CharNext(psz);
    }

    // Or is this hexadecimal?
    //
    pszAdj = CharNext(psz);
    if (*psz == TEXT('0') && (*pszAdj == TEXT('x') || *pszAdj == TEXT('X')))
    {
        bNeg = FALSE;   // Never allow negative sign with hexadecimal numbers
        psz = CharNext(pszAdj);

        // Do the conversion
        //
        for (n = 0; ; psz = CharNext(psz))
        {
            if (*psz >= TEXT('0') && *psz <= TEXT('9'))
                n = 0x10 * n + *psz - TEXT('0');
            else
            {
                TCHAR ch = *psz;
                int n2;

                if (ch >= TEXT('a'))
                    ch -= TEXT('a') - TEXT('A');

                n2 = ch - TEXT('A') + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
            }
        }
    }
    else
    {
        for (n = 0; *psz >= TEXT('0') && *psz <= TEXT('9'); psz = CharNext(psz))
            n = 10 * n + *psz - TEXT('0');
    }

    return bNeg ? -n : n;
}


/*----------------------------------------------------------
Purpose: General front end to invoke dialog boxes
Returns: result from EndDialog
Cond:    --
 */
INT_PTR PUBLIC DoModal(
        HWND hwndParent,            // owner of dialog
        DLGPROC lpfnDlgProc,        // dialog proc
        UINT uID,                   // dialog template ID
        LPARAM lParam)              // extra parm to pass to dialog (may be NULL)
{
    INT_PTR nResult = -1;

    nResult = DialogBoxParam(g_hinst, MAKEINTRESOURCE(uID), hwndParent,
            lpfnDlgProc, lParam);

    return nResult;
}


/*----------------------------------------------------------
Purpose: Sets the rectangle with the bounding extent of the given string.
Returns: Rectangle
Cond:    --
 */
void PUBLIC SetRectFromExtent(
        HDC hdc,
        LPRECT lprect,
        LPCTSTR lpcsz)
{
    SIZE size;

    GetTextExtentPoint(hdc, lpcsz, lstrlen(lpcsz), &size);
    SetRect(lprect, 0, 0, size.cx, size.cy);
}


/*----------------------------------------------------------
Purpose: Sees whether the entire string will fit in *prc.
If not, compute the numbder of chars that will fit
(including ellipses).  Returns length of string in
 *pcchDraw.

 Taken from COMMCTRL.

Returns: TRUE if the string needed ellipses
Cond:    --
 */
BOOL PRIVATE NeedsEllipses(
        HDC hdc,
        LPCTSTR pszText,
        RECT * prc,
        int * pcchDraw,
        int cxEllipses)
{
    int cchText;
    int cxRect;
    int ichMin, ichMax, ichMid;
    SIZE siz;

    cxRect = prc->right - prc->left;

    cchText = lstrlen(pszText);

    if (cchText == 0)
    {
        *pcchDraw = cchText;
        return FALSE;
    }

    GetTextExtentPoint(hdc, pszText, cchText, &siz);

    if (siz.cx <= cxRect)
    {
        *pcchDraw = cchText;
        return FALSE;
    }

    cxRect -= cxEllipses;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxRect > 0)
    {
        // Binary search to find character that will fit
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax)
        {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            //
            ichMid = (ichMin + ichMax + 1) / 2;

            GetTextExtentPoint(hdc, &pszText[ichMin], ichMid - ichMin, &siz);

            if (siz.cx < cxRect)
            {
                ichMin = ichMid;
                cxRect -= siz.cx;
            }
            else if (siz.cx > cxRect)
            {
                ichMax = ichMid - 1;
            }
            else
            {
                // Exact match up up to ichMid: just exit.
                //
                ichMax = ichMid;
                break;
            }
        }

        // Make sure we always show at least the first character...
        //
        if (ichMax < 1)
            ichMax = 1;
    }

    *pcchDraw = ichMax;
    return TRUE;
}


#define CCHELLIPSES     3
#define DT_LVWRAP       (DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)

/*----------------------------------------------------------
Purpose: Draws text the shell's way.

Taken from COMMCTRL.

Returns: --

Cond:    This function requires TRANSPARENT background mode
and a properly selected font.
 */
void PUBLIC MyDrawText(
        HDC hdc, 
        LPCTSTR pszText, 
        RECT * prc, 
        UINT flags, 
        int cyChar, 
        int cxEllipses, 
        COLORREF clrText, 

        COLORREF clrTextBk)
{
    int cchText;
    COLORREF clrSave;
    COLORREF clrSaveBk;
    UINT uETOFlags = 0;
    RECT rc;
    TCHAR ach[MAX_PATH + CCHELLIPSES];

    // REVIEW: Performance idea:
    // We could cache the currently selected text color
    // so we don't have to set and restore it each time
    // when the color is the same.
    //
    if (!pszText)
        return;

    rc = *prc;

    // If needed, add in a little extra margin...
    //
    if (IsFlagSet(flags, MDT_EXTRAMARGIN))
    {
        rc.left  += g_cxLabelMargin * 3;
        rc.right -= g_cxLabelMargin * 3;
    }
    else
    {
        rc.left  += g_cxLabelMargin;
        rc.right -= g_cxLabelMargin;
    }

    if (IsFlagSet(flags, MDT_ELLIPSES) &&
            NeedsEllipses(hdc, pszText, &rc, &cchText, cxEllipses))
    {
        hmemcpy(ach, pszText, cchText * sizeof(TCHAR));
        lstrcpyn(ach + cchText, c_szEllipses, ARRAYSIZE(ach) - cchText);

        pszText = ach;

        // Left-justify, in case there's no room for all of ellipses
        //
        ClearFlag(flags, (MDT_RIGHT | MDT_CENTER));
        SetFlag(flags, MDT_LEFT);

        cchText += CCHELLIPSES;
    }
    else
    {
        cchText = lstrlen(pszText);
    }

    if (IsFlagSet(flags, MDT_TRANSPARENT))
    {
        clrSave = SetTextColor(hdc, 0x000000);
    }
    else
    {
        uETOFlags |= ETO_OPAQUE;

        if (IsFlagSet(flags, MDT_SELECTED))
        {
            clrSave = SetTextColor(hdc, g_clrHighlightText);
            clrSaveBk = SetBkColor(hdc, g_clrHighlight);

            if (IsFlagSet(flags, MDT_DRAWTEXT))
            {
                FillRect(hdc, prc, g_hbrHighlight);
            }
        }
        else
        {
            if (clrText == CLR_DEFAULT && clrTextBk == CLR_DEFAULT)
            {
                clrSave = SetTextColor(hdc, g_clrWindowText);
                clrSaveBk = SetBkColor(hdc, g_clrWindow);

                if (IsFlagSet(flags, MDT_DRAWTEXT | MDT_DESELECTED))
                {
                    FillRect(hdc, prc, g_hbrWindow);
                }
            }
            else
            {
                HBRUSH hbr;

                if (clrText == CLR_DEFAULT)
                    clrText = g_clrWindowText;

                if (clrTextBk == CLR_DEFAULT)
                    clrTextBk = g_clrWindow;

                clrSave = SetTextColor(hdc, clrText);
                clrSaveBk = SetBkColor(hdc, clrTextBk);

                if (IsFlagSet(flags, MDT_DRAWTEXT | MDT_DESELECTED))
                {
                    hbr = CreateSolidBrush(GetNearestColor(hdc, clrTextBk));
                    if (hbr)
                    {
                        FillRect(hdc, prc, hbr);
                        DeleteObject(hbr);
                    }
                    else
                        FillRect(hdc, prc, GetStockObject(WHITE_BRUSH));
                }
            }
        }
    }

    // If we want the item to display as if it was depressed, we will
    // offset the text rectangle down and to the left
    if (IsFlagSet(flags, MDT_DEPRESSED))
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    if (IsFlagSet(flags, MDT_DRAWTEXT))
    {
        UINT uDTFlags = DT_LVWRAP;

        if (IsFlagClear(flags, MDT_CLIPPED))
            uDTFlags |= DT_NOCLIP;

        DrawText(hdc, pszText, cchText, &rc, uDTFlags);
    }
    else
    {
        if (IsFlagClear(flags, MDT_LEFT))
        {
            SIZE siz;

            GetTextExtentPoint(hdc, pszText, cchText, &siz);

            if (IsFlagSet(flags, MDT_CENTER))
                rc.left = (rc.left + rc.right - siz.cx) / 2;
            else
            {
                ASSERT(IsFlagSet(flags, MDT_RIGHT));
                rc.left = rc.right - siz.cx;
            }
        }

        if (IsFlagSet(flags, MDT_VCENTER))
        {
            // Center vertically
            rc.top += (rc.bottom - rc.top - cyChar) / 2;
        }

        if (IsFlagSet(flags, MDT_CLIPPED))
            uETOFlags |= ETO_CLIPPED;

        ExtTextOut(hdc, rc.left, rc.top, uETOFlags, prc, pszText, cchText, NULL);
    }

    if (flags & (MDT_SELECTED | MDT_DESELECTED | MDT_TRANSPARENT))
    {
        SetTextColor(hdc, clrSave);
        if (IsFlagClear(flags, MDT_TRANSPARENT))
            SetBkColor(hdc, clrSaveBk);
    }
}


/*----------------------------------------------------------
Purpose: Takes a DWORD value and converts it to a string, adding
commas on the way.

This was taken from the shell.

Returns: Pointer to buffer

Cond:    --
 */

// REARCHITECT The shell has an AddCommas.  Can it be used instead?

LPTSTR PRIVATE BrfAddCommas(
        DWORD dw,
        LPTSTR pszBuffer,
        UINT cbBuffer)
{
    TCHAR  szTemp[30];
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    nfmt.Grouping = StrToInt(szSep);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    wnsprintf(szTemp, ARRAYSIZE(szTemp), TEXT("%lu"), dw);

    GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszBuffer, cbBuffer);
    return pszBuffer;
}


const short s_rgidsOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB, IDS_ORDERGB, IDS_ORDERTB};

// REARCHITECT This is in the shell too, isn't it?

/*----------------------------------------------------------
Purpose: Converts a number into a short, string format.

This code was taken from the shell.

532     -> 523 bytes
1340    -> 1.3KB
23506   -> 23.5KB
-> 2.4MB
-> 5.2GB

Returns: pointer to buffer
Cond:    --
 */
LPTSTR PRIVATE ShortSizeFormat64(
        __int64 dw64,
        LPTSTR pszBuf,
        UINT cchMax)
{
    int i;
    UINT wInt, wLen, wDec;
    TCHAR szTemp[10], szOrder[20], szFormat[5];

    if (dw64 < 1000)
    {
        wnsprintf(szTemp, ARRAYSIZE(szTemp), TEXT("%d"), LODWORD(dw64));
        i = 0;
        goto AddOrder;
    }

    for (i = 1; i<ARRAYSIZE(s_rgidsOrders)-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
    /* do nothing */

    wInt = LODWORD(dw64 >> 10);
    BrfAddCommas(wInt, szTemp, ARRAYSIZE(szTemp));
    wLen = lstrlen(szTemp);
    if (wLen < 3)
    {
        wDec = LODWORD(dw64 - (__int64)wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
        lstrcpyn(szFormat, TEXT("%02d"), ARRAYSIZE(szFormat));

        szFormat[2] = TEXT('0') + 3 - wLen;
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                szTemp+wLen, ARRAYSIZE(szTemp)-wLen);
        wLen = lstrlen(szTemp);
        wLen += wnsprintf(szTemp+wLen, ARRAYSIZE(szTemp) - wLen, szFormat, wDec);
    }

AddOrder:
    LoadString(g_hinst, s_rgidsOrders[i], szOrder, ARRAYSIZE(szOrder));
    wnsprintf(pszBuf, cchMax, szOrder, (LPTSTR)szTemp);

    return pszBuf;
}



/*----------------------------------------------------------
Purpose: Converts a number into a short, string format.

This code was taken from the shell.

532     -> 523 bytes
1340    -> 1.3KB
23506   -> 23.5KB
-> 2.4MB
-> 5.2GB

Returns: pointer to buffer
Cond:    --
 */
LPTSTR PRIVATE ShortSizeFormatPriv(DWORD dw, LPTSTR pszBuf, int cchMax)
{
    return(ShortSizeFormat64((__int64)dw, pszBuf, cchMax));
}

/*----------------------------------------------------------
Purpose: Gets the file info given a path.  If the path refers
to a directory, then simply the path field is filled.

If himl != NULL, then the function will add the file's
image to the provided image list and set the image index
field in the *ppfi.

Returns: standard hresult
Cond:    --
 */
HRESULT PUBLIC FICreate(
        LPCTSTR pszPath,
        FileInfo ** ppfi,
        UINT uFlags)
{
    HRESULT hres = ResultFromScode(E_OUTOFMEMORY);
    int cchPath;
    SHFILEINFO sfi;
    UINT uInfoFlags = SHGFI_DISPLAYNAME | SHGFI_ATTRIBUTES;
    DWORD dwAttr;

    ASSERT(pszPath);
    ASSERT(ppfi);

    // Get shell file info
    if (IsFlagSet(uFlags, FIF_ICON))
        uInfoFlags |= SHGFI_ICON;
    if (IsFlagSet(uFlags, FIF_DONTTOUCH))
    {
        uInfoFlags |= SHGFI_USEFILEATTRIBUTES;

        // Today, FICreate is not called for folders, so this is ifdef'd out
#ifdef SUPPORT_FOLDERS
        dwAttr = IsFlagSet(uFlags, FIF_FOLDER) ? FILE_ATTRIBUTE_DIRECTORY : 0;
#else
        dwAttr = 0;
#endif
    }
    else
        dwAttr = 0;

    if (SHGetFileInfo(pszPath, dwAttr, &sfi, sizeof(sfi), uInfoFlags))
    {
        // Allocate enough for the structure, plus buffer for the fully qualified
        // path and buffer for the display name (and extra null terminator).
        cchPath = lstrlen(pszPath);

        *ppfi = GAlloc(sizeof(FileInfo) +
                (cchPath+1) * sizeof(TCHAR) -
                sizeof((*ppfi)->szPath) +
                (lstrlen(sfi.szDisplayName)+1) * sizeof(TCHAR));
        if (*ppfi)
        {
            FileInfo * pfi = *ppfi;

            // lstrcpy:  Enough memory is allocated above so no need for
            // bounded copy
            pfi->pszDisplayName = pfi->szPath+cchPath+1;
            lstrcpy(pfi->pszDisplayName, sfi.szDisplayName);

            if (IsFlagSet(uFlags, FIF_ICON))
                pfi->hicon = sfi.hIcon;

            pfi->dwAttributes = sfi.dwAttributes;

            // Does the path refer to a directory?
            if (FIIsFolder(pfi))
            {
                // Yes; just fill in the path field
                lstrcpy(pfi->szPath, pszPath);
                hres = NOERROR;
            }
            else
            {
                // No; assume the file exists?
                if (IsFlagClear(uFlags, FIF_DONTTOUCH))
                {
                    // Yes; get the time, date and size of the file
                    HANDLE hfile = CreateFile(pszPath, GENERIC_READ, 
                            FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                            NULL);

                    if (hfile == INVALID_HANDLE_VALUE)
                    {
                        GFree(*ppfi);
                        hres = ResultFromScode(E_HANDLE);
                    }
                    else
                    {
                        hres = NOERROR;

                        lstrcpy(pfi->szPath, pszPath);
                        pfi->dwSize = GetFileSize(hfile, NULL);
                        GetFileTime(hfile, NULL, NULL, &pfi->ftMod);
                        CloseHandle(hfile);
                    }
                }
                else
                {
                    // No; use what we have
                    hres = NOERROR;
                    lstrcpy(pfi->szPath, pszPath);
                }
            }
        }
    }
    else if (!PathExists(pszPath))
    {
        // Differentiate between out of memory and file not found
        hres = E_FAIL;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Get some file info of the given path.
The returned string is of the format "# bytes <date>"

If the path is a folder, the string is empty.

Returns: FALSE if path is not found
Cond:    --
 */
BOOL PUBLIC FIGetInfoString(
        FileInfo * pfi,
        LPTSTR pszBuf,
        int cchBuf)
{
    BOOL bRet;

    ASSERT(pfi);
    ASSERT(pszBuf);

    *pszBuf = NULL_CHAR;

    if (pfi)
    {
        // Is this a file?
        if ( !FIIsFolder(pfi) )
        {
            // Yes
            TCHAR szSize[MAXMEDLEN];
            TCHAR szDate[MAXMEDLEN];
            TCHAR szTime[MAXMEDLEN];
            LPTSTR pszMsg;
            SYSTEMTIME st;
            FILETIME ftLocal;

            // Construct the string
            FileTimeToLocalFileTime(&pfi->ftMod, &ftLocal);
            FileTimeToSystemTime(&ftLocal, &st);
            GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE, &st, NULL, szDate, ARRAYSIZE(szDate));
            GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, szTime, ARRAYSIZE(szTime));

            if (ConstructMessage(&pszMsg, g_hinst, MAKEINTRESOURCE(IDS_DATESIZELINE),
                        ShortSizeFormatPriv(FIGetSize(pfi), szSize, ARRAYSIZE(szSize)), szDate, szTime))
            {
                lstrcpyn(pszBuf, pszMsg, cchBuf);
                GFree(pszMsg);
            }
            else
                *pszBuf = 0;

            bRet = TRUE;
        }
        else
            bRet = FALSE;
    }
    else
        bRet = FALSE;

    return bRet;
}


/*----------------------------------------------------------
Purpose: Set the path entry.  This can move the pfi.

Returns: FALSE on out of memory
Cond:    --
 */
BOOL PUBLIC FISetPath(
        FileInfo ** ppfi,
        LPCTSTR pszPathNew,
        UINT uFlags)
{
    ASSERT(ppfi);
    ASSERT(pszPathNew);

    FIFree(*ppfi);

    return SUCCEEDED(FICreate(pszPathNew, ppfi, uFlags));
}


/*----------------------------------------------------------
Purpose: Free our file info struct
Returns: --
Cond:    --
 */
void PUBLIC FIFree(
        FileInfo * pfi)
{
    if (pfi)
    {
        if (pfi->hicon)
            DestroyIcon(pfi->hicon);

        GFree(pfi);     // This macro already checks for NULL pfi condition
    }
}


/*----------------------------------------------------------
Purpose: Convert FILETIME struct to a readable string

Returns: String
Cond:    --
 */
void PUBLIC FileTimeToDateTimeString(
        LPFILETIME pft,
        LPTSTR pszBuf,
        int cchBuf)
{
    SYSTEMTIME st;
    FILETIME ftLocal;

    FileTimeToLocalFileTime(pft, &ftLocal);
    FileTimeToSystemTime(&ftLocal, &st);

    // REARCHITECT: how do you know date comes before time???
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, pszBuf, cchBuf/2);
    pszBuf += lstrlen(pszBuf);
    *pszBuf++ = TEXT(' ');
    GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, pszBuf, cchBuf/2);
}


/*----------------------------------------------------------
Purpose: Copies psz into *ppszBuf.  Will alloc or realloc *ppszBuf
accordingly.

Returns: TRUE on success
Cond:    --
 */
BOOL PUBLIC GSetString(
        LPTSTR * ppszBuf,
        LPCTSTR psz)
{
    BOOL bRet = FALSE;
    DWORD cb;

    ASSERT(ppszBuf);
    ASSERT(psz);

    cb = CbFromCch(lstrlen(psz)+CCH_NUL);

    if (*ppszBuf)
    {
        // Need to reallocate?
        if (cb > GGetSize(*ppszBuf))
        {
            // Yes
            LPTSTR pszT = GReAlloc(*ppszBuf, cb);
            if (pszT)
            {
                *ppszBuf = pszT;
                bRet = TRUE;
            }
        }
        else
        {
            // No
            bRet = TRUE;
        }
    }
    else
    {
        *ppszBuf = (LPTSTR)GAlloc(cb);
        if (*ppszBuf)
        {
            bRet = TRUE;
        }
    }

    if (bRet)
    {
        ASSERT(*ppszBuf);
        // lstrcpy:  Enough memory is allocated above so no need for bounded copy
        lstrcpy(*ppszBuf, psz);
    }
    return bRet;
}


/*----------------------------------------------------------
Purpose: Concatenates psz onto *ppszBuf.  Will alloc or realloc *ppszBuf
accordingly.

Returns: TRUE on success
Cond:    --
 */
BOOL PUBLIC GCatString(
        LPTSTR * ppszBuf,
        LPCTSTR psz)
{
    BOOL bRet = FALSE;
    DWORD cb;

    ASSERT(ppszBuf);
    ASSERT(psz);

    cb = CbFromCch(lstrlen(psz)+CCH_NUL);

    if (*ppszBuf)
    {
        // (Don't need to count nul because it is already counted in cb)
        DWORD cbExisting = CbFromCch(lstrlen(*ppszBuf));

        // Need to reallocate?
        if ((cb+cbExisting) > GGetSize(*ppszBuf))
        {
            // Yes; realloc at least MAXBUFLEN to cut down on the amount
            // of calls in the future
            LPTSTR pszT = GReAlloc(*ppszBuf, cbExisting+max(cb, MAXBUFLEN));
            if (pszT)
            {
                *ppszBuf = pszT;
                bRet = TRUE;
            }
        }
        else
        {
            // No
            bRet = TRUE;
        }
    }
    else
    {
        *ppszBuf = (LPTSTR)GAlloc(max(cb, MAXBUFLEN));
        if (*ppszBuf)
        {
            bRet = TRUE;
        }
    }

    if (bRet)
    {
        ASSERT(*ppszBuf);
        StrCatBuff(*ppszBuf, psz, (int)GGetSize(*ppszBuf)/SIZEOF(TCHAR));
    }
    return bRet;
}


/*----------------------------------------------------------
Purpose: Waits for on object to signal.  This function "does
the right thing" to prevent deadlocks which can occur
because the calculation thread calls SendMessage.

Returns: value of MsgWaitForMultipleObjects
Cond:    --
 */
DWORD PUBLIC MsgWaitObjectsSendMessage(
        DWORD cObjects,
        LPHANDLE phObjects,
        DWORD dwTimeout)
{
    DWORD dwRet;

    while (TRUE)
    {
        dwRet = MsgWaitForMultipleObjects(cObjects, phObjects, FALSE,
                dwTimeout, QS_SENDMESSAGE);

        // If it is not a message, return
        if ((WAIT_OBJECT_0 + cObjects) != dwRet)
        {
            return dwRet;
        }
        else
        {
            // Process all the sent messages
            MSG msg;
            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
        }
    }
}


/*----------------------------------------------------------
Purpose: Call this if PeekMessage is going to be called during
an expensive operation and a new window has (or is)
appeared.

Details: simply calling SetCursor to change the cursor
to an hourglass, then calling an expensive operation
which will call PeekMessage, will result in the cursor
changing back prematurely.  The reason is because SetCursorPos
inserts a fake WM_MOUSEMOVE to set the cursor to the
window class when a window appears for the first time.
Since PeekMessage is processing this message, the cursor
gets changed to the window class cursor.

The trick is to remove the WM_MOUSEMOVE messages from
the queue.

Returns: Previous cursor
Cond:    --
 */
HCURSOR PUBLIC SetCursorRemoveWigglies(
        HCURSOR hcur)
{
    MSG msg;

    // Remove any mouse moves
    while (PeekMessage(&msg, NULL, WM_MOUSEMOVE, WM_MOUSEMOVE, PM_REMOVE))
        ;

    return SetCursor(hcur);
}


/*----------------------------------------------------------
Purpose: Load the string (if necessary) and format the string
properly.

Returns: A pointer to the allocated string containing the formatted
message or
NULL if out of memory

Cond:    --
 */
LPTSTR PUBLIC _ConstructMessageString(
        HINSTANCE hinst,
        LPCTSTR pszMsg,
        va_list *ArgList)
{
    TCHAR szTemp[MAXBUFLEN];
    LPTSTR pszRet;
    LPTSTR pszRes;

    if (HIWORD(pszMsg))
        pszRes = (LPTSTR)pszMsg;
    else if (LOWORD(pszMsg) && LoadString(hinst, LOWORD(pszMsg), szTemp, ARRAYSIZE(szTemp)))
        pszRes = szTemp;
    else
        pszRes = NULL;

    if (pszRes)
    {
        if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                    pszRes, 0, 0, (LPTSTR)&pszRet, 0, ArgList))
        {
            pszRet = NULL;
        }
    }
    else
    {
        // Bad parameter
        pszRet = NULL;
    }

    return pszRet;      // free with LocalFree()
}


/*----------------------------------------------------------
Purpose: Constructs a formatted string.  The returned string
must be freed using GFree().

Returns: TRUE on success
Cond:    --
 */
BOOL PUBLIC ConstructMessage(
        LPTSTR * ppsz,
        HINSTANCE hinst,
        LPCTSTR pszMsg, ...)
{
    BOOL bRet;
    LPTSTR pszRet;
    va_list ArgList;

    va_start(ArgList, pszMsg);

    pszRet = _ConstructMessageString(hinst, pszMsg, &ArgList);

    va_end(ArgList);

    *ppsz = NULL;

    if (pszRet)
    {
        bRet = GSetString(ppsz, pszRet);
        LocalFree(pszRet);
    }
    else
        bRet = FALSE;

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\cpath.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cpath.c
//
//  This files contains code for the cached briefcase paths.
//
// History:
//  01-31-94 ScottH     Created
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers

CACHE g_cacheCPATH = {0, 0, 0};       // Briefcase path cache

#define CPATH_EnterCS()    EnterCriticalSection(&g_cacheCPATH.cs)
#define CPATH_LeaveCS()    LeaveCriticalSection(&g_cacheCPATH.cs)



#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Dumps a CPATH entry
Returns: 
Cond:    --
 */
void PRIVATE CPATH_DumpEntry(
        CPATH  * pcpath)
{
    ASSERT(pcpath);

    TRACE_MSG(TF_ALWAYS, TEXT("CPATH:  Atom %d: %s"), pcpath->atomPath, Atom_GetName(pcpath->atomPath));
    TRACE_MSG(TF_ALWAYS, TEXT("               Ref [%u]  "), 
            Cache_GetRefCount(&g_cacheCPATH, pcpath->atomPath));
}


/*----------------------------------------------------------
Purpose: Dumps all CPATH cache
Returns: 
Cond:    --
 */
void PUBLIC CPATH_DumpAll()
{
    CPATH  * pcpath;
    int atom;
    BOOL bDump;

    ENTEREXCLUSIVE()
    {
        bDump = IsFlagSet(g_uDumpFlags, DF_CPATH);
    }
    LEAVEEXCLUSIVE()

        if (!bDump)
            return ;

    atom = Cache_FindFirstKey(&g_cacheCPATH);
    while (atom != ATOM_ERR)
    {
        pcpath = Cache_GetPtr(&g_cacheCPATH, atom);
        ASSERT(pcpath);
        if (pcpath)
        {
            CPATH_DumpEntry(pcpath);
            Cache_DeleteItem(&g_cacheCPATH, atom, FALSE, NULL, CPATH_Free);    // Decrement count
        }

        atom = Cache_FindNextKey(&g_cacheCPATH, atom);
    }
}
#endif


/*----------------------------------------------------------
Purpose: Release the volume ID handle
Returns: --

Cond:    hwndOwner is not used.

This function is serialized by the caller (Cache_Term or
Cache_DeleteItem).
 */
void CALLBACK CPATH_Free(
        LPVOID lpv,
        HWND hwndOwner)
{
    CPATH  * pcpath = (CPATH  *)lpv;

    DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CPATH   Freeing Briefcase path %s"), Atom_GetName(pcpath->atomPath)); )

        // Delete the atom one extra time, because we explicitly added
        // it for this cache.
        Atom_Delete(pcpath->atomPath);

    SharedFree(&pcpath);
}


/*----------------------------------------------------------
Purpose: Add the atomPath to the cache.  
If atomPath is already in the cache, we replace it
with a newly obtained path.

Returns: Pointer to CPATH
NULL on OOM

Cond:    --
 */
CPATH  * PUBLIC CPATH_Replace(
        int atomPath)
{
    CPATH  * pcpath;
    BOOL bJustAllocd;

    CPATH_EnterCS();
    {
        pcpath = Cache_GetPtr(&g_cacheCPATH, atomPath);
        if (pcpath)
            bJustAllocd = FALSE;
        else
        {
            // Allocate using commctrl's Alloc, so the structure will be in
            // shared heap space across processes.
            pcpath = SharedAllocType(CPATH);
            bJustAllocd = TRUE;
        }

        if (pcpath)
        {
            LPCTSTR pszPath = Atom_GetName(atomPath);

            ASSERT(pszPath);

            DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CPATH  Adding known Briefcase %s"), pszPath); )

                pcpath->atomPath = atomPath;

            if (bJustAllocd)
            {
                if (!Cache_AddItem(&g_cacheCPATH, atomPath, (LPVOID)pcpath))
                {
                    // Cache_AddItem failed here
                    //
                    SharedFree(&pcpath);
                }
            }
            else
                Cache_DeleteItem(&g_cacheCPATH, atomPath, FALSE, NULL, CPATH_Free);    // Decrement count
        }
    }
    CPATH_LeaveCS();

    return pcpath;
}


/*----------------------------------------------------------
Purpose: Search for the given path in the cache.  If the path
exists, its locality will be returned.

If it is not found, its locality is not known (but
PL_FALSE is returned).

Returns: path locality (PL_) value
Cond:    --
 */
UINT PUBLIC CPATH_GetLocality(
        LPCTSTR pszPath,
        LPTSTR pszBuf,           // Can be NULL, or must be of size MAXPATHLEN
        int cchMax)              // Can be NULL, or must be MAXPATHLEN
{
    UINT uRet = PL_FALSE;
    LPCTSTR pszBrf;
    int atom;

    ASSERT(pszPath);

    CPATH_EnterCS();
    {
        atom = Cache_FindFirstKey(&g_cacheCPATH);
        while (atom != ATOM_ERR)
        {
            pszBrf = Atom_GetName(atom);

            ASSERT(pszBrf);

            if (IsSzEqual(pszBrf, pszPath))
            {
                uRet = PL_ROOT;
                break;
            }
            else if (PathIsPrefix(pszBrf, pszPath))
            {
                uRet = PL_INSIDE;
                break;
            }

            atom = Cache_FindNextKey(&g_cacheCPATH, atom);
        }

        if (uRet != PL_FALSE && pszBuf)
            lstrcpyn(pszBuf, pszBrf, cchMax);
    }
    CPATH_LeaveCS();

    return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\crl.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: crl.c
//
//  This files contains code for the cached reclists
//
// History:
//  09-02-93 ScottH     Created
//  01-31-94 ScottH     Moved from cache.c
//
//---------------------------------------------------------------------------

#include "brfprv.h"         // common headers
#include "recact.h"

#include "res.h"

#define CRL_Iterate(atom)       \
for (atom = Cache_FindFirstKey(&g_cacheCRL);        \
        ATOM_ERR != atom;                               \
        atom = Cache_FindNextKey(&g_cacheCRL, atom))

    CACHE g_cacheCRL = {0, 0, 0};        // Reclist cache

#define CRL_EnterCS()    EnterCriticalSection(&g_cacheCRL.cs)
#define CRL_LeaveCS()    LeaveCriticalSection(&g_cacheCRL.cs)


#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Dump a CRL entry
Returns: --
Cond:    --
 */
void PRIVATE CRL_DumpEntry(
        CRL  * pcrl)
{
    TCHAR sz[MAXBUFLEN];

    ASSERT(pcrl);

    TRACE_MSG(TF_ALWAYS, TEXT("CRL:  Atom %d: %s"), pcrl->atomPath, Atom_GetName(pcrl->atomPath));
    TRACE_MSG(TF_ALWAYS, TEXT("      Outside %d: %s"), pcrl->atomOutside, Atom_GetName(pcrl->atomOutside));
    TRACE_MSG(TF_ALWAYS, TEXT("               Ref [%u]  Use [%u]  %s  %s  %s  %s"), 
            Cache_GetRefCount(&g_cacheCRL, pcrl->atomPath),
            pcrl->ucUse,
            CRL_IsOrphan(pcrl) ? (LPCTSTR) TEXT("Orphan") : (LPCTSTR) TEXT(""),
            IsFlagSet(pcrl->uFlags, CRLF_DIRTY) ? (LPCTSTR) TEXT("Dirty") : (LPCTSTR) TEXT(""),
            IsFlagSet(pcrl->uFlags, CRLF_NUKE) ? (LPCTSTR) TEXT("Nuke") : (LPCTSTR) TEXT(""),
            CRL_IsSubfolderTwin(pcrl) ? (LPCTSTR) TEXT("SubfolderTwin") : (LPCTSTR) TEXT(""));
    TRACE_MSG(TF_ALWAYS, TEXT("               Status: %s"), SzFromIDS(pcrl->idsStatus, sz, ARRAYSIZE(sz)));
}


void PUBLIC CRL_DumpAll()
{
    CRL  * pcrl;
    int atom;
    BOOL bDump;

    ENTEREXCLUSIVE()
    {
        bDump = IsFlagSet(g_uDumpFlags, DF_CRL);
    }
    LEAVEEXCLUSIVE()

        if (!bDump)
            return ;

    CRL_Iterate(atom)
    {
        pcrl = Cache_GetPtr(&g_cacheCRL, atom);
        ASSERT(pcrl);
        if (pcrl)
        {
            CRL_DumpEntry(pcrl);
            Cache_DeleteItem(&g_cacheCRL, atom, FALSE, NULL, CRL_Free);    // Decrement count
        }
    }
}
#endif


/*----------------------------------------------------------
Purpose: Return the resource string ID describing the action to take
Returns: --
Cond:    --
 */
UINT PRIVATE IdsFromRAItem(
        LPRA_ITEM pitem)
{
    UINT ids;

    ASSERT(IsFlagSet(pitem->mask, RAIF_ACTION));

    switch (pitem->uAction)
    {
        case RAIA_TOOUT:
        case RAIA_TOIN:
        case RAIA_CONFLICT:
        case RAIA_DELETEOUT:
        case RAIA_DELETEIN:
        case RAIA_MERGE:
        case RAIA_SOMETHING:
            ids = IDS_STATE_NeedToUpdate;
            break;

        case RAIA_ORPHAN:
            ids = IDS_STATE_Orphan;
            break;

        case RAIA_DONTDELETE:
        case RAIA_SKIP:
            ASSERT(SI_UNAVAILABLE == pitem->siInside.uState ||
                    SI_UNAVAILABLE == pitem->siOutside.uState);
            if (SI_UNAVAILABLE == pitem->siOutside.uState)
            {
                if (SI_UNCHANGED == pitem->siInside.uState)
                {
                    ids = IDS_STATE_UptodateInBrf;
                }
                else if (SI_UNAVAILABLE != pitem->siInside.uState)
                {
                    ids = IDS_STATE_NeedToUpdate;
                }
                else
                {
                    ids = IDS_STATE_Unavailable;
                }
            }
            else
            {
                ASSERT(SI_UNAVAILABLE == pitem->siInside.uState);
                ids = IDS_STATE_Unavailable;
            }
            break;

        case RAIA_NOTHING:
            ids = IDS_STATE_Uptodate;
            break;

        default:
            ASSERT(0);
            ids = 0;
            break;
    }

    return ids;
}


/*----------------------------------------------------------
Purpose: Gets the outside sync copy and the resource ID to the
status string that indicates the status between the 
sync copies.

Returns: --
Cond:    --
 */
void PRIVATE SetPairInfo(
        PCRL pcrl)
{
    LPCTSTR pszPath = Atom_GetName(pcrl->atomPath);
    LPCTSTR pszName = PathFindFileName(pszPath);

    // Is this an orphan?
    if (CRL_IsOrphan(pcrl))
    {
        // Yes; special case: is this one of the briefcase system files?
        LPCTSTR pszDBName;

        if (IsFlagSet(pcrl->uFlags, CRLF_ISLFNDRIVE))
            pszDBName = g_szDBName;
        else
            pszDBName = g_szDBNameShort;

        if (IsSzEqual(pszName, pszDBName) || 
                IsSzEqual(pszName, c_szDesktopIni))
        {
            // Yes
            pcrl->idsStatus = IDS_STATE_SystemFile;
        }
        // Is this a subfolder twin?  (Only orphans are
        // candidates for being subfolder twins.)
        else if (CRL_IsSubfolderTwin(pcrl))
        {
            // Yes
            ASSERT(PathIsDirectory(pszPath));

            pcrl->idsStatus = IDS_STATE_Subfolder;
        }
        else
        {
            // No
            pcrl->idsStatus = IDS_STATE_Orphan;
        }

        if (Atom_IsValid(pcrl->atomOutside))
        {
            Atom_Delete(pcrl->atomOutside);     // delete the old one
        }
        pcrl->atomOutside = Atom_Add(TEXT(""));
    }
    else
    {
        // No; get the info for this sync copy
        HRESULT hres;
        LPRA_ITEM pitem;
        TCHAR sz[MAXPATHLEN];

        ASSERT(pcrl->lprl);

        hres = RAI_Create(&pitem, Atom_GetName(pcrl->atomBrf), pszPath, 
                pcrl->lprl, pcrl->lpftl);

        if (SUCCEEDED(hres))
        {
            lstrcpyn(sz, pitem->siOutside.pszDir, ARRAYSIZE(sz));

            // Is this a file?
            if ( !CRL_IsFolder(pcrl) )
            {
                // Yes; atomOutside needs to be a fully qualified path to
                // the outside file/folder--not just the parent folder.
                // That's why we tack on the filename here.
                PathAppend(sz, pszName);
            }

            if (Atom_IsValid(pcrl->atomOutside))
            {
                Atom_Delete(pcrl->atomOutside);     // delete the old one
            }

            pcrl->atomOutside = Atom_Add(sz);
            pcrl->idsStatus = IdsFromRAItem(pitem);
            RAI_Free(pitem);
        }
    }
}


/*----------------------------------------------------------
Purpose: Determines whether or not a subfolder of a briefcase 
is the root of a subtree twin.
Returns: --
Cond:    --
 */
BOOL PRIVATE IsSubtreeTwin(HBRFCASE hbrf, LPCTSTR pcszFolder)
{
    BOOL bIsSubtreeTwin = FALSE;
    PFOLDERTWINLIST pftl;

    ASSERT(PathIsDirectory(pcszFolder));

    /* Create a folder twin list for the folder. */

    if (Sync_CreateFolderList(hbrf, pcszFolder, &pftl) == TR_SUCCESS)
    {
        PCFOLDERTWIN pcft;

        /*
         * Look through the folder twin list for any folder twins with the
         * FT_FL_SUBTREE flag set.
         */

        for (pcft = pftl->pcftFirst; pcft; pcft = pcft->pcftNext)
        {
            if (pcft->dwFlags & FT_FL_SUBTREE)
            {
                bIsSubtreeTwin = TRUE;
                break;
            }
        }

        Sync_DestroyFolderList(pftl);
    }

    return(bIsSubtreeTwin);
}


/*----------------------------------------------------------
Purpose: Determines whether or not a path is a subfolder of a subtree twin in a
briefcase.
Returns: --
Cond:    --
 */
BOOL PUBLIC IsSubfolderTwin(HBRFCASE hbrf, LPCTSTR pcszPath)
{
    BOOL bIsSubfolderTwin = FALSE;
    TCHAR szBrfRoot[MAXPATHLEN];

    if (PathIsDirectory(pcszPath) &&
            PathGetLocality(pcszPath, szBrfRoot, ARRAYSIZE(szBrfRoot)) == PL_INSIDE)
    {
        int ncchBrfRootLen;
        TCHAR szParent[MAXPATHLEN];

        ASSERT(PathIsPrefix(szBrfRoot, pcszPath));

        ncchBrfRootLen = lstrlen(szBrfRoot);

        ASSERT(lstrlen(pcszPath) < ARRAYSIZE(szParent));
        lstrcpyn(szParent, pcszPath, ARRAYSIZE(szParent));

        /*
         * Keep whacking off the last path component until we find a parent
         * subtree twin root, or we hit the briefcase root.
         */

        while (! bIsSubfolderTwin &&
                PathRemoveFileSpec(szParent) &&
                lstrlen(szParent) > ncchBrfRootLen)
        {
            BOOL bIsFolderTwin;

            if (Sync_IsFolder(hbrf, szParent, &bIsFolderTwin) == TR_SUCCESS &&
                    bIsFolderTwin)
            {
                bIsSubfolderTwin = IsSubtreeTwin(hbrf, szParent);

#ifdef DEBUG
                TRACE_MSG(TF_CACHE, TEXT("CACHE  Found subfolder twin %s with parent subtree twin root %s."),
                        pcszPath,
                        szParent);
#endif
            }
        }
    }

    return(bIsSubfolderTwin);
}


/*----------------------------------------------------------
Purpose: Sets the bSubfolderTwin member of a CRL.
Returns: --
Cond:    The lprl and lpftl members of the CRL must be filled in before calling
this function.
 */
void PRIVATE SetSubfolderTwinFlag(PCRL pcrl)
{
    if (! pcrl->lprl && ! pcrl->lpftl)
    {
        if (IsSubfolderTwin(pcrl->hbrf, Atom_GetName(pcrl->atomPath)))
            SetFlag(pcrl->uFlags, CRLF_SUBFOLDERTWIN);
        else
            ClearFlag(pcrl->uFlags, CRLF_SUBFOLDERTWIN);
    }
    else
    {
        ClearFlag(pcrl->uFlags, CRLF_SUBFOLDERTWIN);
    }
}


/*----------------------------------------------------------
Purpose: Free the reclist
Returns: --

Cond:    hwndOwner is not used, so it is okay for all CRL_ routines
to pass NULL as hwndOwner.

This function is serialized by the caller (Cache_Term or
Cache_DeleteItem).
 */
void CALLBACK CRL_Free(
        LPVOID lpv,
        HWND hwndOwner)
{
    CRL  * pcrl = (CRL  *)lpv;

    ASSERT(Sync_IsEngineLoaded());

    DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Destroying CRL for %s (0x%lx)"), 
                Atom_GetName(pcrl->atomPath), pcrl->hbrf); )

        if (Atom_IsValid(pcrl->atomOutside))
            Atom_Delete(pcrl->atomOutside);

    if (Atom_IsValid(pcrl->atomBrf))
        Atom_Delete(pcrl->atomBrf);

    if (pcrl->lprl)
        Sync_DestroyRecList(pcrl->lprl);

    if (pcrl->lpftl)
        Sync_DestroyFolderList(pcrl->lpftl);

    // The CRL does not own pabortevt, leave it alone

    SharedFree(&pcrl);
}


/*----------------------------------------------------------
Purpose: Create a reclist and (optional) folder twin list for a path.

Returns: standard result
S_OK if the item is a twin
S_FALSE if the item is an orphan

Cond:    --
 */
HRESULT PRIVATE CreatePathLists(
        HBRFCASE hbrf,
        PABORTEVT pabortevt,
        int atomPath,
        PRECLIST  * lplprl,
        PFOLDERTWINLIST  * lplpftl)
{
    HRESULT hres;
    LPCTSTR pszPath = Atom_GetName(atomPath);

    ASSERT(pszPath);
    ASSERT(hbrf);
    ASSERT(lplprl);
    ASSERT(lplpftl);

    *lplprl = NULL;
    *lplpftl = NULL;

    // Two routes.  
    //
    //  1) If the path is to the root of a briefcase,
    //     create a complete reclist.
    //
    //  2) Otherwise create a reclist for the individual file or folder
    //
    // Hack: a quick way of telling if atomPath is a briefcase
    // root is by looking for it in the CBS cache.

    // Is this the root of a briefcase?
    if (CBS_Get(atomPath))
    {
        // Yes
        CBS_Delete(atomPath, NULL);       // Decrement count
        hres = Sync_CreateCompleteRecList(hbrf, pabortevt, lplprl);
    }
    else
    {
        // No; is this a twin?
        hres = Sync_IsTwin(hbrf, pszPath, 0);
        if (S_OK == hres)
        {
            // Yes; create a reclist (and an optional folder twin list).
            HTWINLIST htl;

            hres = E_OUTOFMEMORY;   // assume error

            if (Sync_CreateTwinList(hbrf, &htl) == TR_SUCCESS)
            {
                if (Sync_AddPathToTwinList(hbrf, htl, pszPath, lplpftl))
                {
                    hres = Sync_CreateRecListEx(htl, pabortevt, lplprl);

                    if (SUCCEEDED(hres))
                    {
                        // The object may have been implicitly deleted
                        // in CreateRecList.  Check again.
                        hres = Sync_IsTwin(hbrf, pszPath, 0);
                    }
                }
                Sync_DestroyTwinList(htl);
            }
        }
    }

    if (FAILED(hres))
    {
        // Cleanup on failure
        //
        if (*lplpftl)
            Sync_DestroyFolderList(*lplpftl);

        *lplprl = NULL;
        *lplpftl = NULL;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Add a CRL entry for the atomPath to the cache.  This 
consists of creating the reclist (and folder twin list 
possibly).

If the atomPath is already in the cache, this function
increments the reference count of the item and calls
CRL_Replace.

Returns: standard result

Cond:    Must call CRL_Delete for every call to this function.

IMPORTANT: Some portions of code call PathIsDirectory,
which will fail if atomPath does not exist.

 */
HRESULT PUBLIC CRL_Add(
        PCBS pcbs,
        int atomPath)
{
    HRESULT hres = E_OUTOFMEMORY;
    PRECLIST lprl = NULL;
    PFOLDERTWINLIST lpftl = NULL;
    CRL  * pcrl;

    ASSERT(pcbs);

    CRL_EnterCS();
    {
        // Caller wants to add.  If it already exists, we simply return
        //  the existing entry.
        //
        // This CRL_Get increments the count (if it succeeds)
        pcrl = Cache_GetPtr(&g_cacheCRL, atomPath);

        // Is the item in the cache?
        if (pcrl)
        {
            // Yes; attempt to get fresh contents
            hres = CRL_Replace(atomPath);
        }
        else
        {
            // No; the entry is not in the cache.  Add it.
            LPCTSTR pszPath = Atom_GetName(atomPath);

            ASSERT(pszPath);

            DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Adding CRL for %s (0x%lx)"), 
                        pszPath, pcbs->hbrf); )

                // Leave the critical section while we do expensive calculation
                CRL_LeaveCS();
            {
                hres = CreatePathLists(pcbs->hbrf, pcbs->pabortevt,
                        atomPath, &lprl, &lpftl);
            }
            CRL_EnterCS();

            if (FAILED(hres))
                goto Fail;
            else
            {
                LPCTSTR pszBrf;

                // Allocate using commctrl's Alloc, so the structure will be in
                // shared heap space across processes.
                pcrl = SharedAllocType(CRL);
                if (!pcrl)
                {
                    hres = E_OUTOFMEMORY;
                    goto Fail;
                }

                pcrl->atomPath = atomPath;

                pcrl->hbrf = pcbs->hbrf;

                pszBrf = Atom_GetName(pcbs->atomBrf);
                pcrl->atomBrf = Atom_Add(pszBrf);

                pcrl->pabortevt = pcbs->pabortevt;
                pcrl->lpftl = lpftl;
                pcrl->lprl = lprl;
                pcrl->ucUse = 0;

                pcrl->uFlags = 0;       // reset
                SetSubfolderTwinFlag(pcrl);
                if (S_FALSE == hres)
                    SetFlag(pcrl->uFlags, CRLF_ORPHAN);

                if (PathIsDirectory(Atom_GetName(atomPath)))
                    SetFlag(pcrl->uFlags, CRLF_ISFOLDER);

                if (IsFlagSet(pcbs->uFlags, CBSF_LFNDRIVE))
                    SetFlag(pcrl->uFlags, CRLF_ISLFNDRIVE);

                SetPairInfo(pcrl);

                // This Cache_AddItem does the increment count
                if ( !Cache_AddItem(&g_cacheCRL, atomPath, (LPVOID)pcrl) )
                {
                    // Failed
                    Atom_Delete(pcrl->atomBrf);
                    Atom_Delete(pcrl->atomOutside);
                    hres = E_OUTOFMEMORY;
                    goto Fail;
                }
            }
        }
    }
    CRL_LeaveCS();

    return hres;

Fail:
    // Cleanup on failure
    //
    if (lprl)
        Sync_DestroyRecList(lprl);
    if (lpftl)
        Sync_DestroyFolderList(lpftl);
    SharedFree(&pcrl);
    CRL_LeaveCS();

    DEBUG_MSG(TF_ERROR, TEXT("SyncUI   CRL_Add failed!"));
    return hres;
}


/*----------------------------------------------------------
Purpose: Decrement the reference count and the use count to 
the reclist cache entry.

If the reference count == 0, the entry is deleted.

Returns: --
Cond:    --
 */
void PUBLIC CRL_Delete(
        int atomPath)
{
    CRL  * pcrl;

    CRL_EnterCS();
    {
        // Decrement the use count
        //
        pcrl = Cache_GetPtr(&g_cacheCRL, atomPath);
        if (pcrl)
        {
            DEBUG_CODE( LPCTSTR pszPath = Atom_GetName(atomPath); )

                if (pcrl->ucUse > 0)
                    pcrl->ucUse--;

            if (IsFlagSet(pcrl->uFlags, CRLF_NUKE))
            {
                if (pcrl->ucUse == 0)
                {
                    DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Nuking late CRL %s..."), 
                                pszPath); )

                        // A nuke was deferred.  Now we can really do it.
                        //
                        Cache_DeleteItem(&g_cacheCRL, atomPath, TRUE, NULL, CRL_Free);
                    goto Done;
                }
#ifdef DEBUG
                else
                {
                    TRACE_MSG(TF_CACHE, TEXT("CACHE  Deferring nuke CRL %s..."), 
                            pszPath);
                }
#endif
            }
            Cache_DeleteItem(&g_cacheCRL, atomPath, FALSE, NULL, CRL_Free);    // Decrement for Cache_GetPtr

            // The real delete...
            Cache_DeleteItem(&g_cacheCRL, atomPath, FALSE, NULL, CRL_Free);
        }
Done:;
    }
    CRL_LeaveCS();
}


/*----------------------------------------------------------
Purpose: Nuke the cache entry if the use count is 0.  Otherwise,
set the nuke bit, and this entry will get nuked on the
next CRL_Get when the use count is 0.

Returns: --
Cond:    --
 */
void PUBLIC CRL_Nuke(
        int atomPath)
{
    CRL  * pcrl;

    CRL_EnterCS();
    {
        // Check the use count
        //
        pcrl = Cache_GetPtr(&g_cacheCRL, atomPath);
        if (pcrl)
        {
            if (pcrl->ucUse > 0)
            {
                DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Marking to nuke CRL for %s (0x%lx)"), 
                            Atom_GetName(atomPath), pcrl->hbrf); )

                    SetFlag(pcrl->uFlags, CRLF_NUKE);
                Cache_DeleteItem(&g_cacheCRL, atomPath, FALSE, NULL, CRL_Free);    // Decrement for Cache_GetPtr
            }
            else
            {
                DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Nuking CRL for %s (0x%lx)"), 
                            Atom_GetName(atomPath), pcrl->hbrf); )

                    Cache_DeleteItem(&g_cacheCRL, atomPath, TRUE, NULL, CRL_Free);
            }
        }
    }
    CRL_LeaveCS();
}


/*----------------------------------------------------------
Purpose: Replace the atomPath in the cache.  This consists of 
creating the reclist (and folder twin list possibly)
and replacing the contents of pcrl.  

The pcrl pointer remains unchanged.

The reference and use-counts remain unchanged.

Returns: standard result 

Cond:    
IMPORTANT: Some portions of code call PathIsDirectory,
which will fail if atomPath does not exist.

 */
HRESULT PUBLIC CRL_Replace(
        int atomPath)
{
    HRESULT hres;
    CRL * pcrl;

    CRL_EnterCS();
    {
        pcrl = Cache_GetPtr(&g_cacheCRL, atomPath);

        // Does the item exist?
        if (pcrl)
        {
            DEBUG_CODE( LPCTSTR pszPath = Atom_GetName(atomPath); )
                ASSERT(pszPath);
            DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Replacing CRL for %s (0x%lx)"), 
                        pszPath, pcrl->hbrf); )

                // Yes; mark it dirty and call CRL_Get on it.
                SetFlag(pcrl->uFlags, CRLF_DIRTY);

            // Note: pay attention to the difference between Cache_Delete
            //  and CRL_Delete.  Cache_Delete must match Cache_Add/Get and
            //  CRL_Delete must match CRL_Add/Get.
            //
            Cache_DeleteItem(&g_cacheCRL, atomPath, FALSE, NULL, CRL_Free);    // Decrement count for Cache_GetPtr

            hres = CRL_Get(atomPath, &pcrl);  // This does the replace

            CRL_Delete(atomPath);             // Decrement count for CRL_Get
        }
        else
        {
            hres = E_FAIL;
        }
    }
    CRL_LeaveCS();

    return hres;
}


/*----------------------------------------------------------
Purpose: Get the reclist from the cache.  If the cache item exists
and is marked dirty and the use count is 0, then recreate 
the reclist.

If the nuke bit is set, then the entry is nuked and this
function returns NULL.

Returns: standard result
Ptr to cache entry.  

Cond:    Must call CRL_Delete for every call to CRL_Get

IMPORTANT: Some portions of code call PathIsDirectory,
which will fail if atomPath does not exist.

 */
HRESULT PUBLIC CRL_Get(
        int atomPath,
        PCRL * ppcrl)
{
    HRESULT hres;
    PCRL pcrl;
    PRECLIST lprl = NULL;
    PFOLDERTWINLIST lpftl = NULL;

    CRL_EnterCS();
    {
        // Don't need to decrement the reference count in this 
        //  function -- this is Get!
        //
        pcrl = Cache_GetPtr(&g_cacheCRL, atomPath);     
        if (pcrl)
        {
            HBRFCASE hbrf = pcrl->hbrf;

            // Is this item pending a nuke?
            if (IsFlagSet(pcrl->uFlags, CRLF_NUKE))
            {
                // Yes; return NULL as if it were already nuked.
                DEBUG_CODE( LPCTSTR pszPath = Atom_GetName(atomPath); )

                    DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Attempt to get deferred nuke CRL %s (0x%lx)..."), 
                                pszPath, hbrf); )

                    // (Decrement counter for Cache_GetPtr to keep count even,
                    // since we are returning NULL.)
                    Cache_DeleteItem(&g_cacheCRL, atomPath, FALSE, NULL, CRL_Free);     
                pcrl = NULL;
                hres = E_FAIL;
            }

            // Is this item tagged dirty and the use-count is 0?
            else if (IsFlagSet(pcrl->uFlags, CRLF_DIRTY) && pcrl->ucUse == 0)
            {
                // Yes; we are free to re-create the reclist.
                LPCTSTR pszPath = Atom_GetName(atomPath);

                ASSERT(pszPath);

                DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Getting clean CRL %s (0x%lx)..."), 
                            pszPath, hbrf); )

                    // Since we'll be leaving the critical section below,
                    // temporarily increase the use count to keep the pcrl
                    // from getting nuked from under us.
                    pcrl->ucUse++;

                // Replace the contents of the cache entry
                // Leave the critical section while we do expensive calculation
                CRL_LeaveCS();
                {
                    hres = CreatePathLists(hbrf, pcrl->pabortevt, atomPath,
                            &lprl, &lpftl);
                }
                CRL_EnterCS();

                // Decrement use count
                pcrl->ucUse--;

                if (FAILED(hres))
                {
                    DEBUG_CODE( DEBUG_MSG(TF_ERROR, TEXT("SyncUI   CRL_Get failed in cleaning dirty entry!")); )

                        // Still return pcrl since it exists
                        hres = NOERROR;
                }
                else
                {
                    // Put the new lists in the cache entry
                    if (pcrl->lprl)
                    {
                        Sync_DestroyRecList(pcrl->lprl);
                    }
                    pcrl->lprl = lprl;

                    if (pcrl->lpftl)
                    {
                        Sync_DestroyFolderList(pcrl->lpftl);
                    }
                    pcrl->lpftl = lpftl;

                    if (S_FALSE == hres)
                        SetFlag(pcrl->uFlags, CRLF_ORPHAN);
                    else
                    {
                        ASSERT(S_OK == hres);
                        ClearFlag(pcrl->uFlags, CRLF_ORPHAN);
                    }

                    ClearFlag(pcrl->uFlags, CRLF_DIRTY);
                    SetSubfolderTwinFlag(pcrl);

                    SetPairInfo(pcrl);
                    hres = NOERROR;
                }
            }
            else
            {
#ifdef DEBUG
                LPCTSTR pszPath = Atom_GetName(atomPath);

                ASSERT(pszPath);

                if (IsFlagSet(pcrl->uFlags, CRLF_DIRTY))
                {
                    TRACE_MSG(TF_CACHE, TEXT("CACHE  Getting dirty CRL %s (0x%lx)..."), 
                            pszPath, hbrf);
                }
                else
                {
                    TRACE_MSG(TF_CACHE, TEXT("CACHE  Getting CRL %s (0x%lx)..."), 
                            pszPath, hbrf);
                }
#endif
                hres = NOERROR;
            }
        }
        else
            hres = E_FAIL;

        // Now increment the use count
        //
        if (pcrl)
            pcrl->ucUse++;

        *ppcrl = pcrl;

        ASSERT((FAILED(hres) && !*ppcrl) || 
                (SUCCEEDED(hres) && *ppcrl));
    }
    CRL_LeaveCS();

    return hres;
}


/*----------------------------------------------------------
Purpose: Mark any related CRLs dirty.  Which CRLs get marked dirty
depends on the lEvent.

In addition, *pbRefresh is set to TRUE if the window that
is calling this function should refresh itself.

(N.b. in the following rules, we never refresh the immediate
folder unless explicitly stated, since the shell will do this
automatically.  E.g., if C:\Bar\Foo.txt received NOE_DIRTYITEM,
the shell will automatically repaint C:\Bar.)

Rules:

NOE_CREATE     Cause:   A file is created.
Dirty?   Any CRLs whose atomInside or atomOutside
are parents or equal to atomPath.
Refresh? Only in windows of parent folders on either
side OR
in immediate window on the briefcase side 
if atomPath was created on the outside.

NOE_CREATEFOLDER  same as above

NOE_DELETE     Cause:   A file or folder was deleted.
Dirty?   Any CRLs whose atomInside or atomOutside
are parents or equal to atomPath.
Delete CRL if atomPath matches atomInside
Refresh? Only in windows of parent folders on either
side OR
in immediate window on the briefcase side 
if atomPath was deleted on the outside.

NOE_DELETEFOLDER  same as above

NOE_RENAME     Cause:   A file or folder was renamed or moved.
Dirty?   Any CRLs whose atomInside or atomOutside
are parents or equal to atomPath.
Rename CRL (and related database entry) if
atomPath is inside briefcase
Refresh? Only in windows of parent folders on either
side OR
in immediate window on the briefcase side
if atomPath is renamed on the outside.

NOE_RENAMEFOLDER  same as above

NOE_DIRTY      Cause:   Varies.  Typically something needs refreshed.
Dirty?   Any CRLs whose atomInside or atomOutside
are parents or equal to atomPath.
If atomPath is folder, any CRLs which are
children of atomPath.
Refresh? Only in windows of parent folders on either
side OR
in immediate window on the briefcase side
if atomPath is updated on the outside.

Returns: FALSE if nothing was marked
TRUE if something was marked
Cond:    --
 */
BOOL PUBLIC CRL_Dirty(
        int atomPath,
        int atomCabFolder,      // path of open cabinet window
        LONG lEvent,
        LPBOOL pbRefresh)       // return TRUE to refresh cabinet window
{
    BOOL bRet = FALSE;
    CRL  * pcrl;
    int atom;
    int atomParent;

    ASSERT(pbRefresh);

    *pbRefresh = FALSE;

    CRL_EnterCS();
    {
        BOOL bIsFolder;

        // Get the atomParent of the atomPath
        TCHAR szParent[MAXPATHLEN];

        lstrcpyn(szParent, Atom_GetName(atomPath), ARRAYSIZE(szParent));
        PathRemoveFileSpec(szParent);
        if (0 == *szParent)         // skip blank parent paths 
            goto Done;
        atomParent = Atom_Add(szParent);
        if (ATOM_ERR == atomParent)
            goto Done;

        // Is the path that is being updated a folder?
        pcrl = Cache_GetPtr(&g_cacheCRL, atomPath);
        if (pcrl)
        {
            bIsFolder = CRL_IsFolder(pcrl);
            Cache_DeleteItem(&g_cacheCRL, atomPath, FALSE, NULL, CRL_Free);    // Decrement count
        }
        else
        {
            bIsFolder = FALSE;
        }

        CRL_Iterate(atom)
        {
            pcrl = Cache_GetPtr(&g_cacheCRL, atom);
            ASSERT(pcrl);
            if (pcrl)
            {
                // Is CRL a parent or equal of atomPath?
                if (Atom_IsParentOf(atom, atomPath))
                {
                    // Yes; mark it
                    DEBUG_CODE( LPCTSTR pszDbg = Atom_GetName(atom); )
                        DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Tagging CRL for %s (0x%lx)"), 
                                    pszDbg, pcrl->hbrf); )

                        SetFlag(pcrl->uFlags, CRLF_DIRTY);
                    bRet = TRUE;

                    // Refresh this window?
                    // (Only if the cabinet folder is > than an immediate
                    // parent folder.)
                    *pbRefresh = Atom_IsParentOf(atomCabFolder, atom) &&
                        atomCabFolder != atomParent;

                    switch (lEvent)
                    {
                        case NOE_DELETE:
                        case NOE_DELETEFOLDER:
                            // Is this CRL the item being deleted?
                            if (pcrl->atomPath == atomPath) 
                            {
                                // Yes; delete the CRL
                                CRL_Delete(atom);
                            }
                            break;

                        case NOE_RENAME:
                        case NOE_RENAMEFOLDER:
                            // Is this CRL being renamed (inside briefcase only)?
                            if (pcrl->atomPath == atomPath)
                            {
                                // FEATURE: Yes; mark it for renaming
                            }
                            break;

                        case NOE_DIRTY:
                        case NOE_DIRTYFOLDER:
                            // Is the atomPath a folder and this CRL a child?
                            if (bIsFolder && Atom_IsChildOf(pcrl->atomPath, atomPath))
                            {
                                // Yes; mark it
                                DEBUG_CODE( LPCTSTR pszDbg = Atom_GetName(atom); )
                                    DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Tagging CRL for %s (0x%lx)"), 
                                                pszDbg, pcrl->hbrf); )

                                    SetFlag(pcrl->uFlags, CRLF_DIRTY);
                                bRet = TRUE;
                            }
                            break;
                    }
                }

                // Is CRL's atomOutside a parent or equal of atomPath?
                if (Atom_IsParentOf(pcrl->atomOutside, atomPath))
                {
                    // Yes; mark it
                    DEBUG_CODE( LPCTSTR pszDbg = Atom_GetName(atom); )
                        DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Tagging CRL for %s (0x%lx)"), 
                                    pszDbg, pcrl->hbrf); )

                        SetFlag(pcrl->uFlags, CRLF_DIRTY);
                    bRet = TRUE;

                    // Refresh this window?
                    *pbRefresh = Atom_IsParentOf(atomCabFolder, atom);
                }

                Cache_DeleteItem(&g_cacheCRL, atom, FALSE, NULL, CRL_Free);    // Decrement count
            }
        }
Done:;
    }
    CRL_LeaveCS();
    return bRet;
}


/*----------------------------------------------------------
Purpose: Mark the entire cache dirty
Returns: --
Cond:    --
 */
void PUBLIC CRL_DirtyAll(
        int atomBrf)
{
    CRL_EnterCS();
    {
        CRL  * pcrl;
        int atom;

        CRL_Iterate(atom)
        {
            pcrl = Cache_GetPtr(&g_cacheCRL, atom);
            ASSERT(pcrl);
            if (pcrl && pcrl->atomBrf == atomBrf)
            {
                DEBUG_CODE( LPCTSTR pszDbg = Atom_GetName(atom); )

                    DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Tagging CRL for %s (0x%lx)"), pszDbg, 
                                pcrl->hbrf); )

                    SetFlag(pcrl->uFlags, CRLF_DIRTY);
                Cache_DeleteItem(&g_cacheCRL, atom, FALSE, NULL, CRL_Free);    // Decrement count
            }
        }
    }
    CRL_LeaveCS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\comm.h ===
//
// comm.h: Declares data, defines and struct types for common code
//            module.
//
//

#ifndef __COMM_H__
#define __COMM_H__



/////////////////////////////////////////////////////  DEFINES

#define BLOCK        
#define Unref(x)     x

#ifdef DEBUG
#define INLINE
#define DEBUG_CODE(x)   x
#else
#define INLINE          __inline
#define DEBUG_CODE(x)   
#endif

#define CbFromCch(cch)              ((cch)*sizeof(TCHAR))
#define CCH_NUL                     (sizeof(TCHAR))


/////////////////////////////////////////////////////  MACROS

// Zero-initialize data-item
//
#define ZeroInit(pobj, type)        lmemset((CHAR *)pobj, 0, sizeof(type))

// Copy chunk of memory
//
#define BltByte(pdest, psrc, cb)    lmemmove((CHAR *)pdest, (CHAR *)psrc, cb)

// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))  
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))  

#define InRange(id, idFirst, idLast)  ((UINT)(id-idFirst) <= (UINT)(idLast-idFirst))

//
// Non-shared memory allocation
//

//      void * GAlloc(DWORD cbBytes)
//          Alloc a chunk of memory, quickly, with no 64k limit on size of
//          individual objects or total object size.  Initialize to zero.
//
#define GAlloc(cbBytes)         GlobalAlloc(GPTR, cbBytes)

//      void * GReAlloc(void * pv, DWORD cbNewSize)
//          Realloc one of above.  If pv is NULL, then this function will do
//          an alloc for you.  Initializes new portion to zero.
//
#define GReAlloc(pv, cbNewSize) GlobalReAlloc(pv, cbNewSize, GMEM_MOVEABLE | GMEM_ZEROINIT)

//      void GFree(void *pv)
//          Free pv if it is nonzero.  Set pv to zero.  
//
#define GFree(pv)        do { (pv) ? GlobalFree(pv) : (void)0;  pv = NULL; } while (0)

//      DWORD GGetSize(void *pv)
//          Get the size of a block allocated by Alloc()
//
#define GGetSize(pv)            GlobalSize(pv)

//      type * GAllocType(type);                    (macro)
//          Alloc some memory the size of <type> and return pointer to <type>.
//
#define GAllocType(type)                (type *)GAlloc(sizeof(type))

//      type * GAllocArray(type, int cNum);         (macro)
//          Alloc an array of data the size of <type>.
//
#define GAllocArray(type, cNum)          (type *)GAlloc(sizeof(type) * (cNum))

//      type * GReAllocArray(type, void * pb, int cNum);
//
#define GReAllocArray(type, pb, cNum)    (type *)GReAlloc(pb, sizeof(type) * (cNum))

// Copies psz into *ppszBuf and (re)allocates *ppszBuf accordingly
BOOL PUBLIC GSetString(LPTSTR * ppszBuf, LPCTSTR psz);

// Concatenates psz onto *ppszBuf and (re)allocates *ppszBuf accordingly
BOOL PUBLIC GCatString(LPTSTR * ppszBuf, LPCTSTR psz);


// FileInfo struct that contains file time/size info
//
typedef struct _FileInfo
    {
    HICON   hicon;
    FILETIME ftMod;
    DWORD   dwSize;         // size of the file
    DWORD   dwAttributes;   // attributes
    LPARAM  lParam;
    LPTSTR   pszDisplayName; // points to the display name
    TCHAR    szPath[1];      
    } FileInfo;

#define FIGetSize(pfi)          ((pfi)->dwSize)
#define FIGetPath(pfi)          ((pfi)->szPath)
#define FIGetDisplayName(pfi)   ((pfi)->pszDisplayName)
#define FIGetAttributes(pfi)    ((pfi)->dwAttributes)
#define FIIsFolder(pfi)         (IsFlagSet((pfi)->dwAttributes, SFGAO_FOLDER))

// Flags for FICreate
#define FIF_DEFAULT     0x0000
#define FIF_ICON        0x0001
#define FIF_DONTTOUCH   0x0002
#define FIF_FOLDER      0x0004

HRESULT PUBLIC FICreate(LPCTSTR pszPath, FileInfo ** ppfi, UINT uFlags);
BOOL    PUBLIC FISetPath(FileInfo ** ppfi, LPCTSTR pszPathNew, UINT uFlags);
BOOL    PUBLIC FIGetInfoString(FileInfo * pfi, LPTSTR pszBuf, int cchBuf);
void    PUBLIC FIFree(FileInfo * pfi);

void    PUBLIC FileTimeToDateTimeString(LPFILETIME pft, LPTSTR pszBuf, int cchBuf);


// Color macros
//
#define ColorText(nState)   (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT)
#define ColorBk(nState)     (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_WINDOW)
#define ColorMenuText(nState)   (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT)
#define ColorMenuBk(nState)     (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_MENU)
#define GetImageDrawStyle(nState)   (((nState) & ODS_SELECTED) ? ILD_SELECTED : ILD_NORMAL)

// Sets the dialog handle in the given data struct on first
//  message that the dialog gets (WM_SETFONT).
//
#define SetDlgHandle(hwnd, msg, lp)     if((msg)==WM_SETFONT) (lp)->hdlg=(hwnd);

#define DECLAREHOURGLASS    HCURSOR hcurSavHourglass
#define SetHourglass()      hcurSavHourglass = SetCursor(LoadCursor(NULL, IDC_WAIT))
#define ResetHourglass()    SetCursor(hcurSavHourglass)

// UNICODE WARNING: These must stay as CHARS for the math to be right

CHAR *   PUBLIC lmemset(CHAR * dst, CHAR val, UINT count);
CHAR *   PUBLIC lmemmove(CHAR * dst, CHAR * src, int count);

int     PUBLIC AnsiToInt(LPCTSTR pszString);

INT_PTR PUBLIC DoModal (HWND hwndParent, DLGPROC lpfnDlgProc, UINT uID, LPARAM lParam);

VOID PUBLIC SetRectFromExtent(HDC hdc, LPRECT lprc, LPCTSTR lpcsz);

// Flags for MyDrawText()
#define MDT_DRAWTEXT        0x00000001                                  
#define MDT_ELLIPSES        0x00000002                                  
#define MDT_LINK            0x00000004                                  
#define MDT_SELECTED        0x00000008                                  
#define MDT_DESELECTED      0x00000010                                  
#define MDT_DEPRESSED       0x00000020                                  
#define MDT_EXTRAMARGIN     0x00000040                                  
#define MDT_TRANSPARENT     0x00000080
#define MDT_LEFT            0x00000100
#define MDT_RIGHT           0x00000200
#define MDT_CENTER          0x00000400
#define MDT_VCENTER         0x00000800
#define MDT_CLIPPED         0x00001000

void PUBLIC MyDrawText(HDC hdc, LPCTSTR pszText, RECT * prc, UINT flags, int cyChar, int cxEllipses, COLORREF clrText, COLORREF clrTextBk);

DWORD PUBLIC MsgWaitObjectsSendMessage(DWORD cObjects, LPHANDLE phObjects, DWORD dwTimeout);

HCURSOR PUBLIC SetCursorRemoveWigglies(HCURSOR hcur);

LPTSTR PUBLIC _ConstructMessageString(HINSTANCE hinst, LPCTSTR pszMsg, va_list *ArgList);

BOOL PUBLIC ConstructMessage(LPTSTR * ppsz, HINSTANCE hinst, LPCTSTR pszMsg, ...);

#endif // __COMM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\cstrings.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cstrings.c
//
//  This file contains read-only string constants
//
// History:
//  12-21-93 ScottH     Created file
//
//---------------------------------------------------------------------------

#include "brfprv.h"

TCHAR const  c_szNULL[] = TEXT("");

TCHAR const  c_szDelim[] = TEXT(" \t,");
TCHAR const  c_szAllFiles[] = TEXT("*.*");
TCHAR const  c_szEllipses[] = TEXT("...");

// Class names

// Executable and DLL names

TCHAR const  c_szEngineDLL[] = TEXT("SYNCENG.DLL");
TCHAR const  c_szCabinet[] = TEXT("Explorer.exe");
TCHAR const  c_szCabinetClass[] = TEXT("CabinetWClass");
TCHAR const  c_szWinHelpFile[] = TEXT("windows.hlp");
TCHAR const  c_szDllGetClassObject[]  = TEXT("DllGetClassObject");
TCHAR const  c_szOpen[] = TEXT("open");

// Ini file name

TCHAR const  c_szIniFile[] = TEXT("rover.ini");
TCHAR const  c_szDesktopIni[]  = STR_DESKTOPINI;
TCHAR const  c_szRunWizard[] = TEXT("RunWizard");

// Ini section names

TCHAR const  c_szIniSecExclude[] = TEXT("Exclude");
TCHAR const  c_szIniSecFilter[] = TEXT("Filter");
TCHAR const  c_szIniSecBriefcase[] = TEXT("Briefcase");

#ifdef DEBUG

TCHAR const  c_szIniSecDebugUI[] = TEXT("SyncUIDebugOptions");

#endif

// Ini key names

TCHAR const  c_szIniKeyCLSID[] = TEXT("CLSID");
TCHAR const  c_szCLSID[] = TEXT("{85BBD920-42A0-1069-A2E4-08002B30309D}");

TCHAR const  c_szIniKeyPBar[] = TEXT("ProgressBar");
TCHAR const  c_szIniKeyFile[] = TEXT("File");
TCHAR const  c_szIniKeyType[] = TEXT("Type");

#ifdef DEBUG

TCHAR const  c_szIniKeyTraceFlags[] = TEXT("TraceFlags");
TCHAR const  c_szIniKeyDumpFlags[] = TEXT("DumpFlags");
TCHAR const  c_szIniKeyBreakOnOpen[] = TEXT("BreakOnOpen");
TCHAR const  c_szIniKeyBreakOnClose[] = TEXT("BreakOnClose");
TCHAR const  c_szIniKeyBreakOnRunOnce[] = TEXT("BreakOnRunOnce");
TCHAR const  c_szIniKeyBreakOnValidate[] = TEXT("BreakOnValidate");
TCHAR const  c_szIniKeyBreakOnThreadAtt[] = TEXT("BreakOnThreadAttach");
TCHAR const  c_szIniKeyBreakOnThreadDet[] = TEXT("BreakOnThreadDetach");
TCHAR const  c_szIniKeyBreakOnProcessAtt[] = TEXT("BreakOnProcessAttach");
TCHAR const  c_szIniKeyBreakOnProcessDet[] = TEXT("BreakOnProcessDetach");

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\da.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: da.c
//
//  This file contains dynamic array functions.
//
// History:
//  09-27-94 ScottH     Taken from commctrl
//
//---------------------------------------------------------------------------


#include "brfprv.h"         // common headers

//
// Heapsort is a bit slower, but it doesn't use any stack or memory...
// Mergesort takes a bit of memory (O(n)) and stack (O(log(n)), but very fast...
//
#ifdef WIN32
#define MERGESORT
#else
#define USEHEAPSORT
#endif

#ifdef DEBUG
#define DSA_MAGIC   (TEXT('S') | (TEXT('A') << 256))
#define IsDSA(pdsa) ((pdsa) && (pdsa)->magic == DSA_MAGIC)
#define DPA_MAGIC   (TEXT('P') | (TEXT('A') << 256))
#define IsDPA(pdpa) ((pdpa) && (pdpa)->magic == DPA_MAGIC)
#else
#define IsDSA(pdsa)
#define IsDPA(pdsa)
#endif


typedef struct {
    void * * pp;
    PFNDPACOMPARE pfnCmp;
    LPARAM lParam;
    int cp;
#ifdef MERGESORT
    void * * ppT;
#endif
} SORTPARAMS;

BOOL  DPA_QuickSort(SORTPARAMS * psp);
BOOL  DPA_QuickSort2(int i, int j, SORTPARAMS * psp);
BOOL  DPA_HeapSort(SORTPARAMS * psp);
void  DPA_HeapSortPushDown(int first, int last, SORTPARAMS * psp);
BOOL  DPA_MergeSort(SORTPARAMS * psp);
void  DPA_MergeSort2(SORTPARAMS * psp, int iFirst, int cItems);



//========== Dynamic structure array ====================================

// Dynamic structure array

typedef struct _DSA {
    // NOTE: The following field MUST be defined at the beginning of the
    // structure in order for GetItemCount() to work.
    //
    int cItem;          // # of elements in dsa

    void * aItem;       // memory for elements
    int cItemAlloc;     // # items which fit in aItem
    int cbItem;         // size of each item
    int cItemGrow;      // # items to grow cItemAlloc by
#ifdef DEBUG
    UINT magic;
#endif
} DSA;

#define DSA_PITEM(pdsa, index)    ((void *)(((BYTE *)(pdsa)->aItem) + ((index) * (pdsa)->cbItem)))


HDSA PUBLIC DSA_Create(int cbItem, int cItemGrow)
{
    HDSA pdsa = SharedAlloc(sizeof(DSA));

    ASSERT(cbItem);

    if (pdsa)
    {
        pdsa->cItem = 0;
        pdsa->cItemAlloc = 0;
        pdsa->cbItem = cbItem;
        pdsa->cItemGrow = (cItemGrow == 0 ? 1 : cItemGrow);
        pdsa->aItem = NULL;
#ifdef DEBUG
        pdsa->magic = DSA_MAGIC;
#endif
    }
    return pdsa;
}

BOOL PUBLIC DSA_Destroy(HDSA pdsa)
{
    ASSERT(IsDSA(pdsa));

    if (pdsa == NULL)       // allow NULL for low memory cases, still assert
        return TRUE;

#ifdef DEBUG
    pdsa->cItem = 0;
    pdsa->cItemAlloc = 0;
    pdsa->cbItem = 0;
    pdsa->magic = 0;
#endif
    if (pdsa->aItem && !SharedFree(&pdsa->aItem))
        return FALSE;

    return SharedFree(&pdsa);
}

BOOL PUBLIC DSA_GetItem(HDSA pdsa, int index, void * pitem)
{
    ASSERT(IsDSA(pdsa));
    ASSERT(pitem);

    if (index < 0 || index >= pdsa->cItem)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: Invalid index: %d"), index);
        return FALSE;
    }

    hmemcpy(pitem, DSA_PITEM(pdsa, index), pdsa->cbItem);
    return TRUE;
}

void * PUBLIC DSA_GetItemPtr(HDSA pdsa, int index)
{
    ASSERT(IsDSA(pdsa));

    if (index < 0 || index >= pdsa->cItem)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: Invalid index: %d"), index);
        return NULL;
    }
    return DSA_PITEM(pdsa, index);
}

BOOL PUBLIC DSA_SetItem(HDSA pdsa, int index, void * pitem)
{
    ASSERT(pitem);
    ASSERT(IsDSA(pdsa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: Invalid index: %d"), index);
        return FALSE;
    }

    if (index >= pdsa->cItem)
    {
        if (index + 1 > pdsa->cItemAlloc)
        {
            int cItemAlloc = (((index + 1) + pdsa->cItemGrow - 1) / pdsa->cItemGrow) * pdsa->cItemGrow;

            void * aItemNew = SharedReAlloc(pdsa->aItem, cItemAlloc * pdsa->cbItem);
            if (!aItemNew)
                return FALSE;

            pdsa->aItem = aItemNew;
            pdsa->cItemAlloc = cItemAlloc;
        }
        pdsa->cItem = index + 1;
    }

    hmemcpy(DSA_PITEM(pdsa, index), pitem, pdsa->cbItem);

    return TRUE;
}

int PUBLIC DSA_InsertItem(HDSA pdsa, int index, void * pitem)
{
    ASSERT(pitem);
    ASSERT(IsDSA(pdsa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: Invalid index: %d"), index);
        return -1;
    }

    if (index > pdsa->cItem)
        index = pdsa->cItem;

    if (pdsa->cItem + 1 > pdsa->cItemAlloc)
    {
        void * aItemNew = SharedReAlloc(pdsa->aItem,
                (pdsa->cItemAlloc + pdsa->cItemGrow) * pdsa->cbItem);
        if (!aItemNew)
            return -1;

        pdsa->aItem = aItemNew;
        pdsa->cItemAlloc += pdsa->cItemGrow;
    }

    if (index < pdsa->cItem)
    {
        hmemcpy(DSA_PITEM(pdsa, index + 1), DSA_PITEM(pdsa, index),
                (pdsa->cItem - index) * pdsa->cbItem);
    }
    pdsa->cItem++;
    hmemcpy(DSA_PITEM(pdsa, index), pitem, pdsa->cbItem);

    return index;
}

BOOL PUBLIC DSA_DeleteItem(HDSA pdsa, int index)
{
    ASSERT(IsDSA(pdsa));

    if (index < 0 || index >= pdsa->cItem)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: Invalid index: %d"), index);
        return FALSE;
    }

    if (index < pdsa->cItem - 1)
    {
        hmemcpy(DSA_PITEM(pdsa, index), DSA_PITEM(pdsa, index + 1),
                (pdsa->cItem - (index + 1)) * pdsa->cbItem);
    }
    pdsa->cItem--;

    if (pdsa->cItemAlloc - pdsa->cItem > pdsa->cItemGrow)
    {
        void * aItemNew = SharedReAlloc(pdsa->aItem,
                (pdsa->cItemAlloc - pdsa->cItemGrow) * pdsa->cbItem);

        ASSERT(aItemNew);
        pdsa->aItem = aItemNew;
        pdsa->cItemAlloc -= pdsa->cItemGrow;
    }
    return TRUE;
}

BOOL PUBLIC DSA_DeleteAllItems(HDSA pdsa)
{
    ASSERT(IsDSA(pdsa));

    if (pdsa->aItem && !SharedFree(&pdsa->aItem))
        return FALSE;

    pdsa->aItem = NULL;
    pdsa->cItem = pdsa->cItemAlloc = 0;
    return TRUE;
}


//================== Dynamic pointer array implementation ===========

typedef struct _DPA {
    // NOTE: The following two fields MUST be defined in this order, at
    // the beginning of the structure in order for the macro APIs to work.
    //
    int cp;
    void * * pp;

    HANDLE hheap;        // Heap to allocate from if NULL use shared

    int cpAlloc;
    int cpGrow;
#ifdef DEBUG
    UINT magic;
#endif
} DPA;



HDPA PUBLIC DPA_Create(int cpGrow)
{
    HDPA pdpa = SharedAlloc(sizeof(DPA));
    if (pdpa)
    {
        pdpa->cp = 0;
        pdpa->cpAlloc = 0;
        pdpa->cpGrow = (cpGrow < 8 ? 8 : cpGrow);
        pdpa->pp = NULL;
#ifdef WIN32
        pdpa->hheap = g_hSharedHeap;   // Defaults to use shared one (for now...)
#else
        pdpa->hheap = NULL;       // Defaults to use shared one (for now...)
#endif
#ifdef DEBUG
        pdpa->magic = DPA_MAGIC;
#endif
    }
    return pdpa;
}

// Should nuke the standard DPA above...
HDPA PUBLIC DPA_CreateEx(int cpGrow, HANDLE hheap)
{
    HDPA pdpa;
    if (hheap == NULL)
    {
        pdpa = SharedAlloc(sizeof(DPA));
#ifdef WIN32
        hheap = g_hSharedHeap;
#endif
    }
    else
        pdpa = MemAlloc(hheap, sizeof(DPA));
    if (pdpa)
    {
        pdpa->cp = 0;
        pdpa->cpAlloc = 0;
        pdpa->cpGrow = (cpGrow < 8 ? 8 : cpGrow);
        pdpa->pp = NULL;
        pdpa->hheap = hheap;
#ifdef DEBUG
        pdpa->magic = DPA_MAGIC;
#endif
    }
    return pdpa;
}

BOOL PUBLIC DPA_Destroy(HDPA pdpa)
{
    ASSERT(IsDPA(pdpa));

    if (pdpa == NULL)       // allow NULL for low memory cases, still assert
        return TRUE;

#ifdef WIN32
    ASSERT (pdpa->hheap);
#endif

#ifdef DEBUG
    pdpa->cp = 0;
    pdpa->cpAlloc = 0;
    pdpa->magic = 0;
#endif
    if (pdpa->pp && !MemFree(pdpa->hheap, pdpa->pp))
        return FALSE;

    return MemFree(pdpa->hheap, pdpa);
}

HDPA PUBLIC DPA_Clone(HDPA pdpa, HDPA pdpaNew)
{
    BOOL fAlloc = FALSE;

    if (!pdpaNew)
    {
        pdpaNew = DPA_CreateEx(pdpa->cpGrow, pdpa->hheap);
        if (!pdpaNew)
            return NULL;

        fAlloc = TRUE;
    }

    if (!DPA_Grow(pdpaNew, pdpa->cpAlloc)) {
        if (!fAlloc)
            DPA_Destroy(pdpaNew);
        return NULL;
    }

    pdpaNew->cp = pdpa->cp;
    hmemcpy(pdpaNew->pp, pdpa->pp, pdpa->cp * sizeof(void *));

    return pdpaNew;
}

void * PUBLIC DPA_GetPtr(HDPA pdpa, int index)
{
    ASSERT(IsDPA(pdpa));

    if (index < 0 || index >= pdpa->cp)
        return NULL;

    return pdpa->pp[index];
}

int PUBLIC DPA_GetPtrIndex(HDPA pdpa, void * p)
{
    void * * pp;
    void * * ppMax;

    ASSERT(IsDPA(pdpa));
    if (pdpa->pp)
    {
        pp = pdpa->pp;
        ppMax = pp + pdpa->cp;
        for ( ; pp < ppMax; pp++)
        {
            if (*pp == p)
                return (pp - pdpa->pp);
        }
    }
    return -1;
}

BOOL PUBLIC DPA_Grow(HDPA pdpa, int cpAlloc)
{
    ASSERT(IsDPA(pdpa));

    if (cpAlloc > pdpa->cpAlloc)
    {
        void * * ppNew;

        cpAlloc = ((cpAlloc + pdpa->cpGrow - 1) / pdpa->cpGrow) * pdpa->cpGrow;

        if (pdpa->pp)
            ppNew = (void * *)MemReAlloc(pdpa->hheap, pdpa->pp, cpAlloc * sizeof(void *));
        else
            ppNew = (void * *)MemAlloc(pdpa->hheap, cpAlloc * sizeof(void *));
        if (!ppNew)
            return FALSE;

        pdpa->pp = ppNew;
        pdpa->cpAlloc = cpAlloc;
    }
    return TRUE;
}

BOOL PUBLIC DPA_SetPtr(HDPA pdpa, int index, void * p)
{
    ASSERT(IsDPA(pdpa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: Invalid index: %d"), index);
        return FALSE;
    }

    if (index >= pdpa->cp)
    {
        if (!DPA_Grow(pdpa, index + 1))
            return FALSE;
        pdpa->cp = index + 1;
    }

    pdpa->pp[index] = p;

    return TRUE;
}

int PUBLIC DPA_InsertPtr(HDPA pdpa, int index, void * p)
{
    ASSERT(IsDPA(pdpa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: Invalid index: %d"), index);
        return -1;
    }
    if (index > pdpa->cp)
        index = pdpa->cp;

    // Make sure we have room for one more item
    //
    if (pdpa->cp + 1 > pdpa->cpAlloc)
    {
        if (!DPA_Grow(pdpa, pdpa->cp + 1))
            return -1;
    }

    // If we are inserting, we need to slide everybody up
    //
    if (index < pdpa->cp)
    {
        hmemcpy(&pdpa->pp[index + 1], &pdpa->pp[index],
                (pdpa->cp - index) * sizeof(void *));
    }

    pdpa->pp[index] = p;
    pdpa->cp++;

    return index;
}

void * PUBLIC DPA_DeletePtr(HDPA pdpa, int index)
{
    void * p;

    ASSERT(IsDPA(pdpa));

    if (index < 0 || index >= pdpa->cp)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: Invalid index: %d"), index);
        return NULL;
    }

    p = pdpa->pp[index];

    if (index < pdpa->cp - 1)
    {
        hmemcpy(&pdpa->pp[index], &pdpa->pp[index + 1],
                (pdpa->cp - (index + 1)) * sizeof(void *));
    }
    pdpa->cp--;

    if (pdpa->cpAlloc - pdpa->cp > pdpa->cpGrow)
    {
        void * * ppNew;
        ppNew = MemReAlloc(pdpa->hheap, pdpa->pp, (pdpa->cpAlloc - pdpa->cpGrow) * sizeof(void *));

        ASSERT(ppNew);
        pdpa->pp = ppNew;
        pdpa->cpAlloc -= pdpa->cpGrow;
    }
    return p;
}

BOOL PUBLIC DPA_DeleteAllPtrs(HDPA pdpa)
{
    ASSERT(IsDPA(pdpa));

    if (pdpa->pp && !MemFree(pdpa->hheap, pdpa->pp))
        return FALSE;
    pdpa->pp = NULL;
    pdpa->cp = pdpa->cpAlloc = 0;
    return TRUE;
}

BOOL PUBLIC DPA_Sort(HDPA pdpa, PFNDPACOMPARE pfnCmp, LPARAM lParam)
{
    SORTPARAMS sp;

    sp.cp = pdpa->cp;
    sp.pp = pdpa->pp;
    sp.pfnCmp = pfnCmp;
    sp.lParam = lParam;

#ifdef USEQUICKSORT
    return DPA_QuickSort(&sp);
#endif
#ifdef USEHEAPSORT
    return DPA_HeapSort(&sp);
#endif
#ifdef MERGESORT
    return DPA_MergeSort(&sp);
#endif
}

#ifdef USEQUICKSORT

BOOL  DPA_QuickSort(SORTPARAMS * psp)
{
    return DPA_QuickSort2(0, psp->cp - 1, psp);
}

BOOL  DPA_QuickSort2(int i, int j, SORTPARAMS * psp)
{
    void * * pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNDPACOMPARE pfnCmp = psp->pfnCmp;

    int iPivot;
    void * pFirst;
    int k;
    int result;

    iPivot = -1;
    pFirst = pp[i];
    for (k = i + 1; k <= j; k++)
    {
        result = (*pfnCmp)(pp[k], pFirst, lParam);

        if (result > 0)
        {
            iPivot = k;
            break;
        }
        else if (result < 0)
        {
            iPivot = i;
            break;
        }
    }

    if (iPivot != -1)
    {
        int l = i;
        int r = j;
        void * pivot = pp[iPivot];

        do
        {
            void * p;

            p = pp[l];
            pp[l] = pp[r];
            pp[r] = p;

            while ((*pfnCmp)(pp[l], pivot, lParam) < 0)
                l++;
            while ((*pfnCmp)(pp[r], pivot, lParam) >= 0)
                r--;
        } while (l <= r);

        if (l - 1 > i)
            DPA_QuickSort2(i, l - 1, psp);
        if (j > l)
            DPA_QuickSort2(l, j, psp);
    }
    return TRUE;
}
#endif  // USEQUICKSORT

#ifdef USEHEAPSORT

void  DPA_HeapSortPushDown(int first, int last, SORTPARAMS * psp)
{
    void * * pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNDPACOMPARE pfnCmp = psp->pfnCmp;
    int r;
    int r2;
    void * p;

    r = first;
    while (r <= last / 2)
    {
        int wRTo2R;
        r2 = r * 2;

        wRTo2R = (*pfnCmp)(pp[r-1], pp[r2-1], lParam);

        if (r2 == last)
        {
            if (wRTo2R < 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2-1]; pp[r2-1] = p;
            }
            break;
        }
        else
        {
            int wR2toR21 = (*pfnCmp)(pp[r2-1], pp[r2+1-1], lParam);

            if (wRTo2R < 0 && wR2toR21 >= 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2-1]; pp[r2-1] = p;
                r = r2;
            }
            else if ((*pfnCmp)(pp[r-1], pp[r2+1-1], lParam) < 0 && wR2toR21 < 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2+1-1]; pp[r2+1-1] = p;
                r = r2 + 1;
            }
            else
            {
                break;
            }
        }
    }
}

BOOL  DPA_HeapSort(SORTPARAMS * psp)
{
    void * * pp = psp->pp;
    int c = psp->cp;
    int i;

    for (i = c / 2; i >= 1; i--)
        DPA_HeapSortPushDown(i, c, psp);

    for (i = c; i >= 2; i--)
    {
        void * p = pp[0]; pp[0] = pp[i-1]; pp[i-1] = p;

        DPA_HeapSortPushDown(1, i - 1, psp);
    }
    return TRUE;
}
#endif  // USEHEAPSORT

#if defined(MERGESORT) && defined(WIN32)

#define SortCompare(psp, pp1, i1, pp2, i2) \
(psp->pfnCmp(pp1[i1], pp2[i2], psp->lParam))

    //
    //  This function merges two sorted lists and makes one sorted list.
    //   psp->pp[iFirst, iFirst+cItes/2-1], psp->pp[iFirst+cItems/2, iFirst+cItems-1]
    //
void  DPA_MergeThem(SORTPARAMS * psp, int iFirst, int cItems)
{
    //
    // Notes:
    //  This function is separated from DPA_MergeSort2() to avoid comsuming
    // stack variables. Never inline this.
    //
    int cHalf = cItems/2;
    int iIn1, iIn2, iOut;
    LPVOID * ppvSrc = &psp->pp[iFirst];

    // Copy the first part to temp storage so we can write directly into
    // the final buffer.  Note that this takes at most psp->cp/2 DWORD's
    hmemcpy(psp->ppT, ppvSrc, cHalf*sizeof(LPVOID));

    for (iIn1=0, iIn2=cHalf, iOut=0;;)
    {
        if (SortCompare(psp, psp->ppT, iIn1, ppvSrc, iIn2) <= 0) {
            ppvSrc[iOut++] = psp->ppT[iIn1++];

            if (iIn1==cHalf) {
                // We used up the first half; the rest of the second half
                // should already be in place
                break;
            }
        } else {
            ppvSrc[iOut++] = ppvSrc[iIn2++];
            if (iIn2==cItems) {
                // We used up the second half; copy the rest of the first half
                // into place
                hmemcpy(&ppvSrc[iOut], &psp->ppT[iIn1], (cItems-iOut)*sizeof(LPVOID));
                break;
            }
        }
    }
}

//
//  This function sorts a give list (psp->pp[iFirst,iFirst-cItems-1]).
//
void  DPA_MergeSort2(SORTPARAMS * psp, int iFirst, int cItems)
{
    //
    // Notes:
    //   This function is recursively called. Therefore, we should minimize
    //  the number of local variables and parameters. At this point, we
    //  use one local variable and three parameters.
    //
    int cHalf;

    switch(cItems)
    {
        case 1:
            return;

        case 2:
            // Swap them, if they are out of order.
            if (SortCompare(psp, psp->pp, iFirst, psp->pp, iFirst+1) > 0)
            {
                psp->ppT[0] = psp->pp[iFirst];
                psp->pp[iFirst] = psp->pp[iFirst+1];
                psp->pp[iFirst+1] = psp->ppT[0];
            }
            break;

        default:
            cHalf = cItems/2;
            // Sort each half
            DPA_MergeSort2(psp, iFirst, cHalf);
            DPA_MergeSort2(psp, iFirst+cHalf, cItems-cHalf);
            // Then, merge them.
            DPA_MergeThem(psp, iFirst, cItems);
            break;
    }
}

BOOL  DPA_MergeSort(SORTPARAMS * psp)
{
    if (psp->cp==0)
        return TRUE;

    // Note that we divide by 2 below; we want to round down
    psp->ppT = LocalAlloc(LPTR, psp->cp/2 * sizeof(LPVOID));
    if (!psp->ppT)
        return FALSE;

    DPA_MergeSort2(psp, 0, psp->cp);
    LocalFree(psp->ppT);
    return TRUE;
}
#endif // MERGESORT

// Search function
//
int PUBLIC DPA_Search(HDPA pdpa, void * pFind, int iStart,
        PFNDPACOMPARE pfnCompare, LPARAM lParam, UINT options)
{
    int cp = DPA_GetPtrCount(pdpa);

    ASSERT(pfnCompare);
    ASSERT(0 <= iStart);

    // Only allow these wierd flags if the list is sorted
    ASSERT((options & DPAS_SORTED) || !(options & (DPAS_INSERTBEFORE | DPAS_INSERTAFTER)));

    if (!(options & DPAS_SORTED))
    {
        // Not sorted: do linear search.
        int i;

        for (i = iStart; i < cp; i++)
        {
            if (0 == pfnCompare(pFind, DPA_FastGetPtr(pdpa, i), lParam))
                return i;
        }
        return -1;
    }
    else
    {
        // Search the array using binary search.  If several adjacent 
        // elements match the target element, the index of the first
        // matching element is returned.

        int iRet = -1;      // assume no match
        BOOL bFound = FALSE;
        int nCmp = 0;
        int iLow = 0;       // Don't bother using iStart for binary search
        int iMid = 0;
        int iHigh = cp - 1;

        // (OK for cp == 0)
        while (iLow <= iHigh)
        {
            iMid = (iLow + iHigh) / 2;

            nCmp = pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid), lParam);

            if (0 > nCmp)
                iHigh = iMid - 1;       // First is smaller
            else if (0 < nCmp)
                iLow = iMid + 1;        // First is larger
            else
            {
                // Match; search back for first match
                bFound = TRUE;
                while (0 < iMid)
                {
                    if (0 != pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid-1), lParam))
                        break;
                    else
                        iMid--;
                }
                break;
            }
        }

        if (bFound)
        {
            ASSERT(0 <= iMid);
            iRet = iMid;
        }

        // Did the search fail AND
        // is one of the strange search flags set?
        if (!bFound && (options & (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)))
        {
            // Yes; return the index where the target should be inserted
            // if not found
            if (0 < nCmp)       // First is larger
                iRet = iLow;
            else
                iRet = iMid;
            // (We don't distinguish between the two flags anymore)
        }
        else if ( !(options & (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)) )
        {
            // Sanity check with linear search
            ASSERT(DPA_Search(pdpa, pFind, iStart, pfnCompare, lParam, options & ~DPAS_SORTED) == iRet);
        }
        return iRet;
    }
}

//===========================================================================
//
// String ptr management routines
//
// Copy as much of *psz to *pszBuf as will fit
//
int PUBLIC Str_GetPtr(LPCTSTR psz, LPTSTR pszBuf, int cchBuf)
{
    int cch = 0;

    // if pszBuf is NULL, just return length of string.
    //
    if (!pszBuf && psz)
        return lstrlen(psz);

    if (cchBuf)
    {
        if (psz)
        {
            cch = lstrlen(psz);

            if (cch > cchBuf - 1)
                cch = cchBuf - 1;

            hmemcpy(pszBuf, psz, cch * sizeof(TCHAR));
        }
        pszBuf[cch] = 0;
    }
    return cch;
}

// Set *ppsz to a copy of psz, reallocing as needed
//
BOOL PUBLIC Str_SetPtr(LPTSTR * ppsz, LPCTSTR psz)
{
    if (!psz)
    {
        if (*ppsz)
        {
            SharedFree(ppsz);
            *ppsz = NULL;
        }
    }
    else
    {
        LPTSTR pszNew = (LPTSTR)SharedReAlloc(*ppsz, (lstrlen(psz) + 1) * sizeof(TCHAR));
        if (!pszNew)
            return FALSE;
        // pszNew is allocated above with enough space so lstrcpy will do
        lstrcpy(pszNew, psz);
        *ppsz = pszNew;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\debug.c ===
#include "brfprv.h"
#ifdef DBG
#define DEBUG
#endif

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "syncui"
#define SZ_MODULE           "SYNCUI"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\da.h ===
//
// da.h:  Dynamic array functions taken from commctrl.
//
#if 0
#ifndef _DA_H_
#define _DA_H_

//====== Dynamic Array routines ==========================================      /* ;Internal */
// Dynamic structure array                                                      /* ;Internal */
typedef struct _DSA * HDSA;                                             /* ;Internal */
                                                                                /* ;Internal */
HDSA   PUBLIC DSA_Create(int cbItem, int cItemGrow);                            /* ;Internal */
BOOL   PUBLIC DSA_Destroy(HDSA hdsa);                                           /* ;Internal */
BOOL   PUBLIC DSA_GetItem(HDSA hdsa, int i, void * pitem);                      /* ;Internal */
LPVOID PUBLIC DSA_GetItemPtr(HDSA hdsa, int i);                                 /* ;Internal */
BOOL   PUBLIC DSA_SetItem(HDSA hdsa, int i, void * pitem);                      /* ;Internal */
int    PUBLIC DSA_InsertItem(HDSA hdsa, int i, void * pitem);                   /* ;Internal */
BOOL   PUBLIC DSA_DeleteItem(HDSA hdsa, int i);                                 /* ;Internal */
BOOL   PUBLIC DSA_DeleteAllItems(HDSA hdsa);                                    /* ;Internal */
#define       DSA_GetItemCount(hdsa) (*(int *)(hdsa))                           /* ;Internal */
                                                                                /* ;Internal */
// Dynamic pointer array                                                        /* ;Internal */
typedef struct _DPA * HDPA;                                             /* ;Internal */
                                                                                /* ;Internal */
HDPA   PUBLIC DPA_Create(int cItemGrow);                                        /* ;Internal */
HDPA   PUBLIC DPA_CreateEx(int cpGrow, HANDLE hheap);                           /* ;Internal */
BOOL   PUBLIC DPA_Destroy(HDPA hdpa);                                           /* ;Internal */
HDPA   PUBLIC DPA_Clone(HDPA hdpa, HDPA hdpaNew);                               /* ;Internal */
LPVOID PUBLIC DPA_GetPtr(HDPA hdpa, int i);                                     /* ;Internal */
int    PUBLIC DPA_GetPtrIndex(HDPA hdpa, LPVOID p);                             /* ;Internal */
BOOL   PUBLIC DPA_Grow(HDPA pdpa, int cp);                                      /* ;Internal */
BOOL   PUBLIC DPA_SetPtr(HDPA hdpa, int i, LPVOID p);                           /* ;Internal */
int    PUBLIC DPA_InsertPtr(HDPA hdpa, int i, LPVOID p);                        /* ;Internal */
LPVOID PUBLIC DPA_DeletePtr(HDPA hdpa, int i);                                  /* ;Internal */
BOOL   PUBLIC DPA_DeleteAllPtrs(HDPA hdpa);                                     /* ;Internal */
#define       DPA_GetPtrCount(hdpa)   (*(int *)(hdpa))                          /* ;Internal */
#define       DPA_GetPtrPtr(hdpa)     (*((LPVOID * *)((BYTE *)(hdpa) + sizeof(int))))   /* ;Internal */
#define       DPA_FastGetPtr(hdpa, i) (DPA_GetPtrPtr(hdpa)[i])                  /* ;Internal */

typedef int (CALLBACK *PFNDPACOMPARE)(LPVOID p1, LPVOID p2, LPARAM lParam);     /* ;Internal */
                                                                                /* ;Internal */
BOOL   PUBLIC DPA_Sort(HDPA hdpa, PFNDPACOMPARE pfnCompare, LPARAM lParam);     /* ;Internal */
                                                                                /* ;Internal */
// Search array.  If DPAS_SORTED, then array is assumed to be sorted            /* ;Internal */
// according to pfnCompare, and binary search algorithm is used.                /* ;Internal */
// Otherwise, linear search is used.                                            /* ;Internal */
//                                                                              /* ;Internal */
// Searching starts at iStart (-1 to start search at beginning).                /* ;Internal */
//                                                                              /* ;Internal */
// DPAS_INSERTBEFORE/AFTER govern what happens if an exact match is not         /* ;Internal */
// found.  If neither are specified, this function returns -1 if no exact       /* ;Internal */
// match is found.  Otherwise, the index of the item before or after the        /* ;Internal */
// closest (including exact) match is returned.                                 /* ;Internal */
//                                                                              /* ;Internal */
// Search option flags                                                          /* ;Internal */
//                                                                              /* ;Internal */
#define DPAS_SORTED             0x0001                                          /* ;Internal */
#define DPAS_INSERTBEFORE       0x0002                                          /* ;Internal */
#define DPAS_INSERTAFTER        0x0004                                          /* ;Internal */
                                                                                /* ;Internal */
int PUBLIC DPA_Search(HDPA hdpa, LPVOID pFind, int iStart,                      /* ;Internal */
                      PFNDPACOMPARE pfnCompare,                                 /* ;Internal */
                      LPARAM lParam, UINT options);                             /* ;Internal */

                                                                                /* ;Internal */
//======================================================================        /* ;Internal */
// String management helper routines                                            /* ;Internal */
                                                                                /* ;Internal */
int  PUBLIC Str_GetPtr(LPCTSTR psz, LPTSTR pszBuf, int cchBuf);                 /* ;Internal */
BOOL PUBLIC Str_SetPtr(LPTSTR * ppsz, LPCTSTR psz);                             /* ;Internal */

#endif // _DA_H_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\cvol.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cvol.c
//
//  This files contains code for the cached volume ID structs.
//
// History:
//  09-02-93 ScottH     Created
//  01-31-94 ScottH     Moved from cache.c
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers

/////////////////////////////////////////////////////  TYPEDEFS

/////////////////////////////////////////////////////  CONTROLLING DEFINES

/////////////////////////////////////////////////////  DEFINES

/////////////////////////////////////////////////////  MACROS

/////////////////////////////////////////////////////  MODULE DATA

CACHE g_cacheCVOL = {0, 0, 0};       // Volume ID cache

/////////////////////////////////////////////////////  Generic Cache Routines


#ifdef DEBUG
void PRIVATE CVOL_DumpEntry(
    CVOL  * pcvol)
    {
    ASSERT(pcvol);

    TRACE_MSG(TF_ALWAYS, TEXT("CVOL:  Atom %d: %s"), pcvol->atomPath, Atom_GetName(pcvol->atomPath));
    TRACE_MSG(TF_ALWAYS, TEXT("               Ref [%u]  Hvid = %lx"), 
        Cache_GetRefCount(&g_cacheCVOL, pcvol->atomPath),
        pcvol->hvid);
    }


void PUBLIC CVOL_DumpAll()
    {
    CVOL  * pcvol;
    int atom;
    BOOL bDump;

    ENTEREXCLUSIVE()
        {
        bDump = IsFlagSet(g_uDumpFlags, DF_CVOL);
        }
    LEAVEEXCLUSIVE()

    if (!bDump)
        return ;

    atom = Cache_FindFirstKey(&g_cacheCVOL);
    while (atom != ATOM_ERR)
        {
        pcvol = Cache_GetPtr(&g_cacheCVOL, atom);
        ASSERT(pcvol);
        if (pcvol)
            {
            CVOL_DumpEntry(pcvol);
            Cache_DeleteItem(&g_cacheCVOL, atom, FALSE);    // Decrement count
            }

        atom = Cache_FindNextKey(&g_cacheCVOL, atom);
        }
    }
#endif


/*----------------------------------------------------------
Purpose: Release the volume ID handle
Returns: --
Cond:    --
*/
void CALLBACK CVOL_Free(
    LPVOID lpv)
    {
    CVOL  * pcvol = (CVOL  *)lpv;

    DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CVOL  Releasing volume ID %s"), Atom_GetName(pcvol->atomPath)); )

    ASSERT(Sync_IsEngineLoaded());

    Sync_ReleaseVolumeIDHandle(pcvol->hvid);

    SharedFree(&pcvol);
    }


/*----------------------------------------------------------
Purpose: Add the atomPath to the cache.  We add the volume ID.
          If atomPath is already in the cache, we replace it
          with a newly obtained volume ID.

Returns: Pointer to CVOL
         NULL on OOM

Cond:    --
*/
CVOL  * PUBLIC CVOL_Replace(
    int atomPath)
    {
    CVOL  * pcvol;
    BOOL bJustAllocd;
    
    pcvol = Cache_GetPtr(&g_cacheCVOL, atomPath);
    if (pcvol)
        bJustAllocd = FALSE;
    else
        {
        // Allocate using commctrl's Alloc, so the structure will be in
        // shared heap space across processes.
        pcvol = SharedAllocType(CVOL);
        bJustAllocd = TRUE;
        }

    if (pcvol)
        {
        HVOLUMEID hvid;
        LPCTSTR pszPath = Atom_GetName(atomPath);

        ASSERT(pszPath);

        DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CVOL  Adding volume ID %s"), pszPath); )

        if (Sync_GetVolumeIDHandle(pszPath, &hvid) != TR_SUCCESS)
            {
            if (bJustAllocd)
                SharedFree(&pcvol);
            else
                Cache_DeleteItem(&g_cacheCVOL, atomPath, FALSE);    // Decrement count

            pcvol = NULL;       // Fail
            }
        else
            {
            ENTEREXCLUSIVE()
                {
                pcvol->atomPath = atomPath;
                pcvol->hvid = hvid;
                }
            LEAVEEXCLUSIVE()

            if (bJustAllocd)
                {
                if (!Cache_AddItem(&g_cacheCVOL, atomPath, (LPVOID)pcvol))
                    {
                    // Cache_AddItem failed here
                    //
                    Sync_ReleaseVolumeIDHandle(hvid);
                    SharedFree(&pcvol);
                    }
                }
            else
                Cache_DeleteItem(&g_cacheCVOL, atomPath, FALSE);    // Decrement count
            }
        }
    return pcvol;
    }


/*----------------------------------------------------------
Purpose: Search for the given volume ID in the cache.  Return
          the atomKey if it exists, otherwise ATOM_ERR.

Returns: atom
         ATOM_ERR if not found
Cond:    --
*/
int PUBLIC CVOL_FindID(
    HVOLUMEID hvid)
    {
    int atom;
    CVOL  * pcvol;

    atom = Cache_FindFirstKey(&g_cacheCVOL);
    while (atom != ATOM_ERR)
        {
        LPCTSTR pszPath = Atom_GetName(atom);

        ASSERT(pszPath);

        ENTEREXCLUSIVE()
            {
            pcvol = CVOL_Get(atom);
            ASSERT(pcvol);
            if (pcvol)
                {
                int nCmp;
    
                Sync_CompareVolumeIDs(pcvol->hvid, hvid, &nCmp);
                if (Sync_GetLastError() == TR_SUCCESS && nCmp == 0)
                    {
                    // We found it
                    CVOL_Delete(atom);
                    LEAVEEXCLUSIVE()
                    return atom;
                    }
    
                CVOL_Delete(atom);       // decrement count
                }
            }
        LEAVEEXCLUSIVE()

        atom = Cache_FindNextKey(&g_cacheCVOL, atom);
        }

    return ATOM_ERR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\dlgids.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by TEMPLATE.RC
//
#define IDB_ACTIONS                     108
#define IDD_INTRO_WIZARD                117
#define IDB_LOGO                        118
#define IDC_MSGBOX                      119
#define IDI_LEATHER_BRIEF               120
#define IDI_METAL_BRIEF                 121
#define IDI_SPLIT_FILE                  122
#define IDI_SPLIT_FOLDER                123
#define IDI_SPLIT_MULT                  124
#define IDI_UPDATE_FILE                 125
#define IDI_UPDATE_FOLDER               126
#define IDI_UPDATE_MULT                 127
#define IDI_UPDATE_DOCK                 128
#define IDI_ADD_FOLDER                  129
#define IDI_REPLACE_FILE                130
#define IDI_REPLACE_FOLDER              131
#define IDI_UPDATE                      132
#define IDA_UPDATE                      133
#define IDA_CHECK                       134
#define IDI_OPEN_FOLDER                 135
#define IDC_INTRO_PAR1                  1012
#define IDC_INTRO_PAR2                  1013
#define IDC_INTRO_PAR3                  1014
#define IDC_INTRO_PAR4                  1015
#define IDC_INTRO_PAR5                  1016
#define IDC_INTRO_PAR6                  1017
#define IDC_INTRO_PAR7                  1018
#define IDC_CREATE_PAR                  1019
#define IDC_CREATE_PAR2                 1020
#define IDC_ATROOT                      1022
#define IDC_ONDESKTOP                   1023
#define IDC_BUTTON1                     1024
#define IDC_BUTTON2                     1025
#define IDC_BUTTON3                     1026
#define IDC_TEXT                        1027
#define IDC_MSGICON                     1028
#define IDC_UPDATEACTIONS               1029
#define IDC_NAME                        1030
#define IDC_EXISTING                    1031
#define IDC_OTHER                       1032
#define IDC_DESC                        1033
#define IDC_BUTTON4                     1034
#define IDD_INFOCREATE                  1100
#define IDD_INFO                        1101
#define IDC_GBIN                        1110
#define IDC_RBINALL                     1111
#define IDC_RBINSELECTED                1112
#define IDC_LBINTYPES                   1113
#define IDC_CHININCLUDE                 1114
#define IDD_UPDATE                      1200
#define IDC_STUPTEXT                    1201
#define IDC_ICTSMAIN                    1310
#define IDC_PBTSRECON                   1324
#define IDC_PBTSFIND                    1328
#define IDC_PBTSSPLIT                   1329
#define IDC_STTSDIRECT                  1339
#define IDD_UPDATEPROGRESS              1400
#define IDC_TONAME                      1410
#define IDC_PROGRESS                    1414
#define IDC_ANIMATE                     1417
#define IDD_STATUS                      1800
#define IDD_REPLACE_FILE                1900
#define IDD_CREATE_WIZARD               1901
#define IDD_PROGRESS                    1902
#define IDC_ICCR                        1910
#define IDC_ICON1                       1911
#define IDC_ICON2                       1912
#define IDC_ICON_EXISTING               1913
#define IDC_ICON_OTHER                  1914
#define IDC_YESTOALL                    1915
#define IDD_REPLACE_FOLDER              1916
#define IDC_LOGO                        -1
#define IDC_UPDICON                     -1
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         105
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\dobj.h ===
//
// dobj.h: Declares data, defines and struct types for RecAct
//          module.
//
//

#ifndef __DOBJ_H__
#define __DOBJ_H__

// DOBJ is the draw object structure for drawing listbox entries
//
// DOBJ kinds
//
#define DOK_ICON        1   // lpvObject is the HICON
#define DOK_STRING      2   // lpvObject is the LPCSTR
#define DOK_BITMAP      3   // lpvObject is the HBITMAP
#define DOK_SIDEITEM    4   // lpvObject points to LPSIDEITEM
#define DOK_IMAGE       5   // 
#define DOK_IDS         6   // lpvObject is the resource ID

// DOBJ item styles
//
#define DOF_LEFT        0x0000
#define DOF_CENTER      0x0001
#define DOF_RIGHT       0x0002
#define DOF_DIFFER      0x0004  // This item's appearance is affected by uState
#define DOF_MENU        0x0008  // Use menu colors
#define DOF_DISABLED    0x0010
#define DOF_IGNORESEL   0x0020  // Ignore selection state
#define DOF_USEIDS      0x0040  // lpvObject is a resource string ID
#define DOF_NODRAW      0x1000  // Don't draw 

typedef struct tagDOBJ
    {
    UINT    uKind;          // One of DOK_* ordinals
    UINT    uFlags;         // One of DOF_* styles
    LPVOID  lpvObject;      // ptr or handle
    HIMAGELIST himl;        // 
    int     iImage;         // 
    int     x;
    int     y;
    RECT    rcBounding;     // Bounding rect of entire object
    union 
        {
        RECT rcSrc;         // DOK_BITMAP: source rect to blt from
        RECT rcClip;        // Clipping rect
        RECT rcLabel;       // Clipping rect for label
        };

    } DOBJ,  * LPDOBJ;


void PUBLIC Dobj_Draw(HDC hdc, LPDOBJ pdobj, int cItems, UINT uState, int cxEllipses, int cyText, COLORREF clrBkgnd);

void PUBLIC ComputeImageRects(LPCTSTR psz, HDC hdc, LPPOINT ppt, LPRECT prcIcon, LPRECT prcLabel, int cxIcon, int cyIcon, int cxIconSpacing, int cyText);

#endif // __DOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\dobj.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: dobj.c
//
//  This file contains support routines for the reconciliation-action 
//   control class code
//
//
// History:
//  09-13-93 ScottH     Extracted from recact.c
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers
#include "res.h"
#include "recact.h"
#include "dobj.h"

/////////////////////////////////////////////////////  CONTROLLING DEFINES


/////////////////////////////////////////////////////  DEFINES

#define DT_CALCWRAP     (DT_CALCRECT | DT_CENTER | DT_WORDBREAK | DT_NOPREFIX)
#define DT_CALC         (DT_CALCRECT | DT_CENTER | DT_SINGLELINE | DT_NOPREFIX)

/*----------------------------------------------------------
Purpose: Formats the given path to the correct location format
Returns: --
Cond:    --
 */
void PRIVATE FormatLocationPath(
        LPCTSTR pszPath,
        LPTSTR pszBuffer,
        int cchMax)         // Must be MAX_PATH
{
    UINT ids;
    TCHAR szBrfDir[MAX_PATH];
    LPCTSTR psz;
    LPTSTR pszMsg;

    //  The format for the directory location is:
    //
    //      Inside briefcase:       "In Briefcase"
    //      Below briefcase:        "In Briefcase\FolderName"
    //      Outside briefcase:      "In FullPath"
    //
    // We assume that paths outside the current briefcase
    //  never consist of a briefcase name of another.
    //
    if (PathGetLocality(pszPath, szBrfDir, ARRAYSIZE(szBrfDir)) != PL_FALSE)
    {
        // Inside the briefcase
        psz = &pszPath[lstrlen(szBrfDir)];
        ids = IDS_InBriefcase;
    }
    else
    {
        // Outside the briefcase
        psz = pszPath;
        ids = IDS_InLocation;
    }

    if (ConstructMessage(&pszMsg, g_hinst, MAKEINTRESOURCE(ids), psz))
    {
        lstrcpyn(pszBuffer, pszMsg, cchMax);
        GFree(pszMsg);
    }
    else
        *pszBuffer = 0;
}


/*----------------------------------------------------------
Purpose: Return the string describing the status of this sideitem
Returns: ptr to status string
Cond:    --
 */
LPTSTR PRIVATE SideItem_GetStatus(
        LPSIDEITEM this,
        LPTSTR pszBuf,
        UINT cchBuf)
{
    switch (this->uState)
    {
        case SI_CHANGED:
            return SzFromIDS(IDS_STATE_Changed, pszBuf, cchBuf);
        case SI_UNCHANGED:
            return SzFromIDS(IDS_STATE_Unchanged, pszBuf, cchBuf);
        case SI_NEW:
            return SzFromIDS(IDS_STATE_NewFile, pszBuf, cchBuf);
        case SI_UNAVAILABLE:
            return SzFromIDS(IDS_STATE_Unavailable, pszBuf, cchBuf);
        case SI_NOEXIST:
            return SzFromIDS(IDS_STATE_DoesNotExist, pszBuf, cchBuf);
        case SI_DELETED:
            return SzFromIDS(IDS_STATE_Deleted, pszBuf, cchBuf);
        default:
            ASSERT(0);
            return NULL;
    }
}


/*----------------------------------------------------------
Purpose: Displays the 3-liner: location, status, and timestamp
Returns: --
Cond:    --
 */
void PRIVATE SideItem_Display(
        LPSIDEITEM this,
        HDC hdc,
        LPRECT prc,
        int cxEllipses,
        int cyText)
{
    TCHAR sz[MAX_PATH];
    TCHAR szBuf[MAXBUFLEN];
    LPTSTR psz;
    RECT rc = *prc;

    // Directory location.  

    FormatLocationPath(this->pszDir, sz, ARRAYSIZE(sz));
    MyDrawText(hdc, sz, &rc, MDT_LEFT | MDT_TRANSPARENT | MDT_ELLIPSES, 
            cyText, cxEllipses, CLR_DEFAULT, CLR_DEFAULT);

    // Status string
    psz = SideItem_GetStatus(this, szBuf, ARRAYSIZE(szBuf));
    if (psz)
    {
        // Only bother with these two lines if the file actually
        // exists.

        rc.top += cyText;
        MyDrawText(hdc, psz, &rc, MDT_LEFT | MDT_TRANSPARENT, 
                cyText, cxEllipses, CLR_DEFAULT, CLR_DEFAULT);

        // Date stamp.  Skip this if this is a folder or unavailable.
        //
        if (SI_DELETED != this->uState && 
                SI_NOEXIST != this->uState &&
                SI_UNAVAILABLE != this->uState &&
                FS_COND_UNAVAILABLE != this->fs.fscond) // hack for folders
        {
            FileTimeToDateTimeString(&this->fs.ftMod, sz, ARRAYSIZE(sz));

            rc.top += cyText;
            MyDrawText(hdc, sz, &rc, MDT_LEFT | MDT_TRANSPARENT, 
                    cyText, cxEllipses, CLR_DEFAULT, CLR_DEFAULT);
        }
    }
}


/*----------------------------------------------------------
Purpose: Return the bounding rect for a labelled image.

Returns: --
Cond:    --
 */
void PUBLIC ComputeImageRects(
        LPCTSTR psz,
        HDC hdc,
        LPPOINT pptInOut,       
        LPRECT prcWhole,        // May be NULL
        LPRECT prcLabel,        // May be NULL
        int cxIcon,
        int cyIcon,
        int cxIconSpacing,
        int cyText)
{
    RECT rc;
    int yLabel;
    int cxLabel;
    int cyLabel;
    int cchLabel;
    POINT pt;

    ASSERT(psz);

    // Set our minimum rect size for icon spacing
    if (cxIconSpacing < cxIcon)
        cxIconSpacing = cxIcon + g_cxIconMargin * 2;

    // Upon entry, *pptInOut is expected to be the upper left corner of the 
    // icon-spacing rect.  This function will set it to the upper left
    // corner of the icon itself.

    pt.x = pptInOut->x + (cxIconSpacing - cxIcon) / 2;
    pt.y = pptInOut->y + g_cyIconMargin;

    // Determine rectangle of label with wrap

    rc.left = rc.top = rc.bottom = 0;
    rc.right = cxIconSpacing - g_cxLabelMargin * 2;

    cchLabel = lstrlen(psz);
    if (0 < cchLabel)
    {
        DrawText(hdc, psz, cchLabel, &rc, DT_CALCWRAP);
    }
    else
    {
        rc.bottom = rc.top + cyText;
    }

    yLabel = pptInOut->y + g_cyIconMargin + cyIcon + g_cyLabelSpace;
    cxLabel = (rc.right - rc.left) + 2 * g_cxLabelMargin;
    cyLabel = rc.bottom - rc.top;

    if (prcWhole)
    {
        prcWhole->left   = pptInOut->x;
        prcWhole->right  = prcWhole->left + cxIconSpacing;
        prcWhole->top    = pptInOut->y;
        prcWhole->bottom = max(prcWhole->top + g_cyIconSpacing,
                yLabel + cyLabel + g_cyLabelSpace);
    }

    if (prcLabel)
    {
        prcLabel->left = pptInOut->x + ((cxIconSpacing - cxLabel) / 2);
        prcLabel->right = prcLabel->left + cxLabel;
        prcLabel->top = yLabel;
        prcLabel->bottom = prcLabel->top + cyLabel;
    }

    *pptInOut = pt;
}


/*----------------------------------------------------------
Purpose: Set the colors for the given HDC.  The previous colors
are stored in pcrText and pcrBk.

Returns: uStyle to pass to ImageList_Draw (specific to images only)
Cond:    --
 */
UINT PRIVATE Dobj_SetColors(
        LPDOBJ this,
        HDC hdc,
        UINT uState,
        COLORREF clrBkgnd)
{
    COLORREF clrText;
    COLORREF clrBk;
    UINT uStyleILD = ILD_NORMAL;
    BOOL bSetColors = FALSE;
    BOOL bDiffer;
    BOOL bMenu;
    BOOL bDisabled;

    // Determine selection colors
    //
    bDiffer = IsFlagSet(this->uFlags, DOF_DIFFER);
    bMenu = IsFlagSet(this->uFlags, DOF_MENU);
    bDisabled = IsFlagSet(this->uFlags, DOF_DISABLED);

    switch (this->uKind)
    {
        case DOK_STRING:
        case DOK_IDS:
        case DOK_SIDEITEM:
            bSetColors = TRUE;
            break;
    }

    // Set the text and background colors
    //
    if (bSetColors)
    {
        if (bDiffer)
        {
            // Make the colors differ based on selection state
            //
            if (bMenu)
            {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(ColorMenuText(uState));

                clrBk = GetSysColor(ColorMenuBk(uState));
            }
            else
            {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(ColorText(uState));

                clrBk = GetSysColor(ColorBk(uState));
            }
        }
        else
        {
            // Transparent colors
            //
            if (bMenu)
            {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(COLOR_MENUTEXT);

                clrBk = GetSysColor(COLOR_MENU);
            }
            else
            {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(COLOR_WINDOWTEXT);

                clrBk = clrBkgnd;
            }
        }
        SetTextColor(hdc, clrText);
        SetBkColor(hdc, clrBk);
    }

    return uStyleILD;
}


/*----------------------------------------------------------
Purpose: Draw the menu image and text
Returns: --
Cond:    --
 */
void PRIVATE Dobj_DrawMenuImage(
        LPDOBJ this,
        HDC hdc,
        UINT uState,
        int cyText,
        COLORREF clrBkgnd)
{
    UINT uStyleILD;
    UINT uFlagsETO;
    LPCTSTR psz;
    TCHAR szIDS[MAXBUFLEN];
    int cch;
    HIMAGELIST himl = this->himl;
    COLORREF clrText;
    COLORREF clrBk;
    int x;
    int y;
    int cxIcon;
    RECT rc;

    if (IsFlagSet(this->uFlags, DOF_USEIDS))
        psz = SzFromIDS(PtrToUlong(this->lpvObject), szIDS, ARRAYSIZE(szIDS));
    else
        psz = (LPCTSTR)this->lpvObject;

    ASSERT(psz);

    cch = lstrlen(psz);
    ImageList_GetImageRect(himl, this->iImage, &rc);
    cxIcon = rc.right-rc.left;

    // Draw the text first

    uFlagsETO = ETO_OPAQUE | ETO_CLIPPED;
    x = this->rcLabel.left + g_cxMargin + cxIcon + g_cxMargin;
    y = this->rcLabel.top + ((this->rcLabel.bottom - this->rcLabel.top - cyText) / 2);

    if (IsFlagSet(this->uFlags, DOF_DISABLED) && 
            IsFlagClear(uState, ODS_SELECTED))
    {
        int imodeOld;
        COLORREF crOld;

        // For disabled menu strings (not selected), we draw the string 
        // twice.  The first is offset down and to the right and drawn 
        // in the 3D hilight color.  The second time is the disabled text
        // color in the normal offset.
        //
        crOld = SetTextColor(hdc, GetSysColor(COLOR_3DHILIGHT));
        imodeOld = SetBkMode(hdc, TRANSPARENT);
        ExtTextOut(hdc, x+1, y+1, uFlagsETO, &this->rcLabel, psz, cch, NULL);

        // Reset back to original color.  Also, turn off the opaqueness.
        //
        SetTextColor(hdc, crOld);
        uFlagsETO ^= ETO_OPAQUE;
    }

    if (IsFlagSet(this->uFlags, DOF_DISABLED))
        clrText = GetSysColor(COLOR_GRAYTEXT);
    else
        clrText = GetSysColor(ColorMenuText(uState));

    clrBk = GetSysColor(ColorMenuBk(uState));
    SetTextColor(hdc, clrText);
    SetBkColor(hdc, clrBk);

    ExtTextOut(hdc, x, y, uFlagsETO, &this->rcLabel, psz, cch, NULL);

    // Draw the image

    if (GetBkColor(hdc) == ImageList_GetBkColor(himl))
        uStyleILD = ILD_NORMAL;     // Paint quicker
    else
        uStyleILD = ILD_TRANSPARENT;

    ImageList_Draw(himl, this->iImage, hdc, this->x, this->y, uStyleILD);
}


/*----------------------------------------------------------
Purpose: Draw the icon image and label
Returns: --
Cond:    --
 */
void PRIVATE Dobj_DrawIconImage(
        LPDOBJ this,
        HDC hdc,
        UINT uState,
        int cxEllipses,
        int cyText,
        COLORREF clrBkgnd)
{
    UINT uStyleILD;
    UINT uFlagsMDT;
    LPCTSTR psz;
    TCHAR szIDS[MAXBUFLEN];

    if (IsFlagSet(this->uFlags, DOF_USEIDS))
        psz = SzFromIDS(PtrToUlong(this->lpvObject), szIDS, ARRAYSIZE(szIDS));
    else
        psz = (LPCTSTR)this->lpvObject;

    ASSERT(psz);

    // Draw the image
    //
    if (IsFlagClear(this->uFlags, DOF_IGNORESEL))
    {
        uStyleILD = GetImageDrawStyle(uState);
        uFlagsMDT = IsFlagSet(uState, ODS_SELECTED) ? MDT_SELECTED : MDT_DESELECTED;
    }
    else
    {
        uStyleILD = ILD_NORMAL;
        uFlagsMDT = MDT_DESELECTED;
        ClearFlag(uState, ODS_FOCUS);
    }

    ImageList_Draw(this->himl, this->iImage, hdc, this->x, this->y, uStyleILD);

    // Draw the file label.  Wrap if it is long.

    if (this->rcLabel.bottom - this->rcLabel.top > cyText)
        uFlagsMDT |= MDT_DRAWTEXT;

    MyDrawText(hdc, psz, &this->rcLabel, MDT_CENTER | uFlagsMDT, cyText, 
            cxEllipses, CLR_DEFAULT, clrBkgnd);

    // (uState may have been changed above)
    if (IsFlagSet(uState, ODS_FOCUS))
        DrawFocusRect(hdc, &this->rcLabel);
}


#ifdef UNUSED
/*----------------------------------------------------------
Purpose: Draw a picture
Returns: --
Cond:    --
 */
void PRIVATE Dobj_DrawPicture(
        LPDOBJ this,
        HDC hdc,
        UINT uState,
        UINT uDrawStyle)
{
    HIMAGELIST himl;
    HDC hdcMem;
    HBITMAP hbmp;
    BITMAP bm;
    RECT rc;
    int iImage;
    int cx;
    int x;
    int y;

    switch (this->uKind)
    {
        case DOK_BITMAP:
            hbmp = (HBITMAP)this->lpvObject;
            GetObject(hbmp, sizeof(BITMAP), &bm);
            cx = this->rcSrc.right - this->rcSrc.left;
            break;

        case DOK_ICON:
            cx = 32;
            break;
    }

    // We only align horizontally
    //
    y = this->y;
    if (IsFlagSet(this->uFlags, DOF_CENTER))
        x = this->x - (cx / 2);
    else if (IsFlagSet(this->uFlags, DOF_RIGHT))
        x = this->x - cx;
    else
        x = this->x;

    // Draw the object
    //
    switch (this->uKind)
    {
        case DOK_ICON:
            // FEATURE: we don't handle DOF_DIFFER for icons
            DrawIcon(hdc, x, y, (HICON)this->lpvObject);
            break;

        case DOK_BITMAP:
            hdcMem = CreateCompatibleDC(hdc);
            if (hdcMem)
            {
                SIZE size;

                SelectBitmap(hdcMem, hbmp);

                size.cx = this->rcSrc.right - this->rcSrc.left;
                size.cy = this->rcSrc.bottom - this->rcSrc.top;

                if (IsFlagSet(this->uFlags, DOF_MENU) && 
                        IsFlagSet(this->uFlags, DOF_DISABLED) && 
                        IsFlagClear(uState, ODS_SELECTED))
                {
                    COLORREF crOld;

                    // For disabled menu strings (not selected), we draw the bitmap 
                    //  twice.  The first is offset down and to the right and drawn 
                    //  in the 3D hilight color.  The second time is the disabled 
                    //  color in the normal offset.
                    //
                    crOld = SetTextColor(hdc, GetSysColor(COLOR_3DHILIGHT));
                    BitBlt(hdc, x+1, y+1, size.cx, size.cy, hdcMem, this->rcSrc.left, 
                            this->rcSrc.top,  SRCCOPY);

                    // Reset back to original color.  Also, turn off the opaqueness.
                    //
                    SetTextColor(hdc, crOld);
                }

                BitBlt(hdc, x, y, size.cx, size.cy, hdcMem, this->rcSrc.left, this->rcSrc.top,  SRCCOPY);
                DeleteDC(hdcMem);
            }
            break;
    }
}
#endif

/*----------------------------------------------------------
Purpose: Draw a string
Returns: --
Cond:    --
 */
void PRIVATE Dobj_DrawString(
        LPDOBJ this,
        HDC hdc,
        UINT uState,
        int cxEllipses,
        int cyText)
{
    UINT ufAlignSav;

    ASSERT(this);

    // Prep the alignment
    //
    if (this->uFlags & (DOF_LEFT | DOF_CENTER | DOF_RIGHT))
    {
        UINT ufMode;

        ufMode = IsFlagSet(this->uFlags, DOF_CENTER) ? TA_CENTER :
            (IsFlagSet(this->uFlags, DOF_RIGHT) ? TA_RIGHT : TA_LEFT);
        ufAlignSav = SetTextAlign(hdc, ufMode);
    }

    // Draw the string
    //
    switch (this->uKind)
    {
        case DOK_IDS:
        case DOK_STRING:
            {
                TCHAR szBuf[MAXBUFLEN];
                LPTSTR lpsz;
                UINT uflag = ETO_OPAQUE;

                if (this->uKind == DOK_IDS)
                    lpsz = SzFromIDS(PtrToUlong(this->lpvObject), szBuf, ARRAYSIZE(szBuf));
                else
                    lpsz = (LPTSTR)this->lpvObject;

                if (!IsRectEmpty(&this->rcClip))
                    uflag |= ETO_CLIPPED;

                if (IsFlagSet(this->uFlags, DOF_MENU) && 
                        IsFlagSet(this->uFlags, DOF_DISABLED) && 
                        IsFlagClear(uState, ODS_SELECTED))
                {
                    int imodeOld;
                    COLORREF crOld;

                    // For disabled menu strings (not selected), we draw the string 
                    //  twice.  The first is offset down and to the right and drawn 
                    //  in the 3D hilight color.  The second time is the disabled text
                    //  color in the normal offset.
                    //
                    crOld = SetTextColor(hdc, GetSysColor(COLOR_3DHILIGHT));
                    imodeOld = SetBkMode(hdc, TRANSPARENT);
                    ExtTextOut(hdc, this->x+1, this->y+1, uflag, &this->rcClip, lpsz,
                            lstrlen(lpsz), NULL);

                    // Reset back to original color.  Also, turn off the opaqueness.
                    //
                    SetTextColor(hdc, crOld);
                    uflag ^= ETO_OPAQUE;
                }

                ExtTextOut(hdc, this->x, this->y, uflag, &this->rcClip, lpsz,
                        lstrlen(lpsz), NULL);
            }
            break;

        case DOK_SIDEITEM:
            SideItem_Display((LPSIDEITEM)this->lpvObject, hdc, &this->rcClip, 
                    cxEllipses, cyText);
            break;
    }

    // Clean up
    //
    if (this->uFlags & (DOF_LEFT | DOF_CENTER | DOF_RIGHT))
    {
        SetTextAlign(hdc, ufAlignSav);
    }
}


/*----------------------------------------------------------
Purpose: Draw an object
Returns: --
Cond:    --
 */
void PUBLIC Dobj_Draw(
        HDC hdc,
        LPDOBJ rgdobj,
        int cItems,
        UINT uState,            // ODS_*
        int cxEllipses,
        int cyText,
        COLORREF clrBkgnd)
{
    UINT uDrawStyle;
    LPDOBJ pdobj;
    int i;

    ASSERT(rgdobj);

    //Bug 199701, 199647, 199699
    if (g_bMirroredOS)
    {
        SetLayout(hdc, LAYOUT_RTL);
    }
    //End bug 199701, 199647, 199699

    for (i = 0, pdobj = rgdobj; i < cItems; i++, pdobj++)
    {
        if (IsFlagSet(pdobj->uFlags, DOF_NODRAW))
            continue ;

        uDrawStyle = Dobj_SetColors(pdobj, hdc, uState, clrBkgnd);

        // Draw the object
        //
        switch (pdobj->uKind)
        {
            case DOK_IMAGE:
                if (IsFlagSet(pdobj->uFlags, DOF_MENU))
                    Dobj_DrawMenuImage(pdobj, hdc, uState, cyText, clrBkgnd);
                else
                    Dobj_DrawIconImage(pdobj, hdc, uState, cxEllipses, cyText, clrBkgnd);
                break;

#ifdef UNUSED
            case DOK_BITMAP:
            case DOK_ICON:
                Dobj_DrawPicture(pdobj, hdc, uState, uDrawStyle);
                break;
#endif

            case DOK_IDS:
            case DOK_STRING:
            case DOK_SIDEITEM:
                Dobj_DrawString(pdobj, hdc, uState, cxEllipses, cyText);
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\cstrings.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cstrings.h
//
//---------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

extern TCHAR const  c_szNULL[];
extern TCHAR const  c_szZero[];
extern TCHAR const  c_szDelim[];
extern TCHAR const  c_szAllFiles[];
extern TCHAR const  c_szEllipses[];

// Class names

// Executable and DLL names

extern TCHAR const  c_szEngineDLL[];
extern TCHAR const  c_szCabinet[];
extern TCHAR const  c_szCabinetClass[];
extern TCHAR const  c_szWinHelpFile[];
extern TCHAR const  c_szDllGetClassObject[];
extern TCHAR const  c_szOpen[];

#ifdef DEBUG

// These declarations are located in err.c
//
extern TCHAR const  c_szNewline[];
extern TCHAR const  c_szTrace[];
extern TCHAR const  c_szDbg[];
extern TCHAR const  c_szAssertFailed[];

#endif

// Ini file name

extern TCHAR const  c_szIniFile[];
extern TCHAR const  c_szDesktopIni[];
extern TCHAR const  c_szRunWizard[];

// Ini section names

extern TCHAR const  c_szIniSecExclude[];
extern TCHAR const  c_szIniSecFilter[];
extern TCHAR const  c_szIniSecBriefcase[];

#ifdef DEBUG

extern TCHAR const  c_szIniSecDebugUI[];

#endif

// Ini key names

extern TCHAR const  c_szIniKeyCLSID[];
extern TCHAR const  c_szCLSID[];

extern TCHAR const  c_szIniKeyPBar[];
extern TCHAR const  c_szIniKeyFile[];
extern TCHAR const  c_szIniKeyType[];

#ifdef DEBUG

extern TCHAR const  c_szIniKeyTraceFlags[];
extern TCHAR const  c_szIniKeyDumpFlags[];
extern TCHAR const  c_szIniKeyBreakOnOpen[];
extern TCHAR const  c_szIniKeyBreakOnClose[];
extern TCHAR const  c_szIniKeyBreakOnRunOnce[];
extern TCHAR const  c_szIniKeyBreakOnValidate[];
extern TCHAR const  c_szIniKeyBreakOnThreadAtt[];
extern TCHAR const  c_szIniKeyBreakOnThreadDet[];
extern TCHAR const  c_szIniKeyBreakOnProcessAtt[];
extern TCHAR const  c_szIniKeyBreakOnProcessDet[];

#endif


#endif  // _CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\err.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: err.c
//
//  This files contains all error handling routines.
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------


/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"     // common headers

/////////////////////////////////////////////////////  TYPEDEFS

/////////////////////////////////////////////////////  CONTROLLING DEFINES

/////////////////////////////////////////////////////  DEFINES

/////////////////////////////////////////////////////  MODULE DATA

#ifdef DEBUG

TCHAR const  c_szNewline[] = TEXT("\r\n");
TCHAR const  c_szTrace[] = TEXT("t BRIEFCASE  ");
TCHAR const  c_szDbg[] = TEXT("BRIEFCASE  ");
TCHAR const  c_szAssertFailed[] = TEXT("BRIEFCASE  Assertion failed in %s on line %d\r\n");

struct _RIIDMAP
{
    REFIID  riid;
    LPCTSTR  psz;
} const c_rgriidmap[] = {
    { &IID_IUnknown,        TEXT("IID_IUnknown") },
    { &IID_IBriefcaseStg,   TEXT("IID_IBriefcaseStg") },
    { &IID_IEnumUnknown,    TEXT("IID_IEnumUnknown") },
    { &IID_IShellBrowser,   TEXT("IID_IShellBrowser") },
    { &IID_IShellView,      TEXT("IID_IShellView") },
    { &IID_IContextMenu,    TEXT("IID_IContextMenu") },
    { &IID_IShellFolder,    TEXT("IID_IShellFolder") },
    { &IID_IShellExtInit,   TEXT("IID_IShellExtInit") },
    { &IID_IShellPropSheetExt, TEXT("IID_IShellPropSheetExt") },
    { &IID_IPersistFolder,  TEXT("IID_IPersistFolder") },
    { &IID_IExtractIcon,    TEXT("IID_IExtractIcon") },
    { &IID_IShellDetails,   TEXT("IID_IShellDetails") },
    { &IID_IDelayedRelease, TEXT("IID_IDelayedRelease") },
    { &IID_IShellLink,      TEXT("IID_IShellLink") },
};

struct _SCODEMAP
{
    SCODE  sc;
    LPCTSTR psz;
} const c_rgscodemap[] = {
    { S_OK,             TEXT("S_OK") },
    { S_FALSE,          TEXT("S_FALSE") },
    { E_UNEXPECTED,     TEXT("E_UNEXPECTED") },
    { E_NOTIMPL,        TEXT("E_NOTIMPL") },
    { E_OUTOFMEMORY,    TEXT("E_OUTOFMEMORY") },
    { E_INVALIDARG,     TEXT("E_INVALIDARG") },
    { E_NOINTERFACE,    TEXT("E_NOINTERFACE") },
    { E_POINTER,        TEXT("E_POINTER") },
    { E_HANDLE,         TEXT("E_HANDLE") },
    { E_ABORT,          TEXT("E_ABORT") },
    { E_FAIL,           TEXT("E_FAIL") },
    { E_ACCESSDENIED,   TEXT("E_ACCESSDENIED") },
};


#endif

/////////////////////////////////////////////////////  PUBLIC FUNCTIONS


#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Return English reason for the debug break
Returns: String
Cond:    --
 */
LPCTSTR PRIVATE GetReasonString(
        UINT flag)      // One of BF_ flags
{
    LPCTSTR psz;

    if (IsFlagSet(flag, BF_ONOPEN))
        psz = TEXT("BREAK ON OPEN BRIEFCASE\r\n");

    else if (IsFlagSet(flag, BF_ONCLOSE))
        psz = TEXT("BREAK ON CLOSE BRIEFCASE\r\n");

    else if (IsFlagSet(flag, BF_ONRUNONCE))
        psz = TEXT("BREAK ON RunDLL_RunOnlyOnce\r\n");

    else if (IsFlagSet(flag, BF_ONVALIDATE))
        psz = TEXT("BREAK ON VALIDATION FAILURE\r\n");

    else if (IsFlagSet(flag, BF_ONTHREADATT))
        psz = TEXT("BREAK ON THREAD ATTACH\r\n");

    else if (IsFlagSet(flag, BF_ONTHREADDET))
        psz = TEXT("BREAK ON THREAD DETACH\r\n");

    else if (IsFlagSet(flag, BF_ONPROCESSATT))
        psz = TEXT("BREAK ON PROCESS ATTACH\r\n");

    else if (IsFlagSet(flag, BF_ONPROCESSDET))
        psz = TEXT("BREAK ON PROCESS DETACH\r\n");

    else
        psz = c_szNewline;

    return psz;
}


/*----------------------------------------------------------
Purpose: Perform a debug break based on the flag
Returns: --
Cond:    --
 */
void PUBLIC DEBUG_BREAK(
        UINT flag)      // One of BF_ flags
{
    BOOL bBreak;
    LPCTSTR psz;

    ENTEREXCLUSIVE();
    {
        bBreak = IsFlagSet(g_uBreakFlags, flag);
        psz = GetReasonString(flag);
    }
    LEAVEEXCLUSIVE();

    if (bBreak)
    {
        TRACE_MSG(TF_ALWAYS, psz);
        DebugBreak();
    }
}


void PUBLIC BrfAssertFailed(
        LPCTSTR pszFile, 
        int line)
{
    LPCTSTR psz;
    TCHAR ach[256];
    UINT uBreakFlags;

    ENTEREXCLUSIVE();
    {
        uBreakFlags = g_uBreakFlags;
    }
    LEAVEEXCLUSIVE();

    // Strip off path info from filename string, if present.
    //
    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=CharPrev(pszFile, psz))
    {
        if ((CharPrev(pszFile, psz) != (psz-2)) && *(psz - 1) == TEXT('\\'))
            break;
    }
    wnsprintf(ach, ARRAYSIZE(ach), c_szAssertFailed, psz, line);
    OutputDebugString(ach);

    if (IsFlagSet(uBreakFlags, BF_ONVALIDATE))
        DebugBreak();
}


void CPUBLIC BrfAssertMsg(
        BOOL f, 
        LPCTSTR pszMsg, ...)
{
    TCHAR ach[MAXPATHLEN+40];    // Largest path plus extra

    if (!f)
    {
        lstrcpyn(ach, c_szTrace, ARRAYSIZE(ach));
        StringCchVPrintf(&ach[ARRAYSIZE(c_szTrace)-1], ARRAYSIZE(ach) - ARRAYSIZE(c_szTrace) + 1, 
                pszMsg, (va_list)(&pszMsg + 1));
        OutputDebugString(ach);
        OutputDebugString(c_szNewline);
    }
}


void CPUBLIC BrfDebugMsg(
        UINT uFlag, 
        LPCTSTR pszMsg, ...)
{
    TCHAR ach[MAXPATHLEN+40];    // Largest path plus extra
    UINT uTraceFlags;

    ENTEREXCLUSIVE();
    {
        uTraceFlags = g_uTraceFlags;
    }
    LEAVEEXCLUSIVE();

    if (uFlag == TF_ALWAYS || IsFlagSet(uTraceFlags, uFlag))
    {
        lstrcpyn(ach, c_szTrace, ARRAYSIZE(ach));
        StringCchVPrintf(&ach[ARRAYSIZE(c_szTrace)-1], ARRAYSIZE(ach) - ARRAYSIZE(c_szTrace) + 1, 
                pszMsg, (va_list)(&pszMsg + 1));
        OutputDebugString(ach);
        OutputDebugString(c_szNewline);
    }
}


/*----------------------------------------------------------
Purpose: Returns the string form of an known interface ID.

Returns: String ptr
Cond:    --
 */
LPCTSTR PUBLIC Dbg_GetRiidName(
        REFIID riid)
{
    int i;

    for (i = 0; i < ARRAYSIZE(c_rgriidmap); i++)
    {
        if (IsEqualIID(riid, c_rgriidmap[i].riid))
            return c_rgriidmap[i].psz;
    }
    return TEXT("Unknown riid");
}


/*----------------------------------------------------------
Purpose: Returns the string form of an scode given an hresult.

Returns: String ptr
Cond:    --
 */
LPCTSTR PUBLIC Dbg_GetScode(
        HRESULT hres)
{
    int i;
    SCODE sc;

    sc = GetScode(hres);
    for (i = 0; i < ARRAYSIZE(c_rgscodemap); i++)
    {
        if (sc == c_rgscodemap[i].sc)
            return c_rgscodemap[i].psz;
    }
    return TEXT("Unknown scode");
}


/*----------------------------------------------------------
Purpose: Returns a string safe enough to print...and I don't
mean swear words.

Returns: String ptr
Cond:    --
 */
LPCTSTR PUBLIC Dbg_SafeStr(
        LPCTSTR psz)
{
    if (psz)
        return psz;
    else
        return TEXT("NULL");
}


/*----------------------------------------------------------
Purpose: Returns a string safe enough to print given an IDataObject.

Returns: String ptr
Cond:    --
 */
LPCTSTR PUBLIC Dbg_DataObjStr(
        LPDATAOBJECT pdtobj,
        LPTSTR pszBuf,
        int cchMax)
{
    if (pdtobj)
    {
        DataObj_QueryPath(pdtobj, pszBuf, cchMax);
    }
    else
    {
        lstrcpyn(pszBuf, TEXT("NULL"), cchMax);
    }
    return pszBuf;
}


#endif  // DEBUG


/*----------------------------------------------------------
Purpose: This function maps the hresult to an hresult in the 
error table, and displays the corresponding string
in a messagebox.

Returns: return value of MessageBox
Cond:    --
 */
int PUBLIC SEMsgBox(
        HWND hwnd,
        UINT idsCaption,
        HRESULT hres,
        PCSETBL pTable,
        UINT cArraySize)        // Number of elements in table
{
    PCSETBL p;
    PCSETBL pEnd;

    p = pTable;
    pEnd = &pTable[cArraySize-1];
    while (p != pEnd)
    {
        if (p->hres == hres)
        {
            return MsgBox(hwnd, MAKEINTRESOURCE(p->ids), MAKEINTRESOURCE(idsCaption), 
                    NULL, p->uStyle);
        }
        p++;
    }

    // Cover last entry
    if (p->hres == hres)
    {
        return MsgBox(hwnd, MAKEINTRESOURCE(p->ids), MAKEINTRESOURCE(idsCaption), 
                NULL, p->uStyle);
    }

    return -1;
}


/*----------------------------------------------------------
Purpose: Maps an hresult to a valid "official" hresult.  This
is necessary because the SYNCUI uses a FACILITY_TR
which is only good for us, but unknown to the outside
world.

Returns: hresult
Cond:    --
 */
HRESULT PUBLIC MapToOfficialHresult(
        HRESULT hres)
{
    if (IS_ENGINE_ERROR(hres))
    {
        SCODE sc = GetScode(hres);

        if (E_TR_OUT_OF_MEMORY == sc)
            hres = ResultFromScode(E_OUTOFMEMORY);
        else
            hres = ResultFromScode(E_FAIL);
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\err.h ===
//
// err.h: Declares data, defines and struct types for error handling
//          module.
//
//

#ifndef __ERR_H__
#define __ERR_H__

// Requires comm.h to be included prior to this
//

/////////////////////////////////////////////////////  INCLUDES
/////////////////////////////////////////////////////  DEFINES

#ifdef DEBUG

// Dump flags used in g_uDumpFlags
//
#define DF_RECLIST      0x0001
#define DF_RECITEM      0x0002
#define DF_RECNODE      0x0004
#define DF_CREATETWIN   0x0008
#define DF_ATOMS        0x0010
#define DF_CRL          0x0020
#define DF_CBS          0x0040
#define DF_CPATH        0x0080
#define DF_PATHS        0x0100
#define DF_UPDATECOUNT  0x0200
#define DF_TWINPAIR     0x0400
#define DF_FOLDERTWIN   0x0800
#define DF_CHOOSESIDE   0x1000

// Break flags used in g_uBreakFlags
//
#define BF_ONOPEN       0x0001
#define BF_ONCLOSE      0x0002
#define BF_ONRUNONCE    0x0004
#define BF_ONVALIDATE   0x0010
#define BF_ONTHREADATT  0x0100
#define BF_ONTHREADDET  0x0200
#define BF_ONPROCESSATT 0x0400
#define BF_ONPROCESSDET 0x0800

#endif

// Trace flags used in g_uTraceFlags (defined in retail on purpose)
//
#define TF_ALWAYS       0x0000
#define TF_WARNING      0x0001
#define TF_ERROR        0x0002
#define TF_GENERAL      0x0004      // Standard briefcase trace messages
#define TF_FUNC         0x0008      // Trace function calls
#define TF_CACHE        0x0010      // Cache-specific trace messages
#define TF_ATOM         0x0020      // Atom-specific trace messages
#define TF_PROGRESS     0x0040      // Progress bar deltas

//---------------------------------------------------------------------------
// HRESULT error codes
//---------------------------------------------------------------------------

// Map a TWINRESULT error value into a HRESULT
// Note: TR_SUCCESS should not be mapped
// Note: This assumes that TWINRESULT errors fall in the range -32k to 32k.
//
#define TR_DELTAVALUE           1000
#define FACILITY_TR             0x018a          // magic number

#define HRESULT_FROM_TR(x)      (TR_SUCCESS == (x) ? NOERROR : \
((HRESULT) ((((x) + TR_DELTAVALUE) & 0x0000FFFF) | (FACILITY_TR << 16) | 0x80000000)))
#define IS_ENGINE_ERROR(hr)     IsFlagSet(hr, ((FACILITY_TR << 16) | 0x80000000))
#define GET_TR(hr)              ((TWINRESULT)((hr) & 0x0000FFFF) - TR_DELTAVALUE)

HRESULT PUBLIC MapToOfficialHresult(HRESULT hres);

// SCODE values that correspond to TWINRESULT values
#define E_TR_RH_LOAD_FAILED         MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_RH_LOAD_FAILED)
#define E_TR_SRC_OPEN_FAILED        MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SRC_OPEN_FAILED)
#define E_TR_SRC_READ_FAILED        MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SRC_READ_FAILED)
#define E_TR_DEST_OPEN_FAILED       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DEST_OPEN_FAILED)
#define E_TR_DEST_WRITE_FAILED      MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DEST_WRITE_FAILED)
#define E_TR_ABORT                  MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_ABORT)
#define E_TR_UNAVAILABLE_VOLUME     MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_UNAVAILABLE_VOLUME)
#define E_TR_OUT_OF_MEMORY          MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_OUT_OF_MEMORY)
#define E_TR_FILE_CHANGED           MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_FILE_CHANGED)
#define E_TR_DUPLICATE_TWIN         MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DUPLICATE_TWIN)
#define E_TR_DELETED_TWIN           MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DELETED_TWIN)
#define E_TR_HAS_FOLDER_TWIN_SRC    MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_HAS_FOLDER_TWIN_SRC)
#define E_TR_INVALID_PARAMETER      MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_INVALID_PARAMETER)
#define E_TR_SAME_FOLDER            MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SAME_FOLDER)
#define E_TR_SUBTREE_CYCLE_FOUND    MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SUBTREE_CYCLE_FOUND)
#define E_TR_NO_MERGE_HANDLER       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_NO_MERGE_HANDLER)
#define E_TR_MERGE_INCOMPLETE       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_MERGE_INCOMPLETE)
#define E_TR_TOO_DIFFERENT          MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_TOO_DIFFERENT)
#define E_TR_BRIEFCASE_LOCKED       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_LOCKED)
#define E_TR_BRIEFCASE_OPEN_FAILED  MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_OPEN_FAILED)
#define E_TR_BRIEFCASE_READ_FAILED  MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_READ_FAILED)
#define E_TR_BRIEFCASE_WRITE_FAILED MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_WRITE_FAILED)
#define E_TR_CORRUPT_BRIEFCASE      MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_CORRUPT_BRIEFCASE)
#define E_TR_NEWER_BRIEFCASE        MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_NEWER_BRIEFCASE)
#define E_TR_NO_MORE                MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_NO_MORE)

/////////////////////////////////////////////////////  MACROS

// Error table for lookup strings.  Usually an array of these
// structures is created and placed in the readonly data segment.
//
typedef struct _SETbl
{
    HRESULT hres;       // standard result
    UINT    ids;        // String ID of message
    UINT    uStyle;     // MB_ flags
} SETbl, * PSETBL;

typedef SETbl const *  PCSETBL;

int PUBLIC SEMsgBox(HWND hwnd, UINT idsCaption, SCODE sc, PCSETBL pseTable, UINT cArraySize);


// Retry loop
//
#define RETRY_BEGIN(bInit)      {BOOL bMyRetry; do { bMyRetry = (bInit);
#define RETRY_END()             } while (bMyRetry); }
#define RETRY_SET()             bMyRetry = TRUE
#define RETRY_CLEAR()           bMyRetry = FALSE


// Debugging macros
//

#ifdef DEBUG

#define DEBUG_CASE_STRING(x)    case x: return TEXT( #x )

#define ASSERTSEG

// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
static const TCHAR ASSERTSEG sz[] = msg;

void PUBLIC BrfAssertFailed(LPCTSTR szFile, int line);
void CPUBLIC BrfAssertMsg(BOOL f, LPCTSTR pszMsg, ...);
void CPUBLIC BrfDebugMsg(UINT mask, LPCTSTR pszMsg, ...);

// ASSERT(f)  -- Generate "assertion failed in line x of file.c"
//               message if f is NOT true.
//
#define ASSERT(f)                                                   \
{                                                                   \
    DEBUGTEXT(szFile, TEXT(__FILE__));                              \
    if (!(f))                                                       \
    BrfAssertFailed(szFile, __LINE__);                              \
}
#define ASSERT_E(f)  ASSERT(f)

// ASSERT_MSG(f, msg, args...)  -- Generate wsprintf-formatted msg w/params
//                          if f is NOT true.
//
#define ASSERT_MSG   BrfAssertMsg

// DEBUG_MSG(mask, msg, args...) - Generate wsprintf-formatted msg using
//                          specified debug mask.  System debug mask
//                          governs whether message is output.
//
#define DEBUG_MSG    BrfDebugMsg
#define TRACE_MSG    DEBUG_MSG

// VERIFYSZ(f, msg, arg)  -- Generate wsprintf-formatted msg w/ 1 param
//                          if f is NOT true 
//
#define VERIFYSZ(f, szFmt, x)   ASSERT_MSG(f, szFmt, x)


// VERIFYSZ2(f, msg, arg1, arg2)  -- Generate wsprintf-formatted msg w/ 2
//                          param if f is NOT true 
//
#define VERIFYSZ2(f, szFmt, x1, x2)   ASSERT_MSG(f, szFmt, x1, x2)



// DBG_ENTER(szFn)  -- Generates a function entry debug spew for
//                          a function 
//
#define DBG_ENTER(szFn)                  \
TRACE_MSG(TF_FUNC, TEXT(" > ") szFn TEXT("()"))


// DBG_ENTER_SZ(szFn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(szFn, sz)                  \
TRACE_MSG(TF_FUNC, TEXT(" > ") szFn TEXT("(..., \"%s\",...)"), Dbg_SafeStr(sz))


// DBG_ENTER_DTOBJ(szFn, pdtobj, szBuf)  -- Generates a function entry 
//                          debug spew for a function that accepts a 
//                          string as one of its parameters.
//
#define DBG_ENTER_DTOBJ(szFn, pdtobj, szBuf, cchMax) \
TRACE_MSG(TF_FUNC, TEXT(" > ") szFn TEXT("(..., %s,...)"), Dbg_DataObjStr(pdtobj, szBuf, cchMax))


// DBG_ENTER_RIID(szFn, riid)  -- Generates a function entry debug spew for
//                          a function that accepts an riid as one of its
//                          parameters.
//
#define DBG_ENTER_RIID(szFn, riid)                  \
TRACE_MSG(TF_FUNC, TEXT(" > ") szFn TEXT("(..., %s,...)"), Dbg_GetRiidName(riid))


// DBG_EXIT(szFn)  -- Generates a function exit debug spew 
//
#define DBG_EXIT(szFn)                              \
TRACE_MSG(TF_FUNC, TEXT(" < ") szFn TEXT("()"))

// DBG_EXIT_US(szFn, us)  -- Generates a function exit debug spew for
//                          functions that return a USHORT.
//
#define DBG_EXIT_US(szFn, us)                       \
TRACE_MSG(TF_FUNC, TEXT(" < ") szFn TEXT("() with %#x"), (USHORT)us)

// DBG_EXIT_UL(szFn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#define DBG_EXIT_UL(szFn, ul)                   \
TRACE_MSG(TF_FUNC, TEXT(" < ") szFn TEXT("() with %#lx"), (ULONG)ul)

// DBG_EXIT_PTR(szFn, pv)  -- Generates a function exit debug spew for
//                          functions that return a pointer.
//
#define DBG_EXIT_PTR(szFn, pv)                   \
TRACE_MSG(TF_FUNC, TEXT(" < ") szFn TEXT("() with %#lx"), (LPVOID)pv)

// DBG_EXIT_HRES(szFn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(szFn, hres)                   \
TRACE_MSG(TF_FUNC, TEXT(" < ") szFn TEXT("() with %s"), Dbg_GetScode(hres))


#else

#define ASSERT(f)
#define ASSERT_E(f)      (f)
#define ASSERT_MSG   1 ? (void)0 : (void)
#define DEBUG_MSG    1 ? (void)0 : (void)
#define TRACE_MSG    1 ? (void)0 : (void)

#define VERIFYSZ(f, szFmt, x)     (f)

#define DBG_ENTER(szFn)
#define DBG_ENTER_SZ(szFn, sz)
#define DBG_ENTER_DTOBJ(szFn, pdtobj, sz, cchMax)
#define DBG_ENTER_RIID(szFn, riid)   

#define DBG_EXIT(szFn)                            
#define DBG_EXIT_US(szFn, us)
#define DBG_EXIT_UL(szFn, ul)
#define DBG_EXIT_PTR(szFn, ptr)                            
#define DBG_EXIT_HRES(szFn, hres)   

#endif

/////////////////////////////////////////////////////  TYPEDEFS

/////////////////////////////////////////////////////  EXPORTED DATA

/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

#ifdef DEBUG

void PUBLIC DEBUG_BREAK(UINT flag);

LPCTSTR PUBLIC Dbg_GetRiidName(REFIID riid);
LPCTSTR PUBLIC Dbg_GetScode(HRESULT hres);
LPCTSTR PUBLIC Dbg_SafeStr(LPCTSTR psz);
LPCTSTR PUBLIC Dbg_DataObjStr(LPDATAOBJECT pdtobj, LPTSTR pszBuf, int cchMax);

#endif

#endif // __ERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\ibrfstg.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: ibrfstg.c
//
//  This files contains the IBriefcaseStg interface.
//
// History:
//  02-02-94 ScottH     Converted from iface.c
//
//---------------------------------------------------------------------------

#include "brfprv.h"         // common headers
#undef LODWORD              // (because they are redefined by configmg.h)
#undef HIDWORD

#include <brfcasep.h>
#include "recact.h"
#include "res.h"

#include <help.h>

// FEATURE - BobDay - We need some mechanism of determining dock state

//---------------------------------------------------------------------------
// BriefStg Class
//---------------------------------------------------------------------------

// An IBriefcaseStg interface instance is created for each
// folder the caller (the Shell) binds to, where the folder
// is known to be inside a briefcase storage.  A briefcase
// storage is the overall storage area (the database) that
// starts at a given folder (called the "briefcase root")
// and extends onwards and below in the file-system.
//
// Internally, the briefcase storage holds the path to the
// folder that this instance is bound to, and it holds a
// cached briefcase structure (CBS), which itself holds a
// reference to the briefcase root.
//
typedef struct _BriefStg
{
    IBriefcaseStg   bs;
    UINT            cRef;           // reference count
    CBS *           pcbs;           // cached briefcase info
    TCHAR            szFolder[MAX_PATH]; // canonical path
    HBRFCASEITER    hbrfcaseiter;   // handle to iterate briefcases
    DWORD           dwFlags;        // BSTG_* flags
} BriefStg, * PBRIEFSTG;

// Flags for BriefStg
#define BSTG_SYNCFOLDER     0x00000001      // This folder has a sync copy


//---------------------------------------------------------------------------
// Supporting private code
//---------------------------------------------------------------------------


#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Dump all the cache tables
Returns: --
Cond:    --
 */
void PUBLIC DumpTables()
{
    Atom_DumpAll();
    CBS_DumpAll();
    CRL_DumpAll();
}
#endif


/*----------------------------------------------------------
Purpose: Initialize the cache tables
Returns: --
Cond:    --
 */
BOOL PRIVATE InitCacheTables()
{
    ASSERT(Sync_IsEngineLoaded());

    DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Initialize cache tables")); )

        if (!CBS_Init())
            goto Init_Fail;

    if (!CRL_Init())
        goto Init_Fail;

    return TRUE;

Init_Fail:

    CRL_Term();
    CBS_Term(NULL);
    return FALSE;
}


/*----------------------------------------------------------
Purpose: Terminate the cache tables
Returns: --
Cond:    --
 */
void PUBLIC TermCacheTables(void)
{
    ASSERT(Sync_IsEngineLoaded());

    DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Terminate cache tables")); )

        CRL_Term();

    CBS_Term(NULL);
}


/*----------------------------------------------------------
Purpose: Returns TRUE if the path (a folder) has a sync copy.

Returns: see above
Cond:    --
 */
BOOL PRIVATE HasFolderSyncCopy(
        HBRFCASE hbrf,
        LPCTSTR pszPath)
{
    ASSERT(pszPath);
    ASSERT(PathIsDirectory(pszPath));

    return (S_OK == Sync_IsTwin(hbrf, pszPath, SF_ISFOLDER) ||
            IsSubfolderTwin(hbrf, pszPath));
}


/*----------------------------------------------------------
Purpose: Open a folder that belongs to a briefcase storage.
The pszPath parameter is a folder, which is not necessarily
the briefcase root.

Returns: NOERROR on success
Cond:    --
 */
HRESULT PRIVATE OpenBriefcaseStorage(
        LPCTSTR pszPath,
        CBS ** ppcbs,
        HWND hwndOwner)
{
    HRESULT hres;
    UINT uLocality;
    int atomBrf;
    TCHAR szBrfPath[MAX_PATH];
    TCHAR szBrfCanon[MAX_PATH];

    ASSERT(pszPath);
    ASSERT(ppcbs);

    DBG_ENTER_SZ(TEXT("OpenBriefcaseStorage"), pszPath);
    DEBUG_CODE( DEBUG_BREAK(BF_ONOPEN); )

        // Get the root folder of the briefcase storage
        // Get strictly up to the briefcase portion of path
        //
        uLocality = PathGetLocality(pszPath, szBrfPath, ARRAYSIZE(szBrfPath));
    if (PL_FALSE == uLocality)
    {
        // The only time we get here is if the caller had a legitimate
        // reason to believe this folder was a briefcase storage,
        // but no database exists (yet).  Just continue on as normal,
        // the database will get created later.
        BrfPathCanonicalize(pszPath, szBrfCanon, ARRAYSIZE(szBrfCanon));
    }
    else
    {
        BrfPathCanonicalize(szBrfPath, szBrfCanon, ARRAYSIZE(szBrfCanon));
    }

    // Add this path to the atom list and add it to the
    // cached briefcase structure table.
    // (Reference count decrement happens in CloseBriefcase)
    //
    atomBrf = Atom_Add(szBrfCanon);
    if (atomBrf != ATOM_ERR)
    {
        hres = CBS_Add(ppcbs, atomBrf, hwndOwner);
    }
    else
    {
        *ppcbs = NULL;
        hres = ResultFromScode(E_OUTOFMEMORY);
    }

    DEBUG_CODE( DumpTables(); )

        DBG_EXIT_HRES(TEXT("OpenBriefcaseStorage"), hres);

    return hres;
}


/*----------------------------------------------------------
Purpose: Close a briefcase.

Returns: NOERROR on success
Cond:    --
 */
HRESULT PRIVATE CloseBriefcaseStorage(
        LPCTSTR pszPath)
{
    int atomBrf;
    TCHAR szBrfPath[MAX_PATH];
    TCHAR szBrfCanon[MAX_PATH];
    UINT uLocality;

    ASSERT(pszPath);
    ASSERT(*pszPath);       // Should not be an emptry string

    DBG_ENTER_SZ(TEXT("CloseBriefcaseStorage"), pszPath);
    DEBUG_CODE( DEBUG_BREAK(BF_ONCLOSE); )

        DEBUG_CODE( DumpTables(); )

        // Save the briefcase and remove it from the cache
        //
        // Get the root folder of the briefcase storage
        // Get strictly up to the briefcase portion of path
        //
        uLocality = PathGetLocality(pszPath, szBrfPath, ARRAYSIZE(szBrfPath));
    if (PL_FALSE == uLocality)
    {
        // The only time we get here is for a briefcase storage that
        // has no database yet.  Just continue on as normal,
        // the database will get created very soon now.
        BrfPathCanonicalize(pszPath, szBrfCanon, ARRAYSIZE(szBrfCanon));
    }
    else
    {
        BrfPathCanonicalize(szBrfPath, szBrfCanon, ARRAYSIZE(szBrfCanon));
    }

    atomBrf = Atom_Find(szBrfCanon);
    ASSERT(atomBrf != ATOM_ERR);

    CBS_Delete(atomBrf, NULL);

    Atom_Delete(atomBrf);      // for the Add in OpenBriefcaseStorage

    DBG_EXIT_HRES(TEXT("CloseBriefcaseStorage"), NOERROR);

    return NOERROR;
}


// Confirm button flags
#define CBF_YES         0x0001
#define CBF_NO          0x0002
#define CBF_TOALL       0x0004
#define CBF_CANCEL      0x0008

/*----------------------------------------------------------
Purpose: Checks to see if the given file/folder already exists
in the given directory.  Prompts the user to confirm
replacing if this is true.

Returns: TRUE if path exists
confirm flag settings

Cond:    --
 */
BOOL PRIVATE DoesPathAlreadyExist(
        CBS  * pcbs,
        LPCTSTR pszPathOld,
        LPCTSTR pszPathNew,
        LPUINT puConfirmFlags,  // CBF_*
        UINT uFlags,            // SF_ISFOLDER or SF_ISFILE
        HWND hwndOwner,
        BOOL bMultiDrop)
{
    BOOL bRet;
    BOOL bIsTwin;

    ASSERT(puConfirmFlags);

    // Retain settings of *puConfirmFlags coming in

    bIsTwin = (S_OK == Sync_IsTwin(pcbs->hbrf, pszPathOld, uFlags));
    if (bIsTwin)
        uFlags |= SF_ISTWIN;
    else
        uFlags |= SF_ISNOTTWIN;

    bRet = (FALSE != PathExists(pszPathOld));

    // Does the path already exist?
    if (!bRet)
    {
        // No; remove it from the database if it is in there so we
        // don't add duplicates.
        Sync_Split(pcbs->hbrf, pszPathOld, 1, hwndOwner, uFlags | SF_QUIET | SF_NOCONFIRM);
    }
    else
    {
        // Yes; has a "to all" previously been specified by the user?
        if (IsFlagSet(*puConfirmFlags, CBF_TOALL))
        {
            // Yes; keep flags as they are

            // (CBF_YES and CBF_NO flags are mutually exclusive)
            ASSERT(IsFlagSet(*puConfirmFlags, CBF_YES) &&
                    IsFlagClear(*puConfirmFlags, CBF_NO | CBF_CANCEL) ||
                    IsFlagSet(*puConfirmFlags, CBF_NO) &&
                    IsFlagClear(*puConfirmFlags, CBF_YES | CBF_CANCEL));
        }
        else
        {
            // No; prompt the user
            UINT uFlagsCRF = bMultiDrop ? CRF_MULTI : CRF_DEFAULT;
            int id = ConfirmReplace_DoModal(hwndOwner, pszPathOld, pszPathNew, uFlagsCRF);

            *puConfirmFlags = 0;

            if (GetKeyState(VK_SHIFT) < 0)
                SetFlag(*puConfirmFlags, CBF_TOALL);

            if (IDYES == id)
                SetFlag(*puConfirmFlags, CBF_YES);
            else if (IDNO == id)
                SetFlag(*puConfirmFlags, CBF_NO);
            else if (IDC_YESTOALL == id)
                SetFlag(*puConfirmFlags, CBF_YES | CBF_TOALL);
            else
            {
                ASSERT(IDCANCEL == id);
                SetFlag(*puConfirmFlags, CBF_CANCEL);
            }
        }

        // Has the user chosen to replace the file?
        if (IsFlagSet(*puConfirmFlags, CBF_YES))
        {
            // Yes; is this an existing twin?
            if (bIsTwin)
            {
                // Yes; delete it from the database before we continue
                Sync_Split(pcbs->hbrf, pszPathOld, 1, hwndOwner, SF_QUIET | SF_NOCONFIRM);
            }

            // Some merge-handlers need the unwanted file to be deleted
            // first because they cannot tell the difference between
            // a newly added file (that is replacing an existing file)
            // and a one-way merge.
            if (!PathIsDirectory(pszPathOld))
                DeleteFile(pszPathOld);
        }
    }
    return bRet;
}


/*----------------------------------------------------------
Purpose: Add the folder twin to the database, using the default
 *.* wildcard settings.

Returns: standard result
Cond:    --
 */
HRESULT PRIVATE AddDefaultFolderTwin(
        HWND hwndOwner,
        HBRFCASE hbrf,
        HDPA hdpa,               // Return: twin handle in array
        LPCTSTR pszPathFrom,      // Source path
        LPCTSTR pszPathTo)        // Target path
{
    HRESULT hres;
    int iTwin;

    // First make sure we can add another handle to hdpa (set to zero for now)
    if (DPA_ERR == (iTwin = DPA_InsertPtr(hdpa, DPA_APPEND, (LPVOID)NULL)))
    {
        hres = E_OUTOFMEMORY;
    }
    else
    {
        NEWFOLDERTWIN nft;
        TWINRESULT tr;
        HFOLDERTWIN hft;

        RETRY_BEGIN(FALSE)
        {
            ZeroInit(&nft, NEWFOLDERTWIN);
            nft.ulSize = sizeof(nft);
            nft.pcszFolder1 = pszPathFrom;
            nft.pcszFolder2 = pszPathTo;
            nft.pcszName = c_szAllFiles;
            nft.dwAttributes = OBJECT_TWIN_ATTRIBUTES;
            nft.dwFlags = NFT_FL_SUBTREE;

            // Add the twin
            tr = Sync_AddFolder(hbrf, &nft, &hft);
            hres = HRESULT_FROM_TR(tr);

            if (FAILED(hres))
            {
                DWORD dwError = GetLastError();
                int id;
                extern SETbl const c_rgseInfo[4];

                // Unavailable disk?
                if (ERROR_INVALID_DATA == dwError || ERROR_ACCESS_DENIED == dwError)
                {
                    // Yes
                    hres = E_TR_UNAVAILABLE_VOLUME;
                }

                id = SEMsgBox(hwndOwner, IDS_CAP_INFO, hres, c_rgseInfo, ARRAYSIZE(c_rgseInfo));
                if (IDRETRY == id)
                {
                    // Try the operation again
                    RETRY_SET();
                }
            }
        }
        RETRY_END()

            if (FAILED(hres))
            {
                DPA_DeletePtr(hdpa, iTwin);
            }
            else
            {
                // Success
                ASSERT(DPA_ERR != iTwin);
                ASSERT(NULL != hft);
                DPA_SetPtr(hdpa, iTwin, hft);
            }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Create a twin relationship between a folder and
another folder.

Returns: standard hresult
handles to created twins in hdpa
confirm flag settings

Cond:    --
 */
HRESULT PRIVATE CreateTwinOfFolder(
        CBS  * pcbs,
        LPTSTR pszPath,          // Dragged folder path
        LPCTSTR pszDir,          // Location to place twin
        HDPA hdpaTwin,          // array of twin handles
        UINT uFlags,            // AOF_*
        PUINT puConfirmFlags,   // CBF_*
        HWND hwndOwner,
        BOOL bMultiDrop)        // TRUE: more than 1 file/folder was dropped
{
    HRESULT hres;
    TCHAR szPathB[MAX_PATH];
    LPTSTR pszFile;

    ASSERT(pszPath);
    ASSERT(pszDir);

    pszFile = PathFindFileName(pszPath);

    // Will the path name be too long?
    if (PathsTooLong(pszDir, pszFile))
    {
        // Yes; bail
        MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_ADDFOLDER_TOOLONG),
                MAKEINTRESOURCE(IDS_CAP_ADD), NULL, MB_ERROR, pszFile);
        hres = E_FAIL;
    }
    // Did the user drag another briefcase root into this briefcase?
    else if (PathIsBriefcase(pszPath))
    {
        // Yes; we don't allow nested briefcases!  Tell the user.
        MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_CANTADDBRIEFCASE),
                MAKEINTRESOURCE(IDS_CAP_ADD), NULL, MB_WARNING);
        hres = E_FAIL;
    }
    else
    {
        // No; check for an existing folder in the target folder.
        BOOL bExists;

        PathCombine(szPathB, pszDir, pszFile);
        bExists = DoesPathAlreadyExist(pcbs, szPathB, pszPath, puConfirmFlags, SF_ISFOLDER, hwndOwner, bMultiDrop);

        if (!bExists || IsFlagSet(*puConfirmFlags, CBF_YES))
        {
            ASSERT(IsFlagClear(*puConfirmFlags, CBF_NO) &&
                    IsFlagClear(*puConfirmFlags, CBF_CANCEL));

            // Show 'Add Folder' dialog?
            if (IsFlagSet(uFlags, AOF_FILTERPROMPT))
            {
                // Yes
                hres = Info_DoModal(hwndOwner, pszPath, szPathB, hdpaTwin,
                        pcbs);
            }
            else
            {
                // No; just default to *.*
                hres = AddDefaultFolderTwin(hwndOwner, pcbs->hbrf, hdpaTwin,
                        pszPath, szPathB);
            }
        }
        else if (IsFlagSet(*puConfirmFlags, CBF_NO))
        {
            // The user said NO
            ASSERT(IsFlagClear(*puConfirmFlags, CBF_YES) &&
                    IsFlagClear(*puConfirmFlags, CBF_CANCEL));
            hres = NOERROR;
        }
        else
        {
            ASSERT(IsFlagSet(*puConfirmFlags, CBF_CANCEL));
            ASSERT(IsFlagClear(*puConfirmFlags, CBF_YES) &&
                    IsFlagClear(*puConfirmFlags, CBF_NO));
            hres = E_ABORT;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Create a twin of a file.

Returns: standard result
twin handle in hdpa
Cond:    --
 */
HRESULT PRIVATE CreateTwinOfFile(
        CBS  * pcbs,
        LPCTSTR pszPath,         // ptr to path to twin
        LPCTSTR pszTargetDir,    // ptr to dest dir
        HDPA hdpa,              // Return: twin handle in array
        UINT uFlags,            // AOF_*
        PUINT puConfirmFlags,   // CBF_*
        HWND hwndOwner,
        BOOL bMultiDrop)        // TRUE: more than 1 file/folder was dropped
{
    HRESULT hres;
    int iTwin;
    TCHAR szPath[MAX_PATH];
    LPCTSTR pszFile;
    HTWINFAMILY htfam = NULL;

    ASSERT(pszPath);
    ASSERT(pszTargetDir);

    pszFile = PathFindFileName(pszPath);

    // Will the path name be too long?
    if (PathsTooLong(pszTargetDir, pszFile))
    {
        // Yes; bail
        MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_ADDFILE_TOOLONG),
                MAKEINTRESOURCE(IDS_CAP_ADD), NULL, MB_ERROR, pszFile);
        iTwin = DPA_ERR;
        hres = E_FAIL;
    }
    // First make sure we can add another handle to hdpa (set to zero for now)
    else if (DPA_ERR == (iTwin = DPA_InsertPtr(hdpa, DPA_APPEND, (LPVOID)NULL)))
    {
        hres = E_OUTOFMEMORY;
    }
    else
    {
        BOOL bExists;

        // Confirm the replace if a file with the same name already exists.
        //
        PathCombine(szPath, pszTargetDir, pszFile);
        bExists = DoesPathAlreadyExist(pcbs, szPath, pszPath, puConfirmFlags, SF_ISFILE, hwndOwner, bMultiDrop);

        if (!bExists ||
                IsFlagSet(*puConfirmFlags, CBF_YES))
        {
            NEWOBJECTTWIN not;
            TWINRESULT tr;
            DECLAREHOURGLASS;

            ASSERT(IsFlagClear(*puConfirmFlags, CBF_NO) &&
                    IsFlagClear(*puConfirmFlags, CBF_CANCEL));

            lstrcpyn(szPath, pszPath, ARRAYSIZE(szPath));
            PathRemoveFileSpec(szPath);

            // User has either opted to continue adding this object to the
            // database, or it does not exist in the destination folder.

            RETRY_BEGIN(FALSE)
            {
                ZeroInit(&not, NEWOBJECTTWIN);
                not.ulSize = sizeof(NEWOBJECTTWIN);
                not.pcszFolder1 = szPath;
                not.pcszFolder2 = pszTargetDir;
                not.pcszName = pszFile;

                SetHourglass();
                Sync_Dump(&not, NEWOBJECTTWIN);
                tr = Sync_AddObject(pcbs->hbrf, &not, &htfam);
                ResetHourglass();

                hres = HRESULT_FROM_TR(tr);

                if (FAILED(hres))
                {
                    DWORD dwError = GetLastError();

                    // Unavailable disk?
                    if (ERROR_INVALID_DATA == dwError || ERROR_ACCESS_DENIED == dwError)
                    {
                        // Yes; ask user to retry/cancel
                        int id = MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_ADDFILE_UNAVAIL_VOL),
                                MAKEINTRESOURCE(IDS_CAP_ADD), NULL, MB_RETRYCANCEL | MB_ICONWARNING);

                        // Set specific error value
                        hres = E_TR_UNAVAILABLE_VOLUME;

                        if (IDRETRY == id)
                        {
                            RETRY_SET();    // Try again
                        }
                    }
                }
            }
            RETRY_END()
        }
        else if (IsFlagSet(*puConfirmFlags, CBF_NO))
        {
            // The user said NO
            ASSERT(IsFlagClear(*puConfirmFlags, CBF_YES) &&
                    IsFlagClear(*puConfirmFlags, CBF_CANCEL));
            DPA_DeletePtr(hdpa, iTwin);
            hres = NOERROR;
        }
        else
        {
            ASSERT(IsFlagSet(*puConfirmFlags, CBF_CANCEL));
            ASSERT(IsFlagClear(*puConfirmFlags, CBF_YES) &&
                    IsFlagClear(*puConfirmFlags, CBF_NO));
            hres = E_ABORT;
        }
    }

    if (FAILED(hres))
    {
        if (DPA_ERR != iTwin)
        {
            DPA_DeletePtr(hdpa, iTwin);
        }
    }
    else
    {
        // Success
        ASSERT(DPA_ERR != iTwin);
        if (htfam)
            DPA_SetPtr(hdpa, iTwin, htfam);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Deletes the new twins
Returns: --
Cond:    --
 */
void PRIVATE DeleteNewTwins(
        CBS  * pcbs,
        HDPA hdpa)
{
    int iItem;
    int cItems;

    ASSERT(pcbs);
    ASSERT(hdpa);

    cItems = DPA_GetPtrCount(hdpa);
    for (iItem = 0; iItem < cItems; iItem++)
    {
        HTWIN htwin = DPA_FastGetPtr(hdpa, iItem);

        if (htwin)
            Sync_DeleteTwin(htwin);
    }
}


/*----------------------------------------------------------
Purpose: Releases the twin handles
Returns: --
Cond:    --
 */
void PRIVATE ReleaseNewTwins(
        HDPA hdpa)
{
    int i;
    int cItems;

    ASSERT(hdpa);

    cItems = DPA_GetPtrCount(hdpa);
    for (i = 0; i < cItems; i++)
    {
        HTWIN htwin = DPA_FastGetPtr(hdpa, i);

        if (htwin)
            Sync_ReleaseTwin(htwin);
    }
}


/*----------------------------------------------------------
Purpose: Returns the count of nodes that do not have FS_COND_UNAVAILABLE.

Returns: see above
Cond:    --
 */
UINT PRIVATE CountAvailableNodes(
        PRECITEM pri)
{
    UINT ucNodes = 0;
    PRECNODE prn;

    for (prn = pri->prnFirst; prn; prn = prn->prnNext)
    {
        if (FS_COND_UNAVAILABLE != prn->fsCurrent.fscond)
        {
            ucNodes++;
        }
    }
    return ucNodes;
}


/*----------------------------------------------------------
Purpose: Returns the count of nodes that require some sort of
action.

Returns: see above
Cond:    --
 */
UINT PRIVATE CountActionItem(
        PRECLIST prl)
{
    UINT uc = 0;
    PRECITEM pri;

    for (pri = prl->priFirst; pri; pri = pri->priNext)
    {
        if (RIA_NOTHING != pri->riaction)
        {
            uc++;
        }
    }
    return uc;
}


/*----------------------------------------------------------
Purpose: Update the twins in the list

Returns:
Cond:    --
 */
HRESULT PRIVATE MassageReclist(
        CBS * pcbs,
        PRECLIST prl,
        LPCTSTR pszInsideDir,
        BOOL bCopyIn,
        HWND hwndOwner)
{
    HRESULT hres = NOERROR;
    PRECITEM pri;
    BOOL bWarnUser = TRUE;
    PRECNODE prnInside;
    PRECNODE prnOutside;

    // Make sure the direction of the reconciliation coincides
    // with the direction of the user's action.
    for (pri = prl->priFirst; pri; pri = pri->priNext)
    {
        if (RIA_NOTHING != pri->riaction)
        {
            UINT cAvailableNodes = CountAvailableNodes(pri);

            // Is this a wierd multi-edged case (not including
            // Sneakernet)?
            if (2 < cAvailableNodes)
            {
                // Should never get here, but better safe than sorry
                ASSERT(0);
            }
            else
            {
                // No; get the pair of nodes that we just added to the
                // database.
                hres = Sync_GetNodePair(pri, Atom_GetName(pcbs->atomBrf),
                        pszInsideDir, &prnInside, &prnOutside);

                if (SUCCEEDED(hres))
                {
                    ASSERT(prnInside);
                    ASSERT(prnOutside);

                    if (bCopyIn)
                    {
                        switch (prnOutside->rnstate)
                        {
                            case RNS_UNAVAILABLE:
                            case RNS_DOES_NOT_EXIST:
                            case RNS_DELETED:
                                break;      // leave alone

                            default:
                                // Force the update to be a copy into the briefcase.
                                pri->riaction = RIA_COPY;
                                prnInside->rnaction = RNA_COPY_TO_ME;
                                prnOutside->rnaction = RNA_COPY_FROM_ME;

                                TRACE_MSG(TF_GENERAL, TEXT("Massaging reclist"));
                                break;
                        }
                    }
                    else
                    {
                        switch (prnInside->rnstate)
                        {
                            case RNS_UNAVAILABLE:
                            case RNS_DOES_NOT_EXIST:
                            case RNS_DELETED:
                                break;      // leave alone

                            default:
                                // Force the update to be a copy out of the briefcase.
                                pri->riaction = RIA_COPY;
                                prnInside->rnaction = RNA_COPY_FROM_ME;
                                prnOutside->rnaction = RNA_COPY_TO_ME;

                                TRACE_MSG(TF_GENERAL, TEXT("Massaging reclist"));
                                break;
                        }
                    }
                }
                else
                    break;      // Error
            }
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Check for more than 2 available nodes in each recitem.
Remove the associated twin if we find such a case,
to prevent multiple sync copies.

Returns: S_OK if everything looks ok
S_FALSE if there were multiple sync copies introduced

Cond:    --
 */
HRESULT PRIVATE VerifyTwins(
        CBS  * pcbs,
        PRECLIST prl,
        LPCTSTR pszTargetDir,
        HWND hwndOwner)
{
    HRESULT hres = NOERROR;
    PRECITEM pri;
    BOOL bWarnUser = TRUE;
    BOOL bWarnUserFolder = TRUE;
    TCHAR szPath[MAX_PATH];

    // Look thru the reclist and pick out recitems that have more than
    // 2 recnodes that are currently available.

    // Scenarios when this can happen:
    //
    //  1) Foo.txt --> BC
    //     Foo.txt --> BC\Orphan Folder
    //
    //          Expected result: delete BC\Orphan Folder\Foo.txt twin
    //
    //  2) Foo.txt --> BC\Orphan Folder
    //     Orphan Folder --> BC
    //
    //          Expected result: delete BC\Orphan Folder twin
    //
    //  3) Foo.txt --> BC\Orphan Folder
    //     Foo.txt --> BC
    //
    //          Expected result: delete BC\Foo.txt twin
    //

    for (pri = prl->priFirst; pri; pri = pri->priNext)
    {
        UINT cAvailableNodes = CountAvailableNodes(pri);
        PRECNODE prn;

        // Are there more than 2 available nodes?
        if (2 < cAvailableNodes && *pri->pcszName)
        {
            BOOL bLookForFolders = TRUE;

            // FIRST: Look for object twins that are not in folder twins.
            for (prn = pri->prnFirst; prn; prn = prn->prnNext)
            {
                // Is this file here because the file was dragged in?
                if (IsSzEqual(pszTargetDir, prn->pcszFolder))
                {
                    // Yes; warn the user
                    if (bWarnUser)
                    {
                        MsgBox(hwndOwner,
                                MAKEINTRESOURCE(IDS_ERR_ADDFILE_TOOMANY),
                                MAKEINTRESOURCE(IDS_CAP_ADD),
                                NULL, MB_WARNING, pri->pcszName);

                        if (0 > GetKeyState(VK_SHIFT))
                        {
                            bWarnUser = FALSE;
                        }
                    }

                    // Try to remove the object twin
                    PathCombine(szPath, prn->pcszFolder, pri->pcszName);
                    hres = Sync_Split(pcbs->hbrf, szPath, 1, hwndOwner,
                            SF_QUIET | SF_NOCONFIRM);

                    TRACE_MSG(TF_GENERAL, TEXT("Deleted object twin for %s"), szPath);
                    ASSERT(FAILED(hres) || S_OK == hres);

                    bLookForFolders = FALSE;
                    break;
                }
            }


            if (bLookForFolders)
            {
                // SECOND: Look for object twins that exist because of folder
                // twins.
                for (prn = pri->prnFirst; prn; prn = prn->prnNext)
                {
                    lstrcpyn(szPath, prn->pcszFolder, ARRAYSIZE(szPath));
                    PathRemoveFileSpec(szPath);

                    // Is this file here because it is in a folder that was
                    // dragged in?
                    if (IsSzEqual(pszTargetDir, szPath))
                    {
                        // Yes; warn the user
                        if (bWarnUserFolder && bWarnUser)
                        {
                            MsgBox(hwndOwner,
                                    MAKEINTRESOURCE(IDS_ERR_ADDFOLDER_TOOMANY),
                                    MAKEINTRESOURCE(IDS_CAP_ADD),
                                    NULL, MB_WARNING, PathFindFileName(prn->pcszFolder));

                            // Hack: to prevent showing this messagebox for
                            // every file in this folder, set this flag
                            bWarnUserFolder = FALSE;

                            if (0 > GetKeyState(VK_SHIFT))
                            {
                                bWarnUser = FALSE;
                            }
                        }

                        // Remove the folder twin
                        hres = Sync_Split(pcbs->hbrf, prn->pcszFolder, 1, hwndOwner,
                                SF_ISFOLDER | SF_QUIET | SF_NOCONFIRM);

                        TRACE_MSG(TF_GENERAL, TEXT("Deleted folder twin for %s"), prn->pcszFolder);

                        ASSERT(FAILED(hres) || !bWarnUserFolder || S_OK == hres);
                        break;
                    }
                }
            }
            hres = S_FALSE;
        }
    }
    return hres;
}


#define STATE_VERIFY    0
#define STATE_UPDATE    1
#define STATE_STOP      2

/*----------------------------------------------------------
Purpose: This function updates the new files.  Unlike the general
update function, this strictly updates file pairs.  All
other incidental nodes are set to RNA_NOTHING.

In addition, to be safe, we force the update to always
perform a copy into the briefcase.

This function releases the twin handles when it is finished.

Returns: standard result
Cond:    --
 */
HRESULT PRIVATE UpdateNewTwins(
        CBS  * pcbs,
        LPCTSTR pszInsideDir,
        LPCTSTR pszTargetDir,
        BOOL bCopyIn,
        HDPA hdpa,
        HWND hwndOwner)
{
    HRESULT hres = E_FAIL;
    int iItem;
    int cItems;

    ASSERT(pcbs);
    ASSERT(hdpa);

    cItems = DPA_GetPtrCount(hdpa);
    if (cItems > 0)
    {
        HTWINLIST htl;
        PRECLIST prl;
        TWINRESULT tr;

        tr = Sync_CreateTwinList(pcbs->hbrf, &htl);

        if (TR_SUCCESS != tr)
        {
            hres = HRESULT_FROM_TR(tr);
        }
        else
        {
            HWND hwndProgress;
            UINT nState = STATE_VERIFY;
            DEBUG_CODE( UINT nCount = 0; )

                // State progression is simple:
                //   STATE_VERIFY --> STATE_UPDATE --> STATE_STOP
                // Any questions?

                hwndProgress = UpdBar_Show(hwndOwner, UB_CHECKING, DELAY_UPDBAR);

            for (iItem = 0; iItem < cItems; iItem++)
            {
                HTWIN htwin = DPA_FastGetPtr(hdpa, iItem);

                if (htwin)
                    Sync_AddToTwinList(htl, htwin);
            }

            do
            {
                ASSERT(STATE_VERIFY == nState || STATE_UPDATE == nState);
                ASSERT(2 > nCount++);       // Sanity check for infinite loop

                // Create the reclist
                hres = Sync_CreateRecListEx(htl, UpdBar_GetAbortEvt(hwndProgress), &prl);

                DEBUG_CODE( Sync_DumpRecList(GET_TR(hres), prl, TEXT("Adding new twins")); )

                    if (SUCCEEDED(hres))
                    {
                        ASSERT(prl);

                        switch (nState)
                        {
                            case STATE_VERIFY:
                                hres = VerifyTwins(pcbs, prl, pszTargetDir, hwndOwner);
                                if (S_FALSE == hres)
                                    nState = STATE_UPDATE;
                                else if (S_OK == hres)
                                    goto Update;
                                else
                                    nState = STATE_STOP;
                                break;

                            case STATE_UPDATE:
                                // After recreating the reclist, is there anything
                                // that needs updating?
                                if (0 < CountActionItems(prl))
                                {
                                    // Yes
Update:
                                    UpdBar_SetAvi(hwndProgress, UB_UPDATEAVI);

                                    hres = MassageReclist(pcbs, prl, pszInsideDir, bCopyIn, hwndOwner);
                                    if (SUCCEEDED(hres))
                                    {
                                        // Update these files
                                        hres = Sync_ReconcileRecList(prl, Atom_GetName(pcbs->atomBrf),
                                                hwndProgress, RF_ONADD);
                                    }
                                }

                                nState = STATE_STOP;
                                break;

                            default:
                                ASSERT(0);
                                break;
                        }

                        Sync_DestroyRecList(prl);
                    }

            } while (SUCCEEDED(hres) && STATE_UPDATE == nState);

            Sync_DestroyTwinList(htl);

            UpdBar_Kill(hwndProgress);
        }
    }
    return hres;
}


// FEATURE - BobDay - WinNT docking state determination code goes here.

/*----------------------------------------------------------
Purpose: Return TRUE if the machine is docked

Returns: See above.
Cond:    --
 */
BOOL PRIVATE IsMachineDocked(void)
{
    return TRUE;
}


//---------------------------------------------------------------------------
// IBriefcaseStg member functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: IBriefcaseStg::Release

Returns: new reference count
Cond:    --
 */
STDMETHODIMP_(UINT) BriefStg_Release(
        LPBRIEFCASESTG pstg)
{
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);

    DBG_ENTER(TEXT("BriefStg_Release"));

    if (--this->cRef)
    {
        DBG_EXIT_UL(TEXT("BriefStg_Release"), this->cRef);
        return this->cRef;      // Return decremented reference count
    }

    if (this->pcbs)
    {
        // Release this briefcase storage instance
        CloseBriefcaseStorage(this->szFolder);
    }

    if (this->hbrfcaseiter)
    {
        Sync_FindClose(this->hbrfcaseiter);
    }

    GFree(this);

    ENTEREXCLUSIVE();
    {
        DecBriefSemaphore();
        if (IsLastBriefSemaphore())
        {
            CommitIniFile();

            DEBUG_CODE( DumpTables(); )

                TermCacheTables();
        }
    }
    LEAVEEXCLUSIVE();

    DBG_EXIT_UL(TEXT("BriefStg_Release"), 0);

    return 0;
}


/*----------------------------------------------------------
Purpose: IBriefcaseStg::AddRef

Returns: new reference count
Cond:    --
 */
STDMETHODIMP_(UINT) BriefStg_AddRef(
        LPBRIEFCASESTG pstg)
{
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    UINT cRef;

    DBG_ENTER(TEXT("BriefStg_AddRef"));

    cRef = ++this->cRef;

    DBG_EXIT_UL(TEXT("BriefStg_AddRef"), cRef);

    return cRef;
}


/*----------------------------------------------------------
Purpose: IBriefcaseStg::QueryInterface

Returns: standard
Cond:    --
 */
STDMETHODIMP BriefStg_QueryInterface(
        LPBRIEFCASESTG pstg,
        REFIID riid,
        LPVOID * ppvOut)
{
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres;

    DBG_ENTER_RIID(TEXT("BriefStg_QueryInterface"), riid);

    if (IsEqualIID(riid, &IID_IUnknown) ||
            IsEqualIID(riid, &IID_IBriefcaseStg))
    {
        // We use the bs field as our IUnknown as well
        *ppvOut = &this->bs;
        this->cRef++;
        hres = NOERROR;
    }
    else
    {
        *ppvOut = NULL;
        hres = ResultFromScode(E_NOINTERFACE);
    }

    DBG_EXIT_HRES(TEXT("BriefStg_QueryInterface"), hres);
    return hres;
}


/*----------------------------------------------------------
Purpose: IBriefcaseStg::Initialize

Called to initialize a briefcase storage instance.
The pszFolder indicates the folder we are binding to,
which is in the briefcase storage (somewhere).

Returns: standard
Cond:    --
 */
STDMETHODIMP BriefStg_Initialize(
        LPBRIEFCASESTG pstg,
        LPCTSTR pszPath,
        HWND hwndOwner)
{
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres = ResultFromScode(E_FAIL);

    DBG_ENTER_SZ(TEXT("BriefStg_Initialize"), pszPath);

    ASSERT(pszPath);

    // Only initialize once per interface instance
    //
    if (pszPath && NULL == this->pcbs)
    {
        BOOL bCancel = FALSE;

        RETRY_BEGIN(FALSE)
        {
            // Unavailable disk?
            if (!PathExists(pszPath))
            {
                // Yes; ask user to retry/cancel
                int id = MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_OPEN_UNAVAIL_VOL),
                        MAKEINTRESOURCE(IDS_CAP_OPEN), NULL, MB_RETRYCANCEL | MB_ICONWARNING);

                if (IDRETRY == id)
                    RETRY_SET();    // Try again
                else
                    bCancel = TRUE;
            }
        }
        RETRY_END()

            if (!bCancel)
            {
                BrfPathCanonicalize(pszPath, this->szFolder, ARRAYSIZE(this->szFolder));

                if (PathExists(this->szFolder) && !PathIsDirectory(this->szFolder))
                {
                    // (Store this as a path to a folder)
                    PathRemoveFileSpec(this->szFolder);
                }

                // Open the briefcase storage for this folder
                //
                hres = OpenBriefcaseStorage(this->szFolder, &this->pcbs, hwndOwner);

                if (SUCCEEDED(hres))
                {
                    // Is this folder a sync folder?
                    if (HasFolderSyncCopy(this->pcbs->hbrf, this->szFolder))
                    {
                        // Yes
                        SetFlag(this->dwFlags, BSTG_SYNCFOLDER);
                    }
                    else
                    {
                        // No (or error, in which case we default to no)
                        ClearFlag(this->dwFlags, BSTG_SYNCFOLDER);
                    }
                }
            }
    }

    hres = MapToOfficialHresult(hres);
    DBG_EXIT_HRES(TEXT("BriefStg_Initialize"), hres);
    return hres;
}


/*----------------------------------------------------------
Purpose: Add an object or objects to the briefcase storage.
This function does the real work for BriefStg_AddObject.

Returns: standard result
NOERROR if the object(s) were added
S_FALSE if the object(s) should be handled by the caller

Cond:    --
 */
HRESULT PRIVATE BriefStg_AddObjectPrivate(
        LPBRIEFCASESTG pstg,
        LPDATAOBJECT pdtobj,
        LPCTSTR pszFolderEx,         // optional (may be NULL)
        UINT uFlags,                // One of AOF_*
        HWND hwndOwner)
{
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres;
    LPTSTR pszList;
    LPTSTR psz;
    UINT i;
    UINT cFiles;
    TCHAR szCanon[MAX_PATH];
    HDPA hdpa;
    LPCTSTR pszTarget;
    BOOL bMultiFiles;
    static SETbl const c_rgseAdd[] = {
        { E_OUTOFMEMORY,        IDS_OOM_ADD,    MB_ERROR },
        { E_TR_OUT_OF_MEMORY,   IDS_OOM_ADD,    MB_ERROR },
    };

    ASSERT(pdtobj);

    // Verify that the folder of this briefcase storage is actually inside
    // a briefcase.  (szCanon is used as a dummy here.)
    ASSERT( !PathExists(this->szFolder) || PL_FALSE != PathGetLocality(this->szFolder, szCanon, ARRAYSIZE(szCanon)) );

    // Get list of files to add
    hres = DataObj_QueryFileList(pdtobj, &pszList, &cFiles);
    if (SUCCEEDED(hres))
    {
        // Grab the mutex to delay any further calculation in any
        // Briefcase views' secondary threads until we're done
        // processing here.
        Delay_Own();

        // Does the caller want to create sync copies of objects that are
        // already in the briefcase to some other folder?  (Sneakernet)
        if (NULL != pszFolderEx)
        {
            // Yes
            pszTarget = pszFolderEx;
        }
        else
        {
            // No
            pszTarget = this->szFolder;

            // Are the entities already in this briefcase?
            //
            // Based on the success return value of DataObj_QueryFileList,
            // we can tell if the entities are already within a briefcase.
            // Because of the nature of the shell, we assume the file
            // list contains entities which all exist in the same folder,
            // so we consider it an "all or nothing" sort of indicator.
            // If the entities are indeed in a briefcase, we compare the
            // roots of the source and destination briefcases, and BLOCK
            // the addition if they are the same.
            //
            if (S_OK == hres)
            {
                // They are in *a* briefcase.  Which one?
                DataObj_QueryBriefPath(pdtobj, szCanon, ARRAYSIZE(szCanon));
                if (IsSzEqual(szCanon, Atom_GetName(this->pcbs->atomBrf)))
                {
                    // This same one!  Don't do anything.
                    // display message box
                    hres = ResultFromScode(E_FAIL);
                    goto Error1;
                }
            }
        }

        bMultiFiles = (1 < cFiles);

        // Create the temporary DPA list
        if (NULL == (hdpa = DPA_Create(cFiles)))
        {
            hres = ResultFromScode(E_OUTOFMEMORY);
        }
        else
        {
            UINT uConfirmFlags = 0;

            // Add all the objects to the briefcase storage
            for (i = 0, psz = pszList; i < cFiles; i++)
            {
                // Get file/folder name that was dropped
                BrfPathCanonicalize(psz, szCanon, ARRAYSIZE(szCanon));

                if (PathIsDirectory(szCanon))
                {
                    hres = CreateTwinOfFolder(this->pcbs, szCanon, pszTarget,
                            hdpa, uFlags, &uConfirmFlags,
                            hwndOwner, bMultiFiles);
                }
                else
                {
                    hres = CreateTwinOfFile(this->pcbs, szCanon, pszTarget,
                            hdpa, uFlags, &uConfirmFlags,
                            hwndOwner, bMultiFiles);
                }

                if (FAILED(hres))
                {
                    // An error occurred while attempting to add a twin
                    break;
                }

                DataObj_NextFile(psz);      // Set psz to next file in list
            }

            if (FAILED(hres))
            {
                // Delete the twins that were added.
                DeleteNewTwins(this->pcbs, hdpa);
            }
            else
            {
                // Update these new twins
                hres = UpdateNewTwins(this->pcbs, this->szFolder, pszTarget, (NULL == pszFolderEx), hdpa, hwndOwner);
            }

            ReleaseNewTwins(hdpa);
            DPA_Destroy(hdpa);
        }
Error1:
        DataObj_FreeList(pszList);

        Delay_Release();
    }

    if (FAILED(hres))
    {
        SEMsgBox(hwndOwner, IDS_CAP_ADD, hres, c_rgseAdd, ARRAYSIZE(c_rgseAdd));
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IBriefcaseStg::AddObject

Add an object to the briefcase storage.

Returns: standard hresult
Cond:    --
 */
STDMETHODIMP BriefStg_AddObject(
        LPBRIEFCASESTG pstg,
        LPDATAOBJECT pdtobj,
        LPCTSTR pszFolderEx,        // optional
        UINT uFlags,
        HWND hwndOwner)
{
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres = NOERROR;
    LPCTSTR pszFolder;
    UINT ids;
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )

        DBG_ENTER_DTOBJ(TEXT("BriefStg_AddObject"), pdtobj, szDbg, ARRAYSIZE(szDbg));

    ASSERT(pdtobj);
    ASSERT(this->pcbs);

    // Is this sneakernet?
    // Is this folder a sync folder?
    if (pszFolderEx)
    {
        // Yes; is the source a sync folder already?
        if (HasFolderSyncCopy(this->pcbs->hbrf, pszFolderEx))
        {
            // Yes; don't allow other sync copies into (or out of) it
            ids = IDS_ERR_ADD_SYNCFOLDER;
            pszFolder = PathFindFileName(pszFolderEx);
            hres = E_FAIL;
        }
        // Is the source folder a sync folder already?
        else if (IsFlagSet(this->dwFlags, BSTG_SYNCFOLDER))
        {
            // Yes; don't allow other sync copies into (or out of) it
            ids = IDS_ERR_ADD_SYNCFOLDER_SRC;
            pszFolder = PathFindFileName(this->szFolder);
            hres = E_FAIL;
        }
    }
    else if (IsFlagSet(this->dwFlags, BSTG_SYNCFOLDER))
    {
        // Yes; don't allow other sync copies into (or out of) it
        ids = IDS_ERR_ADD_SYNCFOLDER;
        pszFolder = PathFindFileName(this->szFolder);
        hres = E_FAIL;
    }

    if (SUCCEEDED(hres))
    {
        hres = BriefStg_AddObjectPrivate(pstg, pdtobj, pszFolderEx, uFlags, hwndOwner);
    }
    else
    {
        MsgBox(hwndOwner,
                MAKEINTRESOURCE(ids),
                MAKEINTRESOURCE(IDS_CAP_ADD),
                NULL,
                MB_WARNING,
                pszFolder);
    }

    DEBUG_CODE( DumpTables(); )
        hres = MapToOfficialHresult(hres);
    DBG_EXIT_HRES(TEXT("BriefStg_AddObject"), hres);

    return hres;
}


/*----------------------------------------------------------
Purpose: Removes an object or objects from the briefcase storage.

Returns: standard hresult
Cond:    --
 */
HRESULT PRIVATE ReleaseObject(
        CBS * pcbs,
        LPDATAOBJECT pdtobj,
        HWND hwndOwner)
{
    HRESULT hres;
    LPTSTR pszList;
    UINT cFiles;

    ASSERT(pdtobj);

    hres = DataObj_QueryFileList(pdtobj, &pszList, &cFiles);
    if (SUCCEEDED(hres))
    {
        RETRY_BEGIN(FALSE)
        {
            hres = Sync_Split(pcbs->hbrf, pszList, cFiles, hwndOwner, 0);

            // Unavailable disk?
            if (E_TR_UNAVAILABLE_VOLUME == hres)
            {
                // Yes; ask user to retry/cancel
                int id = MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_UNAVAIL_VOL),
                        MAKEINTRESOURCE(IDS_CAP_Split), NULL, MB_RETRYCANCEL | MB_ICONWARNING);

                if (IDRETRY == id)
                    RETRY_SET();    // Try again
            }
        }
        RETRY_END()

            DataObj_FreeList(pszList);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IBriefcaseStg::ReleaseObject

Release an object from the briefcase storage.

Returns: standard hresult
Cond:    --
 */
STDMETHODIMP BriefStg_ReleaseObject(
        LPBRIEFCASESTG pstg,
        LPDATAOBJECT pdtobj,
        HWND hwndOwner)
{
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres;
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )

        DBG_ENTER_DTOBJ(TEXT("BriefStg_ReleaseObject"), pdtobj, szDbg, ARRAYSIZE(szDbg));

    ASSERT(pdtobj);
    ASSERT(this->pcbs);

    hres = ReleaseObject(this->pcbs, pdtobj, hwndOwner);

    DEBUG_CODE( DumpTables(); )
        hres = MapToOfficialHresult(hres);
    DBG_EXIT_HRES(TEXT("BriefStg_ReleaseObject"), hres);

    return hres;
}


/*----------------------------------------------------------
Purpose: IBriefcaseStg::UpdateObject

Update an object in the briefcase storage.

Returns: standard hresult
Cond:    --
 */
STDMETHODIMP BriefStg_UpdateObject(
        LPBRIEFCASESTG pstg,
        LPDATAOBJECT pdtobj,
        HWND hwndOwner)
{
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres;
    TCHAR szPath[MAX_PATH];
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )

        DBG_ENTER_DTOBJ(TEXT("BriefStg_UpdateObject"), pdtobj, szDbg, ARRAYSIZE(szDbg));

    ASSERT(pdtobj);
    ASSERT(this->pcbs);

    // Determine whether this is an Update Selection or Update All.
    hres = DataObj_QueryPath(pdtobj, szPath, ARRAYSIZE(szPath));
    if (SUCCEEDED(hres))
    {
        // Is this a briefcase root?
        if (PathIsBriefcase(szPath))
        {
            // Yes; do an Update All
            hres = Upd_DoModal(hwndOwner, this->pcbs, NULL, 0, UF_ALL);
        }
        else
        {
            // No; do an Update Selection
            LPTSTR pszList;
            UINT cFiles;
            hres = DataObj_QueryFileList(pdtobj, &pszList, &cFiles);
            if (SUCCEEDED(hres))
            {
                hres = Upd_DoModal(hwndOwner, this->pcbs, pszList, cFiles, UF_SELECTION);
                DataObj_FreeList(pszList);
            }
        }
    }

    DEBUG_CODE( DumpTables(); )
        hres = MapToOfficialHresult(hres);
    DBG_EXIT_HRES(TEXT("BriefStg_UpdateObject"), hres);

    return hres;
}


/*----------------------------------------------------------
Purpose: Update a briefcase based on events

Returns: standard hresult
Cond:    --
 */
HRESULT PRIVATE BriefStg_UpdateOnEvent(
        LPBRIEFCASESTG pstg,
        UINT uEvent,
        HWND hwndOwner)
{
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres = NOERROR;

    DBG_ENTER(TEXT("BriefStg_UpdateOnEvent"));

    switch (uEvent)
    {
        case UOE_CONFIGCHANGED:
        case UOE_QUERYCHANGECONFIG:
            // Is the machine docked?
            if (IsMachineDocked())
            {
                // Yes; does the user want to update?
                TCHAR sz[MAX_PATH];
                int ids = (UOE_CONFIGCHANGED == uEvent) ? IDS_MSG_UpdateOnDock : IDS_MSG_UpdateBeforeUndock;
                LPCTSTR pszBrf = Atom_GetName(this->pcbs->atomBrf);
                int id = MsgBox(hwndOwner,
                        MAKEINTRESOURCE(ids),
                        MAKEINTRESOURCE(IDS_CAP_UPDATE),
                        LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_UPDATE_DOCK)),
                        MB_QUESTION,
                        PathGetDisplayName(pszBrf, sz, ARRAYSIZE(sz)));

                if (IDYES == id)
                {
                    // Yes; do an Update All
                    hres = Upd_DoModal(hwndOwner, this->pcbs, NULL, 0, UF_ALL);
                }
            }
            break;

        default:
            hres = ResultFromScode(E_INVALIDARG);
            break;
    }

    DEBUG_CODE( DumpTables(); )
        hres = MapToOfficialHresult(hres);
    DBG_EXIT_HRES(TEXT("BriefStg_UpdateOnEvent"), hres);

    return hres;
}

/*----------------------------------------------------------
Purpose: IBriefcaseStg::Notify

Marks the path dirty in the briefcase storage cache.
(The path may not exist in the cache, in which case this
function does nothing.)

Returns: S_OK to force a refresh
S_FALSE to not force a refresh

Cond:    --
 */
STDMETHODIMP BriefStg_Notify(
        LPBRIEFCASESTG pstg,
        LPCTSTR pszPath,         // may be NULL
        LONG lEvent,            // one of NOE_ flags
        UINT * puFlags,         // returned NF_ flags
        HWND hwndOwner)
{
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres = ResultFromScode(E_OUTOFMEMORY);
    TCHAR szCanon[MAX_PATH];
    int atom;

    DBG_ENTER_SZ(TEXT("BriefStg_Notify"), pszPath);

    ASSERT(this->pcbs);
    ASSERT(puFlags);

    DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Received event %lx for %s"), lEvent, Dbg_SafeStr(pszPath)); )

        *puFlags = 0;

    // Dirty the entire cache?
    if (NOE_DIRTYALL == lEvent)
    {
        // Yes
        TRACE_MSG(TF_GENERAL, TEXT("Marking everything"));

        CRL_DirtyAll(this->pcbs->atomBrf);
        Sync_ClearBriefcaseCache(this->pcbs->hbrf);
        hres = NOERROR;
    }
    else if (pszPath && 0 < lEvent)
    {
        // No
        BrfPathCanonicalize(pszPath, szCanon, ARRAYSIZE(szCanon));
        atom = Atom_Add(szCanon);
        if (ATOM_ERR != atom)
        {
            int atomCab = Atom_Add(this->szFolder);
            if (ATOM_ERR != atomCab)
            {
                // There are two actions we must determine: what gets marked dirty?
                // and does this specific window get forcibly refreshed?
                BOOL bRefresh;
                BOOL bMarked;

                bMarked = CRL_Dirty(atom, atomCab, lEvent, &bRefresh);
                hres = NOERROR;

                if (bMarked)
                {
                    SetFlag(*puFlags, NF_ITEMMARKED);
                }

#ifdef DEBUG
                if (bMarked && bRefresh)
                {
                    TRACE_MSG(TF_GENERAL, TEXT("Marked and forcing refresh of window on %s"), (LPTSTR)this->szFolder);
                }
                else if (bMarked)
                {
                    TRACE_MSG(TF_GENERAL, TEXT("Marked"));
                }
#endif

                Atom_Delete(atomCab);
            }
            Atom_Delete(atom);
        }
    }

    DBG_EXIT_HRES(TEXT("BriefStg_Notify"), hres);

    return hres;
}


/*----------------------------------------------------------
Purpose: Gets special info (status and origin) of a path.
Returns: --
Cond:    --
 */
HRESULT PRIVATE BriefStg_GetSpecialInfoOf(
        PBRIEFSTG this,
        LPCTSTR pszName,
        UINT uFlag,
        LPTSTR pszBuf,
        int cchBuf)
{
    HRESULT hres = E_OUTOFMEMORY;
    TCHAR szPath[MAX_PATH];
    TCHAR szCanon[MAX_PATH];
    int atom;

    ASSERT(this);
    ASSERT(pszName);
    ASSERT(pszBuf);
    ASSERT(this->pcbs);

    *pszBuf = TEXT('\0');

    // Would the path be too long if combined?
    if (PathsTooLong(this->szFolder, pszName))
    {
        // Yes
        hres = E_FAIL;
    }
    else
    {
        PathCombine(szPath, this->szFolder, pszName);
        BrfPathCanonicalize(szPath, szCanon, ARRAYSIZE(szCanon));
        atom = Atom_Add(szCanon);
        if (ATOM_ERR != atom)
        {
            CRL * pcrl;

            // The first CRL_Get call will get the reclist from the cache
            // or get a fresh reclist if the dirty bit is set.  If the cache
            // item doesn't exist, add it.  We add orphans to the cache too
            // but they have no reclist.

            // Does the cached item already exist?
            hres = CRL_Get(atom, &pcrl);
            if (FAILED(hres))
            {
                // No; add it
                hres = CRL_Add(this->pcbs, atom);
                if (SUCCEEDED(hres))
                {
                    // Do another 'get' to offset the CRL_Delete at the end of
                    // this function.  This will leave this new reclist in the
                    // cache upon exit.  (We don't want to create a new reclist
                    // everytime this functin is called.)  It will all get
                    // cleaned up when the CBS is freed.
                    //
                    hres = CRL_Get(atom, &pcrl);
                }
            }

            ASSERT(FAILED(hres) || pcrl);

            // Do we have a cache reclist entry to work with?
            if (pcrl)
            {
                // Yes
                if (GEI_ORIGIN == uFlag)
                {
                    lstrcpyn(pszBuf, Atom_GetName(pcrl->atomOutside), cchBuf);
                    PathRemoveFileSpec(pszBuf);
                }
                else
                {
                    ASSERT(GEI_STATUS == uFlag);
                    SzFromIDS(pcrl->idsStatus, pszBuf, cchBuf);
                }

                CRL_Delete(atom);   // Decrement count
            }
            Atom_Delete(atom);
        }
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IBriefcaseStg::GetExtraInfo

Returns: standard hresult
Cond:    --
 */
STDMETHODIMP BriefStg_GetExtraInfo(
        LPBRIEFCASESTG pstg,
        LPCTSTR pszName,
        UINT uInfo,
        WPARAM wParam,
        LPARAM lParam)
{
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres;

    DBG_ENTER_SZ(TEXT("BriefStg_GetExtraInfo"), pszName);

    ASSERT(this->pcbs);

    switch (uInfo)
    {
        case GEI_ORIGIN:
        case GEI_STATUS: {
                             LPTSTR pszBuf = (LPTSTR)lParam;
                             int cchBuf = (int)wParam;

                             ASSERT(pszName);
                             ASSERT(pszBuf);

                             hres = BriefStg_GetSpecialInfoOf(this, pszName, uInfo, pszBuf, cchBuf);
                         }
                         break;

        case GEI_DELAYHANDLE: {
                                  HANDLE * phMutex = (HANDLE *)lParam;

                                  ASSERT(phMutex);

                                  *phMutex = g_hMutexDelay;
                                  hres = NOERROR;
                              }
                              break;

        case GEI_ROOT: {
                           LPTSTR pszBuf = (LPTSTR)lParam;
                           int cchBuf = (int)wParam;

                           ASSERT(pszBuf);

                           lstrcpyn(pszBuf, Atom_GetName(this->pcbs->atomBrf), cchBuf);

#ifdef DEBUG

                           if (IsFlagSet(g_uDumpFlags, DF_PATHS))
                           {
                               TRACE_MSG(TF_ALWAYS, TEXT("Root is \"%s\""), pszBuf);
                           }

#endif
                           hres = NOERROR;
                       }
                       break;

        case GEI_DATABASENAME: {
                                   LPTSTR pszBuf = (LPTSTR)lParam;
                                   int cchBuf = (int)wParam;
                                   LPCTSTR pszDBName;

                                   ASSERT(pszBuf);

                                   if (IsFlagSet(this->pcbs->uFlags, CBSF_LFNDRIVE))
                                       pszDBName = g_szDBName;
                                   else
                                       pszDBName = g_szDBNameShort;

                                   lstrcpyn(pszBuf, pszDBName, cchBuf);

                                   hres = NOERROR;
                               }
                               break;

        default:
                               hres = E_INVALIDARG;
                               break;
    }

    DBG_EXIT_HRES(TEXT("BriefStg_GetExtraInfo"), hres);

    return hres;
}


/*----------------------------------------------------------
Purpose: IBriefcaseStg::FindFirst

Returns the location of the root of the first briefcase storage
in the system.

Returns: S_OK if a briefcase was found
S_FALSE to end enumeration
Cond:    --
 */
STDMETHODIMP BriefStg_FindFirst(
        LPBRIEFCASESTG pstg,
        LPTSTR pszName,
        int cchMaxName)
{
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres;
    TWINRESULT tr;
    BRFCASEINFO bcinfo;

    DBG_ENTER(TEXT("BriefStg_FindFirst"));

    ASSERT(pszName);

    bcinfo.ulSize = sizeof(bcinfo);
    tr = Sync_FindFirst(&this->hbrfcaseiter, &bcinfo);
    switch (tr)
    {
        case TR_OUT_OF_MEMORY:
            hres = ResultFromScode(E_OUTOFMEMORY);
            break;

        case TR_SUCCESS:
            hres = ResultFromScode(S_OK);
            lstrcpyn(pszName, bcinfo.rgchDatabasePath, cchMaxName);
            break;

        case TR_NO_MORE:
            hres = ResultFromScode(S_FALSE);
            break;

        default:
            hres = ResultFromScode(E_FAIL);
            break;
    }

    DBG_EXIT_HRES(TEXT("BriefStg_FindFirst"), hres);

    return hres;
}


/*----------------------------------------------------------
Purpose: IBriefcaseStg::FindNext

Returns the location of the root of the next briefcase storage
in the system.

Returns: S_OK if a briefcase was found
S_FALSE to end enumeration
Cond:    --
 */
STDMETHODIMP BriefStg_FindNext(
        LPBRIEFCASESTG pstg,
        LPTSTR pszName,
        int cchMaxName)
{
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres;
    TWINRESULT tr;
    BRFCASEINFO bcinfo;

    DBG_ENTER(TEXT("BriefStg_FindNext"));

    ASSERT(pszName);

    bcinfo.ulSize = sizeof(bcinfo);
    tr = Sync_FindNext(this->hbrfcaseiter, &bcinfo);
    switch (tr)
    {
        case TR_OUT_OF_MEMORY:
            hres = ResultFromScode(E_OUTOFMEMORY);
            break;

        case TR_SUCCESS:
            hres = ResultFromScode(S_OK);
            lstrcpyn(pszName, bcinfo.rgchDatabasePath, cchMaxName);
            break;

        case TR_NO_MORE:
            hres = ResultFromScode(S_FALSE);
            break;

        default:
            hres = ResultFromScode(E_FAIL);
            break;
    }

    DBG_EXIT_HRES(TEXT("BriefStg_FindNext"), hres);

    return hres;
}


//---------------------------------------------------------------------------
// BriefStg class : Vtables
//---------------------------------------------------------------------------

IBriefcaseStgVtbl c_BriefStg_BSVtbl =
{
    BriefStg_QueryInterface,
    BriefStg_AddRef,
    BriefStg_Release,
    BriefStg_Initialize,
    BriefStg_AddObject,
    BriefStg_ReleaseObject,
    BriefStg_UpdateObject,
    BriefStg_UpdateOnEvent,
    BriefStg_GetExtraInfo,
    BriefStg_Notify,
    BriefStg_FindFirst,
    BriefStg_FindNext,
};


/*----------------------------------------------------------
Purpose: This function is called back from within
IClassFactory::CreateInstance() of the default class
factory object, which is created by SHCreateClassObject.

Returns: standard
Cond:    --
 */
HRESULT CALLBACK BriefStg_CreateInstance(
        LPUNKNOWN punkOuter,        // Should be NULL for us
        REFIID riid,
        LPVOID * ppvOut)
{
    HRESULT hres = E_FAIL;
    PBRIEFSTG this;

    DBG_ENTER_RIID(TEXT("BriefStg_CreateInstance"), riid);

    // Briefcase storage does not support aggregation.
    //
    if (punkOuter)
    {
        hres = CLASS_E_NOAGGREGATION;
        *ppvOut = NULL;
        goto Leave;
    }

    this = GAlloc(sizeof(*this));
    if (!this)
    {
        hres = E_OUTOFMEMORY;
        *ppvOut = NULL;
        goto Leave;
    }
    this->bs.lpVtbl = &c_BriefStg_BSVtbl;
    this->cRef = 1;
    this->pcbs = NULL;
    this->dwFlags = 0;

    // Load the engine if it hasn't already been loaded
    // (this only returns FALSE if something went wrong)
    if (Sync_QueryVTable())
    {
        ENTEREXCLUSIVE();
        {
            // The decrement is in BriefStg_Release()
            IncBriefSemaphore();
            if (IsFirstBriefSemaphore())
            {
                ProcessIniFile();   // Load settings first

                // Initialize cache
                if (InitCacheTables())
                    hres = NOERROR;
                else
                    hres = E_OUTOFMEMORY;
            }
            else
            {
                hres = NOERROR;
            }
        }
        LEAVEEXCLUSIVE();
    }

    if (SUCCEEDED(hres))
    {
        // Note that the Release member will free the object, if
        // QueryInterface failed.
        //
        hres = this->bs.lpVtbl->QueryInterface(&this->bs, riid, ppvOut);
        this->bs.lpVtbl->Release(&this->bs);
    }
    else
    {
        *ppvOut = NULL;
    }

Leave:
    DBG_EXIT_HRES(TEXT("BriefStg_CreateInstance"), hres);

    return hres;        // S_OK or E_NOINTERFACE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\info.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: info.c
//
//  This files contains dialog code for the Info property sheet
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------


#include "brfprv.h"         // common headers
#include <brfcasep.h>

#include "res.h"
#include <help.h>

//---------------------------------------------------------------------------
// INFO dialog struct
//---------------------------------------------------------------------------

// State flags for the INFO dialog
#define IS_ALLTYPES         0x0001
#define IS_INCLUDESUBS      0x0002
#define IS_DENYAPPLY        0x0004
#define IS_CHANGED          0x0008
#define IS_LAST_INCLUDESUBS 0x0010

typedef struct tagINFO
{
    HWND    hwnd;               // dialog handle
    PPAGEDATA ppagedata;
    PINFODATA pinfodata;
    int     cselPrev;           // previous count of selections

    LPTSTR   pszExtListPrev;     // alloc: last saved settings
    UINT    uState;
    BOOL    bInit;

} INFO,  * PINFO;


// Struct for CHANGETWINPROC callback
typedef struct tagCHANGEDATA
{
    HBRFCASE    hbrf;
    HFOLDERTWIN hft;

    HDPA        hdpaTwins;
    int         idpaTwin;
    HDPA        hdpaFolders;
    int         idpaStart;

    UINT        uState;

} CHANGEDATA, * PCHANGEDATA;

typedef HRESULT (CALLBACK * CHANGETWINPROC)(PNEWFOLDERTWIN, TWINRESULT, PCHANGEDATA);


// Struct for Info_AddTwins
typedef struct tagADDTWINSDATA
{
    CHANGETWINPROC pfnCallback;
    HDPA hdpaSortedFolders;
    int idpaStart;
} ADDTWINSDATA, * PADDTWINSDATA;


#define MAX_EXT_LEN     6       // Length for "*.ext"

static TCHAR const c_szAllFilesExt[] = TEXT(".*");

// Helper macros

#define Info_StandAlone(this)       ((this)->pinfodata->bStandAlone)

#define Info_GetPtr(hwnd)           (PINFO)GetWindowLongPtr(hwnd, DWLP_USER)
#define Info_SetPtr(hwnd, lp)       (PINFO)SetWindowLongPtr(hwnd, DWLP_USER, (LRESULT)(lp))


SETbl const c_rgseInfo[4] = {       // change in ibrfstg.c too
    { E_TR_OUT_OF_MEMORY, IDS_OOM_ADDFOLDER, MB_ERROR },
    { E_OUTOFMEMORY, IDS_OOM_ADDFOLDER, MB_ERROR },
    { E_TR_UNAVAILABLE_VOLUME, IDS_ERR_ADDFOLDER_UNAVAIL_VOL, MB_RETRYCANCEL | MB_ICONWARNING },
    { E_TR_SUBTREE_CYCLE_FOUND, IDS_ERR_ADD_SUBTREECYCLE, MB_WARNING },
};


//---------------------------------------------------------------------------
// Info dialog functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Searches for an occurrence of the given extension
in the folder twin list.

Returns: TRUE if the extension was found
Cond:    --
 */
BOOL PRIVATE FindExtension(
        PFOLDERTWINLIST pftl,
        LPCTSTR pszExt)
{
    PCFOLDERTWIN pcft;

    for (pcft = pftl->pcftFirst; pcft; pcft = pcft->pcftNext)
    {
        if (IsSzEqual(pszExt, pcft->pcszName))
        {
            return TRUE;       // Found a match!
        }
    }
    return FALSE;
}


/*----------------------------------------------------------
Purpose: Disable all the controls.  Remove any selections.
Returns: --
Cond:    --
 */
void PRIVATE Info_DisableAll(
        PINFO this)
{
    ASSERT(!Info_StandAlone(this));

    // Remove selections
    //
    ListBox_ResetContent(GetDlgItem(this->hwnd, IDC_LBINTYPES));
    Button_SetCheck(GetDlgItem(this->hwnd, IDC_RBINALL), 0);
    Button_SetCheck(GetDlgItem(this->hwnd, IDC_RBINSELECTED), 0);
    Button_SetCheck(GetDlgItem(this->hwnd, IDC_CHININCLUDE), 0);

    // Disable the controls
    //
    Button_Enable(GetDlgItem(this->hwnd, IDC_RBINALL), FALSE);
    Button_Enable(GetDlgItem(this->hwnd, IDC_RBINSELECTED), FALSE);

    ListBox_Enable(GetDlgItem(this->hwnd, IDC_LBINTYPES), FALSE);

    Button_Enable(GetDlgItem(this->hwnd, IDC_CHININCLUDE), FALSE);
}


/*----------------------------------------------------------
Purpose: Initialize the labels for our formatted radio buttons
Returns: --
Cond:    --
 */
void PRIVATE Info_InitLabels(
        PINFO this)
{
    HWND hwnd = this->hwnd;
    HWND hwndST = GetDlgItem(hwnd, IDC_CHININCLUDE);
    TCHAR sz[MAXMSGLEN];
    TCHAR szFmt[MAXBUFLEN];
    LPCTSTR pszPath = Atom_GetName(this->ppagedata->atomPath);
    LPTSTR pszFile;

    pszFile = PathFindFileName(pszPath);

    // Set static label
    //
    GetWindowText(hwndST, szFmt, ARRAYSIZE(szFmt));
    wnsprintf(sz, ARRAYSIZE(sz), szFmt, pszFile);
    SetWindowText(hwndST, sz);

    if (Info_StandAlone(this))
    {
        // Set title ("Create Twin of %s")
        //
        GetWindowText(hwnd, szFmt, ARRAYSIZE(szFmt));
        wnsprintf(sz, ARRAYSIZE(sz), szFmt, pszFile);
        SetWindowText(hwnd, sz);
    }
}


/*----------------------------------------------------------
Purpose: Queries the registry for all the legal extensions that
are registered.  These extensions are returned as a 
space-separated list in buffer.

Returns: --
Cond:    Caller must GFree *ppszBuffer
 */
void PRIVATE GetExtensionList(
        LPTSTR * ppszBuffer)
{
    HKEY hkRoot;

    *ppszBuffer = NULL;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, NULL, 0, KEY_ENUMERATE_SUB_KEYS, &hkRoot))
    {
        DWORD dwIndex;
        TCHAR szExt[MAX_PATH];

        // Enumerate this key
        for (dwIndex = 0;
                ERROR_SUCCESS == RegEnumKey(hkRoot, dwIndex, szExt, ARRAYSIZE(szExt));
                dwIndex++)
        {
            // Did we get a node that is an extension AND
            // is it a legal MS-DOS extension?
            if (TEXT('.') == *szExt &&
                    4 >= lstrlen(szExt))
            {
                // Yes; add this extension to our list
                StrCatBuff(szExt, TEXT(" "), ARRAYSIZE(szExt));
                if (FALSE == GCatString(ppszBuffer, szExt))
                {
                    // Uh oh, something bad happened
                    break;
                }
            }
        }
        RegCloseKey(hkRoot);
    }
}


/*----------------------------------------------------------
Purpose: Fill the file types listbox
Returns: --
Cond:    --
 */
void PRIVATE Info_FillTypesList(
        PINFO this)
{
    HWND hwndCtl = GetDlgItem(this->hwnd, IDC_LBINTYPES);
    LPTSTR pszExtList;

    GetExtensionList(&pszExtList);
    if (pszExtList)
    {
        int nTabWidth;
        TCHAR szExt[MAXBUFLEN];
        LPTSTR psz;
        LPTSTR pszT;
        UINT uLen;
        SHFILEINFO sfi;

        nTabWidth = 30;
        ListBox_SetTabStops(hwndCtl, 1, &nTabWidth);

        for (psz = pszExtList; *psz; psz = CharNext(psz))
        {
            // Skip any leading white-space 
            for (; TEXT(' ') == *psz; psz = CharNext(psz))
                ;

            if (0 == *psz)
            {
                break;  // End of string
            }

            // Skip to next white-space (or null)
            for (pszT = psz; TEXT(' ') < *pszT; pszT = CharNext(pszT))
            {
                // (This will also stop at null)
            }

            // (GetExtensionList should only get max 3 char extensions)
            uLen = (UINT)(pszT - psz);
            ASSERT(ARRAYSIZE(szExt) > uLen);

            lstrcpyn(szExt, psz, min(uLen+1, ARRAYSIZE(szExt)));
            CharUpper(szExt);
            SHGetFileInfo(szExt, 0, &sfi, sizeof(sfi), SHGFI_TYPENAME | SHGFI_USEFILEATTRIBUTES);

            // Although this forces the format for international versions,
            // it makes extraction much much easier.
            StrCatBuff(szExt, TEXT("\t("), ARRAYSIZE(szExt));
            StrCatBuff(szExt, sfi.szTypeName, ARRAYSIZE(szExt));
            StrCatBuff(szExt, TEXT(")"), ARRAYSIZE(szExt));
            ListBox_AddString(hwndCtl, szExt);

            psz = pszT;     // To next extension
        }

        GFree(pszExtList);
    }
}

/*----------------------------------------------------------
Purpose: Set the selection of the dialog controls
Returns: --
Cond:    --
 */
void PRIVATE Info_SetSelections(
        PINFO this)
{
    HWND hwndLB = GetDlgItem(this->hwnd, IDC_LBINTYPES);
    int idBtn;
    int cItems = ListBox_GetCount(hwndLB);

    ListBox_SetSel(hwndLB, FALSE, -1);  // deselect everything

    // Is this the 'Add Folder' dialog?
    if (Info_StandAlone(this))
    {
        // Yes; default to *.* settings
        SetFlag(this->uState, IS_ALLTYPES);
        SetFlag(this->uState, IS_INCLUDESUBS);
    }
    else
    {
        // No; query what the selections are
        TCHAR szExt[MAXBUFLEN];
        PFOLDERTWINLIST pftl;
        PCFOLDERTWIN pcft;
        int cItems;
        int i;
        BOOL bStarDotStar;
        LPTSTR psz;

        if (S_OK == PageData_Query(this->ppagedata, this->hwnd, NULL, &pftl))
        {
            // Determine the selections in the listbox
            szExt[0] = TEXT('*');

            cItems = ListBox_GetCount(hwndLB);
            for (i = 0; i < cItems; i++)
            {
                // Extract the extension (it will be the first part of the
                // string)
                ListBox_GetText(hwndLB, i, &szExt[1]);
                for (psz = szExt; *psz && TEXT('\t') != *psz; psz = CharNext(psz))
                    ;
                ASSERT(TEXT('\t') == *psz);
                *psz = 0;           // null terminate after the extension

                // Is this extension in the folder twin list?
                if (FindExtension(pftl, szExt))
                {
                    // Yes; select the entry
                    ListBox_SetSel(hwndLB, TRUE, i);
                }
            }

            ListBox_SetTopIndex(hwndLB, 0);
            this->cselPrev = ListBox_GetSelCount(hwndLB);

            // Determine the Include Subdirectories checkbox setting
            //
            bStarDotStar = FALSE;
            ClearFlag(this->uState, IS_INCLUDESUBS);
            for (pcft = pftl->pcftFirst; pcft; pcft = pcft->pcftNext)
            {
                if (IsFlagSet(pcft->dwFlags, FT_FL_SUBTREE))
                    SetFlag(this->uState, IS_INCLUDESUBS);

                if (IsSzEqual(pcft->pcszName, c_szAllFiles))
                    bStarDotStar = TRUE;
            }

            // Set the default radio button choice, and disable listbox 
            // if necessary.  The default radio choice will be IDC_RBINALL, 
            // unless there are selections in the listbox AND there is no 
            // *.* occurrence in the folder twin list.
            //
            if (0 == this->cselPrev || bStarDotStar)
                SetFlag(this->uState, IS_ALLTYPES);
            else
                ClearFlag(this->uState, IS_ALLTYPES);
        }
        else
        {
            // An error occurred or this is an orphan.  Bail early.
            return;
        }
    }

    if (IsFlagSet(this->uState, IS_INCLUDESUBS))
        SetFlag(this->uState, IS_LAST_INCLUDESUBS);
    else
        ClearFlag(this->uState, IS_LAST_INCLUDESUBS);

    // Set the control settings 
    Button_SetCheck(GetDlgItem(this->hwnd, IDC_CHININCLUDE), IsFlagSet(this->uState, IS_INCLUDESUBS));

    ListBox_Enable(hwndLB, IsFlagClear(this->uState, IS_ALLTYPES));
    idBtn =  IsFlagSet(this->uState, IS_ALLTYPES) ? IDC_RBINALL : IDC_RBINSELECTED;
    CheckRadioButton(this->hwnd, IDC_RBINALL, IDC_RBINSELECTED, idBtn);

    // If listbox is empty, disable Selected Types radio button
    if (0 == cItems)
    {
        Button_Enable(GetDlgItem(this->hwnd, IDC_RBINSELECTED), FALSE);
    }
}


/*----------------------------------------------------------
Purpose: Get the selected extensions in the listbox
and place them as a list in *ppszExtList. 

.* is placed in the buffer if the Select All radio button
is chosen instead.

Returns: TRUE on success

Cond:    The caller must GFree *ppszExtList
 */
BOOL PRIVATE Info_GetSelections(
        PINFO this,
        LPTSTR * ppszExtList)
{
    BOOL bRet = FALSE;

    *ppszExtList = NULL;

    // Did user choose the All Types radio button?
    if (IsFlagSet(this->uState, IS_ALLTYPES))
    {
        // Yes; store the .* extension
        bRet = GSetString(ppszExtList, c_szAllFilesExt);
    }
    else
    {
        // No; user selected a bunch of wildcards to filter
        LPINT pisel;
        TCHAR szExt[MAXBUFLEN];
        int csel;
        int isel;
        HWND hwndCtl = GetDlgItem(this->hwnd, IDC_LBINTYPES);

        // Allocate memory for the selection buffer
        csel = ListBox_GetSelCount(hwndCtl);
        pisel = GAllocArray(int, csel);
        if (pisel)
        {
            // Get the selected extensions from the listbox
            LPTSTR psz;

            if (0 < csel)
            {
                ListBox_GetSelItems(hwndCtl, csel, pisel);
                for (isel = 0; isel < csel; isel++)
                {
                    // Extract the extension (it will be the first part of the string)
                    ListBox_GetText(hwndCtl, pisel[isel], szExt);
                    for (psz = szExt; *psz && TEXT('\t') != *psz; psz = CharNext(psz))
                        ;
                    ASSERT(TEXT('\t') == *psz);
                    *psz = 0;

                    if (FALSE == GCatString(ppszExtList, szExt))
                    {
                        break;
                    }
                }

                if (isel == csel)
                {
                    bRet = TRUE;    // Success
                }
                else
                {
                    GFree(*ppszExtList);
                }
            }
            GFree(pisel);
        }
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Create a sorted DPA version of the folder twin list

Returns: hdpa
NULL on OOM
Cond:    --
 */
HDPA PRIVATE CreateSortedFolderDPA(
        PFOLDERTWINLIST pftl)
{
    HDPA hdpa;

    ASSERT(pftl);

    hdpa = DPA_Create(8);
    if (hdpa)
    {
        PCFOLDERTWIN pcft;

        for (pcft = pftl->pcftFirst; pcft; pcft = pcft->pcftNext)
        {
            // Use the dwUser field as a deletion flag
            ((PFOLDERTWIN)pcft)->dwUser = FALSE;

            if (DPA_ERR == DPA_InsertPtr(hdpa, DPA_APPEND, (LPVOID)pcft))
            {
                DPA_Destroy(hdpa);
                return NULL;
            }
        }
        DPA_Sort(hdpa, NCompareFolders, CMP_FOLDERTWINS);
    }

    return hdpa;
}


/*----------------------------------------------------------
Purpose: Process callback after adding a folder twin

Returns: standard result
Cond:    --
 */
HRESULT CALLBACK ChangeTwinProc(
        PNEWFOLDERTWIN pnft,
        TWINRESULT tr,
        PCHANGEDATA pcd)
{
    HRESULT hres = NOERROR;

    // Is this a duplicate twin?
    if (TR_DUPLICATE_TWIN == tr)
    {
        // Yes; there's a wierd case to deal with.  It's possible that the 
        // only thing the user did was check/uncheck the Include Subdirs 
        // checkbox.  If this is true, then we delete the old twin and add 
        // a new twin (with same filespec as before) with the flags set 
        // differently.
        PCFOLDERTWIN pcft;
        HDPA hdpaFolders = pcd->hdpaFolders;
        int cdpa = DPA_GetPtrCount(hdpaFolders);
        int idpa;
        BOOL bOldInclude;

        // Find the correct pcfolder.  We will either tag it or
        // we will delete it right now and re-add the new twin.
        for (idpa = pcd->idpaStart; idpa < cdpa; idpa++)
        {
            pcft = DPA_FastGetPtr(hdpaFolders, idpa);

            if (IsSzEqual(pcft->pcszName, pnft->pcszName))
                break;      // found it!
        }
        ASSERT(idpa < cdpa);

        // Tag the twin to save from impending doom...
        ((PFOLDERTWIN)(DWORD_PTR)pcft)->dwUser = TRUE;

        // Has the Include Subfolders checkbox setting changed?
        bOldInclude = IsFlagSet(pcft->dwFlags, FT_FL_SUBTREE);
        if (bOldInclude ^ IsFlagSet(pcd->uState, IS_INCLUDESUBS))
        {
            // Yes; delete the twin anyway and add the new one.
            HFOLDERTWIN hft;

            DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Deleting old folder twin")); )
                Sync_DeleteTwin(pcft->hftOther);

            // Add the new folder twin to the database
            tr = Sync_AddFolder(pcd->hbrf, pnft, &hft);
            if (TR_SUCCESS != tr)
            {
                // Adding the new twin failed
                DPA_DeletePtr(pcd->hdpaTwins, pcd->idpaTwin);
                hres = HRESULT_FROM_TR(tr);
            }
            else 
            {
                // Set the new twin handle in the pcd->hdpaTwins list
                DPA_SetPtr(pcd->hdpaTwins, pcd->idpaTwin, (LPVOID)hft);

                DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Adding new folder twin")); )
                    DEBUG_CODE( Sync_Dump(pnft, NEWFOLDERTWIN); )
            }
        }
        else
        {
            // No; this isn't new, so don't add to list
            DPA_DeletePtr(pcd->hdpaTwins, pcd->idpaTwin);
        }
    }
    else if (tr != TR_SUCCESS)
    {
        // Sync_AddFolder failed
        DPA_DeletePtr(pcd->hdpaTwins, pcd->idpaTwin);
        hres = HRESULT_FROM_TR(tr);
    }
    else
    {
        // Sync_AddFolder succeeded
        DPA_SetPtr(pcd->hdpaTwins, pcd->idpaTwin, (LPVOID)pcd->hft);

        DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Adding new folder twin")); )
            DEBUG_CODE( Sync_Dump(pnft, NEWFOLDERTWIN); )
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Add folder twins based on the list of extensions

Returns: standard result
Cond:    --
 */
HRESULT PRIVATE Info_AddTwins(
        PINFO this,
        PNEWFOLDERTWIN pnft,
        PADDTWINSDATA patd,         // May be NULL
        LPTSTR pszExtList)           // This function writes in this buffer
{
    HRESULT hres = NOERROR;
    CHANGEDATA cd;
    HDPA hdpa;
    int  idpa;
    TCHAR szWildcard[MAX_EXT_LEN];
    LPTSTR psz;
    LPTSTR pszT;
    TCHAR ch;

    hdpa = this->pinfodata->hdpaTwins;

    cd.hbrf = PageData_GetHbrf(this->ppagedata);
    cd.hdpaTwins = hdpa;
    if (patd)
    {
        cd.hdpaFolders = patd->hdpaSortedFolders;
        cd.idpaStart = patd->idpaStart;
    }
    cd.uState = this->uState;

    pnft->pcszName = szWildcard;
    szWildcard[0] = TEXT('*');

    for (psz = pszExtList; *psz; )
    {
        TWINRESULT tr;
        HFOLDERTWIN hft = NULL;

        // Find the beginning of the next extension for the next iteration
        for (pszT = CharNext(psz); *pszT && TEXT('.') != *pszT; pszT = CharNext(pszT))
            ;
        ch = *pszT;
        *pszT = 0;      // Temporary assignment

        // Copy the extension into the name string
        lstrcpyn(&szWildcard[1], psz, ARRAYSIZE(szWildcard) - 1);

        *pszT = ch;
        psz = pszT;

        // First make sure we can add another handle to hdpaTwins
        if (DPA_ERR == (idpa = DPA_InsertPtr(hdpa, DPA_APPEND, (LPVOID)hft)))
        {
            hres = ResultFromScode(E_OUTOFMEMORY);
            break;      // Failed
        }

        // Add the folder twin to the database
        tr = Sync_AddFolder(cd.hbrf, pnft, &hft);

        if (patd)
        {
            cd.idpaTwin = idpa;
            cd.hft = hft;

            ASSERT(patd->pfnCallback);
            if ( FAILED((hres = patd->pfnCallback(pnft, tr, &cd))) )
            {
                break;
            }
        }
        else if (TR_SUCCESS != tr)
        {
            // Sync_AddFolder failed
            DPA_DeletePtr(hdpa, idpa);
            hres = HRESULT_FROM_TR(tr);
            break;
        }
        else
        {
            // Sync_AddFolder succeeded
            DPA_SetPtr(hdpa, idpa, (LPVOID)hft);

            DEBUG_CODE( Sync_Dump(pnft, NEWFOLDERTWIN); )
        }
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Add the folder twin to the database

Returns: standard result
Cond:    --
 */
HRESULT PRIVATE Info_CommitStandAlone(
        PINFO this)
{
    HRESULT hres;
    NEWFOLDERTWIN nft;
    LPTSTR pszExtList;

    RETRY_BEGIN(FALSE)
    {
        ZeroInit(&nft, NEWFOLDERTWIN);
        nft.ulSize = sizeof(nft);
        nft.pcszFolder1 = Atom_GetName(this->ppagedata->atomPath);
        nft.pcszFolder2 = Atom_GetName(this->pinfodata->atomTo);
        // nft.pcszName is set in Info_AddTwins()
        nft.dwAttributes = OBJECT_TWIN_ATTRIBUTES;
        nft.dwFlags = IsFlagSet(this->uState, IS_INCLUDESUBS) ? NFT_FL_SUBTREE : 0;

        // Create an extension list based on the dialog settings
        if (!Info_GetSelections(this, &pszExtList))
        {
            // Failed
            hres = ResultFromScode(E_OUTOFMEMORY); 
        }
        else
        {
            // Add the twins
            hres = Info_AddTwins(this, &nft, NULL, pszExtList);
            GFree(pszExtList);
        }

        if (SUCCEEDED(hres))
        {
            // Since the engine does not create folders if the folder is empty,
            // we will create the folder now (whether it is empty or not).
            // If the folder already exists, CreateDirectory will fail.
            // Big deal.
            CreateDirectory(nft.pcszFolder2, NULL);
            PathNotifyShell(nft.pcszFolder2, NSE_MKDIR, FALSE);
        }
        else
        {
            DWORD dwError = GetLastError();
            int id;

            // Unavailable disk?
            if (ERROR_INVALID_DATA == dwError || ERROR_ACCESS_DENIED == dwError)
            {
                // Yes
                hres = E_TR_UNAVAILABLE_VOLUME;
            }

            id = SEMsgBox(this->hwnd, IDS_CAP_INFO, hres, c_rgseInfo, ARRAYSIZE(c_rgseInfo));
            if (IDRETRY == id)
            {
                // Try the operation again
                RETRY_SET();
            }
        }
    }
    RETRY_END()

        return hres;
}


/*----------------------------------------------------------
Purpose: Commit the user changes to the database.  We delete
all old hFolderTwins, and add new ones.

Returns: standard result
Cond:    --
 */
HRESULT PRIVATE Info_CommitChange(
        PINFO this)
{
    HRESULT hres;
    PFOLDERTWINLIST pftl;

    hres = PageData_Query(this->ppagedata, this->hwnd, NULL, &pftl);
    if (S_FALSE == hres)
    {
        // The folder has become an orphan right under our nose.
        // Don't do anything.
        Info_DisableAll(this);
    }
    else if (S_OK == hres)
    {
        LPCTSTR pszPath = Atom_GetName(this->ppagedata->atomPath);
        ADDTWINSDATA atd;
        DECLAREHOURGLASS;

        SetHourglass();

        atd.pfnCallback = ChangeTwinProc;

        // Create a sorted DPA based on the folder twin list
        atd.hdpaSortedFolders = CreateSortedFolderDPA(pftl);
        if (atd.hdpaSortedFolders)
        {
            // Create an extension list based on the dialog settings
            LPTSTR pszExtList = NULL;

            if (Info_GetSelections(this, &pszExtList))
            {
                NEWFOLDERTWIN nft;
                PCFOLDERTWIN pcft;
                PCFOLDERTWIN pcftLast;
                int idpa;
                int cdpa;

                // Now add new folder twins.  Iterate thru atd.hdpaSortedFolders.  
                // For each unique folder twin in this list, we add a new twin, 
                // using the old lpcszFolder as the lpcszFolder2 field in our 
                // NEWFOLDERTWIN structure.
                //
                ZeroInit(&nft, NEWFOLDERTWIN);
                nft.ulSize = sizeof(NEWFOLDERTWIN);
                nft.pcszFolder1 = pszPath;
                // nft.pcszFolder2 is set in loop below
                // nft.pcszName is set in Info_AddTwins()
                nft.dwAttributes = OBJECT_TWIN_ATTRIBUTES;
                nft.dwFlags = IsFlagSet(this->uState, IS_INCLUDESUBS) ? NFT_FL_SUBTREE : 0;

                // Iterate thru existing folder twins.  Act on each unique one.
                cdpa = DPA_GetPtrCount(atd.hdpaSortedFolders);
                pcftLast = NULL;
                for (idpa = 0; idpa < cdpa; idpa++)
                {
                    pcft = DPA_FastGetPtr(atd.hdpaSortedFolders, idpa);

                    // Unique?
                    if (pcftLast && pcft->pcszOtherFolder == pcftLast->pcszOtherFolder)
                    {
                        // No; skip to next one
                        continue;
                    }

                    // This is a unique folder.  Add it using the extensions in 
                    // pszExtList.
                    atd.idpaStart = idpa;
                    nft.pcszFolder2 = pcft->pcszOtherFolder;

                    hres = Info_AddTwins(this, &nft, &atd, pszExtList);
                    if (FAILED(hres))
                    {
                        goto Cleanup;
                    }
                    pcftLast = pcft;
                }

                // Delete any old twins
                for (pcft = pftl->pcftFirst; pcft; pcft = pcft->pcftNext)
                {
                    // Is it okay to delete this twin?
                    if (pcft->hftOther && FALSE == pcft->dwUser)
                    {
                        // Yes
                        TRACE_MSG(TF_GENERAL, TEXT("Deleting folder twin with extension '%s'"), pcft->pcszName);
                        Sync_DeleteTwin(pcft->hftOther);
                    }
                }

Cleanup:
                GFree(pszExtList);
            }
            DPA_Destroy(atd.hdpaSortedFolders);
        }

        ResetHourglass();

        // Notify the shell of the change
        PathNotifyShell(pszPath, NSE_UPDATEITEM, FALSE);

        // Throw out the last saved settings and reset
        GFree(this->pszExtListPrev);
        Info_GetSelections(this, &this->pszExtListPrev);

        this->ppagedata->bRecalc = TRUE;

        if (FAILED(hres))
        {
            static SETbl const c_rgseInfoChange[] = {
                { E_TR_OUT_OF_MEMORY, IDS_OOM_CHANGETYPES, MB_ERROR },
                { E_OUTOFMEMORY, IDS_OOM_CHANGETYPES, MB_ERROR },
                { E_TR_SUBTREE_CYCLE_FOUND, IDS_ERR_ADD_SUBTREECYCLE, MB_WARNING },
            };

            SEMsgBox(this->hwnd, IDS_CAP_INFO, hres, c_rgseInfoChange, ARRAYSIZE(c_rgseInfoChange));
        }
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Info WM_INITDIALOG Handler
Returns: 
Cond:    --
 */
BOOL PRIVATE Info_OnInitDialog(
        PINFO this,
        HWND hwndFocus,
        LPARAM lParam)              // LPPROPSHEETINFO
{
    this->ppagedata = (PPAGEDATA)((LPPROPSHEETPAGE)lParam)->lParam;
    this->pinfodata = (PINFODATA)this->ppagedata->lParam;

    // Set the text of the controls
    Info_InitLabels(this);

    // Fill listbox and set the control selections
    Info_FillTypesList(this);
    if (Info_StandAlone(this))
    {
        Info_SetSelections(this);
        Info_GetSelections(this, &this->pszExtListPrev);
    }

    this->bInit = TRUE;

    return TRUE;
}


/*----------------------------------------------------------
Purpose: PSN_APPLY handler

Returns: FALSE if everything is OK
TRUE to have the property sheet switch to this page to 
correct something.
Cond:    --
 */
BOOL PRIVATE Info_OnApply(
        PINFO this)
{
    BOOL bRet;
    LPTSTR pszExtList;

    ASSERT(!Info_StandAlone(this));

    Info_GetSelections(this, &pszExtList);

    // Deny the apply?
    if (IsFlagSet(this->uState, IS_DENYAPPLY))
    {
        // Yes; don't let the apply go thru
        MsgBox(this->hwnd, MAKEINTRESOURCE(IDS_MSG_SPECIFYTYPE), 
                MAKEINTRESOURCE(IDS_CAP_INFO), NULL, MB_ERROR);
        bRet = PSNRET_INVALID;
    }
    // Have any settings changed?
    else if (pszExtList && this->pszExtListPrev &&
            // (Assume extensions are always listed in same order)
            IsSzEqual(this->pszExtListPrev, pszExtList) &&
            IsFlagSet(this->uState, IS_INCLUDESUBS) == IsFlagSet(this->uState, IS_LAST_INCLUDESUBS))
    {
        // No
        bRet = PSNRET_NOERROR;
    }
    else
    {
        // Yes; commit the changes
        Info_CommitChange(this);

        // Sync up the current/previous state
        if (IsFlagSet(this->uState, IS_INCLUDESUBS))
            SetFlag(this->uState, IS_LAST_INCLUDESUBS);
        else
            ClearFlag(this->uState, IS_LAST_INCLUDESUBS);

        bRet = PSNRET_NOERROR;
    }

    GFree(pszExtList);
    ClearFlag(this->uState, IS_CHANGED);

    return bRet;
}


/*----------------------------------------------------------
Purpose: PSN_SETACTIVE handler
Returns: --
Cond:    --
 */
void PRIVATE Info_OnSetActive(
        PINFO this)
{
    HWND hwnd = this->hwnd;

    // Cause the page to be painted right away 
    SetWindowRedraw(hwnd, TRUE);
    InvalidateRect(hwnd, NULL, TRUE);
    UpdateWindow(hwnd);

    if (this->bInit)
    {
        PageData_Init(this->ppagedata, GetParent(hwnd));
        this->bInit = FALSE;

        Info_SetSelections(this);
        Info_GetSelections(this, &this->pszExtListPrev);
    }

    // Is this data still valid?
    else if (S_FALSE == PageData_Query(this->ppagedata, this->hwnd, NULL, NULL))
    {
        // No; the folder has become an orphan
        Info_DisableAll(this);
    }
}


/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
 */
LRESULT PRIVATE Info_OnNotify(
        PINFO this,
        int idFrom,
        NMHDR  * lpnmhdr)
{
    LRESULT lRet = 0;

    switch (lpnmhdr->code)
    {
        case PSN_SETACTIVE:
            Info_OnSetActive(this);
            break;

        case PSN_APPLY:
            lRet = Info_OnApply(this);
            break;

        default:
            break;
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Determines whether to keep from leaving this sheet.
For the stand-alone ('Add Folder') dialog, this 
function enables or disables the OK button.

Returns: --
Cond:    --
 */
void PRIVATE Info_DenyKill(
        PINFO this,
        BOOL bDeny)
{
    if (Info_StandAlone(this))
    {
        Button_Enable(GetDlgItem(this->hwnd, IDOK), !bDeny);
    }
    else
    {
        if (bDeny)
            SetFlag(this->uState, IS_DENYAPPLY);
        else
            ClearFlag(this->uState, IS_DENYAPPLY);
    }
}


/*----------------------------------------------------------
Purpose: Enable the Apply button 

Returns: --
Cond:    --
 */
void PRIVATE Info_HandleChange(
        PINFO this)
{
    if (IsFlagClear(this->uState, IS_CHANGED) && !Info_StandAlone(this))
    {
        SetFlag(this->uState, IS_CHANGED);
        PropSheet_Changed(GetParent(this->hwnd), this->hwnd);
    }
}


/*----------------------------------------------------------
Purpose: Info WM_COMMAND Handler
Returns: --
Cond:    --
 */
VOID PRIVATE Info_OnCommand(
        PINFO this,
        int id,
        HWND hwndCtl,
        UINT uNotifyCode)
{
    HWND hwnd = this->hwnd;

    switch (id)
    {
        case IDC_RBINALL:
            Info_DenyKill(this, FALSE);

            // fall thru

        case IDC_RBINSELECTED:
            // Disable/enable listbox depending on which radio button
            //  is marked.
            //
            if (IDC_RBINALL == id)
                SetFlag(this->uState, IS_ALLTYPES);
            else
                ClearFlag(this->uState, IS_ALLTYPES);
            ListBox_Enable(GetDlgItem(hwnd, IDC_LBINTYPES), IsFlagClear(this->uState, IS_ALLTYPES));

            if (IDC_RBINSELECTED == id &&
                    0 == ListBox_GetSelCount(GetDlgItem(hwnd, IDC_LBINTYPES)))
            {
                Info_DenyKill(this, TRUE);
            }

            Info_HandleChange(this);
            break;

        case IDC_LBINTYPES:
            if (uNotifyCode == LBN_SELCHANGE)
            {
                // Disable/enable OK button based on number of selections
                //  in listbox.
                //
                int csel = ListBox_GetSelCount(GetDlgItem(hwnd, IDC_LBINTYPES));

                if (csel == 0)
                    Info_DenyKill(this, TRUE);
                else if (csel != this->cselPrev && this->cselPrev == 0)
                    Info_DenyKill(this, FALSE);
                this->cselPrev = csel;

                Info_HandleChange(this);
            }

            break;

        case IDC_CHININCLUDE:
            if (FALSE != Button_GetCheck(GetDlgItem(hwnd, IDC_CHININCLUDE)))
                SetFlag(this->uState, IS_INCLUDESUBS);
            else
                ClearFlag(this->uState, IS_INCLUDESUBS);
            Info_HandleChange(this);
            break;

        case IDOK:
            if (FAILED(Info_CommitStandAlone(this)))
                EndDialog(hwnd, -1);

            // Fall thru
            //  |    |
            //  v    v

        case IDCANCEL:
            if (Info_StandAlone(this))
                EndDialog(hwnd, id);
            break;
    }
}


/*----------------------------------------------------------
Purpose: Handle WM_DESTROY
Returns: --
Cond:    --
 */
void PRIVATE Info_OnDestroy(
        PINFO this)
{
    GFree(this->pszExtListPrev);
}


/////////////////////////////////////////////////////  PRIVATE FUNCTIONS


static BOOL s_bInfoRecurse = FALSE;

LRESULT INLINE Info_DefProc(
        HWND hDlg, 
        UINT msg,
        WPARAM wParam,
        LPARAM lParam) 
{
    ENTEREXCLUSIVE();
    {
        s_bInfoRecurse = TRUE;
    }
    LEAVEEXCLUSIVE();

    return DefDlgProc(hDlg, msg, wParam, lParam); 
}


/*----------------------------------------------------------
Purpose: Real Create Folder Twin dialog proc
Returns: varies
Cond:    --
 */
LRESULT Info_DlgProc(
        PINFO this,
        UINT message,
        WPARAM wParam,
        LPARAM lParam)
{
    const static DWORD rgHelpIDs[] = {
        IDC_RBINALL,        IDH_BFC_FILTER_TYPE,
        IDC_RBINSELECTED,   IDH_BFC_FILTER_TYPE,
        IDC_LBINTYPES,      IDH_BFC_FILTER_TYPE,
        IDC_CHININCLUDE,    IDH_BFC_FILTER_INCLUDE,
        IDC_GBIN,           IDH_BFC_FILTER_TYPE,
        0, 0 };

        switch (message)
        {
            HANDLE_MSG(this, WM_INITDIALOG, Info_OnInitDialog);
            HANDLE_MSG(this, WM_COMMAND, Info_OnCommand);
            HANDLE_MSG(this, WM_NOTIFY, Info_OnNotify);
            HANDLE_MSG(this, WM_DESTROY, Info_OnDestroy);

            case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPVOID)rgHelpIDs);
            return 0;

            case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)rgHelpIDs);
            return 0;

            default:
            return Info_DefProc(this->hwnd, message, wParam, lParam);
        }
}


/*----------------------------------------------------------
Purpose: Create Folder Twin Dialog Wrapper
Returns: varies
Cond:    --
 */
INT_PTR _export CALLBACK Info_WrapperProc(
        HWND hDlg,          // std params
        UINT message,
        WPARAM wParam,
        LPARAM lParam)
{
    PINFO this;

    // Cool windowsx.h dialog technique.  For full explanation, see
    //  WINDOWSX.TXT.  This supports multiple-instancing of dialogs.
    //
    ENTEREXCLUSIVE();
    {
        if (s_bInfoRecurse)
        {
            s_bInfoRecurse = FALSE;
            LEAVEEXCLUSIVE();
            return FALSE;
        }
    }
    LEAVEEXCLUSIVE();

    this = Info_GetPtr(hDlg);
    if (this == NULL)
    {
        if (message == WM_INITDIALOG)
        {
            this = GAlloc(sizeof(*this));
            if (!this)
            {
                MsgBox(hDlg, MAKEINTRESOURCE(IDS_OOM_INFO), MAKEINTRESOURCE(IDS_CAP_INFO), 
                        NULL, MB_ERROR);
                EndDialog(hDlg, IDCANCEL);
                return Info_DefProc(hDlg, message, wParam, lParam);
            }
            this->hwnd = hDlg;
            Info_SetPtr(hDlg, this);
        }
        else
        {
            return Info_DefProc(hDlg, message, wParam, lParam);
        }
    }

    if (message == WM_DESTROY)
    {
        Info_DlgProc(this, message, wParam, lParam);
        GFree(this);
        Info_SetPtr(hDlg, NULL);
        return 0;
    }

    return SetDlgMsgResult(hDlg, message, Info_DlgProc(this, message, wParam, lParam));
}



/////////////////////////////////////////////////////  PUBLIC FUNCTIONS


/*----------------------------------------------------------
Purpose: Entry point to invoke dialog

Returns: standard hresult
Cond:    --
 */
HRESULT PUBLIC Info_DoModal(
        HWND hwndOwner,
        LPCTSTR pszPathFrom,      // Source path
        LPCTSTR pszPathTo,        // Target path
        HDPA hdpaTwin,
        PCBS pcbs)
{
    HRESULT hres;
    PROPSHEETPAGE psp;
    PAGEDATA pagedata;
    INFODATA infodata;

    // (Use the source path for the atomPath because the target path
    // does not exist yet.)
    pagedata.atomPath = Atom_Add(pszPathFrom);
    if (ATOM_ERR != pagedata.atomPath)
    {
        infodata.atomTo = Atom_Add(pszPathTo);
        if (ATOM_ERR != infodata.atomTo)
        {
            INT_PTR nRet;

            pagedata.pcbs = pcbs;
            pagedata.lParam = (LPARAM)&infodata;

            infodata.hdpaTwins = hdpaTwin;
            infodata.bStandAlone = TRUE;

            // Fake up a propsheetinfo struct for the dialog box
            psp.lParam = (LPARAM)&pagedata;        // this is all we care about

            nRet = DoModal(hwndOwner, Info_WrapperProc, IDD_INFOCREATE, (LPARAM)(LPVOID)&psp);
            Atom_Delete(infodata.atomTo);

            switch (nRet)
            {
                case IDOK:      hres = NOERROR;         break;
                case IDCANCEL:  hres = E_ABORT;         break;
                default:        hres = E_OUTOFMEMORY;   break;
            }
        }
        else
        {
            hres = E_OUTOFMEMORY;
        }
        Atom_Delete(pagedata.atomPath);
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\init.h ===
//
// init.h: Declares data, defines and struct types for DLL entry point
//          module.
//
//

#ifndef __INIT_H__
#define __INIT_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  DEFINES

/////////////////////////////////////////////////////  MACROS

#define CX_IMG      16
#define CY_IMG      16

// Indexes into our image list
//
#define IMAGE_FOLDER        0       // folder
#define IMAGE_OFOLDER       1       // open folder

#define MyGetTwinResult()           (g_tr)
#define MySetTwinResult(tr)         (g_tr = (tr))

/////////////////////////////////////////////////////  TYPEDEFS


/////////////////////////////////////////////////////  EXPORTED DATA

extern HINSTANCE   g_hinst;
extern TWINRESULT  g_tr;

extern HANDLE      g_hMutexDelay;

extern int g_cxIconSpacing;
extern int g_cyIconSpacing;
extern int g_cxBorder;
extern int g_cyBorder;
extern int g_cxIcon;
extern int g_cyIcon;
extern int g_cxIconMargin;
extern int g_cyIconMargin;
extern int g_cxLabelMargin;
extern int g_cyLabelSpace;
extern int g_cxMargin;

extern COLORREF g_clrHighlightText;
extern COLORREF g_clrHighlight;
extern COLORREF g_clrWindowText;
extern COLORREF g_clrWindow;

extern HBRUSH g_hbrHighlight;
extern HBRUSH g_hbrWindow;

extern TCHAR g_szDBName[];
extern TCHAR g_szDBNameShort[];

extern int g_cProcesses;
extern UINT g_cfBriefObj;

extern UINT g_uBreakFlags;       // Controls when to int 3
extern UINT g_uTraceFlags;       // Controls what trace messages are spewed
extern UINT g_uDumpFlags;        // Controls what structs get dumped

/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

#endif // __INIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\ibrfext.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: ibrfext.c
//
//  This files contains the IShellExtInit, IShellPropSheetExt and
//  IContextMenu interfaces.
//
// History:
//  02-02-94 ScottH     Moved from iface.c; added new shell interface support
//
//---------------------------------------------------------------------------


#include "brfprv.h"         // common headers
#include <brfcasep.h>

#include "res.h"
#include "recact.h"


// Briefcase extension structure.  This is used for IContextMenu
// and PropertySheet binding.
//
typedef struct _BriefExt
{
    // We use the sxi also as our IUnknown interface
    IShellExtInit       sxi;            // 1st base class
    IContextMenu        ctm;            // 2nd base class
    IShellPropSheetExt  spx;            // 3rd base class
    UINT                cRef;           // reference count
    LPDATAOBJECT        pdtobj;         // data object
    HKEY                hkeyProgID;     // reg. database key to ProgID
} BriefExt, * PBRIEFEXT;


//---------------------------------------------------------------------------
// IDataObject extraction functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Return TRUE if the IDataObject knows the special
briefcase file-system object format

Returns: see above
Cond:    --
 */
BOOL PUBLIC DataObj_KnowsBriefObj(
        LPDATAOBJECT pdtobj)
{
    HRESULT hres;
    FORMATETC fmte = {(CLIPFORMAT)g_cfBriefObj, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    // Does this dataobject support briefcase object format?
    //
    hres = pdtobj->lpVtbl->QueryGetData(pdtobj, &fmte);
    return (hres == ResultFromScode(S_OK));
}


/*----------------------------------------------------------
Purpose: Gets the briefcase path from an IDataObject.

Returns: standard
Cond:    --
 */
HRESULT PUBLIC DataObj_QueryBriefPath(
        LPDATAOBJECT pdtobj,
        LPTSTR pszBriefPath,
        int cchMax)         // Must be size MAX_PATH
{
    HRESULT hres = ResultFromScode(E_FAIL);
    FORMATETC fmte = {(CLIPFORMAT)g_cfBriefObj, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    ASSERT(pdtobj);
    ASSERT(pszBriefPath);

    // Does this dataobject support briefcase object format?
    //
    hres = pdtobj->lpVtbl->GetData(pdtobj, &fmte, &medium);
    if (SUCCEEDED(hres))
    {
        PBRIEFOBJ pbo = (PBRIEFOBJ)GlobalLock(medium.hGlobal);
        LPTSTR psz = BOBriefcasePath(pbo);

        lstrcpyn(pszBriefPath, psz, cchMax);

        GlobalUnlock(medium.hGlobal);
        MyReleaseStgMedium(&medium);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Gets a single path from an IDataObject.

Returns: standard
S_OK if the object is inside a briefcase
S_FALSE if not
Cond:    --
 */
HRESULT PUBLIC DataObj_QueryPath(
        LPDATAOBJECT pdtobj,
        LPTSTR pszPath,
        int cchMax)          // Must be size MAX_PATH
{
    HRESULT hres = E_FAIL;
    FORMATETC fmteBrief = {(CLIPFORMAT)g_cfBriefObj, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    FORMATETC fmteHdrop = {(CLIPFORMAT)CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    ASSERT(pdtobj);
    ASSERT(pszPath);

    // Does this dataobject support briefcase object format?
    //
    hres = pdtobj->lpVtbl->GetData(pdtobj, &fmteBrief, &medium);
    if (SUCCEEDED(hres))
    {
        // Yup

        PBRIEFOBJ pbo = (PBRIEFOBJ)GlobalLock(medium.hGlobal);
        LPTSTR psz = BOFileList(pbo);

        // Only get first path in list
        lstrcpyn(pszPath, psz, cchMax);
        GlobalUnlock(medium.hGlobal);
        MyReleaseStgMedium(&medium);
        hres = S_OK;
    }
    else
    {
        // Or does it support hdrops?
        hres = pdtobj->lpVtbl->GetData(pdtobj, &fmteHdrop, &medium);
        if (SUCCEEDED(hres))
        {
            // Yup
            HDROP hdrop = medium.hGlobal;

            // Only get first path in the file list
            DragQueryFile(hdrop, 0, pszPath, MAX_PATH);

            MyReleaseStgMedium(&medium);
            hres = S_FALSE;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Gets a file list from an IDataObject.  Allocates
ppszList to appropriate size and fills it with
a null-terminated list of paths.  It is double-null
terminated.

If ppszList is NULL, then simply get the count of files.

Call DataObj_FreeList to free the ppszList.

Returns: standard
S_OK if the objects are inside a briefcase
S_FALSE if not
Cond:    --
 */
HRESULT PUBLIC DataObj_QueryFileList(
        LPDATAOBJECT pdtobj,
        LPTSTR * ppszList,       // List of files (may be NULL)
        LPUINT puCount)         // Count of files
{
    HRESULT hres = ResultFromScode(E_FAIL);
    FORMATETC fmteBrief = {(CLIPFORMAT)g_cfBriefObj, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    FORMATETC fmteHdrop = {(CLIPFORMAT)CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    ASSERT(pdtobj);
    ASSERT(puCount);

    // Does this dataobject support briefcase object format?
    //
    hres = pdtobj->lpVtbl->GetData(pdtobj, &fmteBrief, &medium);
    if (SUCCEEDED(hres))
    {
        // Yup
        PBRIEFOBJ pbo = (PBRIEFOBJ)GlobalLock(medium.hGlobal);

        *puCount = BOFileCount(pbo);
        hres = ResultFromScode(S_OK);

        if (ppszList)
        {
            *ppszList = GAlloc(BOFileListSize(pbo));
            if (*ppszList)
            {
                BltByte(*ppszList, BOFileList(pbo), BOFileListSize(pbo));
            }
            else
            {
                hres = ResultFromScode(E_OUTOFMEMORY);
            }
        }

        GlobalUnlock(medium.hGlobal);
        MyReleaseStgMedium(&medium);
        goto Leave;
    }

    // Or does it support hdrops?
    //
    hres = pdtobj->lpVtbl->GetData(pdtobj, &fmteHdrop, &medium);
    if (SUCCEEDED(hres))
    {
        // Yup
        HDROP hdrop = medium.hGlobal;
        UINT cFiles = DragQueryFile(hdrop, (UINT)-1, NULL, 0);
        UINT cchSize = 0;
        UINT i;

        *puCount = cFiles;
        hres = ResultFromScode(S_FALSE);

        if (ppszList)
        {
            // Determine size we need to allocate
            for (i = 0; i < cFiles; i++)
            {
                cchSize += DragQueryFile(hdrop, i, NULL, 0) + 1;
            }
            cchSize++;      // for extra null

            *ppszList = GAlloc(CbFromCch(cchSize));
            if (*ppszList)
            {
                LPTSTR psz = *ppszList;
                UINT cch;

                // Translate the hdrop into our file list format.
                // We know that they really are the same format,
                // but to maintain the abstraction layer, we
                // pretend we don't.
                for (i = 0; i < cFiles; i++)
                {
                    cch = DragQueryFile(hdrop, i, psz, cchSize) + 1;
                    psz += cch;
                    cchSize -= cch;
                }
                *psz = TEXT('\0');    // extra null
            }
            else
            {
                hres = ResultFromScode(E_OUTOFMEMORY);
            }
        }
        MyReleaseStgMedium(&medium);
        goto Leave;
    }

    // FEATURE: do we need to query for CF_TEXT?

Leave:
    return hres;
}


/*----------------------------------------------------------
Purpose: Frees a file list that was allocated by DataObj_QueryFileList.
Returns: --
Cond:    --
 */
void PUBLIC DataObj_FreeList(
        LPTSTR pszList)
{
    GFree(pszList);
}


//---------------------------------------------------------------------------
// BriefExt IUnknown base member functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface

Returns: standard
Cond:    --
 */
STDMETHODIMP BriefExt_QueryInterface(
        LPUNKNOWN punk, 
        REFIID riid, 
        LPVOID * ppvOut)
{
    PBRIEFEXT this = IToClass(BriefExt, sxi, punk);
    HRESULT hres;

    if (IsEqualIID(riid, &IID_IUnknown) ||
            IsEqualIID(riid, &IID_IShellExtInit))
    {
        // We use the sxi field as our IUnknown as well
        *ppvOut = &this->sxi;
        this->cRef++;
        hres = NOERROR;
    }
    else if (IsEqualIID(riid, &IID_IContextMenu))
    {
        (LPCONTEXTMENU)*ppvOut = &this->ctm;
        this->cRef++;
        hres = NOERROR;
    }
    else if (IsEqualIID(riid, &IID_IShellPropSheetExt))
    {
        (LPSHELLPROPSHEETEXT)*ppvOut = &this->spx;
        this->cRef++;
        hres = NOERROR;
    }
    else
    {
        *ppvOut = NULL;
        hres = ResultFromScode(E_NOINTERFACE);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IUnknown::AddRef

Returns: new reference count
Cond:    --
 */
STDMETHODIMP_(UINT) BriefExt_AddRef(
        LPUNKNOWN punk)
{
    PBRIEFEXT this = IToClass(BriefExt, sxi, punk);

    return ++this->cRef;
}


/*----------------------------------------------------------
Purpose: IUnknown::Release

Returns: new reference count
Cond:    --
 */
STDMETHODIMP_(UINT) BriefExt_Release(
        LPUNKNOWN punk)
{
    PBRIEFEXT this = IToClass(BriefExt, sxi, punk);

    if (--this->cRef)
    {
        return this->cRef;
    }

    if (this->pdtobj)
    {
        this->pdtobj->lpVtbl->Release(this->pdtobj);
    }

    if (this->hkeyProgID)
    {
        RegCloseKey(this->hkeyProgID);
    }

    GFree(this);
    ENTEREXCLUSIVE();
    {
        DecBusySemaphore();     // Decrement the reference count to the DLL
    }
    LEAVEEXCLUSIVE();

    return 0;
}


//---------------------------------------------------------------------------
// BriefExt IShellExtInit member functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: IShellExtInit::QueryInterface

Returns: standard
Cond:    --
 */
STDMETHODIMP BriefExt_SXI_QueryInterface(
        LPSHELLEXTINIT psxi,
        REFIID riid, 
        LPVOID * ppvOut)
{
    return BriefExt_QueryInterface((LPUNKNOWN)psxi, riid, ppvOut);
}


/*----------------------------------------------------------
Purpose: IShellExtInit::AddRef

Returns: new reference count
Cond:    --
 */
STDMETHODIMP_(UINT) BriefExt_SXI_AddRef(
        LPSHELLEXTINIT psxi)
{
    return BriefExt_AddRef((LPUNKNOWN)psxi);
}


/*----------------------------------------------------------
Purpose: IShellExtInit::Release

Returns: new reference count
Cond:    --
 */
STDMETHODIMP_(UINT) BriefExt_SXI_Release(
        LPSHELLEXTINIT psxi)
{
    return BriefExt_Release((LPUNKNOWN)psxi);
}


/*----------------------------------------------------------
Purpose: IShellExtInit::Initialize

Returns: standard
Cond:    --
 */
STDMETHODIMP BriefExt_SXI_Initialize(
        LPSHELLEXTINIT psxi,
        LPCITEMIDLIST pidlFolder,
        LPDATAOBJECT pdtobj,
        HKEY hkeyProgID)
{
    PBRIEFEXT this = IToClass(BriefExt, sxi, psxi);

    // Initialize can be called more than once.
    //
    if (this->pdtobj)
    {
        this->pdtobj->lpVtbl->Release(this->pdtobj);
    }

    if (this->hkeyProgID)
    {
        RegCloseKey(this->hkeyProgID);
    }

    // Duplicate the pdtobj pointer
    if (pdtobj)
    {
        this->pdtobj = pdtobj;
        pdtobj->lpVtbl->AddRef(pdtobj);
    }

    // Duplicate the handle
    if (hkeyProgID)
    {
        RegOpenKeyEx(hkeyProgID, NULL, 0L, MAXIMUM_ALLOWED, &this->hkeyProgID);
    }

    return NOERROR;
}


//---------------------------------------------------------------------------
// BriefExt IContextMenu member functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: IContextMenu::QueryInterface

Returns: standard
Cond:    --
 */
STDMETHODIMP BriefExt_CM_QueryInterface(
        LPCONTEXTMENU pctm,
        REFIID riid, 
        LPVOID * ppvOut)
{
    PBRIEFEXT this = IToClass(BriefExt, ctm, pctm);
    return BriefExt_QueryInterface((LPUNKNOWN)&this->sxi, riid, ppvOut);
}


/*----------------------------------------------------------
Purpose: IContextMenu::AddRef

Returns: new reference count
Cond:    --
 */
STDMETHODIMP_(UINT) BriefExt_CM_AddRef(
        LPCONTEXTMENU pctm)
{
    PBRIEFEXT this = IToClass(BriefExt, ctm, pctm);
    return BriefExt_AddRef((LPUNKNOWN)&this->sxi);
}


/*----------------------------------------------------------
Purpose: IContextMenu::Release

Returns: new reference count
Cond:    --
 */
STDMETHODIMP_(UINT) BriefExt_CM_Release(
        LPCONTEXTMENU pctm)
{
    PBRIEFEXT this = IToClass(BriefExt, ctm, pctm);
    return BriefExt_Release((LPUNKNOWN)&this->sxi);
}


/*----------------------------------------------------------
Purpose: IContextMenu::QueryContextMenu

Returns: standard
Cond:    --
 */
#define IDCM_UPDATEALL  0
#define IDCM_UPDATE     1
STDMETHODIMP BriefExt_CM_QueryContextMenu(
        LPCONTEXTMENU pctm,
        HMENU hmenu,
        UINT indexMenu,
        UINT idCmdFirst,
        UINT idCmdLast,
        UINT uFlags)
{
    PBRIEFEXT this = IToClass(BriefExt, ctm, pctm);
    USHORT cItems = 0;
    // We only want to add items to the context menu if:
    //  1) That's what the caller is asking for; and
    //  2) The object is a briefcase or an object inside
    //     a briefcase
    //
    if (IsFlagClear(uFlags, CMF_DEFAULTONLY))   // check for (1)
    {
        TCHAR szIDS[MAXSHORTLEN];

        // Is the object inside a briefcase?  We know it is if
        // the object understands our special format.
        //
        if (DataObj_KnowsBriefObj(this->pdtobj))
        {
            // Yes
            InsertMenu(hmenu, indexMenu++, MF_BYPOSITION | MF_STRING,
                    idCmdFirst+IDCM_UPDATE, SzFromIDS(IDS_MENU_UPDATE, szIDS, ARRAYSIZE(szIDS)));

            // NOTE: We should actually be using idCmdFirst+0 above since we are only adding
            // one item to the menu.  But since this code relies on using idCmdFirst+1 then
            // we need to lie and say that we added two items to the menu.  Otherwise the next
            // context menu handler to get called might use the same menu ID that we are using.
            cItems = 2;
        }
        else
        {
            // No
            TCHAR szPath[MAX_PATH];

            // Is the object a briefcase root?
            if (SUCCEEDED(DataObj_QueryPath(this->pdtobj, szPath, ARRAYSIZE(szPath))) &&
                    PathIsBriefcase(szPath))
            {
                // Yup
                InsertMenu(hmenu, indexMenu++, MF_BYPOSITION | MF_STRING,
                        idCmdFirst+IDCM_UPDATEALL, SzFromIDS(IDS_MENU_UPDATEALL, szIDS, ARRAYSIZE(szIDS)));
                cItems++;
            }
        }
    }

    return ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, (USHORT)cItems));
}


/*----------------------------------------------------------
Purpose: IContextMenu::InvokeCommand

Returns: standard
Cond:    --
 */
STDMETHODIMP BriefExt_CM_InvokeCommand(
        LPCONTEXTMENU pctm,
        LPCMINVOKECOMMANDINFO pici)
{
    HWND hwnd = pici->hwnd;
    //LPCSTR pszWorkingDir = pici->lpDirectory;
    //LPCSTR pszCmd = pici->lpVerb;
    //LPCSTR pszParam = pici->lpParameters;
    //int iShowCmd = pici->nShow;
    PBRIEFEXT this = IToClass(BriefExt, ctm, pctm);
    LPBRIEFCASESTG pbrfstg;
    HRESULT hres;

    // The only command we have is to update the selection(s).  Create
    // an instance of IBriefcaseStg so we can call its Update
    // member function.
    //
    hres = BriefStg_CreateInstance(NULL, &IID_IBriefcaseStg, &pbrfstg);

    if (SUCCEEDED(hres))
    {
        TCHAR szPath[MAX_PATH];

        hres = DataObj_QueryPath(this->pdtobj, szPath, ARRAYSIZE(szPath));

        if (SUCCEEDED(hres))
        {
            hres = pbrfstg->lpVtbl->Initialize(pbrfstg, szPath, hwnd);
            if (SUCCEEDED(hres))
            {
                hres = pbrfstg->lpVtbl->UpdateObject(pbrfstg, this->pdtobj, hwnd);
            }
            pbrfstg->lpVtbl->Release(pbrfstg);
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IContextMenu::GetCommandString

Returns: standard
Cond:    --
 */
STDMETHODIMP BriefExt_CM_GetCommandString(
        LPCONTEXTMENU pctm,
        UINT_PTR    idCmd,
        UINT        wReserved,
        UINT  *  pwReserved,
        LPSTR       pszName,
        UINT        cchMax)
{
    switch (wReserved)
    {
        case GCS_VERB:
            switch (idCmd)
            {
                case IDCM_UPDATE:
                    lstrcpyn((LPTSTR)pszName, TEXT("update"), cchMax);
                    return NOERROR;
                case IDCM_UPDATEALL:
                    lstrcpyn((LPTSTR)pszName, TEXT("update all"), cchMax);
                    return NOERROR;
            }
    }
    return E_NOTIMPL;
}


//---------------------------------------------------------------------------
// PageData functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Allocates a pagedata.

Returns: TRUE if the allocation/increment was successful

Cond:    --
 */
BOOL PRIVATE PageData_Alloc(
        PPAGEDATA * pppd,
        int atomPath)
{
    PPAGEDATA this;

    ASSERT(pppd);

    this = GAlloc(sizeof(*this));
    if (this)
    {
        HRESULT hres;
        LPCTSTR pszPath = Atom_GetName(atomPath);
        int  atomBrf;

        // Create an instance of IBriefcaseStg.
        hres = BriefStg_CreateInstance(NULL, &IID_IBriefcaseStg, &this->pbrfstg);
        if (SUCCEEDED(hres))
        {
            hres = this->pbrfstg->lpVtbl->Initialize(this->pbrfstg, pszPath, NULL);
            if (SUCCEEDED(hres))
            {
                TCHAR szBrfPath[MAX_PATH];

                // Request the root path of the briefcase storage
                this->pbrfstg->lpVtbl->GetExtraInfo(this->pbrfstg, NULL, GEI_ROOT,
                        (WPARAM)ARRAYSIZE(szBrfPath), (LPARAM)szBrfPath);

                atomBrf = Atom_Add(szBrfPath);
                hres = (ATOM_ERR != atomBrf) ? NOERROR : E_OUTOFMEMORY;
            }
        }

        if (SUCCEEDED(hres))
        {
            this->pcbs = CBS_Get(atomBrf);
            ASSERT(this->pcbs);

            Atom_AddRef(atomPath);
            this->atomPath = atomPath;

            this->cRef = 1;

            this->bFolder = (FALSE != PathIsDirectory(pszPath));

            Atom_Delete(atomBrf);
        }
        else
        {
            // Failed
            if (this->pbrfstg)
                this->pbrfstg->lpVtbl->Release(this->pbrfstg);

            GFree(this);
        }
    }
    *pppd = this;
    return NULL != this;
}


/*----------------------------------------------------------
Purpose: Increments the reference count of a pagedata

Returns: Current count
Cond:    --
 */
UINT PRIVATE PageData_AddRef(
        PPAGEDATA this)
{
    ASSERT(this);

    return ++(this->cRef);
}


/*----------------------------------------------------------
Purpose: Releases a pagedata struct

Returns: the next reference count
0 if the struct was freed

Cond:    --
 */
UINT PRIVATE PageData_Release(
        PPAGEDATA this)
{
    UINT cRef;

    ASSERT(this);
    ASSERT(0 < this->cRef);

    cRef = this->cRef;
    if (0 < this->cRef)
    {
        this->cRef--;
        if (0 == this->cRef)
        {
            if (this->pftl)
            {
                Sync_DestroyFolderList(this->pftl);
            }
            if (this->prl)
            {
                Sync_DestroyRecList(this->prl);
            }

            CBS_Delete(this->pcbs->atomBrf, NULL);

            Atom_Delete(this->atomPath);

            this->pbrfstg->lpVtbl->Release(this->pbrfstg);
            GFree(this);
            return 0;
        }
    }
    return this->cRef;
}


/*----------------------------------------------------------
Purpose: Sets the data in the pagedata struct to indicate this
is an orphan.  This function makes no change to the
database--the caller must do that.

Returns: --
Cond:    --
 */
void PUBLIC PageData_Orphanize(
        PPAGEDATA this)
{
    this->bOrphan = TRUE;
    if (this->pftl)
    {
        Sync_DestroyFolderList(this->pftl);
        this->pftl = NULL;
    }
    if (this->prl)
    {
        Sync_DestroyRecList(this->prl);
        this->prl = NULL;
    }
}


/*----------------------------------------------------------
Purpose: Initializes the common page data struct shared between
the property pages.  Keep in mind that this function may
be called multiple times, so it must behave properly
under these conditions (ie, don't blow anything away).

This function will return S_OK if it is.  S_FALSE means
the data in question has been invalidated.  This means
the twin has become an orphan.

Returns: standard result
Cond:    --
 */
HRESULT PUBLIC PageData_Init(
        PPAGEDATA this,
        HWND hwndOwner)
{
    HRESULT hres;
    HBRFCASE hbrf = PageData_GetHbrf(this);
    LPCTSTR pszPath = Atom_GetName(this->atomPath);

    // ** Note: this structure is not serialized because it is
    // assumed that of the pages that are sharing it, only one
    // can access it at a time.

    ASSERT(pszPath);

    // Has this been explicitly marked as an orphan?
    if (FALSE == this->bOrphan)
    {
        // No; is it (still) a twin?
        if (S_OK == Sync_IsTwin(hbrf, pszPath, 0))
        {
            // Yes; has the folder twinlist or reclist been created yet?
            if (NULL == this->prl ||
                    (this->bFolder && NULL == this->pftl))
            {
                // No; create it/them
                HTWINLIST htl;
                PFOLDERTWINLIST pftl = NULL;
                PRECLIST prl = NULL;
                HWND hwndProgress;
                TWINRESULT tr;

                ASSERT(NULL == this->prl);
                ASSERT( !this->bFolder || NULL == this->pftl);

                hwndProgress = UpdBar_Show(hwndOwner, UB_CHECKING | UB_NOCANCEL, DELAY_UPDBAR);

                tr = Sync_CreateTwinList(hbrf, &htl);
                hres = HRESULT_FROM_TR(tr);

                if (SUCCEEDED(hres))
                {
                    // Add to the twinlist.  Create folder twinlist if
                    // necessary.
                    if (Sync_AddPathToTwinList(hbrf, htl, pszPath, &pftl))
                    {
                        // Does the reclist need creating?
                        if (NULL == this->prl)
                        {
                            // Yes
                            hres = Sync_CreateRecListEx(htl, UpdBar_GetAbortEvt(hwndProgress), &prl);

                            if (SUCCEEDED(hres))
                            {
                                // The object may have been implicitly
                                // deleted in CreateRecList.  Check again.
                                hres = Sync_IsTwin(hbrf, pszPath, 0);
                            }
                        }
                    }
                    else
                        hres = E_FAIL;

                    // Fill in proper fields
                    if (NULL == this->prl && prl)
                    {
                        this->prl = prl;
                    }
                    if (NULL == this->pftl && pftl)
                    {
                        this->pftl = pftl;
                    }

                    // Clean up twinlist
                    Sync_DestroyTwinList(htl);
                }

                UpdBar_Kill(hwndProgress);

                // Did the above succeed?
                if (FAILED(hres) || S_FALSE == hres)
                {
                    // No
                    PageData_Orphanize(this);
                }
            }
            else
            {
                // Yes; do nothing
                hres = S_OK;
            }
        }
        else
        {
            // No; say the thing is an orphan
            PageData_Orphanize(this);
            hres = S_FALSE;
        }
    }
    else
    {
        // Yes
        hres = S_FALSE;
    }

#ifdef DEBUG
    if (S_OK == hres)
    {
        ASSERT( !this->bFolder || this->pftl );
        ASSERT(this->prl);
    }
    else
    {
        ASSERT(NULL == this->pftl);
        ASSERT(NULL == this->prl);
    }
#endif

    return hres;
}


/*----------------------------------------------------------
Purpose: Verifies whether the page data shared by the property
pages is still valid.  This function will return S_OK if
it is.  S_FALSE means the data in question has been
invalidated.  This means the twin has become an orphan.

This function assumes PageData_Init has been previously
called.

Returns: standard result
Cond:    --
 */
HRESULT PUBLIC PageData_Query(
        PPAGEDATA this,
        HWND hwndOwner,
        PRECLIST * pprl,            // May be NULL
        PFOLDERTWINLIST * ppftl)    // May be NULL
{
    HRESULT hres;
    LPCTSTR pszPath = Atom_GetName(this->atomPath);

    // ** Note: this structure is not serialized because it is
    // assumed that of the pages that are sharing it, only one
    // can access it at a time.

    ASSERT(pszPath);

    // Is a recalc called for?
    if (this->bRecalc)
    {
        // Yes; clear the fields and do again
        PageData_Orphanize(this);       // only temporary
        this->bOrphan = FALSE;          // undo the orphan state
        this->bRecalc = FALSE;

        // Reinit
        hres = PageData_Init(this, hwndOwner);
        if (pprl)
            *pprl = this->prl;
        if (ppftl)
            *ppftl = this->pftl;
    }

    // Are the fields valid?
    else if ( this->prl && (!this->bFolder || this->pftl) )
    {
        // Yes; is it (still) a twin?
        ASSERT(FALSE == this->bOrphan);

        hres = Sync_IsTwin(this->pcbs->hbrf, pszPath, 0);
        if (S_OK == hres)
        {
            // Yes
            if (pprl)
                *pprl = this->prl;
            if (ppftl)
                *ppftl = this->pftl;
        }
        else if (S_FALSE == hres)
        {
            // No; update struct fields
            PageData_Orphanize(this);
            goto OrphanTime;
        }
    }
    else
    {
        // No; say it is an orphan
OrphanTime:
        ASSERT(this->bOrphan);

        if (pprl)
            *pprl = NULL;
        if (ppftl)
            *ppftl = NULL;
        hres = S_FALSE;
    }

    return hres;
}


//---------------------------------------------------------------------------
// BriefExt IShellPropSheetExt member functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::QueryInterface

Returns: standard
Cond:    --
 */
STDMETHODIMP BriefExt_SPX_QueryInterface(
        LPSHELLPROPSHEETEXT pspx,
        REFIID riid, 
        LPVOID * ppvOut)
{
    PBRIEFEXT this = IToClass(BriefExt, spx, pspx);
    return BriefExt_QueryInterface((LPUNKNOWN)&this->sxi, riid, ppvOut);
}


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::AddRef

Returns: new reference count
Cond:    --
 */
STDMETHODIMP_(UINT) BriefExt_SPX_AddRef(
        LPSHELLPROPSHEETEXT pspx)
{
    PBRIEFEXT this = IToClass(BriefExt, spx, pspx);
    return BriefExt_AddRef((LPUNKNOWN)&this->sxi);
}


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::Release

Returns: new reference count
Cond:    --
 */
STDMETHODIMP_(UINT) BriefExt_SPX_Release(
        LPSHELLPROPSHEETEXT pspx)
{
    PBRIEFEXT this = IToClass(BriefExt, spx, pspx);
    return BriefExt_Release((LPUNKNOWN)&this->sxi);
}


/*----------------------------------------------------------
Purpose: Callback when Status property page is done
Returns: --
Cond:    --
 */
UINT CALLBACK StatusPageCallback(
        HWND hwnd,
        UINT uMsg,
        LPPROPSHEETPAGE ppsp)
{
    if (PSPCB_RELEASE == uMsg)
    {
        PPAGEDATA ppagedata = (PPAGEDATA)ppsp->lParam;

        DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Releasing status page")); )

            PageData_Release(ppagedata);
    }
    return TRUE;
}


/*----------------------------------------------------------
Purpose: Callback when Info property sheet is done
Returns: --
Cond:    --
 */
UINT CALLBACK InfoPageCallback(
        HWND hwnd,
        UINT uMsg,
        LPPROPSHEETPAGE ppsp)
{
    if (PSPCB_RELEASE == uMsg)
    {
        PPAGEDATA ppagedata = (PPAGEDATA)ppsp->lParam;
        PINFODATA pinfodata = (PINFODATA)ppagedata->lParam;

        DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Releasing info page")); )

            if (pinfodata->hdpaTwins)
            {
                int iItem;
                int cItems = DPA_GetPtrCount(pinfodata->hdpaTwins);
                HTWIN htwin;

                for (iItem = 0; iItem < cItems; iItem++)
                {
                    htwin = DPA_FastGetPtr(pinfodata->hdpaTwins, iItem);

                    Sync_ReleaseTwin(htwin);
                }
                DPA_Destroy(pinfodata->hdpaTwins);
            }
        GFree(pinfodata);

        PageData_Release(ppagedata);
    }
    return TRUE;
}


/*----------------------------------------------------------
Purpose: Add the status property page
Returns: TRUE on success
FALSE if out of memory
Cond:    --
 */
BOOL PRIVATE AddStatusPage(
        PPAGEDATA ppd,
        LPFNADDPROPSHEETPAGE pfnAddPage,
        LPARAM lParam)
{
    BOOL bRet = FALSE;
    HPROPSHEETPAGE hpsp;
    PROPSHEETPAGE psp = {
        sizeof(PROPSHEETPAGE),          // size
        PSP_USECALLBACK,                // PSP_ flags
        g_hinst,                        // hinstance
        MAKEINTRESOURCE(IDD_STATUS),    // pszTemplate
        NULL,                           // icon
        NULL,                           // pszTitle
        Stat_WrapperProc,               // pfnDlgProc
        (LPARAM)ppd,                    // lParam
        StatusPageCallback,             // pfnCallback
        0 };                            // ref count

        ASSERT(ppd);
        ASSERT(pfnAddPage);

        DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Adding status page")); )

            // Add the status property sheet
            hpsp = CreatePropertySheetPage(&psp);
        if (hpsp)
        {
            bRet = (*pfnAddPage)(hpsp, lParam);
            if (FALSE == bRet)
            {
                // Cleanup on failure
                DestroyPropertySheetPage(hpsp);
            }
        }

        return bRet;
}


/*----------------------------------------------------------
Purpose: Add the info property page.
Returns: TRUE on success
FALSE if out of memory
Cond:    --
 */
BOOL PRIVATE AddInfoPage(
        PPAGEDATA ppd,
        LPFNADDPROPSHEETPAGE lpfnAddPage,
        LPARAM lParam)
{
    BOOL bRet = FALSE;
    HPROPSHEETPAGE hpsp;
    PINFODATA pinfodata;

    ASSERT(lpfnAddPage);

    DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Adding info page")); )

        pinfodata = GAlloc(sizeof(*pinfodata));
    if (pinfodata)
    {
        PROPSHEETPAGE psp = {
            sizeof(PROPSHEETPAGE),          // size
            PSP_USECALLBACK,                // PSP_ flags
            g_hinst,                        // hinstance
            MAKEINTRESOURCE(IDD_INFO),      // pszTemplate
            NULL,                           // icon
            NULL,                           // pszTitle
            Info_WrapperProc,               // pfnDlgProc
            (LPARAM)ppd,                    // lParam
            InfoPageCallback,               // pfnCallback
            0 };                            // ref count

            ppd->lParam = (LPARAM)pinfodata;

            pinfodata->atomTo = ATOM_ERR;       // Not needed for page
            pinfodata->bStandAlone = FALSE;

            if (NULL != (pinfodata->hdpaTwins = DPA_Create(8)))
            {
                hpsp = CreatePropertySheetPage(&psp);
                if (hpsp)
                {
                    bRet = (*lpfnAddPage)(hpsp, lParam);
                    if (FALSE == bRet)
                    {
                        // Cleanup on failure
                        DestroyPropertySheetPage(hpsp);
                    }
                }
                if (FALSE == bRet)
                {
                    // Cleanup on failure
                    DPA_Destroy(pinfodata->hdpaTwins);
                }
            }
            if (FALSE == bRet)
            {
                // Cleanup on failure
                GFree(pinfodata);
            }
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Does the real work to add the briefcase pages to
the property sheet.
Returns: --
Cond:    --
 */
void PRIVATE BriefExt_AddPagesPrivate(
        LPSHELLPROPSHEETEXT pspx,
        LPCTSTR pszPath,
        LPFNADDPROPSHEETPAGE lpfnAddPage,
        LPARAM lParam)
{
    PBRIEFEXT this = IToClass(BriefExt, spx, pspx);
    HRESULT hres = NOERROR;
    TCHAR szCanonPath[MAX_PATH];
    int atomPath;

    BrfPathCanonicalize(pszPath, szCanonPath, ARRAYSIZE(szCanonPath));
    atomPath = Atom_Add(szCanonPath);
    if (atomPath != ATOM_ERR)
    {
        PPAGEDATA ppagedata;
        BOOL bVal;

        // Allocate the pagedata
        if (PageData_Alloc(&ppagedata, atomPath))
        {
            // Always add the status page (even for orphans).
            // Add the info page if the object is a folder.
            bVal = AddStatusPage(ppagedata, lpfnAddPage, lParam);
            if (bVal && ppagedata->bFolder)
            {
                PageData_AddRef(ppagedata);
                AddInfoPage(ppagedata, lpfnAddPage, lParam);
            }
            else if (FALSE == bVal)
            {
                // (Cleanup on failure)
                PageData_Release(ppagedata);
            }
        }
        Atom_Delete(atomPath);
    }
}


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::AddPages

The shell calls this member function when it is
time to add pages to a property sheet.

As the briefcase storage, we only add pages for
entities inside a briefcase.  Anything outside
a briefcase is not touched.

We can quickly determine if the object is inside
the briefcase by querying the data object that
we have.  If it knows our special "briefcase object"
format, then it must be inside a briefcase.  We
purposely do not add pages for the root folder itself.

Returns: standard hresult
Cond:    --
 */
STDMETHODIMP BriefExt_SPX_AddPages(
        LPSHELLPROPSHEETEXT pspx,
        LPFNADDPROPSHEETPAGE lpfnAddPage,
        LPARAM lParam)
{
    PBRIEFEXT this = IToClass(BriefExt, spx, pspx);
    LPTSTR pszList;
    UINT cFiles;

    // Questions:
    //  1) Does this know the briefcase object format?
    //  2) Is there only a single object selected?
    //
    if (DataObj_KnowsBriefObj(this->pdtobj) &&      /* (1) */
            SUCCEEDED(DataObj_QueryFileList(this->pdtobj, &pszList, &cFiles)) &&
            cFiles == 1)                                /* (2) */
            {
                // Yes; add the pages
                BriefExt_AddPagesPrivate(pspx, pszList, lpfnAddPage, lParam);

                DataObj_FreeList(pszList);
            }
    return NOERROR;     // Always allow property sheet to appear
}


//---------------------------------------------------------------------------
// BriefExtMenu class : Vtables
//---------------------------------------------------------------------------


IShellExtInitVtbl c_BriefExt_SXIVtbl =
{
    BriefExt_SXI_QueryInterface,
    BriefExt_SXI_AddRef,
    BriefExt_SXI_Release,
    BriefExt_SXI_Initialize
};

IContextMenuVtbl c_BriefExt_CTMVtbl =
{
    BriefExt_CM_QueryInterface,
    BriefExt_CM_AddRef,
    BriefExt_CM_Release,
    BriefExt_CM_QueryContextMenu,
    BriefExt_CM_InvokeCommand,
    BriefExt_CM_GetCommandString,
};

IShellPropSheetExtVtbl c_BriefExt_SPXVtbl = {
    BriefExt_SPX_QueryInterface,
    BriefExt_SPX_AddRef,
    BriefExt_SPX_Release,
    BriefExt_SPX_AddPages
};


/*----------------------------------------------------------
Purpose: This function is called back from within
IClassFactory::CreateInstance() of the default class
factory object, which is created by SHCreateClassObject.

Returns: standard
Cond:    --
 */
HRESULT CALLBACK BriefExt_CreateInstance(
        LPUNKNOWN punkOuter,
        REFIID riid, 
        LPVOID * ppvOut)
{
    HRESULT hres;
    PBRIEFEXT this;

    DBG_ENTER_RIID(TEXT("BriefExt_CreateInstance"), riid);

    // Shell extentions typically do not support aggregation.
    //
    if (punkOuter)
    {
        hres = ResultFromScode(CLASS_E_NOAGGREGATION);
        *ppvOut = NULL;
        goto Leave;
    }

    this = GAlloc(sizeof(*this));
    if (!this)
    {
        hres = ResultFromScode(E_OUTOFMEMORY);
        *ppvOut = NULL;
        goto Leave;
    }
    this->sxi.lpVtbl = &c_BriefExt_SXIVtbl;
    this->ctm.lpVtbl = &c_BriefExt_CTMVtbl;
    this->spx.lpVtbl = &c_BriefExt_SPXVtbl;
    this->cRef = 1;
    this->pdtobj = NULL;
    this->hkeyProgID = NULL;

    ENTEREXCLUSIVE();
    {
        // The decrement is in BriefExt_Release()
        IncBusySemaphore();
    }
    LEAVEEXCLUSIVE();

    // Note that the Release member will free the object, if QueryInterface
    // failed.
    //
    hres = c_BriefExt_SXIVtbl.QueryInterface(&this->sxi, riid, ppvOut);
    c_BriefExt_SXIVtbl.Release(&this->sxi);

Leave:
    DBG_EXIT_HRES(TEXT("BriefExt_CreateInstance"), hres);

    return hres;        // S_OK or E_NOINTERFACE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\info.h ===
//
// info.h: Declares data, defines and struct types for twin creation
//          module.
//
//

#ifndef __INFO_H__
#define __INFO_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  DEFINES

/////////////////////////////////////////////////////  MACROS

/////////////////////////////////////////////////////  TYPEDEFS

typedef struct
    {
    LPBRIEFCASESTG      pbrfstg;        // IBriefcaseStg instance
    // Params
    //
    CBS  * pcbs;
    int atomPath;
    HDPA   hdpaTwins;    // handle to array of twin handles which will
                         //  be filled by dialog.
                         //  N.b.  Caller must release these twins!
    
    BOOL bStandAlone;    // private: should only be set by Info_DoModal
    } XINFOSTRUCT,  * LPXINFOSTRUCT;


/////////////////////////////////////////////////////  EXPORTED DATA

/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

BOOL _export CALLBACK Info_WrapperProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

int PUBLIC Info_DoModal (HWND hwndParent, LPXINFOSTRUCT lpxinfo);

#endif // __INFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\init.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: init.c
//
//  This file contains the library entry points
//
// Usage and assumptions used in this DLL.
//
//  1) Message crackers are used.  See windowsx.h and windowsx.txt.
//
//  2) Many functions are considered "member functions" of a
//     particular class.  Because this is not C++, the function
//     names follow a special naming convention: "Class_Name".
//     In addition, it is common practice that the first
//     argument for these type of functions is a "this" pointer
//     to the particular object.
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers
#include <brfcasep.h>

#define INITGUID            // Initialize GUIDs
#include <initguid.h>
#include <oleguid.h>
#include <coguid.h>
#include <shlguid.h>
#include <shguidp.h>        // Contains CLSID_Briefcase

#include "res.h"
#include "recact.h"

#ifdef DEBUG
#include <debugstr.h>
#endif


//---------------------------------------------------------------------------
// Per instance data
//---------------------------------------------------------------------------


HINSTANCE   g_hinst = 0;
TWINRESULT  g_tr = TR_SUCCESS;

// Debugging variables
UINT g_uBreakFlags = 0;         // Controls when to int 3
UINT g_uTraceFlags = 0;         // Controls what trace messages are spewed
UINT g_uDumpFlags = 0;          // Controls what structs get dumped

// The delay mutex and the cs that protects the cRef is per-instance
HANDLE g_hMutexDelay = NULL;
static UINT g_cRefMutex = 0;
static CRITICAL_SECTION s_csDelay = { 0 };



//---------------------------------------------------------------------------
// Global data
//---------------------------------------------------------------------------

CRITICAL_SECTION g_csSyncUI = { 0 };
DEBUG_CODE( UINT g_cRefSyncUI = 0; )
UINT g_cfBriefObj = 0;
BOOL g_bMirroredOS = FALSE;
// Use the helper macros in brfprv.h
UINT g_cBusyRef = 0;            // Semaphore
UINT g_cBriefRef = 0;           // Semaphore

// Metrics
int g_cxIconSpacing = 0;
int g_cyIconSpacing = 0;
int g_cxBorder = 0;
int g_cyBorder = 0;
int g_cxIcon = 0;
int g_cyIcon = 0;
int g_cxIconMargin = 0;
int g_cyIconMargin = 0;
int g_cxLabelMargin = 0;
int g_cyLabelSpace = 0;
int g_cxMargin = 0;

// System colors
COLORREF g_clrHighlightText = 0;
COLORREF g_clrHighlight = 0;
COLORREF g_clrWindowText = 0;
COLORREF g_clrWindow = 0;

HBRUSH g_hbrHighlight = 0;
HBRUSH g_hbrWindow = 0;

// Strings
TCHAR g_szDBName[MAXPATHLEN];
TCHAR g_szDBNameShort[MAXPATHLEN];

// Get the system metrics we need

void PRIVATE GetMetrics(WPARAM wParam)      // wParam from WM_WININICHANGE
{
    if ((wParam == 0) || (wParam == SPI_SETNONCLIENTMETRICS))
    {
        g_cxIconSpacing = GetSystemMetrics( SM_CXICONSPACING );
        g_cyIconSpacing = GetSystemMetrics( SM_CYICONSPACING );

        g_cxBorder = GetSystemMetrics(SM_CXBORDER);
        g_cyBorder = GetSystemMetrics(SM_CYBORDER);

        g_cxIcon = GetSystemMetrics(SM_CXICON);
        g_cyIcon = GetSystemMetrics(SM_CYICON);

        g_cxIconMargin = g_cxBorder * 8;
        g_cyIconMargin = g_cyBorder * 2;
        g_cyLabelSpace = g_cyIconMargin + (g_cyBorder * 2);
        g_cxLabelMargin = (g_cxBorder * 2);
        g_cxMargin = g_cxBorder * 5;
    }
}

// Initializes colors

void PRIVATE InitGlobalColors()
{
    g_clrWindowText = GetSysColor(COLOR_WINDOWTEXT);
    g_clrWindow = GetSysColor(COLOR_WINDOW);
    g_clrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_clrHighlight = GetSysColor(COLOR_HIGHLIGHT);

    g_hbrWindow = GetSysColorBrush(COLOR_WINDOW);
    g_hbrHighlight = GetSysColorBrush(COLOR_HIGHLIGHT);
}


// Initialize global strings

void PRIVATE InitGlobalStrings()
{
    SzFromIDS(IDS_BC_DATABASE, g_szDBName, ARRAYSIZE(g_szDBName));
    SzFromIDS(IDS_BC_DATABASE_SHORT, g_szDBNameShort, ARRAYSIZE(g_szDBNameShort));
}


// Initialize the DLL on the first PROCESS_ATTACH

BOOL PRIVATE InitializeFirstTime(void)
{
    BOOL bRet = FALSE;

    InitCommonControls();

    GetMetrics(0);

    CPATH_InitCS();
    CBS_InitCS();
    CRL_InitCS();

    if (!Atom_Init())
        goto Init_Cleanup;

    if (!CPATH_Init())
        goto Init_Cleanup;

    // We do not load the engine DLL until we really need it.

    // Initialize our global imagelist
    //
    g_cfBriefObj = RegisterClipboardFormat(CFSTR_BRIEFOBJECT);
    if (g_cfBriefObj == 0)
        goto Init_Cleanup;

    bRet = TRUE;

Init_Cleanup:
    if (bRet == FALSE)
    {
        Atom_Term();
    }

    return bRet;
}

// Register window classes per process

BOOL PRIVATE InitWindowClasses(HINSTANCE hinst)
{
    return RecAct_Init(hinst);
}

// Terminate DLL on the last PROCESS_DETACH

void PRIVATE FinalTerminate(HINSTANCE hinst)
{
    CPATH_Term();
    Atom_Term();

    CRL_DeleteCS();
    CBS_DeleteCS();
    CPATH_DeleteCS();

    Mem_Terminate();
}


// Unregister window classes per process
void PRIVATE TermWindowClasses(HINSTANCE hinst)
{
    RecAct_Term(hinst);
}

// Purpose: Obtain ownership of the delay-calculation mutex
// Returns: reference count

UINT PUBLIC Delay_Own(void)
{
    UINT cRef;

    EnterCriticalSection(&s_csDelay);
    {
        if (0 == g_cRefMutex++)
        {
            // Obtain ownership of the mutex.  This will get released
            // when Delay_Release is called.
            LeaveCriticalSection(&s_csDelay);
            {
                MsgWaitObjectsSendMessage(1, &g_hMutexDelay, INFINITE);
            }
            EnterCriticalSection(&s_csDelay);

            TRACE_MSG(TF_GENERAL, TEXT("Set delay mutex"));
        }
        cRef = g_cRefMutex;
    }
    LeaveCriticalSection(&s_csDelay);

    return cRef;
}


/*----------------------------------------------------------
Purpose: Release ownership of the delay-calculation mutex

Returns: reference count
Cond:    --
 */
UINT PUBLIC Delay_Release(void)
{
    UINT cRef;

    EnterCriticalSection(&s_csDelay);
    {
        ASSERT(0 < g_cRefMutex);

        if (0 < g_cRefMutex)
        {
            if (0 == --g_cRefMutex)
            {
                ReleaseMutex(g_hMutexDelay);

                TRACE_MSG(TF_GENERAL, TEXT("Release delay mutex"));
            }
        }
        cRef = g_cRefMutex;
    }
    LeaveCriticalSection(&s_csDelay);

    return cRef;
}

void PUBLIC Brief_EnterExclusive(void)
{
    EnterCriticalSection(&g_csSyncUI);
#ifdef DEBUG
    g_cRefSyncUI++;
#endif
}


void PUBLIC Brief_LeaveExclusive(void)
{
#ifdef DEBUG
    g_cRefSyncUI--;
#endif
    LeaveCriticalSection(&g_csSyncUI);
}

BOOL ProcessAttach(HINSTANCE hDll)
{
    DWORD dwLayout = 0;
    BOOL bSuccess = TRUE;

    SHFusionInitializeFromModule(hDll);

    bSuccess = InitializeCriticalSectionAndSpinCount(&g_csSyncUI, 0);
    if (bSuccess)
    {
        bSuccess = InitializeCriticalSectionAndSpinCount(&s_csDelay, 0);
        if (bSuccess)
        {
            g_hinst = hDll;

#ifdef DEBUG
            // We do this simply to load the debug .ini flags
            ProcessIniFile();
            DEBUG_BREAK(BF_ONPROCESSATT);
#endif

            // Under NT, we need to initialize on every process attach, not just the first

            bSuccess = InitializeFirstTime();

            if (bSuccess)
            {
                // security: Changing to unnamed mutex to avoid any possible
                //           squatting issues. Handle is global and accessible
                //           across process.
                g_hMutexDelay = CreateMutex(NULL, FALSE, NULL);
                bSuccess = (NULL != g_hMutexDelay);
            }

            if (bSuccess)
            {
                // (Only do this if we succeeded above)
                //
                // Do the following for every process
                bSuccess = InitWindowClasses(hDll);
            }

            InitGlobalColors();
            InitGlobalStrings();

            //Bug 199701, 199647, 199699
            //Apparently this is either broke or never worked: g_bMirroredOS = IS_MIRRORING_ENABLED();  
            GetProcessDefaultLayout(&dwLayout);
            if (dwLayout == LAYOUT_RTL)
            {
                g_bMirroredOS = TRUE;
            }
            //End bug 199701, 199647, 199699
        }
    }
    return bSuccess;
}

BOOL ProcessDetach(HINSTANCE hDll)
{
    BOOL bSuccess = TRUE;

    ASSERT(hDll == g_hinst);

    DEBUG_CODE( DEBUG_BREAK(BF_ONPROCESSDET); )

        ASSERT(0 == g_cRefMutex);

    if (g_hMutexDelay)
    {
        CloseHandle(g_hMutexDelay);
        g_hMutexDelay = NULL;
    }

    FinalTerminate(g_hinst);

    Sync_ReleaseVTable();

    DeleteCriticalSection(&g_csSyncUI);

    DeleteCriticalSection(&s_csDelay);

    TermWindowClasses(hDll);

    SHFusionUninitialize();

    return bSuccess;
}

BOOL APIENTRY LibMain(HANDLE hDll, DWORD dwReason, void *lpReserved)
{
    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            ProcessAttach(hDll);
#ifndef DEBUG
            DisableThreadLibraryCalls(hDll);
#endif
            break;

        case DLL_PROCESS_DETACH:
            ProcessDetach(hDll);
            break;

        case DLL_THREAD_ATTACH:

#ifdef DEBUG
            // We do this simply to load the debug .ini flags
            ProcessIniFile();
#endif
            break;

        case DLL_THREAD_DETACH:

#ifdef DEBUG
            DEBUG_BREAK(BF_ONTHREADDET);
#endif
            break;

        default:
            break;
    }

    return TRUE;
}


/*----------------------------------------------------------
Purpose: Registers property sheet and context menu extensions
for the briefcase.

Returns: TRUE on success
Cond:    --
 */
BOOL PRIVATE RegisterShellExtension(void)
{
    const static TCHAR c_szPage[] = STRREG_SHEX_PROPSHEET TEXT("\\BriefcasePage");
    const static TCHAR c_szCM[] = STRREG_SHEX_MENUHANDLER TEXT("\\BriefcaseMenu");
    const static TCHAR c_szFolder[] = TEXT("Folder");
    const static TCHAR c_szStar[] = TEXT("*");
    const static TCHAR c_szFmt[] = TEXT("SOFTWARE\\Classes\\%s\\%s");
    // This must be per instance, else it will cause a fixup in
    // shared data segment.
    const static LPCTSTR rgpsz[2] = { c_szFolder, c_szStar };
    TCHAR sz[MAXBUFLEN];
    int i;

    for (i = 0; i < ARRAYSIZE(rgpsz); i++)
    {
        // Add briefcase page extension
        wnsprintf(sz, ARRAYSIZE(sz), c_szFmt, (LPCTSTR)rgpsz[i], (LPCTSTR)c_szPage);
        RegSetValue(HKEY_LOCAL_MACHINE, sz, REG_SZ, c_szCLSID, lstrlen(c_szCLSID));

        // Add briefcase context menu extension
        wnsprintf(sz, ARRAYSIZE(sz), c_szFmt, (LPCTSTR)rgpsz[i], (LPCTSTR)c_szCM);
        RegSetValue(HKEY_LOCAL_MACHINE, sz, REG_SZ, c_szCLSID, lstrlen(c_szCLSID));
    }
    return TRUE;
}


/*----------------------------------------------------------
Purpose: Create a briefcase at the specified location.

Returns: TRUE on success
Cond:    --
 */
BOOL PRIVATE CreateTheBriefcase(HWND hwnd, LPCTSTR pszNewPath)
{
    BOOL bRet = FALSE;
    TCHAR szParent[MAX_PATH];
    TCHAR szTmp[MAX_PATH];

    DEBUG_CODE( TRACE_MSG(TF_ALWAYS, TEXT("Creating %s"), (LPCTSTR)pszNewPath); )

        // We do not allow briefcases to be created inside other briefcases.

        lstrcpyn(szParent, pszNewPath, ARRAYSIZE(szParent));
    PathRemoveFileSpec(szParent);

    // Is this inside another briefcase?
    if (PL_FALSE != PathGetLocality(szParent, szTmp, ARRAYSIZE(szTmp)))
    {
        // Yes; don't do it!
        MsgBox(hwnd,
                MAKEINTRESOURCE(IDS_ERR_CREATE_INANOTHER),
                MAKEINTRESOURCE(IDS_CAP_CREATE),
                NULL,
                MB_WARNING);
    }
    else if (CreateDirectory(pszNewPath, NULL))
    {
        // Mark the briefcase as a system directory
        //
        if (!SetFileAttributes(pszNewPath, FILE_ATTRIBUTE_READONLY))
        {
            TRACE_MSG(TF_ALWAYS, TEXT("Cannot make %s a system directory"), (LPCTSTR)pszNewPath);
            RemoveDirectory(pszNewPath);

            MsgBox(hwnd,
                    MAKEINTRESOURCE(IDS_ERR_CANTCREATEBC),
                    MAKEINTRESOURCE(IDS_CAP_CREATE),
                    NULL,
                    MB_ERROR,
                    pszNewPath);
        }
        else
        {
            const static TCHAR c_szConfirmFileOp[] = TEXT("ConfirmFileOp");
            HBRFCASE hbrf;
            TWINRESULT tr;
            LPCTSTR pszDBName;
            DECLAREHOURGLASS;

            if (PathsTooLong(pszNewPath, c_szDesktopIni) ||
                    PathsTooLong(pszNewPath, g_szDBName) ||
                    PathsTooLong(pszNewPath, g_szDBNameShort))
            {
                MsgBox(hwnd,
                        MAKEINTRESOURCE(IDS_ERR_CREATE_TOOLONG),
                        MAKEINTRESOURCE(IDS_CAP_CREATE),
                        NULL,
                        MB_ERROR);
            }
            else
            {
                // Write in the desktop.ini the briefcase class ID
                PathCombine(szTmp, pszNewPath, c_szDesktopIni);
                // (First, flush the cache to make sure the desktop.ini
                // file is really created.)
                WritePrivateProfileString(NULL, NULL, NULL, szTmp);
                WritePrivateProfileString(STRINI_CLASSINFO, c_szIniKeyCLSID, c_szCLSID, szTmp);
                WritePrivateProfileString(STRINI_CLASSINFO, c_szConfirmFileOp, TEXT("0"), szTmp);

                // Make wizard run the first time it is opened.
                WritePrivateProfileString(STRINI_CLASSINFO, c_szRunWizard, TEXT("1"), szTmp);

                // Hide the desktop.ini since the shell does not selectively hide it.
                // Also make it readonly so that the user can't customize the briefcase.
                if (!SetFileAttributes(szTmp, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM))
                {
                    TRACE_MSG(TF_ALWAYS, TEXT("Cannot hide and/or make read-only %s"), (LPCTSTR)szTmp);
                }

                RegisterShellExtension();

                PathNotifyShell(pszNewPath, NSE_MKDIR, TRUE);

                // Create the database file
                SetHourglass();

                if (IsLFNDrive(pszNewPath))
                    pszDBName = g_szDBName;
                else
                    pszDBName = g_szDBNameShort;

                PathCombine(szTmp, pszNewPath, pszDBName);
                if (Sync_QueryVTable())
                {
                    tr = Sync_OpenBriefcase(szTmp,
                            OB_FL_OPEN_DATABASE | OB_FL_TRANSLATE_DB_FOLDER | OB_FL_ALLOW_UI,
                            hwnd,
                            &hbrf);
                    if (TR_SUCCESS == tr)
                    {
                        // (Don't really care about errors here)
                        Sync_SaveBriefcase(hbrf);
                        Sync_CloseBriefcase(hbrf);
                    }
                }
                ResetHourglass();

                bRet = TRUE;
            }
        }
    }
    else
    {
        // Could not create the directory.  Is it because a briefcase
        // already exists at this location?
        if (PathExists(pszNewPath))
        {
            // Yes
            TRACE_MSG(TF_ALWAYS, TEXT("Briefcase already exists at this location: %s"), (LPCTSTR)pszNewPath);
        }
        else
        {
            // No
            MsgBox(hwnd,
                    MAKEINTRESOURCE(IDS_ERR_CANTCREATEBC),
                    MAKEINTRESOURCE(IDS_CAP_CREATE),
                    NULL,
                    MB_ERROR,
                    pszNewPath);
        }
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Adds the briefcase at pszPath to the SendTo folder

Returns: standard result
Cond:    --
 */
HRESULT PRIVATE AddBriefcaseToSendToFolder(HWND hwnd, LPCTSTR pszPath)
{
    HRESULT hres = E_OUTOFMEMORY;
    TCHAR szSendTo[MAX_PATH];

    Shell_GetImageLists( NULL, NULL ); // make sure icon cache is around

    if (SHGetSpecialFolderPath(hwnd, szSendTo, CSIDL_SENDTO, FALSE))
    {
        LPITEMIDLIST pidl = ILCreateFromPath(pszPath);
        if (pidl)
        {
            LPITEMIDLIST pidlParent = ILClone(pidl);
            if (pidlParent)
            {
                IShellFolder * psf;
                IShellFolder * psfDesktop;

                ILRemoveLastID(pidlParent);

                hres = SHGetDesktopFolder(&psfDesktop);
                if (SUCCEEDED(hres))
                {
                    hres = psfDesktop->lpVtbl->BindToObject(psfDesktop, pidlParent,
                            NULL, &IID_IShellFolder, &psf);

                    if (SUCCEEDED(hres))
                    {
                        IDataObject *pdtobj;
                        LPCITEMIDLIST pidlName = ILFindLastID(pidl);

                        hres = psf->lpVtbl->GetUIObjectOf(psf, hwnd, 1, &pidlName, &IID_IDataObject, NULL, &pdtobj);
                        if (SUCCEEDED(hres))
                        {
                            SHCreateLinks(hwnd, szSendTo, pdtobj, 0, NULL);
                            pdtobj->lpVtbl->Release(pdtobj);
                        }
                        psf->lpVtbl->Release(psf);
                    }
                    psfDesktop->lpVtbl->Release(psfDesktop);
                }
                ILFree(pidlParent);
            }
            ILFree(pidl);
        }
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Creates a briefcase in the specified directory.

Returns: --
Cond:    --
 */
void WINAPI Briefcase_CreateInDirectory(HWND hwnd, HWND hwndCabinet, LPCTSTR pszPath)
{
    if (CreateTheBriefcase(hwnd, pszPath))
    {
        // Select the newly created item to edit it
        LPITEMIDLIST pidl = ILCreateFromPath(pszPath);
        if (pidl)
        {
            SelectItemInCabinet(hwndCabinet, ILFindLastID(pidl), TRUE);
            ILFree(pidl);
        }
    }
}


/*----------------------------------------------------------
Purpose: Creates a briefcase on the desktop.

Returns: --
Cond:    --
 */
void WINAPI Briefcase_CreateOnDesktop(HWND hwnd)
{
    // Place it on the desktop
    TCHAR szPath[MAX_PATH];

    if (SHGetSpecialFolderPath(hwnd, szPath, CSIDL_DESKTOPDIRECTORY, FALSE))
    {
        int cch;
        UINT ids;

        if (IsLFNDrive(szPath))
            ids = IDS_BC_NAME;
        else
            ids = IDS_BC_NAME_SHORT;

        StrCatBuff(szPath, TEXT("\\"), ARRAYSIZE(szPath));
        cch = lstrlen(szPath);
        LoadString(g_hinst, ids, &szPath[cch], ARRAYSIZE(szPath)-cch);
        if (CreateTheBriefcase(hwnd, szPath))
        {
            // Add a shortcut of this briefcase to the SendTo folder
            AddBriefcaseToSendToFolder(hwnd, szPath);
        }
    }
}



/*----------------------------------------------------------
Purpose: Create a briefcase folder in the specified 
directory or on the desktop.
Returns: --
Cond:    --
 */
void WINAPI _export Briefcase_Create_Common(HWND hwnd, HINSTANCE hAppInstance, LPTSTR pszCmdLine, int nCmdShow)
{
    DEBUG_CODE( DEBUG_BREAK(BF_ONRUNONCE); )

        // Command line should be of format "xxxx path" where <path>
        // is the fully qualified pathname of the briefcase to create,
        // and <xxxx> is the explorer hwnd.

        if (pszCmdLine && *pszCmdLine)
        {
            LPTSTR psz;
            HWND hwndCabinet;

            // Get hwnd
            hwndCabinet = IntToPtr(AnsiToInt(pszCmdLine));
            psz = StrChr(pszCmdLine, TEXT(' '));
            if (NULL != hwndCabinet && NULL != psz)
            {
                Briefcase_CreateInDirectory(hwnd, hwndCabinet, CharNext(psz));
                return;
            }
        }
    Briefcase_CreateOnDesktop(hwnd);
}

void WINAPI _export Briefcase_Create(HWND hwnd, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    UINT iLength = lstrlenA(pszCmdLine)+1;
    LPWSTR lpwszCmdLine;

    lpwszCmdLine = (LPWSTR)LocalAlloc(LPTR, iLength *SIZEOF(TCHAR));
    if (lpwszCmdLine)
    {
        MultiByteToWideChar(CP_ACP, 0, pszCmdLine, -1,
                lpwszCmdLine, iLength);

        Briefcase_Create_Common(hwnd, hAppInstance, lpwszCmdLine, nCmdShow);
        LocalFree((HANDLE)lpwszCmdLine);
    }
}

void WINAPI _export Briefcase_CreateW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR pwszCmdLine, int nCmdShow)
{
    Briefcase_Create_Common(hwnd, hAppInstance, pwszCmdLine, nCmdShow);
}




/*----------------------------------------------------------
Purpose: Display the introduction "wizard".  (It's really not
a wizard since it is not making anything for us.)

NOTE: This function serves double duty for both the ansi and unicode
versions. It never uses the command line.

Returns: --
Cond:    --
 */
void WINAPI _export Briefcase_Intro(
        HWND hwnd,
        HINSTANCE hAppInstance,
        LPTSTR lpszCmdLine,
        int nCmdShow)
{
    Intro_DoModal(hwnd);
}


//---------------------------------------------------------------------------
// DLL entry-points
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: This function is called back from within
IClassFactory::CreateInstance() of the default class
factory object, which is created by SHCreateClassObject.

Returns: standard
Cond:    --
 */
HRESULT CALLBACK DllFactoryCallback(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    HRESULT hres;

    if (IsEqualIID(riid, &IID_IShellExtInit))
    {
        hres = BriefExt_CreateInstance(punkOuter, riid, ppvOut);
    }
    else if (IsEqualIID(riid, &IID_IBriefcaseStg))
    {
        hres = BriefStg_CreateInstance(punkOuter, riid, ppvOut);
    }
    else
    {
        hres = E_NOINTERFACE;
        *ppvOut = NULL;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Standard OLE 2.0 entry-point

Returns: standard
Cond:    --
 */
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvOut)
{
    HRESULT hres;

    if (IsEqualIID(rclsid, &CLSID_Briefcase))
    {
        // We are supposed return the class object for this class. Instead
        // of fully implementing it in this DLL, we just call a helper
        // function in the shell DLL which creates a default class factory
        // object for us. When its CreateInstance member is called, it
        // will call back our create instance function.
        hres = SHCreateDefClassObject(
                riid,                   // Interface ID
                ppvOut,                 // Non-null to aggregate
                DllFactoryCallback,     // callback function
                &g_cBusyRef,            // reference count of this DLL
                NULL);                  // init interface
    }
    else
    {
        hres = REGDB_E_CLASSNOTREG;
        *ppvOut = NULL;
    }

    return hres;
}




/*----------------------------------------------------------
Purpose: "Can Unload Now" entry point.  Called by the shell DLL
task handler list.
Returns: S_OK to unload
Cond:    --
 */
STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;

    // We only unload when:
    //  2) We are not busy processing anything else *and*
    //  3) No briefcases are currently open
    //
    ENTEREXCLUSIVE();
    {
        if (!IsBusySemaphore() &&
                !IsOpenBriefSemaphore())
        {
            DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("DllCanUnloadNow says OK (Busy=%d, Brief=%d)"),
                        g_cBusyRef, g_cBriefRef); )

                hr = S_OK;
        }
        else
        {
            DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("DllCanUnloadNow says FALSE (Busy=%d, Brief=%d)"),
                        g_cBusyRef, g_cBriefRef); )

                hr = S_FALSE;
        }
    }
    LEAVEEXCLUSIVE();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\mem.c ===
#include "brfprv.h"

//========== Memory Management =============================================

#ifndef WIN32

#define MAX_WORD    0xffff

DECLARE_HANDLE(HHEAP);

typedef struct {                //  maps to the bottom of a 16bit DS
    WORD reserved[8];
    WORD cAlloc;
    WORD cbAllocFailed;
    HHEAP hhpFirst;
    HHEAP hhpNext;
} HEAP;

#define PHEAP(hhp)          ((HEAP *)MAKELP(hhp, 0))
#define MAKEHP(sel, off)    ((void _huge*)MAKELP((sel), (off)))

#define CBSUBALLOCMAX   0x0000f000L

HHEAP g_hhpFirst = NULL;

BOOL  DestroyHeap(HHEAP hhp);

void Mem_Terminate()
{
    while (g_hhpFirst)
        DestroyHeap(g_hhpFirst);
}

BOOL  CreateHeap(WORD cbInitial)
{
    HHEAP hhp;

    if (cbInitial < 1024)
        cbInitial = 1024;

    hhp = (HHEAP)GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, cbInitial);

    if (!hhp)
        return FALSE;

    if (!LocalInit((WORD)hhp, sizeof(HEAP), cbInitial - 1))
    {
        GlobalFree(hhp);
        return FALSE;
    }

    PHEAP(hhp)->cAlloc = 0;
    PHEAP(hhp)->cbAllocFailed = MAX_WORD;
    PHEAP(hhp)->hhpNext = g_hhpFirst;
    g_hhpFirst = hhp;

    DebugMsg(DM_TRACE, TEXT("CreateHeap: added new local heap %x"), hhp);

    return TRUE;
}

#pragma optimize("o", off)              // linked list removals don't optimize correctly
BOOL  DestroyHeap(HHEAP hhp)
{
    ASSERT(hhp);
    ASSERT(g_hhpFirst);

    if (g_hhpFirst == hhp)
    {
        g_hhpFirst = PHEAP(hhp)->hhpNext;
    }
    else
    {
        HHEAP hhpT = g_hhpFirst;

        while (PHEAP(hhpT)->hhpNext != hhp)
        {
            hhpT = PHEAP(hhpT)->hhpNext;
            if (!hhpT)
                return FALSE;
        }

        PHEAP(hhpT)->hhpNext = PHEAP(hhp)->hhpNext;
    }
    if (GlobalFree((HGLOBAL)hhp) != NULL)
        return FALSE;

    return TRUE;
}
#pragma optimize("", on)        // back to default optimizations

#pragma optimize("lge", off) // Suppress warnings associated with use of _asm...
void *  HeapAlloc(HHEAP hhp, WORD cb)
{
    void * pb;

    _asm {
        push    ds
        mov     ds,hhp
    }

    pb = (void *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb);

    if (pb)
        ((HEAP *)0)->cAlloc++;

    _asm {
        pop     ds
    }

    return pb;
}
#pragma optimize("o", off)              // linked list removals don't optimize correctly

void _huge* WINAPI SharedAlloc(long cb)
{
    void * pb;
    HHEAP hhp;
    HHEAP hhpPrev;

    // If this is a big allocation, just do a global alloc.
    //
    if (cb > CBSUBALLOCMAX)
    {
        void * lpb = MAKEHP(GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, cb), 0);
        if (!lpb)
            DebugMsg(DM_ERROR, TEXT("Alloc: out of memory"));
        return lpb;
    }

    hhp = g_hhpFirst;

    while (TRUE)
    {
        if (hhp == NULL)
        {
            if (!CreateHeap(0))
            {
                DebugMsg(DM_ERROR, TEXT("Alloc: out of memory"));
                return NULL;
            }

            hhp = g_hhpFirst;
        }

        pb = HeapAlloc(hhp, (WORD)cb);
        if (pb)
            return MAKEHP(hhp, pb);

        // Record the size of the allocation that failed.
        // Later attempts to allocate more than this amount
        // will not succeed.  This gets reset anytime anything
        // is freed in the heap.
        //
        PHEAP(hhp)->cbAllocFailed = (WORD)cb;

        // First heap is full... see if there's room in any other heap...
        //
        for (hhpPrev = hhp; hhp = PHEAP(hhp)->hhpNext; hhpPrev = hhp)
        {
            // If the last allocation to fail in this heap
            // is not larger than cb, don't even try an allocation.
            //
            if ((WORD)cb >= PHEAP(hhp)->cbAllocFailed)
                continue;

            pb = HeapAlloc(hhp, (WORD)cb);
            if (pb)
            {
                // This heap had room: move it to the front...
                //
                PHEAP(hhpPrev)->hhpNext = PHEAP(hhp)->hhpNext;
                PHEAP(hhp)->hhpNext = g_hhpFirst;
                g_hhpFirst = hhp;

                return MAKEHP(hhp, pb);
            }
            else
            {
                // The alloc failed.  Set cbAllocFailed...
                //
                PHEAP(hhp)->cbAllocFailed = (WORD)cb;
            }
        }
    }
}
#pragma optimize("", on)        // back to default optimizations

#pragma optimize("lge", off) // Suppress warnings associated with use of _asm...

void _huge* WINAPI SharedReAlloc(void _huge* pb, long cb)
{
    void * pbNew;
    void _huge* lpbNew;
    UINT cbOld;

    // FEATURE, does not work with cb > 64k
    if (!pb)
        return SharedAlloc(cb);

    if (OFFSETOF(pb) == 0)
        return MAKEHP(GlobalReAlloc((HGLOBAL)SELECTOROF(pb), cb, GMEM_MOVEABLE | GMEM_ZEROINIT), 0);

    _asm {
        push    ds
        mov     ds,word ptr [pb+2]
    }

    pbNew = (void *)LocalReAlloc((HLOCAL)OFFSETOF(pb), (int)cb, LMEM_MOVEABLE | LMEM_ZEROINIT);
    if (!pbNew)
        cbOld = LocalSize((HLOCAL)OFFSETOF(pb));

    _asm {
        pop     ds
    }

    if (pbNew)
        return MAKEHP(SELECTOROF(pb), pbNew);

    lpbNew = SharedAlloc(cb);
    if (lpbNew)
    {
        hmemcpy((void *)lpbNew, (void *)pb, cbOld);
        Free(pb);
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("ReAlloc: out of memory"));
    }
    return lpbNew;
}

BOOL WINAPI SharedFree(void _huge*  * ppb)
{
    BOOL fSuccess;
    UINT cAlloc;
    void _huge * pb = *ppb;

    if (!pb)
        return FALSE;

    *ppb = 0;

    if (OFFSETOF(pb) == 0)
        return (GlobalFree((HGLOBAL)SELECTOROF(pb)) == NULL);

    _asm {
        push    ds
        mov     ds,word ptr [pb+2]
    }

    fSuccess = (LocalFree((HLOCAL)OFFSETOF(pb)) ? FALSE : TRUE);

    cAlloc = 1;
    if (fSuccess)
    {
        cAlloc = --((HEAP *)0)->cAlloc;
        ((HEAP *)0)->cbAllocFailed = MAX_WORD;
    }

    _asm {
        pop     ds
    }

    if (cAlloc == 0)
        DestroyHeap((HHEAP)SELECTOROF(pb));

    return fSuccess;
}


DWORD WINAPI SharedGetSize(void _huge* pb)
{
    WORD wSize;

    if (OFFSETOF(pb) == 0)
        return GlobalSize((HGLOBAL)SELECTOROF(pb));

    _asm {
        push    ds
        mov     ds,word ptr [pb+2]
    }

    wSize = LocalSize((HLOCAL)OFFSETOF(pb));

    _asm {
        pop     ds
    }

    return (DWORD)wSize;
}


#if 0
// hmemcpy() is faster (says davidds)

void WINAPI MemCopy(void * pTo, const void * pFrom, UINT cb)
{
    _asm {
        mov     cx,cb
        jcxz    mcexit

;;      push    si
;;      push    di
        mov     dx,ds

        lds     si,pFrom
        les     di,pTo

        cmp     si,di
        jae     mccopyup

        mov     ax,cx
        dec     ax
        dec     ax
        add     si,ax
        add     di,ax

        std
        shr     cx,1
        rep     movsw
        jnc     mc100
        inc     si
        inc     di
        movsb
mc100:
        cld
        jmp     short mcexit

mccopyup:
        cld
        shr     cx,1
        rep     movsw
        jnc     mc200
        movsb
mc200:

mcexit:
        mov     ds,dx
;;      pop     di
;;      pop     si
    }
}
#endif

#pragma optimize("", on)

#else // WIN32

// Define a Global Shared Heap that we use allocate memory out of that we
// Need to share between multiple instances.
HANDLE g_hSharedHeap = NULL;
#define MAXHEAPSIZE 2097152
#define HEAP_SHARED     0x04000000              /* put heap in shared memory */

//----------------------------------------------------------------------------
void PUBLIC Mem_Terminate()
{
    // Assuming that everything else has exited
    //
    if (g_hSharedHeap != NULL)
        HeapDestroy(g_hSharedHeap);
    g_hSharedHeap = NULL;
}

//----------------------------------------------------------------------------
void * WINAPI SharedAlloc(long cb)
{
    // I will assume that this is the only one that needs the checks to
    // see if the heap has been previously created or not

    if (g_hSharedHeap == NULL)
    {
        ENTEREXCLUSIVE();
        if (g_hSharedHeap == NULL)
        {
              g_hSharedHeap = HeapCreate(0, 1, MAXHEAPSIZE);
        }
        LEAVEEXCLUSIVE();

        // If still NULL we have problems!
        if (g_hSharedHeap == NULL)
            return(NULL);
    }

    return HeapAlloc(g_hSharedHeap, HEAP_ZERO_MEMORY, cb);
}

//----------------------------------------------------------------------------
void * WINAPI SharedReAlloc(void * pb, long cb)
{
    if (pb==NULL)
    {
        return SharedAlloc(cb);
    }
    return HeapReAlloc(g_hSharedHeap, HEAP_ZERO_MEMORY, pb, cb);
}

//----------------------------------------------------------------------------
BOOL WINAPI SharedFree(void ** ppb)
{
    void * pb = *ppb;

    if (!pb)
        return FALSE;

    *ppb = 0;

    return HeapFree(g_hSharedHeap, 0, pb);
}

//----------------------------------------------------------------------------
DWORD WINAPI SharedGetSize(void * pb)
{
    return (DWORD)HeapSize(g_hSharedHeap, 0, pb);
}

//----------------------------------------------------------------------------
// The following functions are for debug only and are used to try to
// calculate memory usage.
//
#ifdef DEBUG
typedef struct _HEAPTRACE
{
    DWORD   cAlloc;
    DWORD   cFailure;
    DWORD   cReAlloc;
    DWORD   cbMaxTotal;
    DWORD   cCurAlloc;
    DWORD   cbCurTotal;
} HEAPTRACE;

HEAPTRACE g_htSync = {0};      // Start of zero...

LPVOID WINAPI MemAlloc(HANDLE hheap, DWORD cb)
{
    LPVOID lp;

    lp = HeapAlloc(hheap, HEAP_ZERO_MEMORY, cb);
    if (lp == NULL)
    {
        g_htSync.cFailure++;
        return NULL;
    }

    // Update counts.
    g_htSync.cAlloc++;
    g_htSync.cCurAlloc++;
    g_htSync.cbCurTotal += cb;
    if (g_htSync.cbCurTotal > g_htSync.cbMaxTotal)
        g_htSync.cbMaxTotal = g_htSync.cbCurTotal;

    return lp;
}

LPVOID WINAPI MemReAlloc(HANDLE hheap, LPVOID pb, DWORD cb)
{
    LPVOID lp;
    DWORD cbOld;

    cbOld = HeapSize(hheap, 0, pb);

    lp = HeapReAlloc(hheap, HEAP_ZERO_MEMORY, pb,cb);
    if (lp == NULL)
    {
        g_htSync.cFailure++;
        return NULL;
    }

    // Update counts.
    g_htSync.cReAlloc++;
    g_htSync.cbCurTotal += cb - cbOld;
    if (g_htSync.cbCurTotal > g_htSync.cbMaxTotal)
        g_htSync.cbMaxTotal = g_htSync.cbCurTotal;

    return lp;
}

BOOL  WINAPI MemFree(HANDLE hheap, LPVOID pb)
{
    BOOL fRet;

    DWORD cbOld;

    cbOld = HeapSize(hheap, 0, pb);

    fRet = HeapFree(hheap, 0, pb);
    if (fRet)
    {
        // Update counts.
        g_htSync.cCurAlloc--;
        g_htSync.cbCurTotal -= cbOld;
    }

    return(fRet);
}

DWORD WINAPI MemSize(HANDLE hheap, LPVOID pb)
{
    return HeapSize(hheap, 0, pb);
}
#endif


#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\oledup.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: oledup.c
//
//  This files contains duplicated code the OLE would provide.
//  We do this so we don't have to link to OLE for M6.
//  we should remove this for M7 (why?  the shell does this too)
//
// History:
//  02-14-94 ScottH     Created (copied from shell)
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers


HRESULT MyReleaseStgMedium(LPSTGMEDIUM pmedium)
    {
    if (pmedium->pUnkForRelease)
        {
        pmedium->pUnkForRelease->lpVtbl->Release(pmedium->pUnkForRelease);
        }
    else
        {
        switch(pmedium->tymed)
            {
        case TYMED_HGLOBAL:
            GlobalFree(pmedium->hGlobal);
            break;

        default:
            // Not fullly implemented.
            MessageBeep(0);
            break;
            }
        }

    return NOERROR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\misc.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: misc.c
//
//  This file contains miscellaneous dialog code
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------

#include "brfprv.h"     // common headers

#include "res.h"


typedef struct _MB_BUTTONS
{
    UINT id;        // id
    UINT ids;       // string ID
} MB_BUTTONS, * PMB_BUTTONS;

typedef struct _BTNSTYLE
{
    UINT cButtons;
    MB_BUTTONS rgmbb[4];
} BTNSTYLE;


//---------------------------------------------------------------------------
// Control manipulation stuff
//---------------------------------------------------------------------------


// Flags for SNAPCTL
#define SCF_ANCHOR      0x0001
#define SCF_VCENTER     0x0002
#define SCF_BOTTOM      0x0004
#define SCF_TOP         0x0008
#define SCF_SNAPLEFT    0x0010
#define SCF_SNAPRIGHT   0x0020

typedef struct tagSNAPCTL
{
    UINT    idc;
    UINT    uFlags;
} SNAPCTL, * PSNAPCTL;


/*----------------------------------------------------------
Purpose: Moves a control
Returns: HDWP
Cond:    --
 */
HDWP PRIVATE SlideControlPos(
        HDWP hdwp,
        HWND hDlg,
        UINT idc,
        int cx,
        int cy)
{
    HWND hwndPos = GetDlgItem(hDlg, idc);
    RECT rcPos;

    GetWindowRect(hwndPos, &rcPos);
    MapWindowRect(HWND_DESKTOP, hDlg, &rcPos);
    return DeferWindowPos(hdwp, hwndPos, NULL,
            rcPos.left + cx, rcPos.top + cy,
            0, 0,
            SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
}


/*----------------------------------------------------------
Purpose: Aligns a list of controls, relative to an "anchor"
control.

Only one anchor control is supported; the first control
designated as anchor in the list is selected.

Returns: --
Cond:    --
 */
void PRIVATE SnapControls(
        HWND hwnd,
        SNAPCTL const * psnap,
        UINT csnap)
{
    HWND hwndAnchor;
    UINT i;
    SNAPCTL const * psnapStart = psnap;
    HDWP hdwp;
    RECT rcAnchor;
    int yCenter;

    ASSERT(psnap);

    // Find the anchor control
    for (i = 0; i < csnap; i++, psnap++)
    {
        if (IsFlagSet(psnap->uFlags, SCF_ANCHOR))
        {
            hwndAnchor = GetDlgItem(hwnd, psnap->idc);
            break;
        }
    }

    if (i == csnap)
        return;     // No anchor control!

    GetWindowRect(hwndAnchor, &rcAnchor);
    yCenter = rcAnchor.top + (rcAnchor.bottom - rcAnchor.top)/2;

    hdwp = BeginDeferWindowPos(csnap-1);

    if (hdwp)
    {
        RECT rc;
        UINT uFlags;
        HWND hwndPos;

        for (i = 0, psnap = psnapStart; i < csnap; i++, psnap++)
        {
            uFlags = psnap->uFlags;
            if (IsFlagSet(uFlags, SCF_ANCHOR))
                continue;       // skip anchor

            hwndPos = GetDlgItem(hwnd, psnap->idc);
            GetWindowRect(hwndPos, &rc);

            if (IsFlagSet(uFlags, SCF_VCENTER))
            {
                // Vertically match the center of this control with
                // the center of the anchor
                rc.top += yCenter - (rc.top + (rc.bottom - rc.top)/2);
            }
            else if (IsFlagSet(uFlags, SCF_TOP))
            {
                // Vertically match the top of this control with
                // the top of the anchor
                rc.top += rcAnchor.top - rc.top;
            }
            else if (IsFlagSet(uFlags, SCF_BOTTOM))
            {
                // Vertically match the bottom of this control with
                // the bottom of the anchor
                rc.top += rcAnchor.bottom - rc.bottom;
            }

            if (IsFlagSet(uFlags, SCF_SNAPLEFT))
            {
                // Snap the control so it is abut to the left side
                // of the anchor control
                rc.left += rcAnchor.left - rc.right;
            }
            else if (IsFlagSet(uFlags, SCF_SNAPRIGHT))
            {
                // Snap the control so it is abut to the right side
                // of the anchor control
                rc.left += rcAnchor.right - rc.left;
            }

            // Move control
            MapWindowRect(HWND_DESKTOP, hwnd, &rc);
            hdwp = DeferWindowPos(hdwp, hwndPos, NULL,
                    rc.left, rc.top, 0, 0,
                    SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
        }
        EndDeferWindowPos(hdwp);
    }
}


//---------------------------------------------------------------------------
// Abort event stuff
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Creates an abort event.

Returns: TRUE on success
Cond:    --
 */
BOOL PUBLIC AbortEvt_Create(
        PABORTEVT * ppabortevt,
        UINT uFlags)
{
    PABORTEVT this;

    ASSERT(ppabortevt);

    if (IsFlagSet(uFlags, AEF_SHARED))
        this = SharedAllocType(ABORTEVT);
    else
        this = GAllocType(ABORTEVT);

    if (this)
    {
        this->uFlags = uFlags;
    }

    *ppabortevt = this;

    return NULL != this;
}


/*----------------------------------------------------------
Purpose: Destroys an abort event.

Returns: --
Cond:    --
 */
void PUBLIC AbortEvt_Free(
        PABORTEVT this)
{
    if (this)
    {
        if (IsFlagSet(this->uFlags, AEF_SHARED))
            SharedFree(&this);
        else
            GFree(this);
    }
}


/*----------------------------------------------------------
Purpose: Sets the abort event.

Returns: Returns the previous abort event.
Cond:    --
 */
BOOL PUBLIC AbortEvt_Set(
        PABORTEVT this,
        BOOL bAbort)
{
    BOOL bRet;

    if (this)
    {
        bRet = IsFlagSet(this->uFlags, AEF_ABORT);

        if (bAbort)
        {
            TRACE_MSG(TF_GENERAL, TEXT("Setting abort event"));
            SetFlag(this->uFlags, AEF_ABORT);
        }
        else
        {
            TRACE_MSG(TF_GENERAL, TEXT("Clearing abort event"));
            ClearFlag(this->uFlags, AEF_ABORT);
        }
    }
    else
        bRet = FALSE;

    return bRet;
}


/*----------------------------------------------------------
Purpose: Queries the abort event

Returns: the current abort event (TRUE or FALSE)
Cond:    --
 */
BOOL PUBLIC AbortEvt_Query(
        PABORTEVT this)
{
    BOOL bRet;

    if (this)
    {
        bRet = IsFlagSet(this->uFlags, AEF_ABORT);

#ifdef DEBUG
        if (bRet)
            TRACE_MSG(TF_GENERAL, TEXT("Abort is set!"));
#endif
    }
    else
        bRet = FALSE;

    return bRet;
}


//---------------------------------------------------------------------------
// Progress bar stuff
//---------------------------------------------------------------------------

#define MSECS_PER_SEC   1000

#define WM_QUERYABORT   (WM_APP + 1)


/*----------------------------------------------------------
Purpose: Progress dialog during reconciliations
Returns: varies
Cond:    --
 */
INT_PTR CALLBACK UpdateProgressProc(
        HWND hDlg,
        UINT wMsg,
        WPARAM wParam,
        LPARAM lParam)
{
    PUPDBAR this = (PUPDBAR)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            this = (PUPDBAR)lParam;

            if (IsFlagSet(this->uFlags, UB_NOCANCEL))
            {
                ShowWindow(GetDlgItem(hDlg, IDCANCEL), SW_HIDE);
                EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);
            }
            break;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDCANCEL:
                    AbortEvt_Set(this->pabortevt, TRUE);
                    break;
            }
            break;

        case WM_QUERYABORT:
            if (GetTickCount() >= this->dwTickShow &&
                    0 != this->dwTickShow)
            {
                if (this->hcurSav)
                {
                    SetCursor(this->hcurSav);
                    this->hcurSav = NULL;
                }

                ShowWindow(hDlg, SW_SHOW);
                UpdateWindow(hDlg);
                this->dwTickShow = 0;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}



/*----------------------------------------------------------
Purpose: Displays the update progress bar dialog

Returns: dialog handle to a modeless dialog
NULL if dialog couldn't be created

Cond:    Call UpdBar_Kill when finished
 */
HWND PUBLIC UpdBar_Show(
        HWND hwndParent,
        UINT uFlags,        // UB_*
        UINT nSecs)         // Valid only if UB_TIMER set
{
    HWND hdlg = NULL;
    PUPDBAR this;

    // Create and show the progress dialog
    //
    this = GAlloc(sizeof(*this));
    if (this)
    {
        // (It is okay if this fails--it just means we ignore the Cancel button)
        AbortEvt_Create(&this->pabortevt, AEF_DEFAULT);

        this->hwndParent = hwndParent;
        this->uFlags = uFlags;
        hdlg = CreateDialogParam(g_hinst, MAKEINTRESOURCE(IDD_PROGRESS),
                hwndParent, UpdateProgressProc, (LPARAM)(PUPDBAR)this);

        if (!hdlg)
        {
            GFree(this);
        }
        else
        {
            UpdBar_SetAvi(hdlg, uFlags);

            if (IsFlagClear(uFlags, UB_NOSHOW))
                EnableWindow(hwndParent, FALSE);

            if (IsFlagSet(uFlags, UB_TIMER))
            {
                this->dwTickShow = GetTickCount() + (nSecs * MSECS_PER_SEC);
                this->hcurSav = SetCursorRemoveWigglies(LoadCursor(NULL, IDC_WAIT));
            }
            else
            {
                this->dwTickShow = 0;
                this->hcurSav = NULL;

                if (IsFlagClear(uFlags, UB_NOSHOW))
                {
                    ShowWindow(hdlg, SW_SHOW);
                    UpdateWindow(hdlg);
                }
            }
        }
    }

    return hdlg;
}


/*----------------------------------------------------------
Purpose: Destroy the update progress bar
Returns: --
Cond:    --
 */
void PUBLIC UpdBar_Kill(
        HWND hdlg)
{
    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
    {
        PUPDBAR this = (PUPDBAR)GetWindowLongPtr(hdlg, DWLP_USER);

        ASSERT(this);
        if (this)
        {
            if (this->hcurSav)
                SetCursor(this->hcurSav);

            if (IsWindow(this->hwndParent))
                EnableWindow(this->hwndParent, TRUE);
            GFree(this);
        }
        DestroyWindow(hdlg);
    }
}


/*----------------------------------------------------------
Purpose: Set the progress bar range.  Reset the position to 0
Returns: --
Cond:    --
 */
void PUBLIC UpdBar_SetRange(
        HWND hdlg,
        WORD wRangeMax)
{
    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
    {
        SendDlgItemMessage(hdlg, IDC_PROGRESS, PBM_SETPOS, 0, 0);
        SendDlgItemMessage(hdlg, IDC_PROGRESS, PBM_SETRANGE, 0, MAKELONG(0, wRangeMax));
    }
}


/*----------------------------------------------------------
Purpose: Increment the position of progress bar
Returns: --
Cond:    --
 */
void PUBLIC UpdBar_DeltaPos(
        HWND hdlg,
        WORD wdelta)
{
    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
    {
        SendDlgItemMessage(hdlg, IDC_PROGRESS, PBM_DELTAPOS, wdelta, 0);
    }
}


/*----------------------------------------------------------
Purpose: Set the position of progress bar
Returns: --
Cond:    --
 */
void PUBLIC UpdBar_SetPos(
        HWND hdlg,
        WORD wPos)
{
    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
    {
        SendDlgItemMessage(hdlg, IDC_PROGRESS, PBM_SETPOS, wPos, 0);
    }
}


/*----------------------------------------------------------
Purpose: Set the current name we're updating in the progress
bar.
Returns: --
Cond:    --
 */
void PUBLIC UpdBar_SetName(
        HWND hdlg,
        LPCTSTR pszName)
{
    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
    {
        HWND hwndName = GetDlgItem(hdlg, IDC_NAME);

        Static_SetText(hwndName, pszName);
    }
}


/*----------------------------------------------------------
Purpose: Set the current name we're updating in the progress
bar.
Returns: --
Cond:    --
 */
void PUBLIC UpdBar_SetDescription(
        HWND hdlg,
        LPCTSTR psz)
{
    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
    {
        HWND hwndName = GetDlgItem(hdlg, IDC_TONAME);

        Static_SetText(hwndName, psz);
    }
}


/*----------------------------------------------------------
Purpose: Get the window handle of the progress status text.
Returns: --
Cond:    --
 */
HWND PUBLIC UpdBar_GetStatusWindow(
        HWND hdlg)
{
    HWND hwnd;

    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
        hwnd = GetDlgItem(hdlg, IDC_TEXT);
    else
        hwnd = NULL;

    return hwnd;
}


/*----------------------------------------------------------
Purpose: Returns a pointer to the abort event owned by this
progress window.

Returns: pointer to abort event or NULL

Cond:    --
 */
PABORTEVT PUBLIC UpdBar_GetAbortEvt(
        HWND hdlg)
{
    PABORTEVT pabortevt = NULL;

    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
    {
        PUPDBAR this;

        this = (PUPDBAR)GetWindowLongPtr(hdlg, DWLP_USER);
        if (this)
        {
            pabortevt = this->pabortevt;
        }
    }

    return pabortevt;
}


/*----------------------------------------------------------
Purpose: Sets the animate control to play the avi file designated
by the UB_ flags

Returns: --
Cond:    --
 */
void PUBLIC UpdBar_SetAvi(
        HWND hdlg,
        UINT uFlags)    // UB_*
{
    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
    {
        UINT ida;
        UINT ids;
        HWND hwndAvi = GetDlgItem(hdlg, IDC_ANIMATE);
        TCHAR sz[MAXBUFLEN];
        RECT rc;


        if (IsFlagClear(uFlags, UB_NOSHOW))
        {
            SetWindowRedraw(hdlg, FALSE);

            // Is the window visible yet?
            if (IsFlagSet(GetWindowLong(hdlg, GWL_STYLE), WS_VISIBLE))
            {
                // Yes; select just the upper area of the progress bar to
                // repaint
                int cy;

                GetWindowRect(GetDlgItem(hdlg, IDC_NAME), &rc);
                MapWindowPoints(HWND_DESKTOP, hdlg, (LPPOINT)&rc, 1);
                cy = rc.top;
                GetClientRect(hdlg, &rc);
                rc.bottom = cy;
            }
            else
            {
                // No
                GetWindowRect(hdlg, &rc);
                MapWindowPoints(HWND_DESKTOP, hdlg, (LPPOINT)&rc, 2);
            }
        }

        if (IsFlagSet(uFlags, UB_NOPROGRESS))
        {
            ShowWindow(GetDlgItem(hdlg, IDC_PROGRESS), SW_HIDE);
        }
        else
        {
            ShowWindow(GetDlgItem(hdlg, IDC_PROGRESS), SW_SHOW);
        }

        // Special text when checking?
        if (IsFlagSet(uFlags, UB_CHECKAVI))
        {
            // Yes
            SetDlgItemText(hdlg, IDC_TONAME, SzFromIDS(IDS_MSG_CHECKING, sz, ARRAYSIZE(sz)));
        }
        else
        {
            // No
            SetDlgItemText(hdlg, IDC_TONAME, TEXT(""));
        }

        // Run AVI?
        if (uFlags & (UB_CHECKAVI | UB_UPDATEAVI))
        {
            // Yes
            static const SNAPCTL rgsnap[] = {
                { IDC_ICON1, SCF_BOTTOM | SCF_SNAPLEFT },
                { IDC_ANIMATE, SCF_ANCHOR },
                { IDC_ICON2, SCF_BOTTOM | SCF_SNAPRIGHT },
            };

            if (IsFlagSet(uFlags, UB_CHECKAVI))
            {
                ida = IDA_CHECK;
                ids = IDS_CAP_CHECKING;
            }
            else if (IsFlagSet(uFlags, UB_UPDATEAVI))
            {
                ida = IDA_UPDATE;
                ids = IDS_CAP_UPDATING;
            }
            else
                ASSERT(0);

            SetWindowText(hdlg, SzFromIDS(ids, sz, ARRAYSIZE(sz)));
            Animate_Open(hwndAvi, MAKEINTRESOURCE(ida));

            // Snap the icons on either side to the animation
            // control
            SnapControls(hdlg, rgsnap, ARRAYSIZE(rgsnap));

            Animate_Play(hwndAvi, 0, -1, -1);
        }

        // Don't bother setting the redraw if we're never going to show
        // the progress bar
        if (IsFlagClear(uFlags, UB_NOSHOW))
        {
            SetWindowRedraw(hdlg, TRUE);
            InvalidateRect(hdlg, &rc, TRUE);
            UpdateWindow(hdlg);
        }
    }
}


/*----------------------------------------------------------
Purpose: Yield, and check if user aborted
Returns: TRUE to abort
FALSE to continue
Cond:    --
 */
BOOL PUBLIC UpdBar_QueryAbort(
        HWND hdlg)
{
    BOOL bAbort = FALSE;

    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
    {
        MSG msg;
        PUPDBAR this;

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        /*
         * Don't use SendMessage() here to ask hdlg if reconciliation has been
         * aborted.  hdlg has typically been created in a different thread.
         * hdlg's creator thread may already be blocked in the sync engine.  We
         * must avoid inter-thread SendMessage() to avoid a deadlock on the
         * sync engine's briefcase critical section.  The sync engine is not
         * reentrant.
         */

        PostMessage(hdlg, WM_QUERYABORT, 0, 0);

        this = (PUPDBAR)GetWindowLongPtr(hdlg, DWLP_USER);

        if (this)
        {
            bAbort = AbortEvt_Query(this->pabortevt);
        }
    }

    return bAbort;
}


//---------------------------------------------------------------------------
// Confirm Replace dialog
//---------------------------------------------------------------------------

// This is the private data structure for the dialog
typedef struct
{
    UINT uFlags;        // CRF_*
    TCHAR szDesc[MAXBUFLEN+MAXPATHLEN];
    TCHAR szInfoExisting[MAXMEDLEN];
    TCHAR szInfoOther[MAXMEDLEN];
    HICON hicon;
} CONFIRMREPLACE;


/*----------------------------------------------------------
Purpose: Confirm replace dialog
Returns: varies
Cond:    --
 */
INT_PTR CALLBACK ConfirmReplace_Proc(
        HWND hDlg,
        UINT wMsg,
        WPARAM wParam,
        LPARAM lParam)
{
    switch (wMsg)
    {
        case WM_INITDIALOG:
            {
                CONFIRMREPLACE * pcr = (CONFIRMREPLACE *)lParam;
                UINT i;
                UINT cButtons;
                MB_BUTTONS const * pmbb;
                static UINT const rgidc[4] = { IDC_BUTTON1, IDC_BUTTON2, IDC_BUTTON3, IDC_BUTTON4 };
                static BTNSTYLE const btnstyleSingle =
                    // (List buttons backwards)
                { 2, { { IDNO,  IDS_NO },
                         { IDYES, IDS_YES },
                     } };

                static BTNSTYLE const btnstyleMulti =
                    // (List buttons backwards)
                { 4, { { IDCANCEL,      IDS_CANCEL },
                         { IDNO,          IDS_NO },
                         { IDC_YESTOALL,  IDS_YESTOALL },
                         { IDYES,         IDS_YES },
                     } };

                Static_SetText(GetDlgItem(hDlg, IDC_DESC), pcr->szDesc);

                if (IsFlagClear(pcr->uFlags, CRF_FOLDER))
                {
                    Static_SetText(GetDlgItem(hDlg, IDC_EXISTING), pcr->szInfoExisting);
                    Static_SetText(GetDlgItem(hDlg, IDC_OTHER), pcr->szInfoOther);

                    Static_SetIcon(GetDlgItem(hDlg, IDC_ICON_EXISTING), pcr->hicon);
                    Static_SetIcon(GetDlgItem(hDlg, IDC_ICON_OTHER), pcr->hicon);
                }

                // Set the IDs and strings of used buttons
                if (IsFlagSet(pcr->uFlags, CRF_MULTI))
                {
                    cButtons = btnstyleMulti.cButtons;
                    pmbb = btnstyleMulti.rgmbb;
                }
                else
                {
                    cButtons = btnstyleSingle.cButtons;
                    pmbb = btnstyleSingle.rgmbb;
                }

                for (i = 0; i < cButtons; i++)
                {
                    TCHAR sz[MAXMEDLEN];
                    HWND hwnd = GetDlgItem(hDlg, rgidc[i]);

                    LoadString(g_hinst, pmbb[i].ids, sz, ARRAYSIZE(sz));
                    SetWindowLongPtr(hwnd, GWLP_ID, pmbb[i].id);
                    SetWindowText(hwnd, sz);
                }
                // Disable unused buttons
                for (; i < ARRAYSIZE(rgidc); i++)
                {
                    HWND hwnd = GetDlgItem(hDlg, rgidc[i]);

                    EnableWindow(hwnd, FALSE);
                    ShowWindow(hwnd, SW_HIDE);
                }
            }
            break;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDCANCEL:
                case IDYES:
                case IDC_YESTOALL:
                case IDNO:
                    EndDialog(hDlg, wParam);
                    break;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


/*----------------------------------------------------------
Purpose: Brings up the replace confirmation dialog.

Returns: IDYES, IDC_YESTOALL, IDNO or IDCANCEL
Cond:    --
 */
int PUBLIC ConfirmReplace_DoModal(
        HWND hwndOwner,
        LPCTSTR pszPathExisting,
        LPCTSTR pszPathOther,
        UINT uFlags)                // CRF_*
{
    INT_PTR idRet;
    CONFIRMREPLACE * pcr;

    pcr = GAlloc(sizeof(*pcr));
    if (pcr)
    {
        LPTSTR pszMsg;
        DWORD dwAttrs = GetFileAttributes(pszPathExisting);

        pcr->uFlags = uFlags;

        // Is this replacing a folder?
        if (IsFlagSet(dwAttrs, FILE_ATTRIBUTE_DIRECTORY))
        {
            // Yes
            if (ConstructMessage(&pszMsg, g_hinst, MAKEINTRESOURCE(IDS_MSG_ConfirmFolderReplace),
                        PathFindFileName(pszPathOther)))
            {
                lstrcpyn(pcr->szDesc, pszMsg, ARRAYSIZE(pcr->szDesc));
                GFree(pszMsg);
            }
            else
                *pcr->szDesc = 0;

            SetFlag(pcr->uFlags, CRF_FOLDER);

            idRet = DoModal(hwndOwner, ConfirmReplace_Proc, IDD_REPLACE_FOLDER, (LPARAM)pcr);
        }
        else
        {
            // No
            UINT ids;
            FileInfo * pfi;

            if (SUCCEEDED(FICreate(pszPathExisting, &pfi, FIF_ICON)))
            {
                pcr->hicon = pfi->hicon;

                FIGetInfoString(pfi, pcr->szInfoExisting, ARRAYSIZE(pcr->szInfoExisting));

                pfi->hicon = NULL;      // (keep icon around)
                FIFree(pfi);
            }

            if (SUCCEEDED(FICreate(pszPathOther, &pfi, FIF_DEFAULT)))
            {
                FIGetInfoString(pfi, pcr->szInfoOther, ARRAYSIZE(pcr->szInfoOther));
                FIFree(pfi);
            }

            if (IsFlagSet(dwAttrs, FILE_ATTRIBUTE_READONLY))
            {
                ids = IDS_MSG_ConfirmFileReplace_RO;
            }
            else if (IsFlagSet(dwAttrs, FILE_ATTRIBUTE_SYSTEM))
            {
                ids = IDS_MSG_ConfirmFileReplace_Sys;
            }
            else
            {
                ids = IDS_MSG_ConfirmFileReplace;
            }

            if (ConstructMessage(&pszMsg, g_hinst, MAKEINTRESOURCE(ids),
                        PathFindFileName(pszPathOther)))
            {
                lstrcpyn(pcr->szDesc, pszMsg, ARRAYSIZE(pcr->szDesc));
                GFree(pszMsg);
            }
            else
                *pcr->szDesc = 0;

            ClearFlag(pcr->uFlags, CRF_FOLDER);

            idRet = DoModal(hwndOwner, ConfirmReplace_Proc, IDD_REPLACE_FILE, (LPARAM)pcr);

            if (pcr->hicon)
                DestroyIcon(pcr->hicon);
        }
        GFree(pcr);
    }
    else
    {
        idRet = -1;     // Out of memory
    }
    return (int)idRet;
}


//---------------------------------------------------------------------------
// Introduction dialog
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Intro dialog
Returns: varies
Cond:    --
 */
INT_PTR CALLBACK Intro_Proc(
        HWND hDlg,
        UINT wMsg,
        WPARAM wParam,
        LPARAM lParam)
{
    NMHDR  *lpnm;

    switch (wMsg)
    {
        case WM_INITDIALOG:
            break;

        case WM_NOTIFY:
            lpnm = (NMHDR  *)lParam;
            switch(lpnm->code)
            {
                case PSN_SETACTIVE: {
                                        // Only allow the Finish button.  The user cannot go back and
                                        // change the settings.
                                        HWND hwndCancel = GetDlgItem(GetParent(hDlg), IDCANCEL);

                                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);

                                        // Hide cancel button
                                        EnableWindow(hwndCancel, FALSE);
                                        ShowWindow(hwndCancel, SW_HIDE);
                                    }
                                    break;

                case PSN_KILLACTIVE:
                case PSN_HELP:
                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                                    break;

                default:
                                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


/*----------------------------------------------------------
Purpose: Invoke the introduction wizard.

Returns: ID of button that terminated dialog
Cond:    --
 */
int PUBLIC Intro_DoModal(
        HWND hwndParent)
{
    PROPSHEETPAGE psp = {
        sizeof(psp),
        PSP_DEFAULT | PSP_HIDEHEADER,
        g_hinst,
        MAKEINTRESOURCE(IDD_INTRO_WIZARD),
        NULL,           // hicon
        NULL,           // caption
        Intro_Proc,
        0,              // lParam
        NULL,           // pfnCallback
        NULL            // pointer to ref count
    };
    PROPSHEETHEADER psh = {
        sizeof(psh),
        PSH_WIZARD_LITE | PSH_WIZARD | PSH_PROPSHEETPAGE,     // (use ppsp field)
        hwndParent,
        g_hinst,
        0,              // hicon
        0,              // caption
        1,              // number of pages
        0,              // start page
        &psp
    };

    return (int)PropertySheet(&psh);
}



//---------------------------------------------------------------------------
// MsgBox dialog
//---------------------------------------------------------------------------

typedef struct _MSGBOX
{
    LPCTSTR pszText;
    LPCTSTR pszCaption;
    HICON  hicon;
    UINT   uStyle;
} MSGBOX, * PMSGBOX;


/*----------------------------------------------------------
Purpose: Determines whether to resize the dialog and reposition
the buttons to fit the text.

The dialog is not resized any smaller than its initial
size.

The dialog is only resized vertically.

Returns: --
Cond:    --
 */
void PRIVATE MsgBox_Resize(
        HWND hDlg,
        LPCTSTR pszText,
        UINT cchText)
{
    HDC hdc;
    HWND hwndText = GetDlgItem(hDlg, IDC_TEXT);

    hdc = GetDC(hwndText);
    if (hdc)
    {
        HFONT hfont = GetStockObject(DEFAULT_GUI_FONT);
        HFONT hfontSav = SelectFont(hdc, hfont);
        RECT rc;
        RECT rcOrg;

        // Determine new dimensions
        GetClientRect(hwndText, &rcOrg);
        rc = rcOrg;
        DrawTextEx(hdc, (LPTSTR)pszText, cchText, &rc, DT_CALCRECT | DT_WORDBREAK | DT_LEFT, NULL);

        SelectFont(hdc, hfontSav);
        ReleaseDC(hwndText, hdc);

        // Is the required size bigger?
        if (rc.bottom > rcOrg.bottom)
        {
            // Yes; resize the windows
            int cy = rc.bottom - rcOrg.bottom;
            int cyFudge = GetSystemMetrics(SM_CYCAPTION) + 2*GetSystemMetrics(SM_CYFIXEDFRAME);
            int cxFudge = 2*GetSystemMetrics(SM_CXFIXEDFRAME);
            HDWP hdwp = BeginDeferWindowPos(4);

            if (hdwp)
            {
                // Move Buttons
                hdwp = SlideControlPos(hdwp, hDlg, IDC_BUTTON1, 0, cy);
                hdwp = SlideControlPos(hdwp, hDlg, IDC_BUTTON2, 0, cy);
                hdwp = SlideControlPos(hdwp, hDlg, IDC_BUTTON3, 0, cy);

                // Resize Static Text
                hdwp = DeferWindowPos(hdwp, hwndText, GetDlgItem(hDlg, IDC_BUTTON3),
                        0, 0,
                        rc.right-rc.left, rc.bottom-rc.top,
                        SWP_NOACTIVATE | SWP_NOMOVE);

                EndDeferWindowPos(hdwp);
            }

            // Resize Dialog
            GetClientRect(hDlg, &rc);
            SetWindowPos(hDlg, NULL, 0, 0,
                    rc.right-rc.left + cxFudge, rc.bottom-rc.top + cy + cyFudge,
                    SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
        }
    }
}


/*----------------------------------------------------------
Purpose: MsgBox dialog
Returns: varies
Cond:    --
 */
INT_PTR CALLBACK MsgBox_Proc(
        HWND hDlg,
        UINT wMsg,
        WPARAM wParam,
        LPARAM lParam)
{
    switch (wMsg)
    {
        case WM_INITDIALOG:
            {
                PMSGBOX pmsgbox = (PMSGBOX)lParam;
                UINT uStyle = pmsgbox->uStyle;
                UINT i;
                UINT imb = uStyle & MB_TYPEMASK;
                UINT cButtons;
                MB_BUTTONS const * pmbb;
                static UINT const rgidc[3] = { IDC_BUTTON1, IDC_BUTTON2, IDC_BUTTON3 };
                static BTNSTYLE const rgmbstyle[] = {
                    // (List buttons backwards)
                    // MB_OK
                    { 1, { { IDOK,      IDS_OK },
                         } },
                    // MB_OKCANCEL
                    { 2, { { IDCANCEL,  IDS_CANCEL },
                             { IDOK,      IDS_OK },
                         } },
                    // MB_ABORTRETRYIGNORE (not supported)
                    { 1, { { IDOK,      IDS_OK },
                         } },
                    // MB_YESNOCANCEL
                    { 3, { { IDCANCEL,  IDS_CANCEL },
                             { IDNO,      IDS_NO },
                             { IDYES,     IDS_YES },
                         } },
                    // MB_YESNO
                    { 2, { { IDNO,      IDS_NO },
                             { IDYES,     IDS_YES },
                         } },
                    // MB_RETRYCANCEL
                    { 2, { { IDCANCEL,  IDS_CANCEL },
                             { IDRETRY,   IDS_RETRY },
                         } },
                };

                // Set the text
                if (pmsgbox->pszText)
                {
                    Static_SetText(GetDlgItem(hDlg, IDC_TEXT), pmsgbox->pszText);

                    // Resize and reposition the buttons if necessary
                    MsgBox_Resize(hDlg, pmsgbox->pszText, lstrlen(pmsgbox->pszText));
                }
                if (pmsgbox->pszCaption)
                    SetWindowText(hDlg, pmsgbox->pszCaption);

                // Use a custom icon?
                if (NULL == pmsgbox->hicon)
                {
                    // No; use a system icon
                    LPCTSTR pszIcon;

                    if (IsFlagSet(uStyle, MB_ICONEXCLAMATION))
                        pszIcon = IDI_EXCLAMATION;
                    else if (IsFlagSet(uStyle, MB_ICONHAND))
                        pszIcon = IDI_HAND;
                    else if (IsFlagSet(uStyle, MB_ICONQUESTION))
                        pszIcon = IDI_QUESTION;
                    else
                        pszIcon = IDI_ASTERISK;

                    pmsgbox->hicon = LoadIcon(NULL, pszIcon);
                }
                Static_SetIcon(GetDlgItem(hDlg, IDC_MSGICON), pmsgbox->hicon);

                // Set the IDs and strings of used buttons
                cButtons = rgmbstyle[imb].cButtons;
                pmbb = rgmbstyle[imb].rgmbb;
                for (i = 0; i < cButtons; i++)
                {
                    TCHAR sz[MAXMEDLEN];
                    HWND hwnd = GetDlgItem(hDlg, rgidc[i]);

                    LoadString(g_hinst, pmbb[i].ids, sz, ARRAYSIZE(sz));
                    SetWindowLongPtr(hwnd, GWLP_ID, pmbb[i].id);
                    SetWindowText(hwnd, sz);
                }
                // Disable unused buttons
                for (; i < ARRAYSIZE(rgidc); i++)
                {
                    HWND hwnd = GetDlgItem(hDlg, rgidc[i]);

                    EnableWindow(hwnd, FALSE);
                    ShowWindow(hwnd, SW_HIDE);
                }
            }
            break;

        case WM_COMMAND:
            switch (wParam)
            {
                case IDOK:
                case IDCANCEL:
                case IDYES:
                case IDNO:
                case IDRETRY:
                    EndDialog(hDlg, wParam);
                    break;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


/*----------------------------------------------------------
Purpose: Invoke the introduction dialog.

Returns: ID of button that terminated dialog
Cond:    --
 */
int PUBLIC MsgBox(
        HWND hwndParent,
        LPCTSTR pszText,
        LPCTSTR pszCaption,
        HICON hicon,            // May be NULL
        UINT uStyle, ...)
{
    INT_PTR iRet = -1;
    int ids;
    TCHAR szCaption[MAXPATHLEN];
    LPTSTR pszRet;
    va_list ArgList;

    va_start(ArgList, uStyle);

    pszRet = _ConstructMessageString(g_hinst, pszText, &ArgList);

    va_end(ArgList);

    if (pszRet)
    {
        // Is pszCaption a resource ID?
        if (0 == HIWORD(pszCaption))
        {
            // Yes; load it
            ids = LOWORD(pszCaption);
            SzFromIDS(ids, szCaption, ARRAYSIZE(szCaption));
            pszCaption = szCaption;
        }

        // Invoke dialog
        if (pszCaption)
        {
            MSGBOX msgbox = { pszRet, pszCaption, hicon, uStyle };
            iRet = DoModal(hwndParent, MsgBox_Proc, IDC_MSGBOX, (LPARAM)&msgbox);
        }
        LocalFree(pszRet);
    }

    return (int)iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\port32.h ===
#ifdef WIN32

// These things have direct equivalents.

// Shouldn't be using these things.
#define _huge
#define _export
#define SELECTOROF(x)   ((UINT_PTR)(x))
#define OFFSETOF(x)     ((UINT_PTR)(x))
#define ISLPTR(pv)      (pv)
#define MAKELP(hmem,off) ((LPVOID)((LPBYTE)hmem+off))
#define MAKELRESULTFROMUINT(i)  ((LRESULT)i)
#define ISVALIDHINSTANCE(hinst) (hinst)

#define DATASEG_READONLY    TEXT(".text")
#define DATASEG_PERINSTANCE TEXT(".instanc")
#define DATASEG_SHARED      TEXT(".data")

#define GetWindowInt    GetWindowLong
#define SetWindowInt    SetWindowLong
#define SetWindowID(hwnd,id)    SetWindowLongPtr(hwnd, GWLP_ID, id)
#define MCopyIconEx(hinst, hicon, cx, cy, flags) CopyIconEx(hicon, cx, cy, flags)
#define MLoadIconEx(hinst1, hinst2, lpsz, cx, cy, flags) LoadIconEx(hinst2, lpsz, cx, cy, flags)

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\path.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: path.c
//
//  This files contains the path whacking code.
//
// History:
//  01-31-94 ScottH     Moved from shellext.c
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers
#include "res.h"


/*----------------------------------------------------------
Purpose: Removes the trailing backslash from a path.

A:\            -->     A:\
C:\foo\        -->     C:\foo
\\Pyrex\User\  -->     \\Pyrex\User

Returns: pointer to NULL that replaced the backslash or
the pointer to the last character if it isn't 
a backslash

Cond:    pimped this code from the shell
 */
LPTSTR PUBLIC MyPathRemoveBackslash(
        LPTSTR lpszPath)
{
    int len = lstrlen(lpszPath)-1;
    if (IsDBCSLeadByte((BYTE)*CharPrev(lpszPath,lpszPath+len+1)))
        len--;

    if (!PathIsRoot(lpszPath) && lpszPath[len] == TEXT('\\'))
        lpszPath[len] = TEXT('\0');

    return lpszPath + len;
}

/*----------------------------------------------------------
Purpose: Convert a file spec to make it look a bit better
if it is all upper case chars.

Returns: --
Cond:    --
 */
BOOL PRIVATE PathMakeComponentPretty(LPTSTR lpPath)
{
    LPTSTR lp;

    // REVIEW: INTL need to deal with lower case chars in (>127) range?

    // check for all uppercase
    for (lp = lpPath; *lp; lp = CharNext(lp)) {
        if ((*lp >= TEXT('a')) && (*lp <= TEXT('z')))
            return FALSE;       // this is a LFN, dont mess with it
    }

    CharLower(lpPath);
    CharUpperBuff(lpPath, 1);
    return TRUE;        // did the conversion
}


//---------------------------------------------------------------------------
// Given a pointer to a point in a path - return a ptr the start of the
// next path component. Path components are delimted by slashes or the
// null at the end.
// There's special handling for UNC names.
// This returns NULL if you pass in a pointer to a NULL ie if you're about
// to go off the end of the  path.
LPTSTR PUBLIC PathFindNextComponentI(LPCTSTR lpszPath)
{
    LPTSTR lpszLastSlash;

    // Are we at the end of a path.
    if (!*lpszPath)
    {
        // Yep, quit.
        return NULL;
    }
    // Find the next slash.
    // REVIEW UNDONE - can slashes be quoted?
    lpszLastSlash = StrChr(lpszPath, TEXT('\\'));
    // Is there a slash?
    if (!lpszLastSlash)
    {
        // No - Return a ptr to the NULL.
        return (LPTSTR) (lpszPath+lstrlen(lpszPath));
    }
    else
    {
        // Is it a UNC style name?
        if (TEXT('\\') == *(lpszLastSlash+1))
        {
            // Yep, skip over the second slash.
            return lpszLastSlash+2;
        }
        else
        {
            // Nope. just skip over one slash.
            return lpszLastSlash+1;
        }
    }
}


/*----------------------------------------------------------
Purpose: Takes the path and makes it presentable.

The rules are:
If the LFN name is simply the short name (all caps),
then convert to lowercase with first letter capitalized

Returns: --
Cond:    --
 */
void PUBLIC PathMakePresentable(
        LPTSTR pszPath)
{
    LPTSTR pszComp;          // pointers to begining and
    LPTSTR pszEnd;           //  end of path component
    LPTSTR pch;
    int cComponent = 0;
    BOOL bUNCPath;
    TCHAR ch;

    bUNCPath = PathIsUNC(pszPath);

    pszComp = pszPath;
    while (pszEnd = PathFindNextComponentI(pszComp))
    {
        // pszEnd may be pointing to the right of the backslash
        //  beyond the path component, so back up one
        //
        ch = *pszEnd;
        *pszEnd = 0;        // temporary null

        // pszComp points to the path component
        //
        pch = CharNext(pszComp);
        if (TEXT(':') == *pch)
        {
            // Simply capitalize the drive-portion of the path
            //
            CharUpper(pszComp);
        }
        else if (bUNCPath && cComponent++ < 3)
        {
            // Network server or share name
            //      FEATURE: handle LFN network names
            //
            CharUpper(pszComp);
            PathMakeComponentPretty(pszComp);
        }
        else
        {
            // Normal path component
            //
            PathMakeComponentPretty(pszComp);
        }

        *pszEnd = ch;
        pszComp = pszEnd;
    }
}


#ifdef NOTUSED
/*----------------------------------------------------------
Purpose: Takes the path and pretties up each component of
the path.

The rules are:
Use the LFN name of the component
If the LFN name is simply the short name (all caps),
then convert to lowercase with first letter capitalized

Returns: --
Cond:    --
 */
void PRIVATE PathGetCompleteLFN(
        LPCTSTR pszPath,
        LPTSTR pszLong,
        int cbLong)
{
    TCHAR sz[MAX_PATH];
    TCHAR szPath[MAX_PATH+1];
    LPTSTR pszComp;         // pointers to begining and end of path component
    LPTSTR pszEnd;
    int cbPath;
    int cb;
    BOOL bAtEnd = FALSE;
    int cComponent = 0;
    BOOL bUNCPath;
    TCHAR ch;

    // REARCHITECT: this is broken for double-byte characters for sure

    // For each component in string, get the LFN and add it to
    //  the pszLong buffer.
    //

    cbPath = lstrlen(pszPath) * sizeof(TCHAR);
    ASSERT(cbPath+1 <= sizeof(szPath));
    lstrcpyn(szPath, pszPath, ARRAYSIZE(szPath));

    bUNCPath = PathIsUNC(szPath);

    *pszLong = NULL_CHAR;
    cb = 0;

    pszComp = szPath;
    while (pszEnd = PathFindNextComponentI(pszComp))
    {
        // pszEnd may be pointing to the right of the backslash beyond the
        //  path component, so back up one
        //
        if (0 == *pszEnd)
            bAtEnd = TRUE;
        else
        {
            if (!bUNCPath || cComponent > 0)
                pszEnd--;       // not the server or share portions of a UNC path
            ch = *pszEnd;
            *pszEnd = 0;        // temporary null
        }

        // pszComp points to the path component now
        //
        if (TEXT(':') == *(pszEnd-1) || TEXT(':') == *(pszEnd-2))
        {
            // Simply capitalize the drive-portion of the path
            //
            CharUpper(szPath);
        }
        else if (bUNCPath && cComponent++ < 3)
        {
            // Network server or share name
            //      FEATURE: handle LFN network names
            //
            CharUpper(pszComp);
            PathMakeComponentPretty(pszComp);
        }
        else
        {
            int ib;

            // Try to get the LFN
            //
            *sz = NULL_CHAR;
            PathGetLongName(szPath, sz, ARRAYSIZE(sz));

            // If an LFN does not exist, keep the path component
            //  as it is. (Sometimes the path component can be
            //  something like "Link to Foo.txt")
            //
            if (*sz)
            {
                // Make pszComp point to the same offset in sz now
                //  (the components in each are the same offsets)
                //
                ib = pszComp - (LPTSTR)szPath;
                pszComp = &sz[ib];
            }
            PathMakeComponentPretty(pszComp);
        }

        // Save new LFN-ized component to buffer
        //
        cb += lstrlen(pszComp) * sizeof(TCHAR);
        if (cbLong <= cb)
            break;      // reached end of pszLong buffer
        StrCatBuff(pszLong, pszComp, cbLong/sizeof(TCHAR));
        if (!bAtEnd)
        {
            PathAddBackslash(pszLong);
            *pszEnd = ch;
            if (bUNCPath && 1 == cComponent)
                pszComp = pszEnd;   // pointing to share portion of path
            else
                pszComp = pszEnd+1; // Move component pointer to next part
        }
        else
            pszComp = pszEnd;
    }
}
#endif


/*----------------------------------------------------------
Purpose: Returns TRUE if the combined path of pszFolder and
pszName is greater than MAX_PATH.

Returns: see above
Cond:    --
 */
BOOL PUBLIC PathsTooLong(
        LPCTSTR pszFolder,
        LPCTSTR pszName)
{
    // +1 for possible '\' between the two path components
    return lstrlen(pszFolder) + lstrlen(pszName) + 1 >= MAX_PATH;
}


/*----------------------------------------------------------
Purpose: Fully qualifies a path
Returns: --
Cond:    --
 */
void PUBLIC BrfPathCanonicalize(
        LPCTSTR pszPath,
        LPTSTR pszBuf,
        int cchMax)           // Must be MAX_PATH
{
    DWORD dwcPathLen;

    dwcPathLen = GetFullPathName(pszPath, MAX_PATH, pszBuf, NULL);

    if (! dwcPathLen || dwcPathLen >= MAX_PATH)
        lstrcpyn(pszBuf, pszPath, cchMax);

    // If pszBuf won't cover losslessly to ANSI, use the short name instead

#if defined(UNICODE) 
    {
        CHAR szAnsi[MAX_PATH];
        WCHAR szUnicode[MAX_PATH];
        szUnicode[0] = L'\0';

        WideCharToMultiByte(CP_ACP, 0, pszBuf, -1, szAnsi, ARRAYSIZE(szAnsi), NULL, NULL);
        MultiByteToWideChar(CP_ACP, 0, szAnsi,   -1, szUnicode, ARRAYSIZE(szUnicode));
        if (lstrcmp(szUnicode, pszBuf))
        {
            // Cannot convert losslessly from Unicode -> Ansi, so get the short path

            lstrcpyn(szUnicode, pszBuf, ARRAYSIZE(szUnicode));
            SheShortenPath(szUnicode, TRUE);
            lstrcpyn(pszBuf, szUnicode, cchMax);
        }
    }
#endif

    PathMakePresentable(pszBuf);

    ASSERT(lstrlen(pszBuf) < MAX_PATH);
}


/*----------------------------------------------------------
Purpose: Gets the displayable filename of the path.  The filename 
is placed in the provided buffer.  

Returns: pointer to buffer
Cond:    --
 */
LPTSTR PUBLIC PathGetDisplayName(
        LPCTSTR pszPath,
        LPTSTR pszBuf, int cchMax)
{
    SHFILEINFO sfi;

    if (SHGetFileInfo(pszPath, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME))
        lstrcpyn(pszBuf, sfi.szDisplayName, cchMax);
    else
        lstrcpyn(pszBuf, PathFindFileName(pszPath), cchMax);

    return pszBuf;
}


/*----------------------------------------------------------
Purpose: Checks if the attributes of the path.  If it is a
directory and has the system bit set, and if the brfcase.dat
file exists in the directory, then return TRUE.

Worst case: performs two GetFileAttributes.

Returns: see above
Cond:    --
 */
BOOL PUBLIC PathCheckForBriefcase(
        LPCTSTR pszPath,
        DWORD dwAttrib)     // if -1, then function gets the attributes
{
    ASSERT(pszPath);

    if (0xFFFFFFFF == dwAttrib)
    {
        dwAttrib = GetFileAttributes(pszPath);
        if (0xFFFFFFFF == dwAttrib)
            return FALSE;
    }

    if (IsFlagSet(dwAttrib, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY) ||
            IsFlagSet(dwAttrib, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_SYSTEM))
    {
        TCHAR szT[MAX_PATH];
        LPCTSTR pszDBName;

        // Check for the existence of the brfcase.dat file.
        //
        if (IsLFNDrive(pszPath))
            pszDBName = g_szDBName;
        else
            pszDBName = g_szDBNameShort;

        if (PathsTooLong(pszPath, pszDBName))
            return FALSE;
        else
        {
            PathCombine(szT, pszPath, pszDBName);
            return PathExists(szT);
        }
    }

    return FALSE;
}


/*----------------------------------------------------------
Purpose: Returns TRUE if the path is to a briefcase root.

This function may hit the file-system to achieve
its goal.

Worst case: performs two GetFileAttributes.

Returns: TRUE if the path refers to a briefcase root.
Cond:    --
 */
BOOL PUBLIC PathIsBriefcase(
        LPCTSTR pszPath)
{
    UINT uRet;

    ASSERT(pszPath);

    // We perform our search by first looking in our cache
    // of known briefcase paths (CPATH).  If we don't find
    // anything, then we proceed to iterate thru each
    // component of the path, checking for these two things:
    //
    //   1) A directory with the system attribute
    //   2) The existence of a brfcase.dat file in the directory.
    //
    uRet = CPATH_GetLocality(pszPath, NULL, 0);
    if (PL_FALSE == uRet)
    {
        uRet = PathCheckForBriefcase(pszPath, (DWORD)-1) ? PL_ROOT : PL_FALSE;

        if (PL_ROOT == uRet)
        {
            int atom;

            // Add this path to the briefcase path cache.
            //
            atom = Atom_Add(pszPath);
            if (ATOM_ERR != atom)
                CPATH_Replace(atom);
        }
    }

    return PL_ROOT == uRet;
}


/*----------------------------------------------------------
Purpose: Gets the locality of the path, relative to any
briefcase.  If PL_ROOT or PL_INSIDE is returned,
pszBuf will contain the path to the root of the
briefcase.

This function may hit the file-system to achieve
its goal.

Worst case: performs 2*n GetFileAttributes, where
n is the number of components in pszPath.

Returns: Path locality (PL_FALSE, PL_ROOT, PL_INSIDE)

Cond:    --
 */
UINT PUBLIC PathGetLocality(
        LPCTSTR pszPath,
        LPTSTR pszBuf,        // Buffer for root path
        int cchMax)
{
    UINT uRet;

    ASSERT(pszPath);
    ASSERT(pszBuf);

    *pszBuf = NULL_CHAR;

    // pszPath may be:
    //  1) a path to the briefcase folder itself
    //  2) a path to a file or folder beneath the briefcase
    //  3) a path to something unrelated to a briefcase

    // We perform our search by first looking in our cache
    // of known briefcase paths (CPATH).  If we don't find
    // anything, then we proceed to iterate thru each
    // component of the path, checking for these two things:
    //
    //   1) A directory with the system attribute
    //   2) The existence of a brfcase.dat file in the directory.
    //
    uRet = CPATH_GetLocality(pszPath, pszBuf, cchMax);
    if (PL_FALSE == uRet)
    {
        int cnt = 0;

        lstrcpyn(pszBuf, pszPath, cchMax);
        do
        {
            if (PathCheckForBriefcase(pszBuf, (DWORD)-1))
            {
                int atom;

                uRet = cnt > 0 ? PL_INSIDE : PL_ROOT;

                // Add this briefcase path to our cache
                //
                atom = Atom_Add(pszBuf);
                if (ATOM_ERR != atom)
                    CPATH_Replace(atom);

                break;      // Done
            }

            cnt++;

        } while (PathRemoveFileSpec(pszBuf));

        if (PL_FALSE == uRet)
            *pszBuf = NULL_CHAR;
    }

    return uRet;
}


/*----------------------------------------------------------
Purpose: Returns TRUE if the file/directory exists.

Returns: see above
Cond:    --
 */
BOOL PUBLIC PathExists(
        LPCTSTR pszPath)
{
    return GetFileAttributes(pszPath) != 0xFFFFFFFF;
}


/*----------------------------------------------------------
Purpose: Finds the end of the root specification in a path.

input path                    output string
----------                    -------------
c:                            <empty string>
c:\                           <empty string>
c:\foo                        foo
c:\foo\bar                    foo\bar
\\pyrex\user                  <empty string>
\\pyrex\user\                 <empty string>
\\pyrex\user\foo              foo
\\pyrex\user\foo\bar          foo\bar

Returns: pointer to first character after end of root spec.

Cond:    --
 */
LPCTSTR PUBLIC PathFindEndOfRoot(
        LPCTSTR pszPath)
{
    LPCTSTR psz;

    ASSERT(pszPath);

    if (TEXT(':') == pszPath[1])
    {
        if (TEXT('\\') == pszPath[2])
            psz = &pszPath[3];
        else
            psz = &pszPath[2];
    }
    else if (PathIsUNC(pszPath))
    {
        psz = PathFindNextComponentI(pszPath);  // hop double-slash
        psz = PathFindNextComponentI(psz);      // hop server name
        if (psz)
            psz = PathFindNextComponentI(psz);  // hop share name

        if (!psz)
        {
            ASSERT(0);      // There is no share name
            psz = pszPath;
        }
    }
    else
    {
        ASSERT(0);
        psz = pszPath;
    }

    return psz;
}


/*----------------------------------------------------------
Purpose: Sends a notify message to the shell regarding a file-status
change.
Returns: --
Cond:    --
 */
void PUBLIC PathNotifyShell(
        LPCTSTR pszPath,
        NOTIFYSHELLEVENT nse,
        BOOL bDoNow)        // TRUE: force the event to be processed right away
{

    static LONG const rgShEvents[] = 
    { SHCNE_CREATE, SHCNE_MKDIR, SHCNE_UPDATEITEM, SHCNE_UPDATEDIR };

    ASSERT(pszPath);
    ASSERT(nse < ARRAYSIZE(rgShEvents));

    SHChangeNotify(rgShEvents[nse], SHCNF_PATH, pszPath, NULL);

    if (bDoNow)
    {
        SHChangeNotify(0, SHCNF_FLUSHNOWAIT, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\mem.h ===
#ifndef _INC_MEM
#define _INC_MEM

#ifdef WIN32
//
// These macros are used in our controls, that in 32 bits we simply call
// LocalAlloc as to have the memory associated with the process that created
// it and as such will be cleaned up if the process goes away.
//
#ifdef DEBUG

LPVOID  PUBLIC MemAlloc(HANDLE hheap, DWORD cb);
LPVOID  PUBLIC MemReAlloc(HANDLE hheap, LPVOID pb, DWORD cb);
BOOL    PUBLIC MemFree(HANDLE hheap, LPVOID pb);
DWORD   PUBLIC MemSize(HANDLE hheap, LPVOID pb);

#else // DEBUG

#define MemAlloc(hheap, cb)       HeapAlloc((hheap), HEAP_ZERO_MEMORY, (cb))
#define MemReAlloc(hheap, pb, cb) HeapReAlloc((hheap), HEAP_ZERO_MEMORY, (pb),(cb))
#define MemFree(hheap, pb)        HeapFree((hheap), 0, (pb))
#define MemSize(hheap, pb)        HeapSize((hheap), 0, (LPCVOID)(pb))

#endif // DEBUG

#else // WIN32

// In 16 bit code we need the Allocs to go from our heap code as we do not
// want to limit them to 64K of data.  If we have some type of notification of
// 16 bit application termination, We may want to see if we can
// dedicate different heaps for different processes to cleanup...

#define MemAlloc(hheap, cb)       Alloc(cb)  /* calls to verify heap exists */
#define MemReAlloc(hheap, pb, cb) ReAlloc(pb, cb)
#define MemFree(hheap, pb)        Free(pb)
#define MemSize(hheap, pb)        GetSize((LPCVOID)pb)

#endif // WIN32


void PUBLIC Mem_Terminate();

extern HANDLE g_hSharedHeap;

// Shared memory allocation functions.
//
//      void _huge* SharedAlloc(long cb);
//          Alloc a chunk of memory, quickly, with no 64k limit on size of
//          individual objects or total object size.  Initialize to zero.
//
void _huge* PUBLIC SharedAlloc(long cb);                              

//      void _huge* SharedReAlloc(void _huge* pb, long cb);
//          Realloc one of above.  If pb is NULL, then this function will do
//          an alloc for you.  Initializes new portion to zero.
//
void _huge* PUBLIC SharedReAlloc(void _huge* pb, long cb);             

//      BOOL SharedFree(void _huge* FAR * ppb);
//          Free a chunk of memory alloced or realloced with above routines.
//          Sets *ppb to zero.
//
BOOL    PUBLIC SharedFree(void _huge*  * ppb);

//      DWORD SharedGetSize(void _huge* pb);
//          Get the size of a block allocated by Alloc()
//      
DWORD   PUBLIC SharedGetSize(void _huge* pb);                      


//      type _huge * SharedAllocType(type);                    (macro)
//          Alloc some memory the size of <type> and return pointer to <type>.
//
#define SharedAllocType(type)           (type _huge *)SharedAlloc(sizeof(type))

//      type _huge * SharedAllocArray(type, int cNum);         (macro)
//          Alloc an array of data the size of <type>.
//
#define SharedAllocArray(type, cNum)    (type _huge *)SharedAlloc(sizeof(type) * (cNum))

//      type _huge * SharedReAllocArray(type, void _huge * pb, int cNum);
//
#define SharedReAllocArray(type, pb, cNum) (type _huge *)SharedReAlloc(pb, sizeof(type) * (cNum))

#endif  // !_INC_MEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\recact.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: recact.c
//
//  This file contains the reconciliation-action control class code
//
//
// History:
//  08-12-93 ScottH     Created.
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers
#include <help.h>

#include "res.h"
#include "recact.h"
#include "dobj.h"

/////////////////////////////////////////////////////  CONTROLLING DEFINES


/////////////////////////////////////////////////////  DEFINES

// Manifest constants
#define SIDE_INSIDE     0
#define SIDE_OUTSIDE    1

// These should be changed if the bitmap sizes change!!
#define CX_ACTIONBMP    26
#define CY_ACTIONBMP    26

#define RECOMPUTE       (-1)

#define X_INCOLUMN      (g_cxIcon*2)

// Image indexes
#define II_RIGHT        0
#define II_LEFT         1
#define II_CONFLICT     2
#define II_SKIP         3
#define II_MERGE        4
#define II_SOMETHING    5
#define II_UPTODATE     6
#define II_DELETE       7

// Menu items
//
#define IDM_ACTIONFIRST     100
#define IDM_TOOUT           100
#define IDM_TOIN            101
#define IDM_SKIP            102
#define IDM_MERGE           103
#define IDM_DELETEOUT       104
#define IDM_DELETEIN        105
#define IDM_DONTDELETE      106
#define IDM_ACTIONLAST      106

#define IDM_WHATSTHIS       107


/////////////////////////////////////////////////////  TYPEDEFS

typedef struct tagRECACT
{
    HWND        hwnd;

    HWND        hwndLB;
    HWND        hwndTip;
    HDC         hdcOwn;             // Own DC
    HMENU       hmenu;              // Action and help context menu
    HFONT       hfont;
    WNDPROC     lpfnLBProc;         // Default LB proc
    HIMAGELIST  himlAction;         // imagelist for actions
    HIMAGELIST  himlCache;          // control imagelist cache
    HBITMAP     hbmpBullet;
    HDSA        hdsa;

    HBRUSH      hbrBkgnd;
    COLORREF    clrBkgnd;

    LONG        lStyle;             // Window style flags
    UINT        cTipID;             // Tip IDs are handed out 2 per item

    // Metrics
    int         cxItem;             // Generic width of an item
    int         cxMenuCheck;
    int         cyMenuCheck;
    int         cyText;
    int         cxEllipses;

} RECACT,  * LPRECACT;

#define RecAct_IsNoIcon(this)   IsFlagSet((this)->lStyle, RAS_SINGLEITEM)

// Internal item data struct
//
typedef struct tagRA_PRIV
{
    UINT uStyle;        // One of RAIS_
    UINT uAction;       // One of RAIA_

    FileInfo * pfi;

    SIDEITEM siInside;
    SIDEITEM siOutside;

    LPARAM  lParam;

    DOBJ    rgdobj[4];      // Array of Draw object info
    int     cx;             // Bounding width and height
    int     cy;

} RA_PRIV,  * LPRA_PRIV;

#define IDOBJ_FILE      0
#define IDOBJ_ACTION    1
#define IDOBJ_INSIDE    2
#define IDOBJ_OUTSIDE   3

// RecAction menu item definition structure.  Used to define the
//  context menu brought up in this control.
//
typedef struct tagRAMID
{
    UINT    idm;               // Menu ID (for MENUITEMINFO struct)
    UINT    uAction;           // One of RAIA_* flags
    UINT    ids;               // Resource string ID
    int     iImage;            // Index into himlAction
    RECT    rcExtent;          // Extent rect of string
} RAMID,  * LPRAMID;   // RecAction Menu Item Definition

// Help menu item definition structure.  Used to define the help
//  items in the context menu.
//
typedef struct tagHMID
{
    UINT idm;
    UINT ids;
} HMID;

/////////////////////////////////////////////////////  MACROS

#define RecAct_DefProc      DefWindowProc
#define RecActLB_DefProc    CallWindowProc


// Instance data pointer macros
//
#define RecAct_GetPtr(hwnd)     (LPRECACT)GetWindowLongPtr(hwnd, 0)
#define RecAct_SetPtr(hwnd, lp) (LPRECACT)SetWindowLongPtr(hwnd, 0, (LRESULT)(lp))

#define RecAct_GetCount(this)   ListBox_GetCount((this)->hwndLB)

LPCTSTR PRIVATE SkipDisplayJunkHack(LPSIDEITEM psi);

/////////////////////////////////////////////////////  MODULE DATA

#ifdef SAVE_FOR_RESIZE
static TCHAR const c_szDateDummy[] = TEXT("99/99/99 99:99PM");
#endif

// Map RAIA_* values to image indexes
//
static UINT const c_mpraiaiImage[] =
{ II_RIGHT,
    II_LEFT,
    II_SKIP,
    II_CONFLICT,
    II_MERGE,
    II_SOMETHING,
    II_UPTODATE,
    0,
#ifdef NEW_REC
    II_DELETE,
    II_DELETE,
    II_SKIP
#endif
};

// Map RAIA_* values to menu command positions
//
static UINT const c_mpraiaidmMenu[] =
{ IDM_TOOUT,
    IDM_TOIN,
    IDM_SKIP,
    IDM_SKIP,
    IDM_MERGE,
    0, 0, 0,
#ifdef NEW_REC
    IDM_DELETEOUT,
    IDM_DELETEIN,
    IDM_DONTDELETE
#endif
};

// Define the context menu layout
//
static RAMID const c_rgramid[] = {
    { IDM_TOOUT,    RAIA_TOOUT, IDS_MENU_REPLACE,   II_RIGHT,   0 },
    { IDM_TOIN,     RAIA_TOIN,  IDS_MENU_REPLACE,   II_LEFT,    0 },
    { IDM_SKIP,     RAIA_SKIP,  IDS_MENU_SKIP,      II_SKIP,    0 },
    // Merge must be the last item!
    { IDM_MERGE,    RAIA_MERGE, IDS_MENU_MERGE,     II_MERGE,   0 },
};

static RAMID const c_rgramidCreates[] = {
    { IDM_TOOUT,    RAIA_TOOUT, IDS_MENU_CREATE,    II_RIGHT,   0 },
    { IDM_TOIN,     RAIA_TOIN,  IDS_MENU_CREATE,    II_LEFT,    0 },
};

#ifdef NEW_REC
static RAMID const c_rgramidDeletes[] = {
    { IDM_DELETEOUT,   RAIA_DELETEOUT, IDS_MENU_DELETE,    II_DELETE,  0 },
    { IDM_DELETEIN,    RAIA_DELETEIN,  IDS_MENU_DELETE,    II_DELETE,  0 },
    { IDM_DONTDELETE,  RAIA_DONTDELETE,IDS_MENU_DONTDELETE,II_SKIP,    0 },
};
#endif

// Indexes into c_rgramidCreates
//
#define IRAMID_CREATEOUT    0
#define IRAMID_CREATEIN     1

// Indexes into c_rgramidDeletes
//
#define IRAMID_DELETEOUT    0
#define IRAMID_DELETEIN     1
#define IRAMID_DONTDELETE   2

static HMID const c_rghmid[] = {
    { IDM_WHATSTHIS, IDS_MENU_WHATSTHIS },
};

/////////////////////////////////////////////////////  LOCAL PROCEDURES

LRESULT _export CALLBACK RecActLB_LBProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);

/////////////////////////////////////////////////////  PRIVATE FUNCTIONS



#ifdef DEBUG
LPCTSTR PRIVATE DumpRecAction(
        UINT uAction)        // RAIA_
{
    switch (uAction)
    {
        DEBUG_CASE_STRING( RAIA_TOOUT );
        DEBUG_CASE_STRING( RAIA_TOIN );
        DEBUG_CASE_STRING( RAIA_SKIP );
        DEBUG_CASE_STRING( RAIA_CONFLICT );
        DEBUG_CASE_STRING( RAIA_MERGE );
        DEBUG_CASE_STRING( RAIA_SOMETHING );
        DEBUG_CASE_STRING( RAIA_NOTHING );
        DEBUG_CASE_STRING( RAIA_ORPHAN );
        DEBUG_CASE_STRING( RAIA_DELETEOUT );
        DEBUG_CASE_STRING( RAIA_DELETEIN );
        DEBUG_CASE_STRING( RAIA_DONTDELETE );

        default:        return TEXT("Unknown");
    }
}


LPCTSTR PRIVATE DumpSideItemState(
        UINT uState)        // SI_
{
    switch (uState)
    {
        DEBUG_CASE_STRING( SI_UNCHANGED );
        DEBUG_CASE_STRING( SI_CHANGED );
        DEBUG_CASE_STRING( SI_NEW );
        DEBUG_CASE_STRING( SI_NOEXIST );
        DEBUG_CASE_STRING( SI_UNAVAILABLE );
        DEBUG_CASE_STRING( SI_DELETED );

        default:        return TEXT("Unknown");
    }
}


/*----------------------------------------------------------
Purpose: Dumps a twin pair
Returns: --
Cond:    --
 */
void PUBLIC DumpTwinPair(
        LPRA_ITEM pitem)
{
    if (pitem)
    {
        TCHAR szBuf[MAXMSGLEN];

#define szDump   TEXT("Dump TWINPAIR: ")
#define szBlank  TEXT("               ")

        if (IsFlagClear(g_uDumpFlags, DF_TWINPAIR))
        {
            return;
        }

        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.pszName = %s\r\n"), (LPTSTR)szDump, Dbg_SafeStr(pitem->pszName));
        OutputDebugString(szBuf);
        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.uStyle = %lx\r\n"), (LPTSTR)szBlank, pitem->uStyle);
        OutputDebugString(szBuf);
        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.uAction = %s\r\n"), (LPTSTR)szBlank, DumpRecAction(pitem->uAction));
        OutputDebugString(szBuf);

#undef szDump
#define szDump   TEXT("       Inside: ")
        wnsprintf(szBuf, TEXT("%s.pszDir = %s\r\n"), (LPTSTR)szDump, Dbg_SafeStr(pitem->siInside.pszDir));
        OutputDebugString(szBuf);
        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.uState = %s\r\n"), (LPTSTR)szBlank, DumpSideItemState(pitem->siInside.uState));
        OutputDebugString(szBuf);

#undef szDump
#define szDump   TEXT("      Outside: ")
        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.pszDir = %s\r\n"), (LPTSTR)szDump, Dbg_SafeStr(pitem->siOutside.pszDir));
        OutputDebugString(szBuf);
        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.uState = %s\r\n"), (LPTSTR)szBlank, DumpSideItemState(pitem->siOutside.uState));
        OutputDebugString(szBuf);

#undef szDump
#undef szBlank
    }
}


#endif


/*----------------------------------------------------------
Purpose: Create a monochrome bitmap of the bullet, so we can
play with the colors later.
Returns: handle to bitmap
Cond:    Caller must delete bitmap
 */
HBITMAP PRIVATE CreateBulletBitmap(
        LPSIZE psize)
{
    HDC hdcMem;
    HBITMAP hbmp = NULL;

    hdcMem = CreateCompatibleDC(NULL);
    if (hdcMem)
    {
        hbmp = CreateCompatibleBitmap(hdcMem, psize->cx, psize->cy);
        if (hbmp)
        {
            HBITMAP hbmpOld;
            RECT rc;

            // hbmp is monochrome

            hbmpOld = SelectBitmap(hdcMem, hbmp);
            rc.left = 0;
            rc.top = 0;
            rc.right = psize->cx;
            rc.bottom = psize->cy;
            DrawFrameControl(hdcMem, &rc, DFC_MENU, DFCS_MENUBULLET);

            SelectBitmap(hdcMem, hbmpOld);
        }
        DeleteDC(hdcMem);
    }
    return hbmp;
}


/*----------------------------------------------------------
Purpose: Returns the top and bottom indexes of the visible
entries in the listbox

Returns: --
Cond:    --
 */
void PRIVATE GetVisibleRange(
        HWND hwndLB,
        int * piTop,
        int * piBottom)
{
    int i;
    int cel;
    int cyMac;
    RECT rc;

    *piTop = ListBox_GetTopIndex(hwndLB);

    cel = ListBox_GetCount(hwndLB);
    GetClientRect(hwndLB, &rc);
    cyMac = 0;

    for (i = *piTop; i < cel; i++)
    {
        if (cyMac > rc.bottom)
            break;

        cyMac += ListBox_GetItemHeight(hwndLB, i);
    }

    *piBottom = i-1;;
}


/*----------------------------------------------------------
Purpose: Returns the top and bottom indexes of the visible
entries in the listbox

Returns: --
Cond:    --
 */
int PRIVATE GetHitIndex(
        HWND hwndLB,
        POINT pt)
{
    int i;
    int iTop;
    int cel;
    int cyMac;
    int cy;
    RECT rc;

    iTop = ListBox_GetTopIndex(hwndLB);

    cel = ListBox_GetCount(hwndLB);
    GetClientRect(hwndLB, &rc);
    cyMac = 0;

    for (i = iTop; i < cel; i++)
    {
        cy = ListBox_GetItemHeight(hwndLB, i);

        if (InRange(pt.y, cyMac, cyMac + cy))
            break;

        cyMac += cy;
    }

    if (i == cel)
        return LB_ERR;

    return i;
}


/*----------------------------------------------------------
Purpose: Returns the resource ID string given the action
flag.
Returns: IDS_ value
Cond:    --
 */
UINT PRIVATE GetActionText(
        LPRA_PRIV ppriv)
{
    UINT ids;

    ASSERT(ppriv);

    switch (ppriv->uAction)
    {
        case RAIA_TOOUT:
            if (SI_NEW == ppriv->siInside.uState ||
                    SI_DELETED == ppriv->siOutside.uState)
            {
                ids = IDS_STATE_Creates;
            }
            else
            {
                ids = IDS_STATE_Replaces;
            }
            break;

        case RAIA_TOIN:
            if (SI_NEW == ppriv->siOutside.uState ||
                    SI_DELETED == ppriv->siInside.uState)
            {
                ids = IDS_STATE_Creates;
            }
            else
            {
                ids = IDS_STATE_Replaces;
            }
            break;

#ifdef NEW_REC
        case RAIA_DONTDELETE:
            ASSERT(SI_DELETED == ppriv->siInside.uState ||
                    SI_DELETED == ppriv->siOutside.uState);

            ids = IDS_STATE_DontDelete;
            break;
#endif

        case RAIA_SKIP:
            // Can occur if the user explicitly wants to skip, or if
            // one side is unavailable.
            ids = IDS_STATE_Skip;
            break;

        case RAIA_CONFLICT:     ids = IDS_STATE_Conflict;       break;
        case RAIA_MERGE:        ids = IDS_STATE_Merge;          break;
        case RAIA_NOTHING:      ids = IDS_STATE_Uptodate;       break;
        case RAIA_SOMETHING:    ids = IDS_STATE_NeedToUpdate;   break;

#ifdef NEW_REC
        case RAIA_DELETEOUT:    ids = IDS_STATE_Delete;         break;
        case RAIA_DELETEIN:     ids = IDS_STATE_Delete;         break;
#endif

        default:                ids = 0;                        break;
    }

    return ids;
}


/*----------------------------------------------------------
Purpose: Repaint an item in the listbox
Returns: --
Cond:    --
 */
void PRIVATE ListBox_RepaintItemNow(
        HWND hwnd,
        int iItem,
        LPRECT prc,         // Relative to individual entry rect.  May be NULL
        BOOL bEraseBk)
{
    RECT rc;
    RECT rcItem;

    ListBox_GetItemRect(hwnd, iItem, &rcItem);
    if (prc)
    {
        OffsetRect(prc, rcItem.left, rcItem.top);
        IntersectRect(&rc, &rcItem, prc);
    }
    else
        rc = rcItem;

    InvalidateRect(hwnd, &rc, bEraseBk);
    UpdateWindow(hwnd);
}


/*----------------------------------------------------------
Purpose: Determine which DOBJ of the item is going to get the caret.

Returns: pointer to DOBJ
Cond:    --
 */
LPDOBJ PRIVATE RecAct_ChooseCaretDobj(
        LPRECACT this,
        LPRA_PRIV ppriv)
{
    // Focus rect on file icon?
    if (!RecAct_IsNoIcon(this))
        return ppriv->rgdobj;                   // Yes
    else
        return &ppriv->rgdobj[IDOBJ_ACTION];    // No
}


/*----------------------------------------------------------
Purpose: Returns the tool tip ID for the visible rectangle
that the given item is currently occupying.

Returns: see above
Cond:    --
 */
UINT PRIVATE RecAct_GetTipIDFromItemID(
        LPRECACT this,
        int itemID)
{
    int iTop;
    int iBottom;
    int idsa;
    UINT uID;

    GetVisibleRange(this->hwndLB, &iTop, &iBottom);
    ASSERT(iTop <= itemID);
    ASSERT(itemID <= iBottom);

    idsa = itemID - iTop;
    if ( !DSA_GetItem(this->hdsa, idsa, &uID) )
    {
        // This region has not been added yet
        uID = this->cTipID;

        if (-1 != DSA_SetItem(this->hdsa, idsa, &uID))
        {
            TOOLINFO ti;

            ti.cbSize = sizeof(ti);
            ti.uFlags = 0;
            ti.hwnd = this->hwndLB;
            ti.uId = uID;
            ti.lpszText = LPSTR_TEXTCALLBACK;
            ti.rect.left = ti.rect.top = ti.rect.bottom = ti.rect.right = 0;
            SendMessage(this->hwndTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

            ti.uId++;
            SendMessage(this->hwndTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

            this->cTipID += 2;
        }
    }

    return uID;
}


/*----------------------------------------------------------
Purpose: Finds a listbox item given the tip ID.

Returns: item index
Cond:    --
 */
int PRIVATE RecAct_FindItemFromTipID(
        LPRECACT this,
        UINT uTipID,
        BOOL * pbInside)
{
    int iTop;
    int iBottom;
    int iVisibleItem = uTipID / 2;
    int iItem;

    ASSERT(0 <= iVisibleItem);

    GetVisibleRange(this->hwndLB, &iTop, &iBottom);
    if (iVisibleItem <= iBottom - iTop)
    {
        iItem = iTop + iVisibleItem;

        if (uTipID % 2)
            *pbInside = FALSE;
        else
            *pbInside = TRUE;
    }
    else
        iItem = LB_ERR;

    return iItem;
}


/*----------------------------------------------------------
Purpose: Send selection change notification
Returns:
Cond:    --
 */
BOOL PRIVATE RecAct_SendSelChange(
        LPRECACT this,
        int isel)
{
    NM_RECACT nm;

    nm.iItem = isel;
    nm.mask = 0;

    if (isel != -1)
    {
        LPRA_ITEM pitem;

        ListBox_GetText(this->hwndLB, isel, &pitem);
        if (!pitem)
            return FALSE;

        nm.lParam = pitem->lParam;
        nm.mask |= RAIF_LPARAM;
    }

    return !SendNotify(GetParent(this->hwnd), this->hwnd, RN_SELCHANGED, &nm.hdr);
}


/*----------------------------------------------------------
Purpose: Send an action change notification
Returns:
Cond:    --
 */
BOOL PRIVATE RecAct_SendItemChange(
        LPRECACT this,
        int iEntry,
        UINT uActionOld)
{
    NM_RECACT nm;

    nm.iItem = iEntry;
    nm.mask = 0;

    if (iEntry != -1)
    {
        LPRA_PRIV ppriv;

        ListBox_GetText(this->hwndLB, iEntry, &ppriv);
        if (!ppriv)
            return FALSE;

        nm.mask |= RAIF_LPARAM | RAIF_ACTION;
        nm.lParam = ppriv->lParam;
        nm.uAction = ppriv->uAction;
        nm.uActionOld = uActionOld;
    }

    return !SendNotify(GetParent(this->hwnd), this->hwnd, RN_ITEMCHANGED, &nm.hdr);
}


/*----------------------------------------------------------
Purpose: Create the action context menu
Returns: TRUE on success
Cond:    --
 */
BOOL PRIVATE RecAct_CreateMenu(
        LPRECACT this)
{
    HMENU hmenu;

    hmenu = CreatePopupMenu();
    if (hmenu)
    {
        TCHAR sz[MAXSHORTLEN];
        MENUITEMINFO mii;
        int i;

        // Add the help menu items now, since these will be standard
        //
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
        mii.fType = MFT_STRING;
        mii.fState = MFS_ENABLED;

        for (i = 0; i < ARRAYSIZE(c_rghmid); i++)
        {
            mii.wID = c_rghmid[i].idm;
            mii.dwTypeData = SzFromIDS(c_rghmid[i].ids, sz, ARRAYSIZE(sz));
            InsertMenuItem(hmenu, i, TRUE, &mii);
        }

        this->hmenu = hmenu;
    }

    return hmenu != NULL;
}


/*----------------------------------------------------------
Purpose: Add the action menu items to the context menu
Returns: --
Cond:    --
 */
void PRIVATE AddActionsToContextMenu(
        HMENU hmenu,
        UINT idmCheck,      // menu item to checkmark
        LPRA_PRIV ppriv)
{
    MENUITEMINFO mii;
    int i;
    int cItems = ARRAYSIZE(c_rgramid);

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID | MIIM_DATA;
    mii.fType = MFT_OWNERDRAW;
    mii.fState = MFS_ENABLED;

    // Is merge supported?
    if (IsFlagClear(ppriv->uStyle, RAIS_CANMERGE))
    {
        // No
        --cItems;
    }

    for (i = 0; i < cItems; i++)
    {
        mii.wID = c_rgramid[i].idm;
        mii.dwItemData = (DWORD_PTR)&c_rgramid[i];

        InsertMenuItem(hmenu, i, TRUE, &mii);
    }

    // Add the separator
    mii.fMask = MIIM_TYPE;
    mii.fType = MFT_SEPARATOR;
    InsertMenuItem(hmenu, i, TRUE, &mii);

    // Set the initial checkmark.
    CheckMenuRadioItem(hmenu, IDM_ACTIONFIRST, IDM_ACTIONLAST, idmCheck,
            MF_BYCOMMAND | MF_CHECKED);

    // Is the file or its sync copy unavailable?
    if (SI_UNAVAILABLE == ppriv->siInside.uState ||
            SI_UNAVAILABLE == ppriv->siOutside.uState)
    {
        // Yes
        mii.fMask = MIIM_STATE;
        mii.fState = MFS_GRAYED | MFS_DISABLED;
        SetMenuItemInfo(hmenu, IDM_TOIN, FALSE, &mii);
        SetMenuItemInfo(hmenu, IDM_TOOUT, FALSE, &mii);
        SetMenuItemInfo(hmenu, IDM_MERGE, FALSE, &mii);
    }

    // Is the file being created?
    else if (ppriv->siInside.uState == SI_NEW ||
            ppriv->siOutside.uState == SI_NEW)
    {
        // Yes; disable the replace-in-opposite direction
        UINT idmDisable;
        UINT idmChangeVerb;

        if (ppriv->siInside.uState == SI_NEW)
        {
            idmDisable = IDM_TOIN;
            idmChangeVerb = IDM_TOOUT;
            i = IRAMID_CREATEOUT;
        }
        else
        {
            idmDisable = IDM_TOOUT;
            idmChangeVerb = IDM_TOIN;
            i = IRAMID_CREATEIN;
        }

        // Disable one of the directions
        mii.fMask = MIIM_STATE;
        mii.fState = MFS_GRAYED | MFS_DISABLED;
        SetMenuItemInfo(hmenu, idmDisable, FALSE, &mii);

        // Change the verb of the other direction
        mii.fMask = MIIM_DATA;
        mii.dwItemData = (DWORD_PTR)&c_rgramidCreates[i];

        SetMenuItemInfo(hmenu, idmChangeVerb, FALSE, &mii);
    }

#ifdef NEW_REC
    // Is the file being deleted?
    else if (SI_DELETED == ppriv->siInside.uState ||
            SI_DELETED == ppriv->siOutside.uState)
    {
        // Yes;
        UINT idmCreate;
        UINT idmChangeVerb;
        UINT iCreate;

        if (SI_DELETED == ppriv->siInside.uState)
        {
            idmCreate = IDM_TOIN;
            iCreate = IRAMID_CREATEIN;

            idmChangeVerb = IDM_TOOUT;
            i = IRAMID_DELETEOUT;
        }
        else
        {
            ASSERT(SI_DELETED == ppriv->siOutside.uState);

            idmCreate = IDM_TOOUT;
            iCreate = IRAMID_CREATEOUT;

            idmChangeVerb = IDM_TOIN;
            i = IRAMID_DELETEIN;
        }

        // Change one of the directions to be create
        mii.fMask = MIIM_DATA;
        mii.dwItemData = (DWORD_PTR)&c_rgramidCreates[iCreate];
        SetMenuItemInfo(hmenu, idmCreate, FALSE, &mii);

        // Change the verb of the other direction
        mii.fMask = MIIM_DATA | MIIM_ID;
        mii.wID = c_rgramidDeletes[i].idm;
        mii.dwItemData = (DWORD_PTR)&c_rgramidDeletes[i];

        SetMenuItemInfo(hmenu, idmChangeVerb, FALSE, &mii);

        // Change the skip verb to be "Don't Delete"
        mii.fMask = MIIM_DATA | MIIM_ID;
        mii.wID = c_rgramidDeletes[IRAMID_DONTDELETE].idm;
        mii.dwItemData = (DWORD_PTR)&c_rgramidDeletes[IRAMID_DONTDELETE];

        SetMenuItemInfo(hmenu, IDM_SKIP, FALSE, &mii);
    }
#endif
}


/*----------------------------------------------------------
Purpose: Clear out the context menu
Returns: --
Cond:    --
 */
void PRIVATE ResetContextMenu(
        HMENU hmenu)
{
    int cnt;

    // If there is more than just the help items, remove them
    //  (but leave the help items)
    //
    cnt = GetMenuItemCount(hmenu);
    if (cnt > ARRAYSIZE(c_rghmid))
    {
        int i;

        cnt -= ARRAYSIZE(c_rghmid);
        for (i = 0; i < cnt; i++)
        {
            DeleteMenu(hmenu, 0, MF_BYPOSITION);
        }
    }
}


/*----------------------------------------------------------
Purpose: Do the context menu
Returns: --
Cond:    --
 */
void PRIVATE RecAct_DoContextMenu(
        LPRECACT this,
        int x,              // in screen coords
        int y,
        int iEntry,
        BOOL bHelpOnly)     // TRUE: only show the help items
{
    UINT idCmd;

    if (this->hmenu)
    {
        LPRA_PRIV ppriv;
        RECT rc;
        int idmCheck;
        UINT uActionOld;

        // Only show help-portion of context menu?
        if (bHelpOnly)
        {
            // Yes
            ppriv = NULL;
        }
        else
        {
            // No
            ListBox_GetText(this->hwndLB, iEntry, &ppriv);

            // Determine if this is a help-context menu only.
            //  It is if this is a folder-item or if there is no action
            //  to take.
            //
            ASSERT(ppriv->uAction < ARRAYSIZE(c_mpraiaidmMenu));
            idmCheck = c_mpraiaidmMenu[ppriv->uAction];

            // Build the context menu
            //
            if (IsFlagClear(ppriv->uStyle, RAIS_FOLDER) && idmCheck != 0)
            {
                AddActionsToContextMenu(this->hmenu, idmCheck, ppriv);
            }
        }

        // Show context menu
        //
        SendMessage(this->hwndTip, TTM_ACTIVATE, FALSE, 0L);

        idCmd = TrackPopupMenu(this->hmenu,
                TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                x, y, 0, this->hwnd, NULL);

        SendMessage(this->hwndTip, TTM_ACTIVATE, TRUE, 0L);

        // Clear menu
        //
        ResetContextMenu(this->hmenu);

        if (ppriv)
        {
            // Save the old action
            uActionOld = ppriv->uAction;
        }

        // Act on whatever the user chose
        switch (idCmd)
        {
            case IDM_TOOUT:
                ppriv->uAction = RAIA_TOOUT;
                break;

            case IDM_TOIN:
                ppriv->uAction = RAIA_TOIN;
                break;

            case IDM_SKIP:
                ppriv->uAction = RAIA_SKIP;
                break;

            case IDM_MERGE:
                ppriv->uAction = RAIA_MERGE;
                break;

#ifdef NEW_REC
            case IDM_DELETEOUT:
                ppriv->uAction = RAIA_DELETEOUT;
                break;

            case IDM_DELETEIN:
                ppriv->uAction = RAIA_DELETEIN;
                break;

            case IDM_DONTDELETE:
                ppriv->uAction = RAIA_DONTDELETE;
                break;
#endif

            case IDM_WHATSTHIS:
                WinHelp(this->hwnd, c_szWinHelpFile, HELP_CONTEXTPOPUP, IDH_BFC_UPDATE_SCREEN);
                return;         // Return now

            default:
                return;         // Return now
        }

        // Repaint action portion of entry
        ppriv->cx = RECOMPUTE;
        rc = ppriv->rgdobj[IDOBJ_ACTION].rcBounding;
        ListBox_RepaintItemNow(this->hwndLB, iEntry, &rc, TRUE);

        // Send a notify message
        ASSERT(NULL != ppriv);      // uActionOld should be valid
        RecAct_SendItemChange(this, iEntry, uActionOld);
    }
}


/*----------------------------------------------------------
Purpose: Create the windows for this control
Returns: TRUE on success
Cond:    --
 */
BOOL PRIVATE RecAct_CreateWindows(
        LPRECACT this,
        CREATESTRUCT  * lpcs)
{
    HWND hwnd = this->hwnd;
    HWND hwndLB;
    RECT rc;
    int cxEdge = GetSystemMetrics(SM_CXEDGE);
    int cyEdge = GetSystemMetrics(SM_CYEDGE);
    TOOLINFO ti;

    // Create listbox
    hwndLB = CreateWindowEx(
            0,
            TEXT("listbox"),
            TEXT(""),
            WS_CHILD | WS_CLIPSIBLINGS | LBS_SORT | LBS_OWNERDRAWVARIABLE |
            WS_VSCROLL | WS_TABSTOP | WS_VISIBLE | LBS_NOINTEGRALHEIGHT |
            LBS_NOTIFY,
            0, 0, lpcs->cx, lpcs->cy,
            hwnd,
            NULL,
            lpcs->hInstance,
            0L);
    if (!hwndLB)
        return FALSE;

    SetWindowFont(hwndLB, this->hfont, FALSE);

    this->hwndLB = hwndLB;

    // Determine layout of window
    GetClientRect(hwnd, &rc);
    InflateRect(&rc, -cxEdge, -cyEdge);
    SetWindowPos(hwndLB, NULL, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
            SWP_NOACTIVATE | SWP_SHOWWINDOW | SWP_NOZORDER);

    GetClientRect(hwndLB, &rc);
    this->cxItem = rc.right - rc.left;

    this->hwndTip = CreateWindow(
            TOOLTIPS_CLASS,
            c_szNULL,
            WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
            CW_USEDEFAULT, CW_USEDEFAULT,
            CW_USEDEFAULT, CW_USEDEFAULT,
            hwnd,
            NULL,
            lpcs->hInstance,
            0L);

    // Add a dummy tool so the delay is shorter between other tools
    ti.cbSize = sizeof(ti);
    ti.uFlags = TTF_IDISHWND;
    ti.hwnd = this->hwndLB;
    ti.uId = (UINT_PTR)this->hwndLB;
    ti.lpszText = (LPTSTR)c_szNULL;
    ti.rect.left = ti.rect.top = ti.rect.bottom = ti.rect.right = 0;
    SendMessage(this->hwndTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

    return TRUE;
}


/*----------------------------------------------------------
Purpose: Set the colors of the control
Returns: --
Cond:    --
 */
void PRIVATE RecAct_SetColors(
        LPRECACT this)
{
    int cr;

    if (IsFlagClear(this->lStyle, RAS_SINGLEITEM))
    {
        cr = COLOR_WINDOW;
    }
    else
    {
        cr = COLOR_3DFACE;
    }

    this->clrBkgnd = GetSysColor(cr);

    if (this->hbrBkgnd)
        DeleteBrush(this->hbrBkgnd);

    this->hbrBkgnd = CreateSolidBrush(this->clrBkgnd);
}


/*----------------------------------------------------------
Purpose: Creates an imagelist of the action images

Returns: TRUE on success

Cond:    --
 */
BOOL PRIVATE CreateImageList(
        HIMAGELIST * phiml,
        HDC hdc,
        UINT idb,
        int cxBmp,
        int cyBmp,
        int cImage,
        UINT flags
        )
{
    BOOL bRet;
    HIMAGELIST himl;

    himl = ImageList_Create(cxBmp, cyBmp, flags, cImage, 1);

    if (himl)
    {
        COLORREF clrMask;
        HBITMAP hbm;

        hbm = LoadBitmap(g_hinst, MAKEINTRESOURCE(idb));
        ASSERT(hbm);

        if (hbm)
        {
            HDC hdcMem = CreateCompatibleDC(hdc);
            if (hdcMem)
            {
                HBITMAP hbmSav = SelectBitmap(hdcMem, hbm);

                clrMask = GetPixel(hdcMem, 0, 0);
                SelectBitmap(hdcMem, hbmSav);

                bRet = (0 == ImageList_AddMasked(himl, hbm, clrMask));

                DeleteDC(hdcMem);
            }
            else
                bRet = FALSE;

            DeleteBitmap(hbm);
        }
        else
            bRet = FALSE;
    }
    else
        bRet = FALSE;

    *phiml = himl;
    return bRet;
}


/*----------------------------------------------------------
Purpose: WM_CREATE handler
Returns: TRUE on success
Cond:    --
 */
BOOL PRIVATE RecAct_OnCreate(
        LPRECACT this,
        CREATESTRUCT  * lpcs)
{
    BOOL bRet = FALSE;
    HWND hwnd = this->hwnd;
    HDC hdc;
    TEXTMETRIC tm;
    RECT rcT;
    LOGFONT lf;
    UINT flags = ILC_MASK;
    this->lStyle = GetWindowLong(hwnd, GWL_STYLE);
    RecAct_SetColors(this);

    // Determine some font things

    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
    this->hfont = CreateFontIndirect(&lf);

    // This window is registered with the CS_OWNDC flag
    this->hdcOwn = GetDC(hwnd);
    ASSERT(this->hdcOwn);

    hdc = this->hdcOwn;

    SelectFont(hdc, this->hfont);
    GetTextMetrics(hdc, &tm);
    this->cyText = tm.tmHeight;

    // Calculate text extent for sideitems (use the listbox font)
    //
    SetRectFromExtent(hdc, &rcT, c_szEllipses);
    this->cxEllipses = rcT.right - rcT.left;

    // Create windows used by control
    if (RecAct_CreateWindows(this, lpcs))
    {
        this->lpfnLBProc = SubclassWindow(this->hwndLB, RecActLB_LBProc);

        this->hdsa = DSA_Create(sizeof(int), 16);
        if (this->hdsa)
        {
            // Get the system imagelist cache
            this->himlCache = ImageList_Create(g_cxIcon, g_cyIcon, TRUE, 8, 8);
            if (this->himlCache)
            {
                if(IS_WINDOW_RTL_MIRRORED(hwnd))
                {
                    flags |= ILC_MIRROR;
                }
                if (CreateImageList(&this->himlAction, hdc, IDB_ACTIONS,
                            CX_ACTIONBMP, CY_ACTIONBMP, 8, flags))
                {
                    SIZE size;

                    // Get some metrics
                    this->cxMenuCheck = GetSystemMetrics(SM_CXMENUCHECK);
                    this->cyMenuCheck = GetSystemMetrics(SM_CYMENUCHECK);

                    size.cx = this->cxMenuCheck;
                    size.cy = this->cyMenuCheck;
                    this->hbmpBullet = CreateBulletBitmap(&size);
                    if (this->hbmpBullet)
                    {
                        bRet = RecAct_CreateMenu(this);
                    }
                }
            }
        }
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: WM_DESTROY Handler
Returns: --
Cond:    --
 */
void PRIVATE RecAct_OnDestroy(
        LPRECACT this)
{
    if (this->himlCache)
    {
        ImageList_Destroy(this->himlCache);
        this->himlCache = NULL;
    }

    if (this->himlAction)
    {
        ImageList_Destroy(this->himlAction);
        this->himlAction = NULL;
    }

    if (this->hbmpBullet)
    {
        DeleteBitmap(this->hbmpBullet);
        this->hbmpBullet = NULL;
    }

    if (this->hmenu)
    {
        DestroyMenu(this->hmenu);
        this->hmenu = NULL;
    }

    if (this->hbrBkgnd)
        DeleteBrush(this->hbrBkgnd);

    if (this->hfont)
        DeleteFont(this->hfont);

    if (this->hdsa)
        DSA_Destroy(this->hdsa);
}


/*----------------------------------------------------------
Purpose: WM_COMMAND Handler
Returns: --
Cond:    --
 */
VOID PRIVATE RecAct_OnCommand(
        LPRECACT this,
        int id,
        HWND hwndCtl,
        UINT uNotifyCode)
{
    if (hwndCtl == this->hwndLB)
    {
        switch (uNotifyCode)
        {
            case LBN_SELCHANGE:
                break;
        }
    }
}


/*----------------------------------------------------------
Purpose: Handles WM_SYSKEYDOWN

Returns: 0 if we processed it

Cond:    --
 */
int PRIVATE RecAct_OnSysKeyDown(
        LPRECACT this,
        UINT vkey,
        LPARAM lKeyData)
{
    int nRet = -1;

    // Context menu invoked by the keyboard?
    if (VK_F10 == vkey && 0 > GetKeyState(VK_SHIFT))
    {
        // Yes; forward the message
        HWND hwndLB = this->hwndLB;
        int iCaret = ListBox_GetCurSel(hwndLB);

        // Is this in a property page?
        if (RecAct_IsNoIcon(this) && 0 > iCaret)
        {
            // Yes; don't require the item to be selected
            iCaret = 0;
        }

        if (0 <= iCaret)
        {
            LPRA_PRIV ppriv;
            LPDOBJ pdobj;
            POINT pt;
            RECT rc;

            // Determine where to show the context menu
            ListBox_GetText(hwndLB, iCaret, &ppriv);
            pdobj = RecAct_ChooseCaretDobj(this, ppriv);

            ListBox_GetItemRect(hwndLB, iCaret, &rc);
            pt.x = pdobj->x + (g_cxIcon / 2) + rc.left;
            pt.y = pdobj->y + (g_cyIcon / 2) + rc.top;
            ClientToScreen(hwndLB, &pt);

            PostMessage(this->hwnd, WM_CONTEXTMENU, (WPARAM)hwndLB, MAKELPARAM(pt.x, pt.y));
        }
        nRet = 0;
    }

    return nRet;
}

// ( (4+1) is for ellipses )
#define MAX_HALF    (ARRAYSIZE(pttt->szText)/2 - (4+1))

/*----------------------------------------------------------
Purpose: Handles TTN_NEEDTEXT

Returns: --
Cond:    --
 */
void PRIVATE RecAct_OnNeedTipText(
        LPRECACT this,
        LPTOOLTIPTEXT pttt)
{
    // Find the visible listbox item associated with this tip ID.
    HWND hwndLB = this->hwndLB;
    LPRA_PRIV ppriv;
    int iItem;
    BOOL bInside;
    SIDEITEM * psi;

    iItem = RecAct_FindItemFromTipID(this, (UINT)pttt->hdr.idFrom, &bInside);

    if (LB_ERR != iItem)
    {
        int cb;

        ListBox_GetText(hwndLB, iItem, &ppriv);
        if (bInside)
            psi = &ppriv->siInside;
        else
            psi = &ppriv->siOutside;

        // Need ellipses?
        cb = CbFromCch(lstrlen(psi->pszDir));
        if (cb >= sizeof(pttt->szText))
        {
            // Yes
            LPTSTR pszLastHalf;
            LPTSTR psz;
            LPTSTR pszStart = psi->pszDir;
            LPTSTR pszEnd = &psi->pszDir[lstrlen(psi->pszDir)];

            for (psz = pszEnd;
                    psz != pszStart && (pszEnd - psz) < MAX_HALF;
                    psz = CharPrev(pszStart, psz))
                ;

            pszLastHalf = CharNext(psz);
            lstrcpyn(pttt->szText, psi->pszDir, MAX_HALF);
            StrCatBuff(pttt->szText, c_szEllipses, ARRAYSIZE(pttt->szText));
            StrCatBuff(pttt->szText, pszLastHalf, ARRAYSIZE(pttt->szText));
        }
        else
            lstrcpyn(pttt->szText, psi->pszDir, ARRAYSIZE(pttt->szText));
    }
    else
        *pttt->szText = 0;
}


/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
 */
LRESULT PRIVATE RecAct_OnNotify(
        LPRECACT this,
        int idFrom,
        NMHDR  * lpnmhdr)
{
    LRESULT lRet = 0;

    switch (lpnmhdr->code)
    {
        case HDN_BEGINTRACK:
            lRet = TRUE;       // prevent tracking
            break;

        default:
            break;
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: WM_CONTEXTMENU handler
Returns: --
Cond:    --
 */
void PRIVATE RecAct_OnContextMenu(
        LPRECACT this,
        HWND hwnd,
        int x,
        int y)
{
    if (hwnd == this->hwndLB)
    {
        POINT pt;
        int iHitEntry;
        BOOL bHelpOnly;

        pt.x = x;
        pt.y = y;
        ScreenToClient(hwnd, &pt);

        iHitEntry = GetHitIndex(hwnd, pt);
        if (LB_ERR != iHitEntry)
        {
            ASSERT(iHitEntry < ListBox_GetCount(hwnd));

            ListBox_SetCurSel(hwnd, iHitEntry);
            ListBox_RepaintItemNow(hwnd, iHitEntry, NULL, FALSE);

            bHelpOnly = FALSE;
        }
        else
            bHelpOnly = TRUE;

        // Bring up the context menu for the listbox
        RecAct_DoContextMenu(this, x, y, iHitEntry, bHelpOnly);
    }
}


/*----------------------------------------------------------
Purpose: Calculate the rectangle boundary of a sideitem

Returns: calculated rect
Cond:    --
 */
void PRIVATE RecAct_CalcSideItemRect(
        LPRECACT this,
        int nSide,          // SIDE_INSIDE or SIDE_OUTSIDE
        int cxFile,
        int cxAction,
        LPRECT prcOut)
{
    int x;
    int y = g_cyIconMargin*2;
    int cx = ((this->cxItem - cxFile - cxAction) / 2);

    switch (nSide)
    {
        case SIDE_INSIDE:
            if (RecAct_IsNoIcon(this))
                x = 0;
            else
                x = cxFile;
            break;

        case SIDE_OUTSIDE:
            if (RecAct_IsNoIcon(this))
                x = cx + cxAction;
            else
                x = cxFile + cx + cxAction;
            break;

        default:
            ASSERT(0);
            break;
    }

    x += g_cxMargin;

    prcOut->left   = x + g_cxMargin;
    prcOut->top    = y;
    prcOut->right  = prcOut->left + (cx - 2*g_cxMargin);
    prcOut->bottom = y + (this->cyText * 3);
}


/*----------------------------------------------------------
Purpose: Draw a reconciliation listbox entry
Returns: --
Cond:    --
 */
void PRIVATE RecAct_RecomputeItemMetrics(
        LPRECACT this,
        LPRA_PRIV ppriv)
{
    HDC hdc = this->hdcOwn;
    LPDOBJ pdobj = ppriv->rgdobj;
    RECT rcT;
    RECT rcUnion;
    TCHAR szIDS[MAXBUFLEN];
    UINT ids;
    int cyText = this->cyText;
    int dx;
    int cxFile;
    int cxAction;
    POINT pt;

    // Compute the metrics and dimensions of each of the draw objects
    // and store back into the item.

    // File icon and label

    pt.x = 0;
    pt.y = 0;
    ComputeImageRects(FIGetDisplayName(ppriv->pfi), hdc, &pt, &rcT,
            &pdobj->rcLabel, g_cxIcon, g_cyIcon, g_cxIconSpacing, cyText);

    pdobj->uKind = DOK_IMAGE;
    pdobj->lpvObject = FIGetDisplayName(ppriv->pfi);
    pdobj->uFlags = DOF_DIFFER | DOF_CENTER;
    if (RecAct_IsNoIcon(this))
    {
        SetFlag(pdobj->uFlags, DOF_NODRAW);
        cxFile = 0;
    }
    else
    {
        cxFile = rcT.right - rcT.left;
    }
    pdobj->x = pt.x;
    pdobj->y = pt.y;
    pdobj->himl = this->himlCache;
    pdobj->iImage = (UINT)ppriv->pfi->lParam;
    pdobj->rcBounding = rcT;

    rcUnion = pdobj->rcBounding;

    // Action image

    ASSERT(ppriv->uAction <= ARRAYSIZE(c_mpraiaiImage));

    pdobj++;

    ids = GetActionText(ppriv);
    pt.x = 0;       // (we'll adjust this after the call)
    pt.y = 0;
    ComputeImageRects(SzFromIDS(ids, szIDS, ARRAYSIZE(szIDS)), hdc, &pt,
            &rcT, &pdobj->rcLabel, CX_ACTIONBMP, CY_ACTIONBMP,
            g_cxIconSpacing, cyText);

    // (Adjust pt and the two rects to be centered in the remaining space)
    cxAction = rcT.right - rcT.left;
    dx = cxFile + (((this->cxItem - cxFile) / 2) - (cxAction / 2));
    pt.x += dx;
    OffsetRect(&rcT, dx, 0);
    OffsetRect(&pdobj->rcLabel, dx, 0);

    pdobj->uKind = DOK_IMAGE;
    pdobj->lpvObject = IntToPtr(ids);
    pdobj->uFlags = DOF_CENTER | DOF_USEIDS;
    if (!RecAct_IsNoIcon(this))
        SetFlag(pdobj->uFlags, DOF_IGNORESEL);
    pdobj->x = pt.x;
    pdobj->y = pt.y;
    pdobj->himl = this->himlAction;
    pdobj->iImage = c_mpraiaiImage[ppriv->uAction];
    pdobj->rcBounding = rcT;

    UnionRect(&rcUnion, &rcUnion, &pdobj->rcBounding);

    // Sideitem Info (Inside Briefcase)

    RecAct_CalcSideItemRect(this, SIDE_INSIDE, cxFile, cxAction, &rcT);

    pdobj++;
    pdobj->uKind = DOK_SIDEITEM;
    pdobj->lpvObject = &ppriv->siInside;
    pdobj->uFlags = DOF_LEFT;
    pdobj->x = rcT.left;
    pdobj->y = rcT.top;
    pdobj->rcClip = rcT;
    pdobj->rcBounding = rcT;

    // Sideitem Info (Outside Briefcase)

    RecAct_CalcSideItemRect(this, SIDE_OUTSIDE, cxFile, cxAction, &rcT);

    pdobj++;
    pdobj->uKind = DOK_SIDEITEM;
    pdobj->lpvObject = &ppriv->siOutside;
    pdobj->uFlags = DOF_LEFT;
    pdobj->x = rcT.left;
    pdobj->y = rcT.top;
    pdobj->rcClip = rcT;
    pdobj->rcBounding = rcT;

    UnionRect(&rcUnion, &rcUnion, &rcT);

    // Set the bounding rect of this item.
    ppriv->cx = rcUnion.right - rcUnion.left;
    ppriv->cy = max((rcUnion.bottom - rcUnion.top), g_cyIconSpacing);
}


/*----------------------------------------------------------
Purpose: WM_MEASUREITEM handler
Returns: --
Cond:    --
 */
BOOL PRIVATE RecAct_OnMeasureItem(
        LPRECACT this,
        LPMEASUREITEMSTRUCT lpmis)
{
    HDC hdc = this->hdcOwn;

    switch (lpmis->CtlType)
    {
        case ODT_LISTBOX: {
                              LPRA_PRIV ppriv = (LPRA_PRIV)lpmis->itemData;

                              // Recompute item metrics?
                              if (RECOMPUTE == ppriv->cx)
                              {
                                  RecAct_RecomputeItemMetrics(this, ppriv);   // Yes
                              }

                              lpmis->itemHeight = ppriv->cy;
                          }
                          return TRUE;

        case ODT_MENU:
                          {
                              int i;
                              int cxMac = 0;
                              RECT rc;
                              TCHAR sz[MAXBUFLEN];

                              // Calculate based on font and image dimensions.
                              //
                              SelectFont(hdc, this->hfont);

                              cxMac = 0;
                              for (i = 0; i < ARRAYSIZE(c_rgramid); i++)
                              {
                                  SzFromIDS(c_rgramid[i].ids, sz, ARRAYSIZE(sz));
                                  SetRectFromExtent(hdc, &rc, sz);
                                  cxMac = max(cxMac,
                                          g_cxMargin + CX_ACTIONBMP + g_cxMargin +
                                          (rc.right-rc.left) + g_cxMargin);
                              }

                              lpmis->itemHeight = max(this->cyText, CY_ACTIONBMP);
                              lpmis->itemWidth = cxMac;
                          }
                          return TRUE;
    }
    return FALSE;
}


/*----------------------------------------------------------
Purpose: Draw a reconciliation listbox entry
Returns: --
Cond:    --
 */
void PRIVATE RecAct_DrawLBItem(
        LPRECACT this,
        const DRAWITEMSTRUCT  * lpcdis)
{
    LPRA_PRIV ppriv = (LPRA_PRIV)lpcdis->itemData;
    HDC hdc = lpcdis->hDC;
    RECT rc = lpcdis->rcItem;
    POINT ptSav;
    LPDOBJ pdobj;
    UINT cdobjs;

    if (!ppriv)
    {
        // Empty listbox and we're getting the focus
        return;
    }

    SetBkMode(hdc, TRANSPARENT);        // required for Shell_DrawText
    SetViewportOrgEx(hdc, rc.left, rc.top, &ptSav);

    // The Chicago-look mandates that icon and filename are selected,
    // the rest of the entry is normal.

    // Recompute item metrics?
    if (RECOMPUTE == ppriv->cx)
    {
        RecAct_RecomputeItemMetrics(this, ppriv);   // Yes
    }

    // Do we need to redraw everything?
    if (IsFlagSet(lpcdis->itemAction, ODA_DRAWENTIRE))
    {
        // Yes
        TOOLINFO ti;

        cdobjs = ARRAYSIZE(ppriv->rgdobj);
        pdobj = ppriv->rgdobj;

        // Get the tooltip ID given this ith visible entry
        ti.cbSize = sizeof(ti);
        ti.uFlags = 0;
        ti.hwnd = this->hwndLB;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        ti.uId = RecAct_GetTipIDFromItemID(this, lpcdis->itemID);
        ti.rect = ppriv->rgdobj[IDOBJ_INSIDE].rcBounding;
        OffsetRect(&ti.rect, lpcdis->rcItem.left, lpcdis->rcItem.top);
        SendMessage(this->hwndTip, TTM_NEWTOOLRECT, 0, (LPARAM)&ti);

        ti.uId++;
        ti.rect = ppriv->rgdobj[IDOBJ_OUTSIDE].rcBounding;
        OffsetRect(&ti.rect, lpcdis->rcItem.left, lpcdis->rcItem.top);
        SendMessage(this->hwndTip, TTM_NEWTOOLRECT, 0, (LPARAM)&ti);
    }
    else
    {
        // No; should we even draw the file icon or action icon?
        if (lpcdis->itemAction & (ODA_FOCUS | ODA_SELECT))
        {
            cdobjs = 1;     // Yes
            pdobj = RecAct_ChooseCaretDobj(this, ppriv);
        }
        else
        {
            cdobjs = 0;     // No
            pdobj = ppriv->rgdobj;
        }
    }

    Dobj_Draw(hdc, pdobj, cdobjs, lpcdis->itemState, this->cxEllipses, this->cyText,
            this->clrBkgnd);

    // Clean up
    //
    SetViewportOrgEx(hdc, ptSav.x, ptSav.y, NULL);
}


/*----------------------------------------------------------
Purpose: Draw an action menu item
Returns: --
Cond:    --
 */
void PRIVATE RecAct_DrawMenuItem(
        LPRECACT this,
        const DRAWITEMSTRUCT  * lpcdis)
{
    LPRAMID pramid = (LPRAMID)lpcdis->itemData;
    HDC hdc = lpcdis->hDC;
    RECT rc = lpcdis->rcItem;
    DOBJ dobj;
    LPDOBJ pdobj;
    POINT ptSav;
    MENUITEMINFO mii;
    int cx;
    int cy;
    UINT uFlags;
    UINT uFlagsChecked;

    ASSERT(pramid);

    if (lpcdis->itemID == -1)
        return;

    SetViewportOrgEx(hdc, rc.left, rc.top, &ptSav);
    OffsetRect(&rc, -rc.left, -rc.top);

    cx = rc.right - rc.left;
    cy = rc.bottom - rc.top;

    // Get the menu state
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_STATE | MIIM_CHECKMARKS;
    GetMenuItemInfo(this->hmenu, lpcdis->itemID, FALSE, &mii);
    uFlagsChecked = IsFlagClear(mii.fState, MFS_CHECKED) ? DOF_NODRAW : 0;

    uFlags = DOF_DIFFER | DOF_MENU | DOF_USEIDS;
    if (IsFlagSet(mii.fState, MFS_GRAYED))
        SetFlag(uFlags, DOF_DISABLED);

    // Build the array of DObjs that we want to draw.

    // Action image

    pdobj = &dobj;

    pdobj->uKind = DOK_IMAGE;
    pdobj->lpvObject = IntToPtr(pramid->ids);
    pdobj->himl = this->himlAction;
    pdobj->iImage = pramid->iImage;
    pdobj->uFlags = uFlags;
    pdobj->x = g_cxMargin;
    pdobj->y = (cy - CY_ACTIONBMP) / 2;
    pdobj->rcLabel.left = 0;
    pdobj->rcLabel.right = cx;
    pdobj->rcLabel.top = 0;
    pdobj->rcLabel.bottom = cy;

    // Draw the entry...
    //
    Dobj_Draw(hdc, &dobj, 1, lpcdis->itemState, 0, this->cyText, this->clrBkgnd);

    // Clean up
    //
    SetViewportOrgEx(hdc, ptSav.x, ptSav.y, NULL);
}


/*----------------------------------------------------------
Purpose: WM_DRAWITEM handler
Returns: --
Cond:    --
 */
BOOL PRIVATE RecAct_OnDrawItem(
        LPRECACT this,
        const DRAWITEMSTRUCT  * lpcdis)
{
    switch (lpcdis->CtlType)
    {
        case ODT_LISTBOX:
            RecAct_DrawLBItem(this, lpcdis);
            return TRUE;

        case ODT_MENU:
            RecAct_DrawMenuItem(this, lpcdis);
            return TRUE;
    }
    return FALSE;
}


/*----------------------------------------------------------
Purpose: WM_COMPAREITEM handler
Returns: -1 (item 1 precedes item 2), 0 (equal), 1 (item 2 precedes item 1)
Cond:    --
 */
int PRIVATE RecAct_OnCompareItem(
        LPRECACT this,
        const COMPAREITEMSTRUCT  * lpcis)
{
    LPRA_PRIV ppriv1 = (LPRA_PRIV)lpcis->itemData1;
    LPRA_PRIV ppriv2 = (LPRA_PRIV)lpcis->itemData2;

    // We sort based on name of file
    //
    return lstrcmpi(FIGetPath(ppriv1->pfi), FIGetPath(ppriv2->pfi));
}


/*----------------------------------------------------------
Purpose: WM_DELETEITEM handler
Returns: --
Cond:    --
 */
void RecAct_OnDeleteLBItem(
        LPRECACT this,
        const DELETEITEMSTRUCT  * lpcdis)
{
    switch (lpcdis->CtlType)
    {
        case ODT_LISTBOX:
            {
                LPRA_PRIV ppriv = (LPRA_PRIV)lpcdis->itemData;

                ASSERT(ppriv);

                if (ppriv)
                {
                    FIFree(ppriv->pfi);

                    GFree(ppriv->siInside.pszDir);
                    GFree(ppriv->siOutside.pszDir);
                    GFree(ppriv);
                }
            }
            break;
    }
}


/*----------------------------------------------------------
Purpose: WM_CTLCOLORLISTBOX handler
Returns: --
Cond:    --
 */
HBRUSH PRIVATE RecAct_OnCtlColorListBox(
        LPRECACT this,
        HDC hdc,
        HWND hwndLB,
        int nType)
{
    return this->hbrBkgnd;
}


/*----------------------------------------------------------
Purpose: WM_PAINT handler
Returns: --
Cond:    --
 */
void RecAct_OnPaint(
        LPRECACT this)
{
    HWND hwnd = this->hwnd;
    PAINTSTRUCT ps;
    RECT rc;
    HDC hdc;

    hdc = BeginPaint(hwnd, &ps);
    GetClientRect(hwnd, &rc);
    if (IsFlagSet(this->lStyle, RAS_SINGLEITEM))
    {
        DrawEdge(hdc, &rc, BDR_SUNKENINNER, BF_TOPLEFT);
        DrawEdge(hdc, &rc, BDR_SUNKENOUTER, BF_BOTTOMRIGHT);
    }
    else
    {
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT);
    }

    EndPaint(hwnd, &ps);
}


/*----------------------------------------------------------
Purpose: WM_SETFONT handler
Returns: --
Cond:    --
 */
void RecAct_OnSetFont(
        LPRECACT this,
        HFONT hfont,
        BOOL bRedraw)
{
    this->hfont = hfont;
    FORWARD_WM_SETFONT(this->hwnd, hfont, bRedraw, RecAct_DefProc);
}


/*----------------------------------------------------------
Purpose: WM_SETFOCUS handler
Returns: --
Cond:    --
 */
void RecAct_OnSetFocus(
        LPRECACT this,
        HWND hwndOldFocus)
{
    SetFocus(this->hwndLB);
}


/*----------------------------------------------------------
Purpose: WM_SYSCOLORCHANGE handler
Returns: --
Cond:    --
 */
void RecAct_OnSysColorChange(
        LPRECACT this)
{
    RecAct_SetColors(this);
    InvalidateRect(this->hwnd, NULL, TRUE);
}


/*----------------------------------------------------------
Purpose: Insert item
Returns: index
Cond:    --
 */
int PRIVATE RecAct_OnInsertItem(
        LPRECACT this,
        const LPRA_ITEM pitem)
{
    HWND hwndLB = this->hwndLB;
    LPRA_PRIV pprivNew;
    TCHAR szPath[MAXPATHLEN];
    int iRet = -1;
    int iItem = LB_ERR;

    ASSERT(pitem);
    ASSERT(pitem->siInside.pszDir);
    ASSERT(pitem->siOutside.pszDir);
    ASSERT(pitem->pszName);

    pprivNew = GAlloc(sizeof(*pprivNew));
    if (pprivNew)
    {
        SetWindowRedraw(hwndLB, FALSE);

        // Fill the prerequisite fields first
        //
        pprivNew->uStyle = pitem->uStyle;
        pprivNew->uAction = pitem->uAction;

        // Set the fileinfo stuff and large icon system-cache index.
        //  If we can't get the fileinfo of the inside file, get the outside
        //  file.  If neither can be found, then we fail
        //
        lstrcpyn(szPath, SkipDisplayJunkHack(&pitem->siInside), ARRAYSIZE(szPath));
        if (IsFlagClear(pitem->uStyle, RAIS_FOLDER))
            PathAppend(szPath, pitem->pszName);

        if (FAILED(FICreate(szPath, &pprivNew->pfi, FIF_ICON)))
        {
            // Try the outside file
            //
            lstrcpyn(szPath, SkipDisplayJunkHack(&pitem->siOutside), ARRAYSIZE(szPath));
            if (IsFlagClear(pitem->uStyle, RAIS_FOLDER))
                PathAppend(szPath, pitem->pszName);

            if (FAILED(FICreate(szPath, &pprivNew->pfi, FIF_ICON)))
            {
                // Don't try to touch the file
                if (FAILED(FICreate(szPath, &pprivNew->pfi, FIF_ICON | FIF_DONTTOUCH)))
                    goto Insert_Cleanup;
            }
        }
        ASSERT(pprivNew->pfi);

        pprivNew->pfi->lParam = (LPARAM)ImageList_AddIcon(this->himlCache, pprivNew->pfi->hicon);

        // Fill in the rest of the fields
        //
        lstrcpyn(szPath, pitem->siInside.pszDir, ARRAYSIZE(szPath));
        if (IsFlagSet(pitem->uStyle, RAIS_FOLDER))
            PathRemoveFileSpec(szPath);
        if (!GSetString(&pprivNew->siInside.pszDir, szPath))
            goto Insert_Cleanup;

        pprivNew->siInside.uState = pitem->siInside.uState;
        pprivNew->siInside.fs = pitem->siInside.fs;
        pprivNew->siInside.ichRealPath = pitem->siInside.ichRealPath;

        lstrcpyn(szPath, pitem->siOutside.pszDir, ARRAYSIZE(szPath));
        if (IsFlagSet(pitem->uStyle, RAIS_FOLDER))
            PathRemoveFileSpec(szPath);
        if (!GSetString(&pprivNew->siOutside.pszDir, szPath))
            goto Insert_Cleanup;

        pprivNew->siOutside.uState = pitem->siOutside.uState;
        pprivNew->siOutside.fs = pitem->siOutside.fs;
        pprivNew->siOutside.ichRealPath = pitem->siOutside.ichRealPath;

        pprivNew->lParam = pitem->lParam;

        pprivNew->cx = RECOMPUTE;

        // We know we're doing a redundant sorted add if the element
        //  needs to be inserted at the end of the list, but who cares.
        //
        if (pitem->iItem >= RecAct_GetCount(this))
            iItem = ListBox_AddString(hwndLB, pprivNew);
        else
            iItem = ListBox_InsertString(hwndLB, pitem->iItem, pprivNew);

        if (iItem == LB_ERR)
            goto Insert_Cleanup;

        SetWindowRedraw(hwndLB, TRUE);

        iRet = iItem;
    }
    goto Insert_End;

Insert_Cleanup:
    // Have DeleteString handler clean up field allocations
    //  of pitem.
    //
    if (iItem != LB_ERR)
        ListBox_DeleteString(hwndLB, iItem);
    else
    {
        FIFree(pprivNew->pfi);
        GFree(pprivNew);
    }
    SetWindowRedraw(hwndLB, TRUE);

Insert_End:

    return iRet;
}


/*----------------------------------------------------------
Purpose: Delete item
Returns: count of items left
Cond:    --
 */
int PRIVATE RecAct_OnDeleteItem(
        LPRECACT this,
        int i)
{
    HWND hwndLB = this->hwndLB;

    return ListBox_DeleteString(hwndLB, i);
}


/*----------------------------------------------------------
Purpose: Delete all items
Returns: TRUE
Cond:    --
 */
BOOL PRIVATE RecAct_OnDeleteAllItems(
        LPRECACT this)
{
    ListBox_ResetContent(this->hwndLB);

    return TRUE;
}


/*----------------------------------------------------------
Purpose: Get item
Returns: TRUE on success
Cond:    --
 */
BOOL PRIVATE RecAct_OnGetItem(
        LPRECACT this,
        LPRA_ITEM pitem)
{
    LPRA_PRIV ppriv;
    HWND hwndLB = this->hwndLB;
    UINT uMask;
    int iItem;

    if (!pitem)
        return FALSE;

    iItem = pitem->iItem;
    uMask = pitem->mask;

    ListBox_GetText(hwndLB, iItem, &ppriv);

    if (uMask & RAIF_ACTION)
        pitem->uAction = ppriv->uAction;

    if (uMask & RAIF_NAME)
        pitem->pszName = FIGetPath(ppriv->pfi);

    if (uMask & RAIF_STYLE)
        pitem->uStyle = ppriv->uStyle;

    if (uMask & RAIF_INSIDE)
        pitem->siInside = ppriv->siInside;

    if (uMask & RAIF_OUTSIDE)
        pitem->siOutside = ppriv->siOutside;

    if (uMask & RAIF_LPARAM)
        pitem->lParam = ppriv->lParam;

    return TRUE;
}


/*----------------------------------------------------------
Purpose: Set item
Returns: TRUE on success
Cond:    --
 */
BOOL PRIVATE RecAct_OnSetItem(
        LPRECACT this,
        LPRA_ITEM pitem)
{
    LPRA_PRIV ppriv;
    HWND hwndLB = this->hwndLB;
    UINT uMask;
    int iItem;

    if (!pitem)
        return FALSE;

    uMask = pitem->mask;
    iItem = pitem->iItem;

    ListBox_GetText(hwndLB, iItem, &ppriv);

    if (uMask & RAIF_ACTION)
        ppriv->uAction = pitem->uAction;

    if (uMask & RAIF_STYLE)
        ppriv->uStyle = pitem->uStyle;

    if (uMask & RAIF_NAME)
    {
        if (!FISetPath(&ppriv->pfi, pitem->pszName, FIF_ICON))
            return FALSE;

        ppriv->pfi->lParam = (LPARAM)ImageList_AddIcon(this->himlCache, ppriv->pfi->hicon);
    }

    if (uMask & RAIF_INSIDE)
    {
        if (!GSetString(&ppriv->siInside.pszDir, pitem->siInside.pszDir))
            return FALSE;
        ppriv->siInside.uState = pitem->siInside.uState;
        ppriv->siInside.fs = pitem->siInside.fs;
        ppriv->siInside.ichRealPath = pitem->siInside.ichRealPath;
    }

    if (uMask & RAIF_OUTSIDE)
    {
        if (!GSetString(&ppriv->siOutside.pszDir, pitem->siOutside.pszDir))
            return FALSE;
        ppriv->siOutside.uState = pitem->siOutside.uState;
        ppriv->siOutside.fs = pitem->siOutside.fs;
        ppriv->siOutside.ichRealPath = pitem->siOutside.ichRealPath;
    }

    if (uMask & RAIF_LPARAM)
        ppriv->lParam = pitem->lParam;

    return TRUE;
}


/*----------------------------------------------------------
Purpose: Get the current selection
Returns: index
Cond:    --
 */
int PRIVATE RecAct_OnGetCurSel(
        LPRECACT this)
{
    return ListBox_GetCurSel(this->hwndLB);
}


/*----------------------------------------------------------
Purpose: Set the current selection
Returns: --
Cond:    --
 */
int PRIVATE RecAct_OnSetCurSel(
        LPRECACT this,
        int i)
{
    int iRet = ListBox_SetCurSel(this->hwndLB, i);

    if (iRet != LB_ERR)
        RecAct_SendSelChange(this, i);

    return iRet;
}


/*----------------------------------------------------------
Purpose: Find an item
Returns: TRUE on success
Cond:    --
 */
int PRIVATE RecAct_OnFindItem(
        LPRECACT this,
        int iStart,
        const RA_FINDITEM  * prafi)
{
    HWND hwndLB = this->hwndLB;
    UINT uMask = prafi->flags;
    LPRA_PRIV ppriv;
    BOOL bPass;
    int i;
    int cItems = ListBox_GetCount(hwndLB);

    for (i = iStart+1; i < cItems; i++)
    {
        bPass = TRUE;       // assume we pass

        ListBox_GetText(hwndLB, i, &ppriv);

        if (uMask & RAFI_NAME &&
                !IsSzEqual(FIGetPath(ppriv->pfi), prafi->psz))
            bPass = FALSE;

        if (uMask & RAFI_ACTION && ppriv->uAction != prafi->uAction)
            bPass = FALSE;

        if (uMask & RAFI_LPARAM && ppriv->lParam != prafi->lParam)
            bPass = FALSE;

        if (bPass)
            break;          // found it
    }

    return i == cItems ? -1 : i;
}


/////////////////////////////////////////////////////  EXPORTED FUNCTIONS


/*----------------------------------------------------------
Purpose: RecAct window proc
Returns: varies
Cond:    --
 */
LRESULT CALLBACK RecAct_WndProc(
        HWND hwnd,
        UINT msg,
        WPARAM wParam,
        LPARAM lParam)
{
    LPRECACT this = RecAct_GetPtr(hwnd);

    if (this == NULL)
    {
        if (msg == WM_NCCREATE)
        {
            this = GAlloc(sizeof(*this));
            ASSERT(this);
            if (!this)
                return 0L;      // OOM failure

            this->hwnd = hwnd;
            RecAct_SetPtr(hwnd, this);
        }
        else
        {
            return RecAct_DefProc(hwnd, msg, wParam, lParam);
        }
    }

    if (msg == WM_NCDESTROY)
    {
        GFree(this);
        RecAct_SetPtr(hwnd, NULL);
    }

    switch (msg)
    {
        HANDLE_MSG(this, WM_CREATE, RecAct_OnCreate);
        HANDLE_MSG(this, WM_DESTROY, RecAct_OnDestroy);

        HANDLE_MSG(this, WM_SETFONT, RecAct_OnSetFont);
        HANDLE_MSG(this, WM_COMMAND, RecAct_OnCommand);
        HANDLE_MSG(this, WM_NOTIFY, RecAct_OnNotify);
        HANDLE_MSG(this, WM_MEASUREITEM, RecAct_OnMeasureItem);
        HANDLE_MSG(this, WM_DRAWITEM, RecAct_OnDrawItem);
        HANDLE_MSG(this, WM_COMPAREITEM, RecAct_OnCompareItem);
        HANDLE_MSG(this, WM_DELETEITEM, RecAct_OnDeleteLBItem);
        HANDLE_MSG(this, WM_CONTEXTMENU, RecAct_OnContextMenu);
        HANDLE_MSG(this, WM_SETFOCUS, RecAct_OnSetFocus);
        HANDLE_MSG(this, WM_CTLCOLORLISTBOX, RecAct_OnCtlColorListBox);
        HANDLE_MSG(this, WM_PAINT, RecAct_OnPaint);
        HANDLE_MSG(this, WM_SYSCOLORCHANGE, RecAct_OnSysColorChange);


        case WM_HELP:
        WinHelp(this->hwnd, c_szWinHelpFile, HELP_CONTEXTPOPUP, IDH_BFC_UPDATE_SCREEN);
        return 0;

        case RAM_GETITEMCOUNT:
        return (LRESULT)RecAct_GetCount(this);

        case RAM_GETITEM:
        return (LRESULT)RecAct_OnGetItem(this, (LPRA_ITEM)lParam);

        case RAM_SETITEM:
        return (LRESULT)RecAct_OnSetItem(this, (const LPRA_ITEM)lParam);

        case RAM_INSERTITEM:
        return (LRESULT)RecAct_OnInsertItem(this, (const LPRA_ITEM)lParam);

        case RAM_DELETEITEM:
        return (LRESULT)RecAct_OnDeleteItem(this, (int)wParam);

        case RAM_DELETEALLITEMS:
        return (LRESULT)RecAct_OnDeleteAllItems(this);

        case RAM_GETCURSEL:
        return (LRESULT)RecAct_OnGetCurSel(this);

        case RAM_SETCURSEL:
        return (LRESULT)RecAct_OnSetCurSel(this, (int)wParam);

        case RAM_FINDITEM:
        return (LRESULT)RecAct_OnFindItem(this, (int)wParam, (const RA_FINDITEM  *)lParam);

        case RAM_REFRESH:
        RedrawWindow(this->hwndLB, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);

        default:
        return RecAct_DefProc(hwnd, msg, wParam, lParam);
    }
}


/////////////////////////////////////////////////////  PUBLIC FUNCTIONS


/*----------------------------------------------------------
Purpose: Initialize the reconciliation-action window class
Returns: TRUE on success
Cond:    --
 */
BOOL PUBLIC RecAct_Init(
        HINSTANCE hinst)
{
    WNDCLASSEX wc;

    wc.cbSize       = sizeof(WNDCLASSEX);
    wc.style        = CS_DBLCLKS | CS_OWNDC;
    wc.lpfnWndProc  = RecAct_WndProc;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = sizeof(LPRECACT);
    wc.hInstance    = hinst;
    wc.hIcon        = NULL;
    wc.hCursor      = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground= NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName= WC_RECACT;
    wc.hIconSm      = NULL;

    return RegisterClassEx(&wc) != 0;
}


/*----------------------------------------------------------
Purpose: Clean up RecAct window class
Returns: --
Cond:    --
 */
void PUBLIC RecAct_Term(
        HINSTANCE hinst)
{
    UnregisterClass(WC_RECACT, hinst);
}


/*----------------------------------------------------------
Purpose: Special sub-class listbox proc
Returns: varies
Cond:    --
 */
LRESULT _export CALLBACK RecActLB_LBProc(
        HWND hwnd,          // window handle
        UINT uMsg,           // window message
        WPARAM wparam,      // varies
        LPARAM lparam)      // varies
{
    LRESULT lRet;
    LPRECACT lpra = NULL;

    // Get the instance data for the control
    lpra = RecAct_GetPtr(GetParent(hwnd));
    ASSERT(lpra);

    switch (uMsg)
    {
        case WM_NOTIFY: {
                            NMHDR * pnmhdr = (NMHDR *)lparam;

                            if (TTN_NEEDTEXT == pnmhdr->code)
                            {
                                RecAct_OnNeedTipText(lpra, (LPTOOLTIPTEXT)pnmhdr);
                            }
                        }
                        break;

        case WM_SYSKEYDOWN: {
                                lRet = RecAct_OnSysKeyDown(lpra, (UINT)wparam, lparam);

                                if (0 != lRet)
                                    lRet = RecActLB_DefProc(lpra->lpfnLBProc, hwnd, uMsg, wparam, lparam);
                            }
                            break;

        case WM_MOUSEMOVE: {
                               MSG msg;

                               ASSERT(hwnd == lpra->hwndLB);

                               msg.lParam = lparam;
                               msg.wParam = wparam;
                               msg.message = uMsg;
                               msg.hwnd = hwnd;
                               SendMessage(lpra->hwndTip, TTM_RELAYEVENT, 0, (LPARAM)&msg);

                               lRet = RecActLB_DefProc(lpra->lpfnLBProc, hwnd, uMsg, wparam, lparam);
                           }
                           break;

        default:
                           lRet = RecActLB_DefProc(lpra->lpfnLBProc, hwnd, uMsg, wparam, lparam);
                           break;
    }

    return lRet;
}


//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Converts a recnode state to a sideitem state

Returns: see above
Cond:    --
 */
UINT PRIVATE SiFromRns(
        RECNODESTATE rnstate)
{
    switch (rnstate)
    {
#ifdef NEW_REC
        case RNS_NEVER_RECONCILED:      return SI_CHANGED;
#endif

        case RNS_UNAVAILABLE:           return SI_UNAVAILABLE;
        case RNS_DOES_NOT_EXIST:        return SI_NOEXIST;
        case RNS_DELETED:               return SI_DELETED;
        case RNS_NOT_RECONCILED:        return SI_UNCHANGED;
        case RNS_UP_TO_DATE:            return SI_UNCHANGED;
        case RNS_CHANGED:               return SI_CHANGED;

        default:
                                        ASSERT(0);
                                        return SI_UNCHANGED;
    }
}


/*----------------------------------------------------------
Purpose: Hack to skip potential volume name.

Returns: pointer to beginning of pathname in sideitem
Cond:    --
 */
LPCTSTR PRIVATE SkipDisplayJunkHack(
        LPSIDEITEM psi)
{
    UINT ich;

    ASSERT(psi);
    ASSERT(psi->pszDir);
    ASSERT(TEXT('(') == *psi->pszDir && 0 < psi->ichRealPath ||
            0 == psi->ichRealPath);
    ASSERT(psi->ichRealPath <= (UINT)lstrlen(psi->pszDir));

    // Paranoid checking here.  This function is being added close
    // to RTM, so as an added safety net, we're adding this min()
    // check.  For Nashville, after we're sure that there is no
    // problem with ichRealPath, we can remove the min() function.
    ich = min(psi->ichRealPath, (UINT)lstrlen(psi->pszDir));
    return &psi->pszDir[ich];
}


/*----------------------------------------------------------
Purpose: Returns a path that uses the share name of the hvid,
or the machine name if that is not available.

Returns: Pointer to buffer
Cond:    --
 */
LPTSTR PRIVATE GetAlternativePath(
        LPTSTR pszBuf,           // Must be MAX_PATH in length
        int cchMax,              // Must be equal to MAX_PATH
        LPCTSTR pszPath,
        HVOLUMEID hvid,
        LPUINT pichRealPath)
{
    TWINRESULT tr;
    VOLUMEDESC vd;

    ASSERT(pichRealPath);

    *pichRealPath = 0;

    vd.ulSize = sizeof(vd);
    tr = Sync_GetVolumeDescription(hvid, &vd);
    if (TR_SUCCESS == tr)
    {
        // Is a share name available?
        if (IsFlagSet(vd.dwFlags, VD_FL_NET_RESOURCE_VALID))
        {
            // Yes; use that
            lstrcpyn(pszBuf, vd.rgchNetResource, cchMax);
            PathAppend(pszBuf, PathFindEndOfRoot(pszPath));
            PathMakePresentable(pszBuf);
        }
        else if (IsFlagSet(vd.dwFlags, VD_FL_VOLUME_LABEL_VALID))
        {
            // No; use volume label
            LPTSTR pszMsg;

            PathMakePresentable(vd.rgchVolumeLabel);
            if (ConstructMessage(&pszMsg, g_hinst, MAKEINTRESOURCE(IDS_ALTNAME),
                        vd.rgchVolumeLabel, pszPath))
            {
                lstrcpyn(pszBuf, pszMsg, cchMax);
                GFree(pszMsg);
            }
            else
                lstrcpyn(pszBuf, pszPath, cchMax);

            *pichRealPath = 3 + lstrlen(vd.rgchVolumeLabel);
            PathMakePresentable(&pszBuf[*pichRealPath]);
        }
        else
        {
            lstrcpyn(pszBuf, pszPath, cchMax);
            PathMakePresentable(pszBuf);
        }
    }
    else
    {
        lstrcpyn(pszBuf, pszPath, cchMax);
        PathMakePresentable(pszBuf);
    }

    return pszBuf;
}


/*----------------------------------------------------------
Purpose: Constructs a path that would be appropriate for
the sideitem structure.  The path is placed in the
provided buffer.

Typically the path will simply be the folder path in
the recnode.  In cases when the recnode is unavailable,
this function prepends the machine name (or share name)
to the path.

Returns: --
Cond:    --
 */
void PRIVATE PathForSideItem(
        LPTSTR pszBuf,           // Must be MAX_PATH in length
        int cchMax,              // Must be equal to MAX_PATH
        HVOLUMEID hvid,
        LPCTSTR pszFolder,
        RECNODESTATE rns,
        LPUINT pichRealPath)
{
    ASSERT(pszBuf);
    ASSERT(pszFolder);
    ASSERT(pichRealPath);

    if (RNS_UNAVAILABLE == rns)
        GetAlternativePath(pszBuf, cchMax, pszFolder, hvid, pichRealPath);
    else
    {
        lstrcpyn(pszBuf, pszFolder, cchMax);
        PathMakePresentable(pszBuf);
        *pichRealPath = 0;
    }
    MyPathRemoveBackslash(pszBuf);
}


/*----------------------------------------------------------
Purpose: Determines the recact action based on the combination
of the inside and outside recnode actions

Returns: FALSE if this pair seems like an unlikely match.

(This can occur if there are two recnodes inside the
briefcase and we choose the wrong one such that the
pair consists of two destinations but no source.)

Cond:    --
 */
BOOL PRIVATE DeriveFileAction(
        RA_ITEM * pitem,
        RECNODEACTION rnaInside,
        RECNODEACTION rnaOutside)
{
    BOOL bRet = TRUE;

    if (RNA_COPY_FROM_ME == rnaInside &&
            RNA_COPY_TO_ME == rnaOutside)
    {
        pitem->uAction = RAIA_TOOUT;
    }
    else if (RNA_COPY_TO_ME == rnaInside &&
            RNA_COPY_FROM_ME == rnaOutside)
    {
        pitem->uAction = RAIA_TOIN;
    }

#ifdef NEW_REC
    else if (RNA_DELETE_ME == rnaInside)
    {
        pitem->uAction = RAIA_DELETEIN;
    }
    else if (RNA_DELETE_ME == rnaOutside)
    {
        pitem->uAction = RAIA_DELETEOUT;
    }
#endif

    else if (RNA_MERGE_ME == rnaInside &&
            RNA_MERGE_ME == rnaOutside)
    {
        pitem->uAction = RAIA_MERGE;
    }
    else if (RNA_COPY_TO_ME == rnaInside &&
            RNA_MERGE_ME == rnaOutside)
    {
        // (This is the merge-first-then-copy to third
        // file case.  We sorta punt because we're not
        // showing the implicit merge.)
        pitem->uAction = RAIA_TOIN;
    }
    else if (RNA_MERGE_ME == rnaInside &&
            RNA_COPY_TO_ME == rnaOutside)
    {
        // (This is the merge-first-then-copy to third
        // file case.  We sorta punt because we're not
        // showing the implicit merge.)
        pitem->uAction = RAIA_TOOUT;
    }
    else if (RNA_NOTHING == rnaInside)
    {
        // Is one side unavailable?
        if (SI_UNAVAILABLE == pitem->siInside.uState ||
                SI_UNAVAILABLE == pitem->siOutside.uState)
        {
            // Yes; force a skip
            pitem->uAction = RAIA_SKIP;
        }
        else if (SI_DELETED == pitem->siOutside.uState)
        {
            // No; the outside was deleted and the user had previously
            // said don't delete, so it is an orphan now.
            pitem->uAction = RAIA_ORPHAN;
        }
        else
        {
            // No; it is up-to-date or both sides don't exist
            pitem->uAction = RAIA_NOTHING;
        }
    }
    else
    {
        pitem->uAction = RAIA_TOIN;

        bRet = FALSE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Determines the action and possibly a better inside
path if there are multiple nodes to pick from.

Returns: better (or same) inside path
Cond:    --
 */
PCHOOSESIDE PRIVATE DeriveFileActionAndSide(
        RA_ITEM * pitem,
        HDSA hdsa,
        PCHOOSESIDE pchsideInside,
        PCHOOSESIDE pchsideOutside,     // May be NULL
        BOOL bKeepFirstChoice)
{
    ASSERT(pchsideInside);

    if (pchsideOutside)
    {
        PRECNODE prnInside = pchsideInside->prn;
        PRECNODE prnOutside = pchsideOutside->prn;
        PRECITEM pri = prnInside->priParent;

#ifndef NEW_REC
        // Was the original deleted?
        if (RNS_DELETED == prnOutside->rnstate)
        {
            // Yes; make this an orphan
            TRACE_MSG(TF_GENERAL, TEXT("Found outside path to be deleted"));

            pitem->uAction = RAIA_ORPHAN;
        }
        else
#endif
        {
            // No
            BOOL bDoAgain;
            PCHOOSESIDE pchside = pchsideInside;

            // Determine the action based on the currently
            // chosen inside and outside pair.  If DeriveFileAction
            // determines that the current inside selection is
            // unlikely, we get the next best choice and try
            // again.

            do
            {
                BOOL bGetNextBest = !DeriveFileAction(pitem,
                        pchside->prn->rnaction,
                        prnOutside->rnaction);

                bDoAgain = FALSE;
                if (!bKeepFirstChoice)
                {
                    if (bGetNextBest &&
                            2 < pri->ulcNodes)
                    {
                        TRACE_MSG(TF_GENERAL, TEXT("Getting next best node"));

                        if (!ChooseSide_GetNextBest(hdsa, &pchside))
                            break;

                        bDoAgain = TRUE;
                    }
                    else if (!bGetNextBest)
                        pchsideInside = pchside;
                    else
                        ASSERT(0);
                }

            } while (bDoAgain);

            // Is this a broken merge?
            if (RIA_BROKEN_MERGE == pri->riaction)
            {
                // Yes; override and say it is a conflict
                pitem->uAction = RAIA_CONFLICT;
            }
        }
    }
    else
    {
        TRACE_MSG(TF_GENERAL, TEXT("Outside path doesn't exist in recitem"));

        pitem->uAction = RAIA_ORPHAN;
    }
    return pchsideInside;
}


/*----------------------------------------------------------
Purpose: Updates *prns and *prna based on given pchside, or
leaves them alone.

Returns: --
Cond:    --
 */
void PRIVATE DeriveFolderStateAndAction(
        PCHOOSESIDE pchside,
        RECNODESTATE * prns,
        UINT * puAction)
{
    PRECNODE prn;

    ASSERT(pchside);
    ASSERT(prns);
    ASSERT(puAction);
    ASSERT(RAIA_SOMETHING == *puAction || RAIA_NOTHING == *puAction ||
            RAIA_SKIP == *puAction);

    prn = pchside->prn;
    ASSERT(prn);

    switch (prn->rnstate)
    {
        case RNS_UNAVAILABLE:
            *prns = RNS_UNAVAILABLE;
            *puAction = RAIA_SKIP;      // (Always takes precedence)
            break;

#ifdef NEW_REC
        case RNS_NEVER_RECONCILED:
#endif
        case RNS_CHANGED:
            *prns = RNS_CHANGED;
            if (RAIA_NOTHING == *puAction)
                *puAction = RAIA_SOMETHING;
            break;

        case RNS_DELETED:
#ifdef NEW_REC
            if (RNA_DELETE_ME == prn->rnaction)
            {
                *prns = RNS_CHANGED;
                if (RAIA_NOTHING == *puAction)
                    *puAction = RAIA_SOMETHING;
            }
#else
            // Leave the state as it is
#endif
            break;

        case RNS_DOES_NOT_EXIST:
        case RNS_UP_TO_DATE:
        case RNS_NOT_RECONCILED:
            switch (prn->rnaction)
            {
                case RNA_COPY_TO_ME:
#ifdef NEW_REC
                    if (RAIA_NOTHING == *puAction)
                        *puAction = RAIA_SOMETHING;

#else
                    // Poor man's tombstoning.  Don't say the folder
                    // needs updating if files have been deleted or
                    // the whole folder has been deleted.
                    //
                    if (!PathExists(prn->pcszFolder))
                    {
                        // Folder is gone.  Say this is an orphan now.
                        *prns = RNS_DELETED;
                    }
                    else if (RAIA_NOTHING == *puAction)
                    {
                        *puAction = RAIA_SOMETHING;
                    }
#endif
                    break;

#ifdef NEW_REC
                case RNA_DELETE_ME:
#endif
                case RNA_MERGE_ME:
                    if (RAIA_NOTHING == *puAction)
                        *puAction = RAIA_SOMETHING;
                    break;
            }
            break;

        default:
            ASSERT(0);
            break;
    }
}


/*----------------------------------------------------------
Purpose: Determine the recnode state of a folder that has
no intersecting recnodes.

Returns: recnode state
Cond:    --
 */
RECNODESTATE PRIVATE DeriveFolderState(
        PCHOOSESIDE pchside)
{
    FOLDERTWINSTATUS uStatus;
    RECNODESTATE rns;

    Sync_GetFolderTwinStatus((HFOLDERTWIN)pchside->htwin, NULL, 0, &uStatus);
    if (FTS_UNAVAILABLE == uStatus)
        rns = RNS_UNAVAILABLE;
    else
        rns = RNS_UP_TO_DATE;
    return rns;
}


/*----------------------------------------------------------
Purpose: Initialize a paired-twin structure assuming pszPath
is a file.

Returns: standard result
Cond:    --
 */
HRESULT PRIVATE RAI_InitAsRecItem(
        LPRA_ITEM pitem,
        LPCTSTR pszBrfPath,
        LPCTSTR pszPath,              // May be NULL
        PRECITEM pri,
        BOOL bKeepFirstChoice)
{
    HRESULT hres;
    HDSA hdsa;

    ASSERT(pitem);
    ASSERT(pszBrfPath);
    ASSERT(pri);

    hres = ChooseSide_CreateAsFile(&hdsa, pri);
    if (SUCCEEDED(hres))
    {
        TCHAR sz[MAX_PATH];
        PCHOOSESIDE pchside;
        PCHOOSESIDE pchsideOutside;
        UINT ichRealPath;

        DEBUG_CODE( Sync_DumpRecItem(TR_SUCCESS, pri, TEXT("RAI_InitAsFile")); )

            pitem->mask = RAIF_ALL & ~RAIF_LPARAM;
        if (!GSetString(&pitem->pszName, pri->pcszName))
            goto Error;
        PathMakePresentable(pitem->pszName);

        // Default style
        if (RIA_MERGE == pri->riaction)
            pitem->uStyle = RAIS_CANMERGE;
        else
            pitem->uStyle = 0;

        // Is there an outside file?
        if (ChooseSide_GetBest(hdsa, pszBrfPath, NULL, &pchside))
        {
            // Yes
            RECNODESTATE rns = pchside->prn->rnstate;

            DEBUG_CODE( ChooseSide_DumpList(hdsa); )

                pitem->siOutside.uState = SiFromRns(rns);
            PathForSideItem(sz, ARRAYSIZE(sz), pchside->hvid, pchside->pszFolder, rns, &ichRealPath);
            if (!GSetString(&pitem->siOutside.pszDir, sz))
                goto Error;
            pitem->siOutside.fs = pchside->prn->fsCurrent;
            pitem->siOutside.ichRealPath = ichRealPath;
        }
        else
        {
            // No; this is an orphan
            DEBUG_CODE( ChooseSide_DumpList(hdsa); )

                if (!GSetString(&pitem->siOutside.pszDir, c_szNULL))
                    goto Error;
            pitem->siOutside.uState = SI_NOEXIST;
            pitem->siOutside.ichRealPath = 0;
        }
        pchsideOutside = pchside;

        // Make sure we have some fully qualified folder on which
        // to base our decision for an inside path
        if (pszPath)
        {
            lstrcpyn(sz, pszPath, ARRAYSIZE(sz));
            PathRemoveFileSpec(sz);
        }
        else
            lstrcpyn(sz, pszBrfPath, ARRAYSIZE(sz));    // (best we can do...)

        // Get the inside folder
        if (ChooseSide_GetBest(hdsa, pszBrfPath, sz, &pchside))
        {
            RECNODESTATE rns;

            DEBUG_CODE( ChooseSide_DumpList(hdsa); )

                pchside = DeriveFileActionAndSide(pitem, hdsa, pchside, pchsideOutside, bKeepFirstChoice);

            // Determine status of inside file
            rns = pchside->prn->rnstate;

            pitem->siInside.uState = SiFromRns(rns);
            PathForSideItem(sz, ARRAYSIZE(sz), pchside->hvid, pchside->pszFolder, rns, &ichRealPath);
            GSetString(&pitem->siInside.pszDir, sz);
            pitem->siInside.fs = pchside->prn->fsCurrent;
            pitem->siInside.ichRealPath = ichRealPath;

            // Is there a node for the outside?
            if (pchsideOutside)
            {
                // Yes; special case.  If a single side does not exist
                // then say the existing side is new.
                if (SI_NOEXIST == pitem->siInside.uState &&
                        SI_NOEXIST == pitem->siOutside.uState)
                    ;       // Do nothing special
                else if (SI_NOEXIST == pitem->siInside.uState)
                {
                    ASSERT(SI_NOEXIST != pitem->siOutside.uState);
                    pitem->siOutside.uState = SI_NEW;
                }
                else if (SI_NOEXIST == pitem->siOutside.uState)
                {
                    ASSERT(SI_NOEXIST != pitem->siInside.uState);
                    pitem->siInside.uState = SI_NEW;
                }
            }

            // Save away twin handle.  Use the inside htwin because
            // we want to always delete from inside the briefcase
            // (it's all in your perspective...)
            pitem->htwin = (HTWIN)pchside->prn->hObjectTwin;
        }
        else
        {
            // It is relatively bad to be here

            DEBUG_CODE( ChooseSide_DumpList(hdsa); )
                ASSERT(0);

            hres = E_FAIL;
        }

        DEBUG_CODE( DumpTwinPair(pitem); )

            ChooseSide_Free(hdsa);
        hdsa = NULL;
    }
    else
    {
        hdsa = NULL;

Error:
        hres = E_OUTOFMEMORY;
    }

    if (FAILED(hres))
    {
        ChooseSide_Free(hdsa);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Choose a recitem whose name matches the given name.

Returns: A pointer to the recitem in the given reclist
NULL if filespec is not found

Cond:    --
 */
PRECITEM PRIVATE ChooseRecItem(
        PRECLIST prl,
        LPCTSTR pszName)
{
    PRECITEM pri;

    for (pri = prl->priFirst; pri; pri = pri->priNext)
    {
        if (IsSzEqual(pri->pcszName, pszName))
            return pri;
    }
    return NULL;
}


/*----------------------------------------------------------
Purpose: Initialize a paired-twin structure assuming pszPath
is a file.

Returns: standard result
Cond:    --
 */
HRESULT PRIVATE RAI_InitAsFile(
        LPRA_ITEM pitem,
        LPCTSTR pszBrfPath,
        LPCTSTR pszPath,
        PRECLIST prl)
{
    HRESULT hres;
    PRECITEM pri;

    ASSERT(pitem);
    ASSERT(pszBrfPath);
    ASSERT(pszPath);
    ASSERT(prl);

    if (pszPath)
    {
        LPCTSTR pszFile;
        pszFile = PathFindFileName(pszPath);
        pri = ChooseRecItem(prl, pszFile);
        ASSERT(pri);
    }
    else
    {
        pri = NULL;
    }

    if (pri)
    {
        hres = RAI_InitAsRecItem(pitem, pszBrfPath, pszPath, pri, TRUE);
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Initialize a paired-twin structure assuming pszPath
is a file.

Returns: standard result
Cond:    --
 */
HRESULT PRIVATE RAI_InitAsFolder(
        LPRA_ITEM pitem,
        LPCTSTR pszBrfPath,
        LPCTSTR pszPath,              // Should be inside the briefcase
        PRECLIST prl,
        PFOLDERTWINLIST pftl)
{
    HRESULT hres;
    HDSA hdsa;

    ASSERT(pitem);
    ASSERT(pszBrfPath);
    ASSERT(pszPath);
    ASSERT(prl);
    ASSERT(pftl);
    ASSERT(0 < pftl->ulcItems);

    pitem->mask = RAIF_ALL & ~RAIF_LPARAM;

    DEBUG_CODE( Sync_DumpRecList(TR_SUCCESS, prl, TEXT("RAI_InitAsFolder")); )
        DEBUG_CODE( Sync_DumpFolderTwinList(pftl, NULL); )

        // We only need to flag RAIS_FOLDER for the folder case.
        // (Context menu isn't available for folders, so RAIS_CANMERGE is
        //  unnecessary.)
        //
        pitem->uStyle = RAIS_FOLDER;

    hres = ChooseSide_CreateEmpty(&hdsa);
    if (SUCCEEDED(hres))
    {
        PRECITEM pri;
        RECNODESTATE rnsInside;
        RECNODESTATE rnsOutside;
        PCHOOSESIDE pchside;

        // Set starting defaults
        pitem->uAction = RAIA_NOTHING;
        rnsInside = RNS_UP_TO_DATE;
        rnsOutside = RNS_UP_TO_DATE;

        // Iterate thru reclist, choosing recnode pairs and dynamically
        // updating rnsInside, rnsOutside and pitem->uAction.
        for (pri = prl->priFirst; pri; pri = pri->priNext)
        {
            ChooseSide_InitAsFile(hdsa, pri);

            // Get the inside item
            if (ChooseSide_GetBest(hdsa, pszBrfPath, pszPath, &pchside))
            {
                DeriveFolderStateAndAction(pchside, &rnsInside, &pitem->uAction);
            }
            else
                ASSERT(0);

            // Get the outside item
            if (ChooseSide_GetBest(hdsa, pszBrfPath, NULL, &pchside))
            {
                DeriveFolderStateAndAction(pchside, &rnsOutside, &pitem->uAction);
            }
            else
                ASSERT(0);
        }
        ChooseSide_Free(hdsa);

        // Finish up
        hres = ChooseSide_CreateAsFolder(&hdsa, pftl);
        if (SUCCEEDED(hres))
        {
            TCHAR sz[MAX_PATH];
            UINT ichRealPath;

            // Name
            if (!GSetString(&pitem->pszName, PathFindFileName(pszPath)))
                goto Error;
            PathMakePresentable(pitem->pszName);

            // Get the inside folder
            if (ChooseSide_GetBest(hdsa, pszBrfPath, pszPath, &pchside))
            {
                DEBUG_CODE( ChooseSide_DumpList(hdsa); )

                    // Are there any intersecting files in this folder twin?
                    if (0 == prl->ulcItems)
                        rnsInside = DeriveFolderState(pchside);     // No

                pitem->siInside.uState = SiFromRns(rnsInside);
                PathForSideItem(sz, ARRAYSIZE(sz), pchside->hvid, pchside->pszFolder, rnsInside, &ichRealPath);
                if (!GSetString(&pitem->siInside.pszDir, sz))
                    goto Error;
                // (Hack to avoid printing bogus time/date)
                pitem->siInside.fs.fscond = FS_COND_UNAVAILABLE;
                pitem->siInside.ichRealPath = ichRealPath;
            }
            else
            {
                DEBUG_CODE( ChooseSide_DumpList(hdsa); )
                    ASSERT(0);
            }

            // Get the outside folder
            if (ChooseSide_GetBest(hdsa, pszBrfPath, NULL, &pchside))
            {
                DEBUG_CODE( ChooseSide_DumpList(hdsa); )

                    // Are there any intersecting files in this folder twin?
                    if (0 == prl->ulcItems)
                        rnsOutside = DeriveFolderState(pchside);     // No

                pitem->siOutside.uState = SiFromRns(rnsOutside);
                PathForSideItem(sz, ARRAYSIZE(sz), pchside->hvid, pchside->pszFolder, rnsOutside, &ichRealPath);
                if (!GSetString(&pitem->siOutside.pszDir, sz))
                    goto Error;
                // (Hack to avoid printing bogus time/date)
                pitem->siOutside.fs.fscond = FS_COND_UNAVAILABLE;
                pitem->siOutside.ichRealPath = ichRealPath;

                // Save away twin handle.  Use the outside handle
                // for folders.
                pitem->htwin = pchside->htwin;
            }
            else
            {
                DEBUG_CODE( ChooseSide_DumpList(hdsa); )
                    ASSERT(0);
            }

            DEBUG_CODE( DumpTwinPair(pitem); )

                ChooseSide_Free(hdsa);
        }
    }

    if (FAILED(hres))
    {
Error:
        if (SUCCEEDED(hres))
            hres = E_OUTOFMEMORY;

        ChooseSide_Free(hdsa);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Create a paired-twin structure given a path name.

Returns: standard result
Cond:    --
 */
HRESULT PUBLIC RAI_Create(
        LPRA_ITEM * ppitem,
        LPCTSTR pszBrfPath,
        LPCTSTR pszPath,              // Should be inside the briefcase
        PRECLIST prl,
        PFOLDERTWINLIST pftl)       // NULL if pszPath is a file
{
    HRESULT hres;
    LPRA_ITEM pitem;

    ASSERT(ppitem);
    ASSERT(pszPath);
    ASSERT(pszBrfPath);
    ASSERT(prl);

    DBG_ENTER_SZ(TEXT("RAI_Create"), pszPath);

    if (PathExists(pszPath))
    {
        pitem = GAlloc(sizeof(*pitem));
        if (pitem)
        {
            if (PathIsDirectory(pszPath))
                hres = RAI_InitAsFolder(pitem, pszBrfPath, pszPath, prl, pftl);
            else
                hres = RAI_InitAsFile(pitem, pszBrfPath, pszPath, prl);

            if (FAILED(hres))
            {
                // Cleanup
                RAI_Free(pitem);
                pitem = NULL;
            }
        }
        else
            hres = E_OUTOFMEMORY;
    }
    else
    {
        pitem = NULL;
        hres = E_FAIL;
    }

    *ppitem = pitem;

    DBG_EXIT_HRES(TEXT("RAI_Create"), hres);

    return hres;
}


/*----------------------------------------------------------
Purpose: Create a paired-twin structure given a recitem.

Returns: standard result
Cond:    --
 */
HRESULT PUBLIC RAI_CreateFromRecItem(LPRA_ITEM * ppitem, LPCTSTR pszBrfPath, PRECITEM pri)
{
    HRESULT hr = E_INVALIDARG;
    LPRA_ITEM pitem;

    DBG_ENTER(TEXT("RAI_CreateFromRecItem"));

    if (ppitem && pszBrfPath && pri)
    {
        pitem = GAlloc(sizeof(*pitem));
        if (pitem)
        {
            hr = RAI_InitAsRecItem(pitem, pszBrfPath, NULL, pri, FALSE);

            if (FAILED(hr))
            {
                // Cleanup
                RAI_Free(pitem);
                pitem = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        *ppitem = pitem;
    }

    DBG_EXIT_HRES(TEXT("RAI_CreateFromRecItem"), hr);

    return hr;
}


/*----------------------------------------------------------
Purpose: Free a paired item structure

Returns: standard result
Cond:    --
 */
HRESULT PUBLIC RAI_Free(
        LPRA_ITEM pitem)
{
    HRESULT hres;

    if (pitem)
    {
        GFree(pitem->pszName);
        GFree(pitem->siInside.pszDir);
        GFree(pitem->siOutside.pszDir);
        GFree(pitem);
        hres = NOERROR;
    }
    else
        hres = E_FAIL;

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\recact.h ===
//
// recact.h: Declares data, defines and struct types for RecAct
//                                module.
//
//

#ifndef __RECACT_H__
#define __RECACT_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  DEFINES

// RecAct message ranges
//
#define RAM_FIRST       (WM_USER+1)
#define RAM_LAST        (WM_USER+20)
#define RN_FIRST        (0U-700U)
#define RN_LAST         (0U-799U)

// Window class name
//
#define WC_RECACT       TEXT("RecAction")



// BOOL RecAct_Enable(HWND hwnd, BOOL fEnable);
//
#define RecAct_Enable(hwnd, fEnable) \
        EnableWindow((hwnd), (fEnable))

// int RecAct_GetItemCount(HWND hwnd);
//
#define RAM_GETITEMCOUNT                (RAM_FIRST + 0)
#define RecAct_GetItemCount(hwnd) \
                (int)SendMessage(hwnd, RAM_GETITEMCOUNT, 0, 0L)

// Side item structure
//
#define SI_UNCHANGED    0
#define SI_CHANGED      1
#define SI_NEW          2
#define SI_NOEXIST      3
#define SI_UNAVAILABLE  4
#define SI_DELETED      5

typedef struct tagSIDE_ITEM
    {
    LPTSTR pszDir;
    UINT uState;        // One of SI_* flags
    FILESTAMP fs;
    UINT ichRealPath;   // index to beginning of real path
    } SIDEITEM,  * LPSIDEITEM;

// RecAction Item structure
//
#define RAIF_ACTION      0x0001     // Mask codes
#define RAIF_NAME        0x0002
#define RAIF_STYLE       0x0004
#define RAIF_INSIDE      0x0008
#define RAIF_OUTSIDE     0x0010
#define RAIF_LPARAM      0x0020
#define RAIF_HTWIN       0x0040

#define RAIF_ALL         0x007f


typedef struct tagRA_ITEM
    {
    UINT mask;          // One of RAIF_
    int iItem;
    UINT uStyle;        // One of RAIS_
    UINT uAction;       // One of RAIA_

    LPTSTR pszName;

    SIDEITEM siInside;
    SIDEITEM siOutside;

    LPARAM lParam;
    HTWIN htwin;

    } RA_ITEM,  * LPRA_ITEM;


// RecAct item styles
//
#define RAIS_CANMERGE   0x0001
#define RAIS_FOLDER     0x0002

// RecAct actions
//
#define RAIA_TOOUT      0       // Don't change these values without changing
#define RAIA_TOIN       1       //  the order of the bitmaps in s_rgidAction
#define RAIA_SKIP       2
#define RAIA_CONFLICT   3
#define RAIA_MERGE      4
#define RAIA_SOMETHING  5       // These two require RAIS_FOLDER
#define RAIA_NOTHING    6
#define RAIA_ORPHAN     7
#define RAIA_DELETEOUT  8
#define RAIA_DELETEIN   9
#define RAIA_DONTDELETE 10

// Insert item at specified index.  Item is inserted at end if
// i is greater than or equal to the number of items in the twinview.
// Returns the index of the inserted item, or -1 on error.
//
// int RecAct_InsertItem(HWND hwnd, const LPRA_ITEM pitem);
//
#define RAM_INSERTITEM              (RAM_FIRST + 1)
#define RecAct_InsertItem(hwnd, pitem) \
                (int)SendMessage((hwnd), RAM_INSERTITEM, 0, (LPARAM)(const LPRA_ITEM)(pitem))

// Delete an item at the specified index.
//
// int RecAct_DeleteItem(HWND hwnd, int i);
//
#define RAM_DELETEITEM                  (RAM_FIRST + 2)
#define RecAct_DeleteItem(hwnd, i) \
                (int)SendMessage((hwnd), RAM_DELETEITEM, (WPARAM)(int)(i), 0L)

// Deletes all items in the control
//
// BOOL RecAct_DeleteAllItems(HWND hwnd);
//
#define RAM_DELETEALLITEMS              (RAM_FIRST + 3)
#define RecAct_DeleteAllItems(hwnd) \
                (BOOL)SendMessage((hwnd), RAM_DELETEALLITEMS, 0, 0L)

// BOOL RecAct_GetItem(HWND hwnd, LPRA_ITEM pitem);
//
#define RAM_GETITEM                             (RAM_FIRST + 4)
#define RecAct_GetItem(hwnd, pitem) \
                (BOOL)SendMessage((hwnd), RAM_GETITEM, 0, (LPARAM)(LPRA_ITEM)(pitem))

// BOOL RecAct_SetItem(HWND hwnd, const LPRA_ITEM pitem);
//
#define RAM_SETITEM                             (RAM_FIRST + 5)
#define RecAct_SetItem(hwnd, pitem) \
                (BOOL)SendMessage((hwnd), RAM_SETITEM, 0, (LPARAM)(const LPRA_ITEM)(pitem))

// Get the current selection by index.  -1 if nothing is selected.
//
// int RecAct_GetCurSel(HWND hwnd);
//
#define RAM_GETCURSEL                   (RAM_FIRST + 6)
#define RecAct_GetCurSel(hwnd) \
                (int)SendMessage((hwnd), RAM_GETCURSEL, (WPARAM)0, 0L)

// Set the current selection by index.  -1 to deselect.
//
// int RecAct_SetCurSel(HWND hwnd, int i);
//
#define RAM_SETCURSEL                   (RAM_FIRST + 7)
#define RecAct_SetCurSel(hwnd, i) \
                (int)SendMessage((hwnd), RAM_SETCURSEL, (WPARAM)(i), 0L)

// RecAct_FindItem flags
//
#define RAFI_NAME       0x0001
#define RAFI_LPARAM     0x0002
#define RAFI_ACTION     0x0004

typedef struct tagRA_FINDITEM
    {
    UINT    flags;      // One of RAFI_* flags
    UINT    uAction;    // One of RAIA_* flags
    LPCTSTR  psz;
    LPARAM  lParam;
    
    } RA_FINDITEM;

// Find an item according to RA_FINDITEM struct.  iStart = -1 to
//  start at beginning.
//
// int RecAct_FindItem(HWND hwnd, int iStart, const RA_FINDITEM FAR* prafi);
#define RAM_FINDITEM                            (RAM_FIRST + 8)
#define RecAct_FindItem(hwnd, iStart, prafi) \
                (int)SendMessage((hwnd), RAM_FINDITEM, (WPARAM)(int)(iStart), (LPARAM)(const RA_FINDINFO *)(prafi))

// Refresh the control.
//
// void RecAct_Refresh(HWND hwnd);
#define RAM_REFRESH                             (RAM_FIRST + 9)
#define RecAct_Refresh(hwnd) \
                SendMessage((hwnd), RAM_REFRESH, 0, 0L)


// Notification codes
//
#define RN_SELCHANGED   (RN_FIRST-0)
#define RN_ITEMCHANGED  (RN_FIRST-1)

typedef struct tagNM_RECACT
    {
    NMHDR   hdr;
    int     iItem;
    UINT    mask;           // One of RAIF_* 
    UINT    uAction;        // One of RAIA_*
    UINT    uActionOld;     // One of RAIA_*
    LPARAM  lParam;
    
    } NM_RECACT;

// Window styles
#define RAS_SINGLEITEM  0x0001L


/////////////////////////////////////////////////////  EXPORTED DATA


/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

BOOL PUBLIC RecAct_Init (HINSTANCE hinst);
void PUBLIC RecAct_Term(HINSTANCE hinst);

HRESULT PUBLIC RAI_Create(LPRA_ITEM * ppitem, LPCTSTR pszBrfPath, LPCTSTR pszPath, PRECLIST prl, PFOLDERTWINLIST pftl);
HRESULT PUBLIC RAI_CreateFromRecItem(LPRA_ITEM * ppitem, LPCTSTR pszBrfPath, PRECITEM pri);
HRESULT PUBLIC RAI_Free(LPRA_ITEM pitem);

#endif // __RECACT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\state.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: state.c
//
//  This file contains the state & .ini file routines 
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"     // common headers

/////////////////////////////////////////////////////  TYPEDEFS

#ifdef DEBUG

// Some of the .ini processing code was pimped from the sync engine.
//

typedef struct _INIKEYHEADER
{
    LPCTSTR pszSectionName;
    LPCTSTR pszKeyName;
    LPCTSTR pszDefaultRHS;
} INIKEYHEADER;

typedef struct _BOOLINIKEY
{
    INIKEYHEADER ikh;
    LPUINT puStorage;
    DWORD dwFlag;
} BOOLINIKEY;

typedef struct _INTINIKEY
{
    INIKEYHEADER ikh;
    LPUINT puStorage;
} INTINIKEY;

#endif


// Some of these macros taken from prefs.h in Pen project...
//
#define PutIniIntCmp(idsSection, idsKey, nNewValue, nSave) \
if ((nNewValue) != (nSave)) PutIniInt(idsSection, idsKey, nNewValue)

#define WritePrivateProfileInt(szApp, szKey, i, lpFileName) \
{TCHAR sz[7]; \
WritePrivateProfileString(szApp, szKey, SzFromInt(sz, i), lpFileName);}


/////////////////////////////////////////////////////  MODULE DATA

#ifdef DEBUG

// Array of keys with Integer RHSs to be processed by ProcessIniFile() 

static INTINIKEY s_rgiik[] = 
{
    {
        { c_szIniSecDebugUI,    c_szIniKeyTraceFlags, c_szZero },
        &g_uTraceFlags
    },
    
    {
        { c_szIniSecDebugUI,    c_szIniKeyDumpFlags, c_szZero },
        &g_uDumpFlags
    },
};

// Array of keys with Boolean RHSs to be processed by ProcessIniFile() 

static BOOLINIKEY s_rgbik[] =
{
    {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnOpen, c_szZero },
        &g_uBreakFlags,
        BF_ONOPEN
    },
    
    {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnClose, c_szZero },
        &g_uBreakFlags,
        BF_ONCLOSE
    },
    
    {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnRunOnce, c_szZero },
        &g_uBreakFlags,
        BF_ONRUNONCE
    },
    
    {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnValidate, c_szZero },
        &g_uBreakFlags,
        BF_ONVALIDATE
    },
    
    {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnThreadAtt, c_szZero },
        &g_uBreakFlags,
        BF_ONTHREADATT
    },
    
    {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnThreadDet, c_szZero },
        &g_uBreakFlags,
        BF_ONTHREADDET
    },
    
    {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnProcessAtt, c_szZero },
        &g_uBreakFlags,
        BF_ONPROCESSATT
    },
    
    {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnProcessDet, c_szZero },
        &g_uBreakFlags,
        BF_ONPROCESSDET
    },
};


/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszTrue[] =
{
    TEXT("1"),
    TEXT("On"),
    TEXT("True"),
    TEXT("Y"),
    TEXT("Yes")
};

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszFalse[] =
{
    TEXT("0"),
    TEXT("Off"),
    TEXT("False"),
    TEXT("N"),
    TEXT("No")
};

#endif  // DEBUG


/////////////////////////////////////////////////////  PROCEDURES


#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Determines whether a string corresponds to a boolean
TRUE value.
Returns: The boolean value (TRUE or FALSE)
Cond:    --
*/
BOOL PRIVATE IsIniYes(
                      LPCTSTR psz)
{
    int i;
    BOOL bNotFound = TRUE;
    BOOL bResult;
    
    ASSERT(psz); 
    
    /* Is the value TRUE? */
    
    for (i = 0; i < ARRAYSIZE(s_rgpszTrue); i++)
    {
        if (IsSzEqual(psz, s_rgpszTrue[i]))
        {
            bResult = TRUE;
            bNotFound = FALSE;
            break;
        }
    }
    
    /* Is the value FALSE? */
    
    if (bNotFound)
    {
        for (i = 0; i < ARRAYSIZE(s_rgpszFalse); i++)
        {
            if (IsSzEqual(psz, s_rgpszFalse[i]))
            {
                bResult = FALSE;
                bNotFound = FALSE;
                break;
            }
        }
        
        /* Is the value a known string? */
        
        if (bNotFound)
        {
            /* No.  Whine about it. */
            
            DEBUG_MSG(TF_WARNING, TEXT("IsIniYes() called on unknown Boolean RHS '%s'."), psz);
            bResult = FALSE;
        }
    }
    
    return bResult;
}


/*----------------------------------------------------------
Purpose: Process keys with boolean RHSs.
Returns: --
Cond:    --
*/
void PRIVATE ProcessBooleans(void)
{
    int i;
    
    for (i = 0; i < ARRAYSIZE(s_rgbik); i++)
    {
        DWORD dwcbKeyLen;
        TCHAR szRHS[MAXBUFLEN];
        BOOLINIKEY * pbik = &(s_rgbik[i]);
        LPCTSTR lpcszRHS;
        
        /* Look for key. */
        
        dwcbKeyLen = GetPrivateProfileString(pbik->ikh.pszSectionName,
            pbik->ikh.pszKeyName, TEXT(""), szRHS,
            ARRAYSIZE(szRHS), c_szIniFile);
        
        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = pbik->ikh.pszDefaultRHS;
        
        if (IsIniYes(lpcszRHS))
        {
            if (IsFlagClear(*(pbik->puStorage), pbik->dwFlag))
                DEBUG_MSG(TF_GENERAL, TEXT("ProcessIniFile(): %s set in %s![%s]."),
                pbik->ikh.pszKeyName,
                c_szIniFile,
                pbik->ikh.pszSectionName);
            
            SetFlag(*(pbik->puStorage), pbik->dwFlag);
        }
        else
        {
            if (IsFlagSet(*(pbik->puStorage), pbik->dwFlag))
                DEBUG_MSG(TF_GENERAL, TEXT("ProcessIniFile(): %s cleared in %s![%s]."),
                pbik->ikh.pszKeyName,
                c_szIniFile,
                pbik->ikh.pszSectionName);
            
            ClearFlag(*(pbik->puStorage), pbik->dwFlag);
        }
    }
}


/*----------------------------------------------------------
Purpose: Process keys with integer RHSs.
Returns: --
Cond:    --
*/
void PRIVATE ProcessIntegers(void)
{
    int i;
    
    for (i = 0; i < ARRAYSIZE(s_rgiik); i++)
    {
        DWORD dwcbKeyLen;
        TCHAR szRHS[MAXBUFLEN];
        INTINIKEY * piik = &(s_rgiik[i]);
        LPCTSTR lpcszRHS;
        
        /* Look for key. */
        
        dwcbKeyLen = GetPrivateProfileString(piik->ikh.pszSectionName,
            piik->ikh.pszKeyName, TEXT(""), szRHS,
            ARRAYSIZE(szRHS), c_szIniFile);
        
        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = piik->ikh.pszDefaultRHS;
        
        *(piik->puStorage) = AnsiToInt(lpcszRHS);
        
        DEBUG_MSG(TF_GENERAL, TEXT("ProcessIniFile(): %s set to %#04x."), 
            piik->ikh.pszKeyName, *(piik->puStorage));
    }
}

#endif

#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Process initialization file
Returns: TRUE if initialization is successful
Cond:    --
*/
BOOL PUBLIC ProcessIniFile(void)
{
    BOOL bResult = TRUE;
    
    // Currently, all integer keys are for DEBUG use only.
    //
    ProcessIntegers();
    
    // Currently, all boolean keys are for DEBUG use only.
    //
    ProcessBooleans();
    
    return bResult;
}


/*----------------------------------------------------------
Purpose: Copy user settings to the .ini file
Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC CommitIniFile(void)
{
    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\resids.h ===
//---------------------------------------------------------------------------
// Base values
//---------------------------------------------------------------------------

#define ID_BASE         0x1000
#define IDS_BASE        (ID_BASE + 0x0000)

//---------------------------------------------------------------------------
// Strings
//---------------------------------------------------------------------------

// Range of indexes are 0x000 - 0x7ff
#define IDS_ERR_BASE                    (IDS_BASE + 0x0000)
#define IDS_OOM_BASE                    (IDS_BASE + 0x0800)
#define IDS_MSG_BASE                    (IDS_BASE + 0x1000)
#define IDS_RANDO_BASE                  (IDS_BASE + 0x1800)

// Error strings
#define IDS_ERR_READONLY                (IDS_ERR_BASE + 0x000)
#define IDS_ERR_ADD_SUBTREECYCLE        (IDS_ERR_BASE + 0x003)
#define IDS_ERR_CORRUPTDB               (IDS_ERR_BASE + 0x004)
#define IDS_ERR_SAMEGUYIDIOT            (IDS_ERR_BASE + 0x005)
#define IDS_ERR_BOGUSVOLUME             (IDS_ERR_BASE + 0x006)
#define IDS_ERR_FULLDISK                (IDS_ERR_BASE + 0x007)
#define IDS_ERR_FULLDISKSAVE            (IDS_ERR_BASE + 0x008)
#define IDS_ERR_CANTADDBRIEFCASE        (IDS_ERR_BASE + 0x009)
#define IDS_ERR_BCALREADYEXISTS         (IDS_ERR_BASE + 0x00a)
#define IDS_ERR_CANTCREATEBC            (IDS_ERR_BASE + 0x00b)
#define IDS_ERR_BRIEFCASE_LOCKED        (IDS_ERR_BASE + 0x00c)
#define IDS_ERR_UPD_UNAVAIL_VOL         (IDS_ERR_BASE + 0x00d)
#define IDS_ERR_FILE_CHANGED            (IDS_ERR_BASE + 0x00e)
#define IDS_ERR_SOURCE_FILE             (IDS_ERR_BASE + 0x00f)
#define IDS_ERR_ADDFILE_UNAVAIL_VOL     (IDS_ERR_BASE + 0x010)
#define IDS_ERR_ADDFOLDER_UNAVAIL_VOL   (IDS_ERR_BASE + 0x011)
#define IDS_ERR_NEWER_BRIEFCASE         (IDS_ERR_BASE + 0x012)
#define IDS_ERR_ADD_READONLY            (IDS_ERR_BASE + 0x013)
#define IDS_ERR_ADD_FULLDISK            (IDS_ERR_BASE + 0x014)
#define IDS_ERR_ADD_SOURCE_FILE         (IDS_ERR_BASE + 0x015)
#define IDS_ERR_ADD_UNAVAIL_VOL         (IDS_ERR_BASE + 0x016)
#define IDS_ERR_SAVE_UNAVAIL_VOL        (IDS_ERR_BASE + 0x017)
#define IDS_ERR_CLOSE_UNAVAIL_VOL       (IDS_ERR_BASE + 0x018)
#define IDS_ERR_OPEN_UNAVAIL_VOL        (IDS_ERR_BASE + 0x019)
#define IDS_ERR_UNAVAIL_VOL             (IDS_ERR_BASE + 0x01a)
#define IDS_ERR_OPEN_SUBTREECYCLE       (IDS_ERR_BASE + 0x01b)
#define IDS_ERR_OPEN_ACCESS_DENIED      (IDS_ERR_BASE + 0x01c)
#define IDS_ERR_NO_MERGE_HANDLER        (IDS_ERR_BASE + 0x01d)
#define IDS_ERR_ADDFILE_TOOLONG         (IDS_ERR_BASE + 0x01e)
#define IDS_ERR_ADDFOLDER_TOOLONG       (IDS_ERR_BASE + 0x01f)
#define IDS_ERR_OPEN_TOOLONG            (IDS_ERR_BASE + 0x020)
#define IDS_ERR_CREATE_TOOLONG          (IDS_ERR_BASE + 0x021)
#define IDS_ERR_ADDFILE_TOOMANY         (IDS_ERR_BASE + 0x022)
#define IDS_ERR_ADDFOLDER_TOOMANY       (IDS_ERR_BASE + 0x023)
#define IDS_ERR_ADD_SYNCFOLDER          (IDS_ERR_BASE + 0x024)
#define IDS_ERR_ADD_SYNCFOLDER_SRC      (IDS_ERR_BASE + 0x025)
#define IDS_ERR_CREATE_INANOTHER        (IDS_ERR_BASE + 0x026)

#define IDS_ERR_F_CantSplit             (IDS_ERR_BASE + 0x100)
#define IDS_ERR_1_CantSplit             (IDS_ERR_BASE + 0x101)
#define IDS_ERR_2_CantSplit             (IDS_ERR_BASE + 0x102)

#define IDS_ERR_F_CorruptDB             (IDS_ERR_BASE + 0x104)
#define IDS_ERR_1_CorruptDB             (IDS_ERR_BASE + 0x105)
#define IDS_ERR_2_CorruptDB             (IDS_ERR_BASE + 0x106)

#define IDS_ERR_F_FullDiskSave          (IDS_ERR_BASE + 0x108)
#define IDS_ERR_1_FullDiskSave          (IDS_ERR_BASE + 0x109)
#define IDS_ERR_2_FullDiskSave          (IDS_ERR_BASE + 0x10a)


// Out-of-memory strings
#define IDS_OOM_ADD                     (IDS_OOM_BASE + 0x000)
#define IDS_OOM_CHANGETYPES             (IDS_OOM_BASE + 0x001)
#define IDS_OOM_STATUS                  (IDS_OOM_BASE + 0x002)
#define IDS_OOM_INFO                    (IDS_OOM_BASE + 0x003)
#define IDS_OOM_FILLTYPES               (IDS_OOM_BASE + 0x004)
#define IDS_OOM_UPDATEDIALOG            (IDS_OOM_BASE + 0x005)
#define IDS_OOM_OPENBRIEFCASE           (IDS_OOM_BASE + 0x006)
#define IDS_OOM_UPDATE                  (IDS_OOM_BASE + 0x007)
#define IDS_OOM_ADDFOLDER               (IDS_OOM_BASE + 0x008)


// Messages
#define IDS_MSG_SPECIFYTYPE             (IDS_MSG_BASE + 0x010)
#define IDS_MSG_ONDESKTOP               (IDS_MSG_BASE + 0x011)
#define IDS_MSG_ATPATH                  (IDS_MSG_BASE + 0x012)
#define IDS_MSG_CantFindOriginal        (IDS_MSG_BASE + 0x013)
#define IDS_MSG_ConfirmFileSplit        (IDS_MSG_BASE + 0x014)
#define IDS_MSG_ConfirmFolderSplit      (IDS_MSG_BASE + 0x015)
#define IDS_MSG_ConfirmMultiSplit       (IDS_MSG_BASE + 0x016)
#define IDS_MSG_FileAlreadyOrphan       (IDS_MSG_BASE + 0x017)
#define IDS_MSG_FolderAlreadyOrphan     (IDS_MSG_BASE + 0x018)
#define IDS_MSG_FileTombstone           (IDS_MSG_BASE + 0x019)
#define IDS_MSG_FolderTombstone         (IDS_MSG_BASE + 0x01a)
#define IDS_MSG_UpdateOnDock            (IDS_MSG_BASE + 0x01b)
#define IDS_MSG_UpdateBeforeUndock      (IDS_MSG_BASE + 0x01c)
#define IDS_MSG_NoMatchingFiles         (IDS_MSG_BASE + 0x01d)
#define IDS_MSG_CHECKING                (IDS_MSG_BASE + 0x01e)

#define IDS_MSG_NoFiles                 (IDS_MSG_BASE + 0x040)
#define IDS_MSG_AllOrphans              (IDS_MSG_BASE + 0x041)
#define IDS_MSG_AllUptodate             (IDS_MSG_BASE + 0x042)
#define IDS_MSG_AllSomeUnavailable      (IDS_MSG_BASE + 0x043)

// The file/folder ids below must be interleaved, with the
// folder id = the file id + 1.
#define IDS_MSG_FileOrphan              (IDS_MSG_BASE + 0x044)
#define IDS_MSG_FolderOrphan            (IDS_MSG_BASE + 0x045)
#define IDS_MSG_FileUptodate            (IDS_MSG_BASE + 0x046)
#define IDS_MSG_FolderUptodate          (IDS_MSG_BASE + 0x047)
#define IDS_MSG_FileUnavailable         (IDS_MSG_BASE + 0x048)
#define IDS_MSG_FolderUnavailable       (IDS_MSG_BASE + 0x049)
#define IDS_MSG_FolderSubfolder         (IDS_MSG_BASE + 0x04a)

#define IDS_MSG_MultiOrphans            (IDS_MSG_BASE + 0x050)
#define IDS_MSG_MultiUptodate           (IDS_MSG_BASE + 0x051)
#define IDS_MSG_MultiUptodateOrphan     (IDS_MSG_BASE + 0x052)
#define IDS_MSG_MultiUnavailable        (IDS_MSG_BASE + 0x053)
#define IDS_MSG_MultiSubfolder          (IDS_MSG_BASE + 0x054)


// Menu strings
#define IDS_MENU_REPLACE                (IDS_RANDO_BASE + 0x000)
#define IDS_MENU_CREATE                 (IDS_RANDO_BASE + 0x001)
#define IDS_MENU_WHATSTHIS              (IDS_RANDO_BASE + 0x002)
//#define IDS_MENU_HELPFINDER             (IDS_RANDO_BASE + 0x003)
#define IDS_MENU_UPDATE                 (IDS_RANDO_BASE + 0x004)
#define IDS_MENU_UPDATEALL              (IDS_RANDO_BASE + 0x005)
#define IDS_MENU_SKIP                   (IDS_RANDO_BASE + 0x006)
#define IDS_MENU_MERGE                  (IDS_RANDO_BASE + 0x007)
#define IDS_MENU_DELETE                 (IDS_RANDO_BASE + 0x008)
#define IDS_MENU_DONTDELETE             (IDS_RANDO_BASE + 0x009)

// Captions                             
#define IDS_CAP_ADD                     (IDS_RANDO_BASE + 0x010)
#define IDS_CAP_UPDATE                  (IDS_RANDO_BASE + 0x011)
#define IDS_CAP_INFO                    (IDS_RANDO_BASE + 0x012)
#define IDS_CAP_OPEN                    (IDS_RANDO_BASE + 0x013)
#define IDS_CAP_STATUS                  (IDS_RANDO_BASE + 0x014)
#define IDS_CAP_SAVE                    (IDS_RANDO_BASE + 0x015)
#define IDS_CAP_CREATE                  (IDS_RANDO_BASE + 0x016)
#define IDS_CAP_ReplaceFile             (IDS_RANDO_BASE + 0x017)    // Old
#define IDS_CAP_ReplaceFolder           (IDS_RANDO_BASE + 0x018)
#define IDS_CAP_ConfirmSplit            (IDS_RANDO_BASE + 0x019)
#define IDS_CAP_ConfirmMultiSplit       (IDS_RANDO_BASE + 0x01a)
#define IDS_CAP_Split                   (IDS_RANDO_BASE + 0x01b)
#define IDS_CAP_UpdateFmt               (IDS_RANDO_BASE + 0x01c)
#define IDS_CAP_UPDATING                (IDS_RANDO_BASE + 0x01d)
#define IDS_CAP_CHECKING                (IDS_RANDO_BASE + 0x01e)

// Random stuff
#define IDS_YES                         (IDS_RANDO_BASE + 0x100)
#define IDS_NO                          (IDS_RANDO_BASE + 0x101)
#define IDS_OK                          (IDS_RANDO_BASE + 0x102)
#define IDS_CANCEL                      (IDS_RANDO_BASE + 0x103)
#define IDS_RETRY                       (IDS_RANDO_BASE + 0x104)
#define IDS_YESTOALL                    (IDS_RANDO_BASE + 0x105)

//#define IDS_NoOriginal                  (IDS_RANDO_BASE + 0x110)    // old
#define IDS_InLocation                  (IDS_RANDO_BASE + 0x111)
#define IDS_InBriefcase                 (IDS_RANDO_BASE + 0x112)
#define IDS_BYTES                       (IDS_RANDO_BASE + 0x113)
#define IDS_BOGUSDBTEMPLATE             (IDS_RANDO_BASE + 0x114)
#define IDS_BC_DATABASE                 (IDS_RANDO_BASE + 0x115)
#define IDS_BC_NAME                     (IDS_RANDO_BASE + 0x116)
#define IDS_DATESIZELINE                (IDS_RANDO_BASE + 0x117)
#define IDS_ORDERKB                     (IDS_RANDO_BASE + 0x118)
#define IDS_ORDERMB                     (IDS_RANDO_BASE + 0x119)
#define IDS_ORDERGB                     (IDS_RANDO_BASE + 0x11a)
#define IDS_ORDERTB                     (IDS_RANDO_BASE + 0x11b)
#define IDS_BC_DATABASE_SHORT           (IDS_RANDO_BASE + 0x11c)
#define IDS_BC_NAME_SHORT               (IDS_RANDO_BASE + 0x11d)
#define IDS_ALTNAME                     (IDS_RANDO_BASE + 0x11e)

// Status Property sheet
#define IDS_STATPROP_SubfolderTwin      (IDS_RANDO_BASE + 0x300)
#define IDS_STATPROP_OrphanFolder       (IDS_RANDO_BASE + 0x301)
#define IDS_STATPROP_OrphanFile         (IDS_RANDO_BASE + 0x302)
#define IDS_STATPROP_Uptodate           (IDS_RANDO_BASE + 0x303)
#define IDS_STATPROP_PressButton        (IDS_RANDO_BASE + 0x304)
#define IDS_STATPROP_Unavailable        (IDS_RANDO_BASE + 0x305)
#define IDS_STATPROP_Update             (IDS_RANDO_BASE + 0x306)
#define IDS_STATPROP_Conflict           (IDS_RANDO_BASE + 0x307)

// Confirm Replace dialog
//#define IDS_REPLACE_ReplaceFile         (IDS_RANDO_BASE + 0x340)    // Old
//#define IDS_REPLACE_ReplaceFolder       (IDS_RANDO_BASE + 0x341)    // Old
//#define IDS_REPLACE_WithFile            (IDS_RANDO_BASE + 0x342)    // Old
//#define IDS_REPLACE_WithFolder          (IDS_RANDO_BASE + 0x343)    // Old
//#define IDS_REPLACE_ReplaceOrphan       (IDS_RANDO_BASE + 0x344)    // Old
#define IDS_MSG_ConfirmFileReplace      (IDS_RANDO_BASE + 0x345)
#define IDS_MSG_ConfirmFileReplace_RO   (IDS_RANDO_BASE + 0x346)
#define IDS_MSG_ConfirmFileReplace_Sys  (IDS_RANDO_BASE + 0x347)
#define IDS_MSG_ConfirmFolderReplace    (IDS_RANDO_BASE + 0x348)

// Update progress dialog
#define IDS_UPDATE_Copy                 (IDS_RANDO_BASE + 0x380)
#define IDS_UPDATE_Merge                (IDS_RANDO_BASE + 0x381)
#define IDS_UPDATE_Delete               (IDS_RANDO_BASE + 0x382)

// States of sync copies
#define IDS_STATE_Creates               (IDS_RANDO_BASE + 0x400)
#define IDS_STATE_Replaces              (IDS_RANDO_BASE + 0x401)
#define IDS_STATE_Skip                  (IDS_RANDO_BASE + 0x402)
#define IDS_STATE_Conflict              (IDS_RANDO_BASE + 0x403)
#define IDS_STATE_Merge                 (IDS_RANDO_BASE + 0x404)
#define IDS_STATE_Uptodate              (IDS_RANDO_BASE + 0x405)
#define IDS_STATE_NeedToUpdate          (IDS_RANDO_BASE + 0x406)
#define IDS_STATE_Orphan                (IDS_RANDO_BASE + 0x407)
#define IDS_STATE_Subfolder             (IDS_RANDO_BASE + 0x408)
#define IDS_STATE_Changed               (IDS_RANDO_BASE + 0x409)
#define IDS_STATE_Unchanged             (IDS_RANDO_BASE + 0x40a)
#define IDS_STATE_NewFile               (IDS_RANDO_BASE + 0x40b)
#define IDS_STATE_Unavailable           (IDS_RANDO_BASE + 0x40c)
#define IDS_STATE_UptodateInBrf         (IDS_RANDO_BASE + 0x40d)
#define IDS_STATE_SystemFile            (IDS_RANDO_BASE + 0x40e)
#define IDS_STATE_Delete                (IDS_RANDO_BASE + 0x40f)
#define IDS_STATE_DontDelete            (IDS_RANDO_BASE + 0x410)
#define IDS_STATE_DoesNotExist          (IDS_RANDO_BASE + 0x411)
#define IDS_STATE_Deleted               (IDS_RANDO_BASE + 0x412)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\res.h ===
//
// res.h: Declares data, defines and struct types for common code
//                                module.
//
// This file contains only #define directives, thus it can be
// included in the resource script.
//

#ifndef __RES_H__
#define __RES_H__

/////////////////////////////////////////////////////  DIALOG CONSTANTS
//
// IDD_ naming conventions: IDD_xxdd*
//
// where xx defines the control type:
//   ST: static text            
//   LB: listbox
//   CB: combobox
//   CH: checkbox
//   PB: pushbutton
//   ED: edit control
//   GB: group box
//   RB: radio button
//   IC: icon
//
// and dd is a two-letter initial for the dialog;
// and * is any other qualifier to better explain the name of control.
//


#include "resids.h"
#include "dlgids.h"


#endif // __RES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\state.h ===
//
// state.h: Declares data, defines and struct types for user state code
//          module.
//
//

#ifndef __STATE_H__
#define __STATE_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  DEFINES

/////////////////////////////////////////////////////  MACROS

/////////////////////////////////////////////////////  TYPEDEFS

typedef struct tagUSERSTATE
    {
    }
    CState,  * LPState;


/////////////////////////////////////////////////////  EXPORTED DATA

/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

#ifdef DEBUG

BOOL PUBLIC ProcessIniFile(void);
BOOL PUBLIC CommitIniFile(void);

#else

#define ProcessIniFile()
#define CommitIniFile()

#endif

#endif // __STATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\status.h ===
//
// status.h: Declares data, defines and struct types for twin property
//                                module.
//
//

#ifndef __STATUS_H__
#define __STATUS_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  DEFINES

/////////////////////////////////////////////////////  MACROS

/////////////////////////////////////////////////////  TYPEDEFS

typedef struct tagXSTAT
    {
    LPBRIEFCASESTG      pbrfstg;        // IBriefcaseStg instance

    CBS  * pcbs;
    int atomPath;

    } XSTATSTRUCT,  * LPXSTATSTRUCT;


/////////////////////////////////////////////////////  EXPORTED DATA

/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

BOOL _export CALLBACK Stat_WrapperProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


#endif // __STATUS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\status.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: status.c
//
//  This file contains the dialog code for the Status property sheet
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------


#include "brfprv.h"         // common headers
#include <brfcasep.h>

#include "res.h"
#include "recact.h"
#include <help.h>


typedef struct tagSTAT
{
    HWND        hwnd;              // dialog handle
    PPAGEDATA   ppagedata;
    FileInfo *  pfi;
    TCHAR        szFolder[MAX_PATH];
    BOOL        bInit;
} STAT, * PSTAT;

#define Stat_Pcbs(this)         ((this)->ppagedata->pcbs)
#define Stat_AtomBrf(this)      ((this)->ppagedata->pcbs->atomBrf)
#define Stat_GetPtr(hwnd)       (PSTAT)GetWindowLongPtr(hwnd, DWLP_USER)
#define Stat_SetPtr(hwnd, lp)   (PSTAT)SetWindowLongPtr(hwnd, DWLP_USER, (LRESULT)(lp))

#define LNKM_ACTIVATEOTHER      (WM_USER + 0)

/*----------------------------------------------------------
Purpose: Disable all the controls in the property page
Returns: --
Cond:    --
 */
void PRIVATE Stat_DisableAll(
        PSTAT this)
{
    HWND hwnd = this->hwnd;
    HWND hwndFocus = GetFocus();

    RecAct_DeleteAllItems(GetDlgItem(hwnd, IDC_UPDATEACTIONS));
    RecAct_Enable(GetDlgItem(hwnd, IDC_UPDATEACTIONS), FALSE);

    Button_Enable(GetDlgItem(hwnd, IDC_PBTSRECON), FALSE);
    Button_Enable(GetDlgItem(hwnd, IDC_PBTSFIND), FALSE);
    Button_Enable(GetDlgItem(hwnd, IDC_PBTSSPLIT), FALSE);

    if ( !hwndFocus || !IsWindowEnabled(hwndFocus) )
    {
        SetFocus(GetDlgItem(GetParent(hwnd), IDOK));
        SendMessage(GetParent(hwnd), DM_SETDEFID, IDOK, 0);
    }
}


/*----------------------------------------------------------
Purpose: Set the directions static text
Returns: --
Cond:    --
 */
void PRIVATE Stat_SetDirections(
        PSTAT this)
{
    HWND hwnd = this->hwnd;
    HWND hwndRA = GetDlgItem(this->hwnd, IDC_UPDATEACTIONS);
    RA_ITEM item;
    TCHAR sz[MAXBUFLEN];

    *sz = 0;

    // This function shouldn't be called if this is an orphan
    ASSERT(S_OK == PageData_Query(this->ppagedata, hwnd, NULL, NULL));

    item.mask = RAIF_INSIDE | RAIF_OUTSIDE | RAIF_ACTION;
    item.iItem = 0;

    ASSERT(RecAct_GetItemCount(hwndRA) == 1);

    if (RecAct_GetItem(hwndRA, &item))
    {
        UINT ids;

        ASSERT(IsFlagSet(item.mask, RAIF_INSIDE | RAIF_OUTSIDE));

        switch (item.uAction)
        {
            case RAIA_TOIN:
            case RAIA_TOOUT:
            case RAIA_DELETEOUT:
            case RAIA_DELETEIN:
            case RAIA_MERGE:
            case RAIA_SOMETHING:
                // Instructions to update
                if (this->ppagedata->bFolder)
                    ids = IDS_STATPROP_PressButton;
                else
                    ids = IDS_STATPROP_Update;
                break;

            case RAIA_CONFLICT:
                ids = IDS_STATPROP_Conflict;
                break;

            default:
                if (SI_UNAVAILABLE == item.siOutside.uState)
                {
                    // The original file is unavailable.  We don't know if 
                    // everything is up-to-date.
                    ids = IDS_STATPROP_Unavailable;
                }
                else
                {
                    // They are up-to-date
                    ids = IDS_STATPROP_Uptodate;
                }
                break;
        }

        SzFromIDS(ids, sz, ARRAYSIZE(sz));
    }
    Static_SetText(GetDlgItem(hwnd, IDC_STTSDIRECT), sz);
}


/*----------------------------------------------------------
Purpose: Sets the reconciliation action control

Returns: standard result
S_OK if the item is still a twin
S_FALSE if the item is an orphan

Cond:    --
 */
HRESULT PRIVATE Stat_SetRecAct(
        PSTAT this,
        PRECLIST prl,
        PFOLDERTWINLIST pftl)
{
    HRESULT hres;
    HWND hwnd = this->hwnd;
    HWND hwndRA = GetDlgItem(hwnd, IDC_UPDATEACTIONS);
    LPCTSTR pszPath = Atom_GetName(this->ppagedata->atomPath);
    RA_ITEM * pitem;

    // This function shouldn't be called if this is an orphan
    ASSERT(S_OK == PageData_Query(this->ppagedata, hwnd, NULL, NULL));

    hres = RAI_Create(&pitem, Atom_GetName(Stat_AtomBrf(this)), pszPath, 
            prl, pftl);

    if (SUCCEEDED(hres))
    {
        if (RAIA_ORPHAN == pitem->uAction)
        {
            // This is a pending orphan
            PageData_Orphanize(this->ppagedata);
            hres = S_FALSE;
        }
        else if ( !this->ppagedata->bFolder )
        {
            pitem->mask |= RAIF_LPARAM;
            pitem->lParam = (LPARAM)prl->priFirst;
        }

        if (S_OK == hres)
        {
            BOOL bEnable;
            HWND hwndFocus = GetFocus();

            // Add the item to the recact control.
            RecAct_InsertItem(hwndRA, pitem);

            // Determine the state of the buttons
            bEnable = !(pitem->uAction == RAIA_SKIP ||
                    pitem->uAction == RAIA_CONFLICT || 
                    pitem->uAction == RAIA_NOTHING);
            Button_Enable(GetDlgItem(hwnd, IDC_PBTSRECON), bEnable);

            bEnable = (SI_UNAVAILABLE != pitem->siOutside.uState);
            Button_Enable(GetDlgItem(hwnd, IDC_PBTSFIND), bEnable);

            if ( !hwndFocus || !IsWindowEnabled(hwndFocus) )
            {
                SetFocus(GetDlgItem(hwnd, IDC_PBTSSPLIT));
                SendMessage(hwnd, DM_SETDEFID, IDC_PBTSSPLIT, 0);
            }
        }
        RAI_Free(pitem);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Sets the controls in the status property page.

Returns: --
Cond:    --
 */
void PRIVATE Stat_SetControls(
        PSTAT this)
{
    HWND hwnd = this->hwnd;
    HRESULT hres;
    PRECLIST prl;
    PFOLDERTWINLIST pftl;

    // Is this a twin?
    hres = PageData_Query(this->ppagedata, hwnd, &prl, &pftl);
    if (S_OK == hres)
    {
        // Yes
        RecAct_DeleteAllItems(GetDlgItem(hwnd, IDC_UPDATEACTIONS));

        // Is it still a twin?
        hres = Stat_SetRecAct(this, prl, pftl);
        if (S_OK == hres)
        {
            // Yes
            Stat_SetDirections(this);
        }
        else if (S_FALSE == hres)
        {
            // No
            goto WipeOut;
        }
    }
    else if (S_FALSE == hres)
    {
        // No; disable the controls
        TCHAR sz[MAXBUFLEN];
WipeOut:

        Stat_DisableAll(this);

        // Is this a subfolder twin?
        if (IsSubfolderTwin(PageData_GetHbrf(this->ppagedata), 
                    Atom_GetName(this->ppagedata->atomPath)))
        {
            // Yes; use subfolder twin message.
            SzFromIDS(IDS_STATPROP_SubfolderTwin, sz, ARRAYSIZE(sz));
        }
        else
        {
            // No; use orphan message.
            if (this->ppagedata->bFolder)
                SzFromIDS(IDS_STATPROP_OrphanFolder, sz, ARRAYSIZE(sz));
            else
                SzFromIDS(IDS_STATPROP_OrphanFile, sz, ARRAYSIZE(sz));
        }
        Static_SetText(GetDlgItem(hwnd, IDC_STTSDIRECT), sz);
    }
}


/*----------------------------------------------------------
Purpose: Gets the icon of the file

Returns: HICON
Cond:    --
 */
HICON PRIVATE GetIconHelper(
        LPCTSTR pszPath)
{
    SHFILEINFO sfi;

    if (SHGetFileInfo(pszPath, 0, &sfi, sizeof(sfi), SHGFI_ICON))
    {
        return sfi.hIcon;
    }
    return NULL;
}


/*----------------------------------------------------------
Purpose: Stat WM_INITDIALOG Handler

Returns: FALSE when we assign the control focus
Cond:    --
 */
BOOL PRIVATE Stat_OnInitDialog(
        PSTAT this,
        HWND hwndFocus,
        LPARAM lParam)              // expected to be LPPROPSHEETPAGE
{
    HWND hwnd = this->hwnd;
    LPCTSTR pszPath;

    this->ppagedata = (PPAGEDATA)((LPPROPSHEETPAGE)lParam)->lParam;

    // Set up the display of the dialog
    pszPath = Atom_GetName(this->ppagedata->atomPath);

    if (SUCCEEDED(FICreate(pszPath, &this->pfi, FIF_ICON)))
    {
        Static_SetIcon(GetDlgItem(hwnd, IDC_ICTSMAIN), this->pfi->hicon);
        Static_SetText(GetDlgItem(hwnd, IDC_NAME), FIGetDisplayName(this->pfi));
    }

    // Save the folder of the twin away.
    if (pszPath)
    {
        lstrcpyn(this->szFolder, pszPath, ARRAYSIZE(this->szFolder));
    }
    else
    {
        this->szFolder[0] = 0;
    }
    if (!this->ppagedata->bFolder)
        PathRemoveFileSpec(this->szFolder);

    this->bInit = TRUE;

    return FALSE;   // we set the initial focus
}


/*----------------------------------------------------------
Purpose: PSN_SETACTIVE handler
Returns: --
Cond:    --
 */
void PRIVATE Stat_OnSetActive(
        PSTAT this)
{
    HWND hwnd = this->hwnd;

    // Cause the page to be painted right away 
    HideCaret(NULL);
    SetWindowRedraw(hwnd, TRUE);
    InvalidateRect(hwnd, NULL, TRUE);
    UpdateWindow(hwnd);

    if (this->bInit)
    {
        PageData_Init(this->ppagedata, GetParent(this->hwnd));
        this->bInit = FALSE;
    }

    ShowCaret(NULL);

    Stat_SetControls(this);
}


/*----------------------------------------------------------
Purpose: Reconcile the twins in this property sheet.  
For folder twins, we invoke the Update dialog.  
For object twins, we reconcile from here.

Returns: --
Cond:    --
 */
void PRIVATE Stat_OnUpdate(
        PSTAT this,
        PRECLIST prl)
{
    HWND hwnd = this->hwnd;
    HWND hwndRA = GetDlgItem(hwnd, IDC_UPDATEACTIONS);
    LPCTSTR pszPath = Atom_GetName(this->ppagedata->atomPath);

    if (0 == RecAct_GetItemCount(hwndRA))
        return;

    ASSERT(S_OK == PageData_Query(this->ppagedata, hwnd, NULL, NULL));

    // Is this a folder?
    if (this->ppagedata->bFolder)
    {
        // Yes; let the Update dialog do the work
        Upd_DoModal(hwnd, Stat_Pcbs(this), pszPath, 1, UF_SELECTION);
    }
    else
    {
        // No; we do the work.  
        HWND hwndProgress;

        hwndProgress = UpdBar_Show(hwnd, UB_UPDATING, 0);

        Sync_ReconcileRecList(prl, Atom_GetName(Stat_AtomBrf(this)), 
                hwndProgress, RF_DEFAULT);

        UpdBar_Kill(hwndProgress);
    }

    this->ppagedata->bRecalc = TRUE;

    PropSheet_CancelToClose(GetParent(hwnd));
}


/*----------------------------------------------------------
Purpose: Separate the twins.  
Returns: --
Cond:    --
 */
void PRIVATE Stat_OnSplit(PSTAT this)
{
    HWND hwnd = this->hwnd;
    HWND hwndRA = GetDlgItem(hwnd, IDC_UPDATEACTIONS);
    LPCTSTR pszPath = Atom_GetName(this->ppagedata->atomPath);

    if (0 == RecAct_GetItemCount(hwndRA))
        return;

    ASSERT(S_OK == PageData_Query(this->ppagedata, hwnd, NULL, NULL));

    // Was the twin successfully deleted?
    if (S_OK == Sync_Split(PageData_GetHbrf(this->ppagedata), pszPath, 1, hwnd, 0))
    {
        // Yes; remove the cache references
        CRL_Nuke(this->ppagedata->atomPath);
        Stat_DisableAll(this);

        PropSheet_CancelToClose(GetParent(hwnd));

        // Notify the shell of the change
        PathNotifyShell(pszPath, NSE_UPDATEITEM, FALSE);
    }
}


/*----------------------------------------------------------
Purpose: Attempt to bind to an object to see if it exists.

Returns: TRUE if the object exists
Cond:    --
 */
BOOL PRIVATE VerifyExists(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidl)
{
    BOOL bRet = FALSE;
    IShellFolder *psfDesktop;

    ASSERT(pidlParent);
    ASSERT(pidl);

    if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
    {
        IShellFolder *psf;
        HRESULT hres = psfDesktop->lpVtbl->BindToObject(psfDesktop, pidlParent, NULL, &IID_IShellFolder, &psf);
        if (SUCCEEDED(hres))
        {
            ULONG rgfAttr = SFGAO_VALIDATE;
            bRet = SUCCEEDED(psf->lpVtbl->GetAttributesOf(psf, 1, &pidl, &rgfAttr));
            psf->lpVtbl->Release(psf);
        }
        psfDesktop->lpVtbl->Release(psfDesktop);
    }
    return bRet;
}


/*----------------------------------------------------------
Purpose: Open a file (taken from ShellExecFile)

Returns: value of ShellExecuteEx

Cond:    --
 */
BOOL PUBLIC ExecFile(HWND hwnd, 
        LPCTSTR pszVerb, 
        LPCTSTR pszFile,        // Fully qualified and fully resolved path to the file
        LPCTSTR pszParams,
        LPCTSTR pszDir,         // If NULL then working dir is derived from lpszFile (except for UNC's)
        LPCITEMIDLIST pidl,
        int nShow)
{
    SHELLEXECUTEINFO execinfo = {0};

    execinfo.cbSize          = sizeof(execinfo);
    execinfo.hwnd            = hwnd;
    execinfo.lpVerb          = pszVerb;
    execinfo.lpFile          = pszFile;
    execinfo.lpParameters    = pszParams;
    execinfo.lpDirectory     = pszDir;
    execinfo.nShow           = nShow;
    execinfo.lpIDList        = (LPITEMIDLIST)pidl;

    if (pidl)
    {
        execinfo.fMask |= SEE_MASK_IDLIST;
    }

    return ShellExecuteEx(&execinfo);
}


/*----------------------------------------------------------
Purpose: Selects an item in the given cabinet window.  Optionally
sets it to be renamed.

This function does not verify if the window is really
a cabinet window.

Returns: --
Cond:    --
 */
void PUBLIC SelectItemInCabinet(
        HWND hwndCabinet,
        LPCITEMIDLIST pidl,
        BOOL bEdit)
{
    if (IsWindow(hwndCabinet)) 
    {
        if (pidl)
        {
            LPITEMIDLIST pidlItem;

            // we need to global clone this because hwndCabinet might be
            // in a different process...  could happen with common dialog
            pidlItem = ILGlobalClone(pidl);
            if (pidlItem) 
            {
                UINT uFlagsEx;

                if (bEdit)
                    uFlagsEx = SVSI_EDIT;
                else
                    uFlagsEx = 0;

                SendMessage(hwndCabinet, CWM_SELECTITEM, 
                        uFlagsEx | SVSI_SELECT | SVSI_ENSUREVISIBLE | 
                        SVSI_FOCUSED | SVSI_DESELECTOTHERS, 
                        (LPARAM)pidlItem);
                ILGlobalFree(pidlItem);
            }
        }
    }
}


/*----------------------------------------------------------
Purpose: Open a cabinet window and set the focus on the object.

Returns: --
Cond:    --
 */
void PUBLIC OpenCabinet(
        HWND hwnd,
        LPCITEMIDLIST pidlFolder,
        LPCITEMIDLIST pidl,
        BOOL bEdit)             // TRUE: set the focus to edit the label
{
    if (!VerifyExists(pidlFolder, pidl))
    {
        MsgBox(hwnd, MAKEINTRESOURCE(IDS_MSG_CantFindOriginal), MAKEINTRESOURCE(IDS_CAP_STATUS),
                NULL, MB_INFO);
    }
    else
    {
        HWND hwndCabinet;

        SHWaitForFileToOpen(pidlFolder, WFFO_ADD, 0L);
        if (ExecFile(hwnd, c_szOpen, NULL, NULL, NULL, pidlFolder, SW_NORMAL))
        {
            // This will wait for the window to open or time out
            // We need to disable the dialog box while we are waiting.
            DECLAREHOURGLASS;

            SetHourglass();
            EnableWindow(hwnd, FALSE);
            SHWaitForFileToOpen(pidlFolder, WFFO_REMOVE | WFFO_WAIT, WFFO_WAITTIME);
            EnableWindow(hwnd, TRUE);
            ResetHourglass();

            hwndCabinet = FindWindow(c_szCabinetClass, NULL);
        }
        else
        {
            // If it failed clear out our wait
            hwndCabinet = NULL;
            SHWaitForFileToOpen(pidlFolder, WFFO_REMOVE, 0L);
        }

        if (hwndCabinet)
        {
            SelectItemInCabinet(hwndCabinet, pidl, bEdit);

            // we need to post to the other because we can't activate another
            // thread from within a button's callback
            PostMessage(hwnd, LNKM_ACTIVATEOTHER, 0, (LPARAM)hwndCabinet);
        }
    }
}


/*----------------------------------------------------------
Purpose: Opens the cabinet with the item pointed to by the twin.
(copied and modified from link.c in shelldll)
Returns: --
Cond:    --
 */
void PRIVATE Stat_OnFind(
        PSTAT this)
{
    HWND hwnd = this->hwnd;
    HWND hwndRA = GetDlgItem(hwnd, IDC_UPDATEACTIONS);
    RA_ITEM item;

    if (0 == RecAct_GetItemCount(hwndRA))
        return;

    ASSERT(S_OK == PageData_Query(this->ppagedata, hwnd, NULL, NULL));

    item.mask = RAIF_OUTSIDE | RAIF_NAME;
    item.iItem = 0;

    if (RecAct_GetItem(hwndRA, &item))
    {
        TCHAR szCanon[MAX_PATH];
        LPITEMIDLIST pidlFolder;
        LPITEMIDLIST pidl;

        // Use UNC name to find it on the net
        BrfPathCanonicalize(item.siOutside.pszDir, szCanon, ARRAYSIZE(szCanon));
        pidlFolder = ILCreateFromPath(szCanon);
        if (pidlFolder)
        {
            pidl = ILCreateFromPath(item.pszName);
            if (pidl)
            {
                OpenCabinet(hwnd, pidlFolder, ILFindLastID(pidl), FALSE);
                ILFree(pidl);
            }
            ILFree(pidlFolder);
        }
    }
}


/*----------------------------------------------------------
Purpose: Stat WM_COMMAND Handler
Returns: --
Cond:    --
 */
void PRIVATE Stat_OnCommand(
        PSTAT this,
        int id,
        HWND hwndCtl,
        UINT uNotifyCode)
{
    PRECLIST prl;
    HRESULT hres;

    switch (id)
    {
        case IDC_PBTSRECON:
        case IDC_PBTSFIND:
        case IDC_PBTSSPLIT: 
            RETRY_BEGIN(FALSE)
            {
                hres = PageData_Query(this->ppagedata, this->hwnd, &prl, NULL);
                if (FAILED(hres))
                {
                    // Error

                    // Unavailable disk?
                    if (E_TR_UNAVAILABLE_VOLUME == hres)
                    {
                        // Yes; ask user to retry/cancel
                        int id = MsgBox(this->hwnd, MAKEINTRESOURCE(IDS_ERR_UNAVAIL_VOL),
                                MAKEINTRESOURCE(IDS_CAP_STATUS), NULL, MB_RETRYCANCEL | MB_ICONWARNING);

                        if (IDRETRY == id)
                            RETRY_SET();    // Try again
                    }
                }
            }
            RETRY_END()

                // Is this a twin?
                if (S_OK == hres)
                {
                    // Yes; do the operation
                    switch (id)
                    {
                        case IDC_PBTSRECON:
                            Stat_OnUpdate(this, prl);
                            break;

                        case IDC_PBTSFIND:
                            Stat_OnFind(this);
                            break;

                        case IDC_PBTSSPLIT:
                            Stat_OnSplit(this);
                            break;
                    }
                    Stat_SetControls(this);
                }
                else if (S_FALSE == hres)
                {
                    Stat_SetControls(this);
                }

            break;
    }
}


/*----------------------------------------------------------
Purpose: Handle RN_ITEMCHANGED
Returns: --
Cond:    --
 */
void PRIVATE Stat_HandleItemChange(
        PSTAT this,
        NM_RECACT  * lpnm)
{
    PRECITEM pri;

    ASSERT((lpnm->mask & RAIF_LPARAM) != 0);

    pri = (PRECITEM)lpnm->lParam;

    // The action has changed, update the recnode accordingly
    //
    if (lpnm->mask & RAIF_ACTION)
    {
        BOOL bEnable;
        HWND hwndFocus = GetFocus();

        Sync_ChangeRecItemAction(pri, Atom_GetName(Stat_AtomBrf(this)), 
                this->szFolder, lpnm->uAction);

        bEnable = (RAIA_SKIP != lpnm->uAction && RAIA_CONFLICT != lpnm->uAction);
        Button_Enable(GetDlgItem(this->hwnd, IDC_PBTSRECON), bEnable);

        if ( !hwndFocus || !IsWindowEnabled(hwndFocus) )
        {
            SetFocus(GetDlgItem(this->hwnd, IDC_PBTSSPLIT));
            SendMessage(this->hwnd, DM_SETDEFID, IDC_PBTSSPLIT, 0);
        }
    }
}    


/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
 */
LRESULT PRIVATE Stat_OnNotify(
        PSTAT this,
        int idFrom,
        NMHDR  * lpnmhdr)
{
    LRESULT lRet = PSNRET_NOERROR;

    switch (lpnmhdr->code)
    {
        case RN_ITEMCHANGED:
            Stat_HandleItemChange(this, (NM_RECACT  *)lpnmhdr);
            break;

        case PSN_SETACTIVE:
            Stat_OnSetActive(this);
            break;

        case PSN_KILLACTIVE:
            // N.b. This message is not sent if user clicks Cancel!
            // N.b. This message is sent prior to PSN_APPLY
            //
            break;

        case PSN_APPLY:
            break;

        default:
            break;
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: WM_DESTROY handler
Returns: --
Cond:    --
 */
void PRIVATE Stat_OnDestroy(
        PSTAT this)
{
    FIFree(this->pfi);
}


/////////////////////////////////////////////////////  EXPORTED FUNCTIONS

static BOOL s_bStatRecurse = FALSE;

LRESULT INLINE Stat_DefProc(
        HWND hDlg, 
        UINT msg,
        WPARAM wParam,
        LPARAM lParam) 
{
    ENTEREXCLUSIVE();
    {
        s_bStatRecurse = TRUE;
    }
    LEAVEEXCLUSIVE();

    return DefDlgProc(hDlg, msg, wParam, lParam); 
}


/*----------------------------------------------------------
Purpose: Real Create Folder Twin dialog proc
Returns: varies
Cond:    --
 */
LRESULT Stat_DlgProc(
        PSTAT this,
        UINT message,
        WPARAM wParam,
        LPARAM lParam)
{
    const static DWORD rgHelpIDs[] = {
        IDC_ICTSMAIN,       IDH_BFC_PROP_FILEICON,
        IDC_NAME,           IDH_BFC_PROP_FILEICON,
        IDC_STTSDIRECT,     IDH_BFC_UPDATE_SCREEN,
        IDC_UPDATEACTIONS,  IDH_BFC_UPDATE_SCREEN,      // different
        IDC_PBTSRECON,      IDH_BFC_UPDATE_BUTTON,
        IDC_PBTSSPLIT,      IDH_BFC_PROP_SPLIT_BUTTON,
        IDC_PBTSFIND,       IDH_BFC_PROP_FINDORIG_BUTTON,
        0, 0 };
        DWORD_PTR dw;

        switch (message)
        {
            HANDLE_MSG(this, WM_INITDIALOG, Stat_OnInitDialog);
            HANDLE_MSG(this, WM_COMMAND, Stat_OnCommand);
            HANDLE_MSG(this, WM_NOTIFY, Stat_OnNotify);
            HANDLE_MSG(this, WM_DESTROY, Stat_OnDestroy);

            case WM_HELP:
            dw = (DWORD_PTR)rgHelpIDs;

            if ( IDC_STATIC != ((LPHELPINFO)lParam)->iCtrlId )
                WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, dw);
            return 0;

            case WM_CONTEXTMENU:
            dw = (DWORD_PTR)rgHelpIDs;

            WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, dw);
            return 0;

            case LNKM_ACTIVATEOTHER:
            SwitchToThisWindow(GetLastActivePopup((HWND)lParam), TRUE);
            SetForegroundWindow((HWND)lParam);
            return 0;

            default:
            return Stat_DefProc(this->hwnd, message, wParam, lParam);
        }
        return 0;
}


/*----------------------------------------------------------
Purpose: Create Folder Twin Dialog Wrapper
Returns: varies
Cond:    --
 */
INT_PTR CALLBACK Stat_WrapperProc(
        HWND hDlg,          // std params
        UINT message,
        WPARAM wParam,
        LPARAM lParam)
{
    PSTAT this;

    // Cool windowsx.h dialog technique.  For full explanation, see
    //  WINDOWSX.TXT.  This supports multiple-instancing of dialogs.
    //
    ENTEREXCLUSIVE();
    {
        if (s_bStatRecurse)
        {
            s_bStatRecurse = FALSE;
            LEAVEEXCLUSIVE();
            return FALSE;
        }
    }
    LEAVEEXCLUSIVE();

    this = Stat_GetPtr(hDlg);
    if (this == NULL)
    {
        if (message == WM_INITDIALOG)
        {
            this = GAlloc(sizeof(*this));
            if (!this)
            {
                MsgBox(hDlg, MAKEINTRESOURCE(IDS_OOM_STATUS), MAKEINTRESOURCE(IDS_CAP_STATUS),
                        NULL, MB_ERROR);
                EndDialog(hDlg, IDCANCEL);
                return Stat_DefProc(hDlg, message, wParam, lParam);
            }
            this->hwnd = hDlg;
            Stat_SetPtr(hDlg, this);
        }
        else
        {
            return Stat_DefProc(hDlg, message, wParam, lParam);
        }
    }

    if (message == WM_DESTROY)
    {
        Stat_DlgProc(this, message, wParam, lParam);
        GFree(this);
        Stat_SetPtr(hDlg, NULL);
        return 0;
    }

    return SetDlgMsgResult(hDlg, message, Stat_DlgProc(this, message, wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\strings.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: string.c
//
//  This files contains common string routines
//
// History:
//  10-09-93 ScottH     Created
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers
#include "strings.h"


#ifdef NOTUSED      

static LPTSTR s_pszNextToken = NULL;        

#endif // NOTUSED


// Some of these are replacements for the C runtime routines.
//  This is so we don't have to link to the CRT libs.
//

// WARNING: all of these APIs do not setup DS, so you can not access
// any data in the default data seg of this DLL.
//
// do not create any global variables... talk to chrisg if you don't
// understand this


/*----------------------------------------------------------
Purpose: Case sensitive character comparison for DBCS

  Returns: FALSE if they match, TRUE if no match
  Cond:    --
*/
BOOL ChrCmp(
            WORD w1, 
            WORD wMatch)
{
    // Most of the time this won't match, so test it first for speed.
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}


#ifdef NOTUSED      // REARCHITECT: this is not DBCS aware
/*----------------------------------------------------------
Purpose: strtok

  Swiped from the C 7.0 runtime sources.
  
    Returns: 
    Cond:    
*/
LPTSTR PUBLIC StrTok(
                     LPTSTR psz,
                     LPCTSTR rgchTokens)
{
    TUCHAR map[32];
    LPTSTR pszToken;
    
    ZeroInit(map, map);
    
    do 
    {
        map[*rgchTokens >> 3] |= (1 << (*rgchTokens & 7));
    } while (*rgchTokens++);
    
    if (!psz)
    {
        ENTEREXCLUSIVE();
        {
            psz = s_pszNextToken;
        }
        LEAVEEXCLUSIVE();
    }
    
    while (map[*psz >> 3] & (1 << (*psz & 7)) && *psz)
        psz++;
    pszToken = psz;
    for (;; psz++)
    {
        if (map[*psz >> 3] & (1 << (*psz & 7)))
        {
            if (!*psz && psz == pszToken)
                return(NULL);
            if (*psz)
                *psz++ = TEXT('\0');
            
            ENTEREXCLUSIVE();
            {
                g_pszNextToken = psz;
            }
            LEAVEEXCLUSIVE();
            return pszToken;
        }
    }
}
#endif


/*----------------------------------------------------------
Purpose: Get a string from the resource string table.  Returned
ptr is a ptr to static memory.  The next call to this
function will wipe out the prior contents.
Returns: Ptr to string
Cond:    --
*/
LPTSTR PUBLIC SzFromIDS(
                        UINT ids,               // resource ID
                        LPTSTR pszBuf,
                        UINT cchBuf)           
{
    ASSERT(pszBuf);
    
    *pszBuf = NULL_CHAR;
    LoadString(g_hinst, ids, pszBuf, cchBuf);
    return pszBuf;
}


/*----------------------------------------------------------
Purpose: Formats a string by allocating a buffer and loading
the given resource strings to compose the string.

  Returns: the count of characters 
  
    Cond:    Caller should free the allocated buffer using GFree.
*/
BOOL PUBLIC FmtString(
                      LPCTSTR  * ppszBuf,
                      UINT idsFmt,
                      LPUINT rgids,
                      UINT cids)
{
    UINT cch = 0;
    UINT cchMax;
    LPTSTR pszBuf;
    
    ASSERT(ppszBuf);
    ASSERT(rgids);
    ASSERT(cids > 0);
    
    cchMax = (1+cids) * MAXPATHLEN;
    pszBuf = GAlloc(CbFromCch(cchMax));
    if (pszBuf)
    {
        // The first cids DWORDS are the addresses of the offset strings
        // in the buffer (passed to wvsprintf)
        LPBYTE pszMsgs = GAlloc((cids * sizeof(DWORD_PTR)) + (cids * CbFromCch(MAXPATHLEN)));
        if (pszMsgs)
        {
            TCHAR szFmt[MAXPATHLEN];
            DWORD_PTR *rgpsz = (DWORD_PTR*)pszMsgs;
            LPTSTR pszT = (LPTSTR)(pszMsgs + (cids * sizeof(DWORD_PTR)));
            UINT i;
            
            // Load the series of strings
            for (i = 0; i < cids; i++, pszT += MAXPATHLEN)
            {
                rgpsz[i] = (DWORD_PTR)pszT;
                SzFromIDS(rgids[i], pszT, MAXPATHLEN);
            }
            
            // Compose the string
            SzFromIDS(idsFmt, szFmt, ARRAYSIZE(szFmt));
            cch = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
                szFmt, 0, 0, pszBuf, cchMax, (va_list *)&rgpsz);
            ASSERT(cch <= cchMax);
            
            GFree(pszMsgs);
        }
        // pszBuf is freed by caller
    }
    
    *ppszBuf = pszBuf;
    return cch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\update.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: update.c
//
// This files contains code for the Update UI and dialog.
//
// History:
//  08-17-93 ScottH     Created.
//
//---------------------------------------------------------------------------


#include "brfprv.h"     // common headers

#include "res.h"
#include "recact.h"
#include <help.h>


// This structure contains all the important counts
// that determine the specific course of action when
// the user wants to update something.
typedef struct
{
    // These are 1 to 1
    UINT    cFiles;
    UINT    cOrphans;
    UINT    cSubfolders;

    // These are 1 to 1
    UINT    cUnavailable;
    UINT    cDoSomething;
    UINT    cConflict;
    UINT    cTombstone;
} UPDCOUNT;

// This is the structure passed to the dialog at WM_INITDIALOG
typedef struct
{
    PRECLIST lprl;              // Supplied reclist
    CBS *    pcbs;
    UINT     uFlags;            // UF_ Flags
    HDPA     hdpa;              // List of RA_ITEMs
    UINT     cDoSomething;
} XUPDSTRUCT,  * LPXUPDSTRUCT;


typedef struct tagUPD
{
    HWND hwnd;              // dialog handle

    LPXUPDSTRUCT pxupd;

} UPD, * PUPD;

#define Upd_Prl(this)           ((this)->pxupd->lprl)
#define Upd_AtomBrf(this)       ((this)->pxupd->pcbs->atomBrf)
#define Upd_GetBrfPtr(this)     Atom_GetName(Upd_AtomBrf(this))

#define Upd_GetPtr(hwnd)        (PUPD)GetWindowLongPtr(hwnd, DWLP_USER)
#define Upd_SetPtr(hwnd, lp)    (PUPD)SetWindowLongPtr(hwnd, DWLP_USER, (LRESULT)(lp))

// These flags are used for DoUpdateMsg
#define DUM_ALL             0x0001
#define DUM_SELECTION       0x0002
#define DUM_ORPHAN          0x0004
#define DUM_UPTODATE        0x0008
#define DUM_UNAVAILABLE     0x0010
#define DUM_SUBFOLDER_TWIN  0x0020

// These flags are returned by PassedSpecialCases
#define PSC_SHOWDIALOG      0x0001
#define PSC_POSTMSGBOX      0x0002


//---------------------------------------------------------------------------
// Some comments
//---------------------------------------------------------------------------

// There are several special cases and conditions which must be 
// handled.  Lets break them down now.  The case numbers on on the far
// right, and are referenced in comments thru out this file.
//
// There are two user actions: Update All and Update Selection.
//
// Update All:
// 
//               Case                                     What to do
//         -----------------                            --------------
//  A1.  * No files in the briefcase                --->  MB (messagebox)
//  A2.  * All files are orphans                    --->  MB
//       * Some files are twins and...
//          * they are all available and...
//  A3.        * they are all up-to-date            --->  MB
//  A4.        * some of them need updating         --->  Update dialog
//          * some are unavailable and...
//  A5.        * the available ones are up-to-date  --->  MB then Update 
//  A6.        * some need updating                 --->  MB then Update 
// 
//
// Update Selection:
//
//               Case                                     What to do
//         -----------------                            --------------
//       * Single selection and...
//  S1.     * is an orphan                          --->  MB
//          * is available and...
//  S2.        * up-to-date                         --->  MB
//  S3.        * needs updating                     --->  Update 
//  S4.     * is unavailable                        --->  MB then Update 
//       * Multi selection and...
//  S5.     * all are orphans                       --->  MB
//          * some (non-orphans) are unavailable and...
//             * some need updating and...
//  S6.           * none are orphans                --->  MB then Update 
//  S7.           * some are orphans                --->  MB then Update then MB
//             * the available ones are up-to-date and...
//  S8.           * none are orphans                --->  MB then Update 
//  S9.           * some are orphans                --->  MB then Update then MB
//          * all (non-orphans) are available and...
//             * some need updating and...
// S10.           * none are orphans                --->  Update 
// S11.           * some are orphans                --->  Update then MB
//             * all up-to-date and...
// S12.           * none are orphans                --->  MB
// S13.           * some are orphans                --->  MB



//---------------------------------------------------------------------------
// Dialog code
//---------------------------------------------------------------------------

/*----------------------------------------------------------
Purpose: Fill the reconciliation action listbox
Returns: TRUE on success
Cond:    --
 */
BOOL PRIVATE Upd_FillList(
        PUPD this)
{
    HWND hwndCtl = GetDlgItem(this->hwnd, IDC_UPDATEACTIONS);
    HDPA hdpa = this->pxupd->hdpa;
    int cItems;
    int i;

    cItems = DPA_GetPtrCount(hdpa);
    for (i = 0; i < cItems; i++)
    {
        RA_ITEM * pitem = DPA_FastGetPtr(hdpa, i);
        RecAct_InsertItem(hwndCtl, pitem);
        RAI_Free(pitem);
    }

    return TRUE;
}


/*----------------------------------------------------------
Purpose: Sets the Update and Cancel buttons according to the
bDisableUpdate parameter.

Returns: --
Cond:    --
 */
void PRIVATE Upd_SetExitButtons(
        PUPD this,
        BOOL bDisableUpdate)
{
    HWND hwndOK = GetDlgItem(this->hwnd, IDOK);

    // Disable the update button?
    if (bDisableUpdate)
    {
        // Yes
        if (GetFocus() == hwndOK)
        {
            SetFocus(GetDlgItem(this->hwnd, IDCANCEL));
        }
        Button_Enable(hwndOK, FALSE);
    }
    else
    {
        // No
        Button_Enable(hwndOK, TRUE);
    }
}


/*----------------------------------------------------------
Purpose: WM_INITDIALOG Handler
Returns: 
Cond:    --
 */
BOOL PRIVATE Upd_OnInitDialog(
        PUPD this,
        HWND hwndFocus,
        LPARAM lParam)
{
    HWND hwnd = this->hwnd;
    TCHAR szFmt[MAXBUFLEN];
    TCHAR sz[MAXMSGLEN];

    ASSERT(lParam != 0L);

    this->pxupd = (LPXUPDSTRUCT)lParam;

    if (Upd_FillList(this))
    {
        // Set the title caption
        wnsprintf(sz, ARRAYSIZE(sz), SzFromIDS(IDS_CAP_UpdateFmt, szFmt, ARRAYSIZE(szFmt)),
                PathFindFileName(Upd_GetBrfPtr(this)));
        SetWindowText(hwnd, sz);

        // Do any files need updating?
        if (0 == this->pxupd->cDoSomething)
        {
            // No
            Upd_SetExitButtons(this, TRUE);
        }
    }
    else
    {
        // Failed
        EndDialog(hwnd, -1);
    }
    return(TRUE);
}


/*----------------------------------------------------------
Purpose: Handle RN_ITEMCHANGED
Returns: --
Cond:    --
 */
void PRIVATE Upd_HandleItemChange(
        PUPD this,
        NM_RECACT  * lpnm)
{
    PRECITEM lpri;

    ASSERT((lpnm->mask & RAIF_LPARAM) != 0);

    lpri = (PRECITEM)lpnm->lParam;

    // The action has changed, update the recnode accordingly
    if (lpnm->mask & RAIF_ACTION)
    {
        LPCTSTR pszDir = Upd_GetBrfPtr(this);
        Sync_ChangeRecItemAction(lpri, pszDir, pszDir, lpnm->uAction);

        switch (lpnm->uActionOld)
        {
            case RAIA_TOOUT:
            case RAIA_TOIN:
            case RAIA_MERGE:
                // Is this a change from "do something" to "skip"?
                if (RAIA_SKIP == lpnm->uAction)
                {
                    // Yes
                    ASSERT(0 < this->pxupd->cDoSomething);
                    this->pxupd->cDoSomething--;
                }
                break;

            case RAIA_SKIP:
            case RAIA_CONFLICT:
                // Is this a change from "skip"/"conflict" to "do something"?
                if (RAIA_TOOUT == lpnm->uAction ||
                        RAIA_TOIN == lpnm->uAction ||
                        RAIA_MERGE == lpnm->uAction)
                {
                    // Yes
                    this->pxupd->cDoSomething++;
                }
                break;
        }

        Upd_SetExitButtons(this, 0 == this->pxupd->cDoSomething);
    }
}


/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
 */
LRESULT PRIVATE Upd_OnNotify(
        PUPD this,
        int idFrom,
        NMHDR  * lpnmhdr)
{
    LRESULT lRet = 0;

    switch (lpnmhdr->code)
    {
        case RN_ITEMCHANGED:
            Upd_HandleItemChange(this, (NM_RECACT  *)lpnmhdr);
            break;

        default:
            break;
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Info WM_COMMAND Handler
Returns: --
Cond:    --
 */
VOID PRIVATE Upd_OnCommand(
        PUPD this,
        int id,
        HWND hwndCtl,
        UINT uNotifyCode)
{
    HWND hwnd = this->hwnd;

    switch (id)
    {
        case IDOK:
        case IDCANCEL:
            EndDialog(hwnd, id);
            break;
    }
}


/*----------------------------------------------------------
Purpose: WM_DESTROY handler
Returns: --
Cond:    --
 */
void PRIVATE Upd_OnDestroy(
        PUPD this)
{
}


static BOOL s_bUpdRecurse = FALSE;

LRESULT INLINE Upd_DefProc(
        HWND hDlg, 
        UINT msg,
        WPARAM wParam,
        LPARAM lParam) 
{
    ENTEREXCLUSIVE();
    {
        s_bUpdRecurse = TRUE;
    }
    LEAVEEXCLUSIVE();

    return DefDlgProc(hDlg, msg, wParam, lParam); 
}


/*----------------------------------------------------------
Purpose: Real Create Folder Twin dialog proc
Returns: varies
Cond:    --
 */
LRESULT Upd_DlgProc(
        PUPD this,
        UINT message,
        WPARAM wParam,
        LPARAM lParam)
{
    const static DWORD rgHelpIDs[] = {
        IDC_UPDATEACTIONS,  IDH_BFC_UPDATE_SCREEN,      // different
        IDOK,               IDH_BFC_UPDATE_BUTTON,
        0, 0 };

        switch (message)
        {
            HANDLE_MSG(this, WM_INITDIALOG, Upd_OnInitDialog);
            HANDLE_MSG(this, WM_COMMAND, Upd_OnCommand);
            HANDLE_MSG(this, WM_NOTIFY, Upd_OnNotify);
            HANDLE_MSG(this, WM_DESTROY, Upd_OnDestroy);

            case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPVOID)rgHelpIDs);
            return 0;

            case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)rgHelpIDs);
            return 0;

            default:
            return Upd_DefProc(this->hwnd, message, wParam, lParam);
        }
}


/*----------------------------------------------------------
Purpose: Create Folder Twin Dialog Wrapper
Returns: varies
Cond:    --
 */
INT_PTR _export CALLBACK Upd_WrapperProc(
        HWND hDlg,      // std params
        UINT message,
        WPARAM wParam,
        LPARAM lParam)
{
    PUPD this;

    // Cool windowsx.h dialog technique.  For full explanation, see
    //  WINDOWSX.TXT.  This supports multiple-instancing of dialogs.
    //
    ENTEREXCLUSIVE();
    {
        if (s_bUpdRecurse)
        {
            s_bUpdRecurse = FALSE;
            LEAVEEXCLUSIVE();
            return FALSE;
        }
    }
    LEAVEEXCLUSIVE();

    this = Upd_GetPtr(hDlg);
    if (this == NULL)
    {
        if (message == WM_INITDIALOG)
        {
            this = GAlloc(sizeof(*this));
            if (!this)
            {
                MsgBox(hDlg, MAKEINTRESOURCE(IDS_OOM_UPDATEDIALOG), MAKEINTRESOURCE(IDS_CAP_UPDATE),
                        NULL, MB_ERROR);
                EndDialog(hDlg, IDCANCEL);
                return Upd_DefProc(hDlg, message, wParam, lParam);
            }
            this->hwnd = hDlg;
            Upd_SetPtr(hDlg, this);
        }
        else
        {
            return Upd_DefProc(hDlg, message, wParam, lParam);
        }
    }

    if (message == WM_DESTROY)
    {
        Upd_DlgProc(this, message, wParam, lParam);
        GFree(this);
        Upd_SetPtr(hDlg, NULL);
        return 0;
    }

    return SetDlgMsgResult(hDlg, message, Upd_DlgProc(this, message, wParam, lParam));
}


//---------------------------------------------------------------------------
// Update detection code
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Checks if the briefcase is empty.  This function skips the
"desktop.ini" and "Briefcase Database" files.

Returns: TRUE if the briefcase is empty

Cond:    --
 */
BOOL PRIVATE IsBriefcaseEmpty(
        LPCTSTR pszPath)
{
    BOOL bRet = FALSE;

    ASSERT(pszPath);

    if (pszPath)
    {
        // Enumerate thru folder
        TCHAR szSearch[MAXPATHLEN];
        WIN32_FIND_DATA fd;
        HANDLE hfile;
        // This must be per instance, else it will cause a fixup in 
        // shared data segment.
        const static LPCTSTR s_rgszIgnore[] = { TEXT("."), TEXT(".."), g_szDBName, g_szDBNameShort, c_szDesktopIni };

        PathCombine(szSearch, pszPath, TEXT("*.*"));
        hfile = FindFirstFile(szSearch, &fd);
        if (INVALID_HANDLE_VALUE != hfile)
        {
            BOOL bCont = TRUE;

            bRet = TRUE;        // Default to empty folder
            while (bCont)
            {
                int bIgnore = FALSE;
                int i;

                // Is this file one of the files to ignore?
                for (i = 0; i < ARRAYSIZE(s_rgszIgnore); i++)
                {
                    if (IsSzEqual(fd.cFileName, s_rgszIgnore[i]))
                    {
                        // Yes
                        bIgnore = TRUE;
                        break;
                    }
                }

                // Is this a valid file/folder?
                if (FALSE == bIgnore)
                {
                    // Yes; return the briefcase is not empty
                    bRet = FALSE;
                    bCont = FALSE;  // stop the enumeration
                }
                else
                {
                    bCont = FindNextFile(hfile, &fd);
                }
            }

            FindClose(hfile);
        }
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Create a DSA of RA_ITEMs

Sets the cDoSomething, cUnavailable, cConflict and 
cTombstone fields of pupdcount.

Returns: TRUE on success
Cond:    --
 */
HDPA PRIVATE ComposeUpdateList(
        PCBS pcbs,
        PRECLIST prl,
        UPDCOUNT * pupdcount,
        HWND hwndOwner)
{
    HRESULT hres;
    HDPA hdpa;

    ASSERT(prl);

    hdpa = DPA_Create(20);
    if (NULL != hdpa)
    {
        LPRA_ITEM pitem;
        PRECITEM pri;
        LPCTSTR pszBrf = Atom_GetName(pcbs->atomBrf);

        if (pszBrf)
        {
            DEBUG_CODE( Sync_DumpRecList(TR_SUCCESS, prl, TEXT("ComposeUpdateList")); )

                pupdcount->cUnavailable = 0;
            pupdcount->cDoSomething = 0;
            pupdcount->cTombstone = 0;
            pupdcount->cConflict = 0;

            for (pri = prl->priFirst; pri; pri = pri->priNext)
            {
                hres = RAI_CreateFromRecItem(&pitem, pszBrf, pri);
                if (SUCCEEDED(hres))
                {
                    // Is this a NOP?
                    if (RAIA_NOTHING == pitem->uAction ||
                            RAIA_ORPHAN == pitem->uAction)
                    {
                        // Yes; skip these guys altogether
                    }
                    else
                    {
                        pitem->mask |= RAIF_LPARAM;
                        pitem->lParam = (LPARAM)pri;

#ifndef NEW_REC
                        // Has the file inside or outside the briefcase been deleted?
                        if (SI_DELETED == pitem->siInside.uState ||
                                SI_DELETED == pitem->siOutside.uState)
                        {
                            // Yes
                            pupdcount->cTombstone++;
                        }
                        else
#endif
                            // Is this a file entry?
                            if (IsFileRecItem(pri))
                            {
                                // Yes; add the item to the list.  
                                pitem->iItem = 0x7fff;
                                DPA_InsertPtr(hdpa, DPA_APPEND, pitem);

                                // Is this unavailable?
                                if (RAIA_SKIP == pitem->uAction)
                                {
                                    // Yes
                                    ASSERT(SI_UNAVAILABLE == pitem->siInside.uState ||
                                            SI_UNAVAILABLE == pitem->siOutside.uState ||
                                            SI_NOEXIST == pitem->siInside.uState ||
                                            SI_NOEXIST == pitem->siOutside.uState);
                                    pupdcount->cUnavailable++;
                                }
                                else if (RAIA_CONFLICT == pitem->uAction)
                                {
                                    pupdcount->cConflict++;
                                }
                                else 
                                {
                                    pupdcount->cDoSomething++;
                                }

                                // (prevent pitem from being freed until 
                                // the dialog fills its list in Upd_FillList)
                                pitem = NULL;
                            }
                    }

                    RAI_Free(pitem);
                }
            }
        }
    }

    return hdpa;
}


/*----------------------------------------------------------
Purpose: Displays a messagebox error specific to updating files

Returns: id of button
Cond:    --
 */
int PRIVATE DoUpdateMsg(
        HWND hwndOwner,
        LPCTSTR pszPath,
        UINT cFiles,
        UINT uFlags)            // DUM_ flags
{
    UINT ids;
    UINT idi;
    int idRet;

    // Is this for Update All?
    if (IsFlagSet(uFlags, DUM_ALL))
    {
        // Yes
        idi = IDI_UPDATE_MULT;
        if (IsFlagSet(uFlags, DUM_ORPHAN))
        {
            // In this case, pszPath should be the briefcase root
            ASSERT(pszPath);

            if (IsBriefcaseEmpty(pszPath))
                ids = IDS_MSG_NoFiles;
            else
                ids = IDS_MSG_AllOrphans;
        }
        else if (IsFlagSet(uFlags, DUM_UPTODATE))
            ids = IDS_MSG_AllUptodate;
        else if (IsFlagSet(uFlags, DUM_UNAVAILABLE))
            ids = IDS_MSG_AllSomeUnavailable;
        else
        {
            ASSERT(0);  // should never get here
            ids = (UINT)-1;
        }

        idRet = MsgBox(hwndOwner, 
                MAKEINTRESOURCE(ids), 
                MAKEINTRESOURCE(IDS_CAP_UPDATE), 
                LoadIcon(g_hinst, MAKEINTRESOURCE(idi)), 
                MB_INFO);
    }
    else
    {
        // No
        TCHAR sz[MAX_PATH];

        ASSERT(0 != cFiles);
        ASSERT(pszPath);

        // Is this a single selection?
        if (1 == cFiles)
        {
            // Yes; assume it is a folder, then decrement the count
            // of the ids it is a file 
            if (IsFlagSet(uFlags, DUM_ORPHAN))
                ids = IDS_MSG_FolderOrphan;
            else if (IsFlagSet(uFlags, DUM_UPTODATE))
                ids = IDS_MSG_FolderUptodate;
            else if (IsFlagSet(uFlags, DUM_UNAVAILABLE))
                ids = IDS_MSG_FolderUnavailable;
            else if (IsFlagSet(uFlags, DUM_SUBFOLDER_TWIN))
                ids = IDS_MSG_FolderSubfolder;
            else
            {
                ASSERT(0);  // should never get here
                ids = (UINT)-1;
            }

            if (FALSE == PathIsDirectory(pszPath))
            {
                ASSERT(IsFlagClear(uFlags, DUM_SUBFOLDER_TWIN));
                ids--;      // use file-oriented messages
                idi = IDI_UPDATE_FILE;
            }
            else
            {
                idi = IDI_UPDATE_FOLDER;
            }

            idRet = MsgBox(hwndOwner, 
                    MAKEINTRESOURCE(ids), 
                    MAKEINTRESOURCE(IDS_CAP_UPDATE), 
                    LoadIcon(g_hinst, MAKEINTRESOURCE(idi)), 
                    MB_INFO,
                    PathGetDisplayName(pszPath, sz, ARRAYSIZE(sz)));
        }
        else
        {
            // No; multi selection
            idi = IDI_UPDATE_MULT;

            if (IsFlagSet(uFlags, DUM_UPTODATE))
            {
                if (IsFlagSet(uFlags, DUM_ORPHAN))
                    ids = IDS_MSG_MultiUptodateOrphan;
                else
                    ids = IDS_MSG_MultiUptodate;
            }
            else if (IsFlagSet(uFlags, DUM_ORPHAN))
                ids = IDS_MSG_MultiOrphans;
            else if (IsFlagSet(uFlags, DUM_UNAVAILABLE))
                ids = IDS_MSG_MultiUnavailable;
            else if (IsFlagSet(uFlags, DUM_SUBFOLDER_TWIN))
                ids = IDS_MSG_MultiSubfolder;
            else
            {
                ASSERT(0);  // should never get here
                ids = (UINT)-1;
            }

            idRet = MsgBox(hwndOwner, 
                    MAKEINTRESOURCE(ids), 
                    MAKEINTRESOURCE(IDS_CAP_UPDATE), 
                    LoadIcon(g_hinst, MAKEINTRESOURCE(idi)), 
                    MB_INFO,
                    cFiles);
        }
    }

    return idRet;
}


/*----------------------------------------------------------
Purpose: This function does some preliminary checks to determine
whether the dialog box needs to be invoked at all.

Sets the cOrphans and cSubfolders fields of pupdcount.

Returns: standard result
Cond:    --
 */
HRESULT PRIVATE PrepForUpdateAll(
        PCBS pcbs,
        PRECLIST * pprl,
        UPDCOUNT * pupdcount,
        HWND hwndProgress)
{
    HRESULT hres = E_FAIL;
    TWINRESULT tr;
    HWND hwndOwner = GetParent(hwndProgress);
    BOOL bAnyTwins;

    pupdcount->cSubfolders = 0;

    // Are there any twins in the database?

    tr = Sync_AnyTwins(pcbs->hbrf, &bAnyTwins);
    if (TR_SUCCESS == tr)
    {
        if (FALSE == bAnyTwins)
        {
            // No
            DoUpdateMsg(hwndOwner, Atom_GetName(pcbs->atomBrf), 1, DUM_ALL | DUM_ORPHAN);
            hres = S_FALSE;
        }

        // Can we get a fresh reclist?
        else 
        {
            pupdcount->cOrphans = 0;
            hres = Sync_CreateCompleteRecList(pcbs->hbrf, UpdBar_GetAbortEvt(hwndProgress), pprl);
            if (FAILED(hres))
            {
                // No
                if (E_TR_ABORT != hres)
                {
                    MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_OOM_UPDATEDIALOG), 
                            MAKEINTRESOURCE(IDS_CAP_UPDATE), NULL, MB_ERROR);
                }
            }
            else
            {
                // Yes
                if (*pprl)
                {
                    hres = S_OK;
                }
                else
                {
                    hres = E_UNEXPECTED;
                }
                // (reclist is freed inFinishUpdate())
            }
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: This function does some preliminary checks to determine
whether the dialog box needs to be invoked at all.

Sets the cOrphans and cSubfolders fields of pupdcount.

Returns: standard result
Cond:    --
 */
HRESULT PRIVATE PrepForUpdateSelection(
        PCBS pcbs,
        PRECLIST  * pprl,
        LPCTSTR pszList,
        UINT cFiles,
        UPDCOUNT * pupdcount,
        HWND hwndProgress)
{
    HRESULT hres;
    TWINRESULT tr;
    HTWINLIST htl;
    HWND hwndOwner = GetParent(hwndProgress);

    pupdcount->cSubfolders = 0;

    // Create a twin list
    tr = Sync_CreateTwinList(pcbs->hbrf, &htl);

    if (TR_SUCCESS != tr)
    {
        // Failure
        MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_OOM_UPDATEDIALOG), MAKEINTRESOURCE(IDS_CAP_UPDATE),
                NULL, MB_ERROR);
        hres = E_OUTOFMEMORY;
    }
    else
    {
        LPCTSTR psz;
        UINT cOrphans = 0;
        UINT cSubfolders = 0;
        UINT i;

        for (i = 0, psz = pszList; i < cFiles; i++)
        {
            // Is this object really a twin?
            if (S_FALSE == Sync_IsTwin(pcbs->hbrf, psz, 0) )
            {
                // No; is this a subfolder twin?
                if (IsSubfolderTwin(pcbs->hbrf, psz))
                {
                    // Yes
                    cSubfolders++;
                }
                else
                {
                    // No
                    cOrphans++;
                }
            }
            else 
            {
                // Yes; add it to the twin list
                Sync_AddPathToTwinList(pcbs->hbrf, htl, psz, NULL);
            }

            DataObj_NextFile(psz);      // Set psz to next file in list
        }

        // Are all the selected objects orphans?
        if (cOrphans < cFiles)
        {
            // No; create the reclist 
            hres = Sync_CreateRecListEx(htl, UpdBar_GetAbortEvt(hwndProgress), pprl);
        }
        else
        {
            // Yes
            DoUpdateMsg(hwndOwner, pszList, cFiles, DUM_SELECTION | DUM_ORPHAN);
            hres = S_FALSE;
        }
        pupdcount->cOrphans = cOrphans;
        pupdcount->cSubfolders = cSubfolders;
        Sync_DestroyTwinList(htl);          // Don't need this anymore
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Checks for the special cases that are listed at the top 
of this file.

Returns: PSC_ flags

Cond:    --
 */
UINT PRIVATE PassedSpecialCases(
        HWND hwndOwner,
        LPCTSTR pszList,
        UPDCOUNT * pupdcount,
        UINT uFlags)        // UF_ flags
{
    UINT uRet = 0;
    UINT dum = 0;
    UINT cSomeAction = pupdcount->cDoSomething + pupdcount->cConflict;

    // Is this Update All?
    if (IsFlagSet(uFlags, UF_ALL))
    {
        // Yes
        if (0 < pupdcount->cOrphans)
        {
            // Case A2
            dum = DUM_ALL | DUM_ORPHAN;
        }
        else if (0 == pupdcount->cUnavailable)
        {
            if (0 == cSomeAction)
            {
                // Case A3
                dum = DUM_ALL | DUM_UPTODATE;
            }
            else
            {
                // Case A4
                uRet = PSC_SHOWDIALOG;
            }
        }
        else
        {
            // Cases A5 and A6
            dum = DUM_ALL | DUM_UNAVAILABLE;
            uRet = PSC_SHOWDIALOG;
        }

#ifdef DEBUG

        if (IsFlagSet(g_uDumpFlags, DF_UPDATECOUNT))
        {
            TRACE_MSG(TF_ALWAYS, TEXT("Update All counts: files = %u, orphans = %u, unavailable = %u, dosomething = %u, conflict = %u, subfolders = %u"),
                    pupdcount->cFiles, pupdcount->cOrphans, 
                    pupdcount->cUnavailable, pupdcount->cDoSomething,
                    pupdcount->cConflict, pupdcount->cSubfolders);
        }

#endif
    }
    else
    {
        // No; single selection?

        // Take caution in the comparisons below.  The counts do not
        // have a 1-to-1 correspondence.  They are split into two 
        // groups:        cFiles <---> cOrphans  <---> cSubfolders
        //          cUnavailable <---> cDoSomething
        //
        // This means comparing cFiles with cDoSomething or cUnavailable
        // will produce bogus results in the case when folders are 
        // selected.
        //
        // As long as the comparisons below do not break these limits,
        // everything is okay.

        if (1 == pupdcount->cFiles)
        {
            // Yes
            ASSERT(2 > pupdcount->cOrphans);
            ASSERT(2 > pupdcount->cSubfolders);
            if (1 == pupdcount->cOrphans)
            {
                // Case S1
                dum = DUM_SELECTION | DUM_ORPHAN;
            }
            else if (0 == pupdcount->cUnavailable)
            {
                if (0 == cSomeAction)
                {
                    if (0 == pupdcount->cSubfolders)
                    {
                        // Case S2
                        dum = DUM_SELECTION | DUM_UPTODATE;
                    }
                    else
                    {
                        dum = DUM_SELECTION | DUM_SUBFOLDER_TWIN;
                    }
                }
                else
                {
                    // Case S3
                    uRet = PSC_SHOWDIALOG;
                }
            }
            else 
            {
                // Case S4
                dum = DUM_SELECTION | DUM_UNAVAILABLE;
                uRet = PSC_SHOWDIALOG;
            }
        }
        else
        {
            // No; this is a multi selection

            if (0 < pupdcount->cSubfolders)
            {
                DoUpdateMsg(hwndOwner, pszList, pupdcount->cSubfolders, DUM_SELECTION | DUM_SUBFOLDER_TWIN);
                goto Leave;  // HACK
            }

            if (pupdcount->cFiles == pupdcount->cOrphans)
            {
                // Case S5
                dum = DUM_SELECTION | DUM_ORPHAN;
            }
            else if (0 < pupdcount->cUnavailable)
            {
                if (0 < cSomeAction)
                {
                    if (0 == pupdcount->cOrphans)
                    {
                        // Case S6
                        dum = DUM_SELECTION | DUM_UNAVAILABLE;
                        uRet = PSC_SHOWDIALOG;
                    }
                    else
                    {
                        // Case S7
                        dum = DUM_SELECTION | DUM_UNAVAILABLE;
                        uRet = PSC_SHOWDIALOG | PSC_POSTMSGBOX;
                    }
                }
                else 
                {
                    if (0 == pupdcount->cOrphans)
                    {
                        // Case S8
                        dum = DUM_SELECTION | DUM_UNAVAILABLE;
                        uRet = PSC_SHOWDIALOG;
                    }
                    else
                    {
                        // Case S9
                        dum = DUM_SELECTION | DUM_UNAVAILABLE;
                        uRet = PSC_SHOWDIALOG | PSC_POSTMSGBOX;
                    }
                }
            }
            else
            {
                if (0 < cSomeAction)
                {
                    if (0 == pupdcount->cOrphans)
                    {
                        // Case S10
                        uRet = PSC_SHOWDIALOG;
                    }
                    else
                    {
                        // Case S11
                        uRet = PSC_SHOWDIALOG | PSC_POSTMSGBOX;
                    }
                }
                else 
                {
                    if (0 == pupdcount->cOrphans)
                    {
                        // Case S12
                        dum = DUM_SELECTION | DUM_UPTODATE;
                    }
                    else
                    {
                        // Case S13
                        dum = DUM_SELECTION | DUM_UPTODATE | DUM_ORPHAN;
                    }
                }
            }
        }

Leave:
        ;
#ifdef DEBUG

        if (IsFlagSet(g_uDumpFlags, DF_UPDATECOUNT))
        {
            TRACE_MSG(TF_ALWAYS, TEXT("Update selection counts: files = %u, orphans = %u, unavailable = %u, dosomething = %u, conflict = %u, subfolders = %u"),
                    pupdcount->cFiles, pupdcount->cOrphans, 
                    pupdcount->cUnavailable, pupdcount->cDoSomething,
                    pupdcount->cConflict, pupdcount->cSubfolders);
        }

#endif
    }

    if (0 != dum)
    {
        DoUpdateMsg(hwndOwner, pszList, pupdcount->cFiles, dum);
    }

    return uRet;
}


/*----------------------------------------------------------
Purpose: Show the update dialog and perform the reconcilation
if the user chooses OK

Returns: standard result
Cond:    --
 */
HRESULT PUBLIC Upd_DoModal(
        HWND hwndOwner,
        CBS * pcbs,
        LPCTSTR pszList,         // May be NULL if uFlags == UF_ALL
        UINT cFiles,
        UINT uFlags)
{
    INT_PTR nRet;
    HRESULT hres;
    PRECLIST prl;
    UPDCOUNT updcount;
    HWND hwndProgress;

    hwndProgress = UpdBar_Show(hwndOwner, UB_CHECKING, DELAY_UPDBAR);

    // Get a reclist and other useful information
    updcount.cFiles = cFiles;

    if (IsFlagSet(uFlags, UF_ALL))
    {
        hres = PrepForUpdateAll(pcbs, &prl, &updcount, hwndProgress);
    }
    else
    {
        hres = PrepForUpdateSelection(pcbs, &prl, pszList, cFiles, &updcount, hwndProgress);
    }

    UpdBar_Kill(hwndProgress);

    if (S_OK == GetScode(hres))
    {
        XUPDSTRUCT xupd;
        xupd.lprl = prl;
        xupd.pcbs = pcbs;
        xupd.uFlags = uFlags;
        xupd.hdpa = ComposeUpdateList(pcbs, prl, &updcount, hwndOwner);
        xupd.cDoSomething = updcount.cDoSomething;

        if (NULL == xupd.hdpa)
        {
            hres = E_OUTOFMEMORY;
            MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_OOM_UPDATEDIALOG), MAKEINTRESOURCE(IDS_CAP_UPDATE),
                    NULL, MB_ERROR);
        }
        else
        {
            // Check for some of those special cases listed at top of file
            UINT uVal = PassedSpecialCases(hwndOwner, pszList, &updcount, uFlags);

            // Show the update dialog?
            if (IsFlagSet(uVal, PSC_SHOWDIALOG))
            {
                // Yes
                nRet = DoModal(hwndOwner, Upd_WrapperProc, IDD_UPDATE, (LPARAM)&xupd);

                switch (nRet)
                {
                    case IDOK:
                        // Reconcile!

                        hwndProgress = UpdBar_Show(hwndOwner, UB_UPDATING, 0);

                        Sync_ReconcileRecList(prl, Atom_GetName(pcbs->atomBrf),
                                hwndProgress, RF_DEFAULT);

                        UpdBar_Kill(hwndProgress);

                        // Show a summary messagebox?
                        if (IsFlagSet(uVal, PSC_POSTMSGBOX))
                        {
                            // Yes
                            DoUpdateMsg(hwndOwner, pszList, updcount.cOrphans, DUM_SELECTION | DUM_ORPHAN);
                        }

                        // Fall thru
                        //  |    |
                        //  v    v

                    case IDCANCEL:
                        hres = NOERROR;
                        break;

                    case -1:
                        MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_OOM_UPDATEDIALOG), MAKEINTRESOURCE(IDS_CAP_UPDATE),
                                NULL, MB_ERROR);
                        hres = E_OUTOFMEMORY;
                        break;

                    default:
                        ASSERT(0);
                        break;
                }
            }

            DPA_Destroy(xupd.hdpa);
        }

        Sync_DestroyRecList(prl);
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\strings.h ===
//
// string.h: Declares data, defines and struct types for string code
//
//
#include <shlwapi.h>
#ifndef __STRING_H__
#define __STRING_H__


#define Bltbyte(rgbSrc,rgbDest,cb)  _fmemmove(rgbDest, rgbSrc, cb)

// Model independent, language-independent (DBCS aware) macros
//  taken from rcsys.h in Pen project and modified.
//
#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsCaseSzEqual(sz1, sz2)     (BOOL)(lstrcmp(sz1, sz2) == 0)
#define SzFromInt(sz, n)            (wnsprintf((LPTSTR)sz, ARRAYSIZE(sz), (LPTSTR)TEXT("%d"), n), (LPTSTR)sz)


LPTSTR   PUBLIC SzFromIDS (UINT ids, LPTSTR pszBuf, UINT cchBuf);

BOOL    PUBLIC FmtString(LPCTSTR  * ppszBuf, UINT idsFmt, LPUINT rgids, UINT cids);

#endif // __STRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\twin.h ===
//
// twin.h: Declares data, defines and struct types for twin handling
//          module.
//
//

#ifndef __TWIN_H__
#define __TWIN_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  DEFINES

#define CMP_RECNODES        1L
#define CMP_FOLDERTWINS     2L

#define OBJECT_TWIN_ATTRIBUTES   (FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_READONLY)

/////////////////////////////////////////////////////  MACROS

#ifdef DEBUG

#define Sync_Dump(lpvBuf, type)     Sync_FnDump((LPVOID)lpvBuf, sizeof(type))

extern CONST LPCTSTR rgcpcszTwinResult[];
#define SzFromTR(tr)                (rgcpcszTwinResult[(tr)])

#else

#define Sync_Dump(lpvBuf, type)
#define Sync_DumpRecItem(tr, lpri, pszMsg)
#define Sync_DumpRecNode(tr, lprn)
#define Sync_DumpRecList(tr, lprl, pszMsg)
#define SzFromTR(tr)                (tr)

#endif

// Global v-table to the engine
//

typedef struct 
    {
    HINSTANCE   hinst;

    OPENBRIEFCASEINDIRECT           OpenBriefcase;
    SAVEBRIEFCASEINDIRECT           SaveBriefcase;
    CLOSEBRIEFCASEINDIRECT          CloseBriefcase;
    DELETEBRIEFCASEINDIRECT         DeleteBriefcase;
    GETOPENBRIEFCASEINFOINDIRECT    GetOpenBriefcaseInfo;
    CLEARBRIEFCASECACHEINDIRECT     ClearBriefcaseCache;
    FINDFIRSTBRIEFCASEINDIRECT      FindFirstBriefcase;
    FINDNEXTBRIEFCASEINDIRECT       FindNextBriefcase;
    FINDBRIEFCASECLOSEINDIRECT      FindBriefcaseClose;

    ADDOBJECTTWININDIRECT           AddObjectTwin;
    ADDFOLDERTWININDIRECT           AddFolderTwin;
    RELEASETWINHANDLEINDIRECT       ReleaseTwinHandle;
    DELETETWININDIRECT              DeleteTwin;
    GETOBJECTTWINHANDLEINDIRECT     GetObjectTwinHandle;
    ISFOLDERTWININDIRECT            IsFolderTwin;
    CREATEFOLDERTWINLISTINDIRECT    CreateFolderTwinList;
    DESTROYFOLDERTWINLISTINDIRECT   DestroyFolderTwinList;
    GETFOLDERTWINSTATUSINDIRECT     GetFolderTwinStatus;
    ISORPHANOBJECTTWININDIRECT      IsOrphanObjectTwin;
    COUNTSOURCEFOLDERTWINSINDIRECT  CountSourceFolderTwins;
    ANYTWINSINDIRECT                AnyTwins;

    CREATETWINLISTINDIRECT          CreateTwinList;
    DESTROYTWINLISTINDIRECT         DestroyTwinList;
    ADDTWINTOTWINLISTINDIRECT       AddTwinToTwinList;
    ADDALLTWINSTOTWINLISTINDIRECT   AddAllTwinsToTwinList;
    REMOVETWINFROMTWINLISTINDIRECT  RemoveTwinFromTwinList;
    REMOVEALLTWINSFROMTWINLISTINDIRECT RemoveAllTwinsFromTwinList;

    CREATERECLISTINDIRECT           CreateRecList;
    DESTROYRECLISTINDIRECT          DestroyRecList;
    RECONCILEITEMINDIRECT           ReconcileItem;
    BEGINRECONCILIATIONINDIRECT     BeginReconciliation;
    ENDRECONCILIATIONINDIRECT       EndReconciliation;

    ISPATHONVOLUMEINDIRECT          IsPathOnVolume;
    GETVOLUMEDESCRIPTIONINDIRECT    GetVolumeDescription;

    } VTBLENGINE, * PVTBLENGINE;


// Function wrappers
//
//      TWINRESULT Sync_Verify(fn, args)
//          Returns the twinresult of the function that is called
//
#ifdef DEBUG
#define Sync_Verify(fn, args)  \
    (Sync_SetLastError(g_vtblEngine[0].##fn args), VERIFYSZ2(TR_SUCCESS == Sync_GetLastError(), TEXT("Assert  ") TEXT(#fn) TEXT(": %s (LastError=%ldL)"), SzFromTR(Sync_GetLastError()), GetLastError()), Sync_GetLastError())
#else
// Optimized version for retail
//
#define Sync_Verify(fn, args)  \
    Sync_SetLastError(g_vtblEngine[0].##fn args)
#endif

//      BOOL Sync_IsEngineLoaded();
//          Returns TRUE if the engine is loaded.
//
BOOL PUBLIC Sync_IsEngineLoaded();

//      TWINRESULT Sync_SetLastError(TWINRESULT tr);
//
TWINRESULT PUBLIC Sync_SetLastError(TWINRESULT tr);

//      TWINRESULT Sync_GetLastError();
//
TWINRESULT PUBLIC Sync_GetLastError(void);

//      TWINRESULT Sync_OpenBriefcase(LPCSTR pszPath, DWORD dwFlags, HWND hwndOwner, HBRFCASE FAR * lphbrf);
//
#define Sync_OpenBriefcase(lpcsz, dwflags, hwnd, lphbrf)           \
    Sync_Verify(OpenBriefcase, (lpcsz, dwflags, hwnd, lphbrf))

//      TWINRESULT Sync_SaveBriefcase(HBRFCASE hbrf);
//
#define Sync_SaveBriefcase(hbrf)             \
    Sync_Verify(SaveBriefcase, (hbrf))

//      TWINRESULT Sync_DeleteBriefcase(LPCSTR pszPath);
//
#define Sync_DeleteBriefcase(lpcsz)                 \
    Sync_Verify(DeleteBriefcase, (lpcsz))

//      TWINRESULT Sync_CloseBriefcase(HBRFCASE hbrf);
//
#define Sync_CloseBriefcase(hbrf)                   \
    Sync_Verify(CloseBriefcase, (hbrf))

//      TWINRESULT Sync_GetOpenBriefcaseInfo(HBRFCASE hbrf, POPENBRFCASEINFO pinfo);
//
#define Sync_GetOpenBriefcaseInfo(hbrf, pinfo)          \
    Sync_Verify(GetOpenBriefcaseInfo, (hbrf, pinfo))

//      TWINRESULT Sync_ClearBriefcaseCache(HBRFCASE hbrf);
//
#define Sync_ClearBriefcaseCache(hbrf)                   \
    Sync_Verify(ClearBriefcaseCache, (hbrf))

//      TWINRESULT Sync_FindFirst(PHBRFCASEITER phbrfiter, PBRFCASEINFO pinfo);
//
#define Sync_FindFirst(phbrfiter, pinfo)            \
    Sync_Verify(FindFirstBriefcase, (phbrfiter, pinfo))

//      TWINRESULT Sync_FindNext(HBRFCASEITER hbrfiter, PBRFCASEINFO pinfo);
//
#define Sync_FindNext(hbrfiter, pinfo)            \
    Sync_Verify(FindNextBriefcase, (hbrfiter, pinfo))

//      TWINRESULT Sync_FindClose(HBRFCASEITER hbrfiter);
//
#define Sync_FindClose(hbrfiter)            \
    Sync_Verify(FindBriefcaseClose, (hbrfiter))

//      TWINRESULT Sync_AddObject(HBRFCASE hbrf, LPNEWOBJECTTWIN lpnot, HTWIN FAR * lphtfam);
//
#define Sync_AddObject(hbrf, lpnot, lphtfam)        \
    Sync_Verify(AddObjectTwin, (hbrf, lpnot, lphtfam))

//      TWINRESULT Sync_AddFolder(HBRFCASE hbrf, LPNEWFOLDERTWIN lpnft, HTWIN FAR * lphft);
//
#define Sync_AddFolder(hbrf, lpnft, lphft)          \
    Sync_Verify(AddFolderTwin, (hbrf, lpnft, lphft))

//      TWINRESULT Sync_ReleaseTwin(HTWIN htwin);
//
#define Sync_ReleaseTwin(htwin)                     \
    Sync_Verify(ReleaseTwinHandle, ((HTWIN)htwin))

//      TWINRESULT Sync_DeleteTwin(HTWIN htwin);
//
#define Sync_DeleteTwin(htwin)                      \
    Sync_Verify(DeleteTwin, ((HTWIN)htwin))

//      TWINRESULT Sync_AnyTwins(HBRFCASE hbrf, BOOL FAR * lpb);
//
#define Sync_AnyTwins(hbrf, lpb)                    \
    Sync_Verify(AnyTwins, (hbrf, lpb))

//      TWINRESULT Sync_CountSourceFolders(HOBJECTTWIN hot, ULONG FAR * lpulcSource);
//
#define Sync_CountSourceFolders(hot, lpulcSource)   \
    Sync_Verify(CountSourceFolderTwins, (hot, lpulcSource))

//      TWINRESULT Sync_IsExplicitObject(HOBJECTTWIN hot, BOOL FAR * lpb);
//
#define Sync_IsExplicitObject(hot, lpb)               \
    Sync_Verify(IsOrphanObjectTwin, (hot, lpb))

//      TWINRESULT Sync_GetObject(HBRFCASE hbrf, LPCSTR pszDir, LPCSTR pszName, HOBJECTTWIN FAR * lphot);
//
#define Sync_GetObject(hbrf, lpszFolder, lpszName, lphot)   \
    Sync_Verify(GetObjectTwinHandle, (hbrf, lpszFolder, lpszName, lphot))

//      TWINRESULT Sync_IsFolder(HBRFCASE hbrf, LPCSTR pszFolder, BOOL FAR * lpb);
//
#define Sync_IsFolder(hbrf, lpszFolder, lpb)        \
    Sync_Verify(IsFolderTwin, (hbrf, lpszFolder, lpb))

//      TWINRESULT Sync_GetFolderTwinStatus(HFOLDERTWIN hft, CREATERECLISTPROC crlp, LPARAM lpCallbackData, PFOLDERTWINSTATUS pfts);
//
#ifdef NEW_REC

#define Sync_GetFolderTwinStatus(hft, crlp, lpcb, pfts)        \
    Sync_Verify(GetFolderTwinStatus, (hft, crlp, lpcb, pfts))

#else

#define Sync_GetFolderTwinStatus(hft, crlp, lpcb, pfts)        \
    Sync_Verify(GetFolderTwinStatus, (hft, crlp, lpcb, CRL_FLAGS, pfts))

#endif

//      TWINRESULT Sync_CreateFolderList(HBRFCASE hbrf, LPCSTR pszDir, LPFOLDERTWINLIST FAR * lplpftl);
//
#define Sync_CreateFolderList(hbrf, lpszFolder, lplpftl)    \
    Sync_Verify(CreateFolderTwinList, (hbrf, lpszFolder, lplpftl))

//      TWINRESULT Sync_DestroyFolderList(LPFOLDERTWINLIST lpftl);
//
#define Sync_DestroyFolderList(lpftl)               \
    Sync_Verify(DestroyFolderTwinList, (lpftl))

//      TWINRESULT Sync_CreateTwinList(HBRFCASE hbrf, LPHTWINLIST lphtl);
//
#define Sync_CreateTwinList(hbrf, lphtl)            \
    Sync_Verify(CreateTwinList, (hbrf, lphtl))

//      TWINRESULT Sync_DestroyTwinList(HTWINLIST htl);
//
#define Sync_DestroyTwinList(htl)                   \
    Sync_Verify(DestroyTwinList, (htl))

//      TWINRESULT Sync_AddToTwinList(HTWINLIST htl, HTWIN htwin);
//
#define Sync_AddToTwinList(htl, htwin)              \
    Sync_Verify(AddTwinToTwinList, (htl, (HTWIN)htwin))

//      TWINRESULT Sync_AddAllToTwinList(HTWINLIST htl);
//
#define Sync_AddAllToTwinList(htl)                  \
    Sync_Verify(AddAllTwinsToTwinList, (htl))

//      TWINRESULT Sync_RemoveFromTwinList(HTWINLIST htl, HTWIN htwin);
//
#define Sync_RemoveFromTwinList(htl, htwin)         \
    Sync_Verify(RemoveTwinFromTwinList, (htl, (HTWIN)htwin))

//      TWINRESULT Sync_RemoveAllFromTwinList(HTWINLIST htl);
//
#define Sync_RemoveAllFromTwinList(htl)             \
    Sync_Verify(RemoveAllTwinsFromTwinList, (htl))

//      TWINRESULT Sync_CreateRecList(HTWINLIST htl, CREATERECLISTPROC crlp, LPARAM lpcb, LPRECLIST FAR * lplprl);
//
#ifdef NEW_REC

#define Sync_CreateRecList(htl, crlp, lpcb, lplprl)            \
    Sync_Verify(CreateRecList, (htl, crlp, lpcb, lplprl))

#else

#define Sync_CreateRecList(htl, crlp, lpcb, lplprl)            \
    Sync_Verify(CreateRecList, (htl, crlp, lpcb, CRL_FLAGS, lplprl))

#endif

//      TWINRESULT Sync_DestroyRecList(LPRECLIST lprl);
//
#define Sync_DestroyRecList(lprl)                   \
    Sync_Verify(DestroyRecList, (lprl))

//      TWINRESULT Sync_BeginRec(HBRFCASE hbrf);
//
#define Sync_BeginRec(hbrf)                         \
    Sync_Verify(BeginReconciliation, (hbrf))

//      TWINRESULT Sync_EndRec(HBRFCASE hbrf);
//
#define Sync_EndRec(hbrf)                           \
    Sync_Verify(EndReconciliation, (hbrf))

//      TWINRESULT Sync_ReconcileItem(LPRECITEM lpri, RECSTATUSPROC rsp, LPARAM lpCallbackData, DWORD dwFlags, HWND hwndOwner, HWND hwndStatusText);
//
#define Sync_ReconcileItem(lpri, rsp, lpcb, flags, hwnd, hwndStatusText)    \
    Sync_Verify(ReconcileItem, (lpri, rsp, lpcb, flags, hwnd, hwndStatusText))

//      BOOL Sync_IsPathOnVolume(LPCSTR pszPath, HVOLUMEID hvid);
//
#define Sync_IsPathOnVolume(pszPath, hvid, pbool)      \
    Sync_Verify(IsPathOnVolume, (pszPath, hvid, pbool))

//      BOOL Sync_GetVolumeDecription(HVOLUMEID hvid, PVOLUMEDESC pvd);
//
#define Sync_GetVolumeDescription(hvid, pvd)      \
    Sync_Verify(GetVolumeDescription, (hvid, pvd))


#ifdef NEW_REC

// Returns TRUE if the recitem is referring to a file (not a folder)
#define IsFileRecItem(pri)    (0 != *(pri)->pcszName)

#else

#define IsFileRecItem(pri)    TRUE

#endif


extern const TCHAR szAll[];

extern VTBLENGINE g_vtblEngine[1];

int CALLBACK _export NCompareFolders (LPVOID lpv1, LPVOID lpv2, LPARAM lParam);

// Structure for the ChooseSide functions
typedef struct tagCHOOSESIDE
    {
    DWORD       dwFlags;        // CSF_* flags
    int         nRank;          // Higher means better choice

    HTWIN       htwin;
    HVOLUMEID   hvid;
    LPCTSTR      pszFolder;
    PRECNODE    prn;            // Only if CSF_FOLDER is clear
    } CHOOSESIDE, * PCHOOSESIDE;

#define CSF_FOLDER      0x0001
#define CSF_INSIDE      0x0002      // Ranking for inside

#ifdef DEBUG
void    PUBLIC ChooseSide_DumpList(HDSA hdsa);
#endif

void    PUBLIC ChooseSide_InitAsFile(HDSA hdsa, PRECITEM pri);
HRESULT PUBLIC ChooseSide_CreateEmpty(HDSA * phdsa);
HRESULT PUBLIC ChooseSide_CreateAsFile(HDSA * phdsa, PRECITEM pri);
HRESULT PUBLIC ChooseSide_CreateAsFolder(HDSA * phdsa, PFOLDERTWINLIST pftl);
BOOL    PUBLIC ChooseSide_GetBest(HDSA hdsa, LPCTSTR pszBrfPath, LPCTSTR pszFolder, PCHOOSESIDE * ppchside);
BOOL    PUBLIC ChooseSide_GetNextBest(HDSA hdsa, PCHOOSESIDE * ppchside);
void    PUBLIC ChooseSide_Free(HDSA hdsa);


HRESULT PUBLIC Sync_GetNodePair(PRECITEM pri, LPCTSTR pszBrfPath, LPCTSTR pszFolder, PRECNODE  * pprnInside, PRECNODE  * pprnOutside);
void    PUBLIC Sync_ChangeRecItemAction(PRECITEM pri, LPCTSTR pszBrfPath, LPCTSTR pszInsideDir, UINT uAction);

BOOL PUBLIC Sync_QueryVTable();
void PUBLIC Sync_ReleaseVTable();

BOOL PUBLIC Sync_AddPathToTwinList(HBRFCASE hbrf, HTWINLIST htl, LPCTSTR lpcszPath, PFOLDERTWINLIST  * lplpftl);

HRESULT PUBLIC Sync_CreateCompleteRecList(HBRFCASE hbrf, PABORTEVT pabortevt, PRECLIST * pprl);
HRESULT PUBLIC Sync_CreateRecListEx(HTWINLIST htl, PABORTEVT pabortevt, PRECLIST * pprl);

// Flags for Sync_ReconcileRecList
#define RF_DEFAULT      0x0000
#define RF_ONADD        0x0001

HRESULT PUBLIC Sync_ReconcileRecList (PRECLIST lprl, LPCTSTR pszPathBrf, HWND hwndParent, UINT uFlags);

// Flags for Sync_Split
#define SF_NOCONFIRM    0x0001
#define SF_QUIET        0x0002

// Flags for Sync_IsTwin and Sync_Split
#define SF_ISFOLDER     0x1000
#define SF_ISFILE       0x2000
#define SF_ISTWIN       0x4000
#define SF_ISNOTTWIN    0x8000

HRESULT PUBLIC Sync_IsTwin (HBRFCASE hbrf, LPCTSTR lpcszPath, UINT uFlags);
HRESULT PUBLIC Sync_Split (HBRFCASE hbrf, LPCTSTR pszList, UINT cFiles, HWND hwndOwner, UINT uFlags);

ULONG   PUBLIC CountActionItems(PRECLIST prl);

#ifdef DEBUG
void PUBLIC Sync_FnDump (LPVOID lpvBuf, UINT cbBuf);
void PUBLIC Sync_DumpRecItem (TWINRESULT tr, PRECITEM lpri, LPCTSTR pszMsg);
void PUBLIC Sync_DumpRecNode (TWINRESULT tr, PRECNODE lprn);
void PUBLIC Sync_DumpRecList(TWINRESULT tr, PRECLIST lprl, LPCTSTR pszMsg);
void PUBLIC Sync_DumpFolderTwin(PCFOLDERTWIN pft);
void PUBLIC Sync_DumpFolderTwinList(PFOLDERTWINLIST pftl, LPCTSTR pszMsg);
#endif

#endif // __TWIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\twin.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: twin.c
//
//  This file contains special twin handling functions.
//
//   (Even though we've moved to a briefcase metaphor,
//    we still refer to twins internally...)
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------


#include "brfprv.h"         // common headers

#include "res.h"
#include "recact.h"


// APPCOMPAT: due to a compiler bug, we need to declare this structure
// as a 1-element array because it has pointers to functions in it
// and it is in another datasegment.
VTBLENGINE g_vtblEngine[1] = { { 0 } };    // per-instance v-table

#define GetFunction(rgtable, name, type)     \
    ((rgtable).##name = (type)GetProcAddress((rgtable).hinst, #name)); \
ASSERT((rgtable).##name)

#ifdef DEBUG
#define SzTR(tr)    #tr,
#endif

#define MAX_RANGE       0x7fff

    // Recitem dwUser values
#define RIU_CHANGED     1
#define RIU_SKIP        2
#define RIU_SHOWSTATUS  3


    /*----------------------------------------------------------
      Purpose: Compare two structures by folder name
      Returns: -1 if <, 0 if ==, 1 if >
      Cond:    --
     */
    int CALLBACK _export NCompareFolders(
            LPVOID lpv1,
            LPVOID lpv2,
            LPARAM lParam)      // One of: CMP_RECNODES, CMP_FOLDERTWINS
{
    switch (lParam)
    {
        case CMP_RECNODES:
            return lstrcmpi(((PRECNODE)lpv1)->pcszFolder, ((PRECNODE)lpv2)->pcszFolder);

        case CMP_FOLDERTWINS:
            return lstrcmpi(((PCFOLDERTWIN)lpv1)->pcszOtherFolder, ((PCFOLDERTWIN)lpv2)->pcszOtherFolder);

        default:
            ASSERT(0);      // should never get here
    }
    return 0;
}


//---------------------------------------------------------------------------
// Choose side functions
//---------------------------------------------------------------------------


#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Dump a CHOOSESIDE structure
Returns: --
Cond:    --
 */
void PRIVATE ChooseSide_Dump(
        PCHOOSESIDE pchside)
{
    BOOL bDump;
    TCHAR szBuf[MAXMSGLEN];

    ASSERT(pchside);

#define szDumpLabel     TEXT("             *** ")
#define szDumpMargin    TEXT("                 ")

    ENTEREXCLUSIVE();
    {
        bDump = IsFlagSet(g_uDumpFlags, DF_CHOOSESIDE);
    }
    LEAVEEXCLUSIVE();

    if (bDump)
    {
        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.pszFolder = {%s}\r\n"), (LPTSTR)szDumpLabel, pchside->pszFolder);
        OutputDebugString(szBuf);

        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.dwFlags = 0x%lx\r\n"), (LPTSTR)szDumpMargin, pchside->dwFlags);
        OutputDebugString(szBuf);

        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.nRank = %ld\r\n"), (LPTSTR)szDumpMargin, pchside->nRank);
        OutputDebugString(szBuf);
    }

#undef szDumpLabel
#undef szDumpMargin
}


/*----------------------------------------------------------
Purpose: Dump a CHOOSESIDE list
Returns: --
Cond:    --
 */
void PUBLIC ChooseSide_DumpList(
        HDSA hdsa)
{
    BOOL bDump;
    TCHAR szBuf[MAXMSGLEN];

    ASSERT(hdsa);

#define szDumpLabel     TEXT("Dump CHOOSESIDE list: ")

    ENTEREXCLUSIVE();
    {
        bDump = IsFlagSet(g_uDumpFlags, DF_CHOOSESIDE);
    }
    LEAVEEXCLUSIVE();

    if (bDump)
    {
        int i;
        int cel = DSA_GetItemCount(hdsa);
        PCHOOSESIDE pchside;

        wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.count = %lu\r\n"), (LPTSTR)szDumpLabel, cel);
        OutputDebugString(szBuf);

        if (NULL != (pchside = DSA_GetItemPtr(hdsa, 0)))
        {
            if (IsFlagSet(pchside->dwFlags, CSF_INSIDE))
                OutputDebugString(TEXT("Rank for inside\r\n"));
            else
                OutputDebugString(TEXT("Rank for outside\r\n"));
        }

        for (i = 0; i < cel; i++)
        {
            pchside = DSA_GetItemPtr(hdsa, i);

            ChooseSide_Dump(pchside);
        }
    }

#undef szDumpLabel
}

#endif


/*----------------------------------------------------------
Purpose: Initialize an array of CHOOSESIDE elements from a 
recitem list.  Array is unsorted.

Returns: --

Cond:    The contents of the array are safe as long as the 
recitem list lives.

 */
void PUBLIC ChooseSide_InitAsFile(
        HDSA hdsa,
        PRECITEM pri)
{
    CHOOSESIDE chside;
    PRECNODE prn;

    ASSERT(hdsa);
    ASSERT(pri);

    DSA_DeleteAllItems(hdsa);

    // All entries start with these values
    chside.dwFlags = 0;
    chside.nRank = 0;

    // Add each recnode
    for (prn = pri->prnFirst; prn; prn = prn->prnNext)
    {
        chside.htwin = (HTWIN)prn->hObjectTwin;
        chside.hvid = prn->hvid;
        chside.pszFolder = prn->pcszFolder;
        chside.prn = prn;

        DSA_InsertItem(hdsa, 0x7fff, &chside);
    }
}


/*----------------------------------------------------------
Purpose: Create an array of CHOOSESIDE elements from a recitem
list.  Array is unsorted.

Returns: standard result

Cond:    The contents of the array are safe as long as the 
recitem list lives.

 */
HRESULT PUBLIC ChooseSide_CreateAsFile(
        HDSA * phdsa,
        PRECITEM pri)
{
    HRESULT hres;
    HDSA hdsa;

    ASSERT(phdsa);
    ASSERT(pri);

    hdsa = DSA_Create(sizeof(CHOOSESIDE), (int)pri->ulcNodes);
    if (hdsa)
    {
        ChooseSide_InitAsFile(hdsa, pri);
        hres = NOERROR;
    }
    else
        hres = E_OUTOFMEMORY;

    *phdsa = hdsa;

    return hres;
}


/*----------------------------------------------------------
Purpose: Create an empty array of CHOOSESIDE elements.

Returns: standard result
Cond:    --
 */
HRESULT PUBLIC ChooseSide_CreateEmpty(
        HDSA * phdsa)
{
    HRESULT hres;
    HDSA hdsa;

    ASSERT(phdsa);

    hdsa = DSA_Create(sizeof(CHOOSESIDE), 4);
    if (hdsa)
    {
        hres = NOERROR;
    }
    else
        hres = E_OUTOFMEMORY;

    *phdsa = hdsa;

    return hres;
}


/*----------------------------------------------------------
Purpose: Create an array of CHOOSESIDE elements from a foldertwin
list.  Array is unsorted.

Returns: standard result

Cond:    The contents of the array are safe as long as the 
foldertwin list lives.

 */
HRESULT PUBLIC ChooseSide_CreateAsFolder(
        HDSA * phdsa,
        PFOLDERTWINLIST pftl)
{
    HRESULT hres;
    HDSA hdsa;
    CHOOSESIDE chside;

    ASSERT(pftl);

    hdsa = DSA_Create(sizeof(chside), (int)pftl->ulcItems);
    if (hdsa)
    {
        PCFOLDERTWIN pft;
        LPCTSTR pszFolderLast = NULL;

        // All entries start with these values
        chside.dwFlags = CSF_FOLDER;
        chside.nRank = 0;
        chside.prn = NULL;

        // Special case the source folder
        chside.htwin = (HTWIN)pftl->pcftFirst->hftSrc;
        chside.hvid = pftl->pcftFirst->hvidSrc;
        chside.pszFolder = pftl->pcftFirst->pcszSrcFolder;

        // (Don't care if this fails)
        DSA_InsertItem(hdsa, 0x7fff, &chside);

        // Add the other folders (duplicates skipped)
        for (pft = pftl->pcftFirst; pft; pft = pft->pcftNext)
        {
            // Duplicate?
            if (pszFolderLast && IsSzEqual(pszFolderLast, pft->pcszOtherFolder))
                continue;   // Yes (hack: the engine gives us a sorted list)

            chside.htwin = (HTWIN)pft->hftOther;
            chside.hvid = pft->hvidOther;
            chside.pszFolder = pft->pcszOtherFolder;

            DSA_InsertItem(hdsa, 0x7fff, &chside);

            pszFolderLast = pft->pcszOtherFolder;
        }
        *phdsa = hdsa;
        hres = NOERROR;
    }
    else
        hres = E_OUTOFMEMORY;

    return hres;
}


/*----------------------------------------------------------
Purpose: Reset the ranks

Returns: --
Cond:    --
 */
void PRIVATE ChooseSide_ResetRanks(
        HDSA hdsa)
{
    int i;
    int cel;

    ASSERT(hdsa);

    cel = DSA_GetItemCount(hdsa);
    for (i = 0; i < cel; i++)
    {
        PCHOOSESIDE pchside = DSA_GetItemPtr(hdsa, i);
        ASSERT(pchside);
        pchside->nRank = 0;
    }
}


/*----------------------------------------------------------
Purpose: Determine ranks based on whether each element in the
array is inside the briefcase.

Returns: --
Cond:    --
 */
void PRIVATE ChooseSide_RankForInside(
        HDSA hdsa,
        LPCTSTR pszBrfPath,      // Root path of briefcase
        LPCTSTR pszFolder)       // If NULL, choose best outside element
{
    int i;
    int cel;
    int cchLast = 0;
    PCHOOSESIDE pchsideLast;

    ASSERT(hdsa);
    ASSERT(pszBrfPath);
    ASSERT(pszFolder);
    ASSERT(PathIsPrefix(pszBrfPath, pszFolder));

    cel = DSA_GetItemCount(hdsa);
    for (i = 0; i < cel; i++)
    {
        PCHOOSESIDE pchside = DSA_GetItemPtr(hdsa, i);
        ASSERT(pchside);
        DEBUG_CODE( SetFlag(pchside->dwFlags, CSF_INSIDE); )

            // Is this item inside this briefcase?
            if (PathIsPrefix(pszBrfPath, pchside->pszFolder))
                pchside->nRank++;       // Yes

        // Is this item inside this folder?
        if (PathIsPrefix(pszFolder, pchside->pszFolder))
        {
            int cch = lstrlen(pchside->pszFolder);

            pchside->nRank++;       // Yes; even better

            if (0 == cchLast)
            {
                cchLast = cch;
                pchsideLast = pchside;
            }
            else 
            {
                // Is this path deeper than the last prefix-matching path?
                // (the path closer to the top is better)
                if (cch > cchLast)
                {
                    // Yes; demote this one 
                    pchside->nRank--;
                }
                else
                {
                    // No; demote previous one
                    ASSERT(pchsideLast);
                    pchsideLast->nRank--;

                    cchLast = cch;
                    pchsideLast = pchside;
                }
            }
        }

    }
}


/*----------------------------------------------------------
Purpose: Determine ranks based on whether each element in the
array is outside the briefcase.

Returns: --
Cond:    --
 */
void PRIVATE ChooseSide_RankForOutside(
        HDSA hdsa,
        LPCTSTR pszBrfPath)      // Root path of briefcase
{
    int i;
    int cel;

    ASSERT(hdsa);
    ASSERT(pszBrfPath);

    cel = DSA_GetItemCount(hdsa);
    for (i = 0; i < cel; i++)
    {
        PCHOOSESIDE pchside = DSA_GetItemPtr(hdsa, i);
        ASSERT(pchside);
        DEBUG_CODE( ClearFlag(pchside->dwFlags, CSF_INSIDE); )

            // Is this item NOT in this briefcase?
            if ( !PathIsPrefix(pszBrfPath, pchside->pszFolder) )
            {
                // Yes
                int nDriveType = DRIVE_UNKNOWN;
                int ndrive = PathGetDriveNumber(pchside->pszFolder);

                if (-1 != ndrive)
                {
                    nDriveType = DriveType(ndrive);
                }

                pchside->nRank += 2;

                if (IsFlagClear(pchside->dwFlags, CSF_FOLDER))
                {
                    // Is the file unavailable?
                    if (RNS_UNAVAILABLE == pchside->prn->rnstate ||
                            FS_COND_UNAVAILABLE == pchside->prn->fsCurrent.fscond)
                    {
                        // Yes; demote
                        pchside->nRank--;
                    }
                }
                else
                {
                    // Is the folder unavailable?
                    FOLDERTWINSTATUS uStatus;

                    Sync_GetFolderTwinStatus((HFOLDERTWIN)pchside->htwin, NULL, 0, 
                            &uStatus);
                    if (FTS_UNAVAILABLE == uStatus)
                    {
                        // Yes; demote
                        pchside->nRank--;
                    }
                }

                // Rank on locality of disk (the closer the better)
                if (DRIVE_REMOVABLE == nDriveType || DRIVE_CDROM == nDriveType)
                    ;                       // Floppy/removable (do nothing)
                else if (PathIsUNC(pchside->pszFolder) || IsNetDrive(ndrive))
                    pchside->nRank++;       // Net
                else
                    pchside->nRank += 2;    // Fixed disk
            }

    }
}


/*----------------------------------------------------------
Purpose: Choose the element with the highest rank.

Returns: TRUE if any element distinguished itself

Cond:    --
 */
BOOL PRIVATE ChooseSide_GetBestRank(
        HDSA hdsa,
        PCHOOSESIDE * ppchside)
{
    BOOL bRet;
    int i;
    int cel;
    int nRankCur = 0;       // (start at 0 since 0 is not good enough to pass muster)
    DEBUG_CODE( BOOL bDbgDup = FALSE; )

        ASSERT(hdsa);
    ASSERT(ppchside);

    *ppchside = NULL;

    cel = DSA_GetItemCount(hdsa);
    for (i = 0; i < cel; i++)
    {
        PCHOOSESIDE pchside = DSA_GetItemPtr(hdsa, i);
        ASSERT(pchside);
#ifdef DEBUG
        if (0 < nRankCur && nRankCur == pchside->nRank)
            bDbgDup = TRUE;
#endif

        if (nRankCur < pchside->nRank)
        {
            *ppchside = pchside;
            nRankCur = pchside->nRank;

            DEBUG_CODE( bDbgDup = FALSE; )      // Reset
        }
    }

#ifdef DEBUG
    // We shouldn't get duplicate highest ranks
    if (bDbgDup)
    {
        // Dump the chooseside list if there are duplicate highest ranks
        ChooseSide_DumpList(hdsa);
    }
    ASSERT(FALSE == bDbgDup);
#endif

    bRet = 0 < nRankCur;
    ASSERT(bRet && *ppchside || !bRet && !*ppchside);

    return bRet;
}


/*----------------------------------------------------------
Purpose: Get the best candidate element (inside or outside).
If the pszFolder is NULL, this function gets the best
outside path.  

Returns: TRUE if an element was found

Cond:    --
 */
BOOL PUBLIC ChooseSide_GetBest(
        HDSA hdsa,
        LPCTSTR pszBrfPath,      // Root path of briefcase
        LPCTSTR pszFolder,       // If NULL, choose best outside element
        PCHOOSESIDE * ppchside)
{
    ASSERT(hdsa);
    ASSERT(0 < DSA_GetItemCount(hdsa));
    ASSERT(pszBrfPath);
    ASSERT(ppchside);

    ChooseSide_ResetRanks(hdsa);

    // Are we ranking for inside paths?
    if (pszFolder)
    {
        // Yes; inside wins
        ChooseSide_RankForInside(hdsa, pszBrfPath, pszFolder);
    }
    else
    {
        // No; outside wins
        ChooseSide_RankForOutside(hdsa, pszBrfPath);
    }

    return ChooseSide_GetBestRank(hdsa, ppchside);
}


/*----------------------------------------------------------
Purpose: Get the next best candidate element (inside or outside).
ChooseSide_GetBest must have been previously called.

Returns: TRUE if an element was found

Cond:    --
 */
BOOL PUBLIC ChooseSide_GetNextBest(
        HDSA hdsa,
        PCHOOSESIDE * ppchside)
{
    PCHOOSESIDE pchside;

    ASSERT(hdsa);
    ASSERT(0 < DSA_GetItemCount(hdsa));
    ASSERT(ppchside);

    // Get the best rank and reset it
    ChooseSide_GetBestRank(hdsa, &pchside);
    pchside->nRank = 0;

    // Now get the next best rank
    return ChooseSide_GetBestRank(hdsa, ppchside);
}


/*----------------------------------------------------------
Purpose: Frees an array of CHOOSESIDE elements.

Returns: --
Cond:    --
 */
void PUBLIC ChooseSide_Free(
        HDSA hdsa)
{
    if (hdsa)
    {
        DSA_Destroy(hdsa);
    }
}


//---------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Determine which node is inside and outside a briefcase.

This function takes a list of recnodes and determines
which node is "inside" a briefcase and which one is
"outside" a briefcase.  "Inside" means the file exists 
somewhere underneath the briefcase path indicated by 
atomBrf.  "Outside" is anywhere else (but may be in 
a different briefcase as well).

Returns: --
Cond:    --
 */
HRESULT PUBLIC Sync_GetNodePair(
        PRECITEM pri,
        LPCTSTR pszBrfPath,
        LPCTSTR pszInsideDir,            // Which folder inside the briefcase to consider
        PRECNODE  * pprnInside,
        PRECNODE  * pprnOutside)     
{
    HRESULT hres;
    HDSA hdsa;

    ASSERT(pri);
    ASSERT(pszBrfPath);
    ASSERT(pszInsideDir);
    ASSERT(pprnInside);
    ASSERT(pprnOutside);
    ASSERT(PathIsPrefix(pszBrfPath, pszInsideDir));

    hres = ChooseSide_CreateAsFile(&hdsa, pri);
    if (SUCCEEDED(hres))
    {
        PCHOOSESIDE pchside;

        // Get inside folder
        if (ChooseSide_GetBest(hdsa, pszBrfPath, pszInsideDir, &pchside))
        {
            *pprnInside = pchside->prn;
        }
        else
        {
            ASSERT(0);
            *pprnInside = NULL;
            hres = E_FAIL;
        }

        // Get outside folder
        if (ChooseSide_GetBest(hdsa, pszBrfPath, NULL, &pchside))
        {
            *pprnOutside = pchside->prn;
        }
        else
        {
            ASSERT(0);
            *pprnOutside = NULL;
            hres = E_FAIL;
        }

#ifdef DEBUG

        if (SUCCEEDED(hres) && IsFlagSet(g_uDumpFlags, DF_PATHS))
        {
            TRACE_MSG(TF_ALWAYS, TEXT("Choosing pairs: %s and %s"), (*pprnInside)->pcszFolder,
                    (*pprnOutside)->pcszFolder);
        }

#endif

        ChooseSide_Free(hdsa);
    }
    else
    {
        *pprnInside = NULL;
        *pprnOutside = NULL;
    }
    return hres;
}



/*----------------------------------------------------------
Purpose: Checks if we've loaded the sync engine
Returns: TRUE if loaded
Cond:    --
 */
BOOL PUBLIC Sync_IsEngineLoaded()
{
    BOOL bRet;

    ENTEREXCLUSIVE();
    {
        bRet = g_vtblEngine[0].hinst != NULL;
    }
    LEAVEEXCLUSIVE();

    return bRet;
}


/*----------------------------------------------------------
Purpose: Load the SYNCENG.DLL and initialize the v-table.
Returns: TRUE on success
Cond:    --
 */
BOOL PUBLIC Sync_QueryVTable(void)
{
    BOOL bRet = TRUE;
    HINSTANCE hinst;

    ENTEREXCLUSIVE();
    {
        hinst = g_vtblEngine[0].hinst;
    }
    LEAVEEXCLUSIVE();

    // We want to assure that the engine is loaded the same
    //  number of times that SYNCUI is (by a process).  This prevents
    //  Kernel from nuking the engine prematurely (if a
    //  process is terminated).
    //
    // We go thru these hoops simply because SYNCUI does not
    //  load SYNCENG immediately upon PROCESS_ATTACH.  We wait
    //  until we *really* need to load it the first time.
    //  Once we finally do load it, we need to keep the load
    //  count current.
    //
    // Kernel frees SYNCUI and SYNCENG for us.
    //
    if (NULL == hinst)
    {
        VTBLENGINE vtbl;

        DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Loading %s (cProcess = %d)"),
                    (LPCTSTR)c_szEngineDLL, g_cProcesses); )

            ZeroInit(&vtbl, sizeof(VTBLENGINE));

        // Don't be in the critical section when we load the DLL
        // or call GetProcAddress, since our LibMain can block on
        // this critical section.
        ASSERT_NOT_EXCLUSIVE();

        hinst = LoadLibrary(c_szEngineDLL);

        if ( ISVALIDHINSTANCE(hinst) )
        {
            // We are loading for the first time.  Fill the vtable.
            //
            vtbl.hinst = hinst;

            // Get all the function addresses
            //
            GetFunction(vtbl, OpenBriefcase, OPENBRIEFCASEINDIRECT);
            GetFunction(vtbl, SaveBriefcase, SAVEBRIEFCASEINDIRECT);
            GetFunction(vtbl, CloseBriefcase, CLOSEBRIEFCASEINDIRECT);
            GetFunction(vtbl, ClearBriefcaseCache, CLEARBRIEFCASECACHEINDIRECT);
            GetFunction(vtbl, DeleteBriefcase, DELETEBRIEFCASEINDIRECT);
            GetFunction(vtbl, GetOpenBriefcaseInfo, GETOPENBRIEFCASEINFOINDIRECT);
            GetFunction(vtbl, FindFirstBriefcase, FINDFIRSTBRIEFCASEINDIRECT);
            GetFunction(vtbl, FindNextBriefcase, FINDNEXTBRIEFCASEINDIRECT);
            GetFunction(vtbl, FindBriefcaseClose, FINDBRIEFCASECLOSEINDIRECT);

            GetFunction(vtbl, AddObjectTwin, ADDOBJECTTWININDIRECT);
            GetFunction(vtbl, AddFolderTwin, ADDFOLDERTWININDIRECT);
            GetFunction(vtbl, ReleaseTwinHandle, RELEASETWINHANDLEINDIRECT);
            GetFunction(vtbl, DeleteTwin, DELETETWININDIRECT);
            GetFunction(vtbl, GetObjectTwinHandle, GETOBJECTTWINHANDLEINDIRECT);
            GetFunction(vtbl, IsFolderTwin, ISFOLDERTWININDIRECT);
            GetFunction(vtbl, CreateFolderTwinList, CREATEFOLDERTWINLISTINDIRECT);
            GetFunction(vtbl, DestroyFolderTwinList, DESTROYFOLDERTWINLISTINDIRECT);
            GetFunction(vtbl, GetFolderTwinStatus, GETFOLDERTWINSTATUSINDIRECT);
            GetFunction(vtbl, IsOrphanObjectTwin, ISORPHANOBJECTTWININDIRECT);
            GetFunction(vtbl, CountSourceFolderTwins, COUNTSOURCEFOLDERTWINSINDIRECT);
            GetFunction(vtbl, AnyTwins, ANYTWINSINDIRECT);

            GetFunction(vtbl, CreateTwinList, CREATETWINLISTINDIRECT);
            GetFunction(vtbl, DestroyTwinList, DESTROYTWINLISTINDIRECT);
            GetFunction(vtbl, AddTwinToTwinList, ADDTWINTOTWINLISTINDIRECT);
            GetFunction(vtbl, AddAllTwinsToTwinList, ADDALLTWINSTOTWINLISTINDIRECT);
            GetFunction(vtbl, RemoveTwinFromTwinList, REMOVETWINFROMTWINLISTINDIRECT);
            GetFunction(vtbl, RemoveAllTwinsFromTwinList, REMOVEALLTWINSFROMTWINLISTINDIRECT);

            GetFunction(vtbl, CreateRecList, CREATERECLISTINDIRECT);
            GetFunction(vtbl, DestroyRecList, DESTROYRECLISTINDIRECT);
            GetFunction(vtbl, ReconcileItem, RECONCILEITEMINDIRECT);
            GetFunction(vtbl, BeginReconciliation, BEGINRECONCILIATIONINDIRECT);
            GetFunction(vtbl, EndReconciliation, ENDRECONCILIATIONINDIRECT);

            GetFunction(vtbl, IsPathOnVolume, ISPATHONVOLUMEINDIRECT);
            GetFunction(vtbl, GetVolumeDescription, GETVOLUMEDESCRIPTIONINDIRECT);
        }
        else
        {
            bRet = FALSE;
        }

        ENTEREXCLUSIVE();
        {
            g_vtblEngine[0] = vtbl;
        }
        LEAVEEXCLUSIVE();
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Free the engine DLL if it is loaded
Returns: --
Cond:    --
 */
void PUBLIC Sync_ReleaseVTable()
{
    HINSTANCE hinst;

    ENTEREXCLUSIVE();
    {
        hinst = g_vtblEngine[0].hinst;
    }
    LEAVEEXCLUSIVE();

    if (NULL != hinst)
    {
        DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Freeing %s (cProcess = %d)"),
                    (LPCTSTR)c_szEngineDLL, g_cProcesses); )

            // We must call FreeLibrary() on the sync engine even during a
            //  PROCESS_DETACH.  We may be getting detached from a process even
            //  though the process isn't being terminated.  If we don't unload
            //  the sync engine now, it won't be unloaded until the process is
            //  terminated.
            //
            FreeLibrary(hinst);

        ENTEREXCLUSIVE();
        {
            ZeroInit(&g_vtblEngine[0], sizeof(VTBLENGINE));
        }
        LEAVEEXCLUSIVE();
    }

#ifdef DEBUG

    ENTEREXCLUSIVE();
    {
        ASSERT(g_vtblEngine[0].hinst == NULL);
    }
    LEAVEEXCLUSIVE();

#endif
}


/*----------------------------------------------------------
Purpose: Set the last sync error.
Returns: same twinresult
Cond:    --
 */
TWINRESULT PUBLIC Sync_SetLastError(
        TWINRESULT tr)
{
    ENTEREXCLUSIVE();
    {
        ASSERTEXCLUSIVE();

        MySetTwinResult(tr);
    }
    LEAVEEXCLUSIVE();

    return tr;
}


/*----------------------------------------------------------
Purpose: Get the last sync error.
Returns: twinresult
Cond:    --
 */
TWINRESULT PUBLIC Sync_GetLastError()
{
    TWINRESULT tr;

    ENTEREXCLUSIVE();
    {
        ASSERTEXCLUSIVE();

        tr = MyGetTwinResult();
    }
    LEAVEEXCLUSIVE();

    return tr;
}


/*----------------------------------------------------------
Purpose: Returns the number of recitems that would require 
some reconciliation.

Returns: see above
Cond:    --
 */
ULONG PUBLIC CountActionItems(
        PRECLIST prl)
{
    PRECITEM pri;
    ULONG ulc;

    for (pri = prl->priFirst, ulc = 0; pri; pri = pri->priNext)
    {
        if (IsFileRecItem(pri) &&
                RIU_SKIP != pri->dwUser &&
                RIA_NOTHING != pri->riaction &&
                RIA_BROKEN_MERGE != pri->riaction)
        {
            ulc++;
            pri->dwUser = RIU_SHOWSTATUS;
        }
    }


    return ulc;
}


/*----------------------------------------------------------
Purpose: Displays appropriate error message on update errors
Returns: --
Cond:    --
 */
void PRIVATE HandleUpdateErrors(
        HWND hwndOwner,
        HRESULT hres,
        UINT uFlags)        // RF_*
{
    // Is this an update while adding files?
    if (IsFlagSet(uFlags, RF_ONADD))
    {
        // Yes
        static SETbl const c_rgseUpdateOnAdd[] = {
            // The out of memory message should be handled by caller
            { E_TR_DEST_OPEN_FAILED,    IDS_ERR_ADD_READONLY,    MB_WARNING },
            { E_TR_DEST_WRITE_FAILED,   IDS_ERR_ADD_FULLDISK,    MB_WARNING },
            { E_TR_UNAVAILABLE_VOLUME,  IDS_ERR_ADD_UNAVAIL_VOL, MB_WARNING },
            { E_TR_SRC_OPEN_FAILED,     IDS_ERR_ADD_SOURCE_FILE, MB_WARNING },
        };

        SEMsgBox(hwndOwner, IDS_CAP_ADD, hres, c_rgseUpdateOnAdd, ARRAYSIZE(c_rgseUpdateOnAdd));
    }
    else
    {
        // No
        static SETbl const c_rgseUpdate[] = {
            { E_TR_OUT_OF_MEMORY,       IDS_OOM_UPDATE,         MB_ERROR },
            { E_TR_DEST_OPEN_FAILED,    IDS_ERR_READONLY,       MB_INFO },
            { E_TR_DEST_WRITE_FAILED,   IDS_ERR_FULLDISK,       MB_WARNING },
            { E_TR_UNAVAILABLE_VOLUME,  IDS_ERR_UPD_UNAVAIL_VOL,MB_WARNING },
            { E_TR_FILE_CHANGED,        IDS_ERR_FILE_CHANGED,   MB_INFO },
            { E_TR_SRC_OPEN_FAILED,     IDS_ERR_SOURCE_FILE,    MB_WARNING },
        };

        SEMsgBox(hwndOwner, IDS_CAP_UPDATE, hres, c_rgseUpdate, ARRAYSIZE(c_rgseUpdate));
    }
}


typedef struct tagPROGPARAM
{
    HWND hwndProgress;
    WORD wPosMax;
    WORD wPosBase;
    WORD wPosPrev;
    BOOL bSkip;
} PROGPARAM, * PPROGPARAM;

/*----------------------------------------------------------
Purpose: Status procedure that is called during a single 
ReconcileItem call.

Returns: varies
Cond:    --
 */
BOOL CALLBACK RecStatusProc(
        RECSTATUSPROCMSG msg,
        LPARAM lParam,
        LPARAM lParamUser)
{
    BOOL bRet;
    PRECSTATUSUPDATE prsu = (PRECSTATUSUPDATE)lParam;
    PPROGPARAM pprogparam = (PPROGPARAM)lParamUser;
    HWND hwndProgress = pprogparam->hwndProgress;
    WORD wPos;

    bRet = !UpdBar_QueryAbort(hwndProgress);

    switch (msg)
    {
        case RS_BEGIN_COPY:
        case RS_DELTA_COPY:
        case RS_END_COPY:
        case RS_BEGIN_MERGE:
        case RS_DELTA_MERGE:
        case RS_END_MERGE:
#ifdef NEW_REC
        case RS_BEGIN_DELETE:
        case RS_DELTA_DELETE:
        case RS_END_DELETE:
#endif
            TRACE_MSG(TF_PROGRESS, TEXT("Reconcile progress = %lu of %lu"), prsu->ulProgress, prsu->ulScale);
            ASSERT(prsu->ulProgress <= prsu->ulScale);

            if (0 < prsu->ulScale && !pprogparam->bSkip)
            {
                wPos = LOWORD(LODWORD( (((__int64)pprogparam->wPosMax * prsu->ulProgress) / prsu->ulScale) ));

                TRACE_MSG(TF_PROGRESS, TEXT("Max wPos = %u,  new wPos = %u,  old wPos = %u"), 
                        pprogparam->wPosMax, wPos, pprogparam->wPosPrev);

                if (wPos > pprogparam->wPosPrev && wPos < pprogparam->wPosMax)
                {
                    WORD wPosReal = pprogparam->wPosBase + wPos;

                    TRACE_MSG(TF_PROGRESS, TEXT("Setting real position = %u"), wPosReal);

                    UpdBar_SetPos(hwndProgress, wPosReal);
                    pprogparam->wPosPrev = wPos;
                }
            }
            break;

        default:
            ASSERT(0);
            break;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Decides the description string while updating.  The
string is something like "Copying from 'Foo' to 'Bar'"
or "Merging files in 'Foo' and 'Bar'"

Returns: string in pszBuf

Cond:    --
 */
void PRIVATE DecideDescString(
        LPCTSTR pszBrfPath,
        PRECITEM pri,
        LPTSTR pszBuf,
        int cchBuf,
        LPTSTR pszPathBuf,
        int cchPathBuf)  // Must be MAX_PATH
{
    HRESULT hres;
    RA_ITEM * pitem;

    ASSERT(pszBrfPath);
    ASSERT(pri);
    ASSERT(pszBuf);

    hres = RAI_CreateFromRecItem(&pitem, pszBrfPath, pri);
    if (SUCCEEDED(hres))
    {
        UINT ids;
        LPTSTR pszMsg;
        LPCTSTR pszFrom;
        LPCTSTR pszTo;

        lstrcpyn(pszPathBuf, pitem->siInside.pszDir, cchPathBuf);
        PathAppend(pszPathBuf, pitem->pszName);

        switch (pitem->uAction)
        {
            case RAIA_TOOUT:
                ids = IDS_UPDATE_Copy;
                pszFrom = PathFindFileName(pitem->siInside.pszDir);
                pszTo = PathFindFileName(pitem->siOutside.pszDir);
                break;

            case RAIA_TOIN:
                ids = IDS_UPDATE_Copy;
                pszFrom = PathFindFileName(pitem->siOutside.pszDir);
                pszTo = PathFindFileName(pitem->siInside.pszDir);
                break;

            case RAIA_MERGE:
                ids = IDS_UPDATE_Merge;
                // (Arbitrary)
                pszFrom = PathFindFileName(pitem->siInside.pszDir);
                pszTo = PathFindFileName(pitem->siOutside.pszDir);
                break;

            case RAIA_DELETEOUT:
                ids = IDS_UPDATE_Delete;
                pszFrom = PathFindFileName(pitem->siOutside.pszDir);
                pszTo = NULL;
                break;

            case RAIA_DELETEIN:
                ids = IDS_UPDATE_Delete;
                pszFrom = PathFindFileName(pitem->siInside.pszDir);
                pszTo = NULL;
                break;

            default:
                ASSERT(0);
                ids = 0;
                break;
        }

        if (ConstructMessage(&pszMsg, g_hinst, MAKEINTRESOURCE(ids), 
                    pszFrom, pszTo))
        {
            lstrcpyn(pszBuf, pszMsg, cchBuf);
            GFree(pszMsg);
        }
        else
            *pszBuf = 0;
    }
    else
        *pszBuf = 0;
}


/*----------------------------------------------------------
Purpose: Reconcile a given reclist

Returns: standard result
Cond:    --
 */
HRESULT PUBLIC Sync_ReconcileRecList(
        PRECLIST prl,       // ptr to reclist
        LPCTSTR pszBrfPath,
        HWND hwndProgress,
        UINT uFlags)        // RF_*
{
    HRESULT hres;

    if (prl)
    {
        HWND hwndOwner = GetParent(hwndProgress);
        HWND hwndStatusText = UpdBar_GetStatusWindow(hwndProgress);
        TCHAR szPath[MAX_PATH];
        TCHAR sz[MAXBUFLEN];
        TWINRESULT tr;
        PRECITEM pri;
        PROGPARAM progparam;
        ULONG ulcItems;
        WORD wDelta;

        DEBUG_CODE( Sync_DumpRecList(TR_SUCCESS, prl, TEXT("Updating")); )

            hres = NOERROR;     // assume success

        // Grab the mutex to delay any further calculation in any
        // Briefcase views' secondary threads until we're done 
        // processing here.
        Delay_Own();

        // Determine the range of the progress bar
        UpdBar_SetRange(hwndProgress, MAX_RANGE);

        ulcItems = CountActionItems(prl);
        if (0 < ulcItems)
            wDelta = (WORD)(MAX_RANGE / ulcItems);
        else
            wDelta = 0;

        progparam.hwndProgress = hwndProgress;

        // Start updating
        Sync_BeginRec(prl->hbr);

        ulcItems = 0;           
        for (pri = prl->priFirst; pri; pri = pri->priNext)
        {
            // Did the user explicitly skip this recitem or
            // is this a broken merge?
            if (RIU_SKIP == pri->dwUser ||
                    RIA_BROKEN_MERGE == pri->riaction)
            {
                // Yes; don't call ReconcileItem
                continue;
            }

            // Is something going to be done to this recitem?
            if (RIU_SHOWSTATUS == pri->dwUser)
            {
                // Yes; update the name of the file we're updating
                UpdBar_SetName(hwndProgress, pri->pcszName);
                DecideDescString(pszBrfPath, pri, sz, ARRAYSIZE(sz), szPath, ARRAYSIZE(szPath));
                UpdBar_SetDescription(hwndProgress, sz);

                ASSERT(0 < wDelta);
                progparam.wPosBase = (WORD)(wDelta * ulcItems);
                progparam.wPosMax = wDelta;
                progparam.wPosPrev = 0;
                progparam.bSkip = FALSE;
            }
            else
            {
                progparam.bSkip = TRUE;
            }

            // Call ReconcileItem even for nops, so the recnode states
            // will be updated by the engine.
            tr = Sync_ReconcileItem(pri, RecStatusProc, (LPARAM)&progparam, 
                    RI_FL_FEEDBACK_WINDOW_VALID, hwndProgress, hwndStatusText);
            if (TR_SUCCESS != tr &&
                    IsFileRecItem(pri))     // ignore folder recitem errors
            {
                // On some conditions, stop updating completely
                hres = HRESULT_FROM_TR(tr);

                switch (hres)
                {
                    case E_TR_OUT_OF_MEMORY:
                    case E_TR_RH_LOAD_FAILED: {
                                                  // Couldn't load the merge handler.  Tell the user but
                                                  // continue on...
                                                  int id = MsgBox(hwndOwner, 
                                                          MAKEINTRESOURCE(IDS_ERR_NO_MERGE_HANDLER), 
                                                          MAKEINTRESOURCE(IDS_CAP_UPDATE),
                                                          NULL,
                                                          MB_WARNING | MB_OKCANCEL,
                                                          PathGetDisplayName(szPath, sz, ARRAYSIZE(sz)));

                                                  if (IDOK == id)
                                                      break;      // continue updating other files
                                              }

                                              goto StopUpdating;

                    case E_TR_DELETED_TWIN:
                                              // Allow the updating to continue.
                                              break;

                    case E_TR_DEST_OPEN_FAILED:
                    case E_TR_FILE_CHANGED:
                                              if (IsFlagClear(uFlags, RF_ONADD))
                                              {
                                                  // Allow the updating to continue.  Remember the
                                                  // latest error for the end.
                                                  break;
                                              }
                                              // Fall thru
                                              //   |   |
                                              //   v   v

                    default:
                                              goto StopUpdating;
                }
            }

            // Was something done to this recitem?
            if (RIU_SHOWSTATUS == pri->dwUser)
            {
                // Yes; update the progress bar
                UpdBar_SetPos(hwndProgress, (WORD)(wDelta * ++ulcItems));
            }

            // Check if the Cancel button was pressed
            if (UpdBar_QueryAbort(hwndProgress))
            {
                hres = E_ABORT;
                break;
            }
        }

StopUpdating:
        if (FAILED(hres))
        {
            Sync_DumpRecItem(tr, pri, NULL);
            HandleUpdateErrors(hwndOwner, hres, uFlags);

            if (IsFlagSet(uFlags, RF_ONADD))
            {
                // Hack: since the caller also handles some error messages,
                // return a generic failure code to prevent repeated
                // error messages.
                hres = E_FAIL;
            }
        }
        // Were there any items at all?
        else if (0 == prl->ulcItems)
        {
            // No
            MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_MSG_NoMatchingFiles), 
                    MAKEINTRESOURCE(IDS_CAP_UPDATE), NULL, MB_INFO);
        }

        Sync_EndRec(prl->hbr);

        Delay_Release();
    }
    else
        hres = E_INVALIDARG;

    return hres;
}


/*----------------------------------------------------------
Purpose: Status procedure that is called during a single 
ReconcileItem call.

Returns: varies
Cond:    --
 */
BOOL CALLBACK CreateRecListProc(
        CREATERECLISTPROCMSG msg,
        LPARAM lParam,
        LPARAM lParamUser)
{
    return !AbortEvt_Query((PABORTEVT)lParamUser);
}


/*----------------------------------------------------------
Purpose: Creates a reclist and optionally shows a progress
bar during the creation.

Returns: standard result
Cond:    --
 */
HRESULT PUBLIC Sync_CreateRecListEx(
        HTWINLIST htl,
        PABORTEVT pabortevt,
        PRECLIST * pprl)
{
    TWINRESULT tr;

    ASSERT(pprl);

    tr = Sync_CreateRecList(htl, CreateRecListProc, (LPARAM)pabortevt, pprl);
    return HRESULT_FROM_TR(tr);
}


/*----------------------------------------------------------
Purpose: Return true if the file or folder is a twin.

There are some cases when this function cannot successfully
determine this unless the caller first tells it explicitly 
whether the object is a file or folder.  Otherwise this
function will attempt to determine this on its own.

Returns: S_OK if it is a twin
S_FALSE if it is not
any other is an error

Cond:    --
 */
HRESULT PUBLIC Sync_IsTwin(
        HBRFCASE hbrfcase,
        LPCTSTR pszPath,
        UINT uFlags)        // SF_* flags
{
    HRESULT hres;
    TWINRESULT tr;

    ASSERT(pszPath);

    // The caller may already know whether this is a twin or not.
    // Remind him.
    if (IsFlagSet(uFlags, SF_ISTWIN))
        return S_OK;
    else if (IsFlagSet(uFlags, SF_ISNOTTWIN))
        return S_FALSE;

    // Is this a folder?
    if (IsFlagSet(uFlags, SF_ISFOLDER) ||
            PathIsDirectory(pszPath))
    {
        // Yes; is it a twin?
        BOOL bRet;

        tr = Sync_IsFolder(hbrfcase, pszPath, &bRet);
        if (TR_SUCCESS == tr)
        {
            // Yes/no
            hres = bRet ? S_OK : S_FALSE;
        }
        else
        {
            // Error
            hres = HRESULT_FROM_TR(tr);
        }
    }
    else
    {
        // No
        HOBJECTTWIN hot;
        TCHAR szDir[MAX_PATH];

        lstrcpyn(szDir, pszPath, ARRAYSIZE(szDir));
        PathRemoveFileSpec(szDir);
        tr = Sync_GetObject(hbrfcase, szDir, PathFindFileName(pszPath), &hot);
        if (TR_SUCCESS == tr)
        {
            // Is it a twin?
            if (NULL != hot)
            {
                // Yes
                Sync_ReleaseTwin(hot);
                hres = S_OK;
            }
            else
            {
                // No; (no need to release a null handle)
                hres = S_FALSE;
            }
        }
        else
        {
            // Error
            hres = HRESULT_FROM_TR(tr);
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Create a reclist with everything in it.

Returns: standard result

Cond:    Caller must destroy the reclist
 */
HRESULT PUBLIC Sync_CreateCompleteRecList(
        HBRFCASE hbrf,
        PABORTEVT pabortevt,
        PRECLIST * pprl)
{
    HRESULT hres = E_OUTOFMEMORY;
    HTWINLIST htl;

    ASSERT(pprl);

    *pprl = NULL;

    if (TR_SUCCESS == Sync_CreateTwinList(hbrf, &htl))
    {
        Sync_AddAllToTwinList(htl);

        hres = Sync_CreateRecListEx(htl, pabortevt, pprl);
        Sync_DestroyTwinList(htl);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Add a twin to the twinlist given the pathname.  If the
pathname is not a twin, we don't add it.

Returns: TRUE on success, even when this isn't a twin

Cond:    Caller must destroy the folder list if lplpftl is not NULL
 */
BOOL PUBLIC Sync_AddPathToTwinList(
        HBRFCASE hbrf,
        HTWINLIST htl,
        LPCTSTR lpcszPath,               // Path
        PFOLDERTWINLIST  * lplpftl)  // May be NULL
{
    BOOL bRet = FALSE;

    ASSERT(lpcszPath);
    ASSERT(htl);

    if (lplpftl)
        *lplpftl = NULL;

    if (lpcszPath)
    {
        if (PathIsDirectory(lpcszPath))
        {
            BOOL fIsTwin = FALSE;
            PFOLDERTWINLIST lpftl;

            // We only want to return false if we couldn't mark something
            //  that should have been marked.  If this isn't a twin,
            //  we still succeed.

            bRet = TRUE;

            Sync_IsFolder(hbrf, lpcszPath, &fIsTwin);
            if (fIsTwin)        // Is this actually twinned?
            {
                // This is a folder twin.  Add to reclist "the folder way".
                //
                if (Sync_CreateFolderList(hbrf, lpcszPath, &lpftl) != TR_SUCCESS)
                    bRet = FALSE;
                else
                {
                    PCFOLDERTWIN lpcfolder;

                    ASSERT(lpftl->pcftFirst);

                    // only mark the ones that aren't in other briefcases
                    //
                    lpcfolder = lpftl->pcftFirst;
                    while (lpcfolder)
                    {
                        Sync_AddToTwinList(htl, lpcfolder->hftOther);

                        lpcfolder = lpcfolder->pcftNext;
                    }

                    if (lplpftl)
                        *lplpftl = lpftl;
                    else
                        Sync_DestroyFolderList(lpftl);
                }
            }
        }
        else
        {
            HOBJECTTWIN hot = NULL;
            TCHAR szDir[MAX_PATH];

            // Add the twins to the reclist "the object way"
            //
            lstrcpyn(szDir, lpcszPath, ARRAYSIZE(szDir));
            PathRemoveFileSpec(szDir);
            Sync_GetObject(hbrf, szDir, PathFindFileName(lpcszPath), &hot);

            if (hot)                // Is this actually a twin?
            {
                // yep
                Sync_AddToTwinList(htl, hot);
                Sync_ReleaseTwin(hot);
            }
            if (lplpftl)
                *lplpftl = NULL;
            bRet = TRUE;
        }
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Asks the user to confirm splitting one or more files.

Returns: IDYES or IDNO
Cond:    --
 */
int PRIVATE ConfirmSplit(
        HWND hwndOwner,
        LPCTSTR pszPath,
        UINT cFiles)
{
    int idRet;

    ASSERT(pszPath);
    ASSERT(1 <= cFiles);

    // Multiple files?
    if (1 < cFiles)
    {
        // Yes
        idRet = MsgBox(hwndOwner, 
                MAKEINTRESOURCE(IDS_MSG_ConfirmMultiSplit), 
                MAKEINTRESOURCE(IDS_CAP_ConfirmMultiSplit), 
                LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SPLIT_MULT)), 
                MB_QUESTION,
                cFiles);
    }
    else
    {
        // No
        UINT ids;
        UINT idi;
        TCHAR szName[MAX_PATH];

        if (PathIsDirectory(pszPath))
        {
            ids = IDS_MSG_ConfirmFolderSplit;
            idi = IDI_SPLIT_FOLDER;
        }
        else
        {
            ids = IDS_MSG_ConfirmFileSplit;
            idi = IDI_SPLIT_FILE;
        }

        idRet = MsgBox(hwndOwner, 
                MAKEINTRESOURCE(ids), 
                MAKEINTRESOURCE(IDS_CAP_ConfirmSplit), 
                LoadIcon(g_hinst, MAKEINTRESOURCE(idi)), 
                MB_QUESTION,
                PathGetDisplayName(pszPath, szName, ARRAYSIZE(szName)));
    }
    return idRet;
}


/*----------------------------------------------------------
Purpose: Splits a path from its sync copy.  Private function
called by Sync_Split.

Returns: standard result
S_OK if it is split

Cond:    --
 */
HRESULT PRIVATE SplitPath(
        HBRFCASE hbrf,
        LPCTSTR pszPath,
        HWND hwndOwner,
        UINT uFlags)            // SF_* flags
{
    HRESULT hres;
    TWINRESULT tr;
    TCHAR sz[MAX_PATH];

    if (pszPath)
    {
        // Is the object a folder?
        if (IsFlagSet(uFlags, SF_ISFOLDER) || 
                PathIsDirectory(pszPath))
        {
            // Yup
            BOOL bIsTwin;

            if (IsFlagSet(uFlags, SF_ISTWIN))           // Optimization
            {
                tr = TR_SUCCESS;
                bIsTwin = TRUE;
            }
            else if (IsFlagSet(uFlags, SF_ISNOTTWIN))   // Optimization
            {
                tr = TR_SUCCESS;
                bIsTwin = FALSE;
            }
            else
            {
                tr = Sync_IsFolder(hbrf, pszPath, &bIsTwin);
            }

            // Is this folder a twin?
            if (TR_SUCCESS == tr)
            {
                if (bIsTwin)
                {
                    // Yes; delete all the twin handles associated with it
                    PFOLDERTWINLIST lpftl;

                    tr = Sync_CreateFolderList(hbrf, pszPath, &lpftl);
                    if (TR_SUCCESS == tr)
                    {
                        PCFOLDERTWIN lpcfolder;

                        ASSERT(lpftl);

                        for (lpcfolder = lpftl->pcftFirst; lpcfolder; 
                                lpcfolder = lpcfolder->pcftNext)
                        {
                            Sync_DeleteTwin(lpcfolder->hftOther);
                        }

                        Sync_DestroyFolderList(lpftl);

                        if (IsFlagClear(uFlags, SF_QUIET))
                        {
                            // Send a notification so it is redrawn.
                            PathNotifyShell(pszPath, NSE_UPDATEITEM, FALSE);
                        }
                        hres = NOERROR;
                    }
                }
                else if (IsFlagClear(uFlags, SF_QUIET))
                {
                    // No
                    MsgBox(hwndOwner, 
                            MAKEINTRESOURCE(IDS_MSG_FolderAlreadyOrphan),
                            MAKEINTRESOURCE(IDS_CAP_Split), 
                            LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SPLIT_FOLDER)), 
                            MB_INFO,
                            PathGetDisplayName(pszPath, sz, ARRAYSIZE(sz)));

                    hres = S_FALSE;
                }
                else
                {
                    hres = S_FALSE;
                }
            }
        }
        else
        {
            // No; it is a file
            HOBJECTTWIN hot;
            ULONG ulc;

            lstrcpyn(sz, pszPath, ARRAYSIZE(sz));
            PathRemoveFileSpec(sz);

            // Is this file a twin?
            // (We need the twin handle below, so we cannot take 
            // advantage of SF_ISTWIN or SF_ISNOTTWIN.)
            tr = Sync_GetObject(hbrf, sz, PathFindFileName(pszPath), &hot);

            if (TR_SUCCESS == tr)
            {
                if (hot)
                {
                    // Yes; is this inside a folder twin?
                    // (If we remove this check, the engine needs to be able
                    // to exclude specific files from a folder twin.)
                    tr = Sync_CountSourceFolders(hot, &ulc);
                    if (TR_SUCCESS == tr)
                    {
                        if (0 < ulc)
                        {
                            // Yes; can't do it
                            if (IsFlagClear(uFlags, SF_QUIET))
                            {
                                UINT rgids[2] = { IDS_ERR_1_CantSplit, IDS_ERR_2_CantSplit };
                                LPTSTR psz;

                                if (FmtString(&psz, IDS_ERR_F_CantSplit, rgids, ARRAYSIZE(rgids)))
                                {
                                    // This object twin belongs to a folder twin.  We can't
                                    //  allow this action.
                                    MsgBox(hwndOwner, psz, MAKEINTRESOURCE(IDS_CAP_STATUS), 
                                            LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SPLIT_FILE)), MB_ERROR);
                                    GFree(psz);
                                }
                            }
                            hres = S_FALSE;
                        }
                        else
                        {
                            // No; delete the twin
                            Sync_DeleteTwin(hot);

                            if (IsFlagClear(uFlags, SF_QUIET))
                            {
                                // Send a notification so it's redrawn immediately.
                                PathNotifyShell(pszPath, NSE_UPDATEITEM, FALSE);
                            }
                            hres = NOERROR;
                        }
                    }

                    Sync_ReleaseTwin(hot);
                }
                else if (IsFlagClear(uFlags, SF_QUIET))
                {
                    // No
                    MsgBox(hwndOwner, 
                            MAKEINTRESOURCE(IDS_MSG_FileAlreadyOrphan), 
                            MAKEINTRESOURCE(IDS_CAP_Split), 
                            LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SPLIT_FILE)), 
                            MB_INFO,
                            PathGetDisplayName(pszPath, sz, ARRAYSIZE(sz)));

                    hres = S_FALSE;
                }
            }
        }

        if (TR_SUCCESS != tr)
            hres = HRESULT_FROM_TR(tr);
    }
    else
        hres = S_FALSE;

    return hres;
}


/*----------------------------------------------------------
Purpose: Deletes a series of twins from the engine database.
The user is optionally asked to confirm the action.

If a file is an orphan, the user is optionally 
notified.  The user is also optionally notified
of any errors.

Returns: standard result
S_OK if anything was deleted

Cond:    --
 */
HRESULT PUBLIC Sync_Split(
        HBRFCASE hbrf,
        LPCTSTR pszList,
        UINT cFiles,
        HWND hwndOwner,
        UINT uFlags)
{
    HRESULT hres;
    UINT id;
    TCHAR szCanon[MAX_PATH];
    TCHAR sz[MAX_PATH];

    ASSERT(pszList);
    ASSERT(0 < cFiles);

    // Special precondition: is it a single file?
    if (1 == cFiles)
    {
        // Yes; is it a twin?
        BrfPathCanonicalize(pszList, szCanon, ARRAYSIZE(szCanon));
        hres = Sync_IsTwin(hbrf, szCanon, uFlags);
        if (S_FALSE == hres)
        {
            // No; tell the user.  Don't bother confirming the action first.
            if (IsFlagClear(uFlags, SF_QUIET))
            {
                UINT ids;
                UINT idi;

                if (IsFlagSet(uFlags, SF_ISFOLDER) || 
                        PathIsDirectory(szCanon))
                {
                    ids = IDS_MSG_FolderAlreadyOrphan;
                    idi = IDI_SPLIT_FOLDER;
                }
                else
                {
                    ids = IDS_MSG_FileAlreadyOrphan;
                    idi = IDI_SPLIT_FILE;
                }

                MsgBox(hwndOwner, 
                        MAKEINTRESOURCE(ids), 
                        MAKEINTRESOURCE(IDS_CAP_Split), 
                        LoadIcon(g_hinst, MAKEINTRESOURCE(idi)), 
                        MB_INFO,
                        PathGetDisplayName(szCanon, sz, ARRAYSIZE(sz)));
            }
        }
        else if (S_OK == hres)
        {
            // Yes
            if (IsFlagClear(uFlags, SF_NOCONFIRM))
                id = ConfirmSplit(hwndOwner, szCanon, 1);
            else
                id = IDYES;

            if (IDYES == id)
            {
                hres = SplitPath(hbrf, szCanon, hwndOwner, uFlags);
                if (IsFlagClear(uFlags, SF_QUIET))
                {
                    SHChangeNotifyHandleEvents();
                }
            }
            else
                hres = S_FALSE;
        }
    }

    // Multiselection: ask the user first
    else
    {
        if (IsFlagClear(uFlags, SF_NOCONFIRM))
            id = ConfirmSplit(hwndOwner, pszList, cFiles);
        else
            id = IDYES;

        if (IDYES == id)
        {
            // Remove all the files from the engine database
            LPCTSTR psz;
            UINT i;
            HRESULT hresT;

            hres = S_FALSE;     // assume success but nothing done

            for (i = 0, psz = pszList; i < cFiles; i++)
            {
                // Get dragged file/folder name
                //
                BrfPathCanonicalize(psz, szCanon, ARRAYSIZE(szCanon));

                hresT = SplitPath(hbrf, szCanon, hwndOwner, uFlags);
                if (S_OK == hresT)
                    hres = S_OK;  // (Don't set back to FALSE once it is TRUE)
                else if (FAILED(hresT))
                {
                    hres = hresT;
                    break;
                }

                DataObj_NextFile(psz);      // Set psz to next file in list
            }

            if (IsFlagClear(uFlags, SF_QUIET))
            {
                SHChangeNotifyHandleEvents();    // (Do this after the loop)
            }
        }
        else
            hres = S_FALSE;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Change the recitem action and the two recnodes of
importance to the specified action.
Returns: --
Cond:    --
 */
void PUBLIC Sync_ChangeRecItemAction(
        PRECITEM pri,
        LPCTSTR pszBrfPath,
        LPCTSTR pszInsideDir,     // Folder inside the briefcase
        UINT riaction)           // One of RAIA_* values to change to
{
    HRESULT hres;
    PRECNODE prnInside;
    PRECNODE prnOutside;

    // Determine which node is inside the briefcase and which one is
    //  outside.
    //
    hres = Sync_GetNodePair(pri, pszBrfPath, pszInsideDir, &prnInside, &prnOutside);
    if (SUCCEEDED(hres))
    {
        ASSERT(prnInside);
        ASSERT(prnOutside);

        switch(riaction)
        {
            case RAIA_TOIN:
                pri->dwUser = RIU_CHANGED;
                pri->riaction = RIA_COPY;
                prnInside->rnaction = RNA_COPY_TO_ME;
                prnOutside->rnaction = RNA_COPY_FROM_ME;
                break;

            case RAIA_TOOUT:
                pri->dwUser = RIU_CHANGED;
                pri->riaction = RIA_COPY;
                prnInside->rnaction = RNA_COPY_FROM_ME;
                prnOutside->rnaction = RNA_COPY_TO_ME;
                break;

            case RAIA_SKIP:
                pri->dwUser = RIU_SKIP;
                break;

            case RAIA_MERGE:
                pri->dwUser = RIU_CHANGED;
                pri->riaction = RIA_MERGE;
                prnInside->rnaction = RNA_MERGE_ME;
                prnOutside->rnaction = RNA_MERGE_ME;
                break;

#ifdef NEW_REC
            case RAIA_DONTDELETE:
                if (RNA_DELETE_ME == prnInside->rnaction)
                {
                    pri->dwUser = RIU_CHANGED;
                    pri->riaction = RIA_NOTHING;
                    prnInside->rnaction = RNA_NOTHING;
                }
                else if (RNA_DELETE_ME == prnOutside->rnaction)
                {
                    pri->dwUser = RIU_CHANGED;
                    pri->riaction = RIA_NOTHING;
                    prnOutside->rnaction = RNA_NOTHING;
                }
                break;

            case RAIA_DELETEIN:
                pri->dwUser = RIU_CHANGED;
                pri->riaction = RIA_DELETE;
                prnInside->rnaction = RNA_DELETE_ME;
                prnOutside->rnaction = RNA_NOTHING;
                break;

            case RAIA_DELETEOUT:
                pri->dwUser = RIU_CHANGED;
                pri->riaction = RIA_DELETE;
                prnInside->rnaction = RNA_NOTHING;
                prnOutside->rnaction = RNA_DELETE_ME;
                break;
#endif

            default:
                // (The other values don't make sense here)
                ASSERT(0);
                break;
        }
    }
}


/////////////////////////////////////////////////////  PRIVATE FUNCTIONS


#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Dumps the contents of the given twin structure to
to debug out
Returns: --
Cond:    --
 */
void PUBLIC Sync_FnDump(
        LPVOID lpvBuf,
        UINT cbBuf)
{
    int bDump;

#define szDumpTwin  TEXT("Dump TWIN: ")
#define szDumpSp    TEXT("           ")

    ENTEREXCLUSIVE();
    {
        bDump = IsFlagSet(g_uDumpFlags, DF_CREATETWIN);
    }
    LEAVEEXCLUSIVE();

    if (!bDump)
        return ;

    if (cbBuf == sizeof(NEWOBJECTTWIN))
    {
        PNEWOBJECTTWIN lpnot = (PNEWOBJECTTWIN)lpvBuf;

        TRACE_MSG(TF_ALWAYS, TEXT("%s.Folder1 = {%s}\r\n%s.Folder2 = {%s}\r\n%s.Name = {%s}\r\n"),
                (LPTSTR)szDumpTwin, lpnot->pcszFolder1,
                (LPTSTR)szDumpSp, lpnot->pcszFolder2,
                (LPTSTR)szDumpSp, lpnot->pcszName);
    }
    else if (cbBuf == sizeof(NEWFOLDERTWIN))
    {
        PNEWFOLDERTWIN lpnft = (PNEWFOLDERTWIN)lpvBuf;

        TRACE_MSG(TF_ALWAYS, TEXT("%s.Folder1 = {%s}\r\n%s.Folder2 = {%s}\r\n%s.Name = {%s}\r\n%s.dwFlags = 0x%04lx\r\n"),
                (LPTSTR)szDumpTwin, lpnft->pcszFolder1,
                (LPTSTR)szDumpSp, lpnft->pcszFolder2,
                (LPTSTR)szDumpSp, lpnft->pcszName,
                (LPTSTR)szDumpSp, (DWORD)lpnft->dwFlags);
    }
}


/*----------------------------------------------------------
Purpose: Return English form of RIA_ flags
Returns:
Cond:    --
 */
LPTSTR PRIVATE LpszFromItemAction(
        ULONG riaction)
{
    switch (riaction)
    {
        DEBUG_CASE_STRING( RIA_NOTHING );
        DEBUG_CASE_STRING( RIA_COPY );
        DEBUG_CASE_STRING( RIA_MERGE );
        DEBUG_CASE_STRING( RIA_BROKEN_MERGE );

#ifdef NEW_REC
        DEBUG_CASE_STRING( RIA_DELETE );
#endif

        default:        return TEXT("RIA unknown");
    }
}


/*----------------------------------------------------------
Purpose: Return English form of RNA_ flags
Returns:
Cond:    --
 */
LPTSTR PRIVATE LpszFromNodeAction(
        ULONG rnaction)
{
    switch (rnaction)
    {
        DEBUG_CASE_STRING( RNA_NOTHING );
        DEBUG_CASE_STRING( RNA_COPY_TO_ME );
        DEBUG_CASE_STRING( RNA_COPY_FROM_ME );
        DEBUG_CASE_STRING( RNA_MERGE_ME );

#ifdef NEW_REC
        DEBUG_CASE_STRING( RNA_DELETE_ME );
#endif

        default:    return TEXT("RNA unknown");
    }
}


/*----------------------------------------------------------
Purpose: Return English form of RNS_ flags
Returns:
Cond:    --
 */
LPTSTR PRIVATE LpszFromNodeState(
        ULONG rnstate)
{
    switch (rnstate)
    {
#ifdef NEW_REC
        DEBUG_CASE_STRING( RNS_NEVER_RECONCILED );
#endif

        DEBUG_CASE_STRING( RNS_UNAVAILABLE );
        DEBUG_CASE_STRING( RNS_DOES_NOT_EXIST );
        DEBUG_CASE_STRING( RNS_DELETED );
        DEBUG_CASE_STRING( RNS_NOT_RECONCILED );
        DEBUG_CASE_STRING( RNS_UP_TO_DATE );
        DEBUG_CASE_STRING( RNS_CHANGED );

        default: return TEXT("RNS unknown");
    }
}


/*----------------------------------------------------------
Purpose: Dump the RECNODE
Returns:
Cond:    --
 */
void PUBLIC Sync_DumpRecNode(
        TWINRESULT tr,
        PRECNODE lprn)
{
    BOOL bDump;
    TCHAR szBuf[MAXMSGLEN];

#define szDumpLabel     TEXT("\tDump RECNODE: ")
#define szDumpMargin    TEXT("\t              ")

    ENTEREXCLUSIVE();
    {
        bDump = IsFlagSet(g_uDumpFlags, DF_RECNODE);
    }
    LEAVEEXCLUSIVE();

    if (!bDump || lprn == NULL || tr == TR_OUT_OF_MEMORY || tr == TR_INVALID_PARAMETER)
        return ;

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.Folder = {%s}\r\n"), (LPTSTR)szDumpLabel, lprn->pcszFolder);
    OutputDebugString(szBuf);

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.hObjectTwin = %lx\r\n"), (LPTSTR)szDumpMargin, lprn->hObjectTwin);
    OutputDebugString(szBuf);

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.rnstate = %s\r\n"), (LPTSTR)szDumpMargin, LpszFromNodeState(lprn->rnstate));
    OutputDebugString(szBuf);

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.rnaction = %s\r\n"), (LPTSTR)szDumpMargin, LpszFromNodeAction(lprn->rnaction));
    OutputDebugString(szBuf);
    OutputDebugString(TEXT("\r\n"));

#undef szDumpLabel
#undef szDumpMargin
}


/*----------------------------------------------------------
Purpose: Dump the RECITEM
Returns:
Cond:    --
 */
void PUBLIC Sync_DumpRecItem(
        TWINRESULT tr,
        PRECITEM lpri,
        LPCTSTR pszMsg)
{
    BOOL bDump;
    PRECNODE lprn;
    TCHAR szBuf[MAXMSGLEN];

#define szDumpLabel     TEXT("Dump RECITEM: ")
#define szDumpMargin    TEXT("              ")

    ENTEREXCLUSIVE();
    {
        bDump = IsFlagSet(g_uDumpFlags, DF_RECITEM);
    }
    LEAVEEXCLUSIVE();

    if (!bDump || lpri == NULL || tr == TR_OUT_OF_MEMORY || tr == TR_INVALID_PARAMETER)
        return ;

    if (pszMsg)
        TRACE_MSG(TF_ALWAYS, pszMsg);

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("tr = %s\r\n"), (LPTSTR)SzFromTR(tr));
    OutputDebugString(szBuf);

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.Name = {%s}\r\n"), (LPTSTR)szDumpLabel, lpri->pcszName);
    OutputDebugString(szBuf);

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.hTwinFamily = %lx\r\n"), (LPTSTR)szDumpMargin, lpri->hTwinFamily);
    OutputDebugString(szBuf);

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.ulcNodes = %lu\r\n"), (LPTSTR)szDumpMargin, lpri->ulcNodes);
    OutputDebugString(szBuf);

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.riaction = %s\r\n"), (LPTSTR)szDumpMargin, LpszFromItemAction(lpri->riaction));
    OutputDebugString(szBuf);

    lprn = lpri->prnFirst;
    while (lprn)
    {
        Sync_DumpRecNode(tr, lprn);
        lprn = lprn->prnNext;
    }

#undef szDumpLabel
#undef szDumpMargin
}


/*----------------------------------------------------------
Purpose: Dump the RECLIST
Returns:
Cond:    --
 */
void PUBLIC Sync_DumpRecList(
        TWINRESULT tr,
        PRECLIST lprl,
        LPCTSTR pszMsg)
{
    BOOL bDump;
    PRECITEM lpri;
    TCHAR szBuf[MAXMSGLEN];

#define szDumpLabel   TEXT("Dump RECLIST: ")

    ENTEREXCLUSIVE();
    {
        bDump = IsFlagSet(g_uDumpFlags, DF_RECLIST);
    }
    LEAVEEXCLUSIVE();

    if (!bDump)
        return ;

    if (pszMsg)
        TRACE_MSG(TF_ALWAYS, pszMsg);

    // Note we only dump on TR_SUCCESS
    //
    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("tr = %s\r\n"), (LPTSTR)SzFromTR(tr));
    OutputDebugString(szBuf);

    if (lprl == NULL || tr == TR_OUT_OF_MEMORY || tr == TR_INVALID_PARAMETER)
        return ;

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.ulcItems = %lu\r\n"), (LPTSTR)szDumpLabel, lprl->ulcItems);
    OutputDebugString(szBuf);

    lpri = lprl->priFirst;
    while (lpri)
    {
        Sync_DumpRecItem(TR_SUCCESS, lpri, NULL);
        lpri = lpri->priNext;
    }

#undef szDumpLabel
}


/*----------------------------------------------------------
Purpose: Dump the FOLDERTWIN
Returns: --
Cond:    --
 */
void PUBLIC Sync_DumpFolderTwin(
        PCFOLDERTWIN pft)
{
    BOOL bDump;
    TCHAR szBuf[MAXMSGLEN];

#define szDumpLabel      TEXT("Dump FOLDERTWIN: ")
#define szDumpMargin     TEXT("                 ")

    ENTEREXCLUSIVE();
    {
        bDump = IsFlagSet(g_uDumpFlags, DF_FOLDERTWIN);
    }
    LEAVEEXCLUSIVE();

    if (!bDump || pft == NULL)
        return ;

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.Name = {%s}\r\n"), (LPTSTR)szDumpLabel, pft->pcszName);
    OutputDebugString(szBuf);

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.pszSrcFolder = {%s}\r\n"), (LPTSTR)szDumpMargin, pft->pcszSrcFolder);
    OutputDebugString(szBuf);

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.pszOtherFolder = {%s}\r\n"), (LPTSTR)szDumpMargin, pft->pcszOtherFolder);
    OutputDebugString(szBuf);

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.dwFlags = %lx\r\n"), (LPTSTR)szDumpMargin, pft->dwFlags);
    OutputDebugString(szBuf);

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.dwUser = %lx\r\n"), (LPTSTR)szDumpMargin, pft->dwUser);
    OutputDebugString(szBuf);

#undef szDumpLabel
#undef szDumpMargin
}


/*----------------------------------------------------------
Purpose: Dump the FOLDERTWINLIST
Returns: --
Cond:    --
 */
void PUBLIC Sync_DumpFolderTwinList(
        PFOLDERTWINLIST pftl,
        LPCTSTR pszMsg)
{
    BOOL bDump;
    PCFOLDERTWIN pft;
    TCHAR szBuf[MAXMSGLEN];

#define szDumpLabel   TEXT("Dump FOLDERTWINLIST: ")

    ENTEREXCLUSIVE();
    {
        bDump = IsFlagSet(g_uDumpFlags, DF_FOLDERTWIN);
    }
    LEAVEEXCLUSIVE();

    if (!bDump)
        return ;

    if (pszMsg)
        TRACE_MSG(TF_ALWAYS, pszMsg);

    if (pftl == NULL)
        return ;

    wnsprintf(szBuf, ARRAYSIZE(szBuf), TEXT("%s.ulcItems = %lu\r\n"), (LPTSTR)szDumpLabel, pftl->ulcItems);
    OutputDebugString(szBuf);

    for (pft = pftl->pcftFirst; pft; pft = pft->pcftNext)
    {
        Sync_DumpFolderTwin(pft);
    }

#undef szDumpLabel
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\syncui\update.h ===
//
// update.h: Declares data, defines and struct types for twin creation
//          module.
//
//

#ifndef __UPDATE_H__
#define __UPDATE_H__

// Flags for Upd_DoModal
#define UF_SELECTION    0x0001
#define UF_ALL          0x0002

int PUBLIC Upd_DoModal(HWND hwndOwner, CBS * pcbs, LPCTSTR pszList, UINT cFiles, UINT uFlags);

#endif // __UPDATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\inc\debugstr.h ===
/*
 * debugstr.h - Debug message strings.
 */


#ifdef DEBUG

/* TWINRESULT strings */

/*
 * N.b., this array of strings must match the TWINRESULTs defined in synceng.h.
 * The index of the pointer to the string corresponding to a TWINRESULT tr may
 * be determined as rgcpcszTwinResult[tr].
 */

CONST LPCTSTR rgcpcszTwinResult[] =
{
   TEXT("TR_SUCCESS"),
   TEXT("TR_RH_LOAD_FAILED"),
   TEXT("TR_SRC_OPEN_FAILED"),
   TEXT("TR_SRC_READ_FAILED"),
   TEXT("TR_DEST_OPEN_FAILED"),
   TEXT("TR_DEST_WRITE_FAILED"),
   TEXT("TR_ABORT"),
   TEXT("TR_UNAVAILABLE_VOLUME"),
   TEXT("TR_OUT_OF_MEMORY"),
   TEXT("TR_FILE_CHANGED"),
   TEXT("TR_DUPLICATE_TWIN"),
   TEXT("TR_DELETED_TWIN"),
   TEXT("TR_HAS_FOLDER_TWIN_SRC"),
   TEXT("TR_INVALID_PARAMETER"),
   TEXT("TR_REENTERED"),
   TEXT("TR_SAME_FOLDER"),
   TEXT("TR_SUBTREE_CYCLE_FOUND"),
   TEXT("TR_NO_MERGE_HANDLER"),
   TEXT("TR_MERGE_INCOMPLETE"),
   TEXT("TR_TOO_DIFFERENT"),
   TEXT("TR_BRIEFCASE_LOCKED"),
   TEXT("TR_BRIEFCASE_OPEN_FAILED"),
   TEXT("TR_BRIEFCASE_READ_FAILED"),
   TEXT("TR_BRIEFCASE_WRITE_FAILED"),
   TEXT("TR_CORRUPT_BRIEFCASE"),
   TEXT("TR_NEWER_BRIEFCASE"),
   TEXT("TR_NO_MORE")
};

/* CREATERECLISTPROCMSG strings */

/*
 * N.b., this array of strings must match the CREATERECLISTPROCs defined in
 * synceng.h.  The index of the pointer to the string corresponding to a
 * CREATERECLISTPROCMSG crlpm may be determined as
 * rgcpcszCreateRecListMsg[crlpm].
 */

const LPCTSTR rgcpcszCreateRecListMsg[] =
{
   TEXT("CRLS_BEGIN_CREATE_REC_LIST"),
   TEXT("CRLS_DELTA_CREATE_REC_LIST"),
   TEXT("CRLS_END_CREATE_REC_LIST")
};

/* RECSTATUSPROCMSGs strings */

/*
 * N.b., this array of strings must match the RECSTATUSPROCMSGs defined in
 * synceng.h.  The index of the pointer to the string corresponding to a
 * RECSTATUSPROCMSG rspm may be determined as rgcpcszRecStatusMsg[rspm].
 */

CONST LPCTSTR rgcpcszRecStatusMsg[] =
{
   TEXT("RS_BEGIN_COPY"),
   TEXT("RS_DELTA_COPY"),
   TEXT("RS_END_COPY"),
   TEXT("RS_BEGIN_MERGE"),
   TEXT("RS_DELTA_MERGE"),
   TEXT("RS_END_MERGE"),
   TEXT("RS_BEGIN_DELETE"),
   TEXT("RS_DELTA_DELETE"),
   TEXT("RS_END_DELETE")
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\inc\recguids.h ===
/*
 * recguids.h - OLE reconciliation interface GUID definitions.
 */


/* GUIDs
 ********/

DEFINE_GUID(IID_IReconcileInitiator, 0x99180161L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IReconcilableObject, 0x99180162L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_INotifyReplica,      0x99180163L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IBriefcaseInitiator, 0x99180164L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\inc\reconcil.h ===
/*
 * reconcil.h - OLE reconciliation interface definitions.
 */


#ifndef __RECONCIL_H__
#define __RECONCIL_H__


/* Headers
 **********/

#include <recguids.h>


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* for use in IStorage::SetStateBits() */

#define STATEBITS_FLAT                 (0x0001)

/* reconciliation SCODEs */

#define REC_S_IDIDTHEUPDATES           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1000)
#define REC_S_NOTCOMPLETE              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1001)
#define REC_S_NOTCOMPLETEBUTPROPAGATE  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1002)

#define REC_E_ABORTED                  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1000)
#define REC_E_NOCALLBACK               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1001)
#define REC_E_NORESIDUES               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1002)
#define REC_E_TOODIFFERENT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1003)
#define REC_E_INEEDTODOTHEUPDATES      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1004)


/* Interfaces
 *************/

#undef  INTERFACE
#define INTERFACE INotifyReplica

DECLARE_INTERFACE_(INotifyReplica, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* INotifyReplica methods */

   STDMETHOD(YouAreAReplica)(THIS_
                             ULONG ulcOtherReplicas,
                             IMoniker **rgpmkOtherReplicas) PURE;
};

#undef  INTERFACE
#define INTERFACE IReconcileInitiator

DECLARE_INTERFACE_(IReconcileInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcileInitiator methods */

   STDMETHOD(SetAbortCallback)(THIS_
                               IUnknown *punkForAbort) PURE;

   STDMETHOD(SetProgressFeedback)(THIS_
                                  ULONG ulProgress,
                                  ULONG ulProgressMax) PURE;
};

/* IReconcilableObject::Reconcile() flags */

typedef enum _reconcilef
{
   /* interaction with the user is allowed */

   RECONCILEF_MAYBOTHERUSER         = 0x0001,

   /*
    * hwndProgressFeedback may be used to provide reconciliation progress
    * feedback to the user.
    */

   RECONCILEF_FEEDBACKWINDOWVALID   = 0x0002,

   /* residue support not required */

   RECONCILEF_NORESIDUESOK          = 0x0004,

   /* caller not interested in callee's residues */

   RECONCILEF_OMITSELFRESIDUE       = 0x0008,

   /*
    * Reconcile() call resuming after a previous Reconcile() call returned
    * REC_E_NOTCOMPLETE
    */

   RECONCILEF_RESUMERECONCILIATION  = 0x0010,

   /* Object may perform all updates. */

   RECONCILEF_YOUMAYDOTHEUPDATES    = 0x0020,

   /* Only this object has been changed. */

   RECONCILEF_ONLYYOUWERECHANGED    = 0x0040,

   /* flag combinations */

   ALL_RECONCILE_FLAGS              = (RECONCILEF_MAYBOTHERUSER |
                                       RECONCILEF_FEEDBACKWINDOWVALID |
                                       RECONCILEF_NORESIDUESOK |
                                       RECONCILEF_OMITSELFRESIDUE |
                                       RECONCILEF_RESUMERECONCILIATION |
                                       RECONCILEF_YOUMAYDOTHEUPDATES |
                                       RECONCILEF_ONLYYOUWERECHANGED)
}
RECONCILEF;

#undef  INTERFACE
#define INTERFACE IReconcilableObject

DECLARE_INTERFACE_(IReconcilableObject, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcilableObject methods */

   STDMETHOD(Reconcile)(THIS_
                        IReconcileInitiator *pInitiator,
                        DWORD dwFlags,
                        HWND hwndOwner,
                        HWND hwndProgressFeedback,
                        ULONG ulcInput,
                        IMoniker **rgpmkOtherInput,
                        PLONG plOutIndex,
                        IStorage *pstgNewResidues,
                        PVOID pvReserved) PURE;

   STDMETHOD(GetProgressFeedbackMaxEstimate)(THIS_
                                             PULONG pulProgressMax) PURE;
};

#undef  INTERFACE
#define INTERFACE IBriefcaseInitiator

DECLARE_INTERFACE_(IBriefcaseInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IBriefcaseInitiator methods */

   STDMETHOD(IsMonikerInBriefcase)(THIS_
                                   IMoniker *pmk) PURE;
};


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __RECONCIL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\inc\indirect.h ===
/*
 * indirect.h - Object synchronization engine API types for type-safe indirect
 *              calling.
 */


/*
 * N.b., these API types must match the function prototypes defined in
 * <synceng.h>.  An API function pointer variable may be declared and called in
 * a type-safe manner as an instance of one of the given types, e.g.,
 *
 * HINSTANCE hinstSyncEng;
 *
 * hinstSyncEng = LoadLibrary("synceng.dll");
 *
 * if (hinstSyncEng > HINSTANCE_ERROR)
 * {
 *    OPENBRIEFCASEINDIRECT OpenBriefcaseIndirect;
 *
 *    OpenBriefcaseIndirect = (OPENBRIEFCASEINDIRECT)GetProcAddress(hinstSyncEng, "OpenBriefcase");
 *
 *    if (OpenBriefcaseIndirect)
 *    {
 *       TWINRESULT tr;
 *       HBRFCASE hbr;
 *
 *       tr = (*OpenBriefcaseIndirect)("c:\\chicago\\desktop\\foo.bfc\\briefcase.bfc", OB_FL_TANSLATE_DB_FOLDER, &hbr);
 *    }
 * }
 */


/* Types
 ********/

/* briefcase interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *OPENBRIEFCASEINDIRECT)(LPCTSTR, DWORD, HWND, PHBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *SAVEBRIEFCASEINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *CLOSEBRIEFCASEINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *DELETEBRIEFCASEINDIRECT)(LPCTSTR);
typedef SYNCENGAPI TWINRESULT (WINAPI *GETOPENBRIEFCASEINFOINDIRECT)(HBRFCASE, POPENBRFCASEINFO);
typedef SYNCENGAPI TWINRESULT (WINAPI *CLEARBRIEFCASECACHEINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *FINDFIRSTBRIEFCASEINDIRECT)(PHBRFCASEITER, PBRFCASEINFO);
typedef SYNCENGAPI TWINRESULT (WINAPI *FINDNEXTBRIEFCASEINDIRECT)(HBRFCASEITER, PBRFCASEINFO);
typedef SYNCENGAPI TWINRESULT (WINAPI *FINDBRIEFCASECLOSEINDIRECT)(HBRFCASEITER);

/* twin interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *ADDOBJECTTWININDIRECT)(HBRFCASE, PCNEWOBJECTTWIN, PHTWINFAMILY);
typedef SYNCENGAPI TWINRESULT (WINAPI *ADDFOLDERTWININDIRECT)(HBRFCASE, PCNEWFOLDERTWIN, PHFOLDERTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *RELEASETWINHANDLEINDIRECT)(HTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *DELETETWININDIRECT)(HTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *GETOBJECTTWINHANDLEINDIRECT)(HBRFCASE, LPCTSTR, LPCTSTR, PHOBJECTTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *ISFOLDERTWININDIRECT)(HBRFCASE, LPCTSTR, PBOOL);
typedef SYNCENGAPI TWINRESULT (WINAPI *CREATEFOLDERTWINLISTINDIRECT)(HBRFCASE, LPCTSTR, PFOLDERTWINLIST *);
typedef SYNCENGAPI TWINRESULT (WINAPI *DESTROYFOLDERTWINLISTINDIRECT)(PFOLDERTWINLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *ISORPHANOBJECTTWININDIRECT)(HOBJECTTWIN, PBOOL);
typedef SYNCENGAPI TWINRESULT (WINAPI *COUNTSOURCEFOLDERTWINSINDIRECT)(HOBJECTTWIN, PULONG);
typedef SYNCENGAPI TWINRESULT (WINAPI *ANYTWINSINDIRECT)(HBRFCASE, PBOOL);

/* twin list interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *CREATETWINLISTINDIRECT)(HBRFCASE, PHTWINLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *DESTROYTWINLISTINDIRECT)(HTWINLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *ADDTWINTOTWINLISTINDIRECT)(HTWINLIST, HTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *ADDALLTWINSTOTWINLISTINDIRECT)(HTWINLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *REMOVETWINFROMTWINLISTINDIRECT)(HTWINLIST, HTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *REMOVEALLTWINSFROMTWINLISTINDIRECT)(HTWINLIST);

/* reconciliation list interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *CREATERECLISTINDIRECT)(HTWINLIST, CREATERECLISTPROC, LPARAM, PRECLIST *);
typedef SYNCENGAPI TWINRESULT (WINAPI *DESTROYRECLISTINDIRECT)(PRECLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *RECONCILEITEMINDIRECT)(PCRECITEM, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
typedef SYNCENGAPI TWINRESULT (WINAPI *BEGINRECONCILIATIONINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *ENDRECONCILIATIONINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *GETFOLDERTWINSTATUSINDIRECT)(HFOLDERTWIN, CREATERECLISTPROC, LPARAM, PFOLDERTWINSTATUS);

/* file stamp interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *GETFILESTAMPINDIRECT)(LPCTSTR, PFILESTAMP);
typedef SYNCENGAPI TWINRESULT (WINAPI *COMPAREFILESTAMPSINDIRECT)(PCFILESTAMP, PCFILESTAMP, PCOMPARISONRESULT);

/* volume ID interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *ISPATHONVOLUMEINDIRECT)(LPCTSTR, HVOLUMEID, PBOOL);
typedef SYNCENGAPI TWINRESULT (WINAPI *GETVOLUMEDESCRIPTIONINDIRECT)(HVOLUMEID, PVOLUMEDESC);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\cabitms.cpp ===
//*******************************************************************************************
//
// Filename : CabItms.cpp
//	
//				Implementation file for CMemFile, CCabEnum and CCabExtract
//
// Copyright (c) 1994 - 1996 Microsoft Corporation. All rights reserved
//
//*******************************************************************************************

#include "pch.h"
#include "ccstock.h"
#include "thisdll.h"

#include "resource.h"

#include "fdi.h"
#include "cabitms.h"

class CMemFile
{
public:
	CMemFile(HGLOBAL *phMem, DWORD dwSize);
	~CMemFile() {}

	BOOL Create(LPCTSTR pszFile);
	BOOL Open(LPCTSTR pszFile, int oflag);
	LONG Seek(LONG dist, int seektype);
	UINT Read(LPVOID pv, UINT cb);
	UINT Write(LPVOID pv, UINT cb);
	HANDLE Close();

private:
	HANDLE m_hf;

	HGLOBAL *m_phMem;
	DWORD m_dwSize;
	LONG m_lLoc;
} ;


CMemFile::CMemFile(HGLOBAL *phMem, DWORD dwSize) : m_hf(INVALID_HANDLE_VALUE), m_lLoc(0)
{
	m_phMem = phMem;
	m_dwSize = dwSize;

	if (phMem)
	{
		*phMem = NULL;
	}
}


BOOL CMemFile::Create(LPCTSTR pszFile)
{
	if (m_phMem)
	{
		if (*m_phMem)
		{
			return(FALSE);
		}

		*m_phMem = GlobalAlloc(LMEM_FIXED, m_dwSize);
		return(*m_phMem != NULL);
	}
	else
	{
		if (m_hf != INVALID_HANDLE_VALUE)
		{
			return(FALSE);
		}

        m_hf = CreateFile(pszFile,
                          GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);
		return (m_hf != INVALID_HANDLE_VALUE);
	}
}


BOOL CMemFile::Open(LPCTSTR pszFile, int oflag)
{
	if (m_phMem)
	{
		return(FALSE);
	}
	else
	{
		if (m_hf != INVALID_HANDLE_VALUE)
		{
			return(FALSE);
		}

        m_hf = CreateFile(pszFile,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          oflag,
                          NULL);
		return (m_hf != INVALID_HANDLE_VALUE);
	}
}


LONG CMemFile::Seek(LONG dist, int seektype)
{
	if (m_phMem)
	{
		if (!*m_phMem)
		{
			return -1;
		}

		switch (seektype)
		{
		case FILE_BEGIN:
			break;

		case FILE_CURRENT:
			dist += m_lLoc;
			break;

		case FILE_END:
			dist = m_dwSize - dist;
			break;

		default:
			return -1;
		}

		if (dist<0 || dist>(LONG)m_dwSize)
		{
			return -1;
		}

		m_lLoc = dist;
		return(dist);
	}
	else
	{
		return(_llseek((HFILE)HandleToUlong(m_hf), dist, seektype));
	}
}


UINT CMemFile::Read(LPVOID pv, UINT cb)
{
	if (m_phMem)
	{
		if (!*m_phMem)
		{
			return -1;
		}

		if (cb > m_dwSize - m_lLoc)
		{
			cb = m_dwSize - m_lLoc;
		}

		hmemcpy(pv, (LPSTR)(*m_phMem)+m_lLoc, cb);
		m_lLoc += cb;
		return(cb);
	}
	else
	{
		return(_lread((HFILE)HandleToUlong(m_hf), pv, cb));
	}
}


UINT CMemFile::Write(LPVOID pv, UINT cb)
{
	if (m_phMem)
	{
		if (!*m_phMem)
		{
			return -1;
		}

		if (cb > m_dwSize - m_lLoc)
		{
			cb = m_dwSize - m_lLoc;
		}

		hmemcpy((LPSTR)(*m_phMem)+m_lLoc, pv, cb);
		m_lLoc += cb;
		return(cb);
	}
	else
	{
		return(_lwrite((HFILE)HandleToUlong(m_hf), (LPCSTR)pv, cb));
	}
}


HANDLE CMemFile::Close()
{
	HANDLE hRet;

	if (m_phMem)
	{
		hRet = *m_phMem ? 0 : INVALID_HANDLE_VALUE;
	}
	else
	{
		hRet = LongToHandle(_lclose((HFILE)HandleToUlong(m_hf)));
	}

	delete this;

	return(hRet);
}

//*****************************************************************************
//
// CCabEnum
//
// Purpose:
//
//        Class encapsulating all the FDI operations
//
// Comments:
//
//*****************************************************************************

class CCabEnum
{
public:
	CCabEnum() : m_hfdi(0) {}
	~CCabEnum() {}

protected:
	static void HUGE * FAR DIAMONDAPI CabAlloc(ULONG cb);
	static void FAR DIAMONDAPI CabFree(void HUGE *pv);
	static INT_PTR FAR DIAMONDAPI CabOpen(char FAR *pszFile, int oflag, int pmode);
	static UINT FAR DIAMONDAPI CabRead(INT_PTR hf, void FAR *pv, UINT cb);
	static UINT FAR DIAMONDAPI CabWrite(INT_PTR hf, void FAR *pv, UINT cb);
	static int  FAR DIAMONDAPI CabClose(INT_PTR hf);
	static long FAR DIAMONDAPI CabSeek(INT_PTR hf, long dist, int seektype);

	BOOL StartEnum();
	BOOL SimpleEnum(LPCTSTR szCabFile, PFNFDINOTIFY pfnCallBack, LPVOID pv);
	void EndEnum();

	HFDI m_hfdi;
	ERF  m_erf;

private:
	static CMemFile * s_hSpill;
} ;


CMemFile * CCabEnum::s_hSpill = NULL;

void HUGE * FAR DIAMONDAPI CCabEnum::CabAlloc(ULONG cb)
{
    return(GlobalAllocPtr(GHND, cb));
}

void FAR DIAMONDAPI CCabEnum::CabFree(void HUGE *pv)
{
    GlobalFreePtr(pv);
}

INT_PTR FAR DIAMONDAPI CCabEnum::CabOpen(char FAR *pszFile, int oflag, int pmode)
{
    if(!pszFile)
    {
      return -1;
    }

    // See if we are opening the spill file.
    if( *pszFile=='*' )
    {
		TCHAR szSpillFile[MAX_PATH];
		TCHAR szTempPath[MAX_PATH];

        if(s_hSpill != NULL)
            return -1;

		GetTempPath(ARRAYSIZE(szTempPath), szTempPath);
		GetTempFileName(szTempPath, TEXT("fdi"), 0, szSpillFile);

        s_hSpill = new CMemFile(NULL, 0);
		if (!s_hSpill)
		{
			return(-1);
		}
        if (!s_hSpill->Create(szSpillFile))
		{
			delete s_hSpill;
			s_hSpill = NULL;
			return(-1);
		}

        // Set its extent.
        if( s_hSpill->Seek( ((FDISPILLFILE FAR *)pszFile)->cbFile-1, 0) == HFILE_ERROR)
        {
			s_hSpill->Close();
			s_hSpill = NULL;
			return -1;
        }
        s_hSpill->Write(szSpillFile, 1);

        return (INT_PTR)s_hSpill;
    }

    CMemFile *hFile = new CMemFile(NULL, 0);
	if (!hFile)
	{
		return(-1);
	}

    TCHAR szFile[MAX_PATH];
    SHAnsiToTChar(pszFile, szFile, ARRAYSIZE(szFile));
    while (!hFile->Open(szFile, oflag))
    {
        // TODO: No UI for inserting a disk at this point
		delete hFile;
		return(-1);
    }
   	
    return((INT_PTR)hFile);
}


UINT FAR DIAMONDAPI CCabEnum::CabRead(INT_PTR hf, void FAR *pv, UINT cb)
{
	CMemFile *hFile = (CMemFile *)hf;

    return(hFile->Read(pv,cb));
}


UINT FAR DIAMONDAPI CCabEnum::CabWrite(INT_PTR hf, void FAR *pv, UINT cb)
{
	CMemFile *hFile = (CMemFile *)hf;

	return(hFile->Write(pv,cb));
}


int FAR DIAMONDAPI CCabEnum::CabClose(INT_PTR hf)
{
	CMemFile *hFile = (CMemFile *)hf;

    // Special case for the deletion of the spill file.
    if(hFile == s_hSpill)
	{
        s_hSpill = NULL;
	}

    return (int)HandleToUlong(hFile->Close());
}


long FAR DIAMONDAPI CCabEnum::CabSeek(INT_PTR hf, long dist, int seektype)
{
	CMemFile *hFile = (CMemFile *)hf;

    return(hFile->Seek(dist, seektype));
}


BOOL CCabEnum::StartEnum()
{
	if (m_hfdi)
	{
		// We seem to already be enumerating
		return(FALSE);
	}

	m_hfdi = FDICreate(
		CabAlloc,
        CabFree,
        CabOpen,
        CabRead,
        CabWrite,
        CabClose,
        CabSeek,
        cpu80386,
        &m_erf);

	return(m_hfdi != NULL);
}


BOOL CCabEnum::SimpleEnum(LPCTSTR szCabFile, PFNFDINOTIFY pfnCallBack, LPVOID pv)
{
	char szCabPath[MAX_PATH];
	char szCabName[MAX_PATH];

	// Path should be fully qualified
    char szFile[MAX_PATH];
    SHTCharToAnsi(szCabFile, szFile, ARRAYSIZE(szFile));
    lstrcpynA(szCabPath, szFile, ARRAYSIZE(szCabPath));
	LPSTR pszName = PathFindFileNameA(szCabPath);
	if (!pszName)
	{
		return(FALSE);
	}

	lstrcpynA(szCabName, pszName, ARRAYSIZE(szCabName));
	*pszName = '\0';

	if (!StartEnum())
	{
		return(FALSE);
	}

	BOOL bRet = FDICopy(
		m_hfdi,
		szCabName,
		szCabPath,		// path to cabinet files
		0,				// flags
		pfnCallBack,
		NULL,
		pv);

	EndEnum();

	return(bRet);
}


void CCabEnum::EndEnum()
{
	if (!m_hfdi)
	{
		return;
	}

	FDIDestroy(m_hfdi);
	m_hfdi = NULL;
}


class CCabItemsCB : private CCabEnum
{
public:
	CCabItemsCB(CCabItems::PFNCABITEM pfnCallBack, LPARAM lParam)
	{
		m_pfnCallBack = pfnCallBack;
		m_lParam = lParam;
	}
	~CCabItemsCB() {}

	BOOL DoEnum(LPCTSTR szCabFile)
	{
		return(SimpleEnum(szCabFile, CabItemsNotify, this));
	}

private:
	static INT_PTR FAR DIAMONDAPI CabItemsNotify(FDINOTIFICATIONTYPE fdint,
		PFDINOTIFICATION pfdin);

	CCabItems::PFNCABITEM m_pfnCallBack;
	LPARAM m_lParam;
} ;


INT_PTR FAR DIAMONDAPI CCabItemsCB::CabItemsNotify(FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin)
{
	CCabItemsCB *pThis = (CCabItemsCB *)pfdin->pv;			

    // uiYield( g_hwndSetup );
    TCHAR szFile[MAX_PATH];
    if (NULL != pfdin->psz1)
    {
        // NOTE: CP_UTF8 is not supported on Win9x!
        SHAnsiToTCharCP((_A_NAME_IS_UTF & pfdin->attribs) ? CP_UTF8 : CP_ACP,
                        pfdin->psz1,
                        szFile,
                        ARRAYSIZE(szFile));
    }

    switch (fdint)
    {
    case fdintCOPY_FILE:
        pThis->m_pfnCallBack(pfdin->psz1 ? szFile : NULL,
                             pfdin->cb,
                             pfdin->date,
                             pfdin->time,
                             pfdin->attribs,
                             pThis->m_lParam);
		break;

	default:
		break;
    } // end switch

    return 0;
}

//*****************************************************************************
//
// CCabItems::EnumItems
//
// Purpose:
//
//        Enumerate the items in the cab file
//
//
// Comments:
//
//         lParam contains pointer to CCabFolder
//
//*****************************************************************************

BOOL CCabItems::EnumItems(PFNCABITEM pfnCallBack, LPARAM lParam)
{
	CCabItemsCB cItems(pfnCallBack, lParam);

	return(cItems.DoEnum(m_szCabFile));
}

//*****************************************************************************
//
// CCabExtractCB
//
// Purpose:
//
//        handles the call back while extracting Cab files
//
//
//*****************************************************************************

class CCabExtractCB : private CCabEnum
{
public:
	CCabExtractCB(LPCTSTR szDir, HWND hwndOwner, CCabExtract::PFNCABEXTRACT pfnCallBack,
		LPARAM lParam)
	{
		m_szDir = szDir;
		m_hwndOwner = hwndOwner;
		m_pfnCallBack = pfnCallBack;
		m_lParam = lParam;
		m_bTryNextCab = FALSE;
	}
	~CCabExtractCB() {}

	BOOL DoEnum(LPCTSTR szCabFile)
	{
		return(SimpleEnum(szCabFile, CabExtractNotify, this));
	}

private:
	static INT_PTR FAR DIAMONDAPI CabExtractNotify(FDINOTIFICATIONTYPE fdint,
		PFDINOTIFICATION pfdin);
	static int CALLBACK CCabExtractCB::BrowseNotify(HWND hwnd, UINT uMsg, LPARAM lParam,
		LPARAM lpData);

	LPCTSTR m_szDir;
	HWND m_hwndOwner;
	CCabExtract::PFNCABEXTRACT m_pfnCallBack;
	LPARAM m_lParam;
	BOOL m_bTryNextCab;
	PFDINOTIFICATION m_pfdin;
} ;


int CALLBACK CCabExtractCB::BrowseNotify(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
	CCabExtractCB *pThis = (CCabExtractCB *)lpData;			

	switch (uMsg)
	{
	case BFFM_INITIALIZED:
	{
		// Set initial folder
		if (lstrlenA(pThis->m_pfdin->psz3) < 3)
		{
			// append if drive root
            PathAddBackslashA(pThis->m_pfdin->psz3);
        }
		SendMessage(hwnd, BFFM_SETSELECTION, 1, (LPARAM)pThis->m_pfdin->psz3);
		break;
	}

	default:
		return(0);
	}

	return(1);
}


INT_PTR FAR DIAMONDAPI CCabExtractCB::CabExtractNotify(FDINOTIFICATIONTYPE fdint,
	PFDINOTIFICATION pfdin)
{
	CCabExtractCB *pThis = (CCabExtractCB *)pfdin->pv;			

    // uiYield( g_hwndSetup );

    switch (fdint)
    {
	case fdintCABINET_INFO:
		pThis->m_bTryNextCab = TRUE;
		break;

	case fdintNEXT_CABINET:
	{
		if (pThis->m_bTryNextCab)
		{
			// Automatically open next cab if already in default dir
			pThis->m_bTryNextCab = FALSE;
			return(1);
		}

		pThis->m_pfdin = pfdin;

		TCHAR szFormat[80];
		TCHAR szTitle[80 + 2*MAX_PATH];
		if (pfdin->psz2[0] != '\0')
		{
			LoadString(g_ThisDll.GetInstance(), IDS_NEXTDISKBROWSE, szFormat, ARRAYSIZE(szFormat));
		}
		else
		{
			LoadString(g_ThisDll.GetInstance(), IDS_NEXTCABBROWSE, szFormat, ARRAYSIZE(szFormat));
		}
		wnsprintf(szTitle, ARRAYSIZE(szTitle), szFormat, (LPSTR) (pfdin->psz1), (LPSTR) (pfdin->psz2));

		BROWSEINFO bi;
		bi.hwndOwner = pThis->m_hwndOwner;
		bi.pidlRoot = NULL;
		bi.pszDisplayName = NULL;
		bi.lpszTitle = szTitle;
		bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;
		bi.lpfn = BrowseNotify;
		bi.lParam = (LPARAM)pThis;

		LPITEMIDLIST pidl = SHBrowseForFolder(&bi);

		if (bi.pidlRoot)
		{
			ILFree((LPITEMIDLIST)bi.pidlRoot);
		}

		if (!pidl)
		{
			return(-1);
		}

        CHAR szPath[MAX_PATH];
		BOOL bSuccess = SHGetPathFromIDListA(pidl, szPath);
		ILFree(pidl);

		if (bSuccess)
		{
			PathAddBackslashA(szPath);
            StrCpyNA(pfdin->psz3, szPath, 256); // psz3 is 256 bytes long...
			return(1);
		}

		return(-1);
	}

    case fdintCOPY_FILE:
	{
	    TCHAR szFile[MAX_PATH];
        if (NULL != pfdin->psz1)
        {
            // NOTE: CP_UTF8 is not supported on Win9x!
            SHAnsiToTCharCP((_A_NAME_IS_UTF & pfdin->attribs) ? CP_UTF8 : CP_ACP,
                            pfdin->psz1,
                            szFile,
                            ARRAYSIZE(szFile));
        }
        else
        {
            szFile[0] = TEXT('\0');
        }

        HGLOBAL *phMem = pThis->m_pfnCallBack(pfdin->psz1 ? szFile : NULL,
                                              pfdin->cb,
                                              pfdin->date,
                                              pfdin->time,
                                              pfdin->attribs,
                                              pThis->m_lParam);
		if (!phMem)
		{
			break;
		}

		TCHAR szTemp[MAX_PATH];

		CMemFile *hFile;

		if (pThis->m_szDir == DIR_MEM)
		{
			*szTemp = '\0';
			hFile = new CMemFile(phMem, pfdin->cb);
		}
		else
		{
			PathCombine(szTemp, pThis->m_szDir, PathFindFileName(szFile));
			hFile = new CMemFile(NULL, 0);
		}

		if (!hFile)
		{
			break;
		}

		if (hFile->Create(szTemp))
		{
			return((INT_PTR)hFile);
		}

		delete hFile;

		break;
	}

    case fdintCLOSE_FILE_INFO:
	{
		CMemFile *hFile = (CMemFile *)pfdin->hf;

		return(hFile->Close() == 0);
	}

	default:
		break;
    } // end switch

    return 0;
}

HRESULT CCabExtract::_DoDragDrop(HWND hwnd, IDataObject* pdo, LPCITEMIDLIST pidlFolder)
{
    IShellFolder *psf;
    HRESULT hres = SHBindToObject(NULL, IID_IShellFolder, pidlFolder, (LPVOID*)&psf);

    // This should always succeed because the caller (SHBrowseForFolder) should
    // have weeded out the non-folders.
    if (SUCCEEDED(hres))
    {
        IDropTarget *pdrop;

        hres = psf->CreateViewObject(NULL, IID_IDropTarget, (void**)&pdrop);
        if (SUCCEEDED(hres))    // Will fail for some targets. (Like Nethood->Entire Network)
        {
            // May fail if items aren't compatible for drag/drop. (Nethood is one example)
            // MK_CONTROL | MKLBUTTON is used to suggest a "copy":
            hres = SHSimulateDrop(pdrop, pdo, MK_CONTROL | MK_LBUTTON, NULL, NULL);
            pdrop->Release();
        }

        psf->Release();
    }

    return hres;
}

int BrowseCallback(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData)
{
    switch (msg)
    {
    case BFFM_INITIALIZED:
        {
            // Set the caption. ('Select a destination')
            TCHAR szTitle[100];
            LoadString(g_ThisDll.GetInstance(), IDS_EXTRACTBROWSE_CAPTION, szTitle, ARRAYSIZE(szTitle));
            SetWindowText(hwnd, szTitle);

            // Set the text of the Ok Button.
            TCHAR szOK[100];
            LoadString(g_ThisDll.GetInstance(), IDS_EXTRACTBROWSE_EXTRACT, szOK, ARRAYSIZE(szOK));
            SendMessage(hwnd, BFFM_SETOKTEXT, 0, (LPARAM)szOK);
        }
        break;

    case BFFM_SELCHANGED:
        {
            LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
            BOOL bEnableOk = FALSE;
            IShellFolder *psf;
            LPCITEMIDLIST pidlChild;
            if (SUCCEEDED(SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
            {
                DWORD dwAttributes = SFGAO_FILESYSTEM;
                psf->GetAttributesOf(1, &pidlChild, &dwAttributes);
                psf->Release();
                bEnableOk = dwAttributes & SFGAO_FILESYSTEM;    // is FS?
            }

            SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM) 0, (LPARAM) bEnableOk);
        }
        break;
    }
    return 0;
}

BOOL CCabExtract::ExtractToFolder(HWND hwndOwner, IDataObject* pdo, PFNCABEXTRACT pfnCallBack, LPARAM lParam)
{
    // ASSERT(pdo);
	TCHAR szTitle[120];
	LoadString(g_ThisDll.GetInstance(), IDS_EXTRACTBROWSE, szTitle, ARRAYSIZE(szTitle));

	BROWSEINFO bi;
	bi.hwndOwner = hwndOwner;
	bi.pidlRoot = NULL;
	bi.pszDisplayName = NULL;
	bi.lpszTitle = szTitle;
	bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE | BIF_UAHINT;
	bi.lpfn = BrowseCallback;

	LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
	if (!pidl)
	{
		return(FALSE);
	}

	BOOL bSuccess = SUCCEEDED(_DoDragDrop(hwndOwner, pdo, pidl));

	ILFree(pidl);
	
	return bSuccess;
}


BOOL CCabExtract::ExtractItems(HWND hwndOwner, LPCTSTR szDir, PFNCABEXTRACT pfnCallBack, LPARAM lParam)
{
	// ASSERT(szDir);
	CCabExtractCB cExtract(szDir, hwndOwner, pfnCallBack, lParam);

	// Display Wait cursor until done copying
	CWaitCursor cWait;

	return(cExtract.DoEnum(m_szCabFile));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\cabitms.h ===
//*******************************************************************************************
//
// Filename : CabItms.h
//	
//				Definitions of CCabItems and CCabExtract
//
// Copyright (c) 1994 - 1996 Microsoft Corporation. All rights reserved
//
//*******************************************************************************************

#ifndef _CABITMS_H_
#define _CABITMS_H_

#include "fdi.h"

class CCabItems
{
public:
	typedef void (CALLBACK *PFNCABITEM)(LPCTSTR pszFile, DWORD dwSize, UINT date,
		UINT time, UINT attribs, LPARAM lParam);

	CCabItems(LPTSTR szCabFile) {lstrcpyn(m_szCabFile, szCabFile, ARRAYSIZE(m_szCabFile));}
	~CCabItems() {}

	BOOL EnumItems(PFNCABITEM pfnCallBack, LPARAM lParam);

private:
	TCHAR m_szCabFile[MAX_PATH];
} ;

class CCabExtract
{
public:
	#define DIR_MEM ((LPCTSTR)1)

	#define EXTRACT_FALSE ((HGLOBAL *)0)
	#define EXTRACT_TRUE ((HGLOBAL *)1)

	typedef HGLOBAL * (CALLBACK *PFNCABEXTRACT)(LPCTSTR pszFile, DWORD dwSize, UINT date,
		UINT time, UINT attribs, LPARAM lParam);

	CCabExtract(LPTSTR szCabFile) {lstrcpyn(m_szCabFile, szCabFile, ARRAYSIZE(m_szCabFile));}
	~CCabExtract() {}

	BOOL ExtractItems(HWND hwndOwner, LPCTSTR szDir, PFNCABEXTRACT pfnCallBack, LPARAM lParam);
	BOOL ExtractToFolder(HWND hwndOwner, IDataObject* pdo, PFNCABEXTRACT pfnCallBack, LPARAM lParam);

private:
    HRESULT _DoDragDrop(HWND hwnd, IDataObject* pdo, LPCITEMIDLIST pidlFolder);

	TCHAR m_szCabFile[MAX_PATH];
} ;

#endif // _CABITMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\dataobj.cpp ===
//*******************************************************************************************
//
// Filename : DataObj.cpp
//    
// Implementation file for CObjFormats and CCabObj
//
// Copyright (c) 1994 - 1996 Microsoft Corporation. All rights reserved
//
//*******************************************************************************************

#include "pch.h"
#include "ccstock.h"
#include "thisdll.h"
#include "folder.h"
#include "dataobj.h"

#include "cabitms.h"

UINT CCabObj::s_uFileGroupDesc = 0;
UINT CCabObj::s_uFileContents = 0;
UINT CCabObj::s_uPersistedDataObject = 0;
UINT CCabObj::s_uHIDA = 0;

// {dfe49cfe-cd09-11d2-9643-00c04f79adf0}
const GUID CLSID_CabViewDataObject = {0xdfe49cfe, 0xcd09, 0x11d2, 0x96, 0x43, 0x00, 0xc0, 0x4f, 0x79, 0xad, 0xf0};

#define    MAX_CHUNK    (60*1024)    /* max mouthful to CopyTo from CCabStream */

class CCabStream : public IStream
{
public:
    CCabStream(HGLOBAL hStream,DWORD dwStreamLength);
    ~CCabStream(void);

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IStream methods ***
    STDMETHODIMP Read(void *pv,ULONG cb,ULONG *pcbRead);
    STDMETHODIMP Write(const void *pv,ULONG cb,ULONG *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER * plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream * pstm,    ULARGE_INTEGER cb, ULARGE_INTEGER * pcbRead, ULARGE_INTEGER * pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert(void);
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG * pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream ** ppstm);

private:
    CRefCount m_cRef;
    CRefDll m_cRefDll;
    HGLOBAL m_hStream;
    DWORD m_dwStreamLength;
    DWORD m_dwStreamPosition;
};

CCabStream::CCabStream(HGLOBAL hStream,DWORD dwStreamLength)
{
    m_hStream = hStream;
    m_dwStreamLength = dwStreamLength;
    m_dwStreamPosition = 0;

    AddRef();
}

CCabStream::~CCabStream(void)
{
    GlobalFree(m_hStream);
}

STDMETHODIMP CCabStream::QueryInterface(
   REFIID riid, 
   LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    LPUNKNOWN pObj;
 
    if (riid == IID_IUnknown)
    {
        pObj = (IUnknown*)((IStream *)this); 
    }
    else if (riid == IID_IStream)
    {
        pObj = (IUnknown*)((IStream *)this); 
    }
    else
    {
           return(E_NOINTERFACE);
    }

    pObj->AddRef();
    *ppvObj = pObj;

    return(NOERROR);
}

STDMETHODIMP_(ULONG) CCabStream::AddRef(void)
{
    return(m_cRef.AddRef());
}

STDMETHODIMP_(ULONG) CCabStream::Release(void)
{
    if (!m_cRef.Release())
    {
           delete this;
        return(0);
    }

    return(m_cRef.GetRef());
}

STDMETHODIMP CCabStream::Read(void * pv, ULONG cb, ULONG * pcbRead)
{
    *pcbRead = 0;

    if (m_dwStreamPosition < m_dwStreamLength)
    {
        if (cb > (m_dwStreamLength - m_dwStreamPosition))
        {
            *pcbRead = (m_dwStreamLength - m_dwStreamPosition);
        }
        else
        {
            *pcbRead = cb;
        }

        CopyMemory(pv,(char *) m_hStream + m_dwStreamPosition,*pcbRead);
        m_dwStreamPosition += *pcbRead;
    }

    return(S_OK);
}

STDMETHODIMP CCabStream::Write(const void * pv, ULONG cb, ULONG * pcbWritten)
{
    return(E_NOTIMPL);
}

STDMETHODIMP CCabStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER * plibNewPosition)
{
    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        m_dwStreamPosition = dlibMove.LowPart;
        break;

    case STREAM_SEEK_CUR:
        m_dwStreamPosition += dlibMove.LowPart;
        break;

    case STREAM_SEEK_END:
        m_dwStreamPosition = m_dwStreamLength + dlibMove.LowPart;
        break;

    default:
        return(STG_E_INVALIDFUNCTION);
    }

    if (plibNewPosition)
    {
        (*plibNewPosition).LowPart = m_dwStreamPosition;
        (*plibNewPosition).HighPart = 0;
    }

    return(S_OK);
}

STDMETHODIMP CCabStream::SetSize(ULARGE_INTEGER libNewSize)
{
    return(E_NOTIMPL);
}

STDMETHODIMP CCabStream::CopyTo(IStream * pstm, ULARGE_INTEGER cb, ULARGE_INTEGER * pcbRead, ULARGE_INTEGER * pcbWritten)
{
    HRESULT hRes;
    unsigned long cbActual = cb.LowPart;
    unsigned long cbWritten;
    unsigned long cbChunk;

    if (pcbRead)
    {
        (*pcbRead).LowPart = 0;
        (*pcbRead).HighPart = 0;
    }

    if (pcbWritten)
    {
        (*pcbWritten).LowPart = 0;
        (*pcbWritten).HighPart = 0;
    }

    hRes = S_OK;

    if (m_dwStreamPosition < m_dwStreamLength)
    {
        if (cbActual > (m_dwStreamLength - m_dwStreamPosition))
        {
            cbActual = (m_dwStreamLength - m_dwStreamPosition);
        }

        while (cbActual)
        {
            if (cbActual > MAX_CHUNK)
            {
                cbChunk = MAX_CHUNK;
            }
            else
            {
                cbChunk = cbActual;
            }

            hRes = pstm->Write((char *) m_hStream + m_dwStreamPosition,cbChunk,&cbWritten);
            if (FAILED(hRes))
            {
                break;
            }

            m_dwStreamPosition += cbChunk;

            if (pcbRead)
            {
                (*pcbRead).LowPart += cbChunk;
                (*pcbRead).HighPart = 0;
            }

            if (pcbWritten)
            {
                (*pcbWritten).LowPart += cbWritten;
                (*pcbWritten).HighPart = 0;
            }

            cbActual -= cbChunk;
        }
    }

    return(hRes);
}

STDMETHODIMP CCabStream::Commit(DWORD grfCommitFlags)
{
    return(E_NOTIMPL);
}

STDMETHODIMP CCabStream::Revert(void)
{
    return(E_NOTIMPL);
}

STDMETHODIMP CCabStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return(E_NOTIMPL);
}

STDMETHODIMP CCabStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return(E_NOTIMPL);
}

STDMETHODIMP CCabStream::Stat(STATSTG * pstatstg, DWORD grfStatFlag)
{
    return(E_NOTIMPL);
}

STDMETHODIMP CCabStream::Clone(IStream ** ppstm)
{
    return(E_NOTIMPL);
}



class CObjFormats : public IEnumFORMATETC
{
public:
    CObjFormats(UINT cfmt, const FORMATETC afmt[]);
    ~CObjFormats();

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IEnumFORMATETC methods ***
    STDMETHODIMP Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumFORMATETC ** ppenum);

private:
    CRefCount m_cRef;

    CRefDll m_cRefDll;

    UINT m_iFmt;
    UINT m_cFmt;
    FORMATETC *m_aFmt;
} ;


CObjFormats::CObjFormats(UINT cfmt, const FORMATETC afmt[])
{
    m_iFmt = 0;
    m_cFmt = cfmt;
    m_aFmt = new FORMATETC[cfmt];

    if (m_aFmt)
    {
        CopyMemory(m_aFmt, afmt, cfmt*sizeof(afmt[0]));
    }
}


CObjFormats::~CObjFormats()
{
    if (m_aFmt)
    {
        delete m_aFmt;
    }
}


// *** IUnknown methods ***
STDMETHODIMP CObjFormats::QueryInterface(
   REFIID riid, 
   LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (!m_aFmt)
    {
        return(E_OUTOFMEMORY);
    }

    LPUNKNOWN pObj;
 
    if (riid == IID_IUnknown)
    {
        pObj = (IUnknown*)((IEnumFORMATETC*)this); 
    }
    else if (riid == IID_IEnumFORMATETC)
    {
        pObj = (IUnknown*)((IEnumFORMATETC*)this); 
    }
    else
    {
           return(E_NOINTERFACE);
    }

    pObj->AddRef();
    *ppvObj = pObj;

    return(NOERROR);
}


STDMETHODIMP_(ULONG) CObjFormats::AddRef(void)
{
    return(m_cRef.AddRef());
}


STDMETHODIMP_(ULONG) CObjFormats::Release(void)
{
    if (!m_cRef.Release())
    {
           delete this;
        return(0);
    }

    return(m_cRef.GetRef());
}


STDMETHODIMP CObjFormats::Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed)
{
    UINT cfetch;
    HRESULT hres = S_FALSE;    // assume less numbers

    if (m_iFmt < m_cFmt)
    {
        cfetch = m_cFmt - m_iFmt;
        if (cfetch >= celt)
        {
            cfetch = celt;
            hres = S_OK;
        }

        CopyMemory(rgelt, &m_aFmt[m_iFmt], cfetch * sizeof(FORMATETC));
        m_iFmt += cfetch;
    }
    else
    {
        cfetch = 0;
    }

    if (pceltFethed)
    {
        *pceltFethed = cfetch;
    }

    return hres;
}

STDMETHODIMP CObjFormats::Skip(ULONG celt)
{
    m_iFmt += celt;
    if (m_iFmt > m_cFmt)
    {
        m_iFmt = m_cFmt;
        return S_FALSE;
    }
    return S_OK;
}

STDMETHODIMP CObjFormats::Reset()
{
    m_iFmt = 0;
    return S_OK;
}

STDMETHODIMP CObjFormats::Clone(IEnumFORMATETC ** ppenum)
{
    return(E_NOTIMPL);
}

HRESULT CabViewDataObject_CreateInstance(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr;
    CCabObj* pco = new CCabObj();
    if (NULL != pco)
    {
        pco->AddRef();
        hr = pco->QueryInterface(riid, ppvObj);
        pco->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

CCabObj::CCabObj(HWND hwndOwner, CCabFolder *pcf, LPCABITEM *apit, UINT cpit)
: m_lSel(8), m_lContents(NULL)
{
    m_pcfHere = pcf;
    pcf->AddRef();

    m_hwndOwner = hwndOwner;
    m_lSel.AddItems(apit, cpit);
}

// constructor used when we're co-created:
CCabObj::CCabObj() : m_pcfHere(NULL), m_hwndOwner(NULL), m_lSel(8), m_lContents(NULL)
{
};

CCabObj::~CCabObj()
{
    if (m_lContents != NULL)
    {
        int cItems = m_lSel.GetCount();

        while (cItems--)
        {
            if (m_lContents[cItems] != NULL)
            {
                GlobalFree(m_lContents[cItems]);
                m_lContents[cItems] = NULL;
            }
        }

        GlobalFree(m_lContents);
        m_lContents = NULL;
    }

    if (m_pcfHere)
    {
        m_pcfHere->Release();
    }
}


// *** IUnknown methods ***
STDMETHODIMP CCabObj::QueryInterface(
   REFIID riid, 
   LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (m_lSel.GetState() == CCabItemList::State_OutOfMem)
    {
        return(E_OUTOFMEMORY);
    }

    LPUNKNOWN pObj;
 
    if (riid == IID_IUnknown)
    {
        pObj = (IUnknown*)((IDataObject*)this); 
    }
    else if (riid == IID_IDataObject)
    {
        pObj = (IUnknown*)((IDataObject*)this); 
    }
    else if (riid == IID_IPersist)
    {
        pObj = (IUnknown*)((IPersist*)this); 
    }
    else if (riid == IID_IPersistStream)
    {
        pObj = (IUnknown*)((IPersistStream*)this); 
    }
    else
    {
           return(E_NOINTERFACE);
    }

    pObj->AddRef();
    *ppvObj = pObj;

    return(NOERROR);
}


STDMETHODIMP_(ULONG) CCabObj::AddRef(void)
{
    return(m_cRef.AddRef());
}


STDMETHODIMP_(ULONG) CCabObj::Release(void)
{
    if (!m_cRef.Release())
    {
           delete this;
        return(0);
    }

    return(m_cRef.GetRef());
}

/////////////////////////////////
////// IPersistStream Impl
/////////////////////////////////


typedef struct
{
    DWORD dwVersion;
    DWORD dwExtraSize;   // After pidl list
    DWORD dwReserved1;
    DWORD dwReserved2;
} CABVIEWDATAOBJ_PERSISTSTRUCT;


/*****************************************************************************\
    FUNCTION: IPersistStream::Load

    DESCRIPTION:
        See IPersistStream::Save() for the layout of the stream.
\*****************************************************************************/
HRESULT CCabObj::Load(IStream *pStm)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        CABVIEWDATAOBJ_PERSISTSTRUCT cvdops = { 0 };
        hr = pStm->Read(&cvdops, sizeof(cvdops), NULL);   // #1
        // If we rev the version, read it now (cvdops.dwVersion)

        if (S_OK == hr)
        {
            LPITEMIDLIST pidl = NULL;       // ILLoadFromStream frees the param

            // ASSERT(!m_pff);

            hr = ILLoadFromStream(pStm, &pidl); // #2
            if (SUCCEEDED(hr))
            {
                ATOMICRELEASE(m_pcfHere);
                hr = SHBindToObject(NULL, CLSID_CabFolder, pidl, (void **)&m_pcfHere);
                
                ILFree(pidl);
            }
        }

        DWORD dwNumPidls;
        if (SUCCEEDED(hr))
        {
            hr = pStm->Read(&dwNumPidls, SIZEOF(dwNumPidls), NULL);  // #3
        }

        if (S_OK == hr)
        {
            for (int nIndex = 0; (nIndex < (int)dwNumPidls) && SUCCEEDED(hr); nIndex++)
            {
                LPITEMIDLIST pidl = NULL;       // ILLoadFromStream frees the param

                hr = ILLoadFromStream(pStm, &pidl); // #4
                if (SUCCEEDED(hr))
                {
                    hr = m_lSel.AddItems((LPCABITEM*) &pidl, 1);
                    ILFree(pidl);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            // We may be reading a version newer than us, so skip their data.
            if (0 != cvdops.dwExtraSize)
            {
                LARGE_INTEGER li = {0};
                
                li.LowPart = cvdops.dwExtraSize;
                hr = pStm->Seek(li, STREAM_SEEK_CUR, NULL);
            }
        }
    }

    // don't return success codes other than S_OK:
    return SUCCEEDED(hr) ? S_OK : hr;
}


/*****************************************************************************\
    FUNCTION: IPersistStream::Save

    DESCRIPTION:
        The stream will be layed out in the following way:

    Version 1:
        1. CABVIEWDATAOBJ_PERSISTSTRUCT - Constant sized data.
        <PidlList BEGIN>
            2. PIDL pidl - Pidl for m_pcfHere.  It will be a public pidl (fully qualified
                        from the shell root)
            3. DWORD dwNumPidls - Number of pidls coming.
            4. PIDL pidl(n) - Pidl in slot (n) of m_lSel
        <PidlList END>
\*****************************************************************************/
HRESULT CCabObj::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr = E_INVALIDARG;

    if (pStm)
    {
        CABVIEWDATAOBJ_PERSISTSTRUCT cvdops = {0};
        DWORD dwNumPidls = m_lSel.GetCount();

        cvdops.dwVersion = 1;
        hr = pStm->Write(&cvdops, sizeof(cvdops), NULL);  // #1
        if (SUCCEEDED(hr))
        {
            if (m_pcfHere)
            {
                LPITEMIDLIST pidl;
                hr = m_pcfHere->GetCurFolder(&pidl);
                if (SUCCEEDED(hr))
                {
                    hr = ILSaveToStream(pStm, pidl); // #2
                    ILFree(pidl);
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }

        if (SUCCEEDED(hr))
            hr = pStm->Write(&dwNumPidls, SIZEOF(dwNumPidls), NULL);  // #3

        if (SUCCEEDED(hr))
        {
            for (int nIndex = 0; (nIndex < (int)dwNumPidls) && SUCCEEDED(hr); nIndex++)
            {
                hr = ILSaveToStream(pStm, (LPCITEMIDLIST) m_lSel[nIndex]); // #4
            }
        }
    }

    return hr;
}


#define MAX_STREAM_SIZE    (500 * 1024) // 500k
/*****************************************************************************\
    FUNCTION: IPersistStream::GetSizeMax

    DESCRIPTION:
        Now this is tough.  I can't calculate the real value because I don't know
    how big the hglobals are going to be for the user provided data.  I will
    assume everything fits in
\*****************************************************************************/
HRESULT CCabObj::GetSizeMax(ULARGE_INTEGER * pcbSize)
{
    if (pcbSize)
    {
        pcbSize->HighPart = 0;
        pcbSize->LowPart = MAX_STREAM_SIZE;
    }
    
    return E_NOTIMPL;
}


/*****************************************************************************\
    DESCRIPTION:
        Allocate an hglobal of the indicated size, initialized from the
    specified buffer.
\*****************************************************************************/
HRESULT StgMediumWriteHGlobal(HGLOBAL *phglob, LPVOID pv, SIZE_T cb)
{
    HRESULT hres = E_OUTOFMEMORY;

    *phglob = 0;            // Rules are rules
    if (cb)
    {
        *phglob = (HGLOBAL) LocalAlloc(LPTR, cb);
        if (*phglob)
        {
            hres = S_OK;
            CopyMemory(*phglob, pv, cb);
        }
    }
    else
        hres = E_INVALIDARG;    // Can't clone a discardable block

    return hres;
}


/*****************************************************************************\
    DESCRIPTION:
        When the copy source goes away (the process shuts down), it calls
    OleFlushClipboard.  OLE will then copy our data, release us, and then
    give out our data later.  This works for most things except for:
    1. When lindex needs to very.  This doesn't work because ole doesn't know
       how to ask us how may lindexs they need to copy.
    2. If this object has a private interface OLE doesn't know about.  For us,
       it's IAsyncOperation.

   To get around this problem, we want OLE to recreate us when some possible
   paste target calls OleGetClipboard.  We want OLE to call OleLoadFromStream()
   to have us CoCreated and reload our persisted data via IPersistStream.
   OLE doesn't want to do this by default or they may have backward compat
   problems so they want a sign from the heavens, or at least from us, that
   we will work.  They ping our "OleClipboardPersistOnFlush" clipboard format
   to ask this.
\*****************************************************************************/
HRESULT _RenderOlePersist(STGMEDIUM * pStgMedium)
{
    // The actual cookie value is opaque to the outside world.  Since
    // we don't use it either, we just leave it at zero in case we use
    // it in the future.  It's mere existence will cause OLE to do the
    // use our IPersistStream, which is what we want.
    DWORD dwCookie = 0;
    return StgMediumWriteHGlobal(&pStgMedium->hGlobal, &dwCookie, sizeof(dwCookie));
}


STDMETHODIMP CCabObj::GetData(FORMATETC *pfmt, STGMEDIUM *pmedium)
{
    ZeroMemory(pmedium, sizeof(*pmedium));

    if (!InitFileGroupDesc())
    {
        return(E_UNEXPECTED);
    }

    if (pfmt->cfFormat == s_uFileGroupDesc)
    {
        if (pfmt->ptd==NULL && (pfmt->dwAspect&DVASPECT_CONTENT) && pfmt->lindex==-1
            && (pfmt->tymed&TYMED_HGLOBAL))
        {
            int cItems = m_lSel.GetCount();
            if (cItems < 1)
            {
                return(E_UNEXPECTED);
            }

            FILEGROUPDESCRIPTOR *pfgd = (FILEGROUPDESCRIPTOR *)GlobalAlloc(GMEM_FIXED,
                sizeof(FILEGROUPDESCRIPTOR) + (cItems-1)*sizeof(FILEDESCRIPTOR));
            if (!pfgd)
            {
                return(E_OUTOFMEMORY);
            }

            pfgd->cItems = cItems;
            for (--cItems; cItems>=0; --cItems)
            {
                LPCABITEM pItem = m_lSel[cItems];
                FILETIME ft;

                pfgd->fgd[cItems].dwFlags = FD_ATTRIBUTES|FD_WRITESTIME|FD_FILESIZE|FD_PROGRESSUI;
                pfgd->fgd[cItems].dwFileAttributes = pItem->uFileAttribs;
                DosDateTimeToFileTime(pItem->uFileDate, pItem->uFileTime,&ft);
                LocalFileTimeToFileTime(&ft, &pfgd->fgd[cItems].ftLastWriteTime);
                pfgd->fgd[cItems].nFileSizeHigh = 0;
                pfgd->fgd[cItems].nFileSizeLow  = pItem->dwFileSize;

                LPCWSTR pszName;
                WSTR_ALIGNED_STACK_COPY(&pszName, pItem->szName);

                lstrcpyn(pfgd->fgd[cItems].cFileName, PathFindFileName(pszName),
                    ARRAYSIZE(pfgd->fgd[cItems].cFileName));
            }

            pmedium->tymed = TYMED_HGLOBAL;
            pmedium->hGlobal = (HGLOBAL)pfgd;
            pmedium->pUnkForRelease = NULL;

            return(NOERROR);
        }

        return(E_INVALIDARG);
    }

    if (!InitFileContents())
    {
        return(E_UNEXPECTED);
    }

    if (pfmt->cfFormat == s_uFileContents)
    {
        if (pfmt->ptd==NULL && (pfmt->dwAspect&DVASPECT_CONTENT))
        {
            if (pfmt->tymed & TYMED_ISTREAM)
            {
                int cItems = m_lSel.GetCount();

                if ((pfmt->lindex < 0) || (pfmt->lindex >= cItems))
                {
                    return(E_INVALIDARG);
                }

                HRESULT hRes = InitContents();
                if (FAILED(hRes))
                {
                    return(hRes);
                }

                if (!m_lContents[pfmt->lindex])
                {
                    return(E_OUTOFMEMORY);
                }

                CCabStream *stream = new CCabStream(m_lContents[pfmt->lindex],m_lSel[pfmt->lindex]->dwFileSize);
                if (!stream)
                {
                    return(E_OUTOFMEMORY);
                }

                pmedium->tymed = TYMED_ISTREAM;
                pmedium->pstm = stream;
                pmedium->pUnkForRelease = NULL;

                m_lContents[pfmt->lindex] = NULL;

                return(NOERROR);
            }

            if (pfmt->tymed&TYMED_HGLOBAL)
            {
                int cItems = m_lSel.GetCount();
                if (pfmt->lindex >= cItems)
                {
                    return(E_INVALIDARG);
                }

                HRESULT hRes = InitContents();
                if (FAILED(hRes))
                {
                    return(hRes);
                }

                if (!m_lContents[pfmt->lindex])
                {
                    return(E_OUTOFMEMORY);
                }

                pmedium->tymed = TYMED_HGLOBAL;
                pmedium->hGlobal = m_lContents[pfmt->lindex];
                pmedium->pUnkForRelease = NULL;

                m_lContents[pfmt->lindex] = NULL;

                return(NOERROR);
            }
        }

        return(E_INVALIDARG);
    }

    if (!InitPersistedDataObject())
    {
        return E_UNEXPECTED;
    }

    if (pfmt->cfFormat == s_uPersistedDataObject)
    {
        if ((pfmt->ptd == NULL) &&
            (pfmt->dwAspect & DVASPECT_CONTENT) &&
            (pfmt->lindex == -1) &&
            (pfmt->tymed & TYMED_HGLOBAL))
        {
            return _RenderOlePersist(pmedium);
        }
        else
        {
            return E_INVALIDARG;
        }
    }

    if (!InitHIDA())
    {
        return E_UNEXPECTED;
    }

    if (pfmt->cfFormat == s_uHIDA)
    {
        HRESULT hr = E_INVALIDARG;
        if ((pfmt->ptd == NULL) &&
            (pfmt->dwAspect & DVASPECT_CONTENT) &&
            (pfmt->lindex == -1) &&
            (pfmt->tymed & TYMED_HGLOBAL))
        {
            LPITEMIDLIST pidl;
            hr = m_pcfHere->GetCurFolder(&pidl);
            if (SUCCEEDED(hr))
            {
                HIDA hida = HIDA_Create(pidl, m_lSel.GetCount(), (LPCITEMIDLIST*)m_lSel.GetArray());
                if (hida)
                {
                    pmedium->tymed   = TYMED_HGLOBAL;
                    pmedium->hGlobal = hida;
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                ILFree(pidl);
            }
        }
        return hr;
    }

    return(E_NOTIMPL);
}


STDMETHODIMP CCabObj::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    return(E_NOTIMPL);
}


STDMETHODIMP CCabObj::QueryGetData(FORMATETC *pfmt)
{
    if (!InitFileGroupDesc())
    {
        return(E_UNEXPECTED);
    }

    if (pfmt->cfFormat == s_uFileGroupDesc)
    {
        if (pfmt->ptd==NULL && (pfmt->dwAspect&DVASPECT_CONTENT) && pfmt->lindex==-1
            && (pfmt->tymed&TYMED_HGLOBAL))
        {
            return(S_OK);
        }

        return(E_INVALIDARG);
    }

    if (!InitFileContents())
    {
        return(E_UNEXPECTED);
    }

    if (pfmt->cfFormat == s_uFileContents)
    {
        if (pfmt->ptd==NULL && (pfmt->dwAspect&DVASPECT_CONTENT)
            && (pfmt->tymed & (TYMED_ISTREAM | TYMED_HGLOBAL)))
        {
            return(S_OK);
        }

        return(E_INVALIDARG);
    }

    if (!InitPersistedDataObject())
    {
        return(E_UNEXPECTED);
    }

    if (pfmt->cfFormat == s_uPersistedDataObject)
    {
        if (pfmt->ptd == NULL && (pfmt->dwAspect & DVASPECT_CONTENT)
            && (pfmt->tymed & TYMED_HGLOBAL))
        {
            return(S_OK);
        }

        return(E_INVALIDARG);
    }
    
    if (!InitHIDA())
    {
        return(E_UNEXPECTED);
    }

    if (pfmt->cfFormat == s_uHIDA)
    {
        if (pfmt->ptd == NULL && (pfmt->dwAspect & DVASPECT_CONTENT)
            && (pfmt->tymed & TYMED_HGLOBAL))
        {
            return(S_OK);
        }

        return(E_INVALIDARG);
    }
    
    return(E_NOTIMPL);
}


STDMETHODIMP CCabObj::GetCanonicalFormatEtc(FORMATETC *pformatetcIn, FORMATETC *pformatetcOut)
{
    return(E_NOTIMPL);
}


STDMETHODIMP CCabObj::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    return(E_NOTIMPL);
}


STDMETHODIMP CCabObj::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc)
{
    if (!InitFileGroupDesc() || !InitFileContents() || !InitPersistedDataObject() || !InitHIDA())
    {
        return(E_UNEXPECTED);
    }

    FORMATETC fmte[] = {
        {(USHORT)s_uFileContents,        NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL|TYMED_ISTREAM },
        {(USHORT)s_uFileGroupDesc,       NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {(USHORT)s_uPersistedDataObject, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {(USHORT)s_uHIDA,                NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
    };

    CObjFormats *pFmts = new CObjFormats(ARRAYSIZE(fmte), fmte);
    if (!pFmts)
    {
        return(E_OUTOFMEMORY);
    }

    pFmts->AddRef();
    HRESULT hRes = pFmts->QueryInterface(IID_IEnumFORMATETC, (LPVOID *)ppenumFormatEtc);
    pFmts->Release();

    return(hRes);
}


STDMETHODIMP CCabObj::DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
    DWORD *pdwConnection)
{
    return(E_NOTIMPL);
}


STDMETHODIMP CCabObj::DUnadvise(DWORD dwConnection)
{
    return(E_NOTIMPL);
}


STDMETHODIMP CCabObj::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
    return(E_NOTIMPL);
}


BOOL CCabObj::InitFileGroupDesc()
{
    if (s_uFileGroupDesc)
    {
        return(TRUE);
    }

    s_uFileGroupDesc = RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR);
    return(s_uFileGroupDesc != 0);
}


BOOL CCabObj::InitFileContents()
{
    if (s_uFileContents)
    {
        return(TRUE);
    }

    s_uFileContents = RegisterClipboardFormat(CFSTR_FILECONTENTS);
    return(s_uFileContents != 0);
}

#define CFSTR_OLECLIPBOARDPERSISTONFLUSH           TEXT("OleClipboardPersistOnFlush")
BOOL CCabObj::InitPersistedDataObject()
{
    if (s_uPersistedDataObject)
    {
        return(TRUE);
    }

    s_uPersistedDataObject = RegisterClipboardFormat(CFSTR_OLECLIPBOARDPERSISTONFLUSH);
    return(s_uPersistedDataObject != 0);
}

BOOL CCabObj::InitHIDA()
{
    if (s_uHIDA)
    {
        return(TRUE);
    }

    s_uHIDA = RegisterClipboardFormat(CFSTR_SHELLIDLIST);
    return(s_uHIDA != 0);
}

HGLOBAL * CALLBACK CCabObj::ShouldExtract(LPCTSTR pszFile, DWORD dwSize, UINT date,
        UINT time, UINT attribs, LPARAM lParam)
{
    CCabObj *pThis = (CCabObj*)lParam;

    int iItem = pThis->m_lSel.FindInList(pszFile, dwSize, date, time, attribs);
    if (iItem < 0)
    {
        return(EXTRACT_FALSE);
    }

    // Copy nothing for now
    return(&(pThis->m_lContents[iItem]));
}


HRESULT CCabObj::InitContents()
{
    if (m_lContents)
    {
        return S_OK;
    }

    int iCount = m_lSel.GetCount();
    if (iCount < 1)
    {
        return E_UNEXPECTED;
    }

    m_lContents = (HGLOBAL *)GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,
        sizeof(HGLOBAL)*m_lSel.GetCount());
    if (!m_lContents)
    {
        return E_OUTOFMEMORY;
    }

    TCHAR szHere[MAX_PATH];
    if ((NULL == m_pcfHere) || (!m_pcfHere->GetPath(szHere)))
    {
        return E_UNEXPECTED;
    }

    CCabExtract ceHere(szHere);

    ceHere.ExtractItems(m_hwndOwner, DIR_MEM, ShouldExtract, (LPARAM)this);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\debug.c ===
//*******************************************************************************************
//
// Filename : debug.c
//	
//				Debug routines
//
// Copyright (c) 1994 - 1996 Microsoft Corporation. All rights reserved
//
//*******************************************************************************************

#include "pch.h"


#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "cabview"
#define SZ_MODULE           "CABVIEW"
#define DECLARE_DEBUG
#include <ccstock.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\enum.cpp ===
//*******************************************************************************************
//
// Filename : Enum.cpp
//	
//				Implementation for CEnumCabObjs
//
// Copyright (c) 1994 - 1996 Microsoft Corporation. All rights reserved
//
//*******************************************************************************************

#include "pch.h"		

#include "thisdll.h"
#include "enum.h"

// *** IUnknown methods ***
STDMETHODIMP CEnumCabObjs::QueryInterface(
   REFIID riid, 
   LPVOID FAR* ppvObj)
{
	*ppvObj = NULL;

	LPUNKNOWN pObj;
 
	if (riid == IID_IUnknown)
	{
		pObj = (IUnknown*)((IEnumIDList*)this); 
	}
	else if (riid == IID_IEnumIDList)
	{
		pObj = (IUnknown*)((IEnumIDList*)this); 
	}
	else
	{
   		return(E_NOINTERFACE);
	}

	pObj->AddRef();
	*ppvObj = pObj;

	return(NOERROR);
}


STDMETHODIMP_(ULONG) CEnumCabObjs::AddRef(void)
{
	return(m_cRef.AddRef());
}


STDMETHODIMP_(ULONG) CEnumCabObjs::Release(void)
{
	if (!m_cRef.Release())
	{
   		delete this;
		return(0);
	}

	return(m_cRef.GetRef());
}


// *** IEnumIDList methods ***
STDMETHODIMP CEnumCabObjs::Next(ULONG celt,
	      LPITEMIDLIST *rgelt,
	      ULONG *pceltFetched)
{
	*rgelt = NULL;
	if (pceltFetched)
	{
		*pceltFetched = 0;
	}

	HRESULT hRes = m_pcfThis->InitItems();
	if (FAILED(hRes))
	{
		return(hRes);
	}

	for ( ; ; ++m_iCount)
	{
		if (m_iCount >= m_pcfThis->m_lItems.GetCount())
		{
			return(S_FALSE);
		}

		LPCABITEM pit = m_pcfThis->m_lItems[m_iCount];

		if ((m_uFlags&(SHCONTF_FOLDERS|SHCONTF_NONFOLDERS))
			!= (SHCONTF_FOLDERS|SHCONTF_NONFOLDERS))
		{
			DWORD gfInOut = SFGAO_FOLDER;
			if (FAILED(m_pcfThis->GetAttributesOf(1, (LPCITEMIDLIST *)&pit, &gfInOut)))
			{
				continue;
			}
			if (!(m_uFlags&SHCONTF_FOLDERS) && (gfInOut&SFGAO_FOLDER))
			{
				continue;
			}
			if ((m_uFlags&SHCONTF_FOLDERS) && !(gfInOut&SFGAO_FOLDER))
			{
				continue;
			}
		}

		if (!(m_uFlags&SHCONTF_INCLUDEHIDDEN)
			&& (pit->uFileAttribs&(FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM)))
		{
			continue;
		}

		break;
	}

	*rgelt = ILClone((LPCITEMIDLIST)m_pcfThis->m_lItems[m_iCount]);

	++m_iCount;

	if (*rgelt)
	{
		if (pceltFetched)
		{
			*pceltFetched = 1;
		}

		return(S_OK);
	}

	return(E_OUTOFMEMORY);
}


STDMETHODIMP CEnumCabObjs::Skip(ULONG celt)
{
	return(E_NOTIMPL);
}


STDMETHODIMP CEnumCabObjs::Reset()
{
	m_iCount = 0;

	return(NOERROR);
}


STDMETHODIMP CEnumCabObjs::Clone(IEnumIDList **ppenum)
{
	return(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\dataobj.h ===
//*******************************************************************************************
//
// Filename : DataObj.h
//  
//              Definition of CCabObj
//
// Copyright (c) 1994 - 1996 Microsoft Corporation. All rights reserved
//
//*******************************************************************************************

#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

#include "thisguid.h"

class CCabObj : public IDataObject, public IPersistStream
{
public:
    CCabObj(HWND hwndOwner, CCabFolder *pcf, LPCABITEM *apit, UINT cpit);
    ~CCabObj();

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObject);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
        
    STDMETHODIMP GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    STDMETHODIMP GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
    STDMETHODIMP QueryGetData(FORMATETC *pformatetc);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut);
    STDMETHODIMP SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc);
    STDMETHODIMP DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
        DWORD *pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppenumAdvise);

    // *** IPersist ***
    STDMETHODIMP GetClassID(CLSID* pClassID){ *pClassID = CLSID_CabViewDataObject; return S_OK; }
    
    // *** IPersistStream ***
    STDMETHODIMP IsDirty(void) {return S_OK;} // Indicate that we are dirty and ::Save() needs to be called.
    STDMETHODIMP Load(IStream *pStm);
    STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER * pcbSize);

private:
    BOOL InitFileGroupDesc();
    BOOL InitFileContents();
    BOOL InitPersistedDataObject();
    BOOL InitHIDA();

    static HGLOBAL * CALLBACK ShouldExtract(LPCTSTR pszFile, DWORD dwSize,
        UINT date, UINT time, UINT attribs, LPARAM lParam);

    HRESULT InitContents();
    friend HRESULT CabViewDataObject_CreateInstance(REFIID riid, LPVOID* ppv);
    CCabObj();

private:
    static UINT s_uFileGroupDesc;
    static UINT s_uFileContents;
    static UINT s_uPersistedDataObject;
    static UINT s_uHIDA;

    CRefCount m_cRef;

    CRefDll m_cRefDll;

    CCabItemList m_lSel;
    HGLOBAL *m_lContents;

    CCabFolder *m_pcfHere;
    HWND m_hwndOwner;
};

#endif // _DATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\folder.cpp ===
//*******************************************************************************************
//
// Filename : folder.cpp
//	
//				CAB Files Shell Extension
//
// Copyright (c) 1994 - 1997 Microsoft Corporation. All rights reserved
//
//*******************************************************************************************


#include "pch.h"

#include "ccstock.h"
#include "thisdll.h"
#include "thisguid.h"
#include "ntquery.h"
#include "varutil.h"

#include "folder.h"
#include "enum.h"
#include "menu.h"
#include "dataobj.h"

#include "cabitms.h"

#include "resource.h"

STDAPI StringToStrRet(LPCTSTR pszName, STRRET *pStrRet)
{
#ifdef UNICODE
    pStrRet->uType = STRRET_WSTR;
    return SHStrDup(pszName, &pStrRet->pOleStr);
#else
    pStrRet->uType = STRRET_CSTR;
    lstrcpyn(pStrRet->cStr, pszName, ARRAYSIZE(pStrRet->cStr));
    return NOERROR;
#endif
}

STDMETHODIMP CCabFolder::QueryInterface(REFIID riid, void **ppv)
{
    if (CLSID_CabFolder == riid)
    {
        // yuck - dataobject uses this when loading us from a stream:
        // NOTE: we are doing an AddRef() in this case
        *ppv = (CCabFolder*) this;
        AddRef();
        return S_OK;
    }
    else
    {
        static const QITAB qit[] = {
            QITABENT(CCabFolder, IShellFolder2),
            QITABENTMULTI(CCabFolder, IShellFolder, IShellFolder2),
            QITABENT(CCabFolder, IPersistFolder2),
            QITABENTMULTI(CCabFolder, IPersistFolder, IPersistFolder2),
            QITABENTMULTI(CCabFolder, IPersist, IPersistFolder2),
            QITABENT(CCabFolder, IShellFolderViewCB),
            { 0 },
        };
        return QISearch(this, qit, riid, ppv);
    }
}


STDMETHODIMP_(ULONG) CCabFolder::AddRef(void)
{
    return(m_cRef.AddRef());
}


STDMETHODIMP_(ULONG) CCabFolder::Release(void)
{
    if (!m_cRef.Release())
    {
        delete this;
        return(0);
    }
    
    return(m_cRef.GetRef());
}

STDMETHODIMP CCabFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszDisplayName, ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    return E_NOTIMPL;
}

//**********************************************************************
//
// Purpose:
//
//      Creates an item enumeration object 
//      (an IEnumIDList interface) that can be used to 
//      enumerate the contents of a folder.
//
// Parameters:
//
//       HWND hwndOwner       -    handle to the owner window
//       DWORD grFlags        -    flags about which items to include
//       IEnumIDList **ppenumIDList - address that receives IEnumIDList
//                                    interface pointer 
//********************************************************************

STDMETHODIMP CCabFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    HRESULT hres;
    CEnumCabObjs *pce = new CEnumCabObjs(this, grfFlags);
    if (pce)
    {
        hres = pce->QueryInterface(IID_IEnumIDList, (void **)ppenumIDList);
    }
    else
    {
        *ppenumIDList = NULL;
        hres = E_OUTOFMEMORY;
    }
    return hres;
}

STDMETHODIMP CCabFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj)
{
    return E_NOTIMPL;
}

STDMETHODIMP CCabFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void ** ppvObj)
{
    return E_NOTIMPL;
}


//**********************************************************************
//
// CCabFolder::CompareIDs
//
// Purpose:
//
//      Determines the relative ordering of two file
//      objects or folders, given their item identifier lists
//
// Parameters:
//
//      LPARAM lParam         -    type of comparison
//      LPCITEMIDLIST pidl1   -    address to ITEMIDLIST
//      LPCITEMIDLIST pidl2   -    address to ITEMIDLIST
//
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP CCabFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPCABITEM pit1 = (LPCABITEM)pidl1;
    LPCABITEM pit2 = (LPCABITEM)pidl2;
    
    short nCmp = 0;

    LPCWSTR pszName1, pszName2;
    WSTR_ALIGNED_STACK_COPY(&pszName1, pit1->szName);
    WSTR_ALIGNED_STACK_COPY(&pszName2, pit2->szName);
    
    switch (lParam)
    {
    case CV_COL_NAME:
        break;
        
    case CV_COL_SIZE:
        if (pit1->dwFileSize < pit2->dwFileSize)
        {
            nCmp = -1;
        }
        else if (pit1->dwFileSize > pit2->dwFileSize)
        {
            nCmp = 1;
        }
        break;
        
    case CV_COL_TYPE:
        {
            STRRET srName1, srName2;
            
            GetTypeOf(pit1, &srName1);
            GetTypeOf(pit2, &srName2);
            
#ifdef UNICODE
            if (srName1.pOleStr && srName2.pOleStr)
            {
                nCmp = (SHORT)lstrcmp(srName1.pOleStr, srName2.pOleStr);
            }
            else
            {
                if (srName1.pOleStr)
                {
                    nCmp = 1;
                }
                else
                {
                    nCmp = -1;
                }
            }
            if (srName1.pOleStr)
            {
                CoTaskMemFree(srName1.pOleStr);
            }
            if (srName2.pOleStr)
            {
                CoTaskMemFree(srName2.pOleStr);
            }
#else  // UNICODE
            nCmp = (SHORT)lstrcmp(srName1.cStr, srName2.cStr);
#endif // UNICODE
            break;
        }
        
    case CV_COL_MODIFIED:
        if (pit1->uFileDate < pit2->uFileDate)
        {
            nCmp = -1;
        }
        else if (pit1->uFileDate > pit2->uFileDate)
        {
            nCmp = 1;
        }
        else if (pit1->uFileTime < pit2->uFileTime)
        {
            nCmp = -1;
        }
        else if (pit1->uFileTime > pit2->uFileTime)
        {
            nCmp = 1;
        }
        break;
        
    case CV_COL_PATH:
        if (pit1->cPathChars == 0)
        {
            if (pit2->cPathChars != 0)
            {
                nCmp = -1;
            }
        }
        else if (pit2->cPathChars == 0)
        {
            nCmp = 1;
        }
        else if (pit1->cPathChars <= pit2->cPathChars)
        {
            nCmp = (short) StrCmpN(pszName1, pszName2, pit1->cPathChars-1);
            
            if ((nCmp == 0) && (pit1->cPathChars < pit2->cPathChars))
            {
                nCmp = -1;
            }
        }
        else
        {
            nCmp = (short) StrCmpN(pszName1, pszName2, pit2->cPathChars-1);
            
            if (nCmp == 0)
            {
                nCmp = 1;
            }
        }
        break;
        
    default:
        break;
    }
    
    if (nCmp != 0)
    {
        return ResultFromShort(nCmp);
    }
    
    return ResultFromShort(lstrcmpi(pszName1 + pit1->cPathChars, pszName2 + pit2->cPathChars));
}


STDMETHODIMP CCabFolder::MessageSFVCB(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return E_NOTIMPL;
}

//**********************************************************************
//
// CCabFolder::CreateViewObject
//
// Purpose:
//
//      IShellbrowser calls this to create a ShellView  
//      object
//
// Parameters:
//
//      HWND   hwndOwner     -
//   
//      REFIID riid          -  interface ID
//
//      void ** ppvObj      -  pointer to the Shellview object
//
// Return Value:
//
//      NOERROR
//      E_OUTOFMEMORY
//      E_NOINTERFACE
//
//
// Comments:
//
//      ShellBrowser interface calls this to request the ShellFolder
//      to create a ShellView object
//
//********************************************************************

STDMETHODIMP CCabFolder::CreateViewObject(HWND hwndOwner, REFIID riid, void **ppvObj)
{
    HRESULT hr;
    
    if (riid == IID_IShellView)
    {
        SFV_CREATE sfvc = { 0 };
        sfvc.cbSize = sizeof(sfvc);
        sfvc.pshf = this;
        sfvc.psfvcb = this;        
        hr = SHCreateShellFolderView(&sfvc, (IShellView **)ppvObj);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    
    return hr;
}


// **************************************************************************************
//
// CCabFolder::GetAttributesOf
//
// Purpose
//
//			Retrieves attributes of one of more file objects
//
// Parameters:
//			
//    UINT cidl                -    number of file objects
//    LPCITEMIDLIST  *apidl    -    pointer to array of ITEMIDLIST
//    ULONG *rgfInOut          -    array of values that specify file object
//                                  attributes
//
//
// Return Value:
//    
//     NOERROR
//
//	Comments
//
// ***************************************************************************************

STDMETHODIMP CCabFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    *rgfInOut &= SFGAO_CANCOPY;
    return NOERROR;
}

// **************************************************************************************
//
// CCabFolder::GetUIObjectOf
//
// Purpose
//
//			Returns an interface that can be used to carry out actions on 
//          the specified file objects or folders
//
// Parameters:
//        
//        HWND hwndOwner        -    handle of the Owner window
//
//        UINT cidl             -    Number of file objects
//        
//        LPCITEMIDLIST *apidl  -    array of file object pidls
//
//        REFIID                -    Identifier of interface to return
//        			
//        UINT * prgfInOut      -    reserved
//
//        void **ppvObj        -    address that receives interface pointer
//
// Return Value:
//        
//         E_INVALIDARG
//         E_NOINTERFACE
//         E_OUTOFMEMORY
//
//	Comments
// ***************************************************************************************

STDMETHODIMP CCabFolder::GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST *apidl, 
                                       REFIID riid, UINT *prgfInOut,  void **ppv)
{
    *ppv = NULL;
    
    HRESULT hr = E_OUTOFMEMORY;

    if (riid == IID_IExtractIcon)
    {
        if (cidl != 1)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            LPCABITEM pci = (LPCABITEM)*apidl;

            LPCWSTR pszName;
            WSTR_ALIGNED_STACK_COPY(&pszName, pci->szName);

            hr = SHCreateFileExtractIconW(pszName, pci->uFileAttribs, riid, ppv);
        }
    }
    else if (riid == IID_IContextMenu)
    {
        if (cidl < 1)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            CCabItemMenu *pcim = new CCabItemMenu(hwndOwner, this, (LPCABITEM *)apidl, cidl);
            if (pcim)
            {
                pcim->AddRef(); // weak 0-based refcount
                hr = pcim->QueryInterface(riid, ppv);
                pcim->Release();
            }
        }
    }
    else if (riid == IID_IDataObject)
    {
        if (cidl < 1)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            CCabObj *pco = new CCabObj(hwndOwner, this, (LPCABITEM *)apidl, cidl);
            if (pco)
            {
                pco->AddRef(); // weak 0-based refcount
                hr = pco->QueryInterface(riid, ppv);
                pco->Release();
            }
        }
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    
    return hr;
}

//*****************************************************************************
//
// CCabFolder::GetDisplayNameOf
//
// Purpose:
//        Retrieves the display name for the specified file object or 
//        subfolder.
//
//
// Parameters:
//
//        LPCITEMIDLIST    pidl    -    pidl of the file object
//        DWORD  dwFlags           -    Flags of the type of display name to
//                                      return
//        LPSTRRET  lpName         -    address holding the name returned        
//
//
// Comments:
//
//*****************************************************************************


STDMETHODIMP CCabFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, LPSTRRET lpName)
{
    HRESULT hr;
    LPCABITEM pit = (LPCABITEM)pidl;
    if (pit)
    {
        TCHAR szTemp[MAX_PATH];
        if (dwFlags & SHGDN_FORPARSING)
        {
            if (dwFlags & SHGDN_INFOLDER)
            {
                ualstrcpyn(szTemp, pit->szName, ARRAYSIZE(szTemp)); // relative parse name
            }
            else
            {
                SHGetNameAndFlags(m_pidlHere, dwFlags, szTemp, ARRAYSIZE(szTemp), NULL);

                TCHAR szName[MAX_PATH];
                ualstrcpyn(szName, pit->szName, ARRAYSIZE(szName));

                PathAppend(szTemp, szName);
            }
            hr = StringToStrRetW(szTemp, lpName);
        }
        else
        {
            GetNameOf(pit, lpName);
            hr = S_OK;
        }
    }
    else
        hr = E_INVALIDARG;

    return hr;
}

STDMETHODIMP CCabFolder::SetNameOf(HWND hwndOwner,  LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD dwRes, LPITEMIDLIST *ppidlOut)
{
    return E_NOTIMPL;
}

DEFINE_SCID(SCID_TYPE,          PSGUID_STORAGE, PID_STG_STORAGETYPE);
DEFINE_SCID(SCID_NAME,          PSGUID_STORAGE, PID_STG_NAME);
DEFINE_SCID(SCID_SIZE,          PSGUID_STORAGE, PID_STG_SIZE);
DEFINE_SCID(SCID_WRITETIME,     PSGUID_STORAGE, PID_STG_WRITETIME);

// the CV_COL_PATH column doesn't map to any well-known SCID types.
// since nobody will need to get a hold of the data, just refer to a bogus
// SCID.  all this has to do is work within FindSCID.
#define PSGUID_CabFolder {0x0CD7A5C0L, 0x9F37, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62}  // CLSID_CabFolder
DEFINE_SCID(SCID_BOGUS,         PSGUID_CabFolder, 0);

struct _CVCOLINFO
{
    UINT iColumn;
    UINT iTitle;
    UINT cchCol;
    UINT iFmt;
    const SHCOLUMNID* pscid;
} s_aCVColInfo[] = {
    {CV_COL_NAME,     IDS_CV_COL_NAME,     20, LVCFMT_LEFT,  &SCID_NAME},
    {CV_COL_SIZE,     IDS_CV_COL_SIZE,     10, LVCFMT_RIGHT, &SCID_SIZE},
    {CV_COL_TYPE,     IDS_CV_COL_TYPE,     20, LVCFMT_LEFT,  &SCID_TYPE},
    {CV_COL_MODIFIED, IDS_CV_COL_MODIFIED, 20, LVCFMT_LEFT,  &SCID_WRITETIME},
    {CV_COL_PATH,     IDS_CV_COL_PATH,     30, LVCFMT_LEFT,  &SCID_BOGUS},
};

STDMETHODIMP CCabFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *psd)
{
    LPCABITEM pit = (LPCABITEM)pidl;
    TCHAR szTemp[MAX_PATH];
    
    if (iColumn >= CV_COL_MAX)
    {
        return E_NOTIMPL;
    }
    
    psd->str.uType = STRRET_CSTR;
    psd->str.cStr[0] = '\0';
    
    if (!pit)
    {
        TCHAR szTitle[MAX_PATH];
        LoadString(g_ThisDll.GetInstance(), s_aCVColInfo[iColumn].iTitle, szTitle, ARRAYSIZE(szTitle));
        StringToStrRet(szTitle, &(psd->str));
        psd->fmt = s_aCVColInfo[iColumn].iFmt;
        psd->cxChar = s_aCVColInfo[iColumn].cchCol;
        return S_OK;
    }
    
    HRESULT hr = S_OK;
    switch (iColumn)
    {
    case CV_COL_NAME:
        GetNameOf(pit, &psd->str);
        break;
        
    case CV_COL_PATH:
        GetPathOf(pit, &psd->str);
        break;
        
    case CV_COL_SIZE:
        {
            ULARGE_INTEGER ullSize = {pit->dwFileSize, 0};
            StrFormatKBSize(ullSize.QuadPart, szTemp, ARRAYSIZE(szTemp));
            StringToStrRet(szTemp, &(psd->str));
            break;
        }
        
    case CV_COL_TYPE:
        GetTypeOf(pit, &psd->str);
        break;
        
    case CV_COL_MODIFIED:
        {
            FILETIME ft, uft;
            if (DosDateTimeToFileTime(pit->uFileDate, pit->uFileTime, &ft) &&
                LocalFileTimeToFileTime(&ft, &uft))         // Apply timezone
            {
                SHFormatDateTime(&uft, NULL, szTemp, ARRAYSIZE(szTemp));
                StringToStrRet(szTemp, &(psd->str));
            }
            else
            {
                hr = E_FAIL;
            }
        }
        break;
    }
    
    return hr;
}

STDMETHODIMP CCabFolder::MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid)
{
    HRESULT hr;
    ZeroMemory(pscid, sizeof(*pscid));

    if (iCol < ARRAYSIZE(s_aCVColInfo))
    {
        *pscid = *s_aCVColInfo[iCol].pscid;
        hr = S_OK;
    }
    else
        hr = E_INVALIDARG;
    return hr;
}

STDAPI_(int) FindSCID(const _CVCOLINFO* pcol, UINT nCols, const SHCOLUMNID* pscid)
{
    for (UINT i = 0; i < nCols; i++)
    {
        if (IsEqualSCID(*pscid, *pcol[i].pscid))
            return (int)i;
    }
    return -1;
}

STDMETHODIMP CCabFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr = E_FAIL;
    LPCABITEM pit = (LPCABITEM)pidl;

    int iCol = FindSCID(s_aCVColInfo, ARRAYSIZE(s_aCVColInfo), pscid);
    if (iCol >= 0)
    {
        switch (iCol)
        {
        case CV_COL_SIZE:
            pv->ullVal = pit->dwFileSize;
            pv->vt = VT_UI8;
            hr = S_OK;
            break;

        case CV_COL_MODIFIED:
            if (DosDateTimeToVariantTime(pit->uFileDate, pit->uFileTime, &pv->date))
            {
                pv->vt = VT_DATE;
                hr = S_OK;
            }
            break;
        
        default:
            {
                SHELLDETAILS sd;

                // Note that GetDetailsOf expects a relative pidl, since it is passed the SF itself.
                // The columnid includes the absolute pidl, though.z
                hr = GetDetailsOf(pidl, iCol, &sd);
                if (SUCCEEDED(hr))
                {
                    hr = InitVariantFromStrRet(&sd.str, pidl, pv);
                }
            }
        }
    }

    return hr;
}

// *** IPersist methods ***

STDMETHODIMP CCabFolder::GetClassID(CLSID *pclsid)
{
    *pclsid = CLSID_CabFolder;
    return NOERROR;
}


// IPersistFolder

STDMETHODIMP CCabFolder::Initialize(LPCITEMIDLIST pidl)
{
    if (m_pidlHere)
    {
        ILFree(m_pidlHere);
    }
    
    m_pidlHere = ILClone(pidl); // copy the pidl
    return m_pidlHere ? S_OK : E_OUTOFMEMORY;
}

HRESULT CCabFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    if (m_pidlHere)
    {
        *ppidl = ILClone(m_pidlHere);
        return *ppidl ? NOERROR : E_OUTOFMEMORY;
    }

    *ppidl = NULL;      
    return S_FALSE; // success but empty
}


//*****************************************************************************
//
// CCabFolder::CreateIDList
//
// Purpose:
//
//    Creates an item identifier list for the objects in the namespace
//
//
//*****************************************************************************

LPITEMIDLIST CCabFolder::CreateIDList(LPCTSTR pszName, DWORD dwFileSize,
                                      UINT uFileDate, UINT uFileTime, UINT uFileAttribs)
{
    // We'll assume no name is longer than MAX_PATH
    // Note the terminating NULL is already in the sizeof(CABITEM)
    BYTE bBuf[sizeof(CABITEM) + (sizeof(TCHAR) * MAX_PATH) + sizeof(WORD)];
    CABITEM *pci = (CABITEM*)bBuf;
    
    UINT uNameLen = lstrlen(pszName);
    if (uNameLen >= MAX_PATH)
    {
        uNameLen = MAX_PATH;
    }
    
    pci->wSize = (WORD)(sizeof(CABITEM) + (sizeof(TCHAR) * uNameLen));
    pci->dwFileSize = dwFileSize;
    pci->uFileDate = (USHORT)uFileDate;
    pci->uFileTime = (USHORT)uFileTime;
    pci->uFileAttribs = (USHORT)uFileAttribs & (FILE_ATTRIBUTE_READONLY|
        FILE_ATTRIBUTE_HIDDEN  |
        FILE_ATTRIBUTE_SYSTEM  |
        FILE_ATTRIBUTE_ARCHIVE);
    lstrcpynW(pci->szName, pszName, uNameLen+1);
    pci->cPathChars = 0;
    LPCTSTR psz = pszName;
    while (*psz)
    {
        if ((*psz == TEXT(':')) || (*psz == TEXT('/')) || (*psz == TEXT('\\')))
        {
            pci->cPathChars = (USHORT)(psz - pszName) + 1;
        }
        
        psz = CharNext(psz);
    }
    
    // Terminate the IDList
    *(WORD *)(((LPSTR)pci)+pci->wSize) = 0;
    
    return(ILClone((LPCITEMIDLIST)pci));
}

//*****************************************************************************
//
// CCabFolder::GetPath
//
// Purpose:
//    
//        Get the Path for the current pidl
//
// Parameters:
//   
//        LPSTR szPath        -    return pointer for path string
//
// Comments:
//
//*****************************************************************************

BOOL CCabFolder::GetPath(LPTSTR szPath)
{
    if (!m_pidlHere || !SHGetPathFromIDList(m_pidlHere, szPath))
    {
        *szPath = TEXT('\0');
        return FALSE;
    }

#ifdef UNICODE
    // NOTE: we use GetShortPathName() to avoid losing characters during the
    // UNICODE->ANSI->UNICODE roundtrip while calling FDICopy()
    // NOTE: It is valid for GetShortPathName()'s src and dest pointers to be the same

    // If this fails, we'll just ignore the error and try to use the long path name
    GetShortPathName(szPath, szPath, MAX_PATH);
#endif // UNICODE

    return(TRUE);
}


void CCabFolder::GetNameOf(LPCABITEM pit, LPSTRRET lpName)
{
#ifdef UNICODE
    lpName->uType = STRRET_WSTR;
    lpName->pOleStr = NULL;
#else
    lpName->uType = STRRET_CSTR;
    lpName->cStr[0] = '\0';
#endif
    
    LPCWSTR pszName;
    WSTR_ALIGNED_STACK_COPY(&pszName, pit->szName);

    SHFILEINFO sfi;
    if (SHGetFileInfo(pszName + pit->cPathChars, 0, &sfi, sizeof(sfi),
        SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME))
    {
        StringToStrRet(sfi.szDisplayName, lpName);
    }
}


void CCabFolder::GetPathOf(LPCABITEM pit, LPSTRRET lpName)
{
    WCHAR szPath[MAX_PATH];
    ualstrcpynW(szPath, pit->szName, ARRAYSIZE(szPath));
    szPath[pit->cPathChars] = TEXT('\0');
    StringToStrRet(szPath, lpName);
}


void CCabFolder::GetTypeOf(LPCABITEM pit, LPSTRRET lpName)
{
#ifdef UNICODE
    lpName->uType = STRRET_WSTR;
    lpName->pOleStr = NULL;
#else
    lpName->uType = STRRET_CSTR;
    lpName->cStr[0] = '\0';
#endif

    LPCWSTR pszName;
    WSTR_ALIGNED_STACK_COPY(&pszName, pit->szName);
    
    SHFILEINFO sfi;    
    if (SHGetFileInfo(pszName + pit->cPathChars, 0, &sfi, sizeof(sfi),
        SHGFI_USEFILEATTRIBUTES | SHGFI_TYPENAME))
    {
        StringToStrRet(sfi.szTypeName, lpName);
    }
}

//*****************************************************************************
//
// CCabFolder::EnumToList
//
// Purpose:
//
//       This notify callback is called by the FDI routines. It adds the
//       file object from the cab file to the list.  
//
// Parameters:
//
//
//
// Comments:
//
//*****************************************************************************


void CALLBACK CCabFolder::EnumToList(LPCTSTR pszFile, DWORD dwSize, UINT date,
                                     UINT time, UINT attribs, LPARAM lParam)
{
    CCabFolder *pThis = (CCabFolder *)lParam;
    
    pThis->m_lItems.AddItem(pszFile, dwSize, date, time, attribs);
}


HRESULT CCabFolder::InitItems()
{
    switch (m_lItems.GetState())
    {
    case CCabItemList::State_Init:
        return NOERROR;
        
    case CCabItemList::State_OutOfMem:
        return E_OUTOFMEMORY;
        
    case CCabItemList::State_UnInit:
    default:
        break;
    }
    
    // Force the list to initialize
    m_lItems.InitList();
    
    TCHAR szHere[MAX_PATH];
    
    // the m_pidl has been set to current dir
    // get the path to the current directory
    if (!GetPath(szHere))
    {
        return(E_UNEXPECTED);
    }
    
    CCabItems ciHere(szHere);
    
    if (!ciHere.EnumItems(EnumToList, (LPARAM)this))
    {
        return(E_UNEXPECTED);
    }
    
    return NOERROR;
}

HRESULT CabFolder_CreateInstance(REFIID riid, void **ppvObj)
{
    HRESULT hres;

    *ppvObj = NULL;

    HINSTANCE hCabinetDll = LoadLibrary(TEXT("CABINET.DLL"));
    if (hCabinetDll)
    {
        FreeLibrary(hCabinetDll);

        CCabFolder *pfolder = new CCabFolder;
        if (pfolder)
            hres = pfolder->QueryInterface(riid, ppvObj);
        else
            hres = E_OUTOFMEMORY;
    }
    else
        hres = E_UNEXPECTED;

    return hres;
}


UINT CCabItemList::GetState()
{
    if (m_uStep == 0)
    {
        if (m_dpaList)
        {
            return(State_Init);
        }
        
        return(State_OutOfMem);
    }
    
    return(State_UnInit);
}


BOOL CCabItemList::StoreItem(LPITEMIDLIST pidl)
{
    if (pidl)
    {
        if (InitList() && DPA_InsertPtr(m_dpaList, 0x7fff, (LPSTR)pidl)>=0)
        {
            return(TRUE);
        }
        
        ILFree(pidl);
    }
    
    CleanList();
    return FALSE;
}


BOOL CCabItemList::AddItems(LPCABITEM *apit, UINT cpit)
{
    for (UINT i=0; i<cpit; ++i)
    {
        if (!StoreItem(ILClone((LPCITEMIDLIST)apit[i])))
        {
            return FALSE;
        }
    }
    
    return(TRUE);
}


BOOL CCabItemList::AddItem(LPCTSTR pszName, DWORD dwFileSize,
                           UINT uFileDate, UINT uFileTime, UINT uFileAttribs)
{
    return(StoreItem(CCabFolder::CreateIDList(pszName, dwFileSize, uFileDate, uFileTime,
        uFileAttribs)));
}


int CCabItemList::FindInList(LPCTSTR pszName, DWORD dwFileSize,
                             UINT uFileDate, UINT uFileTime, UINT uFileAttribs)
{
    // TODO: Linear search for now; binary later
    for (int i=DPA_GetPtrCount(m_dpaList)-1; i>=0; --i)
    {
        LPCABITEM pcab = (*this)[i];

        // all guys in the dpa are WORD-aligned but copy out anyway.
        LPCWSTR pszNameCopy;
        WSTR_ALIGNED_STACK_COPY(&pszNameCopy, pcab->szName);

        if ((lstrcmpi(pszName, pszNameCopy) == 0) &&
            (pcab->dwFileSize == dwFileSize) &&
            (pcab->uFileDate == uFileDate) &&
            (pcab->uFileTime == uFileTime) &&
            (pcab->uFileAttribs == uFileAttribs))
        {
            break;
        }
    }
    
    return(i);
}


BOOL CCabItemList::InitList()
{
    switch (GetState())
    {
    case State_Init:
        return(TRUE);
        
    case State_OutOfMem:
        return FALSE;
        
    case State_UnInit:
    default:
        m_dpaList = DPA_Create(m_uStep);
        m_uStep = 0;
        
        return(InitList());
    }
}


void CCabItemList::CleanList()
{
    if (m_uStep != 0)
    {
        m_dpaList = NULL;
        m_uStep = 0;
        return;
    }
    
    if (!m_dpaList)
    {
        return;
    }
    
    for (int i=DPA_GetPtrCount(m_dpaList)-1; i>=0; --i)
    {
        ILFree((LPITEMIDLIST)((*this)[i]));
    }
    
    DPA_Destroy(m_dpaList);
    m_dpaList = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\enum.h ===
//*******************************************************************************************
//
// Filename : Enum.h
//	
//				Definition of CEnumCabObjs
//
// Copyright (c) 1994 - 1996 Microsoft Corporation. All rights reserved
//
//*******************************************************************************************

#ifndef _ENUM_H_
#define _ENUM_H_


#include "folder.h"

// Enumeration object for the CabFolder
class CEnumCabObjs : public IEnumIDList
{
public:
	CEnumCabObjs(CCabFolder *pcf, DWORD uFlags) : m_iCount(0)
	{
		m_uFlags = uFlags;
		m_pcfThis=pcf;
		pcf->AddRef();
	}
	~CEnumCabObjs()
	{
		m_pcfThis->Release();
	}

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IEnumIDList methods ***
    STDMETHODIMP Next(ULONG celt,
		      LPITEMIDLIST *rgelt,
		      ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum);

private:
	CRefDll m_cRefDll;

	CRefCount m_cRef;

	CCabFolder *m_pcfThis;

	UINT m_iCount;
	DWORD m_uFlags;
} ;

#endif // _ENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\menu.h ===
//*******************************************************************************************
//
// Filename : Menu.h
//	
//				CCabItemMenu
//
// Copyright (c) 1994 - 1996 Microsoft Corporation. All rights reserved
//
//*******************************************************************************************


#ifndef _MENU_H_
#define _MENU_H_

#include "folder.h"

//*****************************************************************************
//
// CCabItemMenu
//
// Purpose:
//
//        IContextMenu for the Shellfolder
//
//*****************************************************************************
class CCabItemMenu : public IContextMenu
{
public:
	CCabItemMenu(HWND hwndOwner, CCabFolder*pcf, LPCABITEM *apit, UINT cpit);
	~CCabItemMenu();

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IContextMenu methods ***
    STDMETHODIMP QueryContextMenu(
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);

    STDMETHODIMP InvokeCommand(
                             LPCMINVOKECOMMANDINFO lpici);

    STDMETHODIMP GetCommandString(
                                UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax);

private:
	static HMENU LoadPopupMenu(UINT id, UINT uSubMenu);

	static HGLOBAL * CALLBACK CCabItemMenu::ShouldExtract(LPCTSTR pszFile, DWORD dwSize,
		UINT date, UINT time, UINT attribs, LPARAM lParam);

private:
	CRefCount m_cRef;

	CRefDll m_cRefDll;

	HWND m_hwndOwner;
	CCabFolder *m_pcfHere;

	CCabItemList m_lSel;
} ;

#endif // _MENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\menu.cpp ===
//*******************************************************************************************
//
// Filename : Menu.cpp
//	
//				Implementations for CCabItemMenu methods
//
// Copyright (c) 1994 - 1996 Microsoft Corporation. All rights reserved
//
//*******************************************************************************************

#include "pch.h"

#include "thisdll.h"

#include "resource.h"

#include "folder.h"
#include "menu.h"
#include "dataobj.h"
#include "cabitms.h"


// Copy a menu onto the beginning or end of another menu
// Adds uIDAdjust to each menu ID (pass in 0 for no adjustment)
// Will not add any item whose adjusted ID is greater than uMaxIDAdjust
// (pass in 0xffff to allow everything)
// Returns one more than the maximum adjusted ID that is used
//

BOOL _SHIsMenuSeparator(HMENU hm, int i)
{
    MENUITEMINFO mii;
    
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_TYPE;
    mii.cch = 0;    // WARNING: We MUST initialize it to 0!!!
    if (!GetMenuItemInfo(hm, i, TRUE, &mii))
    {
        return(FALSE);
    }
    
    if (mii.fType & MFT_SEPARATOR)
    {
        return(TRUE);
    }
    
    return(FALSE);
}

//===================================================================
// Cab_MergeMenu parameter
//
#define MM_ADDSEPARATOR         0x00000001L
#define MM_SUBMENUSHAVEIDS      0x00000002L

UINT Cab_MergeMenus(HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags)
{
    int nItem;
    HMENU hmSubMenu;
    BOOL bAlreadySeparated;
    MENUITEMINFO miiSrc;
    TCHAR szName[256];
    UINT uTemp, uIDMax = uIDAdjust;
    
    if (!hmDst || !hmSrc)
    {
        goto MM_Exit;
    }
    
    nItem = GetMenuItemCount(hmDst);
    if (uInsert >= (UINT)nItem)
    {
        uInsert = (UINT)nItem;
        bAlreadySeparated = TRUE;
    }
    else
    {
        bAlreadySeparated = _SHIsMenuSeparator(hmDst, uInsert);;
    }
    
    if ((uFlags & MM_ADDSEPARATOR) && !bAlreadySeparated)
    {
        // Add a separator between the menus
        InsertMenu(hmDst, uInsert, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        bAlreadySeparated = TRUE;
    }
    
    
    // Go through the menu items and clone them
    for (nItem = GetMenuItemCount(hmSrc) - 1; nItem >= 0; nItem--)
    {
        miiSrc.cbSize = sizeof(MENUITEMINFO);
        miiSrc.fMask = MIIM_STATE | MIIM_ID | MIIM_SUBMENU | MIIM_CHECKMARKS | MIIM_TYPE | MIIM_DATA;
        // We need to reset this every time through the loop in case
        // menus DON'T have IDs
        miiSrc.fType = MFT_STRING;
        miiSrc.dwTypeData = szName;
        miiSrc.dwItemData = 0;
        miiSrc.cch        = ARRAYSIZE(szName);
        
        if (!GetMenuItemInfo(hmSrc, nItem, TRUE, &miiSrc))
        {
            continue;
        }
        
        if (miiSrc.fType & MFT_SEPARATOR)
        {
            // This is a separator; don't put two of them in a row
            if (bAlreadySeparated)
            {
                continue;
            }
            
            bAlreadySeparated = TRUE;
        }
        else if (miiSrc.hSubMenu)
        {
            if (uFlags & MM_SUBMENUSHAVEIDS)
            {
                // Adjust the ID and check it
                miiSrc.wID += uIDAdjust;
                if (miiSrc.wID > uIDAdjustMax)
                {
                    continue;
                }
                
                if (uIDMax <= miiSrc.wID)
                {
                    uIDMax = miiSrc.wID + 1;
                }
            }
            else
            {
                // Don't set IDs for submenus that didn't have
                // them already
                miiSrc.fMask &= ~MIIM_ID;
            }
            
            hmSubMenu = miiSrc.hSubMenu;
            miiSrc.hSubMenu = CreatePopupMenu();
            if (!miiSrc.hSubMenu)
            {
                goto MM_Exit;
            }
            
            uTemp = Cab_MergeMenus(miiSrc.hSubMenu, hmSubMenu, 0, uIDAdjust,
                uIDAdjustMax, uFlags&MM_SUBMENUSHAVEIDS);
            if (uIDMax <= uTemp)
            {
                uIDMax = uTemp;
            }
            
            bAlreadySeparated = FALSE;
        }
        else
        {
            // Adjust the ID and check it
            miiSrc.wID += uIDAdjust;
            if (miiSrc.wID > uIDAdjustMax)
            {
                continue;
            }
            
            if (uIDMax <= miiSrc.wID)
            {
                uIDMax = miiSrc.wID + 1;
            }
            
            bAlreadySeparated = FALSE;
        }
        
        if (!InsertMenuItem(hmDst, uInsert, TRUE, &miiSrc))
        {
            goto MM_Exit;
        }
    }
    
    // Ensure the correct number of separators at the beginning of the
    // inserted menu items
    if (uInsert == 0)
    {
        if (bAlreadySeparated)
        {
            DeleteMenu(hmDst, uInsert, MF_BYPOSITION);
        }
    }
    else
    {
        if (_SHIsMenuSeparator(hmDst, uInsert-1))
        {
            if (bAlreadySeparated)
            {
                DeleteMenu(hmDst, uInsert, MF_BYPOSITION);
            }
        }
        else
        {
            if ((uFlags & MM_ADDSEPARATOR) && !bAlreadySeparated)
            {
                // Add a separator between the menus
                InsertMenu(hmDst, uInsert, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
            }
        }
    }
    
MM_Exit:
    return(uIDMax);
}


CCabItemMenu::CCabItemMenu(HWND hwndOwner, CCabFolder*pcf, LPCABITEM *apit, UINT cpit)
: m_lSel(8)
{
	m_hwndOwner = hwndOwner;
	m_pcfHere = pcf;
	pcf->AddRef();

	// No need to check return value here; check in QueryInterface
	m_lSel.AddItems(apit, cpit);
}

CCabItemMenu::~CCabItemMenu()
{
	m_pcfHere->Release();
}

// *** IUnknown methods ***
STDMETHODIMP CCabItemMenu::QueryInterface(
   REFIID riid, 
   LPVOID FAR* ppvObj)
{
	*ppvObj = NULL;

	if (m_lSel.GetState() == CCabItemList::State_OutOfMem)
	{
		return(E_OUTOFMEMORY);
	}

	LPUNKNOWN pObj;
 
	if (riid == IID_IUnknown)
	{
		pObj = (LPUNKNOWN)(IUnknown*)((IContextMenu*)this); 
		// The (IShellFolder*) ^^^ up there is to disambiguate :) the reference
	}
	else if (riid == IID_IContextMenu)
	{
		pObj = (LPUNKNOWN)(IContextMenu*)this;
	}
	else
	{
   		return(E_NOINTERFACE);
	}

	pObj->AddRef();
	*ppvObj = pObj;

	return(NOERROR);
}


STDMETHODIMP_(ULONG) CCabItemMenu::AddRef(void)
{
	return(m_cRef.AddRef());
}


STDMETHODIMP_(ULONG) CCabItemMenu::Release(void)
{
	if (!m_cRef.Release())
	{
   		delete this;
		return(0);
	}

	return(m_cRef.GetRef());
}


// *** IContextMenu methods ***
STDMETHODIMP CCabItemMenu::QueryContextMenu(
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags)
{
    HMENU hmMerge = LoadPopupMenu(MENU_ITEMCONTEXT, 0);

	if (!hmMerge)
	{
		return(E_OUTOFMEMORY);
	}

	if (CMF_DVFILE & uFlags)
	{
	    // No "copy" item on the file menu:
	    RemoveMenu(hmMerge, IDC_ITEM_COPY, MF_BYCOMMAND);
	}

	UINT idMax = Cab_MergeMenus(hmenu, hmMerge, indexMenu, idCmdFirst, idCmdLast,
		MM_ADDSEPARATOR);

	DestroyMenu(hmMerge);

	SetMenuDefaultItem(hmenu, IDC_ITEM_EXTRACT+idCmdFirst, FALSE);

	return(ResultFromShort(idMax - idCmdFirst));
}

STDMETHODIMP CCabItemMenu::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    if (lpici->cbSize < SIZEOF(CMINVOKECOMMANDINFO))
    {
        return E_INVALIDARG;
    }
    
	if (HIWORD(lpici->lpVerb))
	{
		// Deal with string commands
	    LPCMINVOKECOMMANDINFOEX lpicix = (LPCMINVOKECOMMANDINFOEX) lpici; // This value is only usable when fCmdInfoEx is true
#ifdef UNICODE        
        BOOL fUnicode = FALSE;
        if ((lpici->cbSize >= CMICEXSIZE_NT4) && ((lpici->fMask & CMIC_MASK_UNICODE) == CMIC_MASK_UNICODE))
        {
            fUnicode = TRUE;
        }
#endif

        LPCTSTR pszVerb;
#ifdef UNICODE
        WCHAR szVerb[MAX_PATH];

        if (!fUnicode || lpicix->lpVerbW == NULL)
        {
            SHAnsiToUnicode(lpici->lpVerb, szVerb, ARRAYSIZE(szVerb));
            pszVerb = szVerb;
        }
        else
            pszVerb = lpicix->lpVerbW;
#else
        pszVerb = lpici->lpVerb;
#endif

        UINT idCmd = 0;
		if (NULL != pszVerb)
		{
		    if (0 == lstrcmpi(pszVerb, TEXT("copy")))
		    {
                idCmd = IDC_ITEM_COPY;
		    }
		    else if (0 == lstrcmpi(pszVerb, TEXT("extract")))
		    {
		        idCmd = IDC_ITEM_EXTRACT;
		    }
		}
        lpici->lpVerb = (LPCSTR) IntToPtr(idCmd);
	}

	switch ((UINT)LOWORD((DWORD_PTR)lpici->lpVerb))
	{
	case IDC_ITEM_EXTRACT:
	{
		TCHAR szHere[MAX_PATH];
		if (!m_pcfHere->GetPath(szHere))
		{
			return(E_UNEXPECTED);
		}
	    UINT cPidls = m_lSel.GetCount();
	    if (0 == cPidls)
	    {
			return(E_UNEXPECTED);
		}
	        
	    IDataObject* pdo = (IDataObject*) (new CCabObj(m_hwndOwner, m_pcfHere,
            m_lSel.GetArray(), cPidls));
        if (NULL == pdo)
        {
			return(E_OUTOFMEMORY);
        }
        // the object is created with a zero ref count, so we need to temporarily
        // bump it up if we're going to use it:
        pdo->AddRef();

		CCabExtract ceHere(szHere);

		BOOL fResult = ceHere.ExtractToFolder(m_hwndOwner, pdo, ShouldExtract, (LPARAM)this);
		pdo->Release();

		return fResult ? S_OK : E_FAIL;
	}

	case IDC_ITEM_COPY:
	{
	    UINT cPidls = m_lSel.GetCount();
	    if (cPidls > 0)
	    {
    	    IDataObject* pObj = (IDataObject*) (new CCabObj(m_hwndOwner, m_pcfHere,
                m_lSel.GetArray(), cPidls));
            if (NULL != pObj)
            {
                // the object is created with a zero ref count, so we need to temporarily
                // bump it up if we're going to use it:
                pObj->AddRef();
                HRESULT hr = OleSetClipboard(pObj);
                pObj->Release();
                return hr;
            }
        }
        return E_FAIL;
	}

	default:
		return(E_INVALIDARG);
	}

	return(NOERROR);
}

STDMETHODIMP CCabItemMenu::GetCommandString(
                                UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax)
{
	return(E_NOTIMPL);
}


HGLOBAL * CALLBACK CCabItemMenu::ShouldExtract(LPCTSTR pszFile, DWORD dwSize, UINT date,
		UINT time, UINT attribs, LPARAM lParam)
{
	CCabItemMenu *pThis = (CCabItemMenu*)lParam;

	if (pThis->m_lSel.IsInList(pszFile, dwSize, date, time, attribs))
	{
		return(EXTRACT_TRUE);
	}

	// Copy nothing for now
	return(EXTRACT_FALSE);
}


HMENU CCabItemMenu::LoadPopupMenu(UINT id, UINT uSubMenu)
{
    HMENU hmParent = LoadMenu(g_ThisDll.GetInstance(), MAKEINTRESOURCE(id));
    if (!hmParent)
    {
		return(NULL);
	}

    HMENU hmPopup = GetSubMenu(hmParent, 0);
    RemoveMenu(hmParent, uSubMenu, MF_BYPOSITION);
    DestroyMenu(hmParent);

    return(hmPopup);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\fdidll.c ===
/*
 *  FDIDLL.C -- FDI interface using CABINET.DLL
 *
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1997
 *  All Rights Reserved.
 *
 *  Author:
 *      Mike Sliger
 *
 *  History:
 *      21-Jan-1997 msliger Initial version
 *      24-Jan-1997 msliger Changed to public include file
 *
 *  Overview:
 *      This code is a wrapper which provides access to the actual FDI code
 *      in CABINET.DLL.  CABINET.DLL dynamically loads/unloads as needed.
 */
 
#include <windows.h>

#include "fdi.h"

static HINSTANCE hCabinetDll;   /* DLL module handle */

/* pointers to the functions in the DLL */

static HFDI (FAR DIAMONDAPI *pfnFDICreate)(
        PFNALLOC            pfnalloc,
        PFNFREE             pfnfree,
        PFNOPEN             pfnopen,
        PFNREAD             pfnread,
        PFNWRITE            pfnwrite,
        PFNCLOSE            pfnclose,
        PFNSEEK             pfnseek,
        int                 cpuType,
        PERF                perf) = NULL;
static BOOL (FAR DIAMONDAPI *pfnFDIIsCabinet)(
        HFDI                hfdi,
        INT_PTR             hf,
        PFDICABINETINFO     pfdici) = NULL;
static BOOL (FAR DIAMONDAPI *pfnFDICopy)(
        HFDI                hfdi,
        char                *pszCabinet,
        char                *pszCabPath,
        int                 flags,
        PFNFDINOTIFY        pfnfdin,
        PFNFDIDECRYPT       pfnfdid,
        void                *pvUser) = NULL;
static BOOL (FAR DIAMONDAPI *pfnFDIDestroy)(
        HFDI                hfdi) = NULL;


/*
 *  FDICreate -- Create an FDI context
 *
 *  See fdi_int.h for entry/exit conditions.
 */

HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf)
{
    HFDI hfdi;

    hCabinetDll = LoadLibrary(TEXT("CABINET"));
    if (hCabinetDll == NULL)
    {
        return(NULL);
    }

    pfnFDICreate = (void *) GetProcAddress(hCabinetDll,"FDICreate");
    pfnFDICopy = (void *) GetProcAddress(hCabinetDll,"FDICopy");
    pfnFDIIsCabinet = (void *) GetProcAddress(hCabinetDll,"FDIIsCabinet");
    pfnFDIDestroy = (void *) GetProcAddress(hCabinetDll,"FDIDestroy");

    if ((pfnFDICreate == NULL) ||
        (pfnFDICopy == NULL) ||
        (pfnFDIIsCabinet == NULL) ||
        (pfnFDIDestroy == NULL))
    {
        FreeLibrary(hCabinetDll);

        return(NULL);
    }

    hfdi = pfnFDICreate(pfnalloc,pfnfree,
            pfnopen,pfnread,pfnwrite,pfnclose,pfnseek,cpuType,perf);
    if (hfdi == NULL)
    {
        FreeLibrary(hCabinetDll);
    }

    return(hfdi);
}


/*
 *  FDICopy -- extracts files from a cabinet
 *
 *  See fdi_int.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            char         *pszCabinet,
                            char         *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void         *pvUser)
{
    if (pfnFDICopy == NULL)
    {
        return(FALSE);
    }

    return(pfnFDICopy(hfdi,pszCabinet,pszCabPath,flags,pfnfdin,pfnfdid,pvUser));
}


/*
 *  FDIDestroy -- Destroy an FDI context
 *
 *  See fdi_int.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi)
{
    BOOL rc;

    if (pfnFDIDestroy == NULL)
    {
        return(FALSE);
    }

    rc = pfnFDIDestroy(hfdi);
    if (rc == TRUE)
    {
        FreeLibrary(hCabinetDll);
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\folder.h ===
//*******************************************************************************************
//
// Filename : Folder.h
//	
//				Definitions of CCabFolder and CCabItemList
//
// Copyright (c) 1994 - 1997 Microsoft Corporation. All rights reserved
//
//*******************************************************************************************

#ifndef _CABFOLD_H_
#define _CABFOLD_H_

enum _CV_COLS
{
    CV_COL_NAME = 0,
    CV_COL_SIZE,
    CV_COL_TYPE,
    CV_COL_MODIFIED,
    CV_COL_PATH,
    CV_COL_MAX,
} ;

#define IsEqualSCID(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid) )

#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }

typedef struct _CABITEM
{
    WORD wSize;
    DWORD dwFileSize;
    USHORT uFileDate;
    USHORT uFileTime;
    USHORT uFileAttribs;
    USHORT cPathChars;
    WCHAR szName[1];
} CABITEM;
typedef UNALIGNED CABITEM *LPCABITEM;

class CCabItemList
{
public:
    CCabItemList(UINT uStep) {m_uStep=uStep;}
    CCabItemList() {CCabItemList(8);}
    ~CCabItemList() {CleanList();}
    
    enum
    {
        State_UnInit,
        State_Init,
        State_OutOfMem,
    };
    
    UINT GetState();
    
    LPCABITEM operator[](UINT nIndex)
    {
        return((LPCABITEM)DPA_GetPtr(m_dpaList, nIndex));
    }
    UINT GetCount() {return(GetState()==State_Init ? DPA_GetPtrCount(m_dpaList) : 0);}
    LPCABITEM* GetArray() {return(GetState()==State_Init ? (LPCABITEM*) DPA_GetPtrPtr(m_dpaList) : NULL);}
    
    BOOL InitList();
    
    BOOL AddItems(LPCABITEM *apit, UINT cpit);
    BOOL AddItem(LPCTSTR pszName, DWORD dwFileSize,
        UINT uFileDate, UINT uFileTime, UINT uFileAttribs);
    
    int FindInList(LPCTSTR pszName, DWORD dwFileSize,
        UINT uFileDate, UINT uFileTime, UINT uFileAttribs);
    BOOL IsInList(LPCTSTR pszName, DWORD dwFileSize,
        UINT uFileDate, UINT uFileTime, UINT uFileAttribs)
    {
        return(FindInList(pszName, dwFileSize, uFileDate, uFileTime, uFileAttribs) >= 0);
    }
    
    
private:
    BOOL StoreItem(LPITEMIDLIST pidl);
    void CleanList();
    
private:
    UINT m_uStep;
    HDPA m_dpaList;
} ;

class CCabFolder : public IPersistFolder2, public IShellFolder2, public IShellFolderViewCB
{
public:
    CCabFolder() : m_pidlHere(0), m_lItems(1024/sizeof(void *)) {}
    ~CCabFolder()
    {
        if (m_pidlHere)
        {
            ILFree(m_pidlHere);
        }
    }
    
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(
        REFIID riid, 
        void ** ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // *** IParseDisplayName method ***
    STDMETHODIMP ParseDisplayName(
        HWND hwndOwner,
        LPBC pbc, 
        LPOLESTR lpszDisplayName,
        ULONG * pchEaten, 
        LPITEMIDLIST * ppidl,
        ULONG *pdwAttributes);
    
    // *** IOleContainer methods ***
    STDMETHODIMP EnumObjects(
        HWND hwndOwner, 
        DWORD grfFlags,
        LPENUMIDLIST * ppenumIDList);
    
    // *** IShellFolder methods ***
    STDMETHODIMP BindToObject(
        LPCITEMIDLIST pidl, 
        LPBC pbc,
        REFIID riid, 
        void ** ppvObj);
    STDMETHODIMP BindToStorage(
        LPCITEMIDLIST pidl, 
        LPBC pbc,
        REFIID riid, 
        void ** ppvObj);
    STDMETHODIMP CompareIDs(
        LPARAM lParam, 
        LPCITEMIDLIST pidl1,
        LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(
        HWND hwndOwner, 
        REFIID riid,
        void ** ppvObj);
    STDMETHODIMP GetAttributesOf(
        UINT cidl, 
        LPCITEMIDLIST * apidl,
        ULONG * rgfInOut);
    STDMETHODIMP GetUIObjectOf(
        HWND hwndOwner, 
        UINT cidl, 
        LPCITEMIDLIST * apidl, 
        REFIID riid, 
        UINT * prgfInOut, 
        void ** ppvObj);
    STDMETHODIMP GetDisplayNameOf(
        LPCITEMIDLIST pidl, 
        DWORD dwReserved, 
        LPSTRRET lpName);
    STDMETHODIMP SetNameOf(
        HWND hwndOwner, 
        LPCITEMIDLIST pidl,
        LPCOLESTR lpszName, 
        DWORD dwReserved,
        LPITEMIDLIST * ppidlOut);
    
    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pguid) { return E_NOTIMPL; };
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum) { return E_NOTIMPL; };
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay) { return E_NOTIMPL; };
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pcsFlags) { return E_NOTIMPL; };
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *psd);
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid);
    
    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);
    
    // IShellFolderViewCB
    STDMETHODIMP MessageSFVCB(UINT uMsg, WPARAM wParam, LPARAM lParam);

public:
    static LPITEMIDLIST CreateIDList(LPCTSTR pszName, DWORD dwFileSize,
        UINT uFileDate, UINT uFileTime, UINT uFileAttribs);
    static void GetNameOf(LPCABITEM pit, LPSTRRET lpName);
    static void GetPathOf(LPCABITEM pit, LPSTRRET lpName);
    static void GetTypeOf(LPCABITEM pit, LPSTRRET lpName);
    
    BOOL GetPath(LPTSTR szPath);
    
private:
    static void CALLBACK EnumToList(LPCTSTR pszFile, DWORD dwSize, UINT date,
        UINT time, UINT attribs, LPARAM lParam);
    
    HRESULT InitItems();
    
private:
    CRefDll m_cRefDll;
    
    CRefCount m_cRef;
    
    LPITEMIDLIST m_pidlHere;		// maintains the current pidl
    
    CCabItemList m_lItems;
    
    friend class CEnumCabObjs;
} ;

#endif // _CABFOLD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\pch.h ===
//*******************************************************************************************
//
// Filename : Pch.h
//	
//				Common header file 
//
// Copyright (c) 1994 - 1996 Microsoft Corporation. All rights reserved
//
//*******************************************************************************************

#define STRICT 
#include <windows.h>

#include <windowsx.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlguid.h>
#include <shlwapi.h>
#include <shfusion.h>

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define SIZEOF(a)                   sizeof(a)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cabview.rc
//
#define IDS_CV_COL_NAME                 1
#define IDC_ITEM_EXTRACT                1
#define IDI_CABVIEW                     1
#define IDC_SELECT                      1
#define IDS_CV_COL_SIZE                 2
#define IDC_VIEW_ICON                   2
#define IDS_CV_COL_TYPE                 3
#define IDC_VIEW_SMALLICON              3
#define IDS_CV_COL_MODIFIED             4
#define IDC_VIEW_LIST                   4
#define IDS_CV_COL_PATH                 5
#define IDC_VIEW_DETAILS                5
#define IDC_ARRANGE_AUTO                6
#define IDC_ARRANGE_GRID                7
#define IDC_ITEM_COPY                   8

#define IDC_EDIT_COPY                   10
#define IDS_EXTRACTBROWSE               12
#define IDS_NEXTCABBROWSE               13
#define IDS_SUREUNINST                  14
#define IDS_THISDLL                     15
#define IDC_EDIT_SELALL                 15
#define IDC_EDIT_INVSEL                 16
#define IDS_NAME                        16
#define IDS_BYCOL_FMT                   17
#define IDS_NEXTDISKBROWSE              18
#define IDS_MISSINGDLL                  19
#define IDS_VIEW_ICON                   32
#define IDS_VIEW_SMALLICON              33
#define IDS_VIEW_LIST                   34
#define IDS_VIEW_DETAILS                35
#define IDS_EDIT_COPY                   36
#define IDS_EDIT_SELALL                 37
#define IDS_EDIT_INVSEL                 38
#define IDS_BYCOL_HELP_FMT              39
#define IDS_ARRANGE_GRID                40
#define IDS_ARRANGE_AUTO                41
#define IDS_TT_VIEW_ICON                64
#define IDS_TT_VIEW_SMALLICON           65
#define IDS_TT_VIEW_LIST                66
#define IDS_TT_VIEW_DETAILS             67
#define IDS_TT_EDIT_COPY                68
#define IDS_EXTRACTBROWSE_CAPTION       69
#define IDS_EXTRACTBROWSE_EXTRACT       70
#define MENU_ITEMCONTEXT                101
#define IDD_VIEW                        104
#define IDI_GENERIC                     105
#define MENU_SFV                        106
#define MENU_SFV_MAINMERGE              107
#define MENU_SFV_MAINMERGENF            108
#define IDA_MAIN                        108
#define IDC_LISTVIEW                    1000
#define IDC_LISTBOX                     1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40011
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\thisdll.h ===
//*******************************************************************************************
//
// Filename : ThisDll.h
//	
//				Generic OLE header file 
//
// Copyright (c) 1994 - 1996 Microsoft Corporation. All rights reserved
//
//*******************************************************************************************



#ifndef _THISDLL_H_
#define _THISDLL_H_



class CWaitCursor
{
public:
	CWaitCursor() {m_cOld=SetCursor(LoadCursor(NULL, IDC_WAIT));}
	~CWaitCursor() {SetCursor(m_cOld);}

private:
	HCURSOR m_cOld;
} ;

class CRefCount
{
public:
	CRefCount() : m_cRef(0) {};

	UINT AddRef()  {return(++m_cRef);}
	UINT Release() {return(--m_cRef);}
	UINT GetRef()  {return(  m_cRef);}

private:
	UINT m_cRef;

} ;

class CThisDll
{
public:
	CThisDll() {
        m_hInst=NULL;
	}
    // Make no destructor for global classes (requires CRT stuff)

	void SetInstance(HINSTANCE hInst) {m_hInst=hInst;}
	HINSTANCE GetInstance() {return(m_hInst);}

	CRefCount m_cRef;
	CRefCount m_cLock;

private:
	HINSTANCE	m_hInst;
} ;

extern CThisDll g_ThisDll;

class CRefDll
{
public:
	CRefDll()  {g_ThisDll.m_cRef.AddRef ();}
	~CRefDll() {g_ThisDll.m_cRef.Release();}
} ;

extern HRESULT CabFolder_CreateInstance(REFIID riid, LPVOID *ppvObj);
extern HRESULT CabViewDataObject_CreateInstance(REFIID riid, LPVOID *ppvObj);

#endif	// _THISDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\version.h ===
// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Cabinet File Viewer Shell Extension"
#define VER_INTERNALNAME_STR            "cabview"
#define VER_ORIGINALFILENAME_STR        "cabview.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\sources.inc ===
PRECOMPILED_CXX = 1

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETNAME      = cabview
TARGETPATH      = obj
TARGETTYPE      = DYNLINK

#VERIFY_LC       = 1
LC_PATH         = $(PROJECT_ROOT)\lcinf

DLLDEF          = ..\cabview.def

USE_MSVCRT      = 1

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

TARGETLIBS      = $(SDK_LIB_PATH)\kernel32.lib          \
                  $(WINDOWS_LIB_PATH)\gdi32p.lib        \
                  $(WINDOWS_LIB_PATH)\user32p.lib       \
                  $(SDK_LIB_PATH)\advapi32.lib          \
                  $(SDK_LIB_PATH)\mpr.lib               \
                  $(SDK_LIB_PATH)\shlwapi.lib           \
                  $(SDK_LIB_PATH)\shell32.lib           \
                  $(SHELL_LIB_PATH)\shell32p.lib        \
                  $(SDK_LIB_PATH)\ole32.lib             \
                  $(SDK_LIB_PATH)\oleaut32.lib          \
                  $(SDK_LIB_PATH)\uuid.lib              \
                  $(SHELL_LIB_PATH)\shfusion.lib        \
                  $(SHELL_LIB_PATH)\shlwapip.lib        \
                  $(CCSHELL_DIR)\lib\$(O)\shguid.lib    \
                  $(CCSHELL_DIR)\lib\$(O)\shguidp.lib   \
                  $(CCSHELL_DIR)\lib\$(O)\stock.lib

DLLBASE 	= 0x71200000

DLLENTRY	= _DllMainCRTStartup

SOURCES         = ..\cabview.rc  \
                  ..\cabitms.cpp \
                  ..\dataobj.cpp \
                  ..\debug.c     \
                  ..\enum.cpp    \
                  ..\fdidll.c    \
                  ..\folder.cpp  \
                  ..\menu.cpp    \
                  ..\thisdll.cpp

PRECOMPILED_INCLUDE = ..\pch.h

# 
# Fusionized
# 
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\thisguid.h ===
EXTERN_C const GUID CLSID_CabFolder;
EXTERN_C const GUID CLSID_CabViewDataObject;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cabview\thisdll.cpp ===
#include "pch.h"
#include <advpub.h>

#include <cguid.h>
#include "thisguid.h"

#include "thisdll.h"
#include "resource.h"
#include <comcat.h>     // Catagory registration.
#define DECL_CRTFREE
#include <crtfree.h>


// {0CD7A5C0-9F37-11CE-AE65-08002B2E1262}
const GUID CLSID_CabFolder = {0x0CD7A5C0L, 0x9F37, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62};
  
CThisDll g_ThisDll;

STDAPI_(BOOL) DllMain(HINSTANCE hDll, DWORD dwReason, void *lpRes)
{
   switch(dwReason)
   {
      case DLL_PROCESS_ATTACH:
         SHFusionInitializeFromModule(hDll);
         g_ThisDll.SetInstance(hDll);
         break;

      case DLL_PROCESS_DETACH:
          SHFusionUninitialize();
          break;
   }
   return TRUE;
}
 
STDAPI DllCanUnloadNow()
{
    return (g_ThisDll.m_cRef.GetRef() == 0) && (g_ThisDll.m_cLock.GetRef() == 0) ? 
        S_OK : S_FALSE;
}


// Procedure for uninstalling this DLL (given an INF file)
void CALLBACK Uninstall(HWND hwndStub, HINSTANCE hInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
    RUNDLLPROC pfnCheckAPI = Uninstall;
    TCHAR szTitle[100];
    TCHAR szPrompt[100 + MAX_PATH];
    OSVERSIONINFO osvi;
    LPTSTR pszSetupDll;
    LPTSTR pszRunDllExe;
    
    if (!lpszCmdLine || lstrlen(lpszCmdLine)>=MAX_PATH)
    {
        return;
    }
    
    LoadString(g_ThisDll.GetInstance(),IDS_SUREUNINST,szPrompt,ARRAYSIZE(szPrompt));
    LoadString(g_ThisDll.GetInstance(),IDS_THISDLL,szTitle,ARRAYSIZE(szTitle));
    
    if (MessageBox(hwndStub, szPrompt, szTitle, MB_YESNO|MB_ICONSTOP) != IDYES)
    {
        return;
    }
    
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);
    
    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
        /* Windows 95 uses SetupX */
        
        pszRunDllExe = TEXT("rundll.exe");
        pszSetupDll = TEXT("setupx.dll");
    }
    else
    {
        /* Windows NT uses SetupAPI */
        
        pszRunDllExe = TEXT("rundll32.exe");
        pszSetupDll = TEXT("setupapi.dll");
    }
    
    WCHAR szFullPathSetupDll[MAX_PATH];
    GetSystemDirectory(szFullPathSetupDll, ARRAYSIZE(szFullPathSetupDll));
    PathAppend(szFullPathSetupDll, pszSetupDll);
    wnsprintf(szPrompt, ARRAYSIZE(szPrompt), TEXT("%s,InstallHinfSection DefaultUninstall 132 %s"), szFullPathSetupDll, lpszCmdLine);
    
    // Try to win the race before setup finds this DLL still in use.
    // If we lose, a reboot will be required to get rid of the DLL.
    SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_ABOVE_NORMAL);
    
    WCHAR szFullPathRunDllExe[MAX_PATH];
    GetSystemDirectory(szFullPathRunDllExe, ARRAYSIZE(szFullPathRunDllExe));
    PathAppend(szFullPathRunDllExe, pszRunDllExe);
    ShellExecute(hwndStub, NULL, szFullPathRunDllExe, szPrompt, NULL, SW_SHOWMINIMIZED);
}


// Call ADVPACK for the given section of our resource based INF>
//   hInstance = resource instance to get REGINST section from
//   szSection = section name to invoke
HRESULT CallRegInstall(HINSTANCE hInstance, LPCSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");
        if ( pfnri )
        {
#ifdef WINNT
            STRENTRY seReg[] =
            {
                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };
            hr = pfnri(hInstance, szSection, &stReg);
#else
            hr = pfnri(hInstance, szSection, NULL);
#endif
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

STDAPI DllRegisterServer(void)
{
    CallRegInstall(g_ThisDll.GetInstance(), "RegDll");

    // Register as a browseable shell extension.  
    ICatRegister *pcr;
    HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                                   NULL, CLSCTX_INPROC_SERVER,
                                   IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
        CATID acatid[1];
        acatid[0] = CATID_BrowsableShellExt;

        pcr->RegisterClassImplCategories(CLSID_CabFolder, 1, acatid);
        pcr->Release();
    }
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    CallRegInstall(g_ThisDll.GetInstance(), "UnregDll");
    return S_OK;
}

class CThisDllClassFactory : public IClassFactory
{
public:
    CThisDllClassFactory(REFCLSID rclsid);

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // *** IClassFactory methods ***
    STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void ** ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);
    
private:
    CRefDll m_cRefDll;
    LONG m_cRef;
    CLSID m_clsid;
};

STDAPI DllGetClassObject(REFCLSID rclsid,  REFIID riid, void **ppvObj)
{
    HRESULT hres;

    *ppvObj = NULL;
    
    if ((rclsid == CLSID_CabFolder) || (rclsid == CLSID_CabViewDataObject))
    {
        CThisDllClassFactory *pcf = new CThisDllClassFactory(rclsid);
        if (pcf)
        {
            hres = pcf->QueryInterface(riid, ppvObj);
            pcf->Release(); 
        }
        else
            hres = E_OUTOFMEMORY;
    }
    else
        hres = E_FAIL;
    return hres;
}


STDMETHODIMP CThisDllClassFactory::QueryInterface(REFIID riid, void ** ppvObj)
{
    if ((riid == IID_IUnknown) || (riid == IID_IClassFactory))
    {
        *ppvObj = (void *)(IClassFactory *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    ((IUnknown *)*ppvObj)->AddRef();
    return NOERROR;
}

CThisDllClassFactory::CThisDllClassFactory(REFCLSID rclsid) : m_cRef(1), m_clsid(rclsid)
{
}

STDMETHODIMP_(ULONG) CThisDllClassFactory::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CThisDllClassFactory::Release(void)
{
#if DBG==1
    if ( 0 == m_cRef )
    {
        DebugBreak( );  // ref counter problem
    }
#endif
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CThisDllClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void ** ppvObj)
{
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    return (CLSID_CabFolder == m_clsid) ?
                ::CabFolder_CreateInstance(riid, ppvObj) :
                ::CabViewDataObject_CreateInstance(riid, ppvObj);
}


STDMETHODIMP CThisDllClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        g_ThisDll.m_cLock.AddRef();
    }
    else
    {
        g_ThisDll.m_cLock.Release();
    }
    
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\bindstcb.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// bindstcb.cpp 
//
//   Bind status callback object.  Called by cdf file parser.
//
//   History:
//
//       3/31/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "cdfidl.h"
#include "xmlutil.h"
#include "persist.h"
#include "bindstcb.h"
#include "chanapi.h"
#include "chanenum.h"
#include "dll.h"
#include "resource.h"

//
// Constructor and destructor.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::CBindStatusCallback ***
//
//    Constructor.
//
////////////////////////////////////////////////////////////////////////////////
CBindStatusCallback::CBindStatusCallback (
	IXMLDocument* pIXMLDocument,
    LPCWSTR pszURLW
)
: m_cRef(1)
{
    ASSERT(pIXMLDocument);
    ASSERT(pszURLW);

    pIXMLDocument->AddRef();
    m_pIXMLDocument = pIXMLDocument;

    int cb = StrLenW(pszURLW) + 1;

    m_pszURL = new TCHAR[cb];

    if (m_pszURL)
        SHUnicodeToTChar(pszURLW, m_pszURL, cb);

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::~CBindStatusCallback ***
//
//    Destructor.
//
////////////////////////////////////////////////////////////////////////////////
CBindStatusCallback::~CBindStatusCallback (
	void
)
{
    ASSERT(0 == m_cRef);

    if (m_pIXMLDocument)
        m_pIXMLDocument->Release();

    if (m_pszURL)
        delete [] m_pszURL;

    if (m_pPrevIBindStatusCallback)
        m_pPrevIBindStatusCallback->Release();

	return;
}


//
// IUnknown methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::QueryInterface ***
//
//    CBindStatusCallback QI.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback::QueryInterface (
    REFIID riid,
    void **ppv
)
{
    HRESULT hr;

    ASSERT(ppv);

    if (IID_IUnknown == riid || IID_IBindStatusCallback == riid)
    {
        AddRef();
        *ppv = (IBindStatusCallback*)this;
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && NULL == *ppv));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::AddRef ***
//
//    CBindStatusCallback AddRef.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CBindStatusCallback::AddRef (
    void
)
{
    ASSERT(m_cRef != 0);
    ASSERT(m_cRef < (ULONG)-1);

    return ++m_cRef;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::Release ***
//
//    CContextMenu Release.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CBindStatusCallback::Release (
    void
)
{
    ASSERT (m_cRef != 0);

    ULONG cRef = --m_cRef;
    
    if (0 == cRef)
        delete this;

    return cRef;
}


//
// IBindStatusCallback methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::GetBindInfo ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback::GetBindInfo(
    DWORD* pgrfBINDF,
    BINDINFO* pbindinfo
)
{
    //ASSERT(pgrfBINDF);

    //*pgrfBINDF &= ~BINDF_ASYNCHRONOUS;

    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::OnStartBinding ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback::OnStartBinding(
    DWORD dwReserved,
    IBinding* pIBinding
)
{
    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::GetPriority ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback::GetPriority(
    LONG *pnPriority
)
{
    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::OnProgress ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback::OnProgress(
    ULONG ulProgress,
    ULONG ulProgressMax,
    ULONG ulStatusCode,
    LPCWSTR szStatusText
)
{
    HRESULT hr;

    if (m_pPrevIBindStatusCallback)
    {
        hr = m_pPrevIBindStatusCallback->OnProgress(ulProgress, ulProgressMax,
                                                    ulStatusCode, szStatusText);
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::OnDataAvailable ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback::OnDataAvailable(
    DWORD grfBSCF,
    DWORD dwSize,
    FORMATETC* pfmtect,
    STGMEDIUM* pstgmed
)
{
    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::OnObjectAvialable ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback::OnObjectAvailable(
    REFIID riid,
    IUnknown* pIUnknown
)
{
    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::OnLowResource ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback::OnLowResource(
    DWORD dwReserved
)
{
    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::OnStopBinding ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback::OnStopBinding(
    HRESULT hrStatus,
    LPCWSTR szStatusText
)
{
    if (m_pPrevIBindStatusCallback)
        m_pPrevIBindStatusCallback->OnStopBinding(hrStatus, szStatusText);

    HRESULT hr = hrStatus;

    if (SUCCEEDED(hr))
    {
        if (m_pszURL)
        {
            ASSERT(m_pIXMLDocument);

            XML_DownloadImages(m_pIXMLDocument);

            // Moved to constructor.
            //Cache_AddItem(m_pszURL, m_pIXMLDocument, PARSE_NET);

            XML_MarkCacheEntrySticky(m_pszURL);

            //
            // Update the item now that the download is complete.
            //

            WCHAR wszURL[INTERNET_MAX_URL_LENGTH];

            if (SHTCharToUnicode(m_pszURL, wszURL, ARRAYSIZE(wszURL)))
                Channel_SendUpdateNotifications(wszURL);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


//
// Helper functions.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::Wait ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CBindStatusCallback::Init(
    IBindStatusCallback* pPrevIBindStatusCallback
)
{
    ASSERT(NULL == m_pPrevIBindStatusCallback);

    m_pPrevIBindStatusCallback = pPrevIBindStatusCallback;

    return S_OK;
}


//
// Constructor and destructor.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::CBindStatusCallback ***
//
//    Constructor.
//
////////////////////////////////////////////////////////////////////////////////
CBindStatusCallback2::CBindStatusCallback2 (
	HWND hwnd
)
: m_cRef(1),
  m_hwnd(hwnd)
{
    DllAddRef();

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::~CBindStatusCallback ***
//
//    Destructor.
//
////////////////////////////////////////////////////////////////////////////////
CBindStatusCallback2::~CBindStatusCallback2 (
	void
)
{
    ASSERT(0 == m_cRef);

    DllRelease();

	return;
}


//
// IUnknown methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::QueryInterface ***
//
//    CBindStatusCallback QI.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback2::QueryInterface (
    REFIID riid,
    void **ppv
)
{
    HRESULT hr;

    ASSERT(ppv);

    if (IID_IUnknown == riid || IID_IBindStatusCallback == riid)
    {
        AddRef();
        *ppv = (IBindStatusCallback*)this;
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && NULL == *ppv));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::AddRef ***
//
//    CBindStatusCallback AddRef.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CBindStatusCallback2::AddRef (
    void
)
{
    ASSERT(m_cRef != 0);
    ASSERT(m_cRef < (ULONG)-1);

    return ++m_cRef;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::Release ***
//
//    CContextMenu Release.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CBindStatusCallback2::Release (
    void
)
{
    ASSERT (m_cRef != 0);

    ULONG cRef = --m_cRef;
    
    if (0 == cRef)
        delete this;

    return cRef;
}


//
// IBindStatusCallback methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::GetBindInfo ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback2::GetBindInfo(
    DWORD* pgrfBINDF,
    BINDINFO* pbindinfo
)
{
    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::OnStartBinding ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback2::OnStartBinding(
    DWORD dwReserved,
    IBinding* pIBinding
)
{
    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::GetPriority ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback2::GetPriority(
    LONG *pnPriority
)
{
    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::OnProgress ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback2::OnProgress(
    ULONG ulProgress,
    ULONG ulProgressMax,
    ULONG ulStatusCode,
    LPCWSTR szStatusText
)
{
    PostMessage(m_hwnd, WM_COMMAND, DOWNLOAD_PROGRESS,
                0);

    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::OnDataAvailable ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback2::OnDataAvailable(
    DWORD grfBSCF,
    DWORD dwSize,
    FORMATETC* pfmtect,
    STGMEDIUM* pstgmed
)
{
    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::OnObjectAvialable ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback2::OnObjectAvailable(
    REFIID riid,
    IUnknown* pIUnknown
)
{
    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::OnLowResource ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback2::OnLowResource(
    DWORD dwReserved
)
{
    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CBindStatusCallback::OnStopBinding ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBindStatusCallback2::OnStopBinding(
    HRESULT hrStatus,
    LPCWSTR szStatusText
)
{
    HRESULT hr = hrStatus;

    PostMessage(m_hwnd, WM_COMMAND, DOWNLOAD_COMPLETE,
                SUCCEEDED(hr) ? TRUE : FALSE);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\bindstcb.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// bindstcb.h 
//
//   Bind status callback object.
//
//   History:
//
//       3/31/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _BINDSTCB_H_

#define _BINDSTCB_H_

//
// Class definition for the bind status callback class.
//

class CBindStatusCallback : public IBindStatusCallback
{
//
// Methods
//

public:

    // Constructor
    CBindStatusCallback(IXMLDocument* pIXMLDocument, LPCWSTR pszURLW);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IBindStatusCallback methods.
    STDMETHODIMP GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP OnStartBinding(DWORD dwReserved, IBinding* pIBinding);
    STDMETHODIMP GetPriority(LONG *pnPriority);

    STDMETHODIMP OnProgress(ULONG ulProgress,
                            ULONG ulProgressMax,
                            ULONG ulStatusCode,
                            LPCWSTR szStatusText);

    STDMETHODIMP OnDataAvailable(DWORD grfBSCF,
                                 DWORD dwSize,
                                 FORMATETC* pfmtect,
                                 STGMEDIUM* pstgmed);

    STDMETHODIMP OnObjectAvailable(REFIID riid, IUnknown* pIUnknown);
    STDMETHODIMP OnLowResource(DWORD dwReserved);
    STDMETHODIMP OnStopBinding(HRESULT hrStatus, LPCWSTR szStatusText);

    // Helper functions.

    HRESULT Init(IBindStatusCallback* pPrevIBindStatusCallback);

private:

    // Destructor.
    ~CBindStatusCallback(void);

//
// Member variables.
//

private:

    ULONG                   m_cRef;
    IXMLDocument*           m_pIXMLDocument;
    LPTSTR                  m_pszURL;
    IBindStatusCallback*    m_pPrevIBindStatusCallback;
};



#define DOWNLOAD_PROGRESS  0x9001
#define DOWNLOAD_COMPLETE  0x9002

class CBindStatusCallback2 : public IBindStatusCallback
{
//
// Methods
//

public:

    // Constructor
    CBindStatusCallback2(HWND hwnd);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IBindStatusCallback methods.
    STDMETHODIMP GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP OnStartBinding(DWORD dwReserved, IBinding* pIBinding);
    STDMETHODIMP GetPriority(LONG *pnPriority);

    STDMETHODIMP OnProgress(ULONG ulProgress,
                            ULONG ulProgressMax,
                            ULONG ulStatusCode,
                            LPCWSTR szStatusText);

    STDMETHODIMP OnDataAvailable(DWORD grfBSCF,
                                 DWORD dwSize,
                                 FORMATETC* pfmtect,
                                 STGMEDIUM* pstgmed);

    STDMETHODIMP OnObjectAvailable(REFIID riid, IUnknown* pIUnknown);
    STDMETHODIMP OnLowResource(DWORD dwReserved);
    STDMETHODIMP OnStopBinding(HRESULT hrStatus, LPCWSTR szStatusText);

private:

    // Destructor.
    ~CBindStatusCallback2(void);

//
// Member variables.
//

private:

    ULONG           m_cRef;
    HWND            m_hwnd;
};


#endif _BINDSTCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\cache.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// cache.h 
//
//   XML document cache.
//
//   History:
//
//       4/15/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////


//
// Check for previous includes of this file.
//

#ifndef _CACHE_H_

#define _CACHE_H_

//
// Type definitions.
//

typedef struct _tagCACHEITEM
{
    LPTSTR          szURL;
    DWORD           dwParseFlags;
    FILETIME        ftLastMod;
    DWORD           dwCacheCount;
    IXMLDocument*   pIXMLDocument;
    _tagCACHEITEM*  pNext;
} CACHEITEM, *PCACHEITEM;

//
// Function prototypes.
//

void    Cache_Initialize(void);
void    Cache_Deinitialize(void);
void    Cache_EnterWriteLock(void);
void    Cache_LeaveWriteLock(void);
void    Cache_EnterReadLock(void);
void    Cache_LeaveReadLock(void);

HRESULT Cache_AddItem(LPTSTR szURL,
                      IXMLDocument* pIXMLDocument,
                      DWORD dwParseFlags,
                      FILETIME ftLastMod,
                      DWORD dwCacheCount);

HRESULT Cache_QueryItem(LPTSTR szURL,
                        IXMLDocument** ppIXMLDocument,
                        DWORD dwParseFlags);

HRESULT Cache_RemoveItem(LPCTSTR szURL);

void    Cache_FreeAll(void);

#endif // _CACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\cache.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// cache.cpp 
//
//   XML document cache.
//
//   History:
//
//       4/15/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "persist.h"
#include "cache.h"
#include "cdfidl.h"
#include "xmlutil.h"
#include "dll.h"

//
// Cache functions.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Cache_Initialize *** 
//
//   Prepare the XML document cache for use.
//
////////////////////////////////////////////////////////////////////////////////
void
Cache_Initialize(
    void
)
{
    ASSERT(NULL == g_pCache);

    InitializeCriticalSection(&g_csCache);

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Cache_Initialize *** 
//
//   Deactivate the cache.
//
////////////////////////////////////////////////////////////////////////////////
void
Cache_Deinitialize(
    void
)
{
    // MSXML has gone away at this point
    // Cache_FreeAll();

    DeleteCriticalSection(&g_csCache);

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Cache_EnterWriteLock ***
//
//    Obtain exclusive use of the XML document cache.
//
////////////////////////////////////////////////////////////////////////////////
void
Cache_EnterWriteLock(
    void
)
{
    EnterCriticalSection(&g_csCache);

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Cache_EnterWriteLock ***
//
//    Release exclusive use of the XML document cache.
//
////////////////////////////////////////////////////////////////////////////////
void
Cache_LeaveWriteLock(
    void
)
{
    LeaveCriticalSection(&g_csCache);

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Cache_EnterReadLock ***
//
//    Exclude writes to the the items list.  Currently this also excludes other
//    reads.  If need be this can be modified to allow multiple reads while
//    still excluding writes.
//
////////////////////////////////////////////////////////////////////////////////
void
Cache_EnterReadLock(
    void
)
{
    EnterCriticalSection(&g_csCache);

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Cache_LeaveReadLock ***
//
//    Release a read hold on the use of the XML document cache.
//
////////////////////////////////////////////////////////////////////////////////
void
Cache_LeaveReadLock(
    void
)
{
    LeaveCriticalSection(&g_csCache);

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Cache_AddItem ***
//
//
// Description:
//     Add an xml document to the cache.
//
// Parameters:
//     [In]  szURL         - The URL of the cdf file.
//     [In]  pIXMLDocument - The already parsed xml document.
//
// Return:
//     S_OK if the document was added to the cache.
//     E_OUTOFMEMORY if the document couldn't be aded to the cache.
//
// Comments:
//     The xml document is AddRefed when inserted into the cache and
//     Released on removal from the cache.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
Cache_AddItem(
    LPTSTR szURL,
    IXMLDocument* pIXMLDocument,
    DWORD dwParseFlags,
    FILETIME ftLastMod,
    DWORD dwCacheCount
)
{
    ASSERT(szURL);
    ASSERT(pIXMLDocument);

    Cache_EnterWriteLock();

    HRESULT hr;

    PCACHEITEM pNewItem = new CACHEITEM;

    if (pNewItem)
    {
        size_t cch = StrLen(szURL) + 1;
        LPTSTR pszURLCopy = (LPTSTR)new TCHAR[cch];

        if (pszURLCopy)
        {
            //
            // Limit the cache to one item by freeing all current items.
            //

            Cache_FreeAll();

            //
            // Remove an old cache entry for this url if it exists.
            //

            // Check no longer needed since we just cleared the cache.
            /*IXMLDocument* pIXMLDocumentOld;

            if (SUCCEEDED(Cache_QueryItem(szURL, &pIXMLDocumentOld,
                                          PARSE_LOCAL)))
            {
                ASSERT(pIXMLDocumentOld);

                Cache_RemoveItem(szURL);
                pIXMLDocumentOld->Release();
            }*/

            StrCpyN(pszURLCopy, szURL, cch);

            pIXMLDocument->AddRef();

            pNewItem->szURL         = pszURLCopy;
            pNewItem->dwParseFlags  = dwParseFlags;
            pNewItem->ftLastMod     = ftLastMod;
            pNewItem->dwCacheCount  = dwCacheCount;
            pNewItem->pIXMLDocument = pIXMLDocument;

            //
            // REVIEW:  Check for duplicate cache items?
            //

            pNewItem->pNext = g_pCache;
            g_pCache = pNewItem;


            hr = S_OK;
        }
        else
        {
            delete pNewItem;

            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    Cache_LeaveWriteLock();

    return hr;
}

//
//
//

BOOL
IsEmptyTime(
    FILETIME ft
)
{
    return (0 == ft.dwLowDateTime && 0 == ft.dwHighDateTime);
}

BOOL
IsEqualTime(
    FILETIME ft1,
    FILETIME ft2
)
{
    return ((ft1.dwLowDateTime == ft2.dwLowDateTime) && 
            (ft1.dwHighDateTime == ft2.dwHighDateTime));
}

void
Cache_RefreshItem(
    CACHEITEM* pItem,
    LPTSTR pszLocalFile,
    FILETIME ftLastMod
)
{
    ASSERT(pItem);

    //
    // Try and parse the cdf from the wininet cache.
    //

    IXMLDocument* pIXMLDocument;

    HRESULT hr;

    DLL_ForcePreloadDlls(PRELOAD_MSXML);
    
    hr = CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC_SERVER,
                          IID_IXMLDocument, (void**)&pIXMLDocument);

    BOOL bCoInit = FALSE;

    if ((CO_E_NOTINITIALIZED == hr || REGDB_E_IIDNOTREG == hr) &&
        SUCCEEDED(CoInitialize(NULL)))
    {
        bCoInit = TRUE;
        hr = CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC_SERVER,
                              IID_IXMLDocument, (void**)&pIXMLDocument);
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLDocument);

        hr = XML_SynchronousParse(pIXMLDocument, pszLocalFile);

        if (FAILED(hr))
            pIXMLDocument->Release();
    }

    if (bCoInit)
        CoUninitialize();

    //
    // If the new cdf was parsed, replace the old one.
    //

    if (SUCCEEDED(hr))
    {
        pItem->pIXMLDocument->Release();
        pItem->pIXMLDocument = pIXMLDocument;
        pItem->ftLastMod = ftLastMod;
    }

    return;
}

BOOL
Cache_IsItemFresh(
    CACHEITEM* pItem,
    DWORD dwParseFlags
)
{
    ASSERT(pItem);

    BOOL  fRet;
    DWORD dwCurrentCacheCount = g_dwCacheCount;                            

    //
    // If the caller asked for "Net" quality data and we only have "Local" data
    // then throw the "Local" data away.  The resultant cache miss will cause
    // the caller to pick up fresher data.
    //

    if ((dwParseFlags & PARSE_NET) && (pItem->dwParseFlags & PARSE_LOCAL))
    {
        fRet = FALSE;
    }
    else
    {
        fRet = TRUE;

        //
        // If the global cache counter is greater than the counter for this
        // item, then a cdf has been added to the cache.
        //

        if (dwCurrentCacheCount > pItem->dwCacheCount)
        {
            //
            // Get the last mod time from the the cdf in the wininet cache.
            //

            FILETIME ftLastMod;
            TCHAR    szLocalFile[MAX_PATH];

            if (SUCCEEDED(URLGetLocalFileName(pItem->szURL, szLocalFile,
                                ARRAYSIZE(szLocalFile), &ftLastMod)))
            {
                //
                //  If the last mod times are different then the cdf in the
                //  wininet cache is newer, pick it up.
                //  If there are no last modified times then do the conservative
                //  thing and pick up the cdf from the wininet cache.
                //

                if ((IsEmptyTime(ftLastMod) && IsEmptyTime(pItem->ftLastMod)) ||
                    !IsEqualTime(ftLastMod, pItem->ftLastMod))
                {
                    Cache_RefreshItem(pItem, szLocalFile, ftLastMod);
                }
            }

            pItem->dwCacheCount = dwCurrentCacheCount;
        }
    }

    return fRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Cache_QueryItem ***
//
//
// Description:
//     Returns a xml document from the cache if it is found.
//
// Parameters:
//     [In]  szURL          - The URL associated with the xml document.
//     [Out] ppIXMLDocument - A pointer that receives the xml document.
//
// Return:
//     S_OK if the document associtaed with the given URL is found in the cache.
//     E_FAIL if the document isn't in the cache.
//
// Comments:
//     The returned pointer is AddRefed.  The caller isresposible for releasing
//     this pointer.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
Cache_QueryItem(
    LPTSTR szURL,
    IXMLDocument** ppIXMLDocument,
    DWORD dwParseFlags
)
{
    ASSERT(szURL);
    ASSERT(ppIXMLDocument);

    HRESULT hr = E_FAIL;

    Cache_EnterReadLock();

    PCACHEITEM pItem = g_pCache;

    //
    // REVIEW: Use CompareUrl from shlwapip?
    //

    while (pItem && !StrEql(szURL, pItem->szURL))
        pItem = pItem->pNext;

    if (pItem)
    {
        if (Cache_IsItemFresh(pItem, dwParseFlags))
        {
            ASSERT(pItem->pIXMLDocument);

            pItem->pIXMLDocument->AddRef();

            *ppIXMLDocument = pItem->pIXMLDocument;

            hr = S_OK;
        }
        else
        {
            Cache_RemoveItem(szURL);
        }

    }

    Cache_LeaveReadLock();

    ASSERT(SUCCEEDED(hr) && ppIXMLDocument || FAILED(hr));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Cache_FreeAll ***
//
//
// Description:
//     Frees all items from the xml document cache.
//
// Parameters:
//     None.
//
// Return:
//     None.
//
// Comments:
//     Frees all memory held in the xml document cache.
//
////////////////////////////////////////////////////////////////////////////////
void
Cache_FreeAll(
    void
)
{
    Cache_EnterWriteLock();
 
    PCACHEITEM pItem = g_pCache;
    g_pCache = NULL;

    Cache_LeaveWriteLock();

    while (pItem)
    {
        PCACHEITEM pNext = pItem->pNext;

        ASSERT(pItem->szURL);
        ASSERT(pItem->pIXMLDocument);

        pItem->pIXMLDocument->Release();

        delete [] pItem->szURL;
        delete pItem;

        pItem = pNext;
    }

    return;
}
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Cache_FreeItem ***
//
//
// Description:
//     Frees item associated with given URL from the xml document cache.
//
// Parameters:
//     LPTSTR szURL
//
// Return:
//     HRESULT S_OK if item in cache and deleted, E_FAIL if item not in cache
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
Cache_RemoveItem(
    LPCTSTR szURL
)
{
    ASSERT(szURL);

    HRESULT hr;

    Cache_EnterWriteLock();

    PCACHEITEM pItem = g_pCache;
    PCACHEITEM pItemPrev = NULL;

    //
    // REVIEW: Use CompareUrl from slwapip?.
    //

    while (pItem && !StrEql(szURL, pItem->szURL))
    {
        pItemPrev = pItem;
        pItem = pItem->pNext;
    }

    if (pItem)
    {
        ASSERT(pItem->pIXMLDocument);

        if (pItemPrev)
        {
            pItemPrev->pNext = pItem->pNext;
        }
        else
        {
            g_pCache = pItem->pNext; // handle remove first item case
        }

        pItem->pIXMLDocument->Release();
        delete [] pItem->szURL;
        delete pItem;

        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    Cache_LeaveWriteLock();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\cdfidl.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// cdfidl.h 
//
//   The definition of cdf idlist structures and helper functions.
//
//   History:
//
//       3/19/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _CDFIDL_H_

#define _CDFIDL_H_


//
// CDFITEMID_VERSION is used to corerectly read back persisted id lists
// CDFITEMID_ID is used to identify id lists as cdf id lists.
//

#define CDFITEMID_VERSION   0x00
#define CDFITEMID_ID        0xed071264

//
// Index values for "special" cdf nodes.
//

#define INDEX_CHANNEL_LINK  -1

//
// Types of cdf item id lists.  Note: These valuse are cast as bytes to save
// space in the item id.
//

typedef enum _tagCDFITEMTYPE {
    CDF_Folder      = 0x01,
    CDF_FolderLink  = 0x02,
    CDF_Link        = 0x03
} CDFITEMTYPE;


//
//  The structure of a cdf item id.  The szName parameter is a placeholder
//  for a variable length name string followed by zero or more additional
//  variable length strings. 
//

#pragma pack(1)

typedef struct _tagCDFITEMID
{
    USHORT       cb;
    BYTE         wVersion;
    BYTE         cdfItemType;
    DWORD        dwId;
    LONG         nIndex;
    TCHAR        szName[1];
} CDFITEMID;

#pragma pack()

typedef UNALIGNED CDFITEMID *PCDFITEMID;


typedef struct _tagCDFITEMIDLIST
{
    CDFITEMID mkid;
} CDFITEMIDLIST;

typedef UNALIGNED CDFITEMIDLIST *PCDFITEMIDLIST;

//
// Cdf item data.  Structure containing the unique elements of a cdf item id.
// Its used to create cdf item ids.
//

typedef struct _tagCDFITEM
{
    LONG         nIndex;
    CDFITEMTYPE  cdfItemType;
    BSTR         bstrName;
    BSTR         bstrURL;
} CDFITEM, *PCDFITEM;


//
// Cdf id list function prototypes.
//

PCDFITEMIDLIST CDFIDL_Create(PCDFITEM pCdfItem);

PCDFITEMIDLIST CDFIDL_CreateFromXMLElement(IXMLElement* pIXMLElement,
                                           ULONG nIndex);
PCDFITEMIDLIST CDFIDL_CreateFolderPidl(PCDFITEMIDLIST pcdfidl);

BOOL    CDFIDL_IsUnreadURL(LPTSTR szUrl);
void    CDFIDL_Free(PCDFITEMIDLIST pcdfidl);
HRESULT CDFIDL_GetDisplayName(PCDFITEMIDLIST pcdfidl, LPSTRRET pName);
LPTSTR  CDFIDL_GetName(PCDFITEMIDLIST pcdfidl);
LPTSTR  CDFIDL_GetNameId(PCDFITEMID pcdfid); 
LPTSTR  CDFIDL_GetURL(PCDFITEMIDLIST pcdfidl);
LPTSTR  CDFIDL_GetURLId(PCDFITEMID pcdfid);
ULONG   CDFIDL_GetIndex(PCDFITEMIDLIST pcdfidl);
ULONG   CDFIDL_GetIndexId(PCDFITEMID pcdfid);
BOOL    CDFIDL_IsCachedURL(LPWSTR wszUrl);
ULONG   CDFIDL_GetAttributes(IXMLElementCollection* pIXMLElementCollection,
                             PCDFITEMIDLIST pcdfidl, ULONG fAttributesFilter);

SHORT   CDFIDL_Compare(PCDFITEMIDLIST pcdfidl1, PCDFITEMIDLIST pcdfidl2);
SHORT   CDFIDL_CompareId(PCDFITEMID pcdfid1, PCDFITEMID pcdfid2);
BOOL    CDFIDL_IsValid(PCDFITEMIDLIST pcdfidl);
BOOL    CDFIDL_IsValidId(PCDFITEMID pcdfid);
BOOL    CDFIDL_IsValidSize(PCDFITEMID pcdfid);
BOOL    CDFIDL_IsValidType(PCDFITEMID pcdfid);
BOOL    CDFIDL_IsValidIndex(PCDFITEMID pcdfitemid);
BOOL    CDFIDL_IsValidStrings(PCDFITEMID pcdfitemid);
BOOL    CDFIDL_IsFolder(PCDFITEMIDLIST pcdfidl);
BOOL    CDFIDL_IsFolderId(PCDFITEMID pcdfid);
HRESULT CDFIDL_NonCdfGetDisplayName(LPCITEMIDLIST pidl, LPSTRRET pName);


#ifdef ALIGNMENT_MACHINE
#define ALIGN4(sz) (((sz)+3)&~3)
#endif /* UNIX */

#endif // _CDFIDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\cdfview.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// cdfview.h 
//
//   The class definition for the cdf view class.  This class implements the
//   IShelFolder interface.
//
//   History:
//
//       3/16/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _CDFVIEW_H_

#define _CDFVIEW_H_

//
// Function prototypes.
//

HRESULT QueryInternetShortcut(LPCTSTR pszURL, REFIID riid, void** ppvOut);

HRESULT QueryInternetShortcut(PCDFITEMIDLIST pcdfidl, REFIID riid,
                              void** ppvOut);


//
// Class definition for the cdf view class.
//

class CCdfView : public IShellFolder,
                 public CPersist
{
//
// Methods
//

public:

    // Constructors
    CCdfView(void);
    CCdfView(PCDFITEMIDLIST pcdfidl,
             LPCITEMIDLIST pidlParentPath,
             IXMLElementCollection* pIXMLElementCollection);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwndOwner,
                                  LPBC pbcReserved,
                                  LPOLESTR lpszDisplayName,
                                  ULONG* pchEaten,
                                  LPITEMIDLIST* ppidl,
                                  ULONG* pdwAttributes);

    STDMETHODIMP EnumObjects(HWND hwndOwner,
                             DWORD grfFlags,
                             LPENUMIDLIST* ppenumIDList);

    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl,
                              LPBC pbcReserved,
                              REFIID riid,
                              LPVOID* ppvOut);

    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl,
                               LPBC pbcReserved,
                               REFIID riid,
                               LPVOID* ppvObj);

    STDMETHODIMP CompareIDs(LPARAM lParam,
                            LPCITEMIDLIST pidl1,
                            LPCITEMIDLIST pidl2);

    STDMETHODIMP CreateViewObject(HWND hwndOwner,
                                  REFIID riid,
                                  LPVOID* ppvOut);

    STDMETHODIMP GetAttributesOf(UINT cidl,
                                 LPCITEMIDLIST* apidl,
                                 ULONG* pfAttributesOut);

    STDMETHODIMP GetUIObjectOf(HWND hwndOwner,
                               UINT cidl,
                               LPCITEMIDLIST* apidl,
                               REFIID riid,
                               UINT* prgfInOut,
                               LPVOID * ppvOut);

    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl,
                                  DWORD uFlags,
                                  LPSTRRET lpName);

    STDMETHODIMP SetNameOf(HWND hwndOwner,
                           LPCITEMIDLIST pidl,
                           LPCOLESTR lpszName,
                           DWORD uFlags,
                           LPITEMIDLIST* ppidlOut);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

private:

    // Destructor
    ~CCdfView(void);

    // Parsing helper functions.
    HRESULT  ParseCdfFolder(HWND hwndOwner, DWORD dwParseFlags);

    // Folder helper functions.

//
// Member variables.
//

private:

    ULONG                   m_cRef;
    PCDFITEMIDLIST          m_pcdfidl;     // This folder's pidl
    LPITEMIDLIST            m_pidlPath;    // Path to this folder.
    IXMLElementCollection*  m_pIXMLElementCollection;
    BOOL                    m_fIsRootFolder; // Is this the root folder.
};


#endif _CDFVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\cdfview.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// cdfview.cpp 
//
//   IUnknown for the cdfview class.
//
//   History:
//
//       3/16/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "cdfidl.h"
#include "persist.h"
#include "cdfview.h"
#include "view.h"
#include "xmlutil.h"
#include "dll.h"


//
// Constructor and destructor.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::CCdfView ***
//
//    Constructor.
//
////////////////////////////////////////////////////////////////////////////////
CCdfView::CCdfView (
	void
)
: CPersist(FALSE), // TRUE indicates cdf hasn't been parsed.
  m_cRef(1),
  m_fIsRootFolder(TRUE)
{
    //
    // Memory allocs are assumed to be zero init'ed.
    //

    ASSERT(NULL == m_pcdfidl);
    ASSERT(NULL == m_pIXMLElementCollection);
    ASSERT(NULL == m_pidlPath);

    //
    // As long as this class is around the dll should stay loaded.
    //

    TraceMsg(TF_OBJECTS, "+ IShellFolder");
    //TraceMsg(TF_ALWAYS,  "+ IShellFolder %0x08d", this);

    DllAddRef();

	return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::CCdfView ***
//
//    Constructor.
//
////////////////////////////////////////////////////////////////////////////////
CCdfView::CCdfView (
	PCDFITEMIDLIST pcdfidl,
    LPCITEMIDLIST pidlParentPath,
    IXMLElementCollection* pParentIXMLElementCollection
)
: CPersist(TRUE),  // TRUE indicates cdf already parsed.
  m_cRef(1),
  m_fIsRootFolder(FALSE)
{
    ASSERT(CDFIDL_IsValid(pcdfidl));
    ASSERT(pParentIXMLElementCollection == NULL ||
           XML_IsCdfidlMemberOf(pParentIXMLElementCollection, pcdfidl));

    ASSERT(NULL == m_pidlPath);
    ASSERT(NULL == m_pIXMLElementCollection);

    //
    // Note that m_pidlPath, m_pcdfidl & m_pIXMLElementCollection could be
    // NULL in low memory conditions.
    //

    m_pcdfidl = (PCDFITEMIDLIST)ILCloneFirst((LPITEMIDLIST)pcdfidl);

    ASSERT(CDFIDL_IsValid(m_pcdfidl) || NULL == m_pcdfidl);
    ASSERT(ILIsEmpty(_ILNext((LPITEMIDLIST)m_pcdfidl)) || NULL == m_pcdfidl);

    m_pidlPath = ILCombine(pidlParentPath, (LPITEMIDLIST)m_pcdfidl);

    if (pParentIXMLElementCollection)
    {
        XML_GetChildElementCollection(pParentIXMLElementCollection,
                                      CDFIDL_GetIndexId(&pcdfidl->mkid),
                                      &m_pIXMLElementCollection);
    }
    
    //
    // As long as this class is around the dll should stay loaded.
    //

    TraceMsg(TF_OBJECTS, "+ IShellFolder %s", CDFIDL_GetName(pcdfidl));
    //TraceMsg(TF_ALWAYS,  "+ IShellFolder %0x08d", this);

    DllAddRef();

	return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::~CCdfView **
//
//    Destructor.
//
////////////////////////////////////////////////////////////////////////////////
CCdfView::~CCdfView (
	void
)
{
    ASSERT(0 == m_cRef);

    if (m_pidlPath)
        ILFree(m_pidlPath);

    if (m_pcdfidl)
        CDFIDL_Free(m_pcdfidl);

    if (m_pIXMLElementCollection)
        m_pIXMLElementCollection->Release();

    //
    // Matching Release for the constructor Addref.
    //

    TraceMsg(TF_OBJECTS, "- IShellFolder");
    //TraceMsg(TF_ALWAYS,  "- IShellFolder %0x08d", this);

    DllRelease();

	return;
}


//
// IUnknown methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::QueryInterface **
//
//    Cdf view QI.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfView::QueryInterface (
    REFIID riid,
    void **ppv
)
{
    ASSERT(ppv);

    HRESULT hr;

    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IShellFolder == riid)
    {
        *ppv = (IShellFolder*)this;
    }
    else if (IID_IPersist == riid || IID_IPersistFile == riid)
    {
        *ppv = (IPersistFile*)this;
    }
    else if (IID_IPersistFolder == riid)
    {
        *ppv = (IPersistFolder*)this;
    }
    else if (IID_IPersistMoniker == riid)
    {
        *ppv = (IPersistMoniker*)this;
    }
    else if (IID_IOleObject == riid)
    {
        *ppv = (IOleObject*)this;
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && NULL == *ppv));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::AddRef **
//
//    Cdf view AddRef.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCdfView::AddRef (
    void
)
{
    ASSERT(m_cRef != 0);
    ASSERT(m_cRef < (ULONG)-1);

    return ++m_cRef;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::Release **
//
//    Cdf view Release.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCdfView::Release (
    void
)
{
    ASSERT (m_cRef != 0);

    ULONG cRef = --m_cRef;
    
    if (0 == cRef)
        delete this;

    return cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\chanapi.h ===
//
// API to install a channel by creating a system folder in the channel directory
//
// Julian Jiggins (julianj), 4th May, 1997
//

typedef enum _tagSUBSCRIPTIONACTION {
    SUBSACTION_SUBSCRIBEONLY,
    SUBSACTION_ADDADDITIONALCOMPONENTS
} SUBSCRIPTIONACTION;

//
// Flags used by SusbcribeToCDF
//

#define     STC_CHANNEL             0x00000001
#define     STC_DESKTOPCOMPONENT    0x00000002
#define     STC_ALL                 0xffffffff

#define     GUID_STR_LEN            80


EXTERN_C STDAPI_(void) OpenChannel
(
    HWND hwndParent,
    HINSTANCE hinst,
    LPSTR pszCmdLine,
    int nShow
);

EXTERN_C STDAPI_(void) Subscribe
(
    HWND hwndParent,
    HINSTANCE hinst,
    LPSTR pszCmdLine,
    int nShow
);

EXTERN_C STDAPI ParseDesktopComponent
(
    HWND hwndOwner,
    LPWSTR wszURL,                                             
    COMPONENT* pInfo
);

EXTERN_C STDAPI SubscribeToCDF
(
    HWND hwndOwner,
    LPWSTR wszURL,
    DWORD dwFlags
);

HRESULT AddChannel
(
    LPCTSTR pszName, 
    LPCTSTR pszURL, 
    LPCTSTR pszLogo, 
    LPCTSTR pszWideLogo, 
    LPCTSTR pszIcon,
    XMLDOCTYPE xdt
);

HRESULT DeleteChannel
(
    LPTSTR pszName
);

HRESULT OpenChannelHelper
(
    LPWSTR wszURL,
    HWND hwndOwner
);

HRESULT NavigateBrowser
(
    IWebBrowser2* pIWebBrowser2,
    LPWSTR wszURL,
    HWND hwnd
);

HRESULT NavigateChannelPane(
    IWebBrowser2* pIWebBrowser2,
    LPCWSTR pwszName
);

BOOL SubscriptionHelper
(
    IXMLDocument *pIXMLDocument,
    HWND hwnd,
    SUBSCRIPTIONTYPE st,
    SUBSCRIPTIONACTION sa,
    LPCWSTR pszwURL,
    XMLDOCTYPE xdt,
    BSTR* pbstrSubscribedURL
);

BOOL SubscribeToURL
(
    ISubscriptionMgr* pISubscriptionMgr,
    BSTR bstrURL,
    BSTR bstrName,
    SUBSCRIPTIONINFO* psi,
    HWND hwnd,
    SUBSCRIPTIONTYPE st,
    BOOL bIsSoftware
);

HRESULT AddDesktopComponent
(
    COMPONENT* pInfo
);

HRESULT ShowChannelPane
(
    IWebBrowser2* pIWebBrowser2
);

int Channel_CreateDirectory
(
    LPCTSTR pszPath
);

HRESULT Channel_GetBasePath(
    LPTSTR pszPath,
    int cch
);

HRESULT Channel_GetFolder
(
    LPTSTR pszPath,
    DWORD cchPath,
    XMLDOCTYPE xdt
);

BSTR Channel_GetFullPath
(
    LPCWSTR pwszName
);


DWORD CountChannels(void);

HRESULT Channel_CreateSpecialFolder(
    LPCTSTR pszPath,    // path to folder to create
    LPCTSTR pszURL,     // url for webview
    LPCTSTR pszLogo,    // [optional] path to logo
    LPCTSTR pszWideLogo,// [optional] path to wide logo
    LPCTSTR pszIcon,    // [optional] path to icon file
    int     nIconIndex  // index to icon in above file
    );

BOOL InitVARIANTFromPidl(VARIANT* pvar, LPCITEMIDLIST pidl);

HRESULT Channel_CreateILFromPath(LPCTSTR pszPath, LPITEMIDLIST* ppidl);

HRESULT Channel_CreateChannelFolder( XMLDOCTYPE xdt );

//HRESULT Channel_WriteNotificationPath(LPCTSTR pszURL, LPCTSTR pszPath);

HRESULT UpdateImage(LPCTSTR pszPath);

HRESULT PreUpdateChannelImage(
    LPCTSTR pszPath,
    LPTSTR pszHashItem,
    int* piIndex,
    UINT* puFlags,
    int* piImageIndex
);

void UpdateChannelImage(
    LPCWSTR pszHashItem,
    int iIndex,
    UINT uFlags,
    int iImageIndex
);

BOOL Channel_IsInstalled(
    LPCWSTR pszURL
);


LPOLESTR Channel_GetChannelPanePath(
    LPCWSTR pszURL
);

void Channel_SendUpdateNotifications(
    LPCWSTR pwszURL
);

// check the pre-load cache to see if the URL is a default installed one.
BOOL Channel_CheckURLMapping(
    LPCWSTR wszURL
);

HRESULT Channel_WriteScreenSaverURL(
    LPCWSTR pszURL,
    LPCWSTR pszScreenSaverURL
);

HRESULT Channel_RefreshScreenSaverURLs();

HRESULT Channel_GetAndWriteScreenSaverURL(
    LPCTSTR pszURL, 
    LPCTSTR pszDesktopINI
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\cdfidl.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// cdfidl.cpp 
//
//   Cdf id list helper functions.
//
//   History:
//
//       3/19/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "cdfidl.h"
#include "xmlutil.h"
#include "winineti.h" // for MAX_CACHE_ENTRY_INFO_SIZE

//
// Helper functions
//


LPTSTR CDFIDL_GetUserName()
{
    static BOOL gunCalled = FALSE;
    static TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH] = TEXT("");

    if (!gunCalled)
    {
        char  szUserNameA[INTERNET_MAX_USER_NAME_LENGTH];
        szUserNameA[0] = 0;
        DWORD size = INTERNET_MAX_USER_NAME_LENGTH;
        GetUserNameA(szUserNameA, &size);
        SHAnsiToTChar(szUserNameA, szUserName, ARRAYSIZE(szUserName));
        gunCalled = TRUE;
    }
    return szUserName;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_Create ***
//
//
// Description:
//     Creates a cdf id list.
//
// Parameters:
//     [In]  pCdfItem - A pointer to cdf item data.
//
// Return:
//     A new cdf id list on success.
//     NULL otherwise.
//
// Comments:
//     This function builds a variable length cdf item id list.  The item id
//     consists of a fixed length initial section followed by two or more null
//     terminated strings.  It has the following form:
//
//         USHORT  cb               - Size in bytes of this cdf item id.
//         WORD    wVersion;        - Version number of this item id structure.
//         DWORD   dwId;            - Used to identify cdf item ids. Set to
//                                    0x0ed1964ed  
//         CDFITEMTYPE cdfItemType  - CDF_Folder, CDF_FolderLink or CDF_Link.
//         LONG    nIndex           - The object model index for this item.
//         TCHAR   szName[1];       - Two or more null terminated strings
//                                    beggining with the name of this item.
//         USHORT  next.cb          - The size of the next item in the list.
//                                    Set to zero to terminate the list.
//
//     It is the callers responsability to free the item id list.  This should
//     be done using the IMalloc returned from SHGetMalloc();
//
////////////////////////////////////////////////////////////////////////////////
PCDFITEMIDLIST
CDFIDL_Create(
    PCDFITEM pCdfItem
)
{
#ifdef ALIGNMENT_MACHINE
    TCHAR *pszTempName;
#endif
    ASSERT(pCdfItem);
    ASSERT(pCdfItem->bstrName);
    ASSERT(pCdfItem->bstrURL);

    PCDFITEMIDLIST pcdfidl = NULL;

    //
    // Get the number of chars of the name of the item including the terminating
    // null character.
    //

    USHORT cchName = StrLenW(pCdfItem->bstrName) + 1;

    //
    // Get the number of chars of the URL of the item including the terminating
    // null character.
    //

    USHORT cchURL = StrLenW(pCdfItem->bstrURL) + 1;

    //
    // Calculate the total size of the cdf item id in bytes.  When calculating the size
    // of a cdf item id one TCHAR should be subtracted to account for the TCHAR
    // szName[1] included in the CDFITEMID struct definition.
    //

    USHORT cbItemId = sizeof(CDFITEMID) + (cchName + cchURL) * sizeof(TCHAR) - sizeof(TCHAR);

#ifdef ALIGNMENT_MACHINE
    cbItemId = ALIGN4(cbItemId);
#endif

    //
    // Item ids must allocated by the shell's IMalloc interface.
    //

    IMalloc* pIMalloc;

    HRESULT hr = SHGetMalloc(&pIMalloc);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIMalloc);

        //
        // An item id *list* must be NULL terminated so an additional USHORT is
        // allocated to hold the terminating NULL.
        //
        pcdfidl = (PCDFITEMIDLIST)pIMalloc->Alloc(cbItemId + sizeof(USHORT));

        if (pcdfidl)
        {
            //
            // NULL terminate the list.
            //

            *((UNALIGNED USHORT*) ( ((LPBYTE)pcdfidl) + cbItemId )) = 0;

#ifdef ALIGNMENT_MACHINE
            USHORT cbActaulItemId = sizeof(CDFITEMID) + (cchName + cchURL) * sizeof(TCHAR) - sizeof(TCHAR);
            if(cbActaulItemId < cbItemId)
                ZeroMemory((LPBYTE)pcdfidl + cbActaulItemId, cbItemId - cbActaulItemId);
#endif


            //
            // Fill in the data shared by all cdf item ids.
            //

            pcdfidl->mkid.cb       = cbItemId;
            pcdfidl->mkid.wVersion = CDFITEMID_VERSION;
            pcdfidl->mkid.dwId     = CDFITEMID_ID;

            //
            // Set the data that is specific to this cdf item id.
            //

            pcdfidl->mkid.cdfItemType = pCdfItem->cdfItemType;
            pcdfidl->mkid.nIndex      = pCdfItem->nIndex;

            //
            // REVIEW: Need WSTR to TSTR conversion.
            //

#ifndef ALIGNMENT_MACHINE
            SHUnicodeToTChar(pCdfItem->bstrName, pcdfidl->mkid.szName, cchName);
            SHUnicodeToTChar(pCdfItem->bstrURL, pcdfidl->mkid.szName + cchName,
                           cchURL);         
#else
        pszTempName = (LPTSTR)ALIGN4((ULONG_PTR)(pcdfidl->mkid.szName));
            SHUnicodeToTChar(pCdfItem->bstrName, pszTempName, cchName);
        pszTempName = (LPTSTR)((ULONG_PTR)(pcdfidl->mkid.szName+cchName));
            SHUnicodeToTChar(pCdfItem->bstrURL, pszTempName,
                           cchURL);
#endif

        }
        else
        {
            pcdfidl = NULL;
        }

        pIMalloc->Release();
    }

    ASSERT(CDFIDL_IsValid(pcdfidl) || NULL == pcdfidl);

    return pcdfidl;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_CreateFromXMLElement ***
//
//
// Description:
//     Creates a cdf item id list from a xml element.
//
// Parameters:
//     [In]  pIXMLElement - A pointer to the xml element.
//     [In]  nIndex       - The index value used to set the cdfidl index field.
//
// Return:
//     A poniter to a new cdf item id list if successful.
//     NULL otherwise.
//
// Comments:
//     The caller is responsible for freeing the returned id list.
//
////////////////////////////////////////////////////////////////////////////////
PCDFITEMIDLIST
CDFIDL_CreateFromXMLElement(
    IXMLElement* pIXMLElement,
    ULONG nIndex
)
{
    ASSERT(pIXMLElement);

    PCDFITEMIDLIST pcdfidl = NULL;

    CDFITEM cdfItem;

    if (cdfItem.bstrName = XML_GetAttribute(pIXMLElement, XML_TITLE))
    {
        if (cdfItem.bstrURL  = XML_GetAttribute(pIXMLElement, XML_HREF))
        {
            cdfItem.nIndex = nIndex;

            if (INDEX_CHANNEL_LINK == nIndex)
            {
                cdfItem.cdfItemType = CDF_FolderLink;
            }
            else
            {
                cdfItem.cdfItemType = XML_IsFolder(pIXMLElement) ? CDF_Folder :
                                                                   CDF_Link;
            }

            pcdfidl = CDFIDL_Create(&cdfItem);

            SysFreeString(cdfItem.bstrURL);
        }

        SysFreeString(cdfItem.bstrName);
    }

    ASSERT(CDFIDL_IsValid(pcdfidl) || NULL == pcdfidl);

    return pcdfidl;
}


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_CreateFolderPidl ***
//
//
// Description: creates a special folder pidl
//     
//
// Parameters:
//     [In]  pcdfidl - Pointer to the cdf id list to be created from
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
PCDFITEMIDLIST
CDFIDL_CreateFolderPidl(
    PCDFITEMIDLIST pcdfidl
)
{
    ASSERT(CDFIDL_IsValid(pcdfidl));

    PCDFITEMIDLIST pcdfidlRet = (PCDFITEMIDLIST)ILClone((LPITEMIDLIST)pcdfidl);

    if (pcdfidlRet)
    {
        ((PCDFITEMID)pcdfidlRet)->nIndex = INDEX_CHANNEL_LINK;
        ((PCDFITEMID)pcdfidlRet)->cdfItemType = CDF_FolderLink; //CDF_Link instead?
    }
    ASSERT(CDFIDL_IsValid(pcdfidlRet));
   
    return pcdfidlRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_Free ***
//
//
// Description:
//     Free the given cdf item id list.
//
// Parameters:
//     [In]  pcdfidl - Pointer to the cdf id list to be freed.
//
// Return:
//     No return value.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
void
CDFIDL_Free(
    PCDFITEMIDLIST pcdfidl
)
{
    ASSERT(CDFIDL_IsValid(pcdfidl));

    IMalloc *pIMalloc;

    if (SUCCEEDED(SHGetMalloc(&pIMalloc)))
    {
        ASSERT(pIMalloc);
        ASSERT(pIMalloc->DidAlloc(pcdfidl));
        
        pIMalloc->Free(pcdfidl);

        pIMalloc->Release();
    }
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_GetDisplayName ***
//
//
// Description:
//     Gets the name stored in the given cdf item id list.
//
// Parameters:
//     [In]  pcdfidl - A pointer to a cdf item id list.
//     [Out] pName - A pointer to a STRRET structure.  STRRET has the following
//                   structure:
//                       UINT uType             - STRRET_CSTR, _OFFSET or _WSTR
//                       union {
//                           LPWSTR pOleStr;
//                           UINT   uOffset;
//                           char   cStr[MAX_PATH];
//                       }
//
// Return:
//     S_OK on success.  E_Fail otherwise.
//
// Comments:
//     This function returns the name as an offset of the string from the start
//     of the cdf item id list.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CDFIDL_GetDisplayName(
    PCDFITEMIDLIST pcdfidl,
    LPSTRRET pName
)
{
    ASSERT(CDFIDL_IsValid(pcdfidl));
    ASSERT(pName);

    pName->uType = STRRET_CSTR;
    LPTSTR pszName = CDFIDL_GetName(pcdfidl);

    SHTCharToAnsi(pszName, pName->cStr, ARRAYSIZE(pName->cStr));

    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_GetName ***
//
//
// Description:
//     Gets a pointer to the URL stored in the given cdf item id list.
//
// Parameters:
//     [In]  pcdfidl - A pointer to a cdf item id list.
//
// Return:
//     A LPTSTR to the Name stored in the pidl.
//
// Comments:
//     This function returns a pointer to the Name in the cdf item id list.
//     The pointer is valid for the life of the item id list.  The caller is
//     resposible for maintaining the item id list and for not using the
//     the returned pointer after the id list is freed.
//
//     The name returned is the name of the last item in the list. 
//
////////////////////////////////////////////////////////////////////////////////
LPTSTR
CDFIDL_GetName(
    PCDFITEMIDLIST pcdfidl
)
{
    ASSERT(CDFIDL_IsValid(pcdfidl));

    pcdfidl = (PCDFITEMIDLIST)ILFindLastID((LPITEMIDLIST)pcdfidl);
    
    return CDFIDL_GetNameId(&pcdfidl->mkid);
}

LPTSTR
CDFIDL_GetNameId(
    PCDFITEMID pcdfid
)
{
    ASSERT(pcdfid);

#if defined(ALIGNMENT_MACHINE)
    return (LPTSTR)(ALIGN4((ULONG_PTR)pcdfid->szName));
#else
    return pcdfid->szName;
#endif

}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_GetURL ***
//
//
// Description:
//     Gets a pointer to the URL stored in the given cdf item id list.
//
// Parameters:
//     [In]  pcdfidl - A pointer to a cdf item id list.
//
// Return:
//     A LPTSTR to the URL value for the given pcdfidl.
//
// Comments:
//     This function returns a pointer to the URL in the cdf item id list.  The
//     pointer is valid for the life of the item id list.  The caller is
//     resposible for maintaining the item id list and for not using the
//     the returned pointer after the id list is freed. 
//
//     The URL returned is the URL of the last item in the list.
//
////////////////////////////////////////////////////////////////////////////////
LPTSTR
CDFIDL_GetURL(
    PCDFITEMIDLIST pcdfidl
)
{
    ASSERT(CDFIDL_IsValid(pcdfidl));

    //
    // Get the first string after the name.
    //

    LPTSTR szURL = CDFIDL_GetName(pcdfidl);

    while (*szURL++);

    return szURL;
}

LPTSTR
CDFIDL_GetURLId(
    PCDFITEMID pcdfid
)
{
    ASSERT(pcdfid);

    //
    // Get the first string after the name.
    //

    LPTSTR szURL = CDFIDL_GetNameId(pcdfid);

    while (*szURL++);

    return szURL;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_GetIndex ***
//
//
// Description:
//     Returns the index item of the given cdf id list.
//
// Parameters:
//     [In]  pcdfidl - Pointer to the cdf item id list.
//
// Return:
//     Returns the index item of the given id list.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
ULONG
CDFIDL_GetIndex(
    PCDFITEMIDLIST pcdfidl
)
{
    pcdfidl = (PCDFITEMIDLIST)ILFindLastID((LPITEMIDLIST)pcdfidl);

    return CDFIDL_GetIndexId(&pcdfidl->mkid);
}

ULONG
CDFIDL_GetIndexId(
    PCDFITEMID pcdfid
)
{
    return pcdfid->nIndex;
}

#define ASTR_HISTORY_PREFIX TEXT("Visited: ")

//
// Looks the URL up in the cache to see if the user has ever read this url
//
// REVIEW
// REVIEW - Should probably use IUrlStorage instead of constructing the 
// REVIEW
// history cache URL on the fly
//
BOOL
CDFIDL_IsUnreadURL(
    LPTSTR szUrl
)
{
    DWORD dwLen;
    
    //
    //  Canonicalize the input url.
    // 
    TCHAR szCanonicalizedUrl[INTERNET_MAX_URL_LENGTH];
    dwLen = INTERNET_MAX_URL_LENGTH;
    if (!InternetCanonicalizeUrl(szUrl, szCanonicalizedUrl, &dwLen, 0))
        StrCpyN(szCanonicalizedUrl, szUrl, ARRAYSIZE(szCanonicalizedUrl));
    
    //
    // Build a string that is the URL prefixed with VISITED: and the UserName
    //
    TCHAR szVisited[
        INTERNET_MAX_USER_NAME_LENGTH+
        1+
        INTERNET_MAX_URL_LENGTH+
        ARRAYSIZE(ASTR_HISTORY_PREFIX)];
 
    StrCpyN(szVisited, ASTR_HISTORY_PREFIX, ARRAYSIZE(szVisited));
    StrCatBuff(szVisited, CDFIDL_GetUserName(), ARRAYSIZE(szVisited));
    int len = StrLen(szVisited);
    StrCpyN(szVisited + len, TEXT("@"), ARRAYSIZE(szVisited) - len);
    len++;
    StrCpyN(szVisited + len, szCanonicalizedUrl, ARRAYSIZE(szVisited) - len);
    len++;

    // Check for trailing slash and eliminate, copied from shdocvw\urlhist.cpp
    LPTSTR pszT = CharPrev(szVisited, szVisited + lstrlen(szVisited));
    if (*pszT == TEXT('/'))
    {
        ASSERT(lstrlen(pszT) == 1);
        *pszT = 0;
    }

    //
    // If the VISITED: entry does not exist in the cache assume url is unread
    //
#ifndef ALIGNMENT_MACHINE
    BYTE visitedCEI[MAX_CACHE_ENTRY_INFO_SIZE];
    LPINTERNET_CACHE_ENTRY_INFO pVisitedCEI = (LPINTERNET_CACHE_ENTRY_INFO)visitedCEI;
#else
    union
    {
        double align8;
        BYTE visitedCEI[MAX_CACHE_ENTRY_INFO_SIZE];
    } alignedvisitedCEI;
    LPINTERNET_CACHE_ENTRY_INFO pVisitedCEI = (LPINTERNET_CACHE_ENTRY_INFO)&alignedvisitedCEI;
#endif /* ALIGNMENT_MACHINE */
    dwLen = MAX_CACHE_ENTRY_INFO_SIZE;

    if (GetUrlCacheEntryInfo(szVisited, pVisitedCEI, &dwLen) == FALSE)
    {
        return TRUE;
    }
    else
    {
        //
        // URL has been visited, but it still may be unread if the page has
        // been placed in the cache by the infodelivery mechanism
        //
#ifndef ALIGNMENT_MACHINE
        BYTE urlCEI[MAX_CACHE_ENTRY_INFO_SIZE];
        LPINTERNET_CACHE_ENTRY_INFO pUrlCEI = (LPINTERNET_CACHE_ENTRY_INFO)urlCEI;
#else
        union
        {
            double align8;
            BYTE urlCEI[MAX_CACHE_ENTRY_INFO_SIZE];
        } alignedurlCEI;
        LPINTERNET_CACHE_ENTRY_INFO pUrlCEI = (LPINTERNET_CACHE_ENTRY_INFO)&alignedurlCEI;
#endif /* ALIGNMENT_MACHINE */

        dwLen = MAX_CACHE_ENTRY_INFO_SIZE;

        if (GetUrlCacheEntryInfo(szCanonicalizedUrl, pUrlCEI, &dwLen) == FALSE)
        {
            return FALSE; // no url cache entry but url was visited so mark read
        }
        else
        {
            //
            // If the url has been modified after the time of the visited 
            // record then url is unread
            //
            if (CompareFileTime(&pUrlCEI->LastModifiedTime,
                                &pVisitedCEI->LastModifiedTime) > 0)
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }
    }
}

//
// Looks the URL up in the cache. TRUE if it is and FALSE otherwise
//
BOOL
CDFIDL_IsCachedURL(
    LPWSTR wszUrl
)
{

    BOOL  fCached;
    TCHAR szUrlT[INTERNET_MAX_URL_LENGTH];


    //
    //  Canonicalize the input url.
    // 
    
    if (SHUnicodeToTChar(wszUrl, szUrlT, ARRAYSIZE(szUrlT)))
    {
        URL_COMPONENTS uc;
 
        ZeroMemory(&uc, sizeof(uc));
        uc.dwStructSize = sizeof(URL_COMPONENTS);
        uc.dwSchemeLength = 1;
        if (InternetCrackUrl(szUrlT, 0, 0, &uc))
        {
            // zekel should look at this
            TCHAR *pchLoc = StrChr(szUrlT, TEXT('#'));
            if (pchLoc)
                *pchLoc = TEXT('\0');
        

            fCached = GetUrlCacheEntryInfoEx(szUrlT, NULL, NULL, NULL, NULL, NULL, 0);
            if(fCached)
            {
                return TRUE;
            }
            else
            {
                TCHAR szCanonicalizedUrlT[INTERNET_MAX_URL_LENGTH];
                DWORD dwLen = INTERNET_MAX_URL_LENGTH;
                InternetCanonicalizeUrl(szUrlT, szCanonicalizedUrlT, &dwLen, 0);

                fCached = GetUrlCacheEntryInfoEx(szCanonicalizedUrlT, NULL, NULL, NULL, NULL, NULL, 0);

                if(fCached)
                    return TRUE;
            }
        }
    }
    
    return FALSE;


}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_GetAttributes ***
//
//
// Description:
//     Returns the attributes item of the given cdf item id list.
//
// Parameters:
//     [In]  pIXMLElementCollectionparent - The containing element collection.
//     [In]  pcdfidl                      - A pointer to the cdf item id list.
//     [In]  fAttributesFilter            - Determines which flags to bother 
//                                          looking at
//
// Return:
//     The attributes of the given id list.
//     Zero on failure.  Note: Zero is a valid attribute value.
//
// Comments:
//     The attribute flags returned by this function can be used directly as a
//     return value by IShellFolder->GetAttributesOf().
//
////////////////////////////////////////////////////////////////////////////////
ULONG
CDFIDL_GetAttributes(
    IXMLElementCollection* pIXMLElementCollectionParent,
    PCDFITEMIDLIST pcdfidl,
    ULONG fAttributesFilter
)
{
    ASSERT(pIXMLElementCollectionParent);
    ASSERT(CDFIDL_IsValid(pcdfidl));
    ASSERT(ILIsEmpty(_ILNext((LPITEMIDLIST)pcdfidl)));

    //
    // REVIEW:  Need to properly determine shell attributes of cdf items.
    //

    ULONG uRet;

    if (CDFIDL_IsFolderId(&pcdfidl->mkid))
    {
        uRet = SFGAO_FOLDER | SFGAO_CANLINK;

        //  If we weren't asked for HASSUBFOLDER don't bother looking for it
        //  This should be a win in non tree views (ie. std open mode)
        if ((SFGAO_HASSUBFOLDER & fAttributesFilter) &&
            pIXMLElementCollectionParent && 
            XML_ChildContainsFolder(pIXMLElementCollectionParent,
                                    CDFIDL_GetIndex(pcdfidl)))
        {
            uRet |= SFGAO_HASSUBFOLDER;
        }
    }
    else
    {
        uRet = SFGAO_CANLINK;
        //  If we weren't asked for NEWCONTENT don't bother looking for it
        //  This will be a win in non channel pane views.
        //  Can't test for SFGAO_NEWCONTENT since shell is never
        //  expressing interest in it!
        if (/*(SFGAO_NEWCONTENT & fAttributeFilter) && */
            CDFIDL_IsUnreadURL(CDFIDL_GetURL(pcdfidl)))
        {
            uRet |= SFGAO_NEWCONTENT;
        }
    }

    return uRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_Compare ***
//
//
// Description:
//     Compares two cdf item id lists
//
// Parameters:
//     [In]  pcdfidl1 - A pointer to the first item id list to compare.
//     [In]  pcdfidl2 - A pointer to the second item id list to compare.
//
// Return:
//     -1 if item 1 comes before item 2.
//      0 if the items are equal.
//      1 if item 2 comes before item 1.
//
// Comments:
//      Sort Order:
//          1) Use the CompareId result of the first items in the lists.
//          2) If 1) returns 0.  Compare the next two items in the lists.
//          3) If both list are empty. They are equal.
//          4) The shorter id list comes first.
//
////////////////////////////////////////////////////////////////////////////////
SHORT
CDFIDL_Compare(
    PCDFITEMIDLIST pcdfidl1,
    PCDFITEMIDLIST pcdfidl2
)
{
    ASSERT(CDFIDL_IsValid(pcdfidl1));
    ASSERT(CDFIDL_IsValid(pcdfidl2));

    SHORT sRet;

    sRet = CDFIDL_CompareId(&pcdfidl1->mkid, &pcdfidl2->mkid);

    if (0 == sRet)
    {
        if (!ILIsEmpty(_ILNext(pcdfidl1)) && !ILIsEmpty(_ILNext(pcdfidl2)))
        {
            sRet = CDFIDL_Compare((PCDFITEMIDLIST)_ILNext(pcdfidl1), 
                                  (PCDFITEMIDLIST)_ILNext(pcdfidl2));
        }
        else if(!ILIsEmpty(_ILNext(pcdfidl1)) && ILIsEmpty(_ILNext(pcdfidl2)))
        {
            sRet = 1;
        }
        else if (ILIsEmpty(_ILNext(pcdfidl1)) && !ILIsEmpty(_ILNext(pcdfidl2)))
        {
            sRet = -1;
        }
    }

    return sRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_CompareId ***
//
//
// Description:
//     Compares two item cdf item ids.
//
// Parameters:
//     [In]  pcdfid1 - A pointer to the first item id to compare.
//     [In]  pcdfid2 - A pointer to the second item id to compare.
//
// Return:
//     -1 if item 1 comes before item 2.
//      0 if the items are the same.
//      1 if item 2 comes before item 1.
//
// Comments:
//     Sort Order:
//         1) CDF_FolderLink (Essentially an URL for the current folder). These
//            have an index of -1.
//         2) Everything else accoring to its order in the CDF.  These have
//            a zero-based index.
//         3) Non CDF items  (should't have any).
//
////////////////////////////////////////////////////////////////////////////////
SHORT
CDFIDL_CompareId(
    PCDFITEMID pcdfid1,
    PCDFITEMID pcdfid2
)
{
    ASSERT(CDFIDL_IsValidId(pcdfid1));
    ASSERT(CDFIDL_IsValidId(pcdfid2));

    SHORT sRet;

    if (pcdfid1->nIndex < pcdfid2->nIndex)
    {
        sRet = -1;
    }
    else if (pcdfid1->nIndex > pcdfid2->nIndex)
    {
        sRet = 1;
    }
    else
    {
        sRet =  (short) CompareString(LOCALE_USER_DEFAULT, 0, CDFIDL_GetNameId(pcdfid1),
                                      -1, CDFIDL_GetNameId(pcdfid2), -1);

        //
        // Note: CompareString returns 1 if S1 comes before S2, 2 if S1 is equal
        // to S2, 3 if S2 comes before S1 and 0 on error.
        //

        sRet = sRet ? sRet - 2 : 0;

        if (0 == sRet)
        {
            //
            // If the URLs aren't equal just pick one at random.
            //

            sRet = !StrEql(CDFIDL_GetURLId(pcdfid1), CDFIDL_GetURLId(pcdfid2));
            
            ASSERT((pcdfid1->cb == pcdfid2->cb) || 0 != sRet);
            ASSERT((pcdfid1->cdfItemType == pcdfid1->cdfItemType) || 0 != sRet);
        }
    }

    return sRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_IsValid ***
//
//
// Description:
//     Determines if the given pcdfidl is valid.
//
// Parameters:
//     pcdfid - A pointer to the cdf id to check.
//
// Return:
//     TRUE if the id is a cdf id.
//     FALSE otherwise.
//
// Comments:
//     An empty list is not valid.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CDFIDL_IsValid(
    PCDFITEMIDLIST pcdfidl
)
{
    BOOL bRet;

    if (pcdfidl && (pcdfidl->mkid.cb > 0))
    {
        bRet = TRUE;

        while (pcdfidl->mkid.cb && bRet)
        {
            bRet = CDFIDL_IsValidId(&pcdfidl->mkid);
            pcdfidl = (PCDFITEMIDLIST)_ILNext((LPITEMIDLIST)pcdfidl);
        }
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}


//
// Inline helper functions.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_IsValidId ***
//
//
// Description:
//     Inline function that returns TRUE if the given id is a pointer to a cdf
//     item id.
//
// Parameters:
//     pcdfid - A pointer to the cdf id to check.
//
// Return:
//     TRUE if the id is a cdf id.
//     FALSE otherwise.
//
// Comments:
//     This function is not completely safe.  If the first word pointed to 
//     is large but the memory block pointed to is smaller than a 8 bytes an
//     access violation will occur.  Also, if the first word is large enough and
//     the second DWORD is equal to CDFITEM_ID but the item isn't a cdf id a
//     false positive will occur.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CDFIDL_IsValidId(
    PCDFITEMID pcdfid
)
{
    ASSERT(pcdfid);

    return (pcdfid->cb >= (sizeof(CDFITEMID) +  sizeof(TCHAR)) && 
            pcdfid->dwId == CDFITEMID_ID                       &&
            CDFIDL_IsValidSize(pcdfid)                         &&
            CDFIDL_IsValidType(pcdfid)                         &&
            CDFIDL_IsValidIndex(pcdfid)                        &&
            CDFIDL_IsValidStrings(pcdfid)                         );
}

inline
BOOL
CDFIDL_IsValidSize(
    PCDFITEMID pcdfid
)
{
    int cbName = (StrLen(CDFIDL_GetNameId(pcdfid)) + 1) * 
                 sizeof(TCHAR);

    int cbURL  = (StrLen(CDFIDL_GetURLId(pcdfid)) + 1) *
                 sizeof(TCHAR);

#ifndef ALIGNMENT_MACHINE
    return (sizeof(CDFITEMID) - sizeof(TCHAR) + cbName + cbURL == pcdfid->cb);
#else
    return ((ALIGN4(sizeof(CDFITEMID) - sizeof(TCHAR) + cbName + cbURL)) == pcdfid->cb);
#endif
}

inline
BOOL
CDFIDL_IsValidType(
    PCDFITEMID pcdfid
)
{
    return ((CDF_Folder     == (CDFITEMTYPE)pcdfid->cdfItemType) ||
            (CDF_Link       == (CDFITEMTYPE)pcdfid->cdfItemType) ||
            (CDF_FolderLink == (CDFITEMTYPE)pcdfid->cdfItemType)   );
}

inline
BOOL
CDFIDL_IsValidIndex(
    PCDFITEMID pcdfid
)
{
    return (  pcdfid->nIndex >= 0
            || 
              (INDEX_CHANNEL_LINK == pcdfid->nIndex &&
              CDF_FolderLink == (CDFITEMTYPE)pcdfid->cdfItemType));
}

inline
BOOL
CDFIDL_IsValidStrings(
    PCDFITEMID pcdfid
)
{
    //
    // REVIEW: Validate pidl strings.
    //

    return TRUE;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_IsFolder ***
//
//
// Description:
//     Inline function that returns TRUE if the given cdfidl is a folder as far
//     as the shel is concerned.
//
// Parameters:
//     pcdfidl - The cdf item id list to check.
//
// Return:
//     TRUE if the cdf item id list is a folder.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CDFIDL_IsFolder(
    PCDFITEMIDLIST pcdfidl
)
{
    ASSERT(CDFIDL_IsValid(pcdfidl));

    pcdfidl = (PCDFITEMIDLIST)ILFindLastID((LPITEMIDLIST)pcdfidl);

    return CDFIDL_IsFolderId(&pcdfidl->mkid);
}

BOOL
CDFIDL_IsFolderId(
    PCDFITEMID pcdfid
)
{
    ASSERT(CDFIDL_IsValidId(pcdfid));

    return (CDF_Folder == (CDFITEMTYPE)pcdfid->cdfItemType);
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CDFIDL_NonCdfGetName ***
//
//
// Description:
//     Gets the name stored in the given non-cdf item id list.
//
// Parameters:
//     [In]  pcdfidl - A pointer to a cdf item id list.  Can be NULL.
//     [Out] pName - A pointer to a STRRET structure.  STRRET has the following
//                   structure:
//                       UINT uType             - STRRET_CSTR, _OFFSET or _WSTR
//                       union {
//                           LPWSTR pOleStr;
//                           UINT   uOffset;
//                           char   cStr[MAX_PATH];
//                       }
//
// Return:
//     S_OK on success.  E_Fail otherwise.
//
// Comments:
//     This function returns the name as a cString in the STRRET structure.
//
//     ILGetDisplayName returns the full path.  This function strips out the
//     filename sans extension.
//
////////////////////////////////////////////////////////////////////////////////
#if 0
HRESULT
CDFIDL_NonCdfGetDisplayName(
    LPCITEMIDLIST pidl,
    LPSTRRET pName
)
{
    ASSERT(pName);

    HRESULT hr;

    //
    // REVIEW:  Hack to get the name of a shell pidl.
    //

    if (ILGetDisplayName(pidl, pName->cStr))
    {
        TCHAR* p1 = pName->cStr;
        TCHAR* p2 = p1;

        while (*p1++);                          // Go to the end. 
        while (*--p1 != TEXT('\\'));            // Back to last backslash.
        while (TEXT('.') != (*p2++ = *++p1));   // Copy the name.
        *--p2 = TEXT('\0');                     // NULL terminate.

        pName->uType = STRRET_CSTR;

        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\chanapi.cpp ===
// API to install a channel by creating a system folder in the channel directory
//
// Julian Jiggins (julianj), 4th May, 1997
//

#include "stdinc.h"
#include "resource.h"
#include "cdfidl.h"
#include "xmlutil.h"
#include "persist.h"
#include "cdfview.h"
#include "chanapi.h"
#include "chanmgrp.h"
#include "chanmgri.h"
#include "chanenum.h"
#include "dll.h"
#include "shguidp.h"
#include "winineti.h"
#define _SHDOCVW_
#include <shdocvw.h>

#include <mluisupp.h>

#ifdef UNIX
#undef EVAL
#define EVAL(x) x

STDAPI SHAddSubscribeFavorite(HWND hwnd, LPCWSTR pwszURL, LPCWSTR pwszName, DWORD dwFlags, SUBSCRIPTIONTYPE subsType, SUBSCRIPTIONINFO* pInfo);
#endif /* UNIX */

#define SHELLFOLDERS \
   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")

// Wininet cache preload registry key in HKCU
const TCHAR c_szRegKeyCachePreload[]    = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Preload");

BOOL  PathCombineCleanPath(LPTSTR pszCleanPath, LPCTSTR pszPath);
void Channel_OrderItem(LPCTSTR szPath);

// This was copied from shdocvw\favorite.cpp
static const int CREATESUBS_ACTIVATE = 0x8000;      //hidden flag meaning channel is already on system

//
// Debugging code
//
#if 0
void DumpOrderList(HDPA hdpa)
{
    int i = 0;
    PORDERITEM poi = (PORDERITEM)DPA_GetPtr(hdpa, i);
    while (poi)
    {
        TCHAR szName[MAX_PATH];
        wnsprintf(szName, ARRAYSIZE(szName), "nOrder=%d, lParam=%d, pidl=", poi->nOrder, poi->lParam);
        OutputDebugString(szName);
        ASSERT(SHGetPathFromIDListA(poi->pidl, szName));
        OutputDebugString(szName);
        OutputDebugString("\n");
        i++;
        poi = (PORDERITEM)DPA_GetPtr(hdpa, i);
    }
}
void DumpPidl(LPITEMIDLIST pidl)
{
    TCHAR szName[MAX_PATH];
    ASSERT(SHGetPathFromIDListA(pidl, szName));
    OutputDebugString(szName);
    OutputDebugString("\n");
}
#endif

//
// Constructor and destructor.
//

////////////////////////////////////////////////////////////////////////////////
//
// *** CChannelMgr::CChannelMgr ***
//
//    Constructor.
//
////////////////////////////////////////////////////////////////////////////////
CChannelMgr::CChannelMgr (
    void
)
: m_cRef(1)
{
    TraceMsg(TF_OBJECTS, "+ IChannelMgr");

    DllAddRef();

    return;
}

////////////////////////////////////////////////////////////////////////////////
//
// *** CChannelMgr::~CChannelMgr ***
//
//    Destructor.
//
////////////////////////////////////////////////////////////////////////////////
CChannelMgr::~CChannelMgr (
    void
)
{
    ASSERT(0 == m_cRef);

    //
    // Matching Release for the constructor Addref.
    //

    TraceMsg(TF_OBJECTS, "- IChannelMgr");

    DllRelease();

    return;
}


//
// IUnknown methods.
//

////////////////////////////////////////////////////////////////////////////////
//
// *** CChannelMgr::QueryInterface ***
//
//    CChannelMgr QI.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CChannelMgr::QueryInterface (
    REFIID riid,
    void **ppv
)
{
    ASSERT(ppv);

    HRESULT hr;

    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IChannelMgr == riid)
    {
        *ppv = (IChannelMgr*)this;
    }
    else if ((IID_IChannelMgrPriv2 == riid) || (IID_IChannelMgrPriv == riid))
    {
        *ppv = (IChannelMgrPriv2*)this;
    }
    else if (IID_IShellCopyHook == riid)
    {  
        *ppv = (ICopyHook*)this;
    }
#ifdef UNICODE
    else if (IID_IShellCopyHookA == riid)
    {  
        *ppv = (ICopyHookA*)this;
    }
#endif
    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && NULL == *ppv));

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// *** CChannelMgr::AddRef ***
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CChannelMgr::AddRef (
    void
)
{
    ASSERT(m_cRef != 0);
    ASSERT(m_cRef < (ULONG)-1);

    return ++m_cRef;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelMgr::Release ***
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CChannelMgr::Release (
    void
)
{
    ASSERT (m_cRef != 0);

    ULONG cRef = --m_cRef;
    
    if (0 == cRef)
        delete this;

    return cRef;
}

////////////////////////////////////////////////////////////////////////////////
//
// IChannelMgr member(s)
//
////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CChannelMgr::AddCategory(CHANNELCATEGORYINFO *pCategoryInfo)
{
    ASSERT(pCategoryInfo);
    if (!pCategoryInfo || pCategoryInfo->cbSize < sizeof(CHANNELCATEGORYINFO))
    {
        return E_INVALIDARG;
    }
        
    //
    // Convert all the wide str params to tstrs
    //
    LPWSTR pwszURL   = pCategoryInfo->pszURL;
    LPWSTR pwszTitle = pCategoryInfo->pszTitle;
    LPWSTR pwszLogo  = pCategoryInfo->pszLogo;
    LPWSTR pwszIcon  = pCategoryInfo->pszIcon;
    LPWSTR pwszWideLogo  = pCategoryInfo->pszWideLogo;

    //
    // REVIEW:is this too much to alloc on the stack?
    // 
    TCHAR szURL[INTERNET_MAX_URL_LENGTH];
    TCHAR szTitle[MAX_PATH];
    TCHAR szLogo[INTERNET_MAX_URL_LENGTH];
    TCHAR szIcon[INTERNET_MAX_URL_LENGTH];
    TCHAR szWideLogo[INTERNET_MAX_URL_LENGTH];

    LPTSTR pszURL   = NULL;
    LPTSTR pszTitle = NULL;
    LPTSTR pszLogo  = NULL;
    LPTSTR pszIcon  = NULL;
    LPTSTR pszWideLogo  = NULL;

    if (pwszTitle)
    {
        SHUnicodeToTChar(pwszTitle, szTitle, ARRAYSIZE(szTitle));
        pszTitle = szTitle;
    }
    else
    {
        return E_INVALIDARG; // required option
    }

    if (pwszURL)
    {
        SHUnicodeToTChar(pwszURL, szURL, ARRAYSIZE(szURL));
        pszURL = szURL;
    }

    if (pwszLogo)
    {
        SHUnicodeToTChar(pwszLogo, szLogo, ARRAYSIZE(szLogo));
        pszLogo = szLogo;
    }

    if (pwszIcon)
    {
        SHUnicodeToTChar(pwszIcon, szIcon, ARRAYSIZE(szIcon));
        pszIcon = szIcon;
    }

    if (pwszWideLogo)
    {
        SHUnicodeToTChar(pwszWideLogo, szWideLogo, ARRAYSIZE(szWideLogo));
        pszWideLogo = szWideLogo;
    }

    //
    // Find the Channel directory
    // Attempt to create folder if one doesn't exist
    //
    TCHAR szPath[MAX_PATH];
    if (FAILED(Channel_GetFolder(szPath, ARRAYSIZE(szPath), DOC_CHANNEL)))
    {
        return E_FAIL;  // couldn't find Channel Folder or create empty one
    }

    // Convert the title into a path component
    TCHAR szFileTitle[MAX_PATH];
    szFileTitle[0] = TEXT('\0');
    PathCombineCleanPath(szFileTitle, pszTitle);

    TraceMsg(TF_GENERAL, "AddCategory(): pszTitle = %s, szFileTitle = %s", pszTitle, szFileTitle);

    //
    // add title to channel folder path
    //
    if (PathCombine(szPath, szPath, szFileTitle))
    {

        //
        // Create the logoized, iconized, webviewed special folder
        // public ChanMgr api doesn't handle iconIndex yet. Should fix!
        //

        //
        // REARCHITECT: this is not clean or elegant
        // we only work if the incoming URL is infact a UNC
        // and we copy the file to the Category Folder
        //
        if (pszURL)
        {
            TCHAR szTargetPath[MAX_PATH];
            LPTSTR pszFilename = PathFindFileName(pszURL);

            //
            // Create folder, webview htm is just filename no path.
            //
            Channel_CreateSpecialFolder(szPath, pszFilename, pszLogo, pszWideLogo, pszIcon, 0);

            //
            // Now build target fully qualified path to use to copy html file
            //
            if (PathCombine(szTargetPath, szPath, pszFilename))
            {
                //
                // Copy html into category folder and mark it hidden
                if (!CopyFile(pszURL, szTargetPath, FALSE))
                {
                    // If the copy fails, try again after clearing the attributes.
                    SetFileAttributes(szTargetPath, FILE_ATTRIBUTE_NORMAL);
                    CopyFile(pszURL, szTargetPath, FALSE);
                }
                SetFileAttributes(szTargetPath, FILE_ATTRIBUTE_HIDDEN);
            }
        }
        else
            Channel_CreateSpecialFolder(szPath, NULL, pszLogo, pszWideLogo, pszIcon, 0);

        //
        // Place the channel category in the appropriate "order".
        //
        Channel_OrderItem(szPath);

        //
        // Notify the system that a new item has been added.
        //
        SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, (void*)szPath, NULL);
    }

    return S_OK;
}

//
// DeleteCategory 
//
STDMETHODIMP CChannelMgr::DeleteCategory(LPWSTR pwzTitle)
{  
    TCHAR szTitle[INTERNET_MAX_URL_LENGTH];

    SHUnicodeToTChar(pwzTitle, szTitle, INTERNET_MAX_URL_LENGTH);

    //
    // REVIEW: deletegate to just deleting the channel ok???
    //
    return ::DeleteChannel(szTitle);
}

STDMETHODIMP CChannelMgr::AddChannelShortcut(CHANNELSHORTCUTINFO *pChannelInfo)
{
    if (!pChannelInfo || 
        pChannelInfo->cbSize < sizeof(CHANNELSHORTCUTINFO) ||
        pChannelInfo->pszURL == NULL ||
        pChannelInfo->pszTitle == NULL)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    TCHAR szURL[INTERNET_MAX_URL_LENGTH];
    TCHAR szTitle[INTERNET_MAX_URL_LENGTH];
    TCHAR szLogo[INTERNET_MAX_URL_LENGTH];
    TCHAR szIcon[INTERNET_MAX_URL_LENGTH];
    TCHAR szWideLogo[INTERNET_MAX_URL_LENGTH];

    LPTSTR pszLogo = NULL;
    LPTSTR pszIcon = NULL;
    LPTSTR pszWideLogo = NULL;

    //
    // Convert BSTRs to TSTRs
    //
    SHUnicodeToTChar(pChannelInfo->pszURL,   szURL,   ARRAYSIZE(szURL));
    SHUnicodeToTChar(pChannelInfo->pszTitle, szTitle, ARRAYSIZE(szTitle));

    //
    // Now handle optional arguments
    //
    if (pChannelInfo->pszLogo != NULL)
    {
        SHUnicodeToTChar(pChannelInfo->pszLogo, szLogo, ARRAYSIZE(szLogo));
        pszLogo = szLogo;
    }

    if (pChannelInfo->pszWideLogo != NULL)
    {
        SHUnicodeToTChar(pChannelInfo->pszWideLogo, szWideLogo, ARRAYSIZE(szWideLogo));
        pszWideLogo = szWideLogo;
    }

    if (pChannelInfo->pszIcon != NULL)
    {   
        SHUnicodeToTChar(pChannelInfo->pszIcon, szIcon, ARRAYSIZE(szIcon));
        pszIcon = szIcon;
    }

    return ::AddChannel(szTitle, szURL, pszLogo, pszWideLogo, pszIcon,
        pChannelInfo->bIsSoftware ? DOC_SOFTWAREUPDATE : DOC_CHANNEL);
}

STDMETHODIMP CChannelMgr::DeleteChannelShortcut(LPWSTR pwzTitle)
{
    TCHAR szTitle[INTERNET_MAX_URL_LENGTH];

    SHUnicodeToTChar(pwzTitle, szTitle, ARRAYSIZE(szTitle));

    return ::DeleteChannel(szTitle);
}


STDMETHODIMP CChannelMgr::EnumChannels(DWORD dwEnumFlags, LPCWSTR pszURL,
                                       IEnumChannels** ppIEnumChannels)
{
    *ppIEnumChannels = (IEnumChannels*) new CChannelEnum(dwEnumFlags, pszURL);

    return *ppIEnumChannels ? S_OK : E_OUTOFMEMORY;
}


//
// IChannelMgrPriv
//

STDMETHODIMP CChannelMgr::GetBaseChannelPath(LPSTR pszPath, int cch)
{
    ASSERT(pszPath || 0 == cch);
    HRESULT	hr;

#ifdef UNICODE
    TCHAR	tszPath[MAX_PATH];

    hr = Channel_GetBasePath(tszPath, ARRAYSIZE(tszPath));
    SHTCharToAnsi(tszPath, pszPath, cch);

#else
    hr = Channel_GetBasePath(pszPath, cch);
#endif
    return hr;
}

STDMETHODIMP CChannelMgr::GetChannelFolderPath (LPSTR pszPath, int cch,
                                                CHANNELFOLDERLOCATION cflChannel)
{
    ASSERT (pszPath || 0 == cch);

    XMLDOCTYPE xdt;
    switch (cflChannel)
    {
    case CF_CHANNEL:
        xdt = DOC_CHANNEL;
        break;
    case CF_SOFTWAREUPDATE:
        xdt = DOC_SOFTWAREUPDATE;
        break;
    default:
        return E_INVALIDARG;
    }

    TCHAR   tszPath[MAX_PATH];
    HRESULT hr = Channel_GetFolder(tszPath, ARRAYSIZE(tszPath), xdt);
    if (FAILED(hr) || ( SUCCEEDED(hr) && cch <= StrLen(tszPath)) )
        return E_FAIL;

    SHTCharToAnsi(tszPath, pszPath, cch);

    return S_OK;
}

STDMETHODIMP CChannelMgr::GetChannelFolder (LPITEMIDLIST* ppidl,
                                            CHANNELFOLDERLOCATION cflChannel)
{
    if (ppidl == NULL)
        return E_FAIL;

    char szPath[MAX_PATH];
    HRESULT hr = GetChannelFolderPath (szPath, ARRAYSIZE(szPath), cflChannel);
    if (FAILED (hr))
        return hr;

#ifdef UNICODE
    TCHAR   tszPath[MAX_PATH];

    SHAnsiToTChar(szPath, tszPath, ARRAYSIZE(tszPath));

    return Channel_CreateILFromPath (tszPath, ppidl);
#else
    return Channel_CreateILFromPath (szPath, ppidl);
#endif
}

STDMETHODIMP CChannelMgr::InvalidateCdfCache(void)
{
    InterlockedIncrement((LONG*)&g_dwCacheCount);
    return S_OK;
}

STDMETHODIMP CChannelMgr::PreUpdateChannelImage(
    LPCSTR pszPath,
    LPSTR pszHashItem,
    int* piIndex,
    UINT* puFlags,
    int* piImageIndex
)
{
#ifdef UNICODE
    TCHAR   tszPath[MAX_PATH];
    TCHAR   tszHashItem[MAX_PATH];

    SHAnsiToTChar(pszPath, tszPath, ARRAYSIZE(tszPath));
    SHAnsiToTChar(pszHashItem, tszHashItem, ARRAYSIZE(tszHashItem));
    return ::PreUpdateChannelImage(tszPath, tszHashItem, piIndex, puFlags,
                                   piImageIndex);
#else
    return ::PreUpdateChannelImage(pszPath, pszHashItem, piIndex, puFlags,
                                   piImageIndex);
#endif
}

STDMETHODIMP CChannelMgr::UpdateChannelImage(
    LPCWSTR pszHashItem,
    int iIndex,
    UINT uFlags,
    int iImageIndex
)
{
    ::UpdateChannelImage(pszHashItem, iIndex, uFlags, iImageIndex);

    return S_OK;
}

STDMETHODIMP CChannelMgr::ShowChannel(
    IWebBrowser2 *pIWebBrowser2,
    LPWSTR pwszURL, 
    HWND hwnd
)
{
    HRESULT hr;
    
    if (!pwszURL || !pIWebBrowser2)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = ::NavigateBrowser(pIWebBrowser2, pwszURL, hwnd);
    }

    return hr;
}

STDMETHODIMP CChannelMgr::IsChannelInstalled(LPCWSTR pwszURL)
{
    return ::Channel_IsInstalled(pwszURL) ? S_OK : S_FALSE;
}

STDMETHODIMP CChannelMgr::AddAndSubscribe(HWND hwnd, LPCWSTR pwszURL, 
                                          ISubscriptionMgr *pSubscriptionMgr)
{
    return AddAndSubscribeEx2(hwnd, pwszURL, pSubscriptionMgr, FALSE);
}

STDMETHODIMP CChannelMgr::AddAndSubscribeEx2(HWND hwnd, LPCWSTR pwszURL, 
                                             ISubscriptionMgr *pSubscriptionMgr, 
                                             BOOL bAlwaysSubscribe)
{
    HRESULT hr;
    
    BSTR bstrPreinstalled = NULL;
    HRESULT hrPreinstalled = IsChannelPreinstalled(pwszURL, &bstrPreinstalled);

    if (hrPreinstalled == S_OK)
    {
        RemovePreinstalledMapping(pwszURL);
    }

    WCHAR wszTitle[MAX_PATH];
    TASK_TRIGGER     tt = {0};
    SUBSCRIPTIONINFO si = {0};
    BOOL fIsSoftware = FALSE;

    si.cbSize       = sizeof(SUBSCRIPTIONINFO);
    si.fUpdateFlags |= SUBSINFO_SCHEDULE;
    si.schedule     = SUBSSCHED_AUTO;
    si.pTrigger     = (LPVOID)&tt;

    hr = DownloadMinCDF(hwnd, pwszURL, wszTitle, ARRAYSIZE(wszTitle), &si, &fIsSoftware);
            
    if (hr == S_OK)
    {

        DWORD dwFlags = 0;
        BOOL bInstalled = Channel_IsInstalled(pwszURL);

        if (bInstalled)
        {
            dwFlags |= CREATESUBS_ACTIVATE | CREATESUBS_FROMFAVORITES;
        }
        else
        {
            dwFlags |= CREATESUBS_ADDTOFAVORITES;
        }

        if (bAlwaysSubscribe || !bInstalled || (hrPreinstalled == S_OK))
        {

            if (!pSubscriptionMgr)
            {
                hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                                      CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr,
                                      (void**)&pSubscriptionMgr);
            }
            else
            {
                pSubscriptionMgr->AddRef();
            }

            if (SUCCEEDED(hr))
            {
                hr = pSubscriptionMgr->CreateSubscription(hwnd, 
                                                          pwszURL, 
                                                          wszTitle,
                                                          dwFlags, 
                                                          SUBSTYPE_CHANNEL, 
                                                          &si);

                //  This will kill the one we may have CoCreated
                pSubscriptionMgr->Release();
            }
        }
    }

    if (hr != S_OK && hrPreinstalled == S_OK && bstrPreinstalled != NULL)
    {
        SetupPreinstalledMapping(pwszURL, bstrPreinstalled);
    }

    SysFreeString(bstrPreinstalled);

    return hr;
}

STDMETHODIMP CChannelMgr::WriteScreenSaverURL(LPCWSTR pwszURL, LPCWSTR pwszScreenSaverURL)
{
    return Channel_WriteScreenSaverURL(pwszURL, pwszScreenSaverURL);
}

STDMETHODIMP CChannelMgr::RefreshScreenSaverURLs()
{
    return Channel_RefreshScreenSaverURLs();
}

STDMETHODIMP CChannelMgr::DownloadMinCDF(HWND hwnd, LPCWSTR pwszURL, 
                                         LPWSTR pwszTitle, DWORD cchTitle, 
                                         SUBSCRIPTIONINFO *pSubInfo, 
                                         BOOL *pfIsSoftware)
{
    HRESULT hr;
    IXMLDocument* pIXMLDocument;
    IXMLElement* pIXMLElement;

    ASSERT(pSubInfo);
    ASSERT(pfIsSoftware);

    *pwszTitle = NULL;

    DLL_ForcePreloadDlls(PRELOAD_MSXML);
    
    hr = CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC_SERVER,
                          IID_IXMLDocument, (void**)&pIXMLDocument);

    if (SUCCEEDED(hr))
    {
        BOOL fStartedOffLine = IsGlobalOffline();
        BOOL fInformUserOfDownloadProblem = FALSE;

        SetGlobalOffline(FALSE);
        if (InternetAutodial(INTERNET_AUTODIAL_FORCE_ONLINE, 0))
        {
            if (!DownloadCdfUI(hwnd, pwszURL, pIXMLDocument))
            {
                hr = E_FAIL;
                fInformUserOfDownloadProblem = TRUE;
            }
            else
            {
                Channel_SendUpdateNotifications(pwszURL);

                LONG lDontCare;
                hr = XML_GetFirstChannelElement(pIXMLDocument, &pIXMLElement, &lDontCare);
                if (SUCCEEDED(hr))
                {
                    *pfIsSoftware = XML_GetDocType(pIXMLDocument) == DOC_SOFTWAREUPDATE;
                    XML_GetSubscriptionInfo(pIXMLElement, pSubInfo);

                    BSTR bstrTitle = XML_GetAttribute(pIXMLElement, XML_TITLE);
                    if (bstrTitle)
                    {
                        if (bstrTitle[0])
                        {
                            StrCpyNW(pwszTitle, bstrTitle, cchTitle);
                        }
                        else
                        {
                            if (StrCpyNW(pwszTitle, PathFindFileNameW(pwszURL), cchTitle))
                            {
                                PathRemoveExtensionW(pwszTitle);
                            }
                            else
                            {
                                hr = S_FALSE;
                            }
                        }
                        SysFreeString(bstrTitle);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    pIXMLElement->Release();
                }
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            fInformUserOfDownloadProblem = TRUE;
        }

        pIXMLDocument->Release();

        if (fStartedOffLine)
        {
            SetGlobalOffline(TRUE);
        }

        if (fInformUserOfDownloadProblem)
        {
            ASSERT(FAILED(hr));

            CDFMessageBox(hwnd, IDS_INFO_MUST_CONNECT, IDS_INFO_DLG_TITLE,
                            MB_OK | MB_ICONINFORMATION);

            //  Set return val to S_FALSE so the caller can distinguish between
            //  errors which we've informed the user of and hard failures 
            //  such as out of memory, etc.

            hr = S_FALSE;
        }
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// *** Channel_RemoveURLMapping ***
//
// Description:
//     Removes the cache and registry settings that wininet uses to map the
//     given url to a local file.
//
////////////////////////////////////////////////////////////////////////////////

#define PRELOAD_REG_KEY \
    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Preload")

void Channel_RemoveURLMapping(LPCTSTR pszURL)
{
    DWORD cbcei = MAX_CACHE_ENTRY_INFO_SIZE;
    BYTE cei[MAX_CACHE_ENTRY_INFO_SIZE];
    LPINTERNET_CACHE_ENTRY_INFO pcei = (LPINTERNET_CACHE_ENTRY_INFO)cei;

    //
    // Look up the url in the cache
    //
    if (GetUrlCacheEntryInfoEx(pszURL, pcei, &cbcei, NULL, 0, NULL, 0))
    {
        //
        // see if it has a mapping because it is a preinstalled cache entry
        //
        if (pcei->CacheEntryType & INSTALLED_CACHE_ENTRY)
        {
            //
            // Clear the flag
            //
            pcei->CacheEntryType &= ~INSTALLED_CACHE_ENTRY;
            SetUrlCacheEntryInfo(pszURL, pcei, CACHE_ENTRY_ATTRIBUTE_FC);

            //
            // Now remove the mapping from the registry
            //
            HKEY hk;
            if (RegOpenKeyEx(HKEY_CURRENT_USER, PRELOAD_REG_KEY, 0, KEY_WRITE,
                             &hk) == ERROR_SUCCESS)
            {
                RegDeleteValue(hk, pszURL);
                RegCloseKey(hk);
            }
        }
    }
}
#ifndef UNICODE
//
// widechar version of above routine
//
void Channel_RemoveURLMapping(LPCWSTR wszURL)
{
    CHAR szURL[INTERNET_MAX_URL_LENGTH];

    if (SHUnicodeToTChar(wszURL, szURL, ARRAYSIZE(szURL)))
    {
        Channel_RemoveURLMapping(szURL);
    }
}
#endif

// cheap lookup function to see if we are dealing with a preinstalled URL
BOOL Channel_CheckURLMapping( LPCWSTR wszURL )
{
    TCHAR szURL[INTERNET_MAX_URL_LENGTH];
    if (SHUnicodeToTChar(wszURL, szURL, ARRAYSIZE(szURL)))
    {
        // check to see if the value exists for the URL....
        TCHAR szPath[MAX_PATH];
        DWORD cbSize = sizeof(szPath);
        
        LONG lRes = SHRegGetValue( HKEY_CURRENT_USER, PRELOAD_REG_KEY, szURL, SRRF_RT_REG_SZ, NULL, (LPBYTE) szPath, &cbSize );
        
        return (lRes == ERROR_SUCCESS ); 
    }
    return FALSE;
}


////////////////////////////////////////////////////////////////////////////////
//
// *** CChannelMgr::IsChannelPreinstalled ***
//
// Description:
//     Returns S_OK if the channel url has a preinstalled cache entry
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CChannelMgr::IsChannelPreinstalled(LPCWSTR pwszURL, BSTR * bstrFile)
{
    HRESULT hr = S_FALSE;

    TCHAR szURL[INTERNET_MAX_URL_LENGTH];
    if (SHUnicodeToTChar(pwszURL, szURL, ARRAYSIZE(szURL)))
    {
        DWORD cbcei = MAX_CACHE_ENTRY_INFO_SIZE;
        BYTE cei[MAX_CACHE_ENTRY_INFO_SIZE];
        LPINTERNET_CACHE_ENTRY_INFO pcei = (LPINTERNET_CACHE_ENTRY_INFO)cei;

        //
        // Look up the url in the cache
        //
        if (GetUrlCacheEntryInfoEx(szURL, pcei, &cbcei, NULL, 0, NULL, 0))
        {
            //
            // see if it has a mapping because it is a preinstalled cache entry
            //
            if (pcei->CacheEntryType & INSTALLED_CACHE_ENTRY)
            {
                //
                // Get a BSTR from the internet cache entry local file name
                //
                if (bstrFile)
                {
                    WCHAR wszFile[MAX_PATH];
                    SHTCharToUnicode(pcei->lpszLocalFileName, wszFile, ARRAYSIZE(wszFile));
                    *bstrFile = SysAllocString(wszFile);
                }

                hr = S_OK;
            }
        }
    }

    return hr;
}

STDMETHODIMP CChannelMgr::RemovePreinstalledMapping(LPCWSTR pwszURL)
{
    Channel_RemoveURLMapping(pwszURL);
    return S_OK;
}

STDMETHODIMP CChannelMgr::SetupPreinstalledMapping(LPCWSTR pwszURL, LPCWSTR pwszFile)
{
    FILETIME ftZero = {0};
    CommitUrlCacheEntryW(pwszURL, pwszFile, ftZero, ftZero, INSTALLED_CACHE_ENTRY, NULL, 0, NULL, 0);

    //
    // Make sure that there isn't an in memory cached old version of this URL
    //
#ifdef UNICODE
    Cache_RemoveItem(pwszURL);
#else
    char szURL[INTERNET_MAX_URL_LENGTH];
    SHUnicodeToAnsi(pwszURL, szURL, ARRAYSIZE(szURL));
    Cache_RemoveItem(szURL);
#endif
    return S_OK;
}

//
// Create the special folder that can have a webview associated with it, and an
// icon and a logo view.
//
HRESULT Channel_CreateSpecialFolder(
    LPCTSTR pszPath,    // path to folder to create
    LPCTSTR pszURL,     // url for webview
    LPCTSTR pszLogo,    // [optional] path to logo
    LPCTSTR pszWideLogo,    // [optional] path to wide logo
    LPCTSTR pszIcon,    // [optional] path to icon file
    int     nIconIndex  // index to icon in above file
    )
{
    //
    // First create the directory if it doesn't exist
    //
    if (!PathFileExists(pszPath))
    {
        if (Channel_CreateDirectory(pszPath) != 0)
        {
            return E_FAIL;
        }
    }

    //
    // Mark it as a SYSTEM folder
    //
    if (!SetFileAttributes(pszPath, FILE_ATTRIBUTE_SYSTEM))
        return E_FAIL;

    //
    // Make desktop.ini
    //
    TCHAR szDesktopIni[MAX_PATH];
    if (PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini")))
    {
        WritePrivateProfileString(NULL, NULL, NULL, szDesktopIni); 

        //
        // Write ConfirmFileOp=0 to turn off shell warnings during file operations
        //
        EVAL(WritePrivateProfileString( 
            TEXT(".ShellClassInfo"),
            TEXT("ConfirmFileOp"),  TEXT("0"), szDesktopIni));

        //
        // Write the URL for this category folders webview
        //
        if (pszURL)
        {
            EVAL(WritePrivateProfileString( 
                TEXT(".ShellClassInfo"),
                TEXT("URL"),  pszURL, szDesktopIni));
        }

        //
        // Write the Logo for this channel if present
        //
        if (pszLogo)
        {
            EVAL(WritePrivateProfileString( 
                TEXT(".ShellClassInfo"),
                TEXT("Logo"),  pszLogo, szDesktopIni));
        }

        //
        // Write the WideLogo for this channel if present
        //
        if (pszWideLogo)
        {
            EVAL(WritePrivateProfileString( 
                TEXT(".ShellClassInfo"),
                TEXT("WideLogo"),  pszWideLogo, szDesktopIni));
        }
    
        //
        // Write the Icon URL for this category folder if present
        //
        if (pszIcon)
        {
            TCHAR szIconIndex[8];                            // can handle 999999
            ASSERT(nIconIndex >= 0 && nIconIndex <= 999999); // sanity check
            wnsprintf(szIconIndex, ARRAYSIZE(szIconIndex), TEXT("%d"), nIconIndex);

            EVAL(WritePrivateProfileString( 
                TEXT(".ShellClassInfo"),
                TEXT("IconIndex"),  szIconIndex, szDesktopIni));

            EVAL(WritePrivateProfileString( 
                TEXT(".ShellClassInfo"),
                TEXT("IconFile"),  pszIcon, szDesktopIni));
        }
    
        //
        // Flush the buffers
        //
        WritePrivateProfileString(NULL, NULL, NULL, szDesktopIni);

        SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_HIDDEN);
    }

    return S_OK;
}

//
// Create the special channels folder
//

//
// Channel folders are no longer created in IE5+
//
/*
HRESULT Channel_CreateChannelFolder( XMLDOCTYPE xdt )
{
    TCHAR szPath[MAX_PATH];
    if (SUCCEEDED(Channel_GetFolder(szPath, xdt)) && szPath[0] != 0)
    {
        //
        // Create a special folder with an icon that lives in the cdfview.dll
        //
        return Channel_CreateSpecialFolder(
            szPath, NULL, NULL, NULL, g_szModuleName, -IDI_CHANNELFOLDER);
    }
    else
        return E_FAIL;
}
*/

HRESULT Channel_GetBasePath(LPTSTR pszPath, int cch)
{
    ASSERT(pszPath || 0 == cch);

    HRESULT hr;

    DWORD dwLen = cch * sizeof(TCHAR);

    if (SHRegGetValue(HKEY_CURRENT_USER, SHELLFOLDERS, L"Favorites", SRRF_RT_REG_SZ, NULL, pszPath, &dwLen) == ERROR_SUCCESS)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }
    
    return hr;
}

BSTR Channel_GetFullPath(LPCWSTR pwszName)
{
    ASSERT(pwszName);

    BSTR bstrRet = NULL;

    TCHAR szName[MAX_PATH];
    if (SHUnicodeToTChar(pwszName, szName, ARRAYSIZE(szName)))
    {
        TCHAR szPath[MAX_PATH];

        if (SUCCEEDED(Channel_GetFolder(szPath, ARRAYSIZE(szPath), DOC_CHANNEL)))
        {
            if (PathCombineCleanPath(szPath, szName))
            {
                WCHAR wszPath[MAX_PATH];

                if (SHTCharToUnicode(szPath, wszPath, ARRAYSIZE(wszPath)))
                {
                    bstrRet = SysAllocString(wszPath);
                }
            }
        }
    }

    return bstrRet;
}

    
HRESULT Channel_GetFolder(LPTSTR pszPath, DWORD cchPath, XMLDOCTYPE xdt )
{
    TCHAR   szFavs[MAX_PATH];
    TCHAR   szChannel[MAX_PATH];
    ULONG    cbChannel = sizeof(szChannel);
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(Channel_GetBasePath(szFavs, ARRAYSIZE(szFavs))))
    {
        switch (xdt)
        {
            case DOC_CHANNEL:
                //
                // Get the potentially localized name of the Channel folder from the
                // registry if it is there.  Otherwise just read it from the resource.
                // Then tack this on the favorites path.
                //

                if (ERROR_SUCCESS != SHRegGetUSValue(L"Software\\Microsoft\\Windows\\CurrentVersion",
                                                     L"ChannelFolderName", NULL, (void*)szChannel,
                                                     &cbChannel, TRUE, NULL, 0))
                {
                    MLLoadString(IDS_CHANNEL_FOLDER, szChannel, ARRAYSIZE(szChannel));
                }
                break;

            case DOC_SOFTWAREUPDATE:
                MLLoadString(IDS_SOFTWAREUPDATE_FOLDER, szChannel, ARRAYSIZE(szChannel));
                break;
        }

        if (PathCombine(pszPath, szFavs, szChannel))
        {

            //
            // If the channels folder doesn't exist create it now
            // 
            if (!PathFileExists(pszPath))
            {
                //
                // In IE5+ use the favorites folder if the channels folder does not
                // exist.
                //

                StrCpyN(pszPath, szFavs, cchPath);

                //
                // Create special folder with an icon that lives in cdfview.dll
                //
                /*
                Channel_CreateSpecialFolder(
                    pszPath, NULL, NULL, NULL, g_szModuleName, -IDI_CHANNELFOLDER);
                */
            }
        }

        hr = S_OK;
    }
    return hr;
}

// NOTE: This registry location and name is used by webcheck as well so do not
// change it here without updating webcheck.
const TCHAR c_szRegKeyWebcheck[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Webcheck");
const TCHAR c_szRegValueChannelGuide[] = TEXT("ChannelGuide");

HRESULT Channel_GetChannelGuide(LPTSTR pszPath, int cch)
{
    ASSERT(pszPath || 0 == cch);

    HRESULT hr;

    DWORD dwLen = cch * sizeof(TCHAR);

    if (SHRegGetValue(HKEY_CURRENT_USER, c_szRegKeyWebcheck, c_szRegValueChannelGuide,
                      SRRF_RT_REG_SZ, NULL, pszPath, &dwLen) == ERROR_SUCCESS)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }
    
    return hr;
}

//
// Channel_OrderChannel - Set the order of the new channel in the folder
//
void Channel_OrderItem(LPCTSTR szPath)
{
    HRESULT hr;
    BOOL bRet;
    LPITEMIDLIST pidlParent = NULL, pidlChild = NULL;
    IShellFolder *psfDesktop = NULL;
    IShellFolder *psfParent = NULL;
    IPersistFolder *pPF = NULL;
    IOrderList *pOL = NULL;
    HDPA hdpa = NULL;
    int iChannel = -1;  // Pick a negative index to see if we find it.
    int iInsert = 0;    // Assume we don't find the channel guide.
    PORDERITEM poi;

    // Get the full pidl of the new channel (ignore the pidlParent name)
    hr = Channel_CreateILFromPath(szPath, &pidlParent);
    if (FAILED(hr))
        goto cleanup;

    // Allocate a child pidl and make the parent pidl
    pidlChild = ILClone(ILFindLastID(pidlParent));
    if (!pidlChild)
        goto cleanup;
    bRet = ILRemoveLastID(pidlParent);
    ASSERT(bRet);

    // Get the IShellFolder of the parent by going through the
    // desktop folder.
    hr = SHGetDesktopFolder(&psfDesktop);
    if (FAILED(hr))
        goto cleanup;
    hr = psfDesktop->BindToObject(pidlParent, NULL, IID_IShellFolder, (void**)&psfParent);
    if (FAILED(hr))
        goto cleanup;

    // Get the order list of the parent.
    hr = CoCreateInstance(CLSID_OrderListExport, NULL, CLSCTX_INPROC_SERVER, IID_IPersistFolder, (void**)&pPF);
    if (FAILED(hr))
        goto cleanup;
    hr = pPF->Initialize(pidlParent);
    if (FAILED(hr))
        goto cleanup;
    hr = pPF->QueryInterface(IID_IOrderList, (void**)&pOL);
    if (FAILED(hr))
        goto cleanup;
    hr = pOL->GetOrderList(&hdpa);

    // Create a DPA list if there wasn't one already.
    if (!hdpa)
    {
        hdpa = DPA_Create(2);
        if (!hdpa)
            goto cleanup;
    }
    else
    {
        // First, get the channel guide pidl.
        TCHAR szGuide[MAX_PATH];
        WCHAR wzGuide[MAX_PATH];
        LPITEMIDLIST pidlGuide = NULL;
        if (SUCCEEDED(Channel_GetChannelGuide(szGuide, ARRAYSIZE(szGuide))))
        {
            if (SHTCharToUnicode(szGuide, wzGuide, ARRAYSIZE(wzGuide)))
            {
                ULONG ucch;
                hr = psfParent->ParseDisplayName(NULL, NULL, wzGuide, &ucch, &pidlGuide, NULL);
                ASSERT(!pidlGuide || SUCCEEDED(hr));
            }
        }

        // Now do the search.
        // Check to see if the channel is in the DPA list.
        // Check to see if the channel guide is there and first.
        int i = 0;
        poi = (PORDERITEM)DPA_GetPtr(hdpa, i);
        while (poi)
        {
            if (!psfParent->CompareIDs(0, pidlChild, poi->pidl))
                iChannel = poi->nOrder;
            if (pidlGuide && !psfParent->CompareIDs(0, pidlGuide, poi->pidl) && (poi->nOrder == 0))
                iInsert = 1;
            i++;
            poi = (PORDERITEM)DPA_GetPtr(hdpa, i);
        }
    }

    // If the channel pidl was not found, insert it at the end
    if (iChannel < 0)
    {
        // Allocate an order item to insert
        hr = pOL->AllocOrderItem(&poi, pidlChild);
        if (SUCCEEDED(hr))
        {
            iChannel = DPA_InsertPtr(hdpa, 0x7fffffff, poi);
            if (iChannel >= 0)
                poi->nOrder = iChannel;
        }
    }

    // Reorder the channels.  The new channel is in the list at
    // position iChannel.  We're moving it to position iInsert.
    if (iChannel >= 0)
    {
        int i = 0;
        poi = (PORDERITEM)DPA_GetPtr(hdpa, i);
        while (poi)
        {
            if (poi->nOrder == iChannel && iChannel >= iInsert)
                poi->nOrder = iInsert;
            else if (poi->nOrder >= iInsert && poi->nOrder < iChannel)
                poi->nOrder++;
            
            i++;
            poi = (PORDERITEM)DPA_GetPtr(hdpa, i);
        }

        // Finally, set the order.
        hr = pOL->SetOrderList(hdpa, psfParent);
        ASSERT(SUCCEEDED(hr));
    }

cleanup:
    if (hdpa)
        pOL->FreeOrderList(hdpa);
    if (pOL)
        pOL->Release();
    if (pPF)
        pPF->Release();
    if (psfParent)
        psfParent->Release();
    if (psfDesktop)
        psfDesktop->Release();
    ILFree(pidlParent);    // NULL is OK.
    ILFree(pidlChild);
}

//
// AddChannel - Add a channel
//
HRESULT AddChannel(
    LPCTSTR pszName, 
    LPCTSTR pszURL, 
    LPCTSTR pszLogo, 
    LPCTSTR pszWideLogo, 
    LPCTSTR pszIcon,
    XMLDOCTYPE xdt )
{
    HRESULT hr = S_OK;
    BOOL fDirectoryAlreadyExisted = FALSE;
    
    //
    // Find the Channel directory
    // Attempt to create folder if one doesn't exist
    //
    TCHAR szPath[MAX_PATH];
    if (FAILED(Channel_GetFolder(szPath, ARRAYSIZE(szPath), xdt)))
    {
        return E_FAIL;  // couldn't find Channel Folder or create empty one
    }

    // Cleanup each of the path components independently.
    PathCombineCleanPath(szPath, pszName);
    TraceMsg(TF_GENERAL, "Channel Path = %s", szPath);

    //
    // Make the new folder if it doesn't already exist
    //
    if (!PathFileExists(szPath))
    {
        if (Channel_CreateDirectory(szPath) != 0)
        {
            return E_FAIL;
        }
    }
    else
    {
        fDirectoryAlreadyExisted = TRUE;
    }

    //
    // Mark it as a SYSTEM folder
    //
    if (!SetFileAttributes(szPath, FILE_ATTRIBUTE_SYSTEM))
        return E_FAIL;

    //
    // Add the channel to the registry database of all channels.
    //

    //if (FAILED(Reg_WriteChannel(szPath, pszURL)))
    //    return E_FAIL;

    //
    // Place the channel folder in the appropriate "order".
    //
    Channel_OrderItem(szPath);
    
    // Build the CDFINI GUID string
    //
    TCHAR szCDFViewGUID[GUID_STR_LEN];
    SHStringFromGUID(CLSID_CDFINI, szCDFViewGUID, ARRAYSIZE(szCDFViewGUID));

    //
    // Make desktop.ini
    //
    if (PathCombine(szPath, szPath, TEXT("desktop.ini")))
    {
        TraceMsg(TF_GENERAL, "INI path = %s", szPath);
        WritePrivateProfileString(NULL, NULL, NULL, szPath); // Create desktop.ini

        //
        // Write in the CDFViewer GUID
        //
        EVAL(WritePrivateProfileString( 
            TEXT(".ShellClassInfo"),
            TEXT("CLSID"),  szCDFViewGUID, szPath));

        //
        // Write ConfirmFileOp=0 to turn off shell warnings during file operations
        //
        EVAL(WritePrivateProfileString( 
            TEXT(".ShellClassInfo"),
            TEXT("ConfirmFileOp"),  TEXT("0"), szPath));

        //
        // Write the actual URL for this channel
        //
        EVAL(WritePrivateProfileString( 
            TEXT("Channel"),
            TEXT("CDFURL"),  pszURL, szPath));


        Channel_GetAndWriteScreenSaverURL(pszURL, szPath);

        //
        // Write the default Logo URL for this channel if present
        //
        if (pszLogo)
        {
            EVAL(WritePrivateProfileString( 
                TEXT("Channel"),
                TEXT("Logo"),  pszLogo, szPath));
        }

        //
        // Write the default WideLogo URL for this channel if present
        //
        if (pszWideLogo)
        {
            EVAL(WritePrivateProfileString( 
                TEXT("Channel"),
                TEXT("WideLogo"),  pszWideLogo, szPath));
        }

        //
        // Write the default Icon URL for this channel if present
        //
        if (pszIcon)
        {
            EVAL(WritePrivateProfileString( 
                TEXT("Channel"),
                TEXT("Icon"),  pszIcon, szPath));
        }
    
        //
        // Flush the buffers
        //
        WritePrivateProfileString(NULL, NULL, NULL, szPath); // Create desktop.ini

        EVAL(SetFileAttributes(szPath, FILE_ATTRIBUTE_HIDDEN));
    }
    else
    {
        return E_FAIL;
    }

    //
    // Notify the system that a new item has been added, or if the item 
    // already existed just send an UPDATEDIR notification
    //
    PathRemoveFileSpec(szPath);
    if (fDirectoryAlreadyExisted)
    {
        SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, (void*)szPath, NULL);
    }
    else
    {
        SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, (void*)szPath, NULL);
    }

    return S_OK;
}

//
// DeleteChannel - Deletes a channel by name
//
// Returns 
//     S_OK if channel existed and successfully deleted
//     S_FALSE if channel didn't exist.
//     E_FAIL else.
//
HRESULT DeleteChannel(LPTSTR szName)
{
    TCHAR szFolderPath[MAX_PATH];
    TCHAR szDesktopIniPath[MAX_PATH];
        
    if (PathIsRelative(szName))
    {
        //
        // Find the Channel directory
        // Note don't create if doesn't exist
        //
        // FEATURE: this won't find app channels.
        if (FAILED(Channel_GetFolder(szFolderPath, ARRAYSIZE(szFolderPath), DOC_CHANNEL)))
        {
            return S_FALSE;  // couldn't find Channel Folder so channel can't exist
        }

        // Cleanup each of the path components independently.
        PathCombineCleanPath(szFolderPath, szName);
        TraceMsg(TF_GENERAL, "Delete Channel Path = %s", szFolderPath);

    }
    else
    {
        // Assume absolute paths were retrieved by enumeration and
        // therefore don't need to be "cleaned".
        StrCpyN(szFolderPath, szName, ARRAYSIZE(szFolderPath));
    }

    // Create the desktop.ini path
    if (PathCombine(szDesktopIniPath, szFolderPath, TEXT("desktop.ini")))
    {

        // Find URL to CDF from desktop.ini
        TCHAR szCDFURL[INTERNET_MAX_URL_LENGTH];
        GetPrivateProfileString(TEXT("Channel"), TEXT("CDFURL"), TEXT(""), szCDFURL, ARRAYSIZE(szCDFURL), szDesktopIniPath);

        // Remove the URL from the cache preload registry key
        HKEY hkeyPreload;
        LONG lRet = RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegKeyCachePreload, 0, KEY_WRITE, &hkeyPreload);
        if (ERROR_SUCCESS == lRet)
        {
            lRet = RegDeleteValue(hkeyPreload, szCDFURL);
            lRet = RegCloseKey(hkeyPreload);
            ASSERT(ERROR_SUCCESS == lRet);
        }

        if  (
            !DeleteFile(szDesktopIniPath)
            ||
            !SetFileAttributes(szFolderPath, FILE_ATTRIBUTE_NORMAL)
            ||
            //
            // REVIEW: should change this to delete all contents of channel folder
            // incase other files get stored there in the future.
            //
            !RemoveDirectory(szFolderPath)
            )
        {
            return S_FALSE;
        }
    }
    else
    {
        return S_FALSE;
    }

    return S_OK;
}

//
// CountChannels - Counts the number of channels
//
// Returns the count
//
DWORD CountChannels(void)
{
    DWORD cChannels = 0;
    IEnumChannels *pEnum = (IEnumChannels *) new CChannelEnum(CHANENUM_CHANNELFOLDER, NULL);
    if (pEnum)
    {
        CHANNELENUMINFO cei;
        while (S_OK == pEnum->Next(1, &cei, NULL))
        {
            cChannels++;
        }
        pEnum->Release();
    }

    return cChannels;
}


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** OpenChannel ***
//
//
// Description:
//     Opens a new browser and selects the given channel
//
// Parameters:
//     [In]  hwndParent - The owner hwnd.
//     [In]  hinst      - The hinstance for this process.
//     [In]  pszCmdLine - The local path to the cdf file.  This will be the path
//                        to the file in the cache if the cdf came from the net.
//     [In]  nShow      - ShowWindow parameter.
//
// Return:
//     None.
//
// Comments:
//     This is the implementation for the context menu "Open Channel" command.
//     It gets invoke via RunDll32.exe.
//
////////////////////////////////////////////////////////////////////////////////
EXTERN_C
STDAPI_(void)
OpenChannel(
    HWND hwndParent,
    HINSTANCE hinst,
    LPSTR pszCmdLine,
    int nShow
)
{
    WCHAR wszPath[INTERNET_MAX_URL_LENGTH];

    if (MultiByteToWideChar(CP_ACP, 0, pszCmdLine, -1, wszPath,
                            ARRAYSIZE(wszPath)))
    {
        OpenChannelHelper(wszPath, hwndParent);
    }

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Subscribe ***
//
//
// Description:
//     Takes the given cdf through the user subscription path.
//
// Parameters:
//     [In]  hwndParent - The owner hwnd.
//     [In]  hinst      - The hinstance for this process.
//     [In]  pszCmdLine - The local path to the cdf file.  This will be the path
//                        to the file in the cache if the cdf came from the net.
//     [In]  nShow      - ShowWindow parameter.
//
// Return:
//     None.
//
// Comments:
//     This is the implementation of the context menu "Subscribe" command.  It
//     gets invoke via rundll32.exe.
//
//     This function handles channel and desktop component cdfs.
//
////////////////////////////////////////////////////////////////////////////////
EXTERN_C
STDAPI_(void)
Subscribe(
    HWND hwndParent,
    HINSTANCE hinst,
    LPSTR pszCmdLine,
    int nShow
)
{
    WCHAR wszPath[INTERNET_MAX_URL_LENGTH];

    if (MultiByteToWideChar(CP_ACP, 0, pszCmdLine, -1, wszPath,
                            ARRAYSIZE(wszPath)))
    {
        SubscribeToCDF(hwndParent, wszPath, STC_ALL);
    }

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** ParseDesktopComponent ***
//
//
// Description:
//     Fills an information structure for a desktop component and optionally
//     allows the user to subscribe to the component.
//
// Parameters:
//     [In]  hwndOwner - The owner hwnd.  If NULL there is no attempt to
//                       subscribe to this URL.
//     [In]  wszURL    - The URL to the desktop component cdf.
//     [Out] pInfo     - A pointer that receives desktop component information
//                       that is read from the cdf.
//
// Return:
//     S_OK if the desktop info could be read.
//     S_FALSE if the user hits cancel
//     E_FAIL otherwise.
//
// Comments:
//     This function is used by the desktop component property pages.  It may
//     create a subscription to the component but unlike Subscribe, it will
//     not add a desktop component to the system.  Creating the component is
//     left to the desktop component property pages.
//
////////////////////////////////////////////////////////////////////////////////
EXTERN_C
STDAPI
ParseDesktopComponent(
    HWND hwndOwner,
    LPWSTR wszURL,
    COMPONENT*  pInfo
)
{
    HRESULT hr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        CCdfView* pCCdfView = new CCdfView;

        if (pCCdfView)
        {
            hr = pCCdfView->Load(wszURL, 0);

            if (SUCCEEDED(hr))
            {
                IXMLDocument* pIXMLDocument;

                TraceMsg(TF_CDFPARSE, "ParseDesktopComponent");

                TCHAR szFile[MAX_PATH];
                TCHAR szURL[INTERNET_MAX_URL_LENGTH];

                SHUnicodeToTChar(wszURL, szURL, ARRAYSIZE(szURL));

                hr = URLDownloadToCacheFile(NULL, szURL, szFile,
                                            ARRAYSIZE(szFile), 0, NULL);

                if (SUCCEEDED(hr))
                {
                    hr = pCCdfView->ParseCdf(NULL, &pIXMLDocument, PARSE_LOCAL);

                    if (SUCCEEDED(hr))
                    {
                        ASSERT(pIXMLDocument);

                        if (DOC_DESKTOPCOMPONENT == XML_GetDocType(pIXMLDocument))
                        {
                            BOOL fOk = FALSE;

                            if (hwndOwner)
                            {
                                fOk = SubscriptionHelper(pIXMLDocument, hwndOwner,
                                                   SUBSTYPE_DESKTOPCHANNEL,
                                                   SUBSACTION_SUBSCRIBEONLY,
                                                   wszURL, DOC_DESKTOPCOMPONENT, NULL);
                            }

                            if (fOk)
                            {
                                if(SUCCEEDED(hr = XML_GetDesktopComponentInfo(pIXMLDocument, pInfo)) &&
                                    !pInfo->wszSubscribedURL[0])
                                {
                                    // Since XML_GetDesktopComponentInfo did not fillout the SubscribedURL
                                    // field (because the CDF file didn't have a SELF tag), we need to 
                                    // fill it with what was really subscribed to (the URL for CDF file itself)
                                    StrCpyNW(pInfo->wszSubscribedURL, wszURL, ARRAYSIZE(pInfo->wszSubscribedURL));
                                }
                            }
                            else
                                hr = S_FALSE;
                        }
                        else
                        {
                            hr = E_FAIL;
                        }

                        pIXMLDocument->Release();
                    }
                }
            }

            pCCdfView->Release();
        }
    }
    
    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** SubscribeToCDF ***
//
//
// Description:
//     Subscribes to the given cdf.
//
// Parameters:
//     [In]  hwndOwner - The owner hwnd.  Used to display the subscription
//                       wizard.
//     [In]  wszURL    - An url to the cdf.
//     [In]  dwFlags   - The type of cdf the caller wants to subscribe to.
//                       STC_CHANNEL, STC_DESKTOPCOMPONENT or STC_ALL.
//
// Return:
//     S_OK if the subscription worked and the user subscribed.
//     S_FALSE if the subscription UI appeared but the user decided not to
//             subscribe.
//     E_INVALIDARG if the cdf couldn't be opened or parsed.
//     E_ACCESSDENIED if the cdf file doesn't match the type specified in
//                    dwFlags.
//     E_FAIL on any other errors.
//
// Comments:
//     Private API.  Currently called by desktop component drop handler.
//
////////////////////////////////////////////////////////////////////////////////
EXTERN_C
STDAPI
SubscribeToCDF(
    HWND hwndOwner,
    LPWSTR wszURL,
    DWORD dwFlags
)
{
    HRESULT hr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        CCdfView* pCCdfView = new CCdfView;

        if (pCCdfView)
        {
            hr = pCCdfView->Load(wszURL, 0);

            if (SUCCEEDED(hr))
            {
                IXMLDocument* pIXMLDocument;

                TraceMsg(TF_CDFPARSE, "SubscribeToCDF");

                hr = pCCdfView->ParseCdf(NULL, &pIXMLDocument, PARSE_LOCAL);

                if (SUCCEEDED(hr))
                {
                    ASSERT(pIXMLDocument);

                    XMLDOCTYPE xdt = XML_GetDocType(pIXMLDocument);

                    switch(xdt)
                    {
                    case DOC_CHANNEL:
                    case DOC_SOFTWAREUPDATE:
                        // Admins can disallow adding channels and limit
                        // the number of installed channels.
                        if ((dwFlags & STC_CHANNEL) &&
                            !SHRestricted2W(REST_NoAddingChannels, wszURL, 0) &&
                            (!SHRestricted2W(REST_MaxChannelCount, NULL, 0) ||
                            (CountChannels() < SHRestricted2W(REST_MaxChannelCount, NULL, 0))))
                        {
                            if (SubscriptionHelper(pIXMLDocument, hwndOwner,
                                            SUBSTYPE_CHANNEL,
                                            SUBSACTION_ADDADDITIONALCOMPONENTS,
                                            wszURL, xdt, NULL))
                            {
                                OpenChannelHelper(wszURL, hwndOwner);

                                hr = S_OK;
                            }
                            else
                            {
                                hr = S_FALSE;
                            }

                        }
                        else
                        {
                            hr = E_ACCESSDENIED;
                        }
                        break;

                    case DOC_DESKTOPCOMPONENT:
#ifndef UNIX
                        if (hwndOwner &&
                            (WhichPlatform() != PLATFORM_INTEGRATED))
#else
                        /* No Active Desktop on Unix */
                        if (0)
#endif /* UNIX */
                        {
                            TCHAR szText[MAX_PATH];
                            TCHAR szTitle[MAX_PATH];

                            MLLoadString(IDS_BROWSERONLY_DLG_TEXT, 
                                       szText, ARRAYSIZE(szText)); 
                            MLLoadString(IDS_BROWSERONLY_DLG_TITLE,
                                       szTitle, ARRAYSIZE(szTitle));

                            MessageBox(hwndOwner, szText, szTitle, MB_OK); 
                        }
                        else if (dwFlags & STC_DESKTOPCOMPONENT)
                        {
                            if (SubscriptionHelper(pIXMLDocument, hwndOwner,
                                            SUBSTYPE_DESKTOPCHANNEL,
                                            SUBSACTION_ADDADDITIONALCOMPONENTS,
                                            wszURL,
                                            DOC_DESKTOPCOMPONENT, NULL))
                            {
                                hr = S_OK;
                            }
                            else
                            {
                                hr = S_FALSE;
                            }
                        }
                        else
                        {
                            hr = E_ACCESSDENIED;
                        }
                        break;

                    case DOC_UNKNOWN:
                        //If it is NOT a cdfFile, then we get DOC_UNKNOWN. We must return error
                        // here sothat the caller knows that this is NOT a cdffile.
                        hr = E_INVALIDARG;
                        break;
                        
                    default:
                        break;
                    }

                    pIXMLDocument->Release();
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }

            pCCdfView->Release();
        }

        CoUninitialize();
    }

    return hr;
}

//
// Utility functions.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** OpenChannelHelper ***
//
//
// Description:
//     Opens the browser with the wszURL channel selected.
//
// Parameters:
//     [In]  wszURL    - The URL of the cdf file to display.
//     [In]  hwndOwner - The owning hwnd for error messages.  Can be NULL.
//
// Return:
//     S_OK if the browser was opened.
//     E_FAIL otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
OpenChannelHelper(
    LPWSTR wszURL,
    HWND hwndOwner
)
{
    //
    // REVIEW:  Handle non-channel cdfs.
    //

    HRESULT hr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        IWebBrowser2* pIWebBrowser2;

        hr = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER,
                              IID_IWebBrowser2, (void**)&pIWebBrowser2);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIWebBrowser2);
            //
            // Navigate to the root url of the cdf ref'd in wszURL
            //
            hr = NavigateBrowser(pIWebBrowser2, wszURL, hwndOwner);

			pIWebBrowser2->put_Visible(VARIANT_TRUE);

            pIWebBrowser2->Release();
        }

        CoUninitialize();
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// *** ShowChannelPane
//
// Description - shows the channel pane for the given web browser object
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
ShowChannelPane(
    IWebBrowser2* pIWebBrowser2
)
{
    HRESULT hr;
    VARIANT guid;
    VARIANT empty = {0};
    BSTR    bstrGuid;
    TCHAR szGuid[GUID_STR_LEN];
    WCHAR wszGuid[GUID_STR_LEN];

    if (!SHRestricted2W(REST_NoChannelUI, NULL, 0))
    {
        SHStringFromGUID(CLSID_FavBand, szGuid, ARRAYSIZE(szGuid));
        SHTCharToUnicode(szGuid, wszGuid, ARRAYSIZE(wszGuid));

        if ((bstrGuid = SysAllocString(wszGuid)) == NULL)
            return E_OUTOFMEMORY;

        guid.vt = VT_BSTR;
        guid.bstrVal = bstrGuid;

        hr = pIWebBrowser2->ShowBrowserBar(&guid, &empty, &empty);

        SysFreeString(bstrGuid);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

//
// These routines are only needed if we want to pidl a variant pidl for
// navigating the ChannelPane to a specific pidl
//
SAFEARRAY * MakeSafeArrayFromData(const void * pData,DWORD cbData)
{
    SAFEARRAY * psa;

    if (!pData || 0 == cbData)
        return NULL;  // nothing to do

    // create a one-dimensional safe array
    psa = SafeArrayCreateVector(VT_UI1,0,cbData);
    ASSERT(psa);

    if (psa) {
        // copy data into the area in safe array reserved for data
        // Note we party directly on the pointer instead of using locking/
        // unlocking functions.  Since we just created this and no one
        // else could possibly know about it or be using it, this is OK.

        ASSERT(psa->pvData);
        memcpy(psa->pvData,pData,cbData);
    }

    return psa;
}

/************************************************************\
    FUNCTION: InitVARIANTFromPidl

    PARAMETER:
        pvar - Allocated by caller and filled in by this function.
        pidl - Allocated by caller and caller needs to free.

    DESCRIPTION:
        This function will take the PIDL parameter and COPY it
    into the Variant data structure.  This allows the pidl
    to be freed and the pvar to be used later, however, it
    is necessary to call VariantClear(pvar) to free memory
    that this function allocates.
\************************************************************/
BOOL InitVARIANTFromPidl(VARIANT* pvar, LPCITEMIDLIST pidl)
{
    UINT cb = ILGetSize(pidl);
    SAFEARRAY* psa = MakeSafeArrayFromData((const void *)pidl, cb);
    if (psa) {
        ASSERT(psa->cDims == 1);
        // ASSERT(psa->cbElements == cb);
        ASSERT(ILGetSize((LPCITEMIDLIST)psa->pvData)==cb);
        VariantInit(pvar);
        pvar->vt = VT_ARRAY|VT_UI1;
        pvar->parray = psa;
        return TRUE;
    }

    return FALSE;
}


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** NavigateBrowser ***
//
//
// Description:
//     Navigate the browser to the correct URL for the given cdf.
//
// Parameters:
//     [In]  IWebBrowser2 - The browser top naviagte.
//     [In]  szwURL       - The path to the cdf file.
//     [In]  hwnd         - The wner hwnd.
//
// Return:
//     S_OK if the cdf file was parsed and the browser naviagted to teh URL.
//     E_FAIL otherwise.
//
// Comments:
//     Read the href of the first CHANNEL tag in the cfd file and navigate
//     the browser to this href.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
NavigateBrowser(
    IWebBrowser2* pIWebBrowser2,
    LPWSTR wszURL,
    HWND hwnd
)
{
    ASSERT(pIWebBrowser2);
    ASSERT(wszURL);
    ASSERT(*wszURL != 0);

    HRESULT hr = E_FAIL;

    //
    // Try to navigate to the title page.
    //

    CCdfView* pCCdfView = new CCdfView;

    if (pCCdfView)
    {
        hr = pCCdfView->Load(wszURL, 0);

        if (SUCCEEDED(hr))
        {
            IXMLDocument* pIXMLDocument = NULL;

            TraceMsg(TF_CDFPARSE, "NavigateBrowser");

            BOOL fIsURLChannelShortcut = PathIsDirectoryW(wszURL);

            hr = pCCdfView->ParseCdf(NULL, &pIXMLDocument, PARSE_LOCAL | PARSE_REMOVEGLEAM);
            
            if (SUCCEEDED(hr))
            {
                ASSERT(pIXMLDocument);

                //
                // Iff the CDF parsed correctly then show the channel pane
                //
                // pIWebBrowser2->put_TheaterMode(VARIANT_TRUE);
                pIWebBrowser2->put_Visible(VARIANT_TRUE);



                IXMLElement*    pIXMLElement;
                LONG            nIndex;

                hr = XML_GetFirstChannelElement(pIXMLDocument,
                                                &pIXMLElement, &nIndex);

                if (SUCCEEDED(hr))
                {
                    ASSERT(pIXMLElement);

                    BSTR bstrURL = XML_GetAttribute(pIXMLElement, XML_HREF);

                    if (bstrURL && *bstrURL)
                    {
                        if (!fIsURLChannelShortcut)
                        {
                            LPOLESTR pszPath = Channel_GetChannelPanePath(wszURL);

                            if (pszPath)
                            {
                                if (SUCCEEDED(ShowChannelPane(pIWebBrowser2)))
                                    NavigateChannelPane(pIWebBrowser2, pszPath);

                                CoTaskMemFree(pszPath);
                            }
                        }
                        else
                        {
                            TCHAR szChanDir[MAX_PATH];

                            if (SUCCEEDED(Channel_GetFolder(szChanDir,
                                                            ARRAYSIZE(szChanDir),
                                                            DOC_CHANNEL)))
                            {
                                WCHAR wszChanDir[MAX_PATH];

                                if (SHTCharToUnicode(szChanDir, wszChanDir,
                                                   ARRAYSIZE(wszChanDir)))
                                {

                                    if (PathIsPrefixW(wszChanDir, wszURL))
                                    {
                                        if (SUCCEEDED(ShowChannelPane(
                                                                pIWebBrowser2)))
                                        {
                                            NavigateChannelPane(pIWebBrowser2,
                                                                wszURL);
                                        }
                                    }
                                }
                            }
                        }

                        VARIANT vNull = {0};
                        VARIANT vTargetURL;

                        vTargetURL.vt      = VT_BSTR;
                        vTargetURL.bstrVal = bstrURL;
                    
                        //
                        // Nav the main browser pain to the target URL
                        //
                        hr = pIWebBrowser2->Navigate2(&vTargetURL, &vNull,
                                                      &vNull, &vNull, &vNull);
                    }

                    if (bstrURL)
                        SysFreeString(bstrURL);

                    pIXMLElement->Release();
                }
            }
            else if (OLE_E_NOCACHE == hr)
            {
                VARIANT vNull = {0};
                VARIANT vTargetURL;

                if (!fIsURLChannelShortcut)
                {                        
                    vTargetURL.bstrVal = SysAllocString(wszURL);
                }
                else
                {
                    vTargetURL.bstrVal = pCCdfView->ReadFromIni(TSTR_INI_URL);
                }

                if (vTargetURL.bstrVal)
                {
                    vTargetURL.vt = VT_BSTR;

                    //
                    // Nav the main browser pain to the target URL
                    //
                    hr = pIWebBrowser2->Navigate2(&vTargetURL, &vNull, &vNull,
                                                  &vNull, &vNull);

                    SysFreeString(vTargetURL.bstrVal);
                }

            }

            if (pIXMLDocument)
                pIXMLDocument->Release();
        }

        pCCdfView->Release();
    }

    return hr;
}

//
// Navigate the channel pane to the given channel.
//

HRESULT
NavigateChannelPane(
    IWebBrowser2* pIWebBrowser2,
    LPCWSTR pwszPath
)
{
    ASSERT(pIWebBrowser2);

    HRESULT hr = E_FAIL;

    if (pwszPath)
    {
        TCHAR szPath[MAX_PATH];

        if (SHUnicodeToTChar(pwszPath, szPath, ARRAYSIZE(szPath)))
        {
            LPITEMIDLIST pidl;

            if (SUCCEEDED(Channel_CreateILFromPath(szPath,  &pidl)))
            {
                ASSERT(pidl);

                VARIANT varPath;

                if (InitVARIANTFromPidl(&varPath, pidl))
                {
                    VARIANT varNull = {0};
                    VARIANT varFlags;

                    varFlags.vt   = VT_I4;
                    varFlags.lVal = navBrowserBar;

                    hr = pIWebBrowser2->Navigate2(&varPath, &varFlags,
                                                  &varNull, &varNull,
                                                  &varNull);

                    VariantClear(&varPath);
                }

                ILFree(pidl);
            }
        }

    }

    return hr;
}


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** SubscriptionHelper ***
//
//
// Description:
//     Gets subscription information from the given document and uses that info
//     to create a subscription
//
// Parameters:
//     [In]  pIXMLDocument - A pointer to the cdf document.
//     [In]  hwnd          - The ownser hwnd.  Used to display UI.
//     [In]  st            - The type of subscription.
//     [In]  sa            - Flag used to determine if additional steps should
//                           be taken if a user does create a subscription.
//
// Return:
//     TRUE if a subscition for this document exists when this function returns.
//     FALSE if the document doesn't have a subscription and one wasn't created.
//
// Comments:
//     If a subscription to a channel is created then a channel shortcut has to
//     be added to the favorites\channel folder.
//
//     If a subscription to a desktop component is created then the caller
//     determines if the desktop component gets added to the system.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
SubscriptionHelper(
    IXMLDocument *pIXMLDocument,
    HWND hwnd,
    SUBSCRIPTIONTYPE st,
    SUBSCRIPTIONACTION sa,
    LPCWSTR pszwURL,
    XMLDOCTYPE xdt,
    BSTR* pbstrSubscribedURL
)
{
    ASSERT(pIXMLDocument);

    BOOL bChannelInstalled = FALSE;

    HRESULT         hr;
    IXMLElement*    pIXMLElement;
    LONG            nIndex;

    hr = XML_GetFirstChannelElement(pIXMLDocument, &pIXMLElement, &nIndex);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLElement);

        BSTR bstrURL = XML_GetAttribute(pIXMLElement, XML_SELF);

        if ((NULL == bstrURL || 0 == *bstrURL) && pszwURL)
        {
            if (bstrURL)
                SysFreeString(bstrURL);

            bstrURL = SysAllocString(pszwURL);
        }

        if (bstrURL)
        {
            ISubscriptionMgr* pISubscriptionMgr = NULL;

#ifndef UNIX
            hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                                  CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr,
                                  (void**)&pISubscriptionMgr);

            if (SUCCEEDED(hr))
            {
                ASSERT(pISubscriptionMgr);

                //hr = pISubscriptionMgr->IsSubscribed(bstrURL, &bSubscribed);
                bChannelInstalled = Channel_IsInstalled(bstrURL);

                if (SUBSTYPE_DESKTOPCHANNEL == st && hwnd)
                {
                    BOOL bSubscribed;

                    hr = pISubscriptionMgr->IsSubscribed(bstrURL, &bSubscribed);

                    if (bSubscribed)
                    {
                        TCHAR szText[MAX_PATH];
                        TCHAR szTitle[MAX_PATH];

                        MLLoadString(IDS_OVERWRITE_DLG_TEXT,  szText,
                                   ARRAYSIZE(szText)); 
                        MLLoadString(IDS_OVERWRITE_DLG_TITLE, szTitle,
                                   ARRAYSIZE(szTitle));

                        if (IDYES == MessageBox(hwnd, szText, szTitle,
                                                MB_YESNO | MB_ICONQUESTION))
                        {
                            pISubscriptionMgr->DeleteSubscription(bstrURL, NULL);
                            bChannelInstalled = FALSE;
                        }
                    }
                }
#else
                bChannelInstalled = Channel_IsInstalled(bstrURL);
#endif /* UNIX */

                if (!bChannelInstalled)
                {
                    BSTR bstrName;
                    
                    if (SUBSTYPE_DESKTOPCHANNEL != st)
                    {
                        bstrName = XML_GetAttribute(pIXMLElement, XML_TITLE);
                    }
                    else
                    {
                        IXMLElement* pDskCmpIXMLElement;

                        if (SUCCEEDED(XML_GetFirstDesktopComponentElement(
                                                            pIXMLDocument,
                                                            &pDskCmpIXMLElement,
                                                            &nIndex)))
                        {
                            ASSERT(pDskCmpIXMLElement);

                            bstrName = XML_GetAttribute(pDskCmpIXMLElement,
                                                        XML_TITLE);

                            pDskCmpIXMLElement->Release();
                        }
                        else
                        {
                            bstrName = NULL;
                        }
                    }

                    if ((NULL == bstrName || 0 == *bstrName) && pszwURL)
                    {
                        WCHAR szwFilename[MAX_PATH];

                        if (StrCpyNW(szwFilename, PathFindFileNameW(pszwURL),
                                     ARRAYSIZE(szwFilename)))
                        {
                            PathRemoveExtensionW(szwFilename);

                            if (bstrName)
                                SysFreeString(bstrName);

                            bstrName = SysAllocString(szwFilename);
                        }
                    }


                    if (bstrName)
                    {
                        TASK_TRIGGER     tt = {0};
                        SUBSCRIPTIONINFO si = {0};

                        si.cbSize       = sizeof(SUBSCRIPTIONINFO);
                        si.fUpdateFlags |= SUBSINFO_SCHEDULE;
                        si.schedule     = SUBSSCHED_AUTO;
                        si.pTrigger     = (LPVOID)&tt;

                        XML_GetSubscriptionInfo(pIXMLElement, &si);

                        bChannelInstalled = SubscribeToURL(pISubscriptionMgr,
                                                     bstrURL, bstrName, &si,
                                                     hwnd, st, (xdt==DOC_SOFTWAREUPDATE));
                        
#ifndef UNIX
                        if (bChannelInstalled &&
                            SUBSACTION_ADDADDITIONALCOMPONENTS == sa)
                        {
                            if (SUBSTYPE_CHANNEL == st)
                            {
                                // Update the subscription if the user has
                                // choosen to view the screen saver item.
                                if  (
                                    SUCCEEDED(pISubscriptionMgr->GetSubscriptionInfo(bstrURL,
                                                                                        &si))
                                    &&
                                    (si.fChannelFlags & CHANNEL_AGENT_PRECACHE_SCRNSAVER)
                                    )
                                {
                                    pISubscriptionMgr->UpdateSubscription(bstrURL);
                                }

                                //t-mattgi: moved this to AddToFav code in shdocvw
                                //because there, we know what folder to add it to
                                //AddChannel(szName, szURL, NULL, NULL, NULL, xdt);
                            }
                            else if (SUBSTYPE_DESKTOPCHANNEL == st)
                            {
                                COMPONENT Info;


                                if(SUCCEEDED(XML_GetDesktopComponentInfo(
                                                                  pIXMLDocument,
                                                                  &Info)))
                                {
                                    if(!Info.wszSubscribedURL[0])
                                    {
                                        // Since XML_GetDesktopComponentInfo did not fillout the SubscribedURL
                                        // field (because the CDF file didn't have a SELF tag), we need to 
                                        // fill it with what was really subscribed to (the URL for CDF file itself)
                                        StrCpyNW(Info.wszSubscribedURL, bstrURL, ARRAYSIZE(Info.wszSubscribedURL));                                    
                                    }
                                    pISubscriptionMgr->UpdateSubscription(bstrURL);
                                    
                                    AddDesktopComponent(&Info);
                                }
                            }
                        }
#endif /* !UNIX */
                    }
                }

#ifndef UNIX

                pISubscriptionMgr->Release();
            }
#endif /* !UNIX */

            if (pbstrSubscribedURL)
            {
                *pbstrSubscribedURL = bstrURL;
            }
            else
            {
                SysFreeString(bstrURL);
            }
        }

        pIXMLElement->Release();
    }

    return bChannelInstalled;
}
    
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** SubscribeToURL ***
//
//
// Description:
//     Takes the user to the subscription wizard for the given URL.
//
// Parameters:
//     [In]  ISubscriptionMgr - The subscription manager interface
//     [In]  bstrURL          - The URL to subscribe.
//     [In]  bstrName         - The name of the subscription.
//     [In]  psi              - A subscription information structure.
//     [In]  hwnd             - The owner hwnd.
//     [In]  st               - The type of subsciption. SUBSTYPE_CHANNEL or
//                              SUSBSTYPE_DESKTOPCOMPONENT.
//     [In]  bIsSoftare       - modifies SUBSTYPE_CHANNEL since software updates
//                              don't have their own subscriptiontype
//
// Return:
//     TRUE if the user subscribe to the URL.
//     FALSE if the user didn't subscribe to the URL.
//
// Comments:
//     The subscription manager CreateSubscription function takes the user
//     through the subscriptiopn wizard.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
SubscribeToURL(
    ISubscriptionMgr* pISubscriptionMgr,
    BSTR bstrURL,
    BSTR bstrName,
    SUBSCRIPTIONINFO* psi,
    HWND hwnd,
    SUBSCRIPTIONTYPE st,
    BOOL bIsSoftware
)
{
#ifndef UNIX
    ASSERT(pISubscriptionMgr);
#endif /* !UNIX */
    ASSERT(bstrURL);
    ASSERT(bstrName);

    BOOL bSubscribed = FALSE;

    DWORD dwFlags = 0;

    if (Channel_IsInstalled(bstrURL))
    {
        dwFlags |= CREATESUBS_ACTIVATE | CREATESUBS_FROMFAVORITES;
    }
    else
    {
        dwFlags |= CREATESUBS_ADDTOFAVORITES;
    }

    if (bIsSoftware)
    {
        dwFlags |= CREATESUBS_SOFTWAREUPDATE;
    }

#ifndef UNIX
    HRESULT hr = pISubscriptionMgr->CreateSubscription(hwnd, bstrURL, bstrName,
                                                       dwFlags, st, psi);
#else
    /* Unix does not have subscription support      */
    /* But, we want to add the channel to favorites */
    HRESULT hr = E_FAIL;

    if ((dwFlags & CREATESUBS_ADDTOFAVORITES) && (st == SUBSTYPE_CHANNEL || st == SUBSTYPE_URL))
       hr = SHAddSubscribeFavorite(hwnd, bstrURL, bstrName, dwFlags, st, psi);       
#endif /* UNIX */

#if 0
    if (SUCCEEDED(hr))
    {
        pISubscriptionMgr->IsSubscribed(bstrURL, &bSubscribed);

    }
#else
    //t-mattgi: REVIEW with edwardP
    //can't just check if subscribed -- they might choose to add to channel bar without
    //subscribing, then we still want to return true.  or do we?
    bSubscribed = (hr == S_OK); //case where they clicked OK
#endif

    return bSubscribed;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** AddDesktopComponent ***
//
//
// Description:
//     Calls the desktop component manager to add a new component.
//
// Parameters:
//     [In]  pInfo - Information about the new component to add.
//
// Return:
//     S_OK if the component was added.
//     E_FAIL otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
AddDesktopComponent(
    COMPONENT* pInfo
)
{
    ASSERT(pInfo);

    HRESULT hr = S_OK;

#ifndef UNIX
    /* No Active Desktop on Unix */

    IActiveDesktop* pIActiveDesktop;

    hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER,
                          IID_IActiveDesktop, (void**)&pIActiveDesktop);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIActiveDesktop);

        // Assign a default position to the component
        pInfo->cpPos.iLeft = COMPONENT_DEFAULT_LEFT;
        pInfo->cpPos.iTop = COMPONENT_DEFAULT_TOP;

        hr = pIActiveDesktop->AddDesktopItem(pInfo, 0);

        //
        // Apply all except refresh as this causes timing issues because the 
        // desktop is in offline mode but not in silent mode
        //
        if (SUCCEEDED(hr))
        {
            DWORD dwFlags = AD_APPLY_ALL;
            // If the desktop component url is already in cache, we want to
            // refresh right away - otherwise not
            if(!(CDFIDL_IsCachedURL(pInfo->wszSubscribedURL)))
            {
                //It is not in cache, we want to wait until the download
                // is done before refresh. So don't refresh right away
                dwFlags &= ~(AD_APPLY_REFRESH);
            }
            else
                dwFlags |= AD_APPLY_BUFFERED_REFRESH;

            hr = pIActiveDesktop->ApplyChanges(dwFlags);
        }

        pIActiveDesktop->Release();
    }

#endif /* UNIX */

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// *** Channel_CreateDirectory ***
//
// Description:
//     creates a directory including any intermediate
//     directories in the path.
//
// Parameters:
//     LPCTSTR pszPath - path of directory to create
//
// Returns:
//     0 if function succeeded, else returns GetLastError() 
//
// Comments:
//     Copied from SHCreateDirectory. Can't use SHCreateDirectory directly 
//     because that fires off an SHChangeNotify msg immediately and need to 
//     fire it off only after the desktop.ini has been created in AddChannel().
//     Also would have to do a runtime check for NT vs Win95 as this api doesn't
//     have A & W versions.
//
////////////////////////////////////////////////////////////////////////////////
int Channel_CreateDirectory(LPCTSTR pszPath)
{
    int ret = 0;

    if (!CreateDirectory(pszPath, NULL)) {
        TCHAR *pSlash, szTemp[MAX_PATH + 1];  // +1 for PathAddBackslash()
        TCHAR *pEnd;

        ret = GetLastError();

        // There are certain error codes that we should bail out here
        // before going through and walking up the tree...
        switch (ret)
        {
        case ERROR_FILENAME_EXCED_RANGE:
        case ERROR_FILE_EXISTS:
            return(ret);
        }

        StrCpyN(szTemp, pszPath, ARRAYSIZE(szTemp) - 1);
        pEnd = PathAddBackslash(szTemp); // for the loop below

        // assume we have 'X:\' to start this should even work
        // on UNC names because will will ignore the first error

#ifndef UNIX
        pSlash = szTemp + 3;
#else
        /* absolute paths on unix start with / */
        pSlash = szTemp + 1;
#endif /* UNIX */

        // create each part of the dir in order

        while (*pSlash) {
            while (*pSlash && *pSlash != TEXT(FILENAME_SEPARATOR))
                pSlash = CharNext(pSlash);

            if (*pSlash) {
                ASSERT(*pSlash == TEXT(FILENAME_SEPARATOR));

                *pSlash = 0;    // terminate path at seperator

                if (pSlash + 1 == pEnd)
                    ret = CreateDirectory(szTemp, NULL) ? 0 : GetLastError();
                else
                    ret = CreateDirectory(szTemp, NULL) ? 0 : GetLastError();

            }
            *pSlash++ = TEXT(FILENAME_SEPARATOR);     // put the seperator back
        }
    }
    return ret;
}

////////////////////////////////////////////////////////////////////////////////
// PathCombineCleanPath
////////////////////////////////////////////////////////////////////////////////
BOOL PathCombineCleanPath
(
    LPTSTR  pszCleanPath,
    LPCTSTR pszPath
)
{
    TCHAR   szComponent[MAX_PATH];
    TCHAR * pszComponent = szComponent;
    BOOL    bCleaned = FALSE;

    if (*pszPath == TEXT(FILENAME_SEPARATOR))
        pszPath++;

    *pszComponent = TEXT('\0');

    for (;;)
    {
        if  (
            (*pszPath == TEXT(FILENAME_SEPARATOR))
            ||
            (!*pszPath)
            )
        {
            *pszComponent = TEXT('\0');

            PathCleanupSpec(NULL, szComponent);
            PathCombine(pszCleanPath, pszCleanPath, szComponent);

            bCleaned = TRUE;

            if (*pszPath)
            {
                // Reset for the next component
                pszComponent = szComponent;
                *pszComponent = TEXT('\0');
                pszPath = CharNext(pszPath);
            }
            else
                break;
        }
        else
        {
            LPTSTR pszNextChar = CharNext(pszPath);
            while (pszPath < pszNextChar)
            {
                *pszComponent++ = *pszPath++;
            }
        }
    }

    return bCleaned;
}
//
// Is the given path from the recycle bin?
//

BOOL IsRecycleBinPath(LPCTSTR pszPath)
{
    ASSERT(pszPath);

    //
    // "RECYCLED" is hard coded in bitbuck.c in shell32
    //

    TCHAR* pszRootless = PathSkipRoot(pszPath);

    return (pszRootless ? (0 == StrNCmpI(TEXT("RECYCLED"), pszRootless, 8)) : FALSE);
}

////////////////////////////////////////////////////////////////////////////////
//
// ICopyHook::CopyCallback
//
// Either allows the shell to move, copy, delete, or rename a folder or printer
// object, or disallows the shell from carrying out the operation. The shell 
// calls each copy hook handler registered for a folder or printer object until
// either all the handlers have been called or one of them returns IDCANCEL.
//
// RETURNS:
//
//  IDYES    - Allows the operation.
//  IDNO     - Prevents the operation on this file, but continues with any other
//             operations (for example, a batch copy operation).
//  IDCANCEL - Prevents the current operation and cancels any pending operations
//
////////////////////////////////////////////////////////////////////////////////
UINT CChannelMgr::CopyCallback(
    HWND hwnd,          // Handle of the parent window for displaying UI objects
    UINT wFunc,         // Operation to perform. 
    UINT wFlags,        // Flags that control the operation 
    LPCTSTR pszSrcFile,  // Pointer to the source file 
    DWORD dwSrcAttribs, // Source file attributes 
    LPCTSTR pszDestFile, // Pointer to the destination file 
    DWORD dwDestAttribs // Destination file attributes 
)
{
    HRESULT hr;

    //
    // Return immediately if this isn't a delete of a system folder
    // Redundant check as this should be made in shdocvw
    //
    if (!(dwSrcAttribs & FILE_ATTRIBUTE_SYSTEM) ||
        !(dwSrcAttribs & FILE_ATTRIBUTE_DIRECTORY))
    {
        return IDYES;
    }

    //
    // Build a string containing the guid to check for in the desktop.ini
    //
    TCHAR szFolderGUID[GUID_STR_LEN];
    TCHAR szCDFViewGUID[GUID_STR_LEN];
    SHStringFromGUID(CLSID_CDFINI, szCDFViewGUID, ARRAYSIZE(szCDFViewGUID));

    //
    // Build path to desktop.ini in folder
    //
    TCHAR szPath[MAX_PATH]; 
    if (!PathCombine(szPath, pszSrcFile, TEXT("desktop.ini")))
    {
        return IDYES;
    }

    //
    // Read CLSID from desktop.ini if present
    //
    GetPrivateProfileString(
        TEXT(".ShellClassInfo"),
        TEXT("CLSID"),
        TEXT(""), 
        szFolderGUID, 
        ARRAYSIZE(szFolderGUID), 
        szPath);

    if (StrEql(szFolderGUID, szCDFViewGUID))
    {
        //
        // We are deleting/renaming a  folder that has the system bit set and 
        // desktop.ini that contains the CLSID for the CDFINI handler, so it
        // must be a channel
        //

        //
        // Find URL to CDF from desktop.ini
        //
        TCHAR szCDFURL[INTERNET_MAX_URL_LENGTH];
        WCHAR wszCDFURL[INTERNET_MAX_URL_LENGTH];
        GetPrivateProfileString(
            TEXT("Channel"),
            TEXT("CDFURL"),
            TEXT(""), 
            szCDFURL, 
            ARRAYSIZE(szCDFURL), 
            szPath);

        switch(wFunc)
        {
        case FO_RENAME:
            //Reg_RemoveChannel(pszSrcFile);
            //Reg_WriteChannel(pszDestFile, szCDFURL);
            break;

        case FO_COPY:
            //Reg_WriteChannel(pszDestFile, szCDFURL);
            break;

        case FO_MOVE:
            //Reg_RemoveChannel(pszSrcFile);
            //Reg_WriteChannel(pszDestFile, szCDFURL);
            break;

        case FO_DELETE:
            TraceMsg(TF_GENERAL, "Deleting a channel");

            //
            // Check if there is a shell restriction against remove channel(s)
            //
            if (SHRestricted2(REST_NoRemovingChannels, szCDFURL, 0) ||
                SHRestricted2(REST_NoEditingChannels,  szCDFURL, 0)    )
            {
                TraceMsg(TF_GENERAL, "Channel Delete blocked by shell restriction");
                return IDNO;
            }
            else if (!IsRecycleBinPath(pszSrcFile))
            {
                //
                // Delete the in memory cache entry for this url.
                //

                Cache_RemoveItem(szCDFURL);

                //
                // Delete the wininet cache entry for this cdf.
                //

                DeleteUrlCacheEntry(szCDFURL);

                //
                // Remove the channel from the registry.
                //

                //Reg_RemoveChannel(pszSrcFile);
                //
                // Convert UrlToCdf to wide str, and then to bstr
                //
                SHTCharToUnicode(szCDFURL, wszCDFURL, INTERNET_MAX_URL_LENGTH);
                BSTR bstrCDFURL = SysAllocString(wszCDFURL);

                if (bstrCDFURL)
                {
                    //
                    // Create the subscription manager
                    //
                    ISubscriptionMgr* pISubscriptionMgr = NULL;
                    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                                      CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr,
                                      (void**)&pISubscriptionMgr);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Delete the actual subscription to the CDF
                        //
                        hr = pISubscriptionMgr->DeleteSubscription(bstrCDFURL,NULL);

                        TraceMsg(TF_GENERAL, 
                                 SUCCEEDED(hr) ? 
                                 "DeleteSubscription Succeeded" :
                                 "DeleteSubscription Failed");

                        pISubscriptionMgr->Release();
                    }
                    SysFreeString(bstrCDFURL);
                }
            }
            break;

        default:
            break;
        }
    }
    return IDYES;
}

#ifdef UNICODE
UINT CChannelMgr::CopyCallback(
    HWND hwnd,          // Handle of the parent window for displaying UI objects
    UINT wFunc,         // Operation to perform. 
    UINT wFlags,        // Flags that control the operation 
    LPCSTR pszSrcFile,  // Pointer to the source file 
    DWORD dwSrcAttribs, // Source file attributes 
    LPCSTR	pszDestFile, // Pointer to the destination file 
    DWORD dwDestAttribs // Destination file attributes 
)
{
    WCHAR  wszSrcFile[MAX_PATH];
    WCHAR  wszDestFile[MAX_PATH];

    SHAnsiToUnicode(pszSrcFile, wszSrcFile, ARRAYSIZE(wszSrcFile));
    SHAnsiToUnicode(pszDestFile, wszDestFile, ARRAYSIZE(wszDestFile));
    return CopyCallback(hwnd, wFunc, wFlags, wszSrcFile, dwSrcAttribs, wszDestFile, dwDestAttribs);
}
#endif

HRESULT Channel_CreateILFromPath(LPCTSTR pszPath, LPITEMIDLIST* ppidl)
{
    ASSERT(pszPath);
    ASSERT(ppidl);

    HRESULT hr;

    IShellFolder* pIShellFolder;

    hr = SHGetDesktopFolder(&pIShellFolder);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIShellFolder);

        WCHAR wszPath[MAX_PATH];

        if (SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath)))
        {
            ULONG ucch;

            hr = pIShellFolder->ParseDisplayName(NULL, NULL, wszPath, &ucch,
                                                 ppidl, NULL);
        }
        else
        {
            hr = E_FAIL;
        }

        pIShellFolder->Release();
    }

    return hr;
}


HRESULT GetChannelIconInfo(LPCTSTR pszPath, LPTSTR pszHashItem, int* piIndex,
                              UINT* puFlags)
{
    ASSERT(pszPath);
    ASSERT(pszHashItem);
    ASSERT(piIndex);
    ASSERT(puFlags);

    HRESULT hr;

    IShellFolder* pdsktopIShellFolder;

    hr = SHGetDesktopFolder(&pdsktopIShellFolder);

    if (SUCCEEDED(hr))
    {
        ASSERT(pdsktopIShellFolder);

        LPITEMIDLIST pidl; 

        hr = Channel_CreateILFromPath(pszPath, &pidl);

        if (SUCCEEDED(hr))
        {
            ASSERT(pidl);
            ASSERT(!ILIsEmpty(pidl));
            ASSERT(!ILIsEmpty(_ILNext(pidl)));

            LPITEMIDLIST pidlLast = ILClone(ILFindLastID(pidl));

            if (pidlLast)
            {
                if (ILRemoveLastID(pidl))
                {
                    IShellFolder* pIShellFolder;

                    hr = pdsktopIShellFolder->BindToObject(pidl, NULL,
                                                           IID_IShellFolder,
                                                        (void**)&pIShellFolder);

                    if (SUCCEEDED(hr))
                    {
                        ASSERT(pIShellFolder);

                        IExtractIcon* pIExtractIcon;

                        hr = pIShellFolder->GetUIObjectOf(NULL, 1,
                                                      (LPCITEMIDLIST*)&pidlLast,
                                                      IID_IExtractIcon,
                                                      NULL,
                                                      (void**)&pIExtractIcon);

                        if (SUCCEEDED(hr))
                        {
                            ASSERT(pIExtractIcon);

                            hr = pIExtractIcon->GetIconLocation(0, pszHashItem,
                                                                MAX_PATH,
                                                                piIndex,
                                                                puFlags);
                                                                

                            pIExtractIcon->Release();
                        }

                        pIShellFolder->Release();
                    }

                }

                ILFree(pidlLast);
            }

            ILFree(pidl);
        }

        pdsktopIShellFolder->Release();
    }

    return hr;
}

HRESULT PreUpdateChannelImage(LPCTSTR pszPath, LPTSTR pszHashItem, int* piIndex,
                              UINT* puFlags, int* piImageIndex)
{
    ASSERT(pszPath);
    ASSERT(pszHashItem);
    ASSERT(piIndex);
    ASSERT(puFlags);
    ASSERT(piImageIndex);

    HRESULT hr;

    TraceMsg(TF_GLEAM, "Pre     SHChangeNotify %s", pszPath);

    hr = GetChannelIconInfo(pszPath, pszHashItem, piIndex, puFlags);

    if (SUCCEEDED(hr))
    {
        SHFILEINFO fi = {0};

        if (SHGetFileInfo(pszPath, 0, &fi, sizeof(SHFILEINFO),
                          SHGFI_SYSICONINDEX))
        {
            *piImageIndex = fi.iIcon;
        }
        else
        {
            *piImageIndex = -1;
        }
    }

    return hr;
}

//
// UpdateChannelImage is a copy of _SHUpdateImageW found in shdocvw\util.cpp!
//

void UpdateChannelImage(LPCWSTR pszHashItem, int iIndex, UINT uFlags,
                        int iImageIndex)
{
    SHChangeUpdateImageIDList rgPidl;
    SHChangeDWORDAsIDList rgDWord;

    int cLen = MAX_PATH - (lstrlenW( pszHashItem ) + 1);
    cLen *= sizeof( WCHAR );

    if ( cLen < 0 )
        cLen = 0;

    // make sure we send a valid index
    if ( iImageIndex == -1 )
        iImageIndex = II_DOCUMENT;

    rgPidl.dwProcessID = GetCurrentProcessId();
    rgPidl.iIconIndex = iIndex;
    rgPidl.iCurIndex = iImageIndex;
    rgPidl.uFlags = uFlags;
    StrCpyNW( rgPidl.szName, pszHashItem, ARRAYSIZE(rgPidl.szName) );
    rgPidl.cb = (USHORT)(sizeof( rgPidl ) - cLen);
    _ILNext( (LPITEMIDLIST) &rgPidl )->mkid.cb = 0;

    rgDWord.cb = sizeof( rgDWord) - sizeof(USHORT);
    rgDWord.dwItem1 = (DWORD) iImageIndex;
    rgDWord.dwItem2 = 0;
    rgDWord.cbZero = 0;

    TraceMsg(TF_GLEAM, "Sending SHChangeNotify %S,%d (image index %d)",
             pszHashItem, iIndex, iImageIndex);

    // pump it as an extended event
    SHChangeNotify(SHCNE_UPDATEIMAGE, SHCNF_IDLIST | SHCNF_FLUSH, &rgDWord,
                   &rgPidl);
    
    return;
}

HRESULT UpdateImage(LPCTSTR pszPath)
{
    ASSERT(pszPath);

    HRESULT hr;

    TCHAR  szHash[MAX_PATH];
    int   iIndex;
    UINT  uFlags;
    int   iImageIndex;
    
    hr = PreUpdateChannelImage(pszPath, szHash, &iIndex, &uFlags, &iImageIndex);

    if (SUCCEEDED(hr))
    {
        WCHAR wszHash[MAX_PATH];
        SHTCharToUnicode(szHash, wszHash, ARRAYSIZE(wszHash));

        UpdateChannelImage(wszHash, iIndex, uFlags, iImageIndex);
    }

    return hr;
}

//
// Determines if the channel is installed on the system.
//

BOOL
Channel_IsInstalled(
    LPCWSTR pszURL
)
{
    ASSERT(pszURL);

    BOOL fRet = FALSE;

    CChannelEnum* pCChannelEnum = new CChannelEnum(CHANENUM_CHANNELFOLDER |
                                                   CHANENUM_SOFTUPDATEFOLDER,
                                                   pszURL);

    if (pCChannelEnum)
    {
        CHANNELENUMINFO ci;

        fRet =  (S_OK == pCChannelEnum->Next(1, &ci, NULL));

        pCChannelEnum->Release();
    }

    return fRet;
}

HRESULT
Channel_WriteScreenSaverURL(
    LPCWSTR pszURL,
    LPCWSTR pszScreenSaverURL
)
{
    ASSERT(pszURL);

    HRESULT hr = S_OK;

#ifndef UNIX

    CChannelEnum* pCChannelEnum = new CChannelEnum(CHANENUM_CHANNELFOLDER |
                                                   CHANENUM_SOFTUPDATEFOLDER |
                                                   CHANENUM_PATH,
                                                   pszURL);
    if (pCChannelEnum)
    {
        CHANNELENUMINFO ci;

        if (S_OK == pCChannelEnum->Next(1, &ci, NULL))
        {
            TCHAR szDesktopINI[MAX_PATH];
            TCHAR szScreenSaverURL[INTERNET_MAX_URL_LENGTH];
            
            ASSERT(ci.pszPath);

            if (pszScreenSaverURL)
            {
                SHUnicodeToTChar(pszScreenSaverURL, szScreenSaverURL, ARRAYSIZE(szScreenSaverURL));
            }

            SHUnicodeToTChar(ci.pszPath, szDesktopINI, ARRAYSIZE(szDesktopINI));

            if (PathCombine(szDesktopINI, szDesktopINI, c_szDesktopINI))
            {
                WritePrivateProfileString(c_szChannel, 
                                          c_szScreenSaverURL, 
                                          pszScreenSaverURL ? szScreenSaverURL : NULL, 
                                          szDesktopINI);
            }

            CoTaskMemFree(ci.pszPath);
        }
        else
        {
            hr = E_FAIL;
        }

        pCChannelEnum->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

#endif /* !UNIX */

    return hr;
}

HRESULT Channel_GetAndWriteScreenSaverURL(LPCTSTR pszURL, LPCTSTR pszDesktopINI)
{
    HRESULT hr = S_OK;

#ifndef UNIX
    
    CCdfView* pCCdfView = new CCdfView;

    if (NULL != pCCdfView)
    {
        WCHAR wszURL[INTERNET_MAX_URL_LENGTH];

        SHTCharToUnicode(pszURL, wszURL, ARRAYSIZE(wszURL));
        
        if (SUCCEEDED(pCCdfView->Load(wszURL, 0)))
        {
            IXMLDocument* pIXMLDocument;

            if (SUCCEEDED(pCCdfView->ParseCdf(NULL, &pIXMLDocument, PARSE_LOCAL)))
            {
                BSTR bstrSSUrl;
                TCHAR szSSURL[INTERNET_MAX_URL_LENGTH];
                TCHAR *pszScreenSaverURL = NULL;
                
                ASSERT(NULL != pIXMLDocument);

                if (SUCCEEDED(XML_GetScreenSaverURL(pIXMLDocument, &bstrSSUrl)))
                {
                    SHUnicodeToTChar(bstrSSUrl, szSSURL, ARRAYSIZE(szSSURL));
                    pszScreenSaverURL = szSSURL;
                    TraceMsg(TF_GENERAL,  "CDFVIEW: %ws has screensaver URL=%ws", wszURL, bstrSSUrl);
                    SysFreeString(bstrSSUrl);
                }
                else
                {
                    TraceMsg(TF_GENERAL,  "CDFVIEW: %ws has no screensaver URL", wszURL);
                }

                WritePrivateProfileString(c_szChannel, 
                                          c_szScreenSaverURL, 
                                          pszScreenSaverURL, 
                                          pszDesktopINI);
                pIXMLDocument->Release();
            }
            else
            {
                TraceMsg(TF_GENERAL,  "CDFVIEW: cdf parse failed %ws", wszURL);
            }
        }
        else
        {
            TraceMsg(TF_GENERAL,  "CDFVIEW: Couldn't load cdf %ws", wszURL);
        }

        pCCdfView->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

#endif /* !UNIX */

    return hr;
}

HRESULT Channel_RefreshScreenSaverURLs()
{
    HRESULT hr = S_OK;

#ifndef UNIX

    CChannelEnum* pCChannelEnum = new CChannelEnum(CHANENUM_CHANNELFOLDER |
                                                   CHANENUM_SOFTUPDATEFOLDER |
                                                   CHANENUM_PATH | 
                                                   CHANENUM_URL,
                                                   NULL);
    if (pCChannelEnum)
    {
        CHANNELENUMINFO ci;

        while (S_OK == pCChannelEnum->Next(1, &ci, NULL))
        {
            TCHAR szDesktopINI[MAX_PATH];
            TCHAR szURL[INTERNET_MAX_URL_LENGTH];

            ASSERT(ci.pszPath);
            ASSERT(ci.pszURL);

            SHUnicodeToTChar(ci.pszPath, szDesktopINI, ARRAYSIZE(szDesktopINI));
            SHUnicodeToTChar(ci.pszURL, szURL, ARRAYSIZE(szURL));

            if (PathCombine(szDesktopINI, szDesktopINI, c_szDesktopINI))
            {
                Channel_GetAndWriteScreenSaverURL(szURL, szDesktopINI);
            }

            CoTaskMemFree(ci.pszPath);
            CoTaskMemFree(ci.pszURL);
        }

        pCChannelEnum->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

#endif /* !UNIX */

    return hr;
}
    
//
// Finds the path of the channel in the channels folder that has the given url.
//

LPOLESTR
Channel_GetChannelPanePath(
    LPCWSTR pszURL
)
{
    ASSERT(pszURL);

    LPOLESTR pstrRet = NULL;

    CChannelEnum* pCChannelEnum = new CChannelEnum(CHANENUM_CHANNELFOLDER |
                                                   CHANENUM_PATH, pszURL);

    if (pCChannelEnum)
    {
        CHANNELENUMINFO ci;

        if (S_OK == pCChannelEnum->Next(1, &ci, NULL))
            pstrRet = ci.pszPath;

        pCChannelEnum->Release();
    }

    return pstrRet;
}

//
// Send SHChangeNotify for agiven URL.
//

void Channel_SendUpdateNotifications(LPCWSTR pwszURL)
{
    CChannelEnum* pCChannelEnum = new CChannelEnum(
                                            CHANENUM_CHANNELFOLDER |
                                            CHANENUM_PATH,
                                            pwszURL);

    if (pCChannelEnum)
    {
        CHANNELENUMINFO ci;

        while (S_OK == pCChannelEnum->Next(1, &ci, NULL))
        {
            TCHAR szPath[MAX_PATH];

            if (SHUnicodeToTChar(ci.pszPath, szPath, ARRAYSIZE(szPath)))
            {
                //
                // Clearing the gleam flag will result in a SHCNE_UPDATEIMAGE
                // notification.
                //

                TCHAR szURL[INTERNET_MAX_URL_LENGTH];

                if (SHUnicodeToTChar(pwszURL, szURL, ARRAYSIZE(szURL)))
                    ClearGleamFlag(szURL, szPath);

                SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, (void*)szPath,
                               NULL);
            }

            CoTaskMemFree(ci.pszPath);
        }

        pCChannelEnum->Release();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\chanenum.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// chanenum.h 
//
//   The definition of the channel enumerator.
//
//   History:
//
//       8/6/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _CHANENUM_H_

#define _CHANENUM_H_

/*
//
// Defines
//

#define TSTR_CHANNEL_KEY   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Channels")

//
// Helper functions.
//

HKEY    Reg_GetChannelKey(void);
HRESULT Reg_WriteChannel(LPCTSTR pszPath,LPCTSTR pszURL);
HRESULT Reg_RemoveChannel(LPCTSTR pszPath);
*/

//
// Structures.
//

typedef struct _tagSTACKENTRY
{
    LPTSTR          pszPath;
    _tagSTACKENTRY* pNext;
} STACKENTRY;

typedef enum _tagINIVALUE
{
    INI_GUID = 0,
    INI_URL  = 1
} INIVALUE;        


//
// Class definition for the channel enumerator class.
//


class CChannelEnum : public IEnumChannels
{

//
// Methods
//

public:

    // Constructor
    CChannelEnum(DWORD dwEnumFlags, LPCWSTR pszURL);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, CHANNELENUMINFO* rgInfo, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumChannels **ppenum);
 
private:

    // Destructor
    ~CChannelEnum(void);

    // Helper methods
    inline BOOL DirectoryStack_IsEmpty(void);
    void        DirectoryStack_FreeEntry(STACKENTRY* pse);
    void        DirectoryStack_FreeStack(void);
    STACKENTRY* DirectoryStack_Pop(void);
    BOOL        DirectoryStack_Push(LPCTSTR pszPath);
    BOOL        DirectoryStack_InitFromFlags(DWORD dwEnumFlags);
    BOOL        DirectoryStack_PushSubdirectories(LPCTSTR pszPath);

    BOOL        FindNextChannel(CHANNELENUMINFO* pInfo);
    BOOL        ReadChannelInfo(LPCTSTR pszPath, CHANNELENUMINFO* pInfo);
    BOOL        ContainsChannelDesktopIni(LPCTSTR pszPath);
    BOOL        URLMatchesIni(LPCTSTR pszPath, LPCTSTR pszURL);
    BOOL        ReadFromIni(LPCTSTR pszPath, LPTSTR pszOut, int cch, INIVALUE iv);
    LPOLESTR    OleAllocString(LPCTSTR psz);

    SUBSCRIPTIONSTATE GetSubscriptionState(LPCTSTR pszURL);

//
// Member variables.
//

private:

    ULONG        m_cRef;
    STACKENTRY*  m_pseDirectoryStack;
    LPTSTR       m_pszURL;
    DWORD        m_dwEnumFlags;
};


#endif // _CHANENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\chanmenu.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// chanmenu.h 
//
//   Conext menu interface for items.
//
//   History:
//
//       3/26/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _CHANMENU_H_

#define _CHANMENU_H_

//
// Class definition for the item context menu class.
//

class CChannelMenu : public IContextMenu,
                     public IShellExtInit
{
//
// Methods
//

public:

    // Constructor
    CChannelMenu(void);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IContextMenu methods.
    STDMETHODIMP QueryContextMenu(HMENU hmenu,
                                  UINT indexMenu,
                                  UINT idCmdFirst,
                                  UINT idCmdLast,
                                  UINT uFlags);

    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    STDMETHODIMP GetCommandString(UINT_PTR idCommand,
                                  UINT uFLags,
                                  UINT *pwReserved,
                                  LPSTR pszName,
                                  UINT cchMax);

    // ISHelExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl, LPDATAOBJECT pdobj, HKEY hkey);

private:

    // Destructor.
    ~CChannelMenu(void);

    // Helper functions.
    void RemoveMenuItems(HMENU hmenu);
    void Refresh(HWND hwnd);
    void ViewSource(HWND hwnd);
    HRESULT Subscribe(HWND hwnd);


//
// Member variables.
//

private:

    ULONG             m_cRef;
    ISubscriptionMgr* m_pSubscriptionMgr;
    BSTR              m_bstrURL;
    BSTR              m_bstrName;
    TCHAR             m_szPath[MAX_PATH];
    TASK_TRIGGER      m_tt;
    SUBSCRIPTIONINFO  m_si;
};


#endif // _CHANMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\chanenum.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// chanenum.cpp 
//
//   The enumerator object for channels.
//
//   History:
//
//       8/7/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//
                                                                                    
#include "stdinc.h"
#include "chanenum.h"
#include "cdfidl.h"
#include "xmlutil.h"
#include "chanapi.h"
#include "dll.h"

//
// Helper functions.
//

//
// Constructor and destructor.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::CChannelEnum ***
//
//    Constructor.
//
////////////////////////////////////////////////////////////////////////////////
CChannelEnum::CChannelEnum (
    DWORD dwEnumFlags,
    LPCWSTR pszURL
)
: m_cRef(1)
{
    ASSERT(NULL == m_pseDirectoryStack);

    TraceMsg(TF_OBJECTS, "+ IEnumChannels");

    if (pszURL)
    {
        int cch = StrLenW(pszURL) + 1;

        m_pszURL = new TCHAR[cch];

        SHUnicodeToTChar(pszURL, m_pszURL, cch);
    }

    m_dwEnumFlags = dwEnumFlags;

    DirectoryStack_InitFromFlags(dwEnumFlags);

    DllAddRef();

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::~CChannelEnum **
//
//    Destructor.
//
////////////////////////////////////////////////////////////////////////////////
CChannelEnum::~CChannelEnum(
    void
)
{
    TraceMsg(TF_OBJECTS, "- IEnumChannels");

    if (m_pszURL)
        delete []m_pszURL;

    DirectoryStack_FreeStack();

    DllRelease();

    return;
}

//
// IUnknown methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::CChannelEnum ***
//
//    CChannelEnum QI.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CChannelEnum::QueryInterface (
    REFIID riid,
    void **ppv
)
{
    ASSERT(ppv);

    HRESULT hr;

    if (IID_IUnknown == riid || IID_IEnumChannels == riid)
    {
        AddRef();
        *ppv = (IEnumChannels*)this;
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && NULL == *ppv));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::AddRef ***
//
//    CChannelEnum AddRef.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CChannelEnum::AddRef (
    void
)
{
    ASSERT(m_cRef != 0);
    ASSERT(m_cRef < (ULONG)-1);

    return ++m_cRef;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::Release ***
//
//    Cdf view Release.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CChannelEnum::Release (
    void
)
{
    ASSERT (m_cRef != 0);

    ULONG cRef = --m_cRef;
    
    if (0 == cRef)
        delete this;

    return cRef;
}


//
// IEnumIDList methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::Next ***
//
//
// Description:
//     Returns the next n item id lists associated with this enumerator.
//
// Parameters:
//     [in]  celt         - Number of item id lists to return.
//     [Out] rgelt        - A pointer to an array of item id list pointers that
//                          will receive the id item lists.
//     [Out] pceltFetched - A pointer to a ULONG that receives a count of the
//                          number of id lists fetched.
//
// Return:
//     S_OK if celt items where fetched.
//     S_FALSE if celt items where not fetched.
//
// Comments:
//     
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CChannelEnum::Next(
    ULONG celt,	
    CHANNELENUMINFO* rgelt,	
    ULONG* pceltFetched)
{
    ASSERT(rgelt || 0 == celt);
    ASSERT(pceltFetched || 1 == celt);

    //
    // pceltFetched can be NULL if and only if celt is 1.
    //

    ULONG lFetched;

    if (1 == celt && NULL == pceltFetched)
        pceltFetched = &lFetched;

    for (*pceltFetched = 0; *pceltFetched < celt; (*pceltFetched)++)
    {
        if (!FindNextChannel(&rgelt[*pceltFetched]))
            break;
    }

    return (*pceltFetched == celt) ? S_OK : S_FALSE;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::Skip ***
//
//   Shell doesn't call this member.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CChannelEnum::Skip(
    ULONG celt)
{
    CHANNELENUMINFO ci = {0};

    //
    // Don't alocated any data on the FindNextChannel call.
    //

    DWORD dwOldFlags = m_dwEnumFlags;
    m_dwEnumFlags = 0;

    while (celt && FindNextChannel(&ci))
        celt--;

    m_dwEnumFlags = dwOldFlags;

    return 0 == celt ? S_OK : S_FALSE;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::Reset ***
//
//   Set the current item to the index of the first item in CFolderItems.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CChannelEnum::Reset(
    void
)
{
    DirectoryStack_FreeStack();
    DirectoryStack_InitFromFlags(m_dwEnumFlags);

    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::Clone ***
//
//   Shell doesn't call this method.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CChannelEnum::Clone(
    IEnumChannels **ppenum
)
{
    return E_NOTIMPL;
}

//
// Directory stack functions.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::DirectoryStack_IsEmpty ***
//
// Is the stack empty.
//
////////////////////////////////////////////////////////////////////////////////
inline BOOL
CChannelEnum::DirectoryStack_IsEmpty(
    void
)
{
    return NULL == m_pseDirectoryStack;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::DirectoryStack_FreeEntry ***
//
// Free a stack entry item.
//
////////////////////////////////////////////////////////////////////////////////
void
CChannelEnum::DirectoryStack_FreeEntry(
    STACKENTRY* pse
)
{
    ASSERT(pse)
    ASSERT(pse->pszPath);
    ASSERT(!pse->pNext);

    delete []pse->pszPath;
    delete pse;

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::DirectoryStack_FreeStack ***
//
// Free all items on the stack.
//
////////////////////////////////////////////////////////////////////////////////
void
CChannelEnum::DirectoryStack_FreeStack(
    void
)
{
    while (!DirectoryStack_IsEmpty())
        DirectoryStack_FreeEntry(DirectoryStack_Pop());

    return;
}



//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::DirectoryStack_Pop ***
//
// Remove an item from the stack.  The caller must free the item.
//
////////////////////////////////////////////////////////////////////////////////
STACKENTRY*
CChannelEnum::DirectoryStack_Pop(
    void
)
{
    STACKENTRY* pse = m_pseDirectoryStack;

    if (m_pseDirectoryStack)
    {
        m_pseDirectoryStack = m_pseDirectoryStack->pNext;
        pse->pNext = NULL;
    }

    return pse;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::DirectoryStack_Push ***
//
// Put a new directory on the stack.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CChannelEnum::DirectoryStack_Push(
    LPCTSTR pszPath
)
{
    ASSERT(pszPath);

    BOOL fRet = FALSE;

    STACKENTRY* pse = new STACKENTRY;

    if (pse)
    {
        DWORD cchPath = StrLen(pszPath) + 1;
        pse->pszPath = new TCHAR[cchPath];

        if (pse->pszPath)
        {
            StrCpyN(pse->pszPath, pszPath, cchPath);
            
            pse->pNext = m_pseDirectoryStack;
            m_pseDirectoryStack = pse;

            fRet = TRUE;
        }
        else
        {
            delete pse;
        }
    }

    return fRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::DirectoryStack_IntitFromFlags ***
//
// Put initial search directories on the stack.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CChannelEnum::DirectoryStack_InitFromFlags(
    DWORD dwEnumFlags
)
{
    ASSERT(NULL == m_pseDirectoryStack);

    TCHAR szPath[MAX_PATH];

    szPath[0] = 0;

    if (dwEnumFlags & CHANENUM_DESKTOPFOLDER)
    {
        LPITEMIDLIST pidl;

        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY,
                                                 &pidl)))
        {
            ASSERT(pidl);

            if (SHGetPathFromIDList(pidl, szPath))
                DirectoryStack_Push(szPath);

            ILFree(pidl);
        }
    }

    if (dwEnumFlags & CHANENUM_CHANNELFOLDER)
    {
        if (SUCCEEDED(Channel_GetFolder(szPath, ARRAYSIZE(szPath), DOC_CHANNEL)))
            DirectoryStack_Push(szPath);
    }

    if (dwEnumFlags & CHANENUM_SOFTUPDATEFOLDER)
    {
        TCHAR szSoftDistFolder[MAX_PATH];

        if (SUCCEEDED(Channel_GetFolder(szSoftDistFolder, ARRAYSIZE(szSoftDistFolder), DOC_SOFTWAREUPDATE)) &&
            (StrCmpI(szSoftDistFolder, szPath) != 0))
        {
            DirectoryStack_Push(szSoftDistFolder);
        }
    }

    return m_pseDirectoryStack != NULL;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::DirectoryStack_PushSubdirectories ***
//
// Put all subdirectories of the given directory on to the stack.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CChannelEnum::DirectoryStack_PushSubdirectories(
    LPCTSTR pszPath
)
{
    ASSERT(pszPath);

    BOOL fRet = FALSE;
 
    TCHAR szBuffer[MAX_PATH];
    int   cch = StrLen(pszPath);

    StrCpyN(szBuffer, pszPath, ARRAYSIZE(szBuffer));
#ifndef UNIX
    StrCatBuff(szBuffer, TEXT("\\*.*"), ARRAYSIZE(szBuffer));
#else
    StrCatBuff(szBuffer, TEXT("/*"), ARRAYSIZE(szBuffer));
#endif /* UNIX */

    WIN32_FIND_DATA fd;

    HANDLE hSearch = FindFirstFile(szBuffer, &fd);

    if (INVALID_HANDLE_VALUE != hSearch)
    {
        if (cch < ARRAYSIZE(szBuffer) - 2)
        {
            do {
                if ((FILE_ATTRIBUTE_DIRECTORY & fd.dwFileAttributes) &&
                    !StrEql(fd.cFileName, TEXT("."))                 &&
                    !StrEql(fd.cFileName, TEXT(".."))                   )
                {
                    StrCpyN(szBuffer + cch + 1, fd.cFileName,
                            ARRAYSIZE(szBuffer) - cch - 1);

                    if (DirectoryStack_Push(szBuffer))
                        fRet = TRUE;
                }

            } while (TRUE == FindNextFile(hSearch, &fd));
        }

        FindClose(hSearch);
    }

    return fRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::FindNextChannel ***
//
// Find the next channel.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CChannelEnum::FindNextChannel(
    CHANNELENUMINFO* pInfo
)
{
    ASSERT(pInfo);

    BOOL fRet;

    if (DirectoryStack_IsEmpty())
    {
        fRet = FALSE;
    }
    else
    {
        STACKENTRY* pse = DirectoryStack_Pop();

        DirectoryStack_PushSubdirectories(pse->pszPath);

        if (ReadChannelInfo(pse->pszPath, pInfo))
        {
            fRet = TRUE;
        }
        else
        {
            fRet = FindNextChannel(pInfo);
        }

        DirectoryStack_FreeEntry(pse);
    }

    return fRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::FindNextChannel ***
//
// Find the next channel.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CChannelEnum::ReadChannelInfo(
    LPCTSTR pszPath,
    CHANNELENUMINFO* pInfo
)
{
    ASSERT(pszPath);
    ASSERT(pInfo);

    BOOL fRet = FALSE;

    DWORD dwAttributes = GetFileAttributes(pszPath);

#ifndef UNIX
    if ((-1 != dwAttributes) && (FILE_ATTRIBUTE_SYSTEM & dwAttributes))
#else
    if ((-1 != dwAttributes)) 
#endif /* UNIX */
    {
        if (ContainsChannelDesktopIni(pszPath))
        {
            if (NULL == m_pszURL || URLMatchesIni(pszPath, m_pszURL))
            {
                fRet = TRUE;

                TCHAR szURL[INTERNET_MAX_URL_LENGTH];
                szURL[0] = 0;

                if (m_dwEnumFlags & CHANENUM_TITLE)
                    pInfo->pszTitle = OleAllocString(PathFindFileName(pszPath));

                if (m_dwEnumFlags & CHANENUM_PATH)
                    pInfo->pszPath = OleAllocString(pszPath);

                if (m_dwEnumFlags & CHANENUM_URL)
                {
                    ReadFromIni(pszPath, szURL, ARRAYSIZE(szURL), INI_URL);

                    pInfo->pszURL = OleAllocString(szURL);
                }

                if (m_dwEnumFlags & CHANENUM_SUBSCRIBESTATE)
                {
                    if (TEXT('\0') == *szURL)
                        ReadFromIni(pszPath, szURL, ARRAYSIZE(szURL), INI_URL);

                    pInfo->stSubscriptionState = GetSubscriptionState(szURL);
                }
            }
        }
    }

    return fRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::ContainsChannelDesktopIni ***
//
// See if the directory contains a "channel" desktop.ini
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CChannelEnum::ContainsChannelDesktopIni(
    LPCTSTR pszPath
)
{
    ASSERT(pszPath);

    BOOL fRet = FALSE;

    TCHAR szFolderGUID[GUID_STR_LEN];

    if (ReadFromIni(pszPath, szFolderGUID, ARRAYSIZE(szFolderGUID), INI_GUID))
    {
        TCHAR szChannelGUID[GUID_STR_LEN];

        if (SHStringFromGUID(CLSID_CDFINI, szChannelGUID,
                             ARRAYSIZE(szChannelGUID)))
        {
            fRet = StrEql(szFolderGUID, szChannelGUID);
        }
    }

    return fRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::URLMatchesIni ***
//
// See if the given url matches the url in the desktop.ini
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CChannelEnum::URLMatchesIni(
    LPCTSTR pszPath,
    LPCTSTR pszURL
)
{
    ASSERT(pszPath);
    ASSERT(pszURL);

    BOOL fRet = FALSE;

    TCHAR szIniURL[INTERNET_MAX_URL_LENGTH];

    if (ReadFromIni(pszPath, szIniURL, ARRAYSIZE(szIniURL), INI_URL))
    {
        TCHAR szCanonicalURL[INTERNET_MAX_URL_LENGTH];
        DWORD cch = ARRAYSIZE(szCanonicalURL);

        if (InternetCanonicalizeUrl(szIniURL, szCanonicalURL, &cch, ICU_NO_ENCODE))
        {
            fRet = StrEql((LPTSTR)pszURL, szCanonicalURL);
        }
        else
        {
            fRet = StrEql((LPTSTR)pszURL, szIniURL);
        }
    }

    return fRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::ReadFromIni ***
//
// Read a value from the channel desktop.ini
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CChannelEnum::ReadFromIni(
    LPCTSTR pszPath,
    LPTSTR pszOut,
    int cch,
    INIVALUE iv
)
{
    BOOL fRet;

    static const struct _tagINISTRINGS
    {
        LPCTSTR  pszSection;
        LPCTSTR  pszKey;
        INIVALUE iv;
    }
    aIniTable[] =
    {
        {TEXT(".ShellClassInfo"), TEXT("CLSID"),  INI_GUID},
        {TEXT("Channel")        , TEXT("CDFURL"), INI_URL }
    };

    ASSERT(pszPath);
    ASSERT(pszOut || 0 == cch);
    ASSERT(aIniTable[iv].iv == iv);

    TCHAR szIniFile[MAX_PATH];

    if (PathCombine(szIniFile, pszPath, TEXT("desktop.ini")))
    {
        fRet = GetPrivateProfileString(aIniTable[iv].pszSection,
                                       aIniTable[iv].pszKey, TEXT(""), pszOut, cch,
                                       szIniFile);
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::OleAllocString ***
//
// Allocate an OLESTR for the given string.
//
////////////////////////////////////////////////////////////////////////////////
LPOLESTR
CChannelEnum::OleAllocString(
    LPCTSTR psz
)
{
    ASSERT(psz);

    int cch = StrLen(psz) + 1;

    LPOLESTR polestr = (LPOLESTR)CoTaskMemAlloc(cch * sizeof(WCHAR));

    if (polestr)
        SHTCharToUnicode(psz, polestr, cch);

    return polestr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CChannelEnum::GetSubscriptionState ***
//
// Read a value from the channel desktop.ini
//
////////////////////////////////////////////////////////////////////////////////
SUBSCRIPTIONSTATE
CChannelEnum::GetSubscriptionState(
    LPCTSTR pszURL
)
{
    ASSERT(pszURL);

    SUBSCRIPTIONSTATE stRet = SUBSTATE_NOTSUBSCRIBED;

    ISubscriptionMgr* pISubscriptionMgr;

    HRESULT hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                                  CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr,
                                  (void**)&pISubscriptionMgr);

    if (SUCCEEDED(hr))
    {
        ASSERT(pISubscriptionMgr);

        WCHAR wszURL[INTERNET_MAX_URL_LENGTH];

        if (SHTCharToUnicode(pszURL, wszURL, ARRAYSIZE(wszURL)))
        {
            BOOL fSubscribed = FALSE;

            pISubscriptionMgr->IsSubscribed(wszURL, &fSubscribed);

            if (fSubscribed)
            {
                stRet = SUBSTATE_PARTIALSUBSCRIPTION;

                SUBSCRIPTIONINFO si = { 0 };

                si.cbSize = sizeof SUBSCRIPTIONINFO;

                hr = pISubscriptionMgr->GetSubscriptionInfo(wszURL, &si);

                if (SUCCEEDED(hr))
                {
                    if (!(si.fChannelFlags & CHANNEL_AGENT_PRECACHE_SOME))
                        stRet = SUBSTATE_FULLSUBSCRIPTION;
                }

            }
        }

        pISubscriptionMgr->Release();
    }

    return stRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\chanmenu.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// Chanmenu.cpp 
//
//   IConextMenu for folder items.
//
//   History:
//
//       6/12/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "cdfidl.h"
#include "xmlutil.h"
#include "chanmenu.h"
#include "dll.h"
#include "persist.h"
#include "resource.h"
#include "chanapi.h"
#include "chanmgrp.h"
#include "chanmgri.h"
#define _SHDOCVW_
#include <shdocvw.h>

#include <mluisupp.h>



//
// Constructor and destructor.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::CContextMenu ***
//
//    Constructor for IContextMenu.
//
////////////////////////////////////////////////////////////////////////////////
CChannelMenu::CChannelMenu (
    void
)
: m_cRef(1)
{
    TraceMsg(TF_OBJECTS, "+ IContextMenu (root)");

    DllAddRef();

    ASSERT(NULL == m_pSubscriptionMgr);
    ASSERT(NULL == m_bstrURL);
    ASSERT(NULL == m_bstrName);

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::~CContextMenu ***
//
//    Destructor.
//
////////////////////////////////////////////////////////////////////////////////
CChannelMenu::~CChannelMenu (
    void
)
{
    ASSERT(0 == m_cRef);

    if (NULL != m_bstrURL)
        SysFreeString(m_bstrURL);

    if (NULL != m_bstrName)
        SysFreeString(m_bstrName);
        
    if (NULL != m_pSubscriptionMgr)
        m_pSubscriptionMgr->Release();
    //
    // Matching Release for the constructor Addref.
    //

    TraceMsg(TF_OBJECTS, "- IContextMenu (root)");

    DllRelease();

    return;
}


//
// IUnknown methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::CContextMenu ***
//
//    CExtractIcon QI.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CChannelMenu::QueryInterface (
    REFIID riid,
    void **ppv
)
{
    ASSERT(ppv);

    HRESULT hr;

    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IContextMenu == riid)
    {
        *ppv = (IContextMenu*)this;
    }
    else if (IID_IShellExtInit == riid)
    {
        *ppv = (IShellExtInit*)this;
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && NULL == *ppv));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::AddRef ***
//
//    CContextMenu AddRef.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CChannelMenu::AddRef (
    void
)
{
    ASSERT(m_cRef != 0);
    ASSERT(m_cRef < (ULONG)-1);

    return ++m_cRef;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::Release ***
//
//    CContextMenu Release.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CChannelMenu::Release (
    void
)
{
    ASSERT (m_cRef != 0);

    ULONG cRef = --m_cRef;
    
    if (0 == cRef)
        delete this;

    return cRef;
}


//
// IContextMenu methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::QueryContextMenu ***
//
//
// Description:
//     Adds menu items to the given item's context menu.
//
// Parameters:
//     [In Out]  hmenu      - A handle to the menu.  New items are inserted into
//                            this menu  
//     [In]      indexMenu  - Zero-based position at which to insert the first
//                            menu item.
//     [In]      idCmdFirst - Minimum value that can be used for a new menu item
//                            identifier. 
//     [In]      idCmdLast  - Maximum value the can be used for a menu item id.
//     [In]      uFlags     - CMF_DEFAULTONLY, CMF_EXPLORE, CMF_NORMAL or
//                            CMF_VERBSONLY.
//
// Return:
//     On success the scode contains the the menu identifier offset of the last
//     menu item added plus one.
//
// Comments:
//     CMF_DEFAULTONLY flag indicates the user double-clicked on the item.  In
//     this case no menu is displayed.  The shell is simply querying for the ID
//     of the default action.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CChannelMenu::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags
)
{
    HRESULT hr = S_OK;
    BOOL fSubscribed;
    HMENU hChannelMenu, hChannelSubMenu;
    
    ASSERT(hmenu);
    ASSERT(idCmdFirst < idCmdLast);

    if (!(CMF_DEFAULTONLY & uFlags))
    {   
        if (NULL != m_pSubscriptionMgr)
        {
            ASSERT(idCmdFirst + IDM_SUBSCRIBE < idCmdLast);

#ifndef UNIX
            if (CanSubscribe(m_bstrURL))
            {
                m_pSubscriptionMgr->IsSubscribed(m_bstrURL, &fSubscribed);
                if (fSubscribed)
                {
                    hChannelMenu = LoadMenu(MLGetHinst(), 
                                           MAKEINTRESOURCE(IDM_SUBSCRIBEDMENU));

                    if (SHRestricted2W(REST_NoRemovingSubscriptions, m_bstrURL, 0))
                    {
                        EnableMenuItem(hChannelMenu, IDM_SUBSCRIBE,
                                       MF_BYCOMMAND | MF_GRAYED);
                    }
                    
                    if (SHRestricted2W(REST_NoManualUpdates, m_bstrURL, 0))
                    {
                        EnableMenuItem(hChannelMenu, IDM_UPDATESUBSCRIPTION,
                                       MF_BYCOMMAND | MF_GRAYED);
                    }
                }
                else
                {
                    int idMenu = !SHRestricted2W(REST_NoAddingSubscriptions, 
                                                 m_bstrURL, 0) 
                                 ? IDM_UNSUBSCRIBEDMENU : IDM_NOSUBSCRIBEMENU;
                                  
                    hChannelMenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(idMenu));
                }
            }
            else
#endif /* !UNIX */
            {
                hChannelMenu = LoadMenu(MLGetHinst(),
                                          MAKEINTRESOURCE(IDM_NOSUBSCRIBEMENU));
            }

            if (NULL != hChannelMenu)
            {
                hChannelSubMenu = GetSubMenu(hChannelMenu, 0);

                if (NULL != hChannelSubMenu)
                {
                    hr = Shell_MergeMenus(hmenu, hChannelSubMenu, indexMenu,
                                          idCmdFirst, idCmdLast, MM_ADDSEPARATOR)
                                          - idCmdFirst;
                }
                else
                {
                    hr = E_FAIL;
                }
                DestroyMenu(hChannelMenu);
            }
            else
            {
                hr = E_FAIL;
            }
        }

        RemoveMenuItems(hmenu);
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::InvokeCommand ***
//
//
// Description:
//     Carries out the command for the given menu item id.
//
// Parameters:
//     [In]  lpici - Structure containing the verb, hwnd, menu id, etc.
//
// Return:
//     S_OK if the command was successful.
//     E_FAIL otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CChannelMenu::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici
)
{
    HRESULT hr = S_OK;
    
    ASSERT(lpici);

    if (HIWORD(lpici->lpVerb) == 0)
    {
        switch (LOWORD(lpici->lpVerb))
        {
            case IDM_UPDATESUBSCRIPTION:
                ASSERT(NULL != m_pSubscriptionMgr);
                m_pSubscriptionMgr->UpdateSubscription(m_bstrURL);
                break;
                           
            case IDM_SUBSCRIBE:
                ASSERT(NULL != m_pSubscriptionMgr);
                ASSERT( sizeof(SUBSCRIPTIONINFO) == m_si.cbSize);

                hr = Subscribe(lpici->hwnd);
                break;
                
            case IDM_UNSUBSCRIBE:
                ASSERT(NULL != m_pSubscriptionMgr);
                m_pSubscriptionMgr->DeleteSubscription(m_bstrURL, lpici->hwnd);
                break;

            case IDM_EDITSUBSCRIPTION:
                ASSERT(NULL != m_pSubscriptionMgr);
                m_pSubscriptionMgr->ShowSubscriptionProperties(m_bstrURL,
                                                               lpici->hwnd);
                break;

            case IDM_REFRESHCHANNEL:
                Refresh(lpici->hwnd);
                break;

            case IDM_VIEWSOURCE:
                ViewSource(lpici->hwnd);
                break;
        }
    }
    

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CContextMenu::GetCommandString ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CChannelMenu::GetCommandString(
    UINT_PTR idCommand,
    UINT uFLags,
    UINT *pwReserved,
    LPSTR pszName,
    UINT cchMax
)
{
    return E_NOTIMPL;
}

//
//
//

STDMETHODIMP
CChannelMenu::Initialize(
    LPCITEMIDLIST pidl,
    LPDATAOBJECT pdobj,
    HKEY hkey
)
{
    HRESULT hr;
    
    STGMEDIUM stgmed;
    FORMATETC fmtetc = {CF_HDROP, NULL, DVASPECT_CONTENT, -1,
                        TYMED_HGLOBAL};

    ASSERT(pdobj);
    
    hr = pdobj->GetData(&fmtetc, &stgmed);

    if (SUCCEEDED(hr))
    {
        if (DragQueryFile((HDROP)stgmed.hGlobal, 0, m_szPath, 
                          ARRAYSIZE(m_szPath)))
        {
            m_tt.cbTriggerSize = sizeof(TASK_TRIGGER);
            m_si.cbSize        = sizeof(SUBSCRIPTIONINFO);
            m_si.fUpdateFlags |= SUBSINFO_SCHEDULE;
            m_si.schedule      = SUBSSCHED_AUTO;
            m_si.pTrigger = &m_tt;

            hr = GetNameAndURLAndSubscriptionInfo(m_szPath, &m_bstrName, &m_bstrURL,
                                                  &m_si);

            ASSERT((SUCCEEDED(hr) && m_bstrName && m_bstrURL) || FAILED(hr));
        }
        else
        {
            hr = E_FAIL;
        }

        ReleaseStgMedium(&stgmed);

        if (SUCCEEDED(hr))
        {
            hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL,
                                  CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr,
                                  (void**)&m_pSubscriptionMgr);
        }
    }
    //  Return S_OK even if things didn't go as planned so that
    //  RemoveMenus will get called.

    return S_OK;
}


//
// Helper functions
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** Name ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
void
CChannelMenu::RemoveMenuItems(
    HMENU hmenu
)
{
    TCHAR aszRemove[4][62] = {{0}, {0}, {0}, {0}};

    MLLoadString(IDS_SHARING, aszRemove[0], ARRAYSIZE(aszRemove[0]));
    MLLoadString(IDS_RENAME,  aszRemove[1], ARRAYSIZE(aszRemove[1]));
    MLLoadString(IDS_SENDTO,  aszRemove[2], ARRAYSIZE(aszRemove[2]));

    if (SHRestricted2W(REST_NoEditingChannels, NULL, 0))
        MLLoadString(IDS_PROPERTIES, aszRemove[3], ARRAYSIZE(aszRemove[3]));

    TCHAR           szBuffer[62];
    MENUITEMINFO    mii;

    mii.cbSize     = sizeof(MENUITEMINFO);
    mii.fMask      = MIIM_TYPE;

    for (int i = GetMenuItemCount(hmenu) - 1; i >= 0; i--)
    {
        mii.dwTypeData = szBuffer;
        mii.cch = ARRAYSIZE(szBuffer);

        if (GetMenuItemInfo(hmenu, i, TRUE, &mii) && mii.cch)
        {
            for (int j = 0; j < ARRAYSIZE(aszRemove); j++)
            {
                if (StrEql(aszRemove[j], mii.dwTypeData))
                {
                    DeleteMenu(hmenu, i, MF_BYPOSITION);
                    break;
                }
            }
        }
    }

    return;
}

void CChannelMenu::Refresh(HWND hwnd)
{
    IXMLDocument* pIXMLDocument;

    DLL_ForcePreloadDlls(PRELOAD_MSXML);
    
    HRESULT hr = CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IXMLDocument, (void**)&pIXMLDocument);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIXMLDocument);

        if (DownloadCdfUI(hwnd, m_bstrURL, pIXMLDocument))
        {
            UpdateImage(m_szPath);
            SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH | SHCNF_FLUSH,
                           (void*)m_szPath, NULL);
        }

        pIXMLDocument->Release();
    }
}

static TCHAR c_szFileProtocol[] = TEXT("file:");
static TCHAR c_szCDFExtension[] = TEXT(".cdf");
static TCHAR c_szShellEdit[] = TEXT("\\shell\\edit\\command");
static TCHAR c_szEditVerb[] = TEXT("edit");
static TCHAR c_szChannelFile[] = TEXT("ChannelFile");
static TCHAR c_szChannelFileEdit[] = TEXT("ChannelFile\\shell\\edit\\command");
static TCHAR c_szNotepad[] = TEXT("notepad.exe");

void CChannelMenu::ViewSource(HWND hwnd)
{
    TCHAR szProgId[64] = TEXT("");
    TCHAR szBuf[INTERNET_MAX_URL_LENGTH];
    TCHAR szFile[MAX_PATH + 2]; // Leave room for quotes
    DWORD cch, ccb, dwType;
    SHELLEXECUTEINFO sei;
    BOOL fFoundProg = FALSE;
    HRESULT hr = S_OK;

    TraceMsg(TF_OBJECTS, "+ IContextMenu ViewSource %ls", m_bstrURL);

    if (SHUnicodeToTChar(m_bstrURL, szBuf, ARRAYSIZE(szBuf)))
    {
        if (SUCCEEDED(URLGetLocalFileName(szBuf, szFile, ARRAYSIZE(szFile),
                                          NULL)))
        {
            if (StrCmpNI(szFile, c_szFileProtocol, 5) == 0)
            {
                ASSERT(ARRAYSIZE(szFile) < ARRAYSIZE(szBuf));
                StrCpyN(szBuf, szFile, ARRAYSIZE(szBuf));
                cch = ARRAYSIZE(szFile) - 2;
                hr = PathCreateFromUrl(szBuf, szFile, &cch, 0);
            }

            if (SUCCEEDED(hr))
            {
                PathQuoteSpaces(szFile);

                //  
                //  We don't just call ShellExec with edit verb since
                //  who knows what the file extension will be.
                //
                cch = ARRAYSIZE(szProgId);
                if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, 
                                                c_szCDFExtension, 
                                                NULL, &dwType, 
                                                szProgId, &cch)
                    )
                {
                    ASSERT(ARRAYSIZE(szProgId) < ARRAYSIZE(szBuf));
                    StrCpyN(szBuf, szProgId, ARRAYSIZE(szBuf));
                    ASSERT(ARRAYSIZE(szProgId) + ARRAYSIZE(c_szShellEdit) <
                           ARRAYSIZE(szBuf));
                    StrCatBuff(szBuf, c_szShellEdit, ARRAYSIZE(szBuf));
                    ccb = sizeof(szBuf);
                                    
                    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, szBuf, 
                                                    NULL, &dwType, szBuf, &ccb)
                        )
                    {
                        //
                        // Getting here means they have an edit verb for CDF files
                        //
                        fFoundProg = TRUE;
                    }
                }

                //  
                //  If we haven't found a class key yet and the CDF ProgID 
                //  isn't ours, then fall back to our edit verb.
                //
                if (!fFoundProg && StrCmpI(szProgId, c_szChannelFile))
                {
                    ccb = sizeof(szBuf);
                    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, 
                                                    c_szChannelFileEdit, 
                                                    NULL, &dwType, 
                                                    szBuf, &ccb)
                       )
                    {
                        fFoundProg = TRUE;
                        ASSERT(ARRAYSIZE(c_szChannelFile) < ARRAYSIZE(szProgId));
                        StrCpyN(szProgId, c_szChannelFile, ARRAYSIZE(szProgId));
                    }
                }

                ZeroMemory(&sei, sizeof(sei));
                sei.cbSize = sizeof(sei);
                sei.hwnd = hwnd;
                sei.nShow = SW_SHOW;
            
                if (fFoundProg)
                {
                    sei.fMask = SEE_MASK_CLASSNAME;
                    sei.lpVerb = c_szEditVerb;
                    sei.lpFile = szFile;
                    sei.lpClass = szProgId;
                    TraceMsg(TF_OBJECTS, "IContextMenu ViewSource progid=%s file=%s", szProgId, szFile);
                }
                else
                {
                    sei.lpFile = c_szNotepad;
                    sei.lpParameters = szFile;
                    TraceMsg(TF_OBJECTS, "IContextMenu ViewSource Notepad file=%s", szFile);
                }

#ifndef UNIX
                ShellExecuteEx(&sei);
#else
                unixInvokeEditor(szFile);
#endif /* UNIX */
            }
        }
        else
        {
            CDFMessageBox(hwnd, IDS_ERROR_NO_CACHE_ENTRY, IDS_ERROR_DLG_TITLE,
                            MB_OK | MB_ICONEXCLAMATION, szBuf);
        }
    }
    else
    {
        TraceMsg(TF_OBJECTS, "IContextMenu ViewSource couldn't convert to TSTR");
    }
    TraceMsg(TF_OBJECTS, "- IContextMenu ViewSource");
}


HRESULT CChannelMenu::Subscribe(HWND hwnd)
{
    HRESULT hr = S_OK;

    CChannelMgr *pChannelMgr = new CChannelMgr;

    if (pChannelMgr)
    {
        hr = pChannelMgr->AddAndSubscribeEx2(hwnd, m_bstrURL, m_pSubscriptionMgr, TRUE);
        pChannelMgr->Release();

        if (SUCCEEDED(hr) && (NULL != m_pSubscriptionMgr))
        {
            hr = m_pSubscriptionMgr->UpdateSubscription(m_bstrURL);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\chanmgri.h ===
////////////////////////////////////////////////////////////////////////////////
//
// chanmgri.h 
//
//   The class definition for the CChannelMgr
//
//   History:
//
//       4/30/97  julianj   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _CHANMGRI_H_

#define _CHANMGRI_H_

//
// The class definition for the Channel Manager
//

class CChannelMgr : public IChannelMgr,
                    public IChannelMgrPriv2,
#ifdef UNICODE
                    public ICopyHookA,
#endif
                    public ICopyHook
{
    //
    // Methods
    //
public:

    //
    // Constructor
    //
    CChannelMgr(void);                           

    //
    // IUnknown
    //
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IChannelMgr methods
    //
    STDMETHODIMP AddChannelShortcut(CHANNELSHORTCUTINFO *pChannelInfo);
    STDMETHODIMP DeleteChannelShortcut(BSTR strTitle);
    STDMETHODIMP AddCategory(CHANNELCATEGORYINFO *pCategoryInfo);
    STDMETHODIMP DeleteCategory(BSTR strTitle);
    STDMETHODIMP EnumChannels(DWORD dwEnumFlags, LPCWSTR pszURL,
                              IEnumChannels** pIEnumChannels);

    //
    // IChannelMgrPrive methods.
    //
    STDMETHODIMP GetBaseChannelPath(LPSTR pszPath, int cch);
    STDMETHODIMP InvalidateCdfCache(void);

    STDMETHODIMP PreUpdateChannelImage(LPCSTR pszPath,
                                       LPSTR pszHashItem,
                                       int* piIndex,
                                       UINT* puFlags,
                                       int* piImageIndex);

    STDMETHODIMP UpdateChannelImage(LPCWSTR pszHashItem,
                                    int iIndex,
                                    UINT uFlags,
                                    int iImageIndex);

    STDMETHODIMP GetChannelFolderPath (LPSTR pszPath, int cch,
                                       enum _tagCHANNELFOLDERLOCATION chLoc);
    STDMETHODIMP GetChannelFolder (LPITEMIDLIST* ppidl,
                                   enum _tagCHANNELFOLDERLOCATION chLoc);

    STDMETHODIMP DownloadMinCDF(HWND hwnd, LPCWSTR pwszURL, LPWSTR pwszTitle, 
                                DWORD cchTitle, SUBSCRIPTIONINFO *pSubInfo,
                                BOOL *pfIsSoftware);
    STDMETHODIMP ShowChannel(IWebBrowser2 *pWebBrowser2, LPWSTR pwszURL, HWND hwnd);
    STDMETHODIMP IsChannelInstalled(LPCWSTR pwszURL);
    STDMETHODIMP IsChannelPreinstalled(LPCWSTR pwszURL, BSTR * bstrFile); 
    STDMETHODIMP RemovePreinstalledMapping(LPCWSTR pwszURL);
    STDMETHODIMP SetupPreinstalledMapping(LPCWSTR pwszURL, LPCWSTR pwszFile);
    STDMETHODIMP AddAndSubscribe(HWND hwnd, LPCWSTR pwszURL, 
                                 ISubscriptionMgr *pSubscriptionMgr);


    STDMETHODIMP WriteScreenSaverURL(LPCWSTR pwszURL, LPCWSTR pwszScreenSaverURL);
    STDMETHODIMP RefreshScreenSaverURLs();

    //
    // ICopyHook method
    //
    STDMETHODIMP_(UINT) CopyCallback(
        HWND hwnd,          
        UINT wFunc,         
        UINT wFlags,        
        LPCTSTR pszSrcFile,  
        DWORD dwSrcAttribs, 
        LPCTSTR pszDestFile, 
        DWORD dwDestAttribs 
    );
#ifdef UNICODE
    STDMETHODIMP_(UINT) CopyCallback(
        HWND hwnd,          
        UINT wFunc,         
        UINT wFlags,        
        LPCSTR pszSrcFile,  
        DWORD  dwSrcAttribs, 
        LPCSTR pszDestFile, 
        DWORD  dwDestAttribs
    );
#endif

    //  Helpers
    STDMETHODIMP AddAndSubscribeEx2(HWND hwnd, LPCWSTR pwszURL, 
                                    ISubscriptionMgr *pSubscriptionMgr, 
                                    BOOL bAlwaysSubscribe);

private:
    //
    // Destructor
    //
    ~CChannelMgr(void);

    //
    // Member variables.
    //
private:

    ULONG           m_cRef;
};

#endif // _CHANMGRI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\crt.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// crt.cpp 
//
//   Functions defined to avoid a dependency on the crt lib.  Defining these
//   functions here greatly reduces code size.
//
//   History:
//
//       3/16/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"

#ifndef UNIX

#define DECL_CRTFREE
#include <crtfree.h>

#endif /* !UNIX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\clsfact.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// clsfact.h 
//
//   Definitions for the cdf viewer class factory..
//
//   History:
//
//       3/16/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _CLSFACT_H_

#define _CLSFACT_H_

//
// Prototype for function used in class factory to create objects.

typedef HRESULT (*CREATEPROC)(IUnknown** ppIUnknown);

//
// Class definition for the class factory
//

class CCdfClassFactory : public IClassFactory
{
//
// Methods
//

public:

    // Constructor
    CCdfClassFactory(CREATEPROC pfn);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory
    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, void **);
    STDMETHODIMP         LockServer(BOOL);

private:
    
    // Destructor
    ~CCdfClassFactory(void);

//
// Members
//

private:

    ULONG       m_cRef;
    CREATEPROC  m_Create;
};


#endif // _CLSFACT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\clsfact.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// clsfact.cpp 
//
//   Class factory for ineticon.
//
//   History:
//
//       3/16/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "clsfact.h"
#include "cdfidl.h"
#include "persist.h"
#include "cdfview.h"
#include "iconhand.h"
#include "chanmgrp.h"
#include "chanmgri.h"
#include "chanmenu.h"
#include "proppgs.h"
#include "dll.h"        // DllAddRef, DllRelease.


//
// Constructor and destructor.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfClassFactory::CCdfClassFactory ***
//
//    Class factory constructor.
//
////////////////////////////////////////////////////////////////////////////////
CCdfClassFactory::CCdfClassFactory (
	CREATEPROC pfn
)
: m_cRef(1),
  m_Create(pfn)
{
    ASSERT(m_Create != NULL);
    //
    // As long as this class is around the dll should stay loaded.
    //

    TraceMsg(TF_OBJECTS, "+ IClassFactory");

    DllAddRef();

	return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfClassFactory::~CCdfClassFactory ***
//
//    Class factory destructor.
//
////////////////////////////////////////////////////////////////////////////////
CCdfClassFactory::~CCdfClassFactory (
	void
)
{
    //
    // Matching Release for the constructor Addref.
    //

    TraceMsg(TF_OBJECTS, "- IClassFactory");

    DllRelease();

	return;
}


//
// IUnknown methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfClassFactory::QueryInterface ***
//
//    Class factory QI.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfClassFactory::QueryInterface (
    REFIID riid,
    void **ppv
)
{
    ASSERT(ppv);

    HRESULT hr;

    if (IID_IUnknown == riid || IID_IClassFactory == riid)
    {
        AddRef();
        *ppv = (IClassFactory*)this;
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && NULL == *ppv));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfClassFactory::AddRef ***
//
//    Class factory AddRef.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCdfClassFactory::AddRef (
    void
)
{
    ASSERT(m_cRef != 0);
    ASSERT(m_cRef < (ULONG)-1);

    return ++m_cRef;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfClassFactory::Release ***
//
//    Class factory Release.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCdfClassFactory::Release (
    void
)
{
    ASSERT (m_cRef != 0);

    ULONG cRef = --m_cRef;
    
    if (0 == cRef)
        delete this;

    return cRef;
}


//
// IClassFactory methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfClassFactory::CreateInstance ***
//
//    Creates a cdf view object.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfClassFactory::CreateInstance (
    IUnknown* pOuterUnknown,
    REFIID riid,
    void **ppvObj
)
{
    ASSERT(ppvObj);

    HRESULT hr;

    *ppvObj = NULL;

    if (NULL == pOuterUnknown)
    {
        IUnknown* pIUnknown;
            
        hr = m_Create(&pIUnknown);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIUnknown)

            hr = pIUnknown->QueryInterface(riid, ppvObj);

            pIUnknown->Release();
        }
    }
    else
    {
        //
        // This object doesn't support aggregation.
        //

        hr = CLASS_E_NOAGGREGATION;
    }

    ASSERT((SUCCEEDED(hr) && *ppvObj) || (FAILED(hr) && NULL == *ppvObj));

    return hr;
}


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** LockServer ***
//
//    Increments/decrements the class factory ref count.     
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfClassFactory::LockServer (
    BOOL bLock
)
{
    if (bLock)
        AddRef();
    else
        Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\debug.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// debug.cpp 
//
//   Debug file.  This file makes use to the shell debugging macros and
//   functions defined in shell\inc\debug.h
//
//   History:
//
//       3/16/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

#include "stdinc.h"

//
// Define strings used by debug.h.  Declaring DECLARE_DEBUG causes debug.h to
// define its c objects here.
//

#define SZ_DEBUGINI         "shellext.ini"
#define SZ_DEBUGSECTION     "cdfview"
#define SZ_MODULE           "CDFVIEW"

#define DECLARE_DEBUG

#include <ccstock.h>   // TEXTW macro used in debug.h  
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\dll.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// dll.h 
//
//   Definitions for dll.cpp.
//
//   History:
//
//       3/16/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _DLL_H_

#define _DLL_H_

//
// Function prototypes.
//

EXTERN_C BOOL WINAPI DllMain(HANDLE hInst, DWORD dwReason, LPVOID pReserved);

EXTERN_C STDAPI DllCanUnloadNow(void);
EXTERN_C STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppvObj);
EXTERN_C STDAPI DllRegisterServer(void);
EXTERN_C STDAPI DllUnregisterServer(void);

HRESULT RegisterServerHelper(LPSTR szCmd);
void DllAddRef(void);
void DllRelease(void);

#define PRELOAD_MSXML       0x0001
#define PRELOAD_WEBCHECK    0x0002

void DLL_ForcePreloadDlls(DWORD dwFlags);

#endif _DLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\dllload.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#include "stdinc.h"

#pragma warning(disable:4229)  // No warnings when modifiers used on data

//----------------------------------------------------------------------------
// Delay loading mechanism.  [Stolen from shdocvw.]
//
// This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
//----------------------------------------------------------------------------

#define ENSURE_LOADED(_hinst, _dll, pszfn)   (_hinst ? TRUE : NULL!=(_hinst = LoadLibraryA(#_dll)))

#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err) \
static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
_ret __stdcall _fn _args                \
{                                       \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg((BOOL)_hinst, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        AssertMsg((BOOL)_pfn##_fn, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg((BOOL)_hinst, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        AssertMsg((BOOL)_pfn##_fn, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
}
        
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)

//
// And now the DLLs which are delay loaded
//

// --------- SHDOCVW.DLL ---------------

// NOTE: These may not remain private.
HINSTANCE g_hinstSHDOCVW = NULL;

DELAY_LOAD_ORD(g_hinstSHDOCVW, SHDOCVW.DLL, DWORD, SHRestricted2A, 158,
                (BROWSER_RESTRICTIONS rest, LPCSTR pszUrl, DWORD dwReserved), (rest, pszUrl, dwReserved));

DELAY_LOAD_ORD(g_hinstSHDOCVW, SHDOCVW.DLL, DWORD, SHRestricted2W, 159,
                (BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved), (rest, pwzUrl, dwReserved));

DELAY_LOAD_ORD_ERR(g_hinstSHDOCVW, SHDOCVW.DLL, HRESULT, CDDEAuto_Navigate, 162,
                (BSTR str, HWND* phwnd, long lTransID), (str, phwnd, lTransID), E_FAIL);

#ifdef UNIX
DELAY_LOAD_ORD(g_hinstSHDOCVW, SHDOCVW.DLL, HRESULT, SHAddSubscribeFavorite,163, (HWND hwnd, LPCWSTR pwszURL, LPCWSTR pwszName, DWORD dwFlags, SUBSCRIPTIONTYPE subsType, SUBSCRIPTIONINFO* pInfo), (hwnd, pwszURL, pwszName, dwFlags, subsType, pInfo));
#endif /* UNIX */

#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\enum.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// enum.cpp 
//
//   The enumerator object for the cdf viewer.
//
//   History:
//
//       3/16/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "cdfidl.h"
#include "xmlutil.h"
#include "enum.h"
#include "dll.h"


//
// Constructor and destructor.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfEnum::CCdfView ***
//
//    Constructor.
//
////////////////////////////////////////////////////////////////////////////////
CCdfEnum::CCdfEnum (
    IXMLElementCollection* pIXMLElementCollection,
    DWORD fEnumerateFlags,
    PCDFITEMIDLIST pcdfidlFolder
)
: m_cRef(1),
  m_fEnumerate(fEnumerateFlags)
{
    //
    // Zero inited memory.
    //

    ASSERT(NULL == m_pIXMLElementCollection);
    ASSERT(0 == m_nCurrentItem);

    if (pIXMLElementCollection)
    {
        pIXMLElementCollection->AddRef();
        m_pIXMLElementCollection = pIXMLElementCollection;
    }

    m_pcdfidlFolder = (PCDFITEMIDLIST)ILClone((LPITEMIDLIST)pcdfidlFolder);
    
    //
    // Don't allow the dll to be unloaded.
    //

    TraceMsg(TF_OBJECTS, "+ IEnumIDList");

    DllAddRef();
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::~CCdfView **
//
//    Destructor.
//
////////////////////////////////////////////////////////////////////////////////
CCdfEnum::~CCdfEnum(
    void
)
{
    if (m_pIXMLElementCollection)
        m_pIXMLElementCollection->Release();

    TraceMsg(TF_OBJECTS, "- IEnumIDList");

    if (m_pcdfidlFolder)
        ILFree((LPITEMIDLIST)m_pcdfidlFolder);

    DllRelease();
}

//
// IUnknown methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::CCdfEnum ***
//
//    Cdf view QI.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfEnum::QueryInterface (
    REFIID riid,
    void **ppv
)
{
    ASSERT(ppv);

    HRESULT hr;

    if (IID_IUnknown == riid || IID_IEnumIDList == riid)
    {
        AddRef();
        *ppv = (IEnumIDList*)this;
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && NULL == *ppv));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfEnum::AddRef ***
//
//    Cdf view AddRef.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCdfEnum::AddRef (
    void
)
{
    ASSERT(m_cRef != 0);
    ASSERT(m_cRef < (ULONG)-1);

    return ++m_cRef;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfEnum::Release ***
//
//    Cdf view Release.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CCdfEnum::Release (
    void
)
{
    ASSERT (m_cRef != 0);

    ULONG cRef = --m_cRef;
    
    if (0 == cRef)
        delete this;

    return cRef;
}


//
// IEnumIDList methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfEnum::Next ***
//
//
// Description:
//     Returns the next n item id lists associated with this enumerator.
//
// Parameters:
//     [in]  celt         - Number of item id lists to return.
//     [Out] rgelt        - A pointer to an array of item id list pointers that
//                          will receive the id item lists.
//     [Out] pceltFetched - A pointer to a ULONG that receives a count of the
//                          number of id lists fetched.
//
// Return:
//     S_OK if celt items where fetched.
//     S_FALSE if celt items where not fetched.
//
// Comments:
//     
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfEnum::Next(
    ULONG celt,	
    LPITEMIDLIST *rgelt,	
    ULONG* pceltFetched)
{
    ASSERT(rgelt || 0 == celt);
    ASSERT(pceltFetched || 1 == celt);

    //
    // pceltFetched can be NULL if and only if celt is 1.
    //

    ULONG lFetched;

    if (1 == celt && NULL == pceltFetched)
        pceltFetched = &lFetched;

    for (*pceltFetched = 0; *pceltFetched < celt; (*pceltFetched)++)
    {
        if (NULL == (rgelt[*pceltFetched] = NextCdfidl()))
            break;

        ASSERT(CDFIDL_IsValid((PCDFITEMIDLIST)rgelt[*pceltFetched]));
    }

    return (*pceltFetched == celt) ? S_OK : S_FALSE;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfEnum::Skip ***
//
//   Shell doesn't call this member.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfEnum::Skip(
    ULONG celt)
{
    return E_NOTIMPL;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfEnum::Reset ***
//
//   Set the current item to the index of the first item in CFolderItems.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfEnum::Reset(
    void
)
{
    m_nCurrentItem = 0;
    m_fReturnedFolderPidl = FALSE;

    return S_OK;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfEnum::Clone ***
//
//   Shell doesn't call this method.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfEnum::Clone(
    IEnumIDList **ppenum
)
{
    return E_NOTIMPL;
}

//
// Helper functions.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfEnum::NextCdfidl ***
//
//
// Description:
//     Returns a cdf item idl list for the next cdf item in the collection
//
// Parameters:
//     None.
//
// Return:
//     A pointer to a new cdf item id list.
//     NULL if there aren't any more items or if there isn't enough memory to
//     allocated an id list for the item.
//
// Comments:
//     The caller is responsible for freeing the returned item id list.
//
////////////////////////////////////////////////////////////////////////////////
LPITEMIDLIST
CCdfEnum::NextCdfidl(
    void
)
{
    PCDFITEMIDLIST pcdfidlNew = NULL;

    IXMLElement* pIXMLElement;
    ULONG        nIndex;

    //the first item in the enum is the folder's link (if it has one)
    if (!m_fReturnedFolderPidl && m_pIXMLElementCollection)
    {
        IXMLElement *pIXMLElementChild;

        XML_GetElementByIndex(m_pIXMLElementCollection, 0, &pIXMLElementChild);

        if (pIXMLElementChild)
        {
            pIXMLElementChild->get_parent(&pIXMLElement);
            if (pIXMLElement)
            {
                BSTR bstr = XML_GetAttribute(pIXMLElement, XML_HREF);
                if (bstr)
                {
                    if (*bstr)
                        pcdfidlNew = CDFIDL_CreateFolderPidl(m_pcdfidlFolder);
                    SysFreeString(bstr);
                }
                
                //get_parent doesn't addref???
                pIXMLElement->Release();
            }
            pIXMLElementChild->Release();
        }

        m_fReturnedFolderPidl = TRUE;
    }

    if (!pcdfidlNew)
    {
        HRESULT hr = GetNextCdfElement(&pIXMLElement, &nIndex);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIXMLElement);

            pcdfidlNew = CDFIDL_CreateFromXMLElement(pIXMLElement, nIndex);

            pIXMLElement->Release();
        }
    }
    
    ASSERT(CDFIDL_IsValid(pcdfidlNew) || NULL == pcdfidlNew);

    return (LPITEMIDLIST)pcdfidlNew;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfEnum::GetNextCdfElement ***
//
//
// Description:
//     Get the IXMLElement pointer and index for the next cdf item in the
//     collection.
//
// Parameters:
//     [Out] ppIXMLElement - A pointer that recieves the xml element.
//     [Out] pnIndex       - The object model index of the xml element.
//
// Return:
//     S_OK if the element was found.
//     E_FAIL otherwise.
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CCdfEnum::GetNextCdfElement(
    IXMLElement** ppIXMLElement,
    ULONG* pnIndex
)
{
    ASSERT(ppIXMLElement);

    HRESULT hr;

    if (m_pIXMLElementCollection)
    {
        IXMLElement* pIXMLElement;

        hr = XML_GetElementByIndex(m_pIXMLElementCollection,
                                   m_nCurrentItem++, &pIXMLElement);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIXMLElement)

            if (IsCorrectType(pIXMLElement))
            {
                pIXMLElement->AddRef();
                *ppIXMLElement = pIXMLElement;
                *pnIndex = m_nCurrentItem - 1;
            }
            else
            {
                hr = GetNextCdfElement(ppIXMLElement, pnIndex);
            }

            pIXMLElement->Release();
        }
    }
    else
    {
        hr = E_FAIL;
    }

    ASSERT(SUCCEEDED(hr) && *ppIXMLElement || FAILED(hr));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfEnum::IsCorrectType ***
//
//
// Description:
//     Determines if the given xml element is a cdf element and if it should
//     be returned accroding to the folder non-folder enumrator flags.
//
// Parameters:
//     [In]  pIXMLElement - The xml element to check.
//
// Return:
//     TRUE if the lement is cdf displayable and the correct type for this
//     enumerator.
//     FALSE if the given element should not be enumerated.
//
// Comments:
//     Id list enumerators are created with a combination of SHCONTF_FOLDERS,
//     SHCONTF_NONFOLDERS and SHCONTF_INCLUDEHIDDEN flags.
//
////////////////////////////////////////////////////////////////////////////////
inline BOOL
CCdfEnum::IsCorrectType(
    IXMLElement* pIXMLElement
)
{
    return (XML_IsCdfDisplayable(pIXMLElement) &&
            (XML_IsFolder(pIXMLElement) ? (m_fEnumerate & SHCONTF_FOLDERS) :
                                          (m_fEnumerate & SHCONTF_NONFOLDERS)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\exticon.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// exticon.h 
//
//   Extract icon com object.
//
//   History:
//
//       3/21/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _EXTICON_H_

#define _EXTICON_H_


//
// Defines
//

#define     TSTR_ICO_EXT        TEXT(".ico")

#define     INDEX_IMAGE         -1

#define     COLOR1              (RGB(0,0,255))
#define     COLOR2              (RGB(0,255,0))


//
// Function prototypes.
//

void CALLBACK ImgCtx_Callback(void* pIImgCtx, void* phEvent);

void MungePath(LPTSTR pszPath);
void DemungePath(LPTSTR pszPath);


//
// Class definition for the extract icon class.
//

class CExtractIcon : public IExtractIcon
#ifdef UNICODE
                    ,public IExtractIconA
#endif
{
//
// Methods
//

public:

    // Constructors
    CExtractIcon(PCDFITEMIDLIST pcdfidl,
                 IXMLElementCollection* pIXMLElementCollection);

    CExtractIcon (
        PCDFITEMIDLIST pcdfidl,
        IXMLElement *pElem);

    CExtractIcon( BSTR pszPath );
    
    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IExtractIcon methods.
    STDMETHODIMP GetIconLocation(UINT uFlags,
                                 LPTSTR szIconFile,
                                 UINT cchMax,
                                 int *piIndex,
                                 UINT *pwFlags);

    STDMETHODIMP Extract(LPCTSTR pszFile,
                         UINT nIconIndex,
                         HICON *phiconLarge,
                         HICON *phiconSmall,
                         UINT nIconSize);

#ifdef UNICODE
    // IExtractIconA methods.
    STDMETHODIMP GetIconLocation(UINT uFlags,
                                 LPSTR szIconFile,
                                 UINT cchMax,
                                 int *piIndex,
                                 UINT *pwFlags);

    STDMETHODIMP Extract(LPCSTR pszFile,
                         UINT nIconIndex,
                         HICON *phiconLarge,
                         HICON *phiconSmall,
                         UINT nIconSize);
#endif

    // Public helper(s) to talk between implementations of IExtractIcon
    // KENSY: We should probably update the other helpers to look at this
    //        variable instead of taking a gleam parameter.
    
    void    SetGleam(BOOL fGleam) { m_fGleam = fGleam; }
    
private:

    // Destructor.
    ~CExtractIcon(void);

    // Helper functions.
    STDMETHODIMP GetCustomIconLocation(UINT uFlags,
                                       LPTSTR szIconFile,
                                       UINT cchMax,
                                       int *piIndex,
                                       UINT *pwFlags);

    STDMETHODIMP GetDefaultIconLocation(UINT uFlags,
                                        LPTSTR szIconFile,
                                        UINT cchMax,
                                        int *piIndex,
                                        UINT *pwFlags);

    HRESULT SynchronousDownload(LPCTSTR pszFile,
                                IImgCtx** ppIImgCtx,
                                HANDLE hExitThreadEvent);

    HICON   ExtractImageIcon(WORD wSize, IImgCtx* pIImgCtx, BOOL fDrawGleam);

    HRESULT CreateImageAndMask(IImgCtx* pIImgCtx,
                               HDC hdcScreen,
                               SIZE* pSize,
                               HBITMAP* phbmImage,
                               HBITMAP* phbmMask,
                               BOOL fDrawGleam);

    HRESULT StretchBltImage(IImgCtx* pIImgCtx,
                            const SIZE* pSize,
                            HDC hdcDst,
                            BOOL fDrawGleam);

    HRESULT CreateMask(IImgCtx* pIImgCtx,
                       HDC hdcScreen,
                       HDC hdc1,
                       const SIZE* pSize,
                       HBITMAP* phbmMask,
                       BOOL fDrawGleam);

    BOOL ColorFill(HDC hdc, const SIZE* pSize, COLORREF clr);

    HRESULT ExtractGleamedIcon(LPCTSTR pszIconFile, 
                               int iIndex, 
                               UINT uFlags,
                               HICON *phiconLarge, 
                               HICON *phiconSmall, 
                               UINT nIconSize);

    HRESULT ApplyGleamToIcon(HICON hIcon, ULONG nSize, HICON *phGleamedIcon);

    BOOL GetBitmapSize(HBITMAP hbmp, int* pcx, int* pcy);
    
//
// Member variables.
//

private:

    ULONG       m_cRef;
    int         m_iconType;
    BSTR        m_bstrIconURL;
    BOOL        m_fGleam;
};


#endif _EXTICON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\dll.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// dll.cpp 
//
//   Exported Dll functions.
//
//   History:
//
//       3/16/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "dll.h"
#include "clsfact.h"
#include "cdfidl.h"
#include "xmlutil.h"
#include "chanapi.h"
#include "persist.h"
#include "cdfview.h"
#include "iconhand.h"
#include "chanmgrp.h"
#include "chanmgri.h"
#include "chanmenu.h"
#include "proppgs.h"
#include <advpub.h>     // Self registration helper.
#include <olectl.h>     // SELFREG_E_CLASS definition.
#include <comcat.h>     // Catagory registration.

#define MLUI_INIT
#include <mluisupp.h>

BOOL g_bRunningOnNT = FALSE;

void DLL_ForcePreloadDlls(DWORD dwFlags)
{
    //
    // CoLoadLibrary is getting called here to add an extra reference count
    // to a COM dll so that it doesn't get unloaded by COM before we are through
    // with it.  This problem occurs since our object gets created on
    // one thread and then passed along to another where we instantiate an
    // COM object.  The secondary thread isn't guaranteed to have called
    // CoInitialize so we call it, then call CoCreateInstance then call 
    // CoUnitialize to clean up.  The side effect of all this is that dlls
    // are being unloaded while we still have references to them. 
    //
    if ((dwFlags & PRELOAD_MSXML) && !g_msxmlInst)
    {
        g_msxmlInst = CoLoadLibrary(L"msxml.dll", FALSE); // Not much we can if
                                                          // this fails
    }

#ifndef UNIX
    /* Unix does not use webcheck */
    if ((dwFlags & PRELOAD_WEBCHECK) && !g_webcheckInst)
    {
        g_webcheckInst = CoLoadLibrary(L"webcheck.dll", FALSE);
    }
#endif /* UNIX */
}

//
// Exported Functions.
//


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** DllMain ***
//
//    Dll entry point.
//
////////////////////////////////////////////////////////////////////////////////
EXTERN_C
BOOL
WINAPI DllMain(
    HANDLE hInst,
    DWORD dwReason,
    LPVOID pReserved
)
{
    if (DLL_PROCESS_ATTACH == dwReason)
    {
        //
        // This is a hack to fix an oleaut32.dll bug.  If the oleaut32.dll is
        // loaded, then unloaded, then reloaded in the same process its heap
        // can become corrupt.  This Loadlibrary will ensure that oleaut32
        // stays loaded once cdfview is ever loaded.
        //

        LoadLibrary(TEXT("oleaut32.dll"));
        
        DisableThreadLibraryCalls((HINSTANCE)hInst);

        g_hinst = (HINSTANCE)hInst;
        GetModuleFileName(g_hinst, g_szModuleName, ARRAYSIZE(g_szModuleName));
        MLLoadResources(g_hinst, TEXT("cdfvwlc.dll"));

        Cache_Initialize();

        //
        // Read the debug flags defined in ShellExt.ini.  The filename, section
        // to read, and flag variables are defined in debug.cpp.
        //

        #ifdef DEBUG
        #ifndef UNIX
        CcshellGetDebugFlags();
        #endif /* UNIX */
        #endif

        g_bRunningOnNT = IsOS(OS_NT);

    }
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        MLFreeResources(g_hinst);

        //
        // REVIEW:  Clearing the cache on DLL unload.
        //

        Cache_Deinitialize(); 


        if (g_msxmlInst)
            CoFreeLibrary(g_msxmlInst);

        TraceMsg(TF_OBJECTS, "cdfview.dll unloaded!");
    }

    return TRUE;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** DllCanUnloadNow ***
//
//    Determines whether this DLL is in use. If not, the caller can safely
//    unload the DLL from memory. 
//
////////////////////////////////////////////////////////////////////////////////
EXTERN_C
STDAPI DllCanUnloadNow(
    void
)
{
    HRESULT hr;

    if (0 == g_cDllRef)
    {
        Cache_FreeAll();
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    TraceMsg(TF_OBJECTS, "DllCanUnloadNow returned %s",
             hr == S_OK ? TEXT("TRUE") : TEXT("FALSE"));

    return g_cDllRef ? S_FALSE : S_OK;
}

//
// Create functions used by the class factory.
//

#define DEFINE_CREATEINSTANCE(cls, iface)                 \
HRESULT cls##_Create(IUnknown **ppIUnknown)               \
{                                                         \
    ASSERT(NULL != ppIUnknown);                           \
    *ppIUnknown = (iface *)new cls;                       \
    return (NULL != *ppIUnknown) ? S_OK : E_OUTOFMEMORY;  \
}

DEFINE_CREATEINSTANCE(CCdfView,       IShellFolder);
DEFINE_CREATEINSTANCE(CChannelMgr,    IChannelMgr);
DEFINE_CREATEINSTANCE(CIconHandler,   IExtractIcon);
DEFINE_CREATEINSTANCE(CChannelMenu,   IContextMenu);
DEFINE_CREATEINSTANCE(CPropertyPages, IShellPropSheetExt);


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** DllGetClassObject ***
//
//     Retrieves the class factory object for the cdf viewer.    
//
////////////////////////////////////////////////////////////////////////////////
EXTERN_C
STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void** ppvObj
)
{
    //
    // Table used to pass the correct create function to the class factory.
    //

    static const struct _tagCLASSFACT {
        GUID const* pguid;
        CREATEPROC  pfn;
    } aClassFact[] = { {&CLSID_CDFVIEW,        CCdfView_Create},
                       {&CLSID_CDFINI,         CCdfView_Create},
                       {&CLSID_ChannelMgr,     CChannelMgr_Create},
                       {&CLSID_CDFICONHANDLER, CIconHandler_Create},
                       {&CLSID_CDFMENUHANDLER, CChannelMenu_Create},
                       {&CLSID_CDFPROPPAGES,   CPropertyPages_Create} };

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    ASSERT(ppvObj);

    *ppvObj = NULL;

    for (int i = 0; i < ARRAYSIZE(aClassFact); i++)
    {
        if (rclsid == *aClassFact[i].pguid)
        {
            CCdfClassFactory *pCdfClassFactory =
                                        new CCdfClassFactory(aClassFact[i].pfn);

            if (pCdfClassFactory)
            {
                hr = pCdfClassFactory->QueryInterface(riid, ppvObj);

                //
                // The 'new' created a class factory with a ref count of one.  The
                // above QueryInterface incremented the ref count by one or failed.
                // In either case the ClassFactory ref count should be decremented.
                //

                pCdfClassFactory->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            
            break;
        }
    }

    ASSERT((SUCCEEDED(hr) && *ppvObj) || (FAILED(hr) && NULL == *ppvObj));

    return hr;
}


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** DllRegisterServer ***
//
//     Self register the cdf viewer.    
//
////////////////////////////////////////////////////////////////////////////////
EXTERN_C
STDAPI DllRegisterServer(
    void
)
{
    HRESULT hr;

    //
    // Unregister previous versions of this control.
    //

    DllUnregisterServer();

    //
    // REVIEW this should be called at install time
    //
    DllInstall(TRUE, NULL);

    //
    // RegisterServerHelper uses advpack.dll to add registry entries using
    // entries found in the .rc.
    //

    //
    // REVIEW : Use #defines for "Reg" and "Unreg"
    //

    hr = RegisterServerHelper("Reg");
    
    if (SUCCEEDED(hr))
    {
        //
        // Register as a browseable shell extension.  This will allow a user
        // to type the path of a cdf in the address bar and browse to the cdf
        // in place. This call adds an entry to the HKCR\CLSID\CLSID_CDFVIEW
        // \Implemented Catagories key.
        //

        ICatRegister *pICatRegister;

        HRESULT hr2 = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                                       NULL, CLSCTX_INPROC_SERVER,
                                       IID_ICatRegister,
                                       (void**)&pICatRegister);

        if (SUCCEEDED(hr2))
        {
            ASSERT(pICatRegister);

            CATID acatid[1];
            acatid[0] = CATID_BrowsableShellExt;

            pICatRegister->RegisterClassImplCategories(CLSID_CDFVIEW, 1,
                                                       acatid);
            pICatRegister->Release();
        }
    }
       
    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** DllUnregisterServer ***
//
//     Self unregister the cdf viewer.    
//
////////////////////////////////////////////////////////////////////////////////
EXTERN_C
STDAPI DllUnregisterServer(
    void
)
{
    //
    // Note: The catagories registration in DllRegisterServer simply places a
    // value in CLSID\CLSID_CDFVIEW.  This unreg removes the whole key (see
    // "selfreg.inx").  So no special handeling of the removal of the catagory
    // is required.
    //

    return RegisterServerHelper("Unreg");
}

EXTERN_C
STDAPI DllInstall(BOOL fInstall, LPCWSTR pszCmdLine)
{
    if (fInstall)
    {
        //
        // IE5 no longer creates special channel folders.  Channels go into the
        // favorites folder.
        //

        /*
        Channel_CreateChannelFolder(DOC_CHANNEL);
        Channel_CreateChannelFolder(DOC_SOFTWAREUPDATE);
        */
    }
    else
    {
        //
        // REVIEW delete channels folder on uninstall?
        //
        ;
    }
    return S_OK;
}

//
// Internal Functions.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** RegisterServerHelper ***
//
//
// Description:
//     Helper function used to register and unregister the cdf viewer.
//
// Parameters:
//     [IN] szCmd - String passed to advpack.RegInstall.  Values use: "Reg" or
//                  "Unreg".
//
// Return:
//     SELFREG_E_CLASS if advpack.dll isn't accessed.  Otherwise the reuslt
//     from advpack.RegInstall is returned.
//
// Comments:
//     This helper is called by DllRegisterServer and DllUnregisterServer.
//
//     This function uses an exported function from advpack.dll to update the
//     registry.  Advpack uses the REGINST resource item to populate the
//     registry.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
RegisterServerHelper(
    LPSTR szCmd
)
{
    ASSERT(szCmd);

    HRESULT hr = SELFREG_E_CLASS;

    HINSTANCE hinstLib = LoadLibrary(TEXT("advpack.dll"));

    if (hinstLib)
    {
        REGINSTALL RegInstall = (REGINSTALL)GetProcAddress(hinstLib, 
                                                           achREGINSTALL);

        if (RegInstall)
            hr = RegInstall(g_hinst, szCmd, NULL);
        else
            TraceMsg(TF_ERROR, "DLLREG RegisterServerHelper() GetProcAddress Failed");

        FreeLibrary(hinstLib);
    }
    else
        TraceMsg(TF_ERROR, "DLLREG RegisterServerHelper() Failed to load Advpack.dll");

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** DllAddref ***
//
//    Increment the Dll ref counts.
//
////////////////////////////////////////////////////////////////////////////////
void
DllAddRef(
    void
)
{
    ASSERT (g_cDllRef < (ULONG)-1);

    InterlockedIncrement((PLONG)&g_cDllRef);

    TraceMsg(TF_OBJECTS, "%d Dll ref count", g_cDllRef);

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** DllRelease ***
//
//    Decrements the Dll ref counts.
//
////////////////////////////////////////////////////////////////////////////////
void
DllRelease(
    void
)
{
    ASSERT( 0 != g_cDllRef );

    LONG cRef = InterlockedDecrement((PLONG)&g_cDllRef);

    TraceMsg(TF_OBJECTS, "%d Dll ref count", cRef);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\enum.h ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// enum.h 
//
//   The definition of the cdf enumerator.
//
//   History:
//
//       3/17/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Check for previous includes of this file.
//

#ifndef _ENUM_H_

#define _ENUM_H_

//
// Class definition for the cdf enumerator class.
//

class CCdfEnum : public IEnumIDList
{
//
// Methods
//

public:

    // Constructor
    CCdfEnum(IXMLElementCollection* pIXMLElementCollection,
             DWORD fEnumerateFlags, PCDFITEMIDLIST pcdfidlFolder);

    // IUnknown
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumIDList **ppenum);
 
private:

    // Destructor
    ~CCdfEnum(void);

    // Helper methods
    LPITEMIDLIST NextCdfidl(void);
    HRESULT      GetNextCdfElement(IXMLElement** ppIXMLElement,PULONG pnIndex);
    inline BOOL  IsCorrectType(IXMLElement* pIXMLElement);

//
// Member variables.
//

private:

    ULONG                   m_cRef;
    IXMLElementCollection*  m_pIXMLElementCollection;
    DWORD                   m_fEnumerate;
    ULONG                   m_nCurrentItem;
    PCDFITEMIDLIST          m_pcdfidlFolder;
    BOOL                    m_fReturnedFolderPidl;
};


#endif _ENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\exticon.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// exticon.cpp 
//
//   IExtractIcon com object.  Used by the shell to obtain icons.
//
//   History:
//
//       3/21/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "resource.h"
#include "cdfidl.h"
#include "xmlutil.h"
#include "exticon.h"
#include "dll.h"
#include "persist.h"

//
// Constructor and destructor.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::CExtractIcon ***
//
//    Constructor.
//
////////////////////////////////////////////////////////////////////////////////
CExtractIcon::CExtractIcon (
    PCDFITEMIDLIST pcdfidl,
    IXMLElementCollection *pIXMLElementCollection
)
: m_cRef(1)
{
    ASSERT(CDFIDL_IsValid(pcdfidl));
    ASSERT(ILIsEmpty(_ILNext((LPITEMIDLIST)pcdfidl)));
    ASSERT(XML_IsCdfidlMemberOf(pIXMLElementCollection, pcdfidl));

    ASSERT(NULL == m_bstrIconURL);
    ASSERT(FALSE == m_fGleam);

    //
    // Set the default icon type.
    //

    if (CDFIDL_IsFolderId(&pcdfidl->mkid))
    {
        m_iconType = IDI_CLOSESUBCHANNEL;
    }
    else
    {
        m_iconType = IDI_STORY;
    }

    //
    // Get the URL for the custom icon.
    //

    if (pIXMLElementCollection)
    {
        IXMLElement* pIXMLElement;

        HRESULT hr;

        if (CDFIDL_GetIndex(pcdfidl) != -1)
        {
            hr = XML_GetElementByIndex(pIXMLElementCollection,
                                       CDFIDL_GetIndex(pcdfidl), &pIXMLElement);
        }
        else
        {
            IXMLElement *pIXMLElementChild;

            hr = XML_GetElementByIndex(pIXMLElementCollection, 0, &pIXMLElementChild);

            if (pIXMLElementChild)
            {
                hr = pIXMLElementChild->get_parent(&pIXMLElement);
                if (!pIXMLElement)
                {
                    ASSERT(FALSE);
                    hr = E_FAIL;
                }
                pIXMLElementChild->Release();
            }
        }

        if (SUCCEEDED(hr))
        {
            ASSERT(pIXMLElement);

            m_bstrIconURL = XML_GetAttribute(pIXMLElement, XML_ICON);

            pIXMLElement->Release();
        }
    }

    //
    // Don't allow the DLL to unload.
    //

    TraceMsg(TF_OBJECTS, "+ IExtractIcon");

    DllAddRef();

    return;
}

// Used for initializing the Root Element
CExtractIcon::CExtractIcon (
    PCDFITEMIDLIST pcdfidl,
    IXMLElement *pElem
)
: m_cRef(1)
{
    ASSERT(CDFIDL_IsValid(pcdfidl));
    ASSERT(ILIsEmpty(_ILNext((LPITEMIDLIST)pcdfidl)));
    ASSERT(NULL == m_bstrIconURL);
    ASSERT(FALSE == m_fGleam);

    //
    // Set the default icon type.
    //


    m_iconType = IDI_CHANNEL;
    

    //
    // Get the URL for the custom icon.
    //

    if (pElem)
    {
        HRESULT hr; 
        IXMLElement *pDeskElem;
        LONG nIndex;
        
        hr = XML_GetDesktopElementFromChannelElement(pElem, &pDeskElem, &nIndex);
        if (SUCCEEDED(hr))
        {
            m_iconType = IDI_DESKTOP;
            pDeskElem->Release();
        }
            
        m_bstrIconURL = XML_GetAttribute(pElem, XML_ICON);
    }

    //
    // Don't allow the DLL to unload.
    //

    TraceMsg(TF_OBJECTS, "+ IExtractIcon");

    DllAddRef();

    return;
}

// this constructor is used for the default channel case where
// we draw the icon information from the desktop.ini case 
// to avoid having to parse the XML stuff

CExtractIcon::CExtractIcon( BSTR pstrPath ) : m_cRef(1)
{
    ASSERT(NULL == m_bstrIconURL);
    ASSERT(FALSE == m_fGleam);
    
    m_iconType = IDI_CHANNEL;
    
    m_bstrIconURL = SysAllocString( pstrPath );
    
    DllAddRef();
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::~CExtractIcon ***
//
//    Destructor.
//
////////////////////////////////////////////////////////////////////////////////
CExtractIcon::~CExtractIcon (
    void
)
{
    ASSERT(0 == m_cRef);

    if (m_bstrIconURL)
        SysFreeString(m_bstrIconURL);

    //
    // Matching Release for the constructor Addref.
    //

    TraceMsg(TF_OBJECTS, "- IExtractIcon");

    DllRelease();

    return;
}


//
// IUnknown methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::QueryInterface ***
//
//    CExtractIcon QI.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CExtractIcon::QueryInterface (
    REFIID riid,
    void **ppv
)
{
    ASSERT(ppv);

    HRESULT hr;

    if (IID_IUnknown == riid || IID_IExtractIcon == riid)
    {
        AddRef();
        *ppv = (IExtractIcon*)this;
        hr = S_OK;
    }
#ifdef UNICODE
    else if (IID_IExtractIconA == riid)
    {
        AddRef();
        *ppv = (IExtractIconA*)this;
        hr = S_OK;
	}
#endif
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && NULL == *ppv));

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::AddRef ***
//
//    CExtractIcon AddRef.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CExtractIcon::AddRef (
    void
)
{
    ASSERT(m_cRef != 0);
    ASSERT(m_cRef < (ULONG)-1);

    return ++m_cRef;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::Release ***
//
//    CExtractIcon Release.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CExtractIcon::Release (
    void
)
{
    ASSERT (m_cRef != 0);

    ULONG cRef = --m_cRef;
    
    if (0 == cRef)
        delete this;

    return cRef;
}


//
// IExtractIcon methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::GetIconLocation ***
//
//
// Description:
//     Returns a name index pair for the icon associated with this cdf item.
//
// Parameters:
//     [In]  uFlags     - GIL_FORSHELL, GIL_OPENICON.
//     [Out] szIconFile - The address of the buffer that receives the associated
//                        icon name.  It can be a filename, but doesn't have to
//                        be.
//     [In]  cchMax     - Size of the buffer that receives the icon location.
//     [Out] piIndex    - A pointer that receives the icon's index.
//     [Out] pwFlags    - A pointer the receives flags about the icon.
//
// Return:
//     S_OK if an was found.
//     S_FALSE if the shell should supply a default icon.
//
// Comments:
//     The shell can cache an icon associated with a name index pair. This
//     improves performance on subsequent calls for an icon with the same name
//     index pair.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CExtractIcon::GetIconLocation(
    UINT uFlags,
    LPTSTR szIconFile,
    UINT cchMax,
    int *piIndex,
    UINT *pwFlags
)
{
    ASSERT(szIconFile);
    ASSERT(piIndex);
    ASSERT(pwFlags);

    HRESULT hr = E_FAIL;

    //TraceMsg(TF_CDFICON, "<IN>  CExtractIcon::GetLocation (icon) tid:0x%x",
    //         GetCurrentThreadId());

    if (m_bstrIconURL && (uFlags & GIL_ASYNC))
    {
        hr = E_PENDING;
    }
    else
    {
        if (m_bstrIconURL)
        {
            hr = GetCustomIconLocation(uFlags, szIconFile, cchMax, piIndex,
                                       pwFlags);

            if (FAILED(hr))
            {
                SysFreeString(m_bstrIconURL);
                m_bstrIconURL = NULL;
            }
        }

        if (FAILED(hr))
        {
            hr = GetDefaultIconLocation(uFlags, szIconFile, cchMax, piIndex,
                                        pwFlags);
        }

        //
        // If szIconFile is a path the shell will only use the filename part
        // of the path as the cache index.  To ensure a unique index the full
        // path must be used.  This is accomplished by modifying the path string
        // so it is no longer recognized as a path.
        //

        if (SUCCEEDED(hr) && INDEX_IMAGE == *piIndex)
            MungePath(szIconFile);

        if (FAILED(hr))
        {
            *szIconFile = TEXT('\0');
            *piIndex = 0;

            hr = S_FALSE;  // The shell will use a default icon.
        }


        ASSERT((S_OK == hr && *szIconFile) ||
               (S_FALSE == hr && 0 == *szIconFile));
    }

    //TraceMsg(TF_CDFICON, "<OUT> CExtractIcon::GetLocation (icon) tid:0x%x",
    //         GetCurrentThreadId());

    return hr;
}
#ifdef UNICODE
// IExtractIconA methods.
STDMETHODIMP
CExtractIcon::GetIconLocation(
    UINT uFlags,
    LPSTR szIconFile,
    UINT cchMax,
    int *piIndex,
    UINT *pwFlags
)
{
    HRESULT hr;
    WCHAR* pszIconFileW = new WCHAR[cchMax];
    if (pszIconFileW == NULL)
        return ERROR_OUTOFMEMORY;

    hr = GetIconLocation(uFlags, pszIconFileW, cchMax, piIndex, pwFlags);
    if (SUCCEEDED(hr))
        SHUnicodeToAnsi(pszIconFileW, szIconFile, cchMax);

    delete [] pszIconFileW;
    return hr;
}
#endif
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::Extract ***
//
//
// Description:
//     Return an icon given the name index pair returned from GetIconLocation.
//
// Parameters:
//     [In]  pszFile     - A pointer to the name associated with the requested
//                         icon.
//     [In]  nIconIndex  - An index associated with the requested icon.
//     [Out] phiconLarge - Pointer to the variable that receives the handle of
//                         the large icon.
//     [Out] phiconSmall - Pointer to the variable that receives the handle of
//                         the small icon.
//     [Out] nIconSize   - Value specifying the size, in pixels, of the icon
//                         required. The LOWORD and HIWORD specify the size of
//                         the large and small icons, respectively.
//
// Return:
//     S_OK if the icon was extracted.
//     S_FALSE if the shell should extract the icon assuming the name is a
//     filename and the index is the icon index.
//
// Comments:
//     The shell may cache the icon returned from this function.
//
//     If the icon index indicates that the icon is specified by an internet
//     image then custom extraction is required.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CExtractIcon::Extract(
    LPCTSTR pszFile,
    UINT nIconIndex,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize
)
{
    HRESULT hr;

    TCHAR  szPath[MAX_PATH];
    TCHAR* pszPath = szPath;

    StrCpyN(szPath, pszFile, ARRAYSIZE(szPath) - 1);

    //TraceMsg(TF_CDFICON, "<IN>  CExtractIcon::Extract (icon) tid:0x%x",
    //         GetCurrentThreadId());

    if (INDEX_IMAGE == nIconIndex)
    {
        DemungePath(pszPath);

        if (m_fGleam && *pszPath == TEXT('G'))
        {
            pszPath++;
        }

        IImgCtx* pIImgCtx;

        HANDLE hExitThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (hExitThreadEvent)
        {
#ifdef UNIX
            unixEnsureFileScheme(pszPath);
#endif /* UNIX */
            hr = SynchronousDownload(pszPath, &pIImgCtx, hExitThreadEvent);

            if (SUCCEEDED(hr))
            {
                ASSERT(pIImgCtx);

                *phiconLarge = ExtractImageIcon(LOWORD(nIconSize), pIImgCtx,
                                                m_fGleam);
                *phiconSmall = ExtractImageIcon(HIWORD(nIconSize), pIImgCtx,
                                                m_fGleam);
                pIImgCtx->Release();
            }

            SetEvent(hExitThreadEvent);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (m_fGleam)
    {
        // Add gleam to icon for the shell

        hr = ExtractGleamedIcon(pszPath + 1, nIconIndex, 0, 
                phiconLarge, phiconSmall, nIconSize);
    }
    else
    {
        hr = S_FALSE;  // Let shell extract it.
    }

    //TraceMsg(TF_CDFICON, "<OUT> CExtractIcon::Extract (icon) tid:0x%x",
    //         GetCurrentThreadId());

    return hr;
}
#ifdef UNICODE
STDMETHODIMP
CExtractIcon::Extract(
    LPCSTR pszFile,
    UINT nIconIndex,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize)
{
    HRESULT hr;
    int    cch = lstrlenA(pszFile) + 1; 
    WCHAR* pszFileW = new WCHAR[cch];
    if (pszFileW == NULL)
        return ERROR_OUTOFMEMORY;

    SHAnsiToUnicode(pszFile, pszFileW, cch);

    hr = Extract(pszFileW, nIconIndex, phiconLarge, phiconSmall, nIconSize);

    delete [] pszFileW;
    return hr;
}
#endif
//
// Helper functions.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::GetCustomIconLocation ***
//
//
// Description:
//     Gets the location string name for an icon specified via a LOGO element
//     in a cdf.
//
// Parameters:
//     [In]  uFlags     - GIL_FORSHELL, GIL_OPENICON.
//     [Out] szIconFile - The address of the buffer that receives the associated
//                        icon name.
//     [In]  cchMax     - Size of the buffer that receives the icon location.
//     [Out] piIndex    - A pointer that receives the icon's index.
//     [Out] pwFlags    - A pointer the receives flags about the icon.
//
// Return:
//     S_OK if the custom icon location was determined.
//     E_FAIL if the location couldn't be determined.
//
// Comments:
//     If the extension of the image url isn't .ico then it's treated as an
//     internet image file.  IImgCtx is used to convert these files into icons.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CExtractIcon::GetCustomIconLocation(
    UINT uFlags,
    LPTSTR szIconFile,
    UINT cchMax,
    int *piIndex,
    UINT *pwFlags
)
{
    ASSERT(szIconFile);
    ASSERT(piIndex);
    ASSERT(pwFlags);

    HRESULT hr;

    ASSERT(m_bstrIconURL);

    *piIndex = 0;
    *pwFlags = 0;

    TCHAR szURL[INTERNET_MAX_URL_LENGTH];
  
    if (SHUnicodeToTChar(m_bstrIconURL, szURL, ARRAYSIZE(szURL)))
    {
        hr = URLGetLocalFileName(szURL, szIconFile, cchMax, NULL);

        #ifdef DEBUG
            if (SUCCEEDED(hr))
            {
                TraceMsg(TF_CDFICON, "[URLGetLocalFileName %s]", szIconFile);
            }
            else
            {
                TraceMsg(TF_CDFICON, "[URLGetLocalFileName %s FAILED]",
                         szURL);
            }
        #endif // DEBUG

        //hr = URLDownloadToCacheFile(NULL, szURL, szIconFile, cchMax, 0, NULL);

        if (SUCCEEDED(hr))
        {
            LPTSTR pszExt = PathFindExtension(szIconFile);

            if (*pszExt != TEXT('.') || 0 != StrCmpI(pszExt, TSTR_ICO_EXT))
                *piIndex = INDEX_IMAGE;
        }
    }
    else
    {
        *szIconFile = TEXT('\0');

        hr = E_FAIL;
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::GetDefaultIconLocation ***
//
//
// Description:
//     Return the location of the defualt icon.
//
// Parameters:
//     [In]  uFlags     - GIL_FORSHELL, GIL_OPENICON.
//     [Out] szIconFile - The address of the buffer that receives the associated
//                        icon name.
//     [In]  cchMax     - Size of the buffer that receives the icon location.
//     [Out] piIndex    - A pointer that receives the icon's index.
//     [Out] pwFlags    - A pointer the receives flags about the icon.
//
// Return:
//     S_OK if the default location is returned.
//     E_FAIL otherwise.
//
// Comments:
//     The default icons are in the resource file.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CExtractIcon::GetDefaultIconLocation(
    UINT uFlags,
    LPTSTR szIconFile,
    UINT cchMax,
    int *piIndex,
    UINT *pwFlags
)
{
    ASSERT(szIconFile);
    ASSERT(piIndex);
    ASSERT(pwFlags);

    HRESULT hr;

    *pwFlags = 0;

    ASSERT(g_szModuleName[0]);

    StrCpyN(szIconFile, g_szModuleName, cchMax);

    if (*szIconFile)
    {
        switch (m_iconType)
        {
            case IDI_STORY:
            case IDI_CHANNEL:
            case IDI_DESKTOP:
                *piIndex = - m_iconType;
                break;

            default:
                *piIndex = (uFlags & GIL_OPENICON) ? 
                                (-IDI_OPENSUBCHANNEL) : 
                                (-IDI_CLOSESUBCHANNEL);
                break;
        }
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    ASSERT((SUCCEEDED(hr) && *szIconFile) || FAILED(hr));

    return hr;
}

struct ThreadData
{
    HANDLE hEvent;
    HANDLE hExitThreadEvent;
    IImgCtx * pImgCtx;
    LPCWSTR pszBuffer;
    HRESULT * pHr;
};

DWORD CALLBACK SyncDownloadThread( LPVOID pData )
{
    ThreadData * pTD = (ThreadData * ) pData;

    HANDLE hExitThreadEvent = pTD->hExitThreadEvent;

    CoInitialize(NULL);
    pTD->pImgCtx = NULL;
    
    HRESULT hr;
    hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                          IID_IImgCtx, (void**)&(pTD->pImgCtx));
    if (SUCCEEDED(hr))
    {
        hr = pTD->pImgCtx->Load(pTD->pszBuffer, 0);

        if (SUCCEEDED(hr))
        {
            ULONG fState;
            SIZE  sz;

            pTD->pImgCtx->GetStateInfo(&fState, &sz, TRUE);

            if (!(fState & (IMGLOAD_COMPLETE | IMGLOAD_ERROR)))
            {
                BOOL fDone = FALSE;

                hr = pTD->pImgCtx->SetCallback(ImgCtx_Callback, &fDone);

                if (SUCCEEDED(hr))
                {
                    hr = pTD->pImgCtx->SelectChanges(IMGCHG_COMPLETE, 0, TRUE);

                    if (SUCCEEDED(hr))
                    {
                        MSG msg;
                        BOOL fMsg;

                        // HACK: restrict the message pump to those messages we know that URLMON and
                        // HACK: the imageCtx stuff needs, otherwise we will be pumping messages for
                        // HACK: windows we shouldn't be pumping right now...
                        while(!fDone )
                        {
                            fMsg = PeekMessage(&msg, NULL, WM_USER + 1, WM_USER + 4, PM_REMOVE );

                            if (!fMsg)
                            {
                                fMsg = PeekMessage( &msg, NULL, WM_APP + 2, WM_APP + 2, PM_REMOVE );
                            }

                            if (!fMsg)
                            {
                                // go to sleep until we get a new message....
                                WaitMessage();
                                continue;
                            }

                            TranslateMessage(&msg);
                            DispatchMessage(&msg);
                        }

                    }
                }

            }

            hr = pTD->pImgCtx->GetStateInfo(&fState, &sz, TRUE);

            if (SUCCEEDED(hr))
                hr = (fState & IMGLOAD_ERROR) ? E_FAIL : S_OK;
        }

        // Must disconnect on the same thread that SetCallback is
        // done.  This object becomes a primary object on the thread
        // which connects the callback function.  The primary object
        // count is decremented when Disconnect is called, or when the
        // object is released.  In this case, the release is definitely
        // going to happen on a different thread than this one, so we
        // need to disconnect the callback function right now before
        // returning.  There is no further needs for callbacks at this
        // point.

        pTD->pImgCtx->Disconnect();
    }

    if ( FAILED( hr ) && pTD->pImgCtx )
    {
        pTD->pImgCtx->Release();
        pTD->pImgCtx = NULL;
    }
    
    *(pTD->pHr) = hr;
    
    SetEvent( pTD->hEvent );

    //
    // Wait for the calling thread to finish up with IImgCtx before 
    // CoUninitialize gets called.
    //

    WaitForSingleObject(hExitThreadEvent, INFINITE);
    CloseHandle(hExitThreadEvent);

    CoUninitialize();

    return 0;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::SynchronousDownload ***
//
//
// Description:
//     Synchronously downloads the image associated with the image context.
//
// Parameters:
//     [In]  szFile           - The local (already in cache) file name of the
//                              image.
//     [In]  pIImgCtx         - A pointer to the image context.
//     [In]  hExitThreadEvent - An event that gets signaled when the IImgCtx
//                              object is no longer in use.
//
// Return:
//     S_OK if the image was successfully downloaded.
//     E_FAIL if the image wasn't downloaded.
//
// Comments:
//     The image context object doesn't directly support synchronous download.
//     Here a message loop is used to make sure ulrmon keeps geeting messages
//     and the download progresses.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CExtractIcon::SynchronousDownload(
    LPCTSTR  pszFile,
    IImgCtx** ppIImgCtx,
    HANDLE hExitThreadEvent
)
{
    ASSERT(ppIImgCtx);

    HRESULT hr;

    TraceMsg(TF_CDFPARSE, "[*** IImgCtx downloading logo %s ***]",
             pszFile);
    TraceMsg(TF_CDFICON, "[*** IImgCtx downloading logo %s ***]",
             pszFile);

    WCHAR szFileW[MAX_PATH];

    SHTCharToUnicode(pszFile, szFileW, ARRAYSIZE(szFileW));

    ThreadData rgData;
    rgData.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( rgData.hEvent == NULL )
    {
        CloseHandle(hExitThreadEvent);
        return E_OUTOFMEMORY;
    }

    rgData.hExitThreadEvent = hExitThreadEvent;
    rgData.pszBuffer = szFileW;
    rgData.pHr = &hr;

    *ppIImgCtx = NULL;
    
    if ( SHCreateThread( SyncDownloadThread, &rgData, 0, NULL ))
    {
        WaitForSingleObject( rgData.hEvent, INFINITE );
        *ppIImgCtx = rgData.pImgCtx;
    }
    else
    {
        CloseHandle(hExitThreadEvent);
        hr = E_OUTOFMEMORY;
    }

    CloseHandle( rgData.hEvent );

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::ExtractImageIcon ***
//
//
// Description:
//     Returns an HICON for the image in IImgCtx.
//
// Parameters:
//     [In]  wSize      - The height and width of the icon,
//     [In]  pIImgCtx   - The image to convert into an icon.
//     [In]  fDrawGleam - TRUE if a gleam should be added, FALSE otherwise.
//
// Return:
//     An hicon of size nSize for the given IImgCtx.
//     NULL on failure.
//
// Comments:
//     Uses the image in IImgCtx to create bitmaps to pass to
//     CreateIconIndirect.
//
////////////////////////////////////////////////////////////////////////////////
HICON
CExtractIcon::ExtractImageIcon(
    WORD wSize,
    IImgCtx* pIImgCtx,
    BOOL fDrawGleam
)
{
    ASSERT(pIImgCtx);

    HICON hiconRet = NULL;

    HDC hdcScreen = GetDC(NULL);

    if (hdcScreen)
    {
        HBITMAP hbmImage = CreateCompatibleBitmap(hdcScreen, wSize, wSize);

        if (hbmImage)
        {
            HBITMAP hbmMask = CreateBitmap(wSize, wSize, 1, 1, NULL);

            if (hbmMask)
            {
                SIZE sz;
                sz.cx = sz.cy = wSize;

                if (SUCCEEDED(CreateImageAndMask(pIImgCtx, hdcScreen, &sz,
                                                 &hbmImage, &hbmMask,
                                                 fDrawGleam)))
                {
                    ICONINFO ii;

                    ii.fIcon    = TRUE;
                    ii.hbmMask  = hbmMask;
                    ii.hbmColor = hbmImage;

                    hiconRet = CreateIconIndirect(&ii); 
                }

                DeleteObject(hbmMask);
            }

            DeleteObject(hbmImage);
        }

        ReleaseDC(NULL, hdcScreen);
    }

    return hiconRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::CreateImageAndMask ***
//
//
// Description:
//     Create the image and mask bitmaps that get used by CreateIconIndirect,
//
// Parameters:
//    [In]  IImgCtx       - The internet image.
//    [In]  hdcScreen     - The screen hdc.
//    [In]  pSize         - The size of the image and mask bitmaps.
//    [In Out] phbmImage  - A pointer to the handle of the Image bitmap.
//    [In Out] phbmMask   - A pointer to the handle of the Mask bitmap.
//    [In]  fDrawGleam    - TRUE if a gleam should be added, FALSE otherwise.
//
// Return:
//    S_OK if the image and mask bitmaps where successfully created.
//    E_FAIL if the image or mask couldn't be created.
//
// Comments:
//    The image bitmap has the opaque section come through and the transparent
//    sections set to black.
//
//    The mask has the transparent sections set to 1 and the opaque sections to
//    0.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CExtractIcon::CreateImageAndMask(
    IImgCtx* pIImgCtx,
    HDC hdcScreen,
    SIZE* pSize,
    HBITMAP* phbmImage,
    HBITMAP* phbmMask,
    BOOL fDrawGleam
)
{
    ASSERT(pIImgCtx);
    ASSERT(phbmImage);
    ASSERT(phbmMask);

    HRESULT hr = E_FAIL;

    HDC hdcImgDst = CreateCompatibleDC(NULL);
    if (hdcImgDst)
    {
        HGDIOBJ hbmOld = SelectObject(hdcImgDst, *phbmImage);
        if (hbmOld)
        {
            if (ColorFill(hdcImgDst, pSize, COLOR1))
            {
                hr = StretchBltImage(pIImgCtx, pSize, hdcImgDst, fDrawGleam);

                if (SUCCEEDED(hr))
                {
                    hr = CreateMask(pIImgCtx, hdcScreen, hdcImgDst, pSize,
                                    phbmMask, fDrawGleam); 
                }
            }
            SelectObject(hdcImgDst, hbmOld);
        }
        DeleteDC(hdcImgDst);
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::StretchBltImage ***
//
//
// Description:
//     Stretches the image associated with IImgCtx to the given size and places
//     the result in the given DC.
//
// Parameters:
//     [In]  pIImgCtx  - The image context for the image.
//     [In]  pSize     - The size of the resultant image.
//     [In/Out] hdcDst - The destination DC of the stretch blt.
//
// Return:
//     S_OK if the image was successfully resized into the destination DC.
//     E_FAIL otherwise.
//
// Comments:
//     The destination DC already has a bitmap of pSize selected into it.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CExtractIcon::StretchBltImage(
    IImgCtx* pIImgCtx,
    const SIZE* pSize,
    HDC hdcDst,
    BOOL fDrawGleam
)
{
    ASSERT(pIImgCtx);
    ASSERT(hdcDst);

    HRESULT hr;

    SIZE    sz;
    ULONG   fState;

    hr = pIImgCtx->GetStateInfo(&fState, &sz, FALSE);

    if (SUCCEEDED(hr))
    {
        hr = pIImgCtx->StretchBlt(hdcDst, 0, 0, pSize->cx, pSize->cy, 0, 0,
                                  sz.cx, sz.cy, SRCCOPY);

        ASSERT(SUCCEEDED(hr) && "Icon extraction pIImgCtx->StretchBlt failed!");

        if (fDrawGleam)
        {
            hr = E_FAIL;

            HANDLE hGleam = LoadImage(g_hinst, TEXT("ICONGLEAM"),
                                      IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);

            if (hGleam)
            {
                if (DrawIconEx(hdcDst, 0, 0, (HICON)hGleam, pSize->cx, pSize->cy, 0, NULL,DI_NORMAL))
                    hr = S_OK;

                DeleteObject(hGleam);
            }            
        }
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::CreateMask ***
//
//
// Description:
//     Creates the mask for an icon and also adjusts the image bitmap for use
//     with the mask.
//
// Parameters:
//     [In]  pIImgCtx   - The original image.
//     [In]  hdcScreen  - A screen dc.
//     [In/Out] hdc1    - The DC containing the image bitmap.
//     [In]  pSize      - The size of the bitmaps.
//     [In/Out] phbMask - A pointer to the handle of the mask bitmap
//
// Return:
//     S_OK if the mask is properly constructed.
//     E_FAIL otherwise.
//
// Comments:
//     The mask is created by first drawing the original image into a bitmap
//     with background COLOR1.  Then the same image is drawn into another
//     bitmap but this bitmap has background of COLOR2.  These two bitmaps
//     are XOR'ed and the opaque sections come out 0 while the transparent
//     sections are COLOR1 XOR COLOR2.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT
CExtractIcon::CreateMask(
    IImgCtx* pIImgCtx,
    HDC hdcScreen,
    HDC hdc1,
    const SIZE* pSize,
    HBITMAP* phbMask,
    BOOL fDrawGleam
)
{
    ASSERT(hdc1);
    ASSERT(pSize);
    ASSERT(phbMask);

    HRESULT hr = E_FAIL;

    HDC hdc2 = CreateCompatibleDC(NULL);
    if (hdc2)
    {
        HBITMAP hbm2 = CreateCompatibleBitmap(hdcScreen, pSize->cx, pSize->cy);
        if (hbm2)
        {
            HGDIOBJ hbmOld2 = SelectObject(hdc2, hbm2);
            if (hbmOld2)
            {
                ColorFill(hdc2, pSize, COLOR2);

                hr = StretchBltImage(pIImgCtx, pSize, hdc2, fDrawGleam);

#ifndef UNIX
                if (SUCCEEDED(hr) &&
                    BitBlt(hdc2, 0, 0, pSize->cx, pSize->cy, hdc1, 0, 0,
                           SRCINVERT))
                {
                    if (GetDeviceCaps(hdcScreen, BITSPIXEL) <= 8)
                    {
                        //
                        // 6 is the XOR of the index for COLOR1 and the index
                        // for COLOR2.
                        //

                        SetBkColor(hdc2, PALETTEINDEX(6));
                    }
                    else
                    {
                        SetBkColor(hdc2, (COLORREF)(COLOR1 ^ COLOR2));
                    }

                    HDC hdcMask = CreateCompatibleDC(NULL);
                    if (hdcMask)
                    {
                        HGDIOBJ hbmOld = SelectObject(hdcMask, *phbMask);
                        if (hbmOld)
                        {
                            if (BitBlt(hdcMask, 0, 0, pSize->cx, pSize->cy, hdc2, 0,
                                       0, SRCCOPY))
                            {
                                //
                                // RasterOP 0x00220326 does a copy of the ~mask bits
                                // of hdc1 and sets everything else to 0 (Black).
                                //

                                if (BitBlt(hdc1, 0, 0, pSize->cx, pSize->cy, hdcMask,
                                           0, 0, 0x00220326))
                                {
                                    hr = S_OK;
                                }
                            }
                            SelectObject(hdcMask, hbmOld);
                        }
                        DeleteDC(hdcMask);
                    }
                }
#else
        SetBkColor(hdc2, COLOR2);
        HDC hdcMask = CreateCompatibleDC(NULL);
        if (hdcMask)
        {
            HGDIOBJ hbmOld = SelectObject(hdcMask, *phbMask);
            if (hbmOld)
            {
            if (BitBlt(hdcMask, 0, 0, pSize->cx, pSize->cy, hdc2, 0,
                   0, SRCCOPY))
                {
                            //
                            // RasterOP 0x00220326 does a copy of the ~mask bits
                            // of hdc1 and sets everything else to 0 (Black).
                            //

                if (BitBlt(hdc1, 0, 0, pSize->cx, pSize->cy, hdcMask,
                       0, 0, 0x00220326))
                  {
                hr = S_OK;
                  }
              }
              SelectObject(hdcMask, hbmOld);
              }
              DeleteDC(hdcMask);
          }
#endif /* UNIX */
                SelectObject(hdc2, hbmOld2);
            }

            DeleteObject(hbm2);
        }

        DeleteDC(hdc2);
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** ImgCtx_Callback ***
//
//
// Description:
//     Callback function for IImgCtx loads.
//
// Parameters:
//     [In]  pIImgCtx - Not Used.
//     [Out] pfDone   - Set to TRUE on this callback.  
//
// Return:
//     None.
//
// Comments:
//     This callback gets called if IImgCtx is finished downloading an image.
//     It is used in CExtractIcon and CIconHandler.
//
////////////////////////////////////////////////////////////////////////////////
void
CALLBACK
ImgCtx_Callback(
    void* pIImgCtx,
    void* pfDone
)
{
    ASSERT(pfDone);

    *(BOOL*)pfDone = TRUE;

    return;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::ColorFill ***
//
//
// Description:
//     Fills the given bitmap with the given color.
//
// Parameters:
//     [In/Out] hdc - The hdc that contains the bitmap.
//     [In]  pSize  - the size of the bitmap.
//     [In]  clr    - The color used to fill in the bitmap.
//
// Return:
//     TRUE if the bitmap was filled with color clr.
//     FALSE if the itmap wasn't filled.
//
////////////////////////////////////////////////////////////////////////////////
BOOL
CExtractIcon::ColorFill(
    HDC hdc,
    const SIZE* pSize,
    COLORREF clr
)
{
    ASSERT(hdc);

    BOOL fRet = FALSE;

    HBRUSH hbSolid = CreateSolidBrush(clr);
    if (hbSolid)
    {
        HGDIOBJ hbOld = SelectObject(hdc, hbSolid);
        if (hbOld)
        {
            PatBlt(hdc, 0, 0, pSize->cx, pSize->cy, PATCOPY);
            fRet = TRUE;

            SelectObject(hdc, hbOld);
        }
        DeleteObject(hbSolid);
    }

    return fRet;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::ExtractGleamedIcon ***
//
//
// Description:
//     Extracts icon resources and applies gleams to them.
//
// Parameters:
//      [In] pszIconFile - path to the icon
//      [In] iIndex - index of icon with the file
//      [In] uFlags - ignore, pass 0
//      [Out] phiconLarge - HICON in large format with gleam
//      [Out] phiconSmall - HICON in small format with gleam
//
// Return:
//      S_OK if success
//      S_FALSE if the file has no icons (or not the asked for icon)
//      E_FAIL for files on a slow link.
//      E_FAIL if cant access the file
//      E_FAIL if gleam icon construction failed
//
////////////////////////////////////////////////////////////////////////////////
HRESULT 
CExtractIcon::ExtractGleamedIcon(
    LPCTSTR pszIconFile, 
    int iIndex, 
    UINT uFlags,
    HICON *phiconLarge, 
    HICON *phiconSmall, 
    UINT nIconSize)
{
    HICON   hIconLargeShell, hIconSmallShell;
    HRESULT hr;

    hr = Priv_SHDefExtractIcon(pszIconFile, iIndex, uFlags, 
                &hIconLargeShell, &hIconSmallShell, nIconSize);

    if (FAILED(hr))
        goto cleanup1;

    if (hIconLargeShell)
    {
        hr = ApplyGleamToIcon(hIconLargeShell, LOWORD(nIconSize), phiconLarge);
        if (FAILED(hr))
            goto cleanup2;
    }

    if (hIconSmallShell)
    {
        hr = ApplyGleamToIcon(hIconSmallShell, HIWORD(nIconSize), phiconSmall);
        if (FAILED(hr))
            goto cleanup3;
    }
    
cleanup3:
    if (FAILED(hr) && *phiconLarge)
    {
        DestroyIcon(*phiconLarge);
        *phiconLarge = NULL;
    }
    
cleanup2:
    if (hIconLargeShell)
        DestroyIcon(hIconLargeShell);
        
    if (hIconSmallShell)        
        DestroyIcon(hIconSmallShell);
        
cleanup1:
    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CExtractIcon::ApplyGleamToIcon ***
//
//
// Description:
//     Makes a gleamed version of an icon.
//
// Parameters:
//      [In] hIcon - icon that needs to be gleamed
//      [In] nSize - size of icon in pixels
//      [Out] phGleamIcon - variable to contain the gleamed icon
//      
//
// Return:
//      S_OK if success
//      E_FAIL if unsuccessful
//
////////////////////////////////////////////////////////////////////////////////
HRESULT 
CExtractIcon::ApplyGleamToIcon(
    HICON hIcon1, 
    ULONG nSize,
    HICON *phGleamedIcon)
{
    HRESULT hr = E_FAIL;

    HICON hIcon2 = (HICON)LoadImage(g_hinst, TEXT("ICONGLEAM"), IMAGE_ICON,
                                    nSize, nSize, 0);

    if (hIcon2)
    {
        HDC dc = GetDC(NULL);

        if (dc)
        {
            ICONINFO ii1, ii2;

            if (GetIconInfo(hIcon1, &ii1) && GetIconInfo(hIcon2, &ii2))
            {
                HDC dcSrc = CreateCompatibleDC(dc);

                if (dcSrc)
                {

                    HDC dcDst = CreateCompatibleDC(dc);

                    if (dcDst)
                    {
                        HBITMAP bmMask = CreateBitmap(nSize, nSize, 1, 1, NULL);

                        if (bmMask)
                        {
                            HBITMAP bmImage = CreateCompatibleBitmap(dc, nSize,
                                                                     nSize);

                            if (bmImage)
                            {
                                int cx1, cy1, cx2, cy2;
                                GetBitmapSize(ii1.hbmMask, &cx1, &cy1);
                                GetBitmapSize(ii2.hbmMask, &cx2, &cy2);

                                //
                                // Mask
                                //

                                HBITMAP hbmpOldDst = (HBITMAP)SelectObject(
                                                                        dcDst,
                                                                        bmMask);

                                HBITMAP hbmpOldSrc = (HBITMAP)SelectObject(
                                                                   dcSrc,
                                                                   ii1.hbmMask);
                                StretchBlt(dcDst, 0, 0, nSize, nSize, dcSrc, 0,
                                           0, cx1, cy1, SRCCOPY);

                                SelectObject(dcSrc, ii2.hbmMask);

                                StretchBlt(dcDst, 0, 0, nSize, nSize, dcSrc, 0,
                                           0, cx2, cy2, SRCAND);

                                //
                                // Image.
                                //

                                SelectObject(dcDst, bmImage);

                                SelectObject(dcSrc, ii1.hbmColor);

                                StretchBlt(dcDst, 0, 0, nSize, nSize, dcSrc, 0,
                                           0, cx1, cy1, SRCCOPY);

                                SelectObject(dcSrc, ii2.hbmMask);

                                StretchBlt(dcDst, 0, 0, nSize, nSize, dcSrc, 0,
                                           0, cx2, cy2, SRCAND);

                                SelectObject(dcSrc, ii2.hbmColor);

                                StretchBlt(dcDst, 0, 0, nSize, nSize, dcSrc, 0,
                                           0, cx2, cy2, SRCINVERT);

                                ii1.hbmMask  = bmMask;
                                ii1.hbmColor = bmImage;

                                *phGleamedIcon = CreateIconIndirect(&ii1);

                                if (*phGleamedIcon)
                                    hr = S_OK;

                                SelectObject(dcSrc, hbmpOldSrc);
                                SelectObject(dcDst, hbmpOldDst);

                                DeleteObject(bmImage);
                            }

                            DeleteObject(bmMask);
                        }

                        DeleteDC(dcDst);
                    }

                    DeleteDC(dcSrc);
                }
            }

            ReleaseDC(NULL, dc);
        }

        DestroyIcon(hIcon2);
    }

    return hr;
}

//
// Get the size of the given bitmap.
//

BOOL
CExtractIcon::GetBitmapSize(HBITMAP hbmp, int* pcx, int* pcy)
{
    BOOL fRet;

    BITMAP bm;

    if (GetObject(hbmp, sizeof(bm), &bm))
    {
        *pcx = bm.bmWidth;
        *pcy = bm.bmHeight;
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

//
//  Replace '\' with '*' so the path is nolonger a recognized path name.  This
//  is done in-place and can be called multiple times on the same string.
//

void
MungePath(LPTSTR pszPath)
{
    ASSERT(pszPath);

    while(*pszPath)
    {
        if (TEXT(FILENAME_SEPARATOR) == *pszPath)
            *pszPath = TEXT('*');

        pszPath++;
    }

    return;
}

//
//  Replace '*' with '\'.
//

void
DemungePath(LPTSTR pszPath)
{
    ASSERT(pszPath);

    while(*pszPath)
    {
        if (TEXT('*') == *pszPath)
            *pszPath = TEXT(FILENAME_SEPARATOR);

        pszPath++;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\cdfview\folder.cpp ===
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// folder.cpp 
//
//   IShellFolder for the cdfview class.
//
//   History:
//
//       3/16/97  edwardp   Created.
//
////////////////////////////////////////////////////////////////////////////////

//
// Includes
//

#include "stdinc.h"
#include "resource.h"
#include "cdfidl.h"
#include "xmlutil.h"
#include "persist.h"
#include "cdfview.h"
#include "enum.h"
#include "view.h"
#include "exticon.h"
#include "itemmenu.h"
#include "tooltip.h"



//
// IShellFolder methods.
//

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::ParseDisplayName ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfView::ParseDisplayName(
    HWND hwndOwner,
    LPBC pbcReserved,
    LPOLESTR lpszDisplayName,
    ULONG* pchEaten,
    LPITEMIDLIST* ppidl,
    ULONG* pdwAttributes
)
{
    return E_NOTIMPL;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::EnumObjects ***
//
//
// Description:
//     Returns an enumerator for this folder.
//
// Parameters:
//     [In]  hwndOwner    - Handle of the owner window.  Ignored.
//     [In]  grfFlags     - A combination of Folders, NonFolders and Include
//                          Hidden.
//     [Out] ppenumIdList - A pointer to receive the IEnumIDList interface.
//
// Return:
//     S_OK if the enumrator was created and returned.
//     E_OUTOFMEMORY if the enumerator couldn't be created.
//
// Comments:
//     The caller must Release() the returned enumerator.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfView::EnumObjects(
    HWND hwndOwner,
    DWORD grfFlags,
    LPENUMIDLIST* ppIEnumIDList
)
{
    ASSERT(ppIEnumIDList);

    TraceMsg(TF_CDFENUM, "<IN>  EnumObjects tid:0x%x", GetCurrentThreadId());

    HRESULT hr = S_OK;

    if (!m_bCdfParsed)
    {
        TraceMsg(TF_CDFPARSE, "IShellFolder EnumObjects(%s) %s",
                 hwndOwner ? TEXT("HWND") : TEXT("NULL"),
                 PathFindFileName(m_szPath));
        hr = ParseCdfFolder(NULL, PARSE_LOCAL);
    }

    if (SUCCEEDED(hr))
    {
        *ppIEnumIDList = (IEnumIDList*) new CCdfEnum(m_pIXMLElementCollection,
                                                     grfFlags, m_pcdfidl);

        hr = *ppIEnumIDList ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        *ppIEnumIDList = NULL;
    }


    ASSERT((SUCCEEDED(hr) && *ppIEnumIDList) ||
           (FAILED(hr) && NULL == *ppIEnumIDList));

    TraceMsg(TF_CDFENUM, "<OUT> EnumObjects tid:0x%x", GetCurrentThreadId());

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::BindToObject ***
//
//
// Description:
//     Creates an IShellFolder for a given subfolder.
//
// Parameters:
//     [In]  pidl        - Pointer to the id list of the subfolder.
//     []    pdcReserved - Not used.
//     [In]  riid        - The requested interface.
//     [Out] ppvOut      - A pointer to receive the returned interface.  
//
// Return:
//     S_OK if the request folder is created and the interface returned.
//     E_OUTOFMEMORY if there isn't enough memory to create the folder.
//     E_NOINTERFACE if the requested interface isn't supported.
//
// Comments:
//     This function is generaly called on a member of the current folder
//     to create a subfolder.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfView::BindToObject(
    LPCITEMIDLIST pidl,
    LPBC pbcReserved,
    REFIID riid,
    LPVOID* ppvOut
)
{
    ASSERT(ppvOut);

    //
    // REVIEW:  Hack to get around shell pidls.  Bug in shell!
    //

#if 1 //Hack
    while(!ILIsEmpty(pidl) && !CDFIDL_IsValidId((PCDFITEMID)&pidl->mkid))
        pidl = _ILNext(pidl);

    if (ILIsEmpty(pidl))
    {
        HRESULT hr = S_OK;

        if (!m_bCdfParsed)
        {
            TraceMsg(TF_CDFPARSE, "IShellFolder BindToObject (Hack) %s",
                     PathFindFileName(m_szPath));
            hr = ParseCdfFolder(NULL, PARSE_LOCAL);
        }

        if (SUCCEEDED(hr))
        {
            AddRef();
            *ppvOut = (void**)(IShellFolder*)this;
        }

        return hr;
    }
#endif //Hack

    ASSERT(CDFIDL_IsValid((PCDFITEMIDLIST)pidl));

    //
    // REVIEW: nsc.cpp calls this function with non-folder pidls.
    //         Currently remove the ASSERT and replace it with a check.  nsc
    //         shouldn't make this call with non-folder pidls.
    //

    //ASSERT(CDFIDL_IsFolderId((PCDFITEMID)&pidl->mkid));

    HRESULT hr = S_OK;

    *ppvOut = NULL;

    if (CDFIDL_IsFolderId((PCDFITEMID)&pidl->mkid))
    {
        if (!m_bCdfParsed)
        {
            TraceMsg(TF_CDFPARSE, "IShellFolder BindToObject %s",
                     PathFindFileName(m_szPath));
            hr = ParseCdfFolder(NULL, PARSE_LOCAL);
        }

        if (SUCCEEDED(hr))
        {
            ASSERT(XML_IsCdfidlMemberOf(m_pIXMLElementCollection,
                                        (PCDFITEMIDLIST)pidl));

            CCdfView* pCCdfView = (CCdfView*)new CCdfView((PCDFITEMIDLIST)pidl,
                                                          m_pidlPath,
                                                          m_pIXMLElementCollection);

            if (pCCdfView)
            {
                if (ILIsEmpty(_ILNext(pidl)))
                {
                    hr = pCCdfView->QueryInterface(riid, ppvOut);
                }
                else
                {
                    hr = pCCdfView->BindToObject(_ILNext(pidl), pbcReserved, riid,
                                                 ppvOut);
                }

                pCCdfView->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }


    ASSERT((SUCCEEDED(hr) && *ppvOut) || (FAILED(hr) && NULL == *ppvOut));
    
    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::BindToStorage ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfView::BindToStorage(
    LPCITEMIDLIST pidl,
    LPBC pbcReserved,
    REFIID riid,
    LPVOID* ppvObj
)
{
    return E_NOTIMPL;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::CompareIDs ***
//
//
// Description:
//     Determines the relative ordering of two objects given their id lists.
//
// Parameters:
//     [In]  lParam - Value specifying the type of comparison to perform.
//                    Currently ignored.  Always sort by name.
//     [In]  pidl1  - The id list of the first item to compare.
//     [In]  pidl2  - The id list of the second item to compare.
//
// Return:
//     The SCODE of the HRESULT (low word) is <0 if pidl1 comes before pidl2,
//     =0 if pidl1 is the same as pidl2 and >0 if pidl1 comes after pidl2.
//
// Comments:
//     Shell expects this function to never fail.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCdfView::CompareIDs(
    LPARAM lParam,
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2
)
{
    ASSERT(CDFIDL_IsValid((PCDFITEMIDLIST)pidl1));
    ASSERT(CDFIDL_IsValid((PCDFITEMIDLIST)pidl2));

    SHORT sRes = CDFIDL_Compare((PCDFITEMIDLIST)pidl1,(PCDFITEMIDLIST)pidl2);

    return 0x0000ffff & sRes;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\
//
// *** CCdfView::CreateViewObject ***
//
//
// Description:
//     Creates a com object for the current folder implementing