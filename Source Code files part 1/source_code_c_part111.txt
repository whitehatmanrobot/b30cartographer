9
          fma.s1 POW_W1  = POW_Z1, POW_inv_log2_by_128, POW_RSHF
          nop.i 999
}
;;

{ .mfi
          nop.m 999
(p7)      fma.s f8  = f0,f0,f0  // Result +0 if x zero and y not integer
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_Y_Gpr                  = POW_NORM_Y, POW_Gpr, f0
(p8)      br.ret.spnt b0        // Exit if x zero and y odd integer
}
;;

// By subtracting RSHF we get rounded integer POW_N2float
// p15 = TRUE ==> X_0_Y_NEG
{ .mfi
          nop.m 999
          fms.s1 POW_N2float  = POW_W2, f1, POW_RSHF
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_UmZ2pV                 = POW_twoV,POW_Q0_half,POW_UmZ2
(p15)     br.cond.spnt POW_X_0_Y_NEG
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_Z3sq                   = POW_Z3, POW_Z3, f0
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_v4                     = POW_Z3, POW_Q3, POW_Q2
(p7)      br.ret.spnt b0     // Exit if x zero and y not an integer
}
;;



// Extract rounded integer from rightmost significand of POW_W2
// By subtracting RSHF we get rounded integer POW_N1float
{ .mfi
          getf.sig pow_GR_int_W2             = POW_W2
          fms.s1 POW_N1float  = POW_W1, f1, POW_RSHF
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_v2                     = POW_Z3, POW_Q1, POW_Q0_half
          nop.i 999
}
;;


// p13 = TRUE ==> X is NEGATIVE  AND  Y possible int
//     p10 = TRUE ==> X is NEG and Y is an int
//     p12 = TRUE ==> X is NEG and Y is not an int
{ .mfi
          nop.m 999
(p13)     fcmp.eq.unc.s1 p10,p12             = POW_float_int_Y,  POW_NORM_Y
          mov pow_GR_xneg_yodd = 0
}
{ .mfb
          nop.m 999
(p9)      fma.s f8  = f0,f0,f0   // Result +0 if x zero and y even integer
(p9)      br.ret.spnt b0    // Exit if x zero and y even integer
}
;;


{ .mfi
          nop.m 999
          fnma.s1 POW_s2 = POW_N2float, POW_log2_by_128_hi, POW_Z2
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_e2                     = POW_e2,f1,POW_UmZ2pV
          nop.i 999
}
;;

// Extract rounded integer from rightmost significand of POW_W1
// Test if x inf
{ .mfi
          getf.sig pow_GR_int_W1             = POW_W1
          fclass.m.unc p15,p0 = POW_NORM_X,  0x23
          nop.i 999
}
{ .mfb
          nop.m 999
          fnma.s1 POW_f2  = POW_N2float, POW_log2_by_128_lo, f1
(p12)     br.cond.spnt POW_X_NEG_Y_NONINT  // Branch if x neg, y not integer
}
;;

// p11 = TRUE ==> X is +1.0
// p12 = TRUE ==> X is NEGATIVE  AND Y is an odd integer
{ .mfi
          getf.exp pow_GR_signexp_Y_Gpr       = POW_Y_Gpr
          fcmp.eq.s1 p11,p0 = POW_NORM_X, f1
(p10)     tbit.nz.unc  p12,p0                = pow_GR_sig_int_Y,0
}
{ .mfi
          nop.m 999
          fma.s1 POW_v3                     = POW_Z3sq, POW_Q4, POW_v4
          nop.i 999
}
;;


{ .mfi
          add pow_GR_int_N                   = pow_GR_int_W1, pow_GR_int_W2
          fnma.s1 POW_f1  = POW_N1float, POW_log2_by_128_lo, f1
          nop.i 999
}
{ .mfb
          nop.m 999
          fnma.s1 POW_s1  = POW_N1float, POW_log2_by_128_hi, POW_Z1
(p15)     br.cond.spnt POW_X_INF
}
;;


// Test x and y and flag denormal
{ .mfi
          and pow_GR_index1                  = 0x0f, pow_GR_int_N
          fcmp.eq.s0 p15,p0 = f8,f9
          shr r2                             = pow_GR_int_N, 7
}
{ .mfi
          and pow_GR_exp_Y_Gpr               = pow_GR_signexp_Y_Gpr, pow_GR_17ones
(p11)     fma.s.s0 f8 = f1,f1,f0    // If x=1, result is +1
          and pow_GR_index2                  = 0x70, pow_GR_int_N
}
;;



{ .mfi
          shladd pow_AD_T1                   = pow_GR_index1, 4, pow_AD_tbl1
          fcmp.eq.s1 p7,p0 = POW_NORM_Y, f1  // Test for y=1.0
          sub pow_GR_true_exp_Y_Gpr          = pow_GR_exp_Y_Gpr, pow_GR_16ones
}
{ .mfi
          addl pow_int_GR_M                  = 0xFFFF, r2
          fma.s1  POW_e12                     = POW_e1,f1,POW_e2
          add pow_AD_T2                      = pow_AD_tbl2, pow_GR_index2
}
;;


{ .mfi
          ldfe POW_T1                        = [pow_AD_T1],16
          nop.f 999
          andcm pow_GR_sign_Y_Gpr            = pow_GR_signexp_Y_Gpr, pow_GR_17ones
}
{ .mib
          setf.exp POW_2M                    = pow_int_GR_M
(p12)     mov pow_GR_xneg_yodd = 1
(p11)     br.ret.spnt b0        // Early exit if x=1.0, result is +1
}
;;


{ .mfb
          ldfe POW_T2                        = [pow_AD_T2],16
          fma.s1 POW_q                       = POW_Z3sq, POW_v3, POW_v2
(p7)      br.ret.spnt b0        // Early exit if y=1.0, result is x
}
;;


// double: p8 TRUE ==> |Y(G + r)| >= 10
// single: p8 TRUE ==> |Y(G + r)| >= 7

// double
//     -2^10  -2^9             2^9   2^10
// -----+-----+----+ ... +-----+-----+-----
//  p8  |             p9             |  p8
//      |     |       p10      |     |  
// single
//     -2^7   -2^6             2^6   2^7
// -----+-----+----+ ... +-----+-----+-----
//  p8  |             p9             |  p8
//      |     |       p10      |     |


{ .mfi
          cmp.le.unc p8,p9                   = 7, pow_GR_true_exp_Y_Gpr
          fma.s1 POW_s                       = POW_s1, f1, POW_s2
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_f12                     = POW_f1, POW_f2,f0
          nop.i 999
}
;;


{ .mfb
(p9)      cmp.le.unc p0,p10                  = 6, pow_GR_true_exp_Y_Gpr
          nop.f 999
(p8)      br.cond.spnt POW_OVER_UNDER_X_NOT_INF
}
;;



// Form signexp of constants to indicate overflow
{ .mmf
          mov         pow_GR_big_pos         = 0x1007f 
          mov         pow_GR_big_neg         = 0x3007f 
          fma.s1 POW_e123                    = POW_e12, f1, POW_e3
}
;;


// Form big positive and negative constants to test for possible overflow
{ .mmf
          setf.exp POW_big_pos               = pow_GR_big_pos
          setf.exp POW_big_neg               = pow_GR_big_neg
          fma.s1 POW_q                       = POW_Z3sq, POW_q, POW_Z3
}
;;


{ .mfi
          nop.m 999 
          fma.s1 POW_ssq                     = POW_s, POW_s, f0
          nop.i 999
}
{ .mfi
          nop.m 999 
          fma.s1 POW_v4                      = POW_s, POW_Q3, POW_Q2
          nop.i 999
}
;;

{ .mfi
          nop.m 999
          fma.s1 POW_v2                      = POW_s, POW_Q1, POW_Q0_half
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_1ps                     = f1,f1,POW_s
          nop.i 999
}
;;

// f123 = f12*(e123+1) = f12*e123+f12
{ .mfi
          nop.m 999
          fma.s1 POW_f123                    = POW_e123,POW_f12,POW_f12
          nop.i 999
}
;;

{ .mfi
          nop.m 999
          fma.s1 POW_T1T2                    = POW_T1, POW_T2, f0
          nop.i 999
}
;;

// 2Mqp1 = 2M*q+2M
// p12 if x negative and y odd, p13 otherwise
{ .mfi
          nop.m 999
          fma.s1 POW_2Mqp1                    = POW_q, POW_2M, POW_2M
          cmp.ne p12,p13 = pow_GR_xneg_yodd, r0
}
// 2M*q+2M  do it again with s0 to set inexact
{ .mfi
          nop.m 999
          fma.s0 POW_tmp                    = POW_q, POW_2M, POW_2M
          nop.i 999
}
;;

{ .mfi
          nop.m 999
          fma.s1 POW_v3                     = POW_ssq, POW_Q4, POW_v4
          nop.i 999
}
;;

{ .mfi
          nop.m 999
          fma.s1 POW_v21ps                  = POW_ssq, POW_v2, POW_1ps
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_s4                     = POW_ssq, POW_ssq, f0
          nop.i 999
}
;;


{ .mfi
          nop.m 999
(p12)     fnma.s1 POW_A                    =  POW_2Mqp1, POW_f123, f0
          nop.i 999
}
{ .mfi
          nop.m 999
(p13)     fma.s1 POW_A                      =  POW_2Mqp1, POW_f123, f0
          nop.i 999
}
;;


{ .mfi
          nop.m 999
          fma.s1 POW_es                     = POW_s4,  POW_v3, POW_v21ps
          nop.i 999
}
;;


{ .mfi
          nop.m 999
          fma.s1 POW_A                      = POW_A, POW_T1T2, f0
          nop.i 999
}
;;


{ .mfb
          nop.m 999
          fma.s.s0 f8                       = POW_A, POW_es, f0
(p10)     br.ret.sptk     b0
}
;;




// POSSIBLE_OVER_UNDER
// p6 = TRUE ==> Y_Gpr negative
// Result is already computed.  We just need to know if over/underflow occurred.

{ .mfb
        cmp.eq p0,p6                      = pow_GR_sign_Y_Gpr, r0
        nop.f 999
(p6)    br.cond.spnt POW_POSSIBLE_UNDER 
}
;;

// POSSIBLE_OVER
// We got an answer. 
// overflow is a possibility, not a certainty


// We define an overflow when the answer with
//    WRE set
//    user-defined rounding mode

// double
// Largest double is 7FE (biased double)
//                   7FE - 3FF + FFFF = 103FE
// Create + largest_double_plus_ulp
// Create - largest_double_plus_ulp
// Calculate answer with WRE set.

// single
// Largest single is FE (biased double)
//                   FE - 7F + FFFF = 1007E
// Create + largest_single_plus_ulp
// Create - largest_single_plus_ulp
// Calculate answer with WRE set.

// Cases when answer is ldn+1  are as follows:
//  ldn                   ldn+1
// --+----------|----------+------------
//              |
//    +inf          +inf      -inf
//                  RN         RN
//                             RZ


// Put in s2 (td set, wre set)
{ .mfi
        nop.m 999 
        fsetc.s2 0x7F,0x42
        nop.i 999 
}
;;


{ .mfi
        nop.m 999 
        fma.s.s2 POW_wre_urm_f8                    = POW_A, POW_es, f0
        nop.i 999 ;;
}

// Return s2 to default
{ .mfi
        nop.m 999
        fsetc.s2 0x7F,0x40
        nop.i 999
}
;;


// p7 = TRUE ==> yes, we have an overflow
{ .mfi
        nop.m 999
        fcmp.ge.s1 p7, p8                    =  POW_wre_urm_f8, POW_big_pos
        nop.i 999
}
;;

{ .mfi
        nop.m 999
(p8)    fcmp.le.s1 p7, p0                    =  POW_wre_urm_f8, POW_big_neg
        nop.i 999
}
;;

{ .mbb
(p7)   mov pow_GR_tag                            = 30
(p7)   br.cond.spnt __libm_error_region     // Branch if overflow
       br.ret.sptk     b0                   // Exit if did not overflow
}
;;


POW_POSSIBLE_UNDER:
// We got an answer. input was < -2^9 but > -2^10 (double)
// We got an answer. input was < -2^6 but > -2^7  (float)
// underflow is a possibility, not a certainty

// We define an underflow when the answer with
//    ftz set
// is zero (tiny numbers become zero)
// Notice (from below) that if we have an unlimited exponent range,
// then there is an extra machine number E between the largest denormal and
// the smallest normal.
// So if with unbounded exponent we round to E or below, then we are
// tiny and underflow has occurred.
// But notice that you can be in a situation where we are tiny, namely
// rounded to E, but when the exponent is bounded we round to smallest
// normal. So the answer can be the smallest normal with underflow.
//                           E
// -----+--------------------+--------------------+-----
//      |                    |                    |
//   1.1...10 2^-3fff    1.1...11 2^-3fff    1.0...00 2^-3ffe
//   0.1...11 2^-3ffe                                   (biased, 1)
//    largest dn                               smallest normal


// Put in s2 (td set, ftz set)
{ .mfi
        nop.m 999
        fsetc.s2 0x7F,0x41
        nop.i 999 
}
;;



{ .mfi
        nop.m 999
        fma.s.s2 POW_ftz_urm_f8                    = POW_A, POW_es, f0
        nop.i 999
}
;;


// Return s2 to default
{ .mfi
        nop.m 999
        fsetc.s2 0x7F,0x40
        nop.i 999 
}
;;


// p7 = TRUE ==> yes, we have an underflow
{ .mfi
        nop.m 999
        fcmp.eq.unc.s1 p7, p0                     =  POW_ftz_urm_f8, f0
        nop.i 999 
}
;;



{ .mbb
(p7)    mov pow_GR_tag                           = 31
(p7)    br.cond.spnt __libm_error_region      // Branch if underflow
        br.ret.sptk     b0                    // Exit if did not underflow
}
;;


POW_X_DENORM:
// Here if x unorm. Use the NORM_X for getf instructions, and the back
// to normal path
{ .mfi
        getf.exp      pow_GR_signexp_X    = POW_NORM_X
        nop.f 999
        nop.i 999
}
;;

{ .mfi
        getf.sig      pow_GR_sig_X        = POW_NORM_X
        nop.f 999
        nop.i 999
}
;;

{ .mfi
        and           pow_GR_exp_X        = pow_GR_signexp_X, pow_GR_17ones
        nop.f 999
        nop.i 999
}
;;

{ .mib
        sub       pow_GR_true_exp_X       = pow_GR_exp_X, pow_GR_16ones
        shl           pow_GR_offset       = pow_GR_sig_X, 1
        br.cond.sptk    POW_COMMON
}
;;


POW_X_0_Y_0:
// When X is +-0 and Y is +-0, IEEE returns 1.0 
// We call error support with this value 

{ .mfb
        mov pow_GR_tag                     = 32
        fma.s f8                           = f1,f1,f0
        br.cond.sptk __libm_error_region
}
;;


POW_Y_0:
// Here for y zero, x anything but zero and nan
// Set flag if x denormal
// Result is +1.0
{ .mfi
        nop.m 999
        fcmp.eq.s0 p6,p0 = f8,f0    // Sets flag if x denormal
        nop.i 999
}
{ .mfb
        nop.m 999
        fma.s.s0 f8 = f1,f1,f0
        br.ret.sptk b0
}
;;


POW_X_INF:
// When X is +-inf and Y is +-, IEEE returns 

// overflow                       
// X +inf  Y +inf             +inf  
// X -inf  Y +inf             +inf 

// X +inf  Y >0               +inf    
// X -inf  Y >0, !odd integer +inf     <== (-inf)^0.5 = +inf !!
// X -inf  Y >0,  odd integer  -inf   

// underflow                     
// X +inf  Y -inf             +0   
// X -inf  Y -inf             +0  

// X +inf  Y <0               +0      
// X -inf  Y <0, !odd integer +0     
// X -inf  Y <0, odd integer  -0    

// X + inf Y=+0                +1
// X + inf Y=-0                +1
// X - inf Y=+0                +1
// X - inf Y=-0                +1

// p13 == Y negative
// p14 == Y positive

// p6 == Y is a floating point number outside the integer.
//       Hence it is an integer and is even.
//       p13 == (Y negative) 
//          return +inf
//       p14 == (Y positive)
//          return +0



// p7 == Y is a floating point number within the integer range.
//      p9  == (int_Y = NORM_Y), Y is an integer, which may be odd or even.
//           p11 odd
//              p13 == (Y negative)    
//                 return (sign_of_x)inf
//              p14 == (Y positive) 
//                 return (sign_of_x)0
//           pxx even                
//              p13 == (Y negative) 
//                 return +inf     
//              p14 == (Y positive)
//                 return +0     

//      pxx == Y is not an integer
//           p13 == (Y negative) 
//                 return +inf
//           p14 == (Y positive)
//                 return +0
// 

// If x=inf, test y and flag denormal
{ .mfi
          nop.m 999
          fcmp.eq.s0 p10,p11 = f9,f0
          nop.i 999
}
;;

{ .mfi
          nop.m 999
          fcmp.lt p13,p14                    = POW_NORM_Y,f0 
          cmp.gt.unc  p6,p7                  = pow_GR_exp_Y, pow_GR_10033
}
{ .mfi
          nop.m 999
          fclass.m p12,p0                    = f9, 0x23
          nop.i 999
}
;;


{ .mfi
          nop.m 999
          fclass.m p15,p0                    = f9, 0x07	//@zero
          nop.i 999
}
;;

{ .mfb
          nop.m 999
(p15)     fmerge.s f8 = f1,f1
(p15)     br.ret.spnt b0
}
;;

        
{ .mfi
(p13)     mov pow_GR_tag                     = 31
(p14)     frcpa.s1 f8,p10                       = f1,f0
          nop.i 999
}
{ .mfb
(p14)     mov pow_GR_tag                     = 30
(p13)     fma.s1 f8                          = f0,f0,f0
(p12)     br.ret.spnt b0
}
;;

   

{ .mfb
          nop.m 999
(p7)      fcmp.eq.unc.s1 p9,p0              = POW_float_int_Y,  POW_NORM_Y
          nop.b 999
}
;;

{ .mfi
          nop.m 999
          nop.f 999
(p9)      tbit.nz.unc p11,p0                 = pow_GR_sig_int_Y,0
}
;;

{ .mfb
          nop.m 999
(p11)     fmerge.s f8 = POW_NORM_X,f8
          br.ret.sptk b0 
}
;;



POW_X_0_Y_NEG:
// When X is +-0 and Y is negative, IEEE returns 
// X     Y           answer
// +0    -odd int    +inf
// -0    -odd int    -inf

// +0    !-odd int   +inf
// -0    !-odd int   +inf


// p6 == Y is a floating point number outside the integer.
//       Hence it is an integer and is even.
//       return +inf

// p7 == Y is a floating point number within the integer range.
//      p9  == (int_Y = NORM_Y), Y is an integer, which may be odd or even.
//           p11 odd
//              return (sign_of_x)inf
//           p12 even
//              return +inf
//      p10 == Y is not an integer
//         return +inf
// 
// 

{ .mfi
          nop.m 999
          nop.f 999
          cmp.gt.unc  p6,p7                  = pow_GR_exp_Y, pow_GR_10033
}
;;


{ .mfi
          mov pow_GR_tag                     = 33
(p7)      fcmp.eq.unc.s1 p9,p10              = POW_float_int_Y,  POW_NORM_Y
          nop.i 999
}
;;


{ .mfb
          nop.m 999
(p6)      frcpa.s0 f8,p13                       = f1, f0
(p6)      br.cond.sptk __libm_error_region
}
;;

{ .mfb
          nop.m 999
(p10)     frcpa.s0 f8,p13                       = f1, f0
(p10)     br.cond.sptk __libm_error_region
}
;;



{ .mib
          nop.m 999
(p9)      tbit.nz.unc p11,p12                = pow_GR_sig_int_Y,0
          nop.b 999
}
;;



{ .mfi
          nop.m 999
(p12)     frcpa.s0 f8,p13                      = f1,f0
          nop.i 999
}
;;

{ .mfb
          nop.m 999
(p11)     frcpa f8,p13                      = f1,f8 
          br.cond.sptk __libm_error_region
}
;;




POW_X_NEG_Y_NONINT:
// When X is negative and Y is a non-integer, IEEE
// returns a qnan indefinite.
// We call error support with this value 

{ .mfb
         mov pow_GR_tag                     = 34
         frcpa f8,p6                        = f0,f0
         br.cond.sptk __libm_error_region
}
;;




POW_X_NAN_Y_0:
// When X is a NAN and Y is zero, IEEE returns 1.
// We call error support with this value.

{ .mfi
         nop.m 0
         fma.s.s0 f10 = f8,f1,f0 
         nop.i 0
}
{ .mfb
         mov pow_GR_tag                     = 35
         fma.s.s0 f8 = f0,f0,f1 
         br.cond.sptk __libm_error_region
}
;;


POW_OVER_UNDER_X_NOT_INF:

// p8 is TRUE for overflow
// p9 is TRUE for underflow

// if y is infinity, we should not over/underflow


{ .mfi
          nop.m 999
          fcmp.eq.unc.s1     p14, p13        = POW_xsq,f1
          cmp.eq.unc p8,p9                   = pow_GR_sign_Y_Gpr, r0
}
;;

{ .mfi
          nop.m 999
(p14)     fclass.m.unc       p15, p0         = f9, 0x23
          nop.i 999
}
{ .mfi
          nop.m 999
(p13)     fclass.m.unc       p11,p0         = f9, 0x23
          nop.i 999
}
;;

// p15 = TRUE if |x|=1, y=inf, return +1
{ .mfb
          nop.m 999
(p15)     fma.s              f8              = f1,f1,f0
(p15)     br.ret.spnt b0
}
;;

.pred.rel "mutex",p8,p9
{  .mfb
(p8)      setf.exp           f8              = pow_GR_17ones
(p9)      fmerge.s           f8              = f0,f0
(p11)     br.ret.sptk b0
}

{ .mfb
          nop.m 999
          nop.f 999
          br.cond.sptk POW_OVER_UNDER_ERROR
}
;;

POW_Y_NAN:

// Is x = +1 then result is +1, else result is quiet Y
{ .mfi
       nop.m 999
       fcmp.eq.s1         p10,p9               = POW_NORM_X, f1 
       nop.i 999
}
;;

{ .mfi
       nop.m 999
(p10)  fcmp.eq.s0 p6,p0 = f9,f1   // Set invalid, even if x=+1
       nop.i 999
}
;;

{ .mfi
       nop.m 999
(p10)  fma.s f8 = f1,f1,f0 
       nop.i 999
}
{ .mfb
       nop.m 999
(p9)   fma.s f8 = f9,f8,f0 
       br.ret.sptk b0
}
;;


POW_OVER_UNDER_ERROR:

{ .mfi
          nop.m 999
          fmerge.s f10                      = POW_NORM_X,POW_NORM_X
          nop.i 999
}
{ .mfi
          sub   pow_GR_17ones_m1            = pow_GR_17ones, r0, 1
          nop.f 999
          mov pow_GR_one                    = 0x1
}
;;

// overflow
{ .mmb
(p8)     mov pow_GR_tag                     = 30
(p8)     setf.exp f11                       = pow_GR_17ones_m1
         nop.b 999
}
;;

        
// underflow
{ .mmi
(p9)    mov pow_GR_tag                     = 31
(p9)    setf.exp f11                       = pow_GR_one
        nop.i 999
}
;;


// p12 x is negative and y is an odd integer 


{ .mfi
        nop.m 999
        fma.s f8                               = f11, f11, f0
        nop.i 999
}
;;

{ .mfi
        nop.m 999
(p12)   fnma.s f8                              = f11, f11, f0
        nop.i 999
}
;;


.endp powf


// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs



.proc __libm_error_region
__libm_error_region:

// Answer is inf for overflow and 0 for underflow.
.prologue
// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfs [GR_Parameter_Y] = POW_NORM_Y,16 // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfs [GR_Parameter_X] = POW_NORM_X              // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y    // Parameter 3 address
        nop.b 0                                
}
{ .mib
        stfs [GR_Parameter_Y] = f8                      // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#           // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\sinh.s ===
.file "sinh.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 10/12/00 Update to set denormal operand and underflow flags
// 1/22/01  Fixed to set inexact flag for small args.
// 5/02/01  Reworked to improve speed of all paths
//
// API
//==============================================================
// double = sinh(double)
// input  floating point f8
// output floating point f8
//
// Registers used
//==============================================================
// general registers: 
// r32 -> r47
// predicate registers used:
// p6 -> p11
// floating-point registers used:
// f9 -> f15; f32 -> f90; 
// f8 has input, then output
//
// Overview of operation
//==============================================================
// There are seven paths
// 1. 0 < |x| < 0.25          SINH_BY_POLY
// 2. 0.25 <=|x| < 32         SINH_BY_TBL
// 3. 32 <= |x| < 710.47586   SINH_BY_EXP (merged path with SINH_BY_TBL)
// 4. |x| >= 710.47586        SINH_HUGE
// 5. x=0                     Done with early exit
// 6. x=inf,nan               Done with early exit
// 7. x=denormal              SINH_DENORM
//
// For double we get overflow for x >= 4008 b19e 747d cfc3 ed8b
//                                  >= 710.475860073
//
//
// 1. SINH_BY_POLY   0 < |x| < 0.25
// ===============
// Evaluate sinh(x) by a 13th order polynomial
// Care is take for the order of multiplication; and P_1 is not exactly 1/3!, 
// P_2 is not exactly 1/5!, etc.
// sinh(x) = sign * (series(e^x) - series(e^-x))/2
//         = sign * (ax + ax^3/3! + ax^5/5! + ax^7/7! + ax^9/9! + ax^11/11!
//                        + ax^13/13!)
//         = sign * (ax   + ax * ( ax^2 * (1/3! + ax^4 * (1/7! + ax^4*1/11!)) )
//                        + ax * ( ax^4 * (1/5! + ax^4 * (1/9! + ax^4*1/13!)) ))
//         = sign * (ax   + ax*p_odd + (ax*p_even))
//         = sign * (ax   + Y_lo)
// sinh(x) = sign * (Y_hi + Y_lo)
// Note that ax = |x|
//
// 2. SINH_BY_TBL   0.25 <= |x| < 32.0
// =============
// sinh(x) = sinh(B+R)
//         = sinh(B)cosh(R) + cosh(B)sinh(R)
// 
// ax = |x| = M*log2/64 + R
// B = M*log2/64
// M = 64*N + j 
//   We will calculate M and get N as (M-j)/64
//   The division is a shift.
// exp(B)  = exp(N*log2 + j*log2/64)
//         = 2^N * 2^(j*log2/64)
// sinh(B) = 1/2(e^B -e^-B)
//         = 1/2(2^N * 2^(j*log2/64) - 2^-N * 2^(-j*log2/64)) 
// sinh(B) = (2^(N-1) * 2^(j*log2/64) - 2^(-N-1) * 2^(-j*log2/64)) 
// cosh(B) = (2^(N-1) * 2^(j*log2/64) + 2^(-N-1) * 2^(-j*log2/64)) 
// 2^(j*log2/64) is stored as Tjhi + Tjlo , j= -32,....,32
// Tjhi is double-extended (80-bit) and Tjlo is single(32-bit)
//
// R = ax - M*log2/64
// R = ax - M*log2_by_64_hi - M*log2_by_64_lo
// exp(R) = 1 + R +R^2(1/2! + R(1/3! + R(1/4! + ... + R(1/n!)...)
//        = 1 + p_odd + p_even
//        where the p_even uses the A coefficients and the p_even uses 
//        the B coefficients
//
// So sinh(R) = 1 + p_odd + p_even -(1 -p_odd -p_even)/2 = p_odd
//    cosh(R) = 1 + p_even
//    sinh(B) = S_hi + S_lo
//    cosh(B) = C_hi
// sinh(x) = sinh(B)cosh(R) + cosh(B)sinh(R)
//
// 3. SINH_BY_EXP   32.0 <= |x| < 710.47586  ( 4008 b19e 747d cfc3 ed8b )
// ==============
// Can approximate result by exp(x)/2 in this region.
// Y_hi = Tjhi
// Y_lo = Tjhi * (p_odd + p_even) + Tjlo
// sinh(x) = Y_hi + Y_lo
//
// 4. SINH_HUGE     |x| >= 710.47586  ( 4008 b19e 747d cfc3 ed8b )
// ============
// Set error tag and call error support
//
//
// Assembly macros
//==============================================================
sinh_GR_ad1          = r34
sinh_GR_Mmj          = r34
sinh_GR_jshf         = r36
sinh_GR_M            = r35
sinh_GR_N            = r35
sinh_GR_exp_2tom57   = r36
sinh_GR_j            = r36
sinh_GR_joff         = r36
sinh_GR_exp_mask     = r37
sinh_GR_mJ           = r38
sinh_AD_mJ           = r38
sinh_GR_signexp_x    = r38
sinh_GR_signexp_sgnx_0_5 = r38
sinh_GR_exp_0_25     = r39
sinh_GR_J            = r39
sinh_AD_J            = r39
sinh_GR_sig_inv_ln2  = r40
sinh_GR_exp_32       = r40
sinh_GR_exp_huge     = r40
sinh_GR_all_ones     = r40

sinh_GR_ad2e         = r41
sinh_GR_ad3          = r42
sinh_GR_ad4          = r43
sinh_GR_rshf         = r44
sinh_GR_ad2o         = r45
sinh_GR_rshf_2to57   = r46
sinh_GR_exp_denorm   = r46
sinh_GR_exp_x        = r47


GR_SAVE_PFS          = r41
GR_SAVE_B0           = r42
GR_SAVE_GP           = r43

GR_Parameter_X       = r44
GR_Parameter_Y       = r45
GR_Parameter_RESULT  = r46
GR_Parameter_TAG     = r47


sinh_FR_ABS_X        = f9 
sinh_FR_X2           = f10
sinh_FR_X4           = f11
sinh_FR_all_ones     = f13
sinh_FR_tmp          = f14
sinh_FR_RSHF         = f15

sinh_FR_Inv_log2by64 = f32
sinh_FR_log2by64_lo  = f33
sinh_FR_log2by64_hi  = f34
sinh_FR_A1           = f35

sinh_FR_A2           = f36
sinh_FR_A3           = f37
sinh_FR_Rcub         = f38
sinh_FR_M_temp       = f39
sinh_FR_R_temp       = f40

sinh_FR_Rsq          = f41
sinh_FR_R            = f42
sinh_FR_M            = f43
sinh_FR_B1           = f44
sinh_FR_B2           = f45

sinh_FR_B3           = f46
sinh_FR_peven_temp1  = f47
sinh_FR_peven_temp2  = f48
sinh_FR_peven        = f49
sinh_FR_podd_temp1   = f50

sinh_FR_podd_temp2   = f51
sinh_FR_podd         = f52
sinh_FR_poly65       = f53
sinh_FR_poly6543     = f53
sinh_FR_poly6to1     = f53
sinh_FR_poly43       = f54
sinh_FR_poly21       = f55

sinh_FR_X3           = f56
sinh_FR_INV_LN2_2TO63= f57
sinh_FR_RSHF_2TO57   = f58
sinh_FR_2TOM57       = f59
sinh_FR_smlst_oflow_input = f60

sinh_FR_pre_result   = f61
sinh_FR_huge         = f62
sinh_FR_spos         = f63
sinh_FR_sneg         = f64
sinh_FR_Tjhi         = f65

sinh_FR_Tjlo         = f66
sinh_FR_Tmjhi        = f67
sinh_FR_Tmjlo        = f68
sinh_FR_S_hi         = f69
sinh_FR_SC_hi_temp   = f70

sinh_FR_S_lo_temp1   = f71 
sinh_FR_S_lo_temp2   = f72 
sinh_FR_S_lo_temp3   = f73 
sinh_FR_S_lo_temp4   = f73 
sinh_FR_S_lo         = f74
sinh_FR_C_hi         = f75

sinh_FR_C_hi_temp1   = f76
sinh_FR_Y_hi         = f77 
sinh_FR_Y_lo_temp    = f78 
sinh_FR_Y_lo         = f79 
sinh_FR_NORM_X       = f80

sinh_FR_P1           = f81
sinh_FR_P2           = f82
sinh_FR_P3           = f83
sinh_FR_P4           = f84
sinh_FR_P5           = f85

sinh_FR_P6           = f86
sinh_FR_Tjhi_spos    = f87
sinh_FR_Tjlo_spos    = f88
sinh_FR_huge         = f89
sinh_FR_signed_hi_lo = f90


// Data tables
//==============================================================

// DO NOT CHANGE ORDER OF THESE TABLES
.data

.align 16
double_sinh_arg_reduction:
//   data8 0xB8AA3B295C17F0BC, 0x00004005  // 64/log2 -- signif loaded with setf
   data8 0xB17217F7D1000000, 0x00003FF8  // log2/64 high part
   data8 0xCF79ABC9E3B39804, 0x00003FD0  // log2/64 low part

double_sinh_p_table:
   data8 0xb19e747dcfc3ed8b, 0x00004008  // Smallest x to overflow (710.47586)
   data8 0xB08AF9AE78C1239F, 0x00003FDE  // P6
   data8 0xB8EF1D28926D8891, 0x00003FEC  // P4
   data8 0x8888888888888412, 0x00003FF8  // P2
   data8 0xD732377688025BE9, 0x00003FE5  // P5
   data8 0xD00D00D00D4D39F2, 0x00003FF2  // P3
   data8 0xAAAAAAAAAAAAAAAB, 0x00003FFC  // P1

double_sinh_ab_table:
   data8 0xAAAAAAAAAAAAAAAC, 0x00003FFC  // A1
   data8 0x88888888884ECDD5, 0x00003FF8  // A2
   data8 0xD00D0C6DCC26A86B, 0x00003FF2  // A3
   data8 0x8000000000000002, 0x00003FFE  // B1
   data8 0xAAAAAAAAAA402C77, 0x00003FFA  // B2
   data8 0xB60B6CC96BDB144D, 0x00003FF5  // B3

double_sinh_j_table:
   data8 0xB504F333F9DE6484, 0x00003FFE, 0x1EB2FB13, 0x00000000
   data8 0xB6FD91E328D17791, 0x00003FFE, 0x1CE2CBE2, 0x00000000
   data8 0xB8FBAF4762FB9EE9, 0x00003FFE, 0x1DDC3CBC, 0x00000000
   data8 0xBAFF5AB2133E45FB, 0x00003FFE, 0x1EE9AA34, 0x00000000
   data8 0xBD08A39F580C36BF, 0x00003FFE, 0x9EAEFDC1, 0x00000000
   data8 0xBF1799B67A731083, 0x00003FFE, 0x9DBF517B, 0x00000000
   data8 0xC12C4CCA66709456, 0x00003FFE, 0x1EF88AFB, 0x00000000
   data8 0xC346CCDA24976407, 0x00003FFE, 0x1E03B216, 0x00000000
   data8 0xC5672A115506DADD, 0x00003FFE, 0x1E78AB43, 0x00000000
   data8 0xC78D74C8ABB9B15D, 0x00003FFE, 0x9E7B1747, 0x00000000
   data8 0xC9B9BD866E2F27A3, 0x00003FFE, 0x9EFE3C0E, 0x00000000
   data8 0xCBEC14FEF2727C5D, 0x00003FFE, 0x9D36F837, 0x00000000
   data8 0xCE248C151F8480E4, 0x00003FFE, 0x9DEE53E4, 0x00000000
   data8 0xD06333DAEF2B2595, 0x00003FFE, 0x9E24AE8E, 0x00000000
   data8 0xD2A81D91F12AE45A, 0x00003FFE, 0x1D912473, 0x00000000
   data8 0xD4F35AABCFEDFA1F, 0x00003FFE, 0x1EB243BE, 0x00000000
   data8 0xD744FCCAD69D6AF4, 0x00003FFE, 0x1E669A2F, 0x00000000
   data8 0xD99D15C278AFD7B6, 0x00003FFE, 0x9BBC610A, 0x00000000
   data8 0xDBFBB797DAF23755, 0x00003FFE, 0x1E761035, 0x00000000
   data8 0xDE60F4825E0E9124, 0x00003FFE, 0x9E0BE175, 0x00000000
   data8 0xE0CCDEEC2A94E111, 0x00003FFE, 0x1CCB12A1, 0x00000000
   data8 0xE33F8972BE8A5A51, 0x00003FFE, 0x1D1BFE90, 0x00000000
   data8 0xE5B906E77C8348A8, 0x00003FFE, 0x1DF2F47A, 0x00000000
   data8 0xE8396A503C4BDC68, 0x00003FFE, 0x1EF22F22, 0x00000000
   data8 0xEAC0C6E7DD24392F, 0x00003FFE, 0x9E3F4A29, 0x00000000
   data8 0xED4F301ED9942B84, 0x00003FFE, 0x1EC01A5B, 0x00000000
   data8 0xEFE4B99BDCDAF5CB, 0x00003FFE, 0x1E8CAC3A, 0x00000000
   data8 0xF281773C59FFB13A, 0x00003FFE, 0x9DBB3FAB, 0x00000000
   data8 0xF5257D152486CC2C, 0x00003FFE, 0x1EF73A19, 0x00000000
   data8 0xF7D0DF730AD13BB9, 0x00003FFE, 0x9BB795B5, 0x00000000
   data8 0xFA83B2DB722A033A, 0x00003FFE, 0x1EF84B76, 0x00000000
   data8 0xFD3E0C0CF486C175, 0x00003FFE, 0x9EF5818B, 0x00000000
   data8 0x8000000000000000, 0x00003FFF, 0x00000000, 0x00000000
   data8 0x8164D1F3BC030773, 0x00003FFF, 0x1F77CACA, 0x00000000
   data8 0x82CD8698AC2BA1D7, 0x00003FFF, 0x1EF8A91D, 0x00000000
   data8 0x843A28C3ACDE4046, 0x00003FFF, 0x1E57C976, 0x00000000
   data8 0x85AAC367CC487B15, 0x00003FFF, 0x9EE8DA92, 0x00000000
   data8 0x871F61969E8D1010, 0x00003FFF, 0x1EE85C9F, 0x00000000
   data8 0x88980E8092DA8527, 0x00003FFF, 0x1F3BF1AF, 0x00000000
   data8 0x8A14D575496EFD9A, 0x00003FFF, 0x1D80CA1E, 0x00000000
   data8 0x8B95C1E3EA8BD6E7, 0x00003FFF, 0x9D0373AF, 0x00000000
   data8 0x8D1ADF5B7E5BA9E6, 0x00003FFF, 0x9F167097, 0x00000000
   data8 0x8EA4398B45CD53C0, 0x00003FFF, 0x1EB70051, 0x00000000
   data8 0x9031DC431466B1DC, 0x00003FFF, 0x1F6EB029, 0x00000000
   data8 0x91C3D373AB11C336, 0x00003FFF, 0x1DFD6D8E, 0x00000000
   data8 0x935A2B2F13E6E92C, 0x00003FFF, 0x9EB319B0, 0x00000000
   data8 0x94F4EFA8FEF70961, 0x00003FFF, 0x1EBA2BEB, 0x00000000
   data8 0x96942D3720185A00, 0x00003FFF, 0x1F11D537, 0x00000000
   data8 0x9837F0518DB8A96F, 0x00003FFF, 0x1F0D5A46, 0x00000000
   data8 0x99E0459320B7FA65, 0x00003FFF, 0x9E5E7BCA, 0x00000000
   data8 0x9B8D39B9D54E5539, 0x00003FFF, 0x9F3AAFD1, 0x00000000
   data8 0x9D3ED9A72CFFB751, 0x00003FFF, 0x9E86DACC, 0x00000000
   data8 0x9EF5326091A111AE, 0x00003FFF, 0x9F3EDDC2, 0x00000000
   data8 0xA0B0510FB9714FC2, 0x00003FFF, 0x1E496E3D, 0x00000000
   data8 0xA27043030C496819, 0x00003FFF, 0x9F490BF6, 0x00000000
   data8 0xA43515AE09E6809E, 0x00003FFF, 0x1DD1DB48, 0x00000000
   data8 0xA5FED6A9B15138EA, 0x00003FFF, 0x1E65EBFB, 0x00000000
   data8 0xA7CD93B4E965356A, 0x00003FFF, 0x9F427496, 0x00000000
   data8 0xA9A15AB4EA7C0EF8, 0x00003FFF, 0x1F283C4A, 0x00000000
   data8 0xAB7A39B5A93ED337, 0x00003FFF, 0x1F4B0047, 0x00000000
   data8 0xAD583EEA42A14AC6, 0x00003FFF, 0x1F130152, 0x00000000
   data8 0xAF3B78AD690A4375, 0x00003FFF, 0x9E8367C0, 0x00000000
   data8 0xB123F581D2AC2590, 0x00003FFF, 0x9F705F90, 0x00000000
   data8 0xB311C412A9112489, 0x00003FFF, 0x1EFB3C53, 0x00000000
   data8 0xB504F333F9DE6484, 0x00003FFF, 0x1F32FB13, 0x00000000

.align 32
.global sinh#

.section .text
.proc  sinh#
.align 32

sinh: 

{ .mlx
      alloc r32 = ar.pfs,0,12,4,0                  
      movl  sinh_GR_sig_inv_ln2 = 0xb8aa3b295c17f0bc // significand of 1/ln2
}
{ .mlx
      addl sinh_GR_ad1   = @ltoff(double_sinh_arg_reduction), gp
      movl  sinh_GR_rshf_2to57 = 0x4778000000000000 // 1.10000 2^(63+57)
}
;;

{ .mfi
      ld8 sinh_GR_ad1 = [sinh_GR_ad1]
      fmerge.s      sinh_FR_ABS_X    = f0,f8
      mov  sinh_GR_exp_0_25 = 0x0fffd    // Form exponent for 0.25
}
{ .mfi
      nop.m 999
      fnorm.s1  sinh_FR_NORM_X = f8
      mov sinh_GR_exp_2tom57 = 0xffff-57
}
;;

{ .mfi
      setf.d sinh_FR_RSHF_2TO57 = sinh_GR_rshf_2to57 // Form const 1.100 * 2^120
      fclass.m p10,p0 = f8, 0x0b         // Test for denorm
      mov  sinh_GR_exp_mask = 0x1ffff 
}
{ .mlx
      setf.sig sinh_FR_INV_LN2_2TO63 = sinh_GR_sig_inv_ln2 // Form 1/ln2 * 2^63
      movl  sinh_GR_rshf = 0x43e8000000000000 // 1.10000 2^63 for right shift
}
;;

{ .mfi
      getf.exp  sinh_GR_signexp_x = f8   // Extract signexp of x
      fclass.m  p7,p0 = f8, 0x07	// Test if x=0
      nop.i 999
}
{ .mfi
      setf.exp sinh_FR_2TOM57 = sinh_GR_exp_2tom57 // Form 2^-57 for scaling
      nop.f 999
      add  sinh_GR_ad3 = 0x90, sinh_GR_ad1  // Point to ab_table
}
;;

{ .mfi
      setf.d sinh_FR_RSHF = sinh_GR_rshf // Form right shift const 1.100 * 2^63
      fclass.m  p6,p0 = f8, 0xe3	// Test if x nan, inf
      add  sinh_GR_ad4 = 0x4f0, sinh_GR_ad1 // Point to j_table midpoint
}
{ .mib
      add  sinh_GR_ad2e = 0x20, sinh_GR_ad1 // Point to p_table
      mov sinh_GR_all_ones = -1
(p10) br.cond.spnt  SINH_DENORM         // Branch if x denorm
}
;;

// Common path -- return here from SINH_DENORM if x is unnorm
SINH_COMMON:
{ .mfi
      ldfe            sinh_FR_smlst_oflow_input = [sinh_GR_ad2e],16
      nop.f 999
      nop.i 999
}
{ .mib
      ldfe            sinh_FR_log2by64_hi  = [sinh_GR_ad1],16       
      and  sinh_GR_exp_x = sinh_GR_exp_mask, sinh_GR_signexp_x
(p7)  br.ret.spnt   b0                  // Exit if x=0
}
;;

{ .mfi
// Make constant that will generate inexact when squared
      setf.sig sinh_FR_all_ones = sinh_GR_all_ones 
      fcmp.lt.s1 p8,p9 = f8,f0           // Test for x<0
      cmp.ge p7,p0 = sinh_GR_exp_x, sinh_GR_exp_0_25  // Test x < 0.25
}
{ .mfb
      add  sinh_GR_ad2o = 0x30, sinh_GR_ad2e  // Point to p_table odd coeffs
(p6)  fma.d.s0   f8 = f8,f1,f8               
(p6)  br.ret.spnt     b0                 // Exit for x nan, inf
}
;;

// Get the A coefficients for SINH_BY_TBL
// Calculate X2 = ax*ax for SINH_BY_POLY
{ .mfi
      ldfe            sinh_FR_log2by64_lo  = [sinh_GR_ad1],16       
      nop.f 999
      nop.i 999
}
{ .mfb
      ldfe            sinh_FR_A1 = [sinh_GR_ad3],16            
      fma.s1        sinh_FR_X2 = sinh_FR_ABS_X, sinh_FR_ABS_X, f0
(p7)  br.cond.sptk    SINH_BY_TBL
}
;;

// Here if 0 < |x| < 0.25
SINH_BY_POLY: 
{ .mmf
      ldfe            sinh_FR_P6 = [sinh_GR_ad2e],16
      ldfe            sinh_FR_P5 = [sinh_GR_ad2o],16
      nop.f 999
}
;;

{ .mmi
      ldfe            sinh_FR_P4 = [sinh_GR_ad2e],16
      ldfe            sinh_FR_P3 = [sinh_GR_ad2o],16
      nop.i 999
}
;;

{ .mmi
      ldfe            sinh_FR_P2 = [sinh_GR_ad2e],16
      ldfe            sinh_FR_P1 = [sinh_GR_ad2o],16                 
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1        sinh_FR_X3 = sinh_FR_NORM_X, sinh_FR_X2, f0
      nop.i 999
}
{ .mfi
      nop.m 999
      fma.s1        sinh_FR_X4 = sinh_FR_X2, sinh_FR_X2, f0
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1      sinh_FR_poly65 = sinh_FR_X2, sinh_FR_P6, sinh_FR_P5
      nop.i 999
}
{ .mfi
      nop.m 999
      fma.s1      sinh_FR_poly43 = sinh_FR_X2, sinh_FR_P4, sinh_FR_P3
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1      sinh_FR_poly21 = sinh_FR_X2, sinh_FR_P2, sinh_FR_P1
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1   sinh_FR_poly6543 = sinh_FR_X4, sinh_FR_poly65, sinh_FR_poly43
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1   sinh_FR_poly6to1 = sinh_FR_X4, sinh_FR_poly6543, sinh_FR_poly21
      nop.i 999
}
;;

// Dummy multiply to generate inexact
{ .mfi
      nop.m 999
      fmpy.s0      sinh_FR_tmp = sinh_FR_all_ones, sinh_FR_all_ones
      nop.i 999
}
{ .mfb
      nop.m 999
      fma.d.s0      f8 = sinh_FR_poly6to1, sinh_FR_X3, sinh_FR_NORM_X
      br.ret.sptk     b0                // Exit SINH_BY_POLY
}
;;


// Here if |x| >= 0.25
SINH_BY_TBL: 
// ******************************************************
// STEP 1 (TBL and EXP) - Argument reduction
// ******************************************************
// Get the following constants. 
// Inv_log2by64
// log2by64_hi
// log2by64_lo


// We want 2^(N-1) and 2^(-N-1). So bias N-1 and -N-1 and
// put them in an exponent.
// sinh_FR_spos = 2^(N-1) and sinh_FR_sneg = 2^(-N-1)
// 0xffff + (N-1)  = 0xffff +N -1
// 0xffff - (N +1) = 0xffff -N -1


// Calculate M and keep it as integer and floating point.
// M = round-to-integer(x*Inv_log2by64)
// sinh_FR_M = M = truncate(ax/(log2/64))
// Put the integer representation of M in sinh_GR_M
//    and the floating point representation of M in sinh_FR_M

// Get the remaining A,B coefficients
{ .mfi
      ldfe            sinh_FR_A2 = [sinh_GR_ad3],16            
      nop.f 999
      nop.i 999
}
;;

{ .mmi
      ldfe            sinh_FR_A3 = [sinh_GR_ad3],16 ;;
      ldfe            sinh_FR_B1 = [sinh_GR_ad3],16
      nop.i 999
}
;;

.pred.rel "mutex",p8,p9
// Use constant (1.100*2^(63-6)) to get rounded M into rightmost significand
// |x| * 64 * 1/ln2 * 2^(63-6) + 1.1000 * 2^(63+(63-6))
{ .mfi
(p8)  mov  sinh_GR_signexp_sgnx_0_5 = 0x2fffe // signexp of -0.5
      fma.s1  sinh_FR_M_temp = sinh_FR_ABS_X, sinh_FR_INV_LN2_2TO63, sinh_FR_RSHF_2TO57
(p9)  mov  sinh_GR_signexp_sgnx_0_5 = 0x0fffe // signexp of +0.5
}
;;

// Test for |x| >= overflow limit
{ .mfi
      nop.m 999
      fcmp.ge.s1  p6,p0 = sinh_FR_ABS_X, sinh_FR_smlst_oflow_input
      nop.i 999
}
;;

{ .mfi
      ldfe            sinh_FR_B2 = [sinh_GR_ad3],16
      nop.f 999
      nop.i 999
}
;;

// Subtract RSHF constant to get rounded M as a floating point value
// M_temp * 2^(63-6) - 2^63
{ .mfb
      ldfe            sinh_FR_B3 = [sinh_GR_ad3],16            
      fms.s1        sinh_FR_M = sinh_FR_M_temp, sinh_FR_2TOM57, sinh_FR_RSHF
(p6)  br.cond.spnt    SINH_HUGE  // Branch if result will overflow
}
;;

{ .mfi
      getf.sig        sinh_GR_M       = sinh_FR_M_temp                 
      nop.f 999
      nop.i 999
}
;;

// Calculate j. j is the signed extension of the six lsb of M. It 
// has a range of -32 thru 31.

// Calculate R
// ax - M*log2by64_hi
// R = (ax - M*log2by64_hi) - M*log2by64_lo

{ .mfi
      nop.m 999
      fnma.s1 sinh_FR_R_temp = sinh_FR_M, sinh_FR_log2by64_hi, sinh_FR_ABS_X
      and     sinh_GR_j = 0x3f, sinh_GR_M
}
;;

{ .mii
      nop.m 999
      shl     sinh_GR_jshf = sinh_GR_j, 0x2 ;;  // Shift j so can sign extend it
      sxt1    sinh_GR_jshf = sinh_GR_jshf
}
;;

// N = (M-j)/64
{ .mii
      mov     sinh_GR_exp_32 = 0x10004
      shr     sinh_GR_j = sinh_GR_jshf, 0x2 ;;   // Now j has range -32 to 31
      sub     sinh_GR_Mmj = sinh_GR_M, sinh_GR_j ;;   // M-j
}
;;

// The TBL and EXP branches are merged and predicated
// If TBL, p6 true, 0.25 <= |x| < 32
// If EXP, p7 true, 32 <= |x| < overflow_limit
//
{ .mfi
      cmp.ge p7,p6 = sinh_GR_exp_x, sinh_GR_exp_32 // Test if x >= 32
      fnma.s1  sinh_FR_R      = sinh_FR_M, sinh_FR_log2by64_lo, sinh_FR_R_temp 
      shr            sinh_GR_N = sinh_GR_Mmj, 0x6    // N = (M-j)/64 
}
;;

{ .mmi
      sub  r40 = sinh_GR_signexp_sgnx_0_5, sinh_GR_N // signexp of sgnx*2^(-N-1)
      add  r39 = sinh_GR_signexp_sgnx_0_5, sinh_GR_N // signexp of sgnx*2^(N-1)
      shl  sinh_GR_joff = sinh_GR_j,5         // Make j offset to j_table
}
;;

{ .mfi
      setf.exp            sinh_FR_spos = r39  // Form sgnx * 2^(N-1)
      nop.f 999
      sub                 sinh_GR_mJ = r0, sinh_GR_joff // Table offset for -j
}
{ .mfi
      setf.exp            sinh_FR_sneg = r40  // Form sgnx * 2^(-N-1)
      nop.f 999
      add                 sinh_GR_J  = r0, sinh_GR_joff // Table offset for +j
}
;;

// Get the address of the J table midpoint, add the offset 
{ .mmf
      add                  sinh_AD_mJ = sinh_GR_ad4, sinh_GR_mJ
      add                  sinh_AD_J  = sinh_GR_ad4, sinh_GR_J
      nop.f 999
}
;;

{ .mmf
      ldfe                 sinh_FR_Tmjhi = [sinh_AD_mJ],16                 
      ldfe                 sinh_FR_Tjhi  = [sinh_AD_J],16
      nop.f 999
}
;;

// ******************************************************
// STEP 2 (TBL and EXP)
// ******************************************************
// Calculate Rsquared and Rcubed in preparation for p_even and p_odd

{ .mmf
      ldfs                 sinh_FR_Tmjlo = [sinh_AD_mJ],16                 
      ldfs                 sinh_FR_Tjlo  = [sinh_AD_J],16                  
      fma.s1             sinh_FR_Rsq  = sinh_FR_R, sinh_FR_R, f0
}
;;


// Calculate p_even
// B_2 + Rsq *B_3
// B_1 + Rsq * (B_2 + Rsq *B_3)
// p_even = Rsq * (B_1 + Rsq * (B_2 + Rsq *B_3))
{ .mfi
      nop.m 999
      fma.s1          sinh_FR_peven_temp1 = sinh_FR_Rsq, sinh_FR_B3, sinh_FR_B2
      nop.i 999
}
// Calculate p_odd
// A_2 + Rsq *A_3
// A_1 + Rsq * (A_2 + Rsq *A_3)
// podd = R + Rcub * (A_1 + Rsq * (A_2 + Rsq *A_3))
{ .mfi
      nop.m 999
      fma.s1          sinh_FR_podd_temp1 = sinh_FR_Rsq, sinh_FR_A3, sinh_FR_A2
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1             sinh_FR_Rcub = sinh_FR_Rsq, sinh_FR_R, f0
      nop.i 999
}
;;

// 
// If TBL, 
// Calculate S_hi and S_lo, and C_hi
// SC_hi_temp = sneg * Tmjhi
// S_hi = spos * Tjhi - SC_hi_temp
// S_hi = spos * Tjhi - (sneg * Tmjhi)
// C_hi = spos * Tjhi + SC_hi_temp
// C_hi = spos * Tjhi + (sneg * Tmjhi)

{ .mfi
      nop.m 999
(p6)  fma.s1         sinh_FR_SC_hi_temp = sinh_FR_sneg, sinh_FR_Tmjhi, f0   
      nop.i 999
}
;;

// If TBL, 
// S_lo_temp3 = sneg * Tmjlo
// S_lo_temp4 = spos * Tjlo - S_lo_temp3
// S_lo_temp4 = spos * Tjlo -(sneg * Tmjlo)
{ .mfi
      nop.m 999
(p6)  fma.s1  sinh_FR_S_lo_temp3 =  sinh_FR_sneg, sinh_FR_Tmjlo, f0
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1  sinh_FR_peven_temp2 = sinh_FR_Rsq, sinh_FR_peven_temp1, sinh_FR_B1
      nop.i 999
}
{ .mfi
      nop.m 999
      fma.s1  sinh_FR_podd_temp2 = sinh_FR_Rsq, sinh_FR_podd_temp1, sinh_FR_A1
      nop.i 999
}
;;

// If EXP, 
// Compute sgnx * 2^(N-1) * Tjhi and sgnx * 2^(N-1) * Tjlo
{ .mfi
      nop.m 999
(p7)  fma.s1  sinh_FR_Tjhi_spos = sinh_FR_Tjhi, sinh_FR_spos, f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p7)  fma.s1  sinh_FR_Tjlo_spos = sinh_FR_Tjlo, sinh_FR_spos, f0
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p6)  fms.s1  sinh_FR_S_hi = sinh_FR_spos, sinh_FR_Tjhi, sinh_FR_SC_hi_temp
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p6)  fma.s1  sinh_FR_C_hi = sinh_FR_spos, sinh_FR_Tjhi, sinh_FR_SC_hi_temp
      nop.i 999
}
{ .mfi
      nop.m 999
(p6)  fms.s1 sinh_FR_S_lo_temp4 = sinh_FR_spos, sinh_FR_Tjlo, sinh_FR_S_lo_temp3
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1          sinh_FR_peven = sinh_FR_Rsq, sinh_FR_peven_temp2, f0
      nop.i 999
}
{ .mfi
      nop.m 999
      fma.s1          sinh_FR_podd = sinh_FR_podd_temp2, sinh_FR_Rcub, sinh_FR_R
      nop.i 999
}
;;

// If TBL,
// S_lo_temp1 =  spos * Tjhi - S_hi
// S_lo_temp2 = -sneg * Tmjlo + S_lo_temp1
// S_lo_temp2 = -sneg * Tmjlo + (spos * Tjhi - S_hi)

{ .mfi
      nop.m 999
(p6)  fms.s1  sinh_FR_S_lo_temp1 =  sinh_FR_spos, sinh_FR_Tjhi,  sinh_FR_S_hi
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p6)  fnma.s1 sinh_FR_S_lo_temp2 = sinh_FR_sneg, sinh_FR_Tmjhi, sinh_FR_S_lo_temp1       
      nop.i 999
}
;;

// If EXP,
// Y_hi = sgnx * 2^(N-1) * Tjhi
// Y_lo = sgnx * 2^(N-1) * Tjhi * (p_odd + p_even) + sgnx * 2^(N-1) * Tjlo
{ .mfi
      nop.m 999
(p7)  fma.s1  sinh_FR_Y_lo_temp =  sinh_FR_peven, f1, sinh_FR_podd
      nop.i 999
}
;;

// If TBL,
// S_lo = S_lo_temp4 + S_lo_temp2
{ .mfi
      nop.m 999
(p6)  fma.s1         sinh_FR_S_lo = sinh_FR_S_lo_temp4, f1, sinh_FR_S_lo_temp2
      nop.i 999
}
;;

// If TBL,
// Y_hi = S_hi 
// Y_lo = C_hi*p_odd + (S_hi*p_even + S_lo)
{ .mfi
      nop.m 999
(p6)  fma.s1  sinh_FR_Y_lo_temp = sinh_FR_S_hi, sinh_FR_peven, sinh_FR_S_lo
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p7)  fma.s1  sinh_FR_Y_lo = sinh_FR_Tjhi_spos, sinh_FR_Y_lo_temp, sinh_FR_Tjlo_spos
      nop.i 999
}
;;

// Dummy multiply to generate inexact
{ .mfi
      nop.m 999
      fmpy.s0      sinh_FR_tmp = sinh_FR_all_ones, sinh_FR_all_ones
      nop.i 999
}
{ .mfi
      nop.m 999
(p6)  fma.s1       sinh_FR_Y_lo = sinh_FR_C_hi, sinh_FR_podd, sinh_FR_Y_lo_temp
      nop.i 999
}
;;

// f8 = answer = Y_hi + Y_lo
{ .mfi
      nop.m 999
(p7)  fma.d.s0   f8 = sinh_FR_Y_lo,  f1, sinh_FR_Tjhi_spos
      nop.i 999
}
;;

// f8 = answer = Y_hi + Y_lo
{ .mfb
      nop.m 999
(p6)  fma.d.s0  f8 = sinh_FR_Y_lo, f1, sinh_FR_S_hi
      br.ret.sptk     b0      // Exit for SINH_BY_TBL and SINH_BY_EXP
}
;;



// Here if x denorm or unorm
SINH_DENORM:
// Determine if x really a denorm and not a unorm
{ .mmf
      getf.exp  sinh_GR_signexp_x = sinh_FR_NORM_X
      mov  sinh_GR_exp_denorm = 0x0fc01   // Real denorms will have exp < this
      fmerge.s    sinh_FR_ABS_X = f0, sinh_FR_NORM_X
}
;;

{ .mfi
      nop.m 999
      fcmp.eq.s0  p10,p0 = f8, f0  // Set denorm flag
      nop.i 999
}
;;

// Set p8 if really a denorm
{ .mmi
      and  sinh_GR_exp_x = sinh_GR_exp_mask, sinh_GR_signexp_x ;;
      cmp.lt  p8,p9 = sinh_GR_exp_x, sinh_GR_exp_denorm
      nop.i 999
}
;;

// Identify denormal operands.
{ .mfb
      nop.m 999
(p8)  fcmp.ge.unc.s1  p6,p7 = f8, f0   // Test sign of denorm
(p9)  br.cond.sptk  SINH_COMMON    // Return to main path if x unorm
}
;;

{ .mfi
      nop.m 999
(p6)  fma.d.s0       f8 =  f8,f8,f8  // If x +denorm, result=x+x^2
      nop.i 999 
}
{ .mfb
      nop.m 999
(p7)  fnma.d.s0      f8 =  f8,f8,f8  // If x -denorm, result=x-x^2
      br.ret.sptk    b0            // Exit if x denorm
}
;;



// Here if |x| >= overflow limit
SINH_HUGE: 
// for SINH_HUGE, put 24000 in exponent; take sign from input
{ .mmi
      mov                sinh_GR_exp_huge = 0x15dbf ;;
      setf.exp            sinh_FR_huge  = sinh_GR_exp_huge
      nop.i 999
}
;;

.pred.rel "mutex",p8,p9
{ .mfi
      nop.m 999
(p8)  fnma.s1  sinh_FR_signed_hi_lo = sinh_FR_huge, f1, f1
      nop.i 999
}
{ .mfi
      nop.m 999
(p9)  fma.s1   sinh_FR_signed_hi_lo = sinh_FR_huge, f1, f1
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.d.s0  sinh_FR_pre_result = sinh_FR_signed_hi_lo, sinh_FR_huge, f0
      mov                 GR_Parameter_TAG = 127
}
;;

.endp sinh

// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs

.proc __libm_error_region
__libm_error_region:
SINH_ERROR_SUPPORT:
.prologue

// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfd [GR_Parameter_Y] = f0,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfd [GR_Parameter_X] = f8                     // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y   // Parameter 3 address
        nop.b 0                            
}
{ .mib
        stfd [GR_Parameter_Y] = sinh_FR_pre_result     // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#          // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\sinhf.s ===
.file "sinhf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 10/12/00 Update to set denormal operand and underflow flags
// 1/22/01  Fixed to set inexact flag for small args.
// 5/02/01  Reworked to improve speed of all paths
//
// API
//==============================================================
// float = sinhf(float)
// input  floating point f8
// output floating point f8
//
// Registers used
//==============================================================
// general registers: 
// r32 -> r47
// predicate registers used:
// p6 -> p11
// floating-point registers used:
// f9 -> f15; f32 -> f90; 
// f8 has input, then output
//
// Overview of operation
//==============================================================
// There are seven paths
// 1. 0 < |x| < 0.25          SINH_BY_POLY
// 2. 0.25 <=|x| < 32         SINH_BY_TBL
// 3. 32 <= |x| < 89.415986   SINH_BY_EXP (merged path with SINH_BY_TBL)
// 4. |x| >= 89.415986        SINH_HUGE
// 5. x=0                     Done with early exit
// 6. x=inf,nan               Done with early exit
// 7. x=denormal              SINH_DENORM
//
// For float we get overflow for x >= 4005 b2d4 fc27 c173 18a0
//                                 >= 89.415986
//
//
// 1. SINH_BY_POLY   0 < |x| < 0.25
// ===============
// Evaluate sinh(x) by a 13th order polynomial
// Care is take for the order of multiplication; and P_1 is not exactly 1/3!, 
// P_2 is not exactly 1/5!, etc.
// sinh(x) = sign * (series(e^x) - series(e^-x))/2
//         = sign * (ax + ax^3/3! + ax^5/5! + ax^7/7! + ax^9/9! + ax^11/11!
//                        + ax^13/13!)
//         = sign * (ax   + ax * ( ax^2 * (1/3! + ax^4 * (1/7! + ax^4*1/11!)) )
//                        + ax * ( ax^4 * (1/5! + ax^4 * (1/9! + ax^4*1/13!)) ))
//         = sign * (ax   + ax*p_odd + (ax*p_even))
//         = sign * (ax   + Y_lo)
// sinh(x) = sign * (Y_hi + Y_lo)
// Note that ax = |x|
//
// 2. SINH_BY_TBL   0.25 <= |x| < 32.0
// =============
// sinh(x) = sinh(B+R)
//         = sinh(B)cosh(R) + cosh(B)sinh(R)
// 
// ax = |x| = M*log2/64 + R
// B = M*log2/64
// M = 64*N + j 
//   We will calculate M and get N as (M-j)/64
//   The division is a shift.
// exp(B)  = exp(N*log2 + j*log2/64)
//         = 2^N * 2^(j*log2/64)
// sinh(B) = 1/2(e^B -e^-B)
//         = 1/2(2^N * 2^(j*log2/64) - 2^-N * 2^(-j*log2/64)) 
// sinh(B) = (2^(N-1) * 2^(j*log2/64) - 2^(-N-1) * 2^(-j*log2/64)) 
// cosh(B) = (2^(N-1) * 2^(j*log2/64) + 2^(-N-1) * 2^(-j*log2/64)) 
// 2^(j*log2/64) is stored as Tjhi + Tjlo , j= -32,....,32
// Tjhi is double-extended (80-bit) and Tjlo is single(32-bit)
//
// R = ax - M*log2/64
// R = ax - M*log2_by_64_hi - M*log2_by_64_lo
// exp(R) = 1 + R +R^2(1/2! + R(1/3! + R(1/4! + ... + R(1/n!)...)
//        = 1 + p_odd + p_even
//        where the p_even uses the A coefficients and the p_even uses 
//        the B coefficients
//
// So sinh(R) = 1 + p_odd + p_even -(1 -p_odd -p_even)/2 = p_odd
//    cosh(R) = 1 + p_even
//    sinh(B) = S_hi + S_lo
//    cosh(B) = C_hi
// sinh(x) = sinh(B)cosh(R) + cosh(B)sinh(R)
//
// 3. SINH_BY_EXP   32.0 <= |x| < 89.415986    ( 4005 b2d4 fc27 c173 18a0 )
// ==============
// Can approximate result by exp(x)/2 in this region.
// Y_hi = Tjhi
// Y_lo = Tjhi * (p_odd + p_even) + Tjlo
// sinh(x) = Y_hi + Y_lo
//
// 4. SINH_HUGE     |x| >= 89.415986    ( 4005 b2d4 fc27 c173 18a0 )
// ============
// Set error tag and call error support
//
//
// Assembly macros
//==============================================================
sinh_GR_ad1          = r34
sinh_GR_Mmj          = r34
sinh_GR_jshf         = r36
sinh_GR_M            = r35
sinh_GR_N            = r35
sinh_GR_exp_2tom57   = r36
sinh_GR_j            = r36
sinh_GR_joff         = r36
sinh_GR_exp_mask     = r37
sinh_GR_mJ           = r38
sinh_AD_mJ           = r38
sinh_GR_signexp_x    = r38
sinh_GR_signexp_sgnx_0_5 = r38
sinh_GR_exp_0_25     = r39
sinh_GR_J            = r39
sinh_AD_J            = r39
sinh_GR_sig_inv_ln2  = r40
sinh_GR_exp_32       = r40
sinh_GR_exp_huge     = r40
sinh_GR_all_ones     = r40

sinh_GR_ad2e         = r41
sinh_GR_ad3          = r42
sinh_GR_ad4          = r43
sinh_GR_rshf         = r44
sinh_GR_ad2o         = r45
sinh_GR_rshf_2to57   = r46
sinh_GR_exp_denorm   = r46
sinh_GR_exp_x        = r47


GR_SAVE_PFS          = r41
GR_SAVE_B0           = r42
GR_SAVE_GP           = r43

GR_Parameter_X       = r44
GR_Parameter_Y       = r45
GR_Parameter_RESULT  = r46
GR_Parameter_TAG     = r47


sinh_FR_ABS_X        = f9 
sinh_FR_X2           = f10
sinh_FR_X4           = f11
sinh_FR_all_ones     = f13
sinh_FR_tmp          = f14
sinh_FR_RSHF         = f15

sinh_FR_Inv_log2by64 = f32
sinh_FR_log2by64_lo  = f33
sinh_FR_log2by64_hi  = f34
sinh_FR_A1           = f35

sinh_FR_A2           = f36
sinh_FR_A3           = f37
sinh_FR_Rcub         = f38
sinh_FR_M_temp       = f39
sinh_FR_R_temp       = f40

sinh_FR_Rsq          = f41
sinh_FR_R            = f42
sinh_FR_M            = f43
sinh_FR_B1           = f44
sinh_FR_B2           = f45

sinh_FR_B3           = f46
sinh_FR_peven_temp1  = f47
sinh_FR_peven_temp2  = f48
sinh_FR_peven        = f49
sinh_FR_podd_temp1   = f50

sinh_FR_podd_temp2   = f51
sinh_FR_podd         = f52
sinh_FR_poly65       = f53
sinh_FR_poly6543     = f53
sinh_FR_poly6to1     = f53
sinh_FR_poly43       = f54
sinh_FR_poly21       = f55

sinh_FR_X3           = f56
sinh_FR_INV_LN2_2TO63= f57
sinh_FR_RSHF_2TO57   = f58
sinh_FR_2TOM57       = f59
sinh_FR_smlst_oflow_input = f60

sinh_FR_pre_result   = f61
sinh_FR_huge         = f62
sinh_FR_spos         = f63
sinh_FR_sneg         = f64
sinh_FR_Tjhi         = f65

sinh_FR_Tjlo         = f66
sinh_FR_Tmjhi        = f67
sinh_FR_Tmjlo        = f68
sinh_FR_S_hi         = f69
sinh_FR_SC_hi_temp   = f70

sinh_FR_S_lo_temp1   = f71 
sinh_FR_S_lo_temp2   = f72 
sinh_FR_S_lo_temp3   = f73 
sinh_FR_S_lo_temp4   = f73 
sinh_FR_S_lo         = f74
sinh_FR_C_hi         = f75

sinh_FR_C_hi_temp1   = f76
sinh_FR_Y_hi         = f77 
sinh_FR_Y_lo_temp    = f78 
sinh_FR_Y_lo         = f79 
sinh_FR_NORM_X       = f80

sinh_FR_P1           = f81
sinh_FR_P2           = f82
sinh_FR_P3           = f83
sinh_FR_P4           = f84
sinh_FR_P5           = f85

sinh_FR_P6           = f86
sinh_FR_Tjhi_spos    = f87
sinh_FR_Tjlo_spos    = f88
sinh_FR_huge         = f89
sinh_FR_signed_hi_lo = f90


// Data tables
//==============================================================

// DO NOT CHANGE ORDER OF THESE TABLES
.data

.align 16
double_sinh_arg_reduction:
//   data8 0xB8AA3B295C17F0BC, 0x00004005  // 64/log2 -- signif loaded with setf
   data8 0xB17217F7D1000000, 0x00003FF8  // log2/64 high part
   data8 0xCF79ABC9E3B39804, 0x00003FD0  // log2/64 low part

double_sinh_p_table:
   data8 0xb2d4fc27c17318a0, 0x00004005  // Smallest x to overflow (89.415986)
   data8 0xB08AF9AE78C1239F, 0x00003FDE  // P6
   data8 0xB8EF1D28926D8891, 0x00003FEC  // P4
   data8 0x8888888888888412, 0x00003FF8  // P2
   data8 0xD732377688025BE9, 0x00003FE5  // P5
   data8 0xD00D00D00D4D39F2, 0x00003FF2  // P3
   data8 0xAAAAAAAAAAAAAAAB, 0x00003FFC  // P1

double_sinh_ab_table:
   data8 0xAAAAAAAAAAAAAAAC, 0x00003FFC  // A1
   data8 0x88888888884ECDD5, 0x00003FF8  // A2
   data8 0xD00D0C6DCC26A86B, 0x00003FF2  // A3
   data8 0x8000000000000002, 0x00003FFE  // B1
   data8 0xAAAAAAAAAA402C77, 0x00003FFA  // B2
   data8 0xB60B6CC96BDB144D, 0x00003FF5  // B3

double_sinh_j_table:
   data8 0xB504F333F9DE6484, 0x00003FFE, 0x1EB2FB13, 0x00000000
   data8 0xB6FD91E328D17791, 0x00003FFE, 0x1CE2CBE2, 0x00000000
   data8 0xB8FBAF4762FB9EE9, 0x00003FFE, 0x1DDC3CBC, 0x00000000
   data8 0xBAFF5AB2133E45FB, 0x00003FFE, 0x1EE9AA34, 0x00000000
   data8 0xBD08A39F580C36BF, 0x00003FFE, 0x9EAEFDC1, 0x00000000
   data8 0xBF1799B67A731083, 0x00003FFE, 0x9DBF517B, 0x00000000
   data8 0xC12C4CCA66709456, 0x00003FFE, 0x1EF88AFB, 0x00000000
   data8 0xC346CCDA24976407, 0x00003FFE, 0x1E03B216, 0x00000000
   data8 0xC5672A115506DADD, 0x00003FFE, 0x1E78AB43, 0x00000000
   data8 0xC78D74C8ABB9B15D, 0x00003FFE, 0x9E7B1747, 0x00000000
   data8 0xC9B9BD866E2F27A3, 0x00003FFE, 0x9EFE3C0E, 0x00000000
   data8 0xCBEC14FEF2727C5D, 0x00003FFE, 0x9D36F837, 0x00000000
   data8 0xCE248C151F8480E4, 0x00003FFE, 0x9DEE53E4, 0x00000000
   data8 0xD06333DAEF2B2595, 0x00003FFE, 0x9E24AE8E, 0x00000000
   data8 0xD2A81D91F12AE45A, 0x00003FFE, 0x1D912473, 0x00000000
   data8 0xD4F35AABCFEDFA1F, 0x00003FFE, 0x1EB243BE, 0x00000000
   data8 0xD744FCCAD69D6AF4, 0x00003FFE, 0x1E669A2F, 0x00000000
   data8 0xD99D15C278AFD7B6, 0x00003FFE, 0x9BBC610A, 0x00000000
   data8 0xDBFBB797DAF23755, 0x00003FFE, 0x1E761035, 0x00000000
   data8 0xDE60F4825E0E9124, 0x00003FFE, 0x9E0BE175, 0x00000000
   data8 0xE0CCDEEC2A94E111, 0x00003FFE, 0x1CCB12A1, 0x00000000
   data8 0xE33F8972BE8A5A51, 0x00003FFE, 0x1D1BFE90, 0x00000000
   data8 0xE5B906E77C8348A8, 0x00003FFE, 0x1DF2F47A, 0x00000000
   data8 0xE8396A503C4BDC68, 0x00003FFE, 0x1EF22F22, 0x00000000
   data8 0xEAC0C6E7DD24392F, 0x00003FFE, 0x9E3F4A29, 0x00000000
   data8 0xED4F301ED9942B84, 0x00003FFE, 0x1EC01A5B, 0x00000000
   data8 0xEFE4B99BDCDAF5CB, 0x00003FFE, 0x1E8CAC3A, 0x00000000
   data8 0xF281773C59FFB13A, 0x00003FFE, 0x9DBB3FAB, 0x00000000
   data8 0xF5257D152486CC2C, 0x00003FFE, 0x1EF73A19, 0x00000000
   data8 0xF7D0DF730AD13BB9, 0x00003FFE, 0x9BB795B5, 0x00000000
   data8 0xFA83B2DB722A033A, 0x00003FFE, 0x1EF84B76, 0x00000000
   data8 0xFD3E0C0CF486C175, 0x00003FFE, 0x9EF5818B, 0x00000000
   data8 0x8000000000000000, 0x00003FFF, 0x00000000, 0x00000000
   data8 0x8164D1F3BC030773, 0x00003FFF, 0x1F77CACA, 0x00000000
   data8 0x82CD8698AC2BA1D7, 0x00003FFF, 0x1EF8A91D, 0x00000000
   data8 0x843A28C3ACDE4046, 0x00003FFF, 0x1E57C976, 0x00000000
   data8 0x85AAC367CC487B15, 0x00003FFF, 0x9EE8DA92, 0x00000000
   data8 0x871F61969E8D1010, 0x00003FFF, 0x1EE85C9F, 0x00000000
   data8 0x88980E8092DA8527, 0x00003FFF, 0x1F3BF1AF, 0x00000000
   data8 0x8A14D575496EFD9A, 0x00003FFF, 0x1D80CA1E, 0x00000000
   data8 0x8B95C1E3EA8BD6E7, 0x00003FFF, 0x9D0373AF, 0x00000000
   data8 0x8D1ADF5B7E5BA9E6, 0x00003FFF, 0x9F167097, 0x00000000
   data8 0x8EA4398B45CD53C0, 0x00003FFF, 0x1EB70051, 0x00000000
   data8 0x9031DC431466B1DC, 0x00003FFF, 0x1F6EB029, 0x00000000
   data8 0x91C3D373AB11C336, 0x00003FFF, 0x1DFD6D8E, 0x00000000
   data8 0x935A2B2F13E6E92C, 0x00003FFF, 0x9EB319B0, 0x00000000
   data8 0x94F4EFA8FEF70961, 0x00003FFF, 0x1EBA2BEB, 0x00000000
   data8 0x96942D3720185A00, 0x00003FFF, 0x1F11D537, 0x00000000
   data8 0x9837F0518DB8A96F, 0x00003FFF, 0x1F0D5A46, 0x00000000
   data8 0x99E0459320B7FA65, 0x00003FFF, 0x9E5E7BCA, 0x00000000
   data8 0x9B8D39B9D54E5539, 0x00003FFF, 0x9F3AAFD1, 0x00000000
   data8 0x9D3ED9A72CFFB751, 0x00003FFF, 0x9E86DACC, 0x00000000
   data8 0x9EF5326091A111AE, 0x00003FFF, 0x9F3EDDC2, 0x00000000
   data8 0xA0B0510FB9714FC2, 0x00003FFF, 0x1E496E3D, 0x00000000
   data8 0xA27043030C496819, 0x00003FFF, 0x9F490BF6, 0x00000000
   data8 0xA43515AE09E6809E, 0x00003FFF, 0x1DD1DB48, 0x00000000
   data8 0xA5FED6A9B15138EA, 0x00003FFF, 0x1E65EBFB, 0x00000000
   data8 0xA7CD93B4E965356A, 0x00003FFF, 0x9F427496, 0x00000000
   data8 0xA9A15AB4EA7C0EF8, 0x00003FFF, 0x1F283C4A, 0x00000000
   data8 0xAB7A39B5A93ED337, 0x00003FFF, 0x1F4B0047, 0x00000000
   data8 0xAD583EEA42A14AC6, 0x00003FFF, 0x1F130152, 0x00000000
   data8 0xAF3B78AD690A4375, 0x00003FFF, 0x9E8367C0, 0x00000000
   data8 0xB123F581D2AC2590, 0x00003FFF, 0x9F705F90, 0x00000000
   data8 0xB311C412A9112489, 0x00003FFF, 0x1EFB3C53, 0x00000000
   data8 0xB504F333F9DE6484, 0x00003FFF, 0x1F32FB13, 0x00000000

.align 32
.global sinhf#

.section .text
.proc  sinhf#
.align 32

sinhf: 

{ .mlx
      alloc r32 = ar.pfs,0,12,4,0                  
      movl  sinh_GR_sig_inv_ln2 = 0xb8aa3b295c17f0bc // significand of 1/ln2
}
{ .mlx
      addl sinh_GR_ad1   = @ltoff(double_sinh_arg_reduction), gp
      movl  sinh_GR_rshf_2to57 = 0x4778000000000000 // 1.10000 2^(63+57)
}
;;

{ .mfi
      ld8 sinh_GR_ad1 = [sinh_GR_ad1]
      fmerge.s      sinh_FR_ABS_X    = f0,f8
      mov  sinh_GR_exp_0_25 = 0x0fffd    // Form exponent for 0.25
}
{ .mfi
      nop.m 999
      fnorm.s1  sinh_FR_NORM_X = f8
      mov sinh_GR_exp_2tom57 = 0xffff-57
}
;;

{ .mfi
      setf.d sinh_FR_RSHF_2TO57 = sinh_GR_rshf_2to57 // Form const 1.100 * 2^120
      fclass.m p10,p0 = f8, 0x0b         // Test for denorm
      mov  sinh_GR_exp_mask = 0x1ffff 
}
{ .mlx
      setf.sig sinh_FR_INV_LN2_2TO63 = sinh_GR_sig_inv_ln2 // Form 1/ln2 * 2^63
      movl  sinh_GR_rshf = 0x43e8000000000000 // 1.10000 2^63 for right shift
}
;;

{ .mfi
      getf.exp  sinh_GR_signexp_x = f8   // Extract signexp of x
      fclass.m  p7,p0 = f8, 0x07	// Test if x=0
      nop.i 999
}
{ .mfi
      setf.exp sinh_FR_2TOM57 = sinh_GR_exp_2tom57 // Form 2^-57 for scaling
      nop.f 999
      add  sinh_GR_ad3 = 0x90, sinh_GR_ad1  // Point to ab_table
}
;;

{ .mfi
      setf.d sinh_FR_RSHF = sinh_GR_rshf // Form right shift const 1.100 * 2^63
      fclass.m  p6,p0 = f8, 0xe3	// Test if x nan, inf
      add  sinh_GR_ad4 = 0x4f0, sinh_GR_ad1 // Point to j_table midpoint
}
{ .mib
      add  sinh_GR_ad2e = 0x20, sinh_GR_ad1 // Point to p_table
      mov sinh_GR_all_ones = -1
(p10) br.cond.spnt  SINH_DENORM         // Branch if x denorm
}
;;

// Common path -- return here from SINH_DENORM if x is unnorm
SINH_COMMON:
{ .mfi
      ldfe            sinh_FR_smlst_oflow_input = [sinh_GR_ad2e],16
      nop.f 999
      nop.i 999
}
{ .mib
      ldfe            sinh_FR_log2by64_hi  = [sinh_GR_ad1],16       
      and  sinh_GR_exp_x = sinh_GR_exp_mask, sinh_GR_signexp_x
(p7)  br.ret.spnt   b0                  // Exit if x=0
}
;;

{ .mfi
// Make constant that will generate inexact when squared
      setf.sig sinh_FR_all_ones = sinh_GR_all_ones 
      fcmp.lt.s1 p8,p9 = f8,f0           // Test for x<0
      cmp.ge p7,p0 = sinh_GR_exp_x, sinh_GR_exp_0_25  // Test x < 0.25
}
{ .mfb
      add  sinh_GR_ad2o = 0x30, sinh_GR_ad2e  // Point to p_table odd coeffs
(p6)  fma.s.s0   f8 = f8,f1,f8               
(p6)  br.ret.spnt     b0                 // Exit for x nan, inf
}
;;

// Get the A coefficients for SINH_BY_TBL
// Calculate X2 = ax*ax for SINH_BY_POLY
{ .mfi
      ldfe            sinh_FR_log2by64_lo  = [sinh_GR_ad1],16       
      nop.f 999
      nop.i 999
}
{ .mfb
      ldfe            sinh_FR_A1 = [sinh_GR_ad3],16            
      fma.s1        sinh_FR_X2 = sinh_FR_ABS_X, sinh_FR_ABS_X, f0
(p7)  br.cond.sptk    SINH_BY_TBL
}
;;

// Here if 0 < |x| < 0.25
SINH_BY_POLY: 
{ .mmf
      ldfe            sinh_FR_P6 = [sinh_GR_ad2e],16
      ldfe            sinh_FR_P5 = [sinh_GR_ad2o],16
      nop.f 999
}
;;

{ .mmi
      ldfe            sinh_FR_P4 = [sinh_GR_ad2e],16
      ldfe            sinh_FR_P3 = [sinh_GR_ad2o],16
      nop.i 999
}
;;

{ .mmi
      ldfe            sinh_FR_P2 = [sinh_GR_ad2e],16
      ldfe            sinh_FR_P1 = [sinh_GR_ad2o],16                 
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1        sinh_FR_X3 = sinh_FR_NORM_X, sinh_FR_X2, f0
      nop.i 999
}
{ .mfi
      nop.m 999
      fma.s1        sinh_FR_X4 = sinh_FR_X2, sinh_FR_X2, f0
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1      sinh_FR_poly65 = sinh_FR_X2, sinh_FR_P6, sinh_FR_P5
      nop.i 999
}
{ .mfi
      nop.m 999
      fma.s1      sinh_FR_poly43 = sinh_FR_X2, sinh_FR_P4, sinh_FR_P3
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1      sinh_FR_poly21 = sinh_FR_X2, sinh_FR_P2, sinh_FR_P1
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1   sinh_FR_poly6543 = sinh_FR_X4, sinh_FR_poly65, sinh_FR_poly43
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1   sinh_FR_poly6to1 = sinh_FR_X4, sinh_FR_poly6543, sinh_FR_poly21
      nop.i 999
}
;;

// Dummy multiply to generate inexact
{ .mfi
      nop.m 999
      fmpy.s0      sinh_FR_tmp = sinh_FR_all_ones, sinh_FR_all_ones
      nop.i 999
}
{ .mfb
      nop.m 999
      fma.s.s0      f8 = sinh_FR_poly6to1, sinh_FR_X3, sinh_FR_NORM_X
      br.ret.sptk     b0                // Exit SINH_BY_POLY
}
;;



// Here if |x| >= 0.25
SINH_BY_TBL: 
// ******************************************************
// STEP 1 (TBL and EXP) - Argument reduction
// ******************************************************
// Get the following constants. 
// Inv_log2by64
// log2by64_hi
// log2by64_lo


// We want 2^(N-1) and 2^(-N-1). So bias N-1 and -N-1 and
// put them in an exponent.
// sinh_FR_spos = 2^(N-1) and sinh_FR_sneg = 2^(-N-1)
// 0xffff + (N-1)  = 0xffff +N -1
// 0xffff - (N +1) = 0xffff -N -1


// Calculate M and keep it as integer and floating point.
// M = round-to-integer(x*Inv_log2by64)
// sinh_FR_M = M = truncate(ax/(log2/64))
// Put the integer representation of M in sinh_GR_M
//    and the floating point representation of M in sinh_FR_M

// Get the remaining A,B coefficients
{ .mfi
      ldfe            sinh_FR_A2 = [sinh_GR_ad3],16            
      nop.f 999
      nop.i 999
}
;;

{ .mmi
      ldfe            sinh_FR_A3 = [sinh_GR_ad3],16 ;;
      ldfe            sinh_FR_B1 = [sinh_GR_ad3],16
      nop.i 999
}
;;

.pred.rel "mutex",p8,p9
// Use constant (1.100*2^(63-6)) to get rounded M into rightmost significand
// |x| * 64 * 1/ln2 * 2^(63-6) + 1.1000 * 2^(63+(63-6))
{ .mfi
(p8)  mov  sinh_GR_signexp_sgnx_0_5 = 0x2fffe // signexp of -0.5
      fma.s1  sinh_FR_M_temp = sinh_FR_ABS_X, sinh_FR_INV_LN2_2TO63, sinh_FR_RSHF_2TO57
(p9)  mov  sinh_GR_signexp_sgnx_0_5 = 0x0fffe // signexp of +0.5
}
;;

// Test for |x| >= overflow limit
{ .mfi
      nop.m 999
      fcmp.ge.s1  p6,p0 = sinh_FR_ABS_X, sinh_FR_smlst_oflow_input
      nop.i 999
}
;;

{ .mfi
      ldfe            sinh_FR_B2 = [sinh_GR_ad3],16
      nop.f 999
      nop.i 999
}
;;

// Subtract RSHF constant to get rounded M as a floating point value
// M_temp * 2^(63-6) - 2^63
{ .mfb
      ldfe            sinh_FR_B3 = [sinh_GR_ad3],16            
      fms.s1        sinh_FR_M = sinh_FR_M_temp, sinh_FR_2TOM57, sinh_FR_RSHF
(p6)  br.cond.spnt    SINH_HUGE  // Branch if result will overflow
}
;;

{ .mfi
      getf.sig        sinh_GR_M       = sinh_FR_M_temp                 
      nop.f 999
      nop.i 999
}
;;

// Calculate j. j is the signed extension of the six lsb of M. It 
// has a range of -32 thru 31.

// Calculate R
// ax - M*log2by64_hi
// R = (ax - M*log2by64_hi) - M*log2by64_lo

{ .mfi
      nop.m 999
      fnma.s1 sinh_FR_R_temp = sinh_FR_M, sinh_FR_log2by64_hi, sinh_FR_ABS_X
      and     sinh_GR_j = 0x3f, sinh_GR_M
}
;;

{ .mii
      nop.m 999
      shl     sinh_GR_jshf = sinh_GR_j, 0x2 ;;  // Shift j so can sign extend it
      sxt1    sinh_GR_jshf = sinh_GR_jshf
}
;;

// N = (M-j)/64
{ .mii
      mov     sinh_GR_exp_32 = 0x10004
      shr     sinh_GR_j = sinh_GR_jshf, 0x2 ;;   // Now j has range -32 to 31
      sub     sinh_GR_Mmj = sinh_GR_M, sinh_GR_j ;;   // M-j
}
;;

// The TBL and EXP branches are merged and predicated
// If TBL, p6 true, 0.25 <= |x| < 32
// If EXP, p7 true, 32 <= |x| < overflow_limit
//
{ .mfi
      cmp.ge p7,p6 = sinh_GR_exp_x, sinh_GR_exp_32 // Test if x >= 32
      fnma.s1  sinh_FR_R      = sinh_FR_M, sinh_FR_log2by64_lo, sinh_FR_R_temp 
      shr            sinh_GR_N = sinh_GR_Mmj, 0x6    // N = (M-j)/64 
}
;;

{ .mmi
      sub  r40 = sinh_GR_signexp_sgnx_0_5, sinh_GR_N // signexp of sgnx*2^(-N-1)
      add  r39 = sinh_GR_signexp_sgnx_0_5, sinh_GR_N // signexp of sgnx*2^(N-1)
      shl  sinh_GR_joff = sinh_GR_j,5         // Make j offset to j_table
}
;;

{ .mfi
      setf.exp            sinh_FR_spos = r39  // Form sgnx * 2^(N-1)
      nop.f 999
      sub                 sinh_GR_mJ = r0, sinh_GR_joff // Table offset for -j
}
{ .mfi
      setf.exp            sinh_FR_sneg = r40  // Form sgnx * 2^(-N-1)
      nop.f 999
      add                 sinh_GR_J  = r0, sinh_GR_joff // Table offset for +j
}
;;

// Get the address of the J table midpoint, add the offset 
{ .mmf
      add                  sinh_AD_mJ = sinh_GR_ad4, sinh_GR_mJ
      add                  sinh_AD_J  = sinh_GR_ad4, sinh_GR_J
      nop.f 999
}
;;

{ .mmf
      ldfe                 sinh_FR_Tmjhi = [sinh_AD_mJ],16                 
      ldfe                 sinh_FR_Tjhi  = [sinh_AD_J],16
      nop.f 999
}
;;

// ******************************************************
// STEP 2 (TBL and EXP)
// ******************************************************
// Calculate Rsquared and Rcubed in preparation for p_even and p_odd

{ .mmf
      ldfs                 sinh_FR_Tmjlo = [sinh_AD_mJ],16                 
      ldfs                 sinh_FR_Tjlo  = [sinh_AD_J],16                  
      fma.s1             sinh_FR_Rsq  = sinh_FR_R, sinh_FR_R, f0
}
;;


// Calculate p_even
// B_2 + Rsq *B_3
// B_1 + Rsq * (B_2 + Rsq *B_3)
// p_even = Rsq * (B_1 + Rsq * (B_2 + Rsq *B_3))
{ .mfi
      nop.m 999
      fma.s1          sinh_FR_peven_temp1 = sinh_FR_Rsq, sinh_FR_B3, sinh_FR_B2
      nop.i 999
}
// Calculate p_odd
// A_2 + Rsq *A_3
// A_1 + Rsq * (A_2 + Rsq *A_3)
// podd = R + Rcub * (A_1 + Rsq * (A_2 + Rsq *A_3))
{ .mfi
      nop.m 999
      fma.s1          sinh_FR_podd_temp1 = sinh_FR_Rsq, sinh_FR_A3, sinh_FR_A2
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1             sinh_FR_Rcub = sinh_FR_Rsq, sinh_FR_R, f0
      nop.i 999
}
;;

// 
// If TBL, 
// Calculate S_hi and S_lo, and C_hi
// SC_hi_temp = sneg * Tmjhi
// S_hi = spos * Tjhi - SC_hi_temp
// S_hi = spos * Tjhi - (sneg * Tmjhi)
// C_hi = spos * Tjhi + SC_hi_temp
// C_hi = spos * Tjhi + (sneg * Tmjhi)

{ .mfi
      nop.m 999
(p6)  fma.s1         sinh_FR_SC_hi_temp = sinh_FR_sneg, sinh_FR_Tmjhi, f0   
      nop.i 999
}
;;

// If TBL, 
// S_lo_temp3 = sneg * Tmjlo
// S_lo_temp4 = spos * Tjlo - S_lo_temp3
// S_lo_temp4 = spos * Tjlo -(sneg * Tmjlo)
{ .mfi
      nop.m 999
(p6)  fma.s1  sinh_FR_S_lo_temp3 =  sinh_FR_sneg, sinh_FR_Tmjlo, f0
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1  sinh_FR_peven_temp2 = sinh_FR_Rsq, sinh_FR_peven_temp1, sinh_FR_B1
      nop.i 999
}
{ .mfi
      nop.m 999
      fma.s1  sinh_FR_podd_temp2 = sinh_FR_Rsq, sinh_FR_podd_temp1, sinh_FR_A1
      nop.i 999
}
;;

// If EXP, 
// Compute sgnx * 2^(N-1) * Tjhi and sgnx * 2^(N-1) * Tjlo
{ .mfi
      nop.m 999
(p7)  fma.s1  sinh_FR_Tjhi_spos = sinh_FR_Tjhi, sinh_FR_spos, f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p7)  fma.s1  sinh_FR_Tjlo_spos = sinh_FR_Tjlo, sinh_FR_spos, f0
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p6)  fms.s1  sinh_FR_S_hi = sinh_FR_spos, sinh_FR_Tjhi, sinh_FR_SC_hi_temp
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p6)  fma.s1  sinh_FR_C_hi = sinh_FR_spos, sinh_FR_Tjhi, sinh_FR_SC_hi_temp
      nop.i 999
}
{ .mfi
      nop.m 999
(p6)  fms.s1 sinh_FR_S_lo_temp4 = sinh_FR_spos, sinh_FR_Tjlo, sinh_FR_S_lo_temp3
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1          sinh_FR_peven = sinh_FR_Rsq, sinh_FR_peven_temp2, f0
      nop.i 999
}
{ .mfi
      nop.m 999
      fma.s1          sinh_FR_podd = sinh_FR_podd_temp2, sinh_FR_Rcub, sinh_FR_R
      nop.i 999
}
;;

// If TBL,
// S_lo_temp1 =  spos * Tjhi - S_hi
// S_lo_temp2 = -sneg * Tmjlo + S_lo_temp1
// S_lo_temp2 = -sneg * Tmjlo + (spos * Tjhi - S_hi)

{ .mfi
      nop.m 999
(p6)  fms.s1  sinh_FR_S_lo_temp1 =  sinh_FR_spos, sinh_FR_Tjhi,  sinh_FR_S_hi
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p6)  fnma.s1 sinh_FR_S_lo_temp2 = sinh_FR_sneg, sinh_FR_Tmjhi, sinh_FR_S_lo_temp1       
      nop.i 999
}
;;

// If EXP,
// Y_hi = sgnx * 2^(N-1) * Tjhi
// Y_lo = sgnx * 2^(N-1) * Tjhi * (p_odd + p_even) + sgnx * 2^(N-1) * Tjlo
{ .mfi
      nop.m 999
(p7)  fma.s1  sinh_FR_Y_lo_temp =  sinh_FR_peven, f1, sinh_FR_podd
      nop.i 999
}
;;

// If TBL,
// S_lo = S_lo_temp4 + S_lo_temp2
{ .mfi
      nop.m 999
(p6)  fma.s1         sinh_FR_S_lo = sinh_FR_S_lo_temp4, f1, sinh_FR_S_lo_temp2
      nop.i 999
}
;;

// If TBL,
// Y_hi = S_hi 
// Y_lo = C_hi*p_odd + (S_hi*p_even + S_lo)
{ .mfi
      nop.m 999
(p6)  fma.s1  sinh_FR_Y_lo_temp = sinh_FR_S_hi, sinh_FR_peven, sinh_FR_S_lo
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p7)  fma.s1  sinh_FR_Y_lo = sinh_FR_Tjhi_spos, sinh_FR_Y_lo_temp, sinh_FR_Tjlo_spos
      nop.i 999
}
;;

// Dummy multiply to generate inexact
{ .mfi
      nop.m 999
      fmpy.s0      sinh_FR_tmp = sinh_FR_all_ones, sinh_FR_all_ones
      nop.i 999
}
{ .mfi
      nop.m 999
(p6)  fma.s1       sinh_FR_Y_lo = sinh_FR_C_hi, sinh_FR_podd, sinh_FR_Y_lo_temp
      nop.i 999
}
;;

// f8 = answer = Y_hi + Y_lo
{ .mfi
      nop.m 999
(p7)  fma.s.s0   f8 = sinh_FR_Y_lo,  f1, sinh_FR_Tjhi_spos
      nop.i 999
}
;;

// f8 = answer = Y_hi + Y_lo
{ .mfb
      nop.m 999
(p6)  fma.s.s0  f8 = sinh_FR_Y_lo, f1, sinh_FR_S_hi
      br.ret.sptk     b0      // Exit for SINH_BY_TBL and SINH_BY_EXP
}
;;


// Here if x denorm or unorm
SINH_DENORM:
// Determine if x really a denorm and not a unorm
{ .mmf
      getf.exp  sinh_GR_signexp_x = sinh_FR_NORM_X
      mov  sinh_GR_exp_denorm = 0x0ff81   // Real denorms will have exp < this
      fmerge.s    sinh_FR_ABS_X = f0, sinh_FR_NORM_X
}
;;

{ .mfi
      nop.m 999
      fcmp.eq.s0  p10,p0 = f8, f0  // Set denorm flag
      nop.i 999
}
;;

// Set p8 if really a denorm
{ .mmi
      and  sinh_GR_exp_x = sinh_GR_exp_mask, sinh_GR_signexp_x ;;
      cmp.lt  p8,p9 = sinh_GR_exp_x, sinh_GR_exp_denorm
      nop.i 999
}
;;

// Identify denormal operands.
{ .mfb
      nop.m 999
(p8)  fcmp.ge.unc.s1  p6,p7 = f8, f0   // Test sign of denorm
(p9)  br.cond.sptk  SINH_COMMON    // Return to main path if x unorm
}
;;

{ .mfi
      nop.m 999
(p6)  fma.s.s0       f8 =  f8,f8,f8  // If x +denorm, result=x+x^2
      nop.i 999 
}
;;
{ .mfb
      nop.m 999
(p7)  fnma.s.s0      f8 =  f8,f8,f8  // If x -denorm, result=x-x^2
      br.ret.sptk    b0            // Exit if x denorm
}
;;



// Here if |x| >= overflow limit
SINH_HUGE: 
// for SINH_HUGE, put 24000 in exponent; take sign from input
{ .mmi
      mov                sinh_GR_exp_huge = 0x15dbf ;;
      setf.exp            sinh_FR_huge  = sinh_GR_exp_huge
      nop.i 999
}
;;

.pred.rel "mutex",p8,p9
{ .mfi
      nop.m 999
(p8)  fnma.s1  sinh_FR_signed_hi_lo = sinh_FR_huge, f1, f1
      nop.i 999
}
{ .mfi
      nop.m 999
(p9)  fma.s1   sinh_FR_signed_hi_lo = sinh_FR_huge, f1, f1
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s.s0  sinh_FR_pre_result = sinh_FR_signed_hi_lo, sinh_FR_huge, f0
      mov                 GR_Parameter_TAG = 128
}
;;

.endp sinhf

// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs

.proc __libm_error_region
__libm_error_region:
SINH_ERROR_SUPPORT:
.prologue

// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfs [GR_Parameter_Y] = f0,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfs [GR_Parameter_X] = f8                     // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y   // Parameter 3 address
        nop.b 0                            
}
{ .mib
        stfs [GR_Parameter_Y] = sinh_FR_pre_result     // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#          // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\sqrt.s ===
.file "sqrt.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
//********************************************************************
// History
//********************************************************************
// 2/02/00  Initial version
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
//********************************************************************
//
// Function:   Combined sqrt(x), where
//                        _
//             sqrt(x) = |x, for double precision x values
//
//********************************************************************
//
// Accuracy:       Correctly Rounded
//
//********************************************************************
//
// Resources Used:
//
//    Floating-Point Registers: f8  (Input and Return Value)
//                              f7 -f14
//
//    General Purpose Registers:
//      r32-r36 (Locals)
//      r37-r40 (Used to pass arguments to error handling routine)
//
//    Predicate Registers:      p6, p7, p8
//
//*********************************************************************
//
// IEEE Special Conditions:
//
//    All faults and exceptions should be raised correctly.
//    sqrt(QNaN) = QNaN
//    sqrt(SNaN) = QNaN
//    sqrt(+/-0) = +/-0
//    sqrt(negative) = QNaN and error handling is called
//
//*********************************************************************
//
// Implementation:
//
//  Modified Newton-Raphson Algorithm
//
//*********************************************************************

GR_SAVE_PFS          = r33
GR_SAVE_B0           = r34
GR_SAVE_GP           = r35

GR_Parameter_X       = r37
GR_Parameter_Y       = r38
GR_Parameter_RESULT  = r39


.section .text
.proc sqrt#
.global sqrt#
.align 64 

sqrt:
{ .mfi
  alloc r32= ar.pfs,0,5,4,0
  frsqrta.s0 f7,p6=f8
  nop.i 0
} { .mlx
  // BEGIN DOUBLE PRECISION MINIMUM LATENCY SQUARE ROOT ALGORITHM
  nop.m 0
  // exponent of +1/2 in r2
  movl r2 = 0x0fffe;;
} { .mmi
  // +1/2 in f9
  setf.exp f9 = r2
  nop.m 0
  nop.i 0
} { .mlx
  nop.m 0
  // 3/2 in r3
  movl r3=0x3fc00000;;
} { .mfi
  setf.s f10=r3
  // Step (1)
  // y0 = 1/sqrt(a) in f7
  fclass.m.unc p7,p8 = f8,0x3A 
  nop.i 0;;
} { .mlx
  nop.m 0
  // 5/2 in r2
  movl r2 = 0x40200000
} { .mlx
  nop.m 0
  // 63/8 in r3
  movl r3 = 0x40fc0000;;
} { .mfi
  setf.s f11=r2
  // Step (2)
  // h = +1/2 * y0 in f6
  (p6) fma.s1 f6=f9,f7,f0
  nop.i 0
} { .mfi
  setf.s f12=r3
  // Step (3)
  // g = a * y0 in f7
  (p6) fma.s1 f7=f8,f7,f0
  nop.i 0
} { .mfi
  nop.m 0
  mov   f15 = f8
  nop.i 0;;
} { .mlx
  nop.m 0
  // 231/16 in r2
  movl r2 = 0x41670000;;
} { .mfi
  setf.s f13=r2
  // Step (4)
  // e = 1/2 - g * h in f9
  (p6) fnma.s1 f9=f7,f6,f9
  nop.i 0
} { .mlx
  nop.m 0
  // 35/8 in r3
  movl r3 = 0x408c0000;;
} { .mfi
  setf.s f14=r3
  // Step (5)
  // S = 3/2 + 5/2 * e in f10
  (p6) fma.s1 f10=f11,f9,f10
  nop.i 0
} { .mfi
  nop.m 0
  // Step (6)
  // e2 = e * e in f11
  (p6) fma.s1 f11=f9,f9,f0
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (7)
  // t = 63/8 + 231/16 * e in f12
  (p6) fma.s1 f12=f13,f9,f12
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (8)
  // S1 = e + e2 * S in f10
  (p6) fma.s1 f10=f11,f10,f9
  nop.i 0
} { .mfi
  nop.m 0
  // Step (9)
  // e4 = e2 * e2 in f11
  (p6) fma.s1 f11=f11,f11,f0
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (10)
  // t1 = 35/8 + e * t in f9
  (p6) fma.s1 f9=f9,f12,f14
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (11)
  // G = g + S1 * g in f12
  (p6) fma.s1 f12=f10,f7,f7
  nop.i 0
} { .mfi
  nop.m 0
  // Step (12)
  // E = g * e4 in f7
  (p6) fma.s1 f7=f7,f11,f0
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (13)
  // u = S1 + e4 * t1 in f10
  (p6) fma.s1 f10=f11,f9,f10
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (14)
  // g1 = G + t1 * E in f7
  (p6) fma.d.s1 f7=f9,f7,f12
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (15)
  // h1 = h + u * h in f6
  (p6) fma.s1 f6=f10,f6,f6
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (16)
  // d = a - g1 * g1 in f9
  (p6) fnma.s1 f9=f7,f7,f8
  nop.i 0;;
} { .mfb
  nop.m 0
  // Step (17)
  // g2 = g1 + d * h1 in f7
  (p6) fma.d.s0 f8=f9,f6,f7
  (p6) br.ret.sptk b0 ;;
} 

{ .mfb
  nop.m 0
       mov   f8 = f7
  (p8) br.ret.sptk b0 ;;
}
{ .mfb
  (p7) mov   r40 = 49
  nop.f 0
  (p7) br.cond.sptk __libm_error_region ;;
}
// END DOUBLE PRECISION MINIMUM LATENCY SQUARE ROOT ALGORITHM
.endp sqrt#

// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs


.proc __libm_error_region
__libm_error_region:

//
// This branch includes all those special values that are not negative,
// with the result equal to frcpa(x)
// 

.prologue
// We are distinguishing between over(under)flow and letting
// __libm_error_support set ERANGE or do anything else needed.

// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfd [GR_Parameter_Y] = f0,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfd [GR_Parameter_X] = f15                    // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y   // Parameter 3 address
        nop.b 0                                
}
{ .mib
        stfd [GR_Parameter_Y] = f8                     // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#          // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region




.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\sqrtf.s ===
.file "sqrtf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
//*********************************************************************
// History:
//
// 2/02/00  Initial version
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
//*********************************************************************
//
// Function:   Combined sqrtf(x), where
//                         _
//             sqrtf(x) = |x, for single precision x values
//
//********************************************************************
//
// Accuracy:       Correctly Rounded 
//
//********************************************************************
//
// Resources Used:
//
//    Floating-Point Registers: f8  (Input and Return Value)
//                              f7 -f14
//
//    General Purpose Registers:
//      r32-r36 (Locals)
//      r37-r40 (Used to pass arguments to error handling routine)
//
//    Predicate Registers:      p6, p7, p8
//
//********************************************************************
//
// IEEE Special Conditions:
//
//    All faults and exceptions should be raised correctly.
//    sqrtf(QNaN) = QNaN
//    sqrtf(SNaN) = QNaN
//    sqrtf(+/-0) = +/-0 
//    sqrtf(negative) = QNaN and error handling is called
//
//********************************************************************
//
// Implementation:
//
//  Modified Newton-Raphson Algorithm
//
//********************************************************************


GR_SAVE_B0                    = r34
GR_SAVE_PFS                   = r33
GR_SAVE_GP                    = r35 

GR_Parameter_X                = r37
GR_Parameter_Y                = r38
GR_Parameter_RESULT           = r39
GR_Parameter_TAG              = r40

FR_X             = f13
FR_Y             = f0
FR_RESULT        = f8



.section .text
.proc sqrtf#
.global sqrtf#
.align 64 

sqrtf: 
{ .mlx
  // BEGIN SINGLE PRECISION MINIMUM LATENCY SQUARE ROOT ALGORITHM
  alloc r32= ar.pfs,0,5,4,0
  // exponent of +1/2 in r2
  movl r2 = 0x0fffe
} { .mfi
  // +1/2 in f12
  nop.m 0
  frsqrta.s0 f7,p6=f8
  nop.i 0;;
} { .mfi
  setf.exp f12 = r2
  // Step (1)
  // y0 = 1/sqrt(a) in f7
  fclass.m.unc p7,p8 = f8,0x3A 
  nop.i 0
} { .mfi
  nop.m 0
  // Make a copy of x just in case 
  mov f13 = f8 
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (2)
  // H0 = 1/2 * y0 in f9
  (p6) fma.s1 f9=f12,f7,f0
  nop.i 0
} { .mfi
  nop.m 0
  // Step (3)
  // S0 = a * y0 in f7
  (p6) fma.s1 f7=f8,f7,f0
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (4)
  // d = 1/2 - S0 * H0 in f10
  (p6) fnma.s1 f10=f7,f9,f12
  nop.i 0
} { .mfi
  nop.m 0
  // Step (0'')
  // 3/2 = 1 + 1/2 in f12
  (p6) fma.s1 f12=f12,f1,f1
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (5)
  // e = 1 + 3/2 * d in f12
  (p6) fma.s1 f12=f12,f10,f1
  nop.i 0
} { .mfi
  nop.m 0
  // Step (6)
  // T0 = d * S0 in f11
  (p6) fma.s1 f11=f10,f7,f0
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (7)
  // G0 = d * H0 in f10
  (p6) fma.s1 f10=f10,f9,f0
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (8)
  // S1 = S0 + e * T0 in f7
  (p6) fma.s.s1 f7=f12,f11,f7
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (9)
  // H1 = H0 + e * G0 in f12
  (p6) fma.s1 f12=f12,f10,f9
  nop.i 0;;
} { .mfi
  nop.m 0
  // Step (10)
  // d1 = a - S1 * S1 in f9
  (p6) fnma.s1 f9=f7,f7,f8
  nop.i 0;;;
} { .mfb
  nop.m 0
  // Step (11)
  // S = S1 + d1 * H1 in f7
  (p6) fma.s.s0 f8=f9,f12,f7
  (p6) br.ret.sptk   b0 ;;
// END SINGLE PRECISION MINIMUM LATENCY SQUARE ROOT ALGORITHM
} { .mfb
  nop.m 0
       mov   f8 = f7
  (p8) br.ret.sptk b0 ;;
}
//
// This branch includes all those special values that are not negative,
// with the result equal to frcpa(x)
//
.endp sqrtf


.proc __libm_error_region
__libm_error_region:
.prologue
{ .mii
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        mov   GR_Parameter_TAG = 50                   
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = FR_Y,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;
.body
{ .mib
        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\tanhf.s ===
.file "tanhf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 5/30/01  Initial version
//
// API
//==============================================================
// float tanhf(float)
//
// Overview of operation
//==============================================================
// Background
//
//
// There are 9 paths:
// 1. x = +/-0.0
//    Return tanhf(x) = +/-0.0
//
// 2. 0.0 < |x| < 0.3125
//    Return tanhf(x) = x + x^3*Pol3(x^2),
//    where Pol3(x^2) = C3*x^6 + C2*x^4 + C1*x^2 + C0
//
// 3. 0.3125 <= |x| < 8.0
//    Return tanhf(x) = sign(x)*PolD(x)*PolC(|x|) + sign(x)*PolA(|x|),
//    where sign(x)*PolD(x) = sign(x)*(|x|^7 + D2*x^6 + D1*|x|^5 + D0*x^4),
//          PolC(|x|) = B0*x^4 + C3*|x|^3 + C2*|x|^2 + C1*|x| + C0,
//          PolA(|x|) = A3|x|^3 + A2*x^2 + A1*|x| + A0
//
//    Actually range 0.3125<=|x|< 8.0 is split to 5 subranges.
//    For each subrange there is particular set of coefficients.
//    Below is the list of subranges:
//    3.1 0.3125 <= |x| < 0.5
//    3.2 0.5 <= |x| < 1.0
//    3.3 1.0 <= |x| < 2.0
//    3.4 2.0 <= |x| < 4.0
//    3.5 4.0 <= |x| < 8.0
//
// 4. 8.0 <= |x| < 9.125
//    Return tanhf(x) = sign(x)*(A3|x|^3 + A2*x^2 + A1*|x| + A0)
//
// 5. 9.125 <= |x| < +INF
//    Return tanhf(x) = sign(x)*(1.0d - 2^(-52))
//
// 6. |x| = INF
//    Return tanhf(x) = sign(x) * 1.0
//
// 7. x = [S,Q]NaN 
//    Return tanhf(x) = QNaN
//
// 8. x is positive denormal
//    Return tanhf(x) = x - x^2
//
// 9. x is negative denormal
//    Return tanhf(x) = x + x^2
//
// Registers used
//==============================================================
// Floating Point registers used: 
// f8, input
// f32 -> f59

// General registers used:  
// r32 -> r46, r2, r3

// Predicate registers used:
// p0, p6 -> p15

// p6           to filter out case when x = [Q,S]NaN or +/-0
// p7           to filter out case when x = denormal
// p8           set if |x| >= 0.3125, used also to process denormal input
// p9           to filter out case when |x| = inf
// p10          to filter out case when |x| < 0.3125
// p11          to filter out case when 0.3125 <= |x| < 9.125
// p12          to filter out case when |x| >= 9.125
// p13          to filter out case when 8.0 <= |x| < 9.125
// p14          set to 1 for positive x
// p15          set to 1 for negative x

// Assembly macros
//==============================================================
rDataPtr           = r2
rDataPtr1          = r3

rBias              = r33
rCoeffAddr3        = r34
rNearSaturation    = r35
rCoeffAddr1        = r36
rCoeffAddr2        = r37
rOffset2           = r38
rBias2             = r39
rMask              = r40
rArg               = r41
rBound             = r42
rSignBit           = r43
rAbsArg            = r44
rDataPtr2          = r45
rSaturation        = r46

//==============================================================
fA0                = f32
fA1                = f33
fA2                = f34
fA3                = f35
fC0                = f36
fC1                = f37
fC2                = f38
fC3                = f39
fD0                = f40
fD1                = f41
fD2                = f42
fB0                = f43
fArgSqr            = f44
fAbsArg            = f45
fSignumX           = f46
fArg4              = f47
fArg4Sgn           = f48
fArg3              = f49
fArg3Sgn           = f50
fArg7Sgn           = f51
fArg6Sgn           = f52
fPolC              = f53
fPolCTmp           = f54
fPolA              = f55
fPolATmp           = f56
fPolD              = f57
fPolDTmp           = f58
fArgSqrSgn         = f59

// Data tables
//==============================================================

.data

.align 16

tanhf_data:
// Polynomial coefficients for the tanh(x), 0.3125 <= |x| < 0.5
data8 0x3F9BEEDFDD177D7B // C0
data8 0x3F970D10C7F32458 // C1
data8 0x3F766D6B051F3A38 // C2
data8 0xBF732F2001B23402 // C3
data8 0xBF854BE1CE1ED499 // D0
data8 0x4013C944F3999A16 // D1
data8 0xC01106C6975222C0 // D2
data8 0x3F783D5ACCF9EBE8 // B0
// Polynomial coefficients for the tanh(x), 0.5 <= |x| < 1.0
data8 0xBF5D631440786869 // C0
data8 0xBF575D79A0D52069 // C1
data8 0xBF7E2237B7EFC705 // C2
data8 0x3F6A7ACBC273041F // C3
data8 0xC040E32EA52D91EB // D0
data8 0x403D19463E5DB4D7 // D1
data8 0xC02216F61F759F39 // D2
data8 0xBF55B4EA0B844BE7 // B0
// Polynomial coefficients for the tanh(x), 1.0 <= |x| < 2.0
data8 0x3F8637DBE5B3E690 // C0
data8 0xBF7F7FEC158C07F5 // C1
data8 0x3F711C586706838A // C2
data8 0xBF50EF7EF605554E // C3
data8 0xC054D45448354E25 // D0
data8 0x404ADFEEA282E730 // D1
data8 0xC028AEE456D59549 // D2
data8 0x3F25232D1BED59A8 // B0
// Polynomial coefficients for the tanh(x), 2.0 <= |x| < 4.0
data8 0xBF52602285F2D06C // C0
data8 0x3F2E57C298FFE1E0 // C1
data8 0xBF15ED575DB3C811 // C2
data8 0x3EE428878A08525C // C3
data8 0xC0895A26849039C1 // D0
data8 0x406E3C60BBFBB575 // D1
data8 0xC03A06F62867C75A // D2
data8 0xBEB114C70F1C723E // B0
// Polynomial coefficients for the tanh(x), 4.0 <= |x| < 8.0
data8 0x3EF4B22BD17039A3 // C0
data8 0xBEB704ADC040C57F // C1
data8 0x3E937A98288AFE1A // C2
data8 0xBE4F33B2C9FFE7E7 // C3
data8 0xC0BE48CFADE2431E // D0
data8 0x4090E74249760FDD // D1
data8 0xC04B6F537FCF2F1E // D2
data8 0x3E0DCD879C91ADEA // B0
// Polynomial coefficients for the tanh(x), -0.3125 < x < 0.3125 
data8 0xBFD555551E8245B7 // A0
data8 0x3FC110E63F52E689 // A1
data8 0xBFAB8CD6A5B7BAFA // A2
data8 0x3F945D467FCEB553 // A3

// Polynomial coefficients for the tanh(x), 0.3125 <= |x| < 0.5
data8 0xBE3DCC92FCAECBB6 // A0
data8 0x3FF0000043B7D267 // A1
data8 0xBED18BF28ACFC4B1 // A2
data8 0xBFD554A56F82837E // A3
// Polynomial coefficients for the tanh(x), 0.5 <= |x| < 1.0
data8 0x3EFD6054758539F9 // A0
data8 0x3FEFFBFC77198EBE // A1
data8 0x3F700327CA98D237 // A2
data8 0xBFD68955F5BB2FA1 // A3
// Polynomial coefficients for the tanh(x), 1.0 <= |x| < 2.0
data8 0xBF71A53F229DF01B // A0
data8 0x3FF0AECFD730DE50 // A1
data8 0xBFC882F88E5DF3BA // A2
data8 0x3FC6EDF212CA2A8D // A3
// Polynomial coefficients for the tanh(x), 2.0 <= |x| < 4.0
data8 0xBFAF0B712E9EDA47 // A0
data8 0x3FF1C208080BEA64 // A1
data8 0x3FC3D29B20C8946E // A2
data8 0xBFF04514ED900A6A // A3
// Polynomial coefficients for the tanh(x), 4.0 <= |x| < 8.0
data8 0xBFB1DEA49A831CBC // A0
data8 0x3FFA729FC7085674 // A1
data8 0xBFF2F44D923A8FA4 // A2
data8 0x3FE092FC5712227E // A3
// Polynomial coefficients for the tanh(x), 8.0 <= |x| <= 9.125 
data8 0x3FEFFF5769EE3041 // A0
data8 0x3EFBBF148D850891 // A1
data8 0xBEC86BCEF0F5C2FE // A2
data8 0x3E7CBA4F3A885A5C // A3

data8 0x3FEFFFFFFFFFFFFF // 1.0 - epsilon
   
.align 64
.global tanhf#


.section .text
.proc  tanhf#
.align 64
tanhf: 


{ .mfi
      alloc          r32 = ar.pfs, 1, 14, 0, 0
      fmerge.s       fAbsArg = f1, f8             // |x|
      addl           rMask = 0x806, r0
}
{ .mfi
      addl           rDataPtr = @ltoff(tanhf_data), gp
      fma.s1         fArgSqr = f8, f8, f0         // x^2
      adds           rSignBit = 0x1, r0
}
;;

{ .mfi
      getf.s         rArg = f8                    // x in GR 
      fclass.m       p7,p0 = f8, 0x0b             // is x denormal ?
      // sign bit and 2 most bits in significand
      shl            rMask = rMask, 20               
}
{ .mfi
      ld8            rDataPtr = [rDataPtr]
      nop.f          0
      adds           rBias2 = 0x1F4, r0
}
;;

{ .mfi
      adds           rNearSaturation = 0x14, r0
      fmerge.s       fSignumX = f8, f1            // signum(x)
      shl            rSignBit = rSignBit, 31      // mask for sign bit
}
{ .mfi
      adds           rBound = 0x3EA, r0
      nop.f          0
      addl           rSaturation = 0x4112, r0
}
;;

{ .mfi
      andcm          rOffset2 = rArg, rMask
      fclass.m       p6,p0 = f8, 0xc7             // is x [S,Q]NaN or +/-0 ?
      shl            rBound = rBound, 20          // 1.0f in GR
}
{ .mfb
      andcm          rAbsArg = rArg, rSignBit     // |x| in GR
      nop.f          0
(p7)  br.cond.spnt   tanhf_denormal               // branch out if x is denormal
}
;;

{ .mfi
      adds           rCoeffAddr2 = 352, rDataPtr
      fclass.m       p9,p0 = f8, 0x23            // is x +/- inf?
      shr            rOffset2 = rOffset2, 21
}
{ .mfi
      cmp.lt         p10, p8 = rAbsArg, rBound   // |x| < 0.3125? 
      nop.f          0
      adds           rCoeffAddr3 = 16, rDataPtr
}
;;

{ .mfi
(p8)  sub            rBias = rOffset2, rBias2
      fma.s1         fArg4 = fArgSqr, fArgSqr, f0 // x^4
      shl            rSaturation = rSaturation, 16
}
{ .mfb
(p10) adds           rBias = 0x14, r0
(p6)  fma.s.s0       f8 = f8,f1,f8                // NaN or +/-0
(p6)  br.ret.spnt    b0                           // exit for x = NaN or +/-0
}
;;

{ .mfi
      shladd         rCoeffAddr1 = rBias, 4, rDataPtr
      fma.s1         fArg3Sgn = fArgSqr, f8, f0  // sign(x)*|x|^3
      // is |x| < 9.125? 
      cmp.lt         p11, p12 = rAbsArg, rSaturation  
}
{ .mfi
      shladd         rCoeffAddr3 = rBias, 4, rCoeffAddr3
      fma.s1         fArg3 = fArgSqr, fAbsArg, f0 // |x|^3
      shladd         rCoeffAddr2 = rBias, 3, rCoeffAddr2
}
;;

{ .mfi
(p11) ldfpd          fC0, fC1 = [rCoeffAddr1]
(p9)  fmerge.s       f8 = f8,f1                   // +/- inf
(p12) adds           rDataPtr = 544, rDataPtr 
}
{ .mfb
(p11) ldfpd          fC2, fC3 = [rCoeffAddr3], 16
      nop.f          0
(p9)  br.ret.spnt    b0                           // exit for x = +/- inf
}
;;

{ .mfi
(p11) ldfpd          fA0, fA1 = [rCoeffAddr2], 16
      nop.f          0
(p8)  cmp.eq.unc     p13, p0 = rBias, rNearSaturation
}
{ .mfi
      add            rCoeffAddr1 = 48, rCoeffAddr1
      nop.f          0
      nop.i          0
}
;;

{ .mfi
(p11) ldfpd          fD0, fD1 = [rCoeffAddr3]
      nop.f          0
      nop.i          0
}
{ .mfb
(p11) ldfpd          fD2, fB0 = [rCoeffAddr1]
      // sign(x)*|x|^2
      fma.s1         fArgSqrSgn = fArgSqr, fSignumX, f0
(p10) br.cond.spnt   tanhf_near_zero
}
;;

{ .mfi
(p11) ldfpd          fA2, fA3 = [rCoeffAddr2], 16
      fcmp.lt.s1     p15, p14 = f8,f0
      nop.i          0
}
{ .mfb
(p12) ldfd           fA0 = [rDataPtr]
      fma.s1         fArg4Sgn = fArg4, fSignumX, f0 // sign(x)*|x|^4
(p12) br.cond.spnt   tanhf_saturation
}
;;
{ .mfi
      nop.m          0
      fma.s1         fArg7Sgn = fArg4, fArg3Sgn, f0  // sign(x)*|x|^7
      nop.i          0
}
{ .mfb
      nop.m          0
      fma.s1         fArg6Sgn = fArg3, fArg3Sgn, f0  // sign(x)*|x|^6
(p13) br.cond.spnt   tanhf_close_to_saturation      
}
;;

{ .mfi
      nop.m          0
      fma.s1         fPolC = fC3, fAbsArg, fC2    // C3*|x| + C2
      nop.i          0
}
{ .mfi
      nop.m          0
      fma.s1         fPolCTmp = fC1, fAbsArg, fC0 // C1*|x| + C0
      nop.i          0
};;

{ .mfi
      nop.m          0
      fma.s1         fPolA = fA1, fAbsArg, fA0    // A1*|x| + A0
      nop.i          0
}
;;

{ .mfi
      nop.m          0
      fma.s1         fPolD = fD1, fAbsArg, fD0    // D1*|x| + D0
      nop.i          0
}
{ .mfi
      nop.m          0
      // sign(x)*(|x|^7 + D2*x^6)
      fma.s1         fPolDTmp = fArg6Sgn, fD2, fArg7Sgn
      nop.i          0
};;

{ .mfi
      nop.m          0
      fma.s1         fPolATmp = fA3, fAbsArg, fA2  // A3*|x| + A2 
      nop.i          0
}
{ .mfi
      nop.m          0
      fma.s1         fB0 = fB0, fArg4, f0          // B0*x^4
      nop.i          0
};;

{ .mfi
      nop.m          0
      // C3*|x|^3 + C2*x^2 + C1*|x| + C0
      fma.s1         fPolC = fPolC, fArgSqr, fPolCTmp  
      nop.i          0
}
;;

{ .mfi
      nop.m          0
      // PolD = sign(x)*(|x|^7 + D2*x^6 + D1*|x|^5 + D0*x^4)
      fma.d.s1       fPolD = fPolD, fArg4Sgn, fPolDTmp  
      nop.i          0
}
;;

{ .mfi
      nop.m          0
      // PolA = A3|x|^3 + A2*x^2 + A1*|x| + A0 
      fma.d.s1       fPolA = fPolATmp, fArgSqr, fPolA 
      nop.i          0
}
;;                 

{ .mfi
      nop.m          0
      // PolC = B0*x^4 + C3*|x|^3 + C2*|x|^2 + C1*|x| + C0 
      fma.d.s1       fPolC = fPolC, f1, fB0 
      nop.i          0
}
;;     

{ .mfi
      nop.m          0
(p14) fma.s.s0       f8 = fPolC, fPolD, fPolA     // for positive x
      nop.i          0                           
}
{ .mfb
      nop.m          0
(p15) fms.s.s0       f8 = fPolC, fPolD, fPolA     // for negative x
      br.ret.sptk    b0                           // Exit for 0.3125 <=|x|< 8.0
};;


// Here if |x| < 0.3125
tanhf_near_zero:
{ .mfi
      nop.m          0
      fma.s1         fPolC = fC3, fArgSqr, fC2    // C3*x^2 + C2
      nop.i          0
}
{ .mfi
      nop.m          0
      fma.s1         fPolCTmp = fC1, fArgSqr, fC0  // C1*x^2 + C0
      nop.i          0
};;

{ .mfi
      nop.m          0
      fma.s1         fPolC = fPolC, fArg4, fPolCTmp // C3*x^6 + C2*x^4 + C1*x^2 + C0
      nop.i          0
};;

{ .mfb
      nop.m          0
      // x + x^3*(C3*x^6 + C2*x^4 + C1*x^2 + C0)
      fma.s.s0       f8 = fPolC, fArg3Sgn, f8
      br.ret.sptk    b0                           // Exit for |x| < 0.3125
};;

// Here if 9.125 <= |x| < +inf
tanhf_saturation:
{ .mfb
      nop.m          0
      fma.s.s0       f8 = fA0, fSignumX, f0       // sign(x)*(1.0d - 2^(-52))
      // Exit for 9.125 <= |x| < +inf
      br.ret.sptk    b0                           // Exit for 9.125 <=|x|< +inf
}
;;
      
// Here if  8.0 <= |x| < 9.125
tanhf_close_to_saturation:
{ .mfi
      nop.m          0
      fma.s1         fPolATmp = fA1, fAbsArg, fA0 // A1*|x| + A0
      nop.i          0
}
{ .mfi
      nop.m          0
      fma.s1         fPolA = fA3, fAbsArg, fA2    // A3*|x| + A2
      nop.i          0
}    
;;

.pred.rel "mutex", p14, p15
{ .mfi
      nop.m          0
      // for positive x
(p14) fma.s.s0       f8 = fPolA, fArgSqr, fPolATmp
      nop.i          0                           
}
{ .mfb
      nop.m          0
      // for negative x
(p15) fms.s.s0       f8 = fPolA, fArgSqrSgn, fPolATmp
      br.ret.sptk    b0                           // Exit for 8.0 <=|x|< 9.125
};;

// Here if x is single precision denormal
tanhf_denormal:
{ .mfi
      nop.m          0
      fclass.m       p7,p8 = f8, 0x0a             // is x -denormal ?
      nop.i          0
}
;;

{ .mfi
      nop.m          0
(p7)  fma.s.s0       f8 = f8,f8,f8                // -denormal
      nop.i          0
}
{ .mfb
      nop.m          0
(p8)  fnma.s.s0      f8 = f8,f8,f8                // +denormal
      br.ret.sptk    b0                           // Exit for denormal
}
;;

.endp tanhf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\tanh.s ===
.file "tanh.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 05/30/01  Initial version

//
// API
//==============================================================
// double tanh(double)
//
// Overview of operation
//==============================================================

//

// There are 8 paths:
// 1. x = +/-0.0
//    Return tanh(x) = +/-0.0
// 
// 2. MAX_DENORMAL_ABS < |x| < 1/16
//    Return tanh(x) = P13(x), where
//    P13(x) = (((C13*x^2 + C11)*x^4 + (C9*x^2 + C7))*x^4 +
//            (C5*x^2 + C3))*x^3 + x
//            
// 3. 1/16 <= |x| < 32
//    Return tanh(x) = sign(x)*(1 - 2 / (1 + exp(2*|x|))
//    Algorithm description for exp function see below
// 
// 4. 32 <= |x| < +INF
//    Return tanh(x) = sign(x)*(1.0 - 2^(63))
//                    
// 5. x = +/-INF
//    Return tanh(x) = sign(x)
//                                                        
// 6. x = [S,Q]NaN
//   Return tanh(x) = QNaN
//

// 7. x is positive denormal
//    Return tanhf(x) = x - x^2
//

// 8. x is negative denormal
//    Return tanhf(x) = x + x^2
// 

//==============================================================

// Algorithm Description for exp(x) function

//

// Take the input x. w is "how many log2/128 in x?"
//  w = x * 128/log2
//  n = int(w)
//  x = n log2/128 + r + delta

//  n = 128M + index_1 + 2^4 index_2
//  x = M log2 + (log2/128) index_1 + (log2/8) index_2 + r + delta

//  exp(x) = 2^M  2^(index_1/128)  2^(index_2/8) exp(r) exp(delta)
//       Construct 2^M
//       Get 2^(index_1/128) from table_1;
//       Get 2^(index_2/8)   from table_2;
//       Calculate exp(r) by series
//          r = x - n (log2/128)_high
//          delta = - n (log2/128)_low
//       Calculate exp(delta) as 1 + delta

// Registers used
//==============================================================
// Floating Point registers used:
// f8, input
// f32 -> f75

// General registers used:
// r32 -> r57

// Predicate registers used:
// p6 -> p15

// Assembly macros
//==============================================================
exp_GR_rshf                   = r33
EXP_AD_TB1                    = r34
EXP_AD_TB2                    = r35
EXP_AD_P                      = r36
exp_GR_N                      = r37
exp_GR_index_1                = r38
exp_GR_index_2_16             = r39
exp_GR_biased_M               = r40
exp_GR_index_1_16             = r41
EXP_AD_T1                     = r42
EXP_AD_T2                     = r43
exp_GR_sig_inv_ln2            = r44
exp_GR_17ones                 = r45
exp_GR_rshf_2to56             = r46
exp_GR_exp_2tom56             = r47
exp_Expb                      = r48
exp_ExpbOf2to4                = r49
exp_NearZeroBound             = r50
TANH_NZ_CF                    = r51
ALMOST_ONE                    = r52
DATA_PTR                      = r53
reg_RcMask                    = r54
reg_ArFsr                     = r55
reg_RcDown                    = r56
reg_RcUp                      = r57


//==============================================================
EXP_RSHF_2TO56                = f33
EXP_INV_LN2_2TO63             = f34
EXP_W_2TO56_RSH               = f35
EXP_2TOM56                    = f36
exp_P4                        = f37 
exp_P3                        = f38 
exp_P2                        = f39 
exp_P1                        = f40 
exp_ln2_by_128_hi             = f41
exp_ln2_by_128_lo             = f42
EXP_RSHF                      = f43
EXP_Nfloat                    = f44
exp_r                         = f45
exp_f                         = f46
exp_rsq                       = f47
exp_rcube                     = f48
EXP_2M                        = f49
exp_S1                        = f50
exp_T1                        = f51
exp_rP4pP3                    = f52
exp_P_lo                      = f53
exp_P_hi                      = f54
exp_P                         = f55
exp_S                         = f56
exp_ExppOne                   = f57
EXP_NORM_f8                   = f58   
exp_S2                        = f59
exp_T2                        = f60
tanh_rcp0                     = f61
tanh_rcp1                     = f62
tanh_rcp2                     = f63
tanh_rcp3                     = f64
tanh_Two                      = f65
tanh_C13                      = f66
tanh_C11                      = f67
tanh_C9                       = f68
tanh_C7                       = f69
tanh_C5                       = f70
tanh_C3                       = f71
tanh_X4                       = f72
tanh_X3                       = f73
tanh_X2                       = f74
tanh_AlmostOne                = f75


// Data tables
//==============================================================

.data

.align 16

// ************* DO NOT CHANGE ORDER OF THESE TABLES ********************

// double-extended 1/ln(2)
// 3fff b8aa 3b29 5c17 f0bb be87fed0691d3e88
// 3fff b8aa 3b29 5c17 f0bc 
// For speed the significand will be loaded directly with a movl and setf.sig
//   and the exponent will be bias+63 instead of bias+0.  Thus subsequent
//   computations need to scale appropriately.
// The constant 128/ln(2) is needed for the computation of w.  This is also 
//   obtained by scaling the computations.
//
// Two shifting constants are loaded directly with movl and setf.d. 
//   1. EXP_RSHF_2TO56 = 1.1000..00 * 2^(63-7) 
//        This constant is added to x*1/ln2 to shift the integer part of
//        x*128/ln2 into the rightmost bits of the significand.
//        The result of this fma is EXP_W_2TO56_RSH.
//   2. EXP_RSHF       = 1.1000..00 * 2^(63) 
//        This constant is subtracted from EXP_W_2TO56_RSH * 2^(-56) to give
//        the integer part of w, n, as a floating-point number.
//        The result of this fms is EXP_Nfloat.
tanh_data:
data8 0xeb69e870abeefdb0,  0x00003ff6 // C13
data8 0x91371aaf3611e47b,  0x0000bff8 // C11
data8 0xb327a4416087cf99,  0x00003ff9 // C9
data8 0xb17217f7d1cf79ab , 0x00003ff7 // ln2/128 hi
data8 0xffffffffffffffff,  0x00003ffe // almost one
data8 0xc9e3b39803f2f6af , 0x00003fb7 // ln2/128 lo 
data8 0xdd0dd0dd0dd0dd0e,  0x0000bffa // C7
data8 0x8888888888888889,  0x00003ffc // C5
data8 0xaaaaaaaaaaaaaaab,  0x0000bffd // C3
data8 0x8000000000000001,  0x00004000 // almost two

// Table 1 is 2^(index_1/128) where
// index_1 goes from 0 to 15
data8 0x8000000000000000 , 0x00003FFF
data8 0x80B1ED4FD999AB6C , 0x00003FFF
data8 0x8164D1F3BC030773 , 0x00003FFF
data8 0x8218AF4373FC25EC , 0x00003FFF
data8 0x82CD8698AC2BA1D7 , 0x00003FFF
data8 0x8383594EEFB6EE37 , 0x00003FFF
data8 0x843A28C3ACDE4046 , 0x00003FFF
data8 0x84F1F656379C1A29 , 0x00003FFF
data8 0x85AAC367CC487B15 , 0x00003FFF
data8 0x8664915B923FBA04 , 0x00003FFF
data8 0x871F61969E8D1010 , 0x00003FFF
data8 0x87DB357FF698D792 , 0x00003FFF
data8 0x88980E8092DA8527 , 0x00003FFF
data8 0x8955EE03618E5FDD , 0x00003FFF
data8 0x8A14D575496EFD9A , 0x00003FFF
data8 0x8AD4C6452C728924 , 0x00003FFF

// Table 2 is 2^(index_1/8) where
// index_2 goes from 0 to 7
data8 0x8000000000000000 , 0x00003FFF
data8 0x8B95C1E3EA8BD6E7 , 0x00003FFF
data8 0x9837F0518DB8A96F , 0x00003FFF
data8 0xA5FED6A9B15138EA , 0x00003FFF
data8 0xB504F333F9DE6484 , 0x00003FFF
data8 0xC5672A115506DADD , 0x00003FFF
data8 0xD744FCCAD69D6AF4 , 0x00003FFF
data8 0xEAC0C6E7DD24392F , 0x00003FFF

data8 0x3f8111116da21757 //P_4
data8 0x3fa55555d787761c //P_3
data8 0x3fc5555555555414 //P_2
data8 0x3fdffffffffffd6a //P_1


.align 32
.global tanh#

.section .text
.proc  tanh#
.align 32
tanh: 

{ .mlx
      alloc       r32=ar.pfs,1,25,0,0
      // significand of 1/ln2     
      movl        exp_GR_sig_inv_ln2 = 0xb8aa3b295c17f0bc
}
{ .mlx
      addl        DATA_PTR = @ltoff(tanh_data), gp        
      movl        exp_GR_rshf_2to56 = 0x4768000000000000 // 1.1 * 2^(63+56)
};;

// We do this fnorm right at the beginning to take any enabled
// faults and to normalize any input unnormals so that SWA is not taken.
{ .mfi
      ld8         EXP_AD_TB1 = [DATA_PTR]
      fclass.m    p6,p0 = f8, 0xC7 // is arg NaN or +/-0 ? 
      mov         exp_GR_17ones = 0x1FFFF                          
}
{ .mfi
      ld8         ALMOST_ONE = [DATA_PTR]
      fma.s1      EXP_NORM_f8 = f8, f1, f8 // 2*x
      mov         exp_GR_exp_2tom56 = 0xFFFF-56
};;

// Form two constants we need
//  1/ln2 * 2^63  to compute  w = x * 1/ln2 * 128 
//  1.1000..000 * 2^(63+63-7) to right shift int(w) into the significand
{ .mmf
      // form 1/ln2 * 2^63
      setf.sig    EXP_INV_LN2_2TO63 = exp_GR_sig_inv_ln2
      // form const 1.1 * 2^(63+56)
      setf.d      EXP_RSHF_2TO56 = exp_GR_rshf_2to56
      fclass.m    p7,p0 = f8, 0x0A // is arg -denormal ?
};;
{ .mlx
      // form 2^-56 for scaling Nfloat
      setf.exp    EXP_2TOM56 = exp_GR_exp_2tom56
      // 1.10000 2^63 for right shift
      movl        exp_GR_rshf = 0x43e8000000000000
}
{ .mfb
      nop.m       0
(p6)  fma.d.s0    f8 =  f8, f1, f8 // NaN or +/-0
(p6)  br.ret.spnt b0
};;                
{ .mfi
      getf.exp    exp_Expb = f8
      fclass.m    p8,p0 = f8, 0x09 // is arg +denormal ?
      adds        ALMOST_ONE = 0x40, ALMOST_ONE
}
{ .mfb
      ldfe        tanh_C13 = [EXP_AD_TB1], 16
(p7)  fma.d.s0    f8 =  f8, f8, f8 // -denormal
(p7)  br.ret.spnt b0
};;
{ .mfi
      // Form right shift const 1.100 * 2^63
      setf.d      EXP_RSHF = exp_GR_rshf
      fma.s1      tanh_X2 = f8, f8, f0
      mov         exp_ExpbOf2to4 = 0x10003 // biased exp of 16
}
{ .mfi
      ldfe        tanh_C11 = [EXP_AD_TB1], 16
      nop.f       0
      mov         exp_NearZeroBound = 0xFFFB
};;
{ .mfi
      ldfe        tanh_C9 = [EXP_AD_TB1], 16
      fcmp.lt     p10, p11 = f8, f0 // is x < 0 ?
      and         exp_Expb = exp_Expb, exp_GR_17ones
};;                                           
{ .mfi
      ldfe        exp_ln2_by_128_hi  = [EXP_AD_TB1], 32
      fma.s1      tanh_Two = f1, f1, f1
      cmp.gtu     p13, p0 = exp_Expb, exp_ExpbOf2to4
}
{ .mfi
      ldfe        tanh_AlmostOne = [ALMOST_ONE], 80
      nop.f       0
      cmp.eq      p9, p0 = exp_Expb, exp_GR_17ones
};;
{ .mfi
      ldfe        exp_ln2_by_128_lo  = [EXP_AD_TB1], 16
(p8)  fnma.d.s0   f8 =  f8, f8, f8 // +denormal
      mov         reg_RcDown = 0x400
}                      
{ .mfb
      cmp.ltu     p12, p0 = exp_Expb, exp_NearZeroBound
      nop.f       0  
(p8)  br.ret.spnt b0
};;                           
{ .mfi
      mov         reg_ArFsr = ar.fpsr
(p9)  fmerge.s    f8 = f8,f1 // +/- inf
      adds        TANH_NZ_CF = -32, ALMOST_ONE
}
{ .mfb
      ldfe        tanh_C7  = [EXP_AD_TB1], 16
	  nop.f       0
(p9)  br.ret.spnt b0
};;
{ .mfi
      nop.m       0
      fma.s1      tanh_X4 = tanh_X2, tanh_X2, f0
      nop.i       0
}
{ .mfi
      nop.m       0
      fma.s1      tanh_X3 = tanh_X2, f8, f0
      nop.i       0
}
;;

// After that last load, EXP_AD_TB1 points to the beginning of table 1
// W = X * Inv_log2_by_128
// By adding 1.10...0*2^63 we shift and get round_int(W) in significand.
// We actually add 1.10...0*2^56 to X * Inv_log2 to do the same thing.
.pred.rel "mutex",p11,p10
{ .mfi
      adds        EXP_AD_TB1 = 0x30, EXP_AD_TB1
(p11) fma.s1      EXP_W_2TO56_RSH  = EXP_NORM_f8, EXP_INV_LN2_2TO63, EXP_RSHF_2TO56
      mov         reg_RcMask = 0xC00
}
{ .mfi
      ldfe        tanh_C5 = [TANH_NZ_CF], 16
(p10) fnma.s1     EXP_W_2TO56_RSH  = EXP_NORM_f8, EXP_INV_LN2_2TO63, EXP_RSHF_2TO56
      nop.i       0 
};;
{ .mfi
      ldfe        tanh_C3 = [TANH_NZ_CF], 16
(p10) fnma.s1     EXP_NORM_f8 = EXP_NORM_f8, f1, f0
      adds        EXP_AD_TB2 = 0x100, EXP_AD_TB1
}
{ .mfb
      adds        EXP_AD_P = 0x180, EXP_AD_TB1
      nop.f       0 
(p12) br.cond.spnt tanh_near_zero
};;
{ .mfi
      ldfpd       exp_P4, exp_P3  = [EXP_AD_P] ,16
      nop.f       0
      mov         reg_RcUp = 0x800
};;

// Nfloat = round_int(W) 
// The signficand of EXP_W_2TO56_RSH contains the rounded integer part of W,
// as a twos complement number in the lower bits (that is, it may be negative).
// That twos complement number (called N) is put into exp_GR_N.

// Since EXP_W_2TO56_RSH is scaled by 2^56, it must be multiplied by 2^-56
// before the shift constant 1.10000 * 2^63 is subtracted to yield EXP_Nfloat.
// Thus, EXP_Nfloat contains the floating point version of N
{ .mfi
      ldfpd       exp_P2, exp_P1 = [EXP_AD_P]
      fms.s1      EXP_Nfloat = EXP_W_2TO56_RSH, EXP_2TOM56, EXP_RSHF
      nop.i       0 
};;

.pred.rel "mutex",p11,p10
tanh_gt32:
{ .mfi
      // for x > 32 result is +1.0
	  nop.m       0
(p11) fma.d.s0    f8 = tanh_AlmostOne, tanh_AlmostOne, f0
	  nop.i       0
}
{ .mfb
	  nop.m       0
      // for x < -32 result is -1.0
(p10) fnma.d.s0   f8 = tanh_AlmostOne, tanh_AlmostOne, f0
(p13) br.ret.spnt b0
};;


{ .mfi
      getf.sig    exp_GR_N        = EXP_W_2TO56_RSH
      nop.f       0 
      nop.i       0
};;

// exp_GR_index_1 has index_1
// exp_GR_index_2_16 has index_2 * 16
// exp_GR_biased_M has M
// exp_GR_index_1_16 has index_1 * 16
// r2 has true M
{ .mfi
      and         exp_GR_index_1 = 0x0f, exp_GR_N
      fnma.s1     exp_r   = EXP_Nfloat, exp_ln2_by_128_hi, EXP_NORM_f8 
      shr         r2 = exp_GR_N,  0x7
}
{ .mfi
      and         exp_GR_index_2_16 = 0x70, exp_GR_N
      fnma.s1     exp_f = EXP_Nfloat, exp_ln2_by_128_lo, f1 
      nop.i       0
};;

// EXP_AD_T1 has address of T1                           
// EXP_AD_T2 has address if T2                            
{ .mmi
      addl        exp_GR_biased_M = 0xffff, r2 
      add         EXP_AD_T2 = EXP_AD_TB2, exp_GR_index_2_16 
      shladd      EXP_AD_T1 = exp_GR_index_1, 4, EXP_AD_TB1
};;

// Create Scale = 2^M
// r = x - Nfloat * ln2_by_128_hi 
// f = 1 - Nfloat * ln2_by_128_lo 
{ .mmi
      setf.exp    EXP_2M = exp_GR_biased_M
      ldfe        exp_T2  = [EXP_AD_T2]
      nop.i       0 
};;

// Load T1 and T2
{ .mfi
      ldfe        exp_T1  = [EXP_AD_T1]
      nop.f       0
      and         reg_ArFsr = reg_ArFsr, reg_RcMask
}
;;
{ .mfi
      nop.m       0
      fma.s1      exp_rsq = exp_r, exp_r, f0
      cmp.eq      p14, p0 = reg_ArFsr, reg_RcUp
}
{ .mfi
      nop.m       0
      fma.s1      exp_rP4pP3 = exp_r, exp_P4, exp_P3
      nop.i       0
};;
{ .mfi
      nop.m       0 
      fma.s1      exp_rcube = exp_r, exp_rsq, f0
      cmp.eq      p15, p0 = reg_ArFsr, reg_RcDown
}
{ .mfi
      nop.m       0
      fma.s1      exp_P_lo  = exp_r, exp_rP4pP3, exp_P2
      nop.i       0
};;
{ .mfi
(p14) ldfe        tanh_Two = [ALMOST_ONE], 16
      fma.s1      exp_P_hi  = exp_rsq, exp_P1, exp_r
      nop.i       0
}
{ .mfi
      nop.m       0
      fma.s1      exp_S2 = exp_f,exp_T2,f0
      nop.i       0
};;
{ .mfi
      nop.m       0
      fma.s1      exp_S1 = EXP_2M,exp_T1,f0
      nop.i       0
};;
{ .mfi
      nop.m       0
      fma.s1      exp_P = exp_rcube, exp_P_lo, exp_P_hi
      nop.i       0
};;
{ .mfi
      nop.m       0
      fma.s1      exp_S = exp_S1,exp_S2,f0
      nop.i       0
}
{ .mfi
      nop.m       0
      fma.s1      exp_ExppOne  = exp_S1,exp_S2,f1
      nop.i       0
}
;;
{ .mfi
(p15) ldfe        tanh_Two = [ALMOST_ONE], 16
      fma.s1      exp_ExppOne = exp_S, exp_P, exp_ExppOne 
      nop.i       0
};;
{ .mfi
      nop.m       0
      frcpa.s1    tanh_rcp0, p6 = f1, exp_ExppOne
      nop.i       0
}
;;
// NR method: ineration #1
{ .mfi
      nop.m       0
      fnma.s1     tanh_rcp1 = tanh_rcp0, exp_ExppOne, f1 // t = 1 - r0*x
      nop.i       0
};;
{ .mfi
      nop.m       0
      // r1 = r0 + r0*t = r0 + r0*(1 - r0*x)
      fma.s1      tanh_rcp1 = tanh_rcp0, tanh_rcp1, tanh_rcp0
      nop.i       0
};;
// NR method: ineration #2
{ .mfi
      nop.m       0
      fnma.s1     tanh_rcp2 = tanh_rcp1, exp_ExppOne, f1 // t = 1 - r1*x
      nop.i       0
};;
{ .mfi
      nop.m       0
      // r2 = r1 + r1*t = r1 + r1*(1 - r1*x)
      fma.s1      tanh_rcp2 = tanh_rcp1, tanh_rcp2, tanh_rcp1
      nop.i       0
};;
// NR method: ineration #3
{ .mfi
      nop.m       0
      fnma.s1     tanh_rcp3 = tanh_rcp2, exp_ExppOne, f1 // t = 1 - r2*x
      nop.i       0
};;
{ .mfi
      nop.m       0
      // y = r2 + r2*t = r2 + r2*(1 - r2*x)
      fma.s1      exp_ExppOne = tanh_rcp2, tanh_rcp3, tanh_rcp2
      nop.i       0
};;


.pred.rel "mutex",p11,p10
{ .mfi
      nop.m       0
      // tanh(x) = 1 - 2 / (1 + e^(2*x))
(p11) fnma.d.s0   f8 = exp_ExppOne, tanh_Two, f1
      nop.i       0
}
{ .mfb
      nop.m       0
      // tanh(x) = 2 / (1 + e^(2*x)) - 1
(p10) fms.d.s0    f8 = exp_ExppOne, tanh_Two, f1
      br.ret.sptk b0 // Normal path exit
};;

// Here if |x| < 1/16
tanh_near_zero:
{ .mfi
      nop.m       0
      fma.s1      tanh_C13 = tanh_C13, tanh_X2, tanh_C11
      nop.i       0
}
{ .mfi
      nop.m       0
      fma.s1      tanh_C9 = tanh_C9, tanh_X2, tanh_C7
      nop.i       0
};;
{ .mfi
      nop.m       0
      fma.s1      tanh_C5 = tanh_C5, tanh_X2, tanh_C3
      nop.i       0
};;
{ .mfi
      nop.m       0
      fma.s1      tanh_C13 = tanh_C13, tanh_X4, tanh_C9
      nop.i       0
};;
{ .mfi
      nop.m       0
      fma.s1      tanh_C13 = tanh_C13, tanh_X4, tanh_C5
      nop.i       0
};;
{ .mfb
      nop.m       0
      fma.d.s0    f8 = tanh_C13, tanh_X3, f8
      br.ret.sptk b0
};;

.endp tanh
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\_atan.s ===
#include "atan.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\tanf.s ===
.file "tanf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
// 4/04/00  Unwind support added
// 12/27/00 Improved speed
// 02/21/01 Updated to call tanl 
//
// API
//==============================================================
// float tan( float x);
//
// Overview of operation
//==============================================================
// If the input value in radians is |x| >= 1.xxxxx 2^10 call the
// older slower version.
//
// The new algorithm is used when |x| <= 1.xxxxx 2^9.
//
// Represent the input X as Nfloat * pi/2 + r
//    where r can be negative and |r| <= pi/4
//
//     tan_W  = x * 2/pi
//     Nfloat = round_int(tan_W)
//
//     tan_r  = x - Nfloat * (pi/2)_hi
//     tan_r  = tan_r - Nfloat * (pi/2)_lo
//
// We have two paths: p8, when Nfloat is even and p9. when Nfloat is odd.
// p8: tan(X) =  tan(r)
// p9: tan(X) = -cot(r)
//
// Each is evaluated as a series. The p9 path requires 1/r.
//
// The coefficients used in the series are stored in a table as
// are the pi constants.
//
// Registers used
//==============================================================
//
// predicate registers used:  
// p6-10
//
// floating-point registers used:  
// f10-15, f32-105
// f8, input
//
// general registers used
// r14-18, r32-43
//
// Assembly macros
//==============================================================
TAN_INV_PI_BY_2_2TO64        = f10
TAN_RSHF_2TO64               = f11
TAN_2TOM64                   = f12
TAN_RSHF                     = f13
TAN_W_2TO64_RSH              = f14
TAN_NFLOAT                   = f15

tan_Inv_Pi_by_2              = f32
tan_Pi_by_2_hi               = f33
tan_Pi_by_2_lo               = f34


tan_P0                       = f35
tan_P1                       = f36
tan_P2                       = f37
tan_P3                       = f38 
tan_P4                       = f39 
tan_P5                       = f40 
tan_P6                       = f41
tan_P7                       = f42
tan_P8                       = f43 
tan_P9                       = f44 
tan_P10                      = f45 
tan_P11                      = f46
tan_P12                      = f47 
tan_P13                      = f48
tan_P14                      = f49
tan_P15                      = f50

tan_Q0                       = f51 
tan_Q1                       = f52 
tan_Q2                       = f53 
tan_Q3                       = f54 
tan_Q4                       = f55 
tan_Q5                       = f56 
tan_Q6                       = f57 
tan_Q7                       = f58 
tan_Q8                       = f59
tan_Q9                       = f60
tan_Q10                      = f61

tan_r                        = f62
tan_rsq                      = f63
tan_rcube                    = f64

tan_v18                      = f65
tan_v16                      = f66
tan_v17                      = f67
tan_v12                      = f68
tan_v13                      = f69
tan_v7                       = f70
tan_v8                       = f71
tan_v4                       = f72
tan_v5                       = f73
tan_v15                      = f74
tan_v11                      = f75
tan_v14                      = f76
tan_v3                       = f77
tan_v6                       = f78
tan_v10                      = f79
tan_v2                       = f80
tan_v9                       = f81
tan_v1                       = f82
tan_int_Nfloat               = f83 
tan_Nfloat                   = f84 

tan_NORM_f8                  = f85 
tan_W                        = f86

tan_y0                       = f87
tan_d                        = f88 
tan_y1                       = f89 
tan_dsq                      = f90 
tan_y2                       = f91 
tan_d4                       = f92 
tan_inv_r                    = f93 

tan_z1                       = f94
tan_z2                       = f95
tan_z3                       = f96
tan_z4                       = f97
tan_z5                       = f98
tan_z6                       = f99
tan_z7                       = f100
tan_z8                       = f101
tan_z9                       = f102
tan_z10                      = f103
tan_z11                      = f104
tan_z12                      = f105


/////////////////////////////////////////////////////////////

tan_GR_sig_inv_pi_by_2       = r14
tan_GR_rshf_2to64            = r15
tan_GR_exp_2tom64            = r16
tan_GR_n                     = r17
tan_GR_rshf                  = r18

tan_AD                       = r33
tan_GR_10009                 = r34 
tan_GR_17_ones               = r35 
tan_GR_N_odd_even            = r36 
tan_GR_N                     = r37 
tan_signexp                  = r38
tan_exp                      = r39
tan_ADQ                      = r40

GR_SAVE_PFS                  = r41 
GR_SAVE_B0                   = r42       
GR_SAVE_GP                   = r43      


.data

.align 16

double_tan_constants:
//   data8 0xA2F9836E4E44152A, 0x00003FFE // 2/pi
   data8 0xC90FDAA22168C234, 0x00003FFF // pi/2 hi

   data8 0xBEEA54580DDEA0E1 // P14 
   data8 0x3ED3021ACE749A59 // P15
   data8 0xBEF312BD91DC8DA1 // P12 
   data8 0x3EFAE9AFC14C5119 // P13
   data8 0x3F2F342BF411E769 // P8
   data8 0x3F1A60FC9F3B0227 // P9
   data8 0x3EFF246E78E5E45B // P10
   data8 0x3F01D9D2E782875C // P11
   data8 0x3F8226E34C4499B6 // P4
   data8 0x3F6D6D3F12C236AC // P5
   data8 0x3F57DA1146DCFD8B // P6
   data8 0x3F43576410FE3D75 // P7
   data8 0x3FD5555555555555 // P0
   data8 0x3FC11111111111C2 // P1
   data8 0x3FABA1BA1BA0E850 // P2
   data8 0x3F9664F4886725A7 // P3

double_Q_tan_constants:
   data8 0xC4C6628B80DC1CD1, 0x00003FBF // pi/2 lo
   data8 0x3E223A73BA576E48 // Q8
   data8 0x3DF54AD8D1F2CA43 // Q9
   data8 0x3EF66A8EE529A6AA // Q4
   data8 0x3EC2281050410EE6 // Q5
   data8 0x3E8D6BB992CC3CF5 // Q6
   data8 0x3E57F88DE34832E4 // Q7
   data8 0x3FD5555555555555 // Q0
   data8 0x3F96C16C16C16DB8 // Q1
   data8 0x3F61566ABBFFB489 // Q2
   data8 0x3F2BBD77945C1733 // Q3
   data8 0x3D927FB33E2B0E04 // Q10


   
.align 32
.global tanf#

////////////////////////////////////////////////////////



.section .text
.global tanf
.proc  tanf
.align 32
tanf: 
// The initial fnorm will take any unmasked faults and
// normalize any single/double unorms

{ .mlx
      alloc          r32=ar.pfs,1,11,0,0               
      movl tan_GR_sig_inv_pi_by_2 = 0xA2F9836E4E44152A // significand of 2/pi
}
{ .mlx
      addl           tan_AD   = @ltoff(double_tan_constants), gp
      movl tan_GR_rshf_2to64 = 0x47e8000000000000 // 1.1000 2^(63+63+1)
}
;;

{ .mfi
      ld8 tan_AD = [tan_AD]
      fnorm     tan_NORM_f8  = f8                      
      mov tan_GR_exp_2tom64 = 0xffff-64 // exponent of scaling factor 2^-64
}
{ .mlx
      nop.m 999
      movl tan_GR_rshf = 0x43e8000000000000 // 1.1000 2^63 for right shift
}
;;


// Form two constants we need
//   2/pi * 2^1 * 2^63, scaled by 2^64 since we just loaded the significand
//   1.1000...000 * 2^(63+63+1) to right shift int(W) into the significand
{ .mmi
      setf.sig TAN_INV_PI_BY_2_2TO64 = tan_GR_sig_inv_pi_by_2
      setf.d TAN_RSHF_2TO64 = tan_GR_rshf_2to64
      mov       tan_GR_17_ones     = 0x1ffff             ;;
}


// Form another constant
//   2^-64 for scaling Nfloat
//   1.1000...000 * 2^63, the right shift constant
{ .mmf
      setf.exp TAN_2TOM64 = tan_GR_exp_2tom64
      adds tan_ADQ = double_Q_tan_constants - double_tan_constants, tan_AD
      fclass.m.unc  p6,p0 = f8, 0x07  // Test for x=0
}
;;


// Form another constant
//   2^-64 for scaling Nfloat
//   1.1000...000 * 2^63, the right shift constant
{ .mmf
      setf.d TAN_RSHF = tan_GR_rshf
      ldfe      tan_Pi_by_2_hi = [tan_AD],16 
      fclass.m.unc  p7,p0 = f8, 0x23  // Test for x=inf
}
;;

{ .mfb
      ldfe      tan_Pi_by_2_lo = [tan_ADQ],16           
      fclass.m.unc  p8,p0 = f8, 0xc3  // Test for x=nan
(p6)  br.ret.spnt    b0    ;;         // Exit for x=0
}

{ .mfi
      ldfpd     tan_P14,tan_P15 = [tan_AD],16                         
(p7)  frcpa.s0  f8,p9=f0,f0           // Set qnan indef if x=inf
      mov       tan_GR_10009 = 0x10009
}
{ .mib
      ldfpd      tan_Q8,tan_Q9  = [tan_ADQ],16                        
      nop.i 999
(p7)  br.ret.spnt    b0    ;;         // Exit for x=inf
}

{ .mfi
      ldfpd      tan_P12,tan_P13 = [tan_AD],16                         
(p8)  fma.s f8=f8,f1,f8               // Set qnan if x=nan
      nop.i 999
}
{ .mib
      ldfpd      tan_Q4,tan_Q5  = [tan_ADQ],16                        
      nop.i 999
(p8)  br.ret.spnt    b0    ;;         // Exit for x=nan
}

{ .mmi
      getf.exp  tan_signexp    = tan_NORM_f8                 
      ldfpd      tan_P8,tan_P9  = [tan_AD],16                         
      nop.i 999 ;;
}

// Multiply x by scaled 2/pi and add large const to shift integer part of W to 
//   rightmost bits of significand
{ .mfi
      ldfpd      tan_Q6,tan_Q7  = [tan_ADQ],16
      fma.s1 TAN_W_2TO64_RSH = tan_NORM_f8,TAN_INV_PI_BY_2_2TO64,TAN_RSHF_2TO64
      nop.i 999 ;;
}

{ .mmi
      ldfpd      tan_P10,tan_P11 = [tan_AD],16                         
      nop.m 999
      and       tan_exp = tan_GR_17_ones, tan_signexp         ;;
}


// p7 is true if we must call DBX TAN
// p7 is true if f8 exp is > 0x10009 (which includes all ones
//    NAN or inf)
{ .mmi
      ldfpd      tan_Q0,tan_Q1  = [tan_ADQ],16                         
      cmp.ge.unc  p7,p0 = tan_exp,tan_GR_10009               
      nop.i 999 ;;
}


{ .mmb
      ldfpd      tan_P4,tan_P5  = [tan_AD],16                         
      nop.m 999
(p7)  br.cond.spnt   TAN_DBX ;;                                  
}


{ .mmi
      ldfpd      tan_Q2,tan_Q3  = [tan_ADQ],16                         
      nop.m 999
      nop.i 999 ;;
}



// TAN_NFLOAT = Round_Int_Nearest(tan_W)
{ .mfi
      ldfpd      tan_P6,tan_P7  = [tan_AD],16                         
      fms.s1 TAN_NFLOAT = TAN_W_2TO64_RSH,TAN_2TOM64,TAN_RSHF      
      nop.i 999 ;;
}


{ .mfi
      ldfd      tan_Q10 = [tan_ADQ]
      nop.f 999
      nop.i 999 ;;
}


{ .mfi
      ldfpd      tan_P0,tan_P1  = [tan_AD],16                         
      nop.f 999
      nop.i 999 ;;
}


{ .mfi
      getf.sig    tan_GR_n = TAN_W_2TO64_RSH
      nop.f 999
      nop.i 999 ;;
}

// tan_r          = -tan_Nfloat * tan_Pi_by_2_hi + x
{ .mfi
      ldfpd      tan_P2,tan_P3  = [tan_AD]
      fnma.s1  tan_r      = TAN_NFLOAT, tan_Pi_by_2_hi,  tan_NORM_f8         
      nop.i 999 ;;
}


// p8 ==> even
// p9 ==> odd
{ .mmi
      and         tan_GR_N_odd_even = 0x1, tan_GR_n ;;          
      nop.m 999
      cmp.eq.unc  p8,p9          = tan_GR_N_odd_even, r0      ;;
}


// tan_r          = tan_r -tan_Nfloat * tan_Pi_by_2_lo 
{ .mfi
      nop.m 999
      fnma.s1  tan_r      = TAN_NFLOAT, tan_Pi_by_2_lo,  tan_r      
      nop.i 999 ;;
}


{ .mfi
      nop.m 999
      fma.s1   tan_rsq    = tan_r, tan_r,   f0                      
      nop.i 999 ;;
}


{ .mfi
      nop.m 999
(p9)  frcpa.s1   tan_y0, p10 = f1,tan_r                  
      nop.i 999  ;;
}


{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v18 = tan_rsq, tan_P15, tan_P14        
      nop.i 999
}
{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v4  = tan_rsq, tan_P1, tan_P0          
      nop.i 999  ;;
}



{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v16 = tan_rsq, tan_P13, tan_P12        
      nop.i 999 
}
{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v17 = tan_rsq, tan_rsq, f0             
      nop.i 999 ;;
}



{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v12 = tan_rsq, tan_P9, tan_P8          
      nop.i 999 
}
{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v13 = tan_rsq, tan_P11, tan_P10        
      nop.i 999 ;;
}



{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v7  = tan_rsq, tan_P5, tan_P4          
      nop.i 999 
}
{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v8  = tan_rsq, tan_P7, tan_P6          
      nop.i 999 ;;
}



{ .mfi
      nop.m 999
(p9)  fnma.s1    tan_d   = tan_r, tan_y0, f1   
      nop.i 999 
}
{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v5  = tan_rsq, tan_P3, tan_P2          
      nop.i 999 ;;
}



{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z11 = tan_rsq, tan_Q9, tan_Q8         
      nop.i 999
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z12 = tan_rsq, tan_rsq, f0            
      nop.i 999 ;;
}


{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v15 = tan_v17, tan_v18, tan_v16        
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z7 = tan_rsq, tan_Q5, tan_Q4          
      nop.i 999 ;;
}


{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v11 = tan_v17, tan_v13, tan_v12        
      nop.i 999
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z8 = tan_rsq, tan_Q7, tan_Q6          
      nop.i 999 ;;
}



{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v14 = tan_v17, tan_v17, f0             
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z3 = tan_rsq, tan_Q1, tan_Q0          
      nop.i 999 ;; 
}




{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v3 = tan_v17, tan_v5, tan_v4           
      nop.i 999
}
{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v6 = tan_v17, tan_v8, tan_v7           
      nop.i 999 ;;
}



{ .mfi
      nop.m 999
(p9)  fma.s1     tan_y1  = tan_y0, tan_d, tan_y0    
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1     tan_dsq = tan_d, tan_d, f0        
      nop.i 999 ;; 
}


{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z10 = tan_z12, tan_Q10, tan_z11       
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z9  = tan_z12, tan_z12,f0             
      nop.i 999 ;;
}


{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z4 = tan_rsq, tan_Q3, tan_Q2          
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z6  = tan_z12, tan_z8, tan_z7         
      nop.i 999 ;; 
}



{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v10 = tan_v14, tan_v15, tan_v11        
      nop.i 999 ;; 
}



{ .mfi
      nop.m 999
(p9)  fma.s1     tan_y2  = tan_y1, tan_d, tan_y0         
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1     tan_d4  = tan_dsq, tan_dsq, tan_d       
      nop.i 999  ;;
}


{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v2 = tan_v14, tan_v6, tan_v3           
      nop.i 999
}
{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v9 = tan_v14, tan_v14, f0              
      nop.i 999 ;;
}


{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z2  = tan_z12, tan_z4, tan_z3         
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z5  = tan_z9, tan_z10, tan_z6         
      nop.i 999  ;;
}


{ .mfi
      nop.m 999
(p9)  fma.s1     tan_inv_r = tan_d4, tan_y2, tan_y0      
      nop.i 999 
}
{ .mfi
      nop.m 999
(p8)  fma.s1   tan_rcube  = tan_rsq, tan_r,   f0
      nop.i 999  ;;
}



{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v1 = tan_v9, tan_v10, tan_v2           
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z1  = tan_z9, tan_z5, tan_z2          
      nop.i 999   ;;
}



{ .mfi
      nop.m 999
(p8)  fma.s.s0  f8  = tan_v1, tan_rcube, tan_r             
      nop.i 999  
}
{ .mfb
      nop.m 999
(p9)  fms.s.s0  f8  = tan_r, tan_z1, tan_inv_r        
      br.ret.sptk    b0 ;;    
}
.endp tanf#


.proc __libm_callout
__libm_callout:
TAN_DBX: 
.prologue

{ .mfi
        nop.m 0
     fmerge.s f9 = f0,f0 
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs
}
;;

{ .mfi
        mov GR_SAVE_GP=gp
        nop.f 0
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0
}

.body
{ .mfb
      nop.m 999
      nop.f 999
      br.call.sptk.many  b0=__libm_tan# ;;
}


{ .mfi
       mov gp        = GR_SAVE_GP
      fnorm.s     f8 = f8
       mov b0        = GR_SAVE_B0 
}
;;


{ .mib
         nop.m 999
      mov ar.pfs    = GR_SAVE_PFS
      br.ret.sptk     b0
;;
}


.endp  __libm_callout

.type __libm_tan#,@function
.global __libm_tan#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\tan.s ===
.file "tan.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
// 4/04/00  Unwind support added
// 12/27/00 Improved speed
// 02/21/01 Updated to call tanl
//
// API
//==============================================================
// double tan( double x);
//
// Overview of operation
//==============================================================
// If the input value in radians is |x| >= 1.xxxxx 2^10 call the
// older slower version.
//
// The new algorithm is used when |x| <= 1.xxxxx 2^9.
//
// Represent the input X as Nfloat * pi/2 + r
//    where r can be negative and |r| <= pi/4
//
//     tan_W  = x * 2/pi
//     Nfloat = round_int(tan_W)
//
//     tan_r  = x - Nfloat * (pi/2)_hi
//     tan_r  = tan_r - Nfloat * (pi/2)_lo
//
// We have two paths: p8, when Nfloat is even and p9. when Nfloat is odd.
// p8: tan(X) =  tan(r)
// p9: tan(X) = -cot(r)
//
// Each is evaluated as a series. The p9 path requires 1/r.
//
// The coefficients used in the series are stored in a table as
// are the pi constants.
//
// Registers used
//==============================================================
//
// predicate registers used:  
// p6-10
//
// floating-point registers used:  
// f10-15, f32-105
// f8, input
//
// general registers used
// r14-18, r32-43
//
// Assembly macros
//==============================================================
TAN_INV_PI_BY_2_2TO64        = f10
TAN_RSHF_2TO64               = f11
TAN_2TOM64                   = f12
TAN_RSHF                     = f13
TAN_W_2TO64_RSH              = f14
TAN_NFLOAT                   = f15

tan_Inv_Pi_by_2              = f32
tan_Pi_by_2_hi               = f33
tan_Pi_by_2_lo               = f34


tan_P0                       = f35
tan_P1                       = f36
tan_P2                       = f37
tan_P3                       = f38 
tan_P4                       = f39 
tan_P5                       = f40 
tan_P6                       = f41
tan_P7                       = f42
tan_P8                       = f43 
tan_P9                       = f44 
tan_P10                      = f45 
tan_P11                      = f46
tan_P12                      = f47 
tan_P13                      = f48
tan_P14                      = f49
tan_P15                      = f50

tan_Q0                       = f51 
tan_Q1                       = f52 
tan_Q2                       = f53 
tan_Q3                       = f54 
tan_Q4                       = f55 
tan_Q5                       = f56 
tan_Q6                       = f57 
tan_Q7                       = f58 
tan_Q8                       = f59
tan_Q9                       = f60
tan_Q10                      = f61

tan_r                        = f62
tan_rsq                      = f63
tan_rcube                    = f64

tan_v18                      = f65
tan_v16                      = f66
tan_v17                      = f67
tan_v12                      = f68
tan_v13                      = f69
tan_v7                       = f70
tan_v8                       = f71
tan_v4                       = f72
tan_v5                       = f73
tan_v15                      = f74
tan_v11                      = f75
tan_v14                      = f76
tan_v3                       = f77
tan_v6                       = f78
tan_v10                      = f79
tan_v2                       = f80
tan_v9                       = f81
tan_v1                       = f82
tan_int_Nfloat               = f83 
tan_Nfloat                   = f84 

tan_NORM_f8                  = f85 
tan_W                        = f86

tan_y0                       = f87
tan_d                        = f88 
tan_y1                       = f89 
tan_dsq                      = f90 
tan_y2                       = f91 
tan_d4                       = f92 
tan_inv_r                    = f93 

tan_z1                       = f94
tan_z2                       = f95
tan_z3                       = f96
tan_z4                       = f97
tan_z5                       = f98
tan_z6                       = f99
tan_z7                       = f100
tan_z8                       = f101
tan_z9                       = f102
tan_z10                      = f103
tan_z11                      = f104
tan_z12                      = f105


/////////////////////////////////////////////////////////////

tan_GR_sig_inv_pi_by_2       = r14
tan_GR_rshf_2to64            = r15
tan_GR_exp_2tom64            = r16
tan_GR_n                     = r17
tan_GR_rshf                  = r18

tan_AD                       = r33
tan_GR_10009                 = r34 
tan_GR_17_ones               = r35 
tan_GR_N_odd_even            = r36 
tan_GR_N                     = r37 
tan_signexp                  = r38
tan_exp                      = r39
tan_ADQ                      = r40

GR_SAVE_PFS                  = r41 
GR_SAVE_B0                   = r42       
GR_SAVE_GP                   = r43      


.data

.align 16

double_tan_constants:
//   data8 0xA2F9836E4E44152A, 0x00003FFE // 2/pi
   data8 0xC90FDAA22168C234, 0x00003FFF // pi/2 hi

   data8 0xBEEA54580DDEA0E1 // P14 
   data8 0x3ED3021ACE749A59 // P15
   data8 0xBEF312BD91DC8DA1 // P12 
   data8 0x3EFAE9AFC14C5119 // P13
   data8 0x3F2F342BF411E769 // P8
   data8 0x3F1A60FC9F3B0227 // P9
   data8 0x3EFF246E78E5E45B // P10
   data8 0x3F01D9D2E782875C // P11
   data8 0x3F8226E34C4499B6 // P4
   data8 0x3F6D6D3F12C236AC // P5
   data8 0x3F57DA1146DCFD8B // P6
   data8 0x3F43576410FE3D75 // P7
   data8 0x3FD5555555555555 // P0
   data8 0x3FC11111111111C2 // P1
   data8 0x3FABA1BA1BA0E850 // P2
   data8 0x3F9664F4886725A7 // P3

double_Q_tan_constants:
   data8 0xC4C6628B80DC1CD1, 0x00003FBF // pi/2 lo
   data8 0x3E223A73BA576E48 // Q8
   data8 0x3DF54AD8D1F2CA43 // Q9
   data8 0x3EF66A8EE529A6AA // Q4
   data8 0x3EC2281050410EE6 // Q5
   data8 0x3E8D6BB992CC3CF5 // Q6
   data8 0x3E57F88DE34832E4 // Q7
   data8 0x3FD5555555555555 // Q0
   data8 0x3F96C16C16C16DB8 // Q1
   data8 0x3F61566ABBFFB489 // Q2
   data8 0x3F2BBD77945C1733 // Q3
   data8 0x3D927FB33E2B0E04 // Q10


   
.align 32
.global tan#

////////////////////////////////////////////////////////



.section .text
.proc  tan#
.align 32
tan: 
// The initial fnorm will take any unmasked faults and
// normalize any single/double unorms

{ .mlx
      alloc          r32=ar.pfs,1,11,0,0               
      movl tan_GR_sig_inv_pi_by_2 = 0xA2F9836E4E44152A // significand of 2/pi
}
{ .mlx
      addl           tan_AD   = @ltoff(double_tan_constants), gp
      movl tan_GR_rshf_2to64 = 0x47e8000000000000 // 1.1000 2^(63+63+1)
}
;;

{ .mfi
      ld8 tan_AD = [tan_AD]
      fnorm     tan_NORM_f8  = f8                      
      mov tan_GR_exp_2tom64 = 0xffff-64 // exponent of scaling factor 2^-64
}
{ .mlx
      nop.m 999
      movl tan_GR_rshf = 0x43e8000000000000 // 1.1000 2^63 for right shift
}
;;


// Form two constants we need
//   2/pi * 2^1 * 2^63, scaled by 2^64 since we just loaded the significand
//   1.1000...000 * 2^(63+63+1) to right shift int(W) into the significand
{ .mmi
      setf.sig TAN_INV_PI_BY_2_2TO64 = tan_GR_sig_inv_pi_by_2
      setf.d TAN_RSHF_2TO64 = tan_GR_rshf_2to64
      mov       tan_GR_17_ones     = 0x1ffff             ;;
}


// Form another constant
//   2^-64 for scaling Nfloat
//   1.1000...000 * 2^63, the right shift constant
{ .mmf
      setf.exp TAN_2TOM64 = tan_GR_exp_2tom64
      adds tan_ADQ = double_Q_tan_constants - double_tan_constants, tan_AD
      fclass.m.unc  p6,p0 = f8, 0x07  // Test for x=0
}
;;


// Form another constant
//   2^-64 for scaling Nfloat
//   1.1000...000 * 2^63, the right shift constant
{ .mmf
      setf.d TAN_RSHF = tan_GR_rshf
      ldfe      tan_Pi_by_2_hi = [tan_AD],16 
      fclass.m.unc  p7,p0 = f8, 0x23  // Test for x=inf
}
;;

{ .mfb
      ldfe      tan_Pi_by_2_lo = [tan_ADQ],16           
      fclass.m.unc  p8,p0 = f8, 0xc3  // Test for x=nan
(p6)  br.ret.spnt    b0    ;;         // Exit for x=0
}

{ .mfi
      ldfpd     tan_P14,tan_P15 = [tan_AD],16                         
(p7)  frcpa.s0  f8,p9=f0,f0           // Set qnan indef if x=inf
      mov       tan_GR_10009 = 0x10009
}
{ .mib
      ldfpd      tan_Q8,tan_Q9  = [tan_ADQ],16                        
      nop.i 999
(p7)  br.ret.spnt    b0    ;;         // Exit for x=inf
}

{ .mfi
      ldfpd      tan_P12,tan_P13 = [tan_AD],16                         
(p8)  fma.d f8=f8,f1,f8               // Set qnan if x=nan
      nop.i 999
}
{ .mib
      ldfpd      tan_Q4,tan_Q5  = [tan_ADQ],16                        
      nop.i 999
(p8)  br.ret.spnt    b0    ;;         // Exit for x=nan
}

{ .mmi
      getf.exp  tan_signexp    = tan_NORM_f8                 
      ldfpd      tan_P8,tan_P9  = [tan_AD],16                         
      nop.i 999 ;;
}

// Multiply x by scaled 2/pi and add large const to shift integer part of W to 
//   rightmost bits of significand
{ .mfi
      ldfpd      tan_Q6,tan_Q7  = [tan_ADQ],16
      fma.s1 TAN_W_2TO64_RSH = tan_NORM_f8,TAN_INV_PI_BY_2_2TO64,TAN_RSHF_2TO64
      nop.i 999 ;;
}

{ .mmi
      ldfpd      tan_P10,tan_P11 = [tan_AD],16                         
      nop.m 999
      and       tan_exp = tan_GR_17_ones, tan_signexp         ;;
}


// p7 is true if we must call DBX TAN
// p7 is true if f8 exp is > 0x10009 (which includes all ones
//    NAN or inf)
{ .mmi
      ldfpd      tan_Q0,tan_Q1  = [tan_ADQ],16                         
      cmp.ge.unc  p7,p0 = tan_exp,tan_GR_10009               
      nop.i 999 ;;
}


{ .mmb
      ldfpd      tan_P4,tan_P5  = [tan_AD],16                         
      nop.m 999
(p7)  br.cond.spnt   TAN_DBX ;;                                  
}


{ .mmi
      ldfpd      tan_Q2,tan_Q3  = [tan_ADQ],16                         
      nop.m 999
      nop.i 999 ;;
}



// TAN_NFLOAT = Round_Int_Nearest(tan_W)
{ .mfi
      ldfpd      tan_P6,tan_P7  = [tan_AD],16                         
      fms.s1 TAN_NFLOAT = TAN_W_2TO64_RSH,TAN_2TOM64,TAN_RSHF      
      nop.i 999 ;;
}


{ .mfi
      ldfd      tan_Q10 = [tan_ADQ]
      nop.f 999
      nop.i 999 ;;
}


{ .mfi
      ldfpd      tan_P0,tan_P1  = [tan_AD],16                         
      nop.f 999
      nop.i 999 ;;
}


{ .mfi
      getf.sig    tan_GR_n = TAN_W_2TO64_RSH
      nop.f 999
      nop.i 999 ;;
}

// tan_r          = -tan_Nfloat * tan_Pi_by_2_hi + x
{ .mfi
      ldfpd      tan_P2,tan_P3  = [tan_AD]
      fnma.s1  tan_r      = TAN_NFLOAT, tan_Pi_by_2_hi,  tan_NORM_f8         
      nop.i 999 ;;
}


// p8 ==> even
// p9 ==> odd
{ .mmi
      and         tan_GR_N_odd_even = 0x1, tan_GR_n ;;          
      nop.m 999
      cmp.eq.unc  p8,p9          = tan_GR_N_odd_even, r0      ;;
}


// tan_r          = tan_r -tan_Nfloat * tan_Pi_by_2_lo 
{ .mfi
      nop.m 999
      fnma.s1  tan_r      = TAN_NFLOAT, tan_Pi_by_2_lo,  tan_r      
      nop.i 999 ;;
}


{ .mfi
      nop.m 999
      fma.s1   tan_rsq    = tan_r, tan_r,   f0                      
      nop.i 999 ;;
}


{ .mfi
      nop.m 999
(p9)  frcpa.s1   tan_y0, p10 = f1,tan_r                  
      nop.i 999  ;;
}


{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v18 = tan_rsq, tan_P15, tan_P14        
      nop.i 999
}
{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v4  = tan_rsq, tan_P1, tan_P0          
      nop.i 999  ;;
}



{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v16 = tan_rsq, tan_P13, tan_P12        
      nop.i 999 
}
{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v17 = tan_rsq, tan_rsq, f0             
      nop.i 999 ;;
}



{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v12 = tan_rsq, tan_P9, tan_P8          
      nop.i 999 
}
{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v13 = tan_rsq, tan_P11, tan_P10        
      nop.i 999 ;;
}



{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v7  = tan_rsq, tan_P5, tan_P4          
      nop.i 999 
}
{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v8  = tan_rsq, tan_P7, tan_P6          
      nop.i 999 ;;
}



{ .mfi
      nop.m 999
(p9)  fnma.s1    tan_d   = tan_r, tan_y0, f1   
      nop.i 999 
}
{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v5  = tan_rsq, tan_P3, tan_P2          
      nop.i 999 ;;
}



{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z11 = tan_rsq, tan_Q9, tan_Q8         
      nop.i 999
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z12 = tan_rsq, tan_rsq, f0            
      nop.i 999 ;;
}


{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v15 = tan_v17, tan_v18, tan_v16        
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z7 = tan_rsq, tan_Q5, tan_Q4          
      nop.i 999 ;;
}


{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v11 = tan_v17, tan_v13, tan_v12        
      nop.i 999
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z8 = tan_rsq, tan_Q7, tan_Q6          
      nop.i 999 ;;
}



{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v14 = tan_v17, tan_v17, f0             
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z3 = tan_rsq, tan_Q1, tan_Q0          
      nop.i 999 ;; 
}




{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v3 = tan_v17, tan_v5, tan_v4           
      nop.i 999
}
{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v6 = tan_v17, tan_v8, tan_v7           
      nop.i 999 ;;
}



{ .mfi
      nop.m 999
(p9)  fma.s1     tan_y1  = tan_y0, tan_d, tan_y0    
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1     tan_dsq = tan_d, tan_d, f0        
      nop.i 999 ;; 
}


{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z10 = tan_z12, tan_Q10, tan_z11       
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z9  = tan_z12, tan_z12,f0             
      nop.i 999 ;;
}


{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z4 = tan_rsq, tan_Q3, tan_Q2          
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z6  = tan_z12, tan_z8, tan_z7         
      nop.i 999 ;; 
}



{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v10 = tan_v14, tan_v15, tan_v11        
      nop.i 999 ;; 
}



{ .mfi
      nop.m 999
(p9)  fma.s1     tan_y2  = tan_y1, tan_d, tan_y0         
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1     tan_d4  = tan_dsq, tan_dsq, tan_d       
      nop.i 999  ;;
}


{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v2 = tan_v14, tan_v6, tan_v3           
      nop.i 999
}
{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v9 = tan_v14, tan_v14, f0              
      nop.i 999 ;;
}


{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z2  = tan_z12, tan_z4, tan_z3         
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z5  = tan_z9, tan_z10, tan_z6         
      nop.i 999  ;;
}


{ .mfi
      nop.m 999
(p9)  fma.s1     tan_inv_r = tan_d4, tan_y2, tan_y0      
      nop.i 999 
}
{ .mfi
      nop.m 999
(p8)  fma.s1   tan_rcube  = tan_rsq, tan_r,   f0
      nop.i 999  ;;
}



{ .mfi
      nop.m 999
(p8)  fma.s1  tan_v1 = tan_v9, tan_v10, tan_v2           
      nop.i 999 
}
{ .mfi
      nop.m 999
(p9)  fma.s1  tan_z1  = tan_z9, tan_z5, tan_z2          
      nop.i 999   ;;
}



{ .mfi
      nop.m 999
(p8)  fma.d.s0  f8  = tan_v1, tan_rcube, tan_r             
      nop.i 999  
}
{ .mfb
      nop.m 999
(p9)  fms.d.s0  f8  = tan_r, tan_z1, tan_inv_r        
      br.ret.sptk    b0 ;;    
}
.endp tan#


.proc __libm_callout
__libm_callout:
TAN_DBX: 
.prologue

{ .mfi
        nop.m 0
     fmerge.s f9 = f0,f0 
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs
}
;;

{ .mfi
        mov GR_SAVE_GP=gp
        nop.f 0
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0
}

.body
{ .mfb
      nop.m 999
      nop.f 999
(p0)   br.call.sptk.many  b0=__libm_tan# ;;
}


{ .mfi
       mov gp        = GR_SAVE_GP
      fnorm.d     f8 = f8
       mov b0        = GR_SAVE_B0 
}
;;


{ .mib
         nop.m 999
      mov ar.pfs    = GR_SAVE_PFS
      br.ret.sptk     b0
;;
}


.endp  __libm_callout

.type __libm_tan#,@function
.global __libm_tan#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\_exp.s ===
#include "exp.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\_ceil.s ===
#include "ceil.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\_fabs.s ===
#include "fabs.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\_hypot.s ===
#include "hypot.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\_fmod.s ===
#include "fmod.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\_floor.s ===
#include "floor.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\_pow.s ===
#include "pow.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\_modf.s ===
#include "modf.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\_ldexp.s ===
#include "ldexp.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\_sincos.s ===
#include "sincos.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\_log.s ===
#include "log.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\_tan.s ===
#include "tan.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\_sqrt.s ===
#include "sqrt.s"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\langapi\include\rttidata.h ===
//
//	_RTTIBaseClassDescriptor
//
//	TypeDescriptor is declared in ehdata.h
//
#if (defined(_M_IA64) || defined(_M_AMD64)) || defined(VERSP_IA64)	/*IFSTRIP=IGN*/
#pragma pack(push, rttidata, 4)
#endif

#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTIBaseClassDescriptor	{
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_IA64)
	__int32     					pTypeDescriptor;    // Image relative offset of TypeDescriptor
#else
	TypeDescriptor					*pTypeDescriptor;
#endif
	DWORD							numContainedBases;
	PMD								where;
	DWORD							attributes;
	} _RTTIBaseClassDescriptor;
#endif // WANT_NO_TYPES

#define BCD_NOTVISIBLE				0x00000001
#define BCD_AMBIGUOUS				0x00000002
#define BCD_PRIVORPROTINCOMPOBJ		0x00000004
#define BCD_PRIVORPROTBASE			0x00000008
#define BCD_VBOFCONTOBJ				0x00000010
#define BCD_NONPOLYMORPHIC			0x00000020

#define BCD_PTD(bcd)				((bcd).pTypeDescriptor)
#define BCD_NUMCONTBASES(bcd)		((bcd).numContainedBases)
#define BCD_WHERE(bcd)				((bcd).where)
#define BCD_ATTRIBUTES(bcd)			((bcd).attributes)
#if defined(_M_IA64) || defined(_M_AMD64)
#define BCD_PTD_IB(bcd,ib)			((TypeDescriptor*)((ib) + (bcd).pTypeDescriptor))
#endif


//
//	_RTTIBaseClassArray
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning
#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTIBaseClassArray	{
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_IA64)
	__int32                 		arrayOfBaseClassDescriptors[];  // Image relative offset of _RTTIBaseClassDescriptor
#else
	_RTTIBaseClassDescriptor		*arrayOfBaseClassDescriptors[];
#endif
	} _RTTIBaseClassArray;
#endif // WANT_NO_TYPES
#pragma warning(default:4200)

//
//	_RTTIClassHierarchyDescriptor
//
#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTIClassHierarchyDescriptor	{
	DWORD							signature;
	DWORD							attributes;
	DWORD							numBaseClasses;
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_IA64)
	__int32         				pBaseClassArray;    // Image relative offset of _RTTIBaseClassArray
#else
	_RTTIBaseClassArray				*pBaseClassArray;
#endif
	} _RTTIClassHierarchyDescriptor;
#endif // WANT_NO_TYPES

#define CHD_MULTINH					0x00000001
#define CHD_VIRTINH					0x00000002
#define CHD_AMBIGUOUS				0x00000004

#define CHD_SIGNATURE(chd)			((chd).signature)
#define CHD_ATTRIBUTES(chd)			((chd).attributes)
#define CHD_NUMBASES(chd)			((chd).numBaseClasses)
#define CHD_PBCA(chd)				((chd).pBaseClassArray)
#define CHD_PBCD(bcd)				(bcd)
#if defined(_M_IA64) || defined(_M_AMD64)
#define CHD_PBCA_IB(chd,ib)			((_RTTIBaseClassArray*)((ib) + (chd).pBaseClassArray))
#define CHD_PBCD_IB(bcd,ib)			((_RTTIBaseClassDescriptor*)((ib) + bcd))
#endif

//
//	_RTTICompleteObjectLocator
//
#ifndef WANT_NO_TYPES
typedef const struct	_s_RTTICompleteObjectLocator	{
	DWORD							signature;
	DWORD							offset;
	DWORD							cdOffset;
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_IA64)
	__int32		    			    pTypeDescriptor;    // Image relative offset of TypeDescriptor
	__int32                         pClassDescriptor;   // Image relative offset of _RTTIClassHierarchyDescriptor
#else
	TypeDescriptor					*pTypeDescriptor;
	_RTTIClassHierarchyDescriptor	*pClassDescriptor;
#endif
	} _RTTICompleteObjectLocator;
#endif // WANT_NO_TYPES

#define COL_SIGNATURE(col)			((col).signature)
#define COL_OFFSET(col)				((col).offset)
#define COL_CDOFFSET(col)			((col).cdOffset)
#define COL_PTD(col)				((col).pTypeDescriptor)
#define COL_PCHD(col)				((col).pClassDescriptor)
#if defined(_M_IA64) || defined(_M_AMD64)
#define COL_PTD_IB(col,ib)			((TypeDescriptor*)((ib) + (col).pTypeDescriptor))
#define COL_PCHD_IB(col,ib)			((_RTTIClassHierarchyDescriptor*)((ib) + (col).pClassDescriptor))
#endif

#ifdef BUILDING_TYPESRC_C
//
// Type of the result of __RTtypeid and internal applications of typeid().
// This also introduces the tag "type_info" as an incomplete type.
//

typedef const class type_info &__RTtypeidReturnType;

//
// Declaration of CRT entrypoints, as seen by the compiler.  Types are 
// simplified so as to avoid type matching hassles.
//

#ifndef THROWSPEC
#if _MSC_VER >= 1300
#define THROWSPEC(_ex) throw _ex
#else
#define THROWSPEC(_ex)
#endif
#endif

// Perform a dynamic_cast on obj. of polymorphic type
extern "C" PVOID __cdecl __RTDynamicCast (
								PVOID,				// ptr to vfptr
								LONG,				// offset of vftable
								PVOID,				// src type
								PVOID,				// target type
								BOOL) THROWSPEC((...)); // isReference

// Perform 'typeid' on obj. of polymorphic type
extern "C" PVOID __cdecl __RTtypeid (PVOID)  THROWSPEC((...));	// ptr to vfptr

// Perform a dynamic_cast from obj. of polymorphic type to void*
extern "C" PVOID __cdecl __RTCastToVoid (PVOID)  THROWSPEC((...)); // ptr to vfptr
#endif

#if (defined(_M_IA64) || defined(_M_AMD64)) || defined(VERSP_IA64)	/*IFSTRIP=IGN*/
#pragma pack(pop, rttidata)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\langapi\include\ehdata.h ===
/***
*ehdata.h -
*
*	Copyright (c) 1993-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Declare misc. types, macros, etc. for implementation
*	of C++ Exception Handling for the run-time and the compiler.
*	Hardware independent, assumes Windows NT.
*
* Portions of this header file can be disabled by defining the following
* macros:
*	_EHDATA_NOHEADERS - suppresses inclusion of standard header files
*		If this is specified, then appropriate typedefs or macros must
*		be provided by some other means.
*	_EHDATA_NOTHROW - suppresses definitions used only to describe a throw
*	_EHDATA_NOFUNCINFO - suppresses definitions for the frame descriptor
*	_EHDATA_NONT - suppresses definitions of our version of NT's stuff
*
* Other conditional compilation macros:
*    CC_EXPLICITFRAME - if true, representation of registration node includes
*	the value of the frame-pointer for that frame, making the location
*	of the registration node on the frame flexible.  This is intended
*	primarily for early testing.
*
*       [Internal]
*
*Revision History:
*       05-20-93  BS	Module Created.
*	03-01-94  CFW	Remove CONTEXT def for x86 for TiborL.
*	03-03-94  TL	Mips (_M_MRX000 >= 4000) changes
*	09-02-94  SKS	This header file added.
*	09-12-94  GJF	Merged in changes from/for DEC (Al Doser, dated 6/20,
*			and Bill Baxter, dated 6/28).
*	11-06-94  GJF	Changed pack pragma to 8 byte alignment.
*       02-14-95  CFW   Clean up Mac merge.
*       03-22-95  PML   Add const for read-only structs
*       03-29-95  CFW   Add error message to internal headers.
*	04-14-95  JWM	Added EH_ABORT_FRAME_UNWIND_PART for EH/SEH exception handling.
*	04-20-95  TGL	Added iFrameNestLevel field to MIPS FuncInfo
*	04-27-95  JWM	EH_ABORT_FRAME_UNWIND_PART now #ifdef ALLOW_UNWIND_ABORT.
*	06-08-95  JWM	Merged CRT version of ehdata.h into langapi source.
*	01-25-00  GB	Declared _CxxThrowException __declspec(noreturn)
*	02-08-00  GB	Added HT_ISCOMPLUSEH
*	03-27-00  PML	Remove CC_P7_SOFT25, which is now on permanently.
*	09-20-00  GB	Add __cdecl to URT C++ EH support routines (vs7#89576)
*	09-18-01  GB	Added Support for ExceptionSpecification. Changes mainly made by Arturl.
*       09-20-01  PML   Buildfix - can't rename EH_MAGIC_NUMBER1, call the new
*                       code EH_MAGIC_NUMBER2 instead.
*
****/

#ifndef _INC_EHDATA
#define _INC_EHDATA

#ifdef ONLY_VALUES
#define _EHDATA_NOHEADERS
#endif

#ifndef _CRTBLD
#ifndef _VC_VER_INC
#ifdef _M_ALPHA
#include "vcver.h"
#else
#include "..\include\vcver.h"
#endif
#endif
#endif /* _CRTBLD */


#if defined(_M_IX86) && _M_IX86 >= 300 /*IFSTRIP=IGN*/
# ifndef CC_EXPLICITFRAME
#  define CC_EXPLICITFRAME	0	// If non-zero, we're using a hack version of the
								// registration node.
# endif
#endif

#ifndef _EHDATA_NOHEADERS
#include <stddef.h>
#include <excpt.h>
#if defined(_WIN32)
#include <windows.h>
#else
#include <nowin.h>
#endif
#endif /* _EHDATA_NOHEADERS */

#pragma pack(push, ehdata, 4)

#define EH_EXCEPTION_NUMBER	('msc' | 0xE0000000)	// The NT Exception # that we use
#define EH_MAGIC_NUMBER1		0x19930520	// latest magic # in thrown object
#define EH_MAGIC_NUMBER2		0x19930521	// latest magic # in func info for exception specs
							// As magic numbers increase, we have to keep track of
							// the versions that we are backwards compatible with.

#if EH_MAGIC_NUMBER2 <= EH_MAGIC_NUMBER1
#error new magic number must be greater than the old one
#endif

#if (EH_MAGIC_NUMBER1 & 0xE0000000) || (EH_MAGIC_NUMBER2 & 0xE0000000)
#error magic number too big -- must fit into 29 bits
#endif

#define EH_MAGIC_HAS_ES	EH_MAGIC_NUMBER2	// Magic number is greater or equal than that 
											// indicates presence of exception specification

#if defined(_M_IA64) || defined(_M_AMD64)
#define EH_EXCEPTION_PARAMETERS 4			// Number of parameters in exception record
#else
#define EH_EXCEPTION_PARAMETERS 3			// Number of parameters in exception record
#endif

#ifdef ALLOW_UNWIND_ABORT
#define EH_ABORT_FRAME_UNWIND_PART EH_EXCEPTION_NUMBER+1
#endif

#define EH_EMPTY_STATE	-1

#ifndef ONLY_VALUES

//
// PMD - Pointer to Member Data: generalized pointer-to-member descriptor
//

typedef struct PMD
{
#if defined(_WIN64)	 /*IFSTRIP=IGN*/
	__int32		mdisp;		// Offset of intended data within base
	__int32		pdisp;		// Displacement to virtual base pointer
	__int32		vdisp;		// Index within vbTable to offset of base
#else
	ptrdiff_t	mdisp;		// Offset of intended data within base
	ptrdiff_t	pdisp;		// Displacement to virtual base pointer
	ptrdiff_t	vdisp;		// Index within vbTable to offset of base
#endif
	} PMD;

//
// PMFN - Pointer to Member Function
//			M00REVIEW: we may need something more than this, but this will do for now.
//

#ifndef WANT_NO_TYPES
#if defined(_WIN64)	 /*IFSTRIP=IGN*/
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_IA64)	/*IFSTRIP=IGN*/
typedef	__int32	PMFN;					// Image relative offset of Member Function
#else
typedef void (* __ptr64 PMFN)(void* __ptr64);
#endif
#else
typedef void (*PMFN)(void);
#endif
#endif // WANT_NO_TYPES

//
// TypeDescriptor - per-type record which uniquely identifies the type.
//
// Each type has a decorated name which uniquely identifies it, and a hash
// value which is computed by the compiler.  The hash function used is not
// important; the only thing which is essential is that it be the same for
// all time.
//
// The special type '...' (ellipsis) is represented by a null name.
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning

#if defined(_M_ALPHA64) || defined(_M_IA64) || defined(VERSP_IA64) || defined(_M_AMD64)
#pragma pack(push, TypeDescriptor, 8)
#endif

#ifndef WANT_NO_TYPES
typedef struct TypeDescriptor
{
#if defined(_WIN64) /*IFSTRIP=IGN*/
	const void * __ptr64	pVFTable;	// Field overloaded by RTTI
	void * __ptr64			spare;		// reserved, possible for RTTI
#else	// _WIN64
#if defined(_RTTI)
	const void *	pVFTable;	// Field overloaded by RTTI
#else
	DWORD	hash;			// Hash value computed from type's decorated name
#endif
	void *	spare;			// reserved, possible for RTTI
#endif	// _WIN64
	char	name[];			// The decorated name of the type; 0 terminated.
	} TypeDescriptor;
#endif // WANT_NO_TYPES

#if defined(_M_ALPHA64) || defined(_M_IA64) || defined(VERSP_IA64) || defined(_M_AMD64)
#pragma pack(pop, TypeDescriptor)
#endif
#pragma warning(default:4200)

#define TD_HASH(td)		((td).hash)
#define TD_NAME(td)		((td).name)

#define TD_IS_TYPE_ELLIPSIS(td) ((td == NULL) || (TD_NAME(*td)[0] == '\0'))


#ifndef _EHDATA_NOTHROW

/////////////////////////////////////////////////////////////////////////////
//
// Description of the thrown object.  (M00REVIEW: not final)
//
// This information is broken down into three levels, to allow for maximum
// comdat folding (at the cost of some extra pointers).
//
// ThrowInfo is the head of the description, and contains information about
// 				the particular variant thrown.
// CatchableTypeArray is an array of pointers to type descriptors.  It will
//				be shared between objects thrown by reference but with varying
//				qualifiers.
// CatchableType is the description of an individual type, and how to effect
//				the conversion from a given type.
//
//---------------------------------------------------------------------------


//
// CatchableType - description of a type that can be caught.
//
// Note:  although isSimpleType can be part of ThrowInfo, it is more
//		  convenient for the run-time to have it here.
//

#ifndef WANT_NO_TYPES
typedef const struct _s_CatchableType {
	unsigned int	properties;				// Catchable Type properties (Bit field)
#if defined(_WIN64) /*IFSTRIP=IGN*/
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_IA64)	/*IFSTRIP=IGN*/
	__int32			pType;					// Image relative offset of TypeDescriptor
#else
	TypeDescriptor * __ptr64 pType;			// Pointer to the type descriptor for this type
#endif
#else
	TypeDescriptor *pType;					// Pointer to the type descriptor for this type
#endif
	PMD 			thisDisplacement;		// Pointer to instance of catch type within
											//		thrown object.
	int				sizeOrOffset;			// Size of simple-type object or offset into
											//  buffer of 'this' pointer for catch object
	PMFN			copyFunction;			// Copy constructor or CC-closure
} CatchableType;
#endif // WANT_NO_TYPES

#define CT_IsSimpleType			0x00000001		// type is a simple type
#define CT_ByReferenceOnly		0x00000002		// type must be caught by reference
#define CT_HasVirtualBase		0x00000004		// type is a class with virtual bases

#define CT_PROPERTIES(ct)	((ct).properties)
#if defined(_M_IA64) || defined(_M_AMD64)
#define CT_PTD_IB(ct,ib)		((TypeDescriptor *)((ib) + (ct).pType))
#define CT_COPYFUNC_IB(ct,ib)	((void (* __ptr64)(void* __ptr64))((ib) + (ct).copyFunction))
#else
#define CT_PTD(ct)			((ct).pType)
#define CT_COPYFUNC(ct)		((ct).copyFunction)
#endif
#define CT_THISDISP(ct)		((ct).thisDisplacement)
#define CT_SIZE(ct)			((ct).sizeOrOffset)
#define CT_OFFSET(ct)		((ct).sizeOrOffset)
#define CT_HASH(ct)			(TD_HASH(*CT_PTD(ct)))
#define CT_NAME(ct)			(TD_NAME(*CT_PTD(ct)))

#define SET_CT_ISSIMPLETYPE(ct)		(CT_PROPERTIES(ct) |= CT_IsSimpleType)
#define SET_CT_BYREFONLY(ct)		(CT_PROPERTIES(ct) |= CT_ByReferenceOnly)
#define SET_CT_HASVB(ct)			(CT_PROPERTIES(ct) |= CT_HasVirtualBase)

#define CT_ISSIMPLETYPE(ct)			(CT_PROPERTIES(ct) & CT_IsSimpleType)		// Is it a simple type?
#define CT_BYREFONLY(ct)			(CT_PROPERTIES(ct) & CT_ByReferenceOnly)	// Must it be caught by reference?
#define CT_HASVB(ct)				(CT_PROPERTIES(ct) & CT_HasVirtualBase)		// Is this type a class with virtual bases?

//
// CatchableTypeArray - array of pointers to catchable types, with length
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning
#ifndef WANT_NO_TYPES
typedef const struct _s_CatchableTypeArray {
	int	nCatchableTypes;
#if defined(_WIN64) /*IFSTRIP=IGN*/
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_IA64)	/*IFSTRIP=IGN*/
	__int32			arrayOfCatchableTypes[];	// Image relative offset of Catchable Types
#else
	CatchableType	* __ptr64 arrayOfCatchableTypes[];
#endif
#else
	CatchableType	*arrayOfCatchableTypes[];
#endif
	} CatchableTypeArray;
#endif // WANT_NO_TYPES
#pragma warning(default:4200)

//
// ThrowInfo - information describing the thrown object, staticly built
// at the throw site.
//
// pExceptionObject (the dynamic part of the throw; see below) is always a
// reference, whether or not it is logically one.  If 'isSimpleType' is true,
// it is a reference to the simple type, which is 'size' bytes long.  If
// 'isReference' and 'isSimpleType' are both false, then it's a UDT or
// a pointer to any type (ie pExceptionObject points to a pointer).  If it's
// a pointer, copyFunction is NULL, otherwise it is a pointer to a copy
// constructor or copy constructor closure.
//
// The pForwardCompat function pointer is intended to be filled in by future
// versions, so that if say a DLL built with a newer version (say C10) throws,
// and a C9 frame attempts a catch, the frame handler attempting the catch (C9)
// can let the version that knows all the latest stuff do the work.
//

#ifndef WANT_NO_TYPES
typedef const struct _s_ThrowInfo {
	unsigned int	attributes;			// Throw Info attributes (Bit field)
	PMFN			pmfnUnwind;			// Destructor to call when exception
										// has been handled or aborted.

#if defined(_WIN64) /*IFSTRIP=IGN*/
#if (defined(_M_IA64) || defined(_M_AMD64)) && !defined(VERSP_IA64)	/*IFSTRIP=IGN*/
	__int32			pForwardCompat;		// Image relative offset of Forward compatibility frame handler
	__int32			pCatchableTypeArray;// Image relative offset of CatchableTypeArray
#else
	int	(__cdecl* __ptr64 pForwardCompat)(...);	// Forward compatibility frame handler
	CatchableTypeArray	* __ptr64 pCatchableTypeArray;	// Pointer to list of pointers to types.
#endif
#else
	int	(__cdecl*pForwardCompat)(...);	// Forward compatibility frame handler
	CatchableTypeArray	*pCatchableTypeArray;	// Pointer to list of pointers to types.
#endif
} ThrowInfo;
#endif // WANT_NO_TYPES

#define TI_IsConst			0x00000001		// thrown object has const qualifier
#define TI_IsVolatile		0x00000002		// thrown object has volatile qualifier
#define TI_IsUnaligned		0x00000004		// thrown object has unaligned qualifier

#define THROW_ATTRS(t)			((t).attributes)
#if defined(_M_IA64) || defined(_M_AMD64)
#define THROW_UNWINDFUNC_IB(t,ib)		((void (* __ptr64)(void* __ptr64))((ib) + (t).pmfnUnwind))
#define THROW_FORWARDCOMPAT_IB(t,ib)	((int(__cdecl * __ptr64)(...))((ib) + (t).pForwardCompat))
#define THROW_CTARRAY_IB(t,ib)			((CatchableTypeArray*)((ib) + (t).pCatchableTypeArray))
#define THROW_COUNT_IB(t,ib)			(THROW_CTARRAY_IB(t,ib)->nCatchableTypes)
#define THROW_CTLIST_IB(t,ib)			(THROW_CTARRAY_IB(t,ib)->arrayOfCatchableTypes)
#else
#define THROW_FORWARDCOMPAT(t)	((t).pForwardCompat)
#define THROW_COUNT(t)			((t).pCatchableTypeArray->nCatchableTypes)
#define THROW_CTLIST(t)			((t).pCatchableTypeArray->arrayOfCatchableTypes)
#endif
#define THROW_UNWINDFUNC(t)		((t).pmfnUnwind)
#define THROW_PCTLIST(t)		(&THROW_CTLIST(t))
#define THROW_CT(t, n)			(*THROW_CTLIST(t)[n])
#define THROW_PCT(t, n)			(THROW_CTLIST(t)[n])

#define SET_TI_ISCONST(t)		(THROW_ATTRS(t) |= TI_IsConst)		// Is the object thrown 'const' qualified
#define SET_TI_ISVOLATILE(t)	(THROW_ATTRS(t) |= TI_IsVolatile)	// Is the object thrown 'volatile' qualified
#define SET_TI_ISUNALIGNED(t)	(THROW_ATTRS(t) |= TI_IsUnaligned)	// Is the object thrown 'unaligned' qualified

#define THROW_ISCONST(t)		(THROW_ATTRS(t) & TI_IsConst)
#define THROW_ISVOLATILE(t)		(THROW_ATTRS(t) & TI_IsVolatile)
#define THROW_ISUNALIGNED(t)	(THROW_ATTRS(t) & TI_IsUnaligned)

//
// Here's how to throw:
// M00HACK: _ThrowInfo is the name of the type that is 'pre-injected' into the
// compiler; since this prototype is known to the FE along with the pre-injected
// types, it has to match exactly.
//
#if _MSC_VER >= 900 /*IFSTRIP=IGN*/
__declspec (noreturn) extern "C" void __stdcall _CxxThrowException(void* pExceptionObject, _ThrowInfo* pThrowInfo);
#else
// If we're not self-building, we need to use the name that we defined above.
__declspec (noreturn) extern "C" void __stdcall _CxxThrowException(void* pExceptionObject, ThrowInfo* pThrowInfo);
#endif

#ifndef WANT_NO_TYPES
extern "C" int __cdecl __CxxExceptionFilter(void*, void*, int, void *);

// Returns true if the object is really a C++ exception
// If it is, stores the previous exception in *storage, and saves the current one
// This is needed to keep track of the current exception object (used for rethrow & destruction)
extern "C" int __cdecl __CxxRegisterExceptionObject(void *exception, void *storage);

// Returns true if exception is a C++ rethrown exception
// This is needed, so Unregister can know whether or not to destroy the object
extern "C" int __cdecl __CxxDetectRethrow(void *exception);

// Returns the byte count of stack space required to store the exception info
extern "C" int __cdecl __CxxQueryExceptionSize(void);

// Pops the current exception, restoring the previous one from *storage
// This detects whether or not the exception object needs to be destroyed
extern "C" void __cdecl __CxxUnregisterExceptionObject(void *storage, int rethrow);

#endif // WANT_NO_TYPES

#endif /* _EHDATA_NOTHROW */


#ifndef _EHDATA_NOFUNCINFO

/////////////////////////////////////////////////////////////////////////////
//
// Describing 'try/catch' blocks:
//
//---------------------------------------------------------------------------

//
// Current state of a function.
// -1 is the 'blank' state, ie there is nothing to unwind, no try blocks active.
//

typedef int __ehstate_t;		// The type of a state index


//
// HandlerType - description of a single 'catch'
//

#ifndef WANT_NO_TYPES
typedef const struct _s_HandlerType {
	unsigned int	adjectives;			// Handler Type adjectives (bitfield)
#if defined(_M_IA64) || defined(_M_AMD64)	 /*IFSTRIP=IGN*/
	__int32			dispType;			// Image relative offset of the corresponding type descriptor
	__int32			dispCatchObj;		// Displacement of catch object from base
	__int32			dispOfHandler;		// Image relative offset of 'catch' code
#if defined(_M_AMD64)
    __int32         dispFrame;          // displacement of address of function frame wrt establisher frame
#endif
#else
	TypeDescriptor	*pType;				// Pointer to the corresponding type descriptor
#if defined(_M_ALPHA64)
	__int32			dispCatchObj;		// Displacement of catch object from base
#else
	ptrdiff_t		dispCatchObj;		// Displacement of catch object from base
#endif
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
	ULONG			frameNestLevel;		// The static nesting level of parent function
#endif
	void *			addressOfHandler;	// Address of 'catch' code
#endif
} HandlerType;
#endif

#define HT_IsConst			0x00000001		// type referenced is 'const' qualified
#define HT_IsVolatile		0x00000002		// type referenced is 'volatile' qualified
#define HT_IsUnaligned		0x00000004		// type referenced is 'unaligned' qualified
#define HT_IsReference		0x00000008		// catch type is by reference
#define HT_IsResumable		0x00000010		// the catch may choose to resume (Reserved)
#define HT_IsComplusEh      0x80000000      // Is handling within complus eh.

#define HT_ADJECTIVES(ht)		((ht).adjectives)
#if defined(_M_IA64) || defined(_M_AMD64)	 /*IFSTRIP=IGN*/
#define HT_PTD_IB(ht,ib)		((TypeDescriptor*)((ib) + (ht).dispType))
#define HT_HANDLER_IB(ht,ib)	((void* __ptr64)((ib) + (ht).dispOfHandler))
#else
#define HT_PTD(ht)				((ht).pType)
#define HT_HANDLER(ht)			((ht).addressOfHandler)
#endif
#define HT_DISPCATCH(ht)		((ht).dispCatchObj)
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
#define HT_FRAMENEST(ht)		((ht).frameNestLevel)
#endif
#define HT_NAME(ht)				(TD_NAME(*HT_PTD(ht)))
#define HT_HASH(ht)				(TD_HASH(*HT_PTD(ht)))
#define HT_IS_TYPE_ELLIPSIS(ht)	TD_IS_TYPE_ELLIPSIS(HT_PTD(ht))

#define SET_HT_ISCONST(ht)		(HT_ADJECTIVES(ht) |= HT_IsConst)
#define SET_HT_ISVOLATILE(ht)	(HT_ADJECTIVES(ht) |= HT_IsVolatile)
#define SET_HT_ISUNALIGNED(ht)	(HT_ADJECTIVES(ht) |= HT_IsUnaligned)
#define SET_HT_ISREFERENCE(ht)	(HT_ADJECTIVES(ht) |= HT_IsReference)
#define SET_HT_ISRESUMABLE(ht)	(HT_ADJECTIVES(ht) |= HT_IsResumable)
#define SET_HT_ISCOMPLUSEH(ht)  (HT_ADJECTIVES(ht) |= HT_IsComplusEh)

#define HT_ISCONST(ht)			(HT_ADJECTIVES(ht) & HT_IsConst)		// Is the type referenced 'const' qualified
#define HT_ISVOLATILE(ht)		(HT_ADJECTIVES(ht) & HT_IsVolatile)		// Is the type referenced 'volatile' qualified
#define HT_ISUNALIGNED(ht)		(HT_ADJECTIVES(ht) & HT_IsUnaligned)	// Is the type referenced 'unaligned' qualified
#define HT_ISREFERENCE(ht)		(HT_ADJECTIVES(ht) & HT_IsReference)	// Is the catch type by reference
#define HT_ISRESUMABLE(ht)		(HT_ADJECTIVES(ht) & HT_IsResumable)	// Might the catch choose to resume (Reserved)
#define HT_ISCOMPLUSEH(ht)      (HT_ADJECTIVES(ht) & HT_IsComplusEh)

//
// HandlerMapEntry - associates a handler list (sequence of catches) with a
//	range of eh-states.
//

#ifndef WANT_NO_TYPES
typedef const struct _s_TryBlockMapEntry {
	__ehstate_t	tryLow;				// Lowest state index of try
	__ehstate_t	tryHigh;			// Highest state index of try
#if !defined(_M_ALPHA)
	__ehstate_t	catchHigh;			// Highest state index of any associated catch
#endif
	int			nCatches;			// Number of entries in array
#if defined(_M_IA64) || defined(_M_AMD64)	/*IFSTRIP=IGN*/
	__int32		dispHandlerArray;	// Image relative offset of list of handlers for this try
#else
	HandlerType *pHandlerArray;		// List of handlers for this try
#endif
} TryBlockMapEntry;
#endif // WANT_NO_TYPES

#define TBME_LOW(hm)		((hm).tryLow)
#define TBME_HIGH(hm)		((hm).tryHigh)
#define TBME_CATCHHIGH(hm)	((hm).catchHigh)
#define TBME_NCATCHES(hm)	((hm).nCatches)
#if defined(_M_IA64) || defined(_M_AMD64)	/*IFSTRIP=IGN*/
#define TBME_PLIST(hm,ib)	((HandlerType*)((ib) + (hm).dispHandlerArray))
#define TBME_CATCH(hm,n,ib)	(TBME_PLIST(hm,ib)[n])
#define TBME_PCATCH(hm,n,ib)(&(TBME_PLIST(hm,ib)[n]))
#else
#define TBME_PLIST(hm)		((hm).pHandlerArray)
#define TBME_CATCH(hm, n)	(TBME_PLIST(hm)[n])
#define TBME_PCATCH(hm, n)	(&(TBME_PLIST(hm)[n]))
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Description of the function:
//
//---------------------------------------------------------------------------

//
// UnwindMapEntry - Description of each state transition for unwinding
//	the stack (ie destructing objects).
//
// The unwind map is an array, indexed by current state.  Each entry specifies
// the state to go to during unwind, and the action required to get there.
// Note that states are represented by a signed integer, and that the 'blank'
// state is -1 so that the array remains 0-based (because by definition there
// is never any unwind action to be performed from state -1).  It is also
// assumed that state indices will be dense, ie that there will be no gaps of
// unused state indices in a function.
//

typedef const struct _s_UnwindMapEntry {
	__ehstate_t		toState;			// State this action takes us to
#if defined(_M_IA64) || defined(_M_AMD64)	/*IFSTRIP=IGN*/
	__int32			action;				// Image relative offset of funclet
#else
	void			(*action)(void);	// Funclet to call to effect state change
#endif
} UnwindMapEntry;

#define UWE_TOSTATE(uwe)	((uwe).toState)
#if defined(_M_IA64) || defined(_M_AMD64)
#define UWE_ACTION_IB(uwe,ib)	((void (*__ptr64)(void))((ib) + (uwe).action))
#else
#define UWE_ACTION(uwe)			((uwe).action)
#endif

#if _M_MRX000 >= 4000 || defined(_M_MPPC) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)	 /*IFSTRIP=IGN*/
typedef struct IptoStateMapEntry {
#if defined(_M_IA64) || defined(_M_AMD64)	/*IFSTRIP=IGN*/
	__int32		Ip;		// Image relative offset of IP
#else
	ULONG		Ip;
#endif
	__ehstate_t	State;
} IptoStateMapEntry;
#endif

#ifndef WANT_NO_TYPES
typedef const struct _s_ESTypeList
{
	int nCount;					// how many types are there
	HandlerType *pTypeArray;	// List of types in exception specification
}ESTypeList;

#define EST_COUNT(x)    ((x)->nCount)
#define EST_ARRAY(x,n)  (&((x)->pTypeArray[n]))
#endif // WANT_NO_TYPES

//
// FuncInfo - all the information that describes a function with exception
//	handling information.
//

// bbtFlags values
#define BBT_UNIQUE_FUNCINFO 1

#ifndef WANT_NO_TYPES
typedef const struct _s_FuncInfo
{
    unsigned int		magicNumber:29;		// Identifies version of compiler
    unsigned int        bbtFlags:3;         // flags that may be set by BBT processing
	__ehstate_t			maxState;			// Highest state number plus one (thus
											// number of entries in unwind map)
#if defined(_M_IA64) || defined (_M_AMD64)	/*IFSTRIP=IGN*/
	__int32				dispUnwindMap;		// Image relative offset of the unwind map
	unsigned int		nTryBlocks;			// Number of 'try' blocks in this function
	__int32				dispTryBlockMap;	// Image relative offset of the handler map
	unsigned int		nIPMapEntries;		// # entries in the IP-to-state map. NYI (reserved)
	__int32				dispIPtoStateMap;	// Image relative offset of the IP to state map
	__int32				dispUwindHelp;		// Displacement of unwind helpers from base
#else
	UnwindMapEntry		*pUnwindMap;		// Where the unwind map is
	unsigned int		nTryBlocks;			// Number of 'try' blocks in this function
	TryBlockMapEntry	*pTryBlockMap;		// Where the handler map is
#if defined(_M_ALPHA)
    signed int          EHContextDelta;     // Frame offset of EHContext record
#endif
	unsigned int		nIPMapEntries;		// # entries in the IP-to-state map. NYI (reserved)
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
	IptoStateMapEntry	*pIPtoStateMap;     // An IP to state map..
	ptrdiff_t			dispUnwindHelp;		// Displacement of unwind helpers from base
	int					iTryBlockIndex;		// Used by catch functions only
	int					iFrameNestLevel;	// The static nesting level of parent function
#elif defined(_M_MPPC) || defined(_M_PPC)
	IptoStateMapEntry	*pIPtoStateMap;		// An IP to state map..
#else
	void				*pIPtoStateMap;		// An IP to state map.  NYI (reserved).
#endif
#endif
	ESTypeList			*pESTypeList;		// List of types for exception specifications
} FuncInfo;
#endif // WANT_NO_TYPES

#define FUNC_MAGICNUM(fi)			((fi).magicNumber)
#define FUNC_MAXSTATE(fi)		((fi).maxState)
#define FUNC_NTRYBLOCKS(fi)		((fi).nTryBlocks)
#define FUNC_NIPMAPENT(fi)		((fi).nIPMapEntries)
#define FUNC_ESTYPES(fi)		((fi).pESTypeList)
#define FUNC_PESTYPES(fi)		(FUNC_ESTYPES(*fi))
#if defined(_M_IA64) || defined (_M_AMD64)
#define FUNC_PUNWINDMAP(fi,ib)	((UnwindMapEntry*)((ib) + (fi).dispUnwindMap))
#define FUNC_PHANDLERMAP(fi,ib)	((TryBlockMapEntry*)((ib) + (fi).dispTryBlockMap))
#define FUNC_IPMAP(fi,ib)		((IptoStateMapEntry*)((ib) + (fi).dispIPtoStateMap))
#define FUNC_UNWIND(fi,st,ib)	(FUNC_PUNWINDMAP(fi,ib)[st])
#define FUNC_PUNWIND(fi,st,ib)	(&FUNC_UNWIND(fi,st,ib))
#define FUNC_TRYBLOCK(fi,n,ib)	(FUNC_PHANDLERMAP(fi,ib)[n])
#define FUNC_PTRYBLOCK(fi,n,ib)	(&FUNC_TRYBLOCK(fi,n,ib))
#else
#define FUNC_PUNWINDMAP(fi)		((fi).pUnwindMap)
#define FUNC_PHANDLERMAP(fi)	((fi).pTryBlockMap)
#define FUNC_IPMAP(fi)			((fi).pIPtoStateMap)
#define FUNC_UNWIND(fi, st)		((fi).pUnwindMap[st])
#define FUNC_PUNWIND(fi, st)	(&FUNC_UNWIND(fi, st))
#define FUNC_TRYBLOCK(fi,n)		((fi).pTryBlockMap[n])
#define FUNC_PTRYBLOCK(fi,n)	(&FUNC_TRYBLOCK(fi, n))
#endif
#if defined(_M_ALPHA)
#define FUNC_EHCONTEXTDELTA(fi) ((fi).EHContextDelta)
#endif
#if _M_MRX000 >= 4000		 /*IFSTRIP=IGN*/
#define FUNC_IPTOSTATE(fi,n)	((fi).pIPtoStateMap[n])
#define FUNC_PIPTOSTATE(fi,n)	(&FUNC_IPTOSTATE(fi,n))
#define FUNC_DISPUNWINDHELP(fi)	((fi).dispUnwindHelp)
#define FUNC_TRYBLOCKINDEX(fi)	((fi).iTryBlockIndex)
#define FUNC_FRAMENEST(fi)		((fi).iFrameNestLevel)
#elif defined(_M_MPPC) || defined(_M_PPC)
#define FUNC_IPTOSTATE(fi,n)	((fi).pIPtoStateMap[n])
#define FUNC_PIPTOSTATE(fi,n)	(&FUNC_IPTOSTATE(fi,n))
#elif defined(_M_IA64) || defined (_M_AMD64)
#define FUNC_IPTOSTATE(fi,n,ib)	(FUNC_IPMAP(fi,ib)[n])
#define FUNC_PIPTOSTATE(fi,n,ib)(&FUNC_IPTOSTATE(fi,n,ib))
#define FUNC_DISPUNWINDHELP(fi)	((fi).dispUwindHelp)
#else
#define FUNC_IPTOSTATE(fi,n) 	__ERROR_NYI__
#endif

#endif /* _EHDATA_NOFUNCINFO */

#ifndef _EHDATA_NONT

/////////////////////////////////////////////////////////////////////////////
//
// Data types that are variants of data used by NT (and Chicago) to manage
// exception handling.
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//
// A stack registration node (i386 only)
//

#if defined(_M_IX86) && _M_IX86 >= 300 /*IFSTRIP=IGN*/
struct EHRegistrationNode {
	/* void *			stackPtr */		// Stack ptr at entry to try (below address point)
	EHRegistrationNode	*pNext;			// Next node in the chain
	void *				frameHandler;	// The handler function for this frame
	__ehstate_t			state;			// The current state of this function
#if CC_EXPLICITFRAME
	void *				frame;			// Value of ebp for this frame
#endif
};

#if !CC_EXPLICITFRAME
				// Cannonical offset
# define FRAME_OFFSET	sizeof(EHRegistrationNode)
#endif

#define PRN_NEXT(prn)		((prn)->pNext)
#define PRN_HANDLER(prn)	((prn)->frameHandler)
#define PRN_STATE(prn)		((prn)->state)
#define PRN_STACK(prn)		(((void**)(prn))[-1])
#if CC_EXPLICITFRAME
# define PRN_FRAME(prn)		((prn)->frame)
#else
# define PRN_FRAME(prn)		((void*)(((char*)prn) + FRAME_OFFSET))
#endif

typedef void DispatcherContext;		// Meaningless on Intel

#elif _M_MRX000 >= 4000 /*IFSTRIP=IGN*/
//
// On MIPS we don't have a registration node, just a pointer to the stack frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0
#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)();
    PVOID HandlerData;
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;
    PCONTEXT ContextRecord;
} DispatcherContext;					// changed the case of the name to conform to EH conventions

#elif defined(_M_IA64) /*IFSTRIP=IGN*/

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

#if !defined(_NTSUBSET_)
typedef struct _FRAME_POINTERS {
    __int64 MemoryStackFp;                     // memory stack frame pointer
    __int64 BackingStoreFp;                    // backing store frame pointer
} FRAME_POINTERS, *PFRAME_POINTERS;

typedef struct _UNWIND_INFO {
    unsigned __int16 Version;                  // Version Number
    unsigned __int16 Flags;                    // Flags
    unsigned __int32 DataLength;               // Length of Descriptor Data
} UNWIND_INFO, *PUNWIND_INFO;

#ifndef _WINNT_
typedef struct _RUNTIME_FUNCTION {             
    unsigned __int32 BeginAddress;             // image relative offset to start of function
    unsigned __int32 EndAddress;               // image relative offset to end of function
    unsigned __int32 UnwindInfoAddress;        // image relative offset to unwind info block
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif
#endif

typedef struct _xDISPATCHER_CONTEXT {
    FRAME_POINTERS EstablisherFrame;
    __int64 ControlPc;
    __int64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
    PCONTEXT ContextRecord;
} DispatcherContext;					// changed the case of the name to conform to EH conventions


//
// On P7 we don't have a registration node, just a pointer to the stack frame base
//
typedef FRAME_POINTERS EHRegistrationNode;

#elif defined(_M_AMD64)/*IFSTRIP=IGN*/

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

#if !defined(_NTSUBSET_)
typedef union _UNWIND_CODE {
    struct {
        unsigned char CodeOffset;
        unsigned char UnwindOp : 4;
        unsigned char OpInfo : 4;
    };
    unsigned short FrameOffset;
} UNWIND_CODE, *PUNWIND_CODE;
typedef struct _UNWIND_INFO {
    unsigned char Version : 3;                 // Version Number
    unsigned char Flags   : 5;                 // Flags
    unsigned char SizeOfProlog;
    unsigned char CountOfCodes;
    unsigned FrameRegister : 4;
    unsigned FrameOffset   : 4;
    UNWIND_CODE UnwindCode[1];
/*  UNWIND_CODE MoreUnwindCode[((CountOfCodes+1)&~1)-1];
 *  union {
 *      OPTIONAL ULONG ExceptionHandler;
 *      OPTIONAL ULONG FunctionEntry;
 *  };
 *  OPTIONAL ULONG ExceptionData[];
 */
} UNWIND_INFO, *PUNWIND_INFO;

#ifndef _WINNT_
typedef struct _RUNTIME_FUNCTION {             
    unsigned __int32 BeginAddress;             // image relative offset to start of function
    unsigned __int32 EndAddress;               // image relative offset to end of function
    unsigned __int32 UnwindInfoAddress;        // image relative offset to unwind info block
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif
#endif

typedef struct _xDISPATCHER_CONTEXT {
    __int64 ControlPc;
    __int64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG_PTR EstablisherFrame;
    ULONG64 TargetIp;
    PCONTEXT ContextRecord;
    PVOID LanguageHandler;
    PVOID HandlerData;
    PVOID HistoryTable;
} DispatcherContext;					// changed the case of the name to conform to EH conventions

//
// On P7 we don't have a registration node, just a pointer to the stack frame base
//
typedef ULONG_PTR EHRegistrationNode;

#elif defined(_M_ALPHA)
//
// On Alpha we don't have a registration node,
//     just a pointer to the stack frame base
//
typedef ULONG_PTR EHRegistrationNode;

#define PRN_NEXT(prn)           __ERROR__
#define PRN_HANDLER(prn)        __ERROR__
#define PRN_STATE(prn)          __ERROR__
#define PRN_STACK(prn)          __ERROR__
#define PRN_FRAME(prn)          __ERROR__

#if defined(_M_ALPHA64)	 /*IFSTRIP=IGN*/
#pragma pack(push, EHContext, 8)
#endif

#define FRAME_OFFSET            0
#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG_PTR BeginAddress;
    ULONG_PTR EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)();
    PVOID HandlerData;    // ptr to FuncInfo record
    ULONG_PTR PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG_PTR ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG_PTR EstablisherFrame;  // Virtual Frame Pointer
    PCONTEXT ContextRecord;
} DispatcherContext;            // changed the case of the name to conform to EH conventions

//
// _EHCONTEXT is a struct built in the frame by the compiler.
// On entry to a function, compiler generated code stores the
// address of the base of the fixed frame area (the so-called
// Real Frame Pointer) into the Rfp. On every state transition,
// compiler generated code stores the current state index into
// the State field.
//
// The FuncInfo record for the function contains the offset of
// the _EHCONTEXT record from the Virtual Frame Pointer - a
// pointer to the highest address of the frame so this offset
// is negative (frames grow down in the address space).
//
typedef struct _EHCONTEXT {
    ULONG State;
    PVOID Rfp;
} EHContext;
#if defined(_M_ALPHA64)	 /*IFSTRIP=IGN*/
#pragma pack(pop, EHContext)
#endif

#define VIRTUAL_FP(pDC) (pDC->EstablisherFrame)

#define REAL_FP(VirtualFP, pFuncInfo)           \
    (((EHContext *)((char *)VirtualFP           \
     + pFuncInfo->EHContextDelta)) -> Rfp)

#define EH_STATE(VirtualFP, pFuncInfo)          \
    (((EHContext *)((char *)VirtualFP           \
     + pFuncInfo->EHContextDelta)) -> State)

#elif defined(_M_M68K)
struct EHRegistrationNode {
/*	void * 				_sp;			// The stack pointer for the entry of try/catch	*/
	void *				frameHandler;	// The handler function for this frame
	__ehstate_t			state;			// The current state of this function
};

#define PRN_HANDLER(prn)	((prn)->frameHandler)
#define PRN_STATE(prn)		((prn)->state)

typedef void DispatcherContext;		// Meaningless on Mac


#elif defined(_M_PPC) || defined(_M_MPPC)
//
// On PowerPC we don't have a registration node, just a pointer to the stack
// frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)(...);
    PVOID HandlerData;
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;
    PCONTEXT ContextRecord;
} DispatcherContext;
    // changed the case of the name to conform to EH conventions

#if defined(_M_MPPC)
typedef struct _ftinfo {
    ULONG dwMagicNumber;                // magic number
    void *pFrameInfo;			// pointer to runtime frame info
    PRUNTIME_FUNCTION rgFuncTable;	// function table
    ULONG cFuncTable;			// number of function entry
    ULONG dwEntryCF;			// address of starting of the code fragment
    ULONG dwSizeCF;			// size of the code fragment
} FTINFO, *PFTINFO;

#define offsFTINFO              64
#endif

#else
#error "Machine not supported"
#endif

/////////////////////////////////////////////////////////////////////////////
//
// The NT Exception record that we use to pass information from the throw to
// the possible catches.
//
// The constants in the comments are the values we expect.
// This is based on the definition of EXCEPTION_RECORD in winnt.h.
//
#if defined(_M_IA64) || defined(_M_ALPHA64)	|| defined(_M_AMD64) /*IFSTRIP=IGN*/
#pragma pack(push, ExceptionRecord, 8)
#endif
#ifndef WANT_NO_TYPES
typedef struct EHExceptionRecord {
	DWORD		ExceptionCode;			// The code of this exception. (= EH_EXCEPTION_NUMBER)
	DWORD		ExceptionFlags;			// Flags determined by NT
    struct _EXCEPTION_RECORD *ExceptionRecord;	// An extra exception record (not used)
    void * 		ExceptionAddress;		// Address at which exception occurred
    DWORD 		NumberParameters;		// Number of extended parameters. (= EH_EXCEPTION_PARAMETERS)
	struct EHParameters {
		DWORD		magicNumber;		// = EH_MAGIC_NUMBER1
		void *		pExceptionObject;	// Pointer to the actual object thrown
		ThrowInfo	*pThrowInfo;		// Description of thrown object
#if defined(_M_IA64) || defined(_M_AMD64)
		void		*pThrowImageBase;	// Image base of thrown object
#endif
		} params;
} EHExceptionRecord;
#endif // WANT_NO_TYPES
#if defined(_M_IA64) || defined(_M_ALPHA64) || defined(_M_AMD64)	 /*IFSTRIP=IGN*/
#pragma pack(pop, ExceptionRecord)
#endif

#define PER_CODE(per)		((per)->ExceptionCode)
#define PER_FLAGS(per)		((per)->ExceptionFlags)
#define PER_NEXT(per)		((per)->ExceptionRecord)
#define PER_ADDRESS(per)	((per)->ExceptionAddress)
#define PER_NPARAMS(per)	((per)->NumberParameters)
#define PER_MAGICNUM(per)	((per)->params.magicNumber)
#define PER_PEXCEPTOBJ(per)	((per)->params.pExceptionObject)
#define PER_PTHROW(per)		((per)->params.pThrowInfo)
#if defined(_M_IA64) || defined(_M_AMD64)
#define PER_PTHROWIB(per)	((per)->params.pThrowImageBase)
#endif
#define PER_THROW(per)		(*PER_PTHROW(per))

#define PER_ISSIMPLETYPE(t)	(PER_THROW(t).isSimpleType)
#define PER_ISREFERENCE(t)	(PER_THROW(t).isReference)
#define PER_ISCONST(t)		(PER_THROW(t).isConst)
#define PER_ISVOLATILE(t)	(PER_THROW(t).isVolatile)
#define PER_ISUNALIGNED(t)	(PER_THROW(t).isUnaligned)
#define PER_UNWINDFUNC(t)	(PER_THROW(t).pmfnUnwind)
#define PER_PCTLIST(t)		(PER_THROW(t).pCatchable)
#define PER_CTLIST(t)		(*PER_PCTLIST(t))

#define PER_IS_MSVC_EH(per)	((PER_CODE(per) == EH_EXCEPTION_NUMBER) && 			\
		 					 (PER_NPARAMS(per) == EH_EXCEPTION_PARAMETERS) &&	\
		 					 ((PER_MAGICNUM(per) == EH_MAGIC_NUMBER1) ||   \
		 					  (PER_MAGICNUM(per) == EH_MAGIC_NUMBER2)))

/////////////////////////////////////////////////////////////////////////////
//
// NT kernel routines and definitions required to implement exception handling:
//
// (from ntxcapi.h, which is not a public header file)
//
//---------------------------------------------------------------------------

#ifndef _NTXCAPI_

// begin_ntddk
//
// Exception flag definitions.
//

// begin_winnt
#define EXCEPTION_NONCONTINUABLE 0x1    // Noncontinuable exception
// end_winnt

// end_ntddk
#define EXCEPTION_UNWINDING 0x2         // Unwind is in progress
#define EXCEPTION_EXIT_UNWIND 0x4       // Exit unwind is in progress
#define EXCEPTION_STACK_INVALID 0x8     // Stack out of limits or unaligned
#define EXCEPTION_NESTED_CALL 0x10      // Nested exception handler call
#define EXCEPTION_TARGET_UNWIND 0x20    // Target unwind in progress
#define EXCEPTION_COLLIDED_UNWIND 0x40  // Collided exception handler call

#define EXCEPTION_UNWIND (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND | \
                          EXCEPTION_TARGET_UNWIND | EXCEPTION_COLLIDED_UNWIND)

#define IS_UNWINDING(Flag) ((Flag & EXCEPTION_UNWIND) != 0)
#define IS_DISPATCHING(Flag) ((Flag & EXCEPTION_UNWIND) == 0)
#define IS_TARGET_UNWIND(Flag) (Flag & EXCEPTION_TARGET_UNWIND)
#define IS_EXIT_UNWIND(Flag) (Flag & EXCEPTION_EXIT_UNWIND)

#if !defined(_M_M68K)
#ifdef __cplusplus
extern "C" {
#endif

void WINAPI
RtlUnwind (
    IN void * TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue
    );

#if defined(_M_IA64) /*IFSTRIP=IGN*/
#define STATUS_LONGJUMP 0x80000026
#define STATUS_UNWIND_CONSOLIDATE 0x80000029L
RtlUnwind2 (
    IN FRAME_POINTERS TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue,
    IN PCONTEXT ContextRecord
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
     unsigned __int64 ControlPc,
     unsigned __int64 *ImageBase,
     unsigned __int64 *TargetGp
    );
#elif defined(_M_AMD64) /*IFSTRIP=IGN*/
#define STATUS_LONGJUMP 0x80000026
#define STATUS_UNWIND_CONSOLIDATE 0x80000029L
RtlUnwind2 (
    IN void * TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue,
    IN PCONTEXT ContextRecord
    );

RtlUnwindEx (
    IN void * TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue,
    IN PCONTEXT ContextRecord,
    IN void *HistoryTable
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
     unsigned __int64 ControlPc,
     unsigned __int64 *ImageBase,
     void             *HistoryTable
    );
VOID
RtlRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    );
#endif

#if defined(_M_ALPHA)
#define STATUS_UNWIND 0xc0000027

void WINAPI
RtlUnwindRfp (
    IN void * TargetRealFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue
    );
#endif

#if defined(_M_PPC)
ULONG WINAPI
RtlVirtualUnwind (
    IN ULONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PULONG EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL,
    IN ULONG LowStackLimit,
    IN ULONG HighStackLimit
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN ULONG ControlPc
    );
#endif

#if defined(_M_MPPC)
ULONG WINAPI
RtlVirtualUnwind (
    IN ULONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PULONG EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL,
    IN ULONG LowStackLimit,
    IN ULONG HighStackLimit
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN PRUNTIME_FUNCTION RuntimeFunction,
    IN ULONG ControlPc,
    IN ULONG Rtoc
    );

VOID
RtlRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    );
#endif

#ifdef __cplusplus
}
#endif
#endif

#endif /* _NTXCAPI_ */

#endif /* _EHDATA_NONT */

#endif /* ONLY_VALUES */

#pragma pack(pop, ehdata)

#endif /* _INC_EHDATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\langapi\undname\undname.h ===
#include <stdlib.h>

#if !defined(_M_I86)
    //  The 32-bit compiler

    #define __far
    #define __near
    #define __pascal
    #define __loadds
#endif


typedef char *        pchar_t;
typedef const char *  pcchar_t;

typedef void * ( __cdecl * Alloc_t )( size_t );
typedef void   ( __cdecl * Free_t  )( void * );
typedef char * ( __cdecl * GetParameter_t  )( long );


#ifdef  __cplusplus
extern "C"
#endif


#ifdef _CRTBLD
_CRTIMP pchar_t __cdecl __unDName (
#else
pchar_t __cdecl unDName (
#endif
                            pchar_t,		// User supplied buffer (or NULL)
                            pcchar_t,		// Input decorated name
                            int,			// Maximum length of user buffer
                            Alloc_t,		// Address of heap allocator
                            Free_t,			// Address of heap deallocator
                            unsigned short	// Feature disable flags
                        );

#ifdef  __cplusplus
extern "C"
#endif

#ifdef _CRTBLD
_CRTIMP pchar_t __cdecl __unDNameEx (
#else
pchar_t __cdecl unDNameEx (
#endif
                            pchar_t,		// User supplied buffer (or NULL)
                            pcchar_t,		// Input decorated name
                            int,			// Maximum length of user buffer
                            Alloc_t,		// Address of heap allocator
                            Free_t,			// Address of heap deallocator
							GetParameter_t,	// Function to get any template parameters
                            unsigned long	// Feature disable flags
                        );
/*
 *  The user may provide a buffer into which the undecorated declaration
 *  is to be placed, in which case, the length field must be specified.
 *  The length is the maximum number of characters (including the terminating
 *  NULL character) which may be written into the user buffer.
 *
 *  If the output buffer is NULL, the length field is ignored, and the
 *  undecorator will allocate a buffer exactly large enough to hold the
 *  resulting declaration.  It is the users responsibility to deallocate
 *  this buffer.
 *
 *  The user may also supply the allocator and deallocator functions if
 *  they wish.  If they do, then all heap actions performed by the routine
 *  will use the provided heap functions.
 *
 *  If the allocator address is NULL, then the routine will default to using
 *  the standard allocator and deallocator functions, 'malloc' and 'free'.
 *
 *  If an error occurs internally, then the routine will return NULL.  If
 *  it was successful, it will return the buffer address provided by the
 *  user, or the address of the buffer allocated on their behalf, if they
 *  specified a NULL buffer address.
 *
 *  If a given name does not have a valid undecoration, the original name
 *  is returned in the output buffer.
 *
 *  Fine selection of a number of undecorator attributes is possible, by
 *  specifying flags (bit-fields) to disable the production of parts of the
 *  complete declaration.  The flags may be OR'ed together to select multiple
 *  disabling of selected fields.  The fields and flags are as follows :-
 */

#define UNDNAME_COMPLETE                (0x0000)    // Enable full undecoration

#define UNDNAME_NO_LEADING_UNDERSCORES  (0x0001)    // Remove leading underscores from MS extended keywords
#define UNDNAME_NO_MS_KEYWORDS          (0x0002)    // Disable expansion of MS extended keywords
#define UNDNAME_NO_FUNCTION_RETURNS     (0x0004)    // Disable expansion of return type for primary declaration
#define UNDNAME_NO_ALLOCATION_MODEL     (0x0008)    // Disable expansion of the declaration model
#define UNDNAME_NO_ALLOCATION_LANGUAGE  (0x0010)    // Disable expansion of the declaration language specifier
  #define   UNDNAME_NO_MS_THISTYPE          (0x0020)    /* NYI */   // Disable expansion of MS keywords on the 'this' type for primary declaration
  #define   UNDNAME_NO_CV_THISTYPE          (0x0040)    /* NYI */   // Disable expansion of CV modifiers on the 'this' type for primary declaration
#define UNDNAME_NO_THISTYPE             (0x0060)    // Disable all modifiers on the 'this' type
#define UNDNAME_NO_ACCESS_SPECIFIERS    (0x0080)    // Disable expansion of access specifiers for members
#define UNDNAME_NO_THROW_SIGNATURES     (0x0100)    // Disable expansion of 'throw-signatures' for functions and pointers to functions
#define UNDNAME_NO_MEMBER_TYPE          (0x0200)    // Disable expansion of 'static' or 'virtual'ness of members
#define UNDNAME_NO_RETURN_UDT_MODEL     (0x0400)    // Disable expansion of MS model for UDT returns
#define UNDNAME_32_BIT_DECODE           (0x0800)    // Undecorate 32-bit decorated names
#define UNDNAME_NAME_ONLY               (0x1000)    // Crack only the name for primary declaration;
                                                    //  return just [scope::]name.  Does expand template params
#define UNDNAME_TYPE_ONLY               (0x2000)    // Input is just a type encoding; compose an abstract declarator
#define UNDNAME_HAVE_PARAMETERS         (0x4000)    // The real templates parameters are available
#define UNDNAME_NO_ECSU                 (0x8000)    // Suppress enum/class/struct/union
#define UNDNAME_NO_IDENT_CHAR_CHECK     (0x10000)   // Suppress check for IsValidIdentChar
#define UNDNAME_NO_PTR64				(0x20000)	// disable just ptr64 in output
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\langapi\include\cvconst.h ===
// cvconst.h - codeview constant definitions
//-----------------------------------------------------------------
//
// Copyright Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------
#ifndef _CVCONST_H_
#define _CVCONST_H_



//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_SHCALL      = 0x10, // Hitachi SuperH call
    CV_CALL_ARMCALL     = 0x11, // ARM call
    CV_CALL_AM33CALL    = 0x12, // AM33 call
    CV_CALL_TRICALL     = 0x13, // TriCore Call
    CV_CALL_SH5CALL     = 0x14, // Hitachi SuperH-5 call
    CV_CALL_M32RCALL    = 0x15, // M32R Call
    CV_CALL_RESERVED    = 0x16  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;

typedef enum THUNK_ORDINAL {
    THUNK_ORDINAL_NOTYPE,       // standard thunk
    THUNK_ORDINAL_ADJUSTOR,     // "this" adjustor thunk
    THUNK_ORDINAL_VCALL,        // virtual call thunk
    THUNK_ORDINAL_PCODE,        // pcode thunk
    THUNK_ORDINAL_LOAD,         // thunk which loads the address to jump to
                                //  via unknown means...

 // trampoline thunk ordinals   - only for use in Trampoline thunk symbols
    THUNK_ORDINAL_TRAMP_INCREMENTAL,
    THUNK_ORDINAL_TRAMP_BRANCHISLAND,

} THUNK_ORDINAL;


enum CV_SourceChksum_t {
    CHKSUM_TYPE_NONE = 0,        // indicates no checksum is available
    CHKSUM_TYPE_MD5
};

//
// DIA enums
//

enum SymTagEnum
{
    SymTagNull,
    SymTagExe,
    SymTagCompiland,
    SymTagCompilandDetails,
    SymTagCompilandEnv,
    SymTagFunction,
    SymTagBlock,
    SymTagData,
    SymTagAnnotation,
    SymTagLabel,
    SymTagPublicSymbol,
    SymTagUDT,
    SymTagEnum,
    SymTagFunctionType,
    SymTagPointerType,
    SymTagArrayType,
    SymTagBaseType,
    SymTagTypedef,
    SymTagBaseClass,
    SymTagFriend,
    SymTagFunctionArgType,
    SymTagFuncDebugStart,
    SymTagFuncDebugEnd,
    SymTagUsingNamespace,
    SymTagVTableShape,
    SymTagVTable,
    SymTagCustom,
    SymTagThunk,
    SymTagCustomType,
    SymTagManagedType,
    SymTagDimension,
    SymTagMax
};

enum LocationType
{
    LocIsNull,
    LocIsStatic,
    LocIsTLS,
    LocIsRegRel,
    LocIsThisRel,
    LocIsEnregistered,
    LocIsBitField,
    LocIsSlot,
    LocIsIlRel,
    LocInMetaData,
    LocIsConstant,
    LocTypeMax
};

enum DataKind
{
    DataIsUnknown,
    DataIsLocal,
    DataIsStaticLocal,
    DataIsParam,
    DataIsObjectPtr,
    DataIsFileStatic,
    DataIsGlobal,
    DataIsMember,
    DataIsStaticMember,
    DataIsConstant
};

enum UdtKind
{
    UdtStruct,
    UdtClass,
    UdtUnion
};

enum BasicType
{
    btNoType = 0,
    btVoid = 1,
    btChar = 2,
    btWChar = 3,
    btInt = 6,
    btUInt = 7,
    btFloat = 8,
    btBCD = 9,
    btBool = 10,
    btLong = 13,
    btULong = 14,
    btCurrency = 25,
    btDate = 26,
    btVariant = 27,
    btComplex = 28,
    btBit = 29,
    btBSTR = 30,
    btHresult = 31
};


//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
    CV_CFL_CVTPGD   = 0x09,
} CV_CFL_LANG;


//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMII    = 0x06,
    CV_CFL_PENTIUMPRO   = CV_CFL_PENTIUMII,
    CV_CFL_PENTIUMIII   = 0x07,
    CV_CFL_MIPS         = 0x10,
    CV_CFL_MIPSR4000    = CV_CFL_MIPS,  // don't break current code
    CV_CFL_MIPS16       = 0x11,
    CV_CFL_MIPS32       = 0x12,
    CV_CFL_MIPS64       = 0x13,
    CV_CFL_MIPSI        = 0x14,
    CV_CFL_MIPSII       = 0x15,
    CV_CFL_MIPSIII      = 0x16,
    CV_CFL_MIPSIV       = 0x17,
    CV_CFL_MIPSV        = 0x18,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_ALPHA_21064  = 0x30,
    CV_CFL_ALPHA_21164  = 0x31,
    CV_CFL_ALPHA_21164A = 0x32,
    CV_CFL_ALPHA_21264  = 0x33,
    CV_CFL_ALPHA_21364  = 0x34,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43,
    CV_CFL_PPCFP        = 0x44,
    CV_CFL_SH3          = 0x50,
    CV_CFL_SH3E         = 0x51,
    CV_CFL_SH3DSP       = 0x52,
    CV_CFL_SH4          = 0x53,
    CV_CFL_SHMEDIA      = 0x54,
    CV_CFL_ARM3         = 0x60,
    CV_CFL_ARM4         = 0x61,
    CV_CFL_ARM4T        = 0x62,
    CV_CFL_ARM5         = 0x63,
    CV_CFL_ARM5T        = 0x64,
    CV_CFL_OMNI         = 0x70,
    CV_CFL_IA64         = 0x80,
    CV_CFL_IA64_1       = 0x80,
    CV_CFL_IA64_2       = 0x81,
    CV_CFL_CEE          = 0x90,
    CV_CFL_AM33         = 0xA0,
    CV_CFL_M32R         = 0xB0,
    CV_CFL_TRICORE      = 0xC0,
    CV_CFL_X8664        = 0xD0,
    CV_CFL_AMD64        = CV_CFL_X8664,
    CV_CFL_EBC          = 0xE0,
    CV_CFL_THUMB        = 0xF0,
} CV_CPU_TYPE_e;

typedef enum CV_HREG_e {
    // Register subset shared by all processor types,
    // must not overlap with any of the ranges below, hence the high values

    CV_ALLREG_ERR   =   30000,
    CV_ALLREG_TEB   =   30001,
    CV_ALLREG_TIMER =   30002,
    CV_ALLREG_EFAD1 =   30003,
    CV_ALLREG_EFAD2 =   30004,
    CV_ALLREG_EFAD3 =   30005,
    CV_ALLREG_VFRAME=   30006,
    CV_ALLREG_HANDLE=   30007,
    CV_ALLREG_PARAMS=   30008,
    CV_ALLREG_LOCALS=   30009,
    CV_ALLREG_TID   =   30010,
    CV_ALLREG_ENV   =   30011,
    CV_ALLREG_CMDLN =   30012,


    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    CV_REG_MM0      =  146,
    CV_REG_MM1      =  147,
    CV_REG_MM2      =  148,
    CV_REG_MM3      =  149,
    CV_REG_MM4      =  150,
    CV_REG_MM5      =  151,
    CV_REG_MM6      =  152,
    CV_REG_MM7      =  153,

    CV_REG_XMM0     =  154, // KATMAI registers
    CV_REG_XMM1     =  155,
    CV_REG_XMM2     =  156,
    CV_REG_XMM3     =  157,
    CV_REG_XMM4     =  158,
    CV_REG_XMM5     =  159,
    CV_REG_XMM6     =  160,
    CV_REG_XMM7     =  161,

    CV_REG_XMM00    =  162, // KATMAI sub-registers
    CV_REG_XMM01    =  163,
    CV_REG_XMM02    =  164,
    CV_REG_XMM03    =  165,
    CV_REG_XMM10    =  166,
    CV_REG_XMM11    =  167,
    CV_REG_XMM12    =  168,
    CV_REG_XMM13    =  169,
    CV_REG_XMM20    =  170,
    CV_REG_XMM21    =  171,
    CV_REG_XMM22    =  172,
    CV_REG_XMM23    =  173,
    CV_REG_XMM30    =  174,
    CV_REG_XMM31    =  175,
    CV_REG_XMM32    =  176,
    CV_REG_XMM33    =  177,
    CV_REG_XMM40    =  178,
    CV_REG_XMM41    =  179,
    CV_REG_XMM42    =  180,
    CV_REG_XMM43    =  181,
    CV_REG_XMM50    =  182,
    CV_REG_XMM51    =  183,
    CV_REG_XMM52    =  184,
    CV_REG_XMM53    =  185,
    CV_REG_XMM60    =  186,
    CV_REG_XMM61    =  187,
    CV_REG_XMM62    =  188,
    CV_REG_XMM63    =  189,
    CV_REG_XMM70    =  190,
    CV_REG_XMM71    =  191,
    CV_REG_XMM72    =  192,
    CV_REG_XMM73    =  193,

    CV_REG_XMM0L    =  194,
    CV_REG_XMM1L    =  195,
    CV_REG_XMM2L    =  196,
    CV_REG_XMM3L    =  197,
    CV_REG_XMM4L    =  198,
    CV_REG_XMM5L    =  199,
    CV_REG_XMM6L    =  200,
    CV_REG_XMM7L    =  201,

    CV_REG_XMM0H    =  202,
    CV_REG_XMM1H    =  203,
    CV_REG_XMM2H    =  204,
    CV_REG_XMM3H    =  205,
    CV_REG_XMM4H    =  206,
    CV_REG_XMM5H    =  207,
    CV_REG_XMM6H    =  208,
    CV_REG_XMM7H    =  209,

    CV_REG_MXCSR    =  211, // XMM status register

    CV_REG_EDXEAX   =  212, // EDX:EAX pair

    CV_REG_EMM0L    =  220, // XMM sub-registers (WNI integer)
    CV_REG_EMM1L    =  221,
    CV_REG_EMM2L    =  222,
    CV_REG_EMM3L    =  223,
    CV_REG_EMM4L    =  224,
    CV_REG_EMM5L    =  225,
    CV_REG_EMM6L    =  226,
    CV_REG_EMM7L    =  227,

    CV_REG_EMM0H    =  228,
    CV_REG_EMM1H    =  229,
    CV_REG_EMM2H    =  230,
    CV_REG_EMM3H    =  231,
    CV_REG_EMM4H    =  232,
    CV_REG_EMM5H    =  233,
    CV_REG_EMM6H    =  234,
    CV_REG_EMM7H    =  235,

    // do not change the order of these regs, first one must be even too
    CV_REG_MM00     =  236,
    CV_REG_MM01     =  237,
    CV_REG_MM10     =  238,
    CV_REG_MM11     =  239,
    CV_REG_MM20     =  240,
    CV_REG_MM21     =  241,
    CV_REG_MM30     =  242,
    CV_REG_MM31     =  243,
    CV_REG_MM40     =  244,
    CV_REG_MM41     =  245,
    CV_REG_MM50     =  246,
    CV_REG_MM51     =  247,
    CV_REG_MM60     =  248,
    CV_REG_MM61     =  249,
    CV_REG_MM70     =  250,
    CV_REG_MM71     =  251,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )

    //
    // JAVA VM registers
    //

    CV_JAVA_PC      = 1,

    //
    // Register set for the Hitachi SH3
    //

    CV_SH3_NOREG    =   CV_REG_NONE,

    CV_SH3_IntR0    =   10,   // CPU REGISTER
    CV_SH3_IntR1    =   11,
    CV_SH3_IntR2    =   12,
    CV_SH3_IntR3    =   13,
    CV_SH3_IntR4    =   14,
    CV_SH3_IntR5    =   15,
    CV_SH3_IntR6    =   16,
    CV_SH3_IntR7    =   17,
    CV_SH3_IntR8    =   18,
    CV_SH3_IntR9    =   19,
    CV_SH3_IntR10   =   20,
    CV_SH3_IntR11   =   21,
    CV_SH3_IntR12   =   22,
    CV_SH3_IntR13   =   23,
    CV_SH3_IntFp    =   24,
    CV_SH3_IntSp    =   25,
    CV_SH3_Gbr      =   38,
    CV_SH3_Pr       =   39,
    CV_SH3_Mach     =   40,
    CV_SH3_Macl     =   41,

    CV_SH3_Pc       =   50,
    CV_SH3_Sr       =   51,

    CV_SH3_BarA     =   60,
    CV_SH3_BasrA    =   61,
    CV_SH3_BamrA    =   62,
    CV_SH3_BbrA     =   63,
    CV_SH3_BarB     =   64,
    CV_SH3_BasrB    =   65,
    CV_SH3_BamrB    =   66,
    CV_SH3_BbrB     =   67,
    CV_SH3_BdrB     =   68,
    CV_SH3_BdmrB    =   69,
    CV_SH3_Brcr     =   70,

    //
    // Additional registers for Hitachi SH processors
    //

    CV_SH_Fpscr    =   75,    // floating point status/control register
    CV_SH_Fpul     =   76,    // floating point communication register

    CV_SH_FpR0     =   80,    // Floating point registers
    CV_SH_FpR1     =   81,
    CV_SH_FpR2     =   82,
    CV_SH_FpR3     =   83,
    CV_SH_FpR4     =   84,
    CV_SH_FpR5     =   85,
    CV_SH_FpR6     =   86,
    CV_SH_FpR7     =   87,
    CV_SH_FpR8     =   88,
    CV_SH_FpR9     =   89,
    CV_SH_FpR10    =   90,
    CV_SH_FpR11    =   91,
    CV_SH_FpR12    =   92,
    CV_SH_FpR13    =   93,
    CV_SH_FpR14    =   94,
    CV_SH_FpR15    =   95,

    CV_SH_XFpR0    =   96,
    CV_SH_XFpR1    =   97,
    CV_SH_XFpR2    =   98,
    CV_SH_XFpR3    =   99,
    CV_SH_XFpR4    =  100,
    CV_SH_XFpR5    =  101,
    CV_SH_XFpR6    =  102,
    CV_SH_XFpR7    =  103,
    CV_SH_XFpR8    =  104,
    CV_SH_XFpR9    =  105,
    CV_SH_XFpR10   =  106,
    CV_SH_XFpR11   =  107,
    CV_SH_XFpR12   =  108,
    CV_SH_XFpR13   =  109,
    CV_SH_XFpR14   =  110,
    CV_SH_XFpR15   =  111,

    //
    // Register set for the ARM processor.
    //

    CV_ARM_NOREG    =   CV_REG_NONE,

    CV_ARM_R0       =   10,
    CV_ARM_R1       =   11,
    CV_ARM_R2       =   12,
    CV_ARM_R3       =   13,
    CV_ARM_R4       =   14,
    CV_ARM_R5       =   15,
    CV_ARM_R6       =   16,
    CV_ARM_R7       =   17,
    CV_ARM_R8       =   18,
    CV_ARM_R9       =   19,
    CV_ARM_R10      =   20,
    CV_ARM_R11      =   21, // Frame pointer, if allocated
    CV_ARM_R12      =   22,
    CV_ARM_SP       =   23, // Stack pointer
    CV_ARM_LR       =   24, // Link Register
    CV_ARM_PC       =   25, // Program counter
    CV_ARM_CPSR     =   26, // Current program status register

    //
    // Register set for Intel IA64
    //

    CV_IA64_NOREG   =   CV_REG_NONE,

    // Branch Registers

    CV_IA64_Br0     =   512,
    CV_IA64_Br1     =   513,
    CV_IA64_Br2     =   514,
    CV_IA64_Br3     =   515,
    CV_IA64_Br4     =   516,
    CV_IA64_Br5     =   517,
    CV_IA64_Br6     =   518,
    CV_IA64_Br7     =   519,

    // Predicate Registers

    CV_IA64_P0    =   704,
    CV_IA64_P1    =   705,
    CV_IA64_P2    =   706,
    CV_IA64_P3    =   707,
    CV_IA64_P4    =   708,
    CV_IA64_P5    =   709,
    CV_IA64_P6    =   710,
    CV_IA64_P7    =   711,
    CV_IA64_P8    =   712,
    CV_IA64_P9    =   713,
    CV_IA64_P10   =   714,
    CV_IA64_P11   =   715,
    CV_IA64_P12   =   716,
    CV_IA64_P13   =   717,
    CV_IA64_P14   =   718,
    CV_IA64_P15   =   719,
    CV_IA64_P16   =   720,
    CV_IA64_P17   =   721,
    CV_IA64_P18   =   722,
    CV_IA64_P19   =   723,
    CV_IA64_P20   =   724,
    CV_IA64_P21   =   725,
    CV_IA64_P22   =   726,
    CV_IA64_P23   =   727,
    CV_IA64_P24   =   728,
    CV_IA64_P25   =   729,
    CV_IA64_P26   =   730,
    CV_IA64_P27   =   731,
    CV_IA64_P28   =   732,
    CV_IA64_P29   =   733,
    CV_IA64_P30   =   734,
    CV_IA64_P31   =   735,
    CV_IA64_P32   =   736,
    CV_IA64_P33   =   737,
    CV_IA64_P34   =   738,
    CV_IA64_P35   =   739,
    CV_IA64_P36   =   740,
    CV_IA64_P37   =   741,
    CV_IA64_P38   =   742,
    CV_IA64_P39   =   743,
    CV_IA64_P40   =   744,
    CV_IA64_P41   =   745,
    CV_IA64_P42   =   746,
    CV_IA64_P43   =   747,
    CV_IA64_P44   =   748,
    CV_IA64_P45   =   749,
    CV_IA64_P46   =   750,
    CV_IA64_P47   =   751,
    CV_IA64_P48   =   752,
    CV_IA64_P49   =   753,
    CV_IA64_P50   =   754,
    CV_IA64_P51   =   755,
    CV_IA64_P52   =   756,
    CV_IA64_P53   =   757,
    CV_IA64_P54   =   758,
    CV_IA64_P55   =   759,
    CV_IA64_P56   =   760,
    CV_IA64_P57   =   761,
    CV_IA64_P58   =   762,
    CV_IA64_P59   =   763,
    CV_IA64_P60   =   764,
    CV_IA64_P61   =   765,
    CV_IA64_P62   =   766,
    CV_IA64_P63   =   767,

    CV_IA64_Preds   =   768,

    // Banked General Registers

    CV_IA64_IntH0   =   832,
    CV_IA64_IntH1   =   833,
    CV_IA64_IntH2   =   834,
    CV_IA64_IntH3   =   835,
    CV_IA64_IntH4   =   836,
    CV_IA64_IntH5   =   837,
    CV_IA64_IntH6   =   838,
    CV_IA64_IntH7   =   839,
    CV_IA64_IntH8   =   840,
    CV_IA64_IntH9   =   841,
    CV_IA64_IntH10  =   842,
    CV_IA64_IntH11  =   843,
    CV_IA64_IntH12  =   844,
    CV_IA64_IntH13  =   845,
    CV_IA64_IntH14  =   846,
    CV_IA64_IntH15  =   847,

    // Special Registers

    CV_IA64_Ip      =   1016,
    CV_IA64_Umask   =   1017,
    CV_IA64_Cfm     =   1018,
    CV_IA64_Psr     =   1019,

    // Banked General Registers

    CV_IA64_Nats    =   1020,
    CV_IA64_Nats2   =   1021,
    CV_IA64_Nats3   =   1022,

    // General-Purpose Registers

    // Integer registers
    CV_IA64_IntR0   =   1024,
    CV_IA64_IntR1   =   1025,
    CV_IA64_IntR2   =   1026,
    CV_IA64_IntR3   =   1027,
    CV_IA64_IntR4   =   1028,
    CV_IA64_IntR5   =   1029,
    CV_IA64_IntR6   =   1030,
    CV_IA64_IntR7   =   1031,
    CV_IA64_IntR8   =   1032,
    CV_IA64_IntR9   =   1033,
    CV_IA64_IntR10  =   1034,
    CV_IA64_IntR11  =   1035,
    CV_IA64_IntR12  =   1036,
    CV_IA64_IntR13  =   1037,
    CV_IA64_IntR14  =   1038,
    CV_IA64_IntR15  =   1039,
    CV_IA64_IntR16  =   1040,
    CV_IA64_IntR17  =   1041,
    CV_IA64_IntR18  =   1042,
    CV_IA64_IntR19  =   1043,
    CV_IA64_IntR20  =   1044,
    CV_IA64_IntR21  =   1045,
    CV_IA64_IntR22  =   1046,
    CV_IA64_IntR23  =   1047,
    CV_IA64_IntR24  =   1048,
    CV_IA64_IntR25  =   1049,
    CV_IA64_IntR26  =   1050,
    CV_IA64_IntR27  =   1051,
    CV_IA64_IntR28  =   1052,
    CV_IA64_IntR29  =   1053,
    CV_IA64_IntR30  =   1054,
    CV_IA64_IntR31  =   1055,

    // Register Stack
    CV_IA64_IntR32  =   1056,
    CV_IA64_IntR33  =   1057,
    CV_IA64_IntR34  =   1058,
    CV_IA64_IntR35  =   1059,
    CV_IA64_IntR36  =   1060,
    CV_IA64_IntR37  =   1061,
    CV_IA64_IntR38  =   1062,
    CV_IA64_IntR39  =   1063,
    CV_IA64_IntR40  =   1064,
    CV_IA64_IntR41  =   1065,
    CV_IA64_IntR42  =   1066,
    CV_IA64_IntR43  =   1067,
    CV_IA64_IntR44  =   1068,
    CV_IA64_IntR45  =   1069,
    CV_IA64_IntR46  =   1070,
    CV_IA64_IntR47  =   1071,
    CV_IA64_IntR48  =   1072,
    CV_IA64_IntR49  =   1073,
    CV_IA64_IntR50  =   1074,
    CV_IA64_IntR51  =   1075,
    CV_IA64_IntR52  =   1076,
    CV_IA64_IntR53  =   1077,
    CV_IA64_IntR54  =   1078,
    CV_IA64_IntR55  =   1079,
    CV_IA64_IntR56  =   1080,
    CV_IA64_IntR57  =   1081,
    CV_IA64_IntR58  =   1082,
    CV_IA64_IntR59  =   1083,
    CV_IA64_IntR60  =   1084,
    CV_IA64_IntR61  =   1085,
    CV_IA64_IntR62  =   1086,
    CV_IA64_IntR63  =   1087,
    CV_IA64_IntR64  =   1088,
    CV_IA64_IntR65  =   1089,
    CV_IA64_IntR66  =   1090,
    CV_IA64_IntR67  =   1091,
    CV_IA64_IntR68  =   1092,
    CV_IA64_IntR69  =   1093,
    CV_IA64_IntR70  =   1094,
    CV_IA64_IntR71  =   1095,
    CV_IA64_IntR72  =   1096,
    CV_IA64_IntR73  =   1097,
    CV_IA64_IntR74  =   1098,
    CV_IA64_IntR75  =   1099,
    CV_IA64_IntR76  =   1100,
    CV_IA64_IntR77  =   1101,
    CV_IA64_IntR78  =   1102,
    CV_IA64_IntR79  =   1103,
    CV_IA64_IntR80  =   1104,
    CV_IA64_IntR81  =   1105,
    CV_IA64_IntR82  =   1106,
    CV_IA64_IntR83  =   1107,
    CV_IA64_IntR84  =   1108,
    CV_IA64_IntR85  =   1109,
    CV_IA64_IntR86  =   1110,
    CV_IA64_IntR87  =   1111,
    CV_IA64_IntR88  =   1112,
    CV_IA64_IntR89  =   1113,
    CV_IA64_IntR90  =   1114,
    CV_IA64_IntR91  =   1115,
    CV_IA64_IntR92  =   1116,
    CV_IA64_IntR93  =   1117,
    CV_IA64_IntR94  =   1118,
    CV_IA64_IntR95  =   1119,
    CV_IA64_IntR96  =   1120,
    CV_IA64_IntR97  =   1121,
    CV_IA64_IntR98  =   1122,
    CV_IA64_IntR99  =   1123,
    CV_IA64_IntR100 =   1124,
    CV_IA64_IntR101 =   1125,
    CV_IA64_IntR102 =   1126,
    CV_IA64_IntR103 =   1127,
    CV_IA64_IntR104 =   1128,
    CV_IA64_IntR105 =   1129,
    CV_IA64_IntR106 =   1130,
    CV_IA64_IntR107 =   1131,
    CV_IA64_IntR108 =   1132,
    CV_IA64_IntR109 =   1133,
    CV_IA64_IntR110 =   1134,
    CV_IA64_IntR111 =   1135,
    CV_IA64_IntR112 =   1136,
    CV_IA64_IntR113 =   1137,
    CV_IA64_IntR114 =   1138,
    CV_IA64_IntR115 =   1139,
    CV_IA64_IntR116 =   1140,
    CV_IA64_IntR117 =   1141,
    CV_IA64_IntR118 =   1142,
    CV_IA64_IntR119 =   1143,
    CV_IA64_IntR120 =   1144,
    CV_IA64_IntR121 =   1145,
    CV_IA64_IntR122 =   1146,
    CV_IA64_IntR123 =   1147,
    CV_IA64_IntR124 =   1148,
    CV_IA64_IntR125 =   1149,
    CV_IA64_IntR126 =   1150,
    CV_IA64_IntR127 =   1151,

    // Floating-Point Registers

    // Low Floating Point Registers
    CV_IA64_FltF0   =   2048,
    CV_IA64_FltF1   =   2049,
    CV_IA64_FltF2   =   2050,
    CV_IA64_FltF3   =   2051,
    CV_IA64_FltF4   =   2052,
    CV_IA64_FltF5   =   2053,
    CV_IA64_FltF6   =   2054,
    CV_IA64_FltF7   =   2055,
    CV_IA64_FltF8   =   2056,
    CV_IA64_FltF9   =   2057,
    CV_IA64_FltF10  =   2058,
    CV_IA64_FltF11  =   2059,
    CV_IA64_FltF12  =   2060,
    CV_IA64_FltF13  =   2061,
    CV_IA64_FltF14  =   2062,
    CV_IA64_FltF15  =   2063,
    CV_IA64_FltF16  =   2064,
    CV_IA64_FltF17  =   2065,
    CV_IA64_FltF18  =   2066,
    CV_IA64_FltF19  =   2067,
    CV_IA64_FltF20  =   2068,
    CV_IA64_FltF21  =   2069,
    CV_IA64_FltF22  =   2070,
    CV_IA64_FltF23  =   2071,
    CV_IA64_FltF24  =   2072,
    CV_IA64_FltF25  =   2073,
    CV_IA64_FltF26  =   2074,
    CV_IA64_FltF27  =   2075,
    CV_IA64_FltF28  =   2076,
    CV_IA64_FltF29  =   2077,
    CV_IA64_FltF30  =   2078,
    CV_IA64_FltF31  =   2079,

    // High Floating Point Registers
    CV_IA64_FltF32  =   2080,
    CV_IA64_FltF33  =   2081,
    CV_IA64_FltF34  =   2082,
    CV_IA64_FltF35  =   2083,
    CV_IA64_FltF36  =   2084,
    CV_IA64_FltF37  =   2085,
    CV_IA64_FltF38  =   2086,
    CV_IA64_FltF39  =   2087,
    CV_IA64_FltF40  =   2088,
    CV_IA64_FltF41  =   2089,
    CV_IA64_FltF42  =   2090,
    CV_IA64_FltF43  =   2091,
    CV_IA64_FltF44  =   2092,
    CV_IA64_FltF45  =   2093,
    CV_IA64_FltF46  =   2094,
    CV_IA64_FltF47  =   2095,
    CV_IA64_FltF48  =   2096,
    CV_IA64_FltF49  =   2097,
    CV_IA64_FltF50  =   2098,
    CV_IA64_FltF51  =   2099,
    CV_IA64_FltF52  =   2100,
    CV_IA64_FltF53  =   2101,
    CV_IA64_FltF54  =   2102,
    CV_IA64_FltF55  =   2103,
    CV_IA64_FltF56  =   2104,
    CV_IA64_FltF57  =   2105,
    CV_IA64_FltF58  =   2106,
    CV_IA64_FltF59  =   2107,
    CV_IA64_FltF60  =   2108,
    CV_IA64_FltF61  =   2109,
    CV_IA64_FltF62  =   2110,
    CV_IA64_FltF63  =   2111,
    CV_IA64_FltF64  =   2112,
    CV_IA64_FltF65  =   2113,
    CV_IA64_FltF66  =   2114,
    CV_IA64_FltF67  =   2115,
    CV_IA64_FltF68  =   2116,
    CV_IA64_FltF69  =   2117,
    CV_IA64_FltF70  =   2118,
    CV_IA64_FltF71  =   2119,
    CV_IA64_FltF72  =   2120,
    CV_IA64_FltF73  =   2121,
    CV_IA64_FltF74  =   2122,
    CV_IA64_FltF75  =   2123,
    CV_IA64_FltF76  =   2124,
    CV_IA64_FltF77  =   2125,
    CV_IA64_FltF78  =   2126,
    CV_IA64_FltF79  =   2127,
    CV_IA64_FltF80  =   2128,
    CV_IA64_FltF81  =   2129,
    CV_IA64_FltF82  =   2130,
    CV_IA64_FltF83  =   2131,
    CV_IA64_FltF84  =   2132,
    CV_IA64_FltF85  =   2133,
    CV_IA64_FltF86  =   2134,
    CV_IA64_FltF87  =   2135,
    CV_IA64_FltF88  =   2136,
    CV_IA64_FltF89  =   2137,
    CV_IA64_FltF90  =   2138,
    CV_IA64_FltF91  =   2139,
    CV_IA64_FltF92  =   2140,
    CV_IA64_FltF93  =   2141,
    CV_IA64_FltF94  =   2142,
    CV_IA64_FltF95  =   2143,
    CV_IA64_FltF96  =   2144,
    CV_IA64_FltF97  =   2145,
    CV_IA64_FltF98  =   2146,
    CV_IA64_FltF99  =   2147,
    CV_IA64_FltF100 =   2148,
    CV_IA64_FltF101 =   2149,
    CV_IA64_FltF102 =   2150,
    CV_IA64_FltF103 =   2151,
    CV_IA64_FltF104 =   2152,
    CV_IA64_FltF105 =   2153,
    CV_IA64_FltF106 =   2154,
    CV_IA64_FltF107 =   2155,
    CV_IA64_FltF108 =   2156,
    CV_IA64_FltF109 =   2157,
    CV_IA64_FltF110 =   2158,
    CV_IA64_FltF111 =   2159,
    CV_IA64_FltF112 =   2160,
    CV_IA64_FltF113 =   2161,
    CV_IA64_FltF114 =   2162,
    CV_IA64_FltF115 =   2163,
    CV_IA64_FltF116 =   2164,
    CV_IA64_FltF117 =   2165,
    CV_IA64_FltF118 =   2166,
    CV_IA64_FltF119 =   2167,
    CV_IA64_FltF120 =   2168,
    CV_IA64_FltF121 =   2169,
    CV_IA64_FltF122 =   2170,
    CV_IA64_FltF123 =   2171,
    CV_IA64_FltF124 =   2172,
    CV_IA64_FltF125 =   2173,
    CV_IA64_FltF126 =   2174,
    CV_IA64_FltF127 =   2175,

    // Application Registers

    CV_IA64_ApKR0   =   3072,
    CV_IA64_ApKR1   =   3073,
    CV_IA64_ApKR2   =   3074,
    CV_IA64_ApKR3   =   3075,
    CV_IA64_ApKR4   =   3076,
    CV_IA64_ApKR5   =   3077,
    CV_IA64_ApKR6   =   3078,
    CV_IA64_ApKR7   =   3079,
    CV_IA64_AR8     =   3080,
    CV_IA64_AR9     =   3081,
    CV_IA64_AR10    =   3082,
    CV_IA64_AR11    =   3083,
    CV_IA64_AR12    =   3084,
    CV_IA64_AR13    =   3085,
    CV_IA64_AR14    =   3086,
    CV_IA64_AR15    =   3087,
    CV_IA64_RsRSC   =   3088,
    CV_IA64_RsBSP   =   3089,
    CV_IA64_RsBSPSTORE  =   3090,
    CV_IA64_RsRNAT  =   3091,
    CV_IA64_AR20    =   3092,
    CV_IA64_StFCR   =   3093,
    CV_IA64_AR22    =   3094,
    CV_IA64_AR23    =   3095,
    CV_IA64_EFLAG   =   3096,
    CV_IA64_CSD     =   3097,
    CV_IA64_SSD     =   3098,
    CV_IA64_CFLG    =   3099,
    CV_IA64_StFSR   =   3100,
    CV_IA64_StFIR   =   3101,
    CV_IA64_StFDR   =   3102,
    CV_IA64_AR31    =   3103,
    CV_IA64_ApCCV   =   3104,
    CV_IA64_AR33    =   3105,
    CV_IA64_AR34    =   3106,
    CV_IA64_AR35    =   3107,
    CV_IA64_ApUNAT  =   3108,
    CV_IA64_AR37    =   3109,
    CV_IA64_AR38    =   3110,
    CV_IA64_AR39    =   3111,
    CV_IA64_StFPSR  =   3112,
    CV_IA64_AR41    =   3113,
    CV_IA64_AR42    =   3114,
    CV_IA64_AR43    =   3115,
    CV_IA64_ApITC   =   3116,
    CV_IA64_AR45    =   3117,
    CV_IA64_AR46    =   3118,
    CV_IA64_AR47    =   3119,
    CV_IA64_AR48    =   3120,
    CV_IA64_AR49    =   3121,
    CV_IA64_AR50    =   3122,
    CV_IA64_AR51    =   3123,
    CV_IA64_AR52    =   3124,
    CV_IA64_AR53    =   3125,
    CV_IA64_AR54    =   3126,
    CV_IA64_AR55    =   3127,
    CV_IA64_AR56    =   3128,
    CV_IA64_AR57    =   3129,
    CV_IA64_AR58    =   3130,
    CV_IA64_AR59    =   3131,
    CV_IA64_AR60    =   3132,
    CV_IA64_AR61    =   3133,
    CV_IA64_AR62    =   3134,
    CV_IA64_AR63    =   3135,
    CV_IA64_RsPFS   =   3136,
    CV_IA64_ApLC    =   3137,
    CV_IA64_ApEC    =   3138,
    CV_IA64_AR67    =   3139,
    CV_IA64_AR68    =   3140,
    CV_IA64_AR69    =   3141,
    CV_IA64_AR70    =   3142,
    CV_IA64_AR71    =   3143,
    CV_IA64_AR72    =   3144,
    CV_IA64_AR73    =   3145,
    CV_IA64_AR74    =   3146,
    CV_IA64_AR75    =   3147,
    CV_IA64_AR76    =   3148,
    CV_IA64_AR77    =   3149,
    CV_IA64_AR78    =   3150,
    CV_IA64_AR79    =   3151,
    CV_IA64_AR80    =   3152,
    CV_IA64_AR81    =   3153,
    CV_IA64_AR82    =   3154,
    CV_IA64_AR83    =   3155,
    CV_IA64_AR84    =   3156,
    CV_IA64_AR85    =   3157,
    CV_IA64_AR86    =   3158,
    CV_IA64_AR87    =   3159,
    CV_IA64_AR88    =   3160,
    CV_IA64_AR89    =   3161,
    CV_IA64_AR90    =   3162,
    CV_IA64_AR91    =   3163,
    CV_IA64_AR92    =   3164,
    CV_IA64_AR93    =   3165,
    CV_IA64_AR94    =   3166,
    CV_IA64_AR95    =   3167,
    CV_IA64_AR96    =   3168,
    CV_IA64_AR97    =   3169,
    CV_IA64_AR98    =   3170,
    CV_IA64_AR99    =   3171,
    CV_IA64_AR100   =   3172,
    CV_IA64_AR101   =   3173,
    CV_IA64_AR102   =   3174,
    CV_IA64_AR103   =   3175,
    CV_IA64_AR104   =   3176,
    CV_IA64_AR105   =   3177,
    CV_IA64_AR106   =   3178,
    CV_IA64_AR107   =   3179,
    CV_IA64_AR108   =   3180,
    CV_IA64_AR109   =   3181,
    CV_IA64_AR110   =   3182,
    CV_IA64_AR111   =   3183,
    CV_IA64_AR112   =   3184,
    CV_IA64_AR113   =   3185,
    CV_IA64_AR114   =   3186,
    CV_IA64_AR115   =   3187,
    CV_IA64_AR116   =   3188,
    CV_IA64_AR117   =   3189,
    CV_IA64_AR118   =   3190,
    CV_IA64_AR119   =   3191,
    CV_IA64_AR120   =   3192,
    CV_IA64_AR121   =   3193,
    CV_IA64_AR122   =   3194,
    CV_IA64_AR123   =   3195,
    CV_IA64_AR124   =   3196,
    CV_IA64_AR125   =   3197,
    CV_IA64_AR126   =   3198,
    CV_IA64_AR127   =   3199,

    // CPUID Registers

    CV_IA64_CPUID0  =   3328,
    CV_IA64_CPUID1  =   3329,
    CV_IA64_CPUID2  =   3330,
    CV_IA64_CPUID3  =   3331,
    CV_IA64_CPUID4  =   3332,

    // Control Registers

    CV_IA64_ApDCR   =   4096,
    CV_IA64_ApITM   =   4097,
    CV_IA64_ApIVA   =   4098,
    CV_IA64_CR3     =   4099,
    CV_IA64_CR4     =   4100,
    CV_IA64_CR5     =   4101,
    CV_IA64_CR6     =   4102,
    CV_IA64_CR7     =   4103,
    CV_IA64_ApPTA   =   4104,
    CV_IA64_ApGPTA  =   4105,
    CV_IA64_CR10    =   4106,
    CV_IA64_CR11    =   4107,
    CV_IA64_CR12    =   4108,
    CV_IA64_CR13    =   4109,
    CV_IA64_CR14    =   4110,
    CV_IA64_CR15    =   4111,
    CV_IA64_StIPSR  =   4112,
    CV_IA64_StISR   =   4113,
    CV_IA64_CR18    =   4114,
    CV_IA64_StIIP   =   4115,
    CV_IA64_StIFA   =   4116,
    CV_IA64_StITIR  =   4117,
    CV_IA64_StIIPA  =   4118,
    CV_IA64_StIFS   =   4119,
    CV_IA64_StIIM   =   4120,
    CV_IA64_StIHA   =   4121,
    CV_IA64_CR26    =   4122,
    CV_IA64_CR27    =   4123,
    CV_IA64_CR28    =   4124,
    CV_IA64_CR29    =   4125,
    CV_IA64_CR30    =   4126,
    CV_IA64_CR31    =   4127,
    CV_IA64_CR32    =   4128,
    CV_IA64_CR33    =   4129,
    CV_IA64_CR34    =   4130,
    CV_IA64_CR35    =   4131,
    CV_IA64_CR36    =   4132,
    CV_IA64_CR37    =   4133,
    CV_IA64_CR38    =   4134,
    CV_IA64_CR39    =   4135,
    CV_IA64_CR40    =   4136,
    CV_IA64_CR41    =   4137,
    CV_IA64_CR42    =   4138,
    CV_IA64_CR43    =   4139,
    CV_IA64_CR44    =   4140,
    CV_IA64_CR45    =   4141,
    CV_IA64_CR46    =   4142,
    CV_IA64_CR47    =   4143,
    CV_IA64_CR48    =   4144,
    CV_IA64_CR49    =   4145,
    CV_IA64_CR50    =   4146,
    CV_IA64_CR51    =   4147,
    CV_IA64_CR52    =   4148,
    CV_IA64_CR53    =   4149,
    CV_IA64_CR54    =   4150,
    CV_IA64_CR55    =   4151,
    CV_IA64_CR56    =   4152,
    CV_IA64_CR57    =   4153,
    CV_IA64_CR58    =   4154,
    CV_IA64_CR59    =   4155,
    CV_IA64_CR60    =   4156,
    CV_IA64_CR61    =   4157,
    CV_IA64_CR62    =   4158,
    CV_IA64_CR63    =   4159,
    CV_IA64_SaLID   =   4160,
    CV_IA64_SaIVR   =   4161,
    CV_IA64_SaTPR   =   4162,
    CV_IA64_SaEOI   =   4163,
    CV_IA64_SaIRR0  =   4164,
    CV_IA64_SaIRR1  =   4165,
    CV_IA64_SaIRR2  =   4166,
    CV_IA64_SaIRR3  =   4167,
    CV_IA64_SaITV   =   4168,
    CV_IA64_SaPMV   =   4169,
    CV_IA64_SaCMCV  =   4170,
    CV_IA64_CR75    =   4171,
    CV_IA64_CR76    =   4172,
    CV_IA64_CR77    =   4173,
    CV_IA64_CR78    =   4174,
    CV_IA64_CR79    =   4175,
    CV_IA64_SaLRR0  =   4176,
    CV_IA64_SaLRR1  =   4177,
    CV_IA64_CR82    =   4178,
    CV_IA64_CR83    =   4179,
    CV_IA64_CR84    =   4180,
    CV_IA64_CR85    =   4181,
    CV_IA64_CR86    =   4182,
    CV_IA64_CR87    =   4183,
    CV_IA64_CR88    =   4184,
    CV_IA64_CR89    =   4185,
    CV_IA64_CR90    =   4186,
    CV_IA64_CR91    =   4187,
    CV_IA64_CR92    =   4188,
    CV_IA64_CR93    =   4189,
    CV_IA64_CR94    =   4190,
    CV_IA64_CR95    =   4191,
    CV_IA64_CR96    =   4192,
    CV_IA64_CR97    =   4193,
    CV_IA64_CR98    =   4194,
    CV_IA64_CR99    =   4195,
    CV_IA64_CR100   =   4196,
    CV_IA64_CR101   =   4197,
    CV_IA64_CR102   =   4198,
    CV_IA64_CR103   =   4199,
    CV_IA64_CR104   =   4200,
    CV_IA64_CR105   =   4201,
    CV_IA64_CR106   =   4202,
    CV_IA64_CR107   =   4203,
    CV_IA64_CR108   =   4204,
    CV_IA64_CR109   =   4205,
    CV_IA64_CR110   =   4206,
    CV_IA64_CR111   =   4207,
    CV_IA64_CR112   =   4208,
    CV_IA64_CR113   =   4209,
    CV_IA64_CR114   =   4210,
    CV_IA64_CR115   =   4211,
    CV_IA64_CR116   =   4212,
    CV_IA64_CR117   =   4213,
    CV_IA64_CR118   =   4214,
    CV_IA64_CR119   =   4215,
    CV_IA64_CR120   =   4216,
    CV_IA64_CR121   =   4217,
    CV_IA64_CR122   =   4218,
    CV_IA64_CR123   =   4219,
    CV_IA64_CR124   =   4220,
    CV_IA64_CR125   =   4221,
    CV_IA64_CR126   =   4222,
    CV_IA64_CR127   =   4223,

    // Protection Key Registers

    CV_IA64_Pkr0    =   5120,
    CV_IA64_Pkr1    =   5121,
    CV_IA64_Pkr2    =   5122,
    CV_IA64_Pkr3    =   5123,
    CV_IA64_Pkr4    =   5124,
    CV_IA64_Pkr5    =   5125,
    CV_IA64_Pkr6    =   5126,
    CV_IA64_Pkr7    =   5127,
    CV_IA64_Pkr8    =   5128,
    CV_IA64_Pkr9    =   5129,
    CV_IA64_Pkr10   =   5130,
    CV_IA64_Pkr11   =   5131,
    CV_IA64_Pkr12   =   5132,
    CV_IA64_Pkr13   =   5133,
    CV_IA64_Pkr14   =   5134,
    CV_IA64_Pkr15   =   5135,

    // Region Registers

    CV_IA64_Rr0     =   6144,
    CV_IA64_Rr1     =   6145,
    CV_IA64_Rr2     =   6146,
    CV_IA64_Rr3     =   6147,
    CV_IA64_Rr4     =   6148,
    CV_IA64_Rr5     =   6149,
    CV_IA64_Rr6     =   6150,
    CV_IA64_Rr7     =   6151,

    // Performance Monitor Data Registers

    CV_IA64_PFD0    =   7168,
    CV_IA64_PFD1    =   7169,
    CV_IA64_PFD2    =   7170,
    CV_IA64_PFD3    =   7171,
    CV_IA64_PFD4    =   7172,
    CV_IA64_PFD5    =   7173,
    CV_IA64_PFD6    =   7174,
    CV_IA64_PFD7    =   7175,

    // Performance Monitor Config Registers

    CV_IA64_PFC0    =   7424,
    CV_IA64_PFC1    =   7425,
    CV_IA64_PFC2    =   7426,
    CV_IA64_PFC3    =   7427,
    CV_IA64_PFC4    =   7428,
    CV_IA64_PFC5    =   7429,
    CV_IA64_PFC6    =   7430,
    CV_IA64_PFC7    =   7431,

    // Instruction Translation Registers

    CV_IA64_TrI0    =   8192,
    CV_IA64_TrI1    =   8193,
    CV_IA64_TrI2    =   8194,
    CV_IA64_TrI3    =   8195,
    CV_IA64_TrI4    =   8196,
    CV_IA64_TrI5    =   8197,
    CV_IA64_TrI6    =   8198,
    CV_IA64_TrI7    =   8199,

    // Data Translation Registers

    CV_IA64_TrD0    =   8320,
    CV_IA64_TrD1    =   8321,
    CV_IA64_TrD2    =   8322,
    CV_IA64_TrD3    =   8323,
    CV_IA64_TrD4    =   8324,
    CV_IA64_TrD5    =   8325,
    CV_IA64_TrD6    =   8326,
    CV_IA64_TrD7    =   8327,

    // Instruction Breakpoint Registers

    CV_IA64_DbI0    =   8448,
    CV_IA64_DbI1    =   8449,
    CV_IA64_DbI2    =   8450,
    CV_IA64_DbI3    =   8451,
    CV_IA64_DbI4    =   8452,
    CV_IA64_DbI5    =   8453,
    CV_IA64_DbI6    =   8454,
    CV_IA64_DbI7    =   8455,

    // Data Breakpoint Registers

    CV_IA64_DbD0    =   8576,
    CV_IA64_DbD1    =   8577,
    CV_IA64_DbD2    =   8578,
    CV_IA64_DbD3    =   8579,
    CV_IA64_DbD4    =   8580,
    CV_IA64_DbD5    =   8581,
    CV_IA64_DbD6    =   8582,
    CV_IA64_DbD7    =   8583,

    //
    // Register set for the TriCore processor.
    //

    CV_TRI_NOREG    =   CV_REG_NONE,

    // General Purpose Data Registers

    CV_TRI_D0   =   10,
    CV_TRI_D1   =   11,
    CV_TRI_D2   =   12,
    CV_TRI_D3   =   13,
    CV_TRI_D4   =   14,
    CV_TRI_D5   =   15,
    CV_TRI_D6   =   16,
    CV_TRI_D7   =   17,
    CV_TRI_D8   =   18,
    CV_TRI_D9   =   19,
    CV_TRI_D10  =   20,
    CV_TRI_D11  =   21,
    CV_TRI_D12  =   22,
    CV_TRI_D13  =   23,
    CV_TRI_D14  =   24,
    CV_TRI_D15  =   25,

    // General Purpose Address Registers

    CV_TRI_A0   =   26,
    CV_TRI_A1   =   27,
    CV_TRI_A2   =   28,
    CV_TRI_A3   =   29,
    CV_TRI_A4   =   30,
    CV_TRI_A5   =   31,
    CV_TRI_A6   =   32,
    CV_TRI_A7   =   33,
    CV_TRI_A8   =   34,
    CV_TRI_A9   =   35,
    CV_TRI_A10  =   36,
    CV_TRI_A11  =   37,
    CV_TRI_A12  =   38,
    CV_TRI_A13  =   39,
    CV_TRI_A14  =   40,
    CV_TRI_A15  =   41,

    // Extended (64-bit) data registers

    CV_TRI_E0   =   42,
    CV_TRI_E2   =   43,
    CV_TRI_E4   =   44,
    CV_TRI_E6   =   45,
    CV_TRI_E8   =   46,
    CV_TRI_E10  =   47,
    CV_TRI_E12  =   48,
    CV_TRI_E14  =   49,

    // Extended (64-bit) address registers

    CV_TRI_EA0  =   50,
    CV_TRI_EA2  =   51,
    CV_TRI_EA4  =   52,
    CV_TRI_EA6  =   53,
    CV_TRI_EA8  =   54,
    CV_TRI_EA10 =   55,
    CV_TRI_EA12 =   56,
    CV_TRI_EA14 =   57,

    CV_TRI_PSW  =   58,
    CV_TRI_PCXI =   59,
    CV_TRI_PC   =   60,
    CV_TRI_FCX  =   61,
    CV_TRI_LCX  =   62,
    CV_TRI_ISP  =   63,
    CV_TRI_ICR  =   64,
    CV_TRI_BIV  =   65,
    CV_TRI_BTV  =   66,
    CV_TRI_SYSCON   =   67,
    CV_TRI_DPRx_0   =   68,
    CV_TRI_DPRx_1   =   69,
    CV_TRI_DPRx_2   =   70,
    CV_TRI_DPRx_3   =   71,
    CV_TRI_CPRx_0   =   68,
    CV_TRI_CPRx_1   =   69,
    CV_TRI_CPRx_2   =   70,
    CV_TRI_CPRx_3   =   71,
    CV_TRI_DPMx_0   =   68,
    CV_TRI_DPMx_1   =   69,
    CV_TRI_DPMx_2   =   70,
    CV_TRI_DPMx_3   =   71,
    CV_TRI_CPMx_0   =   68,
    CV_TRI_CPMx_1   =   69,
    CV_TRI_CPMx_2   =   70,
    CV_TRI_CPMx_3   =   71,
    CV_TRI_DBGSSR   =   72,
    CV_TRI_EXEVT    =   73,
    CV_TRI_SWEVT    =   74,
    CV_TRI_CREVT    =   75,
    CV_TRI_TRnEVT   =   76,
    CV_TRI_MMUCON   =   77,
    CV_TRI_ASI      =   78,
    CV_TRI_TVA      =   79,
    CV_TRI_TPA      =   80,
    CV_TRI_TPX      =   81,
    CV_TRI_TFA      =   82,

    //
    // Register set for the AM33 and related processors.
    //

    CV_AM33_NOREG   =   CV_REG_NONE,

    // "Extended" (general purpose integer) registers
    CV_AM33_E0      =   10,
    CV_AM33_E1      =   11,
    CV_AM33_E2      =   12,
    CV_AM33_E3      =   13,
    CV_AM33_E4      =   14,
    CV_AM33_E5      =   15,
    CV_AM33_E6      =   16,
    CV_AM33_E7      =   17,

    // Address registers
    CV_AM33_A0      =   20,
    CV_AM33_A1      =   21,
    CV_AM33_A2      =   22,
    CV_AM33_A3      =   23,

    // Integer data registers
    CV_AM33_D0      =   30,
    CV_AM33_D1      =   31,
    CV_AM33_D2      =   32,
    CV_AM33_D3      =   33,

    // (Single-precision) floating-point registers
    CV_AM33_FS0     =   40,
    CV_AM33_FS1     =   41,
    CV_AM33_FS2     =   42,
    CV_AM33_FS3     =   43,
    CV_AM33_FS4     =   44,
    CV_AM33_FS5     =   45,
    CV_AM33_FS6     =   46,
    CV_AM33_FS7     =   47,
    CV_AM33_FS8     =   48,
    CV_AM33_FS9     =   49,
    CV_AM33_FS10    =   50,
    CV_AM33_FS11    =   51,
    CV_AM33_FS12    =   52,
    CV_AM33_FS13    =   53,
    CV_AM33_FS14    =   54,
    CV_AM33_FS15    =   55,
    CV_AM33_FS16    =   56,
    CV_AM33_FS17    =   57,
    CV_AM33_FS18    =   58,
    CV_AM33_FS19    =   59,
    CV_AM33_FS20    =   60,
    CV_AM33_FS21    =   61,
    CV_AM33_FS22    =   62,
    CV_AM33_FS23    =   63,
    CV_AM33_FS24    =   64,
    CV_AM33_FS25    =   65,
    CV_AM33_FS26    =   66,
    CV_AM33_FS27    =   67,
    CV_AM33_FS28    =   68,
    CV_AM33_FS29    =   69,
    CV_AM33_FS30    =   70,
    CV_AM33_FS31    =   71,

    // Special purpose registers

    // Stack pointer
    CV_AM33_SP      =   80,

    // Program counter
    CV_AM33_PC      =   81,

    // Multiply-divide/accumulate registers
    CV_AM33_MDR     =   82,
    CV_AM33_MDRQ    =   83,
    CV_AM33_MCRH    =   84,
    CV_AM33_MCRL    =   85,
    CV_AM33_MCVF    =   86,

    // CPU status words
    CV_AM33_EPSW    =   87,
    CV_AM33_FPCR    =   88,

    // Loop buffer registers
    CV_AM33_LIR     =   89,
    CV_AM33_LAR     =   90,

    //
    // Register set for the Mitsubishi M32R
    //

    CV_M32R_NOREG    =   CV_REG_NONE,

    CV_M32R_R0    =   10,
    CV_M32R_R1    =   11,
    CV_M32R_R2    =   12,
    CV_M32R_R3    =   13,
    CV_M32R_R4    =   14,
    CV_M32R_R5    =   15,
    CV_M32R_R6    =   16,
    CV_M32R_R7    =   17,
    CV_M32R_R8    =   18,
    CV_M32R_R9    =   19,
    CV_M32R_R10   =   20,
    CV_M32R_R11   =   21,
    CV_M32R_R12   =   22,   // Gloabal Pointer, if used
    CV_M32R_R13   =   23,   // Frame Pointer, if allocated
    CV_M32R_R14   =   24,   // Link Register
    CV_M32R_R15   =   25,   // Stack Pointer
    CV_M32R_PSW   =   26,   // Preocessor Status Register
    CV_M32R_CBR   =   27,   // Condition Bit Register
    CV_M32R_SPI   =   28,   // Interrupt Stack Pointer
    CV_M32R_SPU   =   29,   // User Stack Pointer
    CV_M32R_SPO   =   30,   // OS Stack Pointer
    CV_M32R_BPC   =   31,   // Backup Program Counter
    CV_M32R_ACHI  =   32,   // Accumulator High
    CV_M32R_ACLO  =   33,   // Accumulator Low
    CV_M32R_PC    =   34,   // Program Counter

    //
    // Register set for the SuperH SHMedia processor including compact
    // mode
    //

    // Integer - 64 bit general registers
    CV_SHMEDIA_NOREG   =   CV_REG_NONE,
    CV_SHMEDIA_R0      =   10,
    CV_SHMEDIA_R1      =   11,
    CV_SHMEDIA_R2      =   12,
    CV_SHMEDIA_R3      =   13,
    CV_SHMEDIA_R4      =   14,
    CV_SHMEDIA_R5      =   15,
    CV_SHMEDIA_R6      =   16,
    CV_SHMEDIA_R7      =   17,
    CV_SHMEDIA_R8      =   18,
    CV_SHMEDIA_R9      =   19,
    CV_SHMEDIA_R10     =   20,
    CV_SHMEDIA_R11     =   21,
    CV_SHMEDIA_R12     =   22,
    CV_SHMEDIA_R13     =   23,
    CV_SHMEDIA_R14     =   24,
    CV_SHMEDIA_R15     =   25,
    CV_SHMEDIA_R16     =   26,
    CV_SHMEDIA_R17     =   27,
    CV_SHMEDIA_R18     =   28,
    CV_SHMEDIA_R19     =   29,
    CV_SHMEDIA_R20     =   30,
    CV_SHMEDIA_R21     =   31,
    CV_SHMEDIA_R22     =   32,
    CV_SHMEDIA_R23     =   33,
    CV_SHMEDIA_R24     =   34,
    CV_SHMEDIA_R25     =   35,
    CV_SHMEDIA_R26     =   36,
    CV_SHMEDIA_R27     =   37,
    CV_SHMEDIA_R28     =   38,
    CV_SHMEDIA_R29     =   39,
    CV_SHMEDIA_R30     =   40,
    CV_SHMEDIA_R31     =   41,
    CV_SHMEDIA_R32     =   42,
    CV_SHMEDIA_R33     =   43,
    CV_SHMEDIA_R34     =   44,
    CV_SHMEDIA_R35     =   45,
    CV_SHMEDIA_R36     =   46,
    CV_SHMEDIA_R37     =   47,
    CV_SHMEDIA_R38     =   48,
    CV_SHMEDIA_R39     =   49,
    CV_SHMEDIA_R40     =   50,
    CV_SHMEDIA_R41     =   51,
    CV_SHMEDIA_R42     =   52,
    CV_SHMEDIA_R43     =   53,
    CV_SHMEDIA_R44     =   54,
    CV_SHMEDIA_R45     =   55,
    CV_SHMEDIA_R46     =   56,
    CV_SHMEDIA_R47     =   57,
    CV_SHMEDIA_R48     =   58,
    CV_SHMEDIA_R49     =   59,
    CV_SHMEDIA_R50     =   60,
    CV_SHMEDIA_R51     =   61,
    CV_SHMEDIA_R52     =   62,
    CV_SHMEDIA_R53     =   63,
    CV_SHMEDIA_R54     =   64,
    CV_SHMEDIA_R55     =   65,
    CV_SHMEDIA_R56     =   66,
    CV_SHMEDIA_R57     =   67,
    CV_SHMEDIA_R58     =   68,
    CV_SHMEDIA_R59     =   69,
    CV_SHMEDIA_R60     =   70,
    CV_SHMEDIA_R61     =   71,
    CV_SHMEDIA_R62     =   72,
    CV_SHMEDIA_R63     =   73,
    
    // Target Registers - 32 bit
    CV_SHMEDIA_TR0     =   74,
    CV_SHMEDIA_TR1     =   75,
    CV_SHMEDIA_TR2     =   76,
    CV_SHMEDIA_TR3     =   77,
    CV_SHMEDIA_TR4     =   78,
    CV_SHMEDIA_TR5     =   79,
    CV_SHMEDIA_TR6     =   80,
    CV_SHMEDIA_TR7     =   81,
    CV_SHMEDIA_TR8     =   82, // future-proof
    CV_SHMEDIA_TR9     =   83, // future-proof
    CV_SHMEDIA_TR10    =   84, // future-proof
    CV_SHMEDIA_TR11    =   85, // future-proof
    CV_SHMEDIA_TR12    =   86, // future-proof
    CV_SHMEDIA_TR13    =   87, // future-proof
    CV_SHMEDIA_TR14    =   88, // future-proof
    CV_SHMEDIA_TR15    =   89, // future-proof

    // Single - 32 bit fp registers
    CV_SHMEDIA_FR0     =   128,
    CV_SHMEDIA_FR1     =   129,
    CV_SHMEDIA_FR2     =   130,
    CV_SHMEDIA_FR3     =   131,
    CV_SHMEDIA_FR4     =   132,
    CV_SHMEDIA_FR5     =   133,
    CV_SHMEDIA_FR6     =   134,
    CV_SHMEDIA_FR7     =   135,
    CV_SHMEDIA_FR8     =   136,
    CV_SHMEDIA_FR9     =   137,
    CV_SHMEDIA_FR10    =   138,
    CV_SHMEDIA_FR11    =   139,
    CV_SHMEDIA_FR12    =   140,
    CV_SHMEDIA_FR13    =   141,
    CV_SHMEDIA_FR14    =   142,
    CV_SHMEDIA_FR15    =   143,
    CV_SHMEDIA_FR16    =   144,
    CV_SHMEDIA_FR17    =   145,
    CV_SHMEDIA_FR18    =   146,
    CV_SHMEDIA_FR19    =   147,
    CV_SHMEDIA_FR20    =   148,
    CV_SHMEDIA_FR21    =   149,
    CV_SHMEDIA_FR22    =   150,
    CV_SHMEDIA_FR23    =   151,
    CV_SHMEDIA_FR24    =   152,
    CV_SHMEDIA_FR25    =   153,
    CV_SHMEDIA_FR26    =   154,
    CV_SHMEDIA_FR27    =   155,
    CV_SHMEDIA_FR28    =   156,
    CV_SHMEDIA_FR29    =   157,
    CV_SHMEDIA_FR30    =   158,
    CV_SHMEDIA_FR31    =   159,
    CV_SHMEDIA_FR32    =   160,
    CV_SHMEDIA_FR33    =   161,
    CV_SHMEDIA_FR34    =   162,
    CV_SHMEDIA_FR35    =   163,
    CV_SHMEDIA_FR36    =   164,
    CV_SHMEDIA_FR37    =   165,
    CV_SHMEDIA_FR38    =   166,
    CV_SHMEDIA_FR39    =   167,
    CV_SHMEDIA_FR40    =   168,
    CV_SHMEDIA_FR41    =   169,
    CV_SHMEDIA_FR42    =   170,
    CV_SHMEDIA_FR43    =   171,
    CV_SHMEDIA_FR44    =   172,
    CV_SHMEDIA_FR45    =   173,
    CV_SHMEDIA_FR46    =   174,
    CV_SHMEDIA_FR47    =   175,
    CV_SHMEDIA_FR48    =   176,
    CV_SHMEDIA_FR49    =   177,
    CV_SHMEDIA_FR50    =   178,
    CV_SHMEDIA_FR51    =   179,
    CV_SHMEDIA_FR52    =   180,
    CV_SHMEDIA_FR53    =   181,
    CV_SHMEDIA_FR54    =   182,
    CV_SHMEDIA_FR55    =   183,
    CV_SHMEDIA_FR56    =   184,
    CV_SHMEDIA_FR57    =   185,
    CV_SHMEDIA_FR58    =   186,
    CV_SHMEDIA_FR59    =   187,
    CV_SHMEDIA_FR60    =   188,
    CV_SHMEDIA_FR61    =   189,
    CV_SHMEDIA_FR62    =   190,
    CV_SHMEDIA_FR63    =   191,

    // Double - 64 bit synonyms for 32bit fp register pairs
    //          subtract 128 to find first base single register
    CV_SHMEDIA_DR0     =   256,
    CV_SHMEDIA_DR2     =   258,
    CV_SHMEDIA_DR4     =   260,
    CV_SHMEDIA_DR6     =   262,
    CV_SHMEDIA_DR8     =   264,
    CV_SHMEDIA_DR10    =   266,
    CV_SHMEDIA_DR12    =   268,
    CV_SHMEDIA_DR14    =   270,
    CV_SHMEDIA_DR16    =   272,
    CV_SHMEDIA_DR18    =   274,
    CV_SHMEDIA_DR20    =   276,
    CV_SHMEDIA_DR22    =   278,
    CV_SHMEDIA_DR24    =   280,
    CV_SHMEDIA_DR26    =   282,
    CV_SHMEDIA_DR28    =   284,
    CV_SHMEDIA_DR30    =   286,
    CV_SHMEDIA_DR32    =   288,
    CV_SHMEDIA_DR34    =   290,
    CV_SHMEDIA_DR36    =   292,
    CV_SHMEDIA_DR38    =   294,
    CV_SHMEDIA_DR40    =   296,
    CV_SHMEDIA_DR42    =   298,
    CV_SHMEDIA_DR44    =   300,
    CV_SHMEDIA_DR46    =   302,
    CV_SHMEDIA_DR48    =   304,
    CV_SHMEDIA_DR50    =   306,
    CV_SHMEDIA_DR52    =   308,
    CV_SHMEDIA_DR54    =   310,
    CV_SHMEDIA_DR56    =   312,
    CV_SHMEDIA_DR58    =   314,
    CV_SHMEDIA_DR60    =   316,
    CV_SHMEDIA_DR62    =   318,

    // Vector - 128 bit synonyms for 32bit fp register quads
    //          subtract 384 to find first base single register
    CV_SHMEDIA_FV0     =   512,
    CV_SHMEDIA_FV4     =   516,
    CV_SHMEDIA_FV8     =   520,
    CV_SHMEDIA_FV12    =   524,
    CV_SHMEDIA_FV16    =   528,
    CV_SHMEDIA_FV20    =   532,
    CV_SHMEDIA_FV24    =   536,
    CV_SHMEDIA_FV28    =   540,
    CV_SHMEDIA_FV32    =   544,
    CV_SHMEDIA_FV36    =   548,
    CV_SHMEDIA_FV40    =   552,
    CV_SHMEDIA_FV44    =   556,
    CV_SHMEDIA_FV48    =   560,
    CV_SHMEDIA_FV52    =   564,
    CV_SHMEDIA_FV56    =   568,
    CV_SHMEDIA_FV60    =   572,

    // Matrix - 512 bit synonyms for 16 adjacent 32bit fp registers
    //          subtract 896 to find first base single register
    CV_SHMEDIA_MTRX0   =   1024,
    CV_SHMEDIA_MTRX16  =   1040,
    CV_SHMEDIA_MTRX32  =   1056,
    CV_SHMEDIA_MTRX48  =   1072,

    // Control - Implementation defined 64bit control registers
    CV_SHMEDIA_CR0     =   2000,
    CV_SHMEDIA_CR1     =   2001,
    CV_SHMEDIA_CR2     =   2002,
    CV_SHMEDIA_CR3     =   2003,
    CV_SHMEDIA_CR4     =   2004,
    CV_SHMEDIA_CR5     =   2005,
    CV_SHMEDIA_CR6     =   2006,
    CV_SHMEDIA_CR7     =   2007,
    CV_SHMEDIA_CR8     =   2008,
    CV_SHMEDIA_CR9     =   2009,
    CV_SHMEDIA_CR10    =   2010,
    CV_SHMEDIA_CR11    =   2011,
    CV_SHMEDIA_CR12    =   2012,
    CV_SHMEDIA_CR13    =   2013,
    CV_SHMEDIA_CR14    =   2014,
    CV_SHMEDIA_CR15    =   2015,
    CV_SHMEDIA_CR16    =   2016,
    CV_SHMEDIA_CR17    =   2017,
    CV_SHMEDIA_CR18    =   2018,
    CV_SHMEDIA_CR19    =   2019,
    CV_SHMEDIA_CR20    =   2020,
    CV_SHMEDIA_CR21    =   2021,
    CV_SHMEDIA_CR22    =   2022,
    CV_SHMEDIA_CR23    =   2023,
    CV_SHMEDIA_CR24    =   2024,
    CV_SHMEDIA_CR25    =   2025,
    CV_SHMEDIA_CR26    =   2026,
    CV_SHMEDIA_CR27    =   2027,
    CV_SHMEDIA_CR28    =   2028,
    CV_SHMEDIA_CR29    =   2029,
    CV_SHMEDIA_CR30    =   2030,
    CV_SHMEDIA_CR31    =   2031,
    CV_SHMEDIA_CR32    =   2032,
    CV_SHMEDIA_CR33    =   2033,
    CV_SHMEDIA_CR34    =   2034,
    CV_SHMEDIA_CR35    =   2035,
    CV_SHMEDIA_CR36    =   2036,
    CV_SHMEDIA_CR37    =   2037,
    CV_SHMEDIA_CR38    =   2038,
    CV_SHMEDIA_CR39    =   2039,
    CV_SHMEDIA_CR40    =   2040,
    CV_SHMEDIA_CR41    =   2041,
    CV_SHMEDIA_CR42    =   2042,
    CV_SHMEDIA_CR43    =   2043,
    CV_SHMEDIA_CR44    =   2044,
    CV_SHMEDIA_CR45    =   2045,
    CV_SHMEDIA_CR46    =   2046,
    CV_SHMEDIA_CR47    =   2047,
    CV_SHMEDIA_CR48    =   2048,
    CV_SHMEDIA_CR49    =   2049,
    CV_SHMEDIA_CR50    =   2050,
    CV_SHMEDIA_CR51    =   2051,
    CV_SHMEDIA_CR52    =   2052,
    CV_SHMEDIA_CR53    =   2053,
    CV_SHMEDIA_CR54    =   2054,
    CV_SHMEDIA_CR55    =   2055,
    CV_SHMEDIA_CR56    =   2056,
    CV_SHMEDIA_CR57    =   2057,
    CV_SHMEDIA_CR58    =   2058,
    CV_SHMEDIA_CR59    =   2059,
    CV_SHMEDIA_CR60    =   2060,
    CV_SHMEDIA_CR61    =   2061,
    CV_SHMEDIA_CR62    =   2062,
    CV_SHMEDIA_CR63    =   2063,

    CV_SHMEDIA_FPSCR   =   2064,

    // Compact mode synonyms
    CV_SHMEDIA_GBR     =   CV_SHMEDIA_R16,
    CV_SHMEDIA_MACL    =   90, // synonym for lower 32bits of media R17
    CV_SHMEDIA_MACH    =   91, // synonym for upper 32bits of media R17
    CV_SHMEDIA_PR      =   CV_SHMEDIA_R18,
    CV_SHMEDIA_T       =   92, // synonym for lowest bit of media R19
    CV_SHMEDIA_FPUL    =   CV_SHMEDIA_FR32,
    CV_SHMEDIA_PC      =   93,
    CV_SHMEDIA_SR      =   CV_SHMEDIA_CR0,

    //
    // AMD64/X8664 registers
    //

    CV_AMD64_AL       =   1,
    CV_AMD64_CL       =   2,
    CV_AMD64_DL       =   3,
    CV_AMD64_BL       =   4,
    CV_AMD64_AH       =   5,
    CV_AMD64_CH       =   6,
    CV_AMD64_DH       =   7,
    CV_AMD64_BH       =   8,
    CV_AMD64_AX       =   9,
    CV_AMD64_CX       =  10,
    CV_AMD64_DX       =  11,
    CV_AMD64_BX       =  12,
    CV_AMD64_SP       =  13,
    CV_AMD64_BP       =  14,
    CV_AMD64_SI       =  15,
    CV_AMD64_DI       =  16,
    CV_AMD64_EAX      =  17,
    CV_AMD64_ECX      =  18,
    CV_AMD64_EDX      =  19,
    CV_AMD64_EBX      =  20,
    CV_AMD64_ESP      =  21,
    CV_AMD64_EBP      =  22,
    CV_AMD64_ESI      =  23,
    CV_AMD64_EDI      =  24,
    CV_AMD64_ES       =  25,
    CV_AMD64_CS       =  26,
    CV_AMD64_SS       =  27,
    CV_AMD64_DS       =  28,
    CV_AMD64_FS       =  29,
    CV_AMD64_GS       =  30,
    CV_AMD64_IP       =  31,
    CV_AMD64_FLAGS    =  32,
    CV_AMD64_EIP      =  33,
    CV_AMD64_EFLAGS   =  34,

    // Control registers
    CV_AMD64_CR0      =  80,
    CV_AMD64_CR1      =  81,
    CV_AMD64_CR2      =  82,
    CV_AMD64_CR3      =  83,
    CV_AMD64_CR4      =  84,
    CV_AMD64_CR8      =  88,

    // Debug registers
    CV_AMD64_DR0      =  90,
    CV_AMD64_DR1      =  91,
    CV_AMD64_DR2      =  92,
    CV_AMD64_DR3      =  93,
    CV_AMD64_DR4      =  94,
    CV_AMD64_DR5      =  95,
    CV_AMD64_DR6      =  96,
    CV_AMD64_DR7      =  97,
    CV_AMD64_DR8      =  98,
    CV_AMD64_DR9      =  99,
    CV_AMD64_DR10     =  100,
    CV_AMD64_DR11     =  101,
    CV_AMD64_DR12     =  102,
    CV_AMD64_DR13     =  103,
    CV_AMD64_DR14     =  104,
    CV_AMD64_DR15     =  105,

    CV_AMD64_GDTR     =  110,
    CV_AMD64_GDTL     =  111,
    CV_AMD64_IDTR     =  112,
    CV_AMD64_IDTL     =  113,
    CV_AMD64_LDTR     =  114,
    CV_AMD64_TR       =  115,

    CV_AMD64_ST0      =  128,
    CV_AMD64_ST1      =  129,
    CV_AMD64_ST2      =  130,
    CV_AMD64_ST3      =  131,
    CV_AMD64_ST4      =  132,
    CV_AMD64_ST5      =  133,
    CV_AMD64_ST6      =  134,
    CV_AMD64_ST7      =  135,
    CV_AMD64_CTRL     =  136,
    CV_AMD64_STAT     =  137,
    CV_AMD64_TAG      =  138,
    CV_AMD64_FPIP     =  139,
    CV_AMD64_FPCS     =  140,
    CV_AMD64_FPDO     =  141,
    CV_AMD64_FPDS     =  142,
    CV_AMD64_ISEM     =  143,
    CV_AMD64_FPEIP    =  144,
    CV_AMD64_FPEDO    =  145,

    CV_AMD64_MM0      =  146,
    CV_AMD64_MM1      =  147,
    CV_AMD64_MM2      =  148,
    CV_AMD64_MM3      =  149,
    CV_AMD64_MM4      =  150,
    CV_AMD64_MM5      =  151,
    CV_AMD64_MM6      =  152,
    CV_AMD64_MM7      =  153,

    CV_AMD64_XMM0     =  154,   // KATMAI registers
    CV_AMD64_XMM1     =  155,
    CV_AMD64_XMM2     =  156,
    CV_AMD64_XMM3     =  157,
    CV_AMD64_XMM4     =  158,
    CV_AMD64_XMM5     =  159,
    CV_AMD64_XMM6     =  160,
    CV_AMD64_XMM7     =  161,

    CV_AMD64_XMM0_0   =  162,   // KATMAI sub-registers
    CV_AMD64_XMM0_1   =  163,
    CV_AMD64_XMM0_2   =  164,
    CV_AMD64_XMM0_3   =  165,
    CV_AMD64_XMM1_0   =  166,
    CV_AMD64_XMM1_1   =  167,
    CV_AMD64_XMM1_2   =  168,
    CV_AMD64_XMM1_3   =  169,
    CV_AMD64_XMM2_0   =  170,
    CV_AMD64_XMM2_1   =  171,
    CV_AMD64_XMM2_2   =  172,
    CV_AMD64_XMM2_3   =  173,
    CV_AMD64_XMM3_0   =  174,
    CV_AMD64_XMM3_1   =  175,
    CV_AMD64_XMM3_2   =  176,
    CV_AMD64_XMM3_3   =  177,
    CV_AMD64_XMM4_0   =  178,
    CV_AMD64_XMM4_1   =  179,
    CV_AMD64_XMM4_2   =  180,
    CV_AMD64_XMM4_3   =  181,
    CV_AMD64_XMM5_0   =  182,
    CV_AMD64_XMM5_1   =  183,
    CV_AMD64_XMM5_2   =  184,
    CV_AMD64_XMM5_3   =  185,
    CV_AMD64_XMM6_0   =  186,
    CV_AMD64_XMM6_1   =  187,
    CV_AMD64_XMM6_2   =  188,
    CV_AMD64_XMM6_3   =  189,
    CV_AMD64_XMM7_0   =  190,
    CV_AMD64_XMM7_1   =  191,
    CV_AMD64_XMM7_2   =  192,
    CV_AMD64_XMM7_3   =  193,

    CV_AMD64_XMM0L    =  194,
    CV_AMD64_XMM1L    =  195,
    CV_AMD64_XMM2L    =  196,
    CV_AMD64_XMM3L    =  197,
    CV_AMD64_XMM4L    =  198,
    CV_AMD64_XMM5L    =  199,
    CV_AMD64_XMM6L    =  200,
    CV_AMD64_XMM7L    =  201,

    CV_AMD64_XMM0H    =  202,
    CV_AMD64_XMM1H    =  203,
    CV_AMD64_XMM2H    =  204,
    CV_AMD64_XMM3H    =  205,
    CV_AMD64_XMM4H    =  206,
    CV_AMD64_XMM5H    =  207,
    CV_AMD64_XMM6H    =  208,
    CV_AMD64_XMM7H    =  209,

    CV_AMD64_MXCSR    =  211,   // XMM status register

    CV_AMD64_EMM0L    =  220,   // XMM sub-registers (WNI integer)
    CV_AMD64_EMM1L    =  221,
    CV_AMD64_EMM2L    =  222,
    CV_AMD64_EMM3L    =  223,
    CV_AMD64_EMM4L    =  224,
    CV_AMD64_EMM5L    =  225,
    CV_AMD64_EMM6L    =  226,
    CV_AMD64_EMM7L    =  227,

    CV_AMD64_EMM0H    =  228,
    CV_AMD64_EMM1H    =  229,
    CV_AMD64_EMM2H    =  230,
    CV_AMD64_EMM3H    =  231,
    CV_AMD64_EMM4H    =  232,
    CV_AMD64_EMM5H    =  233,
    CV_AMD64_EMM6H    =  234,
    CV_AMD64_EMM7H    =  235,

    // do not change the order of these regs, first one must be even too
    CV_AMD64_MM00     =  236,
    CV_AMD64_MM01     =  237,
    CV_AMD64_MM10     =  238,
    CV_AMD64_MM11     =  239,
    CV_AMD64_MM20     =  240,
    CV_AMD64_MM21     =  241,
    CV_AMD64_MM30     =  242,
    CV_AMD64_MM31     =  243,
    CV_AMD64_MM40     =  244,
    CV_AMD64_MM41     =  245,
    CV_AMD64_MM50     =  246,
    CV_AMD64_MM51     =  247,
    CV_AMD64_MM60     =  248,
    CV_AMD64_MM61     =  249,
    CV_AMD64_MM70     =  250,
    CV_AMD64_MM71     =  251,

    // Extended KATMAI registers
    CV_AMD64_XMM8     =  252,   // KATMAI registers
    CV_AMD64_XMM9     =  253,
    CV_AMD64_XMM10    =  254,
    CV_AMD64_XMM11    =  255,
    CV_AMD64_XMM12    =  256,
    CV_AMD64_XMM13    =  257,
    CV_AMD64_XMM14    =  258,
    CV_AMD64_XMM15    =  259,

    CV_AMD64_XMM8_0   =  260,   // KATMAI sub-registers
    CV_AMD64_XMM8_1   =  261,
    CV_AMD64_XMM8_2   =  262,
    CV_AMD64_XMM8_3   =  263,
    CV_AMD64_XMM9_0   =  264,
    CV_AMD64_XMM9_1   =  265,
    CV_AMD64_XMM9_2   =  266,
    CV_AMD64_XMM9_3   =  267,
    CV_AMD64_XMM10_0  =  268,
    CV_AMD64_XMM10_1  =  269,
    CV_AMD64_XMM10_2  =  270,
    CV_AMD64_XMM10_3  =  271,
    CV_AMD64_XMM11_0  =  272,
    CV_AMD64_XMM11_1  =  273,
    CV_AMD64_XMM11_2  =  274,
    CV_AMD64_XMM11_3  =  275,
    CV_AMD64_XMM12_0  =  276,
    CV_AMD64_XMM12_1  =  277,
    CV_AMD64_XMM12_2  =  278,
    CV_AMD64_XMM12_3  =  279,
    CV_AMD64_XMM13_0  =  280,
    CV_AMD64_XMM13_1  =  281,
    CV_AMD64_XMM13_2  =  282,
    CV_AMD64_XMM13_3  =  283,
    CV_AMD64_XMM14_0  =  284,
    CV_AMD64_XMM14_1  =  285,
    CV_AMD64_XMM14_2  =  286,
    CV_AMD64_XMM14_3  =  287,
    CV_AMD64_XMM15_0  =  288,
    CV_AMD64_XMM15_1  =  289,
    CV_AMD64_XMM15_2  =  290,
    CV_AMD64_XMM15_3  =  291,

    CV_AMD64_XMM8L    =  292,
    CV_AMD64_XMM9L    =  293,
    CV_AMD64_XMM10L   =  294,
    CV_AMD64_XMM11L   =  295,
    CV_AMD64_XMM12L   =  296,
    CV_AMD64_XMM13L   =  297,
    CV_AMD64_XMM14L   =  298,
    CV_AMD64_XMM15L   =  299,

    CV_AMD64_XMM8H    =  300,
    CV_AMD64_XMM9H    =  301,
    CV_AMD64_XMM10H   =  301,
    CV_AMD64_XMM11H   =  302,
    CV_AMD64_XMM12H   =  303,
    CV_AMD64_XMM13H   =  304,
    CV_AMD64_XMM14H   =  305,
    CV_AMD64_XMM15H   =  306,

    // Low byte forms of some standard registers
    CV_AMD64_SIL      =  307,
    CV_AMD64_DIL      =  308,
    CV_AMD64_BPL      =  309,
    CV_AMD64_SPL      =  310,

    // 64-bit regular registers
    CV_AMD64_RAX      =  311,
    CV_AMD64_RBX      =  312,
    CV_AMD64_RCX      =  313,
    CV_AMD64_RDX      =  314,
    CV_AMD64_RSI      =  315,
    CV_AMD64_RDI      =  316,
    CV_AMD64_RBP      =  317,
    CV_AMD64_RSP      =  318,

    // 64-bit integer registers with 8-, 16-, and 32-bit forms (B, W, and D)
    CV_AMD64_R8       =  319,
    CV_AMD64_R9       =  320,
    CV_AMD64_R10      =  321,
    CV_AMD64_R11      =  322,
    CV_AMD64_R12      =  323,
    CV_AMD64_R13      =  324,
    CV_AMD64_R14      =  325,
    CV_AMD64_R15      =  326,

    CV_AMD64_R8B      =  327,
    CV_AMD64_R9B      =  328,
    CV_AMD64_R10B     =  329,
    CV_AMD64_R11B     =  330,
    CV_AMD64_R12B     =  331,
    CV_AMD64_R13B     =  332,
    CV_AMD64_R14B     =  333,
    CV_AMD64_R15B     =  334,

    CV_AMD64_R8W      =  335,
    CV_AMD64_R9W      =  336,
    CV_AMD64_R10W     =  337,
    CV_AMD64_R11W     =  338,
    CV_AMD64_R12W     =  339,
    CV_AMD64_R13W     =  340,
    CV_AMD64_R14W     =  341,
    CV_AMD64_R15W     =  342,

    CV_AMD64_R8D      =  343,
    CV_AMD64_R9D      =  344,
    CV_AMD64_R10D     =  345,
    CV_AMD64_R11D     =  346,
    CV_AMD64_R12D     =  347,
    CV_AMD64_R13D     =  348,
    CV_AMD64_R14D     =  349,
    CV_AMD64_R15D     =  350,

} CV_HREG_e;

enum StackFrameTypeEnum
{
    FrameTypeFPO,                   // Frame pointer omitted, FPO info available
    FrameTypeTrap,                  // Kernel Trap frame
    FrameTypeTSS,                   // Kernel Trap frame
    FrameTypeStandard,              // Standard EBP stackframe
    FrameTypeFrameData,             // Frame pointer omitted, FrameData info available

    FrameTypeUnknown = -1,          // Frame which does not have any debug info
};

enum MemoryTypeEnum
{
    MemTypeCode,                    // Read only code memory
    MemTypeData,                    // Read only data/stack memory
    MemTypeStack,                   // Read only stack memory

    MemTypeAny = -1,
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\langapi\undname\utf8.h ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    utf.h

Abstract:

    This file contains the header information for the UTF module of NLS.

Revision History:
    
    02-06-96    JulieB    Created.

--*/
//
//  Constant Declarations.
//

#ifndef _UTF8_H_
#define _UTF8_H_

#define ASCII                 0x007f

#define UTF8_2_MAX            0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define UTF8_1ST_OF_2         0xc0    // 110x xxxx
#define UTF8_1ST_OF_3         0xe0    // 1110 xxxx
#define UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define UTF8_TRAIL            0x80    // 10xx xxxx

#define HIGHER_6_BIT(u)       ((u) >> 12)
#define MIDDLE_6_BIT(u)       (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)        ((u) & 0x003f)

#define BIT7(a)               ((a) & 0x80)
#define BIT6(a)               ((a) & 0x40)

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff


#define  UCH_SURROGATE_FIRST         0xD800    // First surrogate
#define  UCH_HI_SURROGATE_FIRST      0xD800    // First High Surrogate
#define  UCH_PV_HI_SURROGATE_FIRST   0xDB80    // <Private Use High Surrogate, First>
#define  UCH_PV_HI_SURROGATE_LAST    0xDBFF    // <Private Use High Surrogate, Last>
#define  UCH_HI_SURROGATE_LAST       0xDBFF    // Last High Surrogate
#define  UCH_LO_SURROGATE_FIRST      0xDC00    // <Low Surrogate, First>
#define  UCH_LO_SURROGATE_LAST       0xDFFF    // <Low Surrogate, Last>
#define  UCH_SURROGATE_LAST          0xDFFF    // Last surrogate

#define IN_RANGE(v, r1, r2) ((r1) <= (v) && (v) <= (r2))
#define UCH_REPLACE                   0xFFFD     // REPLACEMENT CHARACTER

#define IsSurrogate(ch)     IN_RANGE(ch, UCH_SURROGATE_FIRST,    UCH_SURROGATE_LAST)
#define IsHighSurrogate(ch) IN_RANGE(ch, UCH_HI_SURROGATE_FIRST, UCH_HI_SURROGATE_LAST)
#define IsLowSurrogate(ch)  IN_RANGE(ch, UCH_LO_SURROGATE_FIRST, UCH_LO_SURROGATE_LAST)

#ifdef __cplusplus
extern "C" {
#endif

size_t UTF8ToUnicode(LPCSTR lpSrcStr, LPWSTR lpDestStr, size_t cchDest);
size_t UTF8ToUnicodeCch(LPCSTR lpSrcStr, size_t cchSrc, LPWSTR lpDestStr, size_t cchDest);
size_t UnicodeToUTF8(LPCWSTR lpSrcStr, LPSTR lpDestStr, size_t cchDest);
size_t UnicodeToUTF8Cch(LPCWSTR lpSrcStr, size_t cchSrc, LPSTR lpDestStr, size_t cchDest);
size_t UnicodeLengthOfUTF8 (PCSTR pUTF8);
size_t UTF8LengthOfUnicode (PCWSTR pUni);
size_t UnicodeLengthOfUTF8Cb (PCSTR pUTF8, size_t cbUTF);
size_t UTF8LengthOfUnicodeCch (PCWSTR pUni, size_t cchUni);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\assert.h ===
/***
*assert.h - define the assert macro
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the assert(exp) macro.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif




/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#undef  assert

#ifdef  NDEBUG

#define assert(exp)     ((void)0)

#else

#ifdef  __cplusplus
extern "C" {
#endif

_CRTIMP void __cdecl _assert(void *, void *, unsigned);

#ifdef  __cplusplus
}
#endif

#define assert(exp) (void)( (exp) || (_assert(#exp, __FILE__, __LINE__), 0) )

#endif  /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\langapi\undname\undname.inl ===
/*
 *	This module contains the definitions for the inline functions used by the
 *	name undecorator.  It is intended that this file should be included
 *	somewhere in the source file for the undecorator to maximise the chance
 *	that they will be truly inlined.
 */

//	The following class is a special node class, used in the implementation
//	of the internal chaining mechanism of the 'DName's

class	charNode;
class	pcharNode;
class	pDNameNode;
class	DNameStatusNode;


#if	( NO_VIRTUAL )
enum	NodeType
{
	charNode_t,
	pcharNode_t,
	pDNameNode_t,
	DNameStatusNode_t

};
#endif	// NO_VIRTUAL


class	DNameNode
{
private:

#if	NO_VIRTUAL
		NodeType			typeIndex;
#endif	// NO_VIRTUAL

		DNameNode *			next;

protected:

#if	( !NO_VIRTUAL )
					DNameNode ();
#else	// } elif NO_VIRTUAL {
					DNameNode ( NodeType );
#endif	// NO_VIRTUAL

					DNameNode ( const DNameNode & );

public:

virtual	int			length () const PURE;
virtual	char		getLastChar () const PURE;
virtual	pchar_t		getString ( pchar_t, int ) const PURE;
		DNameNode *	clone ();
		DNameNode *	nextNode () const;

		DNameNode &	operator += ( DNameNode * );

};


class	charNode		: public DNameNode
{
private:
		char				me;

public:
					charNode ( char );

virtual	int			length () const;
virtual	char		getLastChar () const;
virtual	pchar_t		getString ( pchar_t, int ) const;

};


class	pcharNode		: public DNameNode
{
private:
		pchar_t				me;
		int					myLen;

public:
					pcharNode ( pcchar_t, int = 0 );

virtual	int			length () const;
virtual	char		getLastChar () const;
virtual	pchar_t		getString ( pchar_t, int ) const;

};


class	pDNameNode		: public DNameNode
{
private:
		DName *				me;

public:
					pDNameNode ( DName * );

virtual	int			length () const;
virtual	char		getLastChar () const;
virtual	pchar_t		getString ( pchar_t, int ) const;

};


class	DNameStatusNode	: public DNameNode
{
private:
#define	TruncationMessage		(" ?? ")
#define	TruncationMessageLength	(4)

		DNameStatus			me;
		int					myLen;

public:
					DNameStatusNode ( DNameStatus );

virtual	int			length () const;
virtual	char		getLastChar () const;
virtual	pchar_t		getString ( pchar_t, int ) const;

};



//	Memory allocation functions
			
inline	void *	operator new ( size_t sz, HeapManager &, int noBuffer )
{	return	heap.getMemory ( sz, noBuffer );	}

void *	HeapManager::getMemory ( size_t sz, int noBuffer )
{
	//	Align the allocation on an appropriate boundary

	sz	= (( sz + PACK_SIZE-1 ) & ~(PACK_SIZE-1) );

	if	( noBuffer )
		return	( *pOpNew )( sz );
	else
	{
		//	Handle a potential request for no space

		if	( !sz )
			sz	= PACK_SIZE;

		if	( blockLeft < sz )
		{
			//	Is the request greater than the largest buffer size ?

			if	( sz > memBlockSize )
				return	0;		// If it is, there is nothing we can do


			//	Allocate a new block

			Block *	pNewBlock	= rnew Block;


			//	Did the allocation succeed ?  If so connect it up

			if	( pNewBlock )
			{
				//	Handle the initial state

				if	( tail )
					tail	= tail->next	= pNewBlock;
				else
					head	= tail			= pNewBlock;

				//	Compute the remaining space

				blockLeft	= memBlockSize - sz;

			}	// End of IF then
			else
				return	0;		// Oh-oh!  Memory allocation failure

		}	// End of IF then
		else
			blockLeft	-= sz;	// Deduct the allocated amount

		//	And return the buffer address

		return	&( tail->memBlock[ blockLeft ]);

	}	// End of IF else
}	// End of "HeapManager" FUNCTION "getMemory(size_t,int)"




//	Friend functions of 'DName'

inline DName	operator + ( char c, const DName & rd )
{	return	DName ( c ) + rd;	}

inline DName	operator + ( DNameStatus st, const DName & rd )
{	return	DName ( st ) + rd;	}

inline DName	operator + ( pcchar_t s, const DName & rd )
{	return	DName ( s ) + rd;	}


//	The 'DName' constructors

inline		DName::DName ()					{	node	= 0;	stat	= DN_valid;	isIndir	= 0;	isAUDC	= 0; isAUDTThunk = 0;	isArrayType = 0;	NoTE	= 0; }
inline		DName::DName ( DNameNode * pd )	{	node	= pd;	stat	= DN_valid;	isIndir	= 0;	isAUDC	= 0; isAUDTThunk = 0;	isArrayType = 0;	NoTE	= 0; }

DName::DName ( char c )
{
	stat	= DN_valid;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	node	= 0;
	NoTE	= 0;

	//	The NULL character is boring, do not copy

	if	( c )
		doPchar ( &c, 1 );

}	// End of "DName" CONSTRUCTOR '(char)'


inline DName::DName ( const DName & rd )
{
	stat	= rd.stat;
	isIndir	= rd.isIndir;
	isAUDC	= rd.isAUDC;
	isAUDTThunk = rd.isAUDTThunk;
	isArrayType = rd.isArrayType;
	node	= rd.node;
	NoTE	= rd.NoTE;
}	// End of "DName" CONSTRUCTOR '(const DName&)'


DName::DName ( DName * pd )
{
	if	( pd )
	{
		node	= gnew pDNameNode ( pd );
		stat	= ( node ? DN_valid : DN_error );

	}	// End of IF else
	else
	{
		stat	= DN_valid;
		node	= 0;

	}	// End of IF else

	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

}	// End of "DName" CONSTRUCTOR '( DName* )'


DName::DName ( pcchar_t s )
{
	stat	= DN_valid;
	node	= 0;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

	if	( s )
		doPchar ( s, und_strlen ( s ));

}	// End of "DName" CONSTRUCTOR '(pcchar_t)'


DName::DName ( pcchar_t & name, char terminator )
{
	stat	= DN_valid;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	node	= 0;
	NoTE	= 0;

	//	Is there a string ?

	if	( name )
		if	( *name )
		{
			int	len	= 0;


			//	How long is the string ?

			pcchar_t s;
			for	( s = name; *name && ( *name != terminator ); name++ )
				if	( isValidIdentChar ( *name ) || UnDecorator::doNoIdentCharCheck () )
					len++;
				else
				{
					stat	= DN_invalid;

					return;

				}	// End of IF else

			//	Copy the name string fragment

			doPchar ( s, len );

			//	Now gobble the terminator if present, handle error conditions

			if	( *name )
			{
				if	( *name++ != terminator )
				{
					stat	= DN_error;
					node	= 0;

				}	// End of IF then
				else
					stat	= DN_valid;

			}	// End of IF then
			elif	( status () == DN_valid )
				stat	= DN_truncated;

		}	// End of IF then
		else
			stat	= DN_truncated;
	else
		stat	= DN_invalid;

}	// End of "DName" CONSTRUCTOR '(pcchar_t&,char)'


DName::DName ( unsigned __int64 num )
{
	char	buf[ 21 ];
	char *	pBuf	= buf + 20;


	stat	= DN_valid;
	node	= 0;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

	//	Essentially, 'ultoa ( num, buf, 10 )' :-

	*pBuf	= 0;

	do
	{
		*( --pBuf )	= (char)(( num % 10ui64 ) + '0' );
		num			/= 10ui64;

	}	while	( num );

	doPchar ( pBuf, ( 20 - (int) ( pBuf - buf )));

}	// End of "DName" CONSTRUCTOR '(unsigned long)'

DName::DName ( __int64 num )
{
	char	buf[ 22 ];
	char *	pBuf	= buf + 21;

	stat	= DN_valid;
	node	= 0;
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

	//	Essentially, 'ltoa ( num, buf, 10 )' :-

	*pBuf	= 0;

	bool	fSigned = false;
	if (num < 0) {
		fSigned = true;
		num = -num;
	}

	do
	{
		*( --pBuf )	= (char)(( num % 10ui64 ) + '0' );
		num			/= 10ui64;

	}	while	( num );

	if (fSigned) {
		*(--pBuf) = '-';
	}

	doPchar ( pBuf, ( 21 - (int) ( pBuf - buf )));
}


DName::DName ( DNameStatus st )
{
	stat	= ((( st == DN_invalid ) || ( st == DN_error )) ? st : DN_valid );
	node	= gnew DNameStatusNode ( st );
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;
	NoTE	= 0;

	if	( !node )
		stat	= DN_error;

}	// End of "DName" CONSTRUCTOR '(DNameStatus)'



//	Now the member functions for 'DName'

int		DName::isValid () const		{	return	(( status () == DN_valid ) || ( status () == DN_truncated ));	}
int		DName::isEmpty () const		{	return	(( node == 0 ) || !isValid ());	}

inline	DNameStatus	DName::status () const	{	return	(DNameStatus)stat;	}	// The cast is to keep Glockenspiel quiet
inline	void	DName::clearStatus () { stat = DN_valid; }

inline	DName &	DName::setPtrRef ()			{	isIndir	= 1;	return	*this;	}
inline	int		DName::isPtrRef () const	{	return	isIndir;	}
inline	int		DName::isUDC () const		{	return	( !isEmpty () && isAUDC );	}
inline	void	DName::setIsUDC ()			{	if	( !isEmpty ())	isAUDC	= TRUE;	}
inline	int		DName::isUDTThunk () const		{	return	( !isEmpty () && isAUDTThunk );	}
inline	void	DName::setIsUDTThunk ()			{	if	( !isEmpty ())	isAUDTThunk	= TRUE;	}
inline	void	DName::setIsArray ()		{	isArrayType	= 1;	}
inline	int		DName::isArray () const		{	return	isArrayType;	}
inline	int				DName::isNoTE () const		{	return NoTE;	}
inline	void			DName::setIsNoTE ()			{	NoTE = TRUE;	}

int	DName::length () const
{
	int	len	= 0;


	if	( !isEmpty ())
		for	( DNameNode * pNode = node; pNode; pNode = pNode->nextNode ())
			len	+= pNode->length ();

	return	len;

}	// End of "DName" FUNCTION "length"


char	DName::getLastChar () const
{
	DNameNode * pLast = 0;

	if ( !isEmpty ())
		for ( DNameNode * pNode = node; pNode; pNode = pNode->nextNode ())
			if ( pNode->length () != 0 )
				pLast = pNode;

	return	pLast != 0 ? pLast->getLastChar () : '\0';

}	// End of "DName" FUNCTION "getLastChar"


pchar_t	DName::getString ( pchar_t buf, int max ) const
{
	if		( !isEmpty ())
	{
		//	Does the caller want a buffer allocated ?

		if	( !buf )
		{
			max	= length () + 1;
			buf	= gnew char[ max ];	// Get a buffer big enough

		}	// End of IF then

		//	If memory allocation failure, then return no buffer

		if	( buf )
		{
			//	Now, go through the process of filling the buffer (until max is reached)

			int			curLen	= max;
			DNameNode *	curNode	= node;
			pchar_t		curBuf	= buf;


			while	( curNode && ( curLen > 0 ))
			{
				int		fragLen	= curNode->length ();
				pchar_t	fragBuf	= 0;


				//	Skip empty nodes

				if	( fragLen )
				{
					//	Handle buffer overflow

					if	(( curLen - fragLen ) < 0 )
						fragLen	= curLen;

					//	Now copy 'len' number of bytes of the piece to the buffer

					fragBuf	= curNode->getString ( curBuf, fragLen );

					//	Should never happen, but handle it anyway

					if	( fragBuf )
					{
						//	Update string position

						curLen	-= fragLen;
						curBuf	+= fragLen;

					}	// End of IF
				}	// End of IF

				//	Move on to the next name fragment

				curNode	= curNode->nextNode ();

			}	// End of WHILE

			*curBuf	= 0;	// Always NULL terminate the resulting string

		}	// End of IF
	}	// End of IF then
	elif	( buf )
		*buf	= 0;

	//	Return the buffer

	return	buf;

}	// End of "DName" FUNCTION "getString(pchar_t,int)"


DName	DName::operator + ( char ch ) const
{
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= ch;
	else
		local	+= ch;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(char)"


DName	DName::operator + ( pcchar_t str ) const
{
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= str;
	else
		local	+= str;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(pcchar_t)"


DName	DName::operator + ( const DName & rd ) const
{
	DName	local ( *this );


	if		( local.isEmpty ())
		local	= rd;
	elif	( rd.isEmpty ())
		local	+= rd.status ();
	else
		local	+= rd;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(const DName&)"


DName	DName::operator + ( DName * pd ) const
{
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= pd;
	else
		local	+= pd;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(DName*)"


DName	DName::operator + ( DNameStatus st ) const
{
	DName	local ( *this );


	if	( local.isEmpty ())
		local	= st;
	else
		local	+= st;

	//	And return the newly formed 'DName'

	return	local;

}	// End of "DName" OPERATOR "+(DNameStatus)"



DName &	DName::operator += ( char ch )
{
	if	( ch )
		if	( isEmpty ())
			*this	= ch;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= gnew charNode ( ch );
			else
				stat	= DN_error;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(char)"


DName &	DName::operator += ( pcchar_t str )
{
	if	( str && *str )
		if	( isEmpty ())
			*this	= str;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= gnew pcharNode ( str );
			else
				stat	= DN_error;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(pcchar_t)"


DName &	DName::operator += ( const DName & rd )
{
	if	( rd.isEmpty ())
		*this	+= rd.status ();
	else
		if	( isEmpty ())
			*this	= rd;
		else
		{
			node	= node->clone ();

			if	( node )
				*node	+= rd.node;
			else
				stat	= DN_error;

		}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(const DName&)"


DName &	DName::operator += ( DName * pd )
{
	if	( pd )
		if		( isEmpty ())
			*this	= pd;
		elif	(( pd->status () == DN_valid ) || ( pd->status () == DN_truncated ))
		{
			DNameNode *	pNew	= gnew pDNameNode ( pd );


			if	( pNew )
			{
				node	= node->clone ();

				if	( node )
					*node	+= pNew;

			}	// End of IF then
			else
				node	= 0;

			if	( !node )
				stat	= DN_error;

		}	// End of IF then
		else
			*this	+= pd->status ();

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR "+=(DName*)"


DName &	DName::operator += ( DNameStatus st )
{
	if	( isEmpty () || (( st == DN_invalid ) || ( st == DN_error )))
		*this	= st;
	else
	{
		DNameNode *	pNew	= gnew DNameStatusNode ( st );


		if	( pNew )
		{
			node	= node->clone ();

			if	( node )
				*node	+= pNew;

		}	// End of IF then
		else
			node	= 0;

		if	( !node )
			stat	= DN_error;

	}	// End of IF else

	//	Return self

	return	*this;

}	// End of "DName" OPERATOR "+=(DNameStatus)"



DName &	DName::operator |= ( const DName & rd )
{
	//	Attenuate the error status.  Always becomes worse.  Don't propogate truncation

	if	(( status () != DN_error ) && !rd.isValid ())
		stat	= rd.status ();

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '|=(const DName&)'



DName &	DName::operator = ( char ch )
{
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;

	doPchar ( &ch, 1 );

	return	*this;

}	// End of "DName" OPERATOR '=(char)'


DName &	DName::operator = ( pcchar_t str )
{
	isIndir	= 0;
	isAUDC	= 0;
	isAUDTThunk = 0;
	isArrayType	= 0;

	doPchar ( str, und_strlen ( str ));

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(pcchar_t)'


DName &	DName::operator = ( const DName & rd )
{
	if	(( status () == DN_valid ) || ( status () == DN_truncated ))
	{
		stat	= rd.stat;
		isIndir	= rd.isIndir;
		isAUDC	= rd.isAUDC;
		isAUDTThunk = rd.isAUDTThunk;
		isArrayType	= rd.isArrayType;
		node	= rd.node;

	}	// End of IF

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(const DName&)'


DName &	DName::operator = ( DName * pd )
{
	if	(( status () == DN_valid ) || ( status () == DN_truncated ))
		if	( pd )
		{
			isIndir	= 0;
			isAUDC	= 0;
			isAUDTThunk = 0;
			isArrayType	= 0;
			node	= gnew pDNameNode ( pd );

			if	( !node )
				stat	= DN_error;

		}	// End of IF then
		else
			*this	= DN_error;

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(DName*)'


DName &	DName::operator = ( DNameStatus st )
{
	if	(( st == DN_invalid ) || ( st == DN_error ))
	{
		node	= 0;

		if	( status () != DN_error )
			stat	= st;

	}	// End of IF then
	elif	(( status () == DN_valid ) || ( status () == DN_truncated ))
	{
		isIndir	= 0;
		isAUDC	= 0;
		isAUDTThunk = 0;
		isArrayType	= 0;
		node	= gnew DNameStatusNode ( st );

		if	( !node )
			stat	= DN_error;

	}	// End of ELIF then

	//	And return self

	return	*this;

}	// End of "DName" OPERATOR '=(DNameStatus)'


//	Private implementation functions for 'DName'

void	DName::doPchar ( pcchar_t str, int len )
{
	if	( !(( status () == DN_invalid ) || ( status () == DN_error )))
		if		( node )
			*this	= DN_error;
		elif	( str && len )
		{
			//	Allocate as economically as possible

			switch	( len )
			{
			case 0:
					stat	= DN_error;
				break;

			case 1:
					node	= gnew charNode ( *str );

					if	( !node )
						stat	= DN_error;
				break;

			default:
					node	= gnew pcharNode ( str, len );

					if	( !node )
						stat	= DN_error;
				break;

			}	// End of SWITCH
		}	// End of ELIF
		else
			stat	= DN_invalid;

}	// End of "DName" FUNCTION "doPchar(pcchar_t,int)"



//	The member functions for the 'Replicator'

inline	int	Replicator::isFull () const		{	return	( index == 9 );	}
inline		Replicator::Replicator ()
:	ErrorDName ( DN_error ), InvalidDName ( DN_invalid )
{	index	= -1;	}



Replicator &	Replicator::operator += ( const DName & rd )
{
	if	( !isFull () && !rd.isEmpty ())
	{
		DName *	pNew	= gnew DName ( rd );


		//	Don't update if failed

		if	( pNew )
			dNameBuffer[ ++index ]	= pNew;

	}	// End of IF

	return	*this;

}	// End of "Replicator" OPERATOR '+=(const DName&)'


const DName &	Replicator::operator [] ( int x ) const
{
	if		(( x < 0 ) || ( x > 9 ))
		return	ErrorDName;
	elif	(( index == -1 ) || ( x > index ))
		return	InvalidDName;
	else
		return	*dNameBuffer[ x ];

}	// End of "Replicator" OPERATOR '[](int)'



//	The member functions for the 'DNameNode' classes

#if	( !NO_VIRTUAL )
DNameNode::DNameNode ()
#else	// } elif NO_VIRTUAL {
DNameNode::DNameNode ( NodeType ndTy )
:	typeIndex ( ndTy )
#endif	// NO_VIRTUAL
{	next	= 0;	}

inline	DNameNode::DNameNode ( const DNameNode & rd )	{	next	= (( rd.next ) ? rd.next->clone () : 0 );	}

inline	DNameNode *	DNameNode::nextNode () const		{	return	next;	}

DNameNode *	DNameNode::clone ()
{
	return	gnew pDNameNode ( gnew DName ( this ));
}

#if	( NO_VIRTUAL )
int	DNameNode::length () const
{	//	Pure function, should not be called

	switch	( typeIndex )
	{
	case charNode_t:
		return	((charNode*)this )->length ();

	case pcharNode_t:
		return	((pcharNode*)this )->length ();

	case pDNameNode_t:
		return	((pDNameNode*)this )->length ();

	case DNameStatusNode_t:
		return	((DNameStatusNode*)this )->length ();

	}	// End of SWITCH

	return	0;
}


char	DNameNode::getLastChar () const
{	//	Pure function, should not be called

	switch	( typeIndex )
	{
	case charNode_t:
		return	((charNode*)this )->getLastChar ();

	case pcharNode_t:
		return	((pcharNode*)this )->getLastChar ();

	case pDNameNode_t:
		return	((pDNameNode*)this )->getLastChar ();

	case DNameStatusNode_t:
		return	((DNameStatusNode*)this )->getLastChar ();

	}	// End of SWITCH

	return	0;
}


pchar_t	DNameNode::getString ( pchar_t s, int l ) const
{	//	Pure function, should not be called

	switch	( typeIndex )
	{
	case charNode_t:
		return	((charNode*)this )->getString ( s, l );

	case pcharNode_t:
		return	((pcharNode*)this )->getString ( s, l );

	case pDNameNode_t:
		return	((pDNameNode*)this )->getString ( s, l );

	case DNameStatusNode_t:
		return	((DNameStatusNode*)this )->getString ( s, l );

	}	// End of SWITCH

	return	0;
}
#endif	// NO_VIRTUAL


DNameNode &	DNameNode::operator += ( DNameNode * pNode )
{
	if	( pNode )
	{
		if	( next )
		{
			//	Skip to the end of the chain

			DNameNode* pScan;
			for	( pScan = next; pScan->next; pScan = pScan->next )
				;

			//	And append the new node

			pScan->next	= pNode;

		}	// End of IF then
		else
			next	= pNode;

	}	// End of IF

	//	And return self

	return	*this;

}	// End of "DNameNode" OPERATOR '+=(DNameNode*)'



//	The 'charNode' virtual functions

charNode::charNode ( char ch )
#if	( NO_VIRTUAL )
:	DNameNode ( charNode_t )
#endif	// NO_VIRTUAL
{	me	= ch;	}

inline	int	charNode::length () const		{	return	1;	}

inline	char charNode::getLastChar () const	{	return	me;	}

pchar_t	charNode::getString ( pchar_t buf, int len ) const
{
	if	( buf && len )
		*buf	= me;
	else
		buf		= 0;

	//	Now return the character

	return	buf;

}	// End of "charNode" FUNCTION "getString(pchar_t,int)"



//	The 'pcharNode' virtual functions

inline	int	pcharNode::length () const		{	return	myLen;	}

inline	char pcharNode::getLastChar () const	{	return	( myLen ? me[ myLen - 1 ] : '\0' );	}

pcharNode::pcharNode ( pcchar_t str, int len )
#if ( NO_VIRTUAL )
:	DNameNode ( pcharNode_t )
#endif	// NO_VIRTUAL
{
	//	Get length if not supplied

	if	( !len && str )
		len	= und_strlen ( str );

	//	Allocate a new string buffer if valid state

	if	( len && str )
	{
		me		= gnew char[ len ];
		myLen	= len;

		if	( me )
			und_strncpy ( me, str, len );

	}	// End of IF then
	else
	{
		me		= 0;
		myLen	= 0;

	}	// End of IF else
}	// End of "pcharNode" CONSTRUCTOR '(pcchar_t,int)'


pchar_t	pcharNode::getString ( pchar_t buf, int len ) const
{
	//	Use the shorter of the two lengths (may not be NULL terminated)

	if	( len > pcharNode::length ())
		len	= pcharNode::length ();

	//	Do the copy as appropriate

	return	(( me && buf && len ) ? und_strncpy ( buf, me, len ) : 0 );

}	// End of "pcharNode" FUNCTION "getString(pchar_t,int)"



//	The 'pDNameNode' virtual functions

pDNameNode::pDNameNode ( DName * pName )
#if	( NO_VIRTUAL )
:	DNameNode ( pDNameNode_t )
#endif	// NO_VIRTUAL
{	me	= (( pName && (( pName->status () == DN_invalid ) || ( pName->status () == DN_error ))) ? 0 : pName );	}

inline	int	pDNameNode::length () const					{	return	( me ? me->length () : 0 );	}

inline	char pDNameNode::getLastChar () const			{	return	( me ? me->getLastChar () : '\0' ); }

pchar_t	pDNameNode::getString ( pchar_t buf, int len ) const
{	return	(( me && buf && len ) ? me->getString ( buf, len ) : 0 );	}



//	The 'DNameStatusNode' virtual functions

DNameStatusNode::DNameStatusNode ( DNameStatus stat )
#if	( NO_VIRTUAL )
:	DNameNode ( DNameStatusNode_t )
#endif	// NO_VIRTUAL
{	me	= stat;	myLen	= (( me == DN_truncated ) ? TruncationMessageLength : 0 );	}

inline	int	DNameStatusNode::length () const	{	return	myLen;	}

inline	char DNameStatusNode::getLastChar () const
{	return (( me == DN_truncated ) ? TruncationMessage[ TruncationMessageLength - 1 ] : '\0' );	}

pchar_t	DNameStatusNode::getString ( pchar_t buf, int len ) const
{
	//	Use the shorter of the two lengths (may not be NULL terminated)

	if	( len > DNameStatusNode::length ())
		len	= DNameStatusNode::length ();

	//	Do the copy as appropriate

	return	((( me == DN_truncated ) && buf && len ) ? und_strncpy ( buf, TruncationMessage, len ) : 0 );

}	// End of "DNameStatusNode" FUNCTION "getString(pchar_t,int)"


static	unsigned int	und_strlen ( pcchar_t str )
{
	unsigned int len;

	for	( len = 0; *str; str++ )
		len++;

	return	len;

}	// End of FUNCTION "und_strlen"


static	pchar_t			und_strncpy ( pchar_t dst, pcchar_t src, unsigned int len )
{
	for	( char * d = dst; ( len && ( *d = *src )); d++, src++, len-- )
		;

	return	dst;

}	// End of FUNCTION "und_strncpy"

static	unsigned int	und_strncmp ( pcchar_t first, pcchar_t last, unsigned int count)
{
	if (!count)
		return(0);

	while (--count && *first && *first == *last)
	{
		first++;
		last++;
	}

	return( *(unsigned char *)first - *(unsigned char *)last );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\langapi\undname\undname.cxx ===
//	Make sure all dependent defines exist and have a valid value

#ifndef	NO_COMPILER_NAMES
#define	NO_COMPILER_NAMES		0
#endif

#ifndef VERS_32BIT
#define VERS_32BIT				1
#endif

#ifndef PACK_SIZE
#ifdef _CRTBLD
#define PACK_SIZE				8
#elif !VERS_32BIT
#define PACK_SIZE				2
#elif defined(_X86_)
#define PACK_SIZE				4
#else
#define PACK_SIZE				8
#endif
#endif

//	Check for version inconsistancies, and setup version flags

#ifdef	VERS_BSC
	#undef	NO_COMPILER_NAMES
	#define	NO_COMPILER_NAMES	1

	#pragma	inline_depth ( 3 )
	#pragma	check_stack ( off )
#else
	#pragma	inline_depth ( 3 )
	#pragma	check_stack ( off )
#endif


#define	PURE	= 0

#ifndef CC_COR
#define CC_COR 1
#endif

#include	"undname.hxx"

#if !defined(_CRTBLD) && (!VERSP_RELEASE || defined(_DEBUG))
#include	<assert.h>
#define DASSERT(x) assert(x)
#else
#define DASSERT(x)
#endif

#if (defined(_CRTBLD) && defined(_MT))
#include <mtdll.h>
#endif

#include <stdio.h>
#include <windows.h>
#include "utf8.h"

#pragma warning(disable:4291)	// No matching operator delete

static	unsigned int	und_strlen ( pcchar_t );
static	pchar_t			und_strncpy ( pchar_t, pcchar_t, unsigned int );
static	unsigned int	und_strncmp ( pcchar_t, pcchar_t, unsigned int );

class	DName;
class	DNameNode;
class	Replicator;
class	HeapManager;
class	UnDecorator;


// A '512' byte block including the header
const   unsigned int    memBlockSize = 512 - sizeof(void*);


class	HeapManager
{
private:
		Alloc_t			pOpNew;
		Free_t			pOpDelete;

		struct	Block
		{
			Block *		next;
			char		memBlock[ memBlockSize ];

				__near	Block ()	{	next	= 0;	}

		};

		Block *			head;
		Block *			tail;
		size_t			blockLeft;

public:
		void	__near	Constructor ( Alloc_t pAlloc, Free_t pFree )
						{	pOpNew		= pAlloc;
							pOpDelete	= pFree;
							blockLeft	= 0;
							head		= 0;
							tail		= 0;
						}

		void __far *	__near	getMemory ( size_t, int );

		void	__near	Destructor ( void )
						{	if	( pOpDelete != 0 )
								while	( tail = head )
								{
									head	= tail->next;

									( *pOpDelete )( tail );

								}
						}

		#define	gnew	new(heap,0)
		#define	rnew	new(heap,1)

};



void   *	operator new ( size_t, HeapManager &, int = 0 );



static	HeapManager	heap;


//	The MS Token table

enum	Tokens
{
#if !VERS_32BIT
	TOK_near,
	TOK_nearSp,
	TOK_nearP,
	TOK_far,
	TOK_farSp,
	TOK_farP,
	TOK_huge,
	TOK_hugeSp,
	TOK_hugeP,
#endif
	TOK_basedLp,
	TOK_cdecl,
	TOK_pascal,
	TOK_stdcall,
	TOK_thiscall,
	TOK_fastcall,
	TOK_cocall,
	TOK_ptr64,
	TOK_restrict,
	TOK_unaligned,
#if !VERS_32BIT
	TOK_interrupt,
	TOK_saveregs,
	TOK_self,
	TOK_segment,
	TOK_segnameLpQ,
#endif
	TOK__last
};


static	const pcchar_t	__near	tokenTable[]	=
{
#if !VERS_32BIT
	"__near",		// TOK_near
	"__near ",		// TOK_nearSp
	"__near*",		// TOK_nearP
	"__far",		// TOK_far
	"__far ",		// TOK_farSp
	"__far*",		// TOK_farP
	"__huge",		// TOK_huge
	"__huge ",		// TOK_hugeSp
	"__huge*",		// TOK_hugeP
#endif
	"__based(",		// TOK_basedLp
	"__cdecl",		// TOK_cdecl
	"__pascal",		// TOK_pascal
	"__stdcall",	// TOK_stdcall
	"__thiscall",	// TOK_thiscall
	"__fastcall",	// TOK_fastcall
	"__clrcall",		// TOK_cocall
	"__ptr64",		// TOK_ptr64
	"__restrict",	// TOK_restrict
	"__unaligned",	// TOK_unaligned
#if !VERS_32BIT
	"__interrupt",	// TOK_interrupt
	"__saveregs",	// TOK_saveregs
	"__self",		// TOK_self
	"__segment",	// TOK_segment
	"__segname(\"",	// TOK_segnameLpQ
#endif
	""
};


//	The operator mapping table

static	const pcchar_t	__near	nameTable[]	=
{
	" new",
	" delete",
	"=",
	">>",
	"<<",
	"!",
	"==",
	"!=",
	"[]",
	"operator",
	"->",
	"*",
	"++",
	"--",
	"-",
	"+",
	"&",
	"->*",
	"/",
	"%",
	"<",
	"<=",
	">",
	">=",
	",",
	"()",
	"~",
	"^",
	"|",
	"&&",
	"||",
	"*=",
	"+=",
	"-=",
	"/=",
	"%=",
	">>=",
	"<<=",
	"&=",
	"|=",
	"^=",

#if	( !NO_COMPILER_NAMES )
	"`vftable'",
	"`vbtable'",
	"`vcall'",
	"`typeof'",
	"`local static guard'",
	"`string'",
	"`vbase destructor'",
	"`vector deleting destructor'",
	"`default constructor closure'",
	"`scalar deleting destructor'",
	"`vector constructor iterator'",
	"`vector destructor iterator'",
	"`vector vbase constructor iterator'",
	"`virtual displacement map'",
	"`eh vector constructor iterator'",
	"`eh vector destructor iterator'",
	"`eh vector vbase constructor iterator'",
	"`copy constructor closure'",
	"`udt returning'",
	"`EH", //eh initialized struct
	"`RTTI", //rtti initialized struct
	"`local vftable'",
	"`local vftable constructor closure'",
#endif	// !NO_COMPILER_NAMES

	" new[]",
	" delete[]",

#if ( !NO_COMPILER_NAMES )
	"`omni callsig'",
	"`placement delete closure'",
	"`placement delete[] closure'",
	"`managed vector constructor iterator'",
	"`managed vector destructor iterator'",
	"`eh vector copy constructor iterator'",
	"`eh vector vbase copy constructor iterator'",
#endif

	""
};

static const pcchar_t ehTable[] =
{
	" Ptr to Member Data'",
	" Catchable Type'",
	" Catchable Type Array'",
	" ThrowInfo'",
};

static const pcchar_t rttiTable[] =
{
	" Type Descriptor'",
	" Base Class Descriptor at (",
	" Base Class Array'",
	" Class Hierarchy Descriptor'",
	" Complete Object Locator'",
};


//	The following 'enum' should really be nested inside 'class DName', but to
//	make the code compile better with Glockenspiel, I have extracted it

enum	DNameStatus
{
	DN_valid,
	DN_invalid,
	DN_truncated,
	DN_error
};


class	DName
{
public:
					DName ();
					DName ( char );

					DName ( const DName & );		// Shallow copy

					DName ( DNameNode * );
					DName ( pcchar_t );
					DName ( pcchar_t&, char );
					DName ( DNameStatus );
					DName ( DName * );
					DName ( unsigned __int64 );
					DName ( __int64 );

		int			isValid () const;
		int			isEmpty () const;
		DNameStatus	status () const;
		void		clearStatus ();

		DName &		setPtrRef ();
		int			isPtrRef () const;
		int			isUDC () const;
		void		setIsUDC ();
		int			isUDTThunk () const;
		void		setIsUDTThunk ();
		int			isArray() const;
		void		setIsArray();
		int			isNoTE () const;
		void		setIsNoTE ();

		int			length () const;
		char		getLastChar () const;
		pchar_t		getString ( pchar_t, int ) const;

		DName		operator + ( pcchar_t ) const;
		DName		operator + ( const DName & ) const;
		DName		operator + ( char ) const;
		DName		operator + ( DName * ) const;
		DName		operator + ( DNameStatus ) const;

		DName &		operator += ( char );
		DName &		operator += ( pcchar_t );
		DName &		operator += ( DName * );
		DName &		operator += ( DNameStatus );
		DName &		operator += ( const DName & );

		DName &		operator |= ( const DName & );

		DName &		operator = ( pcchar_t );
		DName &		operator = ( const DName & );
		DName &		operator = ( char );
		DName &		operator = ( DName * );
		DName &		operator = ( DNameStatus );

//	Friends :

friend	DName		operator + ( char, const DName & );
friend	DName		operator + ( pcchar_t, const DName & );
friend	DName		operator + ( DNameStatus, const DName & );

private:
		DNameNode *		node;

		DNameStatus		stat	: 4;
		unsigned int	isIndir	: 1;
		unsigned int	isAUDC	: 1;
		unsigned int	isAUDTThunk	: 1;
		unsigned int	isArrayType	: 1;
		unsigned int	NoTE	: 1;

		void			doPchar ( pcchar_t, int );

};



class	Replicator
{
private:
		//	Declare, in order to suppress automatic generation
		void			operator = ( const Replicator& );

		int				index;
		DName *			dNameBuffer[ 10 ];
		const DName		ErrorDName;
		const DName		InvalidDName;

public:
						Replicator ();

		int				isFull () const;

		Replicator &	operator += ( const DName & );
		const DName &	operator [] ( int ) const;

};



class	UnDecorator
{
private:
		//	Declare, in order to suppress automatic generation
		void			operator = ( const UnDecorator& );

		Replicator		ArgList;
static	Replicator *	pArgList;

		Replicator		ZNameList;
static	Replicator *	pZNameList;

static	Replicator *	pTemplateArgList;

static	pcchar_t		gName;
static	pcchar_t		name;
static	pchar_t			outputString;
static	int				maxStringLength;
static	unsigned long	disableFlags;
static	bool			fExplicitTemplateParams;
static	bool			fGetTemplateArgumentList;

static	DName	getDecoratedName ( void );
static	DName	getSymbolName ( void );
static	DName	getZName ( bool fUpdateCachedNames );
static	DName	getOperatorName ( bool fIsTemplate, bool *pfReadTemplateArguments );
static	DName	getScope ( void );
static	DName			getScopedName ( void );
static	DName	getSignedDimension ( void );
static	DName	getDimension ( bool fSigned = false );
static	int		getNumberOfDimensions ( void );
static	DName	getTemplateName ( bool );
static	DName	getTemplateArgumentList( void );
static	DName	getTemplateConstant( void );
static	DName	composeDeclaration ( const DName & );
static	int		getTypeEncoding ( void );
static	DName	getBasedType ( void );
static	DName	getECSUName ( void );
static	DName	getEnumType ( void );
static	DName	getCallingConvention ( void );
static	DName	getReturnType ( DName * = 0 );
static	DName	getDataType ( DName * );
static	DName	getPrimaryDataType ( const DName & );
static	DName	getDataIndirectType ( const DName &, char, const DName &, int = FALSE );
static	DName	getDataIndirectType ();
static	DName	getBasicDataType ( const DName & );
static	DName	getECSUDataType ( void );
static	DName	getPtrRefType ( const DName &, const DName &, char );
static	DName	getPtrRefDataType ( const DName &, int );
static	DName	getArrayType ( const DName& );
static	DName	getFunctionIndirectType( const DName & superType );
static	DName	getArgumentTypes ( void );
static	DName	getArgumentList ( void );
static	DName	getThrowTypes ( void );
static	DName	getLexicalFrame ( void );
static	DName	getStorageConvention ( void );
static	DName	getThisType ( void );
static	DName	getPointerType ( const DName &, const DName & );
static	DName	getPointerTypeArray ( const DName &, const DName & );
static	DName	getReferenceType ( const DName &, const DName & );
static	DName	getExternalDataType ( const DName & );
static	DName	getSegmentName ( void );

#if	( !NO_COMPILER_NAMES )
static	DName	getDisplacement ( void );
static	DName	getCallIndex ( void );
static	DName	getGuardNumber ( void );
static	DName	getVfTableType ( const DName & );
static	DName	getVbTableType ( const DName & );
static	DName	getVdispMapType	( const DName & );
static	DName	getVCallThunkType ( void );
#endif	// !NO_COMPILER_NAMES

static	DName	getStringEncoding ( char *prefix, int wantBody );

static GetParameter_t m_pGetParameter;

public:
				UnDecorator ( pchar_t, pcchar_t, int, GetParameter_t, unsigned long );

static	int		doUnderScore ();
static	int		doMSKeywords ();
static	int		doPtr64 ();
static	int		doFunctionReturns ();
static	int		doAllocationModel ();
static	int		doAllocationLanguage ();

#if	0
static	int		doMSThisType ();
static	int		doCVThisType ();
#endif

static	int		doThisTypes ();
static	int		doAccessSpecifiers ();
static	int		doThrowTypes ();
static	int		doMemberTypes ();
static	int		doReturnUDTModel ();

static	int		do32BitNear ();

static	int		doNameOnly ();
static	int		doTypeOnly ();
static	int		haveTemplateParameters ();
static	int		doEcsu ();
static	int		doNoIdentCharCheck ();

static	pcchar_t	UScore ( Tokens );

				operator pchar_t ();

};



Replicator *	UnDecorator::pArgList;
Replicator *	UnDecorator::pZNameList			= 0;
Replicator *	UnDecorator::pTemplateArgList	= 0;
pcchar_t		UnDecorator::gName				= 0;
pcchar_t		UnDecorator::name				= 0;
pchar_t			UnDecorator::outputString		= 0;
int				UnDecorator::maxStringLength	= 0;
unsigned long	UnDecorator::disableFlags		= 0;
GetParameter_t	UnDecorator::m_pGetParameter	= 0;
bool			UnDecorator::fExplicitTemplateParams = false;
bool			UnDecorator::fGetTemplateArgumentList = false;


#ifdef _CRTBLD
pchar_t	__far _CRTIMP __loadds	__unDName (	pchar_t outputString,
#else
pchar_t	__far __cdecl __loadds	unDName (	pchar_t outputString,
#endif
											pcchar_t name,
											int maxStringLength,	// Note, COMMA is leading following optional arguments
											Alloc_t pAlloc,
											Free_t pFree,
											unsigned short disableFlags

										)
/*
 *	This function will undecorate a name, returning the string corresponding to
 *	the C++ declaration needed to produce the name.  Its has a similar interface
 *	to 'strncpy'.
 *
 *	If the target string 'outputString' is specified to be NULL, a string of
 *	suitable length will be allocated and its address returned.  If the returned
 *	string is allocated by 'unDName', then it is the programmers responsibility
 *	to deallocate it.  It will have been allocated on the far heap.
 *
 *	If the target string is not NULL, then the parameter 'maxStringLength' will
 *	specify the maximum number of characters which may be placed in the string.
 *	In this case, the returned value is the same as 'outputString'.
 *
 *	Both the input parameter 'name' and the returned string are NULL terminated
 *	strings of characters.
 *
 *	If the returned value is NULL, it indicates that the undecorator ran out of
 *	memory, or an internal error occurred, and was unable to complete its task.
 */

{
	//	Must have an allocator and a deallocator (and we MUST trust them)
	if	( !( pAlloc ))
		return	0;
	
	pchar_t		unDecoratedName;

#if (defined(_CRTBLD) && defined(_MT))
	if (!_mtinitlocknum(_UNDNAME_LOCK))
		return	0;
	_mlock(_UNDNAME_LOCK);
	__try {
#endif

	heap.Constructor ( pAlloc, pFree );

	//	Create the undecorator object, and get the result

	UnDecorator	unDecorate (	outputString,
								name,
								maxStringLength,
								0,
								disableFlags
							);
	unDecoratedName	= unDecorate;


	// Destruct the heap (would use a destructor, but that causes DLL problems)

	heap.Destructor ();

#if (defined(_CRTBLD) && defined(_MT))
	} __finally {
		_munlock(_UNDNAME_LOCK);
	}
#endif

	//	And return the composed name

	return unDecoratedName;

}	// End of FUNCTION "unDName"




#ifdef _CRTBLD
pchar_t	__far _CRTIMP __loadds	__unDNameEx (	pchar_t outputString,
#else
pchar_t	__far __cdecl __loadds	unDNameEx (	pchar_t outputString,
#endif
											pcchar_t name,
											int maxStringLength,	// Note, COMMA is leading following optional arguments
											Alloc_t pAlloc,
											Free_t pFree,
											GetParameter_t pGetParameter,
											unsigned long disableFlags

										)
/*
 *	This function will undecorate a name, returning the string corresponding to
 *	the C++ declaration needed to produce the name.  Its has a similar interface
 *	to 'strncpy'.
 *
 *	If the target string 'outputString' is specified to be NULL, a string of
 *	suitable length will be allocated and its address returned.  If the returned
 *	string is allocated by 'unDName', then it is the programmers responsibility
 *	to deallocate it.  It will have been allocated on the far heap.
 *
 *	If the target string is not NULL, then the parameter 'maxStringLength' will
 *	specify the maximum number of characters which may be placed in the string.
 *	In this case, the returned value is the same as 'outputString'.
 *
 *	Both the input parameter 'name' and the returned string are NULL terminated
 *	strings of characters.
 *
 *	If the returned value is NULL, it indicates that the undecorator ran out of
 *	memory, or an internal error occurred, and was unable to complete its task.
 */

{
	//	Must have an allocator and a deallocator (and we MUST trust them)

	if	( !( pAlloc ))
		return	0;

	pchar_t		unDecoratedName;

#if (defined(_CRTBLD) && defined(_MT))
	if (!_mtinitlocknum(_UNDNAME_LOCK))
		return	0;
	_mlock(_UNDNAME_LOCK);
	__try {
#endif

	heap.Constructor ( pAlloc, pFree );

	//	Create the undecorator object, and get the result

	UnDecorator	unDecorate (	outputString,
								name,
								maxStringLength,
								pGetParameter,
								disableFlags
							);
	unDecoratedName	= unDecorate;


	// Destruct the heap (would use a destructor, but that causes DLL problems)

	heap.Destructor ();

#if (defined(_CRTBLD) && defined(_MT))
	} __finally {
		_munlock(_UNDNAME_LOCK);
	}
#endif

	//	And return the composed name

	return	unDecoratedName;

}	// End of FUNCTION "unDName"

//	The 'UnDecorator' member functions

inline	UnDecorator::UnDecorator	(	pchar_t output,
										pcchar_t dName,
										int maxLen,
										GetParameter_t pGetParameter,
										unsigned long disable
									)
{
	name			= dName;
	gName			= name;

	if	( output ) {
		maxStringLength	= maxLen - 1;	// The algorithm in getString doesn't leave room
										// for terminating NULL; be paranoid and leave one
										// extra char.
										// It's a lot easier to fix this here....
		outputString	= output;	
	}
	else {
		outputString	= 0;
		maxStringLength	= 0;
	}

	pZNameList		= &ZNameList;
	pArgList		= &ArgList;
	disableFlags	= disable;
	m_pGetParameter	= pGetParameter;
	fExplicitTemplateParams = false;

}	// End of "UnDecorator" CONSTRUCTOR '()'


inline	UnDecorator::operator pchar_t ()
{
	DName		result;
	DName		unDName;


	//	Find out if the name is a decorated name or not.  Could be a reserved
	//	CodeView variant of a decorated name

	if	( name )
	{
		if	(( *name == '?' ) && ( name[ 1 ] == '@' ))
		{
#if	( !NO_COMPILER_NAMES )
			gName	+= 2;
			result	= "CV: " + getDecoratedName ();
#else	// } elif NO_COMPILER_NAMES
			result	= DN_invalid;
#endif	// NO_COMPILER_NAMES

		}	// End of IF then
		else if	(( *name == '?' ) && ( name[1] == '$' )) {
			result = getTemplateName( false );

			if ( result.status () == DN_invalid ) {
				// 
				// What harm could there be to try again ?
				//	Repro:
				//		?$S1@?1??VTFromRegType@CRegParser@ATL@@KAHPBGAAG@Z@4IA
				//	---> unsigned int `protected: static int __cdecl ATL::CRegParser::VTFromRegType(unsigned short const *,unsigned short &)'::`2'::$S1
				//
				//	This is a compiler generated symbol for a local static array init.
				//
				gName = name;
				result.clearStatus();
				result	= getDecoratedName ();
			}
		} else {
			result	= getDecoratedName ();
		}

	}	// End of IF then

	//	If the name was not a valid name, then make the name the same as the original
	//	It is also invalid if there are any remaining characters in the name (except when
	//	we're giving the name only)

	if		( result.status () == DN_error )
		return	0;
	elif	( (*gName && !doNameOnly ()) || ( result.status () == DN_invalid ))
		unDName	= name;	// Return the original name
	else
		unDName	= result;

	//	Construct the return string

	if	( !outputString )
	{
		maxStringLength	= unDName.length () + 1;
		outputString 	= rnew char[ maxStringLength ];

	}	// End of IF

	if	( outputString ) {
		unDName.getString ( outputString, maxStringLength );

		// strip extra whitespace out of name
		pchar_t pRead = outputString;
		pchar_t pWrite = pRead;
		while (*pRead) {
			if (*pRead == ' ') {
				pRead++;
				*pWrite++ = ' ';
				while ( *pRead == ' ' ) {
					pRead++;
				}
			}
			else
				*pWrite++ = *pRead++;
		}
		*pWrite = *pRead;
	}

	//	Return the result

	return	outputString;

}	// End of "UnDecorator" OPERATOR 'pchar_t'



DName	UnDecorator::getDecoratedName ( void )
{
	//	Ensure that it is intended to be a decorated name

	if		( doTypeOnly() )
	{
		// Disable the type-only flag, so that if we get here recursively, eg.
		// in a template tag, we do full name undecoration.
		disableFlags &= ~UNDNAME_TYPE_ONLY;

		// If we're decoding just a type, process it as the type for an abstract
		// declarator, by giving an empty symbol name.

		DName	result = getDataType ( NULL );
		disableFlags |= UNDNAME_TYPE_ONLY;

		return result;
	}
	elif	( *gName == '?' )
	{
		//	Extract the basic symbol name

		gName++;	// Advance the original name pointer


		DName	symbolName	= getSymbolName ();																						
		int		udcSeen		= symbolName.isUDC ();

		//	Abort if the symbol name is invalid

		if	( !symbolName.isValid ())
			return	symbolName;

		//	Extract, and prefix the scope qualifiers

		if	( *gName && ( *gName != '@' )) {
			DName	scope = getScope ();
			
			if	( !scope.isEmpty() )
				if (fExplicitTemplateParams) {
					fExplicitTemplateParams = false;
					symbolName	= symbolName + scope;
					if (*gName != '@') {
						scope = getScope();					
						symbolName	= scope + "::" + symbolName;
					}
				} else {
					symbolName	= scope + "::" + symbolName;
				}
			}

		if	( udcSeen )
			symbolName.setIsUDC ();

		//	Now compose declaration

		if	( symbolName.isEmpty () || symbolName.isNoTE() )
		{
			return	symbolName;
		}
		elif	( !*gName || ( *gName == '@' ) )
		{
			if	( *gName )
				gName++;

			if	(doNameOnly () && !udcSeen) {
				// Eat the rest of the dname, in case this is a recursive invocation,
				// such as for a template argument.
				(void)composeDeclaration( DName() );
				return symbolName;
			}
			else {
				return	composeDeclaration ( symbolName );
			}

		}	// End of ELIF then
		else
			return	DN_invalid;

	}	// End of IF then
	elif	( *gName )
		return	DN_invalid;
	else
		return	DN_truncated;

}	// End of "UnDecorator" FUNCTION "getDecoratedName"



inline DName UnDecorator::getSymbolName()
{
	if (gName[0] == '?') {
		if (gName[1] == '$') {
			return getTemplateName(true);
		}
		else {
			gName += 1;

			return getOperatorName(false, NULL);
		}
	}
	else {
		return getZName(true);
	}
}


DName	UnDecorator::getZName ( bool fUpdateCachedNames )
{
	int		zNameIndex	= *gName - '0';


	//	Handle 'zname-replicators', otherwise an actual name

	if	(( zNameIndex >= 0 ) && ( zNameIndex <= 9 ))
	{
		gName++;	// Skip past the replicator

		//	And return the indexed name

		return	( *pZNameList )[ zNameIndex ];

	}	// End of IF then
	else
	{
		DName	zName;

		if	( *gName == '?' )
		{
			zName	= getTemplateName( false );

			if	( *gName++ != '@' )
				zName	= *--gName ? DN_invalid : DN_truncated;
		}
		else {
			#define TEMPLATE_PARAMETER "template-parameter-"
			#define TEMPLATE_PARAMETER_LEN 19
			#define GENERIC_TYPE "generic-type-"
			#define GENERIC_TYPE_LEN 13

			pchar_t genericType;
			if (und_strncmp(gName, TEMPLATE_PARAMETER, TEMPLATE_PARAMETER_LEN) == 0) {
				genericType = TEMPLATE_PARAMETER;
				gName += TEMPLATE_PARAMETER_LEN;
			} else if (und_strncmp(gName, GENERIC_TYPE, GENERIC_TYPE_LEN) == 0) {
				genericType = GENERIC_TYPE;
				gName += GENERIC_TYPE_LEN;
			} else {
				genericType = NULL;
			}

			if (genericType) {
				DName dimension = getSignedDimension();

				if ( haveTemplateParameters()) {
					char buffer[16];

					dimension.getString( buffer, 16 );

					char *str = (*m_pGetParameter)(atol(buffer));

					if ( str != NULL ) {
						zName = str;
					}
					else {
						zName = "`";
						zName += genericType + dimension + "'";
					}
				}
				else {
					zName = "`";
					zName += genericType + dimension + "'";
				}
			}
			else {
				//	Extract the 'zname' to the terminator

				zName	= DName( gName, '@' );	// This constructor updates 'name'
			}
		}


		//	Add it to the current list of 'zname's

		if	( fUpdateCachedNames && !pZNameList->isFull ())
			*pZNameList	+= zName;

		//	And return the symbol name
		return	zName;

	}	// End of IF else
}	// End of "UnDecorator" FUNCTION "getZName"



inline	DName	UnDecorator::getOperatorName ( bool fIsTemplate, bool *pfReadTemplateArguments )
{
	DName	operatorName;
	DName	tmpName;
	int		udcSeen	= FALSE;


	//	So what type of operator is it ?

	switch	( *gName++ )
	{
	case 0:
		gName--;		// End of string, better back-track

		return	DN_truncated;

	case OC_ctor:
	case OC_dtor:
		//
		// The constructor and destructor are special:
		// Their operator name is the name of their first enclosing scope, which
		// will always be a tag, which may be a template specialization!
		//
		{
			//
			// Is this a specialization of a member function template? If it is
			// then we will actually have the template arguments between the "name"
			// of the operator and the scope: so we need to read the template
			// arguments before we try to read the name of the class
			//
			DName templateArguments;

			if ( fIsTemplate ) {
				templateArguments += '<' + getTemplateArgumentList();

				if ( templateArguments.getLastChar () == '>' ) {
					templateArguments += ' ';
				}

				templateArguments += '>';

				gName += 1;

				if ( pfReadTemplateArguments != NULL ) {
					*pfReadTemplateArguments = true;
				}
			}

			//
			// Use a temporary.  Don't want to advance the name pointer
			//
			pcchar_t	pName	= gName;

			operatorName		= getZName ( false );

			gName = pName;		// Undo our lookahead

			if	( !operatorName.isEmpty () && ( gName[ -1 ] == OC_dtor ))
				operatorName	= '~' + operatorName;

			//
			// Append the template argumentsa (if there are any)
			//
			if ( !templateArguments.isEmpty()) {
				operatorName	+= templateArguments;
			}

			return	operatorName;

		}	// End of CASE 'OC_ctor,OC_dtor'
		break;

	case OC_new:
	case OC_delete:
	case OC_assign:
	case OC_rshift:
	case OC_lshift:
	case OC_not:
	case OC_equal:
	case OC_unequal:
			operatorName	= nameTable[ gName[ -1 ] - OC_new ];
		break;

	case OC_udc:
			udcSeen	= TRUE;

		//	No break

	case OC_index:
	case OC_pointer:
	case OC_star:
	case OC_incr:
	case OC_decr:
	case OC_minus:
	case OC_plus:
	case OC_amper:
	case OC_ptrmem:
	case OC_divide:
	case OC_modulo:
	case OC_less:
	case OC_leq:
	case OC_greater:
	case OC_geq:
	case OC_comma:
	case OC_call:
	case OC_compl:
	case OC_xor:
	case OC_or:
	case OC_land:
	case OC_lor:
	case OC_asmul:
	case OC_asadd:
	case OC_assub:			// Regular operators from the first group
			operatorName	= nameTable[ gName[ -1 ] - OC_index + ( OC_unequal - OC_new + 1 )];
		break;

	case '_':
			switch	( *gName++ )
			{
			case 0:
				gName--;		// End of string, better back-track

				return	DN_truncated;

			case OC_asdiv:
			case OC_asmod:
			case OC_asrshift:
			case OC_aslshift:
			case OC_asand:
			case OC_asor:
			case OC_asxor:	// Regular operators from the extended group
					operatorName	= nameTable[ gName[ -1 ] - OC_asdiv + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];
				break;

#if	( !NO_COMPILER_NAMES )
			case OC_vftable:
			case OC_vbtable:
			case OC_vcall:
				return	nameTable[ gName[ -1 ] - OC_asdiv + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];


			case OC_string:
				{
				DName result = getStringEncoding( "`string'", TRUE );
				result.setIsNoTE();
				return result;
				}

			case OC_metatype:
			case OC_guard:
			case OC_vbdtor:
			case OC_vdeldtor:
			case OC_defctor:
			case OC_sdeldtor:
			case OC_vctor:
			case OC_vdtor:
			case OC_vallctor:
			case OC_vdispmap:
			case OC_ehvctor:
			case OC_ehvdtor:
			case OC_ehvctorvb:
			case OC_copyctorclosure:
			case OC_locvfctorclosure:
			case OC_locvftable:	// Special purpose names
			case OC_placementDeleteClosure:
			case OC_placementArrayDeleteClosure:
				return	nameTable[ gName[ -1 ] - OC_metatype + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];

			case OC_udtthunk:
				operatorName	= nameTable[ gName[ -1 ] - OC_metatype + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];
				tmpName 		= getOperatorName( false, NULL );
				if ( !tmpName.isEmpty() && tmpName.isUDTThunk() )
					return	DN_invalid;
				return operatorName + tmpName;
				break;
			case OC_eh_init:
				break;
			case OC_rtti_init:
				operatorName	= nameTable[ gName[ -1 ] - OC_metatype + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];
				tmpName = rttiTable[ gName[0] - OC_rtti_TD ];
				switch	( *gName++ )
				{
				case OC_rtti_TD:
					{
					DName	result = getDataType ( NULL );
					return result + ' ' + operatorName + tmpName;
					}
					break;
				case OC_rtti_BCD:
					{
					DName	result = operatorName + tmpName;
					result += getSignedDimension() + ',';
					result += getSignedDimension() + ',';
					result += getSignedDimension() + ',';
					result += getDimension() + ')';
					return result + '\'';
					}
					break;
				case OC_rtti_BCA:
				case OC_rtti_CHD:
				case OC_rtti_COL:
					return operatorName + tmpName;
					break;
				default:
					gName--;
					return DN_truncated;
					break;
				}
				break;

#endif	// !NO_COMPILER_NAMES

			case OC_arrayNew:
			case OC_arrayDelete:
				operatorName	= nameTable[ gName[ -1 ] - OC_metatype + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )
#if NO_COMPILER_NAMES
											- ( OC_locvfctorclosure - OC_vftable + 1 )	// discount names not in table
#endif
									];
				break;

			// Yet another level of nested encodings....
			case '?':
				switch( *gName++ ) {

					case 0:
						gName--;		// End of string, better back-track

						return	DN_truncated;

					case OC_anonymousNamespace:
						//
						// Anonymous namespace (new-style) is a string encoding of the
						// machine name and the translation unit name.  Since the remainder
						// of the name doesn't really fit the dname grammar, skip it.
						// There are two '@' markers in the name....
						//
						{
						DName result = getStringEncoding( "`anonymous namespace'", FALSE );
						result.setIsNoTE();
						return result;
						}

					default:
						return	DN_invalid;
				}
				break;

			//
			// A double extended operator
			//
			case '_':
				switch (*gName++) {
					case OC_man_vec_ctor:
					case OC_man_vec_dtor:
					case OC_ehvcctor:
					case OC_ehvcctorvb:
						return nameTable[ gName[ -1 ] - OC_man_vec_ctor + ( OC_placementArrayDeleteClosure - OC_metatype + 1) + ( OC_vcall - OC_asdiv + 1 ) + ( OC_assub - OC_index + 1 ) + ( OC_unequal - OC_new + 1 )];

					default:
						return DN_invalid;
				}
				break;

			default:
				return	DN_invalid;

			}	// End of SWITCH
		break;

	default:
		return	DN_invalid;

	}	// End of SWITCH

	//	This really is an operator name, so prefix it with 'operator'

	if	( udcSeen )
		operatorName.setIsUDC ();
	elif	( !operatorName.isEmpty ())
		operatorName	= "operator" + operatorName;

	return	operatorName;

}	// End of "UnDecorator" FUNCTION "getOperatorName"

DName	UnDecorator::getStringEncoding ( char *prefix, int wantBody )
{
	DName result = prefix;

	// First @ comes right after operator code
	if	( *gName++ != '@' || *gName++ != '_' ) {
		return DN_invalid;
	}

	// Skip the string kind
	gName++;

	// Get (& discard) the length
	getDimension();

	// Get (& discart) the checksum
	getDimension();

	while ( *gName && *gName != '@' ) {
		// For now, we'll just skip it
		gName++;
	}

	if	( !*gName ) {
		gName--;
		return DN_truncated;
	}

	// Eat the terminating '@'
	gName++;

	return result;
}


DName	UnDecorator::getScope ( void )
{
	DName	scope;
	bool	fNeedBracket = false;


	//	Get the list of scopes

	while	(( scope.status () == DN_valid ) && *gName && ( *gName != '@' ))
	{	//	Insert the scope operator if not the first scope

		if (fExplicitTemplateParams && !fGetTemplateArgumentList) {
			return scope;
		}
		if	( !scope.isEmpty() ) {
			scope	= "::" + scope;

			if (fNeedBracket) {
				scope = '[' + scope;
				fNeedBracket = false;
			}
		}

		//	Determine what kind of scope it is

		if	( *gName == '?' )
			switch	( *++gName )
			{
			case '?':
					if	( gName[1] == '_' && gName[2] == '?' ) {
						//
						// Anonymous namespace name (new style)
						//
						gName++;
						scope = getOperatorName ( false, NULL ) + scope;

						// There should be a zname termination @...
						if	( *gName == '@' ) {
							gName++;
						}
					}
					else
						scope	= '`' + getDecoratedName () + '\'' + scope;
				break;

			case '$':
					// It's a template name, which is a kind of zname; back up
					// and handle like a zname.
					gName--;
					scope	= getZName ( true ) + scope;
				break;

			case 'A':
					//
					// This is a new-new encoding for anonymous namespaces
					//
					// fall-through

			case '%':
					//
					// It an anonymous namespace (old-style);
					// skip the (unreadable) name and instead insert
					// an appropriate string
					//
					while ( *gName != '@' ) {
						gName++;
					}

					gName++;

					scope = "`anonymous namespace'" + scope;
				break;
			case 'I':
				//
				// This is the interface whose method the class is
				// implementing
				//
				gName++;
				scope = getZName ( true ) + ']' + scope;
				fNeedBracket = true;
				break;

			default:
				scope	= getLexicalFrame () + scope;
				break;

			}	// End of SWITCH
		else
			scope	= getZName ( true ) + scope;

	}	// End of WHILE

	//	Catch error conditions

	switch	( *gName )
	{
	case 0:
			if	( scope.isEmpty() )
				scope	= DN_truncated;
			else
				scope	= DName ( DN_truncated ) + "::" + scope;
		break;

	case '@':		// '@' expected to end the scope list
		break;

	default:
			scope	= DN_invalid;
		break;

	}	// End of SWITCH

	//	Return the composed scope

	return	scope;

}	// End of "UnDecorator" FUNCTION "getScope"


DName	UnDecorator::getSignedDimension ( void )
{
	if		( !*gName )
		return	DN_truncated;
	elif	( *gName == '?' ) {
		gName++;	// skip the '?'
		return	'-' + getDimension();
	}
	else
		return	getDimension();
}	// End of "Undecorator" FUNCTION "getSignedDimension"


DName	UnDecorator::getDimension ( bool fSigned )
{
	char* prefix = 0;
	if (*gName == TC_nontype_dummy) {
		prefix = "`non-type-template-parameter";
		++gName;
	}

	if		( !*gName )
		return	DN_truncated;
	elif	(( *gName >= '0' ) && ( *gName <= '9' ))
		return	prefix ? (prefix + DName ((unsigned __int64)( *gName++ - '0' + 1 ))) : DName ((unsigned __int64)( *gName++ - '0' + 1 ));
	else
	{
		unsigned __int64 dim = 0ui64;


		//	Don't bother detecting overflow, it's not worth it

		while	( *gName != '@' )
		{
			if		( !*gName )
				return	DN_truncated;
			elif	(( *gName >= 'A' ) && ( *gName <= 'P' ))
				dim	= ( dim << 4 ) + ( *gName - 'A' );
			else
				return	DN_invalid;

			gName++;

		}	// End of WHILE

		//	Ensure integrity, and return

		if	( *gName++ != '@' )
			return	DN_invalid;		// Should never get here

		if (fSigned) {
			return prefix ? (prefix + DName((__int64)dim)) : DName((__int64)dim);
		} else {
			return prefix ? (prefix + DName(dim)) : dim;
		}

	}	// End of ELIF else
}	// End of "UnDecorator" FUNCTION "getDimension"


int	UnDecorator::getNumberOfDimensions ( void )
{
	if		( !*gName )
		return	0;
	elif	(( *gName >= '0' ) && ( *gName <= '9' ))
		return	(( *gName++ - '0' ) + 1 );
	else
	{
		int	dim	= 0;


		//	Don't bother detecting overflow, it's not worth it

		while	( *gName != '@' )
		{
			if		( !*gName )
				return	0;
			elif	(( *gName >= 'A' ) && ( *gName <= 'P' ))
				dim	= ( dim << 4 ) + ( *gName - 'A' );
			else
				return	-1;

			gName++;

		}	// End of WHILE

		//	Ensure integrity, and return

		if	( *gName++ != '@' )
			return	-1;		// Should never get here

		return	dim;

	}	// End of ELIF else
}	// End of "UnDecorator" FUNCTION "getNumberOfDimensions"


DName UnDecorator::getTemplateName( bool fReadTerminator )
{
	//
	// First make sure we're really looking at a template name
	//
	if	( gName[0] != '?' || gName[1] != '$' )
		return DN_invalid;

	gName += 2;			// Skip the marker characters

	//
	// Stack the replicators, since template names are their own replicator scope:
	//
	Replicator * pSaveArgList 			= pArgList;
	Replicator * pSaveZNameList 		= pZNameList;
	Replicator * pSaveTemplateArgList 	= pTemplateArgList;

	Replicator localArgList, localZNameList, localTemplateArgList;

	pArgList 			= &localArgList;
	pZNameList 			= &localZNameList;
	pTemplateArgList 	= &localTemplateArgList;

	//
	// Crack the template name:
	//
	DName	templateName;
	DName	templateArguments;
	bool	fReadTemplateArguments = false;

	if ( *gName == '?' ) {
		gName += 1;

		templateName = getOperatorName( true, &fReadTemplateArguments );
	}
	else {
		templateName = getZName( true );
	}

	if	(templateName.isEmpty ()) {
		fExplicitTemplateParams = true;
	}

	//
	// If we haven't already read the template arguments then
	// now is the time to read them
	//
	if ( !fReadTemplateArguments ) {
		templateName += '<' + getTemplateArgumentList ();

		if ( templateName.getLastChar () == '>' ) {
			templateName += ' ';
		}

		templateName += '>';

		if ( fReadTerminator ) {
			gName += 1;
		}
	}

	//
	// Restore the previous replicators:
	//
	pArgList			= pSaveArgList;
	pZNameList			= pSaveZNameList;
	pTemplateArgList	= pSaveTemplateArgList;

	//	Return the completed 'template-name'

	return	templateName;

}	// End of "UnDecorator" FUNCTION "getTemplateName"


DName	UnDecorator::getTemplateArgumentList ( void )
{
	int		first	= TRUE;
	DName	aList;
	fGetTemplateArgumentList = true;


	while	(( aList.status () == DN_valid ) && *gName && ( *gName != AT_endoflist ))
	{
		//	Insert the argument list separator if not the first argument

		if	( first )
			first	= FALSE;
		else
			aList	+= ',';


		//	Get the individual argument type

		int		argIndex	= *gName - '0';


		//	Handle 'template-argument-replicators', otherwise a new argument type

		if	(( argIndex >= 0 ) && ( argIndex <= 9 ))
		{
			gName++;	// Skip past the replicator

			//	Append to the argument list

			aList	+= ( *pTemplateArgList )[ argIndex ];

		}	// End of IF then
		else
		{
			pcchar_t	oldGName	= gName;
			DName		arg;

			//
			//	Extract the 'argument' type
			//

			if	( *gName == DT_void ) {
				gName++;
				arg = "void";
			} 
			elif ( (*gName == '$') && (gName[1] != '$')) {
				gName++;
				arg = getTemplateConstant();
			}
			elif ( *gName == '?' ) {
				//
				// This is a template-parameter, i.e. we have a "specialization" of
				// X<T>. so get the template-parameter-index and use a "generic" name
				// for this parameter
				//
				DName dimension = getSignedDimension();

				if ( haveTemplateParameters()) {
					char buffer[16];

					dimension.getString( buffer, 16 );

					char *str = (*m_pGetParameter)(atol(buffer));

					if ( str != NULL ) {
						arg = str;
					}
					else {
						arg = "`template-parameter" + dimension + "'";
					}
				}
				else {
					arg = "`template-parameter" + dimension + "'";
				}
			}
			else {
				arg = getPrimaryDataType ( DName() );
			}


			//	Add it to the current list of 'template-argument's, if it is bigger than a one byte encoding

			if	((( gName - oldGName ) > 1 ) && !pTemplateArgList->isFull ())
				*pTemplateArgList	+= arg;

			//	Append to the argument list

			aList	+= arg;

		}	// End of IF else
	}	// End of WHILE

	//	Return the completed template argument list

	fGetTemplateArgumentList = false;

	return	aList;

}	// End of "UnDecorator" FUNCTION "getTemplateArgumentList"


DName	UnDecorator::getTemplateConstant(void)
{
	//
	// template-constant ::=
	//		'0'	<template-integral-constant>
	//		'1' <template-address-constant>
	//		'2' <template-floating-point-constant>
	//
	char type_category = *gName++;
	switch ( type_category )
	{
		//
		// template-integral-constant ::=
		//		<signed-dimension>
		//
	case TC_integral:
		return 	getSignedDimension ();

		//
		// template-address-constant ::=
		//		'@'			// Null pointer
		//		<decorated-name>
		//
	case TC_address:
		if 	( *gName == TC_nullptr )
		{
			gName++;
			return	"NULL";
		}
		else
			return	DName("&") + getDecoratedName ();

		//
		// template-name ::=
		//		<docorated-name>
		//
	case TC_name:
		return getDecoratedName ();

		//
		// template-floating-point-constant ::=
		//		<normalized-mantissa><exponent>
		//
	case TC_fp:
		{
			DName	mantissa ( getSignedDimension () );
			DName	exponent ( getSignedDimension () );

			if	( mantissa.isValid() && exponent.isValid() )
			{
				//
				// Get string representation of mantissa
				//
				char	buf[100];		// Way overkill for a compiler generated fp constant

				if	( !mantissa.getString( &(buf[1]), 100 ) )	
					return	DN_invalid;

				//
				// Insert decimal point
				//
				buf[0] = buf[1];

				if	( buf[0] == '-' )
				{
					buf[1] = buf[2];
					buf[2] = '.';
				}
				else
					buf[1] = '.';

				//
				// String it all together
				//
				return DName( buf ) + 'e' + exponent;

			} // End of IF then
			else
				return DN_truncated;

		}	// End of BLOCK case TC_fp

	case TC_dummy:
	case TC_nontype_dummy:
		{
			//
			// This is a template-parameter, i.e. we have a "specialization" of
			// X<n>. so get the template-parameter-index and use a "generic" name
			// for this parameter
			//
			DName dimension = getSignedDimension();

			if ( haveTemplateParameters()) {
				char buffer[16];

				dimension.getString( buffer, 16 );

				char *str = (*m_pGetParameter)(atol(buffer));

				if ( str != NULL ) {
					return str;
				}
			}

			if (type_category == TC_dummy) {
				return "`template-parameter" + dimension + "'";
			} else {
				return "`non-type-template-parameter" + dimension + "'";
			}
		}
		break;

	case TC_vptmd:
	case TC_gptmd:
	case TC_mptmf:
	case TC_vptmf:
	case TC_gptmf:
		{
			DName ptm = '{';
		
			switch (type_category) {
			case TC_mptmf:
			case TC_vptmf:
			case TC_gptmf:
				ptm += getDecoratedName();
				ptm += ',';
				break;
			}

			switch (type_category) {
			case TC_gptmf:
			case TC_gptmd:
				ptm += getSignedDimension();
				ptm += ',';
				// fallthrough

			case TC_vptmd:
			case TC_vptmf:
				ptm += getSignedDimension();
				ptm += ',';
				// fallthrough

			case TC_mptmf:
				ptm += getSignedDimension();
			}

			return ptm + '}';
		}
		break;

	case '\0':
		--gName;
		return	DN_truncated;

	default:
		return	DN_invalid;

	}	// End of SWITCH
}	// End of "UnDecorator" FUNCTION "getTemplateConstant"

	
inline	DName	UnDecorator::composeDeclaration ( const DName & symbol )
{
	DName			declaration;
	unsigned int	typeCode	= getTypeEncoding ();
	int				symIsUDC	= symbol.isUDC ();


	//	Handle bad typeCode's, or truncation

	if		( TE_isbadtype ( typeCode ))
		return	DN_invalid;
	elif	( TE_istruncated ( typeCode ))
		return	( DN_truncated + symbol );
	elif	( TE_isCident ( typeCode ))
		return	symbol;

	//	This is a very complex part.  The type of the declaration must be
	//	determined, and the exact composition must be dictated by this type.

	//	Is it any type of a function ?
	//	However, for ease of decoding, treat the 'localdtor' thunk as data, since
	//	its decoration is a function of the variable to which it belongs and not
	//	a usual function type of decoration.

#if	( NO_COMPILER_NAMES )
	if	( TE_isthunk ( typeCode ))
		return	DN_invalid;

	if	( TE_isfunction ( typeCode ))
#else	// } elif !NO_COMPILER_NAMES {
	if	( TE_isfunction ( typeCode ) && !(( TE_isthunk ( typeCode ) && TE_islocaldtor ( typeCode )) ||
			( TE_isthunk ( typeCode ) && ( TE_istemplatector ( typeCode ) || TE_istemplatedtor ( typeCode )))))
#endif	// !NO_COMPILER_NAMES

	{
		//	If it is based, then compose the 'based' prefix for the name

		if	( TE_isbased ( typeCode ))
			if	( doMSKeywords () && doAllocationModel ())
				declaration	= ' ' + getBasedType ();
			else
				declaration	|= getBasedType ();	// Just lose the 'based-type'

#if	( !NO_COMPILER_NAMES )
		//	Check for some of the specially composed 'thunk's

		if	( TE_isthunk ( typeCode ) && TE_isvcall ( typeCode ))
		{
			declaration	+= symbol + '{' + getCallIndex () + ',';
			declaration	+= getVCallThunkType () + "}' ";
			if ( doMSKeywords () && doAllocationLanguage ())
				declaration	= ' ' + getCallingConvention () + ' ' + declaration;	// What calling convention ?
			else
				declaration |= getCallingConvention ();	// Just lose the 'calling-convention'

		}	// End of IF then
		else
#endif	// !NO_COMPILER_NAMES
		{
			DName	vtorDisp;
			DName	adjustment;
			DName	thisType;

#if	( !NO_COMPILER_NAMES )
			if	( TE_isthunk ( typeCode ))
			{
				if	( TE_isvtoradj ( typeCode ))
					vtorDisp	= getDisplacement ();

				adjustment	= getDisplacement ();

			}	// End of IF else
#endif	// !NO_COMPILER_NAMES

			//	Get the 'this-type' for non-static function members

			if	( TE_ismember ( typeCode ) && !TE_isstatic ( typeCode ))
				if	( doThisTypes ())
					thisType	= getThisType ();
				else
					thisType	|= getThisType ();

			if	( doMSKeywords ())
			{
				//	Attach the calling convention

				if	( doAllocationLanguage ())
					declaration	= getCallingConvention () + declaration;	// What calling convention ?
				else
					declaration	|= getCallingConvention ();	// Just lose the 'calling-convention'

				//	Any model specifiers ?

#if !VERS_32BIT
				if	( doAllocationModel ())
					if		( TE_isnear ( typeCode ))
						declaration	= UScore ( TOK_nearSp ) + declaration;
					elif	( TE_isfar ( typeCode ))
						declaration	= UScore ( TOK_farSp ) + declaration;
#endif

			}	// End of IF
			else
				declaration	|= getCallingConvention ();	// Just lose the 'calling-convention'

			//	Now put them all together

			if	( !symbol.isEmpty ())
				if	( !declaration.isEmpty () && !doNameOnly() )			// And the symbol name
					declaration	+= ' ' + symbol;
				else
					declaration	= symbol;


			//	Compose the return type, catching the UDC case

			DName *	pDeclarator	= 0;
			DName	returnType;


			if	( symIsUDC )		// Is the symbol a UDC operator ?
			{
				declaration	+= " " + getReturnType ();

				if	( doNameOnly() )
					return	declaration;
			}
			else
			{
				pDeclarator	= gnew DName;
				returnType	= getReturnType ( pDeclarator );

			}	// End of IF else

#if	( !NO_COMPILER_NAMES )
			//	Add the displacements for virtual function thunks

			if	( TE_isthunk ( typeCode ))
			{
				if	( TE_isvtoradj ( typeCode ))
					declaration	+= "`vtordisp{" + vtorDisp + ',';
				else
					declaration	+= "`adjustor{";

				declaration	+= adjustment + "}' ";

			}	// End of IF
#endif	// !NO_COMPILER_NAMES

			//	Add the function argument prototype

			declaration	+= '(' + getArgumentTypes () + ')';

			//	If this is a non-static member function, append the 'this' modifiers

			if	( TE_ismember ( typeCode ) && !TE_isstatic ( typeCode ))
				declaration	+= thisType;

			//	Add the 'throw' signature

			if	( doThrowTypes ())
				declaration	+= getThrowTypes ();
			else
				declaration	|= getThrowTypes ();	// Just lose the 'throw-types'

			//	If it has a declarator, then insert it into the declaration,
			//	sensitive to the return type composition

			if	( doFunctionReturns () && pDeclarator )
			{
				*pDeclarator	= declaration;
				declaration		= returnType;

			}	// End of IF
		}	// End of IF else
	}	// End of IF then
	else
	{
		declaration	+= symbol;

		//	Catch the special handling cases

#if	( !NO_COMPILER_NAMES )
		if		( TE_isvftable ( typeCode ))
			return	getVfTableType ( declaration );
		elif	( TE_isvbtable ( typeCode ))
			return	getVbTableType ( declaration );
		elif	( TE_isguard ( typeCode ))
			return	( declaration + '{' + getGuardNumber () + "}'" );
		elif	( TE_isvdispmap ( typeCode ))
			return	getVdispMapType ( declaration );
		elif	( TE_isthunk ( typeCode ) && TE_islocaldtor ( typeCode ))
			declaration	+= "`local static destructor helper'";
		elif	( TE_isthunk ( typeCode ) && TE_istemplatector ( typeCode ))
			declaration	+= "`template static data member constructor helper'";
		elif	( TE_isthunk ( typeCode ) && TE_istemplatedtor ( typeCode ))
			declaration	+= "`template static data member destructor helper'";
		elif	( TE_ismetaclass ( typeCode ))
			//
			// Meta-class information has its information in its operator id
			//
			return declaration;
#else	// } elif NO_COMPILER_NAMES {
		if	( TE_isvftable ( typeCode )
				|| TE_isvbtable ( typeCode )
				|| TE_isguard ( typeCode )
				|| TE_ismetaclass ( typeCode ))
			return	DN_invalid;
#endif	// NO_COMPILER_NAMES

		if ( TE_isthunk( typeCode ) && ( TE_istemplatector( typeCode ) || TE_istemplatedtor( typeCode ))) {
			//
			// Insert a space before the declaration
			//
			declaration = " " + declaration;
		}
		else {
			//	All others are decorated as data symbols
			declaration	= getExternalDataType ( declaration );
		}

	}	// End of IF else

	//	Prepend the 'virtual' and 'static' attributes for members

	if	( TE_ismember ( typeCode ))
	{
		if	( doMemberTypes ())
		{
			if	( TE_isstatic ( typeCode ))
				declaration	= "static " + declaration;

			if	( TE_isvirtual ( typeCode ) || ( TE_isthunk ( typeCode ) && ( TE_isvtoradj ( typeCode ) || TE_isadjustor ( typeCode ))))
				declaration	= "virtual " + declaration;

		}	// End of IF

		//	Prepend the access specifiers

		if	( doAccessSpecifiers ())
			if		( TE_isprivate ( typeCode ))
				declaration	= "private: " + declaration;
			elif	( TE_isprotected ( typeCode ))
				declaration	= "protected: " + declaration;
			elif	( TE_ispublic ( typeCode ))
				declaration	= "public: " + declaration;

	}	// End of IF

#if	( !NO_COMPILER_NAMES )
	//	If it is a thunk, mark it appropriately

	if	( TE_isthunk ( typeCode ))
		declaration	= "[thunk]:" + declaration;
#endif	// !NO_COMPILER_NAMES

	//	Return the composed declaration

	return	declaration;

}	// End of "UnDecorator" FUNCTION "composeDeclaration"


inline	int		UnDecorator::getTypeEncoding ( void )
{
	unsigned int	typeCode	= 0u;


	//	Strip any leading '_' which indicates that it is based

	if	( *gName == '_' )
	{
		TE_setisbased ( typeCode );

		gName++;

	}	// End of IF

	//	Now handle the code proper :-

	if		(( *gName >= 'A' ) && ( *gName <= 'Z' ))	// Is it some sort of function ?
	{
		int	code	= *gName++ - 'A';


		//	Now determine the function type

		TE_setisfunction ( typeCode );	// All of them are functions ?

		//	Determine the calling model

		if	( code & TE_far )
			TE_setisfar ( typeCode );
		else
			TE_setisnear ( typeCode );

		//	Is it a member function or not ?

		if	( code < TE_external )
		{
			//	Record the fact that it is a member

			TE_setismember ( typeCode );

			//	What access permissions does it have

			switch	( code & TE_access )
			{
			case TE_private:
					TE_setisprivate ( typeCode );
				break;

			case TE_protect:
					TE_setisprotected ( typeCode );
				break;

			case TE_public:
					TE_setispublic ( typeCode );
				break;

			default:
					TE_setisbadtype ( typeCode );
					return	typeCode;

			}	// End of SWITCH

			//	What type of a member function is it ?

			switch	( code & TE_adjustor )
			{
			case TE_adjustor:
					TE_setisadjustor ( typeCode );
				break;

			case TE_virtual:
					TE_setisvirtual ( typeCode );
				break;

			case TE_static:
					TE_setisstatic ( typeCode );
				break;

			case TE_member:
				break;

			default:
					TE_setisbadtype ( typeCode );
					return	typeCode;

			}	// End of SWITCH
		}	// End of IF
	}	// End of IF then
	elif	( *gName == '$' )	// Extended set ?  Special handling
	{
		//	What type of symbol is it ?

		switch	( *( ++gName ))
		{
		case SHF_localdtor:	// A destructor helper for a local static ?
				TE_setislocaldtor ( typeCode );
			break;

		case SHF_vcall:	// A VCall-thunk ?
				TE_setisvcall ( typeCode );
			break;
		
		case SHF_templateStaticDataMemberCtor:	// A constructor helper for template static data members
				TE_setistemplatector ( typeCode );
			break; 

		case SHF_templateStaticDataMemberDtor:	// A destructor helper for template static data members
				TE_setistemplatedtor ( typeCode );
			break; 
		case SHF_vdispmap:
				TE_setvdispmap ( typeCode );
			break;

		case '$':
			{
				if ( * ( gName + 1 ) == SHF_AnyDLLImportMethod ) {
					gName += 1;
				}

				switch ( *( ++gName )) {
					case SHF_CPPManagedILFunction:				// C++ managed-IL function
					case SHF_CPPManagedNativeFunction:			// C++ managed-native function
					case SHF_CPPManagedILMain:					// C++ managed-IL main
					case SHF_CPPManagedNativeMain:				// C++ managed-native main
					case SHF_CPPManagedILDLLImportData:			// C++ managed-IL DLL-import function
					case SHF_CPPManagedNativeDLLImportData:		// C++ managed-native DLL-import function
						//
						// Skip the encoding
						//
						gName += 1;
						return getTypeEncoding();

					case SHF_CManagedILFunction:				// C (or extern "C") managed-IL function
					case SHF_CManagedNativeFunction:			// C (or extern "C") managed-native function
					case SHF_CManagedILDLLImportData:			// C (or extern "C") managed-IL DLL-import function 
					case SHF_CManagedNativeDLLImportData:		// C (or extern "C") managed-native DLL-import function 
						//
						// Skip the encoding
						//
						gName += 1;

						//
						// The next character should be the number of characters
						// in the byte-count
						//
						if (( *gName >= '0' ) && ( *gName <= '9' )) {
							//
							// Skip the character count and the byte-count
							// itself
							//
							gName += (( *gName - '0' ) + 1 );

							return getTypeEncoding();
						}
						else {
							TE_setisbadtype( typeCode );
						}
						break;

					default:
						break;
				}
			}
			break;

		case 0:
				TE_setistruncated ( typeCode );
			break;

		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':	// Construction displacement adjustor thunks
			{
				int	code	= *gName - '0';


				//	Set up the principal type information

				TE_setisfunction ( typeCode );
				TE_setismember ( typeCode );
				TE_setisvtoradj ( typeCode );

				//	Is it 'near' or 'far' ?

				if	( code & TE_far )
					TE_setisfar ( typeCode );
				else
					TE_setisnear ( typeCode );

				//	What type of access protection ?

				switch	( code & TE_access_vadj )
				{
				case TE_private_vadj:
						TE_setisprivate ( typeCode );
					break;

				case TE_protect_vadj:
						TE_setisprotected ( typeCode );
					break;

				case TE_public_vadj:
						TE_setispublic ( typeCode );
					break;

				default:
						TE_setisbadtype ( typeCode );
						return	typeCode;

				}	// End of SWITCH
			}	// End of CASE '0,1,2,3,4,5'
			break;

		default:
				TE_setisbadtype ( typeCode );
				return	typeCode;

		}	// End of SWITCH

		//	Advance past the code character

		gName++;

	}	// End of ELIF then
	elif	(( *gName >= TE_static_d ) && ( *gName <= TE_metatype ))	// Non function decorations ?
	{
		int	code	= *gName++;


		TE_setisdata ( typeCode );

		//	What type of symbol is it ?

		switch	( code )
		{
		case ( TE_static_d | TE_private_d ):
				TE_setisstatic ( typeCode );
				TE_setisprivate ( typeCode );
			break;

		case ( TE_static_d | TE_protect_d ):
				TE_setisstatic ( typeCode );
				TE_setisprotected ( typeCode );
			break;

		case ( TE_static_d | TE_public_d ):
				TE_setisstatic ( typeCode );
				TE_setispublic ( typeCode );
			break;

		case TE_global:
				TE_setisglobal ( typeCode );
			break;

		case TE_guard:
				TE_setisguard ( typeCode );
			break;

		case TE_local:
				TE_setislocal ( typeCode );
			break;

		case TE_vftable:
				TE_setisvftable ( typeCode );
			break;

		case TE_vbtable:
				TE_setisvbtable ( typeCode );
			break;

		case TE_metatype:
				TE_setismetaclass ( typeCode );
			break;

		default:
				TE_setisbadtype ( typeCode );

				return	typeCode;

		}	// End of SWITCH
	}	// End of ELIF then
	elif	( *gName == '9' ) {
		gName++;

		TE_setisCident ( typeCode );
	}
	elif	( *gName )
		TE_setisbadtype ( typeCode );
	else
		TE_setistruncated ( typeCode );

	//	Return the composed type code

	return	typeCode;

}	// End of "UnDecorator" FUNCTION "getTypeEncoding"



DName	UnDecorator::getBasedType ( void )
{
	DName	basedDecl ( UScore ( TOK_basedLp ));


	//	What type of 'based' is it ?

	if	( *gName )
	{
		switch	( *gName++ )
		{
#if !VERS_32BIT
		case BT_segname:
				basedDecl	+= UScore ( TOK_segnameLpQ ) + getSegmentName () + "\")";
			break;

		case BT_segment:
				basedDecl	+= DName ( "NYI:" ) + UScore ( TOK_segment );
			break;
#endif

		case BT_void:
				basedDecl	+= "void";
			break;

#if !VERS_32BIT
		case BT_self:
				basedDecl	+= UScore ( TOK_self );
			break;

		case BT_nearptr:
				basedDecl	+= DName ( "NYI:" ) + UScore ( TOK_nearP );
			break;

		case BT_farptr:
				basedDecl	+= DName ( "NYI:" ) + UScore ( TOK_farP );
			break;

		case BT_hugeptr:
				basedDecl	+= DName ( "NYI:" ) + UScore ( TOK_hugeP );
			break;

		case BT_segaddr:
				basedDecl	+= "NYI:<segment-address-of-variable>";
			break;
#else
		case BT_nearptr:
				basedDecl	+= getScopedName();
			break;
#endif

		case BT_basedptr:
				//
				// Note: based pointer on based pointer is reserved
				//
				return	DN_invalid;

		}	// End of SWITCH
	}	// End of IF else
	else
		basedDecl	+= DN_truncated;

	//	Close the based syntax

	basedDecl	+= ") ";

	//	Return completed based declaration

	return	basedDecl;

}	// End of "UnDecorator" FUNCTION "getBasedType"



DName	UnDecorator::getScopedName ( void )
{
	DName	name;


	//	Get the beginning of the name

	name	= getZName ( true );

	//	Now the scope (if any)

	if	(( name.status () == DN_valid ) && *gName && ( *gName != '@' ))
		name	= getScope () + "::" + name;

	//	Skip the trailing '@'

	if		( *gName == '@' )
		gName++;
	elif	( *gName )
		name	= DN_invalid;
	elif	( name.isEmpty ())
		name	= DN_truncated;
	else
		name	= DName ( DN_truncated ) + "::" + name;

	//	And return the complete name

	return	name;

}	// End of "UnDecorator" FUNCTION "getECSUName"


inline	DName			UnDecorator::getECSUName ( void )		{ return getScopedName(); }


inline	DName	UnDecorator::getEnumType ( void )
{
	DName	ecsuName;


	if	( *gName )
	{
		//	What type of an 'enum' is it ?

		switch	( *gName )
		{
		case ET_schar:
		case ET_uchar:
				ecsuName	= "char ";
			break;

		case ET_sshort:
		case ET_ushort:
				ecsuName	= "short ";
			break;

		case ET_sint:
			break;

		case ET_uint:
				ecsuName	= "int ";
			break;

		case ET_slong:
		case ET_ulong:
				ecsuName	= "long ";
			break;

		default:
			return	DN_invalid;

		}	// End of SWITCH

		//	Add the 'unsigned'ness if appropriate
		
		switch	( *gName++ )
		{
		case ET_uchar:
		case ET_ushort:
		case ET_uint:
		case ET_ulong:
				ecsuName	= "unsigned " + ecsuName;
			break;

		}	// End of SWITCH

		//	Now return the composed name

		return	ecsuName;

	}	// End of IF then
	else
		return	DN_truncated;

}	// End of "UnDecorator" FUNCTION "getEnumType"



DName	UnDecorator::getCallingConvention ( void )
{
	if	( *gName )
	{
		unsigned int	callCode	= ((unsigned int)*gName++ ) - 'A';


		//	What is the primary calling convention

		DASSERT(CC_cdecl == 0);
#if CC_COR
		if	(/*( callCode >= CC_cdecl ) &&*/( callCode <= CC_cocall ))
#else	// CC_COR
		if	(/*( callCode >= CC_cdecl ) &&*/( callCode <= CC_interrupt ))
#endif	// CC_COR
		{
			DName	callType;


			//	Now, what type of 'calling-convention' is it, 'interrupt' is special ?

			if	( doMSKeywords ())
#if !VERS_32BIT
				if	( callCode == CC_interrupt )
					callType	= UScore ( TOK_interrupt );
				else
#endif
				{
					switch	( callCode & ~CC_saveregs )
					{
					case CC_cdecl:
							callType	= UScore ( TOK_cdecl );
						break;

					case CC_pascal:
							callType	= UScore ( TOK_pascal );
						break;

					case CC_thiscall:
							callType	= UScore ( TOK_thiscall );
						break;

					case CC_stdcall:
							callType	= UScore ( TOK_stdcall );
						break;

					case CC_fastcall:
							callType	= UScore ( TOK_fastcall );
						break;

					case CC_cocall:
							callType	= UScore ( TOK_cocall );
						break;

					}	// End of SWITCH

					//	Has it also got 'saveregs' marked ?

#if !VERS_32BIT
					if	( callCode & CC_saveregs )
						callType	+= ' ' + UScore ( TOK_saveregs );
#endif

				}	// End of IF else

			//	And return

			return	callType;

		}	// End of IF then
		else
			return	DN_invalid;

	}	// End of IF then
	else
		return	DN_truncated;

}	// End of "UnDecorator" FUNCTION "getCallingConvention"



DName	UnDecorator::getReturnType ( DName * pDeclarator )
{
	if	( *gName == '@' )	// Return type for constructors and destructors ?
	{
		gName++;

		return	DName ( pDeclarator );

	}	// End of IF then
	else
		return	getDataType ( pDeclarator );

}	// End of "UnDecorator" FUNCTION "getReturnType"



DName	UnDecorator::getDataType ( DName * pDeclarator )
{
	DName	superType ( pDeclarator );


	//	What type is it ?

	switch	( *gName )
	{
	case 0:
			return	( DN_truncated + superType );

	case DT_void:
			gName++;

			if	( superType.isEmpty ())
				return	"void";
			else
				return	"void " + superType;

	case '?':
		{

			gName++;	// Skip the '?'

			superType = getDataIndirectType ( superType, 0, DName (), 0);
			return	getPrimaryDataType ( superType );

			return	superType;

		}	// End of CASE '?'

	default:
			return	getPrimaryDataType ( superType );

	}	// End of SWITCH
}	// End of "UnDecorator" FUNCTION "getDataType"



DName	UnDecorator::getPrimaryDataType ( const DName & superType )
{
	DName	cvType;


	switch	( *gName )
	{
	case 0:
			return	( DN_truncated + superType );

	case PDT_volatileReference:
			cvType	= "volatile";

			if	( !superType.isEmpty ())
				cvType	+= ' ';

		// No break

	case PDT_reference:
		{
			DName	superName ( superType );


			gName++;

			return	getReferenceType ( cvType, superName.setPtrRef ());

		}	// End of CASE 'PDT_reference'

	case PDT_extend:
		{
			//
			// Extended Primary Data Type (items overlooked in original design):
			// prefixed by '$$'.
			//
			if	( gName[1] != PDT_extend )
				if	( gName[1] == '\0' ) 
					return DN_truncated + superType;
				else
					return DN_invalid;

			gName += 2;

			switch	( *gName )
			{
			case PDT_ex_function:
				gName++;
				return	getFunctionIndirectType( superType );

			case PDT_ex_other:
				gName++;
				return	getPtrRefDataType( superType, /* isPtr = */ TRUE );

			case PDT_ex_qualified:
				gName++;
				return(getBasicDataType(getDataIndirectType ( superType, 0, DName (), 0)));

			case 0:
				return	( DN_truncated + superType );

			default:
				return	DN_invalid;
			}
		}

	default:
			return	getBasicDataType ( superType );

	}	// End of SWITCH
}	// End of "UnDecorator" FUNCTION "getPrimaryDataType"



DName	UnDecorator::getArgumentTypes ( void )
{
	switch	( *gName )
	{
	case AT_ellipsis:
			return	( gName++, "..." );

	case AT_void:
			return	( gName++, "void" );

	default:
		{
			DName	arguments ( getArgumentList ());


			//	Now, is it a varargs function or not ?

			if	( arguments.status () == DN_valid )
				switch	( *gName )
				{
				case 0:
						return	arguments;

				case AT_ellipsis:
						return	( gName++, arguments + ",..." );

				case AT_endoflist:
						return	( gName++, arguments );

				default:
						return	DN_invalid;

				}	// End of SWITCH
			else
				return	arguments;

		}	// End of DEFAULT
	}	// End of SWITCH
}	// End of "UnDecorator" FUNCTION "getArgumentTypes"


DName	UnDecorator::getArgumentList ( void )
{
	int		first	= TRUE;
	DName	aList;


	while	(( aList.status () == DN_valid ) && ( *gName != AT_endoflist ) && ( *gName != AT_ellipsis ))
	{
		//	Insert the argument list separator if not the first argument

		if	( first )
			first	= FALSE;
		else
			aList	+= ',';


		//	Get the individual argument type

		if	( *gName )
		{
			int		argIndex	= *gName - '0';


			//	Handle 'argument-replicators', otherwise a new argument type

			if	(( argIndex >= 0 ) && ( argIndex <= 9 ))
			{
				gName++;	// Skip past the replicator

				//	Append to the argument list

				aList	+= ( *pArgList )[ argIndex ];

			}	// End of IF then
			else
			{
				pcchar_t	oldGName	= gName;


				//	Extract the 'argument' type

				DName	arg ( getPrimaryDataType ( DName ()));


				//	Add it to the current list of 'argument's, if it is bigger than a one byte encoding

				if	((( gName - oldGName ) > 1 ) && !pArgList->isFull ())
					*pArgList	+= arg;

				//	Append to the argument list

				aList	+= arg;

			}	// End of IF else
		}	// End of IF then
		else
		{
			aList	+= DN_truncated;

			break;

		}	// End of IF else
	}	// End of WHILE

	//	Return the completed argument list

	return	aList;

}	// End of "UnDecorator" FUNCTION "getArgumentList"



DName	UnDecorator::getThrowTypes ( void )
{
	if	( *gName )
		if	( *gName == AT_ellipsis )	// Handle ellipsis here to suppress the 'throw' signature
			return	( gName++, DName ());
		else
			return	( " throw(" + getArgumentTypes () + ')' );
	else
		return	( DName ( " throw(" ) + DN_truncated + ')' );

}	// End of "UnDecorator" FUNCTION "getThrowTypes"



DName	UnDecorator::getBasicDataType ( const DName & superType )
{
	if	( *gName )
	{
		unsigned char	bdtCode	= *gName++;
		unsigned char	extended_bdtCode;
		int				pCvCode	= -1;
		DName			basicDataType;


		//	Extract the principal type information itself, and validate the codes

		switch	( bdtCode )
		{
		case BDT_schar:
		case BDT_char:
		case ( BDT_char   | BDT_unsigned ):
				basicDataType	= "char";
			break;

		case BDT_short:
		case ( BDT_short  | BDT_unsigned ):
				basicDataType	= "short";
			break;

		case BDT_int:
		case ( BDT_int    | BDT_unsigned ):
				basicDataType	= "int";
			break;

		case BDT_long:
		case ( BDT_long   | BDT_unsigned ):
				basicDataType	= "long";
			break;

#if !VERS_32BIT
		case BDT_segment:
				basicDataType	= UScore ( TOK_segment );
			break;
#endif

		case BDT_float:
				basicDataType	= "float";
			break;

		case BDT_longdouble:
				basicDataType	= "long ";

			// No break

		case BDT_double:
				basicDataType	+= "double";
			break;

		case BDT_pointer:
		case ( BDT_pointer | BDT_const ):
		case ( BDT_pointer | BDT_volatile ):
		case ( BDT_pointer | BDT_const | BDT_volatile ):
				pCvCode	= ( bdtCode & ( BDT_const | BDT_volatile ));
			break;
		case BDT_extend:
			switch(extended_bdtCode = *gName++) {
				case BDT_array:
					pCvCode = -2;
					break;
				case BDT_bool:
					basicDataType	= "bool";
					break;
				case BDT_int8:
				case ( BDT_int8   | BDT_unsigned ):
					basicDataType	= "__int8";
					break;
				case BDT_int16:
				case ( BDT_int16  | BDT_unsigned ):
					basicDataType	= "__int16";
					break;
				case BDT_int32:
				case ( BDT_int32  | BDT_unsigned ):
					basicDataType	= "__int32";
					break;
				case BDT_int64:
				case ( BDT_int64  | BDT_unsigned ):
					basicDataType	= "__int64";
					break;
				case BDT_int128:
				case ( BDT_int128 | BDT_unsigned ):
					basicDataType	= "__int128";
					break;
				case BDT_wchar_t:
					basicDataType	= "wchar_t";
					break;
#if CC_COR
				case BDT_coclass:
				case BDT_cointerface:
					{
						gName--;	// Backup, since 'ecsu-data-type' does it's own decoding

						basicDataType = getECSUDataType();

						if ( basicDataType.isEmpty()) {
							return basicDataType;
						}
					}
					break;
#endif	// CC_COR
				case '$':
					return "__w64 " + getBasicDataType (superType);
				default:
					basicDataType	= "UNKNOWN";
					break;
				}
			break;
		default:
				gName--;	// Backup, since 'ecsu-data-type' does it's own decoding

				basicDataType	= getECSUDataType ();

				if	( basicDataType.isEmpty ())
					return	basicDataType;
			break;

		}	// End of SWITCH

		//	What type of basic data type composition is involved ?

		if	( pCvCode == -1 )	// Simple ?
		{
			//	Determine the 'signed/unsigned'ness

			switch	( bdtCode )
			{
			case ( BDT_char   | BDT_unsigned ):
			case ( BDT_short  | BDT_unsigned ):
			case ( BDT_int    | BDT_unsigned ):
			case ( BDT_long   | BDT_unsigned ):
					basicDataType	= "unsigned " + basicDataType;
				break;

			case BDT_schar:
					basicDataType	= "signed " + basicDataType;
				break;
			case BDT_extend:
				switch	( extended_bdtCode )
				{

					case ( BDT_int8   | BDT_unsigned ):
					case ( BDT_int16  | BDT_unsigned ):
					case ( BDT_int32  | BDT_unsigned ):
					case ( BDT_int64  | BDT_unsigned ):
					case ( BDT_int128 | BDT_unsigned ):
						basicDataType	= "unsigned " + basicDataType;
						break;

				}	// End of SWITCH
				break;

			}	// End of SWITCH

			// 	Add the indirection type to the type

			if	( !superType.isEmpty () )
					basicDataType	+= ' ' + superType;

			//	And return the completed type

			return	basicDataType;

		}	// End of IF then
		else
		{
			DName	cvType;
			DName	superName ( superType );

			if ( pCvCode == -2 )
			{
				superName.setIsArray();
				DName arType =	getPointerTypeArray ( cvType, superName );
				// if we didn't get back an array, append.
				// A multidimensional array sticks the braces in before the
				// other dimensions at sets isArray on it's return type.
				if (!arType.isArray()) {
					arType += "[]";
				}
				return arType;
			}

			//	Is it 'const/volatile' qualified ?
			
			if		( superType . isEmpty() ) 
			{
				//
				// const/volatile are redundantly encoded, except at the start
				// of a "type only" context.  In such a context, the super-type
				// is empty.
				//
				if		( pCvCode & BDT_const )
				{
					cvType	= "const";

					if	( pCvCode & BDT_volatile )
						cvType	+= " volatile";
				}	// End of IF then
				elif	( pCvCode & BDT_volatile )
					cvType	= "volatile";
			}	// End of IF then

			//	Construct the appropriate pointer type declaration

			return	getPointerType ( cvType, superName );

		}	// End of IF else
	}	// End of IF then
	else
		return	( DN_truncated + superType );

}	// End of "UnDecorator" FUNCTION "getBasicDataType"



DName	UnDecorator::getECSUDataType ( void )
{
	//	Extract the principal type information itself, and validate the codes

	int fPrefix = doEcsu() && !doNameOnly();

	DName Prefix;

	switch	( *gName++ )
	{
	case 0:
			gName--;	// Backup to permit later error recovery to work safely

			return	"`unknown ecsu'" + DN_truncated;

	case BDT_union:
			Prefix = "union ";
		break;

	case BDT_struct:
			Prefix = "struct ";
		break;

	case BDT_class:
			Prefix = "class ";
		break;

#if CC_COR
	case BDT_coclass:
			Prefix = "coclass ";
		break;

	case BDT_cointerface:
			Prefix = "cointerface ";
		break;
#endif	// CC_COR

	case BDT_enum:
			fPrefix = doEcsu();

			Prefix = "enum " + getEnumType ();
		break;

//	default:
//			return	DN_invalid;

	}	// End of SWITCH

	DName			ecsuDataType;

	if	( fPrefix )
		ecsuDataType	= Prefix;

	//	Get the 'class/struct/union' name

	ecsuDataType	+= getECSUName ();

	//	And return the formed 'ecsu-data-type'

	return	ecsuDataType;

}	// End of "UnDecorator" FUNCTION "getECSUDataType"


//
// Undecorator::getFunctionIndirectType
//
//	Note: this function gets both the function-indirect-type and the function-type.
//
DName		UnDecorator::getFunctionIndirectType( const DName & superType )
{
	if	( ! *gName )
		return DN_truncated + superType;

	if	( ! IT_isfunction( *gName ))
		return DN_invalid;


	int		fitCode	= *gName++ - '6';

	if		( fitCode == ( '_' - '6' ))
	{
		if	( *gName )
		{
			fitCode	= *gName++ - 'A' + FIT_based;

			if	(( fitCode < FIT_based ) || ( fitCode > ( FIT_based | FIT_far | FIT_member )))
				fitCode	= -1;

		}	// End of IF then
		else
			return	( DN_truncated + superType );

	}	// End of IF then
	elif	(( fitCode < FIT_near ) || ( fitCode > ( FIT_far | FIT_member )))
		fitCode	= -1;

	//	Return if invalid name

	if	( fitCode == -1 )
		return	DN_invalid;


	//	Otherwise, what are the function indirect attributes

	DName	thisType;
	DName	fitType = superType;

	//	Is it a pointer to member function ?

	if	( fitCode & FIT_member )
	{
		fitType	= "::" + fitType;

		if	( *gName )
			fitType	= ' ' + getScope () + fitType;
		else
			fitType	= DN_truncated + fitType;

		if	( *gName )
			if	( *gName == '@' )
				gName++;
			else
				return	DN_invalid;
		else
			return	( DN_truncated + fitType );

		if	( doThisTypes ())
			thisType	= getThisType ();
		else
			thisType	|= getThisType ();

	}	// End of IF

	//	Is it a based allocated function ?

	if	( fitCode & FIT_based )
		if	( doMSKeywords ())
			fitType	= ' ' + getBasedType () + fitType;
		else
			fitType	|= getBasedType ();	// Just lose the 'based-type'

	//	Get the 'calling-convention'

	if	( doMSKeywords ())
	{
		fitType	= getCallingConvention () + fitType;

		//	Is it a near or far function pointer

#if !VERS_32BIT
		fitType	= UScore ((( fitCode & FIT_far ) ? TOK_farSp : TOK_nearSp )) + fitType;
#endif

	}	// End of IF then
	else
		fitType	|= getCallingConvention ();	// Just lose the 'calling-convention'

	//	Parenthesise the indirection component, and work on the rest

	if	( ! superType . isEmpty() ) {
		fitType	= '(' + fitType + ')';
	}

	//	Get the rest of the 'function-type' pieces

	DName *	pDeclarator	= gnew DName;
	DName	returnType ( getReturnType ( pDeclarator ));


	fitType	+= '(' + getArgumentTypes () + ')';

	if	( doThisTypes () && ( fitCode & FIT_member ))
		fitType	+= thisType;

	if	( doThrowTypes ())
		fitType	+= getThrowTypes ();
	else
		fitType	|= getThrowTypes ();	// Just lose the 'throw-types'

	//	Now insert the indirected declarator, catch the allocation failure here

	if	( pDeclarator )
		*pDeclarator	= fitType;
	else
		return	DN_error;

	//	And return the composed function type (now in 'returnType' )

	return	returnType;
}


DName	UnDecorator::getPtrRefType ( const DName & cvType, const DName & superType, char ptrChar )
{
	//	Doubles up as 'pointer-type' and 'reference-type'

	if	( *gName )
		if	( IT_isfunction ( *gName ))	// Is it a function or data indirection ?
		{
			DName	fitType	= ptrChar;


			if	( !cvType.isEmpty () && ( superType.isEmpty () || !superType.isPtrRef ()))
				fitType	+= cvType;

			if	( !superType.isEmpty ())
				fitType	+= superType;

			return getFunctionIndirectType( fitType );
		}	// End of IF then
		else
		{
			//	Otherwise, it is either a pointer or a reference to some data type

			DName	innerType ( getDataIndirectType ( superType, ptrChar, cvType ));

			return	getPtrRefDataType ( innerType, ptrChar == '*' );
		}	// End of IF else
	else
	{
		DName	trunk ( DN_truncated );


		trunk	+= ptrChar;

		if	( !cvType.isEmpty ())
			trunk	+= cvType;

		if	( !superType.isEmpty ())
		{
			if	( !cvType.isEmpty ())
				trunk	+= ' ';

			trunk	+= superType;

		}	// End of IF

		return	trunk;

	}	// End of IF else
}	// End of "UnDecorator" FUNCTION "getPtrRefType"



DName	UnDecorator::getDataIndirectType ( const DName & superType, char prType, const DName & cvType, int thisFlag )
{
	DName szComPlusIndirSpecifier;

	if		( *gName )
	{
		if( gName[0] == '$' ) 
		{
			gName++;	// swallow up the dollar

			switch( *gName )
			{
			case PDT_GCPointer:
				szComPlusIndirSpecifier = "__gc ";
				gName++;
				break;

			case PDT_PinnedPointer:
				szComPlusIndirSpecifier = "__pin ";
				gName++;
				break;
			default:
				unsigned int nRank = ((gName[0]-'0') << 4) + (gName[1]-'0');
				gName += 2;

				DASSERT( nRank < 256 );

				szComPlusIndirSpecifier = "__gc[";

				for( unsigned int i=1; i<nRank; i++ )
				{
					szComPlusIndirSpecifier = szComPlusIndirSpecifier + ",";
				}

				szComPlusIndirSpecifier = szComPlusIndirSpecifier + "] ";

				if	( !superType.isEmpty () )
					if ( superType.isArray() )
						szComPlusIndirSpecifier	= superType + szComPlusIndirSpecifier;
					else
						szComPlusIndirSpecifier	= '(' + superType + ')' + szComPlusIndirSpecifier;

				gName++;

				return szComPlusIndirSpecifier;
			}
		}

		unsigned int	ditCode	= ( *gName - (( *gName >= 'A' ) ? (unsigned int)'A': (unsigned int)( '0' - 26 )));

		DName msExtension;
		DName msExtensionPre;

		int fContinue = TRUE;

		do
		{
			switch	( ditCode )
			{
			case DIT_ptr64:
					if	( doMSKeywords () && doPtr64() ) {
						if ( !msExtension.isEmpty())
							msExtension = msExtension + ' ' + UScore( TOK_ptr64 );
						else
							msExtension = UScore( TOK_ptr64 );
					}
					gName++;
					ditCode	= ( *gName - (( *gName >= 'A' ) ? (unsigned int)'A': (unsigned int)( '0' - 26 )));
				break;
			case DIT_unaligned:
					if	( doMSKeywords ()) {
						if ( !msExtensionPre.isEmpty())
							msExtensionPre = msExtensionPre + ' ' + UScore( TOK_unaligned );
						else
							msExtensionPre = UScore( TOK_unaligned );
					}
					gName++;
					ditCode	= ( *gName - (( *gName >= 'A' ) ? (unsigned int)'A': (unsigned int)( '0' - 26 )));
				break;
			case DIT_restrict:
					if	( doMSKeywords ()) {
						if ( !msExtension.isEmpty())
							msExtension = msExtension + ' ' + UScore( TOK_restrict );
						else
							msExtension = UScore( TOK_restrict );
					}
					gName++;
					ditCode	= ( *gName - (( *gName >= 'A' ) ? (unsigned int)'A': (unsigned int)( '0' - 26 )));
				break;

			default:

				fContinue = FALSE;
				break;
			}
		} while (fContinue);

		gName++;		// Skip to next character in name

		//	Is it a valid 'data-indirection-type' ?

		DASSERT(DIT_near == 0);
		if	(( ditCode <= ( DIT_const | DIT_volatile | DIT_modelmask | DIT_member )))
		{
			DName	ditType ( prType );

			ditType = szComPlusIndirSpecifier + ditType;

			if ( !msExtension.isEmpty()) 
				ditType = ditType + ' ' + msExtension;

			if ( !msExtensionPre.isEmpty())
				ditType = msExtensionPre + ' ' + ditType;

			//	If it is a member, then these attributes immediately precede the indirection token

			if	( ditCode & DIT_member )
			{
				//	If it is really 'this-type', then it cannot be any form of pointer to member

				if	( thisFlag )
					return	DN_invalid;

				//	Otherwise, extract the scope for the PM

				if		( prType != '\0' )
				{
					ditType		= "::" + ditType;

					if	( *gName )
						ditType	= getScope () + ditType;
					else
						ditType	= DN_truncated + ditType;
				}
				elif	( *gName )
				{
					//
					// The scope is ignored for special uses of data-indirect-type, such
					// as storage-convention.  I think it's a bug that we ever mark things
					// with Member storage convention, as that is already covered in the
					// scope of the name.  However, we don't want to change the dname scheme,
					// so we're stuck with it.
					//
					ditType |= getScope ();
				}

				//	Now skip the scope terminator

				if		( !*gName )
					ditType	+= DN_truncated;
				elif	( *gName++ != '@' )
					return	DN_invalid;

			}	// End of IF

			//	Add the 'model' attributes (prefixed) as appropriate

			if	( doMSKeywords ()) {
				switch	( ditCode & DIT_modelmask )
				{
#if !VERS_32BIT
				case DIT_near:
						if	( do32BitNear ())
							ditType	= UScore ( TOK_near ) + ditType;
					break;

				case DIT_far:
						ditType	= UScore ( TOK_far ) + ditType;
					break;

				case DIT_huge:
						ditType	= UScore ( TOK_huge ) + ditType;
					break;
#endif

				case DIT_based:
						//	The 'this-type' can never be 'based'

						if	( thisFlag )
							return	DN_invalid;

						ditType	= getBasedType () + ditType;
					break;

				}	// End of SWITCH
			}	// End of IF
			elif	(( ditCode & DIT_modelmask ) == DIT_based )
				ditType	|= getBasedType ();	// Just lose the 'based-type'

			//	Handle the 'const' and 'volatile' attributes

			if	( ditCode & DIT_volatile )
				ditType	= "volatile " + ditType;

			if	( ditCode & DIT_const )
				ditType	= "const " + ditType;

			//	Append the supertype, if not 'this-type'

			if	( !thisFlag )
				if		( !superType.isEmpty ())
				{
					//	Is the super context included 'cv' information, ensure that it is added appropriately

					if	( superType.isPtrRef () || cvType.isEmpty ())
						if (superType.isArray())
							ditType	= superType;	// array type, skip space
						else
							ditType	+= ' ' + superType;
					else
						ditType	+= ' ' + cvType + ' ' + superType;

				}	// End of IF then
				elif	( !cvType.isEmpty ())
					ditType	+= ' ' + cvType;

			//	Make sure qualifiers aren't re-applied
			ditType.setPtrRef ();

			//	Finally, return the composed 'data-indirection-type' (with embedded sub-type)

			return	ditType;

		}	// End of IF then
		else
			return	DN_invalid;

	}	// End of IF then
	elif	( !thisFlag && !superType.isEmpty ())
	{
		//	Is the super context included 'cv' information, ensure that it is added appropriately

		if	( superType.isPtrRef () || cvType.isEmpty ())
			return	( DN_truncated + superType );
		else
			return	( DN_truncated + cvType + ' ' + superType );

	}	// End of ELIF then
	elif	( !thisFlag && !cvType.isEmpty ())
		return	( DN_truncated + cvType );
	else
		return	DN_truncated;

}	// End of "UnDecorator" FUNCTION "getDataIndirectType"


inline	DName	UnDecorator::getPtrRefDataType ( const DName & superType, int isPtr )
{
	//	Doubles up as 'pointer-data-type' and 'reference-data-type'

	if	( *gName )
	{
		//	Is this a 'pointer-data-type' ?

		if	( isPtr && ( *gName == PoDT_void ))
		{
			gName++;	// Skip this character

			if	( superType.isEmpty ())
				return	"void";
			else
				return	"void " + superType;

		}	// End of IF

		//	Otherwise it may be a 'reference-data-type'

		if	( *gName == RDT_array )	// An array ?
		{
			gName++;

			return	getArrayType( superType );

		}	// End of IF

		//	Otherwise, it is a 'basic-data-type'

		if	( *gName == '_' && gName[1] == 'Z' )	// A boxed type ?
		{
			gName += 2;
			return "__box " + getBasicDataType ( superType );
		}

		return	getBasicDataType ( superType );

	}	// End of IF then
	else
		return	( DN_truncated + superType );

}	// End of "UnDecorator" FUNCTION "getPtrRefDataType"


inline	DName	UnDecorator::getArrayType ( const DName & superType )
{
	if	( *gName )
	{
		int	noDimensions	= getNumberOfDimensions ();

		if ( noDimensions < 0 )
			noDimensions = 0;

		if	( !noDimensions )
			return	getBasicDataType ( DName ( '[' ) + DN_truncated + ']' );
		else
		{
			DName	arrayType;

			if ( superType.isArray() ) {
				arrayType	+= "[]";
			}

			while	( noDimensions-- )
				arrayType	+= '[' + getDimension () + ']';

			//	If it is indirect, then parenthesise the 'super-type'

			if	( !superType.isEmpty () )
				if ( superType.isArray() )
					arrayType	= superType + arrayType;
				else
					arrayType	= '(' + superType + ')' + arrayType;

			//	Return the finished array dimension information

			DName newType =	getPrimaryDataType ( arrayType );
			newType.setIsArray();
			return newType;

		}	// End of IF else
	}	// End of IF
	elif	( !superType.isEmpty ())
		return	getBasicDataType ( '(' + superType + ")[" + DN_truncated + ']' );
	else
		return	getBasicDataType ( DName ( '[' ) + DN_truncated + ']' );

}	// End of "UnDecorator" FUNCTION "getArrayType"


inline		DName		UnDecorator::getLexicalFrame ( void )		{	return	'`' + getDimension () + '\'';	}
inline		DName		UnDecorator::getStorageConvention ( void )	{	return	getDataIndirectType ();	}
inline		DName		UnDecorator::getDataIndirectType ()			{	return	getDataIndirectType ( DName (),  0, DName ());	}
inline		DName		UnDecorator::getThisType ( void )			{	return	getDataIndirectType ( DName (), 0, DName (), TRUE );	}

inline	DName		UnDecorator::getPointerType ( const DName & cv, const DName & name )
{	return	getPtrRefType ( cv, name, '*' );	}

inline	DName		UnDecorator::getPointerTypeArray ( const DName & cv, const DName & name )
{	return	getPtrRefType ( cv, name, '\0' );	}

inline	DName		UnDecorator::getReferenceType ( const DName & cv, const DName & name )
{	return	getPtrRefType ( cv, name, '&' );	}

inline	DName		UnDecorator::getSegmentName ( void )		{	return	getZName ( true );	}

#if	( !NO_COMPILER_NAMES )
inline	DName		UnDecorator::getDisplacement ( void )		{	return	getDimension ( true );	}
inline	DName		UnDecorator::getCallIndex ( void )			{	return	getDimension ();	}
inline	DName		UnDecorator::getGuardNumber ( void )		{	return	getDimension ();	}

inline	DName	UnDecorator::getVbTableType ( const DName & superType )
{	return	getVfTableType ( superType );	}


inline	DName	UnDecorator::getVCallThunkType ( void )
{
#if VERS_32BIT
	switch (*gName) {
	case VMT_nTnCnV:
		++gName;
		return DName("{flat}");
	case 0:
		return DN_truncated;
	default:
		return DN_invalid;
	}
#else
	DName	vcallType	= '{';


	//	Get the 'this' model, and validate all values

	switch	( *gName )
	{
	case VMT_nTnCnV:
	case VMT_nTfCnV:
	case VMT_nTnCfV:
	case VMT_nTfCfV:
	case VMT_nTnCbV:
	case VMT_nTfCbV:
			vcallType	+= UScore ( TOK_nearSp );
		break;

	case VMT_fTnCnV:
	case VMT_fTfCnV:
	case VMT_fTnCfV:
	case VMT_fTfCfV:
	case VMT_fTnCbV:
	case VMT_fTfCbV:
			vcallType	+= UScore ( TOK_farSp );
		break;

	case 0:
			return	DN_truncated;

	default:
			return	DN_invalid;

	}	// End of SWITCH

	//	Always append 'this'

	vcallType	+= "this, ";

	//	Get the 'call' model

	switch	( *gName )
	{
	case VMT_nTnCnV:
	case VMT_fTnCnV:
	case VMT_nTnCfV:
	case VMT_fTnCfV:
	case VMT_nTnCbV:
	case VMT_fTnCbV:
			vcallType	+= UScore ( TOK_nearSp );
		break;

	case VMT_nTfCnV:
	case VMT_fTfCnV:
	case VMT_nTfCfV:
	case VMT_fTfCfV:
	case VMT_nTfCbV:
	case VMT_fTfCbV:
			vcallType	+= UScore ( TOK_farSp );
		break;

	}	// End of SWITCH

	//	Always append 'call'

	vcallType	+= "call, ";

	//	Get the 'vfptr' model

	switch	( *gName++ )	// Last time, so advance the pointer
	{
	case VMT_nTnCnV:
	case VMT_nTfCnV:
	case VMT_fTnCnV:
	case VMT_fTfCnV:
			vcallType	+= UScore ( TOK_nearSp );
		break;

	case VMT_nTnCfV:
	case VMT_nTfCfV:
	case VMT_fTnCfV:
	case VMT_fTfCfV:
			vcallType	+= UScore ( TOK_farSp );
		break;

	case VMT_nTfCbV:
	case VMT_fTnCbV:
	case VMT_fTfCbV:
	case VMT_nTnCbV:
			vcallType	+= getBasedType ();
		break;

	}	// End of SWITCH	

	//	Always append 'vfptr'

	vcallType	+= "vfptr}";

	//	And return the resultant 'vcall-model-type'

	return	vcallType;
#endif

}	// End of "UnDecorator" FUNCTION "getVCallThunk"


inline	DName	UnDecorator::getVfTableType ( const DName & superType )
{
	DName	vxTableName	= superType;


	if	( vxTableName.isValid () && *gName )
	{
		vxTableName	= getStorageConvention () + ' ' + vxTableName;

		if	( vxTableName.isValid ())
		{
			if	( *gName != '@' )
			{
				vxTableName	+= "{for ";

				while	( vxTableName.isValid () && *gName && ( *gName != '@' ))
				{
					vxTableName	+= '`' + getScope () + '\'';

					//	Skip the scope delimiter

					if	( *gName == '@' )
						gName++;

					//	Close the current scope, and add a conjunction for the next (if any)

					if	( vxTableName.isValid () && ( *gName != '@' ))
						vxTableName	+= "s ";

				}	// End of WHILE

				if	( vxTableName.isValid ())
				{
					if	( !*gName )
						vxTableName	+= DN_truncated;

					vxTableName	+= '}';

				}	// End of IF
			}	// End of IF

			//	Skip the 'vpath-name' terminator

			if	( *gName == '@' )
				gName++;

		}	// End of IF
	}	// End of IF then
	elif	( vxTableName.isValid ())
		vxTableName	= DN_truncated + vxTableName;

	return	vxTableName;

}	//	End of "UnDecorator" FUNCTION "getVfTableType"


inline	DName	UnDecorator::getVdispMapType ( const DName & superType )
{
	DName	vdispMapName	= superType;
	vdispMapName += "{for ";
	vdispMapName += getScope();
	vdispMapName += '}';

	if	( *gName == '@' )
		gName++;
	return vdispMapName;
}
#endif	// !NO_COMPILER_NAMES


inline	DName	UnDecorator::getExternalDataType ( const DName & superType )
{
	//	Create an indirect declarator for the the rest

	DName *	pDeclarator	= gnew DName ();
	DName	declaration	= getDataType ( pDeclarator );


	//	Now insert the declarator into the declaration along with its 'storage-convention'

	*pDeclarator	= getStorageConvention () + ' ' + superType;

	return	declaration;

}	//	End of "UnDecorator" FUNCTION "getExternalDataType"

inline	int			UnDecorator::doUnderScore ()				{	return	!( disableFlags & UNDNAME_NO_LEADING_UNDERSCORES );	}
inline	int			UnDecorator::doMSKeywords ()				{	return	!( disableFlags & UNDNAME_NO_MS_KEYWORDS );			}
inline	int			UnDecorator::doPtr64 ()						{	return	!( disableFlags & UNDNAME_NO_PTR64 );				}
inline	int			UnDecorator::doFunctionReturns ()			{	return	!( disableFlags & UNDNAME_NO_FUNCTION_RETURNS );	}
inline	int			UnDecorator::doAllocationModel ()			{	return	!( disableFlags & UNDNAME_NO_ALLOCATION_MODEL );	}
inline	int			UnDecorator::doAllocationLanguage ()		{	return	!( disableFlags & UNDNAME_NO_ALLOCATION_LANGUAGE );	}

#if	0
inline	int			UnDecorator::doMSThisType ()				{	return	!( disableFlags & UNDNAME_NO_MS_THISTYPE );			}
inline	int			UnDecorator::doCVThisType ()				{	return	!( disableFlags & UNDNAME_NO_CV_THISTYPE );			}
#endif

inline	int			UnDecorator::doThisTypes ()					{	return	(( disableFlags & UNDNAME_NO_THISTYPE ) != UNDNAME_NO_THISTYPE );	}
inline	int			UnDecorator::doAccessSpecifiers ()			{	return	!( disableFlags & UNDNAME_NO_ACCESS_SPECIFIERS );	}
inline	int			UnDecorator::doThrowTypes ()				{	return	!( disableFlags & UNDNAME_NO_THROW_SIGNATURES );	}
inline	int			UnDecorator::doMemberTypes ()				{	return	!( disableFlags & UNDNAME_NO_MEMBER_TYPE );			}
inline	int			UnDecorator::doReturnUDTModel ()			{	return	!( disableFlags & UNDNAME_NO_RETURN_UDT_MODEL );	}

inline	int			UnDecorator::do32BitNear ()					{	return	!( disableFlags & UNDNAME_32_BIT_DECODE );			}

inline	int			UnDecorator::doNameOnly ()					{	return	( disableFlags & UNDNAME_NAME_ONLY );				}
inline	int			UnDecorator::doTypeOnly ()					{	return	( disableFlags & UNDNAME_TYPE_ONLY );				}
inline	int			UnDecorator::haveTemplateParameters ()		{	return	( disableFlags & UNDNAME_HAVE_PARAMETERS);			}
inline	int 		UnDecorator::doEcsu ()						{	return	!( disableFlags & UNDNAME_NO_ECSU );				}
inline	int 		UnDecorator::doNoIdentCharCheck ()			{	return	( disableFlags & UNDNAME_NO_IDENT_CHAR_CHECK );		}


pcchar_t	UnDecorator::UScore ( Tokens tok  )
{
#if !VERS_32BIT
	if		((( tok == TOK_nearSp ) || ( tok == TOK_nearP )) && !do32BitNear ())
		return	tokenTable[ tok ] + 6;	// Skip '__near'
#endif
	if		( doUnderScore ())
		return	tokenTable[ tok ];
	else
		return	tokenTable[ tok ] + 2 ;

}	// End of "UnDecorator" FUNCTION "UScore"


//	Include the string composition support classes.  Mostly inline stuff, and
//	not important to the algorithm.

#include	"undname.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\crtdbg.h ===
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */


 /****************************************************************************
 *
 * Constants and types
 *
 ***************************************************************************/

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);

#define _CRT_RPTHOOK_INSTALL  0
#define _CRT_RPTHOOK_REMOVE   1

 /****************************************************************************
 *
 * Heap
 *
 ***************************************************************************/

 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);

 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

/*
 * Some bit values for _crtDbgFlag which correspond to frequencies for checking
 * the the heap.
 */
#define _CRTDBG_CHECK_EVERY_16_DF   0x00100000  /* check heap every 16 heap ops */
#define _CRTDBG_CHECK_EVERY_128_DF  0x00800000  /* check heap every 128 heap ops */
#define _CRTDBG_CHECK_EVERY_1024_DF 0x04000000  /* check heap every 1024 heap ops */
#define _CRTDBG_CHECK_DEFAULT_DF    _CRTDBG_CHECK_EVERY_1024_DF

#define _CRTDBG_REPORT_FLAG         -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);

struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        size_t lCounts[_MAX_BLOCKS];
        size_t lSizes[_MAX_BLOCKS];
        size_t lHighWaterCount;
        size_t lTotalCount;
} _CrtMemState;


 /****************************************************************************
 *
 * Declarations, prototype and function-like macros
 *
 ***************************************************************************/


#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _ASSERT(expr) ((void)0)

#define _ASSERTE(expr) ((void)0)


#define _RPT0(rptno, msg)

#define _RPT1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _RPTF0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

#define _aligned_malloc_dbg(s, a, f, l)     _aligned_malloc(s, a)
#define _aligned_realloc_dbg(p, s, a, f, l) _aligned_realloc(p, s, a)
#define _aligned_free_dbg(p)                _aligned_free(p)
#define _aligned_offset_malloc_dbg(s, a, o, f, l)       _aligned_offset_malloc(s, a, o)
#define _aligned_offset_realloc_dbg(p, s, a, o, f, l)   _aligned_offset_realloc(p, s, a, o)

#define _CrtSetReportHook(f)                ((_CRT_REPORT_HOOK)0)
#define _CrtSetReportHook2(t, f)            ((int)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtSetReportFile(t, f)             ((_HFILE)0)

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((_CRT_ALLOC_HOOK)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)
#define _CrtReportBlockType(p)              ((int)-1)

#define _CrtSetDumpClient(f)                ((_CRT_DUMP_CLIENT)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)


#else   /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

_CRTIMP extern long _crtAssertBusy;

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportHook2(
        int,
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );

_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );

_CRTIMP int __cdecl _CrtDbgReport(
        int,
        const char *,
        int,
        const char *,
        const char *,
        ...);

/* Asserts */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _ASSERT_BASE(expr, msg) \
        (void) ((expr) || \
                (1 != _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg)) || \
                (_CrtDbgBreak(), 0))
#else
#define _ASSERT_BASE(expr, msg) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg))) \
             _CrtDbgBreak(); } while (0)
#endif

#define _ASSERT(expr)   _ASSERT_BASE((expr), NULL)

#define _ASSERTE(expr)  _ASSERT_BASE((expr), #expr)

/* Reports with no file/line info */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _RPT_BASE(args) \
        (void) ((1 != _CrtDbgReport args) || \
                (_CrtDbgBreak(), 0))
#else
#define _RPT_BASE(args) \
        do { if ((1 == _CrtDbgReport args)) \
                _CrtDbgBreak(); } while (0)
#endif

#define _RPT0(rptno, msg) \
        _RPT_BASE((rptno, NULL, 0, NULL, "%s", msg))

#define _RPT1(rptno, msg, arg1) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1))

#define _RPT2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2))

#define _RPT3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))


/* Reports with file/line info */

#define _RPTF0(rptno, msg) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, "%s", msg))

#define _RPTF1(rptno, msg, arg1) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1))

#define _RPTF2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))

#define _RPTF3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))

#if     _MSC_VER >= 1300 && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __debugbreak()
#elif   defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __asm { int 3 }
#elif   defined(_M_IA64) && !defined(_CRT_PORTABLE)
void __break(int);
#pragma intrinsic (__break)
#define _CrtDbgBreak() __break(0x80016)
#else
_CRTIMP void __cdecl _CrtDbgBreak(
        void
        );
#endif

 /****************************************************************************
 *
 * Heap routines
 *
 ***************************************************************************/

#ifdef  _CRTDBG_MAP_ALLOC

#define   malloc(s)         _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   calloc(c, s)      _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   realloc(p, s)     _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _expand(p, s)     _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)           _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)         _msize_dbg(p, _NORMAL_BLOCK)
#define   _aligned_malloc(s, a)                 _aligned_malloc_dbg(s, a, __FILE__, __LINE__)
#define   _aligned_realloc(p, s, a)             _aligned_realloc_dbg(p, s, a, __FILE__, __LINE__)
#define   _aligned_offset_malloc(s, a, o)       _aligned_offset_malloc_dbg(s, a, o, __FILE__, __LINE__)
#define   _aligned_offset_realloc(p, s, a, o)   _aligned_offset_realloc_dbg(p, s, a, o, __FILE__, __LINE__)
#define   _aligned_free(p)  _aligned_free_dbg(p)

#endif  /* _CRTDBG_MAP_ALLOC */

_CRTIMP extern long _crtBreakAlloc;      /* Break on this allocation */

_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_CRTIMP void * __cdecl _malloc_dbg(
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _calloc_dbg(
        size_t,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _realloc_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _expand_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void __cdecl _free_dbg(
        void *,
        int
        );

_CRTIMP size_t __cdecl _msize_dbg (
        void *,
        int
        );

_CRTIMP void * __cdecl _aligned_malloc_dbg(
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_realloc_dbg(
        void *,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_malloc_dbg(
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_realloc_dbg(
        void *,
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void __cdecl _aligned_free_dbg(
        void *
        );


 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK
        );


 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bitfield flag that controls CRT heap behavior
 * Default setting is _CRTDBG_ALLOC_MEM_DF
 */

_CRTIMP extern int _crtDbgFlag;

_CRTIMP int __cdecl _CrtCheckMemory(
        void
        );

_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );

_CRTIMP void __cdecl _CrtDoForAllClientObjects(
        void (*pfn)(void *, void *),
        void *
        );

_CRTIMP int __cdecl _CrtIsValidPointer(
        const void *,
        unsigned int,
        int
        );

_CRTIMP int __cdecl _CrtIsValidHeapPointer(
        const void *
        );

_CRTIMP int __cdecl _CrtIsMemoryBlock(
        const void *,
        unsigned int,
        long *,
        char **,
        int *
        );

_CRTIMP int __cdecl _CrtReportBlockType(
        const void *
        );


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT
        );

_CRTIMP void __cdecl _CrtMemCheckpoint(
        _CrtMemState *
        );

_CRTIMP int __cdecl _CrtMemDifference(
        _CrtMemState *,
        const _CrtMemState *,
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpStatistics(
        const _CrtMemState *
        );

_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );

#endif  /* _DEBUG */

#ifdef  __cplusplus
}

#ifndef _MFC_OVERRIDES_NEW

extern "C++" {

#pragma warning(disable: 4507)  /* Ignore faulty warning */

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

 
#ifdef USE_ARRAY_NEW_DELETE
void * __cdecl operator new[](size_t);

inline void* __cdecl operator new[](size_t s, int, const char *, int)
        { return ::operator new[](s); }

#endif

inline void * __cdecl operator new(size_t s, int, const char *, int)
        { return ::operator new(s); }

#if     _MSC_VER >= 1200


#ifdef USE_ARRAY_NEW_DELETE
void __cdecl operator delete[](void *);
inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
#endif
#else /* _DEBUG */

 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/
 
#ifdef USE_ARRAY_NEW_DELETE
void * __cdecl operator new[](size_t);

void * __cdecl operator new[](
        size_t,
        int,
        const char *,
        int
        );
#endif

void * __cdecl operator new(
        size_t,
        int,
        const char *,
        int
        );

#if     _MSC_VER >= 1200
#ifdef USE_ARRAY_NEW_DELETE
void __cdecl operator delete[](void *);
inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }

#endif

#ifdef _CRTDBG_MAP_ALLOC

inline void * __cdecl operator new(size_t s)
        { return ::operator new(s, _NORMAL_BLOCK, __FILE__, __LINE__); }

#ifdef USE_ARRAY_NEW_DELETE
inline void* __cdecl operator new[](size_t s)
        { return ::operator new[](s, _NORMAL_BLOCK, __FILE__, __LINE__); }
#endif
#endif  /* _CRTDBG_MAP_ALLOC */

#endif  /* _DEBUG */

}

#endif  /* _MFC_OVERRIDES_NEW */

#endif  /* __cplusplus */

#endif  /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the structs and unions used for the direct DOS interface
*       routines; includes macros to access the segment and offset
*       values of far pointers, so that they may be used by the routines; and
*       provides function prototypes for direct DOS interface functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_DOS
#define _INC_DOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _DISKFREE_T_DEFINED
/* _getdiskfree structure (duplicated in DIRECT.H) */
struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif

/* File attribute constants */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* Function prototypes */
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);

#ifdef  _M_IX86
void __cdecl _disable(void);
void __cdecl _enable(void);
#endif  /* _M_IX86 */

#if     !__STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t  _diskfree_t
#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DOS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for
*       the MS C V2.03 compatible console I/O routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CONIO
#define _INC_CONIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Function prototypes */

_CRTIMP char * __cdecl _cgets(char *);
_CRTIMP int __cdecl _cprintf(const char *, ...);
_CRTIMP int __cdecl _cputs(const char *);
_CRTIMP int __cdecl _cscanf(const char *, ...);
_CRTIMP int __cdecl _getch(void);
_CRTIMP int __cdecl _getche(void);
#ifdef  _M_IX86
int __cdecl _inp(unsigned short);
unsigned short __cdecl _inpw(unsigned short);
unsigned long __cdecl _inpd(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _kbhit(void);
#ifdef  _M_IX86
int __cdecl _outp(unsigned short, int);
unsigned short __cdecl _outpw(unsigned short, unsigned short);
unsigned long __cdecl _outpd(unsigned short, unsigned long);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _putch(int);
_CRTIMP int __cdecl _ungetch(int);


#ifndef _WCONIO_DEFINED

/* wide function prototypes, also declared in wchar.h */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);


#define _WCONIO_DEFINED
#endif  /* _WCONIO_DEFINED */

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP char * __cdecl cgets(char *);
_CRTIMP int __cdecl cprintf(const char *, ...);
_CRTIMP int __cdecl cputs(const char *);
_CRTIMP int __cdecl cscanf(const char *, ...);
#ifdef  _M_IX86
int __cdecl inp(unsigned short);
unsigned short __cdecl inpw(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl getch(void);
_CRTIMP int __cdecl getche(void);
_CRTIMP int __cdecl kbhit(void);
#ifdef  _M_IX86
int __cdecl outp(unsigned short, int);
unsigned short __cdecl outpw(unsigned short, unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl putch(int);
_CRTIMP int __cdecl ungetch(int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_CONIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the library
*       functions related to directory handling and creation.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_DIRECT
#define _INC_DIRECT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* _getdiskfree structure for _getdiskfree() */
#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif

/* function prototypes */

_CRTIMP int __cdecl _chdir(const char *);
_CRTIMP char * __cdecl _getcwd(char *, int);
_CRTIMP int __cdecl _mkdir(const char *);
_CRTIMP int __cdecl _rmdir(const char *);

_CRTIMP int __cdecl _chdrive(int);
_CRTIMP char * __cdecl _getdcwd(int, char *, int);
_CRTIMP int __cdecl _getdrive(void);
_CRTIMP unsigned long __cdecl _getdrives(void);
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);

#ifndef _WDIRECT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif


#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl chdir(const char *);
_CRTIMP char * __cdecl getcwd(char *, int);
_CRTIMP int __cdecl mkdir(const char *);
_CRTIMP int __cdecl rmdir(const char *);

#define diskfree_t  _diskfree_t

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DIRECT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\eh.h ===
/***
*eh.h - User include file for exception handling.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       User include file for exception handling.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_EH
#define _INC_EH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif  // _MSC_VER

#ifndef __cplusplus
#error "eh.h is only for C++!"
#endif


/* Define _CRTIMP */
#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_handler)();

struct _EXCEPTION_POINTERS;
typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl terminate(void);
_CRTIMP __declspec(noreturn) void __cdecl unexpected(void);
#else
_CRTIMP void __cdecl terminate(void);
_CRTIMP void __cdecl unexpected(void);
#endif

_CRTIMP terminate_function __cdecl set_terminate(terminate_function);
_CRTIMP unexpected_function __cdecl set_unexpected(unexpected_function);
_CRTIMP _se_translator_function __cdecl _set_se_translator(_se_translator_function);
_CRTIMP bool __uncaught_exception();

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_EH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the system-wide error numbers (set by
*       system calls).  Conforms to the XENIX standard.  Extended
*       for compatibility with Uniforum standard.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_ERRNO
#define _INC_ERRNO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* declare reference to errno */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */

/* Error Codes */

#define EPERM           1
#define ENOENT          2
#define ESRCH           3
#define EINTR           4
#define EIO             5
#define ENXIO           6
#define E2BIG           7
#define ENOEXEC         8
#define EBADF           9
#define ECHILD          10
#define EAGAIN          11
#define ENOMEM          12
#define EACCES          13
#define EFAULT          14
#define EBUSY           16
#define EEXIST          17
#define EXDEV           18
#define ENODEV          19
#define ENOTDIR         20
#define EISDIR          21
#define EINVAL          22
#define ENFILE          23
#define EMFILE          24
#define ENOTTY          25
#define EFBIG           27
#define ENOSPC          28
#define ESPIPE          29
#define EROFS           30
#define EMLINK          31
#define EPIPE           32
#define EDOM            33
#define ERANGE          34
#define EDEADLK         36
#define ENAMETOOLONG    38
#define ENOLCK          39
#define ENOSYS          40
#define ENOTEMPTY       41
#define EILSEQ          42

/*
 * Support EDEADLOCK for compatibiity with older MS-C versions.
 */
#define EDEADLOCK       EDEADLK

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_ERRNO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines macros for character classification/conversion.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CTYPE
#define _INC_CTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
_CRTIMP const unsigned short * __cdecl __pctype_func(void);
_CRTIMP const wctype_t * __cdecl __pwctype_func(void);
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#ifndef __PCTYPE_FUNC
#ifdef _MT
#define __PCTYPE_FUNC   __pctype_func()
#else
#define __PCTYPE_FUNC  _pctype
#endif  /* _MT */
#endif  /* __PCTYPE_FUNC */
#endif  /* _CTYPE_DISABLE_MACROS */




/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_CRTIMP int __cdecl _isctype(int, int);
_CRTIMP int __cdecl isalpha(int);
_CRTIMP int __cdecl isupper(int);
_CRTIMP int __cdecl islower(int);
_CRTIMP int __cdecl isdigit(int);
_CRTIMP int __cdecl isxdigit(int);
_CRTIMP int __cdecl isspace(int);
_CRTIMP int __cdecl ispunct(int);
_CRTIMP int __cdecl isalnum(int);
_CRTIMP int __cdecl isprint(int);
_CRTIMP int __cdecl isgraph(int);
_CRTIMP int __cdecl iscntrl(int);
_CRTIMP int __cdecl toupper(int);
_CRTIMP int __cdecl tolower(int);
_CRTIMP int __cdecl _tolower(int);
_CRTIMP int __cdecl _toupper(int);
_CRTIMP int __cdecl __isascii(int);
_CRTIMP int __cdecl __toascii(int);
_CRTIMP int __cdecl __iscsymf(int);
_CRTIMP int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif

#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX
#ifdef _MT
#define MB_CUR_MAX ___mb_cur_max_func()
#else
#define MB_CUR_MAX __mb_cur_max
#endif
_CRTIMP extern int __mb_cur_max;
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */

/* Introduced to detect error when character testing functions are called
 * with illegal input of integer.
 */
#ifdef _DEBUG
_CRTIMP int __cdecl _chvalidator(int, int);
#define __chvalidchk(a,b)       _chvalidator(a,b)
#else
#define __chvalidchk(a,b)       (__PCTYPE_FUNC[(a)] & (b))
#endif



#ifndef _MT
#ifndef __cplusplus
#define isalpha(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : __chvalidchk(_c, _ALPHA))
#define isupper(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : __chvalidchk(_c, _UPPER))
#define islower(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : __chvalidchk(_c, _LOWER))
#define isdigit(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : __chvalidchk(_c, _DIGIT))
#define isxdigit(_c)    (MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : __chvalidchk(_c, _HEX))
#define isspace(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : __chvalidchk(_c, _SPACE))
#define ispunct(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : __chvalidchk(_c, _PUNCT))
#define isalnum(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : __chvalidchk(_c, (_ALPHA|_DIGIT)))
#define isprint(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_BLANK|_PUNCT|_ALPHA|_DIGIT)))
#define isgraph(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_PUNCT|_ALPHA|_DIGIT)))
#define iscntrl(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : __chvalidchk(_c, _CONTROL))
#elif   0         /* Pending ANSI C++ integration */
inline int isalpha(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA) : __chvalidchk(_C, _ALPHA)); }
inline int isupper(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_UPPER) : __chvalidchk(_C, _UPPER)); }
inline int islower(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_LOWER) : __chvalidchk(_C, _LOWER)); }
inline int isdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_DIGIT) : __chvalidchk(_C, _DIGIT)); }
inline int isxdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_HEX)   : __chvalidchk(_C, _HEX)); }
inline int isspace(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_SPACE) : __chvalidchk(_C, _SPACE)); }
inline int ispunct(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT) : __chvalidchk(_C, _PUNCT)); }
inline int isalnum(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA|_DIGIT)
                : __chvalidchk(_C) , (_ALPHA|_DIGIT)); }
inline int isprint(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_BLANK|_PUNCT|_ALPHA|_DIGIT))); }
inline int isgraph(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_PUNCT|_ALPHA|_DIGIT))); }
inline int iscntrl(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_CONTROL)
                : __chvalidchk(_C , _CONTROL)); }
#endif  /* __cplusplus */
#endif  /* _MT */


#define _tolower(_c)    ( (_c)-'A'+'a' )
#define _toupper(_c)    ( (_c)-'a'+'A' )

#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#define __toascii(_c)   ( (_c) & 0x7f )

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )
#define isleadbyte(_c)  ( __PCTYPE_FUNC[(unsigned char)(_c)] & _LEADBYTE)
#elif   0         /* __cplusplus */
inline int iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int isleadbyte(int _C)
        {return (__PCTYPE_FUNC[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */



/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))

#endif  /* _CTYPE_DISABLE_MACROS */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#ifndef _CTYPE_DEFINED
_CRTIMP int __cdecl isascii(int);
_CRTIMP int __cdecl toascii(int);
_CRTIMP int __cdecl iscsymf(int);
_CRTIMP int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif


#endif  /* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines constants for the file control options used
*       by the _open() function.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FCNTL
#define _INC_FCNTL

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _O_RDONLY       0x0000  /* open for reading only */
#define _O_WRONLY       0x0001  /* open for writing only */
#define _O_RDWR         0x0002  /* open for reading and writing */
#define _O_APPEND       0x0008  /* writes done at eof */

#define _O_CREAT        0x0100  /* create and open file */
#define _O_TRUNC        0x0200  /* open and truncate */
#define _O_EXCL         0x0400  /* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define _O_TEXT         0x4000  /* file mode is text (translated) */
#define _O_BINARY       0x8000  /* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define _O_RAW  _O_BINARY

/* Open handle inherit bit */

#define _O_NOINHERIT    0x0080  /* child process doesn't inherit file */

/* Temporary file bit - file is deleted when last handle is closed */

#define _O_TEMPORARY    0x0040  /* temporary file bit */

/* temporary access hint */

#define _O_SHORT_LIVED  0x1000  /* temporary storage file, try not to flush */

/* sequential/random access hints */

#define _O_SEQUENTIAL   0x0020  /* file access is primarily sequential */
#define _O_RANDOM       0x0010  /* file access is primarily random */

#if     !__STDC__ || defined(_POSIX_)
/* Non-ANSI names for compatibility */
#define O_RDONLY        _O_RDONLY
#define O_WRONLY        _O_WRONLY
#define O_RDWR          _O_RDWR
#define O_APPEND        _O_APPEND
#define O_CREAT         _O_CREAT
#define O_TRUNC         _O_TRUNC
#define O_EXCL          _O_EXCL
#define O_TEXT          _O_TEXT
#define O_BINARY        _O_BINARY
#define O_RAW           _O_BINARY
#define O_TEMPORARY     _O_TEMPORARY
#define O_NOINHERIT     _O_NOINHERIT
#define O_SEQUENTIAL    _O_SEQUENTIAL
#define O_RANDOM        _O_RANDOM
#endif  /* __STDC__ */

#endif  /* _INC_FCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\float.h ===
/***
*float.h - constants for floating point values
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains defines for a number of implementation dependent
*       values which are commonly used by sophisticated numerical (floating
*       point) programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FLOAT
#define _INC_FLOAT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#define DBL_DIG         15                      /* # of decimal digits of precision */
#define DBL_EPSILON     2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG    53                      /* # of bits in mantissa */
#define DBL_MAX         1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP  308                     /* max decimal exponent */
#define DBL_MAX_EXP     1024                    /* max binary exponent */
#define DBL_MIN         2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP  (-307)                  /* min decimal exponent */
#define DBL_MIN_EXP     (-1021)                 /* min binary exponent */
#define _DBL_RADIX      2                       /* exponent radix */
#define _DBL_ROUNDS     1                       /* addition rounding: near */

#define FLT_DIG         6                       /* # of decimal digits of precision */
#define FLT_EPSILON     1.192092896e-07F        /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD       0
#define FLT_MANT_DIG    24                      /* # of bits in mantissa */
#define FLT_MAX         3.402823466e+38F        /* max value */
#define FLT_MAX_10_EXP  38                      /* max decimal exponent */
#define FLT_MAX_EXP     128                     /* max binary exponent */
#define FLT_MIN         1.175494351e-38F        /* min positive value */
#define FLT_MIN_10_EXP  (-37)                   /* min decimal exponent */
#define FLT_MIN_EXP     (-125)                  /* min binary exponent */
#define FLT_NORMALIZE   0
#define FLT_RADIX       2                       /* exponent radix */
#define FLT_ROUNDS      1                       /* addition rounding: near */

#define LDBL_DIG        DBL_DIG                 /* # of decimal digits of precision */
#define LDBL_EPSILON    DBL_EPSILON             /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   DBL_MANT_DIG            /* # of bits in mantissa */
#define LDBL_MAX        DBL_MAX                 /* max value */
#define LDBL_MAX_10_EXP DBL_MAX_10_EXP          /* max decimal exponent */
#define LDBL_MAX_EXP    DBL_MAX_EXP             /* max binary exponent */
#define LDBL_MIN        DBL_MIN                 /* min positive value */
#define LDBL_MIN_10_EXP DBL_MIN_10_EXP          /* min decimal exponent */
#define LDBL_MIN_EXP    DBL_MIN_EXP             /* min binary exponent */
#define _LDBL_RADIX     DBL_RADIX               /* exponent radix */
#define _LDBL_ROUNDS    DBL_ROUNDS              /* addition rounding: near */

/* Function prototypes */

_CRTIMP unsigned int __cdecl _clearfp(void);
_CRTIMP unsigned int __cdecl _controlfp(unsigned int,unsigned int);
_CRTIMP unsigned int __cdecl _statusfp(void);
_CRTIMP void __cdecl _fpreset(void);

#define _clear87        _clearfp
#define _status87       _statusfp

/*
 * Abstract User Control Word Mask and bit definitions
 */
#define _MCW_EM         0x0008001f              /* interrupt Exception Masks */
#define _EM_INEXACT     0x00000001              /*   inexact (precision) */
#define _EM_UNDERFLOW   0x00000002              /*   underflow */
#define _EM_OVERFLOW    0x00000004              /*   overflow */
#define _EM_ZERODIVIDE  0x00000008              /*   zero divide */
#define _EM_INVALID     0x00000010              /*   invalid */

#define _MCW_RC         0x00000300              /* Rounding Control */
#define _RC_NEAR        0x00000000              /*   near */
#define _RC_DOWN        0x00000100              /*   down */
#define _RC_UP          0x00000200              /*   up */
#define _RC_CHOP        0x00000300              /*   chop */

/*
 * Abstract User Status Word bit definitions
 */

#define _SW_INEXACT     0x00000001              /* inexact (precision) */
#define _SW_UNDERFLOW   0x00000002              /* underflow */
#define _SW_OVERFLOW    0x00000004              /* overflow */
#define _SW_ZERODIVIDE  0x00000008              /* zero divide */
#define _SW_INVALID     0x00000010              /* invalid */


/*
 * i386 specific definitions
 */
#define _MCW_PC         0x00030000              /* Precision Control */
#define _PC_64          0x00000000              /*    64 bits */
#define _PC_53          0x00010000              /*    53 bits */
#define _PC_24          0x00020000              /*    24 bits */

#define _MCW_IC         0x00040000              /* Infinity Control */
#define _IC_AFFINE      0x00040000              /*   affine */
#define _IC_PROJECTIVE  0x00000000              /*   projective */

#define _EM_DENORMAL    0x00080000              /* denormal exception mask (_control87 only) */

#define _SW_DENORMAL    0x00080000              /* denormal status bit */


_CRTIMP unsigned int __cdecl _control87(unsigned int,unsigned int);


/*
 * RISC specific definitions
 */

#define _MCW_DN         0x03000000              /* Denormal Control */
#define _DN_SAVE        0x00000000              /*   save denormal results and operands */
#define _DN_FLUSH       0x01000000              /*   flush denormal results and operands to zero */
#define _DN_FLUSH_OPERANDS_SAVE_RESULTS 0x02000000  /*   flush operands to zero and save results */
#define _DN_SAVE_OPERANDS_FLUSH_RESULTS 0x03000000  /*   save operands and flush results to zero */


/* initial Control Word value */

#if     defined(_M_IX86)

#define _CW_DEFAULT ( _RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif   defined(_M_IA64) || defined(_M_AMD64)

#define _CW_DEFAULT ( _RC_NEAR + _PC_64 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#endif

/* Global variable holding floating point error code */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl __fpecode(void);
#define _fpecode        (*__fpecode())
#else   /* ndef _MT && ndef _DLL */
extern int _fpecode;
#endif  /* _MT || _DLL */

/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED          0x0040  /* unemulated instruction */
#define _SW_SQRTNEG             0x0080  /* square root of a neg number */
#define _SW_STACKOVERFLOW       0x0200  /* FP stack overflow */
#define _SW_STACKUNDERFLOW      0x0400  /* FP stack underflow */

/*  Floating point error signals and return codes */

#define _FPE_INVALID            0x81
#define _FPE_DENORMAL           0x82
#define _FPE_ZERODIVIDE         0x83
#define _FPE_OVERFLOW           0x84
#define _FPE_UNDERFLOW          0x85
#define _FPE_INEXACT            0x86

#define _FPE_UNEMULATED         0x87
#define _FPE_SQRTNEG            0x88
#define _FPE_STACKOVERFLOW      0x8a
#define _FPE_STACKUNDERFLOW     0x8b

#define _FPE_EXPLICITGEN        0x8c    /* raise( SIGFPE ); */


/* IEEE recommended functions */

_CRTIMP double __cdecl _copysign (double, double);
_CRTIMP double __cdecl _chgsign (double);
_CRTIMP double __cdecl _scalb(double, long);
_CRTIMP double __cdecl _logb(double);
_CRTIMP double __cdecl _nextafter(double, double);
_CRTIMP int    __cdecl _finite(double);
_CRTIMP int    __cdecl _isnan(double);
_CRTIMP int    __cdecl _fpclass(double);

#define _FPCLASS_SNAN   0x0001  /* signaling NaN */
#define _FPCLASS_QNAN   0x0002  /* quiet NaN */
#define _FPCLASS_NINF   0x0004  /* negative infinity */
#define _FPCLASS_NN     0x0008  /* negative normal */
#define _FPCLASS_ND     0x0010  /* negative denormal */
#define _FPCLASS_NZ     0x0020  /* -0 */
#define _FPCLASS_PZ     0x0040  /* +0 */
#define _FPCLASS_PD     0x0080  /* positive denormal */
#define _FPCLASS_PN     0x0100  /* positive normal */
#define _FPCLASS_PINF   0x0200  /* positive infinity */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define clear87         _clear87
#define status87        _status87
#define control87       _control87

_CRTIMP void __cdecl fpreset(void);

#define DBL_RADIX               _DBL_RADIX
#define DBL_ROUNDS              _DBL_ROUNDS

#define LDBL_RADIX              _LDBL_RADIX
#define LDBL_ROUNDS             _LDBL_ROUNDS

#define MCW_EM                  _MCW_EM
#define EM_INVALID              _EM_INVALID
#define EM_DENORMAL             _EM_DENORMAL
#define EM_ZERODIVIDE           _EM_ZERODIVIDE
#define EM_OVERFLOW             _EM_OVERFLOW
#define EM_UNDERFLOW            _EM_UNDERFLOW
#define EM_INEXACT              _EM_INEXACT

#define MCW_IC                  _MCW_IC
#define IC_AFFINE               _IC_AFFINE
#define IC_PROJECTIVE           _IC_PROJECTIVE

#define MCW_RC                  _MCW_RC
#define RC_CHOP                 _RC_CHOP
#define RC_UP                   _RC_UP
#define RC_DOWN                 _RC_DOWN
#define RC_NEAR                 _RC_NEAR

#define MCW_PC                  _MCW_PC
#define PC_24                   _PC_24
#define PC_53                   _PC_53
#define PC_64                   _PC_64

#define CW_DEFAULT              _CW_DEFAULT

#define SW_INVALID              _SW_INVALID
#define SW_DENORMAL             _SW_DENORMAL
#define SW_ZERODIVIDE           _SW_ZERODIVIDE
#define SW_OVERFLOW             _SW_OVERFLOW
#define SW_UNDERFLOW            _SW_UNDERFLOW
#define SW_INEXACT              _SW_INEXACT

#define SW_UNEMULATED           _SW_UNEMULATED
#define SW_SQRTNEG              _SW_SQRTNEG
#define SW_STACKOVERFLOW        _SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW       _SW_STACKUNDERFLOW

#define FPE_INVALID             _FPE_INVALID
#define FPE_DENORMAL            _FPE_DENORMAL
#define FPE_ZERODIVIDE          _FPE_ZERODIVIDE
#define FPE_OVERFLOW            _FPE_OVERFLOW
#define FPE_UNDERFLOW           _FPE_UNDERFLOW
#define FPE_INEXACT             _FPE_INEXACT

#define FPE_UNEMULATED          _FPE_UNEMULATED
#define FPE_SQRTNEG             _FPE_SQRTNEG
#define FPE_STACKOVERFLOW       _FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW      _FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN         _FPE_EXPLICITGEN

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_FLOAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\iso646.h ===
/* iso646.h standard header */
#ifndef _ISO646
#define _ISO646
#define and		&&
#define and_eq	&=
#define bitand	&
#define bitor	|
#define compl	~
#define not		!
#define not_eq	!=
#define or		||
#define or_eq	|=
#define xor		^
#define xor_eq	^=
#endif /* _ISO646 */

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\excpt.h ===
/***
*excpt.h - defines exception values, types and routines
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definitions and prototypes for the compiler-
*       dependent intrinsics, support functions and keywords which implement
*       the structured exception handling extensions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_EXCPT
#define _INC_EXCPT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */

struct _EXCEPTION_RECORD;
struct _CONTEXT;
typedef struct _EXCEPTION_POINTERS *Exception_info_ptr;
struct _DISPATCHER_CONTEXT;

#ifdef  _M_IX86

EXCEPTION_DISPOSITION __cdecl _except_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void * EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext
    );

#elif   defined(_M_IA64)

_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    unsigned __int64 MemoryStackFp,
    unsigned __int64 BackingStoreFp,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext,
    unsigned __int64 GlobalPointer
    );

#elif   defined(_M_AMD64)

_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext
    );

#endif


/*
 * Keywords and intrinsics for SEH
 */

#ifdef  _MSC_VER

#define GetExceptionCode            _exception_code
#define exception_code              _exception_code
#define GetExceptionInformation     (struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info              (struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination         _abnormal_termination
#define abnormal_termination        _abnormal_termination

unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);

#endif


/*
 * Legal values for expression in except().
 */

#define EXCEPTION_EXECUTE_HANDLER       1
#define EXCEPTION_CONTINUE_SEARCH       0
#define EXCEPTION_CONTINUE_EXECUTION    -1



#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_EXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\fpieee.h ===
/***
*fpieee.h - Definitions for floating point IEEE exception handling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant and type definitions for handling
*       floating point exceptions [ANSI/IEEE std. 754]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FPIEEE
#define _INC_FPIEEE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)

/* Disable C4324: structure was padded due to __declspec(align()) */
#pragma warning(push)
#pragma warning(disable: 4324)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/*
 * Define floating point IEEE compare result values.
 */

typedef enum {
    _FpCompareEqual,
    _FpCompareGreater,
    _FpCompareLess,
    _FpCompareUnordered
} _FPIEEE_COMPARE_RESULT;

/*
 * Define floating point format and result precision values.
 */

typedef enum {
    _FpFormatFp32,
    _FpFormatFp64,
    _FpFormatFp80,
    _FpFormatFp128,
    _FpFormatI16,
    _FpFormatI32,
    _FpFormatI64,
    _FpFormatU16,
    _FpFormatU32,
    _FpFormatU64,
    _FpFormatBcd80,
    _FpFormatCompare,
    _FpFormatString,
#if defined(_M_IA64)
    _FpFormatFp82
#endif
} _FPIEEE_FORMAT;

/*
 * Define operation code values.
 */

typedef enum {
    _FpCodeUnspecified,
    _FpCodeAdd,
    _FpCodeSubtract,
    _FpCodeMultiply,
    _FpCodeDivide,
    _FpCodeSquareRoot,
    _FpCodeRemainder,
    _FpCodeCompare,
    _FpCodeConvert,
    _FpCodeRound,
    _FpCodeTruncate,
    _FpCodeFloor,
    _FpCodeCeil,
    _FpCodeAcos,
    _FpCodeAsin,
    _FpCodeAtan,
    _FpCodeAtan2,
    _FpCodeCabs,
    _FpCodeCos,
    _FpCodeCosh,
    _FpCodeExp,
    _FpCodeFabs,
    _FpCodeFmod,
    _FpCodeFrexp,
    _FpCodeHypot,
    _FpCodeLdexp,
    _FpCodeLog,
    _FpCodeLog10,
    _FpCodeModf,
    _FpCodePow,
    _FpCodeSin,
    _FpCodeSinh,
    _FpCodeTan,
    _FpCodeTanh,
    _FpCodeY0,
    _FpCodeY1,
    _FpCodeYn,
    _FpCodeLogb,
    _FpCodeNextafter,
    _FpCodeNegate, 
    _FpCodeFmin,         /* XMMI */
    _FpCodeFmax,         /* XMMI */
    _FpCodeConvertTrunc, /* XMMI */
    _XMMIAddps,          /* XMMI */
    _XMMIAddss,
    _XMMISubps,
    _XMMISubss,
    _XMMIMulps,
    _XMMIMulss,
    _XMMIDivps,
    _XMMIDivss,
    _XMMISqrtps,
    _XMMISqrtss,
    _XMMIMaxps,
    _XMMIMaxss,
    _XMMIMinps,
    _XMMIMinss,
    _XMMICmpps,
    _XMMICmpss,
    _XMMIComiss,
    _XMMIUComiss,
    _XMMICvtpi2ps,
    _XMMICvtsi2ss,
    _XMMICvtps2pi,
    _XMMICvtss2si,
    _XMMICvttps2pi,
    _XMMICvttss2si,
    _XMMI2Addpd,         /* XMMI2 */
    _XMMI2Addsd,
    _XMMI2Subpd,
    _XMMI2Subsd,
    _XMMI2Mulpd,
    _XMMI2Mulsd,
    _XMMI2Divpd,
    _XMMI2Divsd,
    _XMMI2Sqrtpd,
    _XMMI2Sqrtsd,
    _XMMI2Maxpd,
    _XMMI2Maxsd,
    _XMMI2Minpd,
    _XMMI2Minsd,
    _XMMI2Cmppd,
    _XMMI2Cmpsd,
    _XMMI2Comisd,
    _XMMI2UComisd,
    _XMMI2Cvtpd2pi,   /* 66 2D    */
    _XMMI2Cvtsd2si,   /* F2       */
    _XMMI2Cvttpd2pi,  /* 66 2C    */
    _XMMI2Cvttsd2si,  /* F2       */
    _XMMI2Cvtps2pd,   /* 0F 5A    */
    _XMMI2Cvtss2sd,   /* F3       */
    _XMMI2Cvtpd2ps,   /* 66       */
    _XMMI2Cvtsd2ss,   /* F2       */
    _XMMI2Cvtdq2ps,   /* 0F 5B    */
    _XMMI2Cvttps2dq,  /* F3       */
    _XMMI2Cvtps2dq,   /* 66       */
    _XMMI2Cvttpd2dq,  /* 66 0F E6 */
    _XMMI2Cvtpd2dq,   /* F2       */
#if defined(_M_IA64)
    _FpCodeFma,
    _FpCodeFmaSingle,
    _FpCodeFmaDouble,
    _FpCodeFms,
    _FpCodeFmsSingle,
    _FpCodeFmsDouble,
    _FpCodeFnma,
    _FpCodeFnmaSingle,
    _FpCodeFnmaDouble,
    _FpCodeFamin,
    _FpCodeFamax
#endif
} _FP_OPERATION_CODE;

#endif  /* #ifndef __assembler */

/*
 * Define rounding modes.
 */

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

typedef enum {
    _FpRoundNearest,
    _FpRoundMinusInfinity,
    _FpRoundPlusInfinity,
    _FpRoundChopped
} _FPIEEE_ROUNDING_MODE;

typedef enum {
    _FpPrecisionFull,
    _FpPrecision53,
    _FpPrecision24,
#if defined(_M_IA64)
    _FpPrecision64,
    _FpPrecision113
#endif
} _FPIEEE_PRECISION;


/*
 * Define floating point context record
 */

typedef float           _FP32;
typedef double          _FP64;
typedef short           _I16;
typedef int             _I32;
typedef unsigned short  _U16;
typedef unsigned int    _U32;
typedef __int64         _Q64;


typedef struct
#if defined(_M_IA64)
    __declspec(align(16))
#endif
{
    unsigned short W[5];
} _FP80;

typedef struct __declspec(align(16))
{
    unsigned long W[4];
} _FP128;

typedef struct __declspec(align(8))
{
    unsigned long W[2];
} _I64;

typedef struct __declspec(align(8))
{
    unsigned long W[2];
} _U64;

typedef struct
#if defined(_M_IA64)
    __declspec(align(16))
#endif
{
    unsigned short W[5];
} _BCD80;

typedef struct __declspec(align(16))
{
    _Q64 W[2];
} _FPQ64;

typedef struct {
    union {
        _FP32        Fp32Value;
        _FP64        Fp64Value;
        _FP80        Fp80Value;
        _FP128       Fp128Value;
        _I16         I16Value;
        _I32         I32Value;
        _I64         I64Value;
        _U16         U16Value;
        _U32         U32Value;
        _U64         U64Value;
        _BCD80       Bcd80Value;
        char         *StringValue;
        int          CompareValue;
        _Q64         Q64Value;
        _FPQ64       Fpq64Value;
    } Value;

    unsigned int OperandValid : 1;
    unsigned int Format : 4;

} _FPIEEE_VALUE;


typedef struct {
    unsigned int Inexact : 1;
    unsigned int Underflow : 1;
    unsigned int Overflow : 1;
    unsigned int ZeroDivide : 1;
    unsigned int InvalidOperation : 1;
} _FPIEEE_EXCEPTION_FLAGS;


typedef struct {
    unsigned int RoundingMode : 2;
    unsigned int Precision : 3;
    unsigned int Operation :12;
    _FPIEEE_EXCEPTION_FLAGS Cause;
    _FPIEEE_EXCEPTION_FLAGS Enable;
    _FPIEEE_EXCEPTION_FLAGS Status;
    _FPIEEE_VALUE Operand1;
    _FPIEEE_VALUE Operand2;
    _FPIEEE_VALUE Result;
#if defined(_M_IA64)
    _FPIEEE_VALUE Operand3;
#endif
} _FPIEEE_RECORD, *_PFPIEEE_RECORD;


struct _EXCEPTION_POINTERS;

/*
 * Floating point IEEE exception filter routine
 */

_CRTIMP int __cdecl _fpieee_flt(
        unsigned long,
        struct _EXCEPTION_POINTERS *,
        int (__cdecl *)(_FPIEEE_RECORD *)
        );

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma warning(pop)
#pragma pack(pop)
#endif  /* _MSC_VER */
#endif  /* #ifndef __assembler */

#endif  /* _INC_FPIEEE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the low-level
*       file handling and I/O functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_IO
#define _INC_IO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifndef _POSIX_

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _FINDDATA_T_DEFINED

struct _finddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        char        name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _finddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        char        name[260];
};

struct __finddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        char        name[260];
};

#endif

#define _FINDDATA_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _wfinddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        wchar_t     name[260];
};

struct __wfinddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* File attribute constants for _findfirst() */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* function prototypes */

_CRTIMP int __cdecl _access(const char *, int);
_CRTIMP int __cdecl _chmod(const char *, int);
_CRTIMP int __cdecl _chsize(int, long);
_CRTIMP int __cdecl _close(int);
_CRTIMP int __cdecl _commit(int);
_CRTIMP int __cdecl _creat(const char *, int);
_CRTIMP int __cdecl _dup(int);
_CRTIMP int __cdecl _dup2(int, int);
_CRTIMP int __cdecl _eof(int);
_CRTIMP long __cdecl _filelength(int);
_CRTIMP intptr_t __cdecl _findfirst(const char *, struct _finddata_t *);
_CRTIMP int __cdecl _findnext(intptr_t, struct _finddata_t *);
_CRTIMP int __cdecl _findclose(intptr_t);
_CRTIMP int __cdecl _isatty(int);
_CRTIMP int __cdecl _locking(int, int, long);
_CRTIMP long __cdecl _lseek(int, long, int);
_CRTIMP char * __cdecl _mktemp(char *);
_CRTIMP int __cdecl _open(const char *, int, ...);
_CRTIMP int __cdecl _pipe(int *, unsigned int, int);
_CRTIMP int __cdecl _read(int, void *, unsigned int);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP int __cdecl _setmode(int, int);
_CRTIMP int __cdecl _sopen(const char *, int, int, ...);
_CRTIMP long __cdecl _tell(int);
_CRTIMP int __cdecl _umask(int);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl _write(int, const void *, unsigned int);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP __int64 __cdecl _filelengthi64(int);
_CRTIMP intptr_t __cdecl _findfirsti64(const char *, struct _finddatai64_t *);
_CRTIMP intptr_t __cdecl _findfirst64(const char *, struct __finddata64_t *);
_CRTIMP int __cdecl _findnexti64(intptr_t, struct _finddatai64_t *);
_CRTIMP int __cdecl _findnext64(intptr_t, struct __finddata64_t *);
_CRTIMP __int64 __cdecl _lseeki64(int, __int64, int);
_CRTIMP __int64 __cdecl _telli64(int);
#endif

#ifndef _WIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(const wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP intptr_t __cdecl _wfindfirsti64(const wchar_t *, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(const wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif


_CRTIMP intptr_t __cdecl _get_osfhandle(int);
_CRTIMP int __cdecl _open_osfhandle(intptr_t, int);

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl access(const char *, int);
_CRTIMP int __cdecl chmod(const char *, int);
_CRTIMP int __cdecl chsize(int, long);
_CRTIMP int __cdecl close(int);
_CRTIMP int __cdecl creat(const char *, int);
_CRTIMP int __cdecl dup(int);
_CRTIMP int __cdecl dup2(int, int);
_CRTIMP int __cdecl eof(int);
_CRTIMP long __cdecl filelength(int);
_CRTIMP int __cdecl isatty(int);
_CRTIMP int __cdecl locking(int, int, long);
_CRTIMP long __cdecl lseek(int, long, int);
_CRTIMP char * __cdecl mktemp(char *);
_CRTIMP int __cdecl open(const char *, int, ...);
_CRTIMP int __cdecl read(int, void *, unsigned int);
_CRTIMP int __cdecl setmode(int, int);
_CRTIMP int __cdecl sopen(const char *, int, int, ...);
_CRTIMP long __cdecl tell(int);
_CRTIMP int __cdecl umask(int);
_CRTIMP int __cdecl unlink(const char *);
_CRTIMP int __cdecl write(int, const void *, unsigned int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_IO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\ios.h ===
/***
*ios.h - definitions/declarations for the ios class.
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the ios class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOS
#define _INC_IOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#ifdef  _MT

typedef struct __CRT_LIST_ENTRY {
   struct __CRT_LIST_ENTRY *Flink;
   struct __CRT_LIST_ENTRY *Blink;
} _CRT_LIST_ENTRY;

typedef struct _CRT_CRITICAL_SECTION_DEBUG {
    unsigned short Type;
    unsigned short CreatorBackTraceIndex;
    struct _CRT_CRITICAL_SECTION *CriticalSection;
    _CRT_LIST_ENTRY ProcessLocksList;
    unsigned long EntryCount;
    unsigned long ContentionCount;
    unsigned long Depth;
    void * OwnerBackTrace[ 5 ];
} _CRT_CRITICAL_SECTION_DEBUG, *_PCRT_CRITICAL_SECTION_DEBUG;

typedef struct _CRT_CRITICAL_SECTION {
    _PCRT_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    long LockCount;
    long RecursionCount;
    void * OwningThread;        // from the thread's ClientId->UniqueThread
    void * LockSemaphore;
    unsigned long Reserved;
} _CRT_CRITICAL_SECTION, *_PCRT_CRITICAL_SECTION;

extern "C" {
_CRTIMP void __cdecl _mtlock(_PCRT_CRITICAL_SECTION);
_CRTIMP void __cdecl _mtunlock(_PCRT_CRITICAL_SECTION);
}

#endif  /* _MT */

#ifndef NULL
#define NULL    0
#endif

#ifndef EOF
#define EOF     (-1)
#endif

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP streambuf;
class _CRTIMP ostream;

class _CRTIMP ios {

public:
    enum io_state {  goodbit = 0x00,
                     eofbit  = 0x01,
                     failbit = 0x02,
                     badbit  = 0x04 };

    enum open_mode { in        = 0x01,
                     out       = 0x02,
                     ate       = 0x04,
                     app       = 0x08,
                     trunc     = 0x10,
                     nocreate  = 0x20,
                     noreplace = 0x40,
                     binary    = 0x80 };

    enum seek_dir { beg=0, cur=1, end=2 };

    enum {  skipws     = 0x0001,
            left       = 0x0002,
            right      = 0x0004,
            internal   = 0x0008,
            dec        = 0x0010,
            oct        = 0x0020,
            hex        = 0x0040,
            showbase   = 0x0080,
            showpoint  = 0x0100,
            uppercase  = 0x0200,
            showpos    = 0x0400,
            scientific = 0x0800,
            fixed      = 0x1000,
            unitbuf    = 0x2000,
            stdio      = 0x4000
                                 };

    static const long basefield;        // dec | oct | hex
    static const long adjustfield;      // left | right | internal
    static const long floatfield;       // scientific | fixed

    ios(streambuf*);                    // differs from ANSI
    virtual ~ios();

    inline long flags() const;
    inline long flags(long _l);

    inline long setf(long _f,long _m);
    inline long setf(long _l);
    inline long unsetf(long _l);

    inline int width() const;
    inline int width(int _i);

    inline ostream* tie(ostream* _os);
    inline ostream* tie() const;

    inline char fill() const;
    inline char fill(char _c);

    inline int precision(int _i);
    inline int precision() const;

    inline int rdstate() const;
    inline void clear(int _i = 0);

//  inline operator void*() const;
    operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
    inline int operator!() const;

    inline int  good() const;
    inline int  eof() const;
    inline int  fail() const;
    inline int  bad() const;

    inline streambuf* rdbuf() const;

    inline long & iword(int) const;
    inline void * & pword(int) const;

    static long bitalloc();
    static int xalloc();
    static void sync_with_stdio();

#ifdef  _MT
    inline void __cdecl setlock();
    inline void __cdecl clrlock();
    void __cdecl lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void __cdecl unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
    inline void __cdecl lockbuf();
    inline void __cdecl unlockbuf();
#else
    void __cdecl lock() { }
    void __cdecl unlock() { }
    void __cdecl lockbuf() { }
    void __cdecl unlockbuf() { }
#endif

protected:
    ios();
    ios(const ios&);                    // treat as private
    ios& operator=(const ios&);
    void init(streambuf*);

    enum { skipping, tied };
    streambuf*  bp;

    int     state;
    int     ispecial;                   // not used
    int     ospecial;                   // not used
    int     isfx_special;               // not used
    int     osfx_special;               // not used
    int     x_delbuf;                   // if set, rdbuf() deleted by ~ios

    ostream* x_tie;
    long    x_flags;
    int     x_precision;
    char    x_fill;
    int     x_width;

    static void (*stdioflush)();        // not used

#ifdef  _MT
    static void lockc() { _mtlock(& x_lockc); }
    static void unlockc() { _mtunlock( & x_lockc); }
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#else
    static void lockc() { }
    static void unlockc() { }
#endif

public:
    int delbuf() const { return x_delbuf; }
    void    delbuf(int _i) { x_delbuf = _i; }

private:
    static long x_maxbit;
    static int x_curindex;
    static int sunk_with_stdio;         // make sure sync_with done only once
#ifdef  _MT
#define MAXINDEX 7
    static long x_statebuf[MAXINDEX+1];  // used by xalloc()
    static int fLockcInit;              // used to see if x_lockc initialized
    static _CRT_CRITICAL_SECTION x_lockc; // used to lock static (class) data members
    int LockFlg;                        // enable locking flag
    _CRT_CRITICAL_SECTION x_lock;       // used for multi-thread lock on object
#else
    static long * x_statebuf;  // used by xalloc()
#endif
};

#include <streamb.h>

inline _CRTIMP ios& __cdecl dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }

inline long ios::flags() const { return x_flags; }
inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }

inline long ios::setf(long _l,long _m){ long _lO; lock(); _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); unlock(); return _lO; }
inline long ios::setf(long _l){ long _lO; lock(); _lO = x_flags; x_flags |= _l; unlock(); return _lO; }
inline long ios::unsetf(long _l){ long _lO; lock(); _lO = x_flags; x_flags &= (~_l); unlock(); return _lO; }

inline int ios::width() const { return x_width; }
inline int ios::width(int _i){ int _iO; _iO = (int)x_width; x_width = _i; return _iO; }

inline ostream* ios::tie(ostream* _os){ ostream* _osO; _osO = x_tie; x_tie = _os; return _osO; }
inline ostream* ios::tie() const { return x_tie; }
inline char ios::fill() const { return x_fill; }
inline char ios::fill(char _c){ char _cO; _cO = x_fill; x_fill = _c; return _cO; }
inline int ios::precision(int _i){ int _iO; _iO = (int)x_precision; x_precision = _i; return _iO; }
inline int ios::precision() const { return x_precision; }

inline int ios::rdstate() const { return state; }

// inline ios::operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
inline int ios::operator!() const { return state&(badbit|failbit); }

inline int  ios::bad() const { return state & badbit; }
inline void ios::clear(int _i){ lock(); state = _i; unlock(); }
inline int  ios::eof() const { return state & eofbit; }
inline int  ios::fail() const { return state & (badbit | failbit); }
inline int  ios::good() const { return state == 0; }

inline streambuf* ios::rdbuf() const { return bp; }

inline long & ios::iword(int _i) const { return x_statebuf[_i] ; }
inline void * & ios::pword(int _i) const { return (void * &)x_statebuf[_i]; }

#ifdef  _MT
    inline void ios::setlock() { LockFlg--; if (bp) bp->setlock(); }
    inline void ios::clrlock() { if (LockFlg <= 0) LockFlg++; if (bp) bp->clrlock(); }
    inline void ios::lockbuf() { bp->lock(); }
    inline void ios::unlockbuf() { bp->unlock(); }
#endif

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOS

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\iomanip.h ===
/***
*iomanip.h - definitions/declarations for iostream's parameterized manipulators
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes' paramterized manipulators.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOMANIP
#define _INC_IOMANIP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

#include <iostream.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

// #define __MKMANIP(X) \#define X##(T) __##X##_ \#\# T
// __MKMANIP(SMANIP);
// __MKMANIP(SAPP);
// __MKMANIP(IMANIP);
// __MKMANIP(IAPP);
// __MKMANIP(OMANIP);
// __MKMANIP(OAPP);
// __MKMANIP(IOMANIP);
// __MKMANIP(IOAPP);

#define SMANIP(T) __SMANIP_##T
#define SAPP(T) __SAPP_##T
#define IMANIP(T) __IMANIP_##T
#define IAPP(T) __IAPP_##T
#define OMANIP(T) __OMANIP_##T
#define OAPP(T) __OAPP_##T
#define IOMANIP(T) __IOMANIP_##T
#define IOAPP(T) __IOAPP_##T

#define IOMANIPdeclare(T)  \
class SMANIP(T) { \
public: \
        SMANIP(T)(ios& (*f)(ios&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
        friend ostream& operator<<(ostream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
private:        \
        ios& (* _fp)(ios&,T); \
        T _tp; \
};      \
class SAPP(T) { \
public: \
        SAPP(T)( ios& (*f)(ios&,T)) : _fp(f) {} \
        SMANIP(T) operator()(T t) { return SMANIP(T)(_fp,t); }  \
private:        \
        ios& (* _fp)(ios&,T); \
};      \
class IMANIP(T) { \
public: \
        IMANIP(T)(istream& (*f)(istream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, IMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        istream& (* _fp)(istream&,T); \
        T _tp;  \
};      \
class IAPP(T) { \
public: \
        IAPP(T)( istream& (*f)(istream&,T)) : _fp(f) {} \
        IMANIP(T) operator()(T t) { return IMANIP(T)(_fp,t); }  \
private:        \
        istream& (* _fp)(istream&,T); \
};      \
class OMANIP(T) { \
public: \
        OMANIP(T)(ostream& (*f)(ostream&,T), T t) : _fp(f), _tp(t) {} \
        friend ostream& operator<<(ostream& s, OMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        ostream& (* _fp)(ostream&,T); \
        T _tp; \
};      \
class OAPP(T) { \
public: \
        OAPP(T)(ostream& (*f)(ostream&,T)) : _fp(f) {}  \
        OMANIP(T) operator()(T t) { return OMANIP(T)(_fp,t); } \
private:        \
        ostream& (* _fp)(ostream&,T); \
};      \
\
class IOMANIP(T) { \
public: \
        IOMANIP(T)(iostream& (*f)(iostream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
        friend ostream& operator<<(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        iostream& (* _fp)(iostream&,T); \
        T _tp; \
};      \
class IOAPP(T) {        \
public: \
        IOAPP(T)( iostream& (*f)(iostream&,T)) : _fp(f) {}      \
        IOMANIP(T) operator()(T t) { return IOMANIP(T)(_fp,t); }        \
private:        \
        iostream& (* _fp)(iostream&,T); \
}; \

        
IOMANIPdeclare(int)

IOMANIPdeclare(long)

inline ios& __resetiosflags(ios& s, long _flg) { s.setf(0,_flg); return s; }
inline ios& __setfill(ios& s, int _fc) { s.fill((char)_fc); return s; }
inline ios& __setiosflags(ios& s, long _flg) { s.setf(_flg); return s; }
inline ios& __setprecision(ios& s, int _pre) { s.precision(_pre); return s; }
inline ios& __setw(ios& s, int _wid) { s.width(_wid); return s; }

inline SMANIP(long)     resetiosflags(long _l) { return SMANIP(long)(__resetiosflags, _l); }
inline SMANIP(int)      setfill(int _m) {return SMANIP(int)(__setfill, _m); }
inline SMANIP(long)     setiosflags(long _l) {return SMANIP(long)(__setiosflags, _l); }
inline SMANIP(int)      setprecision(int _p) {return SMANIP(int)(__setprecision, _p); }
inline SMANIP(int)      setw(int _w) { return SMANIP(int)(__setw, _w); }

// Restore previous packing
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOMANIP

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\fstream.h ===
/***
*fstream.h - definitions/declarations for filebuf and fstream classes
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the filebuf and fstream classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_FSTREAM
#define _INC_FSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <iostream.h>

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef int filedesc;

class _CRTIMP filebuf : public streambuf {
public:
static  const int       openprot;       // default share/prot mode for open

// optional share values for 3rd argument (prot) of open or constructor
static  const int       sh_none;        // exclusive mode no sharing
static  const int       sh_read;        // allow read sharing
static  const int       sh_write;       // allow write sharing
// use (sh_read | sh_write) to allow both read and write sharing

// options for setmode member function
static  const int       binary;
static  const int       text;

                        filebuf();
                        filebuf(filedesc);
                        filebuf(filedesc, char *, int);
                        ~filebuf();

        filebuf*        attach(filedesc);
        filedesc        fd() const { return (x_fd==-1) ? EOF : x_fd; }
        int             is_open() const { return (x_fd!=-1); }
        filebuf*        open(const char *, int, int = filebuf::openprot);
        filebuf*        close();
        int             setmode(int = filebuf::text);

virtual int             overflow(int=EOF);
virtual int             underflow();

virtual streambuf*      setbuf(char *, int);
virtual streampos       seekoff(streamoff, ios::seek_dir, int);
// virtual      streampos       seekpos(streampos, int);
virtual int             sync();

private:
        filedesc        x_fd;
        int             x_fOpened;
};

class _CRTIMP ifstream : public istream {
public:
        ifstream();
        ifstream(const char *, int =ios::in, int = filebuf::openprot);
        ifstream(filedesc);
        ifstream(filedesc, char *, int);
        ~ifstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::in, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class _CRTIMP ofstream : public ostream {
public:
        ofstream();
        ofstream(const char *, int =ios::out, int = filebuf::openprot);
        ofstream(filedesc);
        ofstream(filedesc, char *, int);
        ~ofstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::out, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
class _CRTIMP fstream : public iostream {
public:
        fstream();
        fstream(const char *, int, int = filebuf::openprot);
        fstream(filedesc);
        fstream(filedesc, char *, int);
        ~fstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ostream::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
// manipulators to dynamically change file access mode (filebufs only)
inline  ios& binary(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::binary); return _fstrm; }
inline  ios& text(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::text); return _fstrm; }

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_FSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\iostream.h ===
/***
*iostream.h - definitions/declarations for iostream classes
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


typedef long streamoff, streampos;

#include <ios.h>                // Define ios.

#include <streamb.h>            // Define streambuf.

#include <istream.h>            // Define istream.

#include <ostream.h>            // Define ostream.

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP iostream : public istream, public ostream {
public:
        iostream(streambuf*);
        virtual ~iostream();
protected:
        iostream();
        iostream(const iostream&);
inline iostream& operator=(streambuf*);
inline iostream& operator=(iostream&);
private:
        iostream(ios&);
        iostream(istream&);
        iostream(ostream&);
};

inline iostream& iostream::operator=(streambuf* _sb) { istream::operator=(_sb); ostream::operator=(_sb); return *this; }

inline iostream& iostream::operator=(iostream& _strm) { return operator=(_strm.rdbuf()); }

class _CRTIMP Iostream_init {
public:
        Iostream_init();
        Iostream_init(ios &, int =0);   // treat as private
        ~Iostream_init();
};

// used internally
// static Iostream_init __iostreaminit; // initializes cin/cout/cerr/clog

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\limits.h ===
/***
*limits.h - implementation dependent values
*
*       Copyright (c) 1985-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains defines for a number of implementation dependent values
*       which are commonly used in C programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LIMITS
#define _INC_LIMITS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define CHAR_BIT      8         /* number of bits in a char */
#define SCHAR_MIN   (-128)      /* minimum signed char value */
#define SCHAR_MAX     127       /* maximum signed char value */
#define UCHAR_MAX     0xff      /* maximum unsigned char value */

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN   /* mimimum char value */
#define CHAR_MAX    SCHAR_MAX   /* maximum char value */
#else
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#endif  /* _CHAR_UNSIGNED */

#define MB_LEN_MAX    5             /* max. # bytes in multibyte char */
#define SHRT_MIN    (-32768)        /* minimum (signed) short value */
#define SHRT_MAX      32767         /* maximum (signed) short value */
#define USHRT_MAX     0xffff        /* maximum unsigned short value */
#define INT_MIN     (-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX       2147483647    /* maximum (signed) int value */
#define UINT_MAX      0xffffffff    /* maximum unsigned int value */
#define LONG_MIN    (-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */

#if     _INTEGRAL_MAX_BITS >= 8
#define _I8_MIN     (-127i8 - 1)    /* minimum signed 8 bit value */
#define _I8_MAX       127i8         /* maximum signed 8 bit value */
#define _UI8_MAX      0xffui8       /* maximum unsigned 8 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 16
#define _I16_MIN    (-32767i16 - 1) /* minimum signed 16 bit value */
#define _I16_MAX      32767i16      /* maximum signed 16 bit value */
#define _UI16_MAX     0xffffui16    /* maximum unsigned 16 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 32
#define _I32_MIN    (-2147483647i32 - 1) /* minimum signed 32 bit value */
#define _I32_MAX      2147483647i32 /* maximum signed 32 bit value */
#define _UI32_MAX     0xffffffffui32 /* maximum unsigned 32 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 64
/* minimum signed 64 bit value */
#define _I64_MIN    (-9223372036854775807i64 - 1)
/* maximum signed 64 bit value */
#define _I64_MAX      9223372036854775807i64
/* maximum unsigned 64 bit value */
#define _UI64_MAX     0xffffffffffffffffui64
#endif

#if     _INTEGRAL_MAX_BITS >= 128
/* minimum signed 128 bit value */
#define _I128_MIN   (-170141183460469231731687303715884105727i128 - 1)
/* maximum signed 128 bit value */
#define _I128_MAX     170141183460469231731687303715884105727i128
/* maximum unsigned 128 bit value */
#define _UI128_MAX    0xffffffffffffffffffffffffffffffffui128
#endif

#ifdef  _POSIX_

#define _POSIX_ARG_MAX      4096
#define _POSIX_CHILD_MAX    6
#define _POSIX_LINK_MAX     8
#define _POSIX_MAX_CANON    255
#define _POSIX_MAX_INPUT    255
#define _POSIX_NAME_MAX     14
#define _POSIX_NGROUPS_MAX  0
#define _POSIX_OPEN_MAX     16
#define _POSIX_PATH_MAX     255
#define _POSIX_PIPE_BUF     512
#define _POSIX_SSIZE_MAX    32767
#define _POSIX_STREAM_MAX   8
#define _POSIX_TZNAME_MAX   3

#define ARG_MAX             14500       /* 16k heap, minus overhead */
#define LINK_MAX            1024
#define MAX_CANON           _POSIX_MAX_CANON
#define MAX_INPUT           _POSIX_MAX_INPUT
#define NAME_MAX            255
#define NGROUPS_MAX         16
#define OPEN_MAX            32
#define PATH_MAX            512
#define PIPE_BUF            _POSIX_PIPE_BUF
#define SSIZE_MAX           _POSIX_SSIZE_MAX
#define STREAM_MAX          20
#define TZNAME_MAX          10

#endif  /* POSIX */

#endif  /* _INC_LIMITS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the function declarations for memory allocation functions;
*       also defines manifest constants and types used by the heap routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MALLOC
#define _INC_MALLOC

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTNOALIAS, _CRTRESTRICT */

#if     _MSC_FULL_VER >= 14002050

#ifndef _CRTNOALIAS
#define _CRTNOALIAS __declspec(noalias)
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT __declspec(restrict)
#endif  /* _CRTRESTRICT */

#else

#ifndef _CRTNOALIAS
#define _CRTNOALIAS
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT
#endif  /* _CRTRESTRICT */

#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif


/* Maximum heap request the heap manager will attempt */

#ifdef  _WIN64
#define _HEAP_MAXREQ    0xFFFFFFFFFFFFFFE0
#else
#define _HEAP_MAXREQ    0xFFFFFFE0
#endif

/* Constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY      (-1)
#define _HEAPOK         (-2)
#define _HEAPBADBEGIN   (-3)
#define _HEAPBADNODE    (-4)
#define _HEAPEND        (-5)
#define _HEAPBADPTR     (-6)
#define _FREEENTRY      0
#define _USEDENTRY      1

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
        int * _pentry;
        size_t _size;
        int _useflag;
        } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif

/* External variable declarations */

extern unsigned int _amblksiz;

#define _mm_free(a)      _aligned_free(a)
#define _mm_malloc(a, b)    _aligned_malloc(a, b)

/* Function prototypes */

_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl calloc(size_t, size_t);
_CRTIMP _CRTNOALIAS              void    __cdecl free(void *);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl malloc(size_t);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl realloc(void *, size_t);
_CRTIMP _CRTNOALIAS              void    __cdecl _aligned_free(void *);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl _aligned_malloc(size_t, size_t);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl _aligned_offset_malloc(size_t, size_t, size_t);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl _aligned_realloc(void *, size_t, size_t);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl _aligned_offset_realloc(void *, size_t, size_t, size_t);

#ifndef _POSIX_

void *          __cdecl _alloca(size_t);
_CRTIMP void *  __cdecl _expand(void *, size_t);
_CRTIMP size_t  __cdecl _get_sbh_threshold(void);
_CRTIMP int     __cdecl _set_sbh_threshold(size_t);
_CRTIMP int     __cdecl _heapadd(void *, size_t);
_CRTIMP int     __cdecl _heapchk(void);
_CRTIMP int     __cdecl _heapmin(void);
_CRTIMP int     __cdecl _heapset(unsigned int);
_CRTIMP int     __cdecl _heapwalk(_HEAPINFO *);
_CRTIMP size_t  __cdecl _heapused(size_t *, size_t *);
_CRTIMP size_t  __cdecl _msize(void *);
_CRTIMP int     __cdecl _resetstkoflw (void);
int __cdecl _resetstkoflw_downlevel(void);

_CRTIMP intptr_t __cdecl _get_heap_handle(void);

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define alloca  _alloca
#endif  /* __STDC__*/

#endif  /* _POSIX_ */

#ifdef  HEAPHOOK
#ifndef _HEAPHOOK_DEFINED
/* hook function type */
typedef int (__cdecl * _HEAPHOOK)(int, size_t, void *, void **);
#define _HEAPHOOK_DEFINED
#endif  /* _HEAPHOOK_DEFINED */

/* set hook function */
_CRTIMP _HEAPHOOK __cdecl _setheaphook(_HEAPHOOK);

/* hook function must handle these types */
#define _HEAP_MALLOC    1
#define _HEAP_CALLOC    2
#define _HEAP_FREE      3
#define _HEAP_REALLOC   4
#define _HEAP_MSIZE     5
#define _HEAP_EXPAND    6
#endif  /* HEAPHOOK */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\math.h ===
/***
*math.h - definitions and declarations for math library
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant definitions and external subroutine
*       declarations for the math subroutine library.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MATH
#define _INC_MATH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __assembler /* Protect from assembler */

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Definition of _exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
struct _exception {
        int type;       /* exception type - see below */
        char *name;     /* name of function where error occured */
        double arg1;    /* first argument to function */
        double arg2;    /* second argument (if any) to function */
        double retval;  /* value to be returned by function */
        } ;

#define _EXCEPTION_DEFINED
#endif


/* Definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED
struct _complex {
        double x,y; /* real and imaginary parts */
        } ;

#if     !__STDC__ && !defined (__cplusplus)
/* Non-ANSI name for compatibility */
#define complex _complex
#endif

#define _COMPLEX_DEFINED
#endif
#endif  /* __assembler */


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN     1   /* argument domain error */
#define _SING       2   /* argument singularity */
#define _OVERFLOW   3   /* overflow range error */
#define _UNDERFLOW  4   /* underflow range error */
#define _TLOSS      5   /* total loss of precision */
#define _PLOSS      6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
 * for a value returned in case of error by a number of the floating point
 * math routines
 */
#ifndef __assembler /* Protect from assembler */
_CRTIMP extern double _HUGE;
#endif  /* __assembler */

#define HUGE_VAL _HUGE

#ifdef  _USE_MATH_DEFINES

/* Define _USE_MATH_DEFINES before including math.h to expose these macro
 * definitions for common math constants.  These are placed under an #ifdef
 * since these commonly-defined names are not part of the C/C++ standards.
 */

/* Definitions of useful mathematical constants
 * M_E        - e
 * M_LOG2E    - log2(e)
 * M_LOG10E   - log10(e)
 * M_LN2      - ln(2)
 * M_LN10     - ln(10)
 * M_PI       - pi
 * M_PI_2     - pi/2
 * M_PI_4     - pi/4
 * M_1_PI     - 1/pi
 * M_2_PI     - 2/pi
 * M_2_SQRTPI - 2/sqrt(pi)
 * M_SQRT2    - sqrt(2)
 * M_SQRT1_2  - 1/sqrt(2)
 */

#define M_E        2.71828182845904523536
#define M_LOG2E    1.44269504088896340736
#define M_LOG10E   0.434294481903251827651
#define M_LN2      0.693147180559945309417
#define M_LN10     2.30258509299404568402
#define M_PI       3.14159265358979323846
#define M_PI_2     1.57079632679489661923
#define M_PI_4     0.785398163397448309616
#define M_1_PI     0.318309886183790671538
#define M_2_PI     0.636619772367581343076
#define M_2_SQRTPI 1.12837916709551257390
#define M_SQRT2    1.41421356237309504880
#define M_SQRT1_2  0.707106781186547524401

#endif  /* _USE_MATH_DEFINES */

/* Function prototypes */

#if     !defined(__assembler)   /* Protect from assembler */
        int     __cdecl abs(int);
        double  __cdecl acos(double);
        double  __cdecl asin(double);
        double  __cdecl atan(double);
        double  __cdecl atan2(double, double);
        double  __cdecl cos(double);
        double  __cdecl cosh(double);
        double  __cdecl exp(double);
        double  __cdecl fabs(double);
        double  __cdecl fmod(double, double);
        long    __cdecl labs(long);
        double  __cdecl log(double);
        double  __cdecl log10(double);
        double  __cdecl pow(double, double);
        double  __cdecl sin(double);
        double  __cdecl sinh(double);
        double  __cdecl tan(double);
        double  __cdecl tanh(double);
        double  __cdecl sqrt(double);
_CRTIMP double  __cdecl atof(const char *);
_CRTIMP double  __cdecl _cabs(struct _complex);
_CRTIMP double  __cdecl ceil(double);
_CRTIMP double  __cdecl floor(double);
_CRTIMP double  __cdecl frexp(double, int *);
_CRTIMP double  __cdecl _hypot(double, double);
_CRTIMP double  __cdecl _j0(double);
_CRTIMP double  __cdecl _j1(double);
_CRTIMP double  __cdecl _jn(int, double);
_CRTIMP double  __cdecl ldexp(double, int);
        int     __cdecl _matherr(struct _exception *);
_CRTIMP double  __cdecl modf(double, double *);

_CRTIMP double  __cdecl _y0(double);
_CRTIMP double  __cdecl _y1(double);
_CRTIMP double  __cdecl _yn(int, double);


#if     defined(_M_IX86)

_CRTIMP int     __cdecl _set_SSE2_enable(int);

#endif

#if defined(_M_IA64)

/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

        float  __cdecl acosf( float );
        float  __cdecl asinf( float );
        float  __cdecl atanf( float );
        float  __cdecl atan2f( float , float );
        float  __cdecl cosf( float );
        float  __cdecl sinf( float );
        float  __cdecl tanf( float );

/* 4.5.3 Hyperbolic functions */
        float  __cdecl coshf( float );
        float  __cdecl sinhf( float );
        float  __cdecl tanhf( float );

/* 4.5.4 Exponential and logarithmic functions */
        float  __cdecl expf( float );
        float  __cdecl logf( float );
        float  __cdecl log10f( float );
        float  __cdecl modff( float , float* );

/* 4.5.5 Power functions */
        float  __cdecl powf( float , float );
        float  __cdecl sqrtf( float );

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
        float  __cdecl ceilf( float );
        float  __cdecl fabsf( float );
        float  __cdecl floorf( float );
        float  __cdecl fmodf( float , float );

        float  __cdecl hypotf(float, float);

#endif /* _M_IA64 */

/* Macros defining long double functions to be their double counterparts
 * (long double is synonymous with double in this implementation).
 */

#ifndef __cplusplus
#define acosl(x)    ((long double)acos((double)(x)))
#define asinl(x)    ((long double)asin((double)(x)))
#define atanl(x)    ((long double)atan((double)(x)))
#define atan2l(x,y) ((long double)atan2((double)(x), (double)(y)))
#define _cabsl      _cabs
#define ceill(x)    ((long double)ceil((double)(x)))
#define cosl(x)     ((long double)cos((double)(x)))
#define coshl(x)    ((long double)cosh((double)(x)))
#define expl(x)     ((long double)exp((double)(x)))
#define fabsl(x)    ((long double)fabs((double)(x)))
#define floorl(x)   ((long double)floor((double)(x)))
#define fmodl(x,y)  ((long double)fmod((double)(x), (double)(y)))
#define frexpl(x,y) ((long double)frexp((double)(x), (y)))
#define _hypotl(x,y)    ((long double)_hypot((double)(x), (double)(y)))
#define ldexpl(x,y) ((long double)ldexp((double)(x), (y)))
#define logl(x)     ((long double)log((double)(x)))
#define log10l(x)   ((long double)log10((double)(x)))
#define _matherrl   _matherr
#define modfl(x,y)  ((long double)modf((double)(x), (double *)(y)))
#define powl(x,y)   ((long double)pow((double)(x), (double)(y)))
#define sinl(x)     ((long double)sin((double)(x)))
#define sinhl(x)    ((long double)sinh((double)(x)))
#define sqrtl(x)    ((long double)sqrt((double)(x)))
#define tanl(x)     ((long double)tan((double)(x)))
#define tanhl(x)    ((long double)tanh((double)(x)))
#else   /* __cplusplus */
inline long double acosl(long double _X)
        {return (acos((double)_X)); }
inline long double asinl(long double _X)
        {return (asin((double)_X)); }
inline long double atanl(long double _X)
        {return (atan((double)_X)); }
inline long double atan2l(long double _X, long double _Y)
        {return (atan2((double)_X, (double)_Y)); }
inline long double ceill(long double _X)
        {return (ceil((double)_X)); }
inline long double cosl(long double _X)
        {return (cos((double)_X)); }
inline long double coshl(long double _X)
        {return (cosh((double)_X)); }
inline long double expl(long double _X)
        {return (exp((double)_X)); }
inline long double fabsl(long double _X)
        {return (fabs((double)_X)); }
inline long double floorl(long double _X)
        {return (floor((double)_X)); }
inline long double fmodl(long double _X, long double _Y)
        {return (fmod((double)_X, (double)_Y)); }
inline long double frexpl(long double _X, int *_Y)
        {return (frexp((double)_X, _Y)); }
inline long double ldexpl(long double _X, int _Y)
        {return (ldexp((double)_X, _Y)); }
inline long double logl(long double _X)
        {return (log((double)_X)); }
inline long double log10l(long double _X)
        {return (log10((double)_X)); }
inline long double modfl(long double _X, long double *_Y)
        {double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (long double)_Di;
        return (_Df); }
inline long double powl(long double _X, long double _Y)
        {return (pow((double)_X, (double)_Y)); }
inline long double sinl(long double _X)
        {return (sin((double)_X)); }
inline long double sinhl(long double _X)
        {return (sinh((double)_X)); }
inline long double sqrtl(long double _X)
        {return (sqrt((double)_X)); }
inline long double tanl(long double _X)
        {return (tan((double)_X)); }
inline long double tanhl(long double _X)
        {return (tanh((double)_X)); }

inline float frexpf(float _X, int *_Y)
        {return ((float)frexp((double)_X, _Y)); }
inline float ldexpf(float _X, int _Y)
        {return ((float)ldexp((double)_X, _Y)); }
#if     !defined(_M_IA64)
inline float acosf(float _X)
        {return ((float)acos((double)_X)); }
inline float asinf(float _X)
        {return ((float)asin((double)_X)); }
inline float atanf(float _X)
        {return ((float)atan((double)_X)); }
inline float atan2f(float _X, float _Y)
        {return ((float)atan2((double)_X, (double)_Y)); }
inline float ceilf(float _X)
        {return ((float)ceil((double)_X)); }
inline float cosf(float _X)
        {return ((float)cos((double)_X)); }
inline float coshf(float _X)
        {return ((float)cosh((double)_X)); }
inline float expf(float _X)
        {return ((float)exp((double)_X)); }
inline float fabsf(float _X)
        {return ((float)fabs((double)_X)); }
inline float floorf(float _X)
        {return ((float)floor((double)_X)); }
inline float fmodf(float _X, float _Y)
        {return ((float)fmod((double)_X, (double)_Y)); }
inline float logf(float _X)
        {return ((float)log((double)_X)); }
inline float log10f(float _X)
        {return ((float)log10((double)_X)); }
inline float modff(float _X, float *_Y)
        { double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (float)_Di;
        return ((float)_Df); }
inline float powf(float _X, float _Y)
        {return ((float)pow((double)_X, (double)_Y)); }
inline float sinf(float _X)
        {return ((float)sin((double)_X)); }
inline float sinhf(float _X)
        {return ((float)sinh((double)_X)); }
inline float sqrtf(float _X)
        {return ((float)sqrt((double)_X)); }
inline float tanf(float _X)
        {return ((float)tan((double)_X)); }
inline float tanhf(float _X)
        {return ((float)tanh((double)_X)); }
#endif  /* !defined(_M_IA64) */
#endif  /* __cplusplus */
#endif  /* __assembler */

#if     !__STDC__

/* Non-ANSI names for compatibility */

#define DOMAIN      _DOMAIN
#define SING        _SING
#define OVERFLOW    _OVERFLOW
#define UNDERFLOW   _UNDERFLOW
#define TLOSS       _TLOSS
#define PLOSS       _PLOSS

#define matherr     _matherr

#ifndef __assembler /* Protect from assembler */

_CRTIMP extern double HUGE;

_CRTIMP double  __cdecl cabs(struct _complex);
_CRTIMP double  __cdecl hypot(double, double);
_CRTIMP double  __cdecl j0(double);
_CRTIMP double  __cdecl j1(double);
_CRTIMP double  __cdecl jn(int, double);
        int     __cdecl matherr(struct _exception *);
_CRTIMP double  __cdecl y0(double);
_CRTIMP double  __cdecl y1(double);
_CRTIMP double  __cdecl yn(int, double);

#endif  /* __assembler */

#endif  /* __STDC__ */

#ifdef  __cplusplus
}

extern "C++" {

template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y)
        {unsigned int _N;
        if (_Y >= 0)
                _N = _Y;
        else
                _N = -_Y;
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

#ifndef _MSC_EXTENSIONS

inline long __cdecl abs(long _X)
        {return (labs(_X)); }
inline double __cdecl abs(double _X)
        {return (fabs(_X)); }
inline double __cdecl pow(double _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline double __cdecl pow(int _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl abs(float _X)
        {return (fabsf(_X)); }
inline float __cdecl acos(float _X)
        {return (acosf(_X)); }
inline float __cdecl asin(float _X)
        {return (asinf(_X)); }
inline float __cdecl atan(float _X)
        {return (atanf(_X)); }
inline float __cdecl atan2(float _Y, float _X)
        {return (atan2f(_Y, _X)); }
inline float __cdecl ceil(float _X)
        {return (ceilf(_X)); }
inline float __cdecl cos(float _X)
        {return (cosf(_X)); }
inline float __cdecl cosh(float _X)
        {return (coshf(_X)); }
inline float __cdecl exp(float _X)
        {return (expf(_X)); }
inline float __cdecl fabs(float _X)
        {return (fabsf(_X)); }
inline float __cdecl floor(float _X)
        {return (floorf(_X)); }
inline float __cdecl fmod(float _X, float _Y)
        {return (fmodf(_X, _Y)); }
inline float __cdecl frexp(float _X, int * _Y)
        {return (frexpf(_X, _Y)); }
inline float __cdecl ldexp(float _X, int _Y)
        {return (ldexpf(_X, _Y)); }
inline float __cdecl log(float _X)
        {return (logf(_X)); }
inline float __cdecl log10(float _X)
        {return (log10f(_X)); }
inline float __cdecl modf(float _X, float * _Y)
        {return (modff(_X, _Y)); }
inline float __cdecl pow(float _X, float _Y)
        {return (powf(_X, _Y)); }
inline float __cdecl pow(float _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl sin(float _X)
        {return (sinf(_X)); }
inline float __cdecl sinh(float _X)
        {return (sinhf(_X)); }
inline float __cdecl sqrt(float _X)
        {return (sqrtf(_X)); }
inline float __cdecl tan(float _X)
        {return (tanf(_X)); }
inline float __cdecl tanh(float _X)
        {return (tanhf(_X)); }
inline long double __cdecl abs(long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl acos(long double _X)
        {return (acosl(_X)); }
inline long double __cdecl asin(long double _X)
        {return (asinl(_X)); }
inline long double __cdecl atan(long double _X)
        {return (atanl(_X)); }
inline long double __cdecl atan2(long double _Y, long double _X)
        {return (atan2l(_Y, _X)); }
inline long double __cdecl ceil(long double _X)
        {return (ceill(_X)); }
inline long double __cdecl cos(long double _X)
        {return (cosl(_X)); }
inline long double __cdecl cosh(long double _X)
        {return (coshl(_X)); }
inline long double __cdecl exp(long double _X)
        {return (expl(_X)); }
inline long double __cdecl fabs(long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl floor(long double _X)
        {return (floorl(_X)); }
inline long double __cdecl fmod(long double _X, long double _Y)
        {return (fmodl(_X, _Y)); }
inline long double __cdecl frexp(long double _X, int * _Y)
        {return (frexpl(_X, _Y)); }
inline long double __cdecl ldexp(long double _X, int _Y)
        {return (ldexpl(_X, _Y)); }
inline long double __cdecl log(long double _X)
        {return (logl(_X)); }
inline long double __cdecl log10(long double _X)
        {return (log10l(_X)); }
inline long double __cdecl modf(long double _X, long double * _Y)
        {return (modfl(_X, _Y)); }
inline long double __cdecl pow(long double _X, long double _Y)
        {return (powl(_X, _Y)); }
inline long double __cdecl pow(long double _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline long double __cdecl sin(long double _X)
        {return (sinl(_X)); }
inline long double __cdecl sinh(long double _X)
        {return (sinhl(_X)); }
inline long double __cdecl sqrt(long double _X)
        {return (sqrtl(_X)); }
inline long double __cdecl tan(long double _X)
        {return (tanl(_X)); }
inline long double __cdecl tanh(long double _X)
        {return (tanhl(_X)); }

#endif  /* _MSC_EXTENSIONS */ 

}
#endif  /* __cplusplus */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MATH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\istream.h ===
/***
*istream.h - definitions/declarations for the istream class
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the istream class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_ISTREAM
#define _INC_ISTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>

#ifdef  _MSC_VER
// C4069: "long double != double"
#pragma warning(disable:4069)   // disable C4069 warning
// #pragma warning(default:4069)    // use this to reenable, if desired

// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)    // use this to reenable, if desired
#endif  // _MSC_VER


typedef long streamoff, streampos;

class _CRTIMP istream : virtual public ios {

public:
    istream(streambuf*);
    virtual ~istream();

    int  ipfx(int =0);
    void isfx() { unlockbuf(); unlock(); }

    inline istream& operator>>(istream& (__cdecl * _f)(istream&));
    inline istream& operator>>(ios& (__cdecl * _f)(ios&));
    istream& operator>>(char *);
    inline istream& operator>>(unsigned char *);
    inline istream& operator>>(signed char *);
    istream& operator>>(char &);
    inline istream& operator>>(unsigned char &);
    inline istream& operator>>(signed char &);
    istream& operator>>(short &);
    istream& operator>>(unsigned short &);
    istream& operator>>(int &);
    istream& operator>>(unsigned int &);
    istream& operator>>(long &);
    istream& operator>>(unsigned long &);
    istream& operator>>(float &);
    istream& operator>>(double &);
    istream& operator>>(long double &);
    istream& operator>>(streambuf*);

    int get();

    inline istream& get(         char *,int,char ='\n');
    inline istream& get(unsigned char *,int,char ='\n');
    inline istream& get(  signed char *,int,char ='\n');

    istream& get(char &);
    inline istream& get(unsigned char &);
    inline istream& get(  signed char &);

    istream& get(streambuf&,char ='\n');
    inline istream& getline(         char *,int,char ='\n');
    inline istream& getline(unsigned char *,int,char ='\n');
    inline istream& getline(  signed char *,int,char ='\n');

    inline istream& ignore(int =1,int =EOF);
    istream& read(char *,int);
    inline istream& read(unsigned char *,int);
    inline istream& read(signed char *,int);

    int gcount() const { return x_gcount; }
    int peek();
    istream& putback(char);
    int sync();

    istream& seekg(streampos);
    istream& seekg(streamoff,ios::seek_dir);
    streampos tellg();

    void eatwhite();

protected:
    istream();
    istream(const istream&);    // treat as private
    istream& operator=(streambuf* _isb); // treat as private
    istream& operator=(const istream& _is) { return operator=(_is.rdbuf()); }
    istream& get(char *, int, int);
     int do_ipfx(int);

private:
    istream(ios&);
    int getint(char *);
    int getdouble(char *, int);
    int _fGline;
    int x_gcount;
};

    inline istream& istream::operator>>(istream& (__cdecl * _f)(istream&)) { (*_f)(*this); return *this; }
    inline istream& istream::operator>>(ios& (__cdecl * _f)(ios&)) { (*_f)(*this); return *this; }

    inline istream& istream::operator>>(unsigned char * _s) { return operator>>((char *)_s); }
    inline istream& istream::operator>>(  signed char * _s) { return operator>>((char *)_s); }

    inline istream& istream::operator>>(unsigned char & _c) { return operator>>((char &) _c); }
    inline istream& istream::operator>>(  signed char & _c) { return operator>>((char &) _c); }

    inline istream& istream::get(         char * _b, int _lim, char _delim) { return get(        _b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(unsigned char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(signed   char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }

    inline istream& istream::get(unsigned char & _c) { return get((char &)_c); }
    inline istream& istream::get(  signed char & _c) { return get((char &)_c); }

    inline istream& istream::getline(         char * _b,int _lim,char _delim) { lock(); _fGline++; get(        _b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(unsigned char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(  signed char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }

    inline istream& istream::ignore(int _n,int _delim) { lock(); _fGline++; get((char *)0, _n+1, _delim); unlock(); return *this; }

    inline istream& istream::read(unsigned char * _ptr, int _n) { return read((char *) _ptr, _n); }
    inline istream& istream::read(  signed char * _ptr, int _n) { return read((char *) _ptr, _n); }

class _CRTIMP istream_withassign : public istream {
        public:
            istream_withassign();
            istream_withassign(streambuf*);
            ~istream_withassign();
    istream& operator=(const istream& _is) { return istream::operator=(_is); }
    istream& operator=(streambuf* _isb) { return istream::operator=(_isb); }
};

extern _CRTIMP istream_withassign cin;

inline _CRTIMP istream& __cdecl ws(istream& _ins) { _ins.eatwhite(); return _ins; }

_CRTIMP ios&        __cdecl dec(ios&);
_CRTIMP ios&        __cdecl hex(ios&);
_CRTIMP ios&        __cdecl oct(ios&);

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_ISTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\locale.h ===
/***
*locale.h - definitions/declarations for localization routines
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the localization routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCALE
#define _INC_LOCALE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

/* Locale categories */

#define LC_ALL          0
#define LC_COLLATE      1
#define LC_CTYPE        2
#define LC_MONETARY     3
#define LC_NUMERIC      4
#define LC_TIME         5

#define LC_MIN          LC_ALL
#define LC_MAX          LC_TIME

/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        };
#define _LCONV_DEFINED
#endif

/* ANSI: char lconv members default is CHAR_MAX which is compile time
   dependent. Defining and using _charmax here causes CRT startup code
   to initialize lconv members properly */

#ifdef  _CHAR_UNSIGNED
extern int _charmax;
extern __inline int __dummy() { return _charmax; }
#endif

/* function prototypes */

#ifndef _CONFIG_LOCALE_SWT
#define _ENABLE_PER_THREAD_LOCALE           0x1
#define _DISABLE_PER_THREAD_LOCALE          0x2
#define _ENABLE_PER_THREAD_LOCALE_GLOBAL    0x10
#define _DISABLE_PER_THREAD_LOCALE_GLOBAL   0x20
#define _ENABLE_PER_THREAD_LOCALE_NEW       0x100
#define _DISABLE_PER_THREAD_LOCALE_NEW      0x200
#define _CONFIG_LOCALE_SWT
#endif

_CRTIMP int __cdecl _configthreadlocale(int i);
_CRTIMP char * __cdecl setlocale(int, const char *);
_CRTIMP struct lconv * __cdecl localeconv(void);

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_LOCALE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\mbctype.h ===
/***
*mbctype.h - MBCS character conversion macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines macros for MBCS character classification/conversion.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MBCTYPE
#define _INC_MBCTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* include the standard ctype.h header file */

#include <ctype.h>

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     (!defined(_MSC_VER) && !defined(__cdecl))
#define __cdecl
#endif


/*
 * MBCS - Multi-Byte Character Set
 */

/*
 * This declaration allows the user access the _mbctype[] look-up array.
 */
_CRTIMP extern unsigned char _mbctype[];
_CRTIMP extern unsigned char _mbcasemap[];


/* bit masks for MBCS character types */

#define _MS     0x01    /* MBCS single-byte symbol */
#define _MP     0x02    /* MBCS punct */
#define _M1     0x04    /* MBCS 1st (lead) byte */
#define _M2     0x08    /* MBCS 2nd byte*/

#define _SBUP   0x10    /* SBCS upper char */
#define _SBLOW  0x20    /* SBCS lower char */

/* byte types  */

#define _MBC_SINGLE     0       /* valid single byte char */
#define _MBC_LEAD       1       /* lead byte */
#define _MBC_TRAIL      2       /* trailing byte */
#define _MBC_ILLEGAL    (-1)    /* illegal byte */

#define _KANJI_CP   932

/* _setmbcp parameter defines */
#define _MB_CP_SBCS     0
#define _MB_CP_OEM      -2
#define _MB_CP_ANSI     -3
#define _MB_CP_LOCALE   -4


#ifndef _MBCTYPE_DEFINED

/* MB control routines */

_CRTIMP int __cdecl _setmbcp(int);
_CRTIMP int __cdecl _getmbcp(void);


/* MBCS character classification function prototypes */


/* byte routines */
_CRTIMP int __cdecl _ismbbkalnum( unsigned int );
_CRTIMP int __cdecl _ismbbkana( unsigned int );
_CRTIMP int __cdecl _ismbbkpunct( unsigned int );
_CRTIMP int __cdecl _ismbbkprint( unsigned int );
_CRTIMP int __cdecl _ismbbalpha( unsigned int );
_CRTIMP int __cdecl _ismbbpunct( unsigned int );
_CRTIMP int __cdecl _ismbbalnum( unsigned int );
_CRTIMP int __cdecl _ismbbprint( unsigned int );
_CRTIMP int __cdecl _ismbbgraph( unsigned int );

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead( unsigned int );
_CRTIMP int __cdecl _ismbbtrail( unsigned int );
_CRTIMP int __cdecl _ismbslead( const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail( const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

#define _MBCTYPE_DEFINED
#endif

/*
 * char byte classification macros
 */

#define _ismbbkalnum(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MS)
#define _ismbbkprint(_c)    ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))
#define _ismbbkpunct(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MP)

#define _ismbbalnum(_c) (((_ctype+1)[(unsigned char)(_c)] & (_ALPHA|_DIGIT))||_ismbbkalnum(_c))
#define _ismbbalpha(_c) (((_ctype+1)[(unsigned char)(_c)] & (_ALPHA))||_ismbbkalnum(_c))
#define _ismbbgraph(_c) (((_ctype+1)[(unsigned char)(_c)] & (_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbprint(_c) (((_ctype+1)[(unsigned char)(_c)] & (_BLANK|_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbpunct(_c) (((_ctype+1)[(unsigned char)(_c)] & _PUNCT)||_ismbbkpunct(_c))

#define _ismbblead(_c)  ((_mbctype+1)[(unsigned char)(_c)] & _M1)
#define _ismbbtrail(_c) ((_mbctype+1)[(unsigned char)(_c)] & _M2)

#define _ismbbkana(_c)  ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MBCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\minmax.h ===
/***
*minmax.h - familiar min & max macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines min and max macros.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MINMAX
#define _INC_MINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the
*       buffer (memory) manipulation routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MEMORY
#define _INC_MEMORY

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Function prototypes */

_CRTIMP void *  __cdecl _memccpy(void *, const void *, int, size_t);
_CRTIMP void *  __cdecl memchr(const void *, int, size_t);
_CRTIMP int     __cdecl _memicmp(const void *, const void *, size_t);
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memcpy(void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP void * __cdecl memccpy(void *, const void *, int, size_t);
_CRTIMP int __cdecl memicmp(const void *, const void *, size_t);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MEMORY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\mbstring.h ===
/***
* mbstring.h - MBCS string manipulation macros and functions
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file contains macros and function declarations for the MBCS
*       string manipulation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MBSTRING
#define _INC_MBSTRING

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647      /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
typedef char *  va_list;
#define _VA_LIST_DEFINED
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/*
 * MBCS - Multi-Byte Character Set
 */

#ifndef _MBSTRING_DEFINED

/* function prototypes */

_CRTIMP unsigned int __cdecl _mbbtombc(unsigned int);
_CRTIMP int __cdecl _mbbtype(unsigned char, int);
_CRTIMP unsigned int __cdecl _mbctombb(unsigned int);
_CRTIMP int __cdecl _mbsbtype(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbscat(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbschr(const unsigned char *, unsigned int);
_CRTIMP int __cdecl _mbscmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbscoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbscpy(unsigned char *, const unsigned char *);
_CRTIMP size_t __cdecl _mbscspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdec(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdup(const unsigned char *);
_CRTIMP int __cdecl _mbsicmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbsicoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsinc(const unsigned char *);
_CRTIMP size_t __cdecl _mbslen(const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbslwr(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsnbcat(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnbcnt(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbcpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbsncat(unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnccnt(const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsncpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned int __cdecl _mbsnextc (const unsigned char *);
_CRTIMP int __cdecl _mbsnicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsninc(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbspbrk(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsrchr(const unsigned char *, unsigned int);
_CRTIMP unsigned char * __cdecl _mbsrev(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsset(unsigned char *, unsigned int);
_CRTIMP size_t __cdecl _mbsspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsspnp(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsstr(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbstok(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsupr(unsigned char *);

_CRTIMP size_t __cdecl _mbclen(const unsigned char *);
_CRTIMP void __cdecl _mbccpy(unsigned char *, const unsigned char *);
#define _mbccmp(_cpc1, _cpc2) _mbsncmp((_cpc1),(_cpc2),1)

/* character routines */

_CRTIMP int __cdecl _ismbcalnum(unsigned int);
_CRTIMP int __cdecl _ismbcalpha(unsigned int);
_CRTIMP int __cdecl _ismbcdigit(unsigned int);
_CRTIMP int __cdecl _ismbcgraph(unsigned int);
_CRTIMP int __cdecl _ismbclegal(unsigned int);
_CRTIMP int __cdecl _ismbclower(unsigned int);
_CRTIMP int __cdecl _ismbcprint(unsigned int);
_CRTIMP int __cdecl _ismbcpunct(unsigned int);
_CRTIMP int __cdecl _ismbcspace(unsigned int);
_CRTIMP int __cdecl _ismbcupper(unsigned int);

_CRTIMP unsigned int __cdecl _mbctolower(unsigned int);
_CRTIMP unsigned int __cdecl _mbctoupper(unsigned int);


#define _MBSTRING_DEFINED
#endif

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead(unsigned int);
_CRTIMP int __cdecl _ismbbtrail(unsigned int);
_CRTIMP int __cdecl _ismbslead(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail(const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

/*  Kanji specific prototypes.  */

_CRTIMP int __cdecl _ismbchira(unsigned int);
_CRTIMP int __cdecl _ismbckata(unsigned int);
_CRTIMP int __cdecl _ismbcsymbol(unsigned int);
_CRTIMP int __cdecl _ismbcl0(unsigned int);
_CRTIMP int __cdecl _ismbcl1(unsigned int);
_CRTIMP int __cdecl _ismbcl2(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjistojms(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjmstojis(unsigned int);
_CRTIMP unsigned int __cdecl _mbctohira(unsigned int);
_CRTIMP unsigned int __cdecl _mbctokata(unsigned int);

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MBSTRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\rtcapi.h ===
/***
*rtcapi.h - declarations and definitions for RTC use
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations and definitions for all RunTime Check
*       support.
*
****/

#ifndef _INC_RTCAPI
#define _INC_RTCAPI


#ifdef  __cplusplus

extern "C" {

#endif

    /* General User API */

typedef enum _RTC_ErrorNumber {
    _RTC_CHKSTK = 0,
    _RTC_CVRT_LOSS_INFO,
    _RTC_CORRUPT_STACK,
    _RTC_UNINIT_LOCAL_USE,
    _RTC_ILLEGAL 
} _RTC_ErrorNumber;
 
#   define _RTC_ERRTYPE_IGNORE -1
#   define _RTC_ERRTYPE_ASK    -2

    typedef int (__cdecl *_RTC_error_fn)(int, const char *, int, const char *, const char *, ...);

    /* User API */
    int           __cdecl _RTC_NumErrors(void);
    const char *  __cdecl _RTC_GetErrDesc(_RTC_ErrorNumber errnum);
    int           __cdecl _RTC_SetErrorType(_RTC_ErrorNumber errnum, int ErrType);
    _RTC_error_fn __cdecl _RTC_SetErrorFunc(_RTC_error_fn);

    /* Power User/library API */


    /* Init functions */

    /* These functions all call _CRT_RTC_INIT */
    void __cdecl _RTC_Initialize(void);
    void __cdecl _RTC_Terminate(void);

    /*
     * If you're not using the CRT, you have to implement _CRT_RTC_INIT
     * Just return either null, or your error reporting function
     * *** Don't mess with res0/res1/res2/res3/res4 - YOU'VE BEEN WARNED! ***
     */
    _RTC_error_fn _CRT_RTC_INIT(void *res0, void **res1, int res2, int res3, int res4);
    
    /* Compiler generated calls (unlikely to be used, even by power users) */
    /* Types */
    typedef struct _RTC_vardesc {
        int addr;
        int size;
        char *name;
    } _RTC_vardesc;

    typedef struct _RTC_framedesc {
        int varCount;
        _RTC_vardesc *variables;
    } _RTC_framedesc;

    /* Shortening convert checks - name indicates src bytes to target bytes */
    /* Signedness is NOT checked */
    char   __fastcall _RTC_Check_2_to_1(short src);
    char   __fastcall _RTC_Check_4_to_1(int src);
    char   __fastcall _RTC_Check_8_to_1(__int64 src);
    short  __fastcall _RTC_Check_4_to_2(int src);
    short  __fastcall _RTC_Check_8_to_2(__int64 src);
    int    __fastcall _RTC_Check_8_to_4(__int64 src);
 
    
    /* Stack Checking Calls */
    void   __cdecl     _RTC_CheckEsp();
    void   __fastcall  _RTC_CheckStackVars(void *esp, _RTC_framedesc *fd);

    /* Unintialized Local call */
    void   __cdecl     _RTC_UninitUse(const char *varname);


    /* Subsystem initialization stuff */
    void    __cdecl    _RTC_Shutdown(void);
    void    __cdecl    _RTC_InitBase(void);
    

#ifdef  __cplusplus

    void* _ReturnAddress();
}

#endif


#endif /* _INC_RTCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\ostream.h ===
/***
*ostream.h - definitions/declarations for the ostream class
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the ostream class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_OSTREAM
#define _INC_OSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef long streamoff, streampos;

class _CRTIMP ostream : virtual public ios {

public:
        ostream(streambuf*);
        virtual ~ostream();

        ostream& flush();
        int  opfx();
        void osfx();

inline  ostream& operator<<(ostream& (__cdecl * _f)(ostream&));
inline  ostream& operator<<(ios& (__cdecl * _f)(ios&));
        ostream& operator<<(const char *);
inline  ostream& operator<<(const unsigned char *);
inline  ostream& operator<<(const signed char *);
inline  ostream& operator<<(char);
        ostream& operator<<(unsigned char);
inline  ostream& operator<<(signed char);
        ostream& operator<<(short);
        ostream& operator<<(unsigned short);
        ostream& operator<<(int);
        ostream& operator<<(unsigned int);
        ostream& operator<<(long);
        ostream& operator<<(unsigned long);
inline  ostream& operator<<(float);
        ostream& operator<<(double);
        ostream& operator<<(long double);
        ostream& operator<<(const void *);
        ostream& operator<<(streambuf*);
inline  ostream& put(char);
        ostream& put(unsigned char);
inline  ostream& put(signed char);
        ostream& write(const char *,int);
inline  ostream& write(const unsigned char *,int);
inline  ostream& write(const signed char *,int);
        ostream& seekp(streampos);
        ostream& seekp(streamoff,ios::seek_dir);
        streampos tellp();

protected:
        ostream();
        ostream(const ostream&);        // treat as private
        ostream& operator=(streambuf*); // treat as private
        ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
        int do_opfx(int);               // not used
        void do_osfx();                 // not used

private:
        ostream(ios&);
        ostream& writepad(const char *, const char *);
        int x_floatused;
};

inline ostream& ostream::operator<<(ostream& (__cdecl * _f)(ostream&)) { (*_f)(*this); return *this; }
inline ostream& ostream::operator<<(ios& (__cdecl * _f)(ios& )) { (*_f)(*this); return *this; }

inline  ostream& ostream::operator<<(char _c) { return operator<<((unsigned char) _c); }
inline  ostream& ostream::operator<<(signed char _c) { return operator<<((unsigned char) _c); }

inline  ostream& ostream::operator<<(const unsigned char * _s) { return operator<<((const char *) _s); }
inline  ostream& ostream::operator<<(const signed char * _s) { return operator<<((const char *) _s); }

inline  ostream& ostream::operator<<(float _f) { x_floatused = 1; return operator<<((double) _f); }

inline  ostream& ostream::put(char _c) { return put((unsigned char) _c); }
inline  ostream& ostream::put(signed char _c) { return put((unsigned char) _c); }

inline  ostream& ostream::write(const unsigned char * _s, int _n) { return write((char *) _s, _n); }
inline  ostream& ostream::write(const signed char * _s, int _n) { return write((char *) _s, _n); }


class _CRTIMP ostream_withassign : public ostream {
        public:
                ostream_withassign();
                ostream_withassign(streambuf* _is);
                ~ostream_withassign();
    ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
    ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
};

extern ostream_withassign _CRTIMP cout;
extern ostream_withassign _CRTIMP cerr;
extern ostream_withassign _CRTIMP clog;

inline _CRTIMP ostream& __cdecl flush(ostream& _outs) { return _outs.flush(); }
inline _CRTIMP ostream& __cdecl endl(ostream& _outs) { return _outs << '\n' << flush; }
inline _CRTIMP ostream& __cdecl ends(ostream& _outs) { return _outs << char('\0'); }

_CRTIMP ios&           __cdecl dec(ios&);
_CRTIMP ios&           __cdecl hex(ios&);
_CRTIMP ios&           __cdecl oct(ios&);

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_OSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\new.h ===
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations for C++ memory allocation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_NEW
#define _INC_NEW

#ifdef  __cplusplus

#ifndef _MSC_EXTENSIONS
#include <new>
#endif

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* Protect against #define of new */
#pragma push_macro("new")
#undef  new


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* types and structures */

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifdef  _MSC_EXTENSIONS
typedef void (__cdecl * new_handler) ();
_CRTIMP new_handler __cdecl set_new_handler(new_handler);
#endif

#ifndef __NOTHROW_T_DEFINED
#define __NOTHROW_T_DEFINED
namespace std {
        /* placement new tag type to suppress exceptions */
        struct nothrow_t {};

        /* constant for placement new tag */
        extern const nothrow_t nothrow;
};

void *__cdecl operator new(size_t, const std::nothrow_t&) throw();
void __cdecl operator delete(void *, const std::nothrow_t&) throw();
#if _MSC_FULL_VER >= 13009179
void *__cdecl operator new[](size_t, const std::nothrow_t&) throw();
void __cdecl operator delete[](void *, const std::nothrow_t&) throw();
#endif
#endif

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
        {return (_P); }
#if     _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void *)
        {return; }
#endif
#endif

/* 
 * new mode flag -- when set, makes malloc() behave like new()
 */

_CRTIMP int __cdecl _query_new_mode( void );
_CRTIMP int __cdecl _set_new_mode( int );

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

_CRTIMP _PNH __cdecl _query_new_handler( void );
_CRTIMP _PNH __cdecl _set_new_handler( _PNH );

/*
 * Microsoft extension: 
 *
 * _NO_ANSI_NEW_HANDLER de-activates the ANSI new_handler. Use this special value
 * to support old style (_set_new_handler) behavior.
 */

#ifndef _NO_ANSI_NH_DEFINED
#define _NO_ANSI_NEW_HANDLER  ((new_handler)-1)
#define _NO_ANSI_NH_DEFINED
#endif

#pragma pop_macro("new")

#endif  /* __cplusplus */

#endif  /* _INC_NEW */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the machine-dependent buffer used by
*       setjmp/longjmp to save and restore the program state, and
*       declarations for those routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SETJMP
#define _INC_SETJMP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif

#define _JBLEN  16
#define _JBTYPE int

/*
 * Define jump buffer layout for x86 setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long Ebp;
    unsigned long Ebx;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Esp;
    unsigned long Eip;
    unsigned long Registration;
    unsigned long TryLevel;
    unsigned long Cookie;
    unsigned long UnwindFunc;
    unsigned long UnwindData[6];
} _JUMP_BUFFER;

#elif defined(_M_AMD64)

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif

/*
 * AMD64 setjmp definitions.
 */

typedef struct __declspec(align(16)) _SETJMP_FLOAT128 {
    unsigned __int64 Part[2];
} SETJMP_FLOAT128;

#define _JBLEN  16
typedef SETJMP_FLOAT128 _JBTYPE;

typedef struct _JUMP_BUFFER {
    unsigned __int64 Frame;
    unsigned __int64 Rbx;
    unsigned __int64 Rsp;
    unsigned __int64 Rbp;
    unsigned __int64 Rsi;
    unsigned __int64 Rdi;
    unsigned __int64 R12;
    unsigned __int64 R13;
    unsigned __int64 R14;
    unsigned __int64 R15;
    unsigned __int64 Rip;
    unsigned __int64 Spare;

    SETJMP_FLOAT128 Xmm6;
    SETJMP_FLOAT128 Xmm7;
    SETJMP_FLOAT128 Xmm8;
    SETJMP_FLOAT128 Xmm9;
    SETJMP_FLOAT128 Xmm10;
    SETJMP_FLOAT128 Xmm11;
    SETJMP_FLOAT128 Xmm12;
    SETJMP_FLOAT128 Xmm13;
    SETJMP_FLOAT128 Xmm14;
    SETJMP_FLOAT128 Xmm15;
} _JUMP_BUFFER;

#elif defined(_M_IA64)

/*
 * Minimum length is 528 bytes
 * Since this is allocated as an array of "SETJMP_FLOAT128", the
 * number of entries required is 33 (16-byte aligned).
 */

/* Avoid conflicts with winnt.h FLOAT128 by giving the typedef another name. */
typedef __declspec(align(16)) struct _SETJMP_FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} SETJMP_FLOAT128;
                                  
#define _JBLEN  33
typedef SETJMP_FLOAT128 _JBTYPE;
#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif
/*
 * Define jump buffer layout for IA64 setjmp/longjmp.
 */

typedef struct __JUMP_BUFFER {

    /*
     * x86 reserved.
     */

    unsigned long iAReserved[6];

    /*
     * x86 C9.0 compatibility
     */

    unsigned long Registration;  /* point to the UnwindData field. */
    unsigned long TryLevel;      /* ignored by setjmp */
    unsigned long Cookie;        /* set to "VC20" by setjmp */
    unsigned long UnwindFunc;    /* set to EM longjmp() by setjmp */

    /*
     * First dword is zero to indicate it's an exception registration
     * record prepared by EM setjmp function.
     * Second dword is set to 0 for unsafe EM setjmp, and 1 for safe
     * EM setjmp.
     * Third dword is set to the setjmp site memory stack frame pointer.
     * Fourth dword is set to the setjmp site backing store frame pointer.
     */

    unsigned long UnwindData[6];

    /*
     * floating point status register,
     * and preserved floating point registers fs0 - fs19
     */

    SETJMP_FLOAT128 FltS0;
    SETJMP_FLOAT128 FltS1;
    SETJMP_FLOAT128 FltS2;
    SETJMP_FLOAT128 FltS3;
    SETJMP_FLOAT128 FltS4;
    SETJMP_FLOAT128 FltS5;
    SETJMP_FLOAT128 FltS6;
    SETJMP_FLOAT128 FltS7;
    SETJMP_FLOAT128 FltS8;
    SETJMP_FLOAT128 FltS9;
    SETJMP_FLOAT128 FltS10;
    SETJMP_FLOAT128 FltS11;
    SETJMP_FLOAT128 FltS12;
    SETJMP_FLOAT128 FltS13;
    SETJMP_FLOAT128 FltS14;
    SETJMP_FLOAT128 FltS15;
    SETJMP_FLOAT128 FltS16;
    SETJMP_FLOAT128 FltS17;
    SETJMP_FLOAT128 FltS18;
    SETJMP_FLOAT128 FltS19;

    __int64 FPSR;

    /*
     * return link and preserved branch registers bs0 - bs4
     */

    __int64 StIIP;     /* continuation address */
    __int64 BrS0;
    __int64 BrS1;
    __int64 BrS2;
    __int64 BrS3;
    __int64 BrS4;

    /*
     * preserved general registers s0 - s3, sp, nats
     */

    __int64 IntS0;
    __int64 IntS1;
    __int64 IntS2;
    __int64 IntS3;

    /*
     * bsp, pfs, unat, lc
     */

    __int64 RsBSP;
    __int64 RsPFS;     /* previous frame marker (cfm of setjmp's caller) */
    __int64 ApUNAT;    /* User Nat collection register (preserved) */
    __int64 ApLC;      /* loop counter */

    __int64 IntSp;     /* memory stack pointer */
    __int64 IntNats;   /* Nat bits of preserved integer regs s0 - s3 */
    __int64 Preds;     /* predicates */

} _JUMP_BUFFER;
#endif


/* Define the buffer type for holding the state information */

#ifndef _JMP_BUF_DEFINED
typedef _JBTYPE jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif


/* Function prototypes */

int __cdecl setjmp(jmp_buf);

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl longjmp(jmp_buf, int);
#else
_CRTIMP void __cdecl longjmp(jmp_buf, int);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_SETJMP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\setjmpex.h ===
/***
*setjmpex.h - definitions/declarations for extended setjmp/longjmp routines
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file causes _setjmpex to be called which will enable safe
*       setjmp/longjmp that work correctly with try/except/finally.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SETJMPEX
#define _INC_SETJMPEX

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#define setjmp  _setjmp
#define longjmp _longjmpex

#else

#ifdef setjmp
#undef setjmp
#endif
#define setjmp _setjmpex

#endif

#include <setjmp.h>

#endif  /* _INC_SETJMPEX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the declarations for the sorting and
*       searching routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SEARCH
#define _INC_SEARCH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Function prototypes */

_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *,
        const void *));


#if     !__STDC__
/* Non-ANSI names for compatibility */
_CRTIMP void * __cdecl lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SEARCH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the file sharing modes for sopen().
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SHARE
#define _INC_SHARE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _SH_DENYRW      0x10    /* deny read/write mode */
#define _SH_DENYWR      0x20    /* deny write mode */
#define _SH_DENYRD      0x30    /* deny read mode */
#define _SH_DENYNO      0x40    /* deny none mode */

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define SH_DENYRW _SH_DENYRW
#define SH_DENYWR _SH_DENYWR
#define SH_DENYRD _SH_DENYRD
#define SH_DENYNO _SH_DENYNO
#endif

#endif  /* _INC_SHARE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\signal.h ===
/***
*signal.h - defines signal values and routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the signal values and declares the signal functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SIGNAL
#define _INC_SIGNAL

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif

#define NSIG 23     /* maximum signal number + 1 */


/* Signal types */

#define SIGINT          2       /* interrupt */
#define SIGILL          4       /* illegal instruction - invalid function image */
#define SIGFPE          8       /* floating point exception */
#define SIGSEGV         11      /* segment violation */
#define SIGTERM         15      /* Software termination signal from kill */
#define SIGBREAK        21      /* Ctrl-Break sequence */
#define SIGABRT         22      /* abnormal termination triggered by abort call */


/* signal action codes */

#define SIG_DFL (void (__cdecl *)(int))0           /* default signal action */
#define SIG_IGN (void (__cdecl *)(int))1           /* ignore signal */
#define SIG_SGE (void (__cdecl *)(int))3           /* signal gets error */
#define SIG_ACK (void (__cdecl *)(int))4           /* acknowledge */


/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (__cdecl *)(int))-1          /* signal error value */


/* pointer to exception information pointers structure */

#if     defined(_MT) || defined(_DLL)
extern void * * __cdecl __pxcptinfoptrs(void);
#define _pxcptinfoptrs  (*__pxcptinfoptrs())
#else   /* ndef _MT && ndef _DLL */
extern void * _pxcptinfoptrs;
#endif  /* _MT || _DLL */


/* Function prototypes */

_CRTIMP void (__cdecl * __cdecl signal(int, void (__cdecl *)(int)))(int);
_CRTIMP int __cdecl raise(int);


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SIGNAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\stl.h ===
// stl.h supplemental header
#ifndef _STL_H_
#define _STL_H_
#include <algorithm>
#include <deque>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <utility>
#include <vector>
using namespace std;

		// TEMPLATE CLASS Deque
template<class _Ty>
	class Deque : public deque<_Ty, allocator<_Ty> > {
public:
	typedef Deque<_Ty> _Myt;
	typedef allocator<_Ty> _A;
	explicit Deque()
		: deque<_Ty, _A>() {}
	explicit Deque(size_type _N, const _Ty& _V = _Ty())
		: deque<_Ty, _A>(_N, _V) {}
	typedef const_iterator _It;
	Deque(_It _F, _It _L)
		: deque<_Ty, _A>(_F, _L) {}
	void swap(_Myt& _X)
		{deque<_Ty, _A>::swap((deque<_Ty, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS List
template<class _Ty>
	class List : public list<_Ty, allocator<_Ty> > {
public:
	typedef List<_Ty> _Myt;
	typedef allocator<_Ty> _A;
	explicit List()
		: list<_Ty, _A>() {}
	explicit List(size_type _N, const _Ty& _V = _Ty())
		: list<_Ty, _A>(_N, _V) {}
	typedef const_iterator _It;
	List(_It _F, _It _L)
		: list<_Ty, _A>(_F, _L) {}
	void swap(_Myt& _X)
		{list<_Ty, _A>::swap((list<_Ty, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Map
template<class _K, class _Ty, class _Pr = less<_K> >
	class Map : public map<_K, _Ty, _Pr, allocator<_Ty> > {
public:
	typedef Map<_K, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _A;
	explicit Map(const _Pr& _Pred = _Pr())
		: map<_K, _Ty, _Pr, _A>(_Pred) {}
	typedef const_iterator _It;
	Map(_It _F, _It _L, const _Pr& _Pred = _Pr())
		: map<_K, _Ty, _Pr, _A>(_F, _L, _Pred) {}
	void swap(_Myt& _X)
		{map<_K, _Ty, _Pr, _A>::
			swap((map<_K, _Ty, _Pr, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Multimap
template<class _K, class _Ty, class _Pr = less<_K> >
	class Multimap
		: public multimap<_K, _Ty, _Pr, allocator<_Ty> > {
public:
	typedef Multimap<_K, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _A;
	explicit Multimap(const _Pr& _Pred = _Pr())
		: multimap<_K, _Ty, _Pr, _A>(_Pred) {}
	typedef const_iterator _It;
	Multimap(_It _F, _It _L, const _Pr& _Pred = _Pr())
		: multimap<_K, _Ty, _Pr, _A>(_F, _L, _Pred) {}
	void swap(_Myt& _X)
		{multimap<_K, _Ty, _Pr, _A>::
			swap((multimap<_K, _Ty, _Pr, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Set
template<class _K, class _Pr = less<_K> >
	class Set : public set<_K, _Pr, allocator<_K> > {
public:
	typedef Set<_K, _Pr> _Myt;
	typedef allocator<_K> _A;
	explicit Set(const _Pr& _Pred = _Pr())
		: set<_K, _Pr, _A>(_Pred) {}
	typedef const_iterator _It;
	Set(_It _F, _It _L, const _Pr& _Pred = _Pr())
		: set<_K, _Pr, _A>(_F, _L, _Pred) {}
	void swap(_Myt& _X)
		{set<_K, _Pr, _A>::swap((set<_K, _Pr, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Multiset
template<class _K, class _Pr = less<_K> >
	class Multiset : public multiset<_K, _Pr, allocator<_K> > {
public:
	typedef Multiset<_K, _Pr> _Myt;
	typedef allocator<_K> _A;
	explicit Multiset(const _Pr& _Pred = _Pr())
		: multiset<_K, _Pr, _A>(_Pred) {}
	typedef const_iterator _It;
	Multiset(_It _F, _It _L, const _Pr& _Pred = _Pr())
		: multiset<_K, _Pr, _A>(_F, _L, _Pred) {}
	void swap(_Myt& _X)
		{multiset<_K, _Pr, _A>::
			swap((multiset<_K, _Pr, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS Vector
template<class _Ty>
	class Vector : public vector<_Ty, allocator<_Ty> > {
public:
	typedef Vector<_Ty> _Myt;
	typedef allocator<_Ty> _A;
	explicit Vector()
		: vector<_Ty, _A>(_Al) {}
	explicit Vector(size_type _N, const _Ty& _V = _Ty())
		: vector<_Ty, _A>(_N, _V) {}
	typedef const_iterator _It;
	Vector(_It _F, _It _L)
		: vector<_Ty, _A>(_F, _L) {}
	void swap(_Myt& _X)
		{vector<_Ty, _A>::swap((vector<_Ty, _A>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// CLASS bit_vector
class bit_vector : public vector<_Bool, _Bool_allocator> {
public:
	typedef _Bool _Ty;
	typedef _Bool_allocator _A;
	typedef bit_vector _Myt;
	explicit bit_vector()
		: vector<_Bool, _Bool_allocator>() {}
	explicit bit_vector(size_type _N, const _Ty& _V = _Ty())
		: vector<_Bool, _Bool_allocator>(_N, _V) {}
	typedef const_iterator _It;
	bit_vector(_It _F, _It _L)
		: vector<_Bool, _Bool_allocator>(_F, _L) {}
	void swap(_Myt& _X)
		{vector<_Bool, _Bool_allocator>::
			swap((vector<_Bool, _Bool_allocator>&)_X); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	};

		// TEMPLATE CLASS priority_queue
template<class _C = vector<_Ty>,
	class _Pr = less<_C::value_type> >
	class Priority_queue
		: public priority_queue<_C::value_type, _C, _Pr,
			allocator<_C::value_type> > {
public:
	typedef _C::value_type _Ty;
	typedef allocator<_C::value_type> _A;
	explicit Priority_queue(const _Pr& _X = _Pr())
		: priority_queue<_Ty, _C, _Pr, _A>(_X) {}
	typedef const value_type *_It;
	Priority_queue(_It _F, _It _L, const _Pr& _X = _Pr())
		: priority_queue<_Ty, _C, _Pr, _A>(_F, _L, _X) {}
	};

		// TEMPLATE CLASS queue
template<class _C = deque<_Ty> >
	class Queue
		: public queue<_C::value_type, _C,
			allocator<_C::value_type> > {
	};

		// TEMPLATE CLASS stack
template<class _C = deque<_Ty> >
	class Stack
		: public stack<_C::value_type, _C,
			allocator<_C::value_type> > {
	};

		// MACRO DEFINITIONS
#define deque			Deque
#define list			List
#define map				Map
#define multimap		Multimap
#define set				Set
#define multiset		Multiset
#define vector			Vector
#define priority_queue	Priority_queue
#define queue			Queue
#define stack			Stack

#endif	/* _STL_H_ */

/*
 * Copyright (c) 1996 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the modeflag values for spawnxx calls.
*       Also contains the function argument declarations for all
*       process control related routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_PROCESS
#define _INC_PROCESS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef _POSIX_

#ifdef __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* modeflag values for _spawnxx routines */

#define _P_WAIT         0
#define _P_NOWAIT       1
#define _OLD_P_OVERLAY  2
#define _P_NOWAITO      3
#define _P_DETACH       4

#ifdef  _MT
#define _P_OVERLAY      2
#else
extern int _p_overlay;
#define _P_OVERLAY      _p_overlay
#endif  /* _MT */

/* Action codes for _cwait(). The action code argument to _cwait is ignored
   on Win32 though it is accepted for compatibilty with old MS CRT libs */
#define _WAIT_CHILD      0
#define _WAIT_GRANDCHILD 1


/* function prototypes */

#ifdef  _MT
_CRTIMP uintptr_t __cdecl _beginthread (void (__cdecl *) (void *),
        unsigned, void *);
_CRTIMP void __cdecl _endthread(void);
_CRTIMP uintptr_t __cdecl _beginthreadex(void *, unsigned,
        unsigned (__stdcall *) (void *), void *, unsigned, unsigned *);
_CRTIMP void __cdecl _endthreadex(unsigned);
#endif

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl abort(void);
_CRTIMP __declspec(noreturn) void __cdecl exit(int);
_CRTIMP __declspec(noreturn) void __cdecl _exit(int);
#else
_CRTIMP void __cdecl abort(void);
_CRTIMP void __cdecl exit(int);
_CRTIMP void __cdecl _exit(int);
#endif
_CRTIMP void __cdecl _cexit(void);
_CRTIMP void __cdecl _c_exit(void);
_CRTIMP int __cdecl _getpid(void);

_CRTIMP intptr_t __cdecl _cwait(int *, intptr_t, int);
_CRTIMP intptr_t __cdecl _execl(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execle(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execlp(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execlpe(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execv(const char *, const char * const *);
_CRTIMP intptr_t __cdecl _execve(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl _execvp(const char *, const char * const *);
_CRTIMP intptr_t __cdecl _execvpe(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnl(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnle(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnlp(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnlpe(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnv(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP intptr_t __cdecl _spawnvp(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnvpe(int, const char *, const char * const *,
        const char * const *);
_CRTIMP int __cdecl system(const char *);

#ifndef _WPROCESS_DEFINED
/* wide function prototypes, also declared in wchar.h  */
_CRTIMP intptr_t __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/*
 * The Win32 API LoadLibrary, FreeLibrary and GetProcAddress should be used
 * instead.
 */
intptr_t __cdecl _loaddll(char *);
int __cdecl _unloaddll(intptr_t);
int (__cdecl * __cdecl _getdllprocaddr(intptr_t, char *, intptr_t))();
/* --------- The preceding functions are OBSOLETE --------- */


#ifdef  _DECL_DLLMAIN
/*
 * Declare DLL notification (initialization/termination) routines
 *      The preferred method is for the user to provide DllMain() which will
 *      be called automatically by the DLL entry point defined by the C run-
 *      time library code.  If the user wants to define the DLL entry point
 *      routine, the user's entry point must call _CRT_INIT on all types of
 *      notifications, as the very first thing on attach notifications and
 *      as the very last thing on detach notifications.
 */
#ifdef  _WINDOWS_       /* Use types from WINDOWS.H */
BOOL WINAPI DllMain(HANDLE, DWORD, LPVOID);
BOOL WINAPI _CRT_INIT(HANDLE, DWORD, LPVOID);
BOOL WINAPI _wCRT_INIT(HANDLE, DWORD, LPVOID);
extern BOOL (WINAPI *_pRawDllMain)(HANDLE, DWORD, LPVOID);
#else
int __stdcall DllMain(void *, unsigned, void *);
int __stdcall _CRT_INIT(void *, unsigned, void *);
int __stdcall _wCRT_INIT(void *, unsigned, void *);
extern int (__stdcall *_pRawDllMain)(void *, unsigned, void *);
#endif  /* _WINDOWS_ */
#endif

#if     !__STDC__

/* Non-ANSI names for compatibility */

#define P_WAIT          _P_WAIT
#define P_NOWAIT        _P_NOWAIT
#define P_OVERLAY       _P_OVERLAY
#define OLD_P_OVERLAY   _OLD_P_OVERLAY
#define P_NOWAITO       _P_NOWAITO
#define P_DETACH        _P_DETACH
#define WAIT_CHILD      _WAIT_CHILD
#define WAIT_GRANDCHILD _WAIT_GRANDCHILD

/* current declarations */
_CRTIMP intptr_t __cdecl cwait(int *, intptr_t, int);
_CRTIMP intptr_t __cdecl execl(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execle(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execlp(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execlpe(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execv(const char *, const char * const *);
_CRTIMP intptr_t __cdecl execve(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl execvp(const char *, const char * const *);
_CRTIMP intptr_t __cdecl execvpe(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl spawnl(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnle(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnlp(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnlpe(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnv(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP intptr_t __cdecl spawnvp(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl spawnvpe(int, const char *, const char * const *,
        const char * const *);

_CRTIMP int __cdecl getpid(void);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#endif  /* _INC_PROCESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines ANSI-style macros for accessing arguments
*       of functions which take a variable number of arguments.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDARG
#define _INC_STDARG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
typedef char *  va_list;
#define _VA_LIST_DEFINED
#endif

#ifdef  __cplusplus
#define _ADDRESSOF(v)   ( &reinterpret_cast<const char &>(v) )
#else
#define _ADDRESSOF(v)   ( &(v) )
#endif

#if     defined(_M_CEE)

extern void __cdecl __va_start(va_list*, ...);
extern void * __cdecl __va_arg(va_list*, ...);
extern void __cdecl __va_end(va_list*);

#define va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), sizeof(v), \
                                __builtin_alignof(v), _ADDRESSOF(v)) )
#define va_arg(ap,t)    ( *(t *)__va_arg(&ap, sizeof(t), \
                                __builtin_alignof(t), (t *)0) )
#define va_end(ap)      ( __va_end(&ap) )

#elif   defined(_M_IX86)

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_IA64)

#define _VA_STRUCT_ALIGN  16 

#define _VA_ALIGN       8

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) \
                            - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#ifdef  __cplusplus
extern void __cdecl __va_start(va_list*, ...);
#define va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), \
                          _ADDRESSOF(v)) )
#else
#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _SLOTSIZEOF(v) )
#endif

#define va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) \
                                                     -_SLOTSIZEOF(t)))

#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_AMD64)


extern void __cdecl __va_start(va_list *, ...);

#define va_start(ap, x) ( __va_start(&ap, x) )
#define va_arg(ap, t)   \
    ( ( sizeof(t) > sizeof(__int64) || ( sizeof(t) & (sizeof(t) - 1) ) != 0 ) \
        ? **(t **)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) \
        :  *(t  *)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) )
#define va_end(ap)      ( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDARG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\stdexcpt.h ===
/***
*stdexcpt.h - User include file for standard exception classes
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file is the previous location of the standard exception class
*       definitions, now found in the standard header <exception>.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDEXCPT
#define _INC_STDEXCPT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus

#include <exception>

#endif  /* __cplusplus */
#endif  /* _INC_STDEXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\stdiostr.h ===
/***
*stdiostr.h - definitions/declarations for stdiobuf, stdiostream
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the stdiostream and stdiobuf classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STDIOSTREAM
#define _INC_STDIOSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <iostream.h>
#include <stdio.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

class _CRTIMP stdiobuf : public streambuf  {
public:
        stdiobuf(FILE* f);
FILE *  stdiofile() { return _str; }

virtual int pbackfail(int c);
virtual int overflow(int c = EOF);
virtual int underflow();
virtual streampos seekoff( streamoff, ios::seek_dir, int =ios::in|ios::out);
virtual int sync();
        ~stdiobuf();
        int setrwbuf(int _rsize, int _wsize);
// protected:
// virtual int doallocate();
private:
        FILE * _str;
};

// obsolescent
class _CRTIMP stdiostream : public iostream {  // note: spec.'d as : public IOS...
public:
        stdiostream(FILE *);
        ~stdiostream();
        stdiobuf* rdbuf() const { return (stdiobuf*) ostream::rdbuf(); }
        
private:
};

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STDIOSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains definitions and declarations for some commonly
*       used constants, types, and variables.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDDEF
#define _INC_STDDEF

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Declare reference to errno */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */


/* Define the implementation dependent size types */

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _PTRDIFF_T_DEFINED
#ifdef  _WIN64
typedef __int64             ptrdiff_t;
#else
typedef _W64 int            ptrdiff_t;
#endif
#define _PTRDIFF_T_DEFINED
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* Define offsetof macro */

#ifdef  _WIN64
#define offsetof(s,m)   (size_t)( (ptrdiff_t)&(((s *)0)->m) )
#else
#define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif


#ifdef  _MT
_CRTIMP extern unsigned long  __cdecl __threadid(void);
#define _threadid       (__threadid())
_CRTIMP extern uintptr_t __cdecl __threadhandle(void);
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STDDEF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the level 2 I/O ("standard I/O") routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDIO
#define _INC_STDIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
typedef char *  va_list;
#define _VA_LIST_DEFINED
#endif


/* Buffered I/O macros */

#define BUFSIZ  512


/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */
#define _NFILE      _NSTREAM_

#define _NSTREAM_   512

/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 */
#define _IOB_ENTRIES 20

#define EOF     (-1)


#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif


/* Directory where temporary files may be created. */

#ifdef  _POSIX_
#define _P_tmpdir   "/"
#define _wP_tmpdir  L"/"
#else
#define _P_tmpdir   "\\"
#define _wP_tmpdir  L"\\"
#endif

/* L_tmpnam = length of string _P_tmpdir
 *            + 1 if _P_tmpdir does not end in "/" or "\", else 0
 *            + 12 (for the filename string)
 *            + 1 (for the null terminator)
 */
#define L_tmpnam sizeof(_P_tmpdir)+12


#ifdef  _POSIX_
#define L_ctermid   9
#define L_cuserid   32
#endif


/* Seek method constants */

#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0


#define FILENAME_MAX    260
#define FOPEN_MAX       20
#define _SYS_OPEN       20
#define TMP_MAX         32767


/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
_CRTIMP extern FILE _iob[];
#endif  /* _STDIO_DEFINED */


/* Define file position type */

#ifndef _FPOS_T_DEFINED
#undef _FPOSOFF

#if     defined (_POSIX_)
typedef long fpos_t;
#define _FPOSOFF(fp) ((long)(fp))
#else   /* _POSIX_ */

#if     !__STDC__ && _INTEGRAL_MAX_BITS >= 64
typedef __int64 fpos_t;
#define _FPOSOFF(fp) ((long)(fp))
#else
typedef struct fpos_t {
        unsigned int lopart;
        int          hipart;
        } fpos_t;
#define _FPOSOFF(fp) ((long)(fp).lopart)
#endif
#endif  /* _POSIX_ */

#define _FPOS_T_DEFINED
#endif


#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])


#define _IOREAD         0x0001
#define _IOWRT          0x0002

#define _IOFBF          0x0000
#define _IOLBF          0x0040
#define _IONBF          0x0004

#define _IOMYBUF        0x0008
#define _IOEOF          0x0010
#define _IOERR          0x0020
#define _IOSTRG         0x0040
#define _IORW           0x0080
#ifdef  _POSIX_
#define _IOAPPEND       0x0200
#endif


/* Function prototypes */

#ifndef _STDIO_DEFINED

_CRTIMP int __cdecl _filbuf(FILE *);
_CRTIMP int __cdecl _flsbuf(int, FILE *);

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *);
#else
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *, int);
#endif

_CRTIMP void __cdecl clearerr(FILE *);
_CRTIMP int __cdecl fclose(FILE *);
_CRTIMP int __cdecl _fcloseall(void);

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl fdopen(int, const char *);
#else
_CRTIMP FILE * __cdecl _fdopen(int, const char *);
#endif

_CRTIMP int __cdecl feof(FILE *);
_CRTIMP int __cdecl ferror(FILE *);
_CRTIMP int __cdecl fflush(FILE *);
_CRTIMP int __cdecl fgetc(FILE *);
_CRTIMP int __cdecl _fgetchar(void);
_CRTIMP int __cdecl fgetpos(FILE *, fpos_t *);
_CRTIMP char * __cdecl fgets(char *, int, FILE *);

#ifdef  _POSIX_
_CRTIMP int __cdecl fileno(FILE *);
#else
_CRTIMP int __cdecl _fileno(FILE *);
#endif

_CRTIMP int __cdecl _flushall(void);
_CRTIMP FILE * __cdecl fopen(const char *, const char *);
_CRTIMP int __cdecl fprintf(FILE *, const char *, ...);
_CRTIMP int __cdecl fputc(int, FILE *);
_CRTIMP int __cdecl _fputchar(int);
_CRTIMP int __cdecl fputs(const char *, FILE *);
_CRTIMP size_t __cdecl fread(void *, size_t, size_t, FILE *);
_CRTIMP FILE * __cdecl freopen(const char *, const char *, FILE *);
_CRTIMP int __cdecl fscanf(FILE *, const char *, ...);
_CRTIMP int __cdecl fsetpos(FILE *, const fpos_t *);
_CRTIMP int __cdecl fseek(FILE *, long, int);
_CRTIMP long __cdecl ftell(FILE *);
_CRTIMP size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
_CRTIMP int __cdecl getc(FILE *);
_CRTIMP int __cdecl getchar(void);
_CRTIMP int __cdecl _getmaxstdio(void);
_CRTIMP char * __cdecl gets(char *);
_CRTIMP int __cdecl _getw(FILE *);
_CRTIMP void __cdecl perror(const char *);
_CRTIMP int __cdecl _pclose(FILE *);
_CRTIMP FILE * __cdecl _popen(const char *, const char *);
_CRTIMP int __cdecl printf(const char *, ...);
_CRTIMP int __cdecl putc(int, FILE *);
_CRTIMP int __cdecl putchar(int);
_CRTIMP int __cdecl puts(const char *);
_CRTIMP int __cdecl _putw(int, FILE *);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP void __cdecl rewind(FILE *);
_CRTIMP int __cdecl _rmtmp(void);
_CRTIMP int __cdecl scanf(const char *, ...);
_CRTIMP void __cdecl setbuf(FILE *, char *);
_CRTIMP int __cdecl _setmaxstdio(int);
_CRTIMP int __cdecl setvbuf(FILE *, char *, int, size_t);
_CRTIMP int __cdecl _snprintf(char *, size_t, const char *, ...);
_CRTIMP int __cdecl sprintf(char *, const char *, ...);
_CRTIMP int __cdecl _scprintf(const char *, ...);
_CRTIMP int __cdecl sscanf(const char *, const char *, ...);
_CRTIMP int __cdecl _snscanf(const char *, size_t, const char *, ...);
_CRTIMP char * __cdecl _tempnam(const char *, const char *);
_CRTIMP FILE * __cdecl tmpfile(void);
_CRTIMP char * __cdecl tmpnam(char *);
_CRTIMP int __cdecl ungetc(int, FILE *);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl vfprintf(FILE *, const char *, va_list);
_CRTIMP int __cdecl vprintf(const char *, va_list);
_CRTIMP int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
_CRTIMP int __cdecl vsprintf(char *, const char *, va_list);
_CRTIMP int __cdecl _vscprintf(const char *, va_list);

#ifndef _WSTDIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wchar_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wchar_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);

_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);

_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _scwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl _vscwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _snwscanf(const wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#define getwchar()              fgetwc(stdin)
#define putwchar(_c)            fputwc((_c),stdout)
#define getwc(_stm)             fgetwc(_stm)
#define putwc(_c,_stm)          fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif  /* _WSTDIO_DEFINED */

#define _STDIO_DEFINED
#endif  /* _STDIO_DEFINED */


/* Macro definitions */

#define feof(_stream)     ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((_stream)->_file)
#define getc(_stream)     (--(_stream)->_cnt >= 0 \
                ? 0xff & *(_stream)->_ptr++ : _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
                ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#define getchar()         getc(stdin)
#define putchar(_c)       putc((_c),stdout)



#ifdef  _MT
#undef  getc
#undef  putc
#undef  getchar
#undef  putchar
#endif



#if     !__STDC__ && !defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

_CRTIMP int __cdecl fcloseall(void);
_CRTIMP FILE * __cdecl fdopen(int, const char *);
_CRTIMP int __cdecl fgetchar(void);
_CRTIMP int __cdecl fileno(FILE *);
_CRTIMP int __cdecl flushall(void);
_CRTIMP int __cdecl fputchar(int);
_CRTIMP int __cdecl getw(FILE *);
_CRTIMP int __cdecl putw(int, FILE *);
_CRTIMP int __cdecl rmtmp(void);
_CRTIMP char * __cdecl tempnam(const char *, const char *);
_CRTIMP int __cdecl unlink(const char *);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\streamb.h ===
/***
*streamb.h - definitions/declarations for the streambuf class
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the streambuf class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STREAMB
#define _INC_STREAMB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>        // need ios::seek_dir definition

#ifndef NULL
#define NULL    0
#endif

#ifndef EOF
#define EOF     (-1)
#endif

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef long streampos, streamoff;

class _CRTIMP ios;

class _CRTIMP streambuf {
public:

    virtual ~streambuf();

    inline int in_avail() const;
    inline int out_waiting() const;
    int sgetc();
    int snextc();
    int sbumpc();
    void stossc();

    inline int sputbackc(char);

    inline int sputc(int);
    inline int sputn(const char *,int);
    inline int sgetn(char *,int);

    virtual int sync();

    virtual streambuf* setbuf(char *, int);
    virtual streampos seekoff(streamoff,ios::seek_dir,int =ios::in|ios::out);
    virtual streampos seekpos(streampos,int =ios::in|ios::out);

    virtual int xsputn(const char *,int);
    virtual int xsgetn(char *,int);

    virtual int overflow(int =EOF) = 0; // pure virtual function
    virtual int underflow() = 0;        // pure virtual function

    virtual int pbackfail(int);

    void dbp();

#ifdef  _MT
    void setlock() { LockFlg--; }       // <0 indicates lock required;
    void clrlock() { if (LockFlg <= 0) LockFlg++; }
    void lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
#else
    void lock() { }
    void unlock() { }
#endif

protected:
    streambuf();
    streambuf(char *,int);

    inline char * base() const;
    inline char * ebuf() const;
    inline char * pbase() const;
    inline char * pptr() const;
    inline char * epptr() const;
    inline char * eback() const;
    inline char * gptr() const;
    inline char * egptr() const;
    inline int blen() const;
    inline void setp(char *,char *);
    inline void setg(char *,char *,char *);
    inline void pbump(int);
    inline void gbump(int);

    void setb(char *,char *,int =0);
    inline int unbuffered() const;
    inline void unbuffered(int);
    int allocate();
    virtual int doallocate();
#ifdef  _MT
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#endif

private:
    int _fAlloc;
    int _fUnbuf;
    int x_lastc;
    char * _base;
    char * _ebuf;
    char * _pbase;
    char * _pptr;
    char * _epptr;
    char * _eback;
    char * _gptr;
    char * _egptr;
#ifdef  _MT
    int LockFlg;                // <0 indicates locking required
   _CRT_CRITICAL_SECTION x_lock;        // lock needed only for multi-thread operation
#endif
};

inline int streambuf::in_avail() const { return (gptr()<_egptr) ? (int)(_egptr-gptr()) : 0; }
inline int streambuf::out_waiting() const { return (_pptr>=_pbase) ? (int)(_pptr-_pbase) : 0; }

inline int streambuf::sputbackc(char _c){ return (_eback<gptr()) ? *(--_gptr)=_c : pbackfail(_c); }

inline int streambuf::sputc(int _i){ return (_pptr<_epptr) ? (unsigned char)(*(_pptr++)=(char)_i) : overflow(_i); }

inline int streambuf::sputn(const char * _str,int _n) { return xsputn(_str, _n); }
inline int streambuf::sgetn(char * _str,int _n) { return xsgetn(_str, _n); }

inline char * streambuf::base() const { return _base; }
inline char * streambuf::ebuf() const { return _ebuf; }
inline int streambuf::blen() const  {return ((_ebuf > _base) ? (int)(_ebuf-_base) : 0); }
inline char * streambuf::pbase() const { return _pbase; }
inline char * streambuf::pptr() const { return _pptr; }
inline char * streambuf::epptr() const { return _epptr; }
inline char * streambuf::eback() const { return _eback; }
inline char * streambuf::gptr() const { return _gptr; }
inline char * streambuf::egptr() const { return _egptr; }
inline void streambuf::gbump(int _n) { if (_egptr) _gptr += _n; }
inline void streambuf::pbump(int _n) { if (_epptr) _pptr += _n; }
inline void streambuf::setg(char * _eb, char * _g, char * _eg) {_eback=_eb; _gptr=_g; _egptr=_eg; x_lastc=EOF; }
inline void streambuf::setp(char * _p, char * _ep) {_pptr=_pbase=_p; _epptr=_ep; }
inline int streambuf::unbuffered() const { return _fUnbuf; }
inline void streambuf::unbuffered(int _f) { _fUnbuf = _f; }

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STREAMB

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\use_ansi.h ===
/***
*use_ansi.h - pragmas for ANSI Standard C++ libraries
*
*	Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header is intended to force the use of the appropriate ANSI
*       Standard C++ libraries whenever it is included.
*
*       [Public]
*
****/

#ifndef _USE_ANSI_CPP
#define _USE_ANSI_CPP

#ifdef _MT
#ifdef _DLL
#ifdef _DEBUG
#pragma comment(lib,"msvcprtd")
#else	// _DEBUG
#pragma comment(lib,"msvcprt")
#endif	// _DEBUG

#else	// _DLL
#ifdef _DEBUG
#pragma comment(lib,"libcpmtd")
#else	// _DEBUG
#pragma comment(lib,"libcpmt")
#endif	// _DEBUG
#endif	// _DLL

#else	// _MT
#ifdef _DEBUG
#pragma comment(lib,"libcpd")
#else	// _DEBUG
#pragma comment(lib,"libcp")
#endif	// _DEBUG
#endif

#endif	// _USE_ANSI_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for commonly
*       used library functions which either don't fit somewhere else, or,
*       cannot be declared in the normal place for other reasons.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDLIB
#define _INC_STDLIB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTNOALIAS, _CRTRESTRICT */

#if     _MSC_FULL_VER >= 14002050

#ifndef _CRTNOALIAS
#define _CRTNOALIAS __declspec(noalias)
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT __declspec(restrict)
#endif  /* _CRTRESTRICT */

#else

#ifndef _CRTNOALIAS
#define _CRTNOALIAS
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT
#endif  /* _CRTRESTRICT */

#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Definition of the argument values for the exit() function */

#define EXIT_SUCCESS    0
#define EXIT_FAILURE    1


#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)(void);
#if     !__STDC__
/* Non-ANSI name for compatibility */
#define onexit_t _onexit_t
#endif
#define _ONEXIT_T_DEFINED
#endif


/* Data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif


/* Maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in ctype.h).
 */
#ifndef MB_CUR_MAX
#ifdef _MT
#define MB_CUR_MAX ___mb_cur_max_func()
#else
#define MB_CUR_MAX __mb_cur_max
#endif
_CRTIMP extern int __mb_cur_max;
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */

/* Minimum and maximum macros */

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))

/*
 * Sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */
#define _MAX_PATH   260 /* max. length of full pathname */
#define _MAX_DRIVE  3   /* max. length of drive component */
#define _MAX_DIR    256 /* max. length of path component */
#define _MAX_FNAME  256 /* max. length of file name component */
#define _MAX_EXT    256 /* max. length of extension component */

/*
 * Argument values for _set_error_mode().
 */
#define _OUT_TO_DEFAULT 0
#define _OUT_TO_STDERR  1
#define _OUT_TO_MSGBOX  2
#define _REPORT_ERRMODE 3

#if     defined(_M_IX86)
/*
 * Typedefs and argument values for _set_security_error_handler()
 */
#define _SECERR_BUFFER_OVERRUN 1        /* void* arg ignored */
typedef void (__cdecl * _secerr_handler_func)(int, void *);
#endif

/* External variable declarations */

#if     defined(_MT) || defined(_DLL)
_CRTIMP int * __cdecl _errno(void);
_CRTIMP unsigned long * __cdecl __doserrno(void);
#define errno       (*_errno())
#define _doserrno   (*__doserrno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;               /* XENIX style error number */
_CRTIMP extern unsigned long _doserrno; /* OS system error value */
#endif  /* _MT || _DLL */


_CRTIMP extern char * _sys_errlist[];   /* perror error message table */
_CRTIMP extern int _sys_nerr;           /* # of entries in sys_errlist table */


_CRTIMP extern int __argc;          /* count of cmd line args */
_CRTIMP extern char ** __argv;      /* pointer to table of cmd line args */
_CRTIMP extern wchar_t ** __wargv;  /* pointer to table of wide cmd line args */

#ifdef  _POSIX_
extern char ** environ;             /* pointer to environment table */
#else
_CRTIMP extern char ** _environ;    /* pointer to environment table */
_CRTIMP extern wchar_t ** _wenviron;    /* pointer to wide environment table */
#endif  /* _POSIX_ */

_CRTIMP extern char * _pgmptr;      /* points to the module (EXE) name */
_CRTIMP extern wchar_t * _wpgmptr;  /* points to the module (EXE) wide name */

_CRTIMP extern int _fmode;          /* default file translation mode */
_CRTIMP extern int _fileinfo;       /* open file info mode (for spawn) */


/* Windows major/minor and O.S. version numbers */

_CRTIMP extern unsigned int _osplatform;
_CRTIMP extern unsigned int _osver;
_CRTIMP extern unsigned int _winver;
_CRTIMP extern unsigned int _winmajor;
_CRTIMP extern unsigned int _winminor;


/* function prototypes */

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void   __cdecl abort(void);
_CRTIMP __declspec(noreturn) void   __cdecl exit(int);
#else
_CRTIMP void   __cdecl abort(void);
_CRTIMP void   __cdecl exit(int);
#endif

        int    __cdecl abs(int);
        __int64    __cdecl _abs64(__int64);
        int    __cdecl atexit(void (__cdecl *)(void));
_CRTIMP double __cdecl atof(const char *);
_CRTIMP int    __cdecl atoi(const char *);
_CRTIMP long   __cdecl atol(const char *);
_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
        unsigned short __cdecl _byteswap_ushort(unsigned short);
        unsigned long  __cdecl _byteswap_ulong (unsigned long);
        unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void * __cdecl calloc(size_t, size_t);
_CRTIMP div_t  __cdecl div(int, int);
_CRTIMP _CRTNOALIAS void   __cdecl free(void *);
_CRTIMP char * __cdecl getenv(const char *);
_CRTIMP char * __cdecl _itoa(int, char *, int);
#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP char * __cdecl _i64toa(__int64, char *, int);
_CRTIMP char * __cdecl _ui64toa(unsigned __int64, char *, int);
_CRTIMP __int64 __cdecl _atoi64(const char *);
_CRTIMP __int64 __cdecl _strtoi64(const char *, char **, int);
_CRTIMP unsigned __int64 __cdecl _strtoui64(const char *, char **, int);
#endif
        long __cdecl labs(long);
_CRTIMP ldiv_t __cdecl ldiv(long, long);
_CRTIMP char * __cdecl _ltoa(long, char *, int);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void * __cdecl malloc(size_t);
_CRTIMP int    __cdecl mblen(const char *, size_t);
_CRTIMP size_t __cdecl _mbstrlen(const char *s);
_CRTIMP int    __cdecl mbtowc(wchar_t *, const char *, size_t);
_CRTIMP size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
_CRTIMP void   __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
        (const void *, const void *));
_CRTIMP int    __cdecl rand(void);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void * __cdecl realloc(void *, size_t);
_CRTIMP int    __cdecl _set_error_mode(int);
#if     defined(_M_IX86)
_CRTIMP _secerr_handler_func
               __cdecl _set_security_error_handler(_secerr_handler_func);
#endif
_CRTIMP void   __cdecl srand(unsigned int);
_CRTIMP double __cdecl strtod(const char *, char **);
_CRTIMP long   __cdecl strtol(const char *, char **, int);
_CRTIMP unsigned long __cdecl strtoul(const char *, char **, int);
_CRTIMP int    __cdecl system(const char *);
_CRTIMP char * __cdecl _ultoa(unsigned long, char *, int);
_CRTIMP int    __cdecl wctomb(char *, wchar_t);
_CRTIMP size_t __cdecl wcstombs(char *, const wchar_t *, size_t);


#ifndef _WSTDLIB_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP double __cdecl _wtof(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);
#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);
_CRTIMP __int64   __cdecl _wcstoi64(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned __int64  __cdecl _wcstoui64(const wchar_t *, wchar_t **, int);
#endif

#define _WSTDLIB_DEFINED
#endif


#ifndef _POSIX_

_CRTIMP char * __cdecl _ecvt(double, int, int *, int *);
#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void   __cdecl _exit(int);
#else
_CRTIMP void   __cdecl _exit(int);
#endif
_CRTIMP char * __cdecl _fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl _fullpath(char *, const char *, size_t);
_CRTIMP char * __cdecl _gcvt(double, int, char *);
        unsigned long __cdecl _lrotl(unsigned long, int);
        unsigned long __cdecl _lrotr(unsigned long, int);
_CRTIMP void   __cdecl _makepath(char *, const char *, const char *, const char *,
        const char *);
        _onexit_t __cdecl _onexit(_onexit_t);
_CRTIMP void   __cdecl perror(const char *);
_CRTIMP int    __cdecl _putenv(const char *);
        unsigned int __cdecl _rotl(unsigned int, int);
        unsigned __int64 __cdecl _rotl64(unsigned __int64, int);
        unsigned int __cdecl _rotr(unsigned int, int);
        unsigned __int64 __cdecl _rotr64(unsigned __int64, int);
_CRTIMP void   __cdecl _searchenv(const char *, const char *, char *);
_CRTIMP void   __cdecl _splitpath(const char *, char *, char *, char *, char *);
_CRTIMP void   __cdecl _swab(char *, char *, int);

#ifndef _WSTDLIBP_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API SetErrorMode, Beep and Sleep should be used instead. */
_CRTIMP void __cdecl _seterrormode(int);
_CRTIMP void __cdecl _beep(unsigned, unsigned);
_CRTIMP void __cdecl _sleep(unsigned long);
/* --------- The preceding functions are OBSOLETE --------- */

#endif  /* _POSIX_ */


#if     !__STDC__
/* --------- The declarations below should not be in stdlib.h --------- */
/* --------- and will be removed in a future release. Include --------- */
/* --------- ctype.h to obtain these declarations.            --------- */
#ifndef tolower     /* tolower has been undefined - use function */
_CRTIMP int __cdecl tolower(int);
#endif  /* tolower */
#ifndef toupper     /* toupper has been undefined - use function */
_CRTIMP int __cdecl toupper(int);
#endif  /* toupper */
/* --------- The declarations above will be removed.          --------- */
#endif


#if     !__STDC__

#ifndef _POSIX_

/* Non-ANSI names for compatibility */

#ifndef __cplusplus
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#define sys_errlist _sys_errlist
#define sys_nerr    _sys_nerr
#define environ     _environ

_CRTIMP char * __cdecl ecvt(double, int, int *, int *);
_CRTIMP char * __cdecl fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl gcvt(double, int, char *);
_CRTIMP char * __cdecl itoa(int, char *, int);
_CRTIMP char * __cdecl ltoa(long, char *, int);
        onexit_t __cdecl onexit(onexit_t);
_CRTIMP int    __cdecl putenv(const char *);
_CRTIMP void   __cdecl swab(char *, char *, int);
_CRTIMP char * __cdecl ultoa(unsigned long, char *, int);

#endif  /* _POSIX_ */

#endif  /* __STDC__ */

#ifdef  __cplusplus
}

#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDLIB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\tchar.h ===
/***
*tchar.h - definitions for generic international text functions
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Definitions for generic international functions, mostly defines
*       which map string/formatted-io/ctype functions to char, wchar_t, or
*       MBCS versions.  To be used for compatibility between single-byte,
*       multi-byte and Unicode text models.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_TCHAR
#define _INC_TCHAR

#ifdef  _MSC_VER
#pragma warning(disable:4514)       /* disable unwanted C++ /W4 warning */
/* #pragma warning(default:4514) */ /* use this to reenable, if necessary */
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


#define _ftcscat    _tcscat
#define _ftcschr    _tcschr
#define _ftcscpy    _tcscpy
#define _ftcscspn   _tcscspn
#define _ftcslen    _tcslen
#define _ftcsncat   _tcsncat
#define _ftcsncpy   _tcsncpy
#define _ftcspbrk   _tcspbrk
#define _ftcsrchr   _tcsrchr
#define _ftcsspn    _tcsspn
#define _ftcsstr    _tcsstr
#define _ftcstok    _tcstok

#define _ftcsdup    _tcsdup
#define _ftcsnset   _tcsnset
#define _ftcsrev    _tcsrev
#define _ftcsset    _tcsset

#define _ftcscmp      _tcscmp
#define _ftcsicmp     _tcsicmp
#define _ftcsnccmp    _tcsnccmp
#define _ftcsncmp     _tcsncmp
#define _ftcsncicmp   _tcsncicmp
#define _ftcsnicmp    _tcsnicmp

#define _ftcscoll     _tcscoll
#define _ftcsicoll    _tcsicoll
#define _ftcsnccoll   _tcsnccoll
#define _ftcsncoll    _tcsncoll
#define _ftcsncicoll  _tcsncicoll
#define _ftcsnicoll   _tcsnicoll

/* Redundant "logical-character" mappings */

#define _ftcsclen   _tcsclen
#define _ftcsnccat  _tcsnccat
#define _ftcsnccpy  _tcsnccpy
#define _ftcsncset  _tcsncset

#define _ftcsdec    _tcsdec
#define _ftcsinc    _tcsinc
#define _ftcsnbcnt  _tcsnbcnt
#define _ftcsnccnt  _tcsnccnt
#define _ftcsnextc  _tcsnextc
#define _ftcsninc   _tcsninc
#define _ftcsspnp   _tcsspnp

#define _ftcslwr    _tcslwr
#define _ftcsupr    _tcsupr

#define _ftclen     _tclen
#define _ftccpy     _tccpy
#define _ftccmp     _tccmp


#ifdef  _UNICODE

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

/* ++++++++++++++++++++ UNICODE ++++++++++++++++++++ */

#include <wchar.h>

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef __TCHAR_DEFINED
typedef wchar_t     _TCHAR;
typedef wchar_t     _TSCHAR;
typedef wchar_t     _TUCHAR;
typedef wchar_t     _TXCHAR;
typedef wint_t      _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef wchar_t     TCHAR;
#endif
#define _TCHAR_DEFINED
#endif

#define _TEOF       WEOF

#define __T(x)      L ## x


/* Program */

#define _tmain      wmain
#define _tWinMain   wWinMain
#define _tenviron   _wenviron
#define __targv     __wargv

/* Formatted i/o */

#define _tprintf    wprintf
#define _tcprintf   _cwprintf
#define _ftprintf   fwprintf
#define _stprintf   swprintf
#define _sctprintf  _scwprintf
#define _sntprintf  _snwprintf
#define _vtprintf   vwprintf
#define _vftprintf  vfwprintf
#define _vstprintf  vswprintf
#define _vsctprintf _vscwprintf
#define _vsntprintf _vsnwprintf
#define _tscanf     wscanf
#define _tcscanf    _cwscanf
#define _ftscanf    fwscanf
#define _stscanf    swscanf
#define _sntscanf   _snwscanf


/* Unformatted i/o */

#define _fgettc     fgetwc
#define _fgettchar  _fgetwchar
#define _fgetts     fgetws
#define _fputtc     fputwc
#define _fputtchar  _fputwchar
#define _fputts     fputws
#define _cputts     _cputws
#define _cgetts     _cgetws
#define _gettc      getwc
#define _gettch     _getwch
#define _gettche    _getwche
#define _gettchar   getwchar
#define _getts      _getws
#define _puttc      putwc
#define _puttchar   putwchar
#define _puttch     _putwch
#define _putts      _putws
#define _ungettc    ungetwc
#define _ungettch   _ungetwch


/* String conversion functions */

#define _tcstod     wcstod
#define _tcstol     wcstol
#define _tcstoul    wcstoul
#define _tcstoi64   _wcstoi64
#define _tcstoui64  _wcstoui64
#define _tstof      _wtof
#define _tstol      _wtol
#define _tstoi      _wtoi
#define _tstoi64    _wtoi64

#define _itot       _itow
#define _ltot       _ltow
#define _ultot      _ultow
#define _ttoi       _wtoi
#define _ttol       _wtol

#define _ttoi64     _wtoi64
#define _i64tot     _i64tow
#define _ui64tot    _ui64tow

/* String functions */

#define _tcscat     wcscat
#define _tcschr     wcschr
#define _tcscpy     wcscpy
#define _tcscspn    wcscspn
#define _tcslen     wcslen
#define _tcsncat    wcsncat
#define _tcsncpy    wcsncpy
#define _tcspbrk    wcspbrk
#define _tcsrchr    wcsrchr
#define _tcsspn     wcsspn
#define _tcsstr     wcsstr
#define _tcstok     wcstok
#define _tcserror   _wcserror
#define __tcserror  __wcserror

#define _tcsdup     _wcsdup
#define _tcsnset    _wcsnset
#define _tcsrev     _wcsrev
#define _tcsset     _wcsset

#define _tcscmp     wcscmp
#define _tcsicmp    _wcsicmp
#define _tcsnccmp   wcsncmp
#define _tcsncmp    wcsncmp
#define _tcsncicmp  _wcsnicmp
#define _tcsnicmp   _wcsnicmp

#define _tcscoll    wcscoll
#define _tcsicoll   _wcsicoll
#define _tcsnccoll  _wcsncoll
#define _tcsncoll   _wcsncoll
#define _tcsncicoll _wcsnicoll
#define _tcsnicoll  _wcsnicoll


/* Execute functions */

#define _texecl     _wexecl
#define _texecle    _wexecle
#define _texeclp    _wexeclp
#define _texeclpe   _wexeclpe
#define _texecv     _wexecv
#define _texecve    _wexecve
#define _texecvp    _wexecvp
#define _texecvpe   _wexecvpe

#define _tspawnl    _wspawnl
#define _tspawnle   _wspawnle
#define _tspawnlp   _wspawnlp
#define _tspawnlpe  _wspawnlpe
#define _tspawnv    _wspawnv
#define _tspawnve   _wspawnve
#define _tspawnvp   _wspawnvp
#define _tspawnvp   _wspawnvp
#define _tspawnvpe  _wspawnvpe

#define _tsystem    _wsystem


/* Time functions */

#define _tasctime   _wasctime
#define _tctime     _wctime
#define _tctime64   _wctime64
#define _tstrdate   _wstrdate
#define _tstrtime   _wstrtime
#define _tutime     _wutime
#define _tutime64   _wutime64
#define _tcsftime   wcsftime


/* Directory functions */

#define _tchdir     _wchdir
#define _tgetcwd    _wgetcwd
#define _tgetdcwd   _wgetdcwd
#define _tmkdir     _wmkdir
#define _trmdir     _wrmdir


/* Environment/Path functions */

#define _tfullpath  _wfullpath
#define _tgetenv    _wgetenv
#define _tmakepath  _wmakepath
#define _tpgmptr    _wpgmptr
#define _tputenv    _wputenv
#define _tsearchenv _wsearchenv
#define _tsplitpath _wsplitpath


/* Stdio functions */

#define _tfdopen    _wfdopen
#define _tfsopen    _wfsopen
#define _tfopen     _wfopen
#define _tfreopen   _wfreopen
#define _tperror    _wperror
#define _tpopen     _wpopen
#define _ttempnam   _wtempnam
#define _ttmpnam    _wtmpnam


/* Io functions */

#define _taccess    _waccess
#define _tchmod     _wchmod
#define _tcreat     _wcreat
#define _tfindfirst _wfindfirst
#define _tfindfirst64   _wfindfirst64
#define _tfindfirsti64  _wfindfirsti64
#define _tfindnext  _wfindnext
#define _tfindnext64    _wfindnext64
#define _tfindnexti64   _wfindnexti64
#define _tmktemp    _wmktemp
#define _topen      _wopen
#define _tremove    _wremove
#define _trename    _wrename
#define _tsopen     _wsopen
#define _tunlink    _wunlink

#define _tfinddata_t    _wfinddata_t
#define _tfinddata64_t  __wfinddata64_t
#define _tfinddatai64_t _wfinddatai64_t


/* Stat functions */

#define _tstat      _wstat
#define _tstat64    _wstat64
#define _tstati64   _wstati64


/* Setlocale functions */

#define _tsetlocale _wsetlocale


/* Redundant "logical-character" mappings */

#define _tcsclen    wcslen
#define _tcsnccat   wcsncat
#define _tcsnccpy   wcsncpy
#define _tcsncset   _wcsnset

#define _tcsdec     _wcsdec
#define _tcsinc     _wcsinc
#define _tcsnbcnt   _wcsncnt
#define _tcsnccnt   _wcsncnt
#define _tcsnextc   _wcsnextc
#define _tcsninc    _wcsninc
#define _tcsspnp    _wcsspnp

#define _tcslwr     _wcslwr
#define _tcsupr     _wcsupr
#define _tcsxfrm    wcsxfrm


#if     __STDC__ || defined(_NO_INLINING)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) ((*(_pc1) = *(_cpc2)))
#define _tccmp(_cpc1,_cpc2) ((*(_cpc1))-(*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _tclen(const wchar_t *_cpc) { _cpc; return (1); }
__inline void __cdecl _tccpy(wchar_t *_pc1, const wchar_t *_cpc2) { *_pc1 = (wchar_t)*_cpc2; }
__inline int __cdecl _tccmp(const wchar_t *_cpc1, const wchar_t *_cpc2) { return (int) ((*_cpc1)-(*_cpc2)); }
#endif  /* __STDC__ */


/* ctype functions */

#define _istalnum   iswalnum
#define _istalpha   iswalpha
#define _istascii   iswascii
#define _istcntrl   iswcntrl
#define _istdigit   iswdigit
#define _istgraph   iswgraph
#define _istlower   iswlower
#define _istprint   iswprint
#define _istpunct   iswpunct
#define _istspace   iswspace
#define _istupper   iswupper
#define _istxdigit  iswxdigit

#define _totupper   towupper
#define _totlower   towlower

#define _istlegal(_c)   (1)
#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)


#if     __STDC__ || defined(_NO_INLINING)
#define _wcsdec(_cpc1, _cpc2) ((_cpc1)>=(_cpc2) ? NULL : (_cpc2)-1)
#define _wcsinc(_pc)    ((_pc)+1)
#define _wcsnextc(_cpc) ((unsigned int) *(_cpc))
#define _wcsninc(_pc, _sz) (((_pc)+(_sz)))
#define _wcsncnt(_cpc, _sz) ((wcslen(_cpc)>_sz) ? _sz : wcslen(_cpc))
#define _wcsspnp(_cpc1, _cpc2) ((*((_cpc1)+wcsspn(_cpc1,_cpc2))) ? ((_cpc1)+wcsspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline wchar_t * __cdecl _wcsdec(const wchar_t * _cpc1, const wchar_t * _cpc2) { return (wchar_t *)((_cpc1)>=(_cpc2) ? NULL : ((_cpc2)-1)); }
__inline wchar_t * __cdecl _wcsinc(const wchar_t * _pc) { return (wchar_t *)(_pc+1); }
__inline unsigned int __cdecl _wcsnextc(const wchar_t * _cpc) { return (unsigned int)*_cpc; }
__inline wchar_t * __cdecl _wcsninc(const wchar_t * _pc, size_t _sz) { return (wchar_t *)(_pc+_sz); }
__inline size_t __cdecl _wcsncnt( const wchar_t * _cpc, size_t _sz) { size_t len; len = wcslen(_cpc); return (len>_sz) ? _sz : len; }
__inline wchar_t * __cdecl _wcsspnp( const wchar_t * _cpc1, const wchar_t * _cpc2) { return (*(_cpc1 += wcsspn(_cpc1,_cpc2))!='\0') ? (wchar_t*)_cpc1 : NULL; }
#endif  /* __STDC__ */


#else   /* ndef _UNICODE */

/* ++++++++++++++++++++ SBCS and MBCS ++++++++++++++++++++ */

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#include <string.h>

#ifdef  __cplusplus
extern "C" {
#endif


#define _TEOF       EOF

#define __T(x)      x


/* Program */

#define _tmain      main
#define _tWinMain   WinMain
#ifdef  _POSIX_
#define _tenviron   environ
#else
#define _tenviron  _environ
#endif
#define __targv     __argv


/* Formatted i/o */

#define _tprintf    printf
#define _tcprintf   _cprintf
#define _ftprintf   fprintf
#define _stprintf   sprintf
#define _sctprintf  _scprintf
#define _sntprintf  _snprintf
#define _vtprintf   vprintf
#define _vftprintf  vfprintf
#define _vstprintf  vsprintf
#define _vsctprintf _vscprintf
#define _vsntprintf _vsnprintf
#define _tscanf     scanf
#define _tcscanf    _cscanf
#define _ftscanf    fscanf
#define _stscanf    sscanf
#define _sntscanf   _snscanf


/* Unformatted i/o */

#define _fgettc     fgetc
#define _fgettchar  _fgetchar
#define _fgetts     fgets
#define _fputtc     fputc
#define _fputtchar  _fputchar
#define _fputts     fputs
#define _cputts     _cputs
#define _gettc      getc
#define _gettch     _getch
#define _gettche    _getche
#define _gettchar   getchar
#define _getts      gets
#define _cgetts     _cgets
#define _puttc      putc
#define _puttchar   putchar
#define _puttch     _putch
#define _putts      puts
#define _ungettc    ungetc
#define _ungettch   _ungetch


/* String conversion functions */

#define _tcstod     strtod
#define _tcstol     strtol
#define _tcstoul    strtoul
#define _tstof      atof
#define _tstol      atol
#define _tstoi      atoi
#define _tstoi64    _atoi64

#define _itot       _itoa
#define _ltot       _ltoa
#define _ultot      _ultoa
#define _ttoi       atoi
#define _ttol       atol

#define _ttoi64     _atoi64
#define _tcstoi64   _strtoi64
#define _tcstoui64  _strtoui64
#define _i64tot     _i64toa
#define _ui64tot    _ui64toa

/* String functions */

/* Note that _mbscat, _mbscpy and _mbsdup are functionally equivalent to 
   strcat, strcpy and strdup, respectively. */

#define _tcscat     strcat
#define _tcscpy     strcpy
#define _tcsdup     _strdup

#define _tcslen     strlen
#define _tcsxfrm    strxfrm
#define _tcserror   strerror
#define __tcserror  _strerror


/* Execute functions */

#define _texecl     _execl
#define _texecle    _execle
#define _texeclp    _execlp
#define _texeclpe   _execlpe
#define _texecv     _execv
#define _texecve    _execve
#define _texecvp    _execvp
#define _texecvpe   _execvpe

#define _tspawnl    _spawnl
#define _tspawnle   _spawnle
#define _tspawnlp   _spawnlp
#define _tspawnlpe  _spawnlpe
#define _tspawnv    _spawnv
#define _tspawnve   _spawnve
#define _tspawnvp   _spawnvp
#define _tspawnvpe  _spawnvpe

#define _tsystem    system


/* Time functions */

#define _tasctime   asctime
#define _tctime     ctime
#define _tctime64   _ctime64
#define _tstrdate   _strdate
#define _tstrtime   _strtime
#define _tutime     _utime
#define _tutime64   _utime64
#define _tcsftime   strftime


/* Directory functions */

#define _tchdir     _chdir
#define _tgetcwd    _getcwd
#define _tgetdcwd   _getdcwd
#define _tmkdir     _mkdir
#define _trmdir     _rmdir


/* Environment/Path functions */

#define _tfullpath  _fullpath
#define _tgetenv    getenv
#define _tmakepath  _makepath
#define _tpgmptr    _pgmptr
#define _tputenv    _putenv
#define _tsearchenv _searchenv
#define _tsplitpath _splitpath


/* Stdio functions */

#ifdef  _POSIX_
#define _tfdopen    fdopen
#else
#define _tfdopen    _fdopen
#endif
#define _tfsopen    _fsopen
#define _tfopen     fopen
#define _tfreopen   freopen
#define _tperror    perror
#define _tpopen     _popen
#define _ttempnam   _tempnam
#define _ttmpnam    tmpnam


/* Io functions */

#define _tchmod     _chmod
#define _tcreat     _creat
#define _tfindfirst _findfirst
#define _tfindfirst64   _findfirst64
#define _tfindfirsti64  _findfirsti64
#define _tfindnext  _findnext
#define _tfindnext64    _findnext64
#define _tfindnexti64   _findnexti64
#define _tmktemp    _mktemp

#ifdef  _POSIX_
#define _topen      open
#define _taccess    access
#else
#define _topen      _open
#define _taccess    _access
#endif

#define _tremove    remove
#define _trename    rename
#define _tsopen     _sopen
#define _tunlink    _unlink

#define _tfinddata_t    _finddata_t
#define _tfinddata64_t  __finddata64_t
#define _tfinddatai64_t _finddatai64_t


/* ctype functions */

#define _istascii   isascii
#define _istcntrl   iscntrl
#define _istxdigit  isxdigit


/* Stat functions */

#define _tstat      _stat
#define _tstat64    _stat64
#define _tstati64   _stati64


/* Setlocale functions */

#define _tsetlocale setlocale


#ifdef  _MBCS

/* ++++++++++++++++++++ MBCS ++++++++++++++++++++ */

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#include <mbstring.h>

#ifdef  __cplusplus
extern "C" {
#endif


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef unsigned char   _TXCHAR;
typedef unsigned int    _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


#ifdef  _MB_MAP_DIRECT

/* use mb functions directly - types must match */

/* String functions */

#define _tcschr     _mbschr
#define _tcscspn    _mbscspn
#define _tcsncat    _mbsnbcat
#define _tcsncpy    _mbsnbcpy
#define _tcspbrk    _mbspbrk
#define _tcsrchr    _mbsrchr
#define _tcsspn     _mbsspn
#define _tcsstr     _mbsstr
#define _tcstok     _mbstok

#define _tcsnset    _mbsnbset
#define _tcsrev     _mbsrev
#define _tcsset     _mbsset

#define _tcscmp     _mbscmp
#define _tcsicmp    _mbsicmp
#define _tcsnccmp   _mbsncmp
#define _tcsncmp    _mbsnbcmp
#define _tcsncicmp  _mbsnicmp
#define _tcsnicmp   _mbsnbicmp

#define _tcscoll    _mbscoll
#define _tcsicoll   _mbsicoll
#define _tcsnccoll  _mbsncoll
#define _tcsncoll   _mbsnbcoll
#define _tcsncicoll _mbsnicoll
#define _tcsnicoll  _mbsnbicoll


/* "logical-character" mappings */

#define _tcsclen    _mbslen
#define _tcsnccat   _mbsncat
#define _tcsnccpy   _mbsncpy
#define _tcsncset   _mbsnset


/* MBCS-specific mappings */

#define _tcsdec     _mbsdec
#define _tcsinc     _mbsinc
#define _tcsnbcnt   _mbsnbcnt
#define _tcsnccnt   _mbsnccnt
#define _tcsnextc   _mbsnextc
#define _tcsninc    _mbsninc
#define _tcsspnp    _mbsspnp

#define _tcslwr     _mbslwr
#define _tcsupr     _mbsupr

#define _tclen      _mbclen
#define _tccpy      _mbccpy

#define _tccmp(_cpuc1,_cpuc2)   _tcsnccmp(_cpuc1,_cpuc2,1)


#else /* _MB_MAP_DIRECT */

#if     __STDC__ || defined(_NO_INLINING)

/* use type-safe linked-in function thunks */

/* String functions */

_CRTIMP char * __cdecl _tcschr(const char *, unsigned int);
_CRTIMP size_t __cdecl _tcscspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsncat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcspbrk(const char *, const char *);
_CRTIMP char * __cdecl _tcsrchr(const char *, int);
_CRTIMP size_t __cdecl _tcsspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsstr(const char *, const char *);
_CRTIMP char * __cdecl _tcstok(char *, const char *);

_CRTIMP char * __cdecl _tcsnset(char *, unsigned int, size_t);
_CRTIMP char * __cdecl _tcsrev(char *);
_CRTIMP char * __cdecl _tcsset(char *, unsigned int);

_CRTIMP int __cdecl _tcscmp(const char *, const char *);
_CRTIMP int __cdecl _tcsicmp(const char *, const char *);
_CRTIMP int __cdecl _tcsnccmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnicmp(const char *, const char *, size_t);

_CRTIMP int __cdecl _tcscoll(const char *, const char *);
_CRTIMP int __cdecl _tcsicoll(const char *, const char *);
_CRTIMP int __cdecl _tcsnccoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnicoll(const char *, const char *, size_t);


/* "logical-character" mappings */

_CRTIMP size_t __cdecl _tcsclen(const char *);
_CRTIMP char * __cdecl _tcsnccat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsnccpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncset(char *, unsigned int, size_t);


/* MBCS-specific mappings */

_CRTIMP char * __cdecl _tcsdec(const char *, const char *);
_CRTIMP char * __cdecl _tcsinc(const char *);
_CRTIMP size_t __cdecl _tcsnbcnt(const char *, size_t);
_CRTIMP size_t __cdecl _tcsnccnt(const char *, size_t);
_CRTIMP unsigned int __cdecl _tcsnextc (const char *);
_CRTIMP char * __cdecl _tcsninc(const char *, size_t);
_CRTIMP char * __cdecl _tcsspnp(const char *, const char *);

_CRTIMP char * __cdecl _tcslwr(char *);
_CRTIMP char * __cdecl _tcsupr(char *);

_CRTIMP size_t __cdecl _tclen(const char *);
_CRTIMP void __cdecl _tccpy(char *, const char *);


#else   /* __STDC__ */

/* the default: use type-safe inline function thunks */

#define _PUC    unsigned char *
#define _CPUC   const unsigned char *
#define _PC     char *
#define _CPC    const char *
#define _UI     unsigned int


/* String functions */

__inline _PC _tcschr(_CPC _s1,_UI _c) {return (_PC)_mbschr((_CPUC)_s1,_c);}
__inline size_t _tcscspn(_CPC _s1,_CPC _s2) {return _mbscspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsncat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcspbrk(_CPC _s1,_CPC _s2) {return (_PC)_mbspbrk((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsrchr(_CPC _s1,_UI _c) {return (_PC)_mbsrchr((_CPUC)_s1,_c);}
__inline size_t _tcsspn(_CPC _s1,_CPC _s2) {return _mbsspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsstr(_CPC _s1,_CPC _s2) {return (_PC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcstok(_PC _s1,_CPC _s2) {return (_PC)_mbstok((_PUC)_s1,(_CPUC)_s2);}

__inline _PC _tcsnset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnbset((_PUC)_s1,_c,_n);}
__inline _PC _tcsrev(_PC _s1) {return (_PC)_mbsrev((_PUC)_s1);}
__inline _PC _tcsset(_PC _s1,_UI _c) {return (_PC)_mbsset((_PUC)_s1,_c);}

__inline int _tcscmp(_CPC _s1,_CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsicmp(_CPC _s1,_CPC _s2) {return _mbsicmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnccmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicmp((_CPUC)_s1,(_CPUC)_s2,_n);}

__inline int _tcscoll(_CPC _s1,_CPC _s2) {return _mbscoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsicoll(_CPC _s1,_CPC _s2) {return _mbsicoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnccoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicoll((_CPUC)_s1,(_CPUC)_s2,_n);}


/* "logical-character" mappings */

__inline size_t _tcsclen(_CPC _s1) {return _mbslen((_CPUC)_s1);}
__inline _PC _tcsnccat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsnccpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnset((_PUC)_s1,_c,_n);}


/* MBCS-specific mappings */

__inline _PC _tcsdec(_CPC _s1,_CPC _s2) {return (_PC)_mbsdec((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsinc(_CPC _s1) {return (_PC)_mbsinc((_CPUC)_s1);}
__inline size_t _tcsnbcnt(_CPC _s1,size_t _n) {return _mbsnbcnt((_CPUC)_s1,_n);}
__inline size_t _tcsnccnt(_CPC _s1,size_t _n) {return _mbsnccnt((_CPUC)_s1,_n);}
__inline _PC _tcsninc(_CPC _s1,size_t _n) {return (_PC)_mbsninc((_CPUC)_s1,_n);}
__inline _PC _tcsspnp(_CPC _s1,_CPC _s2) {return (_PC)_mbsspnp((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcslwr(_PC _s1) {return (_PC)_mbslwr((_PUC)_s1);}
__inline _PC _tcsupr(_PC _s1) {return (_PC)_mbsupr((_PUC)_s1);}

__inline size_t _tclen(_CPC _s1) {return _mbclen((_CPUC)_s1);}
__inline void _tccpy(_PC _s1,_CPC _s2) {_mbccpy((_PUC)_s1,(_CPUC)_s2); return;}


/* inline helper */
__inline _UI _tcsnextc(_CPC _s1) {_UI _n=0; if (_ismbblead((_UI)*(_PUC)_s1)) {_n=((_UI)*(_PUC)_s1)<<8; _s1++;} _n+=(_UI)*(_PUC)_s1; return(_n);}


#endif  /* __STDC__ */

#endif  /* _MB_MAP_DIRECT */


/* MBCS-specific mappings */

#define _tccmp(_cp1,_cp2)   _tcsnccmp(_cp1,_cp2,1)


/* ctype functions */

#define _istalnum   _ismbcalnum
#define _istalpha   _ismbcalpha
#define _istdigit   _ismbcdigit
#define _istgraph   _ismbcgraph
#define _istlegal   _ismbclegal
#define _istlower   _ismbclower
#define _istprint   _ismbcprint
#define _istpunct   _ismbcpunct
#define _istspace   _ismbcspace
#define _istupper   _ismbcupper

#define _totupper   _mbctoupper
#define _totlower   _mbctolower

#define _istlead    _ismbblead
#define _istleadbyte    isleadbyte

#else   /* !_MBCS */

/* ++++++++++++++++++++ SBCS ++++++++++++++++++++ */


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef char            _TXCHAR;
typedef int             _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


/* String functions */

#define _tcschr     strchr
#define _tcscspn    strcspn
#define _tcsncat    strncat
#define _tcsncpy    strncpy
#define _tcspbrk    strpbrk
#define _tcsrchr    strrchr
#define _tcsspn     strspn
#define _tcsstr     strstr
#define _tcstok     strtok

#define _tcsnset    _strnset
#define _tcsrev     _strrev
#define _tcsset     _strset

#define _tcscmp     strcmp
#define _tcsicmp    _stricmp
#define _tcsnccmp   strncmp
#define _tcsncmp    strncmp
#define _tcsncicmp  _strnicmp
#define _tcsnicmp   _strnicmp

#define _tcscoll    strcoll
#define _tcsicoll   _stricoll
#define _tcsnccoll  _strncoll
#define _tcsncoll   _strncoll
#define _tcsncicoll _strnicoll
#define _tcsnicoll  _strnicoll


/* "logical-character" mappings */

#define _tcsclen    strlen
#define _tcsnccat   strncat
#define _tcsnccpy   strncpy
#define _tcsncset   _strnset


/* MBCS-specific functions */

#define _tcsdec     _strdec
#define _tcsinc     _strinc
#define _tcsnbcnt   _strncnt
#define _tcsnccnt   _strncnt
#define _tcsnextc   _strnextc
#define _tcsninc    _strninc
#define _tcsspnp    _strspnp

#define _tcslwr     _strlwr
#define _tcsupr     _strupr
#define _tcsxfrm    strxfrm

#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)

#if     __STDC__ || defined(_NO_INLINING)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) (*(_pc1) = *(_cpc2))
#define _tccmp(_cpc1,_cpc2) (((unsigned char)*(_cpc1))-((unsigned char)*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _tclen(const char *_cpc) { _cpc; return (1); }
__inline void __cdecl _tccpy(char *_pc1, const char *_cpc2) { *_pc1 = *_cpc2; }
__inline int __cdecl _tccmp(const char *_cpc1, const char *_cpc2) { return (int) (((unsigned char)*_cpc1)-((unsigned char)*_cpc2)); }
#endif  /* __STDC__ */


/* ctype-functions */

#define _istalnum   isalnum
#define _istalpha   isalpha
#define _istdigit   isdigit
#define _istgraph   isgraph
#define _istlower   islower
#define _istprint   isprint
#define _istpunct   ispunct
#define _istspace   isspace
#define _istupper   isupper

#define _totupper   toupper
#define _totlower   tolower

#define _istlegal(_c)   (1)


/* the following is optional if functional versions are available */

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#if     __STDC__ || defined(_NO_INLINING)
#define _strdec(_cpc1, _cpc2) ((_cpc1)>=(_cpc2) ? NULL : (_cpc2)-1)
#define _strinc(_pc)    ((_pc)+1)
#define _strnextc(_cpc) ((unsigned int) *(const unsigned char *)(_cpc))
#define _strninc(_pc, _sz) (((_pc)+(_sz)))
#define _strncnt(_cpc, _sz) ((strlen(_cpc)>_sz) ? _sz : strlen(_cpc))
#define _strspnp(_cpc1, _cpc2) ((*((_cpc1)+strspn(_cpc1,_cpc2))) ? ((_cpc1)+strspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline char * __cdecl _strdec(const char * _cpc1, const char * _cpc2) { return (char *)((_cpc1)>=(_cpc2) ? NULL : (_cpc2-1)); }
__inline char * __cdecl _strinc(const char * _pc) { return (char *)(_pc+1); }
__inline unsigned int __cdecl _strnextc(const char * _cpc) { return (unsigned int)*(const unsigned char *)_cpc; }
__inline char * __cdecl _strninc(const char * _pc, size_t _sz) { return (char *)(_pc+_sz); }
__inline size_t __cdecl _strncnt( const char * _cpc, size_t _sz) { size_t len; len = strlen(_cpc); return (len>_sz) ? _sz : len; }
__inline char * __cdecl _strspnp( const char * _cpc1, const char * _cpc2) { return (*(_cpc1 += strspn(_cpc1,_cpc2))!='\0') ? (char*)_cpc1 : NULL; }
#endif  /* __STDC__ */


#endif  /* _MBCS */

#endif  /* _UNICODE */


/* Generic text macros to be used with string literals and character constants.
   Will also allow symbolic constants that resolve to same. */

#define _T(x)       __T(x)
#define _TEXT(x)    __T(x)


#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#endif  /* _INC_TCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STRING
#define _INC_STRING

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647  /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Function prototypes */

        void *  __cdecl memcpy(void *, const void *, size_t);
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);
        char *  __cdecl _strset(char *, int);
        char *  __cdecl strcpy(char *, const char *);
        char *  __cdecl strcat(char *, const char *);
        int     __cdecl strcmp(const char *, const char *);
        size_t  __cdecl strlen(const char *);
_CRTIMP void *  __cdecl _memccpy(void *, const void *, int, size_t);
_CRTIMP void *  __cdecl memchr(const void *, int, size_t);
_CRTIMP int     __cdecl _memicmp(const void *, const void *, size_t);

#if     defined(_M_IA64)
        void *  __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void *  __cdecl memmove(void *, const void *, size_t);
#endif


_CRTIMP char *  __cdecl strchr(const char *, int);
_CRTIMP int     __cdecl _strcmpi(const char *, const char *);
_CRTIMP int     __cdecl _stricmp(const char *, const char *);
_CRTIMP int     __cdecl strcoll(const char *, const char *);
_CRTIMP int     __cdecl _stricoll(const char *, const char *);
_CRTIMP int     __cdecl _strncoll(const char *, const char *, size_t);
_CRTIMP int     __cdecl _strnicoll(const char *, const char *, size_t);
_CRTIMP size_t  __cdecl strcspn(const char *, const char *);
_CRTIMP char *  __cdecl _strdup(const char *);
_CRTIMP char *  __cdecl _strerror(const char *);
_CRTIMP char *  __cdecl strerror(int);
_CRTIMP char *  __cdecl _strlwr(char *);
_CRTIMP char *  __cdecl strncat(char *, const char *, size_t);
_CRTIMP int     __cdecl strncmp(const char *, const char *, size_t);
_CRTIMP int     __cdecl _strnicmp(const char *, const char *, size_t);
_CRTIMP char *  __cdecl strncpy(char *, const char *, size_t);
_CRTIMP char *  __cdecl _strnset(char *, int, size_t);
_CRTIMP char *  __cdecl strpbrk(const char *, const char *);
_CRTIMP char *  __cdecl strrchr(const char *, int);
_CRTIMP char *  __cdecl _strrev(char *);
_CRTIMP size_t  __cdecl strspn(const char *, const char *);
_CRTIMP char *  __cdecl strstr(const char *, const char *);
_CRTIMP char *  __cdecl strtok(char *, const char *);
_CRTIMP char *  __cdecl _strupr(char *);
_CRTIMP size_t  __cdecl strxfrm (char *, const char *, size_t);


#if     !__STDC__

/* prototypes for oldnames.lib functions */
_CRTIMP void * __cdecl memccpy(void *, const void *, int, size_t);
_CRTIMP int __cdecl memicmp(const void *, const void *, size_t);
_CRTIMP int __cdecl strcmpi(const char *, const char *);
_CRTIMP int __cdecl stricmp(const char *, const char *);
_CRTIMP char * __cdecl strdup(const char *);
_CRTIMP char * __cdecl strlwr(char *);
_CRTIMP int __cdecl strnicmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl strnset(char *, int, size_t);
_CRTIMP char * __cdecl strrev(char *);
        char * __cdecl strset(char *, int);
_CRTIMP char * __cdecl strupr(char *);

#endif  /* !__STDC__ */


#ifndef _WSTRING_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcserror(int);
_CRTIMP wchar_t * __cdecl __wcserror(const wchar_t *);

_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);

_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if     !__STDC__

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif  /* !__STDC__ */

#define _WSTRING_DEFINED
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\typeinfo.h ===
/***
*typeinfo.h - Defines the type_info structure and exceptions used for RTTI
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the type_info structure and exceptions used for
*       Runtime Type Identification.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef __cplusplus
#error This header requires a C++ compiler ...
#endif

#ifndef _INC_TYPEINFO
#define _INC_TYPEINFO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

class type_info {
public:
    _CRTIMP virtual ~type_info();
    _CRTIMP int operator==(const type_info& rhs) const;
    _CRTIMP int operator!=(const type_info& rhs) const;
    _CRTIMP int before(const type_info& rhs) const;
    _CRTIMP const char* name() const;
    _CRTIMP const char* raw_name() const;
private:
    void *_m_data;
    char _m_d_name[1];
    type_info(const type_info& rhs);
    type_info& operator=(const type_info& rhs);
};


// This include must occur below the definition of class type_info
#include <stdexcpt.h>

class _CRTIMP bad_cast : public exception {
public:
    bad_cast(const char * _Message = "bad cast");
    bad_cast(const bad_cast &);
    virtual ~bad_cast();
};

class _CRTIMP bad_typeid : public exception {
public:
    bad_typeid(const char * _Message = "bad typeid");
    bad_typeid(const bad_typeid &);
    virtual ~bad_typeid();
};

class _CRTIMP __non_rtti_object : public bad_typeid {
public:
    __non_rtti_object(const char * _Message);
    __non_rtti_object(const __non_rtti_object &);
    virtual ~__non_rtti_object();
};

#ifdef  __RTTI_OLDNAMES
// Some synonyms for folks using older standard
typedef type_info Type_info;
typedef bad_cast Bad_cast;
typedef bad_typeid Bad_typeid;
#endif  // __RTTI_OLDNAMES


#endif  // _INC_TYPEINFO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has declarations of time routines and defines
*       the structure returned by the localtime and gmtime routines and
*       used by asctime.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIME
#define _INC_TIME

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* Define the implementation defined time type */

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif


/* Clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC  1000


/* Extern declarations for the global variables used by the ctime family of
 * routines.
 */

/* non-zero if daylight savings time is used */
_CRTIMP extern int _daylight;

/* offset for Daylight Saving Time */
_CRTIMP extern long _dstbias;

/* difference in seconds between GMT and local time */
_CRTIMP extern long _timezone;

/* standard/daylight savings time zone names */
_CRTIMP extern char * _tzname[2];


/* Function prototypes */

_CRTIMP char * __cdecl asctime(const struct tm *);
_CRTIMP char * __cdecl ctime(const time_t *);
_CRTIMP clock_t __cdecl clock(void);
_CRTIMP double __cdecl difftime(time_t, time_t);
_CRTIMP struct tm * __cdecl gmtime(const time_t *);
_CRTIMP struct tm * __cdecl localtime(const time_t *);
_CRTIMP time_t __cdecl mktime(struct tm *);
_CRTIMP time_t __cdecl _mkgmtime(struct tm *);
_CRTIMP size_t __cdecl strftime(char *, size_t, const char *,
        const struct tm *);
_CRTIMP char * __cdecl _strdate(char *);
_CRTIMP char * __cdecl _strtime(char *);
_CRTIMP time_t __cdecl time(time_t *);

#ifdef  _POSIX_
_CRTIMP void __cdecl tzset(void);
#else
_CRTIMP void __cdecl _tzset(void);
#endif

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP char * __cdecl _ctime64(const __time64_t *);
_CRTIMP struct tm * __cdecl _gmtime64(const __time64_t *);
_CRTIMP struct tm * __cdecl _localtime64(const __time64_t *);
_CRTIMP __time64_t __cdecl _mktime64(struct tm *);
_CRTIMP __time64_t __cdecl _mkgmtime64(struct tm *);
_CRTIMP __time64_t __cdecl _time64(__time64_t *);
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API GetLocalTime and SetLocalTime should be used instead. */
unsigned __cdecl _getsystime(struct tm *);
unsigned __cdecl _setsystime(struct tm *, unsigned);
/* --------- The preceding functions are OBSOLETE --------- */


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* wide function prototypes, also declared in wchar.h */
 
_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _wctime64(const __time64_t *);
#endif

#define _WTIME_DEFINED
#endif


#if     !__STDC__ || defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define CLK_TCK  CLOCKS_PER_SEC

_CRTIMP extern int daylight;
_CRTIMP extern long timezone;
_CRTIMP extern char * tzname[2];

_CRTIMP void __cdecl tzset(void);

#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\strstrea.h ===
/***
*strstrea.h - definitions/declarations for strstreambuf, strstream
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the strstream and strstreambuf classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STRSTREAM
#define _INC_STRSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER

// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <useoldio.h>
#include <iostream.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

class _CRTIMP strstreambuf : public streambuf  {
public:
                strstreambuf();
                strstreambuf(int);
                strstreambuf(char *, int, char * = 0);
                strstreambuf(unsigned char *, int, unsigned char * = 0);
                strstreambuf(signed char *, int, signed char * = 0);
                strstreambuf(void * (*a)(long), void (*f) (void *));
                ~strstreambuf();

        void    freeze(int =1);
        char * str();

virtual int     overflow(int);
virtual int     underflow();
virtual streambuf* setbuf(char *, int);
virtual streampos seekoff(streamoff, ios::seek_dir, int);
virtual int     sync();         // not in spec.

protected:
virtual int     doallocate();
private:
        int     x_dynamic;
        int     x_bufmin;
        int     _fAlloc;
        int     x_static;
        void * (* x_alloc)(long);
        void    (* x_free)(void *);
};

class _CRTIMP istrstream : public istream {
public:
                istrstream(char *);
                istrstream(char *, int);
                ~istrstream();

inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char * str() { return rdbuf()->str(); }
};

class _CRTIMP ostrstream : public ostream {
public:
                ostrstream();
                ostrstream(char *, int, int = ios::out);
                ~ostrstream();

inline  int     pcount() const { return rdbuf()->out_waiting(); }
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char *  str() { return rdbuf()->str(); }
};

class _CRTIMP strstream : public iostream {    // strstreambase ???
public:
                strstream();
                strstream(char *, int, int);
                ~strstream();

inline  int     pcount() const { return rdbuf()->out_waiting(); } // not in spec.
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ostream::rdbuf(); }
inline  char * str() { return rdbuf()->str(); }
};

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STRSTREAM

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\useoldio.h ===
/***
*useoldio.h - force the use of the Microsoft "classic" iostream libraries.
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Generates default library directives for the old ("classic") IOSTREAM
*       libraries.  The exact name of the library specified in the directive
*       depends on the compiler switches (-ML, -MT, -MD, -MLd, -MTd, and -MDd).
*
*       This header file is only included by other header files.
*
*       [Public]
*
****/

#ifndef _USE_OLD_IOSTREAMS
#define _USE_OLD_IOSTREAMS
#if defined(DEPRECATE_IOSTREAMS)
/*
 * Warning C4995, '_OLD_IOSTREAMS_ARE_DEPRECATED' is a deprecated name, is 
 * being issued because the old I/O Streams headers iostreams.h et al will no
 * longer be supported from VC8.  Replace references such as #include 
 * <iostreams.h> with #include <iostreams>, using the new, more conformant, I/O
 * Streams headers.
 */

#pragma deprecated(_OLD_IOSTREAMS_ARE_DEPRECATED)
extern void _OLD_IOSTREAMS_ARE_DEPRECATED();
#endif  /* DEPRECATE_IOSTREAMS */
#ifdef  _MT
#ifdef  _DLL
#ifdef  _DEBUG
#pragma comment(lib,"msvcirtd")
#else   /* _DEBUG */
#pragma comment(lib,"msvcirt")
#endif  /* _DEBUG */

#else   /* _DLL */
#ifdef  _DEBUG
#pragma comment(lib,"libcimtd")
#else   /* _DEBUG */
#pragma comment(lib,"libcimt")
#endif  /* _DEBUG */
#endif  /* _DLL */

#else   /* _MT */
#ifdef  _DEBUG
#pragma comment(lib,"libcid")
#else   /* _DEBUG */
#pragma comment(lib,"libci")
#endif  /* _DEBUG */
#endif

#endif  /* _USE_OLD_IOSTREAMS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines XENIX style macros for accessing arguments of a
*       function which takes a variable number of arguments.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_VARARGS
#define _INC_VARARGS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#if     __STDC__
#error varargs.h incompatible with ANSI (use stdarg.h)
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED

typedef char *va_list;

#define _VA_LIST_DEFINED
#endif


#if     defined(_M_CEE)

#error varargs.h not supported when targetting _M_CEE (use stdarg.h)

#elif   defined(_M_IX86)

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */
#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#elif defined(_M_IA64)

#ifndef _VA_LIST
#define _VA_LIST char*
#endif
typedef _VA_LIST va_list;

#define _VA_STRUCT_ALIGN  16 

#define _VA_ALIGN       8

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) \
                            - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#define va_dcl __int64  va_alist;

#define va_start(ap)    ( ap = (va_list)&va_alist )

#define va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) \
                                                     -_SLOTSIZEOF(t)))

#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_AMD64)

extern void __cdecl __va_start(va_list *, ...);

#define va_dcl          va_list va_alist;
#define va_start(ap, x) ( __va_start(&ap, x) )
#define va_arg(ap, t)   \
    ( ( sizeof(t) > sizeof(__int64) || ( sizeof(t) & (sizeof(t) - 1) ) != 0 ) \
        ? **(t **)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) \
        :  *(t  *)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) )
#define va_end(ap)      ( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


#endif


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_VARARGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\xmath.h ===
/* xmath.h internal header for Microsoft C */
#ifndef _XMATH
#define _XMATH
#include <wctype.h>
#include <errno.h>
#include <math.h>
#include <stddef.h>
#ifndef _YMATH
 #include <ymath.h>
#endif
_STD_BEGIN
		/* FLOAT PROPERTIES */
#define _DBIAS	0x3fe
#define _DOFF	4
#define _FBIAS	0x7e
#define _FOFF	7
#define _FRND	1
 #define _D0	3	/* little-endian, small long doubles */
 #define _D1	2
 #define _D2	1
 #define _D3	0
 #define _DLONG	0
 #define _LBIAS	0x3fe
 #define _LOFF	4
		/* IEEE 754 double properties */
#define _DFRAC	((1 << _DOFF) - 1)
#define _DMASK	(0x7fff & ~_DFRAC)
#define _DMAX	((1 << (15 - _DOFF)) - 1)
#define _DSIGN	0x8000
#define DSIGN(x)	(((unsigned short *)&(x))[_D0] & _DSIGN)
#define HUGE_EXP	(int)(_DMAX * 900L / 1000)
#define HUGE_RAD	3.37e9	/* ~pi * 2^30 */
#define SAFE_EXP	(_DMAX >> 1)
		/* IEEE 754 float properties */
#define _FFRAC	((1 << _FOFF) - 1)
#define _FMASK	(0x7fff & ~_FFRAC)
#define _FMAX	((1 << (15 - _FOFF)) - 1)
#define _FSIGN	0x8000
#define FSIGN(x)	(((unsigned short *)&(x))[_F0] & _FSIGN)
#define FHUGE_EXP	(int)(_FMAX * 900L / 1000)
#define FHUGE_RAD	3.37e9	/* ~pi * 2^30 */
#define FSAFE_EXP	(_FMAX >> 1)
 #define _F0	1	/* little-endian order */
 #define _F1	0
		/* IEEE 754 long double properties */
#define _LFRAC	(-1)
#define _LMASK	0x7fff
#define _LMAX	0x7fff
#define _LSIGN	0x8000
#define LSIGN(x)	(((unsigned short *)&(x))[_L0] & _LSIGN)
#define LHUGE_EXP	(int)(_LMAX * 900L / 1000)
#define LHUGE_RAD	3.37e9	/* ~pi * 2^30 */
#define LSAFE_EXP	(_LMAX >> 1)
 #define _L0	4	/* little-endian order */
 #define _L1	3
 #define _L2	2
 #define _L3	1
 #define _L4	0
		/* return values for testing functions */
#define FINITE	_FINITE
#define INF		_INFCODE
#define NAN		_NANCODE
_C_LIB_DECL
		/* double declarations */
_CRTIMP double _Atan(double, unsigned short);
_CRTIMP short _Dint(double *, short);
_CRTIMP short _Dnorm(unsigned short *);
_CRTIMP short _Dscale(double *, long);
_CRTIMP double _Dtento(double, long);
_CRTIMP short _Dunscale(short *, double *);
_CRTIMP double _Poly(double, const double *, int);
extern _CRTIMP const _Dconst _Eps, _Rteps;
extern _CRTIMP const double _Xbig;
		/* float declarations */
_CRTIMP float _FAtan(float, unsigned short);
_CRTIMP short _FDint(float *, short);
_CRTIMP short _FDnorm(unsigned short *);
_CRTIMP short _FDscale(float *, long);
_CRTIMP float _FDtento(float, long);
_CRTIMP short _FDunscale(short *, float *);
_CRTIMP float _FPoly(float, const float *, int);
extern _CRTIMP const _Dconst _FEps, _FRteps;
extern _CRTIMP const float _FXbig;
		/* long double functions */
_CRTIMP long double _LAtan(long double, unsigned short);
_CRTIMP short _LDint(long double *, short);
_CRTIMP short _LDnorm(unsigned short *);
_CRTIMP short _LDscale(long double *, long);
_CRTIMP long double _LDtento(long double, long);
_CRTIMP short _LDunscale(short *, long double *);
_CRTIMP long double _LPoly(long double, const long double *, int);
extern _CRTIMP const _Dconst _LEps, _LRteps;
extern _CRTIMP const long double _LXbig;
_END_C_LIB_DECL
_STD_END
#endif /* _XMATH */

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\wchar.h ===
/***
*wchar.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all wide character-related functions.  They may also be declared in
*       individual header files on a functional basis.
*       [ISO]
*
*       Note: keep in sync with ctype.h, stdio.h, stdlib.h, string.h, time.h.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif


#ifndef _INC_WCHAR
#define _INC_WCHAR



#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP */
#ifndef _CRTIMP
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#define WCHAR_MIN       0
#define WCHAR_MAX       ((wchar_t)-1)

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
typedef char *  va_list;
#define _VA_LIST_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
_CRTIMP extern FILE _iob[];
#endif  /* _STDIO_DEFINED */

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned attrib;
        time_t   time_create;   /* -1 for FAT file systems */
        time_t   time_access;   /* -1 for FAT file systems */
        time_t   time_write;
        _fsize_t size;
        wchar_t  name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _wfinddatai64_t {
        unsigned attrib;
        time_t   time_create;   /* -1 for FAT file systems */
        time_t   time_access;   /* -1 for FAT file systems */
        time_t   time_write;
        __int64  size;
        wchar_t  name[260];
};

struct __wfinddata64_t {
        unsigned attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
#ifndef __PCTYPE_FUNC
#ifdef _MT
#define __PCTYPE_FUNC   __pctype_func()
#else
#define __PCTYPE_FUNC  _pctype
#endif  /* _MT */
#endif  /* __PCTYPE_FUNC */
_CRTIMP const unsigned short * __cdecl __pctype_func(void);
_CRTIMP const wctype_t * __cdecl __pwctype_func(void);
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#endif  /* _CTYPE_DISABLE_MACROS */


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WDIRECT_DEFINED

/* also declared in direct.h */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif

#ifndef _WIO_DEFINED

/* also declared in io.h */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP intptr_t __cdecl _wfindfirsti64(wchar_t *, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifndef _WPROCESS_DEFINED

/* also declared in process.h */

_CRTIMP intptr_t __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#ifndef _CTYPE_DISABLE_MACROS
#define isleadbyte(_c)  ( __PCTYPE_FUNC[(unsigned char)(_c)] & _LEADBYTE)
#endif  /* _CTYPE_DISABLE_MACROS */

#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

#ifndef _CTYPE_DISABLE_MACROS
inline int __cdecl isleadbyte(int _C)
        {return (__PCTYPE_FUNC[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* _CTYPE_DISABLE_MACROS */
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */


#ifndef _POSIX_

/* define structure for returning status information */

#ifndef _INO_T_DEFINED
typedef unsigned short _ino_t;      /* i-node number (not used on DOS) */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif
#define _INO_T_DEFINED
#endif

#ifndef _DEV_T_DEFINED
typedef unsigned int _dev_t;        /* device code */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif
#define _DEV_T_DEFINED
#endif

#ifndef _OFF_T_DEFINED
typedef long _off_t;                /* file offset value */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif
#define _OFF_T_DEFINED
#endif

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__
/* Non-ANSI names for compatibility */
struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };
#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64

struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

struct __stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

#endif

#define _STAT_DEFINED
#endif


#ifndef _WSTAT_DEFINED

/* also declared in stat.h */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
_CRTIMP int __cdecl _wstat64(const wchar_t *, struct __stat64 *);
#endif

#define _WSTAT_DEFINED
#endif

#endif  /* !_POSIX_ */


#ifndef _WCONIO_DEFINED

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);


#define _WCONIO_DEFINED
#endif

#ifndef _WSTDIO_DEFINED

/* also declared in stdio.h */

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wchar_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wchar_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);
_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);
_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _scwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl _vscwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _snwscanf(const wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#ifndef __cplusplus
#define getwchar()      fgetwc(stdin)
#define putwchar(_c)    fputwc((_c),stdout)
#else   /* __cplusplus */
inline wint_t __cdecl getwchar()
        {return (fgetwc(&_iob[0])); }   /* stdin */
inline wint_t __cdecl putwchar(wchar_t _C)
        {return (fputwc(_C, &_iob[1])); }       /* stdout */
#endif  /* __cplusplus */

#define getwc(_stm)     fgetwc(_stm)
#define putwc(_c,_stm)  fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif


#ifndef _WSTDLIB_DEFINED

/* also declared in stdlib.h */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP double __cdecl _wtof(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);
_CRTIMP __int64   __cdecl _wcstoi64(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned __int64  __cdecl _wcstoui64(const wchar_t *, wchar_t **, int);
#endif

#define _WSTDLIB_DEFINED
#endif

#ifndef _POSIX_

#ifndef _WSTDLIBP_DEFINED

/* also declared in stdlib.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

#endif  /* _POSIX_ */


#ifndef _WSTRING_DEFINED

/* also declared in string.h */

#ifdef  __cplusplus
        #define _WConst_return  const
#else
        #define _WConst_return
#endif

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP _WConst_return wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcserror(int);
_CRTIMP wchar_t * __cdecl __wcserror(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if     !__STDC__

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif  /* !__STDC__ */

#ifdef  __cplusplus
}       /* end of extern "C" */

extern "C++" {
inline wchar_t *wcschr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcschr((const wchar_t *)_S, _C)); }
inline wchar_t *wcspbrk(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_S, _P)); }
inline wchar_t *wcsrchr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_S, _C)); }
inline wchar_t *wcsstr(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcsstr((const wchar_t *)_S, _P)); }
}

extern "C" {
#endif  /* __cplusplus */

#define _WSTRING_DEFINED
#endif

#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* also declared in time.h */

_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _wctime64(const __time64_t *);
#endif

#define _WTIME_DEFINED
#endif



typedef int mbstate_t;
typedef wchar_t _Wint_t;

_CRTIMP wint_t __cdecl btowc(int);
_CRTIMP size_t __cdecl mbrlen(const char *, size_t, mbstate_t *);
_CRTIMP size_t __cdecl mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
_CRTIMP size_t __cdecl mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);

_CRTIMP size_t __cdecl wcrtomb(char *, wchar_t, mbstate_t *);
_CRTIMP size_t __cdecl wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
_CRTIMP int __cdecl wctob(wint_t);

#ifdef  __cplusplus

/* memcpy and memmove are defined just for use in wmemcpy and wmemmove */
#if     defined(_M_IA64)
void *  __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void *  __cdecl memmove(void *, const void *, size_t);
#endif
void *  __cdecl memcpy(void *, const void *, size_t);

inline int fwide(FILE *, int _M)
        {return (_M); }
inline int mbsinit(const mbstate_t *_P)
        {return (_P == NULL || *_P == 0); }
inline const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (_S);
        return (0); }
inline int wmemcmp(const wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }
inline wchar_t *wmemcpy(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemmove(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemset(wchar_t *_S, wchar_t _C, size_t _N)
        {wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
                *_Su = _C;
        return (_S); }
}       /* end of extern "C" */

extern "C++" {
inline wchar_t *wmemchr(wchar_t *_S, wchar_t _C, size_t _N)
        {return ((wchar_t *)wmemchr((const wchar_t *)_S, _C, _N)); }
}

#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\ymath.h ===
/* ymath.h internal header */
#ifndef _YMATH
#define _YMATH
#include <wctype.h>
#include <math.h>
#ifndef _YVALS
#include <yvals.h>
#endif
		/* MACROS */
#define _FINITE		-1
#define _INFCODE	1
#define _NANCODE	2
		/* TYPE DEFINITIONS */
typedef union {
	unsigned short _W[5];
	float _F;
	double _D;
	long double _L;
	} _Dconst;
_C_LIB_DECL
		/* double DECLARATIONS */
_CRTIMP double __cdecl _Cosh(double, double);
_CRTIMP short __cdecl _Dtest(double *);
_CRTIMP short __cdecl _Exp(double *, double, short);
_CRTIMP double __cdecl _Sinh(double, double);
extern _CRTIMP const _Dconst _Denorm, _Hugeval, _Inf, _Nan, _Snan;
		/* float DECLARATIONS */
_CRTIMP float __cdecl _FCosh(float, float);
_CRTIMP short __cdecl _FDtest(float *);
_CRTIMP short __cdecl _FExp(float *, float, short);
_CRTIMP float __cdecl _FSinh(float, float);
extern _CRTIMP const _Dconst _FDenorm, _FInf, _FNan, _FSnan;
		/* long double DECLARATIONS */
_CRTIMP long double __cdecl _LCosh(long double, long double);
_CRTIMP short __cdecl _LDtest(long double *);
_CRTIMP short __cdecl _LExp(long double *, long double, short);
_CRTIMP long double __cdecl _LSinh(long double, long double);
extern _CRTIMP const _Dconst _LDenorm, _LInf, _LNan, _LSnan;
_END_C_LIB_DECL
#endif /* _YMATH */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\wctype.h ===
/***
*wctype.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*       Created from wchar.h January 1996 by P.J. Plauger
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all ctype-style wide-character functions.  They may also be declared in
*       wchar.h.
*       [ISO]
*
*       Note: keep in sync with ctype.h and wchar.h.
*
*       [Public]
*
****/

#ifndef _MAC

#ifndef _INC_WCTYPE
#define _INC_WCTYPE

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP */
#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];

_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#define isleadbyte(_c)  (_pctype[(unsigned char)(_c)] & _LEADBYTE)
#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int __cdecl isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */

typedef wchar_t wctrans_t;
_CRTIMP wint_t __cdecl towctrans(wint_t, wctrans_t);
_CRTIMP wctrans_t __cdecl wctrans(const char *);
_CRTIMP wctype_t __cdecl wctype(const char *);


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCTYPE */

#endif  /* ndef _MAC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\yvals.h ===
/* yvals.h values header for Microsoft C/C++ */
#ifndef _YVALS
#define _YVALS
#include <use_ansi.h>

/* Define _CRTIMP */
#ifndef _CRTIMP
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _CRTIMP */

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

 #pragma warning(disable: 4018 4114 4146 4244 4245)
 #pragma warning(disable: 4663 4664 4665)
 #pragma warning(disable: 4237 4284 4290 4514)
		/* NAMESPACE */
 #if defined(__cplusplus)
  #define _STD			std::
  #define _STD_BEGIN	namespace std {
  #define _STD_END		};
  #define _STD_USING
 #else
  #define _STD			::
  #define _STD_BEGIN
  #define _STD_END
 #endif /* __cplusplus */
_STD_BEGIN
		/* TYPE bool */
 #if defined(__cplusplus)
typedef bool _Bool;
 #endif /* __cplusplus */
		/* INTEGER PROPERTIES */
#define _MAX_EXP_DIG	8	/* for parsing numerics */
#define _MAX_INT_DIG	32
#define _MAX_SIG_DIG	36
		/* STDIO PROPERTIES */
#define _Filet _iobuf

#ifndef _FPOS_T_DEFINED
#define _FPOSOFF(fp)	((long)(fp))
#endif /* _FPOS_T_DEFINED */

		/* NAMING PROPERTIES */
 #if defined(__cplusplus)
  #define _C_LIB_DECL extern "C" {
  #define _END_C_LIB_DECL }
 #else
  #define _C_LIB_DECL
  #define _END_C_LIB_DECL
 #endif /* __cplusplus */
#define _CDECL
		// CLASS _Lockit
 #if defined(__cplusplus)
class _CRTIMP _Lockit
	{	// lock while object in existence
public:
  #ifdef _MT
   #define _LOCKIT(x)	lockit x
	_Lockit();
	~_Lockit();
  #else
   #define _LOCKIT(x)
	_Lockit()
		{}
	~_Lockit()
		{}
  #endif /* _MT */
	};
 #endif /* __cplusplus */
		/* MISCELLANEOUS MACROS */
#define _L(c)	L##c
#define _Mbstinit(x)	mbstate_t x = {0}
#define _MAX	_cpp_max
#define _MIN	_cpp_min
_STD_END
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _YVALS */

/*
 * Copyright (c) 1996 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\assert.h ===
/***
*assert.h - define the assert macro
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the assert(exp) macro.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif




/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#undef  assert

#ifdef  NDEBUG

#define assert(exp)     ((void)0)

#else

#ifdef  __cplusplus
extern "C" {
#endif

_CRTIMP void __cdecl _assert(void *, void *, unsigned);

#ifdef  __cplusplus
}
#endif

#define assert(exp) (void)( (exp) || (_assert(#exp, __FILE__, __LINE__), 0) )

#endif  /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\sys\locking.h ===
/***
*sys/locking.h - flags for locking() function
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the flags for the locking() function.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCKING
#define _INC_LOCKING

#if !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _LK_UNLCK       0       /* unlock the file region */
#define _LK_LOCK        1       /* lock the file region */
#define _LK_NBLCK       2       /* non-blocking lock */
#define _LK_RLCK        3       /* lock for writing */
#define _LK_NBRLCK      4       /* non-blocking lock for writing */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define LK_UNLCK        _LK_UNLCK
#define LK_LOCK         _LK_LOCK
#define LK_NBLCK        _LK_NBLCK
#define LK_RLCK         _LK_RLCK
#define LK_NBRLCK       _LK_NBRLCK
#endif

#endif  /* _INC_LOCKING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\xlocinfo.h ===
/* xlocinfo.h internal header for Microsoft C */
#ifndef _XLOCINFO
#define _XLOCINFO
#include <ctype.h>
#include <locale.h>
#include <wchar.h>
#ifndef _YVALS
#include <yvals.h>
#endif


		/* SUPPLEMENTAL CTYPE MACROS & DECLARATIONS */
#define _XA		0x100		/* extra alphabetic */
#define _XS		0x000		/* extra space */
#define _BB		_CONTROL	/* BEL, BS, etc. */
#define _CN		_SPACE		/* CR, FF, HT, NL, VT */
#define _DI		_DIGIT		/* '0'-'9' */
#define _LO		_LOWER		/* 'a'-'z' */
#define _PU		_PUNCT		/* punctuation */
#define _SP		_BLANK		/* space */
#define _UP		_UPPER		/* 'A'-'Z' */
#define _XD		_HEX		/* '0'-'9', 'A'-'F', 'a'-'f' */

		/* SUPPLEMENTAL LOCALE MACROS AND DECLARATIONS */
#define _LC_ALL			LC_ALL
#define _LC_COLLATE		LC_COLLATE
#define _LC_CTYPE		LC_CTYPE
#define _LC_MONETARY	LC_MONETARY
#define _LC_NUMERIC		LC_NUMERIC
#define _LC_TIME 		LC_TIME
#define _LC_MAX			LC_MAX 
#define _LC_MESSAGE		6
#define _NCAT			7

#define _CATMASK(n)	((1 << (n)) >> 1)
#define _M_COLLATE	_CATMASK(_LC_COLLATE)
#define _M_CTYPE	_CATMASK(_LC_CTYPE)
#define _M_MONETARY	_CATMASK(_LC_MONETARY)
#define _M_NUMERIC	_CATMASK(_LC_NUMERIC)
#define _M_TIME		_CATMASK(_LC_TIME)
#define _M_MESSAGE	_CATMASK(_LC_MESSAGE)
#define _M_ALL		(_CATMASK(_NCAT) - 1)

typedef struct _Collvec {
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Collvec;

typedef struct _Ctypevec {
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	const short *_Table;
	int _Delfl;
	} _Ctypevec;

typedef struct _Cvtvec {
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Cvtvec;

		/* FUNCTION DECLARATIONS */
_C_LIB_DECL
_CRTIMP _Collvec __cdecl _Getcoll();
_CRTIMP _Ctypevec __cdecl _Getctype();
_CRTIMP _Cvtvec __cdecl _Getcvt();
char *__cdecl _Getdays();
char *__cdecl _Getmonths();
void *__cdecl _Gettnames();
_CRTIMP int __cdecl _Mbrtowc(wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
extern float __cdecl _Stof(const char *, char **, long);
extern double __cdecl _Stod(const char *, char **, long);
extern long double __cdecl _Stold(const char *, char **, long);
_CRTIMP int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
size_t __cdecl _Strftime(char *, size_t, const char *,
	const struct tm *, void *);
_CRTIMP size_t __cdecl _Strxfrm(char *, char *,
	const char *, const char *, const _Collvec *);
_CRTIMP int __cdecl _Tolower(int, const _Ctypevec *);
_CRTIMP int __cdecl _Toupper(int, const _Ctypevec *);
_CRTIMP int __cdecl _Wcrtomb(char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
_CRTIMP int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
_CRTIMP size_t __cdecl _Wcsxfrm(wchar_t *, wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
_END_C_LIB_DECL
#endif /* _XLOCINFO */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\sys\stat.h ===
/***
*sys/stat.h - defines structure used by stat() and fstat()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the _stat() and _fstat()
*       routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STAT
#define _INC_STAT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#include <sys/types.h>


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* define structure for returning status information */

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__

/* Non-ANSI names for compatibility */

struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64

struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

struct __stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

#endif

#define _STAT_DEFINED
#endif


#define _S_IFMT         0170000         /* file type mask */
#define _S_IFDIR        0040000         /* directory */
#define _S_IFCHR        0020000         /* character special */
#define _S_IFIFO        0010000         /* pipe */
#define _S_IFREG        0100000         /* regular */
#define _S_IREAD        0000400         /* read permission, owner */
#define _S_IWRITE       0000200         /* write permission, owner */
#define _S_IEXEC        0000100         /* execute/search permission, owner */


/* Function prototypes */

_CRTIMP int __cdecl _fstat(int, struct _stat *);
_CRTIMP int __cdecl _stat(const char *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _fstati64(int, struct _stati64 *);
_CRTIMP int __cdecl _fstat64(int, struct __stat64 *);
_CRTIMP int __cdecl _stati64(const char *, struct _stati64 *);
_CRTIMP int __cdecl _stat64(const char *, struct __stat64 *);
#endif

#ifndef _WSTAT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
_CRTIMP int __cdecl _wstat64(const wchar_t *, struct __stat64 *);
#endif

#define _WSTAT_DEFINED
#endif


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define S_IFMT   _S_IFMT
#define S_IFDIR  _S_IFDIR
#define S_IFCHR  _S_IFCHR
#define S_IFREG  _S_IFREG
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IEXEC  _S_IEXEC

_CRTIMP int __cdecl fstat(int, struct stat *);
_CRTIMP int __cdecl stat(const char *, struct stat *);

#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\sys\types.h ===
/***
*sys/types.h - types returned by system level calls for file and time info
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines types used in defining values returned by system
*       level calls for file status and time information.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TYPES
#define _INC_TYPES

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


#ifndef _INO_T_DEFINED

typedef unsigned short _ino_t;          /* i-node number (not used on DOS) */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif

#define _INO_T_DEFINED
#endif


#ifndef _DEV_T_DEFINED

typedef unsigned int _dev_t;            /* device code */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif

#define _DEV_T_DEFINED
#endif


#ifndef _OFF_T_DEFINED

typedef long _off_t;                    /* file offset value */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif

#define _OFF_T_DEFINED
#endif

#endif  /* _INC_TYPES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\sys\timeb.h ===
/***
*sys/timeb.h - definition/declarations for _ftime()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file define the _ftime() function and the types it uses.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIMEB
#define _INC_TIMEB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


/* Structure returned by _ftime system call */

#ifndef _TIMEB_DEFINED
struct _timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#if     !__STDC__

/* Non-ANSI name for compatibility */

struct timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#endif

#if     _INTEGRAL_MAX_BITS >= 64
struct __timeb64 {
        __time64_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };
#endif

#define _TIMEB_DEFINED
#endif


/* Function prototypes */

_CRTIMP void __cdecl _ftime(struct _timeb *);

#if     !__STDC__

/* Non-ANSI name for compatibility */

_CRTIMP void __cdecl ftime(struct timeb *);

#endif

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP void __cdecl _ftime64(struct __timeb64 *);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIMEB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\eh.h ===
/***
*eh.h - User include file for exception handling.
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       User include file for exception handling.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_EH
#define _INC_EH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)
#endif  // _MSC_VER

#ifndef __cplusplus
#error "eh.h is only for C++!"
#endif


/* Define _CRTIMP */
#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_handler)();

struct _EXCEPTION_POINTERS;
typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl terminate(void);
_CRTIMP __declspec(noreturn) void __cdecl unexpected(void);
#else
_CRTIMP void __cdecl terminate(void);
_CRTIMP void __cdecl unexpected(void);
#endif

_CRTIMP terminate_function __cdecl set_terminate(terminate_function);
_CRTIMP unexpected_function __cdecl set_unexpected(unexpected_function);
_CRTIMP _se_translator_function __cdecl _set_se_translator(_se_translator_function);
_CRTIMP bool __uncaught_exception();

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_EH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines macros for character classification/conversion.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CTYPE
#define _INC_CTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
_CRTIMP const unsigned short * __cdecl __pctype_func(void);
_CRTIMP const wctype_t * __cdecl __pwctype_func(void);
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#ifndef __PCTYPE_FUNC
#ifdef _MT
#define __PCTYPE_FUNC   __pctype_func()
#else
#define __PCTYPE_FUNC  _pctype
#endif  /* _MT */
#endif  /* __PCTYPE_FUNC */
#endif  /* _CTYPE_DISABLE_MACROS */




/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_CRTIMP int __cdecl _isctype(int, int);
_CRTIMP int __cdecl isalpha(int);
_CRTIMP int __cdecl isupper(int);
_CRTIMP int __cdecl islower(int);
_CRTIMP int __cdecl isdigit(int);
_CRTIMP int __cdecl isxdigit(int);
_CRTIMP int __cdecl isspace(int);
_CRTIMP int __cdecl ispunct(int);
_CRTIMP int __cdecl isalnum(int);
_CRTIMP int __cdecl isprint(int);
_CRTIMP int __cdecl isgraph(int);
_CRTIMP int __cdecl iscntrl(int);
_CRTIMP int __cdecl toupper(int);
_CRTIMP int __cdecl tolower(int);
_CRTIMP int __cdecl _tolower(int);
_CRTIMP int __cdecl _toupper(int);
_CRTIMP int __cdecl __isascii(int);
_CRTIMP int __cdecl __toascii(int);
_CRTIMP int __cdecl __iscsymf(int);
_CRTIMP int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif

#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX
#ifdef _MT
#define MB_CUR_MAX ___mb_cur_max_func()
#else
#define MB_CUR_MAX __mb_cur_max
#endif
_CRTIMP extern int __mb_cur_max;
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */

/* Introduced to detect error when character testing functions are called
 * with illegal input of integer.
 */
#ifdef _DEBUG
_CRTIMP int __cdecl _chvalidator(int, int);
#define __chvalidchk(a,b)       _chvalidator(a,b)
#else
#define __chvalidchk(a,b)       (__PCTYPE_FUNC[(a)] & (b))
#endif



#ifndef _MT
#ifndef __cplusplus
#define isalpha(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : __chvalidchk(_c, _ALPHA))
#define isupper(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : __chvalidchk(_c, _UPPER))
#define islower(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : __chvalidchk(_c, _LOWER))
#define isdigit(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : __chvalidchk(_c, _DIGIT))
#define isxdigit(_c)    (MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : __chvalidchk(_c, _HEX))
#define isspace(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : __chvalidchk(_c, _SPACE))
#define ispunct(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : __chvalidchk(_c, _PUNCT))
#define isalnum(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : __chvalidchk(_c, (_ALPHA|_DIGIT)))
#define isprint(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_BLANK|_PUNCT|_ALPHA|_DIGIT)))
#define isgraph(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_PUNCT|_ALPHA|_DIGIT)))
#define iscntrl(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : __chvalidchk(_c, _CONTROL))
#elif   0         /* Pending ANSI C++ integration */
inline int isalpha(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA) : __chvalidchk(_C, _ALPHA)); }
inline int isupper(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_UPPER) : __chvalidchk(_C, _UPPER)); }
inline int islower(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_LOWER) : __chvalidchk(_C, _LOWER)); }
inline int isdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_DIGIT) : __chvalidchk(_C, _DIGIT)); }
inline int isxdigit(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_HEX)   : __chvalidchk(_C, _HEX)); }
inline int isspace(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_SPACE) : __chvalidchk(_C, _SPACE)); }
inline int ispunct(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT) : __chvalidchk(_C, _PUNCT)); }
inline int isalnum(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_ALPHA|_DIGIT)
                : __chvalidchk(_C) , (_ALPHA|_DIGIT)); }
inline int isprint(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_BLANK|_PUNCT|_ALPHA|_DIGIT))); }
inline int isgraph(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_PUNCT|_ALPHA|_DIGIT)
                : __chvalidchk(_C , (_PUNCT|_ALPHA|_DIGIT))); }
inline int iscntrl(int _C)
        {return (MB_CUR_MAX > 1 ? _isctype(_C,_CONTROL)
                : __chvalidchk(_C , _CONTROL)); }
#endif  /* __cplusplus */
#endif  /* _MT */


#define _tolower(_c)    ( (_c)-'A'+'a' )
#define _toupper(_c)    ( (_c)-'a'+'A' )

#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#define __toascii(_c)   ( (_c) & 0x7f )

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )
#define isleadbyte(_c)  ( __PCTYPE_FUNC[(unsigned char)(_c)] & _LEADBYTE)
#elif   0         /* __cplusplus */
inline int iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int isleadbyte(int _C)
        {return (__PCTYPE_FUNC[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */



/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))

#endif  /* _CTYPE_DISABLE_MACROS */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#ifndef _CTYPE_DEFINED
_CRTIMP int __cdecl isascii(int);
_CRTIMP int __cdecl toascii(int);
_CRTIMP int __cdecl iscsymf(int);
_CRTIMP int __cdecl iscsym(int);
#else
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif


#endif  /* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the library
*       functions related to directory handling and creation.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_DIRECT
#define _INC_DIRECT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* _getdiskfree structure for _getdiskfree() */
#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif

/* function prototypes */

_CRTIMP int __cdecl _chdir(const char *);
_CRTIMP char * __cdecl _getcwd(char *, int);
_CRTIMP int __cdecl _mkdir(const char *);
_CRTIMP int __cdecl _rmdir(const char *);

_CRTIMP int __cdecl _chdrive(int);
_CRTIMP char * __cdecl _getdcwd(int, char *, int);
_CRTIMP int __cdecl _getdrive(void);
_CRTIMP unsigned long __cdecl _getdrives(void);
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);

#ifndef _WDIRECT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif


#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl chdir(const char *);
_CRTIMP char * __cdecl getcwd(char *, int);
_CRTIMP int __cdecl mkdir(const char *);
_CRTIMP int __cdecl rmdir(const char *);

#define diskfree_t  _diskfree_t

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DIRECT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\inc64\sys\utime.h ===
/***
*sys/utime.h - definitions/declarations for utime()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the utime routine to set
*       new file access and modification times.  NOTE - MS-DOS
*       does not recognize access time, so this field will
*       always be ignored and the modification time field will be
*       used to set the new time.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_UTIME
#define _INC_UTIME

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

/* define struct used by _utime() function */

#ifndef _UTIMBUF_DEFINED

struct _utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };

#if     !__STDC__
/* Non-ANSI name for compatibility */
struct utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };
#endif

#if     _INTEGRAL_MAX_BITS >= 64
struct __utimbuf64 {
        __time64_t actime;      /* access time */
        __time64_t modtime;     /* modification time */
        };
#endif

#define _UTIMBUF_DEFINED
#endif


/* Function Prototypes */

_CRTIMP int __cdecl _utime(const char *, struct _utimbuf *);

_CRTIMP int __cdecl _futime(int, struct _utimbuf *);

/* Wide Function Prototypes */
_CRTIMP int __cdecl _wutime(const wchar_t *, struct _utimbuf *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _utime64(const char *, struct __utimbuf64 *);
_CRTIMP int __cdecl _futime64(int, struct __utimbuf64 *);
_CRTIMP int __cdecl _wutime64(const wchar_t *, struct __utimbuf64 *);
#endif

#if     !__STDC__
/* Non-ANSI name for compatibility */
_CRTIMP int __cdecl utime(const char *, struct utimbuf *);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_UTIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the system-wide error numbers (set by
*       system calls).  Conforms to the XENIX standard.  Extended
*       for compatibility with Uniforum standard.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_ERRNO
#define _INC_ERRNO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* declare reference to errno */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */

/* Error Codes */

#define EPERM           1
#define ENOENT          2
#define ESRCH           3
#define EINTR           4
#define EIO             5
#define ENXIO           6
#define E2BIG           7
#define ENOEXEC         8
#define EBADF           9
#define ECHILD          10
#define EAGAIN          11
#define ENOMEM          12
#define EACCES          13
#define EFAULT          14
#define EBUSY           16
#define EEXIST          17
#define EXDEV           18
#define ENODEV          19
#define ENOTDIR         20
#define EISDIR          21
#define EINVAL          22
#define ENFILE          23
#define EMFILE          24
#define ENOTTY          25
#define EFBIG           27
#define ENOSPC          28
#define ESPIPE          29
#define EROFS           30
#define EMLINK          31
#define EPIPE           32
#define EDOM            33
#define ERANGE          34
#define EDEADLK         36
#define ENAMETOOLONG    38
#define ENOLCK          39
#define ENOSYS          40
#define ENOTEMPTY       41
#define EILSEQ          42

/*
 * Support EDEADLOCK for compatibiity with older MS-C versions.
 */
#define EDEADLOCK       EDEADLK

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_ERRNO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for
*       the MS C V2.03 compatible console I/O routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CONIO
#define _INC_CONIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Function prototypes */

_CRTIMP char * __cdecl _cgets(char *);
_CRTIMP int __cdecl _cprintf(const char *, ...);
_CRTIMP int __cdecl _cputs(const char *);
_CRTIMP int __cdecl _cscanf(const char *, ...);
_CRTIMP int __cdecl _getch(void);
_CRTIMP int __cdecl _getche(void);
#ifdef  _M_IX86
int __cdecl _inp(unsigned short);
unsigned short __cdecl _inpw(unsigned short);
unsigned long __cdecl _inpd(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _kbhit(void);
#ifdef  _M_IX86
int __cdecl _outp(unsigned short, int);
unsigned short __cdecl _outpw(unsigned short, unsigned short);
unsigned long __cdecl _outpd(unsigned short, unsigned long);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _putch(int);
_CRTIMP int __cdecl _ungetch(int);


#ifndef _WCONIO_DEFINED

/* wide function prototypes, also declared in wchar.h */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);


#define _WCONIO_DEFINED
#endif  /* _WCONIO_DEFINED */

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP char * __cdecl cgets(char *);
_CRTIMP int __cdecl cprintf(const char *, ...);
_CRTIMP int __cdecl cputs(const char *);
_CRTIMP int __cdecl cscanf(const char *, ...);
#ifdef  _M_IX86
int __cdecl inp(unsigned short);
unsigned short __cdecl inpw(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl getch(void);
_CRTIMP int __cdecl getche(void);
_CRTIMP int __cdecl kbhit(void);
#ifdef  _M_IX86
int __cdecl outp(unsigned short, int);
unsigned short __cdecl outpw(unsigned short, unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl putch(int);
_CRTIMP int __cdecl ungetch(int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_CONIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines constants for the file control options used
*       by the _open() function.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FCNTL
#define _INC_FCNTL

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _O_RDONLY       0x0000  /* open for reading only */
#define _O_WRONLY       0x0001  /* open for writing only */
#define _O_RDWR         0x0002  /* open for reading and writing */
#define _O_APPEND       0x0008  /* writes done at eof */

#define _O_CREAT        0x0100  /* create and open file */
#define _O_TRUNC        0x0200  /* open and truncate */
#define _O_EXCL         0x0400  /* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define _O_TEXT         0x4000  /* file mode is text (translated) */
#define _O_BINARY       0x8000  /* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define _O_RAW  _O_BINARY

/* Open handle inherit bit */

#define _O_NOINHERIT    0x0080  /* child process doesn't inherit file */

/* Temporary file bit - file is deleted when last handle is closed */

#define _O_TEMPORARY    0x0040  /* temporary file bit */

/* temporary access hint */

#define _O_SHORT_LIVED  0x1000  /* temporary storage file, try not to flush */

/* sequential/random access hints */

#define _O_SEQUENTIAL   0x0020  /* file access is primarily sequential */
#define _O_RANDOM       0x0010  /* file access is primarily random */

#if     !__STDC__ || defined(_POSIX_)
/* Non-ANSI names for compatibility */
#define O_RDONLY        _O_RDONLY
#define O_WRONLY        _O_WRONLY
#define O_RDWR          _O_RDWR
#define O_APPEND        _O_APPEND
#define O_CREAT         _O_CREAT
#define O_TRUNC         _O_TRUNC
#define O_EXCL          _O_EXCL
#define O_TEXT          _O_TEXT
#define O_BINARY        _O_BINARY
#define O_RAW           _O_BINARY
#define O_TEMPORARY     _O_TEMPORARY
#define O_NOINHERIT     _O_NOINHERIT
#define O_SEQUENTIAL    _O_SEQUENTIAL
#define O_RANDOM        _O_RANDOM
#endif  /* __STDC__ */

#endif  /* _INC_FCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the structs and unions used for the direct DOS interface
*       routines; includes macros to access the segment and offset
*       values of far pointers, so that they may be used by the routines; and
*       provides function prototypes for direct DOS interface functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_DOS
#define _INC_DOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _DISKFREE_T_DEFINED
/* _getdiskfree structure (duplicated in DIRECT.H) */
struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif

/* File attribute constants */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* Function prototypes */
_CRTIMP unsigned __cdecl _getdiskfree(unsigned, struct _diskfree_t *);

#ifdef  _M_IX86
void __cdecl _disable(void);
void __cdecl _enable(void);
#endif  /* _M_IX86 */

#if     !__STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t  _diskfree_t
#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DOS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\fpieee.h ===
/***
*fpieee.h - Definitions for floating point IEEE exception handling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant and type definitions for handling
*       floating point exceptions [ANSI/IEEE std. 754]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FPIEEE
#define _INC_FPIEEE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)

/* Disable C4324: structure was padded due to __declspec(align()) */
#pragma warning(push)
#pragma warning(disable: 4324)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/*
 * Define floating point IEEE compare result values.
 */

typedef enum {
    _FpCompareEqual,
    _FpCompareGreater,
    _FpCompareLess,
    _FpCompareUnordered
} _FPIEEE_COMPARE_RESULT;

/*
 * Define floating point format and result precision values.
 */

typedef enum {
    _FpFormatFp32,
    _FpFormatFp64,
    _FpFormatFp80,
    _FpFormatFp128,
    _FpFormatI16,
    _FpFormatI32,
    _FpFormatI64,
    _FpFormatU16,
    _FpFormatU32,
    _FpFormatU64,
    _FpFormatBcd80,
    _FpFormatCompare,
    _FpFormatString,
#if defined(_M_IA64)
    _FpFormatFp82
#endif
} _FPIEEE_FORMAT;

/*
 * Define operation code values.
 */

typedef enum {
    _FpCodeUnspecified,
    _FpCodeAdd,
    _FpCodeSubtract,
    _FpCodeMultiply,
    _FpCodeDivide,
    _FpCodeSquareRoot,
    _FpCodeRemainder,
    _FpCodeCompare,
    _FpCodeConvert,
    _FpCodeRound,
    _FpCodeTruncate,
    _FpCodeFloor,
    _FpCodeCeil,
    _FpCodeAcos,
    _FpCodeAsin,
    _FpCodeAtan,
    _FpCodeAtan2,
    _FpCodeCabs,
    _FpCodeCos,
    _FpCodeCosh,
    _FpCodeExp,
    _FpCodeFabs,
    _FpCodeFmod,
    _FpCodeFrexp,
    _FpCodeHypot,
    _FpCodeLdexp,
    _FpCodeLog,
    _FpCodeLog10,
    _FpCodeModf,
    _FpCodePow,
    _FpCodeSin,
    _FpCodeSinh,
    _FpCodeTan,
    _FpCodeTanh,
    _FpCodeY0,
    _FpCodeY1,
    _FpCodeYn,
    _FpCodeLogb,
    _FpCodeNextafter,
    _FpCodeNegate, 
    _FpCodeFmin,         /* XMMI */
    _FpCodeFmax,         /* XMMI */
    _FpCodeConvertTrunc, /* XMMI */
    _XMMIAddps,          /* XMMI */
    _XMMIAddss,
    _XMMISubps,
    _XMMISubss,
    _XMMIMulps,
    _XMMIMulss,
    _XMMIDivps,
    _XMMIDivss,
    _XMMISqrtps,
    _XMMISqrtss,
    _XMMIMaxps,
    _XMMIMaxss,
    _XMMIMinps,
    _XMMIMinss,
    _XMMICmpps,
    _XMMICmpss,
    _XMMIComiss,
    _XMMIUComiss,
    _XMMICvtpi2ps,
    _XMMICvtsi2ss,
    _XMMICvtps2pi,
    _XMMICvtss2si,
    _XMMICvttps2pi,
    _XMMICvttss2si,
    _XMMI2Addpd,         /* XMMI2 */
    _XMMI2Addsd,
    _XMMI2Subpd,
    _XMMI2Subsd,
    _XMMI2Mulpd,
    _XMMI2Mulsd,
    _XMMI2Divpd,
    _XMMI2Divsd,
    _XMMI2Sqrtpd,
    _XMMI2Sqrtsd,
    _XMMI2Maxpd,
    _XMMI2Maxsd,
    _XMMI2Minpd,
    _XMMI2Minsd,
    _XMMI2Cmppd,
    _XMMI2Cmpsd,
    _XMMI2Comisd,
    _XMMI2UComisd,
    _XMMI2Cvtpd2pi,   /* 66 2D    */
    _XMMI2Cvtsd2si,   /* F2       */
    _XMMI2Cvttpd2pi,  /* 66 2C    */
    _XMMI2Cvttsd2si,  /* F2       */
    _XMMI2Cvtps2pd,   /* 0F 5A    */
    _XMMI2Cvtss2sd,   /* F3       */
    _XMMI2Cvtpd2ps,   /* 66       */
    _XMMI2Cvtsd2ss,   /* F2       */
    _XMMI2Cvtdq2ps,   /* 0F 5B    */
    _XMMI2Cvttps2dq,  /* F3       */
    _XMMI2Cvtps2dq,   /* 66       */
    _XMMI2Cvttpd2dq,  /* 66 0F E6 */
    _XMMI2Cvtpd2dq,   /* F2       */
#if defined(_M_IA64)
    _FpCodeFma,
    _FpCodeFmaSingle,
    _FpCodeFmaDouble,
    _FpCodeFms,
    _FpCodeFmsSingle,
    _FpCodeFmsDouble,
    _FpCodeFnma,
    _FpCodeFnmaSingle,
    _FpCodeFnmaDouble,
    _FpCodeFamin,
    _FpCodeFamax
#endif
} _FP_OPERATION_CODE;

#endif  /* #ifndef __assembler */

/*
 * Define rounding modes.
 */

#ifndef __assembler     /* MIPS ONLY: Protect from assembler */

typedef enum {
    _FpRoundNearest,
    _FpRoundMinusInfinity,
    _FpRoundPlusInfinity,
    _FpRoundChopped
} _FPIEEE_ROUNDING_MODE;

typedef enum {
    _FpPrecisionFull,
    _FpPrecision53,
    _FpPrecision24,
#if defined(_M_IA64)
    _FpPrecision64,
    _FpPrecision113
#endif
} _FPIEEE_PRECISION;


/*
 * Define floating point context record
 */

typedef float           _FP32;
typedef double          _FP64;
typedef short           _I16;
typedef int             _I32;
typedef unsigned short  _U16;
typedef unsigned int    _U32;
typedef __int64         _Q64;


typedef struct
#if defined(_M_IA64)
    __declspec(align(16))
#endif
{
    unsigned short W[5];
} _FP80;

typedef struct __declspec(align(16))
{
    unsigned long W[4];
} _FP128;

typedef struct __declspec(align(8))
{
    unsigned long W[2];
} _I64;

typedef struct __declspec(align(8))
{
    unsigned long W[2];
} _U64;

typedef struct
#if defined(_M_IA64)
    __declspec(align(16))
#endif
{
    unsigned short W[5];
} _BCD80;

typedef struct __declspec(align(16))
{
    _Q64 W[2];
} _FPQ64;

typedef struct {
    union {
        _FP32        Fp32Value;
        _FP64        Fp64Value;
        _FP80        Fp80Value;
        _FP128       Fp128Value;
        _I16         I16Value;
        _I32         I32Value;
        _I64         I64Value;
        _U16         U16Value;
        _U32         U32Value;
        _U64         U64Value;
        _BCD80       Bcd80Value;
        char         *StringValue;
        int          CompareValue;
        _Q64         Q64Value;
        _FPQ64       Fpq64Value;
    } Value;

    unsigned int OperandValid : 1;
    unsigned int Format : 4;

} _FPIEEE_VALUE;


typedef struct {
    unsigned int Inexact : 1;
    unsigned int Underflow : 1;
    unsigned int Overflow : 1;
    unsigned int ZeroDivide : 1;
    unsigned int InvalidOperation : 1;
} _FPIEEE_EXCEPTION_FLAGS;


typedef struct {
    unsigned int RoundingMode : 2;
    unsigned int Precision : 3;
    unsigned int Operation :12;
    _FPIEEE_EXCEPTION_FLAGS Cause;
    _FPIEEE_EXCEPTION_FLAGS Enable;
    _FPIEEE_EXCEPTION_FLAGS Status;
    _FPIEEE_VALUE Operand1;
    _FPIEEE_VALUE Operand2;
    _FPIEEE_VALUE Result;
#if defined(_M_IA64)
    _FPIEEE_VALUE Operand3;
#endif
} _FPIEEE_RECORD, *_PFPIEEE_RECORD;


struct _EXCEPTION_POINTERS;

/*
 * Floating point IEEE exception filter routine
 */

_CRTIMP int __cdecl _fpieee_flt(
        unsigned long,
        struct _EXCEPTION_POINTERS *,
        int (__cdecl *)(_FPIEEE_RECORD *)
        );

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma warning(pop)
#pragma pack(pop)
#endif  /* _MSC_VER */
#endif  /* #ifndef __assembler */

#endif  /* _INC_FPIEEE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\crtdbg.h ===
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */


 /****************************************************************************
 *
 * Constants and types
 *
 ***************************************************************************/

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);

#define _CRT_RPTHOOK_INSTALL  0
#define _CRT_RPTHOOK_REMOVE   1

 /****************************************************************************
 *
 * Heap
 *
 ***************************************************************************/

 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);

 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

/*
 * Some bit values for _crtDbgFlag which correspond to frequencies for checking
 * the the heap.
 */
#define _CRTDBG_CHECK_EVERY_16_DF   0x00100000  /* check heap every 16 heap ops */
#define _CRTDBG_CHECK_EVERY_128_DF  0x00800000  /* check heap every 128 heap ops */
#define _CRTDBG_CHECK_EVERY_1024_DF 0x04000000  /* check heap every 1024 heap ops */
#define _CRTDBG_CHECK_DEFAULT_DF    _CRTDBG_CHECK_EVERY_1024_DF

#define _CRTDBG_REPORT_FLAG         -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);

struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        size_t lCounts[_MAX_BLOCKS];
        size_t lSizes[_MAX_BLOCKS];
        size_t lHighWaterCount;
        size_t lTotalCount;
} _CrtMemState;


 /****************************************************************************
 *
 * Declarations, prototype and function-like macros
 *
 ***************************************************************************/


#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _ASSERT(expr) ((void)0)

#define _ASSERTE(expr) ((void)0)


#define _RPT0(rptno, msg)

#define _RPT1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _RPTF0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

#define _aligned_malloc_dbg(s, a, f, l)     _aligned_malloc(s, a)
#define _aligned_realloc_dbg(p, s, a, f, l) _aligned_realloc(p, s, a)
#define _aligned_free_dbg(p)                _aligned_free(p)
#define _aligned_offset_malloc_dbg(s, a, o, f, l)       _aligned_offset_malloc(s, a, o)
#define _aligned_offset_realloc_dbg(p, s, a, o, f, l)   _aligned_offset_realloc(p, s, a, o)

#define _CrtSetReportHook(f)                ((_CRT_REPORT_HOOK)0)
#define _CrtSetReportHook2(t, f)            ((int)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtSetReportFile(t, f)             ((_HFILE)0)

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((_CRT_ALLOC_HOOK)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)
#define _CrtReportBlockType(p)              ((int)-1)

#define _CrtSetDumpClient(f)                ((_CRT_DUMP_CLIENT)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)


#else   /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

_CRTIMP extern long _crtAssertBusy;

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportHook2(
        int,
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );

_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );

_CRTIMP int __cdecl _CrtDbgReport(
        int,
        const char *,
        int,
        const char *,
        const char *,
        ...);

/* Asserts */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _ASSERT_BASE(expr, msg) \
        (void) ((expr) || \
                (1 != _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg)) || \
                (_CrtDbgBreak(), 0))
#else
#define _ASSERT_BASE(expr, msg) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, msg))) \
             _CrtDbgBreak(); } while (0)
#endif

#define _ASSERT(expr)   _ASSERT_BASE((expr), NULL)

#define _ASSERTE(expr)  _ASSERT_BASE((expr), #expr)

/* Reports with no file/line info */

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _RPT_BASE(args) \
        (void) ((1 != _CrtDbgReport args) || \
                (_CrtDbgBreak(), 0))
#else
#define _RPT_BASE(args) \
        do { if ((1 == _CrtDbgReport args)) \
                _CrtDbgBreak(); } while (0)
#endif

#define _RPT0(rptno, msg) \
        _RPT_BASE((rptno, NULL, 0, NULL, "%s", msg))

#define _RPT1(rptno, msg, arg1) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1))

#define _RPT2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2))

#define _RPT3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))


/* Reports with file/line info */

#define _RPTF0(rptno, msg) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, "%s", msg))

#define _RPTF1(rptno, msg, arg1) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1))

#define _RPTF2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))

#define _RPTF3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))

#if     _MSC_VER >= 1300 && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __debugbreak()
#elif   defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __asm { int 3 }
#elif   defined(_M_IA64) && !defined(_CRT_PORTABLE)
void __break(int);
#pragma intrinsic (__break)
#define _CrtDbgBreak() __break(0x80016)
#else
_CRTIMP void __cdecl _CrtDbgBreak(
        void
        );
#endif

 /****************************************************************************
 *
 * Heap routines
 *
 ***************************************************************************/

#ifdef  _CRTDBG_MAP_ALLOC

#define   malloc(s)         _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   calloc(c, s)      _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   realloc(p, s)     _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _expand(p, s)     _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)           _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)         _msize_dbg(p, _NORMAL_BLOCK)
#define   _aligned_malloc(s, a)                 _aligned_malloc_dbg(s, a, __FILE__, __LINE__)
#define   _aligned_realloc(p, s, a)             _aligned_realloc_dbg(p, s, a, __FILE__, __LINE__)
#define   _aligned_offset_malloc(s, a, o)       _aligned_offset_malloc_dbg(s, a, o, __FILE__, __LINE__)
#define   _aligned_offset_realloc(p, s, a, o)   _aligned_offset_realloc_dbg(p, s, a, o, __FILE__, __LINE__)
#define   _aligned_free(p)  _aligned_free_dbg(p)

#endif  /* _CRTDBG_MAP_ALLOC */

_CRTIMP extern long _crtBreakAlloc;      /* Break on this allocation */

_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_CRTIMP void * __cdecl _malloc_dbg(
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _calloc_dbg(
        size_t,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _realloc_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _expand_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void __cdecl _free_dbg(
        void *,
        int
        );

_CRTIMP size_t __cdecl _msize_dbg (
        void *,
        int
        );

_CRTIMP void * __cdecl _aligned_malloc_dbg(
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_realloc_dbg(
        void *,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_malloc_dbg(
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void * __cdecl _aligned_offset_realloc_dbg(
        void *,
        size_t,
        size_t,
        size_t,
        const char *,
        int
        );

_CRTIMP void __cdecl _aligned_free_dbg(
        void *
        );


 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK
        );


 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bitfield flag that controls CRT heap behavior
 * Default setting is _CRTDBG_ALLOC_MEM_DF
 */

_CRTIMP extern int _crtDbgFlag;

_CRTIMP int __cdecl _CrtCheckMemory(
        void
        );

_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );

_CRTIMP void __cdecl _CrtDoForAllClientObjects(
        void (*pfn)(void *, void *),
        void *
        );

_CRTIMP int __cdecl _CrtIsValidPointer(
        const void *,
        unsigned int,
        int
        );

_CRTIMP int __cdecl _CrtIsValidHeapPointer(
        const void *
        );

_CRTIMP int __cdecl _CrtIsMemoryBlock(
        const void *,
        unsigned int,
        long *,
        char **,
        int *
        );

_CRTIMP int __cdecl _CrtReportBlockType(
        const void *
        );


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT
        );

_CRTIMP void __cdecl _CrtMemCheckpoint(
        _CrtMemState *
        );

_CRTIMP int __cdecl _CrtMemDifference(
        _CrtMemState *,
        const _CrtMemState *,
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpStatistics(
        const _CrtMemState *
        );

_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );

#endif  /* _DEBUG */

#ifdef  __cplusplus
}

#ifndef _MFC_OVERRIDES_NEW

extern "C++" {

#pragma warning(disable: 4507)  /* Ignore faulty warning */

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

 
void * __cdecl operator new[](size_t);

inline void * __cdecl operator new(size_t s, int, const char *, int)
        { return ::operator new(s); }

inline void* __cdecl operator new[](size_t s, int, const char *, int)
        { return ::operator new[](s); }

#if     _MSC_VER >= 1200


void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif
#else /* _DEBUG */

 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/
 
void * __cdecl operator new[](size_t);

void * __cdecl operator new(
        size_t,
        int,
        const char *,
        int
        );

void * __cdecl operator new[](
        size_t,
        int,
        const char *,
        int
        );

#if     _MSC_VER >= 1200
void __cdecl operator delete[](void *);

inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }

inline void __cdecl operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif

#ifdef _CRTDBG_MAP_ALLOC

inline void * __cdecl operator new(size_t s)
        { return ::operator new(s, _NORMAL_BLOCK, __FILE__, __LINE__); }

inline void* __cdecl operator new[](size_t s)
        { return ::operator new[](s, _NORMAL_BLOCK, __FILE__, __LINE__); }

#endif  /* _CRTDBG_MAP_ALLOC */

#endif  /* _DEBUG */

}

#endif  /* _MFC_OVERRIDES_NEW */

#endif  /* __cplusplus */

#endif  /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\fstream.h ===
/***
*fstream.h - definitions/declarations for filebuf and fstream classes
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the filebuf and fstream classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_FSTREAM
#define _INC_FSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <iostream.h>

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef int filedesc;

class _CRTIMP filebuf : public streambuf {
public:
static  const int       openprot;       // default share/prot mode for open

// optional share values for 3rd argument (prot) of open or constructor
static  const int       sh_none;        // exclusive mode no sharing
static  const int       sh_read;        // allow read sharing
static  const int       sh_write;       // allow write sharing
// use (sh_read | sh_write) to allow both read and write sharing

// options for setmode member function
static  const int       binary;
static  const int       text;

                        filebuf();
                        filebuf(filedesc);
                        filebuf(filedesc, char *, int);
                        ~filebuf();

        filebuf*        attach(filedesc);
        filedesc        fd() const { return (x_fd==-1) ? EOF : x_fd; }
        int             is_open() const { return (x_fd!=-1); }
        filebuf*        open(const char *, int, int = filebuf::openprot);
        filebuf*        close();
        int             setmode(int = filebuf::text);

virtual int             overflow(int=EOF);
virtual int             underflow();

virtual streambuf*      setbuf(char *, int);
virtual streampos       seekoff(streamoff, ios::seek_dir, int);
// virtual      streampos       seekpos(streampos, int);
virtual int             sync();

private:
        filedesc        x_fd;
        int             x_fOpened;
};

class _CRTIMP ifstream : public istream {
public:
        ifstream();
        ifstream(const char *, int =ios::in, int = filebuf::openprot);
        ifstream(filedesc);
        ifstream(filedesc, char *, int);
        ~ifstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::in, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class _CRTIMP ofstream : public ostream {
public:
        ofstream();
        ofstream(const char *, int =ios::out, int = filebuf::openprot);
        ofstream(filedesc);
        ofstream(filedesc, char *, int);
        ~ofstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int =ios::out, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
class _CRTIMP fstream : public iostream {
public:
        fstream();
        fstream(const char *, int, int = filebuf::openprot);
        fstream(filedesc);
        fstream(filedesc, char *, int);
        ~fstream();

        streambuf * setbuf(char *, int);
        filebuf* rdbuf() const { return (filebuf*) ostream::rdbuf(); }

        void attach(filedesc);
        filedesc fd() const { return rdbuf()->fd(); }

        int is_open() const { return rdbuf()->is_open(); }
        void open(const char *, int, int = filebuf::openprot);
        void close();
        int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};
        
// manipulators to dynamically change file access mode (filebufs only)
inline  ios& binary(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::binary); return _fstrm; }
inline  ios& text(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::text); return _fstrm; }

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_FSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\iomanip.h ===
/***
*iomanip.h - definitions/declarations for iostream's parameterized manipulators
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes' paramterized manipulators.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOMANIP
#define _INC_IOMANIP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

#include <iostream.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

// #define __MKMANIP(X) \#define X##(T) __##X##_ \#\# T
// __MKMANIP(SMANIP);
// __MKMANIP(SAPP);
// __MKMANIP(IMANIP);
// __MKMANIP(IAPP);
// __MKMANIP(OMANIP);
// __MKMANIP(OAPP);
// __MKMANIP(IOMANIP);
// __MKMANIP(IOAPP);

#define SMANIP(T) __SMANIP_##T
#define SAPP(T) __SAPP_##T
#define IMANIP(T) __IMANIP_##T
#define IAPP(T) __IAPP_##T
#define OMANIP(T) __OMANIP_##T
#define OAPP(T) __OAPP_##T
#define IOMANIP(T) __IOMANIP_##T
#define IOAPP(T) __IOAPP_##T

#define IOMANIPdeclare(T)  \
class SMANIP(T) { \
public: \
        SMANIP(T)(ios& (*f)(ios&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
        friend ostream& operator<<(ostream& s, const SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
private:        \
        ios& (* _fp)(ios&,T); \
        T _tp; \
};      \
class SAPP(T) { \
public: \
        SAPP(T)( ios& (*f)(ios&,T)) : _fp(f) {} \
        SMANIP(T) operator()(T t) { return SMANIP(T)(_fp,t); }  \
private:        \
        ios& (* _fp)(ios&,T); \
};      \
class IMANIP(T) { \
public: \
        IMANIP(T)(istream& (*f)(istream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(istream& s, IMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        istream& (* _fp)(istream&,T); \
        T _tp;  \
};      \
class IAPP(T) { \
public: \
        IAPP(T)( istream& (*f)(istream&,T)) : _fp(f) {} \
        IMANIP(T) operator()(T t) { return IMANIP(T)(_fp,t); }  \
private:        \
        istream& (* _fp)(istream&,T); \
};      \
class OMANIP(T) { \
public: \
        OMANIP(T)(ostream& (*f)(ostream&,T), T t) : _fp(f), _tp(t) {} \
        friend ostream& operator<<(ostream& s, OMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        ostream& (* _fp)(ostream&,T); \
        T _tp; \
};      \
class OAPP(T) { \
public: \
        OAPP(T)(ostream& (*f)(ostream&,T)) : _fp(f) {}  \
        OMANIP(T) operator()(T t) { return OMANIP(T)(_fp,t); } \
private:        \
        ostream& (* _fp)(ostream&,T); \
};      \
\
class IOMANIP(T) { \
public: \
        IOMANIP(T)(iostream& (*f)(iostream&,T), T t) : _fp(f), _tp(t) {} \
        friend istream& operator>>(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
        friend ostream& operator<<(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:        \
        iostream& (* _fp)(iostream&,T); \
        T _tp; \
};      \
class IOAPP(T) {        \
public: \
        IOAPP(T)( iostream& (*f)(iostream&,T)) : _fp(f) {}      \
        IOMANIP(T) operator()(T t) { return IOMANIP(T)(_fp,t); }        \
private:        \
        iostream& (* _fp)(iostream&,T); \
}; \

        
IOMANIPdeclare(int)

IOMANIPdeclare(long)

inline ios& __resetiosflags(ios& s, long _flg) { s.setf(0,_flg); return s; }
inline ios& __setfill(ios& s, int _fc) { s.fill((char)_fc); return s; }
inline ios& __setiosflags(ios& s, long _flg) { s.setf(_flg); return s; }
inline ios& __setprecision(ios& s, int _pre) { s.precision(_pre); return s; }
inline ios& __setw(ios& s, int _wid) { s.width(_wid); return s; }

inline SMANIP(long)     resetiosflags(long _l) { return SMANIP(long)(__resetiosflags, _l); }
inline SMANIP(int)      setfill(int _m) {return SMANIP(int)(__setfill, _m); }
inline SMANIP(long)     setiosflags(long _l) {return SMANIP(long)(__setiosflags, _l); }
inline SMANIP(int)      setprecision(int _p) {return SMANIP(int)(__setprecision, _p); }
inline SMANIP(int)      setw(int _w) { return SMANIP(int)(__setw, _w); }

// Restore previous packing
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOMANIP

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\iostream.h ===
/***
*iostream.h - definitions/declarations for iostream classes
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the iostream classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


typedef long streamoff, streampos;

#include <ios.h>                // Define ios.

#include <streamb.h>            // Define streambuf.

#include <istream.h>            // Define istream.

#include <ostream.h>            // Define ostream.

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP iostream : public istream, public ostream {
public:
        iostream(streambuf*);
        virtual ~iostream();
protected:
        iostream();
        iostream(const iostream&);
inline iostream& operator=(streambuf*);
inline iostream& operator=(iostream&);
private:
        iostream(ios&);
        iostream(istream&);
        iostream(ostream&);
};

inline iostream& iostream::operator=(streambuf* _sb) { istream::operator=(_sb); ostream::operator=(_sb); return *this; }

inline iostream& iostream::operator=(iostream& _strm) { return operator=(_strm.rdbuf()); }

class _CRTIMP Iostream_init {
public:
        Iostream_init();
        Iostream_init(ios &, int =0);   // treat as private
        ~Iostream_init();
};

// used internally
// static Iostream_init __iostreaminit; // initializes cin/cout/cerr/clog

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\iso646.h ===
/* iso646.h standard header */
#pragma once
#ifndef _ISO646
#define _ISO646

#if !defined(__cplusplus) || defined(_MSC_EXTENSIONS)
 #define and	&&
 #define and_eq	&=
 #define bitand	&
 #define bitor	|
 #define compl	~
 #define not	!
 #define not_eq	!=
 #define or		||
 #define or_eq	|=
 #define xor	^
 #define xor_eq	^=
#endif /* !__cplusplus || _MSC_EXTENSIONS */

#endif /* _ISO646 */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\istream.h ===
/***
*istream.h - definitions/declarations for the istream class
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the istream class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_ISTREAM
#define _INC_ISTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>

#ifdef  _MSC_VER
// C4069: "long double != double"
#pragma warning(disable:4069)   // disable C4069 warning
// #pragma warning(default:4069)    // use this to reenable, if desired

// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)    // use this to reenable, if desired
#endif  // _MSC_VER


typedef long streamoff, streampos;

class _CRTIMP istream : virtual public ios {

public:
    istream(streambuf*);
    virtual ~istream();

    int  ipfx(int =0);
    void isfx() { unlockbuf(); unlock(); }

    inline istream& operator>>(istream& (__cdecl * _f)(istream&));
    inline istream& operator>>(ios& (__cdecl * _f)(ios&));
    istream& operator>>(char *);
    inline istream& operator>>(unsigned char *);
    inline istream& operator>>(signed char *);
    istream& operator>>(char &);
    inline istream& operator>>(unsigned char &);
    inline istream& operator>>(signed char &);
    istream& operator>>(short &);
    istream& operator>>(unsigned short &);
    istream& operator>>(int &);
    istream& operator>>(unsigned int &);
    istream& operator>>(long &);
    istream& operator>>(unsigned long &);
    istream& operator>>(float &);
    istream& operator>>(double &);
    istream& operator>>(long double &);
    istream& operator>>(streambuf*);

    int get();

    inline istream& get(         char *,int,char ='\n');
    inline istream& get(unsigned char *,int,char ='\n');
    inline istream& get(  signed char *,int,char ='\n');

    istream& get(char &);
    inline istream& get(unsigned char &);
    inline istream& get(  signed char &);

    istream& get(streambuf&,char ='\n');
    inline istream& getline(         char *,int,char ='\n');
    inline istream& getline(unsigned char *,int,char ='\n');
    inline istream& getline(  signed char *,int,char ='\n');

    inline istream& ignore(int =1,int =EOF);
    istream& read(char *,int);
    inline istream& read(unsigned char *,int);
    inline istream& read(signed char *,int);

    int gcount() const { return x_gcount; }
    int peek();
    istream& putback(char);
    int sync();

    istream& seekg(streampos);
    istream& seekg(streamoff,ios::seek_dir);
    streampos tellg();

    void eatwhite();

protected:
    istream();
    istream(const istream&);    // treat as private
    istream& operator=(streambuf* _isb); // treat as private
    istream& operator=(const istream& _is) { return operator=(_is.rdbuf()); }
    istream& get(char *, int, int);
     int do_ipfx(int);

private:
    istream(ios&);
    int getint(char *);
    int getdouble(char *, int);
    int _fGline;
    int x_gcount;
};

    inline istream& istream::operator>>(istream& (__cdecl * _f)(istream&)) { (*_f)(*this); return *this; }
    inline istream& istream::operator>>(ios& (__cdecl * _f)(ios&)) { (*_f)(*this); return *this; }

    inline istream& istream::operator>>(unsigned char * _s) { return operator>>((char *)_s); }
    inline istream& istream::operator>>(  signed char * _s) { return operator>>((char *)_s); }

    inline istream& istream::operator>>(unsigned char & _c) { return operator>>((char &) _c); }
    inline istream& istream::operator>>(  signed char & _c) { return operator>>((char &) _c); }

    inline istream& istream::get(         char * _b, int _lim, char _delim) { return get(        _b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(unsigned char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }
    inline istream& istream::get(signed   char * _b, int _lim, char _delim) { return get((char *)_b, _lim, (int)(unsigned char)_delim); }

    inline istream& istream::get(unsigned char & _c) { return get((char &)_c); }
    inline istream& istream::get(  signed char & _c) { return get((char &)_c); }

    inline istream& istream::getline(         char * _b,int _lim,char _delim) { lock(); _fGline++; get(        _b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(unsigned char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }
    inline istream& istream::getline(  signed char * _b,int _lim,char _delim) { lock(); _fGline++; get((char *)_b, _lim, (int)(unsigned char)_delim); unlock(); return *this; }

    inline istream& istream::ignore(int _n,int _delim) { lock(); _fGline++; get((char *)0, _n+1, _delim); unlock(); return *this; }

    inline istream& istream::read(unsigned char * _ptr, int _n) { return read((char *) _ptr, _n); }
    inline istream& istream::read(  signed char * _ptr, int _n) { return read((char *) _ptr, _n); }

class _CRTIMP istream_withassign : public istream {
        public:
            istream_withassign();
            istream_withassign(streambuf*);
            ~istream_withassign();
    istream& operator=(const istream& _is) { return istream::operator=(_is); }
    istream& operator=(streambuf* _isb) { return istream::operator=(_isb); }
};

extern _CRTIMP istream_withassign cin;

inline _CRTIMP istream& __cdecl ws(istream& _ins) { _ins.eatwhite(); return _ins; }

_CRTIMP ios&        __cdecl dec(ios&);
_CRTIMP ios&        __cdecl hex(ios&);
_CRTIMP ios&        __cdecl oct(ios&);

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_ISTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\excpt.h ===
/***
*excpt.h - defines exception values, types and routines
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definitions and prototypes for the compiler-
*       dependent intrinsics, support functions and keywords which implement
*       the structured exception handling extensions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_EXCPT
#define _INC_EXCPT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */

#ifdef  _M_IX86

/*
 * Declarations to keep MS C 8 (386/486) compiler happy
 */
struct _EXCEPTION_RECORD;
struct _CONTEXT;

EXCEPTION_DISPOSITION __cdecl _except_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void * EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext
    );

#elif   defined(_M_IA64)

/*
 * Declarations to keep IA64 compiler happy
 */
typedef struct _EXCEPTION_POINTERS *Exception_info_ptr;
struct _EXCEPTION_RECORD;
struct _CONTEXT;
struct _DISPATCHER_CONTEXT;


_CRTIMP EXCEPTION_DISPOSITION __C_specific_handler (
    struct _EXCEPTION_RECORD *ExceptionRecord,
    unsigned __int64 MemoryStackFp,
    unsigned __int64 BackingStoreFp,
    struct _CONTEXT *ContextRecord,
    struct _DISPATCHER_CONTEXT *DispatcherContext,
    unsigned __int64 GlobalPointer
    );

#endif


/*
 * Keywords and intrinsics for SEH
 */

#ifdef  _MSC_VER

#define GetExceptionCode            _exception_code
#define exception_code              _exception_code
#define GetExceptionInformation     (struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info              (struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination         _abnormal_termination
#define abnormal_termination        _abnormal_termination

unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);

#endif


/*
 * Legal values for expression in except().
 */

#define EXCEPTION_EXECUTE_HANDLER       1
#define EXCEPTION_CONTINUE_SEARCH       0
#define EXCEPTION_CONTINUE_EXECUTION    -1



#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_EXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\float.h ===
/***
*float.h - constants for floating point values
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains defines for a number of implementation dependent
*       values which are commonly used by sophisticated numerical (floating
*       point) programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_FLOAT
#define _INC_FLOAT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#define DBL_DIG         15                      /* # of decimal digits of precision */
#define DBL_EPSILON     2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG    53                      /* # of bits in mantissa */
#define DBL_MAX         1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP  308                     /* max decimal exponent */
#define DBL_MAX_EXP     1024                    /* max binary exponent */
#define DBL_MIN         2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP  (-307)                  /* min decimal exponent */
#define DBL_MIN_EXP     (-1021)                 /* min binary exponent */
#define _DBL_RADIX      2                       /* exponent radix */
#define _DBL_ROUNDS     1                       /* addition rounding: near */

#define FLT_DIG         6                       /* # of decimal digits of precision */
#define FLT_EPSILON     1.192092896e-07F        /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD       0
#define FLT_MANT_DIG    24                      /* # of bits in mantissa */
#define FLT_MAX         3.402823466e+38F        /* max value */
#define FLT_MAX_10_EXP  38                      /* max decimal exponent */
#define FLT_MAX_EXP     128                     /* max binary exponent */
#define FLT_MIN         1.175494351e-38F        /* min positive value */
#define FLT_MIN_10_EXP  (-37)                   /* min decimal exponent */
#define FLT_MIN_EXP     (-125)                  /* min binary exponent */
#define FLT_NORMALIZE   0
#define FLT_RADIX       2                       /* exponent radix */
#define FLT_ROUNDS      1                       /* addition rounding: near */

#define LDBL_DIG        DBL_DIG                 /* # of decimal digits of precision */
#define LDBL_EPSILON    DBL_EPSILON             /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   DBL_MANT_DIG            /* # of bits in mantissa */
#define LDBL_MAX        DBL_MAX                 /* max value */
#define LDBL_MAX_10_EXP DBL_MAX_10_EXP          /* max decimal exponent */
#define LDBL_MAX_EXP    DBL_MAX_EXP             /* max binary exponent */
#define LDBL_MIN        DBL_MIN                 /* min positive value */
#define LDBL_MIN_10_EXP DBL_MIN_10_EXP          /* min decimal exponent */
#define LDBL_MIN_EXP    DBL_MIN_EXP             /* min binary exponent */
#define _LDBL_RADIX     DBL_RADIX               /* exponent radix */
#define _LDBL_ROUNDS    DBL_ROUNDS              /* addition rounding: near */

/* Function prototypes */

_CRTIMP unsigned int __cdecl _clearfp(void);
_CRTIMP unsigned int __cdecl _controlfp(unsigned int,unsigned int);
_CRTIMP unsigned int __cdecl _statusfp(void);
_CRTIMP void __cdecl _fpreset(void);

#define _clear87        _clearfp
#define _status87       _statusfp

/*
 * Abstract User Control Word Mask and bit definitions
 */
#define _MCW_EM         0x0008001f              /* interrupt Exception Masks */
#define _EM_INEXACT     0x00000001              /*   inexact (precision) */
#define _EM_UNDERFLOW   0x00000002              /*   underflow */
#define _EM_OVERFLOW    0x00000004              /*   overflow */
#define _EM_ZERODIVIDE  0x00000008              /*   zero divide */
#define _EM_INVALID     0x00000010              /*   invalid */

#define _MCW_RC         0x00000300              /* Rounding Control */
#define _RC_NEAR        0x00000000              /*   near */
#define _RC_DOWN        0x00000100              /*   down */
#define _RC_UP          0x00000200              /*   up */
#define _RC_CHOP        0x00000300              /*   chop */

/*
 * Abstract User Status Word bit definitions
 */

#define _SW_INEXACT     0x00000001              /* inexact (precision) */
#define _SW_UNDERFLOW   0x00000002              /* underflow */
#define _SW_OVERFLOW    0x00000004              /* overflow */
#define _SW_ZERODIVIDE  0x00000008              /* zero divide */
#define _SW_INVALID     0x00000010              /* invalid */


/*
 * i386 specific definitions
 */
#define _MCW_PC         0x00030000              /* Precision Control */
#define _PC_64          0x00000000              /*    64 bits */
#define _PC_53          0x00010000              /*    53 bits */
#define _PC_24          0x00020000              /*    24 bits */

#define _MCW_IC         0x00040000              /* Infinity Control */
#define _IC_AFFINE      0x00040000              /*   affine */
#define _IC_PROJECTIVE  0x00000000              /*   projective */

#define _EM_DENORMAL    0x00080000              /* denormal exception mask (_control87 only) */

#define _SW_DENORMAL    0x00080000              /* denormal status bit */


_CRTIMP unsigned int __cdecl _control87(unsigned int,unsigned int);


/*
 * RISC specific definitions
 */

#define _MCW_DN         0x03000000              /* Denormal Control */
#define _DN_SAVE        0x00000000              /*   save denormal results and operands */
#define _DN_FLUSH       0x01000000              /*   flush denormal results and operands to zero */
#define _DN_FLUSH_OPERANDS_SAVE_RESULTS 0x02000000  /*   flush operands to zero and save results */
#define _DN_SAVE_OPERANDS_FLUSH_RESULTS 0x03000000  /*   save operands and flush results to zero */


/* initial Control Word value */

#if     defined(_M_IX86)

#define _CW_DEFAULT ( _RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif   defined(_M_IA64) || defined(_M_AMD64)

#define _CW_DEFAULT ( _RC_NEAR + _PC_64 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#endif

/* Global variable holding floating point error code */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl __fpecode(void);
#define _fpecode        (*__fpecode())
#else   /* ndef _MT && ndef _DLL */
extern int _fpecode;
#endif  /* _MT || _DLL */

/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED          0x0040  /* unemulated instruction */
#define _SW_SQRTNEG             0x0080  /* square root of a neg number */
#define _SW_STACKOVERFLOW       0x0200  /* FP stack overflow */
#define _SW_STACKUNDERFLOW      0x0400  /* FP stack underflow */

/*  Floating point error signals and return codes */

#define _FPE_INVALID            0x81
#define _FPE_DENORMAL           0x82
#define _FPE_ZERODIVIDE         0x83
#define _FPE_OVERFLOW           0x84
#define _FPE_UNDERFLOW          0x85
#define _FPE_INEXACT            0x86

#define _FPE_UNEMULATED         0x87
#define _FPE_SQRTNEG            0x88
#define _FPE_STACKOVERFLOW      0x8a
#define _FPE_STACKUNDERFLOW     0x8b

#define _FPE_EXPLICITGEN        0x8c    /* raise( SIGFPE ); */


/* IEEE recommended functions */

_CRTIMP double __cdecl _copysign (double, double);
_CRTIMP double __cdecl _chgsign (double);
_CRTIMP double __cdecl _scalb(double, long);
_CRTIMP double __cdecl _logb(double);
_CRTIMP double __cdecl _nextafter(double, double);
_CRTIMP int    __cdecl _finite(double);
_CRTIMP int    __cdecl _isnan(double);
_CRTIMP int    __cdecl _fpclass(double);

#define _FPCLASS_SNAN   0x0001  /* signaling NaN */
#define _FPCLASS_QNAN   0x0002  /* quiet NaN */
#define _FPCLASS_NINF   0x0004  /* negative infinity */
#define _FPCLASS_NN     0x0008  /* negative normal */
#define _FPCLASS_ND     0x0010  /* negative denormal */
#define _FPCLASS_NZ     0x0020  /* -0 */
#define _FPCLASS_PZ     0x0040  /* +0 */
#define _FPCLASS_PD     0x0080  /* positive denormal */
#define _FPCLASS_PN     0x0100  /* positive normal */
#define _FPCLASS_PINF   0x0200  /* positive infinity */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define clear87         _clear87
#define status87        _status87
#define control87       _control87

_CRTIMP void __cdecl fpreset(void);

#define DBL_RADIX               _DBL_RADIX
#define DBL_ROUNDS              _DBL_ROUNDS

#define LDBL_RADIX              _LDBL_RADIX
#define LDBL_ROUNDS             _LDBL_ROUNDS

#define MCW_EM                  _MCW_EM
#define EM_INVALID              _EM_INVALID
#define EM_DENORMAL             _EM_DENORMAL
#define EM_ZERODIVIDE           _EM_ZERODIVIDE
#define EM_OVERFLOW             _EM_OVERFLOW
#define EM_UNDERFLOW            _EM_UNDERFLOW
#define EM_INEXACT              _EM_INEXACT

#define MCW_IC                  _MCW_IC
#define IC_AFFINE               _IC_AFFINE
#define IC_PROJECTIVE           _IC_PROJECTIVE

#define MCW_RC                  _MCW_RC
#define RC_CHOP                 _RC_CHOP
#define RC_UP                   _RC_UP
#define RC_DOWN                 _RC_DOWN
#define RC_NEAR                 _RC_NEAR

#define MCW_PC                  _MCW_PC
#define PC_24                   _PC_24
#define PC_53                   _PC_53
#define PC_64                   _PC_64

#define CW_DEFAULT              _CW_DEFAULT

#define SW_INVALID              _SW_INVALID
#define SW_DENORMAL             _SW_DENORMAL
#define SW_ZERODIVIDE           _SW_ZERODIVIDE
#define SW_OVERFLOW             _SW_OVERFLOW
#define SW_UNDERFLOW            _SW_UNDERFLOW
#define SW_INEXACT              _SW_INEXACT

#define SW_UNEMULATED           _SW_UNEMULATED
#define SW_SQRTNEG              _SW_SQRTNEG
#define SW_STACKOVERFLOW        _SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW       _SW_STACKUNDERFLOW

#define FPE_INVALID             _FPE_INVALID
#define FPE_DENORMAL            _FPE_DENORMAL
#define FPE_ZERODIVIDE          _FPE_ZERODIVIDE
#define FPE_OVERFLOW            _FPE_OVERFLOW
#define FPE_UNDERFLOW           _FPE_UNDERFLOW
#define FPE_INEXACT             _FPE_INEXACT

#define FPE_UNEMULATED          _FPE_UNEMULATED
#define FPE_SQRTNEG             _FPE_SQRTNEG
#define FPE_STACKOVERFLOW       _FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW      _FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN         _FPE_EXPLICITGEN

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_FLOAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\limits.h ===
/***
*limits.h - implementation dependent values
*
*       Copyright (c) 1985-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Contains defines for a number of implementation dependent values
*       which are commonly used in C programs.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LIMITS
#define _INC_LIMITS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define CHAR_BIT      8         /* number of bits in a char */
#define SCHAR_MIN   (-128)      /* minimum signed char value */
#define SCHAR_MAX     127       /* maximum signed char value */
#define UCHAR_MAX     0xff      /* maximum unsigned char value */

#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN   /* mimimum char value */
#define CHAR_MAX    SCHAR_MAX   /* maximum char value */
#else
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#endif  /* _CHAR_UNSIGNED */

#define MB_LEN_MAX    5             /* max. # bytes in multibyte char */
#define SHRT_MIN    (-32768)        /* minimum (signed) short value */
#define SHRT_MAX      32767         /* maximum (signed) short value */
#define USHRT_MAX     0xffff        /* maximum unsigned short value */
#define INT_MIN     (-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX       2147483647    /* maximum (signed) int value */
#define UINT_MAX      0xffffffff    /* maximum unsigned int value */
#define LONG_MIN    (-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */

#if     _INTEGRAL_MAX_BITS >= 8
#define _I8_MIN     (-127i8 - 1)    /* minimum signed 8 bit value */
#define _I8_MAX       127i8         /* maximum signed 8 bit value */
#define _UI8_MAX      0xffui8       /* maximum unsigned 8 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 16
#define _I16_MIN    (-32767i16 - 1) /* minimum signed 16 bit value */
#define _I16_MAX      32767i16      /* maximum signed 16 bit value */
#define _UI16_MAX     0xffffui16    /* maximum unsigned 16 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 32
#define _I32_MIN    (-2147483647i32 - 1) /* minimum signed 32 bit value */
#define _I32_MAX      2147483647i32 /* maximum signed 32 bit value */
#define _UI32_MAX     0xffffffffui32 /* maximum unsigned 32 bit value */
#endif

#if     _INTEGRAL_MAX_BITS >= 64
/* minimum signed 64 bit value */
#define _I64_MIN    (-9223372036854775807i64 - 1)
/* maximum signed 64 bit value */
#define _I64_MAX      9223372036854775807i64
/* maximum unsigned 64 bit value */
#define _UI64_MAX     0xffffffffffffffffui64
#endif

#if     _INTEGRAL_MAX_BITS >= 128
/* minimum signed 128 bit value */
#define _I128_MIN   (-170141183460469231731687303715884105727i128 - 1)
/* maximum signed 128 bit value */
#define _I128_MAX     170141183460469231731687303715884105727i128
/* maximum unsigned 128 bit value */
#define _UI128_MAX    0xffffffffffffffffffffffffffffffffui128
#endif

#ifdef  _POSIX_

#define _POSIX_ARG_MAX      4096
#define _POSIX_CHILD_MAX    6
#define _POSIX_LINK_MAX     8
#define _POSIX_MAX_CANON    255
#define _POSIX_MAX_INPUT    255
#define _POSIX_NAME_MAX     14
#define _POSIX_NGROUPS_MAX  0
#define _POSIX_OPEN_MAX     16
#define _POSIX_PATH_MAX     255
#define _POSIX_PIPE_BUF     512
#define _POSIX_SSIZE_MAX    32767
#define _POSIX_STREAM_MAX   8
#define _POSIX_TZNAME_MAX   3

#define ARG_MAX             14500       /* 16k heap, minus overhead */
#define LINK_MAX            1024
#define MAX_CANON           _POSIX_MAX_CANON
#define MAX_INPUT           _POSIX_MAX_INPUT
#define NAME_MAX            255
#define NGROUPS_MAX         16
#define OPEN_MAX            32
#define PATH_MAX            512
#define PIPE_BUF            _POSIX_PIPE_BUF
#define SSIZE_MAX           _POSIX_SSIZE_MAX
#define STREAM_MAX          20
#define TZNAME_MAX          10

#endif  /* POSIX */

#endif  /* _INC_LIMITS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\emmintrin.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * emmintrin.h
 *
 * Principal header file for Willamette New Instruction intrinsics
 *
 * The intrinsics package can be used in 2 ways, based whether or not
 * _EMM_FUNCTIONALITY is defined; if it is, the C implementation
 * will be used (the "functional intrinsics").
 */

#ifndef _INCLUDED_EMM
#define _INCLUDED_EMM

/*
 * the __m128 & __m64 types are required for the intrinsics
 */
#include <xmmintrin.h>

#ifdef __ICL
#ifdef _EMM_FUNCTIONALITY
#include "emm_func.h"
#else
typedef long long __m128d;
typedef long long __m128i;
#endif
#elif _MSC_VER >= 1300
typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];    
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double              m128d_f64[2];
} __m128d;
#endif

/*
 * Macro function for shuffle
 */
#define _MM_SHUFFLE2(x,y) (((x)<<1) | (y))

/*****************************************************/
/*     INTRINSICS FUNCTION PROTOTYPES START HERE     */
/*****************************************************/

#if defined __cplusplus
extern "C" { /* Begin "C" */
  /* Intrinsics use C name-mangling. */
#endif /* __cplusplus */

/*
 * DP, arithmetic
 */

extern __m128d _mm_add_sd(__m128d a, __m128d b);
extern __m128d _mm_add_pd(__m128d a, __m128d b);
extern __m128d _mm_sub_sd(__m128d a, __m128d b);
extern __m128d _mm_sub_pd(__m128d a, __m128d b);
extern __m128d _mm_mul_sd(__m128d a, __m128d b);
extern __m128d _mm_mul_pd(__m128d a, __m128d b);
extern __m128d _mm_sqrt_sd(__m128d a, __m128d b);
extern __m128d _mm_sqrt_pd(__m128d a);
extern __m128d _mm_div_sd(__m128d a, __m128d b);
extern __m128d _mm_div_pd(__m128d a, __m128d b);
extern __m128d _mm_min_sd(__m128d a, __m128d b);
extern __m128d _mm_min_pd(__m128d a, __m128d b);
extern __m128d _mm_max_sd(__m128d a, __m128d b);
extern __m128d _mm_max_pd(__m128d a, __m128d b);

/*
 * DP, logicals
 */

extern __m128d _mm_and_pd(__m128d a, __m128d b);
extern __m128d _mm_andnot_pd(__m128d a, __m128d b);
extern __m128d _mm_or_pd(__m128d a, __m128d b);
extern __m128d _mm_xor_pd(__m128d a, __m128d b);

/*
 * DP, comparisons
 */

extern __m128d _mm_cmpeq_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpeq_pd(__m128d a, __m128d b);
extern __m128d _mm_cmplt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmplt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmple_sd(__m128d a, __m128d b);
extern __m128d _mm_cmple_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpgt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpgt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpge_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpge_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpneq_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpneq_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpnlt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpnlt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpnle_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpnle_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpngt_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpngt_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpnge_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpnge_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpord_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpord_sd(__m128d a, __m128d b);
extern __m128d _mm_cmpunord_pd(__m128d a, __m128d b);
extern __m128d _mm_cmpunord_sd(__m128d a, __m128d b);
extern int _mm_comieq_sd(__m128d a, __m128d b);
extern int _mm_comilt_sd(__m128d a, __m128d b);
extern int _mm_comile_sd(__m128d a, __m128d b);
extern int _mm_comigt_sd(__m128d a, __m128d b);
extern int _mm_comige_sd(__m128d a, __m128d b);
extern int _mm_comineq_sd(__m128d a, __m128d b);
extern int _mm_ucomieq_sd(__m128d a, __m128d b);
extern int _mm_ucomilt_sd(__m128d a, __m128d b);
extern int _mm_ucomile_sd(__m128d a, __m128d b);
extern int _mm_ucomigt_sd(__m128d a, __m128d b);
extern int _mm_ucomige_sd(__m128d a, __m128d b);
extern int _mm_ucomineq_sd(__m128d a, __m128d b);

/*
 * DP, converts
 */

extern __m128d _mm_cvtepi32_pd(__m128i a);
extern __m128i _mm_cvtpd_epi32(__m128d a);
extern __m128i _mm_cvttpd_epi32(__m128d a);
extern __m128 _mm_cvtepi32_ps(__m128i a);
extern __m128i _mm_cvtps_epi32(__m128 a);
extern __m128i _mm_cvttps_epi32(__m128 a);
extern __m128 _mm_cvtpd_ps(__m128d a);
extern __m128d _mm_cvtps_pd(__m128 a);
extern __m128 _mm_cvtsd_ss(__m128 a, __m128d b);
extern __m128d _mm_cvtss_sd(__m128d a, __m128 b);

extern int _mm_cvtsd_si32(__m128d a);
extern int _mm_cvttsd_si32(__m128d a);
extern __m128d _mm_cvtsi32_sd(__m128d a, int b);

extern __m64 _mm_cvtpd_pi32(__m128d a);
extern __m64 _mm_cvttpd_pi32(__m128d a);
extern __m128d _mm_cvtpi32_pd(__m64 a);

/*
 * DP, misc
 */

extern __m128d _mm_unpackhi_pd(__m128d a, __m128d b);
extern __m128d _mm_unpacklo_pd(__m128d a, __m128d b);
extern int _mm_movemask_pd(__m128d a);
extern __m128d _mm_shuffle_pd(__m128d a, __m128d b, int i);

/*
 * DP, loads
 */

extern __m128d _mm_load_pd(double const*dp);
extern __m128d _mm_load1_pd(double const*dp);
extern __m128d _mm_loadr_pd(double const*dp);
extern __m128d _mm_loadu_pd(double const*dp);
extern __m128d _mm_load_sd(double const*dp);
extern __m128d _mm_loadh_pd(__m128d a, double const*dp);
extern __m128d _mm_loadl_pd(__m128d a, double const*dp);

/*
 * DP, sets
 */

extern __m128d _mm_set_sd(double w);
extern __m128d _mm_set1_pd(double a);
extern __m128d _mm_set_pd(double z, double y);
extern __m128d _mm_setr_pd(double y, double z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d a, __m128d b);

/* 
 * DP, stores
 */

extern void _mm_store_sd(double *dp, __m128d a);
extern void _mm_store1_pd(double *dp, __m128d a);
extern void _mm_store_pd(double *dp, __m128d a);
extern void _mm_storeu_pd(double *dp, __m128d a);
extern void _mm_storer_pd(double *dp, __m128d a);
extern void _mm_storeh_pd(double *dp, __m128d a);
extern void _mm_storel_pd(double *dp, __m128d a);

/*
 * Integer, arithmetic
 */

extern __m128i _mm_add_epi8(__m128i a, __m128i b);
extern __m128i _mm_add_epi16(__m128i a, __m128i b);
extern __m128i _mm_add_epi32(__m128i a, __m128i b);
extern __m64 _mm_add_si64(__m64 a, __m64 b);
extern __m128i _mm_add_epi64(__m128i a, __m128i b);
extern __m128i _mm_adds_epi8(__m128i a, __m128i b);
extern __m128i _mm_adds_epi16(__m128i a, __m128i b);
extern __m128i _mm_adds_epu8(__m128i a, __m128i b);
extern __m128i _mm_adds_epu16(__m128i a, __m128i b);
extern __m128i _mm_avg_epu8(__m128i a, __m128i b);
extern __m128i _mm_avg_epu16(__m128i a, __m128i b);
extern __m128i _mm_madd_epi16(__m128i a, __m128i b);
extern __m128i _mm_max_epi16(__m128i a, __m128i b);
extern __m128i _mm_max_epu8(__m128i a, __m128i b);
extern __m128i _mm_min_epi16(__m128i a, __m128i b);
extern __m128i _mm_min_epu8(__m128i a, __m128i b);
extern __m128i _mm_mulhi_epi16(__m128i a, __m128i b);
extern __m128i _mm_mulhi_epu16(__m128i a, __m128i b);
extern __m128i _mm_mullo_epi16(__m128i a, __m128i b);
extern __m64 _mm_mul_su32(__m64 a, __m64 b);
extern __m128i _mm_mul_epu32(__m128i a, __m128i b);
extern __m128i _mm_sad_epu8(__m128i a, __m128i b);
extern __m128i _mm_sub_epi8(__m128i a, __m128i b);
extern __m128i _mm_sub_epi16(__m128i a, __m128i b);
extern __m128i _mm_sub_epi32(__m128i a, __m128i b);
extern __m64 _mm_sub_si64(__m64 a, __m64 b);
extern __m128i _mm_sub_epi64(__m128i a, __m128i b);
extern __m128i _mm_subs_epi8(__m128i a, __m128i b);
extern __m128i _mm_subs_epi16(__m128i a, __m128i b);
extern __m128i _mm_subs_epu8(__m128i a, __m128i b);
extern __m128i _mm_subs_epu16(__m128i a, __m128i b);

/*
 * Integer, logicals
 */

extern __m128i _mm_and_si128(__m128i a, __m128i b);
extern __m128i _mm_andnot_si128(__m128i a, __m128i b);
extern __m128i _mm_or_si128(__m128i a, __m128i b);
extern __m128i _mm_xor_si128(__m128i a, __m128i b);

/*
 * Integer, shifts
 */

extern __m128i _mm_slli_si128(__m128i a, int imm);
extern __m128i _mm_slli_epi16(__m128i a, int count);
extern __m128i _mm_sll_epi16(__m128i a, __m128i count);
extern __m128i _mm_slli_epi32(__m128i a, int count);
extern __m128i _mm_sll_epi32(__m128i a, __m128i count);
extern __m128i _mm_slli_epi64(__m128i a, int count);
extern __m128i _mm_sll_epi64(__m128i a, __m128i count);
extern __m128i _mm_srai_epi16(__m128i a, int count);
extern __m128i _mm_sra_epi16(__m128i a, __m128i count);
extern __m128i _mm_srai_epi32(__m128i a, int count);
extern __m128i _mm_sra_epi32(__m128i a, __m128i count);
extern __m128i _mm_srli_si128(__m128i a, int imm);
extern __m128i _mm_srli_epi16(__m128i a, int count);
extern __m128i _mm_srl_epi16(__m128i a, __m128i count);
extern __m128i _mm_srli_epi32(__m128i a, int count);
extern __m128i _mm_srl_epi32(__m128i a, __m128i count);
extern __m128i _mm_srli_epi64(__m128i a, int count);
extern __m128i _mm_srl_epi64(__m128i a, __m128i count);

/*
 * Integer, comparisons
 */

extern __m128i _mm_cmpeq_epi8(__m128i a, __m128i b);
extern __m128i _mm_cmpeq_epi16(__m128i a, __m128i b);
extern __m128i _mm_cmpeq_epi32(__m128i a, __m128i b);
extern __m128i _mm_cmpgt_epi8(__m128i a, __m128i b);
extern __m128i _mm_cmpgt_epi16(__m128i a, __m128i b);
extern __m128i _mm_cmpgt_epi32(__m128i a, __m128i b);
extern __m128i _mm_cmplt_epi8(__m128i a, __m128i b);
extern __m128i _mm_cmplt_epi16(__m128i a, __m128i b);
extern __m128i _mm_cmplt_epi32(__m128i a, __m128i b);

/*
 * Integer, converts
 */

extern __m128i _mm_cvtsi32_si128(int a);
extern int _mm_cvtsi128_si32(__m128i a);

/*
 * Integer, misc
 */

extern __m128i _mm_packs_epi16(__m128i a, __m128i b);
extern __m128i _mm_packs_epi32(__m128i a, __m128i b);
extern __m128i _mm_packus_epi16(__m128i a, __m128i b);
extern int _mm_extract_epi16(__m128i a, int imm);
extern __m128i _mm_insert_epi16(__m128i a, int b, int imm);
extern int _mm_movemask_epi8(__m128i a);
extern __m128i _mm_shuffle_epi32(__m128i a, int imm);
extern __m128i _mm_shufflehi_epi16(__m128i a, int imm);
extern __m128i _mm_shufflelo_epi16(__m128i a, int imm);
extern __m128i _mm_unpackhi_epi8(__m128i a, __m128i b);
extern __m128i _mm_unpackhi_epi16(__m128i a, __m128i b);
extern __m128i _mm_unpackhi_epi32(__m128i a, __m128i b);
extern __m128i _mm_unpackhi_epi64(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi8(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi16(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi32(__m128i a, __m128i b);
extern __m128i _mm_unpacklo_epi64(__m128i a, __m128i b);

/*
 * Integer, loads
 */

extern __m128i _mm_load_si128(__m128i const*p);
extern __m128i _mm_loadu_si128(__m128i const*p);
extern __m128i _mm_loadl_epi64(__m128i const*p);

/*
 * Integer, sets
 */

extern __m128i _mm_set_epi64(__m64 q1, __m64 q0);
extern __m128i _mm_set_epi32(int i3, int i2, int i1, int i0);
extern __m128i _mm_set_epi16(short w7, short w6, short w5, short w4,
                             short w3, short w2, short w1, short w0);
extern __m128i _mm_set_epi8(char b15, char b14, char b13, char b12, 
                            char b11, char b10, char b9, char b8, 
                            char b7, char b6, char b5, char b4, 
                            char b3, char b2, char b1, char b0);
extern __m128i _mm_set1_epi64(__m64 q);
extern __m128i _mm_set1_epi32(int i);
extern __m128i _mm_set1_epi16(short w);
extern __m128i _mm_set1_epi8(char b);
extern __m128i _mm_setl_epi64(__m128i q);
extern __m128i _mm_setr_epi64(__m64 q0, __m64 q1);
extern __m128i _mm_setr_epi32(int i0, int i1, int i2, int i3);
extern __m128i _mm_setr_epi16(short w0, short w1, short w2, short w3, 
                              short w4, short w5, short w6, short w7);
extern __m128i _mm_setr_epi8(char b15, char b14, char b13, char b12, 
                             char b11, char b10, char b9, char b8, 
                             char b7, char b6, char b5, char b4, 
                             char b3, char b2, char b1, char b0);
extern __m128i _mm_setzero_si128();

/*
 * Integer, stores
 */

extern void _mm_store_si128(__m128i *p, __m128i b);
extern void _mm_storeu_si128(__m128i *p, __m128i b);
extern void _mm_storel_epi64(__m128i *p, __m128i q);
extern void _mm_maskmoveu_si128(__m128i d, __m128i n, char *p);

/*
 * Integer, moves
 */

extern __m128i _mm_move_epi64(__m128i q);
extern __m128i _mm_movpi64_epi64(__m64 q);
extern __m64 _mm_movepi64_pi64(__m128i q);

/*
 * Cacheability support
 */

extern void _mm_stream_pd(double *dp, __m128d a);
extern void _mm_stream_si128(__m128i *p, __m128i a);
extern void _mm_clflush(void const*p);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *p, int i);
extern void _mm_pause(void);

#if defined __cplusplus
}; /* End "C" */
#endif /* __cplusplus */

#endif /* _INCLUDED_EMM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the low-level
*       file handling and I/O functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_IO
#define _INC_IO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifndef _POSIX_

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _FINDDATA_T_DEFINED

struct _finddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        char        name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _finddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        char        name[260];
};

struct __finddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        char        name[260];
};

#endif

#define _FINDDATA_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _wfinddatai64_t {
        unsigned    attrib;
        time_t      time_create;    /* -1 for FAT file systems */
        time_t      time_access;    /* -1 for FAT file systems */
        time_t      time_write;
        __int64     size;
        wchar_t     name[260];
};

struct __wfinddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* File attribute constants for _findfirst() */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* function prototypes */

_CRTIMP int __cdecl _access(const char *, int);
_CRTIMP int __cdecl _chmod(const char *, int);
_CRTIMP int __cdecl _chsize(int, long);
_CRTIMP int __cdecl _close(int);
_CRTIMP int __cdecl _commit(int);
_CRTIMP int __cdecl _creat(const char *, int);
_CRTIMP int __cdecl _dup(int);
_CRTIMP int __cdecl _dup2(int, int);
_CRTIMP int __cdecl _eof(int);
_CRTIMP long __cdecl _filelength(int);
_CRTIMP intptr_t __cdecl _findfirst(const char *, struct _finddata_t *);
_CRTIMP int __cdecl _findnext(intptr_t, struct _finddata_t *);
_CRTIMP int __cdecl _findclose(intptr_t);
_CRTIMP int __cdecl _isatty(int);
_CRTIMP int __cdecl _locking(int, int, long);
_CRTIMP long __cdecl _lseek(int, long, int);
_CRTIMP char * __cdecl _mktemp(char *);
_CRTIMP int __cdecl _open(const char *, int, ...);
_CRTIMP int __cdecl _pipe(int *, unsigned int, int);
_CRTIMP int __cdecl _read(int, void *, unsigned int);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP int __cdecl _setmode(int, int);
_CRTIMP int __cdecl _sopen(const char *, int, int, ...);
_CRTIMP long __cdecl _tell(int);
_CRTIMP int __cdecl _umask(int);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl _write(int, const void *, unsigned int);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP __int64 __cdecl _filelengthi64(int);
_CRTIMP intptr_t __cdecl _findfirsti64(const char *, struct _finddatai64_t *);
_CRTIMP intptr_t __cdecl _findfirst64(const char *, struct __finddata64_t *);
_CRTIMP int __cdecl _findnexti64(intptr_t, struct _finddatai64_t *);
_CRTIMP int __cdecl _findnext64(intptr_t, struct __finddata64_t *);
_CRTIMP __int64 __cdecl _lseeki64(int, __int64, int);
_CRTIMP __int64 __cdecl _telli64(int);
#endif

#ifndef _WIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(const wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP intptr_t __cdecl _wfindfirsti64(const wchar_t *, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(const wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif


_CRTIMP intptr_t __cdecl _get_osfhandle(int);
_CRTIMP int __cdecl _open_osfhandle(intptr_t, int);

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP int __cdecl access(const char *, int);
_CRTIMP int __cdecl chmod(const char *, int);
_CRTIMP int __cdecl chsize(int, long);
_CRTIMP int __cdecl close(int);
_CRTIMP int __cdecl creat(const char *, int);
_CRTIMP int __cdecl dup(int);
_CRTIMP int __cdecl dup2(int, int);
_CRTIMP int __cdecl eof(int);
_CRTIMP long __cdecl filelength(int);
_CRTIMP int __cdecl isatty(int);
_CRTIMP int __cdecl locking(int, int, long);
_CRTIMP long __cdecl lseek(int, long, int);
_CRTIMP char * __cdecl mktemp(char *);
_CRTIMP int __cdecl open(const char *, int, ...);
_CRTIMP int __cdecl read(int, void *, unsigned int);
_CRTIMP int __cdecl setmode(int, int);
_CRTIMP int __cdecl sopen(const char *, int, int, ...);
_CRTIMP long __cdecl tell(int);
_CRTIMP int __cdecl umask(int);
_CRTIMP int __cdecl unlink(const char *);
_CRTIMP int __cdecl write(int, const void *, unsigned int);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_IO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\dvec.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to Willamette New Instruction intrinsics.
 *
 *	File name : dvec.h  class definitions
 *
 *	Concept: A C++ abstraction of Willamette new intructions designed to improve
 *  programmer productivity.  Speed and accuracy are sacrificed for utility.
 *	Facilitates an easy transition to compiler intrinsics
 *	or assembly language.
 *
 */

#ifndef DVEC_H_INCLUDED
#define DVEC_H_INCLUDED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#include <emmintrin.h> /* Willamette New Instructions Intrinsics include file */
#include <assert.h>
#include <fvec.h>

/* Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output */
#if defined(_ENABLE_VEC_DEBUG)
	#include <iostream>
#endif

#pragma pack(push,16) /* Must ensure class & union 16-B aligned */


/* If using MSVC5.0, explicit keyword should be used */
#if (_MSC_VER >= 1100)
        #define EXPLICIT explicit
#else
   #if (__ICL)
        #define EXPLICIT __explicit /* If MSVC4.x & ICL, use __explicit */
   #else
        #define EXPLICIT /* nothing */
        #pragma message( "explicit keyword not recognized")
   #endif
#endif

/* EMM Functionality Intrinsics */

class I8vec16;			/* 16 elements, each element a signed or unsigned char data type */
class Is8vec16;			/* 16 elements, each element a signed char data type */
class Iu8vec16;			/* 16 elements, each element an unsigned char data type */
class I16vec8;			/* 8 elements, each element a signed or unsigned short */
class Is16vec8;			/* 8 elements, each element a signed short */
class Iu16vec8;			/* 8 elements, each element an unsigned short */
class I32vec4;			/* 4 elements, each element a signed or unsigned long */
class Is32vec4;			/* 4 elements, each element a signed long */
class Iu32vec4;			/* 4 elements, each element a unsigned long */
class I64vec2;			/* 2 element, each a __m64 data type */
class I128vec1;			/* 1 element, a __m128i data type */

#define _MM_16UB(element,vector) (*((unsigned char*)&##vector + ##element))
#define _MM_16B(element,vector) (*((signed char*)&##vector + ##element))

#define _MM_8UW(element,vector) (*((unsigned short*)&##vector + ##element))
#define _MM_8W(element,vector) (*((short*)&##vector + ##element))

#define _MM_4UDW(element,vector) (*((unsigned int*)&##vector + ##element))
#define _MM_4DW(element,vector) (*((int*)&##vector + ##element))

#define _MM_2QW(element,vector) (*((__int64*)&##vector + ##element))


/* We need a m128i constant, keeping performance in mind*/

inline const __m128i get_mask128()
{
	static const __m128i mask128 = _mm_set1_epi64(M64(0xffffffffffffffffi64));
	return mask128;
}


/* M128 Class:
 * 1 element, a __m128i data type
 * Contructors & Logical Operations
 */

class M128
{
protected:
		__m128i vec;

public:
	M128()									{ }
	M128(__m128i mm)						{ vec = mm; }

	operator __m128i() const					{ return vec; }

	/* Logical Operations */
	M128& operator&=(const M128 &a)					{ return *this = (M128) _mm_and_si128(vec,a); }
	M128& operator|=(const M128 &a)					{ return *this = (M128) _mm_or_si128(vec,a); }
	M128& operator^=(const M128 &a)					{ return *this = (M128) _mm_xor_si128(vec,a); }

};

inline M128 operator&(const M128 &a, const M128 &b)	{ return _mm_and_si128(a,b); }
inline M128 operator|(const M128 &a, const M128 &b)	{ return _mm_or_si128(a,b); }
inline M128 operator^(const M128 &a, const M128 &b)	{ return _mm_xor_si128(a,b); }
inline M128 andnot(const M128 &a, const M128 &b)	{ return _mm_andnot_si128(a,b); }

/* I128vec1 Class:
 * 1 element, a __m128i data type
 * Contains Operations which can operate on any __m6128i data type
 */

class I128vec1 : public M128
{
public:
	I128vec1()								{ }
	I128vec1(__m128i mm) : M128(mm)				{ }

	I128vec1& operator= (const M128 &a) { return *this = (I128vec1) a; }
	I128vec1& operator&=(const M128 &a) { return *this = (I128vec1) _mm_and_si128(vec,a); }
	I128vec1& operator|=(const M128 &a) { return *this = (I128vec1) _mm_or_si128(vec,a); }
	I128vec1& operator^=(const M128 &a) { return *this = (I128vec1) _mm_xor_si128(vec,a); }

};

/* I64vec2 Class:
 * 2 elements, each element signed or unsigned 64-bit integer
 */
class I64vec2 : public M128
{
public:
	I64vec2() { }
	I64vec2(__m128i mm) : M128(mm) { }

	I64vec2(__m64 q1, __m64 q0)
	{
		_MM_2QW(0,vec) = *(__int64*)&q0;
		_MM_2QW(1,vec) = *(__int64*)&q1;
	}

	/* Assignment Operator */
	I64vec2& operator= (const M128 &a) { return *this = (I64vec2) a; }

	/* Logical Assignment Operators */
	I64vec2& operator&=(const M128 &a) { return *this = (I64vec2) _mm_and_si128(vec,a); }
	I64vec2& operator|=(const M128 &a) { return *this = (I64vec2) _mm_or_si128(vec,a); }
	I64vec2& operator^=(const M128 &a) { return *this = (I64vec2) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I64vec2& operator +=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_add_epi64(vec,a); }
	I64vec2& operator -=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_sub_epi64(vec,a); }

	/* Shift Logical Operators */
	I64vec2 operator<<(const I64vec2 &a) 			{ return _mm_sll_epi64(vec,a); }
	I64vec2 operator<<(int count) 					{ return _mm_slli_epi64(vec,count); }
	I64vec2& operator<<=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_sll_epi64(vec,a); }
	I64vec2& operator<<=(int count) 				{ return *this = (I64vec2) _mm_slli_epi64(vec,count); }
	I64vec2 operator>>(const I64vec2 &a) 			{ return _mm_srl_epi64(vec,a); }
	I64vec2 operator>>(int count) 					{ return _mm_srli_epi64(vec,count); }
	I64vec2& operator>>=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_srl_epi64(vec,a); }
	I64vec2& operator>>=(int count) 				{ return *this = (I64vec2) _mm_srli_epi64(vec,count); }

	/* Element Access for Debug, No data modified */
	const __int64& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2QW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	__int64& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2QW(i,vec);
	}


};

/* Unpacks */
inline I64vec2 unpack_low(const I64vec2 &a, const I64vec2 &b) 	{return _mm_unpacklo_epi64(a,b); }
inline I64vec2 unpack_high(const I64vec2 &a, const I64vec2 &b) 	{return _mm_unpackhi_epi64(a,b); }

/* I32vec4 Class:
 * 4 elements, each element either a signed or unsigned int
 */
class I32vec4 : public M128
{
public:
	I32vec4() { }
	I32vec4(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I32vec4& operator= (const M128 &a)				{ return *this = (I32vec4) a; }

	/* Logicals Operators */
	I32vec4& operator&=(const M128 &a)				{ return *this = (I32vec4) _mm_and_si128(vec,a); }
	I32vec4& operator|=(const M128 &a)				{ return *this = (I32vec4) _mm_or_si128(vec,a); }
	I32vec4& operator^=(const M128 &a)				{ return *this = (I32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I32vec4& operator +=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_add_epi32(vec,a); }
	I32vec4& operator -=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_sub_epi32(vec,a); }

	/* Shift Logical Operators */
	I32vec4 operator<<(const I32vec4 &a) 			{ return _mm_sll_epi32(vec,a); }
	I32vec4 operator<<(int count) 					{ return _mm_slli_epi32(vec,count); }
	I32vec4& operator<<=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_sll_epi32(vec,a); }
	I32vec4& operator<<=(int count) 				{ return *this = (I32vec4)_mm_slli_epi32(vec,count); }

};

inline I32vec4 cmpeq(const I32vec4 &a, const I32vec4 &b) 	    { return _mm_cmpeq_epi32(a,b); }
inline I32vec4 cmpneq(const I32vec4 &a, const I32vec4 &b) 	    { return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }

inline I32vec4 unpack_low(const I32vec4 &a, const I32vec4 &b) 	{ return _mm_unpacklo_epi32(a,b); }
inline I32vec4 unpack_high(const I32vec4 &a, const I32vec4 &b) 	{ return _mm_unpackhi_epi32(a,b); }

/* Is32vec4 Class:
 * 4 elements, each element signed integer
 */
class Is32vec4 : public I32vec4
{
public:
	Is32vec4() { }
	Is32vec4(__m128i mm) : I32vec4(mm) { }
	Is32vec4(int i3, int i2, int i1, int i0)
	{
		_MM_4DW(0,vec) = i0;
		_MM_4DW(1,vec) = i1;
		_MM_4DW(2,vec) = i2;
		_MM_4DW(3,vec) = i3;
	}

	/* Assignment Operator */
	Is32vec4& operator= (const M128 &a)		{ return *this = (Is32vec4) a; }

	/* Logical Operators */
	Is32vec4& operator&=(const M128 &a)		{ return *this = (Is32vec4) _mm_and_si128(vec,a); }
	Is32vec4& operator|=(const M128 &a)		{ return *this = (Is32vec4) _mm_or_si128(vec,a); }
	Is32vec4& operator^=(const M128 &a)		{ return *this = (Is32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is32vec4& operator +=(const I32vec4 &a)	{ return *this = (Is32vec4)_mm_add_epi32(vec,a); }
	Is32vec4& operator -=(const I32vec4 &a)	{ return *this = (Is32vec4)_mm_sub_epi32(vec,a); }

	/* Shift Logical Operators */
	Is32vec4 operator<<(const M128 &a) 		{ return _mm_sll_epi32(vec,a); }
	Is32vec4 operator<<(int count) 			{ return _mm_slli_epi32(vec,count); }
	Is32vec4& operator<<=(const M128 &a)	{ return *this = (Is32vec4)_mm_sll_epi32(vec,a); }
	Is32vec4& operator<<=(int count) 		{ return *this = (Is32vec4)_mm_slli_epi32(vec,count); }
	/* Shift Arithmetic Operations */
	Is32vec4 operator>>(const M128 &a) 		{ return _mm_sra_epi32(vec,a); }
	Is32vec4 operator>>(int count) 			{ return _mm_srai_epi32(vec,count); }
	Is32vec4& operator>>=(const M128 &a)	{ return *this = (Is32vec4) _mm_sra_epi32(vec,a); }
	Is32vec4& operator>>=(int count) 		{ return *this = (Is32vec4) _mm_srai_epi32(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is32vec4 &a)
	{
		os << "[3]:" << _MM_4DW(3,a)
			<< " [2]:" << _MM_4DW(2,a)
			<< " [1]:" << _MM_4DW(1,a)
			<< " [0]:" << _MM_4DW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4DW(i,vec);
	}

	/* Element Access for Debug */
	int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4DW(i,vec);
	}
};

/* Compares */
inline Is32vec4 cmpeq(const Is32vec4 &a, const Is32vec4 &b) 	    	{ return _mm_cmpeq_epi32(a,b); }
inline Is32vec4 cmpneq(const Is32vec4 &a, const Is32vec4 &b)			{ return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }
inline Is32vec4 cmpgt(const Is32vec4 &a, const Is32vec4 &b)				{ return _mm_cmpgt_epi32(a,b); }
inline Is32vec4 cmplt(const Is32vec4 &a, const Is32vec4 &b)				{ return _mm_cmpgt_epi32(b,a); }

/* Unpacks */
inline Is32vec4 unpack_low(const Is32vec4 &a, const Is32vec4 &b) 		{ return _mm_unpacklo_epi32(a,b); }
inline Is32vec4 unpack_high(const Is32vec4 &a, const Is32vec4 &b)		{ return _mm_unpackhi_epi32(a,b); }



/* Iu32vec4 Class:
 * 4 elements, each element unsigned int
 */
class Iu32vec4 : public I32vec4
{
public:
	Iu32vec4() { }
	Iu32vec4(__m128i mm) : I32vec4(mm) { }
	Iu32vec4(unsigned int ui3, unsigned int ui2, unsigned int ui1, unsigned int ui0)
	{
		_MM_4UDW(0,vec) = ui0;
		_MM_4UDW(1,vec) = ui1;
		_MM_4UDW(2,vec) = ui2;
		_MM_4UDW(3,vec) = ui3;
	}

	/* Assignment Operator */
	Iu32vec4& operator= (const M128 &a)		{ return *this = (Iu32vec4) a; }

	/* Logical Assignment Operators */
	Iu32vec4& operator&=(const M128 &a)		{ return *this = (Iu32vec4) _mm_and_si128(vec,a); }
	Iu32vec4& operator|=(const M128 &a)		{ return *this = (Iu32vec4) _mm_or_si128(vec,a); }
	Iu32vec4& operator^=(const M128 &a)		{ return *this = (Iu32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu32vec4& operator +=(const I32vec4 &a)	{ return *this = (Iu32vec4)_mm_add_epi32(vec,a); }
	Iu32vec4& operator -=(const I32vec4 &a)	{ return *this = (Iu32vec4)_mm_sub_epi32(vec,a); }

	/* Shift Logical Operators */
	Iu32vec4 operator<<(const M128 &a) 				{ return _mm_sll_epi32(vec,a); }
	Iu32vec4 operator<<(int count) 					{ return _mm_slli_epi32(vec,count); }
	Iu32vec4& operator<<=(const M128 &a)			{ return *this = (Iu32vec4)_mm_sll_epi32(vec,a); }
	Iu32vec4& operator<<=(int count) 				{ return *this = (Iu32vec4)_mm_slli_epi32(vec,count); }
	Iu32vec4 operator>>(const M128 &a) 				{ return _mm_srl_epi32(vec,a); }
	Iu32vec4 operator>>(int count) 					{ return _mm_srli_epi32(vec,count); }
	Iu32vec4& operator>>=(const M128 &a)			{ return *this = (Iu32vec4) _mm_srl_epi32(vec,a); }
	Iu32vec4& operator>>=(int count) 				{ return *this = (Iu32vec4) _mm_srli_epi32(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Iu32vec4 &a)
	{
		os << "[3]:" << _MM_4UDW(3,a)
			<< " [2]:" << _MM_4UDW(2,a)
			<< " [1]:" << _MM_4UDW(1,a)
			<< " [0]:" << _MM_4UDW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UDW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	unsigned int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UDW(i,vec);
	}
};

inline I64vec2 operator*(const Iu32vec4 &a, const Iu32vec4 &b) { return _mm_mul_epu32(a,b); }
inline Iu32vec4 cmpeq(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_cmpeq_epi32(a,b); }
inline Iu32vec4 cmpneq(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }

inline Iu32vec4 unpack_low(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_unpacklo_epi32(a,b); }
inline Iu32vec4 unpack_high(const Iu32vec4 &a, const Iu32vec4 &b)	{ return _mm_unpackhi_epi32(a,b); }

/* I16vec8 Class:
 * 8 elements, each element either unsigned or signed short
 */
class I16vec8 : public M128
{
public:
	I16vec8() { }
	I16vec8(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I16vec8& operator= (const M128 &a)		{ return *this = (I16vec8) a; }

	/* Logical Assignment Operators */
	I16vec8& operator&=(const M128 &a)		{ return *this = (I16vec8) _mm_and_si128(vec,a); }
	I16vec8& operator|=(const M128 &a)		{ return *this = (I16vec8) _mm_or_si128(vec,a); }
	I16vec8& operator^=(const M128 &a)		{ return *this = (I16vec8) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I16vec8& operator +=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_add_epi16(vec,a); }
	I16vec8& operator -=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_sub_epi16(vec,a); }
	I16vec8& operator *=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_mullo_epi16(vec,a); }

	/* Shift Logical Operators */
	I16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	I16vec8 operator<<(int count) 				{ return _mm_slli_epi16(vec,count); }
	I16vec8& operator<<=(const M128 &a)				{ return *this = (I16vec8)_mm_sll_epi16(vec,a); }
	I16vec8& operator<<=(int count) 				{ return *this = (I16vec8)_mm_slli_epi16(vec,count); }

};


inline I16vec8 operator*(const I16vec8 &a, const I16vec8 &b)	{ return _mm_mullo_epi16(a,b); }

inline I16vec8 cmpeq(const I16vec8 &a, const I16vec8 &b) 		{ return _mm_cmpeq_epi16(a,b); }
inline I16vec8 cmpneq(const I16vec8 &a, const I16vec8 &b) 		{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }

inline I16vec8 unpack_low(const I16vec8 &a, const I16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline I16vec8 unpack_high(const I16vec8 &a, const I16vec8 &b) 	{ return _mm_unpackhi_epi16(a,b); }

/* Is16vec8 Class:
 * 8 elements, each element signed short
 */
class Is16vec8 : public I16vec8
{
public:
	Is16vec8() { }
	Is16vec8(__m128i mm) : I16vec8(mm) { }
	Is16vec8(signed short s7,signed short s6,signed short s5,signed short s4,signed short s3,signed short s2,signed short s1,signed short s0)
	 {
		_MM_8W(0,vec) = s0;
		_MM_8W(1,vec) = s1;
		_MM_8W(2,vec) = s2;
		_MM_8W(3,vec) = s3;
		_MM_8W(4,vec) = s4;
		_MM_8W(5,vec) = s5;
		_MM_8W(6,vec) = s6;
		_MM_8W(7,vec) = s7;
	}

	/* Assignment Operator */
	Is16vec8& operator= (const M128 &a)		{ return *this = (Is16vec8) a; }

	/* Logical Assignment Operators */
	Is16vec8& operator&=(const M128 &a)		{ return *this = (Is16vec8) _mm_and_si128(vec,a); }
	Is16vec8& operator|=(const M128 &a)		{ return *this = (Is16vec8) _mm_or_si128(vec,a); }
	Is16vec8& operator^=(const M128 &a)		{ return *this = (Is16vec8) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is16vec8& operator +=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_add_epi16(vec,a); }
	Is16vec8& operator -=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_sub_epi16(vec,a); }
	Is16vec8& operator *=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_mullo_epi16(vec,a); }

	/* Shift Logical Operators */
	Is16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	Is16vec8 operator<<(int count) 				{ return _mm_slli_epi16(vec,count); }
	Is16vec8& operator<<=(const M128 &a)			{ return *this = (Is16vec8)_mm_sll_epi16(vec,a); }
	Is16vec8& operator<<=(int count) 				{ return *this = (Is16vec8)_mm_slli_epi16(vec,count); }
	/* Shift Arithmetic Operators */
	Is16vec8 operator>>(const M128 &a) 				{ return _mm_sra_epi16(vec,a); }
	Is16vec8 operator>>(int count) 				{ return _mm_srai_epi16(vec,count); }
	Is16vec8& operator>>=(const M128 &a)			{ return *this = (Is16vec8)_mm_sra_epi16(vec,a); }
	Is16vec8& operator>>=(int count) 				{ return *this = (Is16vec8)_mm_srai_epi16(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is16vec8 &a)
	{
		os << "[7]:" << _MM_8W(7,a)
			<< " [6]:" << _MM_8W(6,a)
			<< " [5]:" << _MM_8W(5,a)
			<< " [4]:" << _MM_8W(4,a)
			<< " [3]:" << _MM_8W(3,a)
			<< " [2]:" << _MM_8W(2,a)
			<< " [1]:" << _MM_8W(1,a)
			<< " [0]:" << _MM_8W(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const signed short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8W(i,vec);
	}

	/* Element Access and Assignment for Debug */
	signed short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8W(i,vec);
	}
};

inline Is16vec8 operator*(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_mullo_epi16(a,b); }


/* Additional Is16vec8 functions: compares, unpacks, sat add/sub */
inline Is16vec8 cmpeq(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_cmpeq_epi16(a,b); }
inline Is16vec8 cmpneq(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }
inline Is16vec8 cmpgt(const Is16vec8 &a, const Is16vec8 &b)		{ return _mm_cmpgt_epi16(a,b); }
inline Is16vec8 cmplt(const Is16vec8 &a, const Is16vec8 &b)		{ return _mm_cmpgt_epi16(b,a); }

inline Is16vec8 unpack_low(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline Is16vec8 unpack_high(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_unpackhi_epi16(a,b); }

inline Is16vec8 mul_high(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_mulhi_epi16(a,b); }
inline Is32vec4 mul_add(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_madd_epi16(a,b);}

inline Is16vec8 sat_add(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_adds_epi16(a,b); }
inline Is16vec8 sat_sub(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_subs_epi16(a,b); }

inline Is16vec8 simd_max(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_max_epi16(a,b); }
inline Is16vec8 simd_min(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_min_epi16(a,b); }


/* Iu16vec8 Class:
 * 8 elements, each element unsigned short
 */
class Iu16vec8 : public I16vec8
{
public:
	Iu16vec8() { }
	Iu16vec8(__m128i mm) : I16vec8(mm) { }
	Iu16vec8(unsigned short s7,unsigned short s6,unsigned short s5,unsigned short s4, unsigned short s3,unsigned short s2,unsigned short s1,unsigned short s0)
	{
		_MM_8UW(0,vec) = s0;
		_MM_8UW(1,vec) = s1;
		_MM_8UW(2,vec) = s2;
		_MM_8UW(3,vec) = s3;
		_MM_8UW(4,vec) = s4;
		_MM_8UW(5,vec) = s5;
		_MM_8UW(6,vec) = s6;
		_MM_8UW(7,vec) = s7;
	}

	/* Assignment Operator */
	Iu16vec8& operator= (const M128 &a)		{ return *this = (Iu16vec8) a; }
	/* Logical Assignment Operators */
	Iu16vec8& operator&=(const M128 &a)		{ return *this = (Iu16vec8) _mm_and_si128(vec,a); }
	Iu16vec8& operator|=(const M128 &a)		{ return *this = (Iu16vec8) _mm_or_si128(vec,a); }
	Iu16vec8& operator^=(const M128 &a)		{ return *this = (Iu16vec8) _mm_xor_si128(vec,a); }
	/* Addition & Subtraction Assignment Operators */
	Iu16vec8& operator +=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_add_epi16(vec,a); }
	Iu16vec8& operator -=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_sub_epi16(vec,a); }
	Iu16vec8& operator *=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_mullo_epi16(vec,a); }

	/* Shift Logical Operators */
	Iu16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	Iu16vec8 operator<<(int count) 					{ return _mm_slli_epi16(vec,count); }
	Iu16vec8& operator<<=(const M128 &a)			{ return *this = (Iu16vec8)_mm_sll_epi16(vec,a); }
	Iu16vec8& operator<<=(int count) 				{ return *this = (Iu16vec8)_mm_slli_epi16(vec,count); }
	Iu16vec8 operator>>(const M128 &a) 				{ return _mm_srl_epi16(vec,a); }
	Iu16vec8 operator>>(int count) 					{ return _mm_srli_epi16(vec,count); }
	Iu16vec8& operator>>=(const M128 &a)			{ return *this = (Iu16vec8) _mm_srl_epi16(vec,a); }
	Iu16vec8& operator>>=(int count) 				{ return *this = (Iu16vec8) _mm_srli_epi16(vec,count); }


#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Iu16vec8 &a)
	{
		 os << "[7]:"  << unsigned short(_MM_8UW(7,a))
			<< " [6]:" << unsigned short(_MM_8UW(6,a))
			<< " [5]:" << unsigned short(_MM_8UW(5,a))
			<< " [4]:" << unsigned short(_MM_8UW(4,a))
			<< " [3]:" << unsigned short(_MM_8UW(3,a))
			<< " [2]:" << unsigned short(_MM_8UW(2,a))
			<< " [1]:" << unsigned short(_MM_8UW(1,a))
			<< " [0]:" << unsigned short(_MM_8UW(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UW(i,vec);
	}

	/* Element Access for Debug */
	unsigned short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UW(i,vec);
	}
};

inline Iu16vec8 operator*(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_mullo_epi16(a,b); }

/* Additional Iu16vec8 functions: cmpeq,cmpneq, unpacks, sat add/sub */
inline Iu16vec8 cmpeq(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_cmpeq_epi16(a,b); }
inline Iu16vec8 cmpneq(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }

inline Iu16vec8 unpack_low(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline Iu16vec8 unpack_high(const Iu16vec8 &a, const Iu16vec8 &b) { return _mm_unpackhi_epi16(a,b); }

inline Iu16vec8 sat_add(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_adds_epu16(a,b); }
inline Iu16vec8 sat_sub(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_subs_epu16(a,b); }

inline Iu16vec8 simd_avg(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_avg_epu16(a,b); }
inline I16vec8 mul_high(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_mulhi_epu16(a,b); }

/* I8vec16 Class:
 * 16 elements, each element either unsigned or signed char
 */
class I8vec16 : public M128
{
public:
	I8vec16() { }
	I8vec16(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I8vec16& operator= (const M128 &a)		{ return *this = (I8vec16) a; }

	/* Logical Assignment Operators */
	I8vec16& operator&=(const M128 &a)		{ return *this = (I8vec16) _mm_and_si128(vec,a); }
	I8vec16& operator|=(const M128 &a)		{ return *this = (I8vec16) _mm_or_si128(vec,a); }
	I8vec16& operator^=(const M128 &a)		{ return *this = (I8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I8vec16& operator +=(const I8vec16 &a)	{ return *this = (I8vec16) _mm_add_epi8(vec,a); }
	I8vec16& operator -=(const I8vec16 &a)	{ return *this = (I8vec16) _mm_sub_epi8(vec,a); }

};

inline I8vec16 cmpeq(const I8vec16 &a, const I8vec16 &b) 		{ return _mm_cmpeq_epi8(a,b); }
inline I8vec16 cmpneq(const I8vec16 &a, const I8vec16 &b) 		{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }

inline I8vec16 unpack_low(const I8vec16 &a, const I8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline I8vec16 unpack_high(const I8vec16 &a, const I8vec16 &b)	{ return _mm_unpackhi_epi8(a,b); }

/* Is8vec16 Class:
 * 16 elements, each element a signed char
 */
class Is8vec16 : public I8vec16
{
public:
	Is8vec16() { }
	Is8vec16(__m128i mm) : I8vec16(mm) { }

	/* Assignment Operator */
	Is8vec16& operator= (const M128 &a)		{ return *this = (Is8vec16) a; }

	/* Logical Assignment Operators */
	Is8vec16& operator&=(const M128 &a)		{ return *this = (Is8vec16) _mm_and_si128(vec,a); }
	Is8vec16& operator|=(const M128 &a)		{ return *this = (Is8vec16) _mm_or_si128(vec,a); }
	Is8vec16& operator^=(const M128 &a)		{ return *this = (Is8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is8vec16& operator +=(const I8vec16 &a)	{ return *this = (Is8vec16) _mm_add_epi8(vec,a); }
	Is8vec16& operator -=(const I8vec16 &a)	{ return *this = (Is8vec16) _mm_sub_epi8(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Is8vec16 &a)
	{
		 os << "[15]:"  << short(_MM_16B(15,a))
			<< " [14]:" << short(_MM_16B(14,a))
			<< " [13]:" << short(_MM_16B(13,a))
			<< " [12]:" << short(_MM_16B(12,a))
			<< " [11]:" << short(_MM_16B(11,a))
			<< " [10]:" << short(_MM_16B(10,a))
			<< " [9]:" << short(_MM_16B(9,a))
			<< " [8]:" << short(_MM_16B(8,a))
		      << " [7]:" << short(_MM_16B(7,a))
			<< " [6]:" << short(_MM_16B(6,a))
			<< " [5]:" << short(_MM_16B(5,a))
			<< " [4]:" << short(_MM_16B(4,a))
			<< " [3]:" << short(_MM_16B(3,a))
			<< " [2]:" << short(_MM_16B(2,a))
			<< " [1]:" << short(_MM_16B(1,a))
			<< " [0]:" << short(_MM_16B(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const signed char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16B(i,vec);
	}

	/* Element Access for Debug */
	signed char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16B(i,vec);
	}

};

inline Is8vec16 cmpeq(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmpeq_epi8(a,b); }
inline Is8vec16 cmpneq(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }
inline Is8vec16 cmpgt(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmpgt_epi8(a,b); }
inline Is8vec16 cmplt(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmplt_epi8(a,b); }

inline Is8vec16 unpack_low(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline Is8vec16 unpack_high(const Is8vec16 &a, const Is8vec16 &b) { return _mm_unpackhi_epi8(a,b); }

inline Is8vec16 sat_add(const Is8vec16 &a, const Is8vec16 &b)	{ return _mm_adds_epi8(a,b); }
inline Is8vec16 sat_sub(const Is8vec16 &a, const Is8vec16 &b)	{ return _mm_subs_epi8(a,b); }

/* Iu8vec16 Class:
 * 16 elements, each element a unsigned char
 */
class Iu8vec16 : public I8vec16
{
public:
	Iu8vec16() { }
	Iu8vec16(__m128i mm) : I8vec16(mm) { }

	/* Assignment Operator */
	Iu8vec16& operator= (const M128 &a)		{ return *this = (Iu8vec16) a; }

	/* Logical Assignment Operators */
	Iu8vec16& operator&=(const M128 &a)		{ return *this = (Iu8vec16) _mm_and_si128(vec,a); }
	Iu8vec16& operator|=(const M128 &a)		{ return *this = (Iu8vec16) _mm_or_si128(vec,a); }
	Iu8vec16& operator^=(const M128 &a)		{ return *this = (Iu8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu8vec16& operator +=(const I8vec16 &a)	{ return *this = (Iu8vec16) _mm_add_epi8(vec,a); }
	Iu8vec16& operator -=(const I8vec16 &a)	{ return *this = (Iu8vec16) _mm_sub_epi8(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Iu8vec16 &a)
	{
		 os << "[15]:"  << unsigned short(_MM_16UB(15,a))
			<< " [14]:" << unsigned short(_MM_16UB(14,a))
			<< " [13]:" << unsigned short(_MM_16UB(13,a))
			<< " [12]:" << unsigned short(_MM_16UB(12,a))
			<< " [11]:" << unsigned short(_MM_16UB(11,a))
			<< " [10]:" << unsigned short(_MM_16UB(10,a))
			<< " [9]:" << unsigned short(_MM_16UB(9,a))
			<< " [8]:" << unsigned short(_MM_16UB(8,a))
		      << " [7]:" << unsigned short(_MM_16UB(7,a))
			<< " [6]:" << unsigned short(_MM_16UB(6,a))
			<< " [5]:" << unsigned short(_MM_16UB(5,a))
			<< " [4]:" << unsigned short(_MM_16UB(4,a))
			<< " [3]:" << unsigned short(_MM_16UB(3,a))
			<< " [2]:" << unsigned short(_MM_16UB(2,a))
			<< " [1]:" << unsigned short(_MM_16UB(1,a))
			<< " [0]:" << unsigned short(_MM_16UB(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16UB(i,vec);
	}

	/* Element Access for Debug */
	unsigned char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16UB(i,vec);
	}

};

inline Iu8vec16 cmpeq(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_cmpeq_epi8(a,b); }
inline Iu8vec16 cmpneq(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }

inline Iu8vec16 unpack_low(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline Iu8vec16 unpack_high(const Iu8vec16 &a, const Iu8vec16 &b) { return _mm_unpackhi_epi8(a,b); }

inline Iu8vec16 sat_add(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_adds_epu8(a,b); }
inline Iu8vec16 sat_sub(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_subs_epu8(a,b); }

inline I64vec2 sum_abs(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_sad_epu8(a,b); }

inline Iu8vec16 simd_avg(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_avg_epu8(a,b); }
inline Iu8vec16 simd_max(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_max_epu8(a,b); }
inline Iu8vec16 simd_min(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_min_epu8(a,b); }

/* Pack & Saturates */

inline Is16vec8 pack_sat(const Is32vec4 &a, const Is32vec4 &b) 	{ return _mm_packs_epi32(a,b); }
inline Is8vec16 pack_sat(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_packs_epi16(a,b); }
inline Iu8vec16 packu_sat(const Is16vec8 &a, const Is16vec8 &b) { return _mm_packus_epi16(a,b);}

/********************************* Logicals ****************************************/
#define IVEC128_LOGICALS(vect,element) \
inline I##vect##vec##element operator& (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_and_si128( a,b); } \
inline I##vect##vec##element operator| (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_or_si128( a,b); } \
inline I##vect##vec##element operator^ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_xor_si128( a,b); } \
inline I##vect##vec##element andnot (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_andnot_si128( a,b); }

IVEC128_LOGICALS(8,16)
IVEC128_LOGICALS(u8,16)
IVEC128_LOGICALS(s8,16)
IVEC128_LOGICALS(16,8)
IVEC128_LOGICALS(u16,8)
IVEC128_LOGICALS(s16,8)
IVEC128_LOGICALS(32,4)
IVEC128_LOGICALS(u32,4)
IVEC128_LOGICALS(s32,4)
IVEC128_LOGICALS(64,2)
IVEC128_LOGICALS(128,1)
#undef IVEC128_LOGICALS

/********************************* Add & Sub ****************************************/
#define IVEC128_ADD_SUB(vect,element,opsize) \
inline I##vect##vec##element operator+ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_add_##opsize( a,b); } \
inline I##vect##vec##element operator- (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_sub_##opsize( a,b); }

IVEC128_ADD_SUB(8,16, epi8)
IVEC128_ADD_SUB(u8,16, epi8)
IVEC128_ADD_SUB(s8,16, epi8)
IVEC128_ADD_SUB(16,8, epi16)
IVEC128_ADD_SUB(u16,8, epi16)
IVEC128_ADD_SUB(s16,8, epi16)
IVEC128_ADD_SUB(32,4, epi32)
IVEC128_ADD_SUB(u32,4, epi32)
IVEC128_ADD_SUB(s32,4, epi32)
IVEC128_ADD_SUB(64,2, epi64)
#undef IVEC128_ADD_SUB

/********************************* Conditional Select ****************************************/
/*	version of: retval = (a OP b)? c : d;													 *
 *	Where OP is one of the possible comparision operators.									 *
 *	Example: r = select_eq(a,b,c,d);														 *
 *	if "member at position x of the vector a" == "member at position x of vector b" 		 *
 *	assign the corresponding member in r from c, else assign from d.							 *
 ********************************* Conditional Select ****************************************/

#define IVEC128_SELECT(vect12,vect34,element,selop,arg1,arg2) \
	inline I##vect34##vec##element select_##selop (const I##vect12##vec##element &a, const I##vect12##vec##element &b, const I##vect34##vec##element &c, const I##vect34##vec##element &d) 	   \
{																\
	I##vect12##vec##element mask = cmp##selop(a,b);						\
	return( I##vect34##vec##element ((mask & arg1 ) | I##vect12##vec##element ((_mm_andnot_si128(mask, arg2 )))));	\
}
IVEC128_SELECT(8,s8,16,eq,c,d)
IVEC128_SELECT(8,u8,16,eq,c,d)
IVEC128_SELECT(8,8,16,eq,c,d)
IVEC128_SELECT(8,s8,16,neq,c,d)
IVEC128_SELECT(8,u8,16,neq,c,d)
IVEC128_SELECT(8,8,16,neq,c,d)

IVEC128_SELECT(16,s16,8,eq,c,d)
IVEC128_SELECT(16,u16,8,eq,c,d)
IVEC128_SELECT(16,16,8,eq,c,d)
IVEC128_SELECT(16,s16,8,neq,c,d)
IVEC128_SELECT(16,u16,8,neq,c,d)
IVEC128_SELECT(16,16,8,neq,c,d)

IVEC128_SELECT(32,s32,4,eq,c,d)
IVEC128_SELECT(32,u32,4,eq,c,d)
IVEC128_SELECT(32,32,4,eq,c,d)
IVEC128_SELECT(32,s32,4,neq,c,d)
IVEC128_SELECT(32,u32,4,neq,c,d)
IVEC128_SELECT(32,32,4,neq,c,d)

IVEC128_SELECT(s8,s8,16,gt,c,d)
IVEC128_SELECT(s8,u8,16,gt,c,d)
IVEC128_SELECT(s8,8,16,gt,c,d)
IVEC128_SELECT(s8,s8,16,lt,c,d)
IVEC128_SELECT(s8,u8,16,lt,c,d)
IVEC128_SELECT(s8,8,16,lt,c,d)

IVEC128_SELECT(s16,s16,8,gt,c,d)
IVEC128_SELECT(s16,u16,8,gt,c,d)
IVEC128_SELECT(s16,16,8,gt,c,d)
IVEC128_SELECT(s16,s16,8,lt,c,d)
IVEC128_SELECT(s16,u16,8,lt,c,d)
IVEC128_SELECT(s16,16,8,lt,c,d)


#undef IVEC128_SELECT


class F64vec2
{
protected:
   	 __m128d vec;
public:

	/* Constructors: __m128d, 2 doubles */
	F64vec2() {}

	/* initialize 2 DP FP with __m128d data type */
	F64vec2(__m128d m)					{ vec = m;}

	/* initialize 2 DP FPs with 2 doubles */
	F64vec2(double d1, double d0)		                { vec= _mm_set_pd(d1,d0); }

	/* Explicitly initialize each of 2 DP FPs with same double */
	EXPLICIT F64vec2(double d)	{ vec = _mm_set1_pd(d); }

	/* Conversion functions */
	operator  __m128d() const	{ return vec; }		/* Convert to __m128d */

 	/* Logical Operators */
	friend F64vec2 operator &(const F64vec2 &a, const F64vec2 &b) { return _mm_and_pd(a,b); }
	friend F64vec2 operator |(const F64vec2 &a, const F64vec2 &b) { return _mm_or_pd(a,b); }
	friend F64vec2 operator ^(const F64vec2 &a, const F64vec2 &b) { return _mm_xor_pd(a,b); }

	/* Arithmetic Operators */
	friend F64vec2 operator +(const F64vec2 &a, const F64vec2 &b) { return _mm_add_pd(a,b); }
	friend F64vec2 operator -(const F64vec2 &a, const F64vec2 &b) { return _mm_sub_pd(a,b); }
	friend F64vec2 operator *(const F64vec2 &a, const F64vec2 &b) { return _mm_mul_pd(a,b); }
	friend F64vec2 operator /(const F64vec2 &a, const F64vec2 &b) { return _mm_div_pd(a,b); }

	F64vec2& operator +=(F64vec2 &a) { return *this = _mm_add_pd(vec,a); }
	F64vec2& operator -=(F64vec2 &a) { return *this = _mm_sub_pd(vec,a); }
	F64vec2& operator *=(F64vec2 &a) { return *this = _mm_mul_pd(vec,a); }
	F64vec2& operator /=(F64vec2 &a) { return *this = _mm_div_pd(vec,a); }
	F64vec2& operator &=(F64vec2 &a) { return *this = _mm_and_pd(vec,a); }
	F64vec2& operator |=(F64vec2 &a) { return *this = _mm_or_pd(vec,a); }
	F64vec2& operator ^=(F64vec2 &a) { return *this = _mm_xor_pd(vec,a); }

	/* Horizontal Add */
	friend double add_horizontal(F64vec2 &a)
	{
		F64vec2 ftemp = _mm_add_sd(a,_mm_shuffle_pd(a, a, 1));
		return ftemp[0];
	}

	/* And Not */
	friend F64vec2 andnot(const F64vec2 &a, const F64vec2 &b) { return _mm_andnot_pd(a,b); }

	/* Square Root */
	friend F64vec2 sqrt(const F64vec2 &a)		{ return _mm_sqrt_pd(a); }

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example:
			friend F64vec2 cmpeq(const F64vec2 &a, const F64vec2 &b)
			{ return _mm_cmpeq_ps(a,b);} */
	#define F64vec2_COMP(op) \
	friend F64vec2 cmp##op (const F64vec2 &a, const F64vec2 &b) { return _mm_cmp##op##_pd(a,b); }
		F64vec2_COMP(eq)					// expanded to cmpeq(a,b)
		F64vec2_COMP(lt)					// expanded to cmplt(a,b)
		F64vec2_COMP(le)					// expanded to cmple(a,b)
		F64vec2_COMP(gt)					// expanded to cmpgt(a,b)
		F64vec2_COMP(ge)					// expanded to cmpge(a,b)
		F64vec2_COMP(ngt)					// expanded to cmpngt(a,b)
		F64vec2_COMP(nge)					// expanded to cmpnge(a,b)
		F64vec2_COMP(neq)					// expanded to cmpneq(a,b)
		F64vec2_COMP(nlt)					// expanded to cmpnlt(a,b)
		F64vec2_COMP(nle)					// expanded to cmpnle(a,b)
	#undef F64vec2_COMP

	/* Min and Max */
	friend F64vec2 simd_min(const F64vec2 &a, const F64vec2 &b) { return _mm_min_pd(a,b); }
	friend F64vec2 simd_max(const F64vec2 &a, const F64vec2 &b) { return _mm_max_pd(a,b); }

        /* Compare lower DP FP values */
	#define F64vec2_COMI(op) \
	friend int comi##op (const F64vec2 &a, const F64vec2 &b) { return _mm_comi##op##_sd(a,b); }
		F64vec2_COMI(eq)					// expanded to comieq(a,b)
		F64vec2_COMI(lt)					// expanded to comilt(a,b)
		F64vec2_COMI(le)					// expanded to comile(a,b)
		F64vec2_COMI(gt)					// expanded to comigt(a,b)
		F64vec2_COMI(ge)					// expanded to comige(a,b)
		F64vec2_COMI(neq)					// expanded to comineq(a,b)
	#undef F64vec2_COMI

        /* Compare lower DP FP values */
	#define F64vec2_UCOMI(op) \
	friend int ucomi##op (const F64vec2 &a, const F64vec2 &b) { return _mm_ucomi##op##_sd(a,b); }
		F64vec2_UCOMI(eq)					// expanded to ucomieq(a,b)
		F64vec2_UCOMI(lt)					// expanded to ucomilt(a,b)
		F64vec2_UCOMI(le)					// expanded to ucomile(a,b)
		F64vec2_UCOMI(gt)					// expanded to ucomigt(a,b)
		F64vec2_UCOMI(ge)					// expanded to ucomige(a,b)
		F64vec2_UCOMI(neq)					// expanded to ucomineq(a,b)
	#undef F64vec2_UCOMI

	/* Debug Features */
#if defined(_ENABLE_VEC_DEBUG)
	/* Output */
	friend std::ostream & operator<<(std::ostream & os, const F64vec2 &a)
	{
	/* To use: cout << "Elements of F64vec2 fvec are: " << fvec; */
	  double *dp = (double*)&a;
		os <<	" [1]:" << *(dp+1)
			<< " [0]:" << *dp;
		return os;
	}
#endif
	/* Element Access Only, no modifications to elements*/
	const double& operator[](int i) const
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 1));			/* User should only access elements 0-1 */
		double *dp = (double*)&vec;
		return *(dp+i);
	}
	/* Element Access and Modification*/
	double& operator[](int i)
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 1));			/* User should only access elements 0-1 */
		double *dp = (double*)&vec;
		return *(dp+i);
	}
};

						/* Miscellaneous */

/* Interleave low order data elements of a and b into destination */
inline F64vec2 unpack_low(const F64vec2 &a, const F64vec2 &b)
{ return _mm_unpacklo_pd(a, b); }

/* Interleave high order data elements of a and b into target */
inline F64vec2 unpack_high(const F64vec2 &a, const F64vec2 &b)
{ return _mm_unpackhi_pd(a, b); }

/* Move Mask to Integer returns 4 bit mask formed of most significant bits of a */
inline int move_mask(const F64vec2 &a)
{ return _mm_movemask_pd(a);}

						/* Data Motion Functions */

/* Load Unaligned loadu_pd: Unaligned */
inline void loadu(F64vec2 &a, double *p)
{ a = _mm_loadu_pd(p); }

/* Store Temporal storeu_pd: Unaligned */
inline void storeu(double *p, const F64vec2 &a)
{ _mm_storeu_pd(p, a); }

						/* Cacheability Support */

/* Non-Temporal Store */
inline void store_nta(double *p, F64vec2 &a)
{ _mm_stream_pd(p,a);}

#define F64vec2_SELECT(op) \
inline F64vec2 select_##op (const F64vec2 &a, const F64vec2 &b, const F64vec2 &c, const F64vec2 &d) 	   \
{																\
	F64vec2 mask = _mm_cmp##op##_pd(a,b);						\
	return( (mask & c) | F64vec2((_mm_andnot_pd(mask,d))));	\
}
F64vec2_SELECT(eq)		// generates select_eq(a,b)
F64vec2_SELECT(lt)		// generates select_lt(a,b)
F64vec2_SELECT(le)		// generates select_le(a,b)
F64vec2_SELECT(gt)		// generates select_gt(a,b)
F64vec2_SELECT(ge)		// generates select_ge(a,b)
F64vec2_SELECT(neq)		// generates select_neq(a,b)
F64vec2_SELECT(nlt)		// generates select_nlt(a,b)
F64vec2_SELECT(nle)		// generates select_nle(a,b)
#undef F64vec2_SELECT

/* Convert the lower DP FP value of a to a 32 bit signed integer using Truncate*/
inline int F64vec2ToInt(const F64vec2 &a)
{

	return _mm_cvttsd_si32(a);

}

/* Convert the 4 SP FP values of a to DP FP values */
inline F64vec2 F32vec4ToF64vec2(const F32vec4 &a)
{
	return _mm_cvtps_pd(a);
}

/* Convert the 2 DP FP values of a to SP FP values */
inline F32vec4 F64vec2ToF32vec4(const F64vec2 &a)
{
	return _mm_cvtpd_ps(a);
}

/* Convert the signed int in b to a DP FP value.  Upper DP FP value in a passed through */
inline F64vec2 IntToF64vec2(const F64vec2 &a, int b)
{
	return _mm_cvtsi32_sd(a,b);
}

#pragma pack(pop) /* 16-B aligned */
#endif // DVEC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\mbctype.h ===
/***
*mbctype.h - MBCS character conversion macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines macros for MBCS character classification/conversion.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MBCTYPE
#define _INC_MBCTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* include the standard ctype.h header file */

#include <ctype.h>

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     (!defined(_MSC_VER) && !defined(__cdecl))
#define __cdecl
#endif


/*
 * MBCS - Multi-Byte Character Set
 */

/*
 * This declaration allows the user access the _mbctype[] look-up array.
 */
_CRTIMP extern unsigned char _mbctype[];
_CRTIMP extern unsigned char _mbcasemap[];


/* bit masks for MBCS character types */

#define _MS     0x01    /* MBCS single-byte symbol */
#define _MP     0x02    /* MBCS punct */
#define _M1     0x04    /* MBCS 1st (lead) byte */
#define _M2     0x08    /* MBCS 2nd byte*/

#define _SBUP   0x10    /* SBCS upper char */
#define _SBLOW  0x20    /* SBCS lower char */

/* byte types  */

#define _MBC_SINGLE     0       /* valid single byte char */
#define _MBC_LEAD       1       /* lead byte */
#define _MBC_TRAIL      2       /* trailing byte */
#define _MBC_ILLEGAL    (-1)    /* illegal byte */

#define _KANJI_CP   932

/* _setmbcp parameter defines */
#define _MB_CP_SBCS     0
#define _MB_CP_OEM      -2
#define _MB_CP_ANSI     -3
#define _MB_CP_LOCALE   -4


#ifndef _MBCTYPE_DEFINED

/* MB control routines */

_CRTIMP int __cdecl _setmbcp(int);
_CRTIMP int __cdecl _getmbcp(void);


/* MBCS character classification function prototypes */


/* byte routines */
_CRTIMP int __cdecl _ismbbkalnum( unsigned int );
_CRTIMP int __cdecl _ismbbkana( unsigned int );
_CRTIMP int __cdecl _ismbbkpunct( unsigned int );
_CRTIMP int __cdecl _ismbbkprint( unsigned int );
_CRTIMP int __cdecl _ismbbalpha( unsigned int );
_CRTIMP int __cdecl _ismbbpunct( unsigned int );
_CRTIMP int __cdecl _ismbbalnum( unsigned int );
_CRTIMP int __cdecl _ismbbprint( unsigned int );
_CRTIMP int __cdecl _ismbbgraph( unsigned int );

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead( unsigned int );
_CRTIMP int __cdecl _ismbbtrail( unsigned int );
_CRTIMP int __cdecl _ismbslead( const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail( const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

#define _MBCTYPE_DEFINED
#endif

/*
 * char byte classification macros
 */

#define _ismbbkalnum(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MS)
#define _ismbbkprint(_c)    ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))
#define _ismbbkpunct(_c)    ((_mbctype+1)[(unsigned char)(_c)] & _MP)

#define _ismbbalnum(_c) (((_ctype+1)[(unsigned char)(_c)] & (_ALPHA|_DIGIT))||_ismbbkalnum(_c))
#define _ismbbalpha(_c) (((_ctype+1)[(unsigned char)(_c)] & (_ALPHA))||_ismbbkalnum(_c))
#define _ismbbgraph(_c) (((_ctype+1)[(unsigned char)(_c)] & (_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbprint(_c) (((_ctype+1)[(unsigned char)(_c)] & (_BLANK|_PUNCT|_ALPHA|_DIGIT))||_ismbbkprint(_c))
#define _ismbbpunct(_c) (((_ctype+1)[(unsigned char)(_c)] & _PUNCT)||_ismbbkpunct(_c))

#define _ismbblead(_c)  ((_mbctype+1)[(unsigned char)(_c)] & _M1)
#define _ismbbtrail(_c) ((_mbctype+1)[(unsigned char)(_c)] & _M2)

#define _ismbbkana(_c)  ((_mbctype+1)[(unsigned char)(_c)] & (_MS|_MP))


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MBCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\fvec.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to Streaming SIMD Extension intrinsics.
 *
 *
 *	File name : fvec.h  Fvec class definitions
 *
 *	Concept: A C++ abstraction of Streaming SIMD Extensions designed to improve
 *
 *  programmer productivity.  Speed and accuracy are sacrificed for utility.
 *
 *	Facilitates an easy transition to compiler intrinsics
 *
 *	or assembly language.
 *
 *	F32vec4:	4 packed single precision
 *				32-bit floating point numbers
*/

#ifndef FVEC_H_INCLUDED
#define FVEC_H_INCLUDED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#include <xmmintrin.h> /* Streaming SIMD Extensions Intrinsics include file */
#include <assert.h>
#include <ivec.h>

/* Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output */
#if defined(_ENABLE_VEC_DEBUG)
	#include <iostream>
#endif

#pragma pack(push,16) /* Must ensure class & union 16-B aligned */

/* If using MSVC5.0, explicit keyword should be used */
#if (_MSC_VER >= 1100)
        #define EXPLICIT explicit
#else
   #if (__ICL)
        #define EXPLICIT __explicit /* If MSVC4.x & ICL, use __explicit */
   #else
        #define EXPLICIT /* nothing */
        #pragma message( "explicit keyword not recognized")
   #endif
#endif

class F32vec4
{
protected:
   	 __m128 vec;
public:

	/* Constructors: __m128, 4 floats, 1 float */
	F32vec4() {}

	/* initialize 4 SP FP with __m128 data type */
	F32vec4(__m128 m)					{ vec = m;}

	/* initialize 4 SP FPs with 4 floats */
	F32vec4(float f3, float f2, float f1, float f0)		{ vec= _mm_set_ps(f3,f2,f1,f0); }

	/* Explicitly initialize each of 4 SP FPs with same float */
	EXPLICIT F32vec4(float f)	{ vec = _mm_set_ps1(f); }

	/* Explicitly initialize each of 4 SP FPs with same double */
	EXPLICIT F32vec4(double d)	{ vec = _mm_set_ps1((float) d); }

	/* Assignment operations */

	F32vec4& operator =(float f) { vec = _mm_set_ps1(f); return *this; }

	F32vec4& operator =(double d) { vec = _mm_set_ps1((float) d); return *this; }

	/* Conversion functions */
	operator  __m128() const	{ return vec; }		/* Convert to __m128 */

 	/* Logical Operators */
	friend F32vec4 operator &(const F32vec4 &a, const F32vec4 &b) { return _mm_and_ps(a,b); }
	friend F32vec4 operator |(const F32vec4 &a, const F32vec4 &b) { return _mm_or_ps(a,b); }
	friend F32vec4 operator ^(const F32vec4 &a, const F32vec4 &b) { return _mm_xor_ps(a,b); }

	/* Arithmetic Operators */
	friend F32vec4 operator +(const F32vec4 &a, const F32vec4 &b) { return _mm_add_ps(a,b); }
	friend F32vec4 operator -(const F32vec4 &a, const F32vec4 &b) { return _mm_sub_ps(a,b); }
	friend F32vec4 operator *(const F32vec4 &a, const F32vec4 &b) { return _mm_mul_ps(a,b); }
	friend F32vec4 operator /(const F32vec4 &a, const F32vec4 &b) { return _mm_div_ps(a,b); }

	F32vec4& operator =(const F32vec4 &a) { vec = a.vec; return *this; }
	F32vec4& operator =(const __m128 &avec) { vec = avec; return *this; }
	F32vec4& operator +=(F32vec4 &a) { return *this = _mm_add_ps(vec,a); }
	F32vec4& operator -=(F32vec4 &a) { return *this = _mm_sub_ps(vec,a); }
	F32vec4& operator *=(F32vec4 &a) { return *this = _mm_mul_ps(vec,a); }
	F32vec4& operator /=(F32vec4 &a) { return *this = _mm_div_ps(vec,a); }
	F32vec4& operator &=(F32vec4 &a) { return *this = _mm_and_ps(vec,a); }
	F32vec4& operator |=(F32vec4 &a) { return *this = _mm_or_ps(vec,a); }
	F32vec4& operator ^=(F32vec4 &a) { return *this = _mm_xor_ps(vec,a); }

	/* Horizontal Add */
	friend float add_horizontal(F32vec4 &a)
	{
		F32vec4 ftemp = _mm_add_ss(a,_mm_add_ss(_mm_shuffle_ps(a, a, 1),_mm_add_ss(_mm_shuffle_ps(a, a, 2),_mm_shuffle_ps(a, a, 3))));
		return ftemp[0];
	}

	/* Square Root */
	friend F32vec4 sqrt(const F32vec4 &a)		{ return _mm_sqrt_ps(a); }
	/* Reciprocal */
	friend F32vec4 rcp(const F32vec4 &a)		{ return _mm_rcp_ps(a); }
	/* Reciprocal Square Root */
	friend F32vec4 rsqrt(const F32vec4 &a)		{ return _mm_rsqrt_ps(a); }

	/* NewtonRaphson Reciprocal
	   [2 * rcpps(x) - (x * rcpps(x) * rcpps(x))] */
	friend F32vec4 rcp_nr(const F32vec4 &a)
	{
		F32vec4 Ra0 = _mm_rcp_ps(a);
		return _mm_sub_ps(_mm_add_ps(Ra0, Ra0), _mm_mul_ps(_mm_mul_ps(Ra0, a), Ra0));
	}

	/*	NewtonRaphson Reciprocal Square Root
	  	0.5 * rsqrtps * (3 - x * rsqrtps(x) * rsqrtps(x)) */
	friend F32vec4 rsqrt_nr(const F32vec4 &a)
	{
		static const F32vec4 fvecf0pt5(0.5f);
		static const F32vec4 fvecf3pt0(3.0f);
		F32vec4 Ra0 = _mm_rsqrt_ps(a);
		return (fvecf0pt5 * Ra0) * (fvecf3pt0 - (a * Ra0) * Ra0);

	}

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example:
	friend F32vec4 cmpeq(const F32vec4 &a, const F32vec4 &b)
	{ return _mm_cmpeq_ps(a,b);} */
	#define Fvec32s4_COMP(op) \
	friend F32vec4 cmp##op (const F32vec4 &a, const F32vec4 &b) { return _mm_cmp##op##_ps(a,b); }
		Fvec32s4_COMP(eq)					// expanded to cmpeq(a,b)
		Fvec32s4_COMP(lt)					// expanded to cmplt(a,b)
		Fvec32s4_COMP(le)					// expanded to cmple(a,b)
		Fvec32s4_COMP(gt)					// expanded to cmpgt(a,b)
		Fvec32s4_COMP(ge)					// expanded to cmpge(a,b)
		Fvec32s4_COMP(neq)					// expanded to cmpneq(a,b)
		Fvec32s4_COMP(nlt)					// expanded to cmpnlt(a,b)
		Fvec32s4_COMP(nle)					// expanded to cmpnle(a,b)
		Fvec32s4_COMP(ngt)					// expanded to cmpngt(a,b)
		Fvec32s4_COMP(nge)					// expanded to cmpnge(a,b)
	#undef Fvec32s4_COMP

	/* Min and Max */
	friend F32vec4 simd_min(const F32vec4 &a, const F32vec4 &b) { return _mm_min_ps(a,b); }
	friend F32vec4 simd_max(const F32vec4 &a, const F32vec4 &b) { return _mm_max_ps(a,b); }

	/* Debug Features */
#if defined(_ENABLE_VEC_DEBUG)
	/* Output */
	friend std::ostream & operator<<(std::ostream & os, const F32vec4 &a)
	{
	/* To use: cout << "Elements of F32vec4 fvec are: " << fvec; */
	  float *fp = (float*)&a;
	  	os << "[3]:" << *(fp+3)
			<< " [2]:" << *(fp+2)
			<< " [1]:" << *(fp+1)
			<< " [0]:" << *fp;
		return os;
	}
#endif
	/* Element Access Only, no modifications to elements*/
	const float& operator[](int i) const
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 3));			/* User should only access elements 0-3 */
		float *fp = (float*)&vec;
		return *(fp+i);
	}
	/* Element Access and Modification*/
	float& operator[](int i)
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 3));			/* User should only access elements 0-3 */
		float *fp = (float*)&vec;
		return *(fp+i);
	}
};

						/* Miscellaneous */

/* Interleave low order data elements of a and b into destination */
inline F32vec4 unpack_low(const F32vec4 &a, const F32vec4 &b)
{ return _mm_unpacklo_ps(a, b); }

/* Interleave high order data elements of a and b into target */
inline F32vec4 unpack_high(const F32vec4 &a, const F32vec4 &b)
{ return _mm_unpackhi_ps(a, b); }

/* Move Mask to Integer returns 4 bit mask formed of most significant bits of a */
inline int move_mask(const F32vec4 &a)
{ return _mm_movemask_ps(a);}

						/* Data Motion Functions */

/* Load Unaligned loadu_ps: Unaligned */
inline void loadu(F32vec4 &a, float *p)
{ a = _mm_loadu_ps(p); }

/* Store Temporal storeu_ps: Unaligned */
inline void storeu(float *p, const F32vec4 &a)
{ _mm_storeu_ps(p, a); }

						/* Cacheability Support */

/* Non-Temporal Store */
inline void store_nta(float *p, F32vec4 &a)
{ _mm_stream_ps(p,a);}

						/* Conditional Selects:*/
/*(a OP b)? c : d; where OP is any compare operator
Macros expand to conditional selects which use all compare intrinsics.
Example:
friend F32vec4 select_eq(const F32vec4 &a, const F32vec4 &b, const F32vec4 &c, const F32vec4 &d)
{
	F32vec4 mask = _mm_cmpeq_ps(a,b);
	return( (mask & c) | F32vec4((_mm_andnot_ps(mask,d))));
}
*/

#define Fvec32s4_SELECT(op) \
inline F32vec4 select_##op (const F32vec4 &a, const F32vec4 &b, const F32vec4 &c, const F32vec4 &d) 	   \
{																\
	F32vec4 mask = _mm_cmp##op##_ps(a,b);						\
	return( (mask & c) | F32vec4((_mm_andnot_ps(mask,d))));	\
}
Fvec32s4_SELECT(eq)			// generates select_eq(a,b)
Fvec32s4_SELECT(lt)			// generates select_lt(a,b)
Fvec32s4_SELECT(le)			// generates select_le(a,b)
Fvec32s4_SELECT(gt)			// generates select_gt(a,b)
Fvec32s4_SELECT(ge)			// generates select_ge(a,b)
Fvec32s4_SELECT(neq)		// generates select_neq(a,b)
Fvec32s4_SELECT(nlt)		// generates select_nlt(a,b)
Fvec32s4_SELECT(nle)		// generates select_nle(a,b)
Fvec32s4_SELECT(ngt)		// generates select_ngt(a,b)
Fvec32s4_SELECT(nge)		// generates select_nge(a,b)
#undef Fvec32s4_SELECT


/* Streaming SIMD Extensions Integer Intrinsics */

/* Max and Min */
inline Is16vec4 simd_max(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmaxsw(a,b);}
inline Is16vec4 simd_min(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pminsw(a,b);}
inline Iu8vec8 simd_max(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pmaxub(a,b);}
inline Iu8vec8 simd_min(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pminub(a,b);}

/* Average */
inline Iu16vec4 simd_avg(const Iu16vec4 &a, const Iu16vec4 &b)		{ return _m_pavgw(a,b); }
inline Iu8vec8 simd_avg(const Iu8vec8 &a, const Iu8vec8 &b)			{ return _m_pavgb(a,b); }

/* Move ByteMask To Int: returns mask formed from most sig bits	of each vec of a */
inline int move_mask(const I8vec8 &a)								{ return _m_pmovmskb(a);}

/* Packed Multiply High Unsigned */
inline Iu16vec4 mul_high(const Iu16vec4 &a, const Iu16vec4 &b)		{ return _m_pmulhuw(a,b); }

/* Byte Mask Write: Write bytes if most significant bit in each corresponding byte is set */
inline void mask_move(const I8vec8 &a, const I8vec8 &b, char *addr)	{ _m_maskmovq(a, b, addr); }

/* Data Motion: Store Non Temporal */
inline void store_nta(__m64 *p, M64 &a) { _mm_stream_pi(p,a); }

/* Conversions between ivec <-> fvec */

/* Convert first element of F32vec4 to int with truncation */
inline int F32vec4ToInt(const F32vec4 &a)
{

	return _mm_cvtt_ss2si(a);

}

/* Convert two lower SP FP values of a to Is32vec2 with truncation */
inline Is32vec2 F32vec4ToIs32vec2 (const F32vec4 &a)
{

	__m64 result;
	result = _mm_cvtt_ps2pi(a);
	return Is32vec2(result);

}

/* Convert the 32-bit int i to an SP FP value; the upper three SP FP values are passed through from a. */
inline F32vec4 IntToF32vec4(const F32vec4 &a, int i)
{

	__m128 result;
	result = _mm_cvt_si2ss(a,i);
	return F32vec4(result);

}

/* Convert the two 32-bit integer values in b to two SP FP values; the upper two SP FP values are passed from a. */
inline F32vec4 Is32vec2ToF32vec4(const F32vec4 &a, const Is32vec2 &b)
{

	__m128 result;
	result = _mm_cvt_pi2ps(a,b);
	return F32vec4(result);
}

class F32vec1
{
protected:
   	 __m128 vec;
public:

	/* Constructors: 1 float */
	F32vec1() {}

	F32vec1(int i)		{ vec = _mm_cvt_si2ss(vec,i);};

	/* Initialize each of 4 SP FPs with same float */
	EXPLICIT F32vec1(float f)	{ vec = _mm_set_ss(f); }

	/* Initialize each of 4 SP FPs with same float */
	EXPLICIT F32vec1(double d)	{ vec = _mm_set_ss((float) d); }

	/* initialize with __m128 data type */
	F32vec1(__m128 m)	{ vec = m; }

	/* Conversion functions */
	operator  __m128() const	{ return vec; }		/* Convert to float */

 	/* Logical Operators */
	friend F32vec1 operator &(const F32vec1 &a, const F32vec1 &b) { return _mm_and_ps(a,b); }
	friend F32vec1 operator |(const F32vec1 &a, const F32vec1 &b) { return _mm_or_ps(a,b); }
	friend F32vec1 operator ^(const F32vec1 &a, const F32vec1 &b) { return _mm_xor_ps(a,b); }

	/* Arithmetic Operators */
	friend F32vec1 operator +(const F32vec1 &a, const F32vec1 &b) { return _mm_add_ss(a,b); }
	friend F32vec1 operator -(const F32vec1 &a, const F32vec1 &b) { return _mm_sub_ss(a,b); }
	friend F32vec1 operator *(const F32vec1 &a, const F32vec1 &b) { return _mm_mul_ss(a,b); }
	friend F32vec1 operator /(const F32vec1 &a, const F32vec1 &b) { return _mm_div_ss(a,b); }

	F32vec1& operator +=(F32vec1 &a) { return *this = _mm_add_ss(vec,a); }
	F32vec1& operator -=(F32vec1 &a) { return *this = _mm_sub_ss(vec,a); }
	F32vec1& operator *=(F32vec1 &a) { return *this = _mm_mul_ss(vec,a); }
	F32vec1& operator /=(F32vec1 &a) { return *this = _mm_div_ss(vec,a); }
	F32vec1& operator &=(F32vec1 &a) { return *this = _mm_and_ps(vec,a); }
	F32vec1& operator |=(F32vec1 &a) { return *this = _mm_or_ps(vec,a); }
	F32vec1& operator ^=(F32vec1 &a) { return *this = _mm_xor_ps(vec,a); }


	/* Square Root */
	friend F32vec1 sqrt(const F32vec1 &a)		{ return _mm_sqrt_ss(a); }
	/* Reciprocal */
	friend F32vec1 rcp(const F32vec1 &a)		{ return _mm_rcp_ss(a); }
	/* Reciprocal Square Root */
	friend F32vec1 rsqrt(const F32vec1 &a)		{ return _mm_rsqrt_ss(a); }

	/* NewtonRaphson Reciprocal
	   [2 * rcpss(x) - (x * rcpss(x) * rcpss(x))] */
	friend F32vec1 rcp_nr(const F32vec1 &a)
	{
		F32vec1 Ra0 = _mm_rcp_ss(a);
		return _mm_sub_ss(_mm_add_ss(Ra0, Ra0), _mm_mul_ss(_mm_mul_ss(Ra0, a), Ra0));
	}

	/*	NewtonRaphson Reciprocal Square Root
	  	0.5 * rsqrtss * (3 - x * rsqrtss(x) * rsqrtss(x)) */
	friend F32vec1 rsqrt_nr(const F32vec1 &a)
	{
		static const F32vec1 fvecf0pt5(0.5f);
		static const F32vec1 fvecf3pt0(3.0f);
		F32vec1 Ra0 = _mm_rsqrt_ss(a);
		return (fvecf0pt5 * Ra0) * (fvecf3pt0 - (a * Ra0) * Ra0);

	}

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example:
	friend F32vec1 cmpeq(const F32vec1 &a, const F32vec1 &b)
	{ return _mm_cmpeq_ss(a,b);} */
	#define Fvec32s1_COMP(op) \
	friend F32vec1 cmp##op (const F32vec1 &a, const F32vec1 &b) { return _mm_cmp##op##_ss(a,b); }
		Fvec32s1_COMP(eq)					// expanded to cmpeq(a,b)
		Fvec32s1_COMP(lt)					// expanded to cmplt(a,b)
		Fvec32s1_COMP(le)					// expanded to cmple(a,b)
		Fvec32s1_COMP(gt)					// expanded to cmpgt(a,b)
		Fvec32s1_COMP(ge)					// expanded to cmpge(a,b)
		Fvec32s1_COMP(neq)					// expanded to cmpneq(a,b)
		Fvec32s1_COMP(nlt)					// expanded to cmpnlt(a,b)
		Fvec32s1_COMP(nle)					// expanded to cmpnle(a,b)
		Fvec32s1_COMP(ngt)					// expanded to cmpngt(a,b)
		Fvec32s1_COMP(nge)					// expanded to cmpnge(a,b)
	#undef Fvec32s1_COMP

	/* Min and Max */
	friend F32vec1 simd_min(const F32vec1 &a, const F32vec1 &b) { return _mm_min_ss(a,b); }
	friend F32vec1 simd_max(const F32vec1 &a, const F32vec1 &b) { return _mm_max_ss(a,b); }

	/* Debug Features */
#if defined(_ENABLE_VEC_DEBUG)
	/* Output */
	friend std::ostream & operator<<(std::ostream & os, const F32vec1 &a)
	{
	/* To use: cout << "Elements of F32vec1 fvec are: " << fvec; */
	  float *fp = (float*)&a;
	  	os << "float:" << *fp;
		return os;
	}
#endif

};

						/* Conditional Selects:*/
/*(a OP b)? c : d; where OP is any compare operator
Macros expand to conditional selects which use all compare intrinsics.
Example:
friend F32vec1 select_eq(const F32vec1 &a, const F32vec1 &b, const F32vec1 &c, const F32vec1 &d)
{
	F32vec1 mask = _mm_cmpeq_ss(a,b);
	return( (mask & c) | F32vec1((_mm_andnot_ps(mask,d))));
}
*/

#define Fvec32s1_SELECT(op) \
inline F32vec1 select_##op (const F32vec1 &a, const F32vec1 &b, const F32vec1 &c, const F32vec1 &d) 	   \
{													   \
	F32vec1 mask = _mm_cmp##op##_ss(a,b);						                   \
	return( (mask & c) | F32vec1((_mm_andnot_ps(mask,d))));	                                           \
}
Fvec32s1_SELECT(eq)			// generates select_eq(a,b)
Fvec32s1_SELECT(lt)			// generates select_lt(a,b)
Fvec32s1_SELECT(le)			// generates select_le(a,b)
Fvec32s1_SELECT(gt)			// generates select_gt(a,b)
Fvec32s1_SELECT(ge)			// generates select_ge(a,b)
Fvec32s1_SELECT(neq)		// generates select_neq(a,b)
Fvec32s1_SELECT(nlt)		// generates select_nlt(a,b)
Fvec32s1_SELECT(nle)		// generates select_nle(a,b)
Fvec32s1_SELECT(ngt)		// generates select_ngt(a,b)
Fvec32s1_SELECT(nge)		// generates select_nge(a,b)
#undef Fvec32s1_SELECT

/* Conversions between ivec <-> fvec */

/* Convert F32vec1 to int */
inline int F32vec1ToInt(const F32vec1 &a)
{
	return _mm_cvtt_ss2si(a);
}



#pragma pack(pop) /* 16-B aligned */
#endif /* FVEC_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\mbstring.h ===
/***
* mbstring.h - MBCS string manipulation macros and functions
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file contains macros and function declarations for the MBCS
*       string manipulation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MBSTRING
#define _INC_MBSTRING

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647      /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
typedef char *  va_list;
#define _VA_LIST_DEFINED
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/*
 * MBCS - Multi-Byte Character Set
 */

#ifndef _MBSTRING_DEFINED

/* function prototypes */

_CRTIMP unsigned int __cdecl _mbbtombc(unsigned int);
_CRTIMP int __cdecl _mbbtype(unsigned char, int);
_CRTIMP unsigned int __cdecl _mbctombb(unsigned int);
_CRTIMP int __cdecl _mbsbtype(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbscat(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbschr(const unsigned char *, unsigned int);
_CRTIMP int __cdecl _mbscmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbscoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbscpy(unsigned char *, const unsigned char *);
_CRTIMP size_t __cdecl _mbscspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdec(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdup(const unsigned char *);
_CRTIMP int __cdecl _mbsicmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbsicoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsinc(const unsigned char *);
_CRTIMP size_t __cdecl _mbslen(const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbslwr(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsnbcat(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnbcnt(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbcpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbsncat(unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnccnt(const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsncpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned int __cdecl _mbsnextc (const unsigned char *);
_CRTIMP int __cdecl _mbsnicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsninc(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbspbrk(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsrchr(const unsigned char *, unsigned int);
_CRTIMP unsigned char * __cdecl _mbsrev(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsset(unsigned char *, unsigned int);
_CRTIMP size_t __cdecl _mbsspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsspnp(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsstr(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbstok(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsupr(unsigned char *);

_CRTIMP size_t __cdecl _mbclen(const unsigned char *);
_CRTIMP void __cdecl _mbccpy(unsigned char *, const unsigned char *);
#define _mbccmp(_cpc1, _cpc2) _mbsncmp((_cpc1),(_cpc2),1)

/* character routines */

_CRTIMP int __cdecl _ismbcalnum(unsigned int);
_CRTIMP int __cdecl _ismbcalpha(unsigned int);
_CRTIMP int __cdecl _ismbcdigit(unsigned int);
_CRTIMP int __cdecl _ismbcgraph(unsigned int);
_CRTIMP int __cdecl _ismbclegal(unsigned int);
_CRTIMP int __cdecl _ismbclower(unsigned int);
_CRTIMP int __cdecl _ismbcprint(unsigned int);
_CRTIMP int __cdecl _ismbcpunct(unsigned int);
_CRTIMP int __cdecl _ismbcspace(unsigned int);
_CRTIMP int __cdecl _ismbcupper(unsigned int);

_CRTIMP unsigned int __cdecl _mbctolower(unsigned int);
_CRTIMP unsigned int __cdecl _mbctoupper(unsigned int);


#define _MBSTRING_DEFINED
#endif

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead(unsigned int);
_CRTIMP int __cdecl _ismbbtrail(unsigned int);
_CRTIMP int __cdecl _ismbslead(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail(const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

/*  Kanji specific prototypes.  */

_CRTIMP int __cdecl _ismbchira(unsigned int);
_CRTIMP int __cdecl _ismbckata(unsigned int);
_CRTIMP int __cdecl _ismbcsymbol(unsigned int);
_CRTIMP int __cdecl _ismbcl0(unsigned int);
_CRTIMP int __cdecl _ismbcl1(unsigned int);
_CRTIMP int __cdecl _ismbcl2(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjistojms(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjmstojis(unsigned int);
_CRTIMP unsigned int __cdecl _mbctohira(unsigned int);
_CRTIMP unsigned int __cdecl _mbctokata(unsigned int);

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MBSTRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the
*       buffer (memory) manipulation routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MEMORY
#define _INC_MEMORY

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

/* Function prototypes */

_CRTIMP void *  __cdecl _memccpy(void *, const void *, int, size_t);
_CRTIMP void *  __cdecl memchr(const void *, int, size_t);
_CRTIMP int     __cdecl _memicmp(const void *, const void *, size_t);
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memcpy(void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);

#if     !__STDC__

/* Non-ANSI names for compatibility */

_CRTIMP void * __cdecl memccpy(void *, const void *, int, size_t);
_CRTIMP int __cdecl memicmp(const void *, const void *, size_t);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _INC_MEMORY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\minmax.h ===
/***
*minmax.h - familiar min & max macros
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines min and max macros.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MINMAX
#define _INC_MINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\mmintrin.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * Definitions and declarations for use with compiler intrinsics.
 */

#ifndef _MMINTRIN_H_INCLUDED
#define _MMINTRIN_H_INCLUDED

#if defined __cplusplus
extern "C" { /* Begin "C" */
/* Intrinsics use C name-mangling.
 */
#endif /* __cplusplus */

#ifdef __ICL
typedef unsigned long long __m64; 
#elif _MSC_VER >= 1300
typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64    m64_u64;
    float               m64_f32[2];
    __int8              m64_i8[8];
    __int16             m64_i16[4];
    __int32             m64_i32[2];    
    __int64             m64_i64;
    unsigned __int8     m64_u8[8];
    unsigned __int16    m64_u16[4];
    unsigned __int32    m64_u32[2];
} __m64;
#endif

/* General support intrinsics */
void  _m_empty(void);
__m64 _m_from_int(int i);
int   _m_to_int(__m64 m);
__m64 _m_packsswb(__m64 m1, __m64 m2);
__m64 _m_packssdw(__m64 m1, __m64 m2);
__m64 _m_packuswb(__m64 m1, __m64 m2);
__m64 _m_punpckhbw(__m64 m1, __m64 m2);
__m64 _m_punpckhwd(__m64 m1, __m64 m2);
__m64 _m_punpckhdq(__m64 m1, __m64 m2);
__m64 _m_punpcklbw(__m64 m1, __m64 m2);
__m64 _m_punpcklwd(__m64 m1, __m64 m2);
__m64 _m_punpckldq(__m64 m1, __m64 m2);

/* Packed arithmetic intrinsics */
__m64 _m_paddb(__m64 m1, __m64 m2);
__m64 _m_paddw(__m64 m1, __m64 m2);
__m64 _m_paddd(__m64 m1, __m64 m2);
__m64 _m_paddsb(__m64 m1, __m64 m2);
__m64 _m_paddsw(__m64 m1, __m64 m2);
__m64 _m_paddusb(__m64 m1, __m64 m2);
__m64 _m_paddusw(__m64 m1, __m64 m2);
__m64 _m_psubb(__m64 m1, __m64 m2);
__m64 _m_psubw(__m64 m1, __m64 m2);
__m64 _m_psubd(__m64 m1, __m64 m2);
__m64 _m_psubsb(__m64 m1, __m64 m2);
__m64 _m_psubsw(__m64 m1, __m64 m2);
__m64 _m_psubusb(__m64 m1, __m64 m2);
__m64 _m_psubusw(__m64 m1, __m64 m2);
__m64 _m_pmaddwd(__m64 m1, __m64 m2);
__m64 _m_pmulhw(__m64 m1, __m64 m2);
__m64 _m_pmullw(__m64 m1, __m64 m2);

/* Shift intrinsics */
__m64 _m_psllw(__m64 m, __m64 count);
__m64 _m_psllwi(__m64 m, int count);
__m64 _m_pslld(__m64 m, __m64 count);
__m64 _m_pslldi(__m64 m, int count);
__m64 _m_psllq(__m64 m, __m64 count);
__m64 _m_psllqi(__m64 m, int count);
__m64 _m_psraw(__m64 m, __m64 count);
__m64 _m_psrawi(__m64 m, int count);
__m64 _m_psrad(__m64 m, __m64 count);
__m64 _m_psradi(__m64 m, int count);
__m64 _m_psrlw(__m64 m, __m64 count);
__m64 _m_psrlwi(__m64 m, int count);
__m64 _m_psrld(__m64 m, __m64 count);
__m64 _m_psrldi(__m64 m, int count);
__m64 _m_psrlq(__m64 m, __m64 count);
__m64 _m_psrlqi(__m64 m, int count);

/* Logical intrinsics */
__m64 _m_pand(__m64 m1, __m64 m2);
__m64 _m_pandn(__m64 m1, __m64 m2);
__m64 _m_por(__m64 m1, __m64 m2);
__m64 _m_pxor(__m64 m1, __m64 m2);

/* Comparison intrinsics */
__m64 _m_pcmpeqb(__m64 m1, __m64 m2);
__m64 _m_pcmpeqw(__m64 m1, __m64 m2);
__m64 _m_pcmpeqd(__m64 m1, __m64 m2);
__m64 _m_pcmpgtb(__m64 m1, __m64 m2);
__m64 _m_pcmpgtw(__m64 m1, __m64 m2);
__m64 _m_pcmpgtd(__m64 m1, __m64 m2);

/* Utility intrinsics */
__m64 _mm_setzero_si64();
__m64 _mm_set_pi32(int i1, int i0);
__m64 _mm_set_pi16(short s3, short s2, short s1, short s0);
__m64 _mm_set_pi8(char b7, char b6, char b5, char b4,
                  char b3, char b2, char b1, char b0);
__m64 _mm_set1_pi32(int i);
__m64 _mm_set1_pi16(short s);
__m64 _mm_set1_pi8(char b);
__m64 _mm_setr_pi32(int i1, int i0);
__m64 _mm_setr_pi16(short s3, short s2, short s1, short s0);
__m64 _mm_setr_pi8(char b7, char b6, char b5, char b4,
                   char b3, char b2, char b1, char b0);

/* Alternate intrinsic name definitions */
#define _mm_empty         _m_empty
#define _mm_cvtsi32_si64  _m_from_int
#define _mm_cvtsi64_si32  _m_to_int
#define _mm_packs_pi16    _m_packsswb
#define _mm_packs_pi32    _m_packssdw
#define _mm_packs_pu16    _m_packuswb
#define _mm_unpackhi_pi8  _m_punpckhbw
#define _mm_unpackhi_pi16 _m_punpckhwd
#define _mm_unpackhi_pi32 _m_punpckhdq
#define _mm_unpacklo_pi8  _m_punpcklbw
#define _mm_unpacklo_pi16 _m_punpcklwd
#define _mm_unpacklo_pi32 _m_punpckldq
#define _mm_add_pi8       _m_paddb
#define _mm_add_pi16      _m_paddw
#define _mm_add_pi32      _m_paddd
#define _mm_adds_pi8      _m_paddsb
#define _mm_adds_pi16     _m_paddsw
#define _mm_adds_pu8      _m_paddusb
#define _mm_adds_pu16     _m_paddusw
#define _mm_sub_pi8       _m_psubb
#define _mm_sub_pi16      _m_psubw
#define _mm_sub_pi32      _m_psubd
#define _mm_subs_pi8      _m_psubsb
#define _mm_subs_pi16     _m_psubsw
#define _mm_subs_pu8      _m_psubusb
#define _mm_subs_pu16     _m_psubusw
#define _mm_madd_pi16     _m_pmaddwd
#define _mm_mulhi_pi16    _m_pmulhw
#define _mm_mullo_pi16    _m_pmullw
#define _mm_sll_pi16      _m_psllw
#define _mm_slli_pi16     _m_psllwi
#define _mm_sll_pi32      _m_pslld
#define _mm_slli_pi32     _m_pslldi
#define _mm_sll_si64      _m_psllq
#define _mm_slli_si64     _m_psllqi
#define _mm_sra_pi16      _m_psraw
#define _mm_srai_pi16     _m_psrawi
#define _mm_sra_pi32      _m_psrad
#define _mm_srai_pi32     _m_psradi
#define _mm_srl_pi16      _m_psrlw
#define _mm_srli_pi16     _m_psrlwi
#define _mm_srl_pi32      _m_psrld
#define _mm_srli_pi32     _m_psrldi
#define _mm_srl_si64      _m_psrlq
#define _mm_srli_si64     _m_psrlqi
#define _mm_and_si64      _m_pand
#define _mm_andnot_si64   _m_pandn
#define _mm_or_si64       _m_por
#define _mm_xor_si64      _m_pxor
#define _mm_cmpeq_pi8     _m_pcmpeqb
#define _mm_cmpeq_pi16    _m_pcmpeqw
#define _mm_cmpeq_pi32    _m_pcmpeqd
#define _mm_cmpgt_pi8     _m_pcmpgtb
#define _mm_cmpgt_pi16    _m_pcmpgtw
#define _mm_cmpgt_pi32    _m_pcmpgtd


#if defined __cplusplus
}; /* End "C" */
#endif /* __cplusplus */

#endif /* _MMINTRIN_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\mm3dnow.h ===
/**
*** Copyright (C) 1999 Advanced Micro Devices Inc.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Advanced Micro Devices and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * mm3dnow.h
 *
 */

#ifndef _MM3DNOW_H_INCLUDED
#define _MM3DNOW_H_INCLUDED

#include <mmintrin.h>
#include <xmmintrin.h>

#if defined __cplusplus
extern "C" { /* Intrinsics use C name-mangling.  */
#endif /* __cplusplus */

/* 3DNOW intrinsics */

void _m_femms(void);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pf2id(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pmulhrw(__m64, __m64);
void _m_prefetch(void*);
void _m_prefetchw(void*);

__m64 _m_from_float(float);
float _m_to_float(__m64);

/* Athlon DSP intrinsics */

__m64 _m_pf2iw(__m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pswapd(__m64);

#if defined __cplusplus
}; /* End "C" */
#endif /* __cplusplus */

#endif /* _MM3DNOW_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\ostream.h ===
/***
*ostream.h - definitions/declarations for the ostream class
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the ostream class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_OSTREAM
#define _INC_OSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef long streamoff, streampos;

class _CRTIMP ostream : virtual public ios {

public:
        ostream(streambuf*);
        virtual ~ostream();

        ostream& flush();
        int  opfx();
        void osfx();

inline  ostream& operator<<(ostream& (__cdecl * _f)(ostream&));
inline  ostream& operator<<(ios& (__cdecl * _f)(ios&));
        ostream& operator<<(const char *);
inline  ostream& operator<<(const unsigned char *);
inline  ostream& operator<<(const signed char *);
inline  ostream& operator<<(char);
        ostream& operator<<(unsigned char);
inline  ostream& operator<<(signed char);
        ostream& operator<<(short);
        ostream& operator<<(unsigned short);
        ostream& operator<<(int);
        ostream& operator<<(unsigned int);
        ostream& operator<<(long);
        ostream& operator<<(unsigned long);
inline  ostream& operator<<(float);
        ostream& operator<<(double);
        ostream& operator<<(long double);
        ostream& operator<<(const void *);
        ostream& operator<<(streambuf*);
inline  ostream& put(char);
        ostream& put(unsigned char);
inline  ostream& put(signed char);
        ostream& write(const char *,int);
inline  ostream& write(const unsigned char *,int);
inline  ostream& write(const signed char *,int);
        ostream& seekp(streampos);
        ostream& seekp(streamoff,ios::seek_dir);
        streampos tellp();

protected:
        ostream();
        ostream(const ostream&);        // treat as private
        ostream& operator=(streambuf*); // treat as private
        ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
        int do_opfx(int);               // not used
        void do_osfx();                 // not used

private:
        ostream(ios&);
        ostream& writepad(const char *, const char *);
        int x_floatused;
};

inline ostream& ostream::operator<<(ostream& (__cdecl * _f)(ostream&)) { (*_f)(*this); return *this; }
inline ostream& ostream::operator<<(ios& (__cdecl * _f)(ios& )) { (*_f)(*this); return *this; }

inline  ostream& ostream::operator<<(char _c) { return operator<<((unsigned char) _c); }
inline  ostream& ostream::operator<<(signed char _c) { return operator<<((unsigned char) _c); }

inline  ostream& ostream::operator<<(const unsigned char * _s) { return operator<<((const char *) _s); }
inline  ostream& ostream::operator<<(const signed char * _s) { return operator<<((const char *) _s); }

inline  ostream& ostream::operator<<(float _f) { x_floatused = 1; return operator<<((double) _f); }

inline  ostream& ostream::put(char _c) { return put((unsigned char) _c); }
inline  ostream& ostream::put(signed char _c) { return put((unsigned char) _c); }

inline  ostream& ostream::write(const unsigned char * _s, int _n) { return write((char *) _s, _n); }
inline  ostream& ostream::write(const signed char * _s, int _n) { return write((char *) _s, _n); }


class _CRTIMP ostream_withassign : public ostream {
        public:
                ostream_withassign();
                ostream_withassign(streambuf* _is);
                ~ostream_withassign();
    ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
    ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
};

extern ostream_withassign _CRTIMP cout;
extern ostream_withassign _CRTIMP cerr;
extern ostream_withassign _CRTIMP clog;

inline _CRTIMP ostream& __cdecl flush(ostream& _outs) { return _outs.flush(); }
inline _CRTIMP ostream& __cdecl endl(ostream& _outs) { return _outs << '\n' << flush; }
inline _CRTIMP ostream& __cdecl ends(ostream& _outs) { return _outs << char('\0'); }

_CRTIMP ios&           __cdecl dec(ios&);
_CRTIMP ios&           __cdecl hex(ios&);
_CRTIMP ios&           __cdecl oct(ios&);

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_OSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\ios.h ===
/***
*ios.h - definitions/declarations for the ios class.
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the ios class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_IOS
#define _INC_IOS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#ifdef  _MT

typedef struct __CRT_LIST_ENTRY {
   struct __CRT_LIST_ENTRY *Flink;
   struct __CRT_LIST_ENTRY *Blink;
} _CRT_LIST_ENTRY;

typedef struct _CRT_CRITICAL_SECTION_DEBUG {
    unsigned short Type;
    unsigned short CreatorBackTraceIndex;
    struct _CRT_CRITICAL_SECTION *CriticalSection;
    _CRT_LIST_ENTRY ProcessLocksList;
    unsigned long EntryCount;
    unsigned long ContentionCount;
    unsigned long Depth;
    void * OwnerBackTrace[ 5 ];
} _CRT_CRITICAL_SECTION_DEBUG, *_PCRT_CRITICAL_SECTION_DEBUG;

typedef struct _CRT_CRITICAL_SECTION {
    _PCRT_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    long LockCount;
    long RecursionCount;
    void * OwningThread;        // from the thread's ClientId->UniqueThread
    void * LockSemaphore;
    unsigned long Reserved;
} _CRT_CRITICAL_SECTION, *_PCRT_CRITICAL_SECTION;

extern "C" {
_CRTIMP void __cdecl _mtlock(_PCRT_CRITICAL_SECTION);
_CRTIMP void __cdecl _mtunlock(_PCRT_CRITICAL_SECTION);
}

#endif  /* _MT */

#ifndef NULL
#define NULL    0
#endif

#ifndef EOF
#define EOF     (-1)
#endif

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

class _CRTIMP streambuf;
class _CRTIMP ostream;

class _CRTIMP ios {

public:
    enum io_state {  goodbit = 0x00,
                     eofbit  = 0x01,
                     failbit = 0x02,
                     badbit  = 0x04 };

    enum open_mode { in        = 0x01,
                     out       = 0x02,
                     ate       = 0x04,
                     app       = 0x08,
                     trunc     = 0x10,
                     nocreate  = 0x20,
                     noreplace = 0x40,
                     binary    = 0x80 };

    enum seek_dir { beg=0, cur=1, end=2 };

    enum {  skipws     = 0x0001,
            left       = 0x0002,
            right      = 0x0004,
            internal   = 0x0008,
            dec        = 0x0010,
            oct        = 0x0020,
            hex        = 0x0040,
            showbase   = 0x0080,
            showpoint  = 0x0100,
            uppercase  = 0x0200,
            showpos    = 0x0400,
            scientific = 0x0800,
            fixed      = 0x1000,
            unitbuf    = 0x2000,
            stdio      = 0x4000
                                 };

    static const long basefield;        // dec | oct | hex
    static const long adjustfield;      // left | right | internal
    static const long floatfield;       // scientific | fixed

    ios(streambuf*);                    // differs from ANSI
    virtual ~ios();

    inline long flags() const;
    inline long flags(long _l);

    inline long setf(long _f,long _m);
    inline long setf(long _l);
    inline long unsetf(long _l);

    inline int width() const;
    inline int width(int _i);

    inline ostream* tie(ostream* _os);
    inline ostream* tie() const;

    inline char fill() const;
    inline char fill(char _c);

    inline int precision(int _i);
    inline int precision() const;

    inline int rdstate() const;
    inline void clear(int _i = 0);

//  inline operator void*() const;
    operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
    inline int operator!() const;

    inline int  good() const;
    inline int  eof() const;
    inline int  fail() const;
    inline int  bad() const;

    inline streambuf* rdbuf() const;

    inline long & iword(int) const;
    inline void * & pword(int) const;

    static long bitalloc();
    static int xalloc();
    static void sync_with_stdio();

#ifdef  _MT
    inline void __cdecl setlock();
    inline void __cdecl clrlock();
    void __cdecl lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void __cdecl unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
    inline void __cdecl lockbuf();
    inline void __cdecl unlockbuf();
#else
    void __cdecl lock() { }
    void __cdecl unlock() { }
    void __cdecl lockbuf() { }
    void __cdecl unlockbuf() { }
#endif

protected:
    ios();
    ios(const ios&);                    // treat as private
    ios& operator=(const ios&);
    void init(streambuf*);

    enum { skipping, tied };
    streambuf*  bp;

    int     state;
    int     ispecial;                   // not used
    int     ospecial;                   // not used
    int     isfx_special;               // not used
    int     osfx_special;               // not used
    int     x_delbuf;                   // if set, rdbuf() deleted by ~ios

    ostream* x_tie;
    long    x_flags;
    int     x_precision;
    char    x_fill;
    int     x_width;

    static void (*stdioflush)();        // not used

#ifdef  _MT
    static void lockc() { _mtlock(& x_lockc); }
    static void unlockc() { _mtunlock( & x_lockc); }
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#else
    static void lockc() { }
    static void unlockc() { }
#endif

public:
    int delbuf() const { return x_delbuf; }
    void    delbuf(int _i) { x_delbuf = _i; }

private:
    static long x_maxbit;
    static int x_curindex;
    static int sunk_with_stdio;         // make sure sync_with done only once
#ifdef  _MT
#define MAXINDEX 7
    static long x_statebuf[MAXINDEX+1];  // used by xalloc()
    static int fLockcInit;              // used to see if x_lockc initialized
    static _CRT_CRITICAL_SECTION x_lockc; // used to lock static (class) data members
    int LockFlg;                        // enable locking flag
    _CRT_CRITICAL_SECTION x_lock;       // used for multi-thread lock on object
#else
    static long * x_statebuf;  // used by xalloc()
#endif
};

#include <streamb.h>

inline _CRTIMP ios& __cdecl dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
inline _CRTIMP ios& __cdecl oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }

inline long ios::flags() const { return x_flags; }
inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }

inline long ios::setf(long _l,long _m){ long _lO; lock(); _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); unlock(); return _lO; }
inline long ios::setf(long _l){ long _lO; lock(); _lO = x_flags; x_flags |= _l; unlock(); return _lO; }
inline long ios::unsetf(long _l){ long _lO; lock(); _lO = x_flags; x_flags &= (~_l); unlock(); return _lO; }

inline int ios::width() const { return x_width; }
inline int ios::width(int _i){ int _iO; _iO = (int)x_width; x_width = _i; return _iO; }

inline ostream* ios::tie(ostream* _os){ ostream* _osO; _osO = x_tie; x_tie = _os; return _osO; }
inline ostream* ios::tie() const { return x_tie; }
inline char ios::fill() const { return x_fill; }
inline char ios::fill(char _c){ char _cO; _cO = x_fill; x_fill = _c; return _cO; }
inline int ios::precision(int _i){ int _iO; _iO = (int)x_precision; x_precision = _i; return _iO; }
inline int ios::precision() const { return x_precision; }

inline int ios::rdstate() const { return state; }

// inline ios::operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
inline int ios::operator!() const { return state&(badbit|failbit); }

inline int  ios::bad() const { return state & badbit; }
inline void ios::clear(int _i){ lock(); state = _i; unlock(); }
inline int  ios::eof() const { return state & eofbit; }
inline int  ios::fail() const { return state & (badbit | failbit); }
inline int  ios::good() const { return state == 0; }

inline streambuf* ios::rdbuf() const { return bp; }

inline long & ios::iword(int _i) const { return x_statebuf[_i] ; }
inline void * & ios::pword(int _i) const { return (void * &)x_statebuf[_i]; }

#ifdef  _MT
    inline void ios::setlock() { LockFlg--; if (bp) bp->setlock(); }
    inline void ios::clrlock() { if (LockFlg <= 0) LockFlg++; if (bp) bp->clrlock(); }
    inline void ios::lockbuf() { bp->lock(); }
    inline void ios::unlockbuf() { bp->unlock(); }
#endif

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_IOS

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the function declarations for memory allocation functions;
*       also defines manifest constants and types used by the heap routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MALLOC
#define _INC_MALLOC

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTNOALIAS, _CRTRESTRICT */

#if     _MSC_FULL_VER >= 14002050

#ifndef _CRTNOALIAS
#define _CRTNOALIAS __declspec(noalias)
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT __declspec(restrict)
#endif  /* _CRTRESTRICT */

#else

#ifndef _CRTNOALIAS
#define _CRTNOALIAS
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT
#endif  /* _CRTRESTRICT */

#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif


/* Maximum heap request the heap manager will attempt */

#ifdef  _WIN64
#define _HEAP_MAXREQ    0xFFFFFFFFFFFFFFE0
#else
#define _HEAP_MAXREQ    0xFFFFFFE0
#endif

/* Constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY      (-1)
#define _HEAPOK         (-2)
#define _HEAPBADBEGIN   (-3)
#define _HEAPBADNODE    (-4)
#define _HEAPEND        (-5)
#define _HEAPBADPTR     (-6)
#define _FREEENTRY      0
#define _USEDENTRY      1

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
        int * _pentry;
        size_t _size;
        int _useflag;
        } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif

/* External variable declarations */

extern unsigned int _amblksiz;

#define _mm_free(a)      _aligned_free(a)
#define _mm_malloc(a, b)    _aligned_malloc(a, b)

/* Function prototypes */

_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl calloc(size_t, size_t);
_CRTIMP _CRTNOALIAS              void    __cdecl free(void *);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl malloc(size_t);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl realloc(void *, size_t);
_CRTIMP _CRTNOALIAS              void    __cdecl _aligned_free(void *);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl _aligned_malloc(size_t, size_t);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl _aligned_offset_malloc(size_t, size_t, size_t);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl _aligned_realloc(void *, size_t, size_t);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void *  __cdecl _aligned_offset_realloc(void *, size_t, size_t, size_t);
_CRTIMP int     __cdecl _resetstkoflw (void);

#ifndef _POSIX_

void *          __cdecl _alloca(size_t);
_CRTIMP void *  __cdecl _expand(void *, size_t);
_CRTIMP size_t  __cdecl _get_sbh_threshold(void);
_CRTIMP int     __cdecl _set_sbh_threshold(size_t);
_CRTIMP int     __cdecl _heapadd(void *, size_t);
_CRTIMP int     __cdecl _heapchk(void);
_CRTIMP int     __cdecl _heapmin(void);
_CRTIMP int     __cdecl _heapset(unsigned int);
_CRTIMP int     __cdecl _heapwalk(_HEAPINFO *);
_CRTIMP size_t  __cdecl _heapused(size_t *, size_t *);
_CRTIMP size_t  __cdecl _msize(void *);

_CRTIMP intptr_t __cdecl _get_heap_handle(void);

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define alloca  _alloca
#endif  /* __STDC__*/

#endif  /* _POSIX_ */

#ifdef  HEAPHOOK
#ifndef _HEAPHOOK_DEFINED
/* hook function type */
typedef int (__cdecl * _HEAPHOOK)(int, size_t, void *, void **);
#define _HEAPHOOK_DEFINED
#endif  /* _HEAPHOOK_DEFINED */

/* set hook function */
_CRTIMP _HEAPHOOK __cdecl _setheaphook(_HEAPHOOK);

/* hook function must handle these types */
#define _HEAP_MALLOC    1
#define _HEAP_CALLOC    2
#define _HEAP_FREE      3
#define _HEAP_REALLOC   4
#define _HEAP_MSIZE     5
#define _HEAP_EXPAND    6
#endif  /* HEAPHOOK */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the declarations for the sorting and
*       searching routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SEARCH
#define _INC_SEARCH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Function prototypes */

_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *,
        const void *));


#if     !__STDC__
/* Non-ANSI names for compatibility */
_CRTIMP void * __cdecl lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SEARCH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\rtcapi.h ===
/***
*rtcapi.h - declarations and definitions for RTC use
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations and definitions for all RunTime Check
*       support.
*
****/

#ifndef _INC_RTCAPI
#define _INC_RTCAPI


#ifdef  __cplusplus

extern "C" {

#endif

    /* General User API */

typedef enum _RTC_ErrorNumber {
    _RTC_CHKSTK = 0,
    _RTC_CVRT_LOSS_INFO,
    _RTC_CORRUPT_STACK,
    _RTC_UNINIT_LOCAL_USE,
    _RTC_ILLEGAL 
} _RTC_ErrorNumber;
 
#   define _RTC_ERRTYPE_IGNORE -1
#   define _RTC_ERRTYPE_ASK    -2

    typedef int (__cdecl *_RTC_error_fn)(int, const char *, int, const char *, const char *, ...);

    /* User API */
    int           __cdecl _RTC_NumErrors(void);
    const char *  __cdecl _RTC_GetErrDesc(_RTC_ErrorNumber errnum);
    int           __cdecl _RTC_SetErrorType(_RTC_ErrorNumber errnum, int ErrType);
    _RTC_error_fn __cdecl _RTC_SetErrorFunc(_RTC_error_fn);

    /* Power User/library API */


    /* Init functions */

    /* These functions all call _CRT_RTC_INIT */
    void __cdecl _RTC_Initialize(void);
    void __cdecl _RTC_Terminate(void);

    /*
     * If you're not using the CRT, you have to implement _CRT_RTC_INIT
     * Just return either null, or your error reporting function
     * *** Don't mess with res0/res1/res2/res3/res4 - YOU'VE BEEN WARNED! ***
     */
    _RTC_error_fn _CRT_RTC_INIT(void *res0, void **res1, int res2, int res3, int res4);
    
    /* Compiler generated calls (unlikely to be used, even by power users) */
    /* Types */
    typedef struct _RTC_vardesc {
        int addr;
        int size;
        char *name;
    } _RTC_vardesc;

    typedef struct _RTC_framedesc {
        int varCount;
        _RTC_vardesc *variables;
    } _RTC_framedesc;

    /* Shortening convert checks - name indicates src bytes to target bytes */
    /* Signedness is NOT checked */
    char   __fastcall _RTC_Check_2_to_1(short src);
    char   __fastcall _RTC_Check_4_to_1(int src);
    char   __fastcall _RTC_Check_8_to_1(__int64 src);
    short  __fastcall _RTC_Check_4_to_2(int src);
    short  __fastcall _RTC_Check_8_to_2(__int64 src);
    int    __fastcall _RTC_Check_8_to_4(__int64 src);
 
    
    /* Stack Checking Calls */
    void   __cdecl     _RTC_CheckEsp();
    void   __fastcall  _RTC_CheckStackVars(void *esp, _RTC_framedesc *fd);

    /* Unintialized Local call */
    void   __cdecl     _RTC_UninitUse(const char *varname);


    /* Subsystem initialization stuff */
    void    __cdecl    _RTC_Shutdown(void);
    void    __cdecl    _RTC_InitBase(void);
    

#ifdef  __cplusplus

    void* _ReturnAddress();
}

#endif


#endif /* _INC_RTCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\locale.h ===
/***
*locale.h - definitions/declarations for localization routines
*
*       Copyright (c) 1988-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the localization routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCALE
#define _INC_LOCALE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

/* Locale categories */

#define LC_ALL          0
#define LC_COLLATE      1
#define LC_CTYPE        2
#define LC_MONETARY     3
#define LC_NUMERIC      4
#define LC_TIME         5

#define LC_MIN          LC_ALL
#define LC_MAX          LC_TIME

/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        };
#define _LCONV_DEFINED
#endif

/* ANSI: char lconv members default is CHAR_MAX which is compile time
   dependent. Defining and using _charmax here causes CRT startup code
   to initialize lconv members properly */

#ifdef  _CHAR_UNSIGNED
extern int _charmax;
extern __inline int __dummy() { return _charmax; }
#endif

/* function prototypes */

#ifndef _CONFIG_LOCALE_SWT
#define _ENABLE_PER_THREAD_LOCALE           0x1
#define _DISABLE_PER_THREAD_LOCALE          0x2
#define _ENABLE_PER_THREAD_LOCALE_GLOBAL    0x10
#define _DISABLE_PER_THREAD_LOCALE_GLOBAL   0x20
#define _ENABLE_PER_THREAD_LOCALE_NEW       0x100
#define _DISABLE_PER_THREAD_LOCALE_NEW      0x200
#define _CONFIG_LOCALE_SWT
#endif

_CRTIMP int __cdecl _configthreadlocale(int i);
_CRTIMP char * __cdecl setlocale(int, const char *);
_CRTIMP struct lconv * __cdecl localeconv(void);

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_LOCALE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\math.h ===
/***
*math.h - definitions and declarations for math library
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant definitions and external subroutine
*       declarations for the math subroutine library.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MATH
#define _INC_MATH

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __assembler /* Protect from assembler */

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Definition of _exception struct - this struct is passed to the matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
struct _exception {
        int type;       /* exception type - see below */
        char *name;     /* name of function where error occured */
        double arg1;    /* first argument to function */
        double arg2;    /* second argument (if any) to function */
        double retval;  /* value to be returned by function */
        } ;

#define _EXCEPTION_DEFINED
#endif


/* Definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED
struct _complex {
        double x,y; /* real and imaginary parts */
        } ;

#if     !__STDC__ && !defined (__cplusplus)
/* Non-ANSI name for compatibility */
#define complex _complex
#endif

#define _COMPLEX_DEFINED
#endif
#endif  /* __assembler */


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN     1   /* argument domain error */
#define _SING       2   /* argument singularity */
#define _OVERFLOW   3   /* overflow range error */
#define _UNDERFLOW  4   /* underflow range error */
#define _TLOSS      5   /* total loss of precision */
#define _PLOSS      6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
 * for a value returned in case of error by a number of the floating point
 * math routines
 */
#ifndef __assembler /* Protect from assembler */
_CRTIMP extern double _HUGE;
#endif  /* __assembler */

#define HUGE_VAL _HUGE

#ifdef  _USE_MATH_DEFINES

/* Define _USE_MATH_DEFINES before including math.h to expose these macro
 * definitions for common math constants.  These are placed under an #ifdef
 * since these commonly-defined names are not part of the C/C++ standards.
 */

/* Definitions of useful mathematical constants
 * M_E        - e
 * M_LOG2E    - log2(e)
 * M_LOG10E   - log10(e)
 * M_LN2      - ln(2)
 * M_LN10     - ln(10)
 * M_PI       - pi
 * M_PI_2     - pi/2
 * M_PI_4     - pi/4
 * M_1_PI     - 1/pi
 * M_2_PI     - 2/pi
 * M_2_SQRTPI - 2/sqrt(pi)
 * M_SQRT2    - sqrt(2)
 * M_SQRT1_2  - 1/sqrt(2)
 */

#define M_E        2.71828182845904523536
#define M_LOG2E    1.44269504088896340736
#define M_LOG10E   0.434294481903251827651
#define M_LN2      0.693147180559945309417
#define M_LN10     2.30258509299404568402
#define M_PI       3.14159265358979323846
#define M_PI_2     1.57079632679489661923
#define M_PI_4     0.785398163397448309616
#define M_1_PI     0.318309886183790671538
#define M_2_PI     0.636619772367581343076
#define M_2_SQRTPI 1.12837916709551257390
#define M_SQRT2    1.41421356237309504880
#define M_SQRT1_2  0.707106781186547524401

#endif  /* _USE_MATH_DEFINES */

/* Function prototypes */

#if     !defined(__assembler)   /* Protect from assembler */
        int     __cdecl abs(int);
        double  __cdecl acos(double);
        double  __cdecl asin(double);
        double  __cdecl atan(double);
        double  __cdecl atan2(double, double);
        double  __cdecl cos(double);
        double  __cdecl cosh(double);
        double  __cdecl exp(double);
        double  __cdecl fabs(double);
        double  __cdecl fmod(double, double);
        long    __cdecl labs(long);
        double  __cdecl log(double);
        double  __cdecl log10(double);
        double  __cdecl pow(double, double);
        double  __cdecl sin(double);
        double  __cdecl sinh(double);
        double  __cdecl tan(double);
        double  __cdecl tanh(double);
        double  __cdecl sqrt(double);
_CRTIMP double  __cdecl atof(const char *);
_CRTIMP double  __cdecl _cabs(struct _complex);
_CRTIMP double  __cdecl ceil(double);
_CRTIMP double  __cdecl floor(double);
_CRTIMP double  __cdecl frexp(double, int *);
_CRTIMP double  __cdecl _hypot(double, double);
_CRTIMP double  __cdecl _j0(double);
_CRTIMP double  __cdecl _j1(double);
_CRTIMP double  __cdecl _jn(int, double);
_CRTIMP double  __cdecl ldexp(double, int);
        int     __cdecl _matherr(struct _exception *);
_CRTIMP double  __cdecl modf(double, double *);

_CRTIMP double  __cdecl _y0(double);
_CRTIMP double  __cdecl _y1(double);
_CRTIMP double  __cdecl _yn(int, double);


#if     defined(_M_IX86)

_CRTIMP int     __cdecl _set_SSE2_enable(int);

#endif

#if defined(_M_IA64)

/* ANSI C, 4.5 Mathematics        */

/* 4.5.2 Trigonometric functions */

        float  __cdecl acosf( float );
        float  __cdecl asinf( float );
        float  __cdecl atanf( float );
        float  __cdecl atan2f( float , float );
        float  __cdecl cosf( float );
        float  __cdecl sinf( float );
        float  __cdecl tanf( float );

/* 4.5.3 Hyperbolic functions */
        float  __cdecl coshf( float );
        float  __cdecl sinhf( float );
        float  __cdecl tanhf( float );

/* 4.5.4 Exponential and logarithmic functions */
        float  __cdecl expf( float );
        float  __cdecl logf( float );
        float  __cdecl log10f( float );
        float  __cdecl modff( float , float* );

/* 4.5.5 Power functions */
        float  __cdecl powf( float , float );
        float  __cdecl sqrtf( float );

/* 4.5.6 Nearest integer, absolute value, and remainder functions */
        float  __cdecl ceilf( float );
        float  __cdecl fabsf( float );
        float  __cdecl floorf( float );
        float  __cdecl fmodf( float , float );

        float  __cdecl hypotf(float, float);

#endif /* _M_IA64 */

/* Macros defining long double functions to be their double counterparts
 * (long double is synonymous with double in this implementation).
 */

#ifndef __cplusplus
#define acosl(x)    ((long double)acos((double)(x)))
#define asinl(x)    ((long double)asin((double)(x)))
#define atanl(x)    ((long double)atan((double)(x)))
#define atan2l(x,y) ((long double)atan2((double)(x), (double)(y)))
#define _cabsl      _cabs
#define ceill(x)    ((long double)ceil((double)(x)))
#define cosl(x)     ((long double)cos((double)(x)))
#define coshl(x)    ((long double)cosh((double)(x)))
#define expl(x)     ((long double)exp((double)(x)))
#define fabsl(x)    ((long double)fabs((double)(x)))
#define floorl(x)   ((long double)floor((double)(x)))
#define fmodl(x,y)  ((long double)fmod((double)(x), (double)(y)))
#define frexpl(x,y) ((long double)frexp((double)(x), (y)))
#define _hypotl(x,y)    ((long double)_hypot((double)(x), (double)(y)))
#define ldexpl(x,y) ((long double)ldexp((double)(x), (y)))
#define logl(x)     ((long double)log((double)(x)))
#define log10l(x)   ((long double)log10((double)(x)))
#define _matherrl   _matherr
#define modfl(x,y)  ((long double)modf((double)(x), (double *)(y)))
#define powl(x,y)   ((long double)pow((double)(x), (double)(y)))
#define sinl(x)     ((long double)sin((double)(x)))
#define sinhl(x)    ((long double)sinh((double)(x)))
#define sqrtl(x)    ((long double)sqrt((double)(x)))
#define tanl(x)     ((long double)tan((double)(x)))
#define tanhl(x)    ((long double)tanh((double)(x)))
#else   /* __cplusplus */
inline long double acosl(long double _X)
        {return (acos((double)_X)); }
inline long double asinl(long double _X)
        {return (asin((double)_X)); }
inline long double atanl(long double _X)
        {return (atan((double)_X)); }
inline long double atan2l(long double _X, long double _Y)
        {return (atan2((double)_X, (double)_Y)); }
inline long double ceill(long double _X)
        {return (ceil((double)_X)); }
inline long double cosl(long double _X)
        {return (cos((double)_X)); }
inline long double coshl(long double _X)
        {return (cosh((double)_X)); }
inline long double expl(long double _X)
        {return (exp((double)_X)); }
inline long double fabsl(long double _X)
        {return (fabs((double)_X)); }
inline long double floorl(long double _X)
        {return (floor((double)_X)); }
inline long double fmodl(long double _X, long double _Y)
        {return (fmod((double)_X, (double)_Y)); }
inline long double frexpl(long double _X, int *_Y)
        {return (frexp((double)_X, _Y)); }
inline long double ldexpl(long double _X, int _Y)
        {return (ldexp((double)_X, _Y)); }
inline long double logl(long double _X)
        {return (log((double)_X)); }
inline long double log10l(long double _X)
        {return (log10((double)_X)); }
inline long double modfl(long double _X, long double *_Y)
        {double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (long double)_Di;
        return (_Df); }
inline long double powl(long double _X, long double _Y)
        {return (pow((double)_X, (double)_Y)); }
inline long double sinl(long double _X)
        {return (sin((double)_X)); }
inline long double sinhl(long double _X)
        {return (sinh((double)_X)); }
inline long double sqrtl(long double _X)
        {return (sqrt((double)_X)); }
inline long double tanl(long double _X)
        {return (tan((double)_X)); }
inline long double tanhl(long double _X)
        {return (tanh((double)_X)); }

inline float frexpf(float _X, int *_Y)
        {return ((float)frexp((double)_X, _Y)); }
inline float ldexpf(float _X, int _Y)
        {return ((float)ldexp((double)_X, _Y)); }
#if     !defined(_M_IA64)
inline float acosf(float _X)
        {return ((float)acos((double)_X)); }
inline float asinf(float _X)
        {return ((float)asin((double)_X)); }
inline float atanf(float _X)
        {return ((float)atan((double)_X)); }
inline float atan2f(float _X, float _Y)
        {return ((float)atan2((double)_X, (double)_Y)); }
inline float ceilf(float _X)
        {return ((float)ceil((double)_X)); }
inline float cosf(float _X)
        {return ((float)cos((double)_X)); }
inline float coshf(float _X)
        {return ((float)cosh((double)_X)); }
inline float expf(float _X)
        {return ((float)exp((double)_X)); }
inline float fabsf(float _X)
        {return ((float)fabs((double)_X)); }
inline float floorf(float _X)
        {return ((float)floor((double)_X)); }
inline float fmodf(float _X, float _Y)
        {return ((float)fmod((double)_X, (double)_Y)); }
inline float logf(float _X)
        {return ((float)log((double)_X)); }
inline float log10f(float _X)
        {return ((float)log10((double)_X)); }
inline float modff(float _X, float *_Y)
        { double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (float)_Di;
        return ((float)_Df); }
inline float powf(float _X, float _Y)
        {return ((float)pow((double)_X, (double)_Y)); }
inline float sinf(float _X)
        {return ((float)sin((double)_X)); }
inline float sinhf(float _X)
        {return ((float)sinh((double)_X)); }
inline float sqrtf(float _X)
        {return ((float)sqrt((double)_X)); }
inline float tanf(float _X)
        {return ((float)tan((double)_X)); }
inline float tanhf(float _X)
        {return ((float)tanh((double)_X)); }
#endif  /* !defined(_M_IA64) */
#endif  /* __cplusplus */
#endif  /* __assembler */

#if     !__STDC__

/* Non-ANSI names for compatibility */

#define DOMAIN      _DOMAIN
#define SING        _SING
#define OVERFLOW    _OVERFLOW
#define UNDERFLOW   _UNDERFLOW
#define TLOSS       _TLOSS
#define PLOSS       _PLOSS

#define matherr     _matherr

#ifndef __assembler /* Protect from assembler */

_CRTIMP extern double HUGE;

_CRTIMP double  __cdecl cabs(struct _complex);
_CRTIMP double  __cdecl hypot(double, double);
_CRTIMP double  __cdecl j0(double);
_CRTIMP double  __cdecl j1(double);
_CRTIMP double  __cdecl jn(int, double);
        int     __cdecl matherr(struct _exception *);
_CRTIMP double  __cdecl y0(double);
_CRTIMP double  __cdecl y1(double);
_CRTIMP double  __cdecl yn(int, double);

#endif  /* __assembler */

#endif  /* __STDC__ */

#ifdef  __cplusplus
}

extern "C++" {

template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y)
        {unsigned int _N;
        if (_Y >= 0)
                _N = _Y;
        else
                _N = -_Y;
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

#ifndef _MSC_EXTENSIONS

inline long __cdecl abs(long _X)
        {return (labs(_X)); }
inline double __cdecl abs(double _X)
        {return (fabs(_X)); }
inline double __cdecl pow(double _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline double __cdecl pow(int _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl abs(float _X)
        {return (fabsf(_X)); }
inline float __cdecl acos(float _X)
        {return (acosf(_X)); }
inline float __cdecl asin(float _X)
        {return (asinf(_X)); }
inline float __cdecl atan(float _X)
        {return (atanf(_X)); }
inline float __cdecl atan2(float _Y, float _X)
        {return (atan2f(_Y, _X)); }
inline float __cdecl ceil(float _X)
        {return (ceilf(_X)); }
inline float __cdecl cos(float _X)
        {return (cosf(_X)); }
inline float __cdecl cosh(float _X)
        {return (coshf(_X)); }
inline float __cdecl exp(float _X)
        {return (expf(_X)); }
inline float __cdecl fabs(float _X)
        {return (fabsf(_X)); }
inline float __cdecl floor(float _X)
        {return (floorf(_X)); }
inline float __cdecl fmod(float _X, float _Y)
        {return (fmodf(_X, _Y)); }
inline float __cdecl frexp(float _X, int * _Y)
        {return (frexpf(_X, _Y)); }
inline float __cdecl ldexp(float _X, int _Y)
        {return (ldexpf(_X, _Y)); }
inline float __cdecl log(float _X)
        {return (logf(_X)); }
inline float __cdecl log10(float _X)
        {return (log10f(_X)); }
inline float __cdecl modf(float _X, float * _Y)
        {return (modff(_X, _Y)); }
inline float __cdecl pow(float _X, float _Y)
        {return (powf(_X, _Y)); }
inline float __cdecl pow(float _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl sin(float _X)
        {return (sinf(_X)); }
inline float __cdecl sinh(float _X)
        {return (sinhf(_X)); }
inline float __cdecl sqrt(float _X)
        {return (sqrtf(_X)); }
inline float __cdecl tan(float _X)
        {return (tanf(_X)); }
inline float __cdecl tanh(float _X)
        {return (tanhf(_X)); }
inline long double __cdecl abs(long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl acos(long double _X)
        {return (acosl(_X)); }
inline long double __cdecl asin(long double _X)
        {return (asinl(_X)); }
inline long double __cdecl atan(long double _X)
        {return (atanl(_X)); }
inline long double __cdecl atan2(long double _Y, long double _X)
        {return (atan2l(_Y, _X)); }
inline long double __cdecl ceil(long double _X)
        {return (ceill(_X)); }
inline long double __cdecl cos(long double _X)
        {return (cosl(_X)); }
inline long double __cdecl cosh(long double _X)
        {return (coshl(_X)); }
inline long double __cdecl exp(long double _X)
        {return (expl(_X)); }
inline long double __cdecl fabs(long double _X)
        {return (fabsl(_X)); }
inline long double __cdecl floor(long double _X)
        {return (floorl(_X)); }
inline long double __cdecl fmod(long double _X, long double _Y)
        {return (fmodl(_X, _Y)); }
inline long double __cdecl frexp(long double _X, int * _Y)
        {return (frexpl(_X, _Y)); }
inline long double __cdecl ldexp(long double _X, int _Y)
        {return (ldexpl(_X, _Y)); }
inline long double __cdecl log(long double _X)
        {return (logl(_X)); }
inline long double __cdecl log10(long double _X)
        {return (log10l(_X)); }
inline long double __cdecl modf(long double _X, long double * _Y)
        {return (modfl(_X, _Y)); }
inline long double __cdecl pow(long double _X, long double _Y)
        {return (powl(_X, _Y)); }
inline long double __cdecl pow(long double _X, int _Y)
        {return (_Pow_int(_X, _Y)); }
inline long double __cdecl sin(long double _X)
        {return (sinl(_X)); }
inline long double __cdecl sinh(long double _X)
        {return (sinhl(_X)); }
inline long double __cdecl sqrt(long double _X)
        {return (sqrtl(_X)); }
inline long double __cdecl tan(long double _X)
        {return (tanl(_X)); }
inline long double __cdecl tanh(long double _X)
        {return (tanhl(_X)); }

#endif  /* _MSC_EXTENSIONS */ 

}
#endif  /* __cplusplus */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_MATH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the file sharing modes for sopen().
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SHARE
#define _INC_SHARE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _SH_DENYRW      0x10    /* deny read/write mode */
#define _SH_DENYWR      0x20    /* deny write mode */
#define _SH_DENYRD      0x30    /* deny read mode */
#define _SH_DENYNO      0x40    /* deny none mode */

#if     !__STDC__
/* Non-ANSI names for compatibility */
#define SH_DENYRW _SH_DENYRW
#define SH_DENYWR _SH_DENYWR
#define SH_DENYRD _SH_DENYRD
#define SH_DENYNO _SH_DENYNO
#endif

#endif  /* _INC_SHARE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\setjmpex.h ===
/***
*setjmpex.h - definitions/declarations for extended setjmp/longjmp routines
*
*       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file causes _setjmpex to be called which will enable safe
*       setjmp/longjmp that work correctly with try/except/finally.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SETJMPEX
#define _INC_SETJMPEX

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#define setjmp  _setjmp
#define longjmp _longjmpex

#else

#ifdef setjmp
#undef setjmp
#endif
#define setjmp _setjmpex

#endif

#include <setjmp.h>

#endif  /* _INC_SETJMPEX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines ANSI-style macros for accessing arguments
*       of functions which take a variable number of arguments.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDARG
#define _INC_STDARG

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
typedef char *  va_list;
#define _VA_LIST_DEFINED
#endif

#ifdef  __cplusplus
#define _ADDRESSOF(v)   ( &reinterpret_cast<const char &>(v) )
#else
#define _ADDRESSOF(v)   ( &(v) )
#endif

#if     defined(_M_CEE)

extern void __cdecl __va_start(va_list*, ...);
extern void * __cdecl __va_arg(va_list*, ...);
extern void __cdecl __va_end(va_list*);

#define va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), sizeof(v), \
                                __builtin_alignof(v), _ADDRESSOF(v)) )
#define va_arg(ap,t)    ( *(t *)__va_arg(&ap, sizeof(t), \
                                __builtin_alignof(t), (t *)0) )
#define va_end(ap)      ( __va_end(&ap) )

#elif   defined(_M_IX86)

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_IA64)

#define _VA_STRUCT_ALIGN  16 

#define _VA_ALIGN       8

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) \
                            - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#ifdef  __cplusplus
extern void __cdecl __va_start(va_list*, ...);
#define va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), \
                          _ADDRESSOF(v)) )
#else
#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _SLOTSIZEOF(v) )
#endif

#define va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) \
                                                     -_SLOTSIZEOF(t)))

#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_AMD64)


extern void __cdecl __va_start(va_list *, ...);

#define va_start(ap, x) ( __va_start(&ap, x) )
#define va_arg(ap, t)   \
    ( ( sizeof(t) > sizeof(__int64) || ( sizeof(t) & (sizeof(t) - 1) ) != 0 ) \
        ? **(t **)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) \
        :  *(t  *)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) )
#define va_end(ap)      ( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap)      ( ap = (va_list)0 )

#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDARG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\signal.h ===
/***
*signal.h - defines signal values and routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the signal values and declares the signal functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SIGNAL
#define _INC_SIGNAL

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif

#define NSIG 23     /* maximum signal number + 1 */


/* Signal types */

#define SIGINT          2       /* interrupt */
#define SIGILL          4       /* illegal instruction - invalid function image */
#define SIGFPE          8       /* floating point exception */
#define SIGSEGV         11      /* segment violation */
#define SIGTERM         15      /* Software termination signal from kill */
#define SIGBREAK        21      /* Ctrl-Break sequence */
#define SIGABRT         22      /* abnormal termination triggered by abort call */


/* signal action codes */

#define SIG_DFL (void (__cdecl *)(int))0           /* default signal action */
#define SIG_IGN (void (__cdecl *)(int))1           /* ignore signal */
#define SIG_SGE (void (__cdecl *)(int))3           /* signal gets error */
#define SIG_ACK (void (__cdecl *)(int))4           /* acknowledge */


/* signal error value (returned by signal call on error) */

#define SIG_ERR (void (__cdecl *)(int))-1          /* signal error value */


/* pointer to exception information pointers structure */

#if     defined(_MT) || defined(_DLL)
extern void * * __cdecl __pxcptinfoptrs(void);
#define _pxcptinfoptrs  (*__pxcptinfoptrs())
#else   /* ndef _MT && ndef _DLL */
extern void * _pxcptinfoptrs;
#endif  /* _MT || _DLL */


/* Function prototypes */

_CRTIMP void (__cdecl * __cdecl signal(int, void (__cdecl *)(int)))(int);
_CRTIMP int __cdecl raise(int);


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SIGNAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\stdexcpt.h ===
/***
*stdexcpt.h - User include file for standard exception classes
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file is the previous location of the standard exception class
*       definitions, now found in the standard header <exception>.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDEXCPT
#define _INC_STDEXCPT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus

#include <exception>

#endif  /* __cplusplus */
#endif  /* _INC_STDEXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\ivec.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to MMX(TM) instruction intrinsics.
 *
 */

#ifndef IVEC_H_INCLUDED
#define IVEC_H_INCLUDED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#include <mmintrin.h>
#include <assert.h>

/*
 * Define _SILENCE_IVEC_C4799 to disable warning C4799 inside this header.
 * Be careful that any code that uses these functions properly executes EMMS
 * or _m_empty() after using any MMX instruction and before using the x87 NDP.
 */
#if defined(_SILENCE_IVEC_C4799)
	#pragma warning(push)
	#pragma warning(disable: 4799)
#endif

/*
 * Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output
 */
#if defined(_ENABLE_VEC_DEBUG)
	#include <iostream>
#endif

/* If using MSVC5.0, explicit keyword should be used */
#if (_MSC_VER >= 1100)
        #define EXPLICIT explicit
#else
   #if (__ICL)
        #define EXPLICIT __explicit /* If MSVC4.x & ICL, use __explicit */
   #else
        #define EXPLICIT /* nothing */
        #pragma message( "explicit keyword not recognized")
   #endif
#endif

class I8vec8;			/* 8 elements, each element a signed or unsigned char data type */
class Is8vec8;			/* 8 elements, each element a signed char data type */
class Iu8vec8;			/* 8 elements, each element an unsigned char data type */
class I16vec4;			/* 4 elements, each element a signed or unsigned short */
class Is16vec4;			/* 4 elements, each element a signed short */
class Iu16vec4;			/* 4 elements, each element an unsigned short */
class I32vec2;			/* 2 elements, each element a signed or unsigned long */
class Is32vec2;			/* 2 elements, each element a signed long */
class Iu32vec2;			/* 2 elements, each element a unsigned long */
class I64vec1;			/* 1 element, a __m64 data type - Base I64vec1 class  */

#define _MM_8UB(element,vector) (*((unsigned char*)&##vector + ##element))
#define _MM_8B(element,vector) (*((signed char*)&##vector + ##element))

#define _MM_4UW(element,vector) (*((unsigned short*)&##vector + ##element))
#define _MM_4W(element,vector) (*((short*)&##vector + ##element))

#define _MM_2UDW(element,vector) (*((unsigned int*)&##vector + ##element))
#define _MM_2DW(element,vector) (*((int*)&##vector + ##element))

#define _MM_QW (*((__int64*)&vec))

/* M64 Class:
 * 1 element, a __m64 data type
 * Contructors & Logical Operations
 */
class M64
{
protected:
		__m64 vec;

public:
	M64()									{ }
	M64(__m64 mm)							{ vec = mm; }
	M64(__int64 mm)							{ _MM_QW = mm; }
	M64(int i)								{ vec = _m_from_int(i); }

	operator __m64() const					{ return vec; }

	/* Logical Operations */
	M64& operator&=(const M64 &a)					{ return *this = (M64) _m_pand(vec,a); }
	M64& operator|=(const M64 &a)					{ return *this = (M64) _m_por(vec,a); }
	M64& operator^=(const M64 &a)					{ return *this = (M64) _m_pxor(vec,a); }

};

inline M64 operator&(const M64 &a, const M64 &b)	{ return _m_pand( a,b); }
inline M64 operator|(const M64 &a, const M64 &b)	{ return _m_por(a,b); }
inline M64 operator^(const M64 &a, const M64 &b)	{ return _m_pxor(a,b); }
inline M64 andnot(const M64 &a, const M64 &b)		{ return _m_pandn(a,b); }

/* I64vec1 Class:
 * 1 element, a __m64 data type
 * Contains Operations which can operate on any __m64 data type
 */

class I64vec1 : public M64
{
public:
	I64vec1()								{ }
	I64vec1(__m64 mm) : M64(mm)				{ }
	EXPLICIT I64vec1(int i) : M64(i)		{ }
	EXPLICIT I64vec1(__int64 mm) : M64(mm)	{ }

	I64vec1& operator= (const M64 &a) { return *this = (I64vec1) a; }
	I64vec1& operator&=(const M64 &a) { return *this = (I64vec1) _m_pand(vec,a); }
	I64vec1& operator|=(const M64 &a) { return *this = (I64vec1) _m_por(vec,a); }
	I64vec1& operator^=(const M64 &a) { return *this = (I64vec1) _m_pxor(vec,a); }

	/* Shift Logical Operations */
	I64vec1 operator<<(const M64 &a)				{ return _m_psllq(vec, a); }
	I64vec1 operator<<(int count) 				    { return _m_psllqi(vec, count); }
	I64vec1& operator<<=(const M64 &a)				{ return *this = (I64vec1) _m_psllq(vec, a); }
	I64vec1& operator<<=(int count) 				{ return *this = (I64vec1) _m_psllqi(vec, count); }
	I64vec1 operator>>(const M64 &a)				{ return _m_psrlq(vec, a); }
	I64vec1 operator>>(int count) 					{ return _m_psrlqi(vec, count); }
	I64vec1& operator>>=(const M64 &a)				{ return *this = (I64vec1) _m_psrlq(vec, a); }
	I64vec1& operator>>=(int count) 				{ return *this = (I64vec1) _m_psrlqi(vec, count); }
};

/* I32vec2 Class:
 * 2 elements, each element either a signed or unsigned int
 */
class I32vec2 : public M64
{
public:
	I32vec2() { }
	I32vec2(__m64 mm) : M64(mm) { }
	EXPLICIT I32vec2(int i) : M64 (i) { }
	EXPLICIT I32vec2(__int64 i): M64(i) {}

	/* Assignment Operator */
	I32vec2& operator= (const M64 &a) { return *this = (I32vec2) a; }

	/* Logical Assignment Operators */
	I32vec2& operator&=(const M64 &a) { return *this = (I32vec2) _m_pand(vec,a); }
	I32vec2& operator|=(const M64 &a) { return *this = (I32vec2) _m_por(vec,a); }
	I32vec2& operator^=(const M64 &a) { return *this = (I32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I32vec2& operator +=(const I32vec2 &a)			{ return *this = (I32vec2) _m_paddd(vec,a); }
	I32vec2& operator -=(const I32vec2 &a)			{ return *this = (I32vec2) _m_psubd(vec,a); }

	/* Shift Logical Operators */
	I32vec2 operator<<(const I32vec2 &a) 			{ return _m_pslld(vec,a); }
	I32vec2 operator<<(int count) 				    { return _m_pslldi(vec,count); }
	I32vec2& operator<<=(const I32vec2 &a)			{ return *this = (I32vec2) _m_pslld(vec,a); }
	I32vec2& operator<<=(int count) 				{ return *this = (I32vec2) _m_pslldi(vec,count); }

};

/* Compare For Equality */
inline I32vec2 cmpeq(const I32vec2 &a, const I32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline I32vec2 cmpneq(const I32vec2 &a, const I32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline I32vec2 unpack_low(const I32vec2 &a, const I32vec2 &b) 	{return _m_punpckldq(a,b); }
inline I32vec2 unpack_high(const I32vec2 &a, const I32vec2 &b) 	{return _m_punpckhdq(a,b); }

/* Is32vec2 Class:
 * 2 elements, each element a signed int
 */
class Is32vec2 : public I32vec2
{
public:
	Is32vec2() { }
	Is32vec2(__m64 mm) : I32vec2(mm) { }
	Is32vec2(signed int i0, signed int i1)
	{
		_MM_2DW(0,vec) = i1;
		_MM_2DW(1,vec) = i0;
	}
	EXPLICIT Is32vec2(int i) : I32vec2 (i)		{}
	EXPLICIT Is32vec2(__int64 i): I32vec2(i)	{}

	/* Assignment Operator */
	Is32vec2& operator= (const M64 &a)		{ return *this = (Is32vec2) a; }

	/* Logical Assignment Operators */
	Is32vec2& operator&=(const M64 &a)		{ return *this = (Is32vec2) _m_pand(vec,a); }
	Is32vec2& operator|=(const M64 &a)		{ return *this = (Is32vec2) _m_por(vec,a); }
	Is32vec2& operator^=(const M64 &a)		{ return *this = (Is32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is32vec2& operator +=(const I32vec2 &a)	{ return *this = (Is32vec2) _m_paddd(vec,a); }
	Is32vec2& operator -=(const I32vec2 &a)	{ return *this = (Is32vec2) _m_psubd(vec,a); }

	/* Shift Logical Operators */
	Is32vec2 operator<<(const M64 &a) 		{ return _m_pslld(vec,a); }
	Is32vec2 operator<<(int count) 			{ return _m_pslldi(vec,count); }
	Is32vec2& operator<<=(const M64 &a)		{ return *this = (Is32vec2) _m_pslld(vec,a); }
	Is32vec2& operator<<=(int count) 		{ return *this = (Is32vec2) _m_pslldi(vec,count); }
	/* Shift Arithmetic Operations */
	Is32vec2 operator>>(const M64 &a) 		{ return _m_psrad(vec, a); }
	Is32vec2 operator>>(int count) 	  		{ return _m_psradi(vec, count); }
	Is32vec2& operator>>=(const M64 &a)		{ return *this = (Is32vec2) _m_psrad(vec, a); }
	Is32vec2& operator>>=(int count) 		{ return *this = (Is32vec2) _m_psradi(vec, count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is32vec2 &a)
	{
		os << " [1]:" << _MM_2DW(1,a)
		<< " [0]:" << _MM_2DW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2DW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2DW(i,vec);
	}
};

/* Compares */
inline Is32vec2 cmpeq(const Is32vec2 &a, const Is32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline Is32vec2 cmpneq(const Is32vec2 &a, const Is32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
inline Is32vec2 cmpgt(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pcmpgtd(a,b); }
inline Is32vec2 cmplt(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pcmpgtd(b,a); }
inline Is32vec2 cmple(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pandn(_m_pcmpgtd(a,b), M64(0xffffffffffffffffi64)); }
inline Is32vec2 cmpge(const Is32vec2 &a, const Is32vec2 &b)			{ return _m_pandn(_m_pcmpgtd(b,a), M64(0xffffffffffffffffi64)); }
/* Unpacks & Pack */
inline Is32vec2 unpack_low(const Is32vec2 &a, const Is32vec2 &b) 	{ return _m_punpckldq(a,b); }
inline Is32vec2 unpack_high(const Is32vec2 &a, const Is32vec2 &b) 	{ return _m_punpckhdq(a,b); }

/* Iu32vec2 Class:
 * 2 elements, each element unsigned int
 */
class Iu32vec2 : public I32vec2
{
public:
	Iu32vec2() { }
	Iu32vec2(__m64 mm) : I32vec2(mm) { }
	Iu32vec2(unsigned int ui0, unsigned int ui1)
	{
		_MM_2UDW(0,vec) = ui1;
		_MM_2UDW(1,vec) = ui0;
	}

	EXPLICIT Iu32vec2(int i) : I32vec2 (i)		{ }
	EXPLICIT Iu32vec2(__int64 i) : I32vec2 (i)	{ }

	/* Assignment Operator */
	Iu32vec2& operator= (const M64 &a)		{ return *this = (Iu32vec2) a; }

	/* Logical Assignment Operators */
	Iu32vec2& operator&=(const M64 &a)		{ return *this = (Iu32vec2) _m_pand(vec,a); }
	Iu32vec2& operator|=(const M64 &a)		{ return *this = (Iu32vec2) _m_por(vec,a); }
	Iu32vec2& operator^=(const M64 &a)		{ return *this = (Iu32vec2) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu32vec2& operator +=(const I32vec2 &a)	{ return *this = (Iu32vec2) _m_paddd(vec,a); }
	Iu32vec2& operator -=(const I32vec2 &a)	{ return *this = (Iu32vec2) _m_psubd(vec,a); }

	/* Shift Logical Operators */
	Iu32vec2 operator<<(const M64 &a) 		{ return _m_pslld(vec,a); }
	Iu32vec2 operator<<(int count) 			{ return _m_pslldi(vec,count); }
	Iu32vec2& operator<<=(const M64 &a)		{ return *this = (Iu32vec2) _m_pslld(vec,a); }
	Iu32vec2& operator<<=(int count) 		{ return *this = (Iu32vec2) _m_pslldi(vec,count); }
	Iu32vec2 operator>>(const M64 &a) 		{ return _m_psrld(vec,a); }
	Iu32vec2 operator>>(int count) 			{ return _m_psrldi(vec,count); }
	Iu32vec2& operator>>=(const M64 &a)		{ return *this = (Iu32vec2) _m_psrld(vec,a); }
	Iu32vec2& operator>>=(int count) 		{ return *this = (Iu32vec2) _m_psrldi(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Iu32vec2 &a)
	{
		os << " [1]:" << _MM_2UDW(1,a)
		<< " [0]:" << _MM_2UDW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2UDW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	unsigned int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2UDW(i,vec);
	}
};

/* Compares For Equality / Inequality */
inline Iu32vec2 cmpeq(const Iu32vec2 &a, const Iu32vec2 &b) 	    { return _m_pcmpeqd(a,b); }
inline Iu32vec2 cmpneq(const Iu32vec2 &a, const Iu32vec2 &b) 	    { return _m_pandn(_m_pcmpeqd(a,b), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline Iu32vec2 unpack_low(const Iu32vec2 &a, const Iu32vec2 &b) 	{return _m_punpckldq(a,b); }
inline Iu32vec2 unpack_high(const Iu32vec2 &a, const Iu32vec2 &b) 	{return _m_punpckhdq(a,b); }

/* I16vec4 Class:
 * 4 elements, each element either a signed or unsigned short
 */
class I16vec4 : public M64
{
public:
	I16vec4() { }
	I16vec4(__m64 mm) : M64(mm) { }
	EXPLICIT I16vec4(__int64 i) : M64 (i) { }
	EXPLICIT I16vec4(int i) : M64 (i) { }

	/* Assignment Operator */
	I16vec4& operator= (const M64 &a)				{ return *this = (I16vec4) a; }

	/* Addition & Subtraction Assignment Operators */
	I16vec4& operator&=(const M64 &a)				{ return *this = (I16vec4) _m_pand(vec,a); }
	I16vec4& operator|=(const M64 &a)				{ return *this = (I16vec4) _m_por(vec,a); }
	I16vec4& operator^=(const M64 &a)				{ return *this = (I16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I16vec4& operator +=(const I16vec4 &a)			{ return *this = (I16vec4)_m_paddw(vec,a); }
	I16vec4& operator -=(const I16vec4 &a)			{ return *this = (I16vec4)_m_psubw(vec,a); }
	I16vec4& operator *=(const I16vec4 &a)			{ return *this = (I16vec4)_m_pmullw(vec,a); }

	/* Shift Logical Operators */
	I16vec4 operator<<(const I16vec4 &a) 			{ return _m_psllw(vec,a); }
	I16vec4 operator<<(int count) 				    { return _m_psllwi(vec,count); }
	I16vec4& operator<<=(const I16vec4 &a)			{ return *this = (I16vec4)_m_psllw(vec,a); }
	I16vec4& operator<<=(int count) 				{ return *this = (I16vec4)_m_psllwi(vec,count); }
};

inline I16vec4 operator*(const I16vec4 &a, const I16vec4 &b) 	{ return _m_pmullw(a,b); }
inline I16vec4 cmpeq(const I16vec4 &a, const I16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline I16vec4 cmpneq(const I16vec4 &a, const I16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }

inline I16vec4 unpack_low(const I16vec4 &a, const I16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline I16vec4 unpack_high(const I16vec4 &a, const I16vec4 &b) 	{ return _m_punpckhwd(a,b); }

/* Is16vec4 Class:
 * 4 elements, each element signed short
 */
class Is16vec4 : public I16vec4
{
public:
	Is16vec4() { }
	Is16vec4(__m64 mm) : I16vec4(mm) { }
	Is16vec4(short i0, short i1, short i2, short i3)
	{
		_MM_4W(0,vec) = i3;
		_MM_4W(1,vec) = i2;
		_MM_4W(2,vec) = i1;
		_MM_4W(3,vec) = i0;
	}

	EXPLICIT Is16vec4(__int64 i) : I16vec4 (i)	{ }
	EXPLICIT Is16vec4(int i) : I16vec4 (i)		{ }

	/* Assignment Operator */
	Is16vec4& operator= (const M64 &a)		{ return *this = (Is16vec4) a; }

	/* Addition & Subtraction Assignment Operators */
	Is16vec4& operator&=(const M64 &a)		{ return *this = (Is16vec4) _m_pand(vec,a); }
	Is16vec4& operator|=(const M64 &a)		{ return *this = (Is16vec4) _m_por(vec,a); }
	Is16vec4& operator^=(const M64 &a)		{ return *this = (Is16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is16vec4& operator +=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_paddw(vec,a); }
	Is16vec4& operator -=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_psubw(vec,a); }
	Is16vec4& operator *=(const I16vec4 &a)	{ return *this = (Is16vec4)_m_pmullw(vec,a); }

	/* Shift Logical Operators */
	Is16vec4 operator<<(const M64 &a) 		{ return _m_psllw(vec,a); }
	Is16vec4 operator<<(int count) 			{ return _m_psllwi(vec,count); }
	Is16vec4& operator<<=(const M64 &a)		{ return *this = (Is16vec4)_m_psllw(vec,a); }
	Is16vec4& operator<<=(int count) 		{ return *this = (Is16vec4)_m_psllwi(vec,count); }
	/* Shift Arithmetic Operations */
	Is16vec4 operator>>(const M64 &a) 		{ return _m_psraw(vec,a); }
	Is16vec4 operator>>(int count) 			{ return _m_psrawi(vec,count); }
	Is16vec4& operator>>=(const M64 &a)		{ return *this = (Is16vec4) _m_psraw(vec,a); }
	Is16vec4& operator>>=(int count) 		{ return *this = (Is16vec4) _m_psrawi(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is16vec4 &a)
	{
		os << "[3]:" << _MM_4W(3,a)
			<< " [2]:" << _MM_4W(2,a)
			<< " [1]:" << _MM_4W(1,a)
			<< " [0]:" << _MM_4W(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4W(i,vec);
	}

	/* Element Access for Debug */
	short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4W(i,vec);
	}
};

inline Is16vec4 operator*(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_pmullw(a,b); }

/* Compares */
inline Is16vec4 cmpeq(const Is16vec4 &a, const Is16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline Is16vec4 cmpneq(const Is16vec4 &a, const Is16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }
inline Is16vec4 cmpgt(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pcmpgtw(a,b); }
inline Is16vec4 cmplt(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pcmpgtw(b,a); }
inline Is16vec4 cmple(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pandn(_m_pcmpgtw(a,b), M64(0xffffffffffffffffi64)); }
inline Is16vec4 cmpge(const Is16vec4 &a, const Is16vec4 &b)			{ return _m_pandn(_m_pcmpgtw(b,a), M64(0xffffffffffffffffi64)); }
/* Unpacks */
inline Is16vec4 unpack_low(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline Is16vec4 unpack_high(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_punpckhwd(a,b); }

inline Is16vec4 sat_add(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_paddsw(a,b); }
inline Is16vec4 sat_sub(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_psubsw(a,b); }
inline Is16vec4 mul_high(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmulhw(a,b); }
inline Is32vec2 mul_add(const Is16vec4 &a, const Is16vec4 &b)		{ return _m_pmaddwd(a,b);}


/* Iu16vec4 Class:
 * 4 elements, each element unsigned short
 */
class Iu16vec4 : public I16vec4
{
public:
	Iu16vec4() { }
	Iu16vec4(__m64 mm) : I16vec4(mm) { }
	Iu16vec4(unsigned short ui0, unsigned short ui1, unsigned short ui2, unsigned short ui3)
	{
		_MM_4UW(0,vec) = ui3;
		_MM_4UW(1,vec) = ui2;
		_MM_4UW(2,vec) = ui1;
		_MM_4UW(3,vec) = ui0;
	}
	EXPLICIT Iu16vec4(__int64 i) : I16vec4 (i) { }
	EXPLICIT Iu16vec4(int i) : I16vec4 (i) { }

	/* Assignment Operator */
	Iu16vec4& operator= (const M64 &a)		{ return *this = (Iu16vec4) a; }

	/* Logical Assignment Operators */
	Iu16vec4& operator&=(const M64 &a)		{ return *this = (Iu16vec4) _m_pand(vec,a); }
	Iu16vec4& operator|=(const M64 &a)		{ return *this = (Iu16vec4) _m_por(vec,a); }
	Iu16vec4& operator^=(const M64 &a)		{ return *this = (Iu16vec4) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu16vec4& operator +=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_paddw(vec,a); }
	Iu16vec4& operator -=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_psubw(vec,a); }
	Iu16vec4& operator *=(const I16vec4 &a)	{ return *this = (Iu16vec4)_m_pmullw(vec,a); }

	/* Shift Logical Operators */
	Iu16vec4 operator<<(const M64 &a) 				{ return _m_psllw(vec,a); }
	Iu16vec4 operator<<(int count) 				    { return _m_psllwi(vec,count); }
	Iu16vec4& operator<<=(const M64 &a)				{ return *this = (Iu16vec4)_m_psllw(vec,a); }
	Iu16vec4& operator<<=(int count) 				{ return *this = (Iu16vec4)_m_psllwi(vec,count); }
	Iu16vec4 operator>>(const M64 &a) 				{ return _m_psrlw(vec,a); }
	Iu16vec4 operator>>(int count) 				    { return _m_psrlwi(vec,count); }
	Iu16vec4& operator>>=(const M64 &a)				{ return *this = (Iu16vec4) _m_psrlw(vec,a); }
	Iu16vec4& operator>>=(int count) 				{ return *this = (Iu16vec4) _m_psrlwi(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Iu16vec4 &a)
	{
		os << "[3]:" << _MM_4UW(3,a)
			<< " [2]:" << _MM_4UW(2,a)
			<< " [1]:" << _MM_4UW(1,a)
			<< " [0]:" << _MM_4UW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	unsigned short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UW(i,vec);
	}
};

inline Iu16vec4 operator*(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_pmullw(a,b); }
inline Iu16vec4 cmpeq(const Iu16vec4 &a, const Iu16vec4 &b) 	    { return _m_pcmpeqw(a,b); }
inline Iu16vec4 cmpneq(const Iu16vec4 &a, const Iu16vec4 &b) 	    { return _m_pandn(_m_pcmpeqw(a,b), M64(0xffffffffffffffffi64)); }

inline Iu16vec4 sat_add(const Iu16vec4 &a, const Iu16vec4 &b)	{ return _m_paddusw(a,b); }
inline Iu16vec4 sat_sub(const Iu16vec4 &a, const Iu16vec4 &b)	{ return _m_psubusw(a,b); }

inline Iu16vec4 unpack_low(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_punpcklwd(a,b); }
inline Iu16vec4 unpack_high(const Iu16vec4 &a, const Iu16vec4 &b) 	{ return _m_punpckhwd(a,b); }

/* I8vec8 Class:
 * 8 elements, each element either unsigned or signed char
 */
class I8vec8 : public M64
{
public:
	I8vec8() { }
	I8vec8(__m64 mm) : M64(mm) { }
	EXPLICIT I8vec8(__int64 i) : M64 (i) { }
	EXPLICIT I8vec8(int i) : M64 (i) { }

	/* Assignment Operator */
	I8vec8& operator= (const M64 &a)		{ return *this = (I8vec8) a; }

	/* Logical Assignment Operators */
	I8vec8& operator&=(const M64 &a)		{ return *this = (I8vec8) _m_pand(vec,a); }
	I8vec8& operator|=(const M64 &a)		{ return *this = (I8vec8) _m_por(vec,a); }
	I8vec8& operator^=(const M64 &a)		{ return *this = (I8vec8) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I8vec8& operator +=(const I8vec8 &a)	{ return *this = (I8vec8) _m_paddb(vec,a); }
	I8vec8& operator -=(const I8vec8 &a)	{ return *this = (I8vec8) _m_psubb(vec,a); }
};


inline I8vec8 cmpeq(const I8vec8 &a, const I8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline I8vec8 cmpneq(const I8vec8 &a, const I8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }

inline I8vec8 unpack_low(const I8vec8 &a, const I8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline I8vec8 unpack_high(const I8vec8 &a, const I8vec8 &b) { return _m_punpckhbw(a,b); }

/* Is8vec8 Class:
 * 8 elements, each element signed char
 */
class Is8vec8 : public I8vec8
{
public:
	Is8vec8() { }
	Is8vec8(__m64 mm) : I8vec8(mm) { }
	Is8vec8(signed char s0,signed char s1,signed char s2,signed char s3,signed char s4,signed char s5,signed char s6,signed char s7)
	 {
		_MM_8B(0,vec) = s7;
		_MM_8B(1,vec) = s6;
		_MM_8B(2,vec) = s5;
		_MM_8B(3,vec) = s4;
		_MM_8B(4,vec) = s3;
		_MM_8B(5,vec) = s2;
		_MM_8B(6,vec) = s1;
		_MM_8B(7,vec) = s0;
	}

	EXPLICIT Is8vec8(__int64 i) : I8vec8 (i) { }
	EXPLICIT Is8vec8(int i) : I8vec8 (i) { }

	/* Assignment Operator */
	Is8vec8& operator= (const M64 &a)		{ return *this = (Is8vec8) a; }

	/* Logical Assignment Operators */
	Is8vec8& operator&=(const M64 &a)		{ return *this = (Is8vec8) _m_pand(vec,a); }
	Is8vec8& operator|=(const M64 &a)		{ return *this = (Is8vec8) _m_por(vec,a); }
	Is8vec8& operator^=(const M64 &a)		{ return *this = (Is8vec8) _m_pxor(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is8vec8& operator +=(const I8vec8 &a)	{ return *this = (Is8vec8) _m_paddb(vec,a); }
	Is8vec8& operator -=(const I8vec8 &a)	{ return *this = (Is8vec8) _m_psubb(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is8vec8 &a)
	{
		os << "[7]:" << short(_MM_8B(7,a))
			<< " [6]:" << short(_MM_8B(6,a))
			<< " [5]:" << short(_MM_8B(5,a))
			<< " [4]:" << short(_MM_8B(4,a))
			<< " [3]:" << short(_MM_8B(3,a))
			<< " [2]:" << short(_MM_8B(2,a))
			<< " [1]:" << short(_MM_8B(1,a))
			<< " [0]:" << short(_MM_8B(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const signed char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8B(i,vec);
	}

	/* Element Access and Assignment for Debug */
	signed char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8B(i,vec);
	}
};

/* Additional Is8vec8 functions: compares, unpacks, sat add/sub */
inline Is8vec8 cmpeq(const Is8vec8 &a, const Is8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline Is8vec8 cmpneq(const Is8vec8 &a, const Is8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }
inline Is8vec8 cmpgt(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pcmpgtb(a,b); }
inline Is8vec8 cmplt(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pcmpgtb(b,a); }
inline Is8vec8 cmple(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pandn(_m_pcmpgtb(a,b), M64(0xffffffffffffffffi64)); }
inline Is8vec8 cmpge(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_pandn(_m_pcmpgtb(b,a), M64(0xffffffffffffffffi64)); }

inline Is8vec8 unpack_low(const Is8vec8 &a, const Is8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline Is8vec8 unpack_high(const Is8vec8 &a, const Is8vec8 &b) 	{ return _m_punpckhbw(a,b); }

inline Is8vec8 sat_add(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_paddsb(a,b); }
inline Is8vec8 sat_sub(const Is8vec8 &a, const Is8vec8 &b)		{ return _m_psubsb(a,b); }

/* Iu8vec8 Class:
 * 8 elements, each element unsigned char
 */
class Iu8vec8 : public I8vec8
{
public:
	Iu8vec8() { }
	Iu8vec8(__m64 mm) : I8vec8(mm) { }
	Iu8vec8(unsigned char s0,unsigned char s1,unsigned char s2,unsigned char s3,unsigned char s4,unsigned char s5,unsigned char s6,unsigned char s7)
	{
		_MM_8UB(0,vec) = s7;
		_MM_8UB(1,vec) = s6;
		_MM_8UB(2,vec) = s5;
		_MM_8UB(3,vec) = s4;
		_MM_8UB(4,vec) = s3;
		_MM_8UB(5,vec) = s2;
		_MM_8UB(6,vec) = s1;
		_MM_8UB(7,vec) = s0;
	}
	EXPLICIT Iu8vec8(__int64 i) : I8vec8 (i) { }
	EXPLICIT Iu8vec8(int i) : I8vec8 (i) { }

	/* Assignment Operator */
	Iu8vec8& operator= (const M64 &a)		{ return *this = (Iu8vec8) a; }
	/* Logical Assignment Operators */
	Iu8vec8& operator&=(const M64 &a)		{ return *this = (Iu8vec8) _m_pand(vec,a); }
	Iu8vec8& operator|=(const M64 &a)		{ return *this = (Iu8vec8) _m_por(vec,a); }
	Iu8vec8& operator^=(const M64 &a)		{ return *this = (Iu8vec8) _m_pxor(vec,a); }
	/* Addition & Subtraction Assignment Operators */
	Iu8vec8& operator +=(const I8vec8 &a)	{ return *this = (Iu8vec8) _m_paddb(vec,a); }
	Iu8vec8& operator -=(const I8vec8 &a)	{ return *this = (Iu8vec8) _m_psubb(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Iu8vec8 &a)
	{
		 os << "[7]:"  << unsigned short(_MM_8UB(7,a))
			<< " [6]:" << unsigned short(_MM_8UB(6,a))
			<< " [5]:" << unsigned short(_MM_8UB(5,a))
			<< " [4]:" << unsigned short(_MM_8UB(4,a))
			<< " [3]:" << unsigned short(_MM_8UB(3,a))
			<< " [2]:" << unsigned short(_MM_8UB(2,a))
			<< " [1]:" << unsigned short(_MM_8UB(1,a))
			<< " [0]:" << unsigned short(_MM_8UB(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UB(i,vec);
	}

	/* Element Access for Debug */
	unsigned char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UB(i,vec);
	}
};

/* Additional Iu8vec8 functions: cmpeq,cmpneq, unpacks, sat add/sub */
inline Iu8vec8 cmpeq(const Iu8vec8 &a, const Iu8vec8 &b) 		{ return _m_pcmpeqb(a,b); }
inline Iu8vec8 cmpneq(const Iu8vec8 &a, const Iu8vec8 &b) 		{ return _m_pandn(_m_pcmpeqb(a,b), M64(0xffffffffffffffffi64)); }

inline Iu8vec8 unpack_low(const Iu8vec8 &a, const Iu8vec8 &b) 	{ return _m_punpcklbw(a,b); }
inline Iu8vec8 unpack_high(const Iu8vec8 &a, const Iu8vec8 &b) 	{ return _m_punpckhbw(a,b); }

inline Iu8vec8 sat_add(const Iu8vec8 &a, const Iu8vec8 &b)		{ return _m_paddusb(a,b); }
inline Iu8vec8 sat_sub(const Iu8vec8 &a, const Iu8vec8 &b)		{ return _m_psubusb(a,b); }

inline Is16vec4 pack_sat(const Is32vec2 &a, const Is32vec2 &b)		{ return _m_packssdw(a,b); }
inline Is8vec8 pack_sat(const Is16vec4 &a, const Is16vec4 &b) 		{ return _m_packsswb(a,b); }
inline Iu8vec8 packu_sat(const Is16vec4 &a, const Is16vec4 &b) 	{ return _m_packuswb(a,b); }

/********************************* Logicals ****************************************/
#define IVEC_LOGICALS(vect,element) \
inline I##vect##vec##element operator& (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pand( a,b); } \
inline I##vect##vec##element operator| (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_por( a,b); } \
inline I##vect##vec##element operator^ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pxor( a,b); } \
inline I##vect##vec##element andnot (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_pandn( a,b); }

IVEC_LOGICALS(8,8)
IVEC_LOGICALS(u8,8)
IVEC_LOGICALS(s8,8)
IVEC_LOGICALS(16,4)
IVEC_LOGICALS(u16,4)
IVEC_LOGICALS(s16,4)
IVEC_LOGICALS(32,2)
IVEC_LOGICALS(u32,2)
IVEC_LOGICALS(s32,2)
IVEC_LOGICALS(64,1)
#undef IVEC_LOGICALS

/********************************* Add & Sub ****************************************/
#define IVEC_ADD_SUB(vect,element,opsize) \
inline I##vect##vec##element operator+ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_padd##opsize( a,b); } \
inline I##vect##vec##element operator- (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _m_psub##opsize( a,b); }

IVEC_ADD_SUB(8,8, b)
IVEC_ADD_SUB(u8,8, b)
IVEC_ADD_SUB(s8,8, b)
IVEC_ADD_SUB(16,4, w)
IVEC_ADD_SUB(u16,4, w)
IVEC_ADD_SUB(s16,4, w)
IVEC_ADD_SUB(32,2, d)
IVEC_ADD_SUB(u32,2, d)
IVEC_ADD_SUB(s32,2, d)
#undef IVEC_ADD_SUB

/********************************* Conditional Select ****************************************/
/*	version of: retval = (a OP b)? c : d;													 *
 *	Where OP is one of the possible comparision operators.									 *
 *	Example: r = select_eq(a,b,c,d);														 *
 *	if "member at position x of the vector a" == "member at position x of vector b" 		 *
 *	assign the corresponding member in r from c, else assign from d.							 *
 ********************************* Conditional Select ****************************************/

#define IVEC_SELECT(vect12,vect34,element,selop,arg1,arg2) \
	inline I##vect34##vec##element select_##selop (const I##vect12##vec##element &a, const I##vect12##vec##element &b, const I##vect34##vec##element &c, const I##vect34##vec##element &d) 	   \
{																\
	I##vect12##vec##element mask = cmp##selop(a,b);						\
	return( I##vect34##vec##element ((mask & arg1 ) | I##vect12##vec##element ((_m_pandn(mask, arg2 )))));	\
}
IVEC_SELECT(8,s8,8,eq,c,d)
IVEC_SELECT(8,u8,8,eq,c,d)
IVEC_SELECT(8,8,8,eq,c,d)
IVEC_SELECT(8,s8,8,neq,c,d)
IVEC_SELECT(8,u8,8,neq,c,d)
IVEC_SELECT(8,8,8,neq,c,d)

IVEC_SELECT(16,s16,4,eq,c,d)
IVEC_SELECT(16,u16,4,eq,c,d)
IVEC_SELECT(16,16,4,eq,c,d)
IVEC_SELECT(16,s16,4,neq,c,d)
IVEC_SELECT(16,u16,4,neq,c,d)
IVEC_SELECT(16,16,4,neq,c,d)

IVEC_SELECT(32,s32,2,eq,c,d)
IVEC_SELECT(32,u32,2,eq,c,d)
IVEC_SELECT(32,32,2,eq,c,d)
IVEC_SELECT(32,s32,2,neq,c,d)
IVEC_SELECT(32,u32,2,neq,c,d)
IVEC_SELECT(32,32,2,neq,c,d)


IVEC_SELECT(s8,s8,8,gt,c,d)
IVEC_SELECT(s8,u8,8,gt,c,d)
IVEC_SELECT(s8,8,8,gt,c,d)
IVEC_SELECT(s8,s8,8,lt,c,d)
IVEC_SELECT(s8,u8,8,lt,c,d)
IVEC_SELECT(s8,8,8,lt,c,d)
IVEC_SELECT(s8,s8,8,le,c,d)
IVEC_SELECT(s8,u8,8,le,c,d)
IVEC_SELECT(s8,8,8,le,c,d)
IVEC_SELECT(s8,s8,8,ge,c,d)
IVEC_SELECT(s8,u8,8,ge,c,d)
IVEC_SELECT(s8,8,8,ge,c,d)

IVEC_SELECT(s16,s16,4,gt,c,d)
IVEC_SELECT(s16,u16,4,gt,c,d)
IVEC_SELECT(s16,16,4,gt,c,d)
IVEC_SELECT(s16,s16,4,lt,c,d)
IVEC_SELECT(s16,u16,4,lt,c,d)
IVEC_SELECT(s16,16,4,lt,c,d)
IVEC_SELECT(s16,s16,4,le,c,d)
IVEC_SELECT(s16,u16,4,le,c,d)
IVEC_SELECT(s16,16,4,le,c,d)
IVEC_SELECT(s16,s16,4,ge,c,d)
IVEC_SELECT(s16,u16,4,ge,c,d)
IVEC_SELECT(s16,16,4,ge,c,d)

IVEC_SELECT(s32,s32,2,gt,c,d)
IVEC_SELECT(s32,u32,2,gt,c,d)
IVEC_SELECT(s32,32,2,gt,c,d)
IVEC_SELECT(s32,s32,2,lt,c,d)
IVEC_SELECT(s32,u32,2,lt,c,d)
IVEC_SELECT(s32,32,2,lt,c,d)
IVEC_SELECT(s32,s32,2,le,c,d)
IVEC_SELECT(s32,u32,2,le,c,d)
IVEC_SELECT(s32,32,2,le,c,d)
IVEC_SELECT(s32,s32,2,ge,c,d)
IVEC_SELECT(s32,u32,2,ge,c,d)
IVEC_SELECT(s32,32,2,ge,c,d)


#undef IVEC_SELECT

inline static void empty(void) 		{ _m_empty(); }

#if defined(_SILENCE_IVEC_C4799)
	#pragma warning(pop)
#endif

#endif // IVEC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\stdiostr.h ===
/***
*stdiostr.h - definitions/declarations for stdiobuf, stdiostream
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the stdiostream and stdiobuf classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STDIOSTREAM
#define _INC_STDIOSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
/* current definition */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <iostream.h>
#include <stdio.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

class _CRTIMP stdiobuf : public streambuf  {
public:
        stdiobuf(FILE* f);
FILE *  stdiofile() { return _str; }

virtual int pbackfail(int c);
virtual int overflow(int c = EOF);
virtual int underflow();
virtual streampos seekoff( streamoff, ios::seek_dir, int =ios::in|ios::out);
virtual int sync();
        ~stdiobuf();
        int setrwbuf(int _rsize, int _wsize);
// protected:
// virtual int doallocate();
private:
        FILE * _str;
};

// obsolescent
class _CRTIMP stdiostream : public iostream {  // note: spec.'d as : public IOS...
public:
        stdiostream(FILE *);
        ~stdiostream();
        stdiobuf* rdbuf() const { return (stdiobuf*) ostream::rdbuf(); }
        
private:
};

#ifdef  _MSC_VER
// Restore default packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STDIOSTREAM

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\new.h ===
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*       Copyright (c) 1990-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the declarations for C++ memory allocation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_NEW
#define _INC_NEW

#ifdef  __cplusplus

#ifndef _MSC_EXTENSIONS
#include <new>
#endif

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* Protect against #define of new */
#pragma push_macro("new")
#undef  new


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP2 */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* types and structures */

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifdef  _MSC_EXTENSIONS
namespace std {
        typedef void (__cdecl * new_handler) ();
        _CRTIMP2 new_handler __cdecl set_new_handler(new_handler) throw();
};
using std::new_handler;
using std::set_new_handler;
#endif

#ifndef __NOTHROW_T_DEFINED
#define __NOTHROW_T_DEFINED
namespace std {
        /* placement new tag type to suppress exceptions */
        struct nothrow_t {};

        /* constant for placement new tag */
        extern const nothrow_t nothrow;
};

void *__cdecl operator new(size_t, const std::nothrow_t&) throw();
void *__cdecl operator new[](size_t, const std::nothrow_t&) throw();
void __cdecl operator delete(void *, const std::nothrow_t&) throw();
void __cdecl operator delete[](void *, const std::nothrow_t&) throw();
#endif

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
        {return (_P); }
#if     _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void *)
        {return; }
#endif
#endif


/* 
 * new mode flag -- when set, makes malloc() behave like new()
 */

_CRTIMP int __cdecl _query_new_mode( void );
_CRTIMP int __cdecl _set_new_mode( int );

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

_CRTIMP _PNH __cdecl _query_new_handler( void );
_CRTIMP _PNH __cdecl _set_new_handler( _PNH );

/*
 * Microsoft extension: 
 *
 * _NO_ANSI_NEW_HANDLER de-activates the ANSI new_handler. Use this special value
 * to support old style (_set_new_handler) behavior.
 */

#ifndef _NO_ANSI_NH_DEFINED
#define _NO_ANSI_NEW_HANDLER  ((new_handler)-1)
#define _NO_ANSI_NH_DEFINED
#endif

#pragma pop_macro("new")

#endif  /* __cplusplus */

#endif  /* _INC_NEW */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\streamb.h ===
/***
*streamb.h - definitions/declarations for the streambuf class
*
*       Copyright (c) 1990-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the streambuf class.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STREAMB
#define _INC_STREAMB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#include <useoldio.h>

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <ios.h>        // need ios::seek_dir definition

#ifndef NULL
#define NULL    0
#endif

#ifndef EOF
#define EOF     (-1)
#endif

#ifdef  _MSC_VER
// C4514: "unreferenced inline function has been removed"
#pragma warning(disable:4514) // disable C4514 warning
// #pragma warning(default:4514)        // use this to reenable, if desired
#endif  // _MSC_VER

typedef long streampos, streamoff;

class _CRTIMP ios;

class _CRTIMP streambuf {
public:

    virtual ~streambuf();

    inline int in_avail() const;
    inline int out_waiting() const;
    int sgetc();
    int snextc();
    int sbumpc();
    void stossc();

    inline int sputbackc(char);

    inline int sputc(int);
    inline int sputn(const char *,int);
    inline int sgetn(char *,int);

    virtual int sync();

    virtual streambuf* setbuf(char *, int);
    virtual streampos seekoff(streamoff,ios::seek_dir,int =ios::in|ios::out);
    virtual streampos seekpos(streampos,int =ios::in|ios::out);

    virtual int xsputn(const char *,int);
    virtual int xsgetn(char *,int);

    virtual int overflow(int =EOF) = 0; // pure virtual function
    virtual int underflow() = 0;        // pure virtual function

    virtual int pbackfail(int);

    void dbp();

#ifdef  _MT
    void setlock() { LockFlg--; }       // <0 indicates lock required;
    void clrlock() { if (LockFlg <= 0) LockFlg++; }
    void lock() { if (LockFlg<0) _mtlock(lockptr()); };
    void unlock() { if (LockFlg<0) _mtunlock(lockptr()); }
#else
    void lock() { }
    void unlock() { }
#endif

protected:
    streambuf();
    streambuf(char *,int);

    inline char * base() const;
    inline char * ebuf() const;
    inline char * pbase() const;
    inline char * pptr() const;
    inline char * epptr() const;
    inline char * eback() const;
    inline char * gptr() const;
    inline char * egptr() const;
    inline int blen() const;
    inline void setp(char *,char *);
    inline void setg(char *,char *,char *);
    inline void pbump(int);
    inline void gbump(int);

    void setb(char *,char *,int =0);
    inline int unbuffered() const;
    inline void unbuffered(int);
    int allocate();
    virtual int doallocate();
#ifdef  _MT
    _PCRT_CRITICAL_SECTION lockptr() { return & x_lock; }
#endif

private:
    int _fAlloc;
    int _fUnbuf;
    int x_lastc;
    char * _base;
    char * _ebuf;
    char * _pbase;
    char * _pptr;
    char * _epptr;
    char * _eback;
    char * _gptr;
    char * _egptr;
#ifdef  _MT
    int LockFlg;                // <0 indicates locking required
   _CRT_CRITICAL_SECTION x_lock;        // lock needed only for multi-thread operation
#endif
};

inline int streambuf::in_avail() const { return (gptr()<_egptr) ? (int)(_egptr-gptr()) : 0; }
inline int streambuf::out_waiting() const { return (_pptr>=_pbase) ? (int)(_pptr-_pbase) : 0; }

inline int streambuf::sputbackc(char _c){ return (_eback<gptr()) ? *(--_gptr)=_c : pbackfail(_c); }

inline int streambuf::sputc(int _i){ return (_pptr<_epptr) ? (unsigned char)(*(_pptr++)=(char)_i) : overflow(_i); }

inline int streambuf::sputn(const char * _str,int _n) { return xsputn(_str, _n); }
inline int streambuf::sgetn(char * _str,int _n) { return xsgetn(_str, _n); }

inline char * streambuf::base() const { return _base; }
inline char * streambuf::ebuf() const { return _ebuf; }
inline int streambuf::blen() const  {return ((_ebuf > _base) ? (int)(_ebuf-_base) : 0); }
inline char * streambuf::pbase() const { return _pbase; }
inline char * streambuf::pptr() const { return _pptr; }
inline char * streambuf::epptr() const { return _epptr; }
inline char * streambuf::eback() const { return _eback; }
inline char * streambuf::gptr() const { return _gptr; }
inline char * streambuf::egptr() const { return _egptr; }
inline void streambuf::gbump(int _n) { if (_egptr) _gptr += _n; }
inline void streambuf::pbump(int _n) { if (_epptr) _pptr += _n; }
inline void streambuf::setg(char * _eb, char * _g, char * _eg) {_eback=_eb; _gptr=_g; _egptr=_eg; x_lastc=EOF; }
inline void streambuf::setp(char * _p, char * _ep) {_pptr=_pbase=_p; _epptr=_ep; }
inline int streambuf::unbuffered() const { return _fUnbuf; }
inline void streambuf::unbuffered(int _f) { _fUnbuf = _f; }

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STREAMB

#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\strstrea.h ===
/***
*strstrea.h - definitions/declarations for strstreambuf, strstream
*
*       Copyright (c) 1991-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This file defines the classes, values, macros, and functions
*       used by the strstream and strstreambuf classes.
*       [AT&T C++]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifdef  __cplusplus

#ifndef _INC_STRSTREAM
#define _INC_STRSTREAM

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER

// Currently, all MS C compilers for Win32 platforms default to 8 byte
// alignment.
#pragma pack(push,8)

#endif  // _MSC_VER

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


#include <useoldio.h>
#include <iostream.h>

#ifdef  _MSC_VER
#pragma warning(disable:4514)           // disable unwanted /W4 warning
// #pragma warning(default:4514)        // use this to reenable, if necessary
#endif  // _MSC_VER

class _CRTIMP strstreambuf : public streambuf  {
public:
                strstreambuf();
                strstreambuf(int);
                strstreambuf(char *, int, char * = 0);
                strstreambuf(unsigned char *, int, unsigned char * = 0);
                strstreambuf(signed char *, int, signed char * = 0);
                strstreambuf(void * (*a)(long), void (*f) (void *));
                ~strstreambuf();

        void    freeze(int =1);
        char * str();

virtual int     overflow(int);
virtual int     underflow();
virtual streambuf* setbuf(char *, int);
virtual streampos seekoff(streamoff, ios::seek_dir, int);
virtual int     sync();         // not in spec.

protected:
virtual int     doallocate();
private:
        int     x_dynamic;
        int     x_bufmin;
        int     _fAlloc;
        int     x_static;
        void * (* x_alloc)(long);
        void    (* x_free)(void *);
};

class _CRTIMP istrstream : public istream {
public:
                istrstream(char *);
                istrstream(char *, int);
                ~istrstream();

inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char * str() { return rdbuf()->str(); }
};

class _CRTIMP ostrstream : public ostream {
public:
                ostrstream();
                ostrstream(char *, int, int = ios::out);
                ~ostrstream();

inline  int     pcount() const { return rdbuf()->out_waiting(); }
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char *  str() { return rdbuf()->str(); }
};

class _CRTIMP strstream : public iostream {    // strstreambase ???
public:
                strstream();
                strstream(char *, int, int);
                ~strstream();

inline  int     pcount() const { return rdbuf()->out_waiting(); } // not in spec.
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ostream::rdbuf(); }
inline  char * str() { return rdbuf()->str(); }
};

#ifdef  _MSC_VER
// Restore previous packing
#pragma pack(pop)
#endif  // _MSC_VER

#endif  // _INC_STRSTREAM

#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the machine-dependent buffer used by
*       setjmp/longjmp to save and restore the program state, and
*       declarations for those routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SETJMP
#define _INC_SETJMP

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/*
 * Definitions specific to particular setjmp implementations.
 */

#if     defined(_M_IX86)

/*
 * MS compiler for x86
 */

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif

#define _JBLEN  16
#define _JBTYPE int

/*
 * Define jump buffer layout for x86 setjmp/longjmp.
 */
typedef struct __JUMP_BUFFER {
    unsigned long Ebp;
    unsigned long Ebx;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Esp;
    unsigned long Eip;
    unsigned long Registration;
    unsigned long TryLevel;
    unsigned long Cookie;
    unsigned long UnwindFunc;
    unsigned long UnwindData[6];
} _JUMP_BUFFER;


#elif defined(_M_IA64)

/*
 * Minimum length is 528 bytes
 * Since this is allocated as an array of "SETJMP_FLOAT128", the
 * number of entries required is 33 (16-byte aligned).
 */

/* Avoid conflicts with winnt.h FLOAT128 by giving the typedef another name. */
typedef __declspec(align(16)) struct _SETJMP_FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} SETJMP_FLOAT128;
                                  
#define _JBLEN  33
typedef SETJMP_FLOAT128 _JBTYPE;
#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif
/*
 * Define jump buffer layout for IA64 setjmp/longjmp.
 */

typedef struct __JUMP_BUFFER {

    /*
     * x86 reserved.
     */

    unsigned long iAReserved[6];

    /*
     * x86 C9.0 compatibility
     */

    unsigned long Registration;  /* point to the UnwindData field. */
    unsigned long TryLevel;      /* ignored by setjmp */
    unsigned long Cookie;        /* set to "VC20" by setjmp */
    unsigned long UnwindFunc;    /* set to EM longjmp() by setjmp */

    /*
     * First dword is zero to indicate it's an exception registration
     * record prepared by EM setjmp function.
     * Second dword is set to 0 for unsafe EM setjmp, and 1 for safe
     * EM setjmp.
     * Third dword is set to the setjmp site memory stack frame pointer.
     * Fourth dword is set to the setjmp site backing store frame pointer.
     */

    unsigned long UnwindData[6];

    /*
     * floating point status register,
     * and preserved floating point registers fs0 - fs19
     */

    SETJMP_FLOAT128 FltS0;
    SETJMP_FLOAT128 FltS1;
    SETJMP_FLOAT128 FltS2;
    SETJMP_FLOAT128 FltS3;
    SETJMP_FLOAT128 FltS4;
    SETJMP_FLOAT128 FltS5;
    SETJMP_FLOAT128 FltS6;
    SETJMP_FLOAT128 FltS7;
    SETJMP_FLOAT128 FltS8;
    SETJMP_FLOAT128 FltS9;
    SETJMP_FLOAT128 FltS10;
    SETJMP_FLOAT128 FltS11;
    SETJMP_FLOAT128 FltS12;
    SETJMP_FLOAT128 FltS13;
    SETJMP_FLOAT128 FltS14;
    SETJMP_FLOAT128 FltS15;
    SETJMP_FLOAT128 FltS16;
    SETJMP_FLOAT128 FltS17;
    SETJMP_FLOAT128 FltS18;
    SETJMP_FLOAT128 FltS19;

    __int64 FPSR;

    /*
     * return link and preserved branch registers bs0 - bs4
     */

    __int64 StIIP;     /* continuation address */
    __int64 BrS0;
    __int64 BrS1;
    __int64 BrS2;
    __int64 BrS3;
    __int64 BrS4;

    /*
     * preserved general registers s0 - s3, sp, nats
     */

    __int64 IntS0;
    __int64 IntS1;
    __int64 IntS2;
    __int64 IntS3;

    /*
     * bsp, pfs, unat, lc
     */

    __int64 RsBSP;
    __int64 RsPFS;     /* previous frame marker (cfm of setjmp's caller) */
    __int64 ApUNAT;    /* User Nat collection register (preserved) */
    __int64 ApLC;      /* loop counter */

    __int64 IntSp;     /* memory stack pointer */
    __int64 IntNats;   /* Nat bits of preserved integer regs s0 - s3 */
    __int64 Preds;     /* predicates */

} _JUMP_BUFFER;
#elif defined(_M_AMD64)

typedef __declspec(align(16)) struct _SETJMP_FLOAT128 {
    unsigned __int64 Part[2];
} SETJMP_FLOAT128;

#define _JBLEN  16
typedef SETJMP_FLOAT128 _JBTYPE;

#ifndef _INC_SETJMPEX
#define setjmp  _setjmp
#endif

typedef struct _JUMP_BUFFER {
    unsigned __int64 Frame;
    unsigned __int64 Rbx;
    unsigned __int64 Rsp;
    unsigned __int64 Rbp;
    unsigned __int64 Rsi;
    unsigned __int64 Rdi;
    unsigned __int64 R12;
    unsigned __int64 R13;
    unsigned __int64 R14;
    unsigned __int64 R15;
    unsigned __int64 Rip;
    unsigned __int64 Spare;
    
    SETJMP_FLOAT128 Xmm6;
    SETJMP_FLOAT128 Xmm7;
    SETJMP_FLOAT128 Xmm8;
    SETJMP_FLOAT128 Xmm9;
    SETJMP_FLOAT128 Xmm10;
    SETJMP_FLOAT128 Xmm11;
    SETJMP_FLOAT128 Xmm12;
    SETJMP_FLOAT128 Xmm13;
    SETJMP_FLOAT128 Xmm14;
    SETJMP_FLOAT128 Xmm15;
} _JUMP_BUFFER;

#endif


/* Define the buffer type for holding the state information */

#ifndef _JMP_BUF_DEFINED
typedef _JBTYPE jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif


/* Function prototypes */

int __cdecl setjmp(jmp_buf);

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl longjmp(jmp_buf, int);
#else
_CRTIMP void __cdecl longjmp(jmp_buf, int);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_SETJMP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains definitions and declarations for some commonly
*       used constants, types, and variables.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDDEF
#define _INC_STDDEF

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Declare reference to errno */

#if     defined(_MT) || defined(_DLL)
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;
#endif  /* _MT || _DLL */


/* Define the implementation dependent size types */

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _PTRDIFF_T_DEFINED
#ifdef  _WIN64
typedef __int64             ptrdiff_t;
#else
typedef _W64 int            ptrdiff_t;
#endif
#define _PTRDIFF_T_DEFINED
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* Define offsetof macro */

#ifdef  _WIN64
#define offsetof(s,m)   (size_t)( (ptrdiff_t)&(((s *)0)->m) )
#else
#define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif


#ifdef  _MT
_CRTIMP extern unsigned long  __cdecl __threadid(void);
#define _threadid       (__threadid())
_CRTIMP extern uintptr_t __cdecl __threadhandle(void);
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STDDEF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for commonly
*       used library functions which either don't fit somewhere else, or,
*       cannot be declared in the normal place for other reasons.
*       [ANSI]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDLIB
#define _INC_STDLIB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTNOALIAS, _CRTRESTRICT */

#if     _MSC_FULL_VER >= 14002050

#ifndef _CRTNOALIAS
#define _CRTNOALIAS __declspec(noalias)
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT __declspec(restrict)
#endif  /* _CRTRESTRICT */

#else

#ifndef _CRTNOALIAS
#define _CRTNOALIAS
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT
#endif  /* _CRTRESTRICT */

#endif

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Definition of the argument values for the exit() function */

#define EXIT_SUCCESS    0
#define EXIT_FAILURE    1


#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)(void);
#if     !__STDC__
/* Non-ANSI name for compatibility */
#define onexit_t _onexit_t
#endif
#define _ONEXIT_T_DEFINED
#endif


/* Data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif


/* Maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in ctype.h).
 */
#ifndef MB_CUR_MAX
#ifdef _MT
#define MB_CUR_MAX ___mb_cur_max_func()
#else
#define MB_CUR_MAX __mb_cur_max
#endif
_CRTIMP extern int __mb_cur_max;
_CRTIMP int __cdecl ___mb_cur_max_func(void);
#endif  /* MB_CUR_MAX */

/* Minimum and maximum macros */

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))

/*
 * Sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */
#define _MAX_PATH   260 /* max. length of full pathname */
#define _MAX_DRIVE  3   /* max. length of drive component */
#define _MAX_DIR    256 /* max. length of path component */
#define _MAX_FNAME  256 /* max. length of file name component */
#define _MAX_EXT    256 /* max. length of extension component */

/*
 * Argument values for _set_error_mode().
 */
#define _OUT_TO_DEFAULT 0
#define _OUT_TO_STDERR  1
#define _OUT_TO_MSGBOX  2
#define _REPORT_ERRMODE 3

#if     defined(_M_IX86)
/*
 * Typedefs and argument values for _set_security_error_handler()
 */
#define _SECERR_BUFFER_OVERRUN 1        /* void* arg ignored */
typedef void (__cdecl * _secerr_handler_func)(int, void *);
#endif

/* External variable declarations */

#if     defined(_MT) || defined(_DLL)
_CRTIMP int * __cdecl _errno(void);
_CRTIMP unsigned long * __cdecl __doserrno(void);
#define errno       (*_errno())
#define _doserrno   (*__doserrno())
#else   /* ndef _MT && ndef _DLL */
_CRTIMP extern int errno;               /* XENIX style error number */
_CRTIMP extern unsigned long _doserrno; /* OS system error value */
#endif  /* _MT || _DLL */


_CRTIMP extern char * _sys_errlist[];   /* perror error message table */
_CRTIMP extern int _sys_nerr;           /* # of entries in sys_errlist table */


#if     defined(_DLL) && defined(_M_IX86)

#define __argc      (*__p___argc())     /* count of cmd line args */
#define __argv      (*__p___argv())     /* pointer to table of cmd line args */
#define __wargv     (*__p___wargv())    /* pointer to table of wide cmd line args */
#define _environ    (*__p__environ())   /* pointer to environment table */
#ifdef  _POSIX_
extern char ** environ;                 /* pointer to environment table */
#else
#define _wenviron   (*__p__wenviron())  /* pointer to wide environment table */
#endif  /* _POSIX_ */
#define _pgmptr     (*__p__pgmptr())    /* points to the module (EXE) name */
#define _wpgmptr    (*__p__wpgmptr())   /* points to the module (EXE) wide name */

_CRTIMP int *          __cdecl __p___argc(void);
_CRTIMP char ***       __cdecl __p___argv(void);
_CRTIMP wchar_t ***    __cdecl __p___wargv(void);
_CRTIMP char ***       __cdecl __p__environ(void);
_CRTIMP wchar_t ***    __cdecl __p__wenviron(void);
_CRTIMP char **        __cdecl __p__pgmptr(void);
_CRTIMP wchar_t **     __cdecl __p__wpgmptr(void);


#else

_CRTIMP extern int __argc;          /* count of cmd line args */
_CRTIMP extern char ** __argv;      /* pointer to table of cmd line args */
_CRTIMP extern wchar_t ** __wargv;  /* pointer to table of wide cmd line args */

#ifdef  _POSIX_
extern char ** environ;             /* pointer to environment table */
#else
_CRTIMP extern char ** _environ;    /* pointer to environment table */
_CRTIMP extern wchar_t ** _wenviron;    /* pointer to wide environment table */
#endif  /* _POSIX_ */

_CRTIMP extern char * _pgmptr;      /* points to the module (EXE) name */
_CRTIMP extern wchar_t * _wpgmptr;  /* points to the module (EXE) wide name */

#endif


_CRTIMP extern int _fmode;          /* default file translation mode */
_CRTIMP extern int _fileinfo;       /* open file info mode (for spawn) */


/* Windows major/minor and O.S. version numbers */

_CRTIMP extern unsigned int _osplatform;
_CRTIMP extern unsigned int _osver;
_CRTIMP extern unsigned int _winver;
_CRTIMP extern unsigned int _winmajor;
_CRTIMP extern unsigned int _winminor;


/* function prototypes */

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void   __cdecl abort(void);
_CRTIMP __declspec(noreturn) void   __cdecl exit(int);
#else
_CRTIMP void   __cdecl abort(void);
_CRTIMP void   __cdecl exit(int);
#endif

        int    __cdecl abs(int);
        __int64    __cdecl _abs64(__int64);
        int    __cdecl atexit(void (__cdecl *)(void));
_CRTIMP double __cdecl atof(const char *);
_CRTIMP int    __cdecl atoi(const char *);
_CRTIMP long   __cdecl atol(const char *);
_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
        unsigned short __cdecl _byteswap_ushort(unsigned short);
        unsigned long  __cdecl _byteswap_ulong (unsigned long);
        unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void * __cdecl calloc(size_t, size_t);
_CRTIMP div_t  __cdecl div(int, int);
_CRTIMP _CRTNOALIAS void   __cdecl free(void *);
_CRTIMP char * __cdecl getenv(const char *);
_CRTIMP char * __cdecl _itoa(int, char *, int);
#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP char * __cdecl _i64toa(__int64, char *, int);
_CRTIMP char * __cdecl _ui64toa(unsigned __int64, char *, int);
_CRTIMP __int64 __cdecl _atoi64(const char *);
_CRTIMP __int64 __cdecl _strtoi64(const char *, char **, int);
_CRTIMP unsigned __int64 __cdecl _strtoui64(const char *, char **, int);
#endif
        long __cdecl labs(long);
_CRTIMP ldiv_t __cdecl ldiv(long, long);
_CRTIMP char * __cdecl _ltoa(long, char *, int);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void * __cdecl malloc(size_t);
_CRTIMP int    __cdecl mblen(const char *, size_t);
_CRTIMP size_t __cdecl _mbstrlen(const char *s);
_CRTIMP int    __cdecl mbtowc(wchar_t *, const char *, size_t);
_CRTIMP size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
_CRTIMP void   __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
        (const void *, const void *));
_CRTIMP int    __cdecl rand(void);
_CRTIMP _CRTNOALIAS _CRTRESTRICT void * __cdecl realloc(void *, size_t);
_CRTIMP int    __cdecl _set_error_mode(int);
#if     defined(_M_IX86)
_CRTIMP _secerr_handler_func
               __cdecl _set_security_error_handler(_secerr_handler_func);
#endif
_CRTIMP void   __cdecl srand(unsigned int);
_CRTIMP double __cdecl strtod(const char *, char **);
_CRTIMP long   __cdecl strtol(const char *, char **, int);
_CRTIMP unsigned long __cdecl strtoul(const char *, char **, int);
_CRTIMP int    __cdecl system(const char *);
_CRTIMP char * __cdecl _ultoa(unsigned long, char *, int);
_CRTIMP int    __cdecl wctomb(char *, wchar_t);
_CRTIMP size_t __cdecl wcstombs(char *, const wchar_t *, size_t);


#ifndef _WSTDLIB_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP double __cdecl _wtof(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);
#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);
_CRTIMP __int64   __cdecl _wcstoi64(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned __int64  __cdecl _wcstoui64(const wchar_t *, wchar_t **, int);
#endif

#define _WSTDLIB_DEFINED
#endif


#ifndef _POSIX_

_CRTIMP char * __cdecl _ecvt(double, int, int *, int *);
#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void   __cdecl _exit(int);
#else
_CRTIMP void   __cdecl _exit(int);
#endif
_CRTIMP char * __cdecl _fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl _fullpath(char *, const char *, size_t);
_CRTIMP char * __cdecl _gcvt(double, int, char *);
        unsigned long __cdecl _lrotl(unsigned long, int);
        unsigned long __cdecl _lrotr(unsigned long, int);
_CRTIMP void   __cdecl _makepath(char *, const char *, const char *, const char *,
        const char *);
        _onexit_t __cdecl _onexit(_onexit_t);
_CRTIMP void   __cdecl perror(const char *);
_CRTIMP int    __cdecl _putenv(const char *);
        unsigned int __cdecl _rotl(unsigned int, int);
        unsigned __int64 __cdecl _rotl64(unsigned __int64, int);
        unsigned int __cdecl _rotr(unsigned int, int);
        unsigned __int64 __cdecl _rotr64(unsigned __int64, int);
_CRTIMP void   __cdecl _searchenv(const char *, const char *, char *);
_CRTIMP void   __cdecl _splitpath(const char *, char *, char *, char *, char *);
_CRTIMP void   __cdecl _swab(char *, char *, int);

#ifndef _WSTDLIBP_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API SetErrorMode, Beep and Sleep should be used instead. */
_CRTIMP void __cdecl _seterrormode(int);
_CRTIMP void __cdecl _beep(unsigned, unsigned);
_CRTIMP void __cdecl _sleep(unsigned long);
/* --------- The preceding functions are OBSOLETE --------- */

#endif  /* _POSIX_ */


#if     !__STDC__
/* --------- The declarations below should not be in stdlib.h --------- */
/* --------- and will be removed in a future release. Include --------- */
/* --------- ctype.h to obtain these declarations.            --------- */
#ifndef tolower     /* tolower has been undefined - use function */
_CRTIMP int __cdecl tolower(int);
#endif  /* tolower */
#ifndef toupper     /* toupper has been undefined - use function */
_CRTIMP int __cdecl toupper(int);
#endif  /* toupper */
/* --------- The declarations above will be removed.          --------- */
#endif


#if     !__STDC__

#ifndef _POSIX_

/* Non-ANSI names for compatibility */

#ifndef __cplusplus
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#define sys_errlist _sys_errlist
#define sys_nerr    _sys_nerr
#define environ     _environ

_CRTIMP char * __cdecl ecvt(double, int, int *, int *);
_CRTIMP char * __cdecl fcvt(double, int, int *, int *);
_CRTIMP char * __cdecl gcvt(double, int, char *);
_CRTIMP char * __cdecl itoa(int, char *, int);
_CRTIMP char * __cdecl ltoa(long, char *, int);
        onexit_t __cdecl onexit(onexit_t);
_CRTIMP int    __cdecl putenv(const char *);
_CRTIMP void   __cdecl swab(char *, char *, int);
_CRTIMP char * __cdecl ultoa(unsigned long, char *, int);

#endif  /* _POSIX_ */

#endif  /* __STDC__ */

#ifdef  __cplusplus
}

#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDLIB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\typeinfo.h ===
/***
*typeinfo.h - Defines the type_info structure and exceptions used for RTTI
*
*       Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the type_info structure and exceptions used for
*       Runtime Type Identification.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef __cplusplus
#error This header requires a C++ compiler ...
#endif

#ifndef _INC_TYPEINFO
#define _INC_TYPEINFO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

class type_info {
public:
    _CRTIMP virtual ~type_info();
    _CRTIMP int operator==(const type_info& rhs) const;
    _CRTIMP int operator!=(const type_info& rhs) const;
    _CRTIMP int before(const type_info& rhs) const;
    _CRTIMP const char* name() const;
    _CRTIMP const char* raw_name() const;
private:
    void *_m_data;
    char _m_d_name[1];
    type_info(const type_info& rhs);
    type_info& operator=(const type_info& rhs);
};


// This include must occur below the definition of class type_info
#include <stdexcpt.h>

class _CRTIMP bad_cast : public exception {
public:
    bad_cast(const char * _Message = "bad cast");
    bad_cast(const bad_cast &);
    virtual ~bad_cast();
};

class _CRTIMP bad_typeid : public exception {
public:
    bad_typeid(const char * _Message = "bad typeid");
    bad_typeid(const bad_typeid &);
    virtual ~bad_typeid();
};

class _CRTIMP __non_rtti_object : public bad_typeid {
public:
    __non_rtti_object(const char * _Message);
    __non_rtti_object(const __non_rtti_object &);
    virtual ~__non_rtti_object();
};

#ifdef  __RTTI_OLDNAMES
// Some synonyms for folks using older standard
typedef type_info Type_info;
typedef bad_cast Bad_cast;
typedef bad_typeid Bad_typeid;
#endif  // __RTTI_OLDNAMES


#endif  // _INC_TYPEINFO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\tchar.h ===
/***
*tchar.h - definitions for generic international text functions
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Definitions for generic international functions, mostly defines
*       which map string/formatted-io/ctype functions to char, wchar_t, or
*       MBCS versions.  To be used for compatibility between single-byte,
*       multi-byte and Unicode text models.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000 /*IFSTRIP=IGN*/
#pragma once
#endif

#ifndef _INC_TCHAR
#define _INC_TCHAR

#ifdef  _MSC_VER
#pragma warning(disable:4514)       /* disable unwanted C++ /W4 warning */
/* #pragma warning(default:4514) */ /* use this to reenable, if necessary */
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  CRTDLL
#define _CRTIMP __declspec(dllexport)
#else   /* ndef CRTDLL */
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */


#define _ftcscat    _tcscat
#define _ftcschr    _tcschr
#define _ftcscpy    _tcscpy
#define _ftcscspn   _tcscspn
#define _ftcslen    _tcslen
#define _ftcsncat   _tcsncat
#define _ftcsncpy   _tcsncpy
#define _ftcspbrk   _tcspbrk
#define _ftcsrchr   _tcsrchr
#define _ftcsspn    _tcsspn
#define _ftcsstr    _tcsstr
#define _ftcstok    _tcstok

#define _ftcsdup    _tcsdup
#define _ftcsnset   _tcsnset
#define _ftcsrev    _tcsrev
#define _ftcsset    _tcsset

#define _ftcscmp      _tcscmp
#define _ftcsicmp     _tcsicmp
#define _ftcsnccmp    _tcsnccmp
#define _ftcsncmp     _tcsncmp
#define _ftcsncicmp   _tcsncicmp
#define _ftcsnicmp    _tcsnicmp

#define _ftcscoll     _tcscoll
#define _ftcsicoll    _tcsicoll
#define _ftcsnccoll   _tcsnccoll
#define _ftcsncoll    _tcsncoll
#define _ftcsncicoll  _tcsncicoll
#define _ftcsnicoll   _tcsnicoll

/* Redundant "logical-character" mappings */

#define _ftcsclen   _tcsclen
#define _ftcsnccat  _tcsnccat
#define _ftcsnccpy  _tcsnccpy
#define _ftcsncset  _tcsncset

#define _ftcsdec    _tcsdec
#define _ftcsinc    _tcsinc
#define _ftcsnbcnt  _tcsnbcnt
#define _ftcsnccnt  _tcsnccnt
#define _ftcsnextc  _tcsnextc
#define _ftcsninc   _tcsninc
#define _ftcsspnp   _tcsspnp

#define _ftcslwr    _tcslwr
#define _ftcsupr    _tcsupr

#define _ftclen     _tclen
#define _ftccpy     _tccpy
#define _ftccmp     _tccmp


#ifdef  _UNICODE

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

/* ++++++++++++++++++++ UNICODE ++++++++++++++++++++ */

#include <wchar.h>

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif

#ifndef __TCHAR_DEFINED
typedef wchar_t     _TCHAR;
typedef wchar_t     _TSCHAR;
typedef wchar_t     _TUCHAR;
typedef wchar_t     _TXCHAR;
typedef wint_t      _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef wchar_t     TCHAR;
#endif
#define _TCHAR_DEFINED
#endif

#define _TEOF       WEOF

#define __T(x)      L ## x


/* Program */

#define _tmain      wmain
#define _tWinMain   wWinMain
#define _tenviron   _wenviron
#define __targv     __wargv

/* Formatted i/o */

#define _tprintf    wprintf
#define _tcprintf   _cwprintf
#define _ftprintf   fwprintf
#define _stprintf   swprintf
#define _sctprintf  _scwprintf
#define _sntprintf  _snwprintf
#define _vtprintf   vwprintf
#define _vftprintf  vfwprintf
#define _vstprintf  vswprintf
#define _vsctprintf _vscwprintf
#define _vsntprintf _vsnwprintf
#define _tscanf     wscanf
#define _tcscanf    _cwscanf
#define _ftscanf    fwscanf
#define _stscanf    swscanf
#define _sntscanf   _snwscanf


/* Unformatted i/o */

#define _fgettc     fgetwc
#define _fgettchar  _fgetwchar
#define _fgetts     fgetws
#define _fputtc     fputwc
#define _fputtchar  _fputwchar
#define _fputts     fputws
#define _cputts     _cputws
#define _cgetts     _cgetws
#define _gettc      getwc
#define _gettch     _getwch
#define _gettche    _getwche
#define _gettchar   getwchar
#define _getts      _getws
#define _puttc      putwc
#define _puttchar   putwchar
#define _puttch     _putwch
#define _putts      _putws
#define _ungettc    ungetwc
#define _ungettch   _ungetwch


/* String conversion functions */

#define _tcstod     wcstod
#define _tcstol     wcstol
#define _tcstoul    wcstoul
#define _tcstoi64   _wcstoi64
#define _tcstoui64  _wcstoui64
#define _tstof      _wtof
#define _tstol      _wtol
#define _tstoi      _wtoi
#define _tstoi64    _wtoi64

#define _itot       _itow
#define _ltot       _ltow
#define _ultot      _ultow
#define _ttoi       _wtoi
#define _ttol       _wtol

#define _ttoi64     _wtoi64
#define _i64tot     _i64tow
#define _ui64tot    _ui64tow

/* String functions */

#define _tcscat     wcscat
#define _tcschr     wcschr
#define _tcscpy     wcscpy
#define _tcscspn    wcscspn
#define _tcslen     wcslen
#define _tcsncat    wcsncat
#define _tcsncpy    wcsncpy
#define _tcspbrk    wcspbrk
#define _tcsrchr    wcsrchr
#define _tcsspn     wcsspn
#define _tcsstr     wcsstr
#define _tcstok     wcstok
#define _tcserror   _wcserror
#define __tcserror  __wcserror

#define _tcsdup     _wcsdup
#define _tcsnset    _wcsnset
#define _tcsrev     _wcsrev
#define _tcsset     _wcsset

#define _tcscmp     wcscmp
#define _tcsicmp    _wcsicmp
#define _tcsnccmp   wcsncmp
#define _tcsncmp    wcsncmp
#define _tcsncicmp  _wcsnicmp
#define _tcsnicmp   _wcsnicmp

#define _tcscoll    wcscoll
#define _tcsicoll   _wcsicoll
#define _tcsnccoll  _wcsncoll
#define _tcsncoll   _wcsncoll
#define _tcsncicoll _wcsnicoll
#define _tcsnicoll  _wcsnicoll


/* Execute functions */

#define _texecl     _wexecl
#define _texecle    _wexecle
#define _texeclp    _wexeclp
#define _texeclpe   _wexeclpe
#define _texecv     _wexecv
#define _texecve    _wexecve
#define _texecvp    _wexecvp
#define _texecvpe   _wexecvpe

#define _tspawnl    _wspawnl
#define _tspawnle   _wspawnle
#define _tspawnlp   _wspawnlp
#define _tspawnlpe  _wspawnlpe
#define _tspawnv    _wspawnv
#define _tspawnve   _wspawnve
#define _tspawnvp   _wspawnvp
#define _tspawnvp   _wspawnvp
#define _tspawnvpe  _wspawnvpe

#define _tsystem    _wsystem


/* Time functions */

#define _tasctime   _wasctime
#define _tctime     _wctime
#define _tctime64   _wctime64
#define _tstrdate   _wstrdate
#define _tstrtime   _wstrtime
#define _tutime     _wutime
#define _tutime64   _wutime64
#define _tcsftime   wcsftime


/* Directory functions */

#define _tchdir     _wchdir
#define _tgetcwd    _wgetcwd
#define _tgetdcwd   _wgetdcwd
#define _tmkdir     _wmkdir
#define _trmdir     _wrmdir


/* Environment/Path functions */

#define _tfullpath  _wfullpath
#define _tgetenv    _wgetenv
#define _tmakepath  _wmakepath
#define _tpgmptr    _wpgmptr
#define _tputenv    _wputenv
#define _tsearchenv _wsearchenv
#define _tsplitpath _wsplitpath


/* Stdio functions */

#define _tfdopen    _wfdopen
#define _tfsopen    _wfsopen
#define _tfopen     _wfopen
#define _tfreopen   _wfreopen
#define _tperror    _wperror
#define _tpopen     _wpopen
#define _ttempnam   _wtempnam
#define _ttmpnam    _wtmpnam


/* Io functions */

#define _taccess    _waccess
#define _tchmod     _wchmod
#define _tcreat     _wcreat
#define _tfindfirst _wfindfirst
#define _tfindfirst64   _wfindfirst64
#define _tfindfirsti64  _wfindfirsti64
#define _tfindnext  _wfindnext
#define _tfindnext64    _wfindnext64
#define _tfindnexti64   _wfindnexti64
#define _tmktemp    _wmktemp
#define _topen      _wopen
#define _tremove    _wremove
#define _trename    _wrename
#define _tsopen     _wsopen
#define _tunlink    _wunlink

#define _tfinddata_t    _wfinddata_t
#define _tfinddata64_t  __wfinddata64_t
#define _tfinddatai64_t _wfinddatai64_t


/* Stat functions */

#define _tstat      _wstat
#define _tstat64    _wstat64
#define _tstati64   _wstati64


/* Setlocale functions */

#define _tsetlocale _wsetlocale


/* Redundant "logical-character" mappings */

#define _tcsclen    wcslen
#define _tcsnccat   wcsncat
#define _tcsnccpy   wcsncpy
#define _tcsncset   _wcsnset

#define _tcsdec     _wcsdec
#define _tcsinc     _wcsinc
#define _tcsnbcnt   _wcsncnt
#define _tcsnccnt   _wcsncnt
#define _tcsnextc   _wcsnextc
#define _tcsninc    _wcsninc
#define _tcsspnp    _wcsspnp

#define _tcslwr     _wcslwr
#define _tcsupr     _wcsupr
#define _tcsxfrm    wcsxfrm


#if     __STDC__ || defined(_NO_INLINING)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) ((*(_pc1) = *(_cpc2)))
#define _tccmp(_cpc1,_cpc2) ((*(_cpc1))-(*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _tclen(const wchar_t *_cpc) { return (_cpc,1); }
__inline void __cdecl _tccpy(wchar_t *_pc1, const wchar_t *_cpc2) { *_pc1 = (wchar_t)*_cpc2; }
__inline int __cdecl _tccmp(const wchar_t *_cpc1, const wchar_t *_cpc2) { return (int) ((*_cpc1)-(*_cpc2)); }
#endif  /* __STDC__ */


/* ctype functions */

#define _istalnum   iswalnum
#define _istalpha   iswalpha
#define _istascii   iswascii
#define _istcntrl   iswcntrl
#define _istdigit   iswdigit
#define _istgraph   iswgraph
#define _istlower   iswlower
#define _istprint   iswprint
#define _istpunct   iswpunct
#define _istspace   iswspace
#define _istupper   iswupper
#define _istxdigit  iswxdigit

#define _totupper   towupper
#define _totlower   towlower

#define _istlegal(_c)   (1)
#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)


#if     __STDC__ || defined(_NO_INLINING)
#define _wcsdec(_cpc1, _cpc2) ((_cpc1)>=(_cpc2) ? NULL : (_cpc2)-1)
#define _wcsinc(_pc)    ((_pc)+1)
#define _wcsnextc(_cpc) ((unsigned int) *(_cpc))
#define _wcsninc(_pc, _sz) (((_pc)+(_sz)))
#define _wcsncnt(_cpc, _sz) ((wcslen(_cpc)>_sz) ? _sz : wcslen(_cpc))
#define _wcsspnp(_cpc1, _cpc2) ((*((_cpc1)+wcsspn(_cpc1,_cpc2))) ? ((_cpc1)+wcsspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline wchar_t * __cdecl _wcsdec(const wchar_t * _cpc1, const wchar_t * _cpc2) { return (wchar_t *)((_cpc1)>=(_cpc2) ? NULL : ((_cpc2)-1)); }
__inline wchar_t * __cdecl _wcsinc(const wchar_t * _pc) { return (wchar_t *)(_pc+1); }
__inline unsigned int __cdecl _wcsnextc(const wchar_t * _cpc) { return (unsigned int)*_cpc; }
__inline wchar_t * __cdecl _wcsninc(const wchar_t * _pc, size_t _sz) { return (wchar_t *)(_pc+_sz); }
__inline size_t __cdecl _wcsncnt( const wchar_t * _cpc, size_t _sz) { size_t len; len = wcslen(_cpc); return (len>_sz) ? _sz : len; }
__inline wchar_t * __cdecl _wcsspnp( const wchar_t * _cpc1, const wchar_t * _cpc2) { return (*(_cpc1 += wcsspn(_cpc1,_cpc2))!='\0') ? (wchar_t*)_cpc1 : NULL; }
#endif  /* __STDC__ */


#else   /* ndef _UNICODE */

/* ++++++++++++++++++++ SBCS and MBCS ++++++++++++++++++++ */

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#include <string.h>

#ifdef  __cplusplus
extern "C" {
#endif


#define _TEOF       EOF

#define __T(x)      x


/* Program */

#define _tmain      main
#define _tWinMain   WinMain
#ifdef  _POSIX_
#define _tenviron   environ
#else
#define _tenviron  _environ
#endif
#define __targv     __argv


/* Formatted i/o */

#define _tprintf    printf
#define _tcprintf   _cprintf
#define _ftprintf   fprintf
#define _stprintf   sprintf
#define _sctprintf  _scprintf
#define _sntprintf  _snprintf
#define _vtprintf   vprintf
#define _vftprintf  vfprintf
#define _vstprintf  vsprintf
#define _vsctprintf _vscprintf
#define _vsntprintf _vsnprintf
#define _tscanf     scanf
#define _tcscanf    _cscanf
#define _ftscanf    fscanf
#define _stscanf    sscanf
#define _sntscanf   _snscanf


/* Unformatted i/o */

#define _fgettc     fgetc
#define _fgettchar  _fgetchar
#define _fgetts     fgets
#define _fputtc     fputc
#define _fputtchar  _fputchar
#define _fputts     fputs
#define _cputts     _cputs
#define _gettc      getc
#define _gettch     _getch
#define _gettche    _getche
#define _gettchar   getchar
#define _getts      gets
#define _cgetts     _cgets
#define _puttc      putc
#define _puttchar   putchar
#define _puttch     _putch
#define _putts      puts
#define _ungettc    ungetc
#define _ungettch   _ungetch


/* String conversion functions */

#define _tcstod     strtod
#define _tcstol     strtol
#define _tcstoul    strtoul
#define _tstof      atof
#define _tstol      atol
#define _tstoi      atoi
#define _tstoi64    _atoi64

#define _itot       _itoa
#define _ltot       _ltoa
#define _ultot      _ultoa
#define _ttoi       atoi
#define _ttol       atol

#define _ttoi64     _atoi64
#define _tcstoi64   _strtoi64
#define _tcstoui64  _strtoui64
#define _i64tot     _i64toa
#define _ui64tot    _ui64toa

/* String functions */

/* Note that _mbscat, _mbscpy and _mbsdup are functionally equivalent to 
   strcat, strcpy and strdup, respectively. */

#define _tcscat     strcat
#define _tcscpy     strcpy
#define _tcsdup     _strdup

#define _tcslen     strlen
#define _tcsxfrm    strxfrm
#define _tcserror   strerror
#define __tcserror  _strerror


/* Execute functions */

#define _texecl     _execl
#define _texecle    _execle
#define _texeclp    _execlp
#define _texeclpe   _execlpe
#define _texecv     _execv
#define _texecve    _execve
#define _texecvp    _execvp
#define _texecvpe   _execvpe

#define _tspawnl    _spawnl
#define _tspawnle   _spawnle
#define _tspawnlp   _spawnlp
#define _tspawnlpe  _spawnlpe
#define _tspawnv    _spawnv
#define _tspawnve   _spawnve
#define _tspawnvp   _spawnvp
#define _tspawnvpe  _spawnvpe

#define _tsystem    system


/* Time functions */

#define _tasctime   asctime
#define _tctime     ctime
#define _tctime64   _ctime64
#define _tstrdate   _strdate
#define _tstrtime   _strtime
#define _tutime     _utime
#define _tutime64   _utime64
#define _tcsftime   strftime


/* Directory functions */

#define _tchdir     _chdir
#define _tgetcwd    _getcwd
#define _tgetdcwd   _getdcwd
#define _tmkdir     _mkdir
#define _trmdir     _rmdir


/* Environment/Path functions */

#define _tfullpath  _fullpath
#define _tgetenv    getenv
#define _tmakepath  _makepath
#define _tpgmptr    _pgmptr
#define _tputenv    _putenv
#define _tsearchenv _searchenv
#define _tsplitpath _splitpath


/* Stdio functions */

#ifdef  _POSIX_
#define _tfdopen    fdopen
#else
#define _tfdopen    _fdopen
#endif
#define _tfsopen    _fsopen
#define _tfopen     fopen
#define _tfreopen   freopen
#define _tperror    perror
#define _tpopen     _popen
#define _ttempnam   _tempnam
#define _ttmpnam    tmpnam


/* Io functions */

#define _tchmod     _chmod
#define _tcreat     _creat
#define _tfindfirst _findfirst
#define _tfindfirst64   _findfirst64
#define _tfindfirsti64  _findfirsti64
#define _tfindnext  _findnext
#define _tfindnext64    _findnext64
#define _tfindnexti64   _findnexti64
#define _tmktemp    _mktemp

#ifdef  _POSIX_
#define _topen      open
#define _taccess    access
#else
#define _topen      _open
#define _taccess    _access
#endif

#define _tremove    remove
#define _trename    rename
#define _tsopen     _sopen
#define _tunlink    _unlink

#define _tfinddata_t    _finddata_t
#define _tfinddata64_t  __finddata64_t
#define _tfinddatai64_t _finddatai64_t


/* ctype functions */

#define _istascii   isascii
#define _istcntrl   iscntrl
#define _istxdigit  isxdigit


/* Stat functions */

#define _tstat      _stat
#define _tstat64    _stat64
#define _tstati64   _stati64


/* Setlocale functions */

#define _tsetlocale setlocale


#ifdef  _MBCS

/* ++++++++++++++++++++ MBCS ++++++++++++++++++++ */

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#include <mbstring.h>

#ifdef  __cplusplus
extern "C" {
#endif


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef unsigned char   _TXCHAR;
typedef unsigned int    _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


#ifdef  _MB_MAP_DIRECT

/* use mb functions directly - types must match */

/* String functions */

#define _tcschr     _mbschr
#define _tcscspn    _mbscspn
#define _tcsncat    _mbsnbcat
#define _tcsncpy    _mbsnbcpy
#define _tcspbrk    _mbspbrk
#define _tcsrchr    _mbsrchr
#define _tcsspn     _mbsspn
#define _tcsstr     _mbsstr
#define _tcstok     _mbstok

#define _tcsnset    _mbsnbset
#define _tcsrev     _mbsrev
#define _tcsset     _mbsset

#define _tcscmp     _mbscmp
#define _tcsicmp    _mbsicmp
#define _tcsnccmp   _mbsncmp
#define _tcsncmp    _mbsnbcmp
#define _tcsncicmp  _mbsnicmp
#define _tcsnicmp   _mbsnbicmp

#define _tcscoll    _mbscoll
#define _tcsicoll   _mbsicoll
#define _tcsnccoll  _mbsncoll
#define _tcsncoll   _mbsnbcoll
#define _tcsncicoll _mbsnicoll
#define _tcsnicoll  _mbsnbicoll


/* "logical-character" mappings */

#define _tcsclen    _mbslen
#define _tcsnccat   _mbsncat
#define _tcsnccpy   _mbsncpy
#define _tcsncset   _mbsnset


/* MBCS-specific mappings */

#define _tcsdec     _mbsdec
#define _tcsinc     _mbsinc
#define _tcsnbcnt   _mbsnbcnt
#define _tcsnccnt   _mbsnccnt
#define _tcsnextc   _mbsnextc
#define _tcsninc    _mbsninc
#define _tcsspnp    _mbsspnp

#define _tcslwr     _mbslwr
#define _tcsupr     _mbsupr

#define _tclen      _mbclen
#define _tccpy      _mbccpy

#define _tccmp(_cpuc1,_cpuc2)   _tcsnccmp(_cpuc1,_cpuc2,1)


#else /* _MB_MAP_DIRECT */

#if     __STDC__ || defined(_NO_INLINING)

/* use type-safe linked-in function thunks */

/* String functions */

_CRTIMP char * __cdecl _tcschr(const char *, unsigned int);
_CRTIMP size_t __cdecl _tcscspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsncat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcspbrk(const char *, const char *);
_CRTIMP char * __cdecl _tcsrchr(const char *, int);
_CRTIMP size_t __cdecl _tcsspn(const char *, const char *);
_CRTIMP char * __cdecl _tcsstr(const char *, const char *);
_CRTIMP char * __cdecl _tcstok(char *, const char *);

_CRTIMP char * __cdecl _tcsnset(char *, unsigned int, size_t);
_CRTIMP char * __cdecl _tcsrev(char *);
_CRTIMP char * __cdecl _tcsset(char *, unsigned int);

_CRTIMP int __cdecl _tcscmp(const char *, const char *);
_CRTIMP int __cdecl _tcsicmp(const char *, const char *);
_CRTIMP int __cdecl _tcsnccmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicmp(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnicmp(const char *, const char *, size_t);

_CRTIMP int __cdecl _tcscoll(const char *, const char *);
_CRTIMP int __cdecl _tcsicoll(const char *, const char *);
_CRTIMP int __cdecl _tcsnccoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsncicoll(const char *, const char *, size_t);
_CRTIMP int __cdecl _tcsnicoll(const char *, const char *, size_t);


/* "logical-character" mappings */

_CRTIMP size_t __cdecl _tcsclen(const char *);
_CRTIMP char * __cdecl _tcsnccat(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsnccpy(char *, const char *, size_t);
_CRTIMP char * __cdecl _tcsncset(char *, unsigned int, size_t);


/* MBCS-specific mappings */

_CRTIMP char * __cdecl _tcsdec(const char *, const char *);
_CRTIMP char * __cdecl _tcsinc(const char *);
_CRTIMP size_t __cdecl _tcsnbcnt(const char *, size_t);
_CRTIMP size_t __cdecl _tcsnccnt(const char *, size_t);
_CRTIMP unsigned int __cdecl _tcsnextc (const char *);
_CRTIMP char * __cdecl _tcsninc(const char *, size_t);
_CRTIMP char * __cdecl _tcsspnp(const char *, const char *);

_CRTIMP char * __cdecl _tcslwr(char *);
_CRTIMP char * __cdecl _tcsupr(char *);

_CRTIMP size_t __cdecl _tclen(const char *);
_CRTIMP void __cdecl _tccpy(char *, const char *);


#else   /* __STDC__ */

/* the default: use type-safe inline function thunks */

#define _PUC    unsigned char *
#define _CPUC   const unsigned char *
#define _PC     char *
#define _CPC    const char *
#define _UI     unsigned int


/* String functions */

__inline _PC _tcschr(_CPC _s1,_UI _c) {return (_PC)_mbschr((_CPUC)_s1,_c);}
__inline size_t _tcscspn(_CPC _s1,_CPC _s2) {return _mbscspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsncat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsnbcpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcspbrk(_CPC _s1,_CPC _s2) {return (_PC)_mbspbrk((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsrchr(_CPC _s1,_UI _c) {return (_PC)_mbsrchr((_CPUC)_s1,_c);}
__inline size_t _tcsspn(_CPC _s1,_CPC _s2) {return _mbsspn((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsstr(_CPC _s1,_CPC _s2) {return (_PC)_mbsstr((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcstok(_PC _s1,_CPC _s2) {return (_PC)_mbstok((_PUC)_s1,(_CPUC)_s2);}

__inline _PC _tcsnset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnbset((_PUC)_s1,_c,_n);}
__inline _PC _tcsrev(_PC _s1) {return (_PC)_mbsrev((_PUC)_s1);}
__inline _PC _tcsset(_PC _s1,_UI _c) {return (_PC)_mbsset((_PUC)_s1,_c);}

__inline int _tcscmp(_CPC _s1,_CPC _s2) {return _mbscmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsicmp(_CPC _s1,_CPC _s2) {return _mbsicmp((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnccmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicmp((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnicmp(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicmp((_CPUC)_s1,(_CPUC)_s2,_n);}

__inline int _tcscoll(_CPC _s1,_CPC _s2) {return _mbscoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsicoll(_CPC _s1,_CPC _s2) {return _mbsicoll((_CPUC)_s1,(_CPUC)_s2);}
__inline int _tcsnccoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsncoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbcoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsncicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnicoll((_CPUC)_s1,(_CPUC)_s2,_n);}
__inline int _tcsnicoll(_CPC _s1,_CPC _s2,size_t _n) {return _mbsnbicoll((_CPUC)_s1,(_CPUC)_s2,_n);}


/* "logical-character" mappings */

__inline size_t _tcsclen(_CPC _s1) {return _mbslen((_CPUC)_s1);}
__inline _PC _tcsnccat(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncat((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsnccpy(_PC _s1,_CPC _s2,size_t _n) {return (_PC)_mbsncpy((_PUC)_s1,(_CPUC)_s2,_n);}
__inline _PC _tcsncset(_PC _s1,_UI _c,size_t _n) {return (_PC)_mbsnset((_PUC)_s1,_c,_n);}


/* MBCS-specific mappings */

__inline _PC _tcsdec(_CPC _s1,_CPC _s2) {return (_PC)_mbsdec((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcsinc(_CPC _s1) {return (_PC)_mbsinc((_CPUC)_s1);}
__inline size_t _tcsnbcnt(_CPC _s1,size_t _n) {return _mbsnbcnt((_CPUC)_s1,_n);}
__inline size_t _tcsnccnt(_CPC _s1,size_t _n) {return _mbsnccnt((_CPUC)_s1,_n);}
__inline _PC _tcsninc(_CPC _s1,size_t _n) {return (_PC)_mbsninc((_CPUC)_s1,_n);}
__inline _PC _tcsspnp(_CPC _s1,_CPC _s2) {return (_PC)_mbsspnp((_CPUC)_s1,(_CPUC)_s2);}
__inline _PC _tcslwr(_PC _s1) {return (_PC)_mbslwr((_PUC)_s1);}
__inline _PC _tcsupr(_PC _s1) {return (_PC)_mbsupr((_PUC)_s1);}

__inline size_t _tclen(_CPC _s1) {return _mbclen((_CPUC)_s1);}
__inline void _tccpy(_PC _s1,_CPC _s2) {_mbccpy((_PUC)_s1,(_CPUC)_s2); return;}


/* inline helper */
__inline _UI _tcsnextc(_CPC _s1) {_UI _n=0; if (_ismbblead((_UI)*(_PUC)_s1)) {_n=((_UI)*(_PUC)_s1)<<8; _s1++;} _n+=(_UI)*(_PUC)_s1; return(_n);}


#endif  /* __STDC__ */

#endif  /* _MB_MAP_DIRECT */


/* MBCS-specific mappings */

#define _tccmp(_cp1,_cp2)   _tcsnccmp(_cp1,_cp2,1)


/* ctype functions */

#define _istalnum   _ismbcalnum
#define _istalpha   _ismbcalpha
#define _istdigit   _ismbcdigit
#define _istgraph   _ismbcgraph
#define _istlegal   _ismbclegal
#define _istlower   _ismbclower
#define _istprint   _ismbcprint
#define _istpunct   _ismbcpunct
#define _istspace   _ismbcspace
#define _istupper   _ismbcupper

#define _totupper   _mbctoupper
#define _totlower   _mbctolower

#define _istlead    _ismbblead
#define _istleadbyte    isleadbyte

#else   /* !_MBCS */

/* ++++++++++++++++++++ SBCS ++++++++++++++++++++ */


#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef char            _TXCHAR;
typedef int             _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if     !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


/* String functions */

#define _tcschr     strchr
#define _tcscspn    strcspn
#define _tcsncat    strncat
#define _tcsncpy    strncpy
#define _tcspbrk    strpbrk
#define _tcsrchr    strrchr
#define _tcsspn     strspn
#define _tcsstr     strstr
#define _tcstok     strtok

#define _tcsnset    _strnset
#define _tcsrev     _strrev
#define _tcsset     _strset

#define _tcscmp     strcmp
#define _tcsicmp    _stricmp
#define _tcsnccmp   strncmp
#define _tcsncmp    strncmp
#define _tcsncicmp  _strnicmp
#define _tcsnicmp   _strnicmp

#define _tcscoll    strcoll
#define _tcsicoll   _stricoll
#define _tcsnccoll  _strncoll
#define _tcsncoll   _strncoll
#define _tcsncicoll _strnicoll
#define _tcsnicoll  _strnicoll


/* "logical-character" mappings */

#define _tcsclen    strlen
#define _tcsnccat   strncat
#define _tcsnccpy   strncpy
#define _tcsncset   _strnset


/* MBCS-specific functions */

#define _tcsdec     _strdec
#define _tcsinc     _strinc
#define _tcsnbcnt   _strncnt
#define _tcsnccnt   _strncnt
#define _tcsnextc   _strnextc
#define _tcsninc    _strninc
#define _tcsspnp    _strspnp

#define _tcslwr     _strlwr
#define _tcsupr     _strupr
#define _tcsxfrm    strxfrm

#define _istlead(_c)    (0)
#define _istleadbyte(_c)    (0)

#if     __STDC__ || defined(_NO_INLINING)
#define _tclen(_pc) (1)
#define _tccpy(_pc1,_cpc2) (*(_pc1) = *(_cpc2))
#define _tccmp(_cpc1,_cpc2) (((unsigned char)*(_cpc1))-((unsigned char)*(_cpc2)))
#else   /* __STDC__ */
__inline size_t __cdecl _tclen(const char *_cpc) { return (_cpc,1); }
__inline void __cdecl _tccpy(char *_pc1, const char *_cpc2) { *_pc1 = *_cpc2; }
__inline int __cdecl _tccmp(const char *_cpc1, const char *_cpc2) { return (int) (((unsigned char)*_cpc1)-((unsigned char)*_cpc2)); }
#endif  /* __STDC__ */


/* ctype-functions */

#define _istalnum   isalnum
#define _istalpha   isalpha
#define _istdigit   isdigit
#define _istgraph   isgraph
#define _istlower   islower
#define _istprint   isprint
#define _istpunct   ispunct
#define _istspace   isspace
#define _istupper   isupper

#define _totupper   toupper
#define _totlower   tolower

#define _istlegal(_c)   (1)


/* the following is optional if functional versions are available */

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#if     __STDC__ || defined(_NO_INLINING)
#define _strdec(_cpc1, _cpc2) ((_cpc1)>=(_cpc2) ? NULL : (_cpc2)-1)
#define _strinc(_pc)    ((_pc)+1)
#define _strnextc(_cpc) ((unsigned int) *(const unsigned char *)(_cpc))
#define _strninc(_pc, _sz) (((_pc)+(_sz)))
#define _strncnt(_cpc, _sz) ((strlen(_cpc)>_sz) ? _sz : strlen(_cpc))
#define _strspnp(_cpc1, _cpc2) ((*((_cpc1)+strspn(_cpc1,_cpc2))) ? ((_cpc1)+strspn(_cpc1,_cpc2)) : NULL)
#else   /* __STDC__ */
__inline char * __cdecl _strdec(const char * _cpc1, const char * _cpc2) { return (char *)((_cpc1)>=(_cpc2) ? NULL : (_cpc2-1)); }
__inline char * __cdecl _strinc(const char * _pc) { return (char *)(_pc+1); }
__inline unsigned int __cdecl _strnextc(const char * _cpc) { return (unsigned int)*(const unsigned char *)_cpc; }
__inline char * __cdecl _strninc(const char * _pc, size_t _sz) { return (char *)(_pc+_sz); }
__inline size_t __cdecl _strncnt( const char * _cpc, size_t _sz) { size_t len; len = strlen(_cpc); return (len>_sz) ? _sz : len; }
__inline char * __cdecl _strspnp( const char * _cpc1, const char * _cpc2) { return (*(_cpc1 += strspn(_cpc1,_cpc2))!='\0') ? (char*)_cpc1 : NULL; }
#endif  /* __STDC__ */


#endif  /* _MBCS */

#endif  /* _UNICODE */


/* Generic text macros to be used with string literals and character constants.
   Will also allow symbolic constants that resolve to same. */

#define _T(x)       __T(x)
#define _TEXT(x)    __T(x)


#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#endif  /* _INC_TCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structures, values, macros, and functions
*       used by the level 2 I/O ("standard I/O") routines.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDIO
#define _INC_STDIO

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
typedef char *  va_list;
#define _VA_LIST_DEFINED
#endif


/* Buffered I/O macros */

#define BUFSIZ  512


/*
 * Default number of supported streams. _NFILE is confusing and obsolete, but
 * supported anyway for backwards compatibility.
 */
#define _NFILE      _NSTREAM_

#define _NSTREAM_   512

/*
 * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be
 * greater than or equal to _IOB_ENTRIES.
 */
#define _IOB_ENTRIES 20

#define EOF     (-1)


#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif


/* Directory where temporary files may be created. */

#ifdef  _POSIX_
#define _P_tmpdir   "/"
#define _wP_tmpdir  L"/"
#else
#define _P_tmpdir   "\\"
#define _wP_tmpdir  L"\\"
#endif

/* L_tmpnam = length of string _P_tmpdir
 *            + 1 if _P_tmpdir does not end in "/" or "\", else 0
 *            + 12 (for the filename string)
 *            + 1 (for the null terminator)
 */
#define L_tmpnam sizeof(_P_tmpdir)+12


#ifdef  _POSIX_
#define L_ctermid   9
#define L_cuserid   32
#endif


/* Seek method constants */

#define SEEK_CUR    1
#define SEEK_END    2
#define SEEK_SET    0


#define FILENAME_MAX    260
#define FOPEN_MAX       20
#define _SYS_OPEN       20
#define TMP_MAX         32767


/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
_CRTIMP extern FILE _iob[];
#endif  /* _STDIO_DEFINED */


/* Define file position type */

#ifndef _FPOS_T_DEFINED
#undef _FPOSOFF

#if     defined (_POSIX_)
typedef long fpos_t;
#define _FPOSOFF(fp) ((long)(fp))
#else   /* _POSIX_ */

#if     !__STDC__ && _INTEGRAL_MAX_BITS >= 64
typedef __int64 fpos_t;
#define _FPOSOFF(fp) ((long)(fp))
#else
typedef struct fpos_t {
        unsigned int lopart;
        int          hipart;
        } fpos_t;
#define _FPOSOFF(fp) ((long)(fp).lopart)
#endif
#endif  /* _POSIX_ */

#define _FPOS_T_DEFINED
#endif


#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])


#define _IOREAD         0x0001
#define _IOWRT          0x0002

#define _IOFBF          0x0000
#define _IOLBF          0x0040
#define _IONBF          0x0004

#define _IOMYBUF        0x0008
#define _IOEOF          0x0010
#define _IOERR          0x0020
#define _IOSTRG         0x0040
#define _IORW           0x0080
#ifdef  _POSIX_
#define _IOAPPEND       0x0200
#endif


/* Function prototypes */

#ifndef _STDIO_DEFINED

_CRTIMP int __cdecl _filbuf(FILE *);
_CRTIMP int __cdecl _flsbuf(int, FILE *);

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *);
#else
_CRTIMP FILE * __cdecl _fsopen(const char *, const char *, int);
#endif

_CRTIMP void __cdecl clearerr(FILE *);
_CRTIMP int __cdecl fclose(FILE *);
_CRTIMP int __cdecl _fcloseall(void);

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl fdopen(int, const char *);
#else
_CRTIMP FILE * __cdecl _fdopen(int, const char *);
#endif

_CRTIMP int __cdecl feof(FILE *);
_CRTIMP int __cdecl ferror(FILE *);
_CRTIMP int __cdecl fflush(FILE *);
_CRTIMP int __cdecl fgetc(FILE *);
_CRTIMP int __cdecl _fgetchar(void);
_CRTIMP int __cdecl fgetpos(FILE *, fpos_t *);
_CRTIMP char * __cdecl fgets(char *, int, FILE *);

#ifdef  _POSIX_
_CRTIMP int __cdecl fileno(FILE *);
#else
_CRTIMP int __cdecl _fileno(FILE *);
#endif

_CRTIMP int __cdecl _flushall(void);
_CRTIMP FILE * __cdecl fopen(const char *, const char *);
_CRTIMP int __cdecl fprintf(FILE *, const char *, ...);
_CRTIMP int __cdecl fputc(int, FILE *);
_CRTIMP int __cdecl _fputchar(int);
_CRTIMP int __cdecl fputs(const char *, FILE *);
_CRTIMP size_t __cdecl fread(void *, size_t, size_t, FILE *);
_CRTIMP FILE * __cdecl freopen(const char *, const char *, FILE *);
_CRTIMP int __cdecl fscanf(FILE *, const char *, ...);
_CRTIMP int __cdecl fsetpos(FILE *, const fpos_t *);
_CRTIMP int __cdecl fseek(FILE *, long, int);
_CRTIMP long __cdecl ftell(FILE *);
_CRTIMP size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
_CRTIMP int __cdecl getc(FILE *);
_CRTIMP int __cdecl getchar(void);
_CRTIMP int __cdecl _getmaxstdio(void);
_CRTIMP char * __cdecl gets(char *);
_CRTIMP int __cdecl _getw(FILE *);
_CRTIMP void __cdecl perror(const char *);
_CRTIMP int __cdecl _pclose(FILE *);
_CRTIMP FILE * __cdecl _popen(const char *, const char *);
_CRTIMP int __cdecl printf(const char *, ...);
_CRTIMP int __cdecl putc(int, FILE *);
_CRTIMP int __cdecl putchar(int);
_CRTIMP int __cdecl puts(const char *);
_CRTIMP int __cdecl _putw(int, FILE *);
_CRTIMP int __cdecl remove(const char *);
_CRTIMP int __cdecl rename(const char *, const char *);
_CRTIMP void __cdecl rewind(FILE *);
_CRTIMP int __cdecl _rmtmp(void);
_CRTIMP int __cdecl scanf(const char *, ...);
_CRTIMP void __cdecl setbuf(FILE *, char *);
_CRTIMP int __cdecl _setmaxstdio(int);
_CRTIMP int __cdecl setvbuf(FILE *, char *, int, size_t);
_CRTIMP int __cdecl _snprintf(char *, size_t, const char *, ...);
_CRTIMP int __cdecl sprintf(char *, const char *, ...);
_CRTIMP int __cdecl _scprintf(const char *, ...);
_CRTIMP int __cdecl sscanf(const char *, const char *, ...);
_CRTIMP int __cdecl _snscanf(const char *, size_t, const char *, ...);
_CRTIMP char * __cdecl _tempnam(const char *, const char *);
_CRTIMP FILE * __cdecl tmpfile(void);
_CRTIMP char * __cdecl tmpnam(char *);
_CRTIMP int __cdecl ungetc(int, FILE *);
_CRTIMP int __cdecl _unlink(const char *);
_CRTIMP int __cdecl vfprintf(FILE *, const char *, va_list);
_CRTIMP int __cdecl vprintf(const char *, va_list);
_CRTIMP int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
_CRTIMP int __cdecl vsprintf(char *, const char *, va_list);
_CRTIMP int __cdecl _vscprintf(const char *, va_list);

#ifndef _WSTDIO_DEFINED

/* wide function prototypes, also declared in wchar.h  */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wchar_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wchar_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);

_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);

_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _scwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl _vscwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _snwscanf(const wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#define getwchar()              fgetwc(stdin)
#define putwchar(_c)            fputwc((_c),stdout)
#define getwc(_stm)             fgetwc(_stm)
#define putwc(_c,_stm)          fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif  /* _WSTDIO_DEFINED */

#define _STDIO_DEFINED
#endif  /* _STDIO_DEFINED */


/* Macro definitions */

#define feof(_stream)     ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((_stream)->_file)
#define getc(_stream)     (--(_stream)->_cnt >= 0 \
                ? 0xff & *(_stream)->_ptr++ : _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
                ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#define getchar()         getc(stdin)
#define putchar(_c)       putc((_c),stdout)



#ifdef  _MT
#undef  getc
#undef  putc
#undef  getchar
#undef  putchar
#endif



#if     !__STDC__ && !defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

_CRTIMP int __cdecl fcloseall(void);
_CRTIMP FILE * __cdecl fdopen(int, const char *);
_CRTIMP int __cdecl fgetchar(void);
_CRTIMP int __cdecl fileno(FILE *);
_CRTIMP int __cdecl flushall(void);
_CRTIMP int __cdecl fputchar(int);
_CRTIMP int __cdecl getw(FILE *);
_CRTIMP int __cdecl putw(int, FILE *);
_CRTIMP int __cdecl rmtmp(void);
_CRTIMP char * __cdecl tempnam(const char *, const char *);
_CRTIMP int __cdecl unlink(const char *);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STDIO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the modeflag values for spawnxx calls.
*       Also contains the function argument declarations for all
*       process control related routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_PROCESS
#define _INC_PROCESS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef _POSIX_

#ifdef __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* modeflag values for _spawnxx routines */

#define _P_WAIT         0
#define _P_NOWAIT       1
#define _OLD_P_OVERLAY  2
#define _P_NOWAITO      3
#define _P_DETACH       4

#ifdef  _MT
#define _P_OVERLAY      2
#else
extern int _p_overlay;
#define _P_OVERLAY      _p_overlay
#endif  /* _MT */

/* Action codes for _cwait(). The action code argument to _cwait is ignored
   on Win32 though it is accepted for compatibilty with old MS CRT libs */
#define _WAIT_CHILD      0
#define _WAIT_GRANDCHILD 1


/* function prototypes */

#ifdef  _MT
_CRTIMP uintptr_t __cdecl _beginthread (void (__cdecl *) (void *),
        unsigned, void *);
_CRTIMP void __cdecl _endthread(void);
_CRTIMP uintptr_t __cdecl _beginthreadex(void *, unsigned,
        unsigned (__stdcall *) (void *), void *, unsigned, unsigned *);
_CRTIMP void __cdecl _endthreadex(unsigned);
#endif

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl abort(void);
_CRTIMP __declspec(noreturn) void __cdecl exit(int);
_CRTIMP __declspec(noreturn) void __cdecl _exit(int);
#else
_CRTIMP void __cdecl abort(void);
_CRTIMP void __cdecl exit(int);
_CRTIMP void __cdecl _exit(int);
#endif
_CRTIMP void __cdecl _cexit(void);
_CRTIMP void __cdecl _c_exit(void);
_CRTIMP int __cdecl _getpid(void);

_CRTIMP intptr_t __cdecl _cwait(int *, intptr_t, int);
_CRTIMP intptr_t __cdecl _execl(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execle(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execlp(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execlpe(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _execv(const char *, const char * const *);
_CRTIMP intptr_t __cdecl _execve(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl _execvp(const char *, const char * const *);
_CRTIMP intptr_t __cdecl _execvpe(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnl(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnle(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnlp(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnlpe(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl _spawnv(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP intptr_t __cdecl _spawnvp(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl _spawnvpe(int, const char *, const char * const *,
        const char * const *);
_CRTIMP int __cdecl system(const char *);

#ifndef _WPROCESS_DEFINED
/* wide function prototypes, also declared in wchar.h  */
_CRTIMP intptr_t __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/*
 * The Win32 API LoadLibrary, FreeLibrary and GetProcAddress should be used
 * instead.
 */
intptr_t __cdecl _loaddll(char *);
int __cdecl _unloaddll(intptr_t);
int (__cdecl * __cdecl _getdllprocaddr(intptr_t, char *, intptr_t))();
/* --------- The preceding functions are OBSOLETE --------- */


#ifdef  _DECL_DLLMAIN
/*
 * Declare DLL notification (initialization/termination) routines
 *      The preferred method is for the user to provide DllMain() which will
 *      be called automatically by the DLL entry point defined by the C run-
 *      time library code.  If the user wants to define the DLL entry point
 *      routine, the user's entry point must call _CRT_INIT on all types of
 *      notifications, as the very first thing on attach notifications and
 *      as the very last thing on detach notifications.
 */
#ifdef  _WINDOWS_       /* Use types from WINDOWS.H */
BOOL WINAPI DllMain(HANDLE, DWORD, LPVOID);
BOOL WINAPI _CRT_INIT(HANDLE, DWORD, LPVOID);
BOOL WINAPI _wCRT_INIT(HANDLE, DWORD, LPVOID);
extern BOOL (WINAPI *_pRawDllMain)(HANDLE, DWORD, LPVOID);
#else
int __stdcall DllMain(void *, unsigned, void *);
int __stdcall _CRT_INIT(void *, unsigned, void *);
int __stdcall _wCRT_INIT(void *, unsigned, void *);
extern int (__stdcall *_pRawDllMain)(void *, unsigned, void *);
#endif  /* _WINDOWS_ */
#endif

#if     !__STDC__

/* Non-ANSI names for compatibility */

#define P_WAIT          _P_WAIT
#define P_NOWAIT        _P_NOWAIT
#define P_OVERLAY       _P_OVERLAY
#define OLD_P_OVERLAY   _OLD_P_OVERLAY
#define P_NOWAITO       _P_NOWAITO
#define P_DETACH        _P_DETACH
#define WAIT_CHILD      _WAIT_CHILD
#define WAIT_GRANDCHILD _WAIT_GRANDCHILD

/* current declarations */
_CRTIMP intptr_t __cdecl cwait(int *, intptr_t, int);
_CRTIMP intptr_t __cdecl execl(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execle(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execlp(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execlpe(const char *, const char *, ...);
_CRTIMP intptr_t __cdecl execv(const char *, const char * const *);
_CRTIMP intptr_t __cdecl execve(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl execvp(const char *, const char * const *);
_CRTIMP intptr_t __cdecl execvpe(const char *, const char * const *, const char * const *);
_CRTIMP intptr_t __cdecl spawnl(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnle(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnlp(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnlpe(int, const char *, const char *, ...);
_CRTIMP intptr_t __cdecl spawnv(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP intptr_t __cdecl spawnvp(int, const char *, const char * const *);
_CRTIMP intptr_t __cdecl spawnvpe(int, const char *, const char * const *,
        const char * const *);

_CRTIMP int __cdecl getpid(void);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#endif  /* _INC_PROCESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STRING
#define _INC_STRING

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647  /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* Function prototypes */

        void *  __cdecl memcpy(void *, const void *, size_t);
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);
        char *  __cdecl _strset(char *, int);
        char *  __cdecl strcpy(char *, const char *);
        char *  __cdecl strcat(char *, const char *);
        int     __cdecl strcmp(const char *, const char *);
        size_t  __cdecl strlen(const char *);
_CRTIMP void *  __cdecl _memccpy(void *, const void *, int, size_t);
_CRTIMP void *  __cdecl memchr(const void *, int, size_t);
_CRTIMP int     __cdecl _memicmp(const void *, const void *, size_t);

#if     defined(_M_IA64)
        void *  __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void *  __cdecl memmove(void *, const void *, size_t);
#endif


_CRTIMP char *  __cdecl strchr(const char *, int);
_CRTIMP int     __cdecl _strcmpi(const char *, const char *);
_CRTIMP int     __cdecl _stricmp(const char *, const char *);
_CRTIMP int     __cdecl strcoll(const char *, const char *);
_CRTIMP int     __cdecl _stricoll(const char *, const char *);
_CRTIMP int     __cdecl _strncoll(const char *, const char *, size_t);
_CRTIMP int     __cdecl _strnicoll(const char *, const char *, size_t);
_CRTIMP size_t  __cdecl strcspn(const char *, const char *);
_CRTIMP char *  __cdecl _strdup(const char *);
_CRTIMP char *  __cdecl _strerror(const char *);
_CRTIMP char *  __cdecl strerror(int);
_CRTIMP char *  __cdecl _strlwr(char *);
_CRTIMP char *  __cdecl strncat(char *, const char *, size_t);
_CRTIMP int     __cdecl strncmp(const char *, const char *, size_t);
_CRTIMP int     __cdecl _strnicmp(const char *, const char *, size_t);
_CRTIMP char *  __cdecl strncpy(char *, const char *, size_t);
_CRTIMP char *  __cdecl _strnset(char *, int, size_t);
_CRTIMP char *  __cdecl strpbrk(const char *, const char *);
_CRTIMP char *  __cdecl strrchr(const char *, int);
_CRTIMP char *  __cdecl _strrev(char *);
_CRTIMP size_t  __cdecl strspn(const char *, const char *);
_CRTIMP char *  __cdecl strstr(const char *, const char *);
_CRTIMP char *  __cdecl strtok(char *, const char *);
_CRTIMP char *  __cdecl _strupr(char *);
_CRTIMP size_t  __cdecl strxfrm (char *, const char *, size_t);


#if     !__STDC__

/* prototypes for oldnames.lib functions */
_CRTIMP void * __cdecl memccpy(void *, const void *, int, size_t);
_CRTIMP int __cdecl memicmp(const void *, const void *, size_t);
_CRTIMP int __cdecl strcmpi(const char *, const char *);
_CRTIMP int __cdecl stricmp(const char *, const char *);
_CRTIMP char * __cdecl strdup(const char *);
_CRTIMP char * __cdecl strlwr(char *);
_CRTIMP int __cdecl strnicmp(const char *, const char *, size_t);
_CRTIMP char * __cdecl strnset(char *, int, size_t);
_CRTIMP char * __cdecl strrev(char *);
        char * __cdecl strset(char *, int);
_CRTIMP char * __cdecl strupr(char *);

#endif  /* !__STDC__ */


#ifndef _WSTRING_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcserror(int);
_CRTIMP wchar_t * __cdecl __wcserror(const wchar_t *);

_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);

_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if     !__STDC__

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif  /* !__STDC__ */

#define _WSTRING_DEFINED
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STRING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines XENIX style macros for accessing arguments of a
*       function which takes a variable number of arguments.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_VARARGS
#define _INC_VARARGS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#if     __STDC__
#error varargs.h incompatible with ANSI (use stdarg.h)
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED

typedef char *va_list;

#define _VA_LIST_DEFINED
#endif


#if     defined(_M_CEE)

#error varargs.h not supported when targetting _M_CEE (use stdarg.h)

#elif   defined(_M_IX86)

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */
#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#elif defined(_M_IA64)

#ifndef _VA_LIST
#define _VA_LIST char*
#endif
typedef _VA_LIST va_list;

#define _VA_STRUCT_ALIGN  16 

#define _VA_ALIGN       8

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) \
                            - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#define va_dcl __int64  va_alist;

#define va_start(ap)    ( ap = (va_list)&va_alist )

#define va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) \
                                                     -_SLOTSIZEOF(t)))

#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_AMD64)

extern void __cdecl __va_start(va_list *, ...);

#define va_dcl          va_list va_alist;
#define va_start(ap, x) ( __va_start(&ap, x) )
#define va_arg(ap, t)   \
    ( ( sizeof(t) > sizeof(__int64) || ( sizeof(t) & (sizeof(t) - 1) ) != 0 ) \
        ? **(t **)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) \
        :  *(t  *)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) )
#define va_end(ap)      ( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


#endif


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_VARARGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\stl.h ===
// stl.h supplemental header
#pragma once
#ifndef _STL_H_
#define _STL_H_
#include <algorithm>
#include <deque>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <utility>
#include <vector>

using namespace std;

		// TEMPLATE CLASS Deque
template<class _Ty>
	class Deque
		: public deque<_Ty, allocator<_Ty> >
	{	// wrap new deque as old
public:
	typedef Deque<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	Deque()
		: deque<_Ty, _Alloc>()
		{	// construct empty deque
		}

	explicit Deque(size_type _Count)
		: deque<_Ty, _Alloc>(_Count, _Ty())
		{	// construct deque from _Count * _Ty()
		}

	Deque(size_type _Count, const _Ty& _Val)
		: deque<_Ty, _Alloc>(_Count, _Val)
		{	// construct deque from _Count * _Val
		}

	typedef const_iterator _Iter;

	Deque(_Iter _First, _Iter _Last)
		: deque<_Ty, _Alloc>(_First, _Last)
		{	// construct deque from [_First, _Last)
		}
	};

		// TEMPLATE CLASS List
template<class _Ty>
	class List
		: public list<_Ty, allocator<_Ty> >
	{	// wrap new list as old
public:
	typedef List<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	List()
		: list<_Ty, _Alloc>()
		{	// construct empty list
		}

	explicit List(size_type _Count)
		: list<_Ty, _Alloc>(_Count, _Ty())
		{	// construct list from _Count * _Ty()
		}

	List(size_type _Count, const _Ty& _Val)
		: list<_Ty, _Alloc>(_Count, _Val)
		{	// construct list from _Count * _Val
		}

	typedef const_iterator _Iter;

	List(_Iter _First, _Iter _Last)
		: list<_Ty, _Alloc>(_First, _Last)
		{	// construct list from [_First, _Last)
		}
	};

		// TEMPLATE CLASS Map
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty> >
	class Map
		: public map<_Kty, _Ty, _Pr, allocator<_Ty> >
	{	// wrap new map as old
public:
	typedef Map<_Kty, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _Alloc;

	Map()
		: map<_Kty, _Ty, _Pr, _Alloc>(_Pr())
		{	// construct empty map from defaults
		}

	explicit Map(const _Pr& _Pred)
		: map<_Kty, _Ty, _Pr, _Alloc>(_Pred)
		{	// construct empty map from comparator
		}

	typedef const_iterator _Iter;

	Map(_Iter _First, _Iter _Last)
		: map<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct map from [_First, _Last)
		}

	Map(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: map<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Multimap
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty> >
	class Multimap
		: public multimap<_Kty, _Ty, _Pr, allocator<_Ty> >
	{	// wrap new multimap as old
public:
	typedef Multimap<_Kty, _Ty, _Pr> _Myt;
	typedef allocator<_Ty> _Alloc;

	Multimap()
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_Pr())
		{	// construct empty map from defaults
		}

	explicit Multimap(const _Pr& _Pred)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_Pred)
		{	// construct empty map from comparator
		}

	typedef const_iterator _Iter;

	Multimap(_Iter _First, _Iter _Last)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct map from [_First, _Last)
		}

	Multimap(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: multimap<_Kty, _Ty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Set
template<class _Kty,
	class _Pr = less<_Kty> >
	class Set
		: public set<_Kty, _Pr, allocator<_Kty> >
	{	// wrap new set as old
public:
	typedef Set<_Kty, _Pr> _Myt;
	typedef allocator<_Kty> _Alloc;

	Set()
		: set<_Kty, _Pr, _Alloc>(_Pr())
		{	// construct empty set from defaults
		}

	explicit Set(const _Pr& _Pred)
		: set<_Kty, _Pr, _Alloc>(_Pred)
		{	// construct empty set from comparator
		}

	typedef const_iterator _Iter;

	Set(_Iter _First, _Iter _Last)
		: set<_Kty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct set from [_First, _Last)
		}

	Set(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: set<_Kty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct set from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Multiset
template<class _Kty,
	class _Pr = less<_Kty> >
	class Multiset
		: public multiset<_Kty, _Pr, allocator<_Kty> >
	{	// wrap new multiset as old
public:
	typedef Multiset<_Kty, _Pr> _Myt;
	typedef allocator<_Kty> _Alloc;

	Multiset()
		: multiset<_Kty, _Pr, _Alloc>(_Pr())
		{	// construct empty set from defaults
		}

	explicit Multiset(const _Pr& _Pred)
		: multiset<_Kty, _Pr, _Alloc>(_Pred)
		{	// construct empty set from comparator
		}

	typedef const_iterator _Iter;

	Multiset(_Iter _First, _Iter _Last)
		: multiset<_Kty, _Pr, _Alloc>(_First, _Last, _Pr())
		{	// construct set from [_First, _Last)
		}

	Multiset(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: multiset<_Kty, _Pr, _Alloc>(_First, _Last, _Pred)
		{	// construct set from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS Vector
template<class _Ty>
	class Vector
		: public vector<_Ty, allocator<_Ty> >
	{	// wrap new vector as old
public:
	typedef Vector<_Ty> _Myt;
	typedef allocator<_Ty> _Alloc;

	Vector()
		: vector<_Ty, _Alloc>()
		{	// construct empty vector
		}

	explicit Vector(size_type _Count)
		: vector<_Ty, _Alloc>(_Count, _Ty())
		{	// construct vector from _Count * _Ty()
		}

	Vector(size_type _Count, const _Ty& _Val)
		: vector<_Ty, _Alloc>(_Count, _Val)
		{	// construct vector from _Count * _Val
		}

	typedef const_iterator _Iter;

	Vector(_Iter _First, _Iter _Last)
		: vector<_Ty, _Alloc>(_First, _Last)
		{	// construct vector from [_First, _Last)
		}
	};

		// CLASS bit_vector
class bit_vector
	: public vector<_Bool, _Bool_allocator>
	{	// wrap new vector<bool> as old
public:
	typedef _Bool _Ty;
	typedef _Bool_allocator _Alloc;
	typedef bit_vector _Myt;

	bit_vector()
		: vector<_Bool, _Bool_allocator>()
		{	// construct empty vector
		}

	explicit bit_vector(size_type _Count, const _Ty& _Val = _Ty())
		: vector<_Bool, _Bool_allocator>(_Count, _Val)
		{	// construct vector from _Count * _Val
		}

	typedef const_iterator _Iter;

	bit_vector(_Iter _First, _Iter _Last)
		: vector<_Bool, _Bool_allocator>(_First, _Last)
		{	// construct vector from [_First, _Last)
		}
	};

		// TEMPLATE CLASS priority_queue
template<class _Container,
	class _Pr = less<_Container::value_type> >
	class Priority_queue
		: public priority_queue<_Container::value_type, _Container, _Pr>
	{	// wrap new priority_queue as old
public:
	typedef typename _Container::value_type _Ty;

	Priority_queue()
		: priority_queue<_Ty, _Container, _Pr>(_Pr())
		{	// construct empty queue from defaults
		}

	explicit Priority_queue(const _Pr& _Pred)
		: priority_queue<_Ty, _Container, _Pr>(_Pred)
		{	// construct empty queue from comparator
		}

	typedef const _Ty *_Iter;

	Priority_queue(_Iter _First, _Iter _Last)
		: priority_queue<_Ty, _Container, _Pr>(_First, _Last, _Pr())
		{	// construct queue from [_First, _Last)
		}

	Priority_queue(_Iter _First, _Iter _Last, const _Pr& _Pred)
		: priority_queue<_Ty, _Container, _Pr>(_First, _Last, _Pred)
		{	// construct map from [_First, _Last), comparator
		}
	};

		// TEMPLATE CLASS queue
template<class _Container>
	class Queue
		: public queue<_Container::value_type, _Container>
	{	// wrap new queue as old
	};

		// TEMPLATE CLASS stack
template<class _Container>
	class Stack
		: public stack<_Container::value_type, _Container>
	{	// wrap new stack as old
	};

		// MACRO DEFINITIONS
#define deque			Deque
#define list			List
#define map				Map
#define multimap		Multimap
#define set				Set
#define multiset		Multiset
#define vector			Vector
#define priority_queue	Priority_queue
#define queue			Queue
#define stack			Stack

#endif /* _STL_H_ */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\xlocinfo.h ===
/* xlocinfo.h internal header for Microsoft C */
#pragma once
#ifndef _XLOCINFO
#define _XLOCINFO
#include <ctype.h>
#include <locale.h>
#include <wchar.h>
#ifndef _YVALS
 #include <yvals.h>
#endif

		/* SUPPLEMENTAL CTYPE MACROS & DECLARATIONS */
#define _XA		0x100		/* extra alphabetic */
#define _XS		0x000		/* extra space */
#define _BB		_CONTROL	/* BEL, BS, etc. */
#define _CN		_SPACE		/* CR, FF, HT, NL, VT */
#define _DI		_DIGIT		/* '0'-'9' */
#define _LO		_LOWER		/* 'a'-'z' */
#define _PU		_PUNCT		/* punctuation */
#define _SP		_BLANK		/* space */
#define _UP		_UPPER		/* 'A'-'Z' */
#define _XD		_HEX		/* '0'-'9', 'A'-'F', 'a'-'f' */

		/* SUPPLEMENTAL LOCALE MACROS AND DECLARATIONS */
#define _X_ALL			LC_ALL
#define _X_COLLATE		LC_COLLATE
#define _X_CTYPE		LC_CTYPE
#define _X_MONETARY		LC_MONETARY
#define _X_NUMERIC		LC_NUMERIC
#define _X_TIME 		LC_TIME
#define _X_MAX			LC_MAX 
#define _X_MESSAGE		6
#define _NCAT			7

#define _CATMASK(n)	((1 << (n)) >> 1)
#define _M_COLLATE	_CATMASK(_X_COLLATE)
#define _M_CTYPE	_CATMASK(_X_CTYPE)
#define _M_MONETARY	_CATMASK(_X_MONETARY)
#define _M_NUMERIC	_CATMASK(_X_NUMERIC)
#define _M_TIME		_CATMASK(_X_TIME)
#define _M_MESSAGE	_CATMASK(_X_MESSAGE)
#define _M_ALL		(_CATMASK(_NCAT) - 1)

typedef struct _Collvec
	{	/* stuff needed by _Strcoll, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Collvec;

typedef struct _Ctypevec
	{	/* stuff needed by _Tolower, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	const short *_Table;
	int _Delfl;
	} _Ctypevec;

typedef struct _Cvtvec
	{	/* stuff needed by _Mbrtowc, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Cvtvec;

		/* FUNCTION DECLARATIONS */
_C_LIB_DECL
_CRTIMP2 _Collvec __cdecl _Getcoll();
_CRTIMP2 _Ctypevec __cdecl _Getctype();
_CRTIMP2 _Cvtvec __cdecl _Getcvt();

_CRTIMP2 int __cdecl _Getdateorder();
_CRTIMP2 char *__cdecl _Getdays();
_CRTIMP2 char *__cdecl _Getmonths();
_CRTIMP2 void *__cdecl _Gettnames();

_CRTIMP2 int __cdecl _Mbrtowc(wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
_CRTIMP2 float __cdecl _Stof(const char *, char **, long);
_CRTIMP2 double __cdecl _Stod(const char *, char **, long);
_CRTIMP2 long double __cdecl _Stold(const char *, char **, long);
_CRTIMP2 int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
_CRTIMP size_t __cdecl _Strftime(char *, size_t, const char *,
	const struct tm *, void *);
_CRTIMP2 size_t __cdecl _Strxfrm(char *, char *,
	const char *, const char *, const _Collvec *);
_CRTIMP2 int __cdecl _Tolower(int, const _Ctypevec *);
_CRTIMP2 int __cdecl _Toupper(int, const _Ctypevec *);
_CRTIMP2 int __cdecl _Wcrtomb(char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
_CRTIMP2 int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
_CRTIMP2 size_t __cdecl _Wcsxfrm(wchar_t *, wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);

_CRTIMP2 short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
_CRTIMP2 const wchar_t * __cdecl _Getwctypes(const wchar_t *, const wchar_t *,
	short*, const _Ctypevec*);
_CRTIMP2 wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
_CRTIMP2 wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);
_END_C_LIB_DECL
#endif /* _XLOCINFO */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\xmath.h ===
/* xmath.h internal header for Microsoft C */
#ifndef _XMATH
#define _XMATH
#include <errno.h>
#include <math.h>
#include <stddef.h>
#ifndef _YMATH
 #include <ymath.h>
#endif
_STD_BEGIN

		/* FLOAT PROPERTIES */
#define _DBIAS	0x3fe
#define _DOFF	4
#define _FBIAS	0x7e
#define _FOFF	7
#define _FRND	1

 #define _D0	3	/* little-endian, small long doubles */
 #define _D1	2
 #define _D2	1
 #define _D3	0
 #define _DLONG	0
 #define _LBIAS	0x3fe
 #define _LOFF	4

		/* IEEE 754 double properties */
#define _DFRAC	((unsigned short)((1 << _DOFF) - 1))
#define _DMASK	((unsigned short)(0x7fff & ~_DFRAC))
#define _DMAX	((unsigned short)((1 << (15 - _DOFF)) - 1))
#define _DSIGN	((unsigned short)0x8000)
#define DSIGN(x)	(((unsigned short *)&(x))[_D0] & _DSIGN)
#define HUGE_EXP	(int)(_DMAX * 900L / 1000)
#define HUGE_RAD	2.73e9	/* ~ 2^33 / pi */
#define SAFE_EXP	((unsigned short)(_DMAX >> 1))

		/* IEEE 754 float properties */
#define _FFRAC	((unsigned short)((1 << _FOFF) - 1))
#define _FMASK	((unsigned short)(0x7fff & ~_FFRAC))
#define _FMAX	((unsigned short)((1 << (15 - _FOFF)) - 1))
#define _FSIGN	((unsigned short)0x8000)
#define FSIGN(x)	(((unsigned short *)&(x))[_F0] & _FSIGN)
#define FHUGE_EXP	(int)(_FMAX * 900L / 1000)
#define FHUGE_RAD	31.8	/* ~ 2^10 / pi */
#define FSAFE_EXP	((unsigned short)(_FMAX >> 1))

 #define _F0	1	/* little-endian order */
 #define _F1	0

		/* IEEE 754 long double properties */
#define _LFRAC	((unsigned short)(-1))
#define _LMASK	((unsigned short)0x7fff)
#define _LMAX	((unsigned short)0x7fff)
#define _LSIGN	((unsigned short)0x8000)
#define LSIGN(x)	(((unsigned short *)&(x))[_L0] & _LSIGN)
#define LHUGE_EXP	(int)(_LMAX * 900L / 1000)
#define LHUGE_RAD	2.73e9	/* ~ 2^33 / pi */
#define LSAFE_EXP	((unsigned short)(_LMAX >> 1))

 #define _L0	3	/* little-endian, small long doubles */
 #define _L1	2
 #define _L2	1
 #define _L3	0
 #define _L4	xxx

		/* return values for testing functions */
#define FINITE	_FINITE
#define INF		_INFCODE
#define NAN		_NANCODE

		/* return values for _Stopfx/_Stoflt */
#define FL_ERR	0
#define FL_DEC	1
#define FL_HEX	2
#define FL_INF	3
#define FL_NAN	4
#define FL_NEG	8

_C_LIB_DECL
		/* double declarations */
_CRTIMP2 double __cdecl _Atan(double, int);
_CRTIMP2 short __cdecl _Dint(double *, short);
_CRTIMP2 short __cdecl _Dnorm(unsigned short *);
_CRTIMP2 short __cdecl _Dscale(double *, long);
_CRTIMP2 double __cdecl _Dtento(double, long);
_CRTIMP2 short __cdecl _Dunscale(short *, double *);
_CRTIMP2 double __cdecl _Poly(double, const double *, int);

_CRTIMP2 int __cdecl _Stoflt(const char *, char **, long[], int);

extern _CRTIMP2 const _Dconst _Eps, _Rteps;
extern _CRTIMP2 const double _Xbig;

		/* float declarations */
_CRTIMP2 float __cdecl _FAtan(float, int);
_CRTIMP2 short __cdecl _FDint(float *, short);
_CRTIMP2 short __cdecl _FDnorm(unsigned short *);
_CRTIMP2 short __cdecl _FDscale(float *, long);
_CRTIMP2 float __cdecl _FDtento(float, long);
_CRTIMP2 short __cdecl _FDunscale(short *, float *);
_CRTIMP2 float __cdecl _FPoly(float, const float *, int);

extern _CRTIMP2 const _Dconst _FEps, _FRteps;
extern _CRTIMP2 const float _FXbig;

		/* long double functions */
_CRTIMP2 long double __cdecl _LAtan(long double, int);
_CRTIMP2 short __cdecl _LDint(long double *, short);
_CRTIMP2 short __cdecl _LDnorm(unsigned short *);
_CRTIMP2 short __cdecl _LDscale(long double *, long);
_CRTIMP2 long double __cdecl _LDtento(long double, long);
_CRTIMP2 short __cdecl _LDunscale(short *, long double *);
_CRTIMP2 long double __cdecl _LPoly(long double, const long double *, int);

extern _CRTIMP2 const _Dconst _LEps, _LRteps;
extern _CRTIMP2 const long double _LXbig;
_END_C_LIB_DECL
_STD_END
#endif /* _XMATH */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\ymath.h ===
/* ymath.h internal header */
#pragma once
#ifndef _YMATH
#define _YMATH
#include <yvals.h>
_C_STD_BEGIN
_C_LIB_DECL

		/* MACROS FOR _Dtest RETURN (0 => ZERO) */
#define _DENORM		(-2)	/* C9X only */
#define _FINITE		(-1)
#define _INFCODE	1
#define _NANCODE	2

		/* MACROS FOR _Feraise ARGUMENT */
#define _FE_DIVBYZERO	0x04
#define _FE_INEXACT		0x20
#define _FE_INVALID		0x01
#define _FE_OVERFLOW	0x08
#define _FE_UNDERFLOW	0x10

		/* TYPE DEFINITIONS */
typedef union
	{	/* pun float types as integer array */
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		/* ERROR REPORTING */
void __cdecl _Feraise(int);

		/* double DECLARATIONS */
_CRTIMP2 double __cdecl _Cosh(double, double);
_CRTIMP2 short __cdecl _Dtest(double *);
_CRTIMP2 short __cdecl _Exp(double *, double, short);
_CRTIMP2 double __cdecl _Log(double, int);
_CRTIMP2 double __cdecl _Sin(double, unsigned int);
_CRTIMP2 double __cdecl _Sinh(double, double);
extern _CRTIMP2 const _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		/* float DECLARATIONS */
_CRTIMP2 float __cdecl _FCosh(float, float);
_CRTIMP2 short __cdecl _FDtest(float *);
_CRTIMP2 short __cdecl _FExp(float *, float, short);
_CRTIMP2 float __cdecl _FLog(float, int);
_CRTIMP2 float __cdecl _FSin(float, unsigned int);
_CRTIMP2 float __cdecl _FSinh(float, float);
extern _CRTIMP2 const _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		/* long double DECLARATIONS */
_CRTIMP2 long double __cdecl _LCosh(long double, long double);
_CRTIMP2 short __cdecl _LDtest(long double *);
_CRTIMP2 short __cdecl _LExp(long double *, long double, short);
_CRTIMP2 long double __cdecl _LLog(long double, int);
_CRTIMP2 long double __cdecl _LSin(long double, unsigned int);
_CRTIMP2 long double __cdecl _LSinh(long double, long double);
_CRTIMP2 extern const _Dconst _LDenorm, _LInf, _LNan, _LSnan;
_END_C_LIB_DECL
_C_STD_END
#endif /* _YMATH */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\use_ansi.h ===
/***
*use_ansi.h - pragmas for ANSI Standard C++ libraries
*
*	Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header is intended to force the use of the appropriate ANSI
*       Standard C++ libraries whenever it is included.
*
*       [Public]
*
****/


#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _USE_ANSI_CPP
#define _USE_ANSI_CPP

#ifdef _MT
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#ifdef _DEBUG
#pragma comment(lib,"msvcprtd")
#else	// _DEBUG
#pragma comment(lib,"msvcprt")
#endif	// _DEBUG

#else	// _DLL && !STATIC_CPPLIB
#ifdef _DEBUG
#pragma comment(lib,"libcpmtd")
#else	// _DEBUG
#pragma comment(lib,"libcpmt")
#endif	// _DEBUG
#endif	// _DLL && !STATIC_CPPLIB

#else	// _MT
#ifdef _DEBUG
#pragma comment(lib,"libcpd")
#else	// _DEBUG
#pragma comment(lib,"libcp")
#endif	// _DEBUG
#endif

#endif	// _USE_ANSI_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\sys\locking.h ===
/***
*sys/locking.h - flags for locking() function
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the flags for the locking() function.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCKING
#define _INC_LOCKING

#if !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _LK_UNLCK       0       /* unlock the file region */
#define _LK_LOCK        1       /* lock the file region */
#define _LK_NBLCK       2       /* non-blocking lock */
#define _LK_RLCK        3       /* lock for writing */
#define _LK_NBRLCK      4       /* non-blocking lock for writing */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define LK_UNLCK        _LK_UNLCK
#define LK_LOCK         _LK_LOCK
#define LK_NBLCK        _LK_NBLCK
#define LK_RLCK         _LK_RLCK
#define LK_NBRLCK       _LK_NBRLCK
#endif

#endif  /* _INC_LOCKING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\useoldio.h ===
/***
*useoldio.h - force the use of the Microsoft "classic" iostream libraries.
*
*       Copyright (c) 1996-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Generates default library directives for the old ("classic") IOSTREAM
*       libraries.  The exact name of the library specified in the directive
*       depends on the compiler switches (-ML, -MT, -MD, -MLd, -MTd, and -MDd).
*
*       This header file is only included by other header files.
*
*       [Public]
*
****/

#ifndef _USE_OLD_IOSTREAMS
#define _USE_OLD_IOSTREAMS
#ifndef _M_IA64
/*
 * Warning C4995, '_OLD_IOSTREAMS_ARE_DEPRECATED' is a deprecated name, is 
 * being issued because the old I/O Streams headers iostreams.h et al will no
 * longer be supported from VC8.  Replace references such as #include 
 * <iostreams.h> with #include <iostreams>, using the new, more conformant, I/O
 * Streams headers.
 */

#pragma deprecated(_OLD_IOSTREAMS_ARE_DEPRECATED)
extern void _OLD_IOSTREAMS_ARE_DEPRECATED();
#endif  /* _M_IA64 */
#ifdef  _MT
#ifdef  _DLL
#ifdef  _DEBUG
#pragma comment(lib,"msvcirtd")
#else   /* _DEBUG */
#pragma comment(lib,"msvcirt")
#endif  /* _DEBUG */

#else   /* _DLL */
#ifdef  _DEBUG
#pragma comment(lib,"libcimtd")
#else   /* _DEBUG */
#pragma comment(lib,"libcimt")
#endif  /* _DEBUG */
#endif  /* _DLL */

#else   /* _MT */
#ifdef  _DEBUG
#pragma comment(lib,"libcid")
#else   /* _DEBUG */
#pragma comment(lib,"libci")
#endif  /* _DEBUG */
#endif

#endif  /* _USE_OLD_IOSTREAMS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\sys\timeb.h ===
/***
*sys/timeb.h - definition/declarations for _ftime()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file define the _ftime() function and the types it uses.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIMEB
#define _INC_TIMEB

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


/* Structure returned by _ftime system call */

#ifndef _TIMEB_DEFINED
struct _timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#if     !__STDC__

/* Non-ANSI name for compatibility */

struct timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#endif

#if     _INTEGRAL_MAX_BITS >= 64
struct __timeb64 {
        __time64_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };
#endif

#define _TIMEB_DEFINED
#endif


/* Function prototypes */

_CRTIMP void __cdecl _ftime(struct _timeb *);

#if     !__STDC__

/* Non-ANSI name for compatibility */

_CRTIMP void __cdecl ftime(struct timeb *);

#endif

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP void __cdecl _ftime64(struct __timeb64 *);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIMEB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\sys\types.h ===
/***
*sys/types.h - types returned by system level calls for file and time info
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines types used in defining values returned by system
*       level calls for file status and time information.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TYPES
#define _INC_TYPES

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


#ifndef _INO_T_DEFINED

typedef unsigned short _ino_t;          /* i-node number (not used on DOS) */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif

#define _INO_T_DEFINED
#endif


#ifndef _DEV_T_DEFINED

typedef unsigned int _dev_t;            /* device code */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif

#define _DEV_T_DEFINED
#endif


#ifndef _OFF_T_DEFINED

typedef long _off_t;                    /* file offset value */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif

#define _OFF_T_DEFINED
#endif

#endif  /* _INC_TYPES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has declarations of time routines and defines
*       the structure returned by the localtime and gmtime routines and
*       used by asctime.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIME
#define _INC_TIME

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

/* Define the implementation defined time type */

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif


/* Define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif


/* Clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC  1000


/* Extern declarations for the global variables used by the ctime family of
 * routines.
 */

/* non-zero if daylight savings time is used */
_CRTIMP extern int _daylight;

/* offset for Daylight Saving Time */
_CRTIMP extern long _dstbias;

/* difference in seconds between GMT and local time */
_CRTIMP extern long _timezone;

/* standard/daylight savings time zone names */
_CRTIMP extern char * _tzname[2];


/* Function prototypes */

_CRTIMP char * __cdecl asctime(const struct tm *);
_CRTIMP char * __cdecl ctime(const time_t *);
_CRTIMP clock_t __cdecl clock(void);
_CRTIMP double __cdecl difftime(time_t, time_t);
_CRTIMP struct tm * __cdecl gmtime(const time_t *);
_CRTIMP struct tm * __cdecl localtime(const time_t *);
_CRTIMP time_t __cdecl mktime(struct tm *);
_CRTIMP size_t __cdecl strftime(char *, size_t, const char *,
        const struct tm *);
_CRTIMP char * __cdecl _strdate(char *);
_CRTIMP char * __cdecl _strtime(char *);
_CRTIMP time_t __cdecl time(time_t *);

#ifdef  _POSIX_
_CRTIMP void __cdecl tzset(void);
#else
_CRTIMP void __cdecl _tzset(void);
#endif

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP char * __cdecl _ctime64(const __time64_t *);
_CRTIMP struct tm * __cdecl _gmtime64(const __time64_t *);
_CRTIMP struct tm * __cdecl _localtime64(const __time64_t *);
_CRTIMP __time64_t __cdecl _mktime64(struct tm *);
_CRTIMP __time64_t __cdecl _time64(__time64_t *);
#endif

/* --------- The following functions are OBSOLETE --------- */
/* The Win32 API GetLocalTime and SetLocalTime should be used instead. */
unsigned __cdecl _getsystime(struct tm *);
unsigned __cdecl _setsystime(struct tm *, unsigned);
/* --------- The preceding functions are OBSOLETE --------- */


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* wide function prototypes, also declared in wchar.h */
 
_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _wctime64(const __time64_t *);
#endif

#define _WTIME_DEFINED
#endif


#if     !__STDC__ || defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define CLK_TCK  CLOCKS_PER_SEC

_CRTIMP extern int daylight;
_CRTIMP extern long timezone;
_CRTIMP extern char * tzname[2];

_CRTIMP void __cdecl tzset(void);

#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\wctype.h ===
/***
*wctype.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*       Created from wchar.h January 1996 by P.J. Plauger
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all ctype-style wide-character functions.  They may also be declared in
*       wchar.h.
*       [ISO]
*
*       Note: keep in sync with ctype.h and wchar.h.
*
*       [Public]
*
****/


#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_WCTYPE
#define _INC_WCTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP2 */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];

#if     defined(_DLL) && defined(_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP const unsigned short ** __cdecl __p__pctype(void);
_CRTIMP const wctype_t ** __cdecl ___p__pwctype(void);
#endif
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
_CRTIMP const unsigned short * __cdecl __pctype_func(void);
#ifndef __PCTYPE_FUNC
#ifdef _MT
#define __PCTYPE_FUNC   __pctype_func()
#else
#define __PCTYPE_FUNC  _pctype
#endif  /* _MT */
#endif  /* __PCTYPE_FUNC */


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#define isleadbyte(c) (__pctype_func()[(unsigned char)(c)] & _LEADBYTE)
#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int __cdecl isleadbyte(int _C)
        {return (__pctype_func()[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */

typedef wchar_t wctrans_t;
_CRTIMP2 wint_t __cdecl towctrans(wint_t, wctrans_t);
_CRTIMP2 wctrans_t __cdecl wctrans(const char *);
_CRTIMP2 wctype_t __cdecl wctype(const char *);


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\lib\dll40\data.c ===
int _HUGE;
int __argc;
int __argv;
int __initenv;
int __mb_cur_max;
int __wargv;
int __winitenv;
int _acmdln;
int _aexit_rtn;
int _ctype;
int _daylight;
int _dstbias;
int _environ;
int _fileinfo;
int _iob;
int _mbctype;
int _osver;
int _pctype;
int _pgmptr;
int _pwctype;
int _sys_errlist;
int _sys_nerr;
int _timezone;
int _tzname;
int _wcmdln;
int _wenviron;
int _winmajor;
int _winminor;
int _winver;
int _wpgmptr;;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\oldnames\weak.asm ===
.386
.model flat, c

extern C alternate:PROC
extern C weak(alternate):PROC

    end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\xmmintrin.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * xmmintrin.h
 *
 * Principal header file for Streaming SIMD Extensions intrinsics
 *
 * The intrinsics package can be used in 2 ways, based whether or not
 * _MM_FUNCTIONALITY is defined; if it is, the C/x87 implementation
 * will be used (the "faux intrinsics").
 *
 *
 * Note that the m128 datatype provided using _MM2_FUNCTIONALITY mode is
 *   implemented as struct, will not be 128b aligned, will be passed
 *   via the stack, etc.  MM_FUNCTIONALITY mode is not intended for
 *   performance, just semantics.
 *
 */

#ifndef _INCLUDED_MM2
#define _INCLUDED_MM2


/*
 * the m64 type is required for the integer Streaming SIMD Extensions intrinsics
 */
#ifndef _MMINTRIN_H_INCLUDED
#include <mmintrin.h>
#endif

#ifdef _MM2_FUNCTIONALITY
/* support old notation */
#ifndef _MM_FUNCTIONALITY
#define _MM_FUNCTIONALITY
#endif
#endif

#ifdef __ICL
#ifdef _MM_FUNCTIONALITY
#include "xmm_func.h"
#else
/* using real intrinsics */
typedef long long __m128;
#endif
#else

#if _MSC_VER >= 1300
typedef struct __declspec(intrin_type) __declspec(align(16)) __m128 {
    float       m128_f32[4];
} __m128;
#endif

#ifndef _INC_MALLOC
/* pick up _mm_malloc() and _mm_free() */
#include <malloc.h>
#endif
#endif

/*******************************************************/
/* MACRO for shuffle parameter for _mm_shuffle_ps().   */
/* Argument fp3 is a digit[0123] that represents the fp*/
/* from argument "b" of mm_shuffle_ps that will be     */
/* placed in fp3 of result. fp2 is the same for fp2 in */
/* result. fp1 is a digit[0123] that represents the fp */
/* from argument "a" of mm_shuffle_ps that will be     */
/* places in fp1 of result. fp0 is the same for fp0 of */
/* result                                              */
/*******************************************************/
#define _MM_SHUFFLE(fp3,fp2,fp1,fp0) (((fp3) << 6) | ((fp2) << 4) | \
                                     ((fp1) << 2) | ((fp0)))


/*******************************************************/
/* MACRO for performing the transpose of a 4x4 matrix  */
/* of single precision floating point values.          */
/* Arguments row0, row1, row2, and row3 are __m128     */
/* values whose elements form the corresponding rows   */
/* of a 4x4 matrix.  The matrix transpose is returned  */
/* in arguments row0, row1, row2, and row3 where row0  */
/* now holds column 0 of the original matrix, row1 now */
/* holds column 1 of the original matrix, etc.         */
/*******************************************************/
#define _MM_TRANSPOSE4_PS(row0, row1, row2, row3) {                 \
            __m128 tmp3, tmp2, tmp1, tmp0;                          \
                                                                    \
            tmp0   = _mm_shuffle_ps((row0), (row1), 0x44);          \
            tmp2   = _mm_shuffle_ps((row0), (row1), 0xEE);          \
            tmp1   = _mm_shuffle_ps((row2), (row3), 0x44);          \
            tmp3   = _mm_shuffle_ps((row2), (row3), 0xEE);          \
                                                                    \
            (row0) = _mm_shuffle_ps(tmp0, tmp1, 0x88);              \
            (row1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD);              \
            (row2) = _mm_shuffle_ps(tmp2, tmp3, 0x88);              \
            (row3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD);              \
        }


/* constants for use with _mm_prefetch */
#define _MM_HINT_T0     1
#define _MM_HINT_T1     2
#define _MM_HINT_T2     3
#define _MM_HINT_NTA    0

/* (this declspec not supported with 0.A or 0.B) */
#define _MM_ALIGN16 __declspec(align(16))

/* MACRO functions for setting and reading the MXCSR */
#define _MM_EXCEPT_MASK       0x003f
#define _MM_EXCEPT_INVALID    0x0001
#define _MM_EXCEPT_DENORM     0x0002
#define _MM_EXCEPT_DIV_ZERO   0x0004
#define _MM_EXCEPT_OVERFLOW   0x0008
#define _MM_EXCEPT_UNDERFLOW  0x0010
#define _MM_EXCEPT_INEXACT    0x0020

#define _MM_MASK_MASK         0x1f80
#define _MM_MASK_INVALID      0x0080
#define _MM_MASK_DENORM       0x0100
#define _MM_MASK_DIV_ZERO     0x0200
#define _MM_MASK_OVERFLOW     0x0400
#define _MM_MASK_UNDERFLOW    0x0800
#define _MM_MASK_INEXACT      0x1000

#define _MM_ROUND_MASK        0x6000
#define _MM_ROUND_NEAREST     0x0000
#define _MM_ROUND_DOWN        0x2000
#define _MM_ROUND_UP          0x4000
#define _MM_ROUND_TOWARD_ZERO 0x6000

#define _MM_FLUSH_ZERO_MASK   0x8000
#define _MM_FLUSH_ZERO_ON     0x8000
#define _MM_FLUSH_ZERO_OFF    0x0000

#define _MM_SET_EXCEPTION_STATE(mask)                               \
            _mm_setcsr((_mm_getcsr() & ~_MM_EXCEPT_MASK) | (mask))
#define _MM_GET_EXCEPTION_STATE()                                   \
            (_mm_getcsr() & _MM_EXCEPT_MASK)

#define _MM_SET_EXCEPTION_MASK(mask)                                \
            _mm_setcsr((_mm_getcsr() & ~_MM_MASK_MASK) | (mask))
#define _MM_GET_EXCEPTION_MASK()                                    \
            (_mm_getcsr() & _MM_MASK_MASK)

#define _MM_SET_ROUNDING_MODE(mode)                                 \
            _mm_setcsr((_mm_getcsr() & ~_MM_ROUND_MASK) | (mode))
#define _MM_GET_ROUNDING_MODE()                                     \
            (_mm_getcsr() & _MM_ROUND_MASK)

#define _MM_SET_FLUSH_ZERO_MODE(mode)                               \
            _mm_setcsr((_mm_getcsr() & ~_MM_FLUSH_ZERO_MASK) | (mode))
#define _MM_GET_FLUSH_ZERO_MODE(mode)                               \
            (_mm_getcsr() & _MM_FLUSH_ZERO_MASK)

/*****************************************************/
/*     INTRINSICS FUNCTION PROTOTYPES START HERE     */
/*****************************************************/

#if defined __cplusplus
extern "C" { /* Begin "C" */
  /* Intrinsics use C name-mangling. */
#endif /* __cplusplus */

/*
 * FP, arithmetic
 */

extern __m128 _mm_add_ss(__m128 a, __m128 b);
extern __m128 _mm_add_ps(__m128 a, __m128 b);
extern __m128 _mm_sub_ss(__m128 a, __m128 b);
extern __m128 _mm_sub_ps(__m128 a, __m128 b);
extern __m128 _mm_mul_ss(__m128 a, __m128 b);
extern __m128 _mm_mul_ps(__m128 a, __m128 b);
extern __m128 _mm_div_ss(__m128 a, __m128 b);
extern __m128 _mm_div_ps(__m128 a, __m128 b);
extern __m128 _mm_sqrt_ss(__m128 a);
extern __m128 _mm_sqrt_ps(__m128 a);
extern __m128 _mm_rcp_ss(__m128 a);
extern __m128 _mm_rcp_ps(__m128 a);
extern __m128 _mm_rsqrt_ss(__m128 a);
extern __m128 _mm_rsqrt_ps(__m128 a);
extern __m128 _mm_min_ss(__m128 a, __m128 b);
extern __m128 _mm_min_ps(__m128 a, __m128 b);
extern __m128 _mm_max_ss(__m128 a, __m128 b);
extern __m128 _mm_max_ps(__m128 a, __m128 b);

/*
 * FP, logical
 */

extern __m128 _mm_and_ps(__m128 a, __m128 b);
extern __m128 _mm_andnot_ps(__m128 a, __m128 b);
extern __m128 _mm_or_ps(__m128 a, __m128 b);
extern __m128 _mm_xor_ps(__m128 a, __m128 b);

/*
 * FP, comparison
 */

extern __m128 _mm_cmpeq_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpeq_ps(__m128 a, __m128 b);
extern __m128 _mm_cmplt_ss(__m128 a, __m128 b);
extern __m128 _mm_cmplt_ps(__m128 a, __m128 b);
extern __m128 _mm_cmple_ss(__m128 a, __m128 b);
extern __m128 _mm_cmple_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpgt_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpgt_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpge_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpge_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpneq_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpneq_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpnlt_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpnlt_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpnle_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpnle_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpngt_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpngt_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpnge_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpnge_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpord_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpord_ps(__m128 a, __m128 b);
extern __m128 _mm_cmpunord_ss(__m128 a, __m128 b);
extern __m128 _mm_cmpunord_ps(__m128 a, __m128 b);
extern int _mm_comieq_ss(__m128 a, __m128 b);
extern int _mm_comilt_ss(__m128 a, __m128 b);
extern int _mm_comile_ss(__m128 a, __m128 b);
extern int _mm_comigt_ss(__m128 a, __m128 b);
extern int _mm_comige_ss(__m128 a, __m128 b);
extern int _mm_comineq_ss(__m128 a, __m128 b);
extern int _mm_ucomieq_ss(__m128 a, __m128 b);
extern int _mm_ucomilt_ss(__m128 a, __m128 b);
extern int _mm_ucomile_ss(__m128 a, __m128 b);
extern int _mm_ucomigt_ss(__m128 a, __m128 b);
extern int _mm_ucomige_ss(__m128 a, __m128 b);
extern int _mm_ucomineq_ss(__m128 a, __m128 b);

/*
 * FP, conversions
 */

extern int _mm_cvt_ss2si(__m128 a);
extern __m64 _mm_cvt_ps2pi(__m128 a);
extern int _mm_cvtt_ss2si(__m128 a);
extern __m64 _mm_cvtt_ps2pi(__m128 a);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern __m128 _mm_cvt_pi2ps(__m128, __m64);

/*
 * FP, misc
 */

extern __m128 _mm_shuffle_ps(__m128 a, __m128 b, unsigned int imm8);
extern __m128 _mm_unpackhi_ps(__m128 a, __m128 b);
extern __m128 _mm_unpacklo_ps(__m128 a, __m128 b);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 a);


/*
 * Integer extensions
 */
extern int _m_pextrw(__m64, int);
extern __m64 _m_pinsrw(__m64, int, int);
extern __m64 _m_pmaxsw(__m64, __m64);
extern __m64 _m_pmaxub(__m64, __m64);
extern __m64 _m_pminsw(__m64, __m64);
extern __m64 _m_pminub(__m64, __m64);
extern int _m_pmovmskb(__m64);
extern __m64 _m_pmulhuw(__m64, __m64);
extern __m64 _m_pshufw(__m64, int);
extern void _m_maskmovq(__m64, __m64, char *);
extern __m64 _m_pavgb(__m64, __m64);
extern __m64 _m_pavgw(__m64, __m64);
extern __m64 _m_psadbw(__m64, __m64);

/*
 * memory & initialization
 */

extern __m128 _mm_set_ss(float a);
extern __m128 _mm_set_ps1(float a);
extern __m128 _mm_set_ps(float a, float b, float c, float d);
extern __m128 _mm_setr_ps(float a, float b, float c, float d);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*a);
extern __m128 _mm_load_ps1(float const*a);
extern __m128 _mm_load_ps(float const*a);
extern __m128 _mm_loadr_ps(float const*a);
extern __m128 _mm_loadu_ps(float const*a);
extern void _mm_store_ss(float *v, __m128 a);
extern void _mm_store_ps1(float *v, __m128 a);
extern void _mm_store_ps(float *v, __m128 a);
extern void _mm_storer_ps(float *v, __m128 a);
extern void _mm_storeu_ps(float *v, __m128 a);
extern void _mm_prefetch(char const*a, int sel);
extern void _mm_stream_pi(__m64 *, __m64);
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 a, __m128 b);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);

#ifdef __ICL
extern void* __cdecl _mm_malloc(int siz, int al);
extern void __cdecl _mm_free(void *p);
#endif

/* Alternate intrinsic names definition */
#define _mm_cvtss_si32    _mm_cvt_ss2si
#define _mm_cvtps_pi32    _mm_cvt_ps2pi
#define _mm_cvttss_si32   _mm_cvtt_ss2si
#define _mm_cvttps_pi32   _mm_cvtt_ps2pi
#define _mm_cvtsi32_ss    _mm_cvt_si2ss
#define _mm_cvtpi32_ps    _mm_cvt_pi2ps
#define _mm_extract_pi16  _m_pextrw
#define _mm_insert_pi16   _m_pinsrw
#define _mm_max_pi16      _m_pmaxsw
#define _mm_max_pu8       _m_pmaxub
#define _mm_min_pi16      _m_pminsw
#define _mm_min_pu8       _m_pminub
#define _mm_movemask_pi8  _m_pmovmskb
#define _mm_mulhi_pu16    _m_pmulhuw
#define _mm_shuffle_pi16  _m_pshufw
#define _mm_maskmove_si64 _m_maskmovq
#define _mm_avg_pu8       _m_pavgb
#define _mm_avg_pu16      _m_pavgw
#define _mm_sad_pu8       _m_psadbw
#define _mm_set1_ps       _mm_set_ps1
#define _mm_load1_ps      _mm_load_ps1
#define _mm_store1_ps     _mm_store_ps1

/******************************************************/
/* UTILITY INTRINSICS FUNCTION DEFINITIONS START HERE */
/******************************************************/

/*********************************************************/
/*  NAME : _mm_cvtpi16_ps                                */
/*  DESCRIPTION : Convert 4 16-bit signed integer values */
/*                to 4 single-precision float values     */
/*  IN : __m64 a                                         */
/*  OUT : none                                           */
/*  RETURN : __m128 : (float)a                           */
/*********************************************************/
__inline __m128 _mm_cvtpi16_ps(__m64 a)
{
  __m128 tmp;
  __m64  ext_val = _mm_cmpgt_pi16(_mm_setzero_si64(), a);

  tmp = _mm_cvtpi32_ps(_mm_setzero_ps(), _mm_unpackhi_pi16(a, ext_val));
  return(_mm_cvtpi32_ps(_mm_movelh_ps(tmp, tmp), 
                        _mm_unpacklo_pi16(a, ext_val)));
}


/***********************************************************/
/*  NAME : _mm_cvtpu16_ps                                  */
/*  DESCRIPTION : Convert 4 16-bit unsigned integer values */
/*                to 4 single-precision float values       */
/*  IN : __m64 a                                           */
/*  OUT : none                                             */
/*  RETURN : __m128 : (float)a                             */
/***********************************************************/
__inline __m128 _mm_cvtpu16_ps(__m64 a)
{
  __m128 tmp;
  __m64  ext_val = _mm_setzero_si64();

  tmp = _mm_cvtpi32_ps(_mm_setzero_ps(), _mm_unpackhi_pi16(a, ext_val));
  return(_mm_cvtpi32_ps(_mm_movelh_ps(tmp, tmp), 
                        _mm_unpacklo_pi16(a, ext_val)));
}


/******************************************************/
/*  NAME : _mm_cvtps_pi16                             */
/*  DESCRIPTION : Convert 4 single-precision float    */
/*                values to 4 16-bit integer values   */
/*  IN : __m128 a                                     */
/*  OUT : none                                        */
/*  RETURN : __m64 : (short)a                         */
/******************************************************/
__inline __m64 _mm_cvtps_pi16(__m128 a)
{
  return _mm_packs_pi32(_mm_cvtps_pi32(a), 
                        _mm_cvtps_pi32(_mm_movehl_ps(a, a)));
}


/******************************************************/
/*  NAME : _mm_cvtpi8_ps                              */
/*  DESCRIPTION : Convert 4 8-bit integer values to 4 */
/*                single-precision float values       */
/*  IN : __m64 a                                      */
/*  OUT : none                                        */
/*  RETURN : __m128 : (float)a                        */
/******************************************************/
__inline __m128 _mm_cvtpi8_ps(__m64 a)
{
  __m64  ext_val = _mm_cmpgt_pi8(_mm_setzero_si64(), a);

  return _mm_cvtpi16_ps(_mm_unpacklo_pi8(a, ext_val));
}


/******************************************************/
/*  NAME : _mm_cvtpu8_ps                              */
/*  DESCRIPTION : Convert 4 8-bit unsigned integer    */
/*                values to 4 single-precision float  */
/*                values                              */
/*  IN : __m64 a                                      */
/*  OUT : none                                        */
/*  RETURN : __m128 : (float)a                        */
/******************************************************/
__inline __m128 _mm_cvtpu8_ps(__m64 a)
{
  return _mm_cvtpu16_ps(_mm_unpacklo_pi8(a, _mm_setzero_si64()));
}


/******************************************************/
/*  NAME : _mm_cvtps_pi8                              */
/*  DESCRIPTION : Convert 4 single-precision float    */
/*                values to 4 8-bit integer values    */
/*  IN : __m128 a                                     */
/*  OUT : none                                        */
/*  RETURN : __m64 : (char)a                          */
/******************************************************/
__inline __m64 _mm_cvtps_pi8(__m128 a)
{
  return _mm_packs_pi16(_mm_cvtps_pi16(a), _mm_setzero_si64());
}


/******************************************************/
/*  NAME : _mm_cvtpi32x2_ps                           */
/*  DESCRIPTION : Convert 4 32-bit integer values     */
/*                to 4 single-precision float values  */
/*  IN : __m64 a : operand 1                          */
/*       __m64 b : operand 2                          */
/*  OUT : none                                        */
/*  RETURN : __m128 : (float)a,(float)b               */
/******************************************************/
__inline __m128 _mm_cvtpi32x2_ps(__m64 a, __m64 b)
{
  return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), a), 
                       _mm_cvt_pi2ps(_mm_setzero_ps(), b)); 
}


#if defined __cplusplus
}; /* End "C" */
#endif /* __cplusplus */

#endif /* _INCLUDED_MM2 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\yvals.h ===
/* yvals.h values header for Microsoft C/C++ */
#pragma once
#ifndef _YVALS
#define _YVALS

#define _CPPLIB_VER	310

		/* NAMING PROPERTIES */
#define _WIN32_C_LIB	1

		/* THREAD AND LOCALE CONTROL */
#define _MULTI_THREAD	_MT	/* nontrivial locks if multithreaded */
#define _GLOBAL_LOCALE	0	/* 0 for per-thread locales, 1 for shared */

		/* THREAD-LOCAL STORAGE */
#define _COMPILER_TLS	1	/* 1 if compiler supports TLS directly */
 #if _MULTI_THREAD
  #define _TLS_QUAL	__declspec(thread)	/* TLS qualifier, if any */
 #else
  #define _TLS_QUAL
 #endif

 #ifndef _HAS_EXCEPTIONS
  #define  _HAS_EXCEPTIONS  1	/* predefine as 0 to disable exceptions */
 #endif

 #define _HAS_TEMPLATE_PARTIAL_ORDERING	0

 #define _HAS_PARTIAL_SPECIALIZATION	(1301 <= _MSC_VER)

#include <use_ansi.h>

#ifndef _VC6SP2
 #define _VC6SP2	0 /* define as 1 to fix linker errors with V6.0 SP2 */
#endif

/* Define _CRTIMP2 */
 #ifndef _CRTIMP2
   #if defined(_DLL) && !defined(_STATIC_CPPLIB)
    #define _CRTIMP2	__declspec(dllimport)
   #else   /* ndef _DLL && !STATIC_CPPLIB */
    #define _CRTIMP2
   #endif  /* _DLL && !STATIC_CPPLIB */
 #endif  /* _CRTIMP2 */

 #if defined(_DLL) && !defined(_STATIC_CPPLIB)
  #define _DLL_CPPLIB
 #endif


 #if (1300 <= _MSC_VER)
  #define _DEPRECATED	__declspec(deprecated)
 #else
  #define _DEPRECATED
 #endif

		/* NAMESPACE */
 #if defined(__cplusplus)
  #define _STD			std::
  #define _STD_BEGIN	namespace std {
  #define _STD_END		}

  #define _CSTD			::
   #define _C_STD_BEGIN	/* match _STD_BEGIN/END if *.c compiled as C++ */
   #define _C_STD_END

  #define _C_LIB_DECL	extern "C" {	/* C has extern "C" linkage */
  #define _END_C_LIB_DECL }
  #define _EXTERN_C		extern "C" {
  #define _END_EXTERN_C }

 #else /* __cplusplus */
  #define _STD
  #define _STD_BEGIN
  #define _STD_END

  #define _CSTD
  #define _C_STD_BEGIN
  #define _C_STD_END

  #define _C_LIB_DECL
  #define _END_C_LIB_DECL
  #define _EXTERN_C
  #define _END_EXTERN_C
 #endif /* __cplusplus */

 #define _Restrict	restrict

 #ifdef __cplusplus
_STD_BEGIN
typedef bool _Bool;
_STD_END
 #endif /* __cplusplus */

		/* VC++ COMPILER PARAMETERS */
#define _LONGLONG	__int64
#define _ULONGLONG	unsigned __int64
#define _LLONG_MAX	0x7fffffffffffffff
#define _ULLONG_MAX	0xffffffffffffffff

		/* INTEGER PROPERTIES */
#define _C2			1	/* 0 if not 2's complement */

#define _MAX_EXP_DIG	8	/* for parsing numerics */
#define _MAX_INT_DIG	32
#define _MAX_SIG_DIG	36

typedef _LONGLONG _Longlong;
typedef _ULONGLONG _ULonglong;

		/* STDIO PROPERTIES */
#define _Filet _iobuf

 #ifndef _FPOS_T_DEFINED
  #define _FPOSOFF(fp)	((long)(fp))
 #endif /* _FPOS_T_DEFINED */

#define _IOBASE	_base
#define _IOPTR	_ptr
#define _IOCNT	_cnt

		/* MULTITHREAD PROPERTIES */
		/* LOCK MACROS */
#define _LOCK_LOCALE	0
#define _LOCK_MALLOC	1
#define _LOCK_STREAM	2
#define _MAX_LOCK		3	/* one more than highest lock number */

 #ifdef __cplusplus
_STD_BEGIN
		// CLASS _Lockit
class _CRTIMP2 _Lockit
	{	// lock while object in existence -- MUST NEST
public:
  #if _MULTI_THREAD
	explicit _Lockit();	// set default lock
	explicit _Lockit(int);	// set the lock
	~_Lockit();	// clear the lock

private:
	_Lockit(const _Lockit&);				// not defined
	_Lockit& operator=(const _Lockit&);	// not defined

	int _Locktype;
  #else /* _MULTI_THREAD */
   #define _LOCKIT(x)
	explicit _Lockit()
		{	// do nothing
		}

	explicit _Lockit(int)
		{	// do nothing
		}

	~_Lockit()
		{	// do nothing
		}
  #endif /* _MULTI_THREAD */
	};

class _CRTIMP2 _Mutex
	{	// lock under program control
public:
  #if _MULTI_THREAD
	_Mutex();
	~_Mutex();
	void _Lock();
	void _Unlock();

private:
	_Mutex(const _Mutex&);				// not defined
	_Mutex& operator=(const _Mutex&);	// not defined
	void *_Mtx;
  #else /* _MULTI_THREAD */
    void _Lock()
		{	// do nothing
		}

	void _Unlock()
		{	// do nothing
		}
  #endif /* _MULTI_THREAD */
	};

class _Init_locks
	{	// initialize mutexes
public:
 #if _MULTI_THREAD
	_Init_locks();
	~_Init_locks();
 #else /* _MULTI_THREAD */
	_Init_locks()
		{	// do nothing
		}

	~_Init_locks()
		{	// do nothing
		}
 #endif /* _MULTI_THREAD */ 
	};
_STD_END
 #endif /* __cplusplus */


		/* MISCELLANEOUS MACROS AND TYPES */
_C_STD_BEGIN
_EXTERN_C
_CRTIMP2 void __cdecl _Atexit(void (__cdecl *)(void));
_END_EXTERN_C

typedef int _Mbstatet;

#define _ATEXIT_T	void
#define _Mbstinit(x)	mbstate_t x = {0}
_C_STD_END

#endif /* _YVALS */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\sys\utime.h ===
/***
*sys/utime.h - definitions/declarations for utime()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the utime routine to set
*       new file access and modification times.  NOTE - MS-DOS
*       does not recognize access time, so this field will
*       always be ignored and the modification time field will be
*       used to set the new time.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_UTIME
#define _INC_UTIME

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

/* define struct used by _utime() function */

#ifndef _UTIMBUF_DEFINED

struct _utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };

#if     !__STDC__
/* Non-ANSI name for compatibility */
struct utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };
#endif

#if     _INTEGRAL_MAX_BITS >= 64
struct __utimbuf64 {
        __time64_t actime;      /* access time */
        __time64_t modtime;     /* modification time */
        };
#endif

#define _UTIMBUF_DEFINED
#endif


/* Function Prototypes */

_CRTIMP int __cdecl _utime(const char *, struct _utimbuf *);

_CRTIMP int __cdecl _futime(int, struct _utimbuf *);

/* Wide Function Prototypes */
_CRTIMP int __cdecl _wutime(const wchar_t *, struct _utimbuf *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _utime64(const char *, struct __utimbuf64 *);
_CRTIMP int __cdecl _futime64(int, struct __utimbuf64 *);
_CRTIMP int __cdecl _wutime64(const wchar_t *, struct __utimbuf64 *);
#endif

#if     !__STDC__
/* Non-ANSI name for compatibility */
_CRTIMP int __cdecl utime(const char *, struct utimbuf *);
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_UTIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\wchar.h ===
/***
*wchar.h - declarations for wide character functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all wide character-related functions.  They may also be declared in
*       individual header files on a functional basis.
*       [ISO]
*
*       Note: keep in sync with ctype.h, stdio.h, stdlib.h, string.h, time.h.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif


#ifndef _INC_WCHAR
#define _INC_WCHAR



#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP2 */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _TIME64_T_DEFINED
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME64_T_DEFINED
#endif

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef _W64 int            intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#define WCHAR_MIN       0
#define WCHAR_MAX       ((wchar_t)-1)

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef _VA_LIST_DEFINED
typedef char *  va_list;
#define _VA_LIST_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
_CRTIMP extern FILE _iob[];
#endif  /* _STDIO_DEFINED */

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata_t {
        unsigned attrib;
        time_t   time_create;   /* -1 for FAT file systems */
        time_t   time_access;   /* -1 for FAT file systems */
        time_t   time_write;
        _fsize_t size;
        wchar_t  name[260];
};

#if     _INTEGRAL_MAX_BITS >= 64

struct _wfinddatai64_t {
        unsigned attrib;
        time_t   time_create;   /* -1 for FAT file systems */
        time_t   time_access;   /* -1 for FAT file systems */
        time_t   time_write;
        __int64  size;
        wchar_t  name[260];
};

struct __wfinddata64_t {
        unsigned attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#endif

#define _WFINDDATA_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


#ifndef _CTYPE_DISABLE_MACROS
_CRTIMP extern const unsigned short _ctype[];
_CRTIMP extern const unsigned short _wctype[];
#ifndef __PCTYPE_FUNC
#ifdef _MT
#define __PCTYPE_FUNC   __pctype_func()
#else
#define __PCTYPE_FUNC  _pctype
#endif  /* _MT */
#endif  /* __PCTYPE_FUNC */
_CRTIMP const unsigned short * __cdecl __pctype_func(void);
_CRTIMP const wctype_t * __cdecl __pwctype_func(void);
_CRTIMP extern const unsigned short *_pctype;
_CRTIMP extern const wctype_t *_pwctype;
#endif  /* _CTYPE_DISABLE_MACROS */


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wchar_t __cdecl towupper(wchar_t);
_CRTIMP wchar_t __cdecl towlower(wchar_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

/* --------- The following functions are OBSOLETE --------- */
_CRTIMP int __cdecl is_wctype(wint_t, wctype_t);
/*  --------- The preceding functions are OBSOLETE --------- */

#define _WCTYPE_DEFINED
#endif

#ifndef _WDIRECT_DEFINED

/* also declared in direct.h */

_CRTIMP int __cdecl _wchdir(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wgetcwd(wchar_t *, int);
_CRTIMP wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
_CRTIMP int __cdecl _wmkdir(const wchar_t *);
_CRTIMP int __cdecl _wrmdir(const wchar_t *);

#define _WDIRECT_DEFINED
#endif

#ifndef _WIO_DEFINED

/* also declared in io.h */

_CRTIMP int __cdecl _waccess(const wchar_t *, int);
_CRTIMP int __cdecl _wchmod(const wchar_t *, int);
_CRTIMP int __cdecl _wcreat(const wchar_t *, int);
_CRTIMP intptr_t __cdecl _wfindfirst(wchar_t *, struct _wfinddata_t *);
_CRTIMP int __cdecl _wfindnext(intptr_t, struct _wfinddata_t *);
_CRTIMP int __cdecl _wunlink(const wchar_t *);
_CRTIMP int __cdecl _wrename(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wopen(const wchar_t *, int, ...);
_CRTIMP int __cdecl _wsopen(const wchar_t *, int, int, ...);
_CRTIMP wchar_t * __cdecl _wmktemp(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP intptr_t __cdecl _wfindfirsti64(wchar_t *, struct _wfinddatai64_t *);
_CRTIMP intptr_t __cdecl _wfindfirst64(wchar_t *, struct __wfinddata64_t *);
_CRTIMP int __cdecl _wfindnexti64(intptr_t, struct _wfinddatai64_t *);
_CRTIMP int __cdecl _wfindnext64(intptr_t, struct __wfinddata64_t *);
#endif

#define _WIO_DEFINED
#endif

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP wchar_t * __cdecl _wsetlocale(int, const wchar_t *);

#define _WLOCALE_DEFINED
#endif

#ifndef _WPROCESS_DEFINED

/* also declared in process.h */

_CRTIMP intptr_t __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP intptr_t __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP intptr_t __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#ifndef __cplusplus
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#ifndef _CTYPE_DISABLE_MACROS
#define isleadbyte(_c)  ( __PCTYPE_FUNC[(unsigned char)(_c)] & _LEADBYTE)
#endif  /* _CTYPE_DISABLE_MACROS */

#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

#ifndef _CTYPE_DISABLE_MACROS
inline int __cdecl isleadbyte(int _C)
        {return (__PCTYPE_FUNC[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* _CTYPE_DISABLE_MACROS */
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */


#ifndef _POSIX_

/* define structure for returning status information */

#ifndef _INO_T_DEFINED
typedef unsigned short _ino_t;      /* i-node number (not used on DOS) */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif
#define _INO_T_DEFINED
#endif

#ifndef _DEV_T_DEFINED
typedef unsigned int _dev_t;        /* device code */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif
#define _DEV_T_DEFINED
#endif

#ifndef _OFF_T_DEFINED
typedef long _off_t;                /* file offset value */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif
#define _OFF_T_DEFINED
#endif

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__
/* Non-ANSI names for compatibility */
struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };
#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64

struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

struct __stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

#endif

#define _STAT_DEFINED
#endif


#ifndef _WSTAT_DEFINED

/* also declared in stat.h */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
_CRTIMP int __cdecl _wstat64(const wchar_t *, struct __stat64 *);
#endif

#define _WSTAT_DEFINED
#endif

#endif  /* !_POSIX_ */


#ifndef _WCONIO_DEFINED

_CRTIMP wchar_t * __cdecl _cgetws(wchar_t *);
_CRTIMP wint_t __cdecl _getwch(void);
_CRTIMP wint_t __cdecl _getwche(void);
_CRTIMP wint_t __cdecl _putwch(wchar_t);
_CRTIMP wint_t __cdecl _ungetwch(wint_t);
_CRTIMP int __cdecl _cputws(const wchar_t *);
_CRTIMP int __cdecl _cwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _cwscanf(const wchar_t *, ...);


#define _WCONIO_DEFINED
#endif

#ifndef _WSTDIO_DEFINED

/* also declared in stdio.h */

#ifdef  _POSIX_
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *);
#else
_CRTIMP FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#endif

_CRTIMP wint_t __cdecl fgetwc(FILE *);
_CRTIMP wint_t __cdecl _fgetwchar(void);
_CRTIMP wint_t __cdecl fputwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl _fputwchar(wchar_t);
_CRTIMP wint_t __cdecl getwc(FILE *);
_CRTIMP wint_t __cdecl getwchar(void);
_CRTIMP wint_t __cdecl putwc(wchar_t, FILE *);
_CRTIMP wint_t __cdecl putwchar(wchar_t);
_CRTIMP wint_t __cdecl ungetwc(wint_t, FILE *);
_CRTIMP wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
_CRTIMP int __cdecl fputws(const wchar_t *, FILE *);
_CRTIMP wchar_t * __cdecl _getws(wchar_t *);
_CRTIMP int __cdecl _putws(const wchar_t *);
_CRTIMP int __cdecl fwprintf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl wprintf(const wchar_t *, ...);
_CRTIMP int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _scwprintf(const wchar_t *, ...);
_CRTIMP int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
_CRTIMP int __cdecl vwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
_CRTIMP int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
_CRTIMP int __cdecl _vscwprintf(const wchar_t *, va_list);
_CRTIMP int __cdecl fwscanf(FILE *, const wchar_t *, ...);
_CRTIMP int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _snwscanf(const wchar_t *, size_t, const wchar_t *, ...);
_CRTIMP int __cdecl wscanf(const wchar_t *, ...);

#ifndef __cplusplus
#define getwchar()      fgetwc(stdin)
#define putwchar(_c)    fputwc((_c),stdout)
#else   /* __cplusplus */
inline wint_t __cdecl getwchar()
        {return (fgetwc(&_iob[0])); }   /* stdin */
inline wint_t __cdecl putwchar(wchar_t _C)
        {return (fputwc(_C, &_iob[1])); }       /* stdout */
#endif  /* __cplusplus */

#define getwc(_stm)     fgetwc(_stm)
#define putwc(_c,_stm)  fputwc(_c,_stm)

_CRTIMP FILE * __cdecl _wfdopen(int, const wchar_t *);
_CRTIMP FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
_CRTIMP FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
_CRTIMP void __cdecl _wperror(const wchar_t *);
_CRTIMP FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wremove(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wtmpnam(wchar_t *);


#define _WSTDIO_DEFINED
#endif


#ifndef _WSTDLIB_DEFINED

/* also declared in stdlib.h */

_CRTIMP wchar_t * __cdecl _itow (int, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ltow (long, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
_CRTIMP double __cdecl wcstod(const wchar_t *, wchar_t **);
_CRTIMP long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
_CRTIMP wchar_t * __cdecl _wgetenv(const wchar_t *);
_CRTIMP int    __cdecl _wsystem(const wchar_t *);
_CRTIMP double __cdecl _wtof(const wchar_t *);
_CRTIMP int __cdecl _wtoi(const wchar_t *);
_CRTIMP long __cdecl _wtol(const wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
_CRTIMP wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
_CRTIMP __int64   __cdecl _wtoi64(const wchar_t *);
_CRTIMP __int64   __cdecl _wcstoi64(const wchar_t *, wchar_t **, int);
_CRTIMP unsigned __int64  __cdecl _wcstoui64(const wchar_t *, wchar_t **, int);
#endif

#define _WSTDLIB_DEFINED
#endif

#ifndef _POSIX_

#ifndef _WSTDLIBP_DEFINED

/* also declared in stdlib.h  */

_CRTIMP wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
_CRTIMP void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
_CRTIMP void   __cdecl _wperror(const wchar_t *);
_CRTIMP int    __cdecl _wputenv(const wchar_t *);
_CRTIMP void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
_CRTIMP void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);

#define _WSTDLIBP_DEFINED
#endif

#endif  /* _POSIX_ */


#ifndef _WSTRING_DEFINED

/* also declared in string.h */

#ifdef  __cplusplus
        #define _WConst_return  const
#else
        #define _WConst_return
#endif

_CRTIMP wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
_CRTIMP int __cdecl wcscmp(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
_CRTIMP size_t __cdecl wcslen(const wchar_t *);
_CRTIMP wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
_CRTIMP _WConst_return wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
_CRTIMP size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
_CRTIMP _WConst_return wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcserror(int);
_CRTIMP wchar_t * __cdecl __wcserror(const wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsdup(const wchar_t *);
_CRTIMP int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl _wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl _wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl _wcsupr(wchar_t *);
_CRTIMP size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl wcscoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
_CRTIMP int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);

#if     !__STDC__

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_CRTIMP wchar_t * __cdecl wcsdup(const wchar_t *);
_CRTIMP int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
_CRTIMP int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
_CRTIMP wchar_t * __cdecl wcsrev(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
_CRTIMP wchar_t * __cdecl wcslwr(wchar_t *);
_CRTIMP wchar_t * __cdecl wcsupr(wchar_t *);
_CRTIMP int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#endif  /* !__STDC__ */

#ifdef  __cplusplus
}       /* end of extern "C" */

extern "C++" {
inline wchar_t *wcschr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcschr((const wchar_t *)_S, _C)); }
inline wchar_t *wcspbrk(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_S, _P)); }
inline wchar_t *wcsrchr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_S, _C)); }
inline wchar_t *wcsstr(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcsstr((const wchar_t *)_S, _P)); }
}

extern "C" {
#endif  /* __cplusplus */

#define _WSTRING_DEFINED
#endif

#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* also declared in time.h */

_CRTIMP wchar_t * __cdecl _wasctime(const struct tm *);
_CRTIMP wchar_t * __cdecl _wctime(const time_t *);
_CRTIMP size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
_CRTIMP wchar_t * __cdecl _wstrdate(wchar_t *);
_CRTIMP wchar_t * __cdecl _wstrtime(wchar_t *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP wchar_t * __cdecl _wctime64(const __time64_t *);
#endif

#define _WTIME_DEFINED
#endif



typedef int mbstate_t;
typedef wchar_t _Wint_t;

_CRTIMP2 wint_t __cdecl btowc(int);
_CRTIMP2 size_t __cdecl mbrlen(const char *, size_t, mbstate_t *);
_CRTIMP2 size_t __cdecl mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
_CRTIMP2 size_t __cdecl mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);

_CRTIMP2 size_t __cdecl wcrtomb(char *, wchar_t, mbstate_t *);
_CRTIMP2 size_t __cdecl wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
_CRTIMP2 int __cdecl wctob(wint_t);

#ifdef  __cplusplus

/* memcpy and memmove are defined just for use in wmemcpy and wmemmove */
#if     defined(_M_IA64)
void *  __cdecl memmove(void *, const void *, size_t);
#else
_CRTIMP void *  __cdecl memmove(void *, const void *, size_t);
#endif
void *  __cdecl memcpy(void *, const void *, size_t);

inline int fwide(FILE *, int _M)
        {return (_M); }
inline int mbsinit(const mbstate_t *_P)
        {return (_P == NULL || *_P == 0); }
inline const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (_S);
        return (0); }
inline int wmemcmp(const wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }
inline wchar_t *wmemcpy(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemmove(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
            return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));
        }
inline wchar_t *wmemset(wchar_t *_S, wchar_t _C, size_t _N)
        {wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
                *_Su = _C;
        return (_S); }
}       /* end of extern "C" */

extern "C++" {
inline wchar_t *wmemchr(wchar_t *_S, wchar_t _C, size_t _N)
        {return ((wchar_t *)wmemchr((const wchar_t *)_S, _C, _N)); }
}

#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\include\sys\stat.h ===
/***
*sys/stat.h - defines structure used by stat() and fstat()
*
*       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the _stat() and _fstat()
*       routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STAT
#define _INC_STAT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#include <sys/types.h>


#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64 time_t;         /* time value */
#else
typedef long    time_t;         /* time value */
#endif
#if     _INTEGRAL_MAX_BITS >= 64
typedef __int64 __time64_t;     /* 64-bit time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* define structure for returning status information */

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__

/* Non-ANSI names for compatibility */

struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64

struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

struct __stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

#endif

#define _STAT_DEFINED
#endif


#define _S_IFMT         0170000         /* file type mask */
#define _S_IFDIR        0040000         /* directory */
#define _S_IFCHR        0020000         /* character special */
#define _S_IFIFO        0010000         /* pipe */
#define _S_IFREG        0100000         /* regular */
#define _S_IREAD        0000400         /* read permission, owner */
#define _S_IWRITE       0000200         /* write permission, owner */
#define _S_IEXEC        0000100         /* execute/search permission, owner */


/* Function prototypes */

_CRTIMP int __cdecl _fstat(int, struct _stat *);
_CRTIMP int __cdecl _stat(const char *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _fstati64(int, struct _stati64 *);
_CRTIMP int __cdecl _fstat64(int, struct __stat64 *);
_CRTIMP int __cdecl _stati64(const char *, struct _stati64 *);
_CRTIMP int __cdecl _stat64(const char *, struct __stat64 *);
#endif

#ifndef _WSTAT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
_CRTIMP int __cdecl _wstat64(const wchar_t *, struct __stat64 *);
#endif

#define _WSTAT_DEFINED
#endif


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define S_IFMT   _S_IFMT
#define S_IFDIR  _S_IFDIR
#define S_IFCHR  _S_IFCHR
#define S_IFREG  _S_IFREG
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IEXEC  _S_IEXEC

_CRTIMP int __cdecl fstat(int, struct stat *);
_CRTIMP int __cdecl stat(const char *, struct stat *);

#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\tools\source\ifstrip\errormes.h ===
/***
*Errormes.h - Error / Warning reporting used by the ifstripper, parser and symbol table
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Error / Warning reporting used by the ifstripper, parser and symbol table
*
*Revision History:
*	??-??-88   PHG  Initial version
*
*******************************************************************************/

#ifndef ERRORMES_H
#define ERRORMES_H

/* error messages, parameters are strings holding the reason and text of the line that caused the error */
extern void error(char *, char *);

/* warning messages, parameters are strings holding the reason and text of the line that caused the error */
extern void warning(char *, char *);

extern FILE *errorfile;	/* file to output error/warning messages */

#endif /* ERRORMES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\tools\source\detab.c ===
/*
**	DETAB - replaces tabs with multiple spaces as appropriate
**		tab width defaults to 8 but may be anything
**		Steve Salisbury 1988-03-09 Wed
**
**	1989 Aug 30 Wed -- arg parsing was wrong
**	1989 Nov 01 Wed 12:00	add selection of non-space fill character
**	1991 Jan 14 Mon 18:20	fix selection of non-space fill character
**	1991 Jan 17 Thu 12:00	change message every 4KB to every 16KB
**				allow command line argument for input file
**				do not use big output buffer if stdout=con
**
**	cl -G2s -Oaltr detab.c -o detab.exr -link slibcr libh /nod:slibce;
**	cl detab -link slibcp libh /nod:slibce, detab;
*/

#include <fcntl.h>
#include <io.h>
#include <stdio.h>

#define SPACE	' '
#define TAB	'\t'
#define TABWIDTH 8

#define REG register

#define NEWLINE(c)  ( (c) == '\n' || (c) == '\r' || (c) == '\f' )

#ifndef BIGBUFSIZE
#define BIGBUFSIZE  8192
#endif

char	inbuf [ BIGBUFSIZE ] ;
char	outbuf [ BIGBUFSIZE ] ;

static	char	MsgInternalError [ ] = "detab: internal error: %s(%s)\n" ;
static	char	MsgOpenError [ ] = "detab: cannot open `%s' for input\n" ;
static	char	MsgWriteError [ ] = "detab: error writing to `%s'\n" ;
static	char	MsgStdin [ ] = "<stdin>" ;
static	char	MsgStdout [ ] = "<stdout>" ;
static	char	MsgSetmode [ ] = "setmode" ;
static	char	MsgSetvbuf [ ] = "setvbuf" ;

int main ( int argc , char * * argv )
{
REG int column ;
REG int ch ;
REG int spcount ;
    FILE * input ;
    char * MsgInput ;
    int tabwidth = TABWIDTH ;
    int countflag = 0 ;
    long kilobytes ;
    unsigned bytecount ;
    char * cp ;
    int FillChar = SPACE ;	/* default character to use when detabbing */

    while ( -- argc > 0 && * ( cp = * ++ argv ) == '-' )
    {
	++cp;
	while (*cp)
	{
	    if ( * cp == 'k' )
		++ countflag , ++ cp ;
	    else if ( '0' <= * cp && * cp <= '9' )
	    {
		tabwidth = * cp ++ - '0' ;
		while ( '0' <= * cp && * cp <= '9' )
		    tabwidth = 10 * tabwidth + * cp ++ - '0' ;
	    }
	    else if ( * cp == 'c' )
	    {
		FillChar = * ++ cp ;
		++ cp ;
	    }
	    else
	    {
Usage :
		fprintf ( stderr ,

"Usage: detab [-cX -k -###] [inputfile]\n"
"where ### is the number of colums per tab stop (default=8)\n"
"-k selects progress reports (written to stderr) every 16 Kbytes\n"
"and X is the character to use for tabs (default is space)\n"
) ;

		exit ( 1 ) ;
	    }
	}
    }

    if ( argc == 0 )
    {
	MsgInput = MsgStdin ;
	input = stdin ;

	if ( _setmode ( _fileno(stdin) , O_BINARY ) == -1 )
	{
	    fprintf ( stderr , MsgInternalError , MsgSetmode , MsgStdin ) ;
	    exit ( -1 ) ;
	}
    }
    else if ( argc == 1 )
    {
	MsgInput = * argv ;
	if ( ! ( input = fopen ( MsgInput , "rb" ) ) )
	{
	    fprintf ( stderr , MsgOpenError , MsgInput ) ;
	    exit ( 1 ) ;
	}
    }
    else
	goto Usage ;

    if ( setvbuf ( input , inbuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , MsgInternalError , MsgSetvbuf , MsgInput ) ;
	exit ( -1 ) ;
    }

    if ( _setmode ( _fileno(stdout) , O_BINARY ) == -1 )
    {
	fprintf ( stderr , MsgInternalError , MsgSetmode , MsgStdout ) ;
	exit ( -1 ) ;
    }

    if ( ! _isatty ( _fileno ( stdin ) )
      && setvbuf ( stdout , outbuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , MsgInternalError , MsgSetvbuf , MsgStdout ) ;
	exit ( -1 ) ;
    }

    kilobytes = bytecount = 0 ;

    column = 0 ;

    while ( ( ch = getc ( input ) ) != EOF )
    {
	if ( ch == TAB )
	{
	    do
		putchar ( FillChar ) ;
	    while ( ++ column < tabwidth ) ;
	    column = 0 ;
	}
	else {
	    putchar ( ch ) ;
	    if ( NEWLINE(ch) )
		column = 0 ;
	    else if ( ++ column == tabwidth )
		column = 0 ;
	    else if ( column > tabwidth )
	    {
		fprintf ( stderr , MsgInternalError , "" , "column>tabwidth" ) ;
		return 1 ;
	    }
	}

	if ( ++ bytecount >= 16384 )
	{
	    bytecount -= 16384 ;

	    if ( countflag )
		fprintf ( stderr , "%ldK\r" , kilobytes += 16 ) ;

            if ( ferror ( stdout) )
	    {
		fprintf ( stderr , MsgWriteError , MsgStdout ) ;
		return 1 ;
	    }
	}
    }

    if ( ferror ( stdout) || fflush ( stdout ) )
    {
	fprintf ( stderr , MsgWriteError , MsgStdout ) ;
	return 1 ;
    }

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\tools\source\ifstrip\constant.h ===
/***
*Constant.h - Constants used by the ifstripper, parser and symbol table
*
*	Copyright (c) 1992-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Constants used by the ifstripper, parser and symbol table
*
*Revision History:
*	09-30-92   MAL  Initial version
*
*******************************************************************************/

#ifndef CONSTANT_H
#define CONSTANT_H

#define TRUE  1
#define FALSE 0 		/* Boolean values */

#define IF          0           /* Tokens for preprocessor statements */
#define ELIF        1           /* These must not be re-ordered */
#define ELSE        2
#define ENDIF       3
#define IFDEF       4
#define IFNDEF      5
#define IF1         6
#define IF2         7
#define IFB         8
#define IFNB        9
#define IFIDN      10
#define IFDIF      11      /* CFW - added */
#define IFE        12      /* CFW - added */
#define maxkeyword 12
#define maxcomment  2      /* number of comment strings */
#define NORMAL    100
#define KEYWORD   101		/* Used only for skipto and copyto */

#define DEFINED    1
#define UNDEFINED  2
#define IGNORE     3
#define NOTPRESENT 4		/* Types of switches (symbols) */

#define MAXNAMELEN     65	/* Maximum length of a switch name */
#define MAXLINELEN    512	/* Maximum input line length */
#define MAXCONDLEN    512	/* Maximum length of a condition */
#define MAXFILENAMELEN 97	/* Maximum file name length */

#endif /* CONSTANT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\tools\source\trailing.c ===
/*
 *	Trailing - strip trailing tabs and blanks from input stream
 *	Assumes no sequence of tabs or spaces is more than MAXWHITE chars long.
 *	This filter also enforces that '\n' is preceeded by '\r'
 *
 *	Last Modified Mon 12 Oct 1987 by Steve Salisbury
 *	1988 Mar 09 Wed (SKS)	Reworked buffering, output counting
 *				check for buffer overflow
 *
 *	cl -Oaltr -G2s trailing.c -o trailing.exr -link slibcr libh /nod:slibce;
 *	cl trailing -link slibcp libh /nod:slibce, trailing;
 */

#define MAXWHITE	4096

#ifndef BIGBUFSIZE
#define BIGBUFSIZE	8192
#endif

#include <stdio.h>
#include <fcntl.h>

#define	REG	register

char InBuf [ BIGBUFSIZE ] ;
char OutBuf [ BIGBUFSIZE ] ;

char	Line [ MAXWHITE ] ;

int main ( int argc , char * * argv )
{
    FILE    * input ;
    FILE    * output ;
    char * inputname ;
    char * outputname ;
REG int     ch ;
REG char    * whiteptr ;
    int     ch_save ;
    int     kbytes = 0 ;
    int     numbytes = 0 ;
    int     countflag = 0 ;
    char    * arg ;

    if ( -1 == _setmode ( _fileno(stdin) , O_BINARY ) )
    {
	fprintf ( stderr , "trailing: internal error (setmode stdin)\n" ) ;
	exit ( 1 ) ;
    }

    if ( -1 == _setmode ( _fileno(stdout) , O_BINARY ) )
    {
	fprintf ( stderr , "trailing: internal error (setmode stdout)\n" ) ;
	exit ( 1 ) ;
    }

    -- argc ;
    ++ argv ;

    while ( argc > 0 && * * argv == '-' )
    {
	arg = * argv ++ ;
	-- argc ;

	while ( * ++ arg )
	    switch ( * arg )
	    {
	    case 'k' :
		countflag = 1 ;
		break ;
	    default :
		goto Usage;
	    }
    }

    if ( argc > 2 )
    {
Usage:
	fprintf ( stderr , "Usage: trailing [-k] [input [output]]\n" ) ;
	fprintf ( stderr , "`-' for input means use standard input\n" ) ;
	exit ( 1 ) ;
    }

    if ( argc >= 1 && strcmp ( argv [ 0 ] , "-" ) )
    {
	input = fopen ( inputname = argv [ 0 ] , "rb" ) ;
	if ( ! input )
	{
	    fprintf ( stderr , "trailing: cannot open `%s'\n" , argv [ 0 ] ) ;
	    exit ( 2 ) ;
	}
    }
    else
    {
	input = stdin ;
	inputname = "<standard input>" ;
    }

    if ( argc == 2 && strcmp ( argv [ 1 ] , "-" ) )
    {
	output = fopen ( outputname = argv [ 1 ] , "wb" ) ;
	if ( ! output )
	{
	    fprintf ( stderr , "trailing: cannot open `%s'\n" , argv [ 1 ] ) ;
	    exit ( 3 ) ;
	}
    }
    else
    {
	output = stdout ;
	outputname = "<standard output>" ;
    }

    if ( setvbuf ( input , InBuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , "trailing: internal error (setvbuf input)\n" ) ;
	exit ( 1 ) ;
    }

    if ( setvbuf ( output , OutBuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , "trailing: internal error (setvbuf output)\n" ) ;
	exit ( 1 ) ;
    }

    whiteptr = Line ;

    while ( ( ch = getc ( input ) ) != EOF )
    {
	if ( ch == '\r' )
	{
	    /*
	    ** '\r' followed by '\n' gets swallowed
	    */
	    if ( ( ch = getc ( input ) ) != '\n' )
	    {
		ungetc ( ch , input ) ; /* pushback */
		ch = '\r' ;
	    }
	    else
		++ numbytes ;
	}

	if ( ch == ' ' || ch == '\t' )
	{
	    * whiteptr ++ = ch ;
	    if ( whiteptr > Line + sizeof ( Line ) )
	    {
		fprintf ( stderr , "trailing: too many spaces/tabs (%d)\n" ,
		     whiteptr - Line ) ;
		exit ( 4 ) ;
	    }
	}
	else if ( ch == '\n' )
	{
	    putc ( '\r' , output ) ;
	    putc ( '\n' , output ) ;
	    whiteptr = Line ;
	}
	else
	{
	    if ( whiteptr != Line )
	    {
		/*
		 * Flush the white space buffer
		 */
		ch_save = ch ;
		ch = whiteptr - Line ;
		whiteptr = Line ;
		do
		    putc ( * whiteptr ++ , output ) ;
		while ( -- ch ) ;
		whiteptr = Line ;
		ch = ch_save ;
	    }
	    putc ( ch , output ) ;
	}

	if ( ++ numbytes >= 4096 )
	{
	    numbytes -= 4096 ;
	    if ( countflag )
		fprintf ( stderr , "%uK\r" , 4 * ++ kbytes ) ;
	}
    }

    if ( fflush ( output ) )
    {
	fprintf ( stderr , "trailing: cannot flush %s\n" , argv [ 1 ] ) ;
	exit ( 4 ) ;
    }

    fclose ( input ) ;
    fclose ( output ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\tools\source\aliasobj.c ===
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include <windows.h>

#include "prodids.h"
#include "version.h"


void
StoreName(PUCHAR sz, PIMAGE_SYMBOL psym, PULONG pcbStrings)
{
    memset((void *)&psym->N.Name, 0, (size_t)sizeof(psym->N.Name));
    if (strlen(sz) <= IMAGE_SIZEOF_SHORT_NAME) {
        strncpy((char *)psym->N.ShortName, (char *)sz, IMAGE_SIZEOF_SHORT_NAME);
    } else {
        psym->N.Name.Long = *pcbStrings;
        *pcbStrings += strlen(sz) + 1;
    }
}


int main(int argc, char **argv)
{
    PUCHAR szFrom, szTo, szFilename;
    FILE *pfile;
    IMAGE_FILE_HEADER hdr;
    IMAGE_SYMBOL sym;
    IMAGE_AUX_SYMBOL aux;
    ULONG cbStrings, foStringTable;
    IMAGE_SECTION_HEADER sec;
    DWORD dwProdid;

    if (argc != 4) {
        printf("usage: ALIASOBJ from-name to-name output-filename\n");
        exit(1);
    }
    szFrom = argv[1];
    szTo = argv[2];
    szFilename = argv[3];

    if ((pfile = fopen(szFilename, "wb")) == NULL) {
        printf("can't open file \"%s\"\n", szFilename);
        exit(1);
    }

    hdr.Machine = IMAGE_FILE_MACHINE_UNKNOWN;
    hdr.NumberOfSections = 1;
    hdr.TimeDateStamp = (DWORD) time(NULL);
    hdr.PointerToSymbolTable = sizeof(hdr) + sizeof(sec);
    hdr.NumberOfSymbols = 4;
    hdr.SizeOfOptionalHeader = 0;
    hdr.Characteristics = 0;

    fwrite(&hdr, sizeof(hdr), 1, pfile);

    // Generate one section header.  This is necessary because of a link bug (vce:182)
    // which fails for .obj's with 0 sections and unknown machine type.
    //
    memset(&sec, 0, sizeof(sec));
    strcpy(sec.Name, ".text");
    sec.Characteristics = IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_EXECUTE;
    fwrite(&sec, sizeof(sec), 1, pfile);

    cbStrings = sizeof(ULONG);  // make room for stringtab size

#if     (rmj == 7) && (rmm == 0)

    dwProdid = DwProdidFromProdidWBuild(prodidAliasObj70, rup);

#else

#error  PRODID needs to be assigned

#endif

    memset(sym.N.ShortName, 0, sizeof(sym.N.ShortName));
    strncpy((char *) sym.N.ShortName, symProdIdentName, IMAGE_SIZEOF_SHORT_NAME);
    sym.Value = dwProdid;
    sym.SectionNumber = symProdIdentSection;
    sym.Type = IMAGE_SYM_TYPE_NULL;
    sym.StorageClass = symProdIdentClass;
    sym.NumberOfAuxSymbols = 0;
    fwrite(&sym, sizeof(sym), 1, pfile);

    StoreName(szTo, &sym, &cbStrings);
    sym.Value = 0;
    sym.SectionNumber = IMAGE_SYM_UNDEFINED;
    sym.Type = IMAGE_SYM_TYPE_NULL;
    sym.StorageClass = IMAGE_SYM_CLASS_EXTERNAL;
    sym.NumberOfAuxSymbols = 0;
    fwrite(&sym, sizeof(sym), 1, pfile);

    StoreName(szFrom, &sym, &cbStrings);
    sym.Value = 0;
    sym.SectionNumber = IMAGE_SYM_UNDEFINED;
    sym.Type = IMAGE_SYM_TYPE_NULL;
    sym.StorageClass = IMAGE_SYM_CLASS_WEAK_EXTERNAL;
    sym.NumberOfAuxSymbols = 1;
    fwrite(&sym, sizeof(sym), 1, pfile);

    memset(&aux, 0, sizeof(aux));
    aux.Sym.Misc.TotalSize = IMAGE_WEAK_EXTERN_SEARCH_ALIAS;
    aux.Sym.TagIndex = 1;               // symtab index for extern
    fwrite(&aux, sizeof(aux), 1, pfile);

    // Write the string table.
    //
    foStringTable = ftell(pfile);
    fwrite(&cbStrings, sizeof(cbStrings), 1, pfile);
    if (strlen(szTo) > IMAGE_SIZEOF_SHORT_NAME) {
        fputs(szTo, pfile);
        fputc(0, pfile);
    }
    if (strlen(szFrom) > IMAGE_SIZEOF_SHORT_NAME) {
        fputs(szFrom, pfile);
        fputc(0, pfile);
    }
    assert(ftell(pfile) - foStringTable == cbStrings);

    fclose(pfile);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\tools\source\tolwrupr.c ===
/*
**  TOLWRUPR - translate [a-z] to [A-Z] or vice versa or both (!)
**
**	1994-08-19 Fri - original version, based on DTOX, which translated
**		If the output is the console, case line buffering is used.
**		CR+LF newlines (MS-DOS) to LF-only newlines (XENIX).
**
**	This program (tolwrupr) is equivalent to:
**
**		tolwrupr -L:	tr "[a-z]" "[A-Z]"
**		tolwrupr -U:	tr "[A-Z]" "[a-z]"
**		tolwrupr -X:	tr "[A-Z][a-z]" "[a-z][A-Z]"
*/

#include <fcntl.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>

#define CR	'\r'
#define LF	'\n'

#define REG register

#ifndef BIGBUFSIZE
#define BIGBUFSIZE  16384
#endif

char	inbuf [ BIGBUFSIZE ] ;
char	outbuf [ BIGBUFSIZE ] ;

int LineBuf;

static	char	MsgInternalError [ ] = "tolwrupr: internal error: %s(%s)\n" ;
static	char	MsgOpenError [ ] = "tolwrupr: cannot open `%s' for input\n" ;
static	char	MsgStdin [ ] = "stdin" ;
static	char	MsgStdout [ ] = "stdout" ;
static	char	MsgSetmode [ ] = "setmode" ;
static	char	MsgSetvbuf [ ] = "setvbuf" ;
static	char	MsgFflush [ ] = "fflush" ;

static unsigned char map [ 256 ] ;


int main ( int argc , char * * argv ) ;

void Usage ( void ) ;


int main ( int argc , char * * argv )
{
REG int ch ;
    int countflag = 0 ;
    int toupperflag = -1 ;
    unsigned kilobytes ;
    unsigned bytecount ;
    char * MsgInput ;
    FILE * input ;
    char * cp ;

    -- argc ;
    ++ argv ;

    while ( argc > 0 && * ( cp = * argv ) == '-' )
    {
	while ( * ++ cp )
	{
	    if ( * cp == 'k' )
	    {
	        if ( countflag != 0 )
		    Usage ( ) ;

	        countflag = 1 ;
	    }
	    else if ( * cp == 'L' )
	    {
	        if ( toupperflag != -1 )
		    Usage ( ) ;

		toupperflag = 0 ;
	    }
	    else if ( * cp == 'U' )
	    {
	        if ( toupperflag != -1 )
		    Usage ( ) ;

		toupperflag = 1 ;
	    }
	    else if ( * cp == 'X' )
	    {
	        if ( toupperflag != -1 )
		    Usage ( ) ;

		toupperflag = 2 ;
	    }
	    else
	    {
		Usage ( ) ;
	    }
	}

	-- argc ;
	++ argv ;
    }

    /*
     * Either -U or -L must be specified!
     */

    if ( toupperflag == -1 )
	Usage ( ) ;

    for ( ch = 0 ; ch < 256 ; ++ ch )
	map [ ch ] = ch ;

    /*
     * Set the case map
     */

    if ( toupperflag == 1 || toupperflag == 2 )
    {
    	for ( ch = 'a' ; ch <= 'z' ; ++ ch )
	    map [ ch ] -= 'a' - 'A' ;
    }

    if ( toupperflag == 0 || toupperflag == 2 )
    {
    	for ( ch = 'A' ; ch <= 'Z' ; ++ ch )
	    map [ ch ] += 'a' - 'A' ;
    }


    /*
     * Open the Input
     */

    if ( argc == 0 )
    {
	MsgInput = MsgStdin ;
	input = stdin ;

	if ( _setmode ( _fileno(stdin) , _O_BINARY ) == -1 )
	{
	    fprintf ( stderr , MsgInternalError , MsgSetmode , MsgStdin ) ;
	    exit ( -1 ) ;
	}
    }
    else if ( argc == 1 )
    {
	MsgInput = * argv ;
	if ( ! ( input = fopen ( MsgInput , "rb" ) ) )
	{
	    fprintf ( stderr , MsgOpenError , MsgInput ) ;
	    exit ( 1 ) ;
	}
    }
    else
	Usage ( ) ;

    if ( _setmode ( _fileno ( stdout ) , _O_BINARY ) == -1 )
    {
	fprintf ( stderr , MsgInternalError , MsgSetmode , MsgStdout ) ;
	exit ( -1 ) ;
    }

    if ( setvbuf ( input , inbuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , MsgInternalError , MsgSetvbuf , MsgInput ) ;
	exit ( -1 ) ;
    }

    if ( setvbuf ( stdout , outbuf , _IOFBF , BIGBUFSIZE ) )
    {
	fprintf ( stderr , MsgInternalError , MsgSetvbuf , MsgStdout ) ;
	exit ( -1 ) ;
    }

    /* check for the need for line buffering */

    LineBuf = _isatty ( _fileno ( stdout ) ) ;

    /*
     * Process the Input
     */

    kilobytes = bytecount = 0 ;

    while ( ( ch = getc ( input ) ) != EOF )
    {
	ch = map [ ch ] ;

	putc ( ch , stdout ) ;

	if (ch == '\n' && LineBuf)
	    fflush ( stdout ) ;
	
	if ( countflag )
	    if ( ++ bytecount >= BIGBUFSIZE )
	    {
		bytecount -= BIGBUFSIZE ;
		fprintf ( stderr , "%uK\r" , kilobytes += ( BIGBUFSIZE / 1024 ) ) ;
	    }
    }

    if ( fflush ( stdout ) )
    {
	fprintf ( stderr , MsgInternalError , MsgFflush , MsgStdout ) ;
	return 1 ;
    }

    return 0 ;
}


void Usage ( void )
{
    fprintf ( stderr ,
	"Usage: tolwrupr [-k] -(L|U|X) [ <InputFile> ]\n"
	"-k means echo progress in kilobytes to stderr\n"
	"-L means map lowercase characters to uppercase (tr \"[A-Z]\" \"[a-z]\")\n"
	"-U means map uppercase characters to lowercase (tr \"[a-z]\" \"[A-Z]\")\n"
	"-X means swap uppercase and lowercase (tr \"[a-z][A-Z]\" \"[A-Z][a-z]\")\n"
	"Exactly one of -L or -U or -X must be specified\n"
	) ;

    exit ( 1 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\tools\source\pd.c ===
/*
 * Program:	Recursive Directory listing
 * Author:	Steve Salisbury
 *
 * Last Modified:
 *
 *	1995-03-08 Wed 16:00 PST
 *	**** >>>> Ported to Win32 <<<< ****
 */

#ifdef _WIN32
#define WIN32
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>


#ifdef _DEBUG
int DebugFlag ;
#define	DEBUG(n,x)	if ( DebugFlag & n ) printf x;
#else
#define	DEBUG(n,x)
#endif


#define ISSLASH(ch)	((ch) == '/' || (ch) == '\\')

#define	BL	' '
#define	NAMLEN	8
#define	EXTLEN	3

typedef unsigned char uchar ;
typedef unsigned short ushort ;
typedef unsigned int uint ;
typedef unsigned long ulong ;

#define	ATTRIB_READONLY		0x01
#define	ATTRIB_HIDDEN		0x02
#define	ATTRIB_SYSTEM		0x04
#define	ATTRIB_VOLUMELABEL	0x08
#define	ATTRIB_DIRECTORY	0x10
#define	ATTRIB_ARCHIVE		0x20

#define	ATTRIB_ALL	( ATTRIB_HIDDEN | ATTRIB_SYSTEM | ATTRIB_DIRECTORY )



void PrintFile ( WIN32_FIND_DATA * match ) ;

#define	MAXPATHLENGTH	(_MAX_PATH+4)

char	path [ MAXPATHLENGTH ] ;

char	current_dir [ MAXPATHLENGTH ] ;	/* Current Directory */

int	pathlength ;

uint	clustersize ;
uint	sectorsize ;
uint	availclusters ;
uint	totalclusters ;

int 	numfiles ;
int 	numdirs ;
long	numbytes ;
long	numclusters ;

uint	NewClusterSize ;	/* override actual cluster size */
uint	NewSectorSize ;		/* override actual sector size */

int 	maxwidth = 71 ;	/* Maximum width of an output line */

char	totalstring [] =
	"[ %s files, %s sub-dirs, %s bytes (%s allocated) ]\n" ;

int 	AltNameFlag ;		/* If non-zero, echo 8.3 names as well */
int 	DirOnlyFlag ;		/* If non-zero, only directories are listed */
int 	FileOnlyFlag ;		/* If non-zero, only files are listed */
int		TerseFlag ;			/* If non-zero, output is very terse */
int 	SummaryOnlyFlag ;	/* If non-zero, output ONLY summary information */
int 	NoSummaryFlag ;		/* If non-zero, do not output summary information */

uint	Exclude ;		/* file attributes to excluded from display */
uint	Require ;		/* file attributes to be required for display */


char * VolumeLabel ( char * driveString , unsigned * serialNum ) ;
void PrintDir ( void ) ;
void PrintFile ( WIN32_FIND_DATA * match ) ;
int get_drive ( void ) ;
void get_dir ( char * buffer , int drive ) ;
int get_free ( char * driveString , uint * availp , uint * secsizep , uint * totalp ) ;
char * PrintWithCommas ( unsigned n ) ;


int main ( int argc , char * * argv )
{
	char	* ap ;		/* ap = *argv when parsing the switch args */
	char	* volume ;
	int 	drive = get_drive ( ) ;
	char	driveString [ _MAX_PATH ] ;
	uint	serialNum ;

	++ argv , -- argc ;

#ifdef _DEBUG
	if ( argc > 0 && argv [ 0 ] [ 0 ] == '-' && argv [ 0 ] [ 1 ] == 'D' )
	{
		char * endptr ;

		DebugFlag = strtoul ( argv [ 0 ] + 2 , & endptr , 0 ) ;
		printf("DebugFlag = 0x%x (%s)\n" , DebugFlag , * argv ) ;

		++ argv , -- argc ;
	}
#endif

	while ( argc > 0 && * ( ap = * argv ) == '-' )
	{
		while ( * ++ ap )
			if ( * ap == 'a' )
			{
				int flag ;

				if ( * ++ ap != '-' && * ap != '=' )
					goto Usage ;

				flag = * ap ;
				while ( * ++ ap )
				{
					if ( * ap == 'a' || * ap == 'A' )
						if ( flag == '-' )
							Exclude |= ATTRIB_ARCHIVE ;
						else
							Require |= ATTRIB_ARCHIVE ;
					else if ( * ap == 'r' || * ap == 'R' )
						if ( flag == '-' )
							Exclude |= ATTRIB_READONLY ;
						else
							Require |= ATTRIB_READONLY ;
					else if ( * ap == 'h' || * ap == 'H' )
						if ( flag == '-' )
							Exclude |= ATTRIB_HIDDEN ;
						else
							Require |= ATTRIB_HIDDEN ;
					else if ( * ap == 's' || * ap == 'S' )
						if ( flag == '-' )
							Exclude |= ATTRIB_SYSTEM ;
						else
							Require |= ATTRIB_SYSTEM ;
					else if ( * ap == '-' || * ap == '=' )
						flag = * ap ;
					else
						goto Usage ;
				}
				
				-- ap ;
			}
			else if ( * ap == 'c' )
			{	/* Use alternate cluster size */
				while ( isdigit ( * ++ ap ) )
					NewClusterSize = NewClusterSize * 10 + * ap - '0' ;
				printf ( "New ClusterSize = %u\n" , NewClusterSize ) ;
				-- ap ;
			}
			else if ( * ap == 'd' )
				/* Print directories but not files */
				++ DirOnlyFlag ;
			else if ( * ap == 'f' )
				/* Print directories but not files */
				++ FileOnlyFlag ;
			else if ( * ap == 's' )
			{	/* Use alternate sector size */
				while ( isdigit ( * ++ ap ) )
					NewSectorSize = NewSectorSize * 10 + * ap - '0' ;
				printf ( "NewSectorSize = %u\n" , NewSectorSize ) ;
				-- ap ;
			}
			else if ( * ap == 'z' )
				/* Display ONLY summary info. */
				++ SummaryOnlyFlag ;
			else if ( * ap == 'Z' )
				/* Display no summary info. */
				++ NoSummaryFlag ;
			else if ( * ap == 't' )
				/* Only file/dir names in output */
				++ TerseFlag ;
			else if ( * ap == 'x' )
				/* Show 8.3 names */
				++ AltNameFlag ;
			else
				goto Usage ;
		-- argc ;
		++ argv ;
	}

	if ( argc > 1 )
	{
Usage:
		puts (
#ifdef _DEBUG
			"usage: pd [-D#] [ -dftxzZ -a-* -a=* -s# -c# ] [path]\n"
#else
			"usage: pd "    "[ -dftxzZ -a-* -a=* -s# -c# ] [path]\n"
#endif

			"\twhere path is an optional Path to a directory\n"
#ifdef _DEBUG
			"\t`-D#' means print debugging information (# is a number\n"
			"\t\twhich is interpreted as a bit mask for debug info.)\n"
#endif
			"\t`-d' means print only directory names\n"
			"\t`-f' means print only file names\n"
			"\t`-t' means terse output (only file/directory name)\n"
			"\t`-x' means show 8.3 alternate names after long filenames\n"
			"\t`-z' means output only summary information\n"
			"\t`-Z' means do not output any summary information\n"
			"\t`-a-* means exclude files with attribute(s) * (out of ARHS)\n"
			"\t`-a=* means show only files with attribute(s) *\n"
			"\t        the possible attributes are ARHS\n"
			"\t`-c#' sets logical cluster size to # sectors\n"
			"\t`-s#' sets logical sector size to # bytes\n"
			) ;
		exit ( 1 ) ;
	}

	path [ 0 ] = drive + '@' ;
	path [ 1 ] = ':' ;
	path [ 2 ] = '\\' ;
	path [ 3 ] = '\0' ;

	strcpy ( driveString , path ) ;

	if ( argc == 1 )
	{
		char * arg = argv [ 0 ] ;

		if ( isalpha ( arg [ 0 ] ) && arg [ 1 ] == ':' )
		{
			drive = toupper ( * arg ) ;

			if ( isalpha ( drive ) )
				drive -= 'A' - 1 ;
			else
			{
				fprintf ( stderr , "pd: expected alphabetic character before :\n\t%s\n" , arg ) ;
				exit ( 1 ) ;
			}

			driveString [ 0 ] = path [ 0 ] = * arg ;

			if ( arg [ 2 ] )
				/* Specified Directory & Directory */
				strcpy ( path + 2 , arg + 2 ) ;
			else	/* Specified Drive, Current Directory */
				get_dir ( path + 3 , drive ) ;
		}
		else if ( ISSLASH ( arg [ 0 ] ) && ISSLASH ( arg [ 1 ] ) )
		{
			int n = 2 ;

			/*-
			 * Find the slash that terminates the server name
			-*/

			while ( arg [ n ] && ! ISSLASH ( arg [ n ] ) )
				++ n ;

			if ( ! arg [ n ] )
			{
				fprintf ( stderr , "pd: expected server name plus share point:\n\t%s\n" , * argv ) ;
				exit ( 1 ) ;
			}

			++ n ;

			/*-
			 * Find the slash that terminates the share point
			-*/

			while ( arg [ n ] && ! ISSLASH ( arg [ n ] ) )
				++ n ;

			if ( ! arg [ n ] )
			{
				fprintf ( stderr , "pd: expected share point name after server name:\n\t%s\n" , * argv ) ;
				exit ( 1 ) ;
			}

			++ n ;

			strcpy ( path , arg ) ;
			strcpy ( driveString , arg ) ;
			driveString [ n ] = '\0' ;
		}
		else	/* Current Drive, Specified Directory */
			strcpy ( path + 2 , arg ) ;
	}
	else	/* Current Drive & Directory */
		get_dir ( path + 3 , drive ) ;

	DEBUG(1, ("path = \"%s\"\n",path))
	DEBUG(1, ("driveString = \"%s\"\n",driveString))

	volume = VolumeLabel ( driveString , & serialNum ) ;

	if ( ! NoSummaryFlag )
	{
		printf ( "Directory %s  " , path ) ;

		if ( * volume )
			printf ( "(Volume = \"%s\", %04X-%04X)\n" , volume ,
					( serialNum >> 16 ) & 0xFFFF , serialNum & 0xFFFF ) ;
		else
			printf ( "(No Volume Label, %04X-%04X)\n" ,
					( serialNum >> 16 ) & 0xFFFF , serialNum & 0xFFFF ) ;
	}
	
	clustersize = get_free ( driveString , & availclusters , & sectorsize ,
		& totalclusters ) ;

	if ( NewClusterSize )
		clustersize = NewClusterSize ;

	if ( NewSectorSize )
		sectorsize = NewSectorSize ;

	if ( ! sectorsize )
	{
		fprintf ( stderr , "pd: warning: assuming 512 bytes/sector.\n" ) ;
		sectorsize = 512 ;
	}

	if ( ! clustersize )
	{
		fprintf ( stderr , "pd: warning: assuming 1 sector/cluster.\n" ) ;
		clustersize = 1 ;
	}

	pathlength = strlen ( path ) ;

	if ( path [ pathlength - 1 ] == '\\' )
		-- pathlength ;	/* Make "\" visible but not present */

	PrintDir ( ) ;

	if ( ! NoSummaryFlag )
		printf ( totalstring , PrintWithCommas ( numfiles ) ,
			PrintWithCommas ( numdirs ) ,
			PrintWithCommas ( numbytes ) ,
			PrintWithCommas ( numclusters * clustersize *
				sectorsize ) ) ;

	return 0 ;
}


/*
 * VolumeLabel -
 *	Get the volume Label
 *	This routine may NOT return NULL
 */

static	char	volume [ _MAX_PATH ] = "12345678901" ;

char * VolumeLabel ( char * driveString , unsigned * pSerialNumber )
{
	uint MaxCompLength ;
	uint FSflags ;

	if ( ! GetVolumeInformation ( driveString , volume , sizeof ( volume ) ,
		pSerialNumber , & MaxCompLength , & FSflags , NULL , 0 ) )
	{
		fprintf ( stderr , "pd: unexpected error (%d) from GetVolumeInformation(%s)\n" ,
			GetLastError() , driveString ) ;

		exit ( 1 ) ;
	}

	DEBUG(2, ("%s: \"%s\" : %04X-%04X; %d c; 0x%X\n",driveString,volume,
		(*pSerialNumber>>16)&0xFFFF,*pSerialNumber&0xFFFF,FSflags))

	return volume ;
}


/*
 * PrintDir -
 *	Print all the files in the current directory
 *	Then recursively print the sub-directories
 *	Ignore the "." and ".." special entries
 */

void PrintDir ( void )
{
	WIN32_FIND_DATA	match ;
	HANDLE handle ;
	int	flag ;

	path [ pathlength ] = '\\' ;
	path [ pathlength + 1 ] = '*' ;
	path [ pathlength + 2 ] = '\0' ;

	handle = FindFirstFile ( path , & match ) ;
	flag = handle != INVALID_HANDLE_VALUE ;

	DEBUG(4, ("PrintDir - opening handle %08X (files)\n",handle))

	path [ pathlength ] = '\0' ;	/* Truncate to original path */

	while ( flag )
	{
		DEBUG(4, ("PrintDir - FindFirst/NextFile(\"%s\") (files)\n",match.cFileName))

		/* Print everything in the directory except "." and ".." */
		if ( ATTRIB_DIRECTORY & ~ match . dwFileAttributes )
			PrintFile ( & match ) ;

		flag = FindNextFile ( handle , & match ) ;
	}

	FindClose ( handle ) ;
	DEBUG(4, ("PrintDir - closing handle %08X (files)\n",handle))

	path [ pathlength ] = '\\' ;	/* Restore to "...\*" */

	handle = FindFirstFile ( path , & match ) ;
	flag = handle != INVALID_HANDLE_VALUE ;

	DEBUG(8, ("PrintDir - opening handle %08X (dirs)\n",handle))

	path [ pathlength ] = '\0' ;	/* Truncate to original path */

	while ( flag )
	{
		char	* cp ;
		int	lensave ;

		DEBUG(8, ("PrintDir - FindFirst/NextFile(\"%s\") (dirs)\n",match.cFileName))

		/* Find all sub-directories except "." and ".." */

		if ( ( match . dwFileAttributes & ATTRIB_DIRECTORY )
		  && strcmp ( match . cFileName , "." )
		  && strcmp ( match . cFileName , ".." ) )
		{
			PrintFile ( & match ) ;

			cp = match . cFileName ;
			lensave = pathlength ;

			/* Add "\dirname" to the current Path */

			path [ pathlength ++ ] = '\\' ;

			while ( path [ pathlength ] = * cp ++ )
				++ pathlength ;

			PrintDir ( ) ;

			path [ pathlength = lensave ] = '\0' ;
		}

		flag = FindNextFile ( handle , & match ) ;
	}

	FindClose ( handle ) ;
	DEBUG(8, ("PrintDir - closing handle %08X (dirs)\n",handle))
}


/* static	char *	months [ ] = {
/*	"?00" , "Jan" , "Feb" , "Mar" , "Apr" , "May" , "Jun" , "Jul" ,
/*	"Aug" , "Sep" , "Oct" , "Nov" , "Dec" , "?13" , "?14" , "?15" } ;
 */

/* static	char *	weekdays [ ] = {
/*	"Sun" , "Mon" , "Tue" , "Wed" , "Thu" , "Fri" , "Sat" } ;
 */

static	char	monthstarts [ ] =
	/**** Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec */
	{ -1 , 0 , 3 , 3 , 6 , 1 , 4 , 6 , 2 , 5 , 0 , 3 , 5 , -1 , -1 , -1 } ;


/*
 * PrintFile -
 *	Print the information for the file described in "match"
 */

void PrintFile ( WIN32_FIND_DATA * match )
{
	int	year , month , day /* , wkday */ ;
	int	hour , minute , second ;
	long sec , clu ;
	char sizebuf [ 12 ] ;	/* Either size of file or else "****DIR****" */
	FILETIME lftime ;
	SYSTEMTIME systime ;

	/*
	 * If only directories are to be shown, do not list files
	 * and if only files are to be shown, do not list directories
	 */

	if ( ( DirOnlyFlag  && ! ( match -> dwFileAttributes & ATTRIB_DIRECTORY ) )
	||   ( FileOnlyFlag &&	 ( match -> dwFileAttributes & ATTRIB_DIRECTORY ) ) )
		return ;

	/*
	** Check the attribute filters
	*/

	if ( ( match -> dwFileAttributes & Exclude )
	|| ( match -> dwFileAttributes & Require ) != Require )
		return ;

	/*
	** At this point, count this file and its bytes
	*/

	if ( match -> dwFileAttributes & ATTRIB_DIRECTORY )
		++ numdirs ;
	else
		++ numfiles ;

	sec = ( match -> nFileSizeLow + sectorsize - 1 ) / sectorsize ;
	clu = ( sec + clustersize - 1 ) / clustersize ;

	numbytes += match -> nFileSizeLow ;
	numclusters += clu ;

	if ( SummaryOnlyFlag )
		return ;

	FileTimeToLocalFileTime ( & match -> ftLastWriteTime , & lftime ) ;
	FileTimeToSystemTime ( & lftime , & systime ) ;

	year = systime . wYear ;
	month = systime . wMonth ;
	day = systime . wDay ;
	hour = systime . wHour ;
	minute = systime . wMinute ;
	second = systime . wSecond ;

	/*
	 * 1980 Jan 01 was a Tuesday (2):
	 *	Add in the day of the month and the month offsets
	 *	Add 1 day for each year since 1980
 	 *	Add 1 for each leap year since 1980
	 */

/*	wkday = 2 + ( day - 1 ) + monthstarts [ month ] +
/*		/* year + leap years before the most recent */
/*		( year - 1980 ) + ( ( year - 1980 ) >> 2 ) +
/*		/* Add in the most recent leap day */
/*		( ( ( year & 3 ) != 0 || month > 2 ) ? 1 : 0 ) ;
/*	wkday %= 7 ;
 */

	if ( TerseFlag )
		printf ( "%s\\%s%s\n" ,
			path , match->cFileName ,
			match -> dwFileAttributes & ATTRIB_DIRECTORY ? "\\" : "" ) ;
	else
	{
		char altbuf [ 24 ] ;	/* used to display alternate (8.3) name */

		if ( match -> dwFileAttributes & ATTRIB_DIRECTORY )
			strcpy ( sizebuf , "****DIR****" ) ;
		else if ( match -> nFileSizeLow <= 999999999L )
			strcpy ( sizebuf , PrintWithCommas ( match -> nFileSizeLow ) ) ;
		else	/* File too big for 9 digits */
			sprintf ( sizebuf , "%s K" , PrintWithCommas ( ( match -> nFileSizeLow + 1023 ) / 1024 ) ) ;

		if ( AltNameFlag && * match -> cAlternateFileName )
			sprintf ( altbuf , "  [%s]" , match->cAlternateFileName ) ;
		else
			altbuf [ 0 ] = '\0' ;

		printf ( "%11s %04d-%02d-%02d %02d:%02d:%02d %c%c%c%c  %s\\%s%s%s\n" ,
			sizebuf , year , month , day , hour , minute , second ,
			match -> dwFileAttributes & ATTRIB_ARCHIVE  ? 'A' : '-' ,
			match -> dwFileAttributes & ATTRIB_READONLY ? 'R' : '-' ,
			match -> dwFileAttributes & ATTRIB_HIDDEN ? 'H' : '-' ,
			match -> dwFileAttributes & ATTRIB_SYSTEM ? 'S' : '-' ,
			path , match->cFileName ,
			match -> dwFileAttributes & ATTRIB_DIRECTORY ? "\\" : "" ,
			altbuf ) ;
	}
}

/*
 * Return the Current Disk Drive (1=A, 2=B, etc.)
 *	Note that DOS uses (0=A,1=B, etc.) for this call
 */

int get_drive ( void )
{
	char CurDir [ _MAX_PATH + 4 ] ;
	int lenCurDir = _MAX_PATH ;
	int drive ;

	if ( ! GetCurrentDirectory ( lenCurDir , CurDir ) )
	{
		fprintf ( stderr , "pd: unexpected error (%d) from GetCurrentDirector\n" ,
			GetLastError() ) ;

		exit ( 1 ) ;
	}

	drive = toupper ( CurDir [ 0 ] ) - ( 'A' - 1 ) ;

	DEBUG(1, ("get_drive => %d (%c:)\n", drive , CurDir [ 0 ]))

	return drive ;
}


/*
 * Store the Current Directory in the given char buffer
 *	The leading "\" in the path is not stored.
 *	The string is terminated by a null.
 */

void get_dir ( char * buffer , int drive )
{
	char CurDir [ _MAX_PATH + 4 ] ;
	int lenCurDir = _MAX_PATH ;

	if ( ! GetCurrentDirectory ( lenCurDir , CurDir ) )
	{
		fprintf ( stderr , "pd: unexpected error (%d) from GetCurrentDirectory\n" ,
			GetLastError() ) ;

		exit ( 1 ) ;
	}

	strcpy ( buffer , CurDir + 3 ) ;
	DEBUG(1, ("get_dir => \"%s\"\n", buffer ))
}


/*
 * get_free - returns the number of sectors per cluster
 *	and stores the number of available clusters,
 *	the size of a sector (in bytes), and the total
 *	number of clusters on the current drive 
 */

int get_free ( char * driveString , uint * availp , uint * secsizep , uint * totalp )
{
	unsigned int SectorsPerCluster , BytesPerSector , FreeClusters , Clusters ;

	if ( ! GetDiskFreeSpace ( driveString , & SectorsPerCluster ,
		& BytesPerSector , & FreeClusters , & Clusters ) )
	{
		fprintf ( stderr , "pd: unexpected error (%d) from GetDiskFreeSpace ( %s )\n" ,
				GetLastError() , driveString ) ;

		exit ( 1 ) ;
	}

	* availp = FreeClusters ;
	* totalp = Clusters ;
	* secsizep = BytesPerSector ;

	DEBUG(1, ("get_free => Clusters %d/%d, %d * %d\n",*availp,*totalp,*secsizep,SectorsPerCluster))

	return SectorsPerCluster ;
}


char * PrintWithCommas ( unsigned n )
{
static char buffers [ 16 ] [ 16 ] ;
static int bufnumber ;
	char * p = buffers [ bufnumber ++ % 16 ] ;

	if ( n <= 999 )
		sprintf ( p , "%d" , n ) ;
	else if ( n <= 999999 )
		sprintf ( p , "%d,%03d" , n / 1000 , n % 1000 ) ;
	else if ( n <= 999999999 )
		sprintf ( p , "%d,%03d,%03d" , n / 1000000 , n / 1000 % 1000 , n % 1000 ) ;
	else
		sprintf ( p , "%d,%03d,%03d,%03d" , n / 1000000000 , n / 1000000 % 1000 , n / 1000 % 1000 , n % 1000 ) ;

	return p ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\tools\source\wsfdiff.cpp ===
#include <windows.h>
#include <stdio.h>
#include <string>
#include <set>
#include <iostream>
#include <algorithm>
#include <dbghelp.h>

#define F_USE_USH_NAME  0x000001
#define F_OUT_DIFF      0x000002
#define F_OUT_USH       0x000004
#define F_OUT_WCH       0x000008
#define F_OUT_IDEN      0x000010
#define F_OUT_DNAME     0x000020
#define F_OUT_ALL       0x00001e
using namespace std;

int flags = 0;

enum Ext { none, lib, dll};
char tmp[512];

Ext FindExt(const char *Fname)
{
    Fname = strrchr(Fname, '.');
    if ( Fname == NULL)
        return none;
    else if ( !stricmp(Fname, ".Lib"))
         return lib;
    else if ( !stricmp(Fname, ".Dll"))
        return dll;
    else
        return none;
}


char *filter(char* ch, Ext fext)
{
    char *str = strchr(ch, '?');
    return str == NULL ? ch: str;
}


const char* setflags(int argc, char *argv[])
{
    const char *Fname = NULL;
    for (int i = 1; i < argc; i++)
    {
        if (argv[i][0] == '-' || argv[i][0] == '/')
        {
            for ( int j = 1; argv[i][j] != '\0'; j++)
            {
                switch (argv[i][j])
                {
                case 'u':
                case 'U':
                    flags |= F_OUT_USH;
                    break;
                case 'w':
                case 'W':
                    flags |= F_OUT_WCH;
                    break;
                case 'd':
                case 'D':
                    flags |= F_OUT_DNAME;
                    break;
                case 'i':
                case 'I':
                    flags |= F_OUT_IDEN;
                    break;
                case 'x':
                case 'X':
                    flags |= F_USE_USH_NAME;
                    break;
                default:
                    return NULL;
                }
            }
        }
        else
        {
            if (!Fname)
                Fname = argv[i];
            else
                return NULL;
        }
    }
    if (!(flags & F_OUT_USH) && !(flags & F_OUT_WCH) && !(flags & F_OUT_IDEN))
        flags |= F_OUT_ALL;
    return Fname;
}


void print(string st)
{
    if ( flags & F_OUT_DNAME)
    {
        if (UnDecorateSymbolName( st.c_str(), tmp, 511, 0))
            cout << tmp << '\n';
        else
            cout << st << '\n';
    } else {
        cout << st << '\n';
    }
}

int funccmp(const char *func1, const char *func2)
{
    while (*func1 != 0 && *func2 != 0)
    {
        if ( *func1 == *func2)
            func1++, func2++;
        else if ( func1 == strstr(func1, "_W") && 
                  func2 == strstr(func2, "G"))
            func1 += sizeof("_W"), func2 += sizeof("G");
        else if ( func2 == strstr(func2, "_W") &&
                  func1 == strstr(func1, "G"))
            func2 += sizeof("_W"), func1 += sizeof("G");
        else
            break;
    }
    if (*func1 < *func2)
        return -1;
    else if (*func1 > *func2)
        return 1;
    else
        return 0;
}
int Funccmp(const char *func1, const char *func2)
{
    static char tmp1[512];
    UnDecorateSymbolName(func1, tmp, 511, 0);
    UnDecorateSymbolName(func2, tmp1, 511, 0);
    func1 = tmp;
    func2 = tmp1;

    if (strstr(tmp, "wchar_t") || strstr(tmp, "unsigned short"))
        return 11;
    else if (strstr(tmp1, "wchar_t") || strstr(tmp1, "unsigned short"))
        return 22;
    
    while (*func1 != 0 && *func2 != 0)
    {
        if ( *func1 == *func2)
            func1++, func2++;
        else if ( func1 == strstr(func1, "wchar_t") && 
                  func2 == strstr(func2, "unsigned short"))
            func1 += sizeof("wchar_t"), func2 += sizeof("unsigned short");
        else if ( func2 == strstr(func2, "wchar_t") &&
                  func1 == strstr(func1, "unsigned short"))
            func2 += sizeof("wchar_t"), func1 += sizeof("unsigned short");
        else
            break;
    }
    if (*func1 < *func2)
        return -1;
    else if (*func1 > *func2)
        return 1;
    else
        return 0;
}


int main(int argc, char *argv[])
{
    FILE *phDumpbin;
    Ext Fext;
    const char *Fname;
    int StripLine, i, result;
    char ExeName[256];
    char TmpStr[512];
    char *tch;
    set<string> Sdiff, Wdiff, Iden;


    if (!(Fname = setflags(argc, argv)))
    {
        cout << "Usage : wsfdiff -[options] filename" << endl;
        cout << "-x -X: Use unsigned char as data type in identical functions" << endl;
        cout << "-u -U: Print diff with unsigned short version" << endl;
        cout << "-w -W: Print diff with wchar_t version" << endl;
        cout << "-i -I: Print Identical function" << endl;
        cout << "-d -D: UnDname the function names" << endl;
        cout << "filename can only have be .lib or .dll" << endl;
        return -1;
    }
    strcpy(ExeName, "dumpbin ");
    switch (Fext = FindExt(Fname))
    {
    case dll:
        strcat(ExeName, "-exports ");
        break;
    case lib:
        strcat(ExeName, "-linkermember ");
        break;
    case none:
        return -1;
    }
    strcat(ExeName, Fname);
    phDumpbin = _popen(ExeName, "r");
    
    //Strip header
    if (Fext == dll)
        StripLine = 19;
    else
        StripLine = 18;

    for ( i = 0; i < StripLine; i++)
    {
        fgets(TmpStr, 511, phDumpbin);
        cerr << TmpStr;
    }
    set<string>::iterator spos, wpos;
    while (fgets(TmpStr, 511, phDumpbin))
    {
        tch = filter(TmpStr, Fext);
        tch[strlen(tch) -1] = '\0';
        UnDecorateSymbolName(tch, tmp, 511, 0);
        if (strstr (tmp, "wchar_t"))
        {
            spos = Sdiff.begin();
            result = -1;
            while(spos != Sdiff.end())
            {
                switch(result = funccmp(tch, (*spos).c_str()))
                {
                case 1:
                    ++spos;
                    break;
                case 0:
                    if (flags & F_USE_USH_NAME)
                        Iden.insert(*spos);
                    else
                        Iden.insert(string(tch));
                    Sdiff.erase(spos);
                    break;
                }
                if ( result != 1)
                {
                    break;
                }
            }
            if (result != 0)
                Wdiff.insert(string(tch));
        } else if ( strstr(tmp, "unsigned short"))
        {
            spos = Wdiff.begin();
            result = -1;
            while(spos != Wdiff.end())
            {
                switch(result = funccmp(tch, (*spos).c_str()))
                {
                case 1:
                    ++spos;
                    break;
                case 0:
                    if (flags & F_USE_USH_NAME)
                        Iden.insert(string(tch));
                    else
                        Iden.insert(*spos);
                    Wdiff.erase(spos);
                    break;
                }
                if ( result != 1)
                    break;
            }
            if (result != 0)
                Sdiff.insert(string(tch));
        }
    }
    // final checks for diffs and validity
    for ( wpos = Wdiff.begin(), spos = Sdiff.begin();
          spos != Sdiff.end() && wpos != Wdiff.end();)
    {
        switch(Funccmp((*wpos).c_str(), (*spos).c_str()))
        {
        case 0:
            if (flags & F_USE_USH_NAME)
                Iden.insert(*spos);
            else
                Iden.insert(*wpos);
            spos = Sdiff.erase(spos);
            wpos = Wdiff.erase(wpos);
            break;
        case 1:
            ++spos;
            break;
        case -1:
            ++wpos;
            break;
        case 11:
            wpos = Wdiff.erase(wpos);
            break;
        case 22:
            spos = Sdiff.erase(spos);
        }
    }

    if ( flags & F_OUT_USH)
    {
        cout << "Only Unsigned Short version " << Sdiff.size() << '\n';
        for_each (Sdiff.begin(), Sdiff.end(), print);
        cout <<"-----------------------------------------------------------\n";
    }

    if ( flags & F_OUT_WCH)
    {
        cout << "Only wchar_t versions " << Wdiff.size() << '\n';
        for_each (Wdiff.begin(), Wdiff.end(), print);
        cout <<"-----------------------------------------------------------\n";
    }

    if ( flags & F_OUT_IDEN)
    {
        cout <<"Both the versions are present " << Iden.size() << '\n';
        for_each (Iden.begin(), Iden.end(), print );
        cout <<"-----------------------------------------------------------\n";
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\tools\source\ifstrip\eval.h ===
/***
*Eval.h - If expression evaluator
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Evaluate complex if expressions
*
*Revision History:
*	??-??-88   PHG  Initial version
*
*******************************************************************************/

/* Take a pointer to workspace for a simplified condition and truth value, and pass in the condition string to simplify */
extern void evaluate(char *, int *, char *);

/* Produce the negative of a truth value,
   !DEFINED    == UNDEFINED
   !UNDEFINED  == DEFINED
   !IGNORE     == IGNORE
   !NOTPRESENT == NOTPRESENT */
extern int negatecondition(int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\tools\source\ifstrip\symtab.h ===
/***
*Symtab.h - symbol table storage used by the ifstripper, parser and symbol table
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Symbol table storage used by the ifstripper, parser and symbol table
*
*Revision History:
*	??-??-88   PHG  Initial version
*
*******************************************************************************/

#ifndef SYMTAB_H
#define SYMTAB_H

/* read the symbol table from the named switch file */
extern void readsyms(char *);

/* add the named symbol to the table, with the given truth value */
extern void addsym(char *, int);

/* find the truth value for the named symbol */
extern int lookupsym(char *);

/* Check that the named identifier consists of valid characters */
extern int ident_only(char *);

#endif /* SYMTAB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\tools\source\ifstrip\symtab.c ===
/***
*symtab.c - Ifdef symbol table storage module
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Store the symbols from the switches file.
*
*Revision History:
*	??-??-88   PHG	Initial version
*
*******************************************************************************/
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <search.h>
#include <ctype.h>
#include "constant.h"
#include "errormes.h"
#include "symtab.h"

/* Internal constants */
#define MAXSYMBOLS    512	/* Maximum number of symbols (switches) */
#define IDENT_CHARS "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_$?"

/* Symbol record */
struct symrec {
	char *name;		/* name of the symbol */
	int type;		/* type of symbol (DEFINED, UNDEFINED, IGNORE)*/
};

/* Internal variables */
int numsyms;			/* Number of symbols */
struct symrec symtable[MAXSYMBOLS];
				/* Symbol table */
/* Procedures */
int compsym(const struct symrec *, const struct symrec *);

/* Compare two records for alphabetical order */
int compsym(rec1, rec2)
const struct symrec *rec1, *rec2;
{
	return strcmp(rec1->name, rec2->name);
}

/* Add symbol to symbol table */
void addsym(symbol, type)
char *symbol;
int type;
{
	if (lookupsym(symbol) != NOTPRESENT) {
		fprintf(stderr, "fatal error: symbol \"%s\" already in symbol table.\n", symbol);
		exit(1);
	}
	symtable[numsyms].name = _strdup(symbol);
	symtable[numsyms].type = type;
	++numsyms;
}

/* Read switches from a file into symbol table */
void readsyms(filename)
char *filename;
{
	FILE *f;
	char name[MAXNAMELEN];
	f = fopen(filename, "r");
	if (f == NULL) {
		fprintf(stderr, "fatal error: cannot open switch file \"%s\".\n", filename);
		exit(1);
	}
	numsyms = 0;

	do {
		if ( fgets(name, MAXNAMELEN, f) == NULL) {
			fprintf(stderr, "fatal error: unexpected EOF in switch file.\n");
			exit(1);
		}
		name[strlen(name) - 1] = '\0';	/* remove trailing \n */
		if (name[0] != '-') {
			addsym(name, DEFINED);
		}
	} while (name[0] != '-');

	do {
		if (fgets(name, MAXNAMELEN, f) == NULL) {
			fprintf(stderr, "fatal error: unexpected EOF in switch file.\n");
			exit(1);
		}
		name[strlen(name) - 1] = '\0';	/* remove trailing \n */
		if (name[0] != '-') {
			addsym(name, UNDEFINED);
		}
	} while (name[0] != '-');

	do {
		if (fgets(name, MAXNAMELEN, f) == NULL)
			break;
		name[strlen(name) - 1] = '\0';	/* remove trailing \n */
		if (name[0] != '-') {
			addsym(name, IGNORE);
		}
	} while (name[0] != '-');

	fclose(f);
}

/* Lookup symbol in symbol table */
int lookupsym(name)
char *name;
{
	struct symrec srchrec;
	struct symrec *recfound;

	srchrec.name = name;
	recfound = (struct symrec *) _lfind( (const void *)&srchrec, (const void *)symtable,
		&numsyms, sizeof(struct symrec), compsym);
	if (recfound == NULL)
		return NOTPRESENT;
	else
		return recfound->type;
}

/* Check if token is identifier only (must have no whitespace) */
int ident_only(token)
char *token;
{
	/* is an identifier if all characters are in IDENT_CHARS
	   and first character is not a digit */
	return (strspn(token, IDENT_CHARS) == strlen(token) &&
			!isdigit(token[0]));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\tools\source\striphdr\striphdr.c ===
/***************************************************************************
*striphdr.c -  Program to read source files and produce alphabetised
*                    listing of header blocks, telling which files they came
*                    from.
*
*	Copyright (c) 1983-2001, Microsoft Corporation.  All rights reserved.
*
*Author:         Tom Corbett, Brian Lewis - Microsoft Corp.
*
*Usage: striphdr [switches] file {file ...}
*  Accepts native code or C source; determines source
*     type based on filename suffix.
*  Wildcards may be used in the file names.
*
*  switches:
*
*  -m        process module headers only
*  -b        process both procedure and module headers
*            [default is procedure headers only]
*  -l        process only first line of each header
*  -n        process none of header (i.e. lists only function name)
*  -s <name> process named section only (may be used with -l)
*            [default is to process whole header]
*  -d        delete processed section from input file
*  -q        quiet, do not print headers (useful only with -d)
*  -x <ext>  gives extension for output file when -d used
*            [default: .new]
*  -r        remove revision histories from file headers
*              (equivalent to -m -d -q -s "Revision History")
*
*Purpose:
*   Given a list of Native code and/or C sources, strip out routine or module
*   headers and produce an alphabetised listing of the headers, telling where
*   (filename) each header came from. Optionally, delete part or all of the
*   headers from the source file.
*
*   For each file on the command line (wildcards may be used), striphdr reads
*   the file, and records information from the file and/or procedure headers.
*   This information is then sorted by procedure name/file name, and printed
*   to stdout, with an indication of which file each procedure is from.  If
*   the -d flag is activated, the information is also deleted from the input
*   file and the new file placed in a file with the same name but the
*   extension .new (this extension can be changed with the -x switch).  The
*   actual input file is also left as is. When using the -d switch, -q will
*   eliminate the output, so that only the deleting action takes place.  By
*   default only the procedure headers are scanned, the -m and -b switches
*   change this.  By default all the information in a header is printed or
*   deleted, the -l, -n, and -s switches change this.  The -r switch is an
*   abbreviation which will remove revision histories from the file headers.
*
*   Input filenames with suffixes of .c or .h are assumed to contain C source,
*   and suffixes of .asm or .inc imply native code source. Routine or module
*   names must be on the first or second line following the start of header;
*   if on the second line then the first line must contain only whitespace
*   after an optional '*' (if C source) or ';' (if native code source).
*   Routine names can contain a return type and parameters; multiple entry
*   point should be seperated by commas.  Header start and end symbols must
*   start in the left-most column. Module headers and routine headers are
*   marked in the same manner; position relative to the beginning of file is
*   used to determine which header type is appropriate.
*
*   Source is detabbed (1 tab assumed to equal 4 spaces in C, 8 spaces in native
*   code) and routine names are parsed to ensure that the correct name is
*   grabbed for sorting.
*
*   C Headers are started with a '/' characters in the first column followed
*   by at least 3 '*' characters, and are ended with at least 4 '*' characters
*   followed by a '/'. Each line within a header must begin with a '*', except
*   lines beginning with '#if', '#else', or '#endif'. Module headers must be
*   preceded with nothing except (perhaps) blank lines; if any non-blank lines
*   are found prior to the first header in a module, it is assumed that the
*   header belongs to a routine, otherwise, to the entire module.
*
*   Native code headers are started by a ';' followed by at least 3 '*'
*   characters, and the header  end is denoted by a ';' followed by at least
*   4 '*' characters. There must be a ';' character in the left-most column of
*   every line of the header block; the only exception to this is that the '
*   if', 'else', and 'endif' switches are allowed inside header blocks. Module
*   headers can be preceded with any number of blank lines, a TITLE statement,
*   a NAME statement, and/or a PAGE statement; if anything else is
*   encountered, subsequent headers will be assumed to be routine headers.
*
*   Sections within a header must have a title beginning on the 2nd
*   character of the line, and the section is assumed to extend to the next
*   line with a non-blank character in position 2.
*
*   No non-header comments should begin in column 1 with '/***' in C or
*   ';***' in native code; this will confuse striphdr.
*
*
*Revision History:
*
*   01-01-83  TOMC Created [tomc]
*   09-09-85  BL   Modified to allow the option of stripping module headers
*                  instead of routine headers via the -m switch
*   09-30-85  BL   Modified to accept either C Source or native code source.
*                  Modified to detab C Source assuming 3 spaces per tab.
*                  Modified to parse C Routine names properly, allowing
*                  types, macros, etc. to precede routine names.
*                  Modified to make the sorting be case insensitive.
*   11-12-85  BL   Fixed bug that caused 1st char to always be removed from
*                  headers, and that caused problems when a blank line follows
*                  header starts.
*   06-01-87  PHG  fixed GetNonBlank()
*                  allowed 'title' and 'Title" as well as 'TITLE'
*                  allowed NAME, PAGE as well as TITLE
*                  made tab expansion for both ASM and C files
*                  both C and ASM procedure names can have args,
*                  multiple entries
*                  simplified some code and a few minor bug fixes
*                  added -b, -n, -s, -d, -q, -x, -r switches
*   05-10-90  JCR  Accept .cxx/.hxx files (C++ support), misc cleanup
*   04-06-95  SKS  Accept .cpp/.hpp as equivalent to .cxx/.hxx, respectively
***************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <direct.h>


#define TRUE 1
#define FALSE 0
#define NAMBUFSZ 20000      /* size of buffer for holding all procedure names */
#define LINEBUFSZ 250       /* maximum size of 1 physical line */
#define MAXENT 3000         /* maximum number of procedure entry points */
#define MAXFUNCS 2000       /* maximum number of function headers */

/* abort codes */
#define NMBUFOV 0           /* name buffer table overflow */
#define FILENF 1            /* file not found */
#define FUNCSOV 2           /* function table overflow */
#define ENTOV 3             /* entry table overflow */
#define FILENO 4            /* cannot open file */
#define OUTSPACE 5          /* out of disk space */

/* tab sizes, pagelength */
#define TABSIZE_C 4
#define TABSIZE_ASM 8       /* tab sizes for code */
#define PAGELEN 60	    /* pagelength for page breaks; 60 for HP LaserJet */

struct {
	char *entname;          /* name of entry point */
	int funcid;             /* function index for this entry point */
	char printed;           /* flag to ensure each entry printed just once */
} 
entry [MAXENT];
int nentries;               /* number of entries parsed so far */

struct {
	char *filename;         /* name of file which contains this function */
	long filepos;           /* seek position on file "temp" */
	int nlines;             /* number of lines in function header */
} 
func [MAXFUNCS];
int nfuncs;                 /* number of function parsed so far */

long ofpos;                 /* output file seek position */
char linebuf[LINEBUFSZ];
char nambuf[NAMBUFSZ];      /* buffer for holding function names */
int nambufi;                /* next free byte in nambuf */
char fEof;
FILE *ofd;                  /* output file descriptor */
FILE *ifd;                  /* input file descriptor */
FILE *cfd;                  /* copy file descriptor */
FILE *fopen();
int outline;                /* output line number (1..PAGELEN) for page ejects */
int fDelete = FALSE;        /* TRUE if copy and delete instead of display */
int fGetModNams = FALSE;    /* TRUE if strip module names */
int fGetProcNams = TRUE;    /* TRUE if strip procedure names */
int fC_Source;              /* TRUE if we're processing C source, false if .asm */
int fDoAll = TRUE;          /* TRUE if we process all of header */
int fDoFirst = FALSE;       /* TRUE if we process first line of header */
int fDoSection = FALSE;     /* TRUE if we process named section of header */
int fQuiet = FALSE;         /* TRUE is quiet mode */
char SectionHead[80];       /* Section name */
char CopyExt[4] = "new";    /* extension of new files */
char *szFilenameCur;        /* name of file being read (for error reporting) */



/*** 
*MyAbort(code, s) - abort program with message
*Purpose:
*   abort the program with correct message.
*
*Entry:
*   code = error code
*   s = filename for code == FILENF
*
*Exit:
*   exits to DOS
*
*Exceptions:
*
*******************************************************************************/

void MyAbort(code, s)
int code;
char *s;
{
	fprintf(stderr, "Fatal Error - ");
	if (code == NMBUFOV)
		fprintf(stderr, "NAME Buffer overflow\n");
	if (code == FILENF)
		fprintf(stderr, "File not found: %s\n", s);
	if (code == FUNCSOV)
		fprintf(stderr, "Function table overflow\n");
	if (code == ENTOV)
		fprintf(stderr, "Entry table overflow\n");
	if (code == FILENO)
		fprintf(stderr, "Cannot open file: %s\n", s);
	if (code == OUTSPACE)
		fprintf(stderr, "Out of disk space\n", s);

	exit(code);
} /* MyAbort */


/***
*FindIfC(szFile) - find if filename if C or ASM
*
*Purpose:
*   Set global flag fC_Source to TRUE if the filename ends in
*   .c, .h, .cxx (.cpp), or .hxx (.hpp); FALSE if it ends in .asm or .inc.
*   The extension comparison is NOT case senstive.  If none of
*   these are found, don't set the flag,and return FALSE,
*   else return TRUE.
*
*Exit:
*   sets flag fC_Source
*   returns FALSE if neither C nor ASM source
*   returns TRUE if fC_Source set
********************************************************************/

FindIfC(szFile)
char *szFile;
{
	int cbFileName = strlen(szFile);
	char *pbPastName = szFile + cbFileName; /* points at NULL at string end */

	if ((!_stricmp (".c", pbPastName - 2)) ||
	    (!_stricmp (".h", pbPastName - 2)) ||
	    (!_stricmp (".s", pbPastName - 2)) ||
	    (!_stricmp (".cpp", pbPastName - 4)) ||
	    (!_stricmp (".hpp", pbPastName - 4)) ||
	    (!_stricmp (".cxx", pbPastName - 4)) ||
	    (!_stricmp (".hxx", pbPastName - 4)))
		fC_Source = TRUE;       /* file is assumed to be C source */

	else if ((!_stricmp (".asm", pbPastName - 4)) ||
	    (!_stricmp (".inc", pbPastName - 4)))
		fC_Source = FALSE;      /* file is assumed to be Native Code source */

	else return (FALSE);        /* didn't find an appropriate suffix */

	return (TRUE);

} /* FindIfC */


/***
*MakeCopyfileName(filename, copyname) - make copyfile name from input name
*
*Purpose:
*   Put the copy file suffix onto a file name
*
*Entry:
*   filename = input file name
*
*Exit:
*   copyname = filled in with copy file name
*
*Exceptions:
*
*******************************************************************************/

void MakeCopyfileName(filename, copyname)
char *filename, *copyname;
{
	char *p;

	strcpy(copyname, filename);
	p = copyname + strlen(copyname);
	while (*(--p) != '.')
		;                            /* p points to '.' */
	*(p+1) = '\0';                  /* cut off string after '.' */
	strcat(copyname, CopyExt);      /* put on copy file extension */
}



/***
*linelen(pLine)
*
*Purpose:
*       Return the number of characters in a passed line. The line terminator
*       ('\n') is not included in the count.
*
*Entry:
*       pLine = a pointer to the first char in the line.
*Exit:
*       returns the number of characters in the line (an int).
***************************************************************************/

int linelen(pLine)
char *pLine;
{
	register int index;

	for (index = 0; *(pLine + index) != '\n'; index++);
	return (index);
}



static int cLinesRead;
static char fInHeader = FALSE;

/***
*ReadLine(copyit) - read line and analyze it
*
*Purpose:
*   read 1 line from input file into 'linebuf'.
*   if copyit == TRUE, copy previous line to copy file
*
*Entry:
*   copyit = TRUE means copy the line to the copy file
*
*Exit:
*   returns     -1 for EOF,
*                   0 for vanilla lines,
*               if C Source,
*                   1 for lines which begin "/***"  (start of header)
*                   2 for lines which begin "/****" (end of header)
*               if Native Code Source,
*                   1 for lines which begin ";***"  (start of header)
*                   2 for lines which begin ";****" (end of header)
*
***************************************************************************/

int ReadLine(copyit)
int copyit;             /* TRUE = copy line to copy file */
{
	register int i;
	register int cbLine;

	if (copyit) {
		if (fputs(linebuf, cfd) == EOF)
			MyAbort(OUTSPACE);
	}                   /* copy previous line if requested */

	if ((fgets(linebuf, LINEBUFSZ, ifd)) == NULL) {
		fEof = TRUE;
		return(-1);
	}

	cLinesRead++;
	cbLine = linelen(linebuf);

	if ((linebuf[0] == ';') && (!fC_Source)) {  /* native code comment */
		if ((linebuf[1] == '*') && (linebuf[2] == '*') && (linebuf[3] == '*'))
			/* know we have either start or end of a header */
			if (fInHeader) {
				fInHeader = FALSE;
				if (linebuf[4] == '*')
					return (2);             /* valid end of header */
				/* error, got start of header when we're already in a header */
				fprintf(stderr, "Unterminated header for function: %s\n",
				entry[nentries].entname);
				fprintf(stderr, "  before line %d of file %s\n",
				cLinesRead, szFilenameCur);
			}
			else {      /* have a valid start of header */
				fInHeader = TRUE;
				return (1);
			}
	}

	else if ((linebuf[0] == '/') && (fC_Source)) {  /* C code comment? */
		if ((linebuf[1] == '*') && (linebuf[2] == '*') && (linebuf[3] == '*'))
			if (fInHeader) {
				/* error, got start of header when we're already in a header */
				fprintf(stderr, "Unterminated header for function: %s\n",
				entry[nentries].entname);
				fprintf(stderr, "  before line %d of file %s\n",
				cLinesRead, szFilenameCur);
			}
			else {
				fInHeader = TRUE;
				return (1);             /* valid start of header */
			}
	}

	else if ((linebuf[0] == '*') && (fC_Source)) {  /* C code comment? */
		for (i = 1; (i < cbLine) && (linebuf[i] == '*'); i++);

		if ((linebuf[i] == '/') && (i > 3)) {   /* have a valid end of header */
			if (fInHeader) {
				fInHeader = FALSE;
				return (2);
			}
			/* got a header terminator when we weren't within a header */
			fprintf(stderr, "Illegal termination to header for function: %s",
			entry[nentries].entname);
			fprintf(stderr, "  in line %d of file %s\n",
			cLinesRead, szFilenameCur);
		} /* if */
	}   /* else if */

	return(0); /* vanilla line */
} /* ReadLine */


/***
*WriteLine(pb, of) - write a line and expand tabs
*
*Purpose:
*   Write a zero terminated string to file 'of'.
*   If we're writing C Source header lines, detab them as we go.
*
*Entry:
*   pb = points to 1st byte of 0-terminated string.
*   of = aft index for destination file.
*
*Exit:
*   'ofpos' is bumped to reflect current output file position.
*
***************************************************************************/

void WriteLine(pb, of)
register char *pb;
FILE *of;
{
	register int linepos = 0;   /* column position on output line */
	int modTS;                  /* linepos mod tabSize */
	int cSpaces;                /* number of spaces to print to next tab stop */
	int index;                  /* 'for' index for printing spaces */
	int tabSize;                /* current tab size */

	if (fC_Source)
		tabSize = TABSIZE_C;
	else
		tabSize = TABSIZE_ASM;

	while (*pb != '\0') {
		if (*pb == '\t') {      /* if a tab character found */
			modTS = linepos % tabSize;  
			cSpaces = tabSize - modTS;
			for (index = 0; index < cSpaces; index++) {
				fputc(' ', of);
				linepos++;
			}
		}   /* if */
		else {
			fputc(*pb, of);
			linepos++;
		}
		pb++;
	}   /* while */

	if (ferror(of))
		MyAbort(OUTSPACE);
	ofpos = ftell(of);  /* update output file seek position for next line */
} /* WriteLine */


/***
*SwitchFound(s) - see if IF, ELSE, ENDIF switch on this line
*
*Purpose: return TRUE if an "if", "else", or "endif" are identified at
*   the start of string 's'. This is used to check to see if a
*   header line which doesn't start with ';' is an assembler switch.
*Entry:
*   s = pointer to a char which represents the string to be checked.
*   
*Exit:
*   returns TRUE if the string matches "if", "else", or "endif" of either
*   upper or lower case, FALSE otherwise.
***************************************************************************/

SwitchFound(s)
char *s;
{
	if (fC_Source) {
		/* strncmp returns 0 (which maps to FALSE) iff a match was found */
		if (strncmp(s, "#if", 3) &&
		    strncmp(s, "#IF", 3) &&
		    strncmp(s, "#else", 5) &&
		    strncmp(s, "#ELSE", 5) &&
		    strncmp(s, "#endif", 6) &&
		    strncmp(s, "#ENDIF", 6))
			return (FALSE);
	}
	else {
		if (strncmp(s, "if", 2) &&
		    strncmp(s, "IF", 2) &&
		    strncmp(s, "else", 4) &&
		    strncmp(s, "ELSE", 4) &&
		    strncmp(s, "endif", 5) &&
		    strncmp(s, "ENDIF", 5))
			return (FALSE);
	}
	return (TRUE);
}

/***
*GetNonBlank(copyit) - read line, find first non blank character
*
*Purpose:
*   Read in a line; return linebuf index if non-blank line found, -1 otherwise
*
*Entry:
*   copyit = TRUE means copy line to copy file
*
*Exit:
*   returns -1 if blank line read
*   return index of first non-whitespace char otherwise
*
***************************************************************************/
GetNonBlank(copyit)
int copyit;         /* copy lines to copy file if TRUE */
{
	register int i;
	register int cbLine;

	if (ReadLine(copyit) == -1) {
		return(-1);
	}

	cbLine = linelen(linebuf);

	for (i = 0; ((linebuf[i] == ' ') || (linebuf[i] == '\t')) &&
                    (i < cbLine); i++);

	if (i >= cbLine)
		return (-1);
	else
		return (i);

}   /* GetNonBlank */

/***
*ReadToHeader() - reads to beginning of next header
*
*Purpose:
*   Reads to beginning of next header or EOF 
*
*Entry:
*   
*Exit:
*   Returns -1 if at EOF, 0 if at a header
*
************************************************************************/

int ReadToHeader()
{
	while (!fEof && ReadLine(fDelete) != 1)
		;
	if (fEof)
		return -1;      /* at EOF */
	else
		return 0;       /* at beginning of header */
}



/***
*Get1stHdr() - read to first header
*
*Purpose:
*   Read lines until the first header is found. Return TRUE if this is
*   the header for the module, or FALSE if no module header is found.
*   
*   In C Sources, we assume that if the first non-blank line in the source
*       starts with  '/***', then it's the start of a module header.
*   In Native-Code Sources, we assume that there can exist any number
*       of blank lines, optionally followed by a TITLE statement, followed
*       by any number of blanks lines, and then by the module header if
*       it exists.
*
*Entry:
*       NONE
*Exit:
*       TRUE if module header found, FALSE otherwise. Note that if fEof is found,
*       FALSE is returned, and if !fEof and no module header is found, this 
*       routine will read in lines until the first routine header is found,or
*       fEof.
***************************************************************************/

Get1stHdr()
{
	register int index;
	register int i;

	while (((index = GetNonBlank(fDelete)) == -1) && (!fEof))
		;

	if (fEof) {
		fprintf(stderr, "warning: no file header on file ");
		fprintf(stderr, "%s\n", szFilenameCur);
		return (FALSE);
	}

	/* now, index is set into linebuf for a non-blank character */
	if (fC_Source) {        /* if header exists, must be first non-blank line */
		if ((linebuf[0] == '/') && (linebuf[1] == '*') &&
		    (linebuf[2] == '*') && (linebuf[3] == '*')) {
			fInHeader = TRUE;
			return (TRUE);
		}
		else {
			/* read to start of first header, tell caller no module header found */
			ReadToHeader();
			fprintf(stderr, "warning: no file header on file ");
			fprintf(stderr, "%s\n", szFilenameCur);
			return (FALSE);
		}
	}

	/* must be native-code source - - - can have a TITLE line with blank
	                lines before and after it - - - all prior to module header       */

	for (i = 1; i <= 3; ++i) { /* do thrice, might have TITLE, NAME, and PAGE */
		if (strncmp("TITLE", linebuf + index, 5) == 0 ||
		    strncmp("title", linebuf + index, 5) == 0 ||
		    strncmp("Title", linebuf + index, 5) == 0 ||
		    strncmp("NAME", linebuf + index, 4) == 0 ||
		    strncmp("name", linebuf + index, 4) == 0 ||
		    strncmp("Name", linebuf + index, 4) == 0 ||
		    strncmp("PAGE", linebuf + index, 4) == 0 ||
		    strncmp("Page", linebuf + index, 4) == 0 ||
		    strncmp("page", linebuf + index, 4) == 0)
		{ /* found TITLE, NAME, or PAGE statement */
			while (((index = GetNonBlank(fDelete)) == -1) && (!fEof))
				;

			if (fEof) {
				fprintf(stderr, "warning: no file header on file ");
				fprintf(stderr, "%s\n", szFilenameCur);
				return (FALSE);
			}
		}
	}

	/* if there was a TITLE and/or NAME statement, we've eaten it, 
	                   and any following blank lines;
	               must now have module header, if it exists */

	if ((linebuf[0] == ';') && (linebuf[1] == '*') &&
	    (linebuf[2] == '*') && (linebuf[3] == '*')) {
		fInHeader = TRUE;
		return (TRUE);
	}
	else {
		/* read to start of first header, tell caller no module header found */
		ReadToHeader();
		fprintf(stderr, "warning: no file header on file ");
		fprintf(stderr, "%s\n", szFilenameCur);
		return (FALSE);
	}

}   /* Get1stHdr */

/***
*AdvanceOne(s) - advance one char if one whitespace or comment token
*
*Purpose:
*   's' points to the first character in an input line; if it's a whitespace
*   token or a comment token, return a pointer to the next character in the
*   line, otherwise, return 's' unchanged.
*
*Entry:
*   s = ptr to first char in input line
*
*Exit:
*   returns ptr the next char if *s is whatspace, ';', or '*',
*   otherwise returns s
*
*******************************************************************************/

char *AdvanceOne(s)
char *s;
{
	if (*s == '*') {
		if (fC_Source)
			s++;
	}
	else if (*s == ';') {
		if (!fC_Source)
			s++;
	}
	else if ((*s == ' ') || (*s == '\t'))
		s++;
	return(s);
}   /* AdvanceOne */


/***
*FuncNamePtr(pbName) - find function name from this or next line
*
*Purpose:
*   Given a pointer into the current header line, return a pointer to
*   the first non-blank or comment symbol; if none found in the existing
*   line, read in another and try that one.
*   if a C routine line, skip any types, etc., and return a pointer to
*   the filename itself.
*
*   If a C routine line:
*   -------------------
*       Assumes that C routine names will end with a left paren.
*       Allows left parens in a summary of purpose if said summary is
*           preceded by a '-' which comes after the routine name.
*       Assumes that there are 1 or 0 spaces between the the routine name
*           and the mandatory left paren.
*
*Entry:
*       pbName = a pointer to the place to begin searching in linebuf.
*Exit:
*       Returns a pointer to the filename.
*
***************************************************************************/

char *FuncNamePtr(pbName)
register char *pbName;
{
	register int cbLine;
	char *pbTmp;
	int iStart;

	/* first, see if we have a blank line - if so, read in another one,
	                and assume that it has the filename; don't check that one ... */
	pbTmp = AdvanceOne(pbName);
	cbLine = linelen(pbTmp);
	for (iStart = 0; ((*(pbTmp+iStart) == ' ') || (*(pbTmp+iStart) == ' ')) &&
                    (iStart < cbLine); iStart++);
	    if (iStart >= cbLine) {
		if (ReadLine(fDelete) != 0) {   /* then we got a procedure end w/out a name! */
			if (fEof)
				fprintf(stderr, "EOF not expected\n");
			else
				fprintf(stderr, "Illegal header termination\n");
			fprintf(stderr,
			"  in line %d of file %s\n", cLinesRead, szFilenameCur);
			return((char *)-1);
		}
		pbName = linebuf;
	}

	/* now, assume that there is a filename somewhere at or after pbName */


	iStart = 0;

	while (*(pbName+iStart) != '(' && *(pbName+iStart) != '-' &&
	    *(pbName+iStart) != ',' && *(pbName+iStart) != '\n')
		++iStart;   /* search fwd for '(', '-', ',' or '\n' */
	do {
		--iStart;
	} 
	while ((*(pbName+iStart) == ' ' || *(pbName+iStart) == '\t') &&
	    iStart > 0);
	/* search back through whitespace */ 
	while (*(pbName+iStart) != ' ' && *(pbName+iStart) != '\t' &&
	    *(pbName+iStart) != ';' && *(pbName+iStart) != '*')
		--iStart;
	/* search back to beginning of name */
	++iStart;       /* point to first letter of name */
	return (pbName+iStart); /* return pointer to name */
}   /* FuncNamePtr */


/***
*MyReadFile(pbNam) - read file and remember headers
*
*Purpose:
*   Read one entire file, stripping out and remembering function headers
*   or module headers, as appropriate.
*
***************************************************************************/

void MyReadFile(char *pbNam)
{
	char CopyName[65];                  /* name of copy file */
	char *s, done, backout;
	int funci, svnfuncs, svnentries;
	int inmodhdr;                       /* TRUE if in module header, else FALSE */
	int insection;                      /* TRUE if in scetion to process */
	int onfirst;                        /* TRUE if on first line of header */

	szFilenameCur = pbNam;
	if ((ifd = fopen(pbNam, "r")) <= 0)
		MyAbort(FILENF, pbNam);
	linebuf[0] = '\0';                  /* make linebuf blank so file copying works */
	fEof = FALSE;
	cLinesRead = 0;

	if (!FindIfC(pbNam))    {           /* filename had invalid suffix */
		fprintf(stderr, "Illegal suffix for file %s", pbNam);
		fprintf(stderr, "; must have .c or .asm suffix\n");
		fclose(ifd);
		return;
	}

	if (fDelete) {
		MakeCopyfileName(pbNam, CopyName);  /* put the right extension on */
		cfd = fopen(CopyName, "w");
		if (cfd == NULL)
			MyAbort(FILENO, CopyName);        /* can't open file */
	}

	inmodhdr = Get1stHdr(); 
	if (inmodhdr && !fGetModNams) {
		/* don't want module header */
		ReadToHeader();                 /* skip module header */
		inmodhdr = FALSE;
	}

	/* we are currently at the beginning of a new header.
	        copy it to file TEMP, remember all entry points in NAMBUF.  */

	while (!fEof && (inmodhdr || fGetProcNams)) {
		svnfuncs = nfuncs;
		svnentries = nentries;
		if (++nfuncs >= MAXFUNCS)
			MyAbort(FUNCSOV);
		func[nfuncs].filename = pbNam;
		func[nfuncs].nlines = 0;
		func[nfuncs].filepos = ofpos;
		if (ReadLine(fDelete) == -1)
			done = TRUE;            /* got end-of-file */
		else
			done = FALSE;
		funci = nfuncs;
		s = linebuf;

		while (!done) {
			if (++nentries >= MAXENT)
				MyAbort(ENTOV);
			entry[nentries].entname = nambuf + nambufi;
			entry[nentries].printed = FALSE;
			entry[nentries].funcid = funci;
			s = FuncNamePtr(s);
			if (s == (char *)-1) {
				fprintf(stderr, "Error found in line %d of file %s\n",
				cLinesRead, szFilenameCur);
				s = linebuf;
			}
			while ((*s != '\0') &&  /* transfer function name to nambuf */
			(*s != ',') &&
			    (*s != '(') &&
			    (*s != ' ') &&
			    (*s != '\n') &&
			    (*s != '\t') &&
			    (nambufi < (NAMBUFSZ - 2))) {
				nambuf[nambufi++] = *(s++);
			}
			if (nambufi >= (NAMBUFSZ - 2))
				MyAbort(NMBUFOV, NULL);
			nambuf[nambufi++] = '\0';

			/* make all secondary entry points reference primary entry point */
			if (funci >= 0)
				funci = -1 - nentries;   

			/* next we see if another entry point exists */
			while (*s == ' ' || *s == '\t')
				++s;                            /* skip whitespace */
			if (*s == '(') {
				do {
					++s;
				} 
				while (*s != ')' && *s != '\n');  /* skip param list */
				++s;                            /* goto next character */
			}
			while (*s == ' ' || *s == '\t')
				++s;                            /* skip whitespace */
			if (*(s++) != ',')
				done = TRUE;                    /* no more entry pts */
			else {
				++s;
				done = FALSE;
			}
		} /* while !done */

		backout = FALSE;

		if (fDoAll || fDoFirst)
			insection = TRUE;
		else
			insection = FALSE;                  /* are we in the correct section */

		onfirst = TRUE;                         /* on first line */

		do {
			s = linebuf;

			if ((!fC_Source && (*s != ';') && !SwitchFound(s)) || 
			    (fC_Source && (*s != '*') && !SwitchFound(s))) {
				/* Illegal Header Format, leave garbage in file TEMP,
				                    but restore nfuncs and nentries to previous values
				                    and backout of this header gracefully. */
				fprintf(stderr, "Invalid Header for function: %s",
				entry[nentries].entname);
				fprintf(stderr, " in line %d", cLinesRead);
				fprintf(stderr, ", in file: %s\n", pbNam);
				nfuncs = svnfuncs;
				nentries = svnentries;
				backout = TRUE;
			}

			s = AdvanceOne(s);

			if (!fDoAll && fDoSection && !onfirst && *s != ' ' && *s != '\t' && *s != '\n') {
				/* now at a section beginning -- and it's significant */
				if (insection)
					insection = FALSE;          /* come to end of section */
				else if (strncmp(s, SectionHead, strlen(SectionHead)) == 0)
					insection = TRUE;           /* come to beginning of section */
			}

			/* if in the section, don't copy, but write to TEMP */
			if (insection) {
				WriteLine(s, ofd);
				func[nfuncs].nlines++;
				ReadLine(FALSE);
			}
			else {
				ReadLine(fDelete);
			}

			if (onfirst && !fDoAll)
				insection = FALSE;

			onfirst = FALSE;                    /* no longer on first line */
		} 
		while ((!fEof) && (!backout) && fInHeader);

		/* skip to start of next function header */
		if (fGetProcNams)
			ReadToHeader();
		inmodhdr = FALSE;

	} /* while !fEof etc. */

	while (!fEof) {
		ReadLine(fDelete);
	}                                       /* read rest of file */

	if (fInHeader) {
		/* Error: reached EOF with unterminated header */
		fInHeader = FALSE;
		fprintf(stderr,
		"Error: function %s not terminated before end-of-file in %s\n",
		entry[nentries].entname, szFilenameCur);
	}

	fclose(ifd);
	fclose(cfd);

} /* MyReadFile */


/***
*PrintSep() - print a seperator
*
*Purpose:
*   Output a some lines which mark function header boundaries.
*
***************************************************************************/

void PrintSep(void)
{
	printf("---------------------------------------");
	printf("----------------------------------------\n");
} /* PrintSep */


/***
*PrintEntry(i) - print out an entry point header/module header
*
*Purpose:
*   Prints the given header out
*
***************************************************************************/

PrintEntry(i)
int i;
{
	int linecnt, m, entrysize;
	if ((m = entry[i].funcid) >= 0)
		entrysize = 4 + func[m].nlines; /* primary entry point */
	else
		entrysize = 4; /* secondary entry point */
	if (outline + entrysize > PAGELEN && outline > 1) {
		while (outline > PAGELEN)
			outline -= PAGELEN;
		while (outline <= PAGELEN) {
			printf("\n");
			outline++;
		}
		outline = 1;
	}
	printf("\n");
	PrintSep();
	printf("%s - ", entry[i].entname);
	if (m < 0)
		printf("see %s\n", entry[-1-m].entname);
	else
		printf("File: %s\n", func[m].filename);
	PrintSep();
	outline = outline + 4;
	if (m < 0 || func[m].nlines == 0)
		return(0);
	fseek(ifd, func[m].filepos, 0);
	fEof = FALSE;
	linecnt = func[m].nlines;
	ReadLine(FALSE);
	do {
		WriteLine(linebuf, stdout);
		outline++;
		ReadLine(FALSE);
	}
	while ((!fEof) && ((--linecnt) > 0));
} /* PrintEntry */

#if 0
/***************************************************************************
*_stricmp(pbLeft, pbRight) - case insensitive string compare
*
*Purpose:
*   Case-insensitive string comparison.
*
*Entry:
*   pbLeft, pbRight = ptrs to strings to compare
*
*Exit:
*   Return 0 if left string == right string, -1 if left string less than
*   right string, 1 otherwise
*
*NOTE:
*       This routine is provided because not all C runtime libraries support
*       this; specifically, MS C for DOS does have this routine, but
*       on a 68k it doesn't seem to be there.
*
***************************************************************************/
char *malloc();
#define isLcase(c)   (((c) >= 'a') && ((c) <= 'z'))
#define upit(c)  ((isLcase(c))? (c) - 'a' + 'A' : (c))

_stricmp(pbLeft, pbRight)
char *pbLeft, *pbRight;
{
	int cbLeft = strlen(pbLeft);
	int cbRight = strlen(pbRight);
	char *pbUCleft = malloc(cbLeft +1);
	char *pbUCright = malloc(cbRight +1);
	register char *pbSrc;
	register char *pbDst;
	register int i, retval;

	pbDst = pbUCleft;
	pbSrc = pbLeft;
	for (i = 0; i <= cbLeft; i++, pbDst++, pbSrc++)
		*pbDst = (char)upit(*pbSrc);

	pbDst = pbUCright;
	pbSrc = pbRight;
	for (i = 0; i <= cbRight; i++, pbDst++, pbSrc++)
		*pbDst = (char)upit(*pbSrc);

	retval = strcmp(pbUCleft, pbUCright);

	free(pbUCright);
	free(pbUCleft);

	return(retval);
} /* strless */

#endif /* 0 */

/***************************************************************************
* SortFunctions()
*
* Purpose:
*   Print sorted list of functions headers.
*
***************************************************************************/
void SortFunctions(void)
{
	int i, j, low;
	ifd = fopen("temp", "r");
	i = -1;
	while (++i <= nentries) {
		low = 0;
		j = -1;
		while (++j <= nentries) {
			if (!entry[j].printed) {
				if (entry[low].printed)
					low = j;
				else if (0 > _stricmp(entry[j].entname, entry[low].entname))
					low = j;
			}
		}
		PrintEntry(low);
		entry[low].printed = TRUE;
	}
} /* SortFunctions */

/*** 
*UsageError() - print out usage
*Purpose:
*   prints out the usage guidelines
*
*Entry:
*
*Exit:
*   exits to DOS
*
*Exceptions:
*
*******************************************************************************/

void UsageError(void)
{
	printf("Usage: striphdr [switches] file {file ...}\n\n");
	printf("  Accepts native code or C source; determines source\n");
	printf("     type based on filename suffix.\n");
	printf("  Wildcards may be used in the file names.\n");
	printf("\n");
	printf("Switches:\n");
	printf("  -m        process module headers only\n");
	printf("  -b        processes both procedure and module headers\n");
	printf("            [default is procedure headers only]\n");
	printf("  -l        processes only first line of each header\n");
	printf("  -n        processes none of header (i.e. lists only function name)\n");
	printf("  -s <name> processes named section only (may be used with -l)\n");
	printf("            [default is to process whole header]\n");
	printf("  -d        delete processed section from input file\n");
	printf("  -q        quiet, do not print headers (useful only with -d)\n");
	printf("  -x <ext>  gives extension for output file when -d used\n");
	printf("            [default: .new]\n");
	printf("  -r        remove revision histories from file headers\n");
	printf("              (equivalent to -m -d -q -s \"Revision History\")\n");
	exit(-1);
} /* UsageError */


void gdir( char * dst, char * src)
{
    int i;
    for ( i = strlen(src) -1; i >= 0 && (src[i] != '\\'); i--);
    strncpy(dst, src, i);
    dst[i] = 0;
}



/***
*main() - parse command line and process all file
*
*Purpose:
*   To run the other procedures based on the command line.
*
*******************************************************************************/

int main(int argc, char *argv[])
{
	int filei;
	int fScanningSwitches = TRUE;
    char base_dir[256], curr_dir[256];
    long h_find;
    struct _finddata_t f_data;

	nfuncs = -1;
	nentries = -1;
	nambufi = 0;
	ofpos = 0;
	filei = 1;
	outline = 1;

	if (argc == 1)      /* no args given - print usage message and quit */
		UsageError();

	while (fScanningSwitches) {
		if (filei >= argc) {
			fScanningSwitches = FALSE;
		}
		else if (_stricmp("-d", argv[filei]) == 0) {
			fDelete = TRUE;
			filei++;
		}
		else if (_stricmp("-q", argv[filei]) == 0) {
			fQuiet = TRUE;
			filei++;
		}
		else if (_stricmp("-n", argv[filei]) == 0) {
			fDoFirst = fDoSection = fDoAll = FALSE;
			filei++;
		}
		else if (_stricmp("-m", argv[filei]) == 0) {
			fGetModNams = TRUE;
			fGetProcNams = FALSE;
			filei++;
		}
		else if (_stricmp("-b", argv[filei]) == 0) {
			fGetModNams = TRUE;
			fGetProcNams = TRUE;
			filei++;
		}
		else if (_stricmp("-l", argv[filei]) == 0) {
			fDoFirst = TRUE;
			fDoAll = FALSE;
			filei++;
		}
		else if (_stricmp("-s", argv[filei]) == 0) {
			fDoSection = TRUE;
			fDoAll = FALSE;
			filei++;
			if (filei >= argc)
				UsageError();
			strcpy(SectionHead, argv[filei]);   /* copy section header in */
			filei++;
		}
		else if (_stricmp("-x", argv[filei]) == 0) {
			filei++;
			if (argv[filei][0] == '.')
				strncpy(CopyExt, argv[filei]+1, 3);     /* skip '.' */
			else
				strncpy(CopyExt, argv[filei], 3);
			CopyExt[3] = '\0';                  /* terminate string */
			filei++;
		}
		else if (_stricmp("-r", argv[filei]) == 0) {
			fDelete = TRUE;
			fGetModNams = TRUE;
			fGetProcNams = FALSE;
			fDoAll = FALSE;
			fDoSection = TRUE;
			fQuiet = TRUE;
			strcpy(SectionHead, "Revision History");
			filei++;
		}
		else if (*(argv[filei]) == '-')
			UsageError();
		else
			fScanningSwitches = FALSE;
	}

	if (filei >= argc)
		UsageError();                           /* no files specified */

	if (fQuiet)
		ofd = fopen("nul", "w");    /* in quiet mode, so no need to save the headers */
	else
		ofd = fopen("temp", "w");
	if (ofd == NULL)
		MyAbort(FILENO, "temp");                  /* can't open file */

	filei--;

    if ( _getcwd(base_dir, 255) == NULL) 
        exit(0);
    while (++filei < argc) {
        gdir(curr_dir, argv[filei]);
        if (_chdir(curr_dir) == -1) {
            printf("%s: %s\n", curr_dir, strerror(errno));
            exit(0);
        }
		if ( (h_find = _findfirst(argv[filei], &f_data)) == -1)
			continue;
        do
		{
       		MyReadFile(f_data.name);
        } while ( _findnext(h_find, &f_data) == 0);
		_findclose(h_find);
        if (_chdir(base_dir) == -1) {
            printf("%s: %s\n", curr_dir, strerror(errno));
            exit(0);
        }
    }
	fclose(ofd);
	if (!fQuiet)
		SortFunctions();
	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\tools\source\ifstrip\eval.c ===
/***
*eval.c - if expression evaluator
*
*	Copyright (c) 1992-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	produce truth values and simplified conditions from compound if
*	statements.
*
*Revision History:
*	09-30-92  MAL	Original version
*	10-13-93  SKS	Recognize comments of the form /-*IFSTRIP=IGN*-/ to
*			override ifstrip behavior.
*	09-01-94  SKS	Add support for more operators: == != < > <= >=
*			Add terseflag (-t) to suppress mesgs about directives
*	10-04-94  SKS	Add support for more operators: EQ NE LT GT LE NE
*			@ is an identifier character (e.g., MASM's @Version)
*   01-04-00  GB    Add support for internal crt builds
*
*******************************************************************************/
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include "eval.h"     /* Header for this module */
#include "symtab.h" 	 /* Symbol table access */
#include "constant.h" /* Constants for tokens etc */
#include "errormes.h" /* Errors and Warning messages */

/* Types */
typedef struct condrec
{
   int truth;
   char *condition;
} condrec, *cond;

/* Global variables */

extern int terseFlag;			/* controls display of forced directives */
extern char **comments;		         /* Language dependent comment strings */
extern int *commlen;                 /* Lengths of above strings */
extern int nonumbers;			     /* allow numeric expressions */
extern enum {NON_CRT = 0, CRT = 1} progtype;

char *operators[] = {
	"!", "(", ")", "||", "&&", "defined" ,
	"==" , "!=" , "<" , ">" , "<=" , ">=" ,
	"EQ" , "NE" , "LT" , "GT" , "LE" , "GE" };
int oplengths[] =   {
	1 , 1 , 1 , 2 , 2 , 7 ,
	2 , 2 , 1 , 1 , 2 , 2 ,
	2 , 2 , 2 , 2 , 2 , 2 };
                                                   /* # significant chars */
#define numoperators 18
	/* These tokens must be in the same order as 'operators' */
#define NOT			0
#define OPENPARENTHESIS		1
#define CLOSEPARENTHESIS	2
#define OR			3
#define AND			4
#define DEFINEDFN		5
#define	EQUALS			6
#define	NOTEQUALS		7
#define	LESSTHAN		8
#define	LESSOREQ		9
#define	GREATERTHAN		10
#define	GREATEROREQ		11
#define	EQUALS_ASM		12
#define	NOTEQUALS_ASM		13
#define	LESSTHAN_ASM		14
#define	LESSOREQ_ASM		15
#define	GREATERTHAN_ASM		16
#define	GREATEROREQ_ASM		17

#define UINT 100
#define ID 101
#define ENDOFLINE 102
#define UNKNOWN 103

/* Global state */
/* String holding input, the current pointer into it, and the current token */
char conditions[MAXLINELEN], *tokenptr, currenttoken[MAXCONDLEN];
int token = -1;

/* Function prototypes */
cond evaluateexpression(void);
cond orexpression(void);
cond andexpression(void);
cond unaryexpression(void);
cond parenthesesexpression(void);
cond atomicexpression(void);
cond createcondition(void);
void destroycondition(cond);
char *createstring(int);
void destroystring(char *);
void gettoken(void);
int issymbolchar(char);

/* CFW - added complex expression warning */
void evalwarn()
{
   warning("cannot parse expression - ignoring", conditions);
}


/*
 *	Comments may be in the input source which contain IFSTRIP Directives:
 *
 *	For C source they should look like:
 *
 *		#if foo>bar !*IFSTRIP=DEF*!		'!' here stands for '/'
 *
 *	and for Assembler source they should look like:
 *
 *		if foo ;;IFSTRIP=UND;;
 *
 *	Note that the directive and an optional preceding blank or tab
 *	are deleted from the input source.  The directive can thus be
 *	followed by a backslash to continue the line, another comment, etc.
 */

static char IfStripCStr[] =
 "/*IFSTRIP="; /* -*IFSTRIP=IGN*- */

static char IfStripAStr[] =
/*0123456789*- -* 0123456789012345 */
 ";;IFSTRIP="; /* ;;IFSTRIP=IGN;; */
	/* IGN may also be DEF or UND */

#define IFSTRIPVALOFF	10
#define IFSTRIPVALEND	13
#define	IFSTRIPVALLEN	15


void evaluate(char *outputstring, int *value, char *inputstring)
{
   int forcevalue = IGNORE;
   cond result;
   strcpy(conditions, inputstring);                /* Prepare the string for tokenising */
   tokenptr = conditions;
   gettoken();                                     /* Read in the first token of input */
   result = evaluateexpression();
   /* check for bad/complex expression */
   if (token != ENDOFLINE)
   {
	  char *adir = NULL;
	  char *cdir = NULL;
	  
	  if(((cdir = strstr(inputstring, IfStripCStr)) && cdir[IFSTRIPVALEND] == '*' && cdir[IFSTRIPVALEND+1] == '/')
	  || ((adir = strstr(inputstring, IfStripAStr)) && adir[IFSTRIPVALEND] == ';' && adir[IFSTRIPVALEND+1] == ';'))
	  {
	  	char *pstr;
		char *ifstr;

		/* fprintf(stderr,"<< evaluate(): (%s)\n", inputstring); */

		pstr = ifstr = ( adir ? adir : cdir ) ;

		/*
		 * Have recognized the /-*-IFSTRIP= directive, interpret its argument
		 * and remove the directive comment from the input/output text.
		 * Back up exactly one white space character (blank or tab) if possible.
		 */

		if(pstr > inputstring && (pstr[-1] == '\t' || pstr[-1] == ' '))
			-- pstr;

		if(!memcmp(ifstr+IFSTRIPVALOFF, "DEF", 3))	/* DEFINED */
			forcevalue = DEFINED;
		else if(!memcmp(ifstr+IFSTRIPVALOFF, "UND", 3))	/* UNDEFINED */
			forcevalue = UNDEFINED;
		else if(memcmp(ifstr+IFSTRIPVALOFF, "IGN", 3))	/* IGNORE */
			warning("cannot recognize IFSTRIP: directive - ignoring", conditions);
		/* else "IGNORE" -- forcevalue is already set by default to IGNORE */

		if(!terseFlag)					
			warning("ifstrip directive forced evaluation", conditions);

		/* remove the directive comment (and preceding blank or tab) from the input line */
		strcpy(pstr, ifstr + IFSTRIPVALLEN);	/* "C" comments have closing -*-/- */

		/* fprintf(stderr,">> evaluate(): (%s)\n", inputstring); */
	  }
	  else
	      evalwarn();

      if (result)
      {
         destroycondition(result);
         result = NULL;
      }
   }
   /* bad/complex expression, return IGNORE and entire expression */
   if (!result)
   {
      *value = forcevalue;
      strcpy(outputstring, inputstring);
      return;
   }
   *value = result -> truth;
   if(!result -> condition)
      * outputstring = '\0';
   else
      strcpy(outputstring, result -> condition);
   /* Convert from internal to external representation */
   destroycondition(result);
}

cond evaluateexpression()
{
   return orexpression();
}

cond orexpression()
{
   cond condition1, condition2;
   char *output;
   condition1 = andexpression();
   if (!condition1)
      return NULL;
   while (token == OR)
   {
      gettoken();
      condition2 = andexpression();
      if (!condition2)
      {
         destroycondition(condition1);
         return NULL;
      }
      switch (condition1 -> truth)
      {
         case DEFINED:                             /* DEFINED || x == DEFINED */
            /* condition1 set up correctly for next pass */
            destroycondition(condition2);
            break;
         case UNDEFINED:
            switch (condition2 -> truth)
            {
               case DEFINED:                       /* UNDEFINED || DEFINED == DEFINED */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
               case UNDEFINED:                     /* UNDEFINED || UNDEFINED == UNDEFINED */
                  destroycondition(condition2);
                  /* condition1 set up correctly for next pass */
                  break;
               case IGNORE:                        /* UNDEFINED || IGNORE == IGNORE */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
            }
            break;
         case IGNORE:
            switch (condition2 -> truth)
            {
               case DEFINED:                       /* IGNORE || DEFINED == DEFINED */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
               case UNDEFINED:                     /* IGNORE || UNDEFINED == IGNORE */
                  /* condition1 set up correctly for next pass */
                  destroycondition(condition2);
                  break;
               case IGNORE:                        /* IGNORE || IGNORE == IGNORE */
                  output = createstring(strlen(condition1 -> condition)
                                        + strlen (condition2 -> condition)
                                        + (sizeof(" || ") - 1));
                  strcpy(output, condition1 -> condition);
                  strcat(output, " || ");
                  strcat(output, condition2 -> condition);
                  /* Build up the condition string */
                  destroystring(condition1 -> condition);
                  condition1 -> condition = output;
                  /* Place the new string in condition1 */
                  destroycondition(condition2);
                  break;
            }
            break;
      }
   }
   return condition1;
}

cond andexpression()
{
   cond condition1, condition2;
   char *output;
   condition1 = unaryexpression();
   if (!condition1)
      return NULL;
   while (token == AND)
   {
      gettoken();
      condition2 = unaryexpression();
      if (!condition2)
      {
         destroycondition(condition1);
         return NULL;
      }
      switch (condition1 -> truth)
      {
         case DEFINED:
            switch (condition2 -> truth)
            {
               case DEFINED:                       /* DEFINED && DEFINED == DEFINED */
                  destroycondition(condition2);
                  /* condition1 set up correctly for next pass */
                  break;
               case UNDEFINED:                     /* DEFINED && UNDEFINED == UNDEFINED */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
               case IGNORE:                        /* DEFINED && IGNORE == IGNORE */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
            }
            break;
         case UNDEFINED:                           /* UNDEFINED && x == UNDEFINED */
            /* condition1 set up correctly for next pass */
            destroycondition(condition2);
            break;
        case IGNORE:
            switch (condition2 -> truth)
            {
               case DEFINED:                       /* IGNORE && DEFINED == IGNORE */
                  /* condition1 set up correctly for next pass */
                  destroycondition(condition2);
                  break;
               case UNDEFINED:                     /* IGNORE && UNDEFINED == UNDEFINED */
                  destroycondition(condition1);
                  condition1 = condition2;
                  break;
               case IGNORE:                        /* IGNORE && IGNORE == IGNORE */
                  output = createstring(strlen(condition1 -> condition)
                                        + strlen (condition2 -> condition)
                                        + (sizeof(" && ") - 1));
                  strcpy(output, condition1 -> condition);
                  strcat(output, " && ");
                  strcat(output, condition2 -> condition);
                  /* Build up the condition string */
                  destroystring(condition1 -> condition);
                  condition1 -> condition = output;
                  /* Place the new string in condition1 */
                  destroycondition(condition2);
                  break;
            }
            break;
      }
   }
   return condition1;
}

cond unaryexpression()
{
   cond condition1;
   char *output;
   switch (token)
   {
      case NOT:
         gettoken();
         condition1 = unaryexpression();
         if (!condition1)
            return NULL;
         if ((condition1 -> truth) == IGNORE)
         {
            output = createstring(strlen(condition1 -> condition) + 1);
            *output = '!';
            strcpy(output + 1, condition1 -> condition);
            destroystring(condition1 -> condition);
            condition1 -> condition = output;
         }
         else
            condition1 -> truth = negatecondition(condition1 -> truth);
         break;
      case DEFINEDFN:
         gettoken();
         condition1 = parenthesesexpression();
         if (!condition1)
            return NULL;
         if ((condition1 -> truth) == IGNORE)
         {
            output = createstring(strlen(condition1 -> condition)
                                  + (sizeof("defined ") - 1));
            strcpy(output, "defined ");
            strcat(output, condition1 -> condition);
            destroystring(condition1 -> condition);
            condition1 -> condition = output;
         }
         break;
      default:
         condition1 = parenthesesexpression();
         if (!condition1)
            return NULL;
         break;
   }
   return condition1;
}

cond parenthesesexpression()
{
   cond condition1;
   char *output;
   if (token == OPENPARENTHESIS)
   {
      gettoken();
      condition1 = evaluateexpression();
      if (!condition1)
         return NULL;
      if (token != CLOSEPARENTHESIS)
      {
         /* check for bad/complex expression */
         evalwarn();
         destroycondition(condition1);
         return NULL;
      }
      gettoken();
      if ((condition1 -> truth) == IGNORE)
      {
         output = createstring(strlen(condition1 -> condition) + 2);
         *output = '(';
         strcpy(output + 1, condition1 -> condition);
         strcat(output, ")");
         destroystring(condition1 -> condition);
         condition1 -> condition = output;
      }
   }
   else
      condition1 = atomicexpression();
   return condition1;
}

cond atomicexpression()
{
   cond condition1 = createcondition();

   switch (token)
   {
      case UINT:
         if ( progtype == 1)
            condition1 -> truth = DEFINED;
         else
            condition1 -> truth = (atoi(currenttoken) == 0) ? UNDEFINED : DEFINED;
         break;
      case ID:
         condition1 -> truth = lookupsym(currenttoken);
         if ((condition1 -> truth) == NOTPRESENT)
         {
            warning("Switch unlisted - ignoring", currenttoken);
            condition1 -> truth = IGNORE;
         }
         if ((condition1 -> truth) == IGNORE) {
            condition1 -> condition = createstring(strlen(currenttoken));
            strcpy(condition1 -> condition, currenttoken);
         }
         break;
      default:
         /* bad/complex expression */
         evalwarn();
         destroycondition(condition1);
         return NULL;
         break;
   }
   gettoken();
   return condition1;
}

/* Negate condition (MAL) */
__inline int negatecondition(int condvalue)        /* inline for speed */
{
   switch (condvalue)
   {
      case DEFINED:
         return UNDEFINED;
      case UNDEFINED:
         return DEFINED;
      default:
         return condvalue;
   };
}

/* Allocate the memory for an empty condition structure and return a pointer to it */
__inline cond createcondition()
{
   cond retvalue;
   retvalue = (cond) malloc(sizeof(condrec));
   if (retvalue == NULL)
      error("Memory overflow","");
   retvalue -> condition = NULL;
   return retvalue;
}

/* Destroy a condition structure */
__inline void destroycondition(cond condition1)
{
   if (condition1 -> condition)
      free(condition1 -> condition);

   free(condition1);
}

/* Allocate the memory for a string of given length (not including terminator) and return the pointer */
__inline char *createstring(int length)
{
   char *retvalue;
   retvalue = (char *) malloc(length + 1);
   if (retvalue == NULL)
      error("Memory overflow","");
   return retvalue;
}

/* Destroy a string */
__inline void destroystring(char *string)
{
   free(string);
}

int iscomment(char *tokenptr)
{
   int cindex;

   for (cindex = 0; cindex < maxcomment; cindex++)
   {
      if (commlen[cindex] &&
		  !_strnicmp(tokenptr, comments[cindex], commlen[cindex]))
         return TRUE;
   }
   return FALSE;
}

void gettoken()
{
   int numofwhitespace, comparetoken = 0, found = FALSE, isnumber = TRUE;
   char *digitcheck;

   numofwhitespace = strspn(tokenptr, " \t");

   /* CFW - skips comments, assumes comment is last thing on line */
   if (numofwhitespace == (int) strlen(tokenptr))
      token = ENDOFLINE;
   else
   {
      tokenptr += numofwhitespace;
      if (iscomment(tokenptr))
	  {
         token = ENDOFLINE;
	  }
      else
      {

         do
         {
	    if (!_strnicmp(tokenptr, operators[comparetoken], oplengths[comparetoken]))
               found = TRUE;
            else
               comparetoken++;
         } while ( (!found) && (comparetoken < numoperators) );
         if (found)
         {
            tokenptr += oplengths[comparetoken];
            token = comparetoken;
            /* currenttoken is left blank for all but UINTs and IDs */
         }
         else
         {
            digitcheck = tokenptr;
            if (!nonumbers && isdigit(*digitcheck))
            {
               while (isdigit(*digitcheck))
                  digitcheck++;
               strncpy(currenttoken, tokenptr, digitcheck - tokenptr);
               tokenptr = digitcheck;
               token = UINT;
            }
            else if (issymbolchar(*digitcheck))
            {
               while (issymbolchar(*digitcheck))
                  digitcheck++;
               strncpy(currenttoken, tokenptr, digitcheck - tokenptr);
               *(currenttoken + (digitcheck - tokenptr)) = '\0';
               tokenptr = digitcheck;
               token = ID;
            }
            else
               token = UNKNOWN;
         }
      }
   }
}

__inline int issymbolchar(char c)
{
   return (iscsym(c) || (c == '$') || (c == '?') || (c == '@'));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\libw32\tools\source\ifstrip\ifstrip.c ===
/***
*ifstrip.c - Ifdef stripping tool
*
*	Copyright (c) 1988-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Strip in/out conditional code from sources.
*	Refer to ifstrip.doc for more information.
*
*Revision History:
*	??-??-88  PHG	Initial version
*	05-10-90  JCR	Accept .cxx/.hxx files, misc cleanup, etc.
*	09-18-92  MAL	Rewritten to cope with nested IFs, ELIFs etc.
*	09-30-92  MAL	Added support for IF expressions, modularized code
*	10-13-93  SKS	Recognize comments of the form /-*IFSTRIP=IGN*-/ to
*			override ifstrip behavior.
*	09-01-94  SKS	Add terseflag (-t) to suppress mesgs about directives
*	10-05-94  SKS	Fix bug: Add missing space to keyword "ifndef "
*	01-04-99  GB    Added support for internal CRT builds.
*
*******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <search.h>
#include <direct.h>
#include <io.h>
#include <errno.h>
#include <fcntl.h>
#include "constant.h"                              /* Program constants used by modules */
#include "errormes.h"                              /* Error and warning reporting */
#include "symtab.h"                                /* Symbol table handling */
#include "eval.h"                                  /* If expression evaluation */

/* Global constants */
/* CFW - added ifdef, ifndef asm keywords, added IFE, added IFDIF */
char *syntaxstrings[2][maxkeyword + 1] =
       { {"#if ", "#elif ", "#else ", "#endif ", "#ifdef ", "#ifndef ", "",     "",     "",     "",      "",       "",        "" },
          {"if ",  "",       "else ",  "endif ",  "ifdef ",  "ifndef ",   "if1 ", "if2 ", "ifb ", "ifnb ", "ifidn ", "ifdif ", "ife " } };
       /* Language dependent if constructs, must be in the order c, asm and the keywords in the
          same order as the tokens stored in constant.h - All strings must be followed by a
          space, and those not available in a language should be empty */
int syntaxlengths[2][maxkeyword + 1] = { {3, 5, 5, 6, 6, 7, 0, 0, 0, 0, 0, 0, 0},
                                         {2, 0, 4, 5, 5, 6, 3, 3, 3, 4, 5, 5, 3} };
       /* The lengths of the above strings minus spaces. Unused keywords marked with 0 */

/* CFW - added comment stuff */
char *commentstrings[2][maxcomment] = { {"/* ", "// "}, {"; ",  ""} };      
int commentlengths[2][maxcomment] =   { {2,     2    }, {1,     0} };
      /* must ignore comments in IF statements */

/* Global variables */
int terseFlag = FALSE;			/* TRUE means do not echo forced directives */
int warnings = TRUE;          /* TRUE == print warnings */
int currdir = FALSE;		      /* Put in current dir, use source extension */
int isasm;			            /* TRUE == is assembler file */
char **syntax;   		         /* Language dependent syntax for output / matching */
int *synlen;			         /* Lengths of above strings */
char **comments;		         /* Language dependent comment strings */
int *commlen;                 /* Lengths of above strings */
char extension[5] = ".new";	/* Extension for output file */
FILE *outfile;			         /* Current output file */
char *curr_file;		         /* Name of current input file */
FILE *infile;			         /* Current input file */
FILE *errorfile;			      /* file to output error/warning messages */
int linenum;			         /* Line number of current input file */
int nonumbers;			    	 /* allow numeric expressions */
enum {NOCOMMENT, CSTYLE, CPPSTYLE} commstyle = NOCOMMENT;  /* type of comment to put after #else/#endif */
enum {NON_CRT = 0, CRT=1} progtype = NON_CRT;
char _inputline[MAXLINELEN];

/* Functions */
void setfiletype(char *);
void makenewname(char *, char *);
void usage(void);
void stripprog(void);
void putstring(char *);
void putline(char *);
char *getstring(char *, int, FILE *);
char *cleanse(char *inputstring);
void stripifdef(int, char *);
void definedif(void);
void undefinedif(void);
void undefinedifsubpart(int, char *);
void ignoredif(int, char *);
void ignoredifsubpart(int, char *, char *);
void skipto(int *, char *, int);
void copyto(int *, char *, int);
char *parseline(char *, int *);
void stripif(int, char *);

/* Print message and terminate */
void error(reason, line)
char *reason;
char *line;
{
	fprintf(errorfile, "%s(%d): %s\nfatal error: %s\n\n",
	curr_file, linenum, line, reason);
	exit(1);
}

/* Print message and return */
void warning(reason, line)
char *reason;
char *line;
{
	if (warnings)
		fprintf(errorfile, "%s(%d): %s\nwarning: %s\n\n", curr_file, linenum, line, reason);
}

/* Get a string from the input file, returns as fgets (MAL) */
char *getstring(char *line, int n, FILE *fp)
{
   char *returnvalue;
   int linelength;
   linenum++;
   returnvalue = fgets(line, n, fp);
   if (returnvalue != NULL)
   {
      linelength = strlen(line);
      if (line[linelength-1] == '\n')
         line[linelength-1] = '\0';                /* Strip trailing newline */
      else
         error("Line too long",line);
   }
   strcpy(_inputline, line);
   return returnvalue;
}

/* Put a string to the output file (MAL) */
void putstring(char *string)
{
   if ( fputs(string, outfile) == EOF )
      error("Fatal error writing output file","");
}

/* Put a line to the output file (MAL) */
void putline(char *line)
{
   putstring(line);
   if ( fputc('\n', outfile) == EOF )
      error("Fatal error writing output file","");
}

/* Put commented line like "#endif //CONDITION" based on comstytle flag
 * keyword = keyword to put
 * condition = condition to put
 */
void putcommentedline(int keyword, char *condition)
{
   if (progtype == CRT) {
       putline(_inputline);
       return;
   }
   putstring(syntax[keyword]);
   switch (commstyle) {
   case CSTYLE:
     if (isasm)
	   putstring(" ; ");
	 else
       putstring(" /* ");
     putstring(condition);
	 if (isasm)
	   putline("");
	 else
       putline(" */");
     break;
   case CPPSTYLE:
     if (isasm)
	   putstring(" ; ");
	 else
       putstring(" // ");
     putline(condition);
     break;
   case NOCOMMENT:
     putline("");
   }
}

/* Set file type (assembler or C, treat C++ as C) */
/* Language strings added (MAL) */
void setfiletype(filename)
char *filename;
{
	char *p;

	p = strrchr(filename, '.');
	if (p == NULL)
		error("file must have an extension", "");
	if ( (_stricmp(p, ".c")   == 0) || (_stricmp(p, ".h")	== 0) ||
	     (_stricmp(p, ".cpp") == 0) || (_stricmp(p, ".hpp") == 0) ||
	     (_stricmp(p, ".cxx") == 0) || (_stricmp(p, ".hxx") == 0) ||
         (_stricmp(p, ".s") == 0) )
		isasm = FALSE;
	else if  ( (_stricmp(p, ".asm") == 0) || (_stricmp(p, ".inc") == 0) )
		isasm = TRUE;
	else
		error("cannot determine file type", "");
	syntax = syntaxstrings[(isasm) ? 1 : 0];     /* Choose correct set of syntax strings */
	synlen = syntaxlengths[(isasm) ? 1 : 0];     /* and lengths */
   comments = commentstrings[(isasm) ? 1 : 0];  /* Choose correct comment set */
   commlen = commentlengths[(isasm) ? 1 : 0];   /* and lengths */
}

/* Make output file name */
void makenewname(filename, newname)
char *filename, *newname;
{
	char *p;

	if (!currdir) {
		/* put on new extension */
		strcpy(newname, filename);
		p = strrchr(newname, '.');
		if (p == NULL)
			error("file must have an extension", "");
		strcpy(p, extension);
	}
	else {
		/* strip off directory specifier */
		p = strrchr(filename, '\\');
		if (p == NULL)
			error("file must not be in current directory", "");
		strcpy(newname, p+1);
	}
}

/* Strip the ifs within a program or block of program text (MAL) */
void stripprog()
{
   char inputline[MAXLINELEN], *condition;
   int linetype;
   while ( getstring(inputline, MAXLINELEN, infile) != NULL )
   {
      condition = parseline(inputline, &linetype); /* Get the line token and condition pointer */
      switch (linetype)
      {
      case NORMAL:
         putline(inputline);
         break;
      case IFDEF:
      case IFNDEF:
         stripifdef(linetype, condition);
         break;
      case IF:
      case IFE:
         stripif(linetype, condition);
         break;
      case IF1:
      case IF2:
      case IFB:
      case IFNB:
      case IFIDN:
         /* CFW - ignore special assembler directives */
         ignoredif(linetype, condition);
         break;
      default:
         error("Error in program structure - ELSE / ELIF / ENDIF before IF","");
      }
   }
}

// CFW - cleanse condition strings of any trailing junk such as comments
char *cleanse(char *inputstring)
{
	char *linepointer = inputstring;

	while (__iscsym(*linepointer))
      linepointer++;

	*linepointer = '\0';

	return inputstring;
}


/* Strip an if depending on the statement if(n)def and the value of its condition (MAL) */
void stripifdef(int iftype, char *condition)
{
   int condvalue;
   condvalue = lookupsym(cleanse(condition)); /* Find the value of the condition from the symbol table */
   if (iftype == IFNDEF)
      condvalue = negatecondition(condvalue); /* Negate the condition for IFNDEFs */
   switch (condvalue)
   {
      case DEFINED:
         definedif();
         break;
      case UNDEFINED:
         undefinedif(); /* CFW - changed definedif to undefinedif call */
         break;
      case NOTPRESENT:
         warning("Switch unlisted - ignoring", condition);
         /* Drop through to IGNORE case */
      case IGNORE:
         ignoredif(iftype, condition);
   }
}

void stripif(int linetype, char *condition)
{
   char newcondition[MAXLINELEN];                  /* IGNORE conditions can be MAXLINELEN long */
   int truth;
   evaluate(newcondition, &truth, condition);      /* Get the truth value and new condition. */
   /* CFW - added IFE */
   if (linetype == IFE)
      truth = negatecondition(truth);
   switch (truth)
   {
      case DEFINED:
         definedif();
         break;
      case UNDEFINED:
         undefinedif();
         break;
      case IGNORE:
         ignoredif(linetype, newcondition);
         break;
   }
}

/* Strip a defined if (MAL) */
void definedif()
{
   char condition[MAXCONDLEN];
   int keyword;
   copyto(&keyword, condition, KEYWORD);           /* Copy up to the ELSE / ELIF / ENDIF */
   if (keyword != ENDIF)
      skipto(&keyword, condition, ENDIF);          /* Skip forward to the ENDIF if not there already */
}

/* Strip an undefined if (MAL) */
void undefinedif()
{
   char condition[MAXCONDLEN];
   int keyword;
   skipto(&keyword, condition, KEYWORD);           /* Skip to the ELSE / ELIF / ENDIF */
   if (keyword != ENDIF)                           /* No need to recurse if at ENDIF */
      undefinedifsubpart(keyword, condition);      /* Deal with the ELSE / ELIF */
}

/* Deal with the subparts of an undefined if (MAL) */
void undefinedifsubpart(int keyword, char *condition)
{
   int nextkeyword, condvalue;
   char newcondition[MAXCONDLEN];
   char nextcondition[MAXCONDLEN];
   switch (keyword)
   {
      case ELIF:
         evaluate(newcondition, &condvalue, condition);
         switch (condvalue)
         {
            case DEFINED:
               copyto(&nextkeyword, nextcondition, KEYWORD);
               if (nextkeyword != ENDIF)
                  skipto(&nextkeyword, nextcondition, ENDIF);
               break;
            case UNDEFINED:
               skipto(&nextkeyword, nextcondition, KEYWORD);
               if (keyword != ENDIF)               /* No need to recurse at ENDIF */
                  undefinedifsubpart(nextkeyword, nextcondition);
               break;
            case IGNORE:
               stripifdef(IFDEF, newcondition);
         }
         break;
      case ELSE:
         copyto(&nextkeyword, nextcondition, ENDIF);
   }
}

/* Strip an ignored if (MAL) */
void ignoredif(int linetype, char *condition)
{
   char *controlcondition;
   int nextkeyword;
   char nextcondition[MAXLINELEN];                 /* IGNORE conditions may be a line long */
   if ( progtype == CRT){
       putline(_inputline);
   } else {
       putstring(syntax[linetype]);                          /* Use IF to cope with any expression */
       putline(condition);
   }
   controlcondition = _strdup(condition);
   copyto(&nextkeyword, nextcondition, KEYWORD);
   ignoredifsubpart(nextkeyword, nextcondition, controlcondition);
   free(controlcondition);
}

/* Deal with the subparts of an ignored if (MAL) */
/* See design document for explanation of actions! */
/* controlcondition is controlling condition of the if */
void ignoredifsubpart(int keyword, char *condition, char *controlcondition)
{
   int nextkeyword, condvalue;
   char newcondition[MAXLINELEN];   /* IGNORE conditions may be a line long */
   char nextcondition[MAXLINELEN];  /* IGNORE conditions may be a line long */
   switch (keyword)
   {
      case ELIF:
         /* CFW - replaced lookupsym with evaluate */
         evaluate(newcondition, &condvalue, condition);
         switch (condvalue)
         {
            case DEFINED:
               putcommentedline(ELSE, controlcondition);              /* ELSIF DEFINED == ELSE */
               copyto(&nextkeyword, nextcondition, KEYWORD);
               if (nextkeyword != ENDIF)
                  skipto(&nextkeyword, nextcondition, ENDIF);
               if (progtype == CRT)
                  putline(_inputline);
               else
                  putline(syntax[ENDIF]);
               break;
            case UNDEFINED:                        /* ELSIF UNDEFINED skipped */
               skipto(&nextkeyword, nextcondition, KEYWORD);
               ignoredifsubpart(nextkeyword, nextcondition, controlcondition);
               break;
            case IGNORE:
               if ( progtype == CRT)
                  putline(_inputline);
               else {
                  putstring(syntax[ELIF]);            /* ELSIF IGNORED copied like IF */
                  putline(newcondition);
               }
			   controlcondition = _strdup(newcondition);  // new controlling condition.
               copyto(&nextkeyword, nextcondition, KEYWORD);
               ignoredifsubpart(nextkeyword, nextcondition, controlcondition);
			   free(controlcondition);
         }
         break;
      case ELSE:
         putcommentedline(ELSE, controlcondition);
         copyto(&nextkeyword, nextcondition, ENDIF);
         putcommentedline(ENDIF, controlcondition);
         break;
      case ENDIF:
         putcommentedline(ENDIF, controlcondition);
   }
}

/* Skip to the target keyword. Returns the keyword found and any condition following it. (MAL) */
void skipto(int *keyword, char *condition, int target)
{
   char currline[MAXLINELEN], *conditioninline;
   int linetype, ifdepth = 0, found = FALSE;
   while (!found)
      if ( getstring(currline, MAXLINELEN, infile) != NULL )
      {
         conditioninline = parseline(currline, &linetype);
         switch (linetype)
         {
            case NORMAL:
               break;                              /* Ignore a normal line */
            case IFDEF:
            case IFNDEF:
            case IF:
            case IF1:
            case IF2:
            case IFB:
            case IFNB:
            case IFIDN:
            case IFE:
               ifdepth++;
               break;                              /* Register nested if, do not need to test for stripping */
        		case ENDIF:
               if (ifdepth > 0)
               {
                  ifdepth--;                       /* Back up a level if in a nested if */
                  break;
               }
               /* Else drop through to default case */
            default:
               if ( (ifdepth == 0) && ((linetype == target) || (target == KEYWORD)) )
                  found = TRUE;
         }
      }
      else
         error("Error in program structure - EOF before ENDIF", "");
   *keyword = linetype;                            /* Return keyword token */
   strcpy(condition, conditioninline);
}

/* Copy to the target keyword. Returns the keyword found and any condition following it.
   Any if statements inside the area being copied are stripped as usual. (MAL) */
void copyto(int *keyword, char *condition, int target)
{
   char currline[MAXLINELEN], *conditioninline;
   int linetype, found = FALSE;
   while (!found)
      if ( getstring(currline, MAXLINELEN, infile) != NULL )
      {
         conditioninline = parseline(currline, &linetype);
         switch (linetype)
         {
            case NORMAL:
               putline(currline);                  /* Copy a normal line */
               break;
            case IFDEF:
            case IFNDEF:
               stripifdef(linetype, conditioninline);    /* Strip a nested if(n)def */
               break;
            case IF:
            case IFE:
               stripif(linetype, conditioninline);
               break;
            case IF1:
            case IF2:
            case IFB:
            case IFNB:
            case IFIDN:
               /* CFW - ignore special assembler directives */
               ignoredif(linetype, conditioninline);
               break;
            default:
               if ( (linetype == target) || (target == KEYWORD) )
                  found = TRUE;
         }
      }
      else
         error("Error in program structure - EOF before ENDIF", "");
   *keyword = linetype;                            /* Return line token */
   strcpy(condition, conditioninline);
}

/* Parse a line of text returning a condition pointer into the line and placing a line type in
   the integer location supplied (MAL) */
char *parseline(char *inputline, int *linetype)
{
   int numofwhitespace, comparetoken = 0, found = FALSE;
   char *linepointer = inputline;
   numofwhitespace = strspn(inputline, " \t");
   if (*(numofwhitespace + inputline) == '\0')
   {
      *linetype = NORMAL;                          /* Empty line */
      return NULL;
   }
   linepointer += numofwhitespace;
   do
   {
      if (synlen[comparetoken] != 0)
         {
	 if ( (!_strnicmp(linepointer, syntax[comparetoken], (size_t) synlen[comparetoken])) &&
              ( isspace( *(linepointer + synlen[comparetoken]) ) || !*(linepointer + synlen[comparetoken]) ) )
            found = TRUE;
         else
            comparetoken++;
         }
      else
         comparetoken++;
   } while ( (!found) && (comparetoken <= maxkeyword) );
   if (found)
   {
      linepointer += synlen[comparetoken];
      if (*linepointer)
         linepointer += strspn(linepointer, " \t");
      *linetype = comparetoken;
      return linepointer;
   }
   else
   {
      *linetype = NORMAL;
      return NULL;
   }
}

/* Print program usage and quit */
void usage()
{
	fprintf(stderr, "Usage: ifstrip [-n] [-w] [-x[ext]] [-f switchfile] file ...\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "    -n  produce no output files\n");
	fprintf(stderr, "    -w  suppresses warning levels\n");
	fprintf(stderr, "    -f  next argument is the switch file\n");
	fprintf(stderr, "    -e  next argument is the error/warning file\n");
	fprintf(stderr, "    -c  comment retained else/endifs with switch condition\n");
	fprintf(stderr, "    -C  save as -C, but C++ style (//) comments\n");
	fprintf(stderr, "    -z  treat numbers (e.g., #if 0) like identifiers\n");
	fprintf(stderr, "    -x  specify extension to use on output files\n");
	fprintf(stderr, "        none means use source extension but put in\n");
	fprintf(stderr, "        current directory (source must be in other dir)\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "    file list may contain wild cards\n");
	exit(1);
}



int exclude(struct _finddata_t f_data)
{
    if ( f_data.attrib & _A_SUBDIR )
    {
        printf("%s is a directory\n", f_data.name);
        return 1;
    }
    return 0;
}



void gdir( char * dst, char * src)
{
    int i;
    for ( i = strlen(src) -1; i >= 0 && (src[i] != '\\'); i--);
    strncpy(dst, src, i);
    dst[i] = 0;
}



/* Main program - parse command line, process each file */
void main(argc, argv)
int argc;
char *argv[];
{
	char *errorfilename;
	char *switchfilename = "switches";
	char outfilename[MAXFILENAMELEN];
    int ferrorfile = FALSE;
	int nooutput = FALSE;
	struct _finddata_t f_data;
	long h_find;
    char base_dir[256], curr_dir[256];
    int i;

	for (i = 1; i < argc; ++i) {
		if (argv[i][0] != '-')
			break;
		switch (argv[i][1]) {
		case 'w':
			warnings = FALSE;
			break;
		case 'f':
			++i;
			switchfilename = argv[i];
			break;
		case 't':
			++ terseFlag;
			break;
		case 'z':
		    nonumbers = TRUE;
			break;

      case 'e':
         ++i;
         errorfilename = argv[i];
         ferrorfile = TRUE;
         break;
		case 'x':
			if (argv[i][2] == '\0')
				currdir = TRUE;
			else if (argv[i][2] == '.')
				strncpy(extension, argv[i]+2, 4);
                                /* period was supplied */
			else
				strncpy(extension+1, argv[i]+2, 3);
                                /* period not supplied */
			break;
		case 'n':
			nooutput = TRUE;
			break;
        case 'c':
            commstyle = CSTYLE;
            break;
        case 'C':
            commstyle = CPPSTYLE;
            break;
        case 'a':
            progtype = CRT;
            break;
		default:
			fprintf(errorfile, "unknown switch \"%s\"\n", argv[i]);
			usage();
		}
	}

	if (i >= argc)
		usage();

   if (ferrorfile)
   {
      errorfile = fopen(errorfilename, "a");
      if (errorfile == NULL)
      {
         fprintf(stderr, "cannot open \"%s\" for error, using stderr\n",
                           errorfilename);
         ferrorfile = FALSE;
         errorfile = stderr;
      }
   }
   else
      errorfile = stderr;

	readsyms(switchfilename);

    if ( _getcwd(base_dir, 255) == NULL) 
        exit(0);
	for ( ; i < argc; ++i) {
        gdir(curr_dir, argv[i]);
        if (_chdir(curr_dir) == -1) {
            printf("%s: %s\n", curr_dir, strerror(errno));
            exit(0);
        }
		if ( (h_find = _findfirst(argv[i], &f_data)) == -1)
			continue;
        do
		{
			if ( exclude(f_data) != 1)
			{
                curr_file = f_data.name;
                linenum = 0;
                setfiletype(curr_file);
                if (nooutput)
                    strcpy(outfilename, "nul");
                else
                    makenewname(curr_file, outfilename);
                infile = fopen(curr_file, "r");
                if (infile == NULL) {
                    printf("%s which is %s is somewhat wrong, and the length is %d\n",f_data.name, strerror(errno),  strlen(f_data.name));
                    error("cannot open file for input", "");
                }
                outfile = fopen(outfilename, "w");
                if (outfile == NULL) {
                    fprintf(stderr, "cannot open \"%s\" for output\n",
                        outfilename);
                    exit(1);
                }
                stripprog();
                fclose(infile);
                fclose(outfile);
            }
        } while ( _findnext(h_find, &f_data) == 0);
		_findclose(h_find);
        if (_chdir(base_dir) == -1) {
            printf("%s: %s\n", curr_dir, strerror(errno));
            exit(0);
        }
    }
   if (ferrorfile)
   	fclose(errorfile);

   exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\srcrel\mkclnmkf.c ===
/*
 * MkClnMkf - generates the makefile to cleanse the VC++ v7.0 CRTL sources
 *	in preparation for a Microsoft-internal build of the CRTL.  Those
 *	cleansed sources will also be used for the publicly-released CRTL
 *	source as a part of the VC++ 7.0 retail product.
 *
 * Programmed by Steve Salisbury, 1994-12-07 Wed
 *
 * This program takes 7 arguments:
 *	prefixSrc - path to the raw VC++ 7.0 CRTL sources
 *	prefixDst - path to the partly cleansed VC++ 7.0 CRTL sources
 *	prefixDst2 - path to the final cleansed VC++ 7.0 CRTL sources
 *	inputRaw - a list of raw input files
 *	inputCln - a list of the input files that must be cleansed
 *	output - name of the first output file (may not already exist)
 *	outputRel - name of the second output file (may not already exist)
 *
 * Modified by Steve Salisbury, 1994-12-15 Thu
 *	Restore the crtw32/ and fpw32/ subdirectories
 *	Automate the generation of the directory list
 *
 * Modified 1995-01-16 Mon - take directory list from an input file, too.
 *
 * Modified 1995-01-17 Tue - many changes to make things work when removing
 *	crtw32/ and fpw32/ directories from the target filename paths.
 *
 * Modified 1995-01-18 Wed - The 3 files cleansed with bldmkf.sed should
 *	have that file as an explicit dependency.
 *
 * Modified 1995-01-23 Mon - Add a second output file
 *
 * Modified 1996-06-27 Thu - Fix off by 1 error in list allocation
 *
 * Modified 1997-08-14 Thu (Jamie) - Revved version strings from 4.0 => 6.0
 *
 * Modified 1999-05-16 Sun (PhilipLu) - Removed MAC support
 *
 * Modified 1999-08-02 Mon (PhilipLu) - Revved version strings from 6.0 => 7.0
 *
 * Modified 1999-08-06 Fri (PhilipLu) - Set .RC file names by cmdline switches
 *
 * Modified 1999-10-17 Sun (PhilipLu) - Add -noclean options
 */


/*-
 * Build Version Options
-*/

/* define KEEPDIRS */


/*-
 * Include Header Files
-*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>


/*-
 * Define Constants
-*/

#define MAXARGLEN	128

#define	CRTW32	"crtw32\\"

#define	FPW32	"fpw32\\"


/*-
 * Define VERBOSE to get verbose output makefiles
-*/

#ifdef VERBOSE
#define	AT	""
#else
#define	AT	"@"
#endif


#if	defined(_BUILD_IA64)
#define TOOLDIR "..\\libw32\\tools\\i386"
#define CPUDIR	"ia64"
#elif	defined(_BUILD_AMD64)
#define TOOLDIR "..\\libw32\\tools\\i386"
#define CPUDIR	"amd64"
#elif	defined(_M_IA64)
#define TOOLDIR "..\\libw32\\tools\\ia64"
#define CPUDIR	"ia64"
#elif	defined(_M_IX86)
#define TOOLDIR "..\\libw32\\tools\\i386"
#define CPUDIR	"intel"
#endif

#define INTEL_DIR	"intel"

/*-
 * Define Global Variables (Constants)
-*/

#ifndef KEEPDIRS
char fmtRaw2 [ ] =
	"%s%s: %s%s %ssrcrel\\bldmkf.sed\n"
	"\t"	AT "echo Copying %s from %s to %s. (using SED.EXE)\n"
	"\t"	AT "if exist %s%s attrib -r %s%s\n"
	"\t"	AT "sed -f %ssrcrel\\bldmkf.sed %s%s > %s%s\n"
	"\t"	AT "attrib +r %s%s\n"
	"\n" ;
#endif /* KEEPDIRS */

char fmtRaw [ ] =
	"%s%s: %s%s\n"
	"\t"	AT "echo Copying %s from %s to %s.\n"
	"\t"	AT "if exist %s%s attrib -r %s%s\n"
	"\t"	AT "copy /b %s%s %s%s >nul\n"
	"\t"	AT "attrib +r %s%s\n"
	"\n" ;

char fmtCln2 [ ] =
	"%s%s: %s%s %ssrcrel\\msvc40.if\n"
	"\t"	AT "echo Cleansing %s%s\n"
	"\t"	AT "if exist %s%s attrib -r %s%s\n"
	"\t"	AT TOOLDIR "\\detab < %s%s | " TOOLDIR "\\trailing > %s%s\n"
	"\t"	AT "rem *\n"
	"\t"	AT "rem * IFSTRIP is NOT used on .INC assembler include files!\n"
	"\t"	AT "rem *\n"
	"\t"	AT "rem " TOOLDIR "\\ifstrip -z -c -t -x.TMP -f %ssrcrel\\msvc40.if %s%s\n"
	"\t"	AT "rem del %s%s\n"
	"\t"	AT "rem ren %s%s.TMP *%s\n"
	"\t"	AT TOOLDIR "\\striphdr -r %s%s\n"
	"\t"	AT "del %s%s\n"
	"\t"	AT "ren %s%s.NEW *%s\n"
	"\t"	AT "attrib +r %s%s\n"
	"\n" ;

char fmtCln [ ] =
	"%s%s: %s%s %ssrcrel\\msvc40.if\n"
	"\t"	AT "echo Cleansing %s%s\n"
	"\t"	AT "if exist %s%s attrib -r %s%s\n"
	"\t"	AT TOOLDIR "\\detab < %s%s | " TOOLDIR "\\trailing > %s%s\n"
	"\t"	AT TOOLDIR "\\ifstrip -z -c -t -x.TMP -f %ssrcrel\\msvc40.if %s%s\n"
	"\t"	AT "del %s%s\n"
	"\t"	AT "ren %s%s.TMP *%s\n"
	"\t"	AT TOOLDIR "\\striphdr -r %s%s\n"
	"\t"	AT "del %s%s\n"
	"\t"	AT "ren %s%s.NEW *%s\n"
	"\t"	AT "attrib +r %s%s\n"
	"\n" ;

const char prefixSrc [ ] = "$(SRC)\\" ;

const char prefixDst [ ] = "$(DST)\\" ;

char * * DirList ;

const char * szRcFiles [ 2 ] [ 2 ] [ 3 ] =
{
	{
		{ "msvcirt.rc"   , "msvcprt.rc"   , "msvcrt.rc"   } ,
		{ "msvcirt.rc"   , "msvcprt.rc"   , "msvcrt.rc"   }
	} ,
	{
		{ "sysirt.rc"    , "sysprt.rc"    , "syscrt.rc"   } ,
		{ "sysirt64.rc"  , "sysprt64.rc"  , "syscrt64.rc" }
	}
} ;

/*-
 * Function Declarations (Prototypes)
-*/

int main ( int argc , char * * argv ) ;

void Usage ( void ) ;

char * fgetsNL ( char * lineBuf , int lineSize , FILE * fileInput ) ;

void Progress ( int prefix , char * string , int suffix ) ;

char * SkipFirstDir ( char * string ) ;


/*-
 * Function Definitions (Implementations)
-*/

int main ( int argc , char * * argv )
{
	FILE * inputRaw ;
	FILE * inputCln ;
	FILE * inputDir ;
	FILE * output ;
	FILE * output2 ;
	char lineRaw [ MAXARGLEN ] ;
	char lineCln [ MAXARGLEN ] ;
	char * rvRaw ;
	char * rvCln ;
	char * defaultSrc ;
	char * defaultDst ;
	char * defaultDst2 ;
	char * lineSkip ;
	char * * pDirs ;
	time_t timestamp ;
	struct tm localt ;
	char * * nextArg ;
	int fSysCrt = 0;
	int fCrt64 = 0;
	int fNoClean = 0;

	nextArg = ++ argv ;

	while ( * nextArg != NULL && * * nextArg == '-' )
	{
		if ( strcmp ( * nextArg , "-sys" ) == 0 )
		{
			fSysCrt = 1 ;
		}
		else if ( strcmp ( * nextArg , "-64" ) == 0 )
		{
			fCrt64 = 1 ;
		}
		else if ( strcmp ( * nextArg , "-noclean" ) == 0 )
		{
			fNoClean = 1 ;
		}
		else
		{
			Usage ( ) ;
			exit ( 1 ) ;
		}

		nextArg = ++ argv ;
		-- argc ;
	}

	if ( -- argc != 8 )
	{
		Usage ( ) ;
		exit ( 1 ) ;
	}

	defaultSrc = * nextArg ;
	++ nextArg ;
	defaultDst = * nextArg ;
	++ nextArg ;
	defaultDst2 = * nextArg ;
	++ nextArg ;
	
	if ( ( inputRaw = fopen ( * nextArg , "rt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open input file \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	if ( ( inputCln = fopen ( * nextArg , "rt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open input file \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	if ( ( inputDir = fopen ( * nextArg , "rt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open input file \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	if ( ( output = fopen ( * nextArg , "rb" ) ) != NULL )
	{
		fprintf ( stderr , "mkclnmkf: first output file already exists: \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}

	if ( ( output = fopen ( * nextArg , "wt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open first output file: \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	if ( ( output2 = fopen ( * nextArg , "rb" ) ) != NULL )
	{
		fprintf ( stderr , "mkclnmkf: second output file already exists: \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}

	if ( ( output2 = fopen ( * nextArg , "wt" ) ) == NULL )
	{
		fprintf ( stderr , "mkclnmkf: cannot open second output file: \"%s\"\n" ,
			* nextArg ) ;
		exit ( 1 ) ;
	}
	++ nextArg ;

	/*-
	 * Read in the list of directories
	-*/

	{
		int numDirs = 0 ;
		int maxNumDirs = 0 ;
		char nextDir [ MAXARGLEN ] ;
		char * pDir ;

		pDir = fgetsNL ( nextDir , sizeof ( nextDir ) , inputDir ) ;

		while ( pDir )
		{
			if ( numDirs + 1 >= maxNumDirs )
			{
				maxNumDirs += 16 ;
				if ( ! ( DirList = ( char * * ) realloc ( DirList ,
					sizeof ( char * ) * maxNumDirs ) ) )
				{
					fprintf ( stderr ,
						"mkclnmkf: realloc failed (maxNumDirs=%d)\n" ,
							maxNumDirs ) ;

					exit ( 1 ) ;
				}
			}

			DirList [ numDirs ] = _strdup ( nextDir ) ;

			if ( ! DirList [ numDirs ] )
			{
				fprintf ( stderr ,
					"mkclnmkf: strdup failed (nextDir=\"%s\")\n" ,
						nextDir ) ;

				exit ( 1 ) ;
			}

			++ numDirs ;

			pDir = fgetsNL ( nextDir , sizeof ( nextDir ) , inputDir ) ;
		}

		DirList [ numDirs ] = NULL ;

		{
			int i ;

			fprintf ( stderr , "Reading in directory list...\n" ) ;

			for ( i = 0 ; DirList [ i ] ; ++ i )
				Progress ( '(' , DirList [ i ] , ')' ) ;

			Progress ( '(' , NULL , ')' ) ;
		}
	}

	if ( fclose ( inputDir ) )
	{
		fprintf ( stderr ,
			"mkclnmkf: error closing input file \"%s\"\n" ,
			* nextArg ) ;
	}

	/*
	 * Generate MAKEFILE header comment
	 */

	time ( & timestamp ) ;

	localt = * localtime ( & timestamp ) ;

	fprintf ( output ,
	"########\n"
	"#\n"
	"# This is a program-generated Makefile, the purpose of which is to\n"
	"# copy Visual C++ v7.0 C Run-Time Library Source files from the raw\n"
	"# source tree to a directory structure suitable for end user usage\n"
	"# in debugging and modification.  Not all of the VC++ 7.0 CRTL srcs\n"
	"# are provided to end users, but the ones that are 'cleansed' using\n"
	"# an automated process.  Another makefile will copy these cleansed\n"
	"# files to their final directory lay-out.\n"
	"#\n"
	"# This Makefile was generated on\n"
	"#\t\t%.3s %2d %4d at %02d:%02d:%02d\n"
	"#\n"
	"# The program that generated this Makefile was compiled on\n"
	"#\t\t" __DATE__ " at " __TIME__ "\n"
	"\n"
	"!if \"$(SRC)\"==\"\"\n"
	"SRC=%s\n"
	"!endif\n"
	"\n"
	"!if \"$(DST)\"==\"\"\n"
	"DST=%s\n"
	"!endif\n"
	"\n"
	"all:\tdirs files\n"
	"\n"
	"files: \\\n" ,
		localt . tm_mon * 3 + "JanFebMarAprMayJunJulAugSepOctNovDec" ,
		localt . tm_mday , localt . tm_year + 1900 ,
		localt . tm_hour , localt . tm_min , localt . tm_sec ,
		defaultSrc , defaultDst ) ;


	fprintf ( output2 ,
	"########\n"
	"#\n"
	"# This is a program-generated Makefile, the purpose of which is to\n"
	"# copy the cleansed Visual C++ v7.0 C Run-Time Library Source files\n"
	"# to their directory lay-out which will be received by end users.\n"
	"#\n"
	"# This Makefile was generated on\n"
	"#\t\t%.3s %2d %4d at %02d:%02d:%02d\n"
	"#\n"
	"# The program that generated this Makefile was compiled on\n"
	"#\t\t" __DATE__ " at " __TIME__ "\n"
	"\n"
	"!if \"$(SRC)\"==\"\"\n"
	"SRC=%s\n"
	"!endif\n"
	"\n"
	"!if \"$(DST)\"==\"\"\n"
	"DST=%s\n"
	"!endif\n"
	"\n"
	"all:\tdirs files\n"
	"\n"
	"dirs:\n"
	"\t" AT "if not exist %s" CPUDIR "\\NUL mkdire %s" CPUDIR "\n"
#if	defined(_BUILD_IA64)
	"\t" AT "if not exist %s" INTEL_DIR "\\NUL mkdire %s" INTEL_DIR "\n"
#endif
	"\t" AT "if not exist %ssys\\NUL mkdire %ssys\n"
	"\t" AT "if not exist %sbuild\\NUL mkdire %sbuild\n"
	"\t" AT "if not exist %sbuild\\" CPUDIR "\\NUL mkdire %sbuild\\" CPUDIR "\n"
	"\n"
	"files: \\\n"
	"\t%s%s \\\n"
	"\t%s%s \\\n"
	"\t%s%s \\\n"
	"\t%smsvcrt40.rc \\\n"
	"\t%smakefile \\\n"
	"\t%smakefile.inc \\\n"
	"\t%smakefile.sub \\\n" ,
		localt . tm_mon * 3 + "JanFebMarAprMayJunJulAugSepOctNovDec" ,
		localt . tm_mday , localt . tm_year + 1900 ,
		localt . tm_hour , localt . tm_min , localt . tm_sec ,
		defaultDst , defaultDst2 ,
		/* if not exist ... CPUDIR */
		prefixDst , prefixDst ,
#if	defined(_BUILD_IA64)
		/* if not exist intel */
		prefixDst , prefixDst ,
#endif
		/* if not exist sys */
		prefixDst , prefixDst ,
		/* if not exist build ... */
		prefixDst , prefixDst ,
		prefixDst , prefixDst ,
		/* RC files... */
		prefixDst , szRcFiles [ fSysCrt ] [ fCrt64 ] [ 0 ] ,
		prefixDst , szRcFiles [ fSysCrt ] [ fCrt64 ] [ 1 ] ,
		prefixDst , szRcFiles [ fSysCrt ] [ fCrt64 ] [ 2 ] ,
		prefixDst ,
		/* makefile.{,inc,sub} */
		prefixDst , prefixDst , prefixDst ) ;

	/*
	 * Generate default ("all") dependecy
	 */

	/*-
	 * First, files that are just copied
	-*/

	rvRaw = fgetsNL ( lineRaw , sizeof ( lineRaw ) , inputRaw ) ;

	while ( rvRaw )
	{
		lineSkip = lineRaw ;

#ifndef KEEPDIRS
		if ( ! strncmp ( "crtw32\\" , lineSkip , 7 ) )
			lineSkip += 7 ;
		else if ( ! strncmp ( "fpw32\\" , lineSkip , 6 ) )
			lineSkip += 6 ;
#endif /* KEEPDIRS */

		fprintf ( output , "\t%s%s \\\n" ,
			prefixDst , lineSkip ) ;

		if ( ! memcmp ( lineSkip , "stdcpp\\" , 7 )
		  || ! memcmp ( lineSkip , "stdhpp\\" , 7 ) )
		{
			/*
			 * Files in the stdcpp / stdhpp directories are
			 * special cases -- they are not cleansed but are
			 * copied to the crt/src/ directory.
			 */
			fprintf ( output2 , "\t%s%s \\\n" ,
				prefixDst , lineSkip + 7 ) ;
		}

		if ( ! memcmp ( lineSkip , "stdcpp64\\" , 9 )
		  || ! memcmp ( lineSkip , "stdhpp64\\" , 9 ) )
		{
			/* same goes for stdcpp64 / stdhpp64 */
			fprintf ( output2 , "\t%s%s \\\n" ,
				prefixDst , lineSkip + 9 ) ;
		}

		if ( ! memcmp ( lineSkip , "heap\\" , 5 )
		  &&   strcmp ( lineSkip , "heap\\lsources" ) )
		{
			/* same goes for heap\*opnt.cpp */
			fprintf ( output2 , "\t%s%s \\\n" ,
				prefixDst , lineSkip + 5 ) ;
		}

		rvRaw = fgetsNL ( lineRaw , sizeof ( lineRaw ) , inputRaw ) ;
	}
	
	/*-
	 * Second, files that have be cleansed
	-*/

	rvCln = fgetsNL ( lineCln , sizeof ( lineCln ) , inputCln ) ;

	while ( rvCln )
	{
		lineSkip = lineCln ;

#ifndef KEEPDIRS
		if ( ! strncmp ( "crtw32\\" , lineSkip , 7 ) )
			lineSkip += 7 ;
		else if ( ! strncmp ( "fpw32\\" , lineSkip , 6 ) )
			lineSkip += 6 ;
#endif /* KEEPDIRS */

		fprintf ( output , "\t%s%s \\\n" ,
			prefixDst , lineSkip ) ;

		fprintf ( output2 , "\t%s%s \\\n" ,
			prefixDst , SkipFirstDir ( lineSkip ) ) ;

		rvCln = fgetsNL ( lineCln , sizeof ( lineCln ) , inputCln ) ;
	}

	fprintf ( output ,
		"\n\n# Directory Dependencies:\n\ndirs:\n"
		"\t" AT "if not exist %sbuild\\NUL mkdire %sbuild\n" ,
			prefixDst , prefixDst ) ;

#ifdef BLDROOTDIR
	/*
	 * Create Root Directory Component by Component
	 *	NOTE: this code assumes prefixDst resembles:
	 *		\msdev\crt\src\
	 */

	{
		char temp [ MAXARGLEN ] ;
		char * prefixSlash ;
		char * prefixNext ;
		int len ;

		strcpy ( temp , prefixDst ) ;
		len = strlen ( temp ) ;

		if ( temp [ len - 1 ] == '\\' )
			temp [ len - 1 ] = '\0' ;

		prefixNext = prefixDst + 1 ;

		while ( prefixSlash = strchr ( prefixNext , '\\' ) )
		{
			temp [ prefixSlash - prefixDst ] = '\0' ;

			fprintf ( output ,
	"\t" AT "if not exist %s\\NUL mkdire %s\n" ,
				temp , temp ) ;

			prefixNext = prefixSlash + 1 ;
			temp [ prefixSlash - prefixDst ] = '\\' ;
		}
	}
#endif /* BLDROOTDIR */

	/*
	 * Create Directories
	 */

	for ( pDirs = DirList ; * pDirs ; ++ pDirs )
	{
		char * targetDir ;

		targetDir = * pDirs ;

#ifndef KEEPDIRS
		if ( ! strcmp ( "crtw32" , targetDir )
		  || ! strcmp ( "fpw32" , targetDir ) )
			continue ;

		if ( ! strncmp ( "crtw32\\" , targetDir , 7 ) )
			targetDir += 7 ;
		else if ( ! strncmp ( "fpw32\\" , targetDir , 6 ) )
			targetDir += 6 ;
#endif /* KEEPDIRS */

		fprintf ( output ,
	"\t" AT "if not exist %s%s\\NUL mkdire %s%s\n" ,
			prefixDst , targetDir ,
			prefixDst , targetDir ,
			prefixDst , targetDir ) ;
	}

	fprintf ( output , "\n\n#\n# Individual Dependencies:\n#\n\n" ) ;

	/*
	 * Second output makefile has some special targets
	 */

	fprintf ( output2 , "\n\n#\n# Individual Dependencies:\n#\n\n" ) ;
	
	{
		static char * listMkf [ ] =
		{
			"makefile" , "makefile.inc" , "makefile.sub" , NULL
		} ;

		static const char * listSpc [ ] =
		{

			"msvcirt.rc" , "msvcprt.rc" , "msvcrt.rc" ,
			"msvcrt40.rc" , NULL
		} ;

		int i ;

		listSpc [ 0 ] = szRcFiles [ fSysCrt ] [ fCrt64 ] [ 0 ] ;
		listSpc [ 1 ] = szRcFiles [ fSysCrt ] [ fCrt64 ] [ 1 ] ;
		listSpc [ 2 ] = szRcFiles [ fSysCrt ] [ fCrt64 ] [ 2 ] ;

		for ( i = 0 ; listSpc [ i ] ; ++ i )
			fprintf ( output2 ,
				"%s%s: %slibw32\\%s\n"
				"\t" AT "echo Copying %s from %s to %s.\n"
				"\t" AT "if exist %s%s attrib -r %s%s\n"
				"\t" AT "copy /b $** $@ >NUL\n"
				"\t" AT "attrib +r %s%s\n"
				"\n" ,
				/* %s%s: %slibw32\\%s */
				prefixDst , listSpc [ i ] ,
				prefixSrc , listSpc [ i ] ,
				/* echo Copying %s from %s to %s. */
				listSpc [ i ] , prefixSrc , prefixDst ,
				/* if exist %s%s attrib -r %s%s */
				prefixDst , listSpc [ i ] ,
				prefixDst , listSpc [ i ] ,
				/* copy /b $** $@ >NUL */
				/* attrib +r %s%s */
				prefixDst , listSpc [ i ] ) ;

		for ( i = 0 ; listMkf [ i ] ; ++ i )
			fprintf ( output2 ,
				"%s%s: %s%s relmkf.sed\n"
				"\t" AT "echo Copying %s from %s to %s. (using SED)\n"
				"\t" AT "if exist %s%s attrib -r %s%s\n"
				"\t" AT "sed -f relmkf.sed %s%s > $@\n"
				"\t" AT "attrib +r %s%s\n"
				"\n" ,
				/* %s%s: %slibw32\\%s */
				prefixDst , listMkf [ i ] ,
				prefixSrc , listMkf [ i ] ,
				/* echo Copying %s from %s to %s. */
				listMkf [ i ] , prefixSrc , prefixDst ,
				/* if exist %s%s attrib -r %s%s */
				prefixDst , listMkf [ i ] ,
				prefixDst , listMkf [ i ] ,
				/* sed -f relmkf.sed %s%s > $@ */
				prefixSrc , listMkf [ i ] ,
				/* attrib +r %s%s */
				prefixDst , listMkf [ i ] ) ;
	}

	/*
	 * Reset input files for another pass: individual dependencies
	 */

	if ( fseek ( inputRaw , 0L , SEEK_SET )
	  || fseek ( inputCln , 0L , SEEK_SET ) )
	{
		fprintf ( stderr , "mkclnmkf: cannot reset input file(s)\n" ) ;
		exit ( 1 ) ;
	}


	/*
	 * Generate individual dependecies for files that are copied as-is
	 */

	fprintf ( stderr , "Producing copied file dependencies...\n" ) ;

	fprintf ( output , "# Copied File Dependencies:\n\n" ) ;

	rvRaw = fgetsNL ( lineRaw , sizeof ( lineRaw ) , inputRaw ) ;

	while ( rvRaw )
	{
		lineSkip = lineRaw ;

#ifndef KEEPDIRS
		/*
		 * strip crtw32\ and fpw32\ from the input string
		 */

		if ( ! strncmp ( "crtw32\\" , lineSkip , 7 ) )
			lineSkip += 7 ;
		else if ( ! strncmp ( "fpw32\\" , lineSkip , 6 ) )
			lineSkip += 6 ;

		if ( ( lineRaw [ 0 ] != 'f'
		  || strcmp ( lineSkip + strlen ( lineSkip ) - 9 , "\\lsources" ) )
		  && strcmp ( "makefile" , lineRaw ) )
#endif /* KEEPDIRS */

			fprintf ( output , fmtRaw ,
				/* %s%s: %s%s */
				prefixDst , lineSkip , prefixSrc , lineRaw ,
				/* echo Copying %s from %s to %s */
				lineSkip , prefixSrc , prefixDst ,
				/* if exist %s%s attrib -r %s%s */
				prefixDst , lineSkip , prefixDst , lineSkip ,
				/* copy /b %s%s %s%s */
				prefixSrc , lineRaw , prefixDst , lineSkip ,
				/* attrib +r %s%s */
				prefixDst , lineSkip ) ;
#ifndef KEEPDIRS
		else
			fprintf ( output , fmtRaw2 ,
				/* %s%s: %s%s %ssrcrel\\bldmkf.sed */
				prefixDst , lineSkip ,
				prefixSrc , lineRaw , prefixSrc ,
				/* echo Copying %s from %s to %s */
				lineSkip , prefixSrc , prefixDst ,
				/* if exist %s%s attrib -r %s%s */
				prefixDst , lineSkip , prefixDst , lineSkip ,
				/* sed -f %ssrcrel\\bldmkf.sed %s%s > %s%s */
				prefixSrc ,
				prefixSrc , lineRaw , prefixDst , lineSkip ,
				/* attrib +r %s%s */
				prefixDst , lineSkip ) ;
#endif /* KEEPDIRS */

		if ( ! memcmp ( lineSkip , "stdcpp\\" , 7 )
		  || ! memcmp ( lineSkip , "stdhpp\\" , 7 ) )
		{
			/*
			 * Files in the stdcpp / stdhpp directories are
			 * special cases -- they are not cleansed but are
			 * copied to the crt/src/ directory.
			 */
			fprintf ( output2 , "%s%s: %s%s\n"
				"\t" AT "echo Copying %s from %s to %s.\n"
				"\t" AT "if exist %s%s attrib -r %s%s\n"
				"\t" AT "copy /b %s%s %s%s\n"
				"\t" AT "attrib +r %s%s\n"
				"\n" ,
				prefixDst , lineSkip + 7 ,
				prefixSrc , lineSkip ,
				lineRaw , prefixSrc , prefixDst ,
				prefixDst , lineSkip + 7 ,
				prefixDst , lineSkip + 7 ,
				prefixSrc , lineSkip ,
				prefixDst , lineSkip + 7 ,
				prefixDst , lineSkip + 7 ) ;
		}

		if ( ! memcmp ( lineSkip , "stdcpp64\\" , 9 )
		  || ! memcmp ( lineSkip , "stdhpp64\\" , 9 ) )
		{
			/* Same goes for stdcpp64 / stdhpp64 */
			fprintf ( output2 , "%s%s: %s%s\n"
				"\t" AT "echo Copying %s from %s to %s.\n"
				"\t" AT "if exist %s%s attrib -r %s%s\n"
				"\t" AT "copy /b %s%s %s%s\n"
				"\t" AT "attrib +r %s%s\n"
				"\n" ,
				prefixDst , lineSkip + 9 ,
				prefixSrc , lineSkip ,
				lineRaw , prefixSrc , prefixDst ,
				prefixDst , lineSkip + 9 ,
				prefixDst , lineSkip + 9 ,
				prefixSrc , lineSkip ,
				prefixDst , lineSkip + 9 ,
				prefixDst , lineSkip + 9 ) ;
		}

		if ( ! memcmp ( lineSkip , "heap\\" , 5 )
		  &&   strcmp ( lineSkip , "heap\\lsources" ) )
		{
			/* Same goes for heap\*opnt.cpp */
			fprintf ( output2 , "%s%s: %s%s\n"
				"\t" AT "echo Copying %s from %s to %s.\n"
				"\t" AT "if exist %s%s attrib -r %s%s\n"
				"\t" AT "copy /b %s%s %s%s\n"
				"\t" AT "attrib +r %s%s\n"
				"\n" ,
				prefixDst , lineSkip + 5 ,
				prefixSrc , lineSkip ,
				lineRaw , prefixSrc , prefixDst ,
				prefixDst , lineSkip + 5 ,
				prefixDst , lineSkip + 5 ,
				prefixSrc , lineSkip ,
				prefixDst , lineSkip + 5 ,
				prefixDst , lineSkip + 5 ) ;
		}

		Progress ( '[' , lineRaw , ']' ) ;

		rvRaw = fgetsNL ( lineRaw , sizeof ( lineRaw ) , inputRaw ) ;
	}

	Progress ( '[' , NULL , ']' ) ;

	/*
	 * Generate individual dependecies for files that are cleansed
	 */

	fprintf ( stderr , "Producing cleansed file dependencies...\n" ) ;

	fprintf ( output , "# Cleansed File Dependencies:\n\n" ) ;

	rvCln = fgetsNL ( lineCln , sizeof ( lineCln ) , inputCln ) ;

	while ( rvCln )
	{
		char * pExt ;
		char pNoExt [ MAXARGLEN ] ;

		lineSkip = lineCln ;

#ifndef KEEPDIRS
		/*
		 * strip crtw32\ and fpw32\ from the input string
		 */

		if ( ! strncmp ( "crtw32\\" , lineSkip , 7 ) )
			lineSkip += 7 ;
		else if ( ! strncmp ( "fpw32\\" , lineSkip , 6 ) )
			lineSkip += 6 ;
#endif /* KEEPDIRS */

		pExt = strrchr ( lineSkip , '.' ) ;

		if ( ! pExt )
		{
			fprintf ( stderr ,
				"Warning: filename has no extension: %s\n" ,
				lineCln ) ;

			pExt = lineSkip + strlen ( pExt ) ;
		}

		strcpy ( pNoExt , lineSkip ) ;
		pNoExt [ pExt - lineSkip ] = '\0' ;

		if ( !fNoClean )

		    /*
		     * .INC files do not get ifstripped - use fmtCln2 for them
		     */

		    fprintf ( output ,
			    strcmp ( ".inc" , pExt ) ? fmtCln : fmtCln2 ,
			    /* %s%s: %scrtw32\%s %ssrcrel\msvc40.if */
			    prefixDst , lineSkip , prefixSrc , lineCln , prefixSrc ,
			    /* echo Cleansing %scrtw32\%s */
			    prefixDst , lineSkip ,
			    /* if exist %s%s attrib -r %s%s */
			    prefixDst , lineSkip , prefixDst , lineSkip ,
			    /* detab < %scrtw32\%s | trailing > ... */
			    prefixSrc , lineCln , prefixDst , lineSkip ,
			    /* ifstrip %s\srcrel\msvc40.if %s%s */
			    prefixSrc , prefixDst , lineSkip ,
			    /* del %s%s */
			    prefixDst , lineSkip ,
			    /* ren %s%s.TMP *%s */
			    prefixDst , pNoExt , pExt ,
			    /* striphdr -r %s%s */
			    prefixDst , lineSkip ,
			    /* del %s%s */
			    prefixDst , lineSkip ,
			    /* ren %s%s.NEW *%s */
			    prefixDst , pNoExt , pExt ,
			    /* attrib +r %s%s */
			    prefixDst , lineSkip ) ;

		else

		    /*
		     * -noclean: Just copy, don't cleanse, for development builds
		     */

		    fprintf ( output , fmtRaw ,
			    /* %s%s: %s%s */
			    prefixDst , lineSkip , prefixSrc , lineCln ,
			    /* echo Copying %s from %s to %s */
			    lineSkip , prefixSrc , prefixDst ,
			    /* if exist %s%s attrib -r %s%s */
			    prefixDst , lineSkip , prefixDst , lineSkip ,
			    /* copy /b %s%s %s%s */
			    prefixSrc , lineCln , prefixDst , lineSkip ,
			    /* attrib +r %s%s */
			    prefixDst , lineSkip ) ;

		/*
		 * Secondary makefile
		 */

		if ( memcmp ( "libw32" , lineCln , 6 ) )
		{
			char * lineSkipFirst = SkipFirstDir ( lineSkip ) ;

			if ( ! strcmp ( ".asm" , pExt ) &&
			   (  ! memcmp ( "mbstring" , lineSkip , 8 )
			   || ! strcmp ( "memmove.asm" , pExt - 7 )
			   || ! strcmp ( "strcspn.asm" , pExt - 7 )
			   || ! strcmp ( "strpbrk.asm" , pExt - 7 ) )
			  || ! strcmp ( ".c" , pExt ) &&
			   (  ! strcmp ( "mbscat.c" , pExt - 6 )
			   || ! strcmp ( "mbsdup.c" , pExt - 6 ) ) )
				fprintf ( output2 ,
					"%s%s: %s%s asmfile.sed\n"
					"\t" AT "echo Copying %s from %s to %s. (using SED.EXE)\n"
					"\t" AT "if exist %s%s attrib -r %s%s\n"
					"\t" AT "sed -f asmfile.sed %s%s > $@\n"
					"\t" AT "attrib +r %s%s\n"
					"\n" ,
					/* %s%s: %s%s asmfile.sed */
					prefixDst , lineSkipFirst ,
					prefixSrc , lineSkip ,
					/* echo Copying %s from %s to %s... */
					lineSkip , prefixSrc , prefixDst ,
					/* if exist %s%s attrib -r %s%s */
					prefixDst , lineSkipFirst ,
					prefixDst , lineSkipFirst ,
					/* sed -f asmfile.sed %s%s > $@ */
					prefixSrc , lineSkip ,
					/* attrib +r %s%s */
					prefixDst , lineSkipFirst ) ;
			else
				fprintf ( output2 ,
					"%s%s: %s%s\n"
					"\t" AT "echo Copying %s from %s to %s.\n"
					"\t" AT "if exist %s%s attrib -r %s%s\n"
					"\t" AT "copy /b $** $@ >NUL\n"
					"\t" AT "attrib +r %s%s\n"
					"\n" ,
					/* %s%s: %s%s */
					prefixDst , lineSkipFirst ,
					prefixSrc , lineSkip ,
					/* Copying %s from %s to %s */
					lineSkip , prefixSrc , prefixDst ,
					/* if exist %s%s attrib -r %s%s */
					prefixDst , lineSkipFirst ,
					prefixDst , lineSkipFirst ,
					/* copy /b $** $@ >NUL */
					/* attrib +r %s%s */
					prefixDst , lineSkipFirst ) ;
		}
	
		/*
		 * Show Progress 
		 */

		Progress ( '{' , lineSkip , '}' ) ;

		rvCln = fgetsNL ( lineCln , sizeof ( lineCln ) , inputCln ) ;
	}

	Progress ( '{' , NULL , '}' ) ;

	return 0 ;
}


/*
 * Usage - print message explaining the arguments to this program
 */

void Usage ( void )
{
	fprintf ( stderr ,
	"Usage: mkclnmkf [opts] prefIn prefOut prefOut2 fRaw fCln dirList mkfOut mkfOut2\n"
	"where\tprefIn is the input prefix (such as \"\\crt\")\n"
	"\tprefOut is the primary output prefix (such as \"\\msdev\\crt\\prebuild\")\n"
	"\tprefOut2 is the secondary output prefix (such as \"\\msdev\\crt\\src\")\n"
	"\tfRaw is a list of files to be copied as-is\n"
	"\tfCln is a list of files to be cleansed\n"
	"\tdirList is a list of the directories to be created\n"
	"\tmkfOut is the primary output makefile (it may not already exist)\n"
	"\tmkfOut2 is the secondary output makefile (it may not already exist)\n\n"
	"\tOptions:\n"
	"\t  -sys\t\tuse system CRT filenames\n"
	"\t  -64\t\tuse Win64 CRT filenames\n"
	"\t  -noclean\tdon't cleanse source files\n"
	) ;
}


/*
 * fgetsNL - same as fgets except final newline character is deleted
 *	Upon EOF or error, make sure the buffer is set to the empty string.
 */

char * fgetsNL ( char * lineBuf , int lineSize , FILE * fileInput )
{
	char * retval = fgets ( lineBuf , lineSize , fileInput ) ;

	if ( retval )
	{
		size_t len = strlen ( lineBuf ) ;

		if ( len < 1 || lineBuf [ len - 1 ] != '\n' )
		{
			fprintf ( stderr , "mkclnmkf: malformed input line:\n\t%s\n" , lineBuf ) ;
		}
		else
			lineBuf [ len - 1 ] = '\0' ;
	}
	else
		lineBuf [ 0 ] = '\0' ;

	return retval ;
}

void Progress ( int prefix , char * string , int suffix )
{
static	size_t prevlen = 0 ;
static	int counter = 0 ;

	if ( string == NULL )
	{
		fprintf ( stderr , "%*s\n" , prevlen + 3 , " " )  ;
		prevlen = 0 ;
		counter = 0 ;
	}
	else if ( ++ counter % 100 == 1 )
	{
		size_t length = strlen ( string ) ;

		fprintf ( stderr , "%c%s%c%*s\r" ,
			prefix , string , suffix ,
			prevlen > length ? prevlen - length : 1 ,
			" " ) ;

		prevlen = length ;
	}
}

char * SkipFirstDir ( char * string )
{
	char * pFile = string ;

	while ( * pFile ++ != '\\' )
		if ( ! * pFile )
		{
			fprintf ( stderr ,
				"mkclnmkf: no \\ in \"%s\"\n" , string ) ;
			exit ( 1 ) ;
		}

	return pFile ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\srcrel\striplin.c ===
/**
 *	StripLines - strips a text file (usually a Makefile) of
 *		Microsoft-proprietary or other specialized parts
 *
 *	Programmed by Steve Salisbury, Thu 18 May 1995
 *
 *	Fri 19 May 1995 -- add code to skips lines containing STRIPLIN! 
 *		Add line numbers to diagnostic messages
 *		Flag redundant STRIPLIN= directives (which are an error)
 *
 *	This program just copies stdin to stdout.  Depending on the
 *	value of a global state variable, some lines may be ignored.
 *
 *	... STRIPLIN=0 ...
 *		turns off line-by-line copying until STRIPLIN=1 or STRIPLIN=2
 *		is encountered, at which point lines will be copied again.
 *	... STRIPLIN=1 ...
 *		turns on line-by-line copying (initial state)
 *	... STRIPLIN=2 ...
 *		turns on line-by-line copying with deletion of
 *		initial # on each line (if there is one).  If
 *		an input line has no initial #, it is copied as-is.
 *	... STRIPLIN! ...
 *		this single line is not copied (regardless of the 0/1/2 state)
**/


/**
 *
 * Header Files
 *
**/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


/**
 *
 * Global Constants
 *
**/

#define	MAXLINELEN	4096


/**
 *
 * Global Variables
 *
**/

char InputLine [ MAXLINELEN ] ;

char ControlString[ ] = "STRIPLIN=" ;
char DeleteString[ ] = "STRIPLIN!" ;


/**
 *
 * Function Declarations (Prototypes)
 *
**/

int main ( int argc , char * argv [ ] ) ;


/**
 *
 * Function Definitions (Implementations)
 *
**/

int main ( int argc , char * argv [ ] )
{
	int	StateFlag = 1 ;
	int	LineNumber = 0 ;

	while ( fgets ( InputLine , sizeof ( InputLine ) , stdin ) )
	{
		char * pString ;

		++ LineNumber ;

		if ( pString = strstr ( InputLine , ControlString ) )
		{
			int NewStateFlag ;

			NewStateFlag = pString [ strlen ( ControlString ) ] - '0' ;

			if ( NewStateFlag < 0 || 2 < NewStateFlag )
			{
				fprintf ( stderr , "striplin: invalid directive:\n%d:\t%s\n" ,
					LineNumber , InputLine ) ;
				exit ( 1 ) ;
			}

			if ( NewStateFlag == StateFlag )
			{
				fprintf ( stderr , "striplin: redundant directive:\n%d:\t%s\n" ,
					LineNumber , InputLine ) ;
				exit ( 1 ) ;
			}

			StateFlag = NewStateFlag ;
		}
		else if ( StateFlag != 0 )
		{
			char * start = InputLine ;

			/*-
			 * If StateFlag is 2 and the line begins with #, skip the #
			-*/

			if ( StateFlag == 2 && * start == '#' )
				start ++ ;
				
			/*-
			 * Echo lines that do not contain the delete string
			-*/

			if ( ! strstr ( start , DeleteString ) )
				fputs ( start , stdout ) ;
		}
	}
			
	if ( fflush ( stdout ) )
	{
		fprintf ( stderr , "striplin: Error flushing standard output\n" ) ;
		exit ( 1 ) ;
	}

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\srcrel\nmktobat.c ===
/***
*NMKtoBAT.C - convert NMAKE.EXE output into a Windows 9x batch file
*
*       Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	The makefiles provided with the Microsoft Visual C++ (C/C++) Run-Time
*	Library Sources generate commands with multiple commands per line,
*	separated by ampersands (&).  This program will convert such a
*	text file into a batch file which can be executed by the Windows 9x
*	command interpreter (COMMAND.COM) which does not recognize multiple
*	commands on a single line.
*
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int main(int argc, char **argv);


#define MAXLINE	4096

char InBuf [ MAXLINE ] ;


int main(int argc, char **argv)
{
	/*
	 * If any arguments are given, print a usage message and exit
	 */

	if ( argc != 1 || argv [ 1 ] )
	{
		fprintf ( stderr , "Usage: nmk2bat < input > output\n"
			"This program takes no arguments\n" ) ;
		exit ( 1 ) ;
	}

	/*
	 * Batch file should be terse
	 */

	printf ( "@echo off\n" ) ;

	/*
	 * Process each input line
	 */

	while ( fgets ( InBuf , sizeof ( InBuf ) , stdin ) )
	{
		char * pStart ;
		char * pFinish ;
		char * pNextPart ;

		pStart = InBuf ;
	
		pFinish = pStart + strlen ( pStart ) ;

		/*
		 * Remove the trailing newline character from the
		 * input buffer.  This simplifies the line processing.
		 */

		if ( pFinish > pStart && pFinish [ -1 ] == '\n' )
			pFinish [ -1 ] = '\0' ;

		/*
		 * Process each part of the line.  Parts are delimited
		 * by ampersand characters with optional whitespace.
		 */

		do
		{
			/*
			 * Skip initial whitespace
			 */

			while ( * pStart == ' ' || * pStart == '\t' )
				++ pStart ;

			/*
			 * Find the next command separator or
			 * the end of line, whichever comes first
			 */

			pNextPart = strchr ( pStart , '&' ) ;

			if ( ! pNextPart )
				pNextPart = pStart + strlen ( pStart ) ;
		
			pFinish = pNextPart ;

			/*
			 * Skip blank lines and blank parts of lines
			 */

			if ( pStart == pNextPart )
				break ;
			/*
			 * Skip the trailing whitespace
			 */

			while ( pFinish > pStart
			&& ( pFinish [ -1 ] == ' ' || pFinish [ -1 ] == '\t' ) )
				-- pFinish ;

			/*
			 * Copy to stdout the characters between
			 * the skipped initial whitespace and
			 * the skipped trailing whitespace
			 */

			while ( pStart < pFinish )
				putchar ( * pStart ++ ) ;

			putchar ( '\n' ) ;

			/*
			 * We are done with this line when pNextPart
			 * points to a null character (rather than a '&').
			 */

			pStart = pNextPart ;

		} while ( * pStart ++ ) ;
	}

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ddk\makefile.inc ===
!IFDEF PASS0ONLY
BuildDDK:

!ELSE

#
# Process only on the second pass
#

# NOTE: DDKBUILD.CMD will exit w/o building a DDK on AXP64 and Alpha.
#        This is by design.
BuildDDK:
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  ddk_base.ini  ddk $(PROJECT_ROOT)
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  hal_base.ini  hal $(PROJECT_ROOT)
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  ifs_base.ini  ifs $(PROJECT_ROOT)
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  processor_base.ini  processor $(PROJECT_ROOT)

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\dload\basepch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\dload\cfgmgr32.c ===
#include "basepch.h"
#pragma hdrstop

#define _CFGMGR32_
#include <cfgmgr32.h>

#error Do not add any delayload stubs for CFGMGR32.DLL.
#error CFGMGR32.DLL is just a stub DLL that forwards all its exports
#error to the same-named exports in SETUPAPI.DLL.
#error So you should change your SOURCES file
#error to link to SETUPAPI.LIB instead of CFGMGR32.LIB.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\dload\cscdll.c ===
//
// Copyright (c) Microsoft Corporation
//
#include "basepch.h"
#include "dloadexcept.h"
#pragma hdrstop

#include <cscapi.h>

VOID
WINAPI
DelayLoad_SetLastNtStatusAndWin32Error(
    );

static
BOOL
WINAPI
CSCIsCSCEnabled(
    VOID
    )
{
    return FALSE;
}

static
BOOL
WINAPI
CSCQueryFileStatusW(
    LPCWSTR lpszFileName,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(cscdll)
{
    DLOENTRY(9, CSCIsCSCEnabled)
    DLOENTRY(42, CSCQueryFileStatusW)
};

DEFINE_ORDINAL_MAP(cscdll)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\dload\loadperf.c ===
#include "basepch.h"
#pragma hdrstop

static
DWORD
LoadPerfCounterTextStringsW(
    IN  LPWSTR  lpCommandLine,
    IN  BOOL    bQuietModeArg
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
UnloadPerfCounterTextStringsW (
    IN  LPWSTR  lpCommandLine,
    IN  BOOL    bQuietModeArg
    )
{
    return ERROR_PROC_NOT_FOUND;
}

//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(loadperf)
{
    DLPENTRY(LoadPerfCounterTextStringsW)
    DLPENTRY(UnloadPerfCounterTextStringsW)
};

DEFINE_PROCNAME_MAP(loadperf)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\dload\pch.h ===
#pragma once

#include <dloadexcept.h>
#include "dload.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\dload\pidgen.c ===
#include "basepch.h"
#pragma hdrstop

static
BOOL STDAPICALLTYPE PIDGenW(
    LPWSTR  lpstrSecureCdKey,
    LPCWSTR lpstrRpc,
    LPCWSTR lpstrSku,
    LPCWSTR lpstrOemId,
    LPWSTR  lpstrLocal24,
    LPBYTE lpbPublicKey,
    DWORD  dwcbPublicKey,
    DWORD  dwKeyIdx,
    BOOL   fOem,

    LPWSTR lpstrPid2,
    LPBYTE  lpbPid3,
    LPDWORD lpdwSeq,
    LPBOOL  pfCCP,
    LPBOOL  pfPSS)
{
    return FALSE;
}

static
BOOL STDAPICALLTYPE SetupPIDGenW(
    LPWSTR  lpstrSecureCdKey,
    LPCWSTR lpstrMpc,
    LPCWSTR lpstrSku,
    BOOL   fOem,
    LPWSTR lpstrPid2,
    LPBYTE  lpbDigPid,
    LPBOOL  pfCCP)
{
    return FALSE;
}

static
BOOL STDAPICALLTYPE PIDGenExW(
    LPWSTR  lpstrSecureCdKey,
    LPCWSTR lpstrRpc,
    LPCWSTR lpstrSku,
    LPCWSTR lpstrOemId,
    LPWSTR  lpstrLocal24,
    LPBYTE lpbPublicKey,
    DWORD  dwcbPublicKey,
    DWORD  dwKeyIdx,
    BOOL   fOem,

    LPWSTR lpstrPid2,
    LPBYTE  lpbPid3,
    LPDWORD lpdwSeq,
    LPBOOL  pfCCP,
    LPBOOL  pfPSS,
    LPBOOL  pfVL)
{
    return FALSE;
}

static
BOOL STDAPICALLTYPE SetupPIDGenExW(
    LPWSTR  lpstrSecureCdKey,
    LPCWSTR lpstrMpc,
    LPCWSTR lpstrSku,
    BOOL   fOem,
    LPWSTR lpstrPid2,
    LPBYTE  lpbDigPid,
    LPBOOL  pfCCP,
    LPBOOL  pfVL)
{
    return FALSE;
}
//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(pidgen)
{
    DLOENTRY(  2, PIDGenW)    
    DLOENTRY(  6, SetupPIDGenW)
    DLOENTRY(  8, PIDGenExW)    
    DLOENTRY( 10, SetupPIDGenExW)
};

DEFINE_ORDINAL_MAP(pidgen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\dload\ocmanage.c ===
#include "basepch.h"
#pragma hdrstop

#include <setupapi.h>
#include <ocmanage.h>
#include <ocmgrlib.h>


static
PVOID
OcInitialize(
    IN  POCM_CLIENT_CALLBACKS Callbacks,
    IN  LPCTSTR               MasterOcInfName,
    IN  UINT                  Flags,
    OUT PBOOL                 ShowError,
    IN  PVOID                 Log
    )
{
    return NULL;
}

static
VOID
OcTerminate(
    IN OUT PVOID *OcManagerContext
    )
{
}

static
UINT
OcGetWizardPages(
    IN  PVOID                OcManagerContext,
    OUT PSETUP_REQUEST_PAGES Pages[WizPagesTypeMax]
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
HPROPSHEETPAGE
OcCreateOcPage(
    IN PVOID             OcManagerContext,
    IN POC_PAGE_CONTROLS WizardPageControlsInfo,
    IN POC_PAGE_CONTROLS DetailsPageControlsInfo
    )
{
    return NULL;
}

static
HPROPSHEETPAGE
OcCreateSetupPage(
    IN PVOID                OcManagerContext,
    IN PSETUP_PAGE_CONTROLS ControlsInfo
    )
{
    return NULL;
}

static
VOID
OcRememberWizardDialogHandle(
    IN PVOID OcManagerContext,
    IN HWND  DialogHandle
    )
{
}

static
BOOL
OcSubComponentsPresent(
    IN PVOID OcManagerContext
   )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ocmanage)
{
    DLPENTRY(OcCreateOcPage)
    DLPENTRY(OcCreateSetupPage)
    DLPENTRY(OcGetWizardPages)
    DLPENTRY(OcInitialize)
    DLPENTRY(OcRememberWizardDialogHandle)    
    DLPENTRY(OcSubComponentsPresent)
    DLPENTRY(OcTerminate)
};

DEFINE_PROCNAME_MAP(ocmanage)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\dload\syssetup.c ===
#include "basepch.h"
#pragma hdrstop

#include <prsht.h>
#include <setupapi.h>
#include <syssetup.h>

static
DWORD
SetupChangeFontSize(
    HWND Window,
    PCWSTR SizeSpec)
{
    return ERROR_NOT_ENOUGH_MEMORY;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(syssetup)
{
    DLPENTRY(SetupChangeFontSize)
};

DEFINE_PROCNAME_MAP(syssetup);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\dload\sxs.c ===
//
// Copyright (c) Microsoft Corporation
//
#include "basepch.h"
#include "sxsapi.h"
#include "dload.h"

DEFINE_PROCNAME_ENTRIES(sxs)
{
    DLPENTRY(SxsBeginAssemblyInstall)
    DLPENTRY(SxsEndAssemblyInstall)
};

DEFINE_PROCNAME_MAP(sxs)

static BOOL g_fSxsBeginAssemblyInstallFailed = FALSE;
static BOOL g_fSxsInstallAssemblyFailed = FALSE;

BOOL
WINAPI
SxsBeginAssemblyInstall(
    IN DWORD Flags,
    IN PSXS_INSTALLATION_FILE_COPY_CALLBACK InstallationCallback OPTIONAL,
    IN PVOID InstallationContext OPTIONAL,
    IN PSXS_IMPERSONATION_CALLBACK ImpersonationCallback OPTIONAL,
    IN PVOID ImpersonationContext OPTIONAL,
    OUT PVOID *InstallCookie
    )
{
    g_fSxsBeginAssemblyInstallFailed = TRUE;
    if (InstallCookie != NULL) {
        *InstallCookie = NULL;
    }
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

BOOL
WINAPI
SxsEndAssemblyInstall(
    IN PVOID InstallCookie,
    IN DWORD Flags,
    IN OUT PVOID Reserved OPTIONAL
    )
{
    if (g_fSxsBeginAssemblyInstallFailed || g_fSxsInstallAssemblyFailed) {
        MYASSERT(Flags & SXS_END_ASSEMBLY_INSTALL_ABORT);
        return TRUE;
    }
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\dload\setupapi.c ===
#include "basepch.h"
#pragma hdrstop

#define _CFGMGR32_
#include <cfgmgr32.h>

#define _SETUPAPI_
#include <setupapi.h>
#include <spapip.h>

static
CMAPI
CONFIGRET
WINAPI
CM_Add_Empty_Log_Conf(
             OUT PLOG_CONF plcLogConf,
             IN  DEVINST   dnDevInst,
             IN  PRIORITY  Priority,
             IN  ULONG     ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Add_Res_Des(
             OUT PRES_DES  prdResDes,
             IN LOG_CONF   lcLogConf,
             IN RESOURCEID ResourceID,
             IN PCVOID     ResourceData,
             IN ULONG      ResourceLen,
             IN ULONG      ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Free_Log_Conf_Handle(
            IN  LOG_CONF  lcLogConf
            )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Child(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_PropertyW(
             IN  DEVINST     dnDevInst,
             IN  PCWSTR      pszCustomPropertyName,
             OUT PULONG      pulRegDataType,        OPTIONAL
             OUT PVOID       Buffer,                OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_Property_ExW(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Status(
             OUT PULONG   pulStatus,
             OUT PULONG   pulProblemNumber,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Status_Ex(
             OUT PULONG   pulStatus,
             OUT PULONG   pulProblemNumber,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_IDW(
             IN  DEVINST  dnDevInst,
             OUT PWCHAR   Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ExW(
             IN  DEVINST  dnDevInst,
             OUT PWCHAR   Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_Size(
             OUT PULONG   pulLen,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_ExW(
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             OUT PWCHAR      Buffer,
             IN  ULONG       BufferLen,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_Size_ExW(
             IN  PULONG      pulLen,
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_First_Log_Conf(
             OUT PLOG_CONF plcLogConf,          OPTIONAL
             IN  DEVINST   dnDevInst,
             IN  ULONG     ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Log_Conf(
             OUT PLOG_CONF plcLogConf,  OPTIONAL
             IN  LOG_CONF  lcLogConf,
             IN  ULONG     ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Res_Des(
             OUT PRES_DES    prdResDes,
             IN  RES_DES     rdResDes,
             IN  RESOURCEID  ForResource,
             OUT PRESOURCEID pResourceID,
             IN  ULONG       ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Parent_Ex(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data(
             IN  RES_DES  rdResDes,
             OUT PVOID    Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data_Size(
             OUT PULONG   pulSize,
             IN  RES_DES  rdResDes,
             IN  ULONG    ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_Sibling(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  DevInst,
             IN  ULONG    ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Is_Dock_Station_Present(
    OUT PBOOL pbPresent
    )
{
    *pbPresent = FALSE;
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNodeW(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,   OPTIONAL
             IN  ULONG       ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Open_DevNode_Key(
             IN  DEVINST        dnDevNode,
             IN  REGSAM         samDesired,
             IN  ULONG          ulHardwareProfile,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkDevice,
             IN  ULONG          ulFlags
             )
{
    return CR_FAILURE;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Request_Eject_PC()
{
    return CR_FAILURE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupCloseFileQueue(
    IN HSPFILEQ QueueHandle
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
VOID
WINAPI
SetupCloseInfFile(
    IN HINF InfHandle
    )
{
}

static
WINSETUPAPI
VOID
WINAPI
SetupCloseLog (
    VOID
    )
{
}

static
WINSETUPAPI
BOOL
WINAPI
SetupCommitFileQueueW(
    IN HWND                Owner,         OPTIONAL
    IN HSPFILEQ            QueueHandle,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupCopyOEMInfW(
    IN  PCWSTR  SourceInfFileName,
    IN  PCWSTR  OEMSourceMediaLocation,         OPTIONAL
    IN  DWORD   OEMSourceMediaType,
    IN  DWORD   CopyStyle,
    OUT PWSTR   DestinationInfFileName,         OPTIONAL
    IN  DWORD   DestinationInfFileNameSize,
    OUT PDWORD  RequiredSize,                   OPTIONAL
    OUT PWSTR  *DestinationInfFileNameComponent OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
UINT
WINAPI
SetupDefaultQueueCallbackW(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiBuildDriverInfoList(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN     DWORD            DriverType
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiCallClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiClassGuidsFromNameW(
    IN  PCWSTR ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
HKEY
WINAPI
SetupDiCreateDevRegKeyW(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN HINF             InfHandle,      OPTIONAL
    IN PCWSTR           InfSectionName  OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
HDEVINFO
WINAPI
SetupDiCreateDeviceInfoList(
    IN CONST GUID *ClassGuid, OPTIONAL
    IN HWND       hwndParent OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiCreateDeviceInfoW(
    IN  HDEVINFO          DeviceInfoSet,
    IN  PCWSTR            DeviceName,
    IN  CONST GUID       *ClassGuid,
    IN  PCWSTR            DeviceDescription, OPTIONAL
    IN  HWND              hwndParent,        OPTIONAL
    IN  DWORD             CreationFlags,
    OUT PSP_DEVINFO_DATA  DeviceInfoData     OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiDeleteDeviceInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiDeleteDeviceInterfaceData(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiDestroyClassImageList(
    IN PSP_CLASSIMAGELIST_DATA ClassImageListData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiDestroyDeviceInfoList(
    IN HDEVINFO DeviceInfoSet
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiEnumDeviceInfo(
    IN  HDEVINFO         DeviceInfoSet,
    IN  DWORD            MemberIndex,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiEnumDeviceInterfaces(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,     OPTIONAL
    IN  CONST GUID                *InterfaceClassGuid,
    IN  DWORD                      MemberIndex,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiEnumDriverInfoW(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN  DWORD              DriverType,
    IN  DWORD              MemberIndex,
    OUT PSP_DRVINFO_DATA_W DriverInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetActualSectionToInstallW(
    IN  HINF    InfHandle,
    IN  PCWSTR  InfSectionName,
    OUT PWSTR   InfSectionWithExt,     OPTIONAL
    IN  DWORD   InfSectionWithExtSize,
    OUT PDWORD  RequiredSize,          OPTIONAL
    OUT PWSTR  *Extension              OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
HDEVINFO
WINAPI
SetupDiGetClassDevsA(
    IN CONST GUID *ClassGuid,  OPTIONAL
    IN PCSTR       Enumerator, OPTIONAL
    IN HWND        hwndParent, OPTIONAL
    IN DWORD       Flags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
HDEVINFO
WINAPI
SetupDiGetClassDevsW(
    IN CONST GUID *ClassGuid,  OPTIONAL
    IN PCWSTR      Enumerator, OPTIONAL
    IN HWND        hwndParent, OPTIONAL
    IN DWORD       Flags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassInstallParamsW(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN  DWORD                   ClassInstallParamsSize,
    OUT PDWORD                  RequiredSize            OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInfoListClass(
    IN  HDEVINFO DeviceInfoSet,
    OUT LPGUID   ClassGuid
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInstallParamsW(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,          OPTIONAL
    OUT PSP_DEVINSTALL_PARAMS_W DeviceInstallParams
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInstanceIdW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PWSTR            DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassImageIndex(
    IN  PSP_CLASSIMAGELIST_DATA  ClassImageListData,
    IN  CONST GUID              *ClassGuid,
    OUT PINT                     ImageIndex
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetClassImageList(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInterfaceDetailA(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceInterfaceDetailW(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetDeviceRegistryPropertyW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PDWORD           PropertyRegDataType, OPTIONAL
    OUT PBYTE            PropertyBuffer,
    IN  DWORD            PropertyBufferSize,
    OUT PDWORD           RequiredSize         OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetDriverInfoDetailW(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,           OPTIONAL
    IN  PSP_DRVINFO_DATA_W        DriverInfoData,
    OUT PSP_DRVINFO_DETAIL_DATA_W DriverInfoDetailData,     OPTIONAL
    IN  DWORD                     DriverInfoDetailDataSize,
    OUT PDWORD                    RequiredSize              OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
   return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetDriverInstallParamsW(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN  PSP_DRVINFO_DATA_W    DriverInfoData,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetSelectedDevice(
    IN  HDEVINFO         DeviceInfoSet,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiGetSelectedDriverW(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    OUT PSP_DRVINFO_DATA_W DriverInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiInstallDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
HKEY
WINAPI
SetupDiOpenDevRegKey(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN REGSAM           samDesired
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiOpenDeviceInfoW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCWSTR           DeviceInstanceId,
    IN  HWND             hwndParent,       OPTIONAL
    IN  DWORD            OpenFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiOpenDeviceInterfaceW(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PCWSTR                    DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiRegisterDeviceInfo(
    IN     HDEVINFO           DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA   DeviceInfoData,
    IN     DWORD              Flags,
    IN     PSP_DETSIG_CMPPROC CompareProc,      OPTIONAL
    IN     PVOID              CompareContext,   OPTIONAL
    OUT    PSP_DEVINFO_DATA   DupDeviceInfoData OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiRemoveDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
SetupDiSelectBestCompatDrv(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiSetClassInstallParamsW(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,        OPTIONAL
    IN PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN DWORD                   ClassInstallParamsSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiSetDeviceInstallParamsW(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,     OPTIONAL
    IN PSP_DEVINSTALL_PARAMS_W DeviceInstallParams
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiSetDeviceRegistryPropertyW(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     DWORD            Property,
    IN     CONST BYTE*      PropertyBuffer,    OPTIONAL
    IN     DWORD            PropertyBufferSize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiSetDriverInstallParamsW(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN PSP_DRVINFO_DATA_W    DriverInfoData,
    IN PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiSetSelectedDevice(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiSetSelectedDriverW(
    IN     HDEVINFO           DeviceInfoSet,
    IN     PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN OUT PSP_DRVINFO_DATA_W DriverInfoData  OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupFindFirstLineW(
    IN  HINF        InfHandle,
    IN  PCWSTR      Section,
    IN  PCWSTR      Key,          OPTIONAL
    OUT PINFCONTEXT Context
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupFindNextLine(
    IN  PINFCONTEXT ContextIn,
    OUT PINFCONTEXT ContextOut
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupFindNextMatchLineW(
    IN  PINFCONTEXT ContextIn,
    IN  PCWSTR      Key,        OPTIONAL
    OUT PINFCONTEXT ContextOut
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupGetBinaryField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PBYTE       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
DWORD
WINAPI
SetupGetFieldCount(
    IN PINFCONTEXT Context
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupGetInfInformationW(
    IN  LPCVOID             InfSpec,
    IN  DWORD               SearchControl,
    OUT PSP_INF_INFORMATION ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupGetIntField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PINT        IntegerValue
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupGetLineByIndexW(
    IN  HINF        InfHandle,
    IN  PCWSTR      Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
LONG
WINAPI
SetupGetLineCountW(
    IN HINF   InfHandle,
    IN PCWSTR Section
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupGetLineTextW(
    IN  PINFCONTEXT Context,          OPTIONAL
    IN  HINF        InfHandle,        OPTIONAL
    IN  PCWSTR      Section,          OPTIONAL
    IN  PCWSTR      Key,              OPTIONAL
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupGetMultiSzFieldW(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupGetStringFieldW(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
PVOID
WINAPI
SetupInitDefaultQueueCallbackEx(
    IN HWND  OwnerWindow,
    IN HWND  AlternateProgressWindow, OPTIONAL
    IN UINT  ProgressMessage,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupInstallFileExW(
    IN HINF         InfHandle           OPTIONAL,
    IN PINFCONTEXT  InfContext          OPTIONAL,
    IN PCWSTR       SourceFile          OPTIONAL,
    IN PCWSTR       SourcePathRoot      OPTIONAL,
    IN PCWSTR       DestinationName     OPTIONAL,
    IN DWORD        CopyStyle,
    IN PSP_FILE_CALLBACK CopyMsgHandler OPTIONAL,
    IN PVOID        Context             OPTIONAL,
    OUT PBOOL       FileWasInUse        OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupInstallFilesFromInfSectionW(
    IN HINF     InfHandle,
    IN HINF     LayoutInfHandle,    OPTIONAL
    IN HSPFILEQ FileQueue,
    IN PCWSTR   SectionName,
    IN PCWSTR   SourceRootPath,     OPTIONAL
    IN UINT     CopyFlags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupInstallFromInfSectionW(
    IN HWND                Owner,
    IN HINF                InfHandle,
    IN PCWSTR              SectionName,
    IN UINT                Flags,
    IN HKEY                RelativeKeyRoot,   OPTIONAL
    IN PCWSTR              SourceRootPath,    OPTIONAL
    IN UINT                CopyFlags,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context,
    IN HDEVINFO            DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA    DeviceInfoData     OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupInstallServicesFromInfSectionW(
    IN HINF   InfHandle,
    IN PCWSTR SectionName,
    IN DWORD  Flags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupLogErrorA (
    IN  LPCSTR             MessageString,
    IN  LogSeverity         Severity
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupLogErrorW (
    IN  LPCWSTR             MessageString,
    IN  LogSeverity         Severity
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupOpenAppendInfFileW(
    IN  PCWSTR FileName,    OPTIONAL
    IN  HINF   InfHandle,
    OUT PUINT  ErrorLine    OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
HSPFILEQ
WINAPI
SetupOpenFileQueue(
    VOID
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
HINF
WINAPI
SetupOpenInfFileW(
    IN  PCWSTR FileName,
    IN  PCWSTR InfClass,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PUINT  ErrorLine    OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupOpenLog (
    BOOL Erase
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
HINF
WINAPI
SetupOpenMasterInf(
    VOID
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupQueryInfVersionInformationW(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    IN  PCWSTR              Key,              OPTIONAL
    OUT PWSTR               ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupScanFileQueueW(
    IN  HSPFILEQ            FileQueue,
    IN  DWORD               Flags,
    IN  HWND                Window,            OPTIONAL
    IN  PSP_FILE_CALLBACK_W CallbackRoutine,   OPTIONAL
    IN  PVOID               CallbackContext,   OPTIONAL
    OUT PDWORD              Result
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
VOID
WINAPI
SetupTermDefaultQueueCallback(
    IN PVOID Context
    )
{
}

static
BOOL
pSetupSetQueueFlags(
    IN HSPFILEQ QueueHandle,
    IN DWORD flags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
DWORD
pSetupGetQueueFlags(
    IN HSPFILEQ QueueHandle
    )
{
    return 0;
}

BOOL
pSetupConcatenatePaths(
    IN OUT PTSTR  Target,
    IN     PCTSTR Path,
    IN     UINT   TargetBufferSize,
    OUT    PUINT  RequiredSize          OPTIONAL
    )
{
    if (RequiredSize)
        *RequiredSize = 0;

    *Target=0;

    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
VOID
pSetupGetRealSystemTime(
    OUT LPSYSTEMTIME RealSystemTime
    )
{
}

static
DWORD
pSetupInstallCatalog(
    IN  LPCTSTR CatalogFullPath,
    IN  LPCTSTR NewBaseName,        OPTIONAL
    OUT LPTSTR  NewCatalogFullPath  OPTIONAL
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOL
pSetupIsUserAdmin(
    VOID
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
SetupQueueCopyW(
    IN HSPFILEQ QueueHandle,
    IN PCWSTR   SourceRootPath,     OPTIONAL
    IN PCWSTR   SourcePath,         OPTIONAL
    IN PCWSTR   SourceFilename,
    IN PCWSTR   SourceDescription,  OPTIONAL
    IN PCWSTR   SourceTagfile,      OPTIONAL
    IN PCWSTR   TargetDirectory,
    IN PCWSTR   TargetFilename,     OPTIONAL
    IN DWORD    CopyStyle
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
SetupQueueCopyIndirectW(
    IN PSP_FILE_COPY_PARAMS_W CopyParams
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return(FALSE);
}

static
WINSETUPAPI
BOOL
SetupGetSourceFileLocationW(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCWSTR      FileName,         OPTIONAL
    OUT PUINT       SourceId,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
SetupGetSourceInfoW(
    IN  HINF   InfHandle,
    IN  UINT   SourceId,
    IN  UINT   InfoDesired,
    OUT PWSTR  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
BOOL
SetupSetDirectoryIdExW(
    IN HINF   InfHandle,
    IN DWORD  Id,           OPTIONAL
    IN PCWSTR Directory,    OPTIONAL
    IN DWORD  Flags,
    IN DWORD  Reserved1,
    IN PVOID  Reserved2
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
DWORD
SetupDecompressOrCopyFileW(
    IN  PCWSTR  SourceFileName,
    OUT PCWSTR  TargetFileName,
    OUT PUINT   CompressionType OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return ERROR_PROC_NOT_FOUND;
}

static
WINSETUPAPI
DWORD
SetupGetFileCompressionInfoW(
    IN  PCWSTR  SourceFileName,
    OUT PWSTR  *ActualSourceFileName,
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return ERROR_PROC_NOT_FOUND;
}

static
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_PropertyW(
    IN  DEVINST     dnDevInst,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType,   OPTIONAL
    OUT PVOID       Buffer,           OPTIONAL
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags
    )
{
    return CR_FAILURE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiDestroyDriverInfoList(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN DWORD            DriverType
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
WINSETUPAPI
HKEY
WINAPI
SetupDiCreateDeviceInterfaceRegKeyW(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD                     Reserved,
    IN REGSAM                    samDesired,
    IN HINF                      InfHandle,           OPTIONAL
    IN PCWSTR                    InfSectionName       OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return INVALID_HANDLE_VALUE;
}

static
WINSETUPAPI
BOOL
WINAPI
SetupDiCreateDeviceInterfaceW(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,
    IN  CONST GUID                *InterfaceClassGuid,
    IN  PCWSTR                     ReferenceString,    OPTIONAL
    IN  DWORD                      CreationFlags,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData OPTIONAL
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(setupapi)
{
    DLPENTRY(CM_Add_Empty_Log_Conf)
    DLPENTRY(CM_Add_Res_Des)
    DLPENTRY(CM_Free_Log_Conf_Handle)
    DLPENTRY(CM_Get_Child)
    DLPENTRY(CM_Get_DevNode_Custom_PropertyW)
    DLPENTRY(CM_Get_DevNode_Registry_PropertyW)
    DLPENTRY(CM_Get_DevNode_Registry_Property_ExW)
    DLPENTRY(CM_Get_DevNode_Status)
    DLPENTRY(CM_Get_DevNode_Status_Ex)
    DLPENTRY(CM_Get_Device_IDW)
    DLPENTRY(CM_Get_Device_ID_ExW)
    DLPENTRY(CM_Get_Device_ID_Size)
    DLPENTRY(CM_Get_Device_Interface_List_ExW)
    DLPENTRY(CM_Get_Device_Interface_List_Size_ExW)
    DLPENTRY(CM_Get_First_Log_Conf)
    DLPENTRY(CM_Get_Next_Log_Conf)
    DLPENTRY(CM_Get_Next_Res_Des)
    DLPENTRY(CM_Get_Parent_Ex)
    DLPENTRY(CM_Get_Res_Des_Data)
    DLPENTRY(CM_Get_Res_Des_Data_Size)
    DLPENTRY(CM_Get_Sibling)
    DLPENTRY(CM_Is_Dock_Station_Present)
    DLPENTRY(CM_Locate_DevNodeW)
    DLPENTRY(CM_Open_DevNode_Key)
    DLPENTRY(CM_Request_Eject_PC)
    DLPENTRY(SetupCloseFileQueue)
    DLPENTRY(SetupCloseInfFile)
    DLPENTRY(SetupCloseLog)
    DLPENTRY(SetupCommitFileQueueW)
    DLPENTRY(SetupCopyOEMInfW)
    DLPENTRY(SetupDecompressOrCopyFileW)
    DLPENTRY(SetupDefaultQueueCallbackW)
    DLPENTRY(SetupDiBuildDriverInfoList)
    DLPENTRY(SetupDiCallClassInstaller)
    DLPENTRY(SetupDiClassGuidsFromNameW)
    DLPENTRY(SetupDiCreateDevRegKeyW)
    DLPENTRY(SetupDiCreateDeviceInfoList)
    DLPENTRY(SetupDiCreateDeviceInfoW)
    DLPENTRY(SetupDiCreateDeviceInterfaceRegKeyW)
    DLPENTRY(SetupDiCreateDeviceInterfaceW)
    DLPENTRY(SetupDiDeleteDeviceInfo)
    DLPENTRY(SetupDiDeleteDeviceInterfaceData)
    DLPENTRY(SetupDiDestroyClassImageList)
    DLPENTRY(SetupDiDestroyDeviceInfoList)
    DLPENTRY(SetupDiDestroyDriverInfoList)
    DLPENTRY(SetupDiEnumDeviceInfo)
    DLPENTRY(SetupDiEnumDeviceInterfaces)
    DLPENTRY(SetupDiEnumDriverInfoW)
    DLPENTRY(SetupDiGetActualSectionToInstallW)
    DLPENTRY(SetupDiGetClassDevsA)
    DLPENTRY(SetupDiGetClassDevsW)
    DLPENTRY(SetupDiGetClassImageIndex)
    DLPENTRY(SetupDiGetClassImageList)
    DLPENTRY(SetupDiGetClassInstallParamsW)
    DLPENTRY(SetupDiGetDeviceInfoListClass)
    DLPENTRY(SetupDiGetDeviceInstallParamsW)
    DLPENTRY(SetupDiGetDeviceInstanceIdW)
    DLPENTRY(SetupDiGetDeviceInterfaceDetailA)
    DLPENTRY(SetupDiGetDeviceInterfaceDetailW)
    DLPENTRY(SetupDiGetDeviceRegistryPropertyW)
    DLPENTRY(SetupDiGetDriverInfoDetailW)
    DLPENTRY(SetupDiGetDriverInstallParamsW)
    DLPENTRY(SetupDiGetSelectedDevice)
    DLPENTRY(SetupDiGetSelectedDriverW)
    DLPENTRY(SetupDiInstallDevice)
    DLPENTRY(SetupDiOpenDevRegKey)
    DLPENTRY(SetupDiOpenDeviceInfoW)
    DLPENTRY(SetupDiOpenDeviceInterfaceW)
    DLPENTRY(SetupDiRegisterDeviceInfo)
    DLPENTRY(SetupDiRemoveDevice)
    DLPENTRY(SetupDiSelectBestCompatDrv)
    DLPENTRY(SetupDiSetClassInstallParamsW)
    DLPENTRY(SetupDiSetDeviceInstallParamsW)
    DLPENTRY(SetupDiSetDeviceRegistryPropertyW)
    DLPENTRY(SetupDiSetDriverInstallParamsW)
    DLPENTRY(SetupDiSetSelectedDevice)
    DLPENTRY(SetupDiSetSelectedDriverW)
    DLPENTRY(SetupFindFirstLineW)
    DLPENTRY(SetupFindNextLine)
    DLPENTRY(SetupFindNextMatchLineW)
    DLPENTRY(SetupGetBinaryField)
    DLPENTRY(SetupGetFieldCount)
    DLPENTRY(SetupGetFileCompressionInfoW)
    DLPENTRY(SetupGetInfInformationW)
    DLPENTRY(SetupGetIntField)
    DLPENTRY(SetupGetLineByIndexW)
    DLPENTRY(SetupGetLineCountW)
    DLPENTRY(SetupGetLineTextW)
    DLPENTRY(SetupGetMultiSzFieldW)
    DLPENTRY(SetupGetSourceFileLocationW)
    DLPENTRY(SetupGetSourceInfoW)
    DLPENTRY(SetupGetStringFieldW)
    DLPENTRY(SetupInitDefaultQueueCallbackEx)
    DLPENTRY(SetupInstallFileExW)
    DLPENTRY(SetupInstallFilesFromInfSectionW)
    DLPENTRY(SetupInstallFromInfSectionW)
    DLPENTRY(SetupInstallServicesFromInfSectionW)
    DLPENTRY(SetupLogErrorA)
    DLPENTRY(SetupLogErrorW)
    DLPENTRY(SetupOpenAppendInfFileW)
    DLPENTRY(SetupOpenFileQueue)
    DLPENTRY(SetupOpenInfFileW)
    DLPENTRY(SetupOpenLog)
    DLPENTRY(SetupOpenMasterInf)
    DLPENTRY(SetupQueryInfVersionInformationW)
    DLPENTRY(SetupQueueCopyIndirectW)
    DLPENTRY(SetupQueueCopyW)
    DLPENTRY(SetupScanFileQueueW)
    DLPENTRY(SetupSetDirectoryIdExW)
    DLPENTRY(SetupTermDefaultQueueCallback)
    DLPENTRY(pSetupConcatenatePaths)
    DLPENTRY(pSetupGetQueueFlags)
    DLPENTRY(pSetupGetRealSystemTime)
    DLPENTRY(pSetupInstallCatalog)
    DLPENTRY(pSetupIsUserAdmin)
    DLPENTRY(pSetupSetQueueFlags)
};

DEFINE_PROCNAME_MAP(setupapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\dloadhandler\kernel32dloadhandler.c ===
// this file builds a "lib" (really just an .obj) for people who want to
// use the kernel32.dll delay-load exception handler.

#define DELAYLOAD_VERSION 0x0200

#include <windows.h>
#include <delayimp.h>

// kernel32's base hmodule
extern HANDLE   BaseDllHandle;

// prototype (implemented in kernl32p.lib)
FARPROC
DelayLoadFailureHook (
    LPCSTR pszDllName,
    LPCSTR pszProcName
    );


// people who care about being notified of dll loadlibray will override this 
PfnDliHook __pfnDliNotifyHook2;

// Instead of implementing a "notify hook" (__pfnDliNotifyHook2) or a 
// "failure hook" (__pfnDliFailureHook2) we are just going to up and implement
// __delayLoadHelper2 which is the stub who's fn. pointer is filled in all
// of the import tables for delayloaded entries. 
//
// This will effectively bypass the linker's LoadLibrary/GetProcAddress thunk code 
// as we simply duplicate it here (most of this fn. was stolen from \vc7\delayhlp.cpp)
 
FARPROC
WINAPI
__delayLoadHelper2(
    PCImgDelayDescr pidd,
    FARPROC *       ppfnIATEntry
    )
{
    UINT iINT;
    PCImgThunkData pitd;
    LPCSTR pszProcName;
    LPCSTR pszDllName = (LPCSTR)PFromRva(pidd->rvaDLLName, NULL);
    HMODULE* phmod = (HMODULE*)PFromRva(pidd->rvaHmod, NULL);
    PCImgThunkData pIAT = (PCImgThunkData)PFromRva(pidd->rvaIAT, NULL);
    PCImgThunkData pINT = (PCImgThunkData)PFromRva(pidd->rvaINT, NULL);
    FARPROC pfnRet = 0;
    HMODULE hmod = *phmod;

    // Calculate the index for the name in the import name table.
    // N.B. it is ordered the same as the IAT entries so the calculation
    // comes from the IAT side.
    //
    iINT = IndexFromPImgThunkData((PCImgThunkData)ppfnIATEntry, pIAT);

    pitd = &(pINT[iINT]);

    if (!IMAGE_SNAP_BY_ORDINAL(pitd->u1.Ordinal))
    {
        PIMAGE_IMPORT_BY_NAME pibn = (PIMAGE_IMPORT_BY_NAME)PFromRva((RVA)pitd->u1.AddressOfData, NULL);

        pszProcName = pibn->Name;
    }
    else
    {
        pszProcName = MAKEINTRESOURCEA(IMAGE_ORDINAL(pitd->u1.Ordinal));
    }

    if (hmod == 0)
    {
        hmod = LoadLibraryA(pszDllName);

        if (hmod != 0)
        {
            // Store the library handle.  If it is already there, we infer
            // that another thread got there first, and we need to do a
            // FreeLibrary() to reduce the refcount
            //
            HMODULE hmodT = (HMODULE)InterlockedCompareExchangePointer((void**)phmod, (void*)hmod, NULL);
            if (hmodT == NULL)
            {
                DelayLoadInfo dli = {0};

                dli.cb = sizeof(dli);
                dli.szDll = pszDllName;
                dli.hmodCur = hmod;

                // call the notify hook to inform them that we have successfully LoadLibrary'ed a dll.
                // (we do this in case they want to free it when they unload)
                if (__pfnDliNotifyHook2 != NULL)
                {
                    __pfnDliNotifyHook2(dliNoteEndProcessing, &dli);
                }
            }
            else
            {
                // some other thread beat us to loading this module, use the existing hmod
                FreeLibrary(hmod);
                hmod = hmodT;
            }
        }
    }

    if (hmod)
    {
        // Go for the procedure now.
        pfnRet = GetProcAddress(hmod, pszProcName);
    }

    if (pfnRet == 0)
    {
        pfnRet = DelayLoadFailureHook(pszDllName, pszProcName);
    }

    *ppfnIATEntry = pfnRet;

    return pfnRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\dload\sfc.c ===
#include "basepch.h"
#pragma hdrstop

#include <sfcapip.h>
#include <winwlx.h>

static
BOOL
WINAPI
SfcIsFileProtected(
    IN HANDLE RpcHandle, // must be NULL
    IN LPCWSTR ProtFileName
    )
{
    return FALSE;
}

static
BOOL
WINAPI
SfcGetNextProtectedFile(
    IN HANDLE RpcHandle, // must be NULL
    IN PPROTECTED_FILE_DATA ProtFileData
    )
{
    return FALSE;
}

static
VOID
SfcWLEventLogon(
    IN PWLX_NOTIFICATION_INFO pInfo
    )
{
    NOTHING;
}

VOID
SfcWLEventLogoff(
    IN PWLX_NOTIFICATION_INFO pInfo
    )
{
    NOTHING;
}

static
HANDLE
WINAPI
SfcConnectToServer(
    IN LPCWSTR ServerName
    )
{
    return NULL;
}

static
VOID
SfcClose(
    IN HANDLE RpcHandle
    )
{
    NOTHING;
}

static
DWORD
WINAPI
SfcFileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    )
{
    return 0;
}

static
DWORD
WINAPI
SfcInitiateScan(
    IN HANDLE RpcHandle,
    IN DWORD ScanWhen
    )
{
    return 0;
}

static
ULONG
SfcInitProt(
    IN ULONG OverrideRegistry,
    IN ULONG ReqDisable,
    IN ULONG ReqScan,
    IN ULONG ReqQuota,
    IN HWND ProgressWindow, OPTIONAL
    IN PCWSTR SourcePath, OPTIONAL
    IN PCWSTR IgnoreFiles OPTIONAL
    )
{
    return STATUS_UNSUCCESSFUL;
}

static
VOID
SfcTerminateWatcherThread(
    VOID
    )
{
    return;
}

static
BOOL
WINAPI
SfcInstallProtectedFiles(
    IN HANDLE RpcHandle,
    IN PCWSTR FileNames,
    IN BOOL AllowUI,
    IN PCWSTR ClassName,
    IN PCWSTR WindowName,
    IN PSFCNOTIFICATIONCALLBACK SfcNotificationCallback,
    IN DWORD_PTR Context
    )
{
    return FALSE;
}

DWORD
SfpInstallCatalog(
    IN LPCSTR pszCatName, 
    IN LPCSTR pszCatDependency,
    IN PVOID   Reserved
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}


DWORD
SfpDeleteCatalog(
    IN LPCSTR pszCatName,
    IN PVOID   Reserved
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}


BOOL
SfpVerifyFile(
    IN LPCSTR pszFileName,
    IN LPSTR  pszError,
    IN DWORD   dwErrSize
    )
{
    return FALSE;    
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(sfc)
{    
    DLOENTRY(1, SfcInitProt)
    DLOENTRY(2, SfcTerminateWatcherThread)
    DLOENTRY(3, SfcConnectToServer)
    DLOENTRY(4, SfcClose)
    DLOENTRY(5, SfcFileException)
    DLOENTRY(6, SfcInitiateScan)
    DLOENTRY(7, SfcInstallProtectedFiles)
    DLOENTRY(8, SfpInstallCatalog)
    DLOENTRY(9, SfpDeleteCatalog)
};

DEFINE_ORDINAL_MAP(sfc)

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(sfc)
{
    DLPENTRY(SfcGetNextProtectedFile)
    DLPENTRY(SfcIsFileProtected)
    DLPENTRY(SfcWLEventLogoff)
    DLPENTRY(SfcWLEventLogon)
    DLPENTRY(SfpVerifyFile)
};

DEFINE_PROCNAME_MAP(sfc)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\cdboot\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\cdboot.obj \
     $(O)\cdboot.res

EFI_LIBS=$(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib
        

$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:EfiMain
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\$(TARGETNAME).efi: $(OBJS) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\cpuid\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\cpuid.obj

EFI_LIBS=$(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib


$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:EfiMain
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\$(TARGETNAME).efi: $(OSLOADER) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\cdboot\cdboot.c ===
#include <efi.h>
#include <efilib.h>


//
// Prototype
//
void TrimNonPrint(CHAR16 * str);
void Launch (CHAR16 *exePath);

//
//Globals
//
EFI_HANDLE ExeHdl;
EFI_LOADED_IMAGE *ExeImage;

//
// Defines
//
#define REGISTER1 L"*register"
#define REGISTER2 L"*register*"
#define STARTFILE L"startup.nsh"
#define BOOTOFILE L"boot.nvr"
#define OSLOADOPT L"OSLOADER"
#define PARTENT   L"partition"
#define PARTENTRE L"*partition*"

#define APPNAME_TOLAUNCH   L"setupldr.efi"

EFI_STATUS
EfiMain (    IN EFI_HANDLE           ImageHandle,
             IN EFI_SYSTEM_TABLE     *SystemTable)
{

	EFI_STATUS Status;
	EFI_FILE_HANDLE bootFile;
    UINTN Count;
    BOOLEAN LaunchTheApplication;
    CHAR16 App[30];

    InitializeLib (ImageHandle, SystemTable);
	
	ExeHdl = ImageHandle;
	BS->HandleProtocol (ImageHandle, &LoadedImageProtocol, &ExeImage);

    LaunchTheApplication = FALSE;

    ST->ConOut->ClearScreen(ST->ConOut);

    Print (L"Press any key to boot from CD-ROM...");
    for (Count = 0; Count < 3; Count++) {
        Status = WaitForSingleEvent (ST->ConIn->WaitForKey,1*10000000);

        if (Status != EFI_TIMEOUT){
            LaunchTheApplication = TRUE;
            break;
        }

        Print(L".");

    }

    if (!LaunchTheApplication) {

        BS->Exit(ExeHdl,EFI_TIMEOUT,0,NULL);

    }

    StrCpy(App, APPNAME_TOLAUNCH);        
    
    Launch( App );
    

    

	//
	// If we get here, we failed to load the OS
	//
    Print(L"Failed to launch SetupLDR.");

	return EFI_SUCCESS;
}

void
Launch (CHAR16 *exePath)
{
	EFI_HANDLE exeHdl=NULL;
	UINTN i;
	EFI_DEVICE_PATH *ldrDevPath;
	EFI_STATUS 	Status;
    EFI_FILE_IO_INTERFACE   *Vol;
	EFI_FILE_HANDLE         RootFs;
	EFI_FILE_HANDLE         CurDir;
	EFI_FILE_HANDLE         FileHandle;
	CHAR16                  FileName[100],*DevicePathAsString;

	
    //
    // Open the volume for the device where the exe was loaded from.
    //
    Status = BS->HandleProtocol (ExeImage->DeviceHandle,
                                 &FileSystemProtocol,
                                 &Vol
                                 );

    if (EFI_ERROR(Status)) {
        Print(L"Can not get a FileSystem handle for ExeImage->DeviceHandle\n");
        BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
    }	
	Status = Vol->OpenVolume (Vol, &RootFs);
	
	if (EFI_ERROR(Status)) {
		Print(L"Can not open the volume for the file system\n");
		 BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	}
	
	CurDir = RootFs;
	
	//
	// Open the file relative to the root.
	//
	
	DevicePathAsString = DevicePathToStr(ExeImage->FilePath);
	
	if (DevicePathAsString!=NULL) {
		StrCpy(FileName,DevicePathAsString);
		FreePool(DevicePathAsString);
	}

	FileName[0] = 0;
	StrCat(FileName,exePath);

//    size = StrLen(FileName);
//    Print(L"Length of filename is %d\n", size);
//    DumpHex(4, 0, 10, &FileName[size - 4]);

    //
    // Get rid of trailing spaces, new lines, whatever
    //
    TrimNonPrint(FileName);


	Status = CurDir->Open (CurDir,
						&FileHandle,
						FileName,
						EFI_FILE_MODE_READ,
						0
						);
	
	if (EFI_ERROR(Status)) {
		Print(L"Can not open the file ->%s<-, error was %X\n",FileName, Status);
		BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	} else {
//		Print(L"Opened %s\n",FileName);
	}

	ldrDevPath  = FileDevicePath (ExeImage->DeviceHandle,FileName);

/*
	if (ldrDevPath) {
		Print (L"Type: %d\nSub-Type: %d\nLength[0][1]: [%d][%d]\n",ldrDevPath->Type,
			ldrDevPath->SubType,ldrDevPath->Length[0],ldrDevPath->Length[1]);
	}else {
		Print (L"bad dev path\n");
	}
*/
//	DumpHex (4,0,ldrDevPath->Length[0],ldrDevPath);

	Status = BS->LoadImage (FALSE,ExeHdl,ldrDevPath,NULL,0,&exeHdl);
	if (!(EFI_ERROR (Status))) {
//		Print (L"Image loaded!\n");
	
	}else {
		Print (L"Load Error: %X\n",Status);
		BS->Exit(ExeHdl,EFI_SUCCESS,0,NULL);
	}
	FreePool (ldrDevPath);

	BS->StartImage (exeHdl,&i,NULL);

	return;
}


void
TrimNonPrint(
	CHAR16 * str
)
{
	INTN i,size;


    if ((NULL == str) || (L'\0' == *str)) {
        return;
    }

    size = (INTN) StrLen(str);

//    Print(L"Size is %d\n", size);
//    DumpHex(4, 0, 2, &str[size]);

    for (i = size; i > 0; i--) {

        if (str[i] <= 0x20) {
            str[i] = L'\0';
        }
        else {
            // Leave when we hit a legit character
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\cpuid\cpuid.c ===
#include <efi.h>
#include <efilib.h>


    // CPUID Registers 
#define    CV_IA64_CPUID0  3328
#define    CV_IA64_CPUID1  3329
#define    CV_IA64_CPUID2  3330
#define    CV_IA64_CPUID3  3331
#define    CV_IA64_CPUID4  3332



EFI_STATUS
EfiMain (    IN EFI_HANDLE           ImageHandle,
             IN EFI_SYSTEM_TABLE     *SystemTable)
{
    UINT64  val64;
    UINT32  val32;
    UINT32  model;
    UINT32  revision;
    UINT32  family;

	InitializeLib( ImageHandle, SystemTable );

    Print( L"CPUID Program\n\n" );
	
    SystemTable->ConOut->ClearScreen( SystemTable->ConOut );
    
    val64 = __getReg( CV_IA64_CPUID3 );
    
    model = ( UINT32 )( ( val64 >> 16 ) & 0xFF );             // ProcessorModel
    Print( L"Processor Model    = %x\n", model );

    revision = ( UINT32 )( ( val64 >> 8 ) & 0xFF );           // ProcessorRevision
    Print( L"Processor Revision = %x\n", revision );
    
    family = ( UINT32 ) ( ( val64 >> 24 ) & 0xFF );           // ProcessorFamily
    Print( L"Processor Family   = %x\n", family );

    val32 = ( UINT32 ) ( ( val64 >> 32 ) & 0xFF );            // ProcessorArchRev
    Print( L"Processor ArchRev  = %x\n\n", val32 );

    switch ( model ) {

        case 0:     Print( L"Itanium    " );
                    break;

        case 1:     Print( L"McKinley   " );
                    break;

        default:    Print( L"IA64       " );
                    break;

    }

    switch ( revision ) {

        case 0:     Print( L"A stepping\n\n" );
                    break;

        case 1:     Print( L"B0 stepping\n\n" );
                    break;

        case 2:     Print( L"B1 stepping\n\n" );
                    break;

        case 3:     Print( L"B2 stepping \n\n" );
                    break;

        default:    Print( L"Unknown stepping\n\n" );
                    break;

    }

    // IA64 architected CPUID0 & CPUID1: Vendor Information.

    val64 = __getReg( CV_IA64_CPUID0 );
    Print( L"VendorString[0]         = %X\n", val64 );
    val64 = __getReg( CV_IA64_CPUID1 );
    Print( L"VendorString[1]         = %X\n", val64 );

    // IA64 architected CPUID2: Processor Serial Number.

    val64 = __getReg( CV_IA64_CPUID2 );
    Print( L"Processor Serial Number = %X\n", val64 );

    // IA64 architected CPUID4: General Features / Capability bits.

    val64 = __getReg( CV_IA64_CPUID4 );
    Print( L"Processor Feature Bits  = %X\n\n", val64 );

	return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\doport.c ===
/*

    DoPort.c

    Contains large routines that are too complicated to "wrap", so
    here you have to rewrite the function for whatever the target is.

*/

#include "diskpart.h"

EFI_STATUS
FindPartitionableDevices(
    EFI_HANDLE  **ReturnBuffer,
    UINTN       *Count
    )
/*
    FindPartitionableDevices gets the list of handles that support
    the block I/O protocol.  It then traverses these handles, and
    filters out any that don't appear to be fixed mount, present, read/write,
    disks.

    ReturnBuffer - will be set to point to a buffer with a an array of
                    handles to partitionable disks.  NULL if failure or
                    no such disks found.  Caller may free from pool
an
    Count - number of entries in ReturnBuffer, 0 if none.

    Return is a status.an
*/
{
    EFI_HANDLE      *HandlePointer;
    UINTN           HandleCount;
    EFI_BLOCK_IO    *BlkIo;
    EFI_DEVICE_PATH *DevicePath;
    UINTN           PathSize;
    BOOLEAN         Partitionable;
    EFI_DEVICE_PATH *PathInstance;
    UINTN           SpindleCount;
    UINTN           i;

    *ReturnBuffer = NULL;
    *Count = 0;

    //
    // Try to find all of the hard disks by finding all
    // handles that support BlockIo protocol
    //
    status = LibLocateHandle(
        ByProtocol,
        &BlockIoProtocol,
        NULL,
        &HandleCount,
        &HandlePointer
        );

    if (EFI_ERROR(status)) {
        return status;
    }

    *ReturnBuffer = DoAllocate(sizeof(EFI_HANDLE)*HandleCount);

    if (*ReturnBuffer == NULL) {
        *Count = 0;
        return EFI_OUT_OF_RESOURCES;
    }

    SpindleCount = 0;
    for (i = 0; i < HandleCount; i++) {
        Partitionable = TRUE;
        status = BS->HandleProtocol(HandlePointer[i], &BlockIoProtocol, &BlkIo);
        if (BlkIo->Media->RemovableMedia) {
            //
            // It's removable, it's not for us
            //
            Partitionable = FALSE;
        }
        if ( ! BlkIo->Media->MediaPresent) {
            //
            // It's still not for us
            //
            Partitionable = FALSE;
        }

        if (BlkIo->Media->ReadOnly) {
            //
            // Cannot partition a read-only device!
            //
            Partitionable = FALSE;
        }

        //
        // OK, it seems to be a present, fixed, read/write, block device.
        // Now, make sure it's really the raw device by inspecting the
        // device path.
        //
        DevicePath = DevicePathFromHandle(HandlePointer[i]);
        while (DevicePath != NULL) {
            PathInstance = DevicePathInstance(&DevicePath, &PathSize);

            while (!IsDevicePathEnd(PathInstance)) {
                if ((DevicePathType(PathInstance) == MEDIA_DEVICE_PATH)) {
                    Partitionable = FALSE;
                }

                PathInstance = NextDevicePathNode(PathInstance);
            }
        }

        if (Partitionable) {
            //
            // Return this handle
            //
            (*ReturnBuffer)[*Count] = HandlePointer[i];
            (*Count)++;
        }
    }
    return EFI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\crypto.c ===
/*++

Copyright (c) 2000  Intel Corporation

Module Name:

    crypto.c
    
Abstract:

    Add support for IEEE Node address generation when there is 
    not a SNP-compliant NIC attached.

Revision History

    ** Intel 2000 Update for EFI 1.0
    ** Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
    ** Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
    ** Digital Equipment Corporation, Maynard, Mass.
    ** To anyone who acknowledges that this file is provided AS IS
    ** without any express or implied warranty: permission to use, copy,
    ** modify, and distribute this file for any purpose is hereby
    ** granted without fee, provided that the above copyright notices and
    ** this notice appears in all source code copies, and that none of
    ** the names of Open Software Foundation, Inc., Hewlett-Packard
    ** Company, or Digital Equipment Corporation be used in advertising
    ** or publicity pertaining to distribution of the software without
    ** specific, written prior permission. Neither Open Software
    ** Foundation, Inc., Hewlett-Packard Company, nor Digital Equipment
    ** Corporation makes any representations about the suitability of
    ** this software for any purpose.

*/


#include "efi.h"
#include "efilib.h"
#include "md5.h"

#define HASHLEN 16

void GenNodeID(
  unsigned char *pDataBuf,
  long cData, 
  UINT8 NodeID[]
)
{
  int i, j;
  unsigned char Hash[HASHLEN];
  MD5_CTX context;

  MD5Init (&context);

  MD5Update (&context, pDataBuf, cData);

  MD5Final (&context);

  for (j = 0; j<6; j++) {
    NodeID[j]=0;
  }
  
  for (i = 0,j = 0; i < HASHLEN; i++) {
    NodeID[j++] ^= Hash[i];
    if (j == 6) {
      j = 0;
    }
  }
  NodeID[0] |= 0x80; // set the multicast bit
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\gpt.c ===
/*

    Gpt - Guid Partition Table routines

*/


#include "diskpart.h"

BOOLEAN Debug = TRUE;

EFI_STATUS  WriteShadowMBR(EFI_HANDLE   DiskHandle);

EFI_STATUS
ReadGPT(
    EFI_HANDLE      DiskHandle,
    PGPT_HEADER     *Header,
    PGPT_TABLE      *Table,
    PLBA_BLOCK      *LbaBlock,
    UINTN           *DiskType
    )
/*

    *Header, *Table, *LbaBlock will either be NULL or have a pointer.
    If they have pointers, caller is expected to free them with DoFree();

    RAW and MBR stuff is NOT DONE.

    DISK_RAW     - no known partition scheme on the disk
    DISK_MBR     - an MBR/Legacy disk
    DISK_GPT     - a GPT style disk
    DISK_GPT_UPD - a GPT disk with inconsistent partition tables
                   that need to be fixed up (may also need MBR rewrite)
    DISK_GPT_BAD - a GPT disk that is hopeless (or a hopeless disk
                   that we think is a GPT disk)
*/
{
#define MBR_STATE_RAW   0
#define MBR_STATE_MBR   1
#define MBR_STATE_GPT   2

    UINTN       MbrState = MBR_STATE_RAW;
    UINT32      BlockSize;
    UINT64      DiskSize;
    VOID        *p = NULL;
    PGPT_HEADER h1 = NULL;
    PGPT_HEADER h2 = NULL;
    PGPT_TABLE  t1 = NULL;
    PGPT_TABLE  t2 = NULL;
    PLBA_BLOCK  lba = NULL;
    UINT32      h1crc;
    UINT32      h2crc;
    UINT32      newcrc;
    UINT32      TableSize;
    UINT32      TableBlocks;
    BOOLEAN     PartialGPT = FALSE;
    MBR_ENTRY   *MbrTable;
    UINT16      *MbrSignature;


    BOOLEAN H1T1good = TRUE;
    BOOLEAN H2T2good = TRUE;


    BlockSize = GetBlockSize(DiskHandle);
    DiskSize = GetDiskSize(DiskHandle);

    //
    // Assure that DoFree will notice uninited returns...
    //
    *Header = NULL;
    *Table = NULL;
    *LbaBlock = NULL;

    *DiskType = DISK_ERROR;
    status = EFI_SUCCESS;

    p = DoAllocate(BlockSize);
    if (p == NULL) goto ErrorMem;

    //
    // Read the MBR, if we can't read that, assume
    // we're in deep trouble  (MBR is always block 0, 1 block long)
    //
    status = ReadBlock(DiskHandle, p, (UINT64)0, BlockSize);
    if (EFI_ERROR(status)) goto ErrorRead;

    MbrTable = (MBR_ENTRY *)((CHAR8 *)p + MBR_TABLE_OFFSET);
    MbrSignature = (UINT16 *)((CHAR8 *)p + MBR_SIGNATURE_OFFSET);

    if (*MbrSignature == MBR_SIGNATURE) {        // 0xaa55
        //
        // There's an MBR signature, so assume NOT RAW
        //

        //
        // If we find a type 0xEE in the first slot, we'll assume
        // it's a GPT Shadow MBR.   Otherwise we think it's an old MBR.
        // But code below will account for GPT structures as well
        //
        if (MbrTable[0].PartitionType == PARTITION_TYPE_GPT_SHADOW) {   // 0xEE
            //
            // Well, that type should never occur anywhere else,
            // so assume it's a GPT Shadow regardless of how it's set
            //
            MbrState = MBR_STATE_GPT;
        } else {
            //
            // It's not RAW (there's a signature) and it's not
            // GPT Shadow MBR (no 0xEE for Table[0] type
            // So, assume it's an MBR and we're done
            //
            *DiskType = DISK_MBR;
            DoFree(p);
            p = NULL;
            return EFI_SUCCESS;
        }
    } else {
        *DiskType = DISK_RAW;       // if we don't find more...
    }


    //
    // ----- h1/t1 ------------------------------------------------
    //

    //
    // Read Header1. If cannot *read* it, punt.
    // First header is always at Block 1, 1 block long
    //
    h1 = p;
    p = NULL;
    status = ReadBlock(DiskHandle, h1, 1, BlockSize);
    if (EFI_ERROR(status)) goto ErrorRead;

    //
    // h1 => header1
    //
    if ( (h1->Signature != GPT_HEADER_SIGNATURE) ||
         (h1->Revision != GPT_REVISION_1_0) ||
         (h1->HeaderSize != sizeof(GPT_HEADER)) ||
         (h1->SizeOfGPT_ENTRY != sizeof(GPT_ENTRY))  )
    {
        H1T1good = FALSE;
        if (DebugLevel >= DEBUG_ERRPRINT) {
            Print(L"GPT header 1 is incorrect with status %x\n",
                  (h1->Signature != GPT_HEADER_SIGNATURE)*1 +
                  (h1->Revision != GPT_REVISION_1_0)*2 +
                  (h1->HeaderSize != sizeof(GPT_HEADER))*4 +
                  (h1->SizeOfGPT_ENTRY != sizeof(GPT_ENTRY))*8);
        }
    }

    h1crc = h1->HeaderCRC32;
    h1->HeaderCRC32 = 0;
    newcrc = GetCRC32(h1, sizeof(GPT_HEADER));
    h1->HeaderCRC32 = h1crc;

    if (h1crc != newcrc) {
        H1T1good = FALSE;
        if (DebugLevel >= DEBUG_ERRPRINT) {
            Print(L"GPT header 1 crc is incorrect\n");
        }
    }

    if (H1T1good) {
        PartialGPT = TRUE;
    }

    //
    // if header1 is bad, assume that table1 is bad too...
    //
    if (H1T1good) {

        TableSize = sizeof(GPT_ENTRY) * h1->EntriesAllocated;


        t1 = DoAllocate(TableSize);
        if (t1 == NULL) goto ErrorMem;

        //
        // OK, so how many BLOCKS long is the table?
        //
        TableBlocks = TableSize / BlockSize;

        //
        // if we cannot READ t1, punt...
        //
        status = ReadBlock(DiskHandle, t1, h1->TableLBA, TableSize);
        if (EFI_ERROR(status)) goto ErrorRead;

        newcrc = GetCRC32(t1, TableSize);

        if (h1->TableCRC32 != newcrc) {
            H1T1good = FALSE;
            if (DebugLevel >= DEBUG_ERRPRINT) {
                Print(L"GPT table 1 crc is incorrect\n");
            }
        }
    }


    //
    // ----- h2/t2 ------------------------------------------------
    //

    //
    // Read Header2. If cannot *read* it, punt.
    //
    h2 = DoAllocate(BlockSize);
    if (h2 == NULL) goto ErrorMem;

    //
    // Header2 is always 1 block long, last block on disk
    //
    status = ReadBlock(DiskHandle, h2, DiskSize-1, BlockSize);
    if (EFI_ERROR(status)) goto ErrorRead;

    //
    // h2 => header2
    //
    if ( (h2->Signature != GPT_HEADER_SIGNATURE) ||
         (h2->Revision != GPT_REVISION_1_0) ||
         (h2->HeaderSize != sizeof(GPT_HEADER)) ||
         (h2->SizeOfGPT_ENTRY != sizeof(GPT_ENTRY))  )
    {
        H2T2good = FALSE;
        if (DebugLevel >= DEBUG_ERRPRINT) {
            Print(L"GPT header 2 is incorrect with status %x\n",
                  (h2->Signature != GPT_HEADER_SIGNATURE)*1 +
                  (h2->Revision != GPT_REVISION_1_0)*2 +
                  (h2->HeaderSize != sizeof(GPT_HEADER))*4 +
                  (h2->SizeOfGPT_ENTRY != sizeof(GPT_ENTRY))*8);
        }
    }

    h2crc = h2->HeaderCRC32;
    h2->HeaderCRC32 = 0;
    newcrc = GetCRC32(h2, sizeof(GPT_HEADER));
    h2->HeaderCRC32 = h2crc;

    if (h2crc != newcrc) {
        H2T2good = FALSE;
        if (DebugLevel >= DEBUG_ERRPRINT) {
            Print(L"GPT header 2 crc is incorrect\n");
        }
    }

    if (H2T2good) {
        PartialGPT = TRUE;
    }

    //
    // if header2 is bad, assume that table2 is bad too...
    //
    if (H2T2good) {

        TableSize = sizeof(GPT_ENTRY) * h2->EntriesAllocated;

        t2 = DoAllocate(TableSize);
        if (t2 == NULL) goto ErrorMem;

        //
        // OK, so how many BLOCKS long is the table?
        //
        TableBlocks = TableSize / BlockSize;

        //
        // if we cannot READ t2, punt...
        //
        status = ReadBlock(DiskHandle, t2,  h2->TableLBA, TableSize);
        if (EFI_ERROR(status)) goto ErrorRead;

        newcrc = GetCRC32(t2, TableSize);

        if (h2->TableCRC32 != newcrc) {
            H2T2good = FALSE;
            if (DebugLevel >= DEBUG_ERRPRINT) {
                Print(L"GPT table 2 crc is incorrect\n");
            }
        }
    }

    //
    // ------ analysis  --------------------------------------------------
    //
    // since we are here:
    //  h1 -> header1, t1 -> table1, H1T1good indicates state
    //  h2 -> header2, t2 -> table2, H2T2good indicates state
    //

    lba = (PLBA_BLOCK)DoAllocate(sizeof(LBA_BLOCK));
    if (lba == NULL) goto ErrorMem;

    lba->Header1_LBA = 1;
    lba->Table1_LBA = h1->TableLBA;
    lba->Header2_LBA = (DiskSize - 1);
    lba->Table2_LBA = h2->TableLBA;

    if (H1T1good) {
        *Header = h1;
        *Table = t1;
        *LbaBlock = lba;

        if ( (H2T2good) &&
             (h1->AlternateLBA == (DiskSize-1)) &&
             (CompareMem(t1, t2, TableSize) == 0)
           )
        {
            *DiskType = DISK_GPT;
        } else {
            *DiskType = DISK_GPT_UPD;
            if (DebugLevel >= DEBUG_ERRPRINT) {
                Print(L"GPT partition table 1 checked out but table 2 is inconsistent with table 1\n");
            }
        }
        DoFree(h2);
        h2 = NULL;
        DoFree(t2);
        t2 = NULL;
        status = EFI_SUCCESS;
        return status;
    }

    if (H2T2good) {
        // since we're here, H1T1good is FALSE...

        *Header = h2;
        *Table = t2;
        *LbaBlock = lba;
        DoFree(h1);
        h1 = NULL;
        DoFree(t1);
        t1 = NULL;

        *DiskType = DISK_GPT_UPD;
        if (DebugLevel >= DEBUG_ERRPRINT) {
            Print(L"GPT partition table 2 checked out but table 1 is not good\n");
        }
        return EFI_SUCCESS;
    }

    //
    // Since we're HERE, H1T1good AND H2T2good are BOTH false.
    // Unless the shadow MBR says it's a GPT disk, claim it's raw.
    // If we did see a shadow, or GPT partial is set, say it's a bad GPT
    //
    if ( (PartialGPT) || (MbrState == MBR_STATE_GPT) ) {
        //
        // At least one of the headers looked OK,
        //          OR
        // There's an MBR that looks like a GPT shadow MBR
        //          SO
        // Report DISK_GPT_BAD
        //
        *DiskType = DISK_GPT_BAD;
        goto ExitRet;

    } else {
        //
        // It's not an MBR disk, or we wouldn't have gotten here
        //
        *DiskType = DISK_RAW;
        goto ExitRet;
    }

ErrorMem:
    status = EFI_OUT_OF_RESOURCES;
    goto ExitRet;

ErrorRead:
    status = EFI_DEVICE_ERROR;

ExitRet:
    DoFree(p);
    DoFree(h1);
    DoFree(t1);
    DoFree(h2);
    DoFree(t2);
    DoFree(lba);
    return status;
}


EFI_STATUS
WriteGPT(
    EFI_HANDLE      DiskHandle,
    PGPT_HEADER     Header,
    PGPT_TABLE      Table,
    PLBA_BLOCK      LbaBlock
    )
/*
    CALLER is expected to fill in:
            FirstUseableLBA
            LastUseableLBA
            EntryCount
            DiskGUID

    We fill in the rest, and blast it out.

    Returns a status.

*/
{
    UINT32      BlockSize;
    UINT32      TableSize;
    UINT32      TableBlocks;

    status = EFI_SUCCESS;

    BlockSize = GetBlockSize(DiskHandle);
    TableSize = Header->EntriesAllocated * sizeof(GPT_ENTRY);

    WriteShadowMBR(DiskHandle);
    //
    // Write out the primary header...
    //
    Header->Signature = GPT_HEADER_SIGNATURE;
    Header->Revision = GPT_REVISION_1_0;
    Header->HeaderSize = sizeof(GPT_HEADER);

    Header->MyLBA = LbaBlock->Header1_LBA;
    Header->AlternateLBA = LbaBlock->Header2_LBA;

    Header->TableLBA = LbaBlock->Table1_LBA;
    Header->SizeOfGPT_ENTRY = sizeof(GPT_ENTRY);

    Header->TableCRC32 = GetCRC32(Table, TableSize);

    Header->HeaderCRC32 = 0;
    Header->HeaderCRC32 = GetCRC32(Header, sizeof(GPT_HEADER));

    if (DebugLevel >= DEBUG_ARGPRINT) {
        Print(L"\nWriteGPT\n    DiskHandle = %8X\n", DiskHandle);
        Print(L"    Header=%X\n", Header);
        Print(L"    Signature=%lX\n    Revision=%X  HeaderSize=%X HeaderCRC=%X\n",
                Header->Signature, Header->Revision, Header->HeaderSize, Header->HeaderCRC32);
        Print(L"          MyLBA=%lX  AltLBA=%lX\n", Header->MyLBA, Header->AlternateLBA);
        Print(L"    FirstUsable=%lX    Last=%lX\n", Header->FirstUsableLBA,  Header->LastUsableLBA);
        Print(L"       TableLBA=%lX\n", Header->TableLBA);
    }

    status = WriteBlock(DiskHandle, Header, LbaBlock->Header1_LBA, BlockSize);

    if (EFI_ERROR(status)) return status;

    //
    // Write out the primary table ...
    //
    TableBlocks = TableSize / BlockSize;

    status = WriteBlock(DiskHandle, Table, LbaBlock->Table1_LBA, TableSize);

    if (EFI_ERROR(status)) return status;

    //
    // Write out the secondary header ...
    //
    Header->MyLBA = LbaBlock->Header2_LBA;
    Header->AlternateLBA = 0;
    Header->TableLBA = LbaBlock->Table2_LBA;
    Header->HeaderCRC32 = 0;
    Header->HeaderCRC32 = GetCRC32(Header, sizeof(GPT_HEADER));

    status = WriteBlock(DiskHandle, Header, LbaBlock->Header2_LBA, BlockSize);

    if (EFI_ERROR(status)) return status;

    //
    // write out the secondary table ..
    //
    TableBlocks = TableSize / BlockSize;

    status = WriteBlock(DiskHandle, Table, LbaBlock->Table2_LBA, TableSize);
    FlushBlock(DiskHandle);
    return status;
}


EFI_STATUS
WriteShadowMBR(
    EFI_HANDLE   DiskHandle
    )
/*
    WriteShadowMBR writes out a GPT shadow master boot record,
    which means an MBR full of zeros except:
    a. It has the 0xaa55 signature at 0x1fe
    b. It has a single partition entry of type 'EE'...
*/
{
    UINT32      BlockSize;
    UINT8       *MbrBlock;
    UINT64      DiskSize;
    MBR_ENTRY UNALIGNED *MbrEntry = NULL;
    UINT16    UNALIGNED *MbrSignature;

    BlockSize = GetBlockSize(DiskHandle);
    MbrBlock = DoAllocate(BlockSize);

    if (MbrBlock == NULL) {
        status = EFI_OUT_OF_RESOURCES;
        return status;
    }

    ZeroMem(MbrBlock, BlockSize);
    DiskSize = GetDiskSize(DiskHandle);
    if (DiskSize > 0xffffffff) {
        DiskSize = 0xffffffff;
    }

    MbrEntry = (MBR_ENTRY *)(MbrBlock + MBR_TABLE_OFFSET);
    MbrEntry->ActiveFlag = 0;
    MbrEntry->PartitionType = PARTITION_TYPE_GPT_SHADOW;
    MbrEntry->StartingSector = 1;
    MbrEntry->PartitionLength = (UINT32)DiskSize - MbrEntry->StartingSector;


    //
    // We don't actually know this data, so we'll make up
    // something that seems likely.
    //

    //
    // Old software is expecting the Partition to start on
    // a Track boundary, so we'll set track to 1 to avoid "overlay"
    // with the MBR
    //

    MbrEntry->StartingTrack = 1;
    MbrEntry->StartingCylinderLsb = 0;
    MbrEntry->StartingCylinderMsb = 0;
    MbrEntry->EndingTrack = 0xff;
    MbrEntry->EndingCylinderLsb = 0xff;
    MbrEntry->EndingCylinderMsb = 0xff;
    MbrSignature = (UINT16 *)(MbrBlock + MBR_SIGNATURE_OFFSET);
    *MbrSignature = BOOT_RECORD_SIGNATURE;

    status = WriteBlock(DiskHandle, MbrBlock, 0, BlockSize);

    DoFree(MbrBlock);
    return status;
}


EFI_STATUS
CreateGPT(
    EFI_HANDLE  DiskHandle,
    UINTN       EntryRequest
    )
/*
    Write a new GPT table onto a clean disk

    When we get here, we assume the disk is clean, and
    that the user really wants to do this.

    DiskHandle - the disk we are going to write to

    EntryRequest - number of entries the user wants, ignored
        if less than our minimum, rounded up to number of entries
        that fill up the nearest sector.  So, the user is
        says "at least" this many.

        Ignored if > 1024. (At least for now)

    NOTE:
        Even though the disk is in theory all zeros from
        having been cleaned, we actually rewrite all the data,
        just in case somebody fooled the detector code...

*/
{
    UINTN       EntryCount;
    UINTN       BlockFit;
    UINTN       BlockSize;
    UINTN       EntryBlocks;
    UINT64      DiskSize;
    LBA_BLOCK   LbaBlock;
    PGPT_HEADER Header;
    PGPT_TABLE  Table;
    UINTN       TableSize;
    EFI_LBA     Header1_LBA;
    EFI_LBA     Table1_LBA;
    EFI_LBA     Header2_LBA;
    EFI_LBA     Table2_LBA;
    EFI_LBA     FirstUsableLBA;
    EFI_LBA     LastUsableLBA;

    //
    // BlockSize is the block/sector size, in bytes.
    // It is assumed to be a power of 2 and >= 512
    //
    BlockSize = GetBlockSize(DiskHandle);

    //
    // DiskSize is a Count (1 based, not 0 based) of
    // software visible blocks on the disk.  We assume
    // we may address them as 0 to DiskSize-1.
    //
    DiskSize = GetDiskSize(DiskHandle);

    //
    // By default, we support the max of 32 entries or
    // BlockSize/sizeof(GPT_ENTRY).  (Meaning there will
    // always be at least 32 entries and always be at least
    // enough entries to fill 1 sector)
    // If the user asks for more than that, but less than
    // the sanity threshold, we give the user what they asked
    // for, rounded up to BlockSize/sizeof(GPT_ENTRY)
    //

    EntryCount = ENTRY_DEFAULT;
    BlockFit = BlockSize/sizeof(GPT_ENTRY);

    if (BlockFit > ENTRY_DEFAULT) {
        EntryCount = BlockFit;
    }

    if (EntryRequest > EntryCount) {
        if (EntryRequest <= ENTRY_SANITY_LIMIT) {   // 1024

            EntryCount = ((EntryRequest + BlockFit) / BlockFit) * BlockFit;

            if ((EntryCount < EntryRequest) ||
                (EntryCount < ENTRY_DEFAULT) ||
                (EntryCount < BlockFit))
            {
                TerribleError(L"CreateGPT is terribly confused\n");
            }
        }
    }

    EntryBlocks = EntryCount / BlockFit;

    if ((EntryBlocks * BlockFit) != EntryCount) {
        TerribleError(L"CreateGPT is terribly confused, spot #2\n");
    }

    Header1_LBA = 1;
    Table1_LBA = 2;
    FirstUsableLBA = Table1_LBA + EntryBlocks;

    Header2_LBA = DiskSize - 1;
    Table2_LBA = Header2_LBA - EntryBlocks;
    LastUsableLBA = Table2_LBA - 1;

    TableSize = EntryBlocks * BlockSize;

    if (TableSize != (EntryCount * sizeof(GPT_ENTRY))) {
        TerribleError(L"CreateGPT is terribly confused, spot #3\n");
    }

    if (DebugLevel >= DEBUG_ARGPRINT) {
        Print(L"DiskSize = %lx\n", DiskSize);
        Print(L"BlockSize = %x\n", BlockSize);
        Print(L"Header1_LBA = %lx\n", Header1_LBA);
        Print(L"Table1_LBA = %lx\n", Table1_LBA);
        Print(L"FirstUsableLBA = %lx\n", FirstUsableLBA);
        Print(L"Header2_LBA = %lx\n", Header2_LBA);
        Print(L"Table2_LBA = %lx\n", Table2_LBA);
        Print(L"LastUsableLBA = %lx\n", LastUsableLBA);
        Print(L"EntryCount = %x\n", EntryCount);
        Print(L"EntryBlocks = %x\n", EntryBlocks);
    }

    //
    // OK, from this point it's just filling in structures
    // and writing them out.
    //

    Header = (PGPT_HEADER)DoAllocate(BlockSize);
    if (Header == NULL) {
        return EFI_OUT_OF_RESOURCES;
    }
    ZeroMem(Header, BlockSize);

    //
    // Since we're making empty tables, we just write zeros...
    //

    Table = (PGPT_TABLE)DoAllocate(TableSize);
    if (Table == NULL) {
        DoFree(Header);
        Header = NULL;
        return EFI_OUT_OF_RESOURCES;
    }
    ZeroMem(Table, TableSize);

    //
    // Fill in the things that WriteGPT doesn't understand
    //
    Header->FirstUsableLBA = FirstUsableLBA;
    Header->LastUsableLBA = LastUsableLBA;
    Header->EntriesAllocated = (UINT32)EntryCount;
    Header->DiskGUID = GetGUID();

    LbaBlock.Header1_LBA = Header1_LBA;
    LbaBlock.Header2_LBA = Header2_LBA;
    LbaBlock.Table1_LBA = Table1_LBA;
    LbaBlock.Table2_LBA = Table2_LBA;

    status = WriteGPT(
                DiskHandle,
                Header,
                Table,
                &LbaBlock
                );

    DoFree(Header);
    DoFree(Table);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\diskpart.h ===
//
// diskpart.h
//

//
// Alignmnet macros
//

#if defined (i386)
#   define UNALIGNED
#elif defined (_IA64_)
#   define UNALIGNED __unaligned
#elif defined (ALPHA)
#   define UNALIGNED __unaligned
#endif


//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#include "efi.h"
#include "efilib.h"
#include "msg.h"
#include "scriptmsg.h"
#include "gpt.h"
#include "mbr.h"

//
// Debug Control
//
#define DEBUG_NONE      0
#define DEBUG_ERRPRINT  1
#define DEBUG_ARGPRINT  2
#define DEBUG_OPPROMPT  3

extern  UINTN   DebugLevel;


//
//  Externs
//
extern  EFI_GUID    BlockIOProtocol;

extern  EFI_STATUS  status;             // always save the last error status
                                        // by using this global

extern  INTN    AllocCount;             // track DoFree/DoAlloc

extern  EFI_HANDLE  *DiskHandleList;
extern  INTN        SelectedDisk;

BOOLEAN ScriptList(CHAR16 **Token);

//
// Prototypes for all fo the workers for main parser in DiskPart
// Declared here so that scripts can call them
//
BOOLEAN CmdAbout(CHAR16 **Token);
BOOLEAN CmdList(CHAR16 **Token);
BOOLEAN CmdSelect(CHAR16 **Token);
BOOLEAN CmdInspect(CHAR16 **Token);
BOOLEAN CmdClean(CHAR16 **Token);
BOOLEAN CmdNew(CHAR16 **Token);
BOOLEAN CmdFix(CHAR16 **Token);
BOOLEAN CmdCreate(CHAR16 **Token);
BOOLEAN CmdDelete(CHAR16 **Token);
BOOLEAN CmdHelp(CHAR16 **Token);
BOOLEAN CmdExit(CHAR16 **Token);
BOOLEAN CmdSymbols(CHAR16 **Token);
BOOLEAN CmdRemark(CHAR16 **Token);
BOOLEAN CmdMake(CHAR16 **Token);
BOOLEAN CmdDebug(CHAR16 **Token);

//
// Worker function type
//
typedef
BOOLEAN
(*PSCRIPT_FUNCTION)(
    CHAR16  **Token
    );

//
// The script table structure
//
typedef struct {
    CHAR16              *Name;
    PSCRIPT_FUNCTION    Function;
    CHAR16              *HelpSummary;
} SCRIPT_ENTRY;

extern  SCRIPT_ENTRY    ScriptTable[];


//
//  Routines that will need to be ported
//
EFI_STATUS
FindPartitionableDevices(
    EFI_HANDLE  **ReturnBuffer,
    UINTN       *Count
    );


//
// Utility/Wrapper routines
//

UINT32      GetBlockSize(EFI_HANDLE  Handle);
UINT64      GetDiskSize(EFI_HANDLE  Handle);
VOID        DoFree(VOID *Buffer);
VOID        *DoAllocate(UINTN Size);
UINT32      GetCRC32(VOID *Buffer, UINT32 Length);
EFI_GUID    GetGUID();

EFI_STATUS
WriteBlock(
    EFI_HANDLE  DiskHandle,
    VOID        *Buffer,
    UINT64      BlockAddress,
    UINT32      BlockCount
    );


EFI_STATUS
ReadBlock(
    EFI_HANDLE  DiskHandle,
    VOID        *Buffer,
    UINT64      BlockAddress,
    UINT32      Size
    );

EFI_STATUS
FlushBlock(
    EFI_HANDLE  DiskHandle
    );


VOID
TerribleError(
    CHAR16  *String
    );

//
// Misc useful stuff
//
VOID        PrintHelp(CHAR16 *HelpText[]);
EFI_STATUS  GetGuidFromString(CHAR16 *String, EFI_GUID *Guid);
INTN        HexChar(CHAR16 Ch);
UINT64      Xtoi64(CHAR16 *String);
UINT64      Atoi64(CHAR16  *String);
VOID        PrintGuidString(EFI_GUID *Guid);
BOOLEAN     IsIn(CHAR16  What, CHAR16  *InWhat);
VOID        Tokenize(CHAR16  *CommandLine, CHAR16  **Token);
#define COMMAND_LINE_MAX    512
#define TOKEN_COUNT_MAX     256         // most possible in 512 chars


#define NUL     ((CHAR16)0)

//
// Some EFI functions are just a rename of 'C' lib functions,
// so they can just be macroed back.
// Somebody will need to check this out...
//
#if 0
#define CompareMem(a, b, c) memcmp(a, b, c)
#define ZeroMem(a, b)       memset(a, 0, b)

//
// This is a fiction, Print is NOT printf, but it's close
// enough that everything or almost everything will work...
//
#define Print   printf

#endif

//
// Functions that allow the Guid Generator to be used
//

VOID InitGuid(VOID); 
VOID CreateGuid(EFI_GUID *guid);


//
// Status Symbols
//
#define DISK_ERROR      0
#define DISK_RAW        1
#define DISK_MBR        2
#define DISK_GPT        4
#define DISK_GPT_UPD    6
#define DISK_GPT_BAD    7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\gpt.h ===
//
// GPT (GUID Partition Table) declarations.
//


//
// DO WE EVER ALLOW GPT_TABLEs TO NOT BE PACKED UP AGAINST THEIR HEADER?
// IF NOT, DO WE ALLOW PEOPLE TO MAKE ASSUMPTIONS ABOUT THEIR LOCATION?
// DO WE NEED THE POINTER?
//

//
// Rules:
//      None of these structures ever appear at LBA 0, because
//      we put a "fake" MBR there (the legacy defense MBR).
//      Therefore, LBA of 0 is useable as NULL.
//
//      For All Entry's, StartingLBA must be >= FirstUsableLBA.
//      For All Entry's, EndingLBA must be <= LastUsableLBA.
//
//      0 is not a valid GUID.  Therefore, emtpy GPT_ENTRY's will
//      have a PartitionType of 0.
//      However, if an entry is otherwise valid, but has a PartitionID
//      of 0, this means a GUID needs to be generated and placed there.
//
//      LBA = Logical Block Address == Sector Number.  Always count from 0.
//
//      Block size (sector size) could be any number >= sizeof(GPT_ENTRY)
//      AND >= sizeof(GPT_HEADER).  In practice, always >= 512 bytes.
//
//      A block, B, is free for allocation to a partition if and only if
//      it is in the range FirstUsableLBA <= B <= LastUsableLBA AND it
//      is not already allocated to some other parition.
//
//      GPT partitions are always contiguous arrays of blocks.  however,
//      they need NOT be packed on the disk, their order in the GPT need
//      NOT match their order on the disk, there may be blank entries
//      in the GPT table, etc.  Building an accurate view of the parititon
//      *requires* reading the entire GPT_TABLE into memory.  In practice,
//      it will always be small enough for this to be easy.
//

#pragma pack (4)

//
// Each partition is described by a GPT_ENTRY.
//
#define PART_NAME_LEN       36

typedef struct {
    EFI_GUID    PartitionType;  // declartion of this partition's type
    EFI_GUID    PartitionID;    // Unique ID for this particular partition
                                // (unique to this instance)
    EFI_LBA     StartingLBA;    // 0 based block (sector) address of the
                                // first block included in the partition.
    EFI_LBA     EndingLBA;      // 0 based block (sector) address of the
                                // last block included in the partition.
                                // If StartingLBA == EndingLBA then the
                                // partition is 1 block long.  this is legal.
    UINT64      Attributes;     // Always ZERO for now
    CHAR16      PartitionName[PART_NAME_LEN];  // 36 unicode characters of name
} GPT_ENTRY, *PGPT_ENTRY;

C_ASSERT (sizeof (GPT_ENTRY) == 128);
//
// All of the GPT_ENTRY's are gathered into a GPT_TABLE, which
// is stored as a linear array of blocks on the disk.
//
typedef struct {
    GPT_ENTRY   Entry[1];       // Always an integer number of Entry's
                                // per sector.  Always at least 1 sector.
                                // Can be any number of sectors...
} GPT_TABLE, *PGPT_TABLE;

//
// A main and a backup header each describe the disk, and each points
// to it's own copy of the GPT_TABLE...
//
typedef struct {
    UINT64      Signature;      // GPT PART
    UINT32      Revision;
    UINT32      HeaderSize;
    UINT32      HeaderCRC32;    // computed using 0 for own init value
    UINT32      Reserved0;
    EFI_LBA     MyLBA;          // 0 based sector number of the first
                                // sector of this structure
    EFI_LBA     AlternateLBA;   // 0 based sector (block) number of the
                                // first sector of the secondary
                                // GPT_HEADER, or 0 if this is the
                                // secondary.
    EFI_LBA     FirstUsableLBA; // 0 based sector number of the first
                                // sector that may be included in a partition.
    EFI_LBA     LastUsableLBA;  // last legal LBA, inclusive.
    EFI_GUID    DiskGUID;       // The unique ID of this LUN/spindle/disk
    EFI_LBA     TableLBA;       // The start of the table of entries...
    UINT32      EntriesAllocated; // Number of entries in the table, this is
                                  // how many allocated, NOT how many used.
    UINT32      SizeOfGPT_ENTRY;    // sizeof(GPT_ENTRY) always mult. of 8
    UINT32      TableCRC32;      // CRC32 of the table.
    // Reserved and zeros to the end of the block
    // Don't declare an array or sizeof() gives a nonsense answer..
} GPT_HEADER, *PGPT_HEADER;

C_ASSERT (sizeof (GPT_HEADER) == 92);

#define GPT_HEADER_SIGNATURE    0x5452415020494645
#define GPT_REVISION_1_0        0x00010000

#define ENTRY_DEFAULT       128
//#define ENTRY_DEFAULT       8           // TESTING ONLY
#define ENTRY_SANITY_LIMIT  1024


//
// GPT Disk Layout
//
/*

        +---------------------------------------------------+
LBA=0   | "Fake" MBR to ward off legacy parition apps       |
        +---------------------------------------------------+
LBA=1   | Primary GPT_HEADER                                |
        +---------------------------------------------------+
LBA=2   | Primary GPT_TABLE starts                          |
        ...             ...                                 ...
LBA=n   | Primary GPT_TABLE ends                            |
        +---------------------------------------------------+
LBA=n+1 | FirstUsableLBA = this block                       |
        ...             ...                                 ...
LBA=x   | LastUsableLBA = this block                        |
        +---------------------------------------------------+
LBA=x+1 | Secondary GPT_TABLE starts                        |
        ...             ...                                 ...
LBA=z   | Secondary GPT_TABLE ends                          |
        +---------------------------------------------------+
LBA=z+n | Secondary GPT_HEADER starts                       |
        ...             ...                                 ...
LAST    | Secondary GPT_HEADER ends at last sector of disk  |
        +---------------------------------------------------+

SO:
    Primary GPT_HEADER is always at LBA=1
    Secondary GPT_HEADER is at LBA=Last so long as GPT_HEADER fits
    in 1 sector, which we require.

    Primary Table is stacked up after the primary header,
    which points to it anyway.

    Secondary Table is stacked up before the secondary header,
    which points to it anyway.

*/


//
// ------------------ Functions To Manipulate GPT ---------------
//
typedef struct _LBA_BLOCK {
    EFI_LBA     Header1_LBA;
    EFI_LBA     Table1_LBA;
    EFI_LBA     Header2_LBA;
    EFI_LBA     Table2_LBA;
} LBA_BLOCK, *PLBA_BLOCK;


EFI_STATUS
ReadGPT(
    EFI_HANDLE      DiskHandle,
    PGPT_HEADER     *Header,
    PGPT_TABLE      *Table,
    PLBA_BLOCK      *LbaBlock,
    UINTN           *DiskType
    );

EFI_STATUS
WriteGPT(
    EFI_HANDLE      DiskHandle,
    PGPT_HEADER     Header,
    PGPT_TABLE      Table,
    PLBA_BLOCK      LbaBlock
    );

EFI_STATUS
CreateGPT(
    EFI_HANDLE  DiskHandle,
    UINTN       EntryRequest
    );

#pragma pack ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\diskpart.c ===
/*

Module Name:

    DiskPart - GUID Partition Table scheme disk partitioning program.
                (The GPT version of FDISK, if you will)

Abstract:

Revision History

*/

#include "DiskPart.h"
#include "symbols.h"
#include "helpmsg.h"

//
// Globals
//
UINTN       DebugLevel = DEBUG_NONE;
//UINTN       DebugLevel = DEBUG_OPPROMPT;

EFI_STATUS  status;
EFI_HANDLE  *DiskHandleList = NULL;
INTN        DiskHandleCount = 0;
INTN        SelectedDisk = -1;

EFI_HANDLE  SavedImageHandle;

EFI_STATUS  ParseAndExecuteCommands();
BOOLEAN     ExecuteSingleCommand(CHAR16 *Token[]);




VOID DumpGPT(
        EFI_HANDLE DiskHandle,
        PGPT_HEADER Header,
        PGPT_TABLE Table,
        BOOLEAN Raw,
        BOOLEAN Verbose
        );
VOID
PrintGptEntry(
    GPT_ENTRY   *Entry,
    UINTN       Index
    );


EFI_GUID
GetGUID(
    );

#define CLEAN_RANGE (1024*1024)


CHAR16  *TokenChar =
L"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789`~!@#$%^&*()-_+[]{}':;/?.>,<\\|";



VOID    CmdInspectMBR(CHAR16  **Token);
VOID    CmdCreateMBR(CHAR16  **Token);
VOID    CmdNewMBR(CHAR16  **Token);
VOID    CmdDeleteMBR(CHAR16  **Token);

//
// Worker function type
//
typedef
BOOLEAN
(*PCMD_FUNCTION)(
    CHAR16  **Token
    );

EFI_STATUS
ReinstallFSDStack(
    );

//
// The parse table structure
//
typedef struct {
    CHAR16          *Name;
    PCMD_FUNCTION   Function;
    CHAR16          *HelpSummary;
} CMD_ENTRY;

//
// The parse/command table
//
CMD_ENTRY   CmdTable[] = {
                { STR_LIST,     CmdList,    MSG_LIST },
                { STR_SELECT,   CmdSelect,  MSG_SELECT },
                { STR_INSPECT,  CmdInspect, MSG_INSPECT },
                { STR_CLEAN,    CmdClean,   MSG_CLEAN },
                { STR_NEW,      CmdNew,     MSG_NEW },
                { STR_FIX,      CmdFix,     MSG_FIX },
                { STR_CREATE,   CmdCreate,  MSG_CREATE },
                { STR_DELETE,   CmdDelete,  MSG_DELETE },
                { STR_HELP,     CmdHelp,    MSG_HELP },
                { STR_HELP2,    CmdHelp,    MSG_ABBR_HELP },
                { STR_HELP3,    CmdHelp,    MSG_ABBR_HELP },
                { STR_EXIT,     CmdExit,    MSG_EXIT },
                { STR_SYMBOLS,  CmdSymbols, MSG_SYMBOLS },
                { STR_REMARK,   CmdRemark,  MSG_REMARK },
                { STR_MAKE,     CmdMake,    MSG_MAKE },
                { STR_DEBUG,    CmdDebug,   NULL },
                { STR_ABOUT,    CmdAbout,   MSG_ABOUT },
                { NULL, NULL, NULL }
            };


EFI_STATUS
EfiMain(
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    //
    // Initialize the Library.
    //
    SavedImageHandle = ImageHandle;
    InitializeLib (ImageHandle, SystemTable);


    Print(L"DiskPart Version 0.2\n");
    Print(L"Based on EFI core release ");
    Print(MSG_ABOUT02,
        EFI_SPECIFICATION_MAJOR_REVISION,
        EFI_SPECIFICATION_MINOR_REVISION,
        EFI_FIRMWARE_MAJOR_REVISION,
        EFI_FIRMWARE_MINOR_REVISION
    );

    //
    // See if there are any disks that look like candidates to be partitioned
    //
    status = FindPartitionableDevices(&DiskHandleList, &DiskHandleCount);
    if (EFI_ERROR(status)) {
        Print(L"%s\n", MSG_NO_DISKS);
        return EFI_NOT_FOUND;
    }

    //
    // Start Parse Loop
    //
    ParseAndExecuteCommands();
    
    ReinstallFSDStack();

    DoFree(DiskHandleList);
    return status;
}


EFI_STATUS
ReinstallFSDStack(
    )
/*++ 

    Make sure that the partition driver is alerted to the changes in the
    the file system structures.  One way to effect this end is to 
    reinstall all of the blkio interfaces such that the partition driver
    will receive a notification and probe the partition tables to reconstruct
    the file system stack.


--*/
{
    INTN            Index;      
    EFI_STATUS      Status;
    EFI_BLOCK_IO    *IBlkIo;

    Status = EFI_SUCCESS;

    for (Index = 0; Index < DiskHandleCount; Index++) {
   
        Status = BS->HandleProtocol(
                          DiskHandleList[Index], 
                          &BlockIoProtocol, 
                          &IBlkIo
                          );
 
        if (!EFI_ERROR(Status)) {
            Status = BS->ReinstallProtocolInterface (
                                DiskHandleList[Index], 
                                &BlockIoProtocol, 
                                IBlkIo, 
                                IBlkIo
                                );   
	      }
    }

    return Status;
}




EFI_STATUS
ParseAndExecuteCommands()
/*
    ParseAndExecuteCommands reads 1 line at a time from stdin.
    Lines are parsed for commands and arguments.
    The symbol ";" (semicolon) is used to mark the end of a command
    and start a new one.
    \ is the escape, \\ => '\'

    All commands are upper cased before parsing to give us
    case insensitive operations.  This does not apply to literal
    strings.

    Any white space is treated a token separator.

    Commandline is set quite long.
*/
{
    CHAR16  *Prompt = MSG_PROMPT;
    CHAR16  CommandLine[COMMAND_LINE_MAX];
    CHAR16  *Token[TOKEN_COUNT_MAX];
    UINTN   i;

NewLine:
    while (TRUE) {
        for (i = 0; i < COMMAND_LINE_MAX; i++ ) {
            CommandLine[i] = NUL;
        }
        Input(Prompt, CommandLine, COMMAND_LINE_MAX);
        Print(L"\n");
        if (CommandLine[0] == NUL) {
            continue;
        }
        StrUpr(CommandLine);
        Tokenize(CommandLine, Token);

        if (Token[0] == (CHAR16 *)-1) {
            //
            // syntax error
            //
            Print(L"???\n");
            goto NewLine;
        }

        if (ExecuteSingleCommand(Token) == TRUE) {
            return TRUE;
        }
        if (DebugLevel >= DEBUG_ERRPRINT) {
            if (EFI_ERROR(status)) {
                Print(L"status = %x %r\n", status, status);
            }
        }
    }
    return EFI_SUCCESS;
}


VOID
Tokenize(
    CHAR16  *CommandLine,
    CHAR16  *Token[]
    )
/*
    Tokenize -

        find the tokens, where a token is any string of letter & numbers.
        tokens to contain blanks, etc, must begin end with "

    return
        Token[] set.  if Token[0] = NULL, nothing in THIS command
*/
{
    CHAR16  *ch;
    UINTN   tx;

    //
    // init the token array
    //
    for (tx = 0; tx < TOKEN_COUNT_MAX; tx++) {
        Token[tx] = NULL;
    }
    tx = 0;

    //
    // sweep for tokens
    //
    ch = CommandLine;
    while (TRUE) {

        //
        // if we see a quote, advance to the closing quote
        // and call the result a token.
        //
        if (*ch == '"') {
            ch++;
            Token[tx] = ch;
            while ((*ch != '"') && (*ch != NUL)) {
                ch++;
            }
            if (*ch == '"') {
                //
                // we have the closing ", we have a token
                //
                *ch = NUL;                   // mark end of token
                ch++;
                tx++;
            } else {
                Token[0] = (CHAR16 *)-1;              // report error
                return;
            }
        } else {
            //
            // not a quoted string, so pick off a normal token
            //
            // Start by finding start of token
            //
            for ( ; *ch != NUL; ch++) {
                if (IsIn(*ch, TokenChar)) {
                    Token[tx] = ch;
                    tx++;
                    break;
                }
            }
            while (IsIn(*ch, TokenChar)) {
                ch++;
            }

            //
            // if we're at the end of the command line, we're done
            // else, trim off token and go on
            //
            if (*ch == NUL) {
                //
                // we hit the end
                //
                Token[tx] = NULL;
                return;
            } else {
                *ch = NUL;
                ch++;
            }
        } // else
    } // while
}

BOOLEAN
ExecuteSingleCommand(
    CHAR16      *Token[]
    )
/*
    Returns TRUE to tell program to exit, else FALSE

*/
{
    UINTN   i;

    for (i = 0; CmdTable[i].Name != NULL; i++) {
        if (StrCmp(CmdTable[i].Name, Token[0]) == 0) {
            return CmdTable[i].Function(Token);
        }
    }

    //
    // If we're here, we didn't understand the command
    //
    Print(L"%s\n%s\n", MSG_BAD_CMD, MSG_GET_HELP);
    return FALSE;
}

BOOLEAN
CmdAbout(
    CHAR16  **Token
    )
{
    Print(MSG_ABOUT02,
        EFI_FIRMWARE_MAJOR_REVISION,
        EFI_FIRMWARE_MINOR_REVISION,
        EFI_FIRMWARE_MAJOR_REVISION,
        EFI_FIRMWARE_MINOR_REVISION
    );
    return FALSE;
}

BOOLEAN
CmdList(
    CHAR16  **Token
    )
/*
    CmdList - print the list of Partionable Disks

    Globals:    DiskHandleList, DiskHandleCount
    Cmd Args:   None.
*/
{
    INTN            i;
    EFI_BLOCK_IO    *BlkIo;
    CHAR16          c;

    Print(MSG_LIST01);
    Print(MSG_LIST01B);
    for (i = 0; i < DiskHandleCount; i++) {
        status = BS->HandleProtocol(DiskHandleList[i], &BlockIoProtocol, &BlkIo);

        if (i == SelectedDisk) {
            c = '*';
        } else {
            c = ' ';
        }

        if (EFI_ERROR(status)) {
            Print(MSG_LIST03, i);
        } else {
            Print(
                MSG_LIST02,
                c,
                i,
                BlkIo->Media->BlockSize,
                BlkIo->Media->LastBlock+1
                );
        }
    }
    return FALSE;
}

BOOLEAN
CmdSelect(
    CHAR16  **Token
    )
/*
    CmdSelect - Select the disk that most commands operate on.

    Globals:    SelectedDisk, DiskHandleCount
    Options:    None.
    Cmd Args:   none for display, number to select
*/
{
    INTN     NewSelect;

    if (Token[1] == NULL) {
        if (SelectedDisk == -1) {
            Print(MSG_SELECT01);
        } else {
            Print(MSG_SELECT02, SelectedDisk);
        }
    } else {
        NewSelect = Atoi(Token[1]);
        if ((NewSelect >= 0) &&
            (NewSelect < DiskHandleCount) &&
            (IsIn(*Token[1], L"0123456789")) )
        {
            SelectedDisk = NewSelect;
            Print(MSG_SELECT02, SelectedDisk);
        } else {
            Print(MSG_SELECT03);
        }
    }
    return FALSE;
}

BOOLEAN
CmdInspect(
    CHAR16  **Token
    )
/*
    CmdInspect - report data on the currently selected disk

    Globals:    SelectedDisk, DiskHandleList
    Cmd Args:   [RAW] [VER]
*/
{
    EFI_HANDLE  DiskHandle;
    UINTN       DiskType = 0;
    PGPT_HEADER Header = NULL;
    PGPT_TABLE  Table = NULL;
    PLBA_BLOCK  LbaBlock = NULL;
    BOOLEAN     Raw;
    BOOLEAN     Verbose;
    UINTN       i;

    if (SelectedDisk == -1) {
        Print(MSG_INSPECT01);
        return FALSE;
    }

    Print(MSG_SELECT02, SelectedDisk);
    DiskHandle = DiskHandleList[SelectedDisk];

    status = ReadGPT(DiskHandle, &Header, &Table, &LbaBlock, &DiskType);

    if (EFI_ERROR(status)) {
        return FALSE;
    }


    if (DiskType == DISK_RAW) {
        Print(MSG_INSPECT04);
        goto Exit;

    } else if (DiskType == DISK_MBR) {
        CmdInspectMBR(Token);
        goto Exit;

    } else if (DiskType == DISK_GPT_BAD) {
        Print(MSG_INSPECT06);
        goto Exit;

    } else if ( (DiskType != DISK_GPT_UPD) &&
                (DiskType != DISK_GPT))
    {
        TerribleError(L"Bad Disk Type returnted to Inspect!");
        goto Exit;
    }

    if (DiskType == DISK_GPT_UPD) {
        Print(MSG_INSPECT03);
    }

    if ( (Token[1]) &&
         (StrCmp(Token[1], STR_HELP) == 0) )
    {
        PrintHelp(InspectHelpText);
        goto Exit;
    }

    Raw = FALSE;
    Verbose = FALSE;
    for (i = 1; Token[i]; i++) {
        if (StrCmp(Token[i], STR_RAW) == 0) {
            Raw = TRUE;
        } else if (StrCmp(Token[i], STR_VER) == 0) {
            Verbose = TRUE;
        } else {
            PrintHelp(InspectHelpText);
            goto Exit;
        }
    }
    DumpGPT(DiskHandle, Header, Table, Raw, Verbose);

Exit:
    DoFree(Header);
    DoFree(Table);
    DoFree(LbaBlock);
    return FALSE;
}


typedef struct {
    UINTN   Slot;
    EFI_LBA StartingLBA;
} SORT_SLOT_ENTRY;

VOID
DumpGPT(
    EFI_HANDLE  DiskHandle,
    PGPT_HEADER Header,
    PGPT_TABLE  Table,
    BOOLEAN     Raw,
    BOOLEAN     Verbose
    )
/*
    DumpGPT - print out the GPT passed in via Header and Table

    if (Raw) print slot order, all slots, table order.
        else print only allocated slots, StartingLBA order.
    if (Verbose) print out the Header data.
*/
{
    EFI_BLOCK_IO    *BlkIo;
    UINTN           i;
    UINTN           AllocatedSlots;
    CHAR16          Buffer[PART_NAME_LEN+1];
    BOOLEAN         changed;
    SORT_SLOT_ENTRY *SortSlot;
    GPT_ENTRY       Entry;
    UINTN           tslot;
    EFI_LBA         tlba;

    SortSlot = DoAllocate(Header->EntriesAllocated * sizeof(SORT_SLOT_ENTRY));
    if (SortSlot == NULL) {
        status = EFI_OUT_OF_RESOURCES;
        Print(MSG_INSPECT02);
        return;
    }

    //
    // Dump the handle data just as List would
    //
    BS->HandleProtocol(DiskHandle, &BlockIoProtocol, &BlkIo);
    Print(MSG_LIST01);
    Print(MSG_LIST01B);
    Print(MSG_LIST02, '*', SelectedDisk, BlkIo->Media->BlockSize, BlkIo->Media->LastBlock+1);

    if (Verbose) {
        //
        // Dump the header
        //
        Print(L"\nHeader Structure\n");
        Print(L"         Signature= %16lx     Revision=%8X\n",
            Header->Signature, Header->Revision);
        Print(L"        HeaderSize=%8x           HeaderCRC32=%8x\n",
            Header->HeaderSize, Header->HeaderCRC32);
        Print(L"             MyLBA=%16lx  AlternateLBA=%16lx\n",
            Header->MyLBA, Header->AlternateLBA);
        Print(L"    FirstUsableLBA=%16lx LastUsableLBA=%16lx\n",
            Header->FirstUsableLBA, Header->LastUsableLBA);
        Print(L"          TableLBA=%16lx\n", Header->TableLBA);
        Print(L"    EntrySize=%8x  EntriesAllowed=%8x  TableCRC=%8x\n\n",
            Header->SizeOfGPT_ENTRY, Header->EntriesAllocated, Header->TableCRC32);
    }

    //
    // Print the Table of GPT entries
    //
    if (!Raw) {
        //
        // !Raw == Cooked -> Print the Allocated entries in StartingLBA
        // SORTED order...
        //
        // Find ALL of the allocated entries
        //
        AllocatedSlots = 0;
        for (i = 0; i < Header->EntriesAllocated; i++) {
            CopyMem(&Entry, &Table->Entry[i], sizeof(GPT_ENTRY));
            if (CompareMem(&(Entry.PartitionType), &GuidNull, sizeof(EFI_GUID)) != 0) {
                SortSlot[AllocatedSlots].Slot = i;
                SortSlot[AllocatedSlots].StartingLBA = Entry.StartingLBA;
                AllocatedSlots++;
            }
        }
        // j has the count of allocated entries

        //
        // Sort them - yes this is a bubble sort, but the list is probably
        // in order and probably small, so for the vastly typical case
        // this is actually optimal
        //
        if (AllocatedSlots > 0) {
            do {
                changed = FALSE;
                for (i = 0; i < AllocatedSlots-1; i++) {
                    if (SortSlot[i].StartingLBA > SortSlot[i+1].StartingLBA) {
                        tslot = SortSlot[i+1].Slot;
                        tlba = SortSlot[i+1].StartingLBA;
                        changed = TRUE;
                        SortSlot[i+1].Slot = SortSlot[i].Slot;
                        SortSlot[i+1].StartingLBA = SortSlot[i].StartingLBA;
                        SortSlot[i].Slot = tslot;
                        SortSlot[i].StartingLBA = tlba;
                    }
                }
            } while (changed);

            //
            // Print them, but print the SLOT number, not the row number.
            // This is to make Delete be reliable.
            //
            for (i = 0; i < AllocatedSlots; i++) {
                PrintGptEntry(&Table->Entry[SortSlot[i].Slot], SortSlot[i].Slot);
                if (((i+1) % 4) == 0) {
                    Input(MSG_MORE, Buffer, PART_NAME_LEN);
                }
            }
        }

    } else {
        //
        // Raw -> Print ALL of the entries in Table order
        // (mostly for test, debug, looking at cratered disks
        //
        Print(L"RAW RAW RAW\n");
        for (i = 0; i < Header->EntriesAllocated; i++) {
            PrintGptEntry(&Table->Entry[i], i);
            if (((i+1) % 4) == 0) {
                Input(MSG_MORE, Buffer, PART_NAME_LEN);
            }
        }
        Print(L"RAW RAW RAW\n");
    }

    DoFree(SortSlot);
    return;
}


VOID
PrintGptEntry(
    GPT_ENTRY   *Entry,
    UINTN       Index
    )
{
    CHAR16  Buffer[PART_NAME_LEN+1];
    UINTN   j;

    Print(L"\n%3d: ", Index);
    ZeroMem(Buffer, (PART_NAME_LEN+1)*sizeof(CHAR16));
    CopyMem(Buffer, &(Entry->PartitionName), PART_NAME_LEN*sizeof(CHAR16));
    Print(L"%s\n     ", Buffer);
    PrintGuidString(&(Entry->PartitionType));

    for (j = 0; SymbolList[j].SymName; j++) {
        if (CompareMem(&(Entry->PartitionType), SymbolList[j].Value, sizeof(EFI_GUID)) == 0) {
            Print(L" = %s", SymbolList[j].SymName);
        }
     }
     if (CompareMem(&(Entry->PartitionType), &GuidNull, sizeof(EFI_GUID)) == 0) {
        Print(L" = UNALLOCATED SLOT");
    }
    Print(L"\n     ");
    PrintGuidString(&(Entry->PartitionID));
    Print(L" @%16x\n", Entry->Attributes);
    Print(L"      %16lx - %16lx\n",
        Entry->StartingLBA,
        Entry->EndingLBA
        );
}


BOOLEAN
CmdClean(
    CHAR16  **Token
    )
/*
    CmdClean - Clean off the disk

    Globals:    SelectedDisk, DiskHandleList
    Cmd Args:   ALL to clean whole disk, rather than just 1st and last megabyte

    We write out 1 block at a time.  While this is slow, it avoids wondering
    about the Block protocol write size limit, and about how big a buffer
    we can allocate.
*/
{
    EFI_HANDLE  DiskHandle;
    CHAR16  Answer[COMMAND_LINE_MAX];
    BOOLEAN CleanAll;
    UINT32  BlockSize;
    UINT64  DiskSize;
    UINT64  DiskBytes;
    UINT64  RangeBlocks;
    UINT64  EndRange;
    UINT64  i;
    CHAR8   *zbuf;

    if (SelectedDisk == -1) {
        Print(MSG_INSPECT01);
        return FALSE;
    }

    DiskHandle = DiskHandleList[SelectedDisk];
    BlockSize = GetBlockSize(DiskHandle);
    DiskSize = GetDiskSize(DiskHandle);
    DiskBytes = MultU64x32(DiskSize, BlockSize);

    zbuf = DoAllocate(CLEAN_RANGE);
    if (zbuf == NULL) return FALSE;
    ZeroMem(zbuf, CLEAN_RANGE);

    //
    // Are you sure?
    //
    Print(MSG_CLEAN01, SelectedDisk);
    Input(STR_CLEAN_PROMPT, Answer, COMMAND_LINE_MAX);
    StrUpr(Answer);
    Print(L"\n");
    if (StrCmp(Answer, L"Y") != 0) {
        DoFree(zbuf);
        return FALSE;
    }

    //
    // Are you REALLY Sure?
    //
    Print(MSG_CLEAN02);
    Input(STR_CLEAN_PROMPT, Answer, COMMAND_LINE_MAX);
    Print(L"\n");
    if (StrCmp(Answer, STR_CLEAN_ANS) != 0) {
        DoFree(zbuf);
        return FALSE;
    }

    //
    // OK, the user really wants to do this
    //

    //
    // All? or just start and end?
    //
    CleanAll = FALSE;
    if (Token[1]) {
        if (StrCmp(Token[1], STR_CLEAN03) == 0) {
            CleanAll = TRUE;
        }
    }

    if (DiskBytes > (2 * CLEAN_RANGE)) {
        RangeBlocks = CLEAN_RANGE / BlockSize;
        WriteBlock(DiskHandle, zbuf, 0, CLEAN_RANGE);
        EndRange = DiskSize - RangeBlocks;
        if (CleanAll) {
            for (i=RangeBlocks; i < DiskSize; i += RangeBlocks) {
                WriteBlock(DiskHandle, zbuf, i, CLEAN_RANGE);
            }
        }
        WriteBlock(DiskHandle, zbuf, EndRange, CLEAN_RANGE);
    } else {
        //
        // Kind of a small disk, clean it all always
        //
        for (i = 0; i < DiskSize; i++) {
            WriteBlock(DiskHandle, zbuf, i, BlockSize);
        }
    }
    FlushBlock(DiskHandle);

    DoFree(zbuf);
    return FALSE;
}

BOOLEAN
CmdNew(
    CHAR16  **Token
    )
/*
    CmdNew [mbr | [gpt=numentry]

    Changes a RAW disk into either an MBR (well, somebody) or GPT disk

    "new mbr" - you want an mbr disk (not implemented)
    "new gpt" - you want a gpt disk, you get a default table
    "new gpt=xyz" - you want a gpt disk, with at least xyz entries
                    (you will get less than xyz if exceeds sanity threshold)

    anything else - try again with right syntax
*/
{
    EFI_HANDLE  DiskHandle;
    PGPT_HEADER Header;
    PGPT_TABLE  Table;
    PLBA_BLOCK  LbaBlock;
    UINTN       DiskType;
    UINTN       GptOptSize;

    if (SelectedDisk == -1) {
        Print(MSG_INSPECT01);
        return FALSE;
    }

    DiskHandle = DiskHandleList[SelectedDisk];

    status = ReadGPT(DiskHandle, &Header, &Table, &LbaBlock, &DiskType);

    if (EFI_ERROR(status)) {
        return FALSE;
    }

    if (DiskType != DISK_RAW) {
        Print(MSG_NEW01, SelectedDisk);
        Print(MSG_NEW02);
        return FALSE;
    }

    //
    // OK, it's a raw disk...
    //
    GptOptSize = 0;

    if (Token[1]) {
        if (StrCmp(Token[1], STR_GPT) == 0) {
            if (Token[2]) {
                GptOptSize = Atoi(Token[2]);
            }
            CreateGPT(DiskHandle, GptOptSize);
        } else if (StrCmp(Token[1], STR_MBR) == 0) {
            CmdNewMBR(Token);
        }
    } else {
        Print(MSG_NEW03);
    }
    return FALSE;
}

BOOLEAN
CmdFix(
    CHAR16  **Token
    )
/*
    CmdFix - very basic tool to try to fix up GPT disks.

    Basic strategy is to read the GPT, if it seems to be a
    GPT disk (not MBR, RAW, or totally dead) then call
    WriteGPT, which will write both GPTs (and thus sync them)
    and rebuild the shadow MBR, all as a matter of course.

*/
{
    EFI_HANDLE  DiskHandle;
    PGPT_HEADER Header = NULL;
    PGPT_TABLE  Table = NULL;
    PLBA_BLOCK  LbaBlock = NULL;
    UINTN       DiskType;

    //
    // Setup parameters and error handling
    //
    if (SelectedDisk == -1) {
        Print(MSG_INSPECT01);
        return FALSE;
    }

    if ( (Token[1]) &&
         (StrCmp(Token[1], STR_HELP) == 0) )
    {
        PrintHelp(FixHelpText);
        return FALSE;
    }

    DiskHandle = DiskHandleList[SelectedDisk];

    status = ReadGPT(DiskHandle, &Header, &Table, &LbaBlock, &DiskType);

    if (EFI_ERROR(status)) {
        Print(MSG_FIX05);
        return FALSE;
    }

    //
    // From this point on, must exit this Procedure with a goto Exit
    // to free up allocated stuff, otherwise we leak pool...
    //
    if (DiskType == DISK_RAW) {
        Print(MSG_FIX01);
        goto Exit;
    }

    if (DiskType == DISK_MBR) {
        Print(MSG_FIX02);
        goto Exit;
    }

    if ((DiskType != DISK_GPT) &&
        (DiskType != DISK_GPT_UPD)) {
        if (DebugLevel >= DEBUG_ERRPRINT) {
            Print(L"DiskType = %d\n", DiskType);
        }
        Print(MSG_FIX03);
        goto Exit;
    }

    status = WriteGPT(DiskHandle, Header, Table, LbaBlock);

    if (EFI_ERROR(status)) {
        Print(MSG_FIX04);
    }

Exit:
    DoFree(Header);
    DoFree(Table);
    DoFree(LbaBlock);
    return FALSE;
}


//
// ----- Create and sub procs thereof
//

BOOLEAN
CmdCreate(
    CHAR16  **Token
    )
/*
    CmdCreate - Create a new partition

    (Actually, this routine is a GPT only partition creator)

        create name="name string" size=sss type=name typeguid=<guid> attributes=hex
            name is label string
            offset is in megabytes, or start at the end of the last partition if absent
            size is in megabytes, or "fill the disk" if 0 or absent or > free space
            type is any named symbol type (symbols gives list)
            typeguid is an arbitrary type guid
            attributes is hex 32bit flag
            if "help" is first arg, print better help data

            name, type or typeguid, required

        if all that parses out OK, read the gpt, edit it, write it back,
        and voila, we have a new partition.
*/
{
    EFI_HANDLE  DiskHandle;
    PGPT_HEADER Header = NULL;
    PGPT_TABLE  Table = NULL;
    PLBA_BLOCK  LbaBlock = NULL;
    UINTN       DiskType;
    UINT64      SizeInMegaBytes = 0;
    UINT64      OffsetInBlocks = 0;
    UINT64      StartBlock;
    UINT64      EndBlock;
    UINT64      SizeInBytes = 0;
    UINT64      Attributes = 0;
    UINTN       i;
    UINTN       j;
    EFI_GUID    *TypeGuid = NULL;
    EFI_GUID    GuidBody;
    EFI_GUID    PartitionIdGuid;
    CHAR16      *TypeName = NULL;
    CHAR16      PartName[PART_NAME_LEN+1];           // 36 allowed by spec plus NUL we need
    CHAR16      Buffer[10];
    BOOLEAN     Verbose = FALSE;
    UINT32      BlockSize;
    UINT64      DiskSizeBlocks;
    UINT8       *p;
    BOOLEAN     OffsetSpecified = FALSE;
    BOOLEAN     AllZeros;
    INTN        AllZeroEntry;
    INTN        OldFreeEntry;
    UINT64      AvailBlocks;
    UINT64      BlocksToAllocate;
    UINT64      HighSeen;
    UINTN       Slot;


    //
    // Setup parameters and error handling
    //
    if (SelectedDisk == -1) {
        Print(MSG_INSPECT01);
        return FALSE;
    }

    if (Token[1] == NULL) {
        PrintHelp(CreateHelpText);
        return FALSE;
    }

    if ( (Token[1]) &&
         (StrCmp(Token[1], STR_HELP) == 0) )
    {
        PrintHelp(CreateHelpText);
        return FALSE;
    }

    DiskHandle = DiskHandleList[SelectedDisk];

    status = ReadGPT(DiskHandle, &Header, &Table, &LbaBlock, &DiskType);

    if (EFI_ERROR(status)) {
        return FALSE;
    }

    BlockSize = GetBlockSize(DiskHandle);
    DiskSizeBlocks = GetDiskSize(DiskHandle);

    //
    // From this point on, must exit this Procedure with a goto Exit
    // to free up allocated stuff, otherwise we leak pool...
    //
    if (DiskType == DISK_RAW) {
        Print(MSG_CREATE01, SelectedDisk);
        goto Exit;
    }

    if (DiskType == DISK_MBR) {
        CmdCreateMBR(Token);
        goto Exit;
    }

    if (DiskType != DISK_GPT) {
        if (DebugLevel >= DEBUG_ERRPRINT) {
            Print(L"DiskType = %d\n", DiskType);
        }
        Print(MSG_CREATE02);
        goto Exit;
    }

    //
    // Parse arguments...
    //
    for (i = 1; Token[i]; i++) {
        if (StrCmp(Token[i], STR_NAME) == 0) {
            ZeroMem(PartName, (PART_NAME_LEN+1)*sizeof(CHAR16));
            StrCpy(PartName, Token[i+1]);
            i++;
        } else if (StrCmp(Token[i], STR_TYPE) == 0) {
            if (Token[i+1] == NULL) {
                PrintHelp(CreateHelpText);
                goto Exit;
            }
            for (j = 0; SymbolList[j].SymName != NULL; j++) {
                if (StrCmp(SymbolList[j].SymName, Token[i+1]) == 0) {
                    TypeGuid = SymbolList[j].Value;
                    TypeName = SymbolList[j].SymName;
                    break;
                }
            }
            if (TypeGuid == NULL) {
                Print(MSG_CREATE03);
                goto Exit;
            }
            i++;
        } else if (StrCmp(Token[i], STR_TYPEGUID) == 0) {
            if (Token[i+1] == NULL) {
                PrintHelp(CreateHelpText);
                goto Exit;
            }
            status = GetGuidFromString(Token[i+1], &GuidBody);
            if (EFI_ERROR(status)) {
                PrintHelp(CreateHelpText);
                goto Exit;
            }
            TypeGuid = &GuidBody;
            i++;
        } else if (StrCmp(Token[i], STR_OFFSET) == 0) {
            if (Token[i+1] == NULL) {
                PrintHelp(CreateHelpText);
                goto Exit;
            }
            OffsetInBlocks = Xtoi64(Token[i+1]);
            OffsetSpecified = TRUE;
            i++;
        } else if (StrCmp(Token[i], STR_SIZE) == 0) {
            if (Token[i+1] == NULL) {
                PrintHelp(CreateHelpText);
                goto Exit;
            }
            SizeInMegaBytes = Atoi64(Token[i+1]);
            i++;
        } else if (StrCmp(Token[i], STR_ATTR) == 0) {
            if (Token[i+1] == NULL) {
                PrintHelp(CreateHelpText);
                goto Exit;
            }
            Attributes = Xtoi64(Token[i+1]);
            i++;
        } else if (StrCmp(Token[i], STR_VER) == 0) {
            Verbose = TRUE;
            // do NOT increment i, we only consumed 1 Token
        } else {
            Print(L"\n??? % ???\n", Token[i]);
            PrintHelp(CreateHelpText);
            goto Exit;
        }
    }

    if ( (PartName == NULL) ||
         (TypeGuid == NULL) )
    {
        PrintHelp(CreateHelpText);
        goto Exit;
    }

    if ( (DebugLevel >= DEBUG_ARGPRINT) ||
         (Verbose) )
    {
        Print(L"CmdCreate arguments:\n");
        Print(L"SelectedDisk = %d\n", SelectedDisk);
        Print(L"Name=%s\n", PartName);
        Print(L"TypeGuid = ");
        PrintGuidString(TypeGuid);
        Print(L"\n");
        if (TypeName) {
            Print(L"TypeName = %s\n", TypeName);
        }
        Print(L"Requested OffsetInBlocks = %lx\n", OffsetInBlocks);
        Print(L"Requested SizeInMegaBytes = %ld\n", SizeInMegaBytes);
        Print(L"Attributes = %lx\n", Attributes);
    }
    if (DebugLevel >= DEBUG_OPPROMPT) {
        Input(L"\nCreate = Enter to Continue\n", Buffer, 10);
    }

    //
    // If Requested size is 0, or greater than size remaining,
    // we want to fill the disk.
    // Otherwise, use enough blocks to provide at *least* the
    // required storage.  (Not likely to be a problem...)
    //

    //
    // First, scan the Table and decide where the first unallocated
    // space is.  Note that for this procedure's primitive space allocation,
    // holes between the beginning of the first allocated partition and
    // the last allocated partition are ignored.
    //

    AllZeroEntry = -1;
    OldFreeEntry  = -1;
    HighSeen = Header->FirstUsableLBA - 1;

    if (OffsetSpecified) {
        //
        // if offset is specified, compute the start and end blocks
        //
        StartBlock = OffsetInBlocks;
        if (StartBlock < Header->FirstUsableLBA ||
            StartBlock > Header->LastUsableLBA) {
            //
            // Offset specified is too large
            //
            status = EFI_INVALID_PARAMETER;
            Print(MSG_CREATE08);
            goto Exit;
        }

        SizeInBytes = MultU64x32(SizeInMegaBytes, (1024*1024));
        if (SizeInBytes < SizeInMegaBytes || SizeInBytes == 0) {
            //
            // If size is not specified or too large,
            // try to make the partition as big as it can be
            //
            BlocksToAllocate = EndBlock = SizeInBytes = 0xffffffffffffffff;
        } else {
            BlocksToAllocate = DivU64x32(SizeInBytes, BlockSize, NULL);
            EndBlock = StartBlock + BlocksToAllocate - 1;
            if (EndBlock > Header->LastUsableLBA) {
                EndBlock = Header->LastUsableLBA;
                BlocksToAllocate = EndBlock - StartBlock + 1;
            }
        }
    }

    for (i = 0; i < Header->EntriesAllocated; i++) {
        if (CompareMem(
                &(Table->Entry[i].PartitionType),
                &GuidNull,
                sizeof(EFI_GUID)
                ) != 0)
        {
            //
            // Type not null, so it's allocated
            //
            if (Table->Entry[i].EndingLBA > HighSeen) {
                HighSeen = Table->Entry[i].EndingLBA;
            }
            if (OffsetSpecified) {
                //
                // make sure new partition does not overlap with existing partitions
                //
                if (Table->Entry[i].StartingLBA <= StartBlock &&
                    StartBlock <= Table->Entry[i].EndingLBA) {
                    //
                    // starting block is inside an existing partition
                    //
                    status = EFI_INVALID_PARAMETER;
                    Print(MSG_CREATE08);
                    goto Exit;
                }
                if ((Table->Entry[i].StartingLBA <= EndBlock &&
                     EndBlock <= Table->Entry[i].EndingLBA) ||
                    (StartBlock <= Table->Entry[i].StartingLBA &&
                     Table->Entry[i].StartingLBA <= EndBlock) ||
                    (StartBlock <= Table->Entry[i].EndingLBA &&
                     Table->Entry[i].EndingLBA <= EndBlock)) {
                    //
                    // new partition overlaps with an existing partition
                    // readjust new partition size to avoid overlapping
                    //
                    EndBlock = Table->Entry[i].StartingLBA-1;
                    if (EndBlock < StartBlock) {
                        status = EFI_INVALID_PARAMETER;
                        Print(MSG_CREATE08);
                        goto Exit;
                    } else {
                        BlocksToAllocate = EndBlock - StartBlock + 1;
                    }
                }
            }
        } else {
            p = (UINT8 *)(&(Table->Entry[i]));
            AllZeros = TRUE;
            for (j = 0; j < sizeof(GPT_ENTRY); j++) {
                if (p[j] != 0) {
                    AllZeros = FALSE;
                }
            }
            if (AllZeros) {
                if (AllZeroEntry == -1) {
                    AllZeroEntry = i;
                }
            } else if (OldFreeEntry == -1) {
                OldFreeEntry = i;
            }
        }
    }

    //
    // AllZeroEntry - if not -1, is pointer to a never before used entry (free)
    // OldFreeEntry - if not -1, is pointer to some pre-used free entry
    //
    if ( (AllZeroEntry == -1) && (OldFreeEntry == -1) ) {
        //
        // TABLE IS FULL!!
        //
        status = EFI_OUT_OF_RESOURCES;
        Print(MSG_CREATE04);
        goto Exit;
    }

    if (OffsetSpecified) {
        //
        // the user haven't specified the new partition size and we haven't
        // run into any partition that will limit the size of this new partition.
        // So, use the max it can
        //
        if (BlocksToAllocate == -1) {
            EndBlock = Header->LastUsableLBA;
            BlocksToAllocate = EndBlock - StartBlock + 1;
        }
    } else {
        //
        // [HighSeen+1 ... LastUsableLBA] is available...
        // avail = (LastUsableLBA - (HighSeen+1)) + 1 => LastUsabbleLBA - HighSeen
        //
        AvailBlocks = Header->LastUsableLBA - HighSeen;

        if (AvailBlocks == 0) {
            status = EFI_OUT_OF_RESOURCES;
            Print(MSG_CREATE07);
            goto Exit;
        }

        SizeInBytes = MultU64x32(SizeInMegaBytes, (1024*1024));
        if (SizeInBytes < SizeInMegaBytes) {
            //
            // overflow, force a very big answer
            //
            SizeInBytes = 0xffffffffffffffff;
        }

        if  ((SizeInBytes == 0) ||
             (SizeInBytes > (MultU64x32(AvailBlocks, BlockSize)) ) )
        {
            //
            // User asked for zero, or for more than we've got,
            // so give them all that is left
            //
            BlocksToAllocate = AvailBlocks;

        } else {

            //
            // We would have to have a BlockSize > 1mb for Remainder to
            // not be 0.  Since we cannot actually test this case, we
            // ingore it...
            //
            BlocksToAllocate = DivU64x32(SizeInBytes, BlockSize, NULL);

        }
    }

    //
    // We have a name
    // We have a type guid
    // We have a size in blocks
    // We have an attribute mask
    //

    if (BlocksToAllocate < ((1024*1024)/BlockSize)) {
        status = EFI_OUT_OF_RESOURCES;
        Print(MSG_CREATE09);
        goto Exit;
    }

    if ( (Verbose) ||
         (DebugLevel > DEBUG_ARGPRINT) )
    {
        Print(L"Requested SizeInMegaBytes = %ld\n", SizeInMegaBytes);
        Print(L"Resulting size in Blocks = %ld\n", BlocksToAllocate);
        Print(L"Results size in Bytes = %ld\n", MultU64x32(BlocksToAllocate, BlockSize));
    }

    if (AllZeroEntry != -1) {
        Slot = AllZeroEntry;
    } else {
        Slot = OldFreeEntry;
    }

    PartitionIdGuid = GetGUID();
    CopyMem(&(Table->Entry[Slot].PartitionType), TypeGuid, sizeof(EFI_GUID));
    CopyMem(&(Table->Entry[Slot].PartitionID), &PartitionIdGuid, sizeof(EFI_GUID));
    if (OffsetSpecified) {
        Table->Entry[Slot].StartingLBA = StartBlock;
        Table->Entry[Slot].EndingLBA = EndBlock;
    } else {
        Table->Entry[Slot].StartingLBA = HighSeen + 1;
        Table->Entry[Slot].EndingLBA = HighSeen + BlocksToAllocate;
    }

    if (! ( ((Table->Entry[Slot].EndingLBA - Table->Entry[Slot].StartingLBA) + 1) == BlocksToAllocate) ) {
        TerribleError(L"Wrong Size for new partiton in CmdCreate\n");
    }

    if ( (Table->Entry[Slot].StartingLBA < Header->FirstUsableLBA) ||
         (Table->Entry[Slot].EndingLBA > Header->LastUsableLBA) )
    {
        TerribleError(L"New Partition out of bounds in CmdCreate\n");
    }

    Table->Entry[Slot].Attributes = Attributes;
    CopyMem(&(Table->Entry[Slot].PartitionName[0]), PartName, PART_NAME_LEN*sizeof(CHAR16));

    status = WriteGPT(DiskHandle, Header, Table, LbaBlock);

    if (EFI_ERROR(status)) {
        Print(MSG_CREATE05);
    }

Exit:
    DoFree(Header);
    DoFree(Table);
    DoFree(LbaBlock);
    return FALSE;
}



//
// -----
//


BOOLEAN
CmdDelete(
    CHAR16  **Token
    )
/*
    CmdDelete - deletes a partition from the currently selected disk
*/
{
    EFI_HANDLE  DiskHandle;
    UINTN       DiskType = 0;
    PGPT_HEADER Header = NULL;
    PGPT_TABLE  Table = NULL;
    PLBA_BLOCK  LbaBlock = NULL;
    INTN        Victim;
    CHAR16      Answer[COMMAND_LINE_MAX];
    GPT_ENTRY   Entry;

    if (SelectedDisk == -1) {
        Print(MSG_INSPECT01);
        return FALSE;
    }

    if (Token[1] == NULL) {
        PrintHelp(DeleteHelpText);
        return FALSE;
    }

    if ( (Token[1]) &&
         (StrCmp(Token[1], STR_HELP) == 0) )
    {
        PrintHelp(DeleteHelpText);
        return FALSE;
    }

    Print(MSG_SELECT02, SelectedDisk);
    DiskHandle = DiskHandleList[SelectedDisk];

    status = ReadGPT(DiskHandle, &Header, &Table, &LbaBlock, &DiskType);
    if (EFI_ERROR(status)) {
        return FALSE;
    }


    if (DiskType == DISK_RAW) {
        Print(MSG_DELETE02);
        goto Exit;
    } else if (DiskType == DISK_MBR) {
        CmdInspectMBR(Token);
        goto Exit;
    } else if (DiskType == DISK_GPT_UPD) {
        Print(MSG_DELETE03);
        goto Exit;
    } else if (DiskType == DISK_GPT_BAD) {
        Print(MSG_DELETE04);
        goto Exit;
    } else if (DiskType != DISK_GPT) {
        TerribleError(L"Bad Disk Type returned to Delete!");
        goto Exit;
    }

    //
    // OK, it's a Good GPT disk, so do the Delete thing for GPT...
    //
    if ( (Token[1] == NULL) ||
         (Token[2] != NULL) )
    {
        PrintHelp(InspectHelpText);
        goto Exit;
    }

    Victim = Atoi(Token[1]);

    if ( (Victim < 0) ||
         ((UINT32)Victim > Header->EntriesAllocated) )
    {
        Print(MSG_DELETE05);
        goto Exit;
    }

    CopyMem(&Entry, &Table->Entry[Victim], sizeof(GPT_ENTRY));

    if (CompareMem(&(Entry.PartitionType), &GuidNull, sizeof(EFI_GUID)) == 0) {
        Print(MSG_DELETE06);
        goto Exit;
    }

    //
    // What you are going to delete, are you sure, are you really sure...
    //
    Print(MSG_DELETE07, Victim);
    PrintGptEntry(&Entry, Victim);
    Print(L"\n\n");
    Print(MSG_DELETE09);
    Print(MSG_DELETE10);
    Input(STR_DELETE_PROMPT, Answer, COMMAND_LINE_MAX);
    Print(L"\n");
    StrUpr(Answer);
    if (StrCmp(Answer, L"Y") != 0) {
        goto Exit;
    }
    Print(MSG_DELETE11);
    Input(STR_DELETE_PROMPT, Answer, COMMAND_LINE_MAX);
    Print(L"\n");
    StrUpr(Answer);
    if (StrCmp(Answer, STR_DELETE_ANS) != 0) {
        goto Exit;
    }

    //
    // If we get here, then...
    //      Victim is the number of legal GPT slot
    //      Victim refers to a slot which is allocated
    //      The user has seen confirmation of which slot that is
    //      The user says they realy truly want to delete it
    //
    CopyMem(&(Table->Entry[Victim].PartitionType), &GuidNull, sizeof(EFI_GUID));
    status = WriteGPT(DiskHandle, Header, Table, LbaBlock);

    if (EFI_ERROR(status)) {
        Print(MSG_DELETE08);
    }

Exit:
    DoFree(Header);
    DoFree(Table);
    DoFree(LbaBlock);
    return FALSE;
}


BOOLEAN
CmdHelp(
    CHAR16  **Token
    )
{
    UINTN   i;

    for (i = 0; CmdTable[i].Name != NULL; i++) {
        Print(L"%s %s\n", CmdTable[i].Name, CmdTable[i].HelpSummary);
    }
    return FALSE;
}


BOOLEAN
CmdExit(
    CHAR16  **Token
    )
{
    Print(L"%s\n", MSG_EXITING);
    return TRUE;
}


BOOLEAN
CmdSymbols(
    CHAR16  **Token
    )
/*
    CmdSymbols - print out the GUID symbols compiled into the program

    For predefined symbol (see ...) we print it's friendly name,
    it's text definition, and it's actual value.
*/
{
    UINTN       i;
    EFI_GUID    *Guid;
    BOOLEAN     Verbose = FALSE;

    if ( (Token[1]) &&
         (StrCmp(Token[1], STR_VER) ==  0) )
    {
        Verbose = TRUE;
    }

    for (i = 0; SymbolList[i].SymName != NULL; i++) {
        Guid = SymbolList[i].Value;
        Print(L"%s = %s\n", SymbolList[i].SymName, SymbolList[i].Comment);
        if (Verbose) {
            PrintGuidString(Guid);
            Print(L"\n\n");
        }
    }
    return FALSE;
}


BOOLEAN
CmdRemark(
    CHAR16  **Token
    )
{
    //
    // The remark command does nothing...
    return FALSE;
}


BOOLEAN
CmdMake(
    CHAR16  **Token
    )
{
    UINTN   i;

    Token++;

    if (Token[0] != NULL) {
        for (i = 0; ScriptTable[i].Name != NULL; i++) {
            if (StrCmp(ScriptTable[i].Name, Token[0]) == 0) {
                return ScriptTable[i].Function(Token);
            }
        }
    }
    //
    // Nothing we know about, so run list
    //
    return ScriptList(Token);
}


BOOLEAN
CmdDebug(
    CHAR16  **Token
    )
/*
    Debug -
        Without args, shows last status value, and AllocCount
        If an arg, it sets the debug/checkout support level
            0 = do nothing extra
            1 = print full computed arguments before starting an operation
            2 = print full computed arguments and hold for prompt before
                    doing a major operation.
*/
{
    if (Token[1]) {
        DebugLevel = Atoi(Token[1]);
    }
    Print(L"status = %x %r\n", status, status);
    Print(L"AllocCount = %d\n", AllocCount);
    Print(L"DebugLevel = %d\n", DebugLevel);
    return FALSE;
}


//
// ----- SubUnits to do MBR operations -----
//
VOID
CmdInspectMBR(
    CHAR16  **Token
    )
/*
    CmdInspectMBR - dumps the partition data for an MBR disk
*/
{
    Print(MSG_INSPECT05);
    return;
}

VOID
CmdCreateMBR(
    CHAR16  **Token
    )
/*
    CmdCreateMBR - creates an MBR parititon
*/
{
    Print(MSG_CREATE06);
    return;
}


VOID
CmdNewMBR(
    CHAR16  **Token
    )
/*
    CmdCreateMBR - creates an MBR parititon
*/
{
    Print(MSG_NEW04);
    return;
}


VOID
CmdDeleteMBR(
    CHAR16  **Token
    )
/*
    CmdDeleteMBR - deletes an MBR parititon
*/
{
    Print(MSG_DELETE01);
    return;
}


//
// ----- Various Support Routines -----
//


VOID
PrintGuidString(
    EFI_GUID    *Guid
    )
{
    CHAR16  Buffer[40];

    SPrint(Buffer, 40, L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
        Guid->Data1,
        Guid->Data2,
        Guid->Data3,
        Guid->Data4[0],
        Guid->Data4[1],
        Guid->Data4[2],
        Guid->Data4[3],
        Guid->Data4[4],
        Guid->Data4[5],
        Guid->Data4[6],
        Guid->Data4[7]
        );
    Print(L"%s", Buffer);
    return;
}


EFI_STATUS
GetGuidFromString(
    CHAR16      *String,
    EFI_GUID    *Guid
    )
/*
    GetGuidFromString

    This routine scans the string looking for 32 hex digits.  Each
    such digits is shifted into the Guid.  Non hex digits are skipped.
    This means the guid MUST begin with the first digit, not with a filler
    0 or 0x or the like.  However, because non hex digits are skipped,
    any set of dashes, dots, etc. may be used as punctuation.

    So:
        01234567-abcd-ef01-12-34-56-78-9a-bc-de-f0
    &
        01.23.45.67-ab.cd.ef.01-12.34.56.78-9a.bc.de.f0

    Will create the same Guid value.
*/
{
    EFI_GUID    TempGuid;
    INTN    x;
    UINTN   i;
    UINTN   j;

    //
    // scan until we have the right number of hex digits for each part
    // of the guid structure, skipping over non hex digits
    //
    ZeroMem((CHAR16 *)&TempGuid, sizeof(EFI_GUID));

    //
    // 1st uint32
    //
    for (i = 0; i < 8; String++) {
        if (*String == NUL) {
            status = EFI_INVALID_PARAMETER;
            return status;
        }
        x = HexChar(*String);
        if (x != -1) {
            TempGuid.Data1 = (UINT32)((TempGuid.Data1 * 16) + x);
            i++;
        }
    }

    //
    // 2nd unit - uint16
    //
    for (i = 0; i < 4; String++) {
        if (*String == NUL) {
            status = EFI_INVALID_PARAMETER;
            return status;
        }
        x = HexChar(*String);
        if (x != -1) {
            TempGuid.Data2 = (TempGuid.Data2 * 16) + (UINT16)x;
            i++;
        }
    }

    //
    // 3nd unit - uint16
    //
    for (i = 0; i < 4; String++) {
        if (*String == NUL) {
            status = EFI_INVALID_PARAMETER;
            return status;
        }
        x = HexChar(*String);
        if (x != -1) {
            TempGuid.Data3 = (TempGuid.Data3 * 16) + (UINT16)x;
            i++;
        }
    }

    //
    // 4th unit - 8 uint8s
    //
    for (j = 0; j < 8; j++) {
        for (i = 0; i < 2; String++) {
            if (*String == NUL) {
                status = EFI_INVALID_PARAMETER;
                return status;
            }
            x = HexChar(*String);
            if (x != -1) {
                TempGuid.Data4[j] = (TempGuid.Data4[j] * 16) + (UINT8)x;
                i++;
            }
        }
    }

    CopyMem(Guid, &TempGuid, sizeof(EFI_GUID));
    return status = EFI_SUCCESS;
}


INTN
HexChar(
    CHAR16  Ch
    )
/*
    HexChar just finds the offset of Ch in the string "0123456789ABCDEF",
    which in effect converts a hex digit to a number.
    (a one char at a time xtoi)
    If Ch isn't a hex digit, -1 is returned.
*/
{
    UINTN   i;
    CHAR16  *String = L"0123456789ABCDEF";

    for (i = 0; String[i] != NUL; i++) {
        if (Ch == String[i]) {
            return i;
        }
    }
    return -1;
}


UINT64
Xtoi64(
    CHAR16  *String
    )
/*
    Xtoi64 is NOT fully xtoi compatible, it requires that the hex
    number start at the first character and stops at first non hex char
    Always returns a 64bit value
*/
{
    UINT64  BigHex;
    INT32   x;

    BigHex = 0;
    x = (INT32)HexChar(*String);
    while (x != -1) {
        BigHex = MultU64x32(BigHex, 16) + x;
        String++;
        x = (INT32)HexChar(*String);
    }
    return BigHex;
}


UINT64
Atoi64(
    CHAR16  *String
    )
/*
    Atoi64 is NOT fully atoi compatible, it requires that the number
    start at the first character and stops at first non number char
    Always returns a 64bit value
*/
{
    UINT64  BigNum;
    INT32   x;

    BigNum = 0;
    x = (INT32)HexChar(*String);
    while ( (x >= 0) && (x <= 9) ) {
        BigNum = MultU64x32(BigNum, 10);
        BigNum = BigNum + x;
        String++;
        x = (INT32)HexChar(*String);
    }
    return BigNum;
}


BOOLEAN
IsIn(
    CHAR16  What,
    CHAR16  *InWhat
    )
/*
    IsIn - return TRUE if What is found in InWhat, else FALSE;
*/
{
    UINTN   i;

    for (i = 0; InWhat[i] != NUL; i++) {
        if (InWhat[i] == What) {
            return TRUE;
        }
    }
    return FALSE;
}


VOID
PrintHelp(
    CHAR16  *HelpText[]
    )
{
    UINTN   i;

    for (i = 0; HelpText[i] != NULL; i++) {
        Print(HelpText[i]);
    }
    return;
}


VOID
TerribleError(
    CHAR16  *String
    )
{
    CHAR16  *Buffer;

    Buffer = AllocatePool(512);

    SPrint(Buffer, 512, L"Terrible Error = %s status=%x %r\nProgram terminated.\n", String, status, status);
    Print(Buffer);
    BS->Exit(SavedImageHandle, EFI_VOLUME_CORRUPTED, StrLen(Buffer), Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\doutil.c ===
/*

    DoUtil.c

    Contains "wrappers" for various work routines, which do TWO things:

    A.  Make the semantics friendly the calling program.
    B.  Make it easy to move from Win2k to some emulator to a real EFI box.

*/

#include "diskpart.h"


INTN    AllocCount = 0;

UINT32
GetBlockSize(
    EFI_HANDLE  Handle
    )
/*
    Return the size, in bytes, of a block.  Handle is presumed to
    point to a device supporting Block IO protocol.

    return's 0 if some error.
*/
{
    EFI_BLOCK_IO    *BlkIo;

    status = BS->HandleProtocol(Handle, &BlockIoProtocol, &BlkIo);
    if (EFI_ERROR(status)) {
        return 0;
    }
    return (BlkIo->Media->BlockSize);
}

UINT64
GetDiskSize(
    EFI_HANDLE  Handle
    )
/*
    Return the size, in blocks, of a spindle.  Note that if we return X,
    this means there are blocks with LBAs = 0...(X-1)

    return 0 if some error
*/
{
    EFI_BLOCK_IO    *BlkIo;

    status = BS->HandleProtocol(Handle, &BlockIoProtocol, &BlkIo);
    if (EFI_ERROR(status)) {
        return 0;
    }
    return (BlkIo->Media->LastBlock+1);
}


VOID
DoFree(
    VOID    *Buffer
    )
/*
    If and only if Buffer != NULL, free it.
    If Buffer == NULL, do nothing and return
*/
{
    if (Buffer) {
        FreePool(Buffer);
        AllocCount--;
    }
    return;
}

VOID *
DoAllocate(
    UINTN   Size
    )
/*
    Just allocate at least Size bytes from some heap,
    return pointer.  return NULL if failure
*/
{
    VOID    *v;

    v = AllocatePool(Size);
    if (v) {
        AllocCount++;
    }
    return v;
}


//
// One source quotes this table as being from Dr Dobbs 1992.
// Others say other things
//

UINT32 CRCHelpTable[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
    };

UINT32
GetCRC32(
    UINT8   *Buffer,
    UINT32  Length
    )
/*
    Compute a CRC for the Buffer data for Length bytes.
    Remember to zero out any CRC fields included in the Buffer
    and to restore them afterwards.
*/
{
    UINT32      Crc,i;
    Crc = 0xffffffffL;

    for (i = 0; i < Length; i++) {
        Crc = CRCHelpTable [(Crc ^ Buffer [ i ]) & 0xff] ^ (Crc >> 8);
    }

    return (Crc ^ 0xffffffffL);
}

EFI_GUID
GetGUID()
/*
    Return a GUID.
*/
{
    EFI_GUID    Guid;
    CHAR16      Buffer[10];
   
    if (DebugLevel >= DEBUG_OPPROMPT) {
        Input(L"\nCreate = Enter to Continue\n", Buffer, 10);
    }

    InitGuid();
    CreateGuid(&Guid);

    if (DebugLevel >= DEBUG_OPPROMPT) {
        Input(L"\nCreate = Enter to Continue\n", Buffer, 10);
    }

    return (Guid);

//    return NullGuid;        // WORK WORK!!!
}

EFI_STATUS
WriteBlock(
    EFI_HANDLE  DiskHandle,
    VOID        *Buffer,
    UINT64      BlockAddress,
    UINT32      Size
    )
/*
    WriteBlock - wrapper routine

    Write Size bytes from Buffer to DiskHandle at Block BlockAddress
*/
{
    EFI_BLOCK_IO   *BlkIo  = NULL;
    EFI_DISK_IO    *DiskIo = NULL;

    BS->HandleProtocol(DiskHandle, &BlockIoProtocol, &BlkIo);
    BS->HandleProtocol(DiskHandle, &DiskIoProtocol,  &DiskIo);

    status = DiskIo->WriteDisk(
                DiskIo,
                BlkIo->Media->MediaId,
                MultU64x32 (BlockAddress, BlkIo->Media->BlockSize),
                Size,
                Buffer
                );

    return status;
}

EFI_STATUS
ReadBlock(
    EFI_HANDLE  DiskHandle,
    VOID        *Buffer,
    UINT64      BlockAddress,
    UINT32      Size
    )
/*
    ReadBlock - wrapper routine.

    Caller is presumed to know the BlockSize and number of blocks
    on the device.

    Read Size bytes from BlockAddress of DiskHandle into buffer.
    Buffer had better be big enough.
*/
{
    EFI_DISK_IO     *DiskIo = NULL;
    EFI_BLOCK_IO    *BlkIo = NULL;

    BS->HandleProtocol(DiskHandle, &BlockIoProtocol, &BlkIo);
    BS->HandleProtocol(DiskHandle, &DiskIoProtocol,  &DiskIo);

    status = DiskIo->ReadDisk(
                DiskIo,
                BlkIo->Media->MediaId,
                MultU64x32 (BlockAddress, BlkIo->Media->BlockSize),
                Size,
                Buffer
                );

    return status;
}

EFI_STATUS
FlushBlock(
    EFI_HANDLE  DiskHandle
    )
/*
    FlushBlock - force anything we've written to make it onto the platter
*/
{
    EFI_BLOCK_IO    *BlkIo = NULL;

    BS->HandleProtocol(DiskHandle, &BlockIoProtocol, &BlkIo);
    return BlkIo->FlushBlocks(BlkIo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\guidgen.c ===
/*++

Copyright (c) 2000  Intel Corporation

Module Name:

    guidgen.c
    
Abstract:

    Add the GUID generator logic for the EFI 1.0 Disk Utilities.

Revision History

    ** Intel 2000 Update for EFI 1.0
    ** Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
    ** Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
    ** Digital Equipment Corporation, Maynard, Mass.
    ** To anyone who acknowledges that this file is provided AS IS
    ** without any express or implied warranty: permission to use, copy,
    ** modify, and distribute this file for any purpose is hereby
    ** granted without fee, provided that the above copyright notices and
    ** this notice appears in all source code copies, and that none of
    ** the names of Open Software Foundation, Inc., Hewlett-Packard
    ** Company, or Digital Equipment Corporation be used in advertising
    ** or publicity pertaining to distribution of the software without
    ** specific, written prior permission. Neither Open Software
    ** Foundation, Inc., Hewlett-Packard Company, nor Digital Equipment
    ** Corporation makes any representations about the suitability of
    ** this software for any purpose.
*/

#include "efi.h"
#include "efilib.h"
#include "md5.h"

//#define NONVOLATILE_CLOCK

extern  EFI_HANDLE  SavedImageHandle;
extern  EFI_HANDLE  *DiskHandleList;
extern  INTN        DiskHandleCount;

#define CLOCK_SEQ_LAST 0x3FFF
#define RAND_MASK CLOCK_SEQ_LAST

typedef struct _uuid_t {
    UINT32 time_low;
    UINT16 time_mid;
    UINT16 time_hi_and_version;
    UINT8 clock_seq_hi_and_reserved;
    UINT8 clock_seq_low;
    UINT8 node[6];
} uuid_t;

typedef struct {
    UINT32 lo;
    UINT32 hi;
} unsigned64_t;


/*
** Add two unsigned 64-bit long integers.
*/
#define ADD_64b_2_64b(A, B, sum) \
    { \
        if (!(((A)->lo & 0x80000000UL) ^ ((B)->lo & 0x80000000UL))) { \
            if (((A)->lo&0x80000000UL)) { \
                (sum)->lo = (A)->lo + (B)->lo; \
                (sum)->hi = (A)->hi + (B)->hi + 1; \
            } \
        else { \
                (sum)->lo = (A)->lo + (B)->lo; \
                (sum)->hi = (A)->hi + (B)->hi; \
        } \
    } \
    else { \
        (sum)->lo = (A)->lo + (B)->lo; \
        (sum)->hi = (A)->hi + (B)->hi; \
        if (!((sum)->lo&0x80000000UL)) (sum)->hi++; \
    } \
}

/*
** Add a 16-bit unsigned integer to a 64-bit unsigned integer.
*/
#define ADD_16b_2_64b(A, B, sum) \
    { \
        (sum)->hi = (B)->hi; \
        if ((B)->lo & 0x80000000UL) { \
            (sum)->lo = (*A) + (B)->lo; \
            if (!((sum)->lo & 0x80000000UL)) (sum)->hi++; \
        } \
        else \
            (sum)->lo = (*A) + (B)->lo; \
    }

/*
** Global variables.
*/
static unsigned64_t time_last;
static UINT16 clock_seq;

VOID
GetIeeeNodeIdentifier(
    UINT8 MacAddress[]
    ) 
// Use the Device Path for the NIC to provide a MAC address
{
    UINTN                       NoHandles, Index;
    EFI_HANDLE                  *Handles;
    EFI_HANDLE                  Handle;
    EFI_DEVICE_PATH             *DevPathNode, *DevicePath;
    MAC_ADDR_DEVICE_PATH        *SourceMacAddress; 
    UINT8                       *Anchor;
    EFI_MEMORY_DESCRIPTOR       *Desc, *MemMap;
    UINTN                       DescriptorSize;
    UINT32                      DescriptorVersion;
    UINTN                       NoDesc, MapKey;
    UINT8                       *pDataBuf;
    UINT32                      cData;
    EFI_TIME                    Time;    
    EFI_STATUS                  Status;

    Status = EFI_SUCCESS;

    //
    // Find all Device Paths
    //

    LibLocateHandle (ByProtocol, &DevicePathProtocol, NULL, &NoHandles, &Handles);

    for (Index=0; Index < NoHandles; Index++) {
        Handle = Handles[Index];   
        DevicePath = DevicePathFromHandle (Handle);

        //
        // Process each device path node
        //    
        DevPathNode = DevicePath;
        while (!IsDevicePathEnd(DevPathNode)) {
            //
            // Find the handler to dump this device path node
            //
            if (DevicePathType(DevPathNode) == MESSAGING_DEVICE_PATH &&
                DevicePathSubType(DevPathNode) == MSG_MAC_ADDR_DP) {
                SourceMacAddress = (MAC_ADDR_DEVICE_PATH *) DevPathNode;
                if (SourceMacAddress->IfType == 0x01 || SourceMacAddress->IfType == 0x00) {               
                    CopyMem(&MacAddress[0], &SourceMacAddress->MacAddress, sizeof(UINT8) * 6);
                    return;
                }
            }
            DevPathNode = NextDevicePathNode(DevPathNode);          
        }
    }

    //
    // Arriving here means that there is not an SNP-compliant
    // device in the system.  Use the MD5 1-way hash function to 
    // generate the node address
    //
    MemMap = LibMemoryMap (&NoDesc, &MapKey, &DescriptorSize, &DescriptorVersion);

    if (!MemMap) {
        Print (L"Memory map was not returned\n");
    } else {
        pDataBuf = AllocatePool (NoDesc * DescriptorSize + 
                    DiskHandleCount * sizeof(EFI_HANDLE) + sizeof(EFI_TIME));
        ASSERT (pDataBuf != NULL);
        Anchor = pDataBuf;
        Desc = MemMap;
        cData = 0;
        if (NoDesc != 0) {
            while (NoDesc --) {
                CopyMem(pDataBuf, Desc, DescriptorSize);
                Desc ++;
                pDataBuf += DescriptorSize;
                cData += (UINT32)DescriptorSize;
            }
        }
        //
        // Also copy in the handles of the Disks
        //
        if (DiskHandleCount != 0) {
            Index = DiskHandleCount;
            while (Index --) {
                CopyMem(pDataBuf, &DiskHandleList [Index], sizeof (EFI_HANDLE));
                pDataBuf += sizeof(EFI_HANDLE);
                cData    += sizeof(EFI_HANDLE);
            }
        }
        Status = RT->GetTime(&Time,NULL);
        if (!EFI_ERROR(Status)) {
            CopyMem(pDataBuf, &Time, sizeof(EFI_TIME));
            pDataBuf += sizeof(EFI_TIME);
            cData += sizeof (EFI_TIME);
        }

        GenNodeID(Anchor, cData, &MacAddress[0]);

        FreePool(Anchor);
        FreePool(MemMap);
        return;
    }
    // Just case fall through
    ZeroMem(MacAddress, 6 * sizeof (UINT8));
    return;
}


static VOID
mult32(UINT32 u, UINT32 v, unsigned64_t *result)
{
    /* Following the notation in Knuth, Vol. 2. */
    UINT32 uuid1, uuid2, v1, v2, temp;
    uuid1 = u >> 16;
    uuid2 = u & 0xFFFF;
    v1 = v >> 16;
    v2 = v & 0xFFFF;
    temp = uuid2 * v2;
    result->lo = temp & 0xFFFF;
    temp = uuid1 * v2 + (temp >> 16);
    result->hi = temp >> 16;
    temp = uuid2 * v1 + (temp & 0xFFFF);
    result->lo += (temp & 0xFFFF) << 16;
    result->hi += uuid1 * v1 + (temp >> 16);
}

static VOID
GetSystemTime(unsigned64_t *uuid_time)
{
//    struct timeval tp;
    EFI_TIME              Time;
    EFI_STATUS            Status;
    unsigned64_t utc, usecs, os_basetime_diff;
    EFI_TIME_CAPABILITIES TimeCapabilities;
    UINTN                 DeadCount;
    UINT8                 Second;

    DeadCount = 0;

//    gettimeofday(&tp, (struct timezone *)0);
    Status = RT->GetTime(&Time,&TimeCapabilities);

    Second = Time.Second;

    //
    // If the time resolution is 1Hz, then spin until a
    // second transition.  This will at least make the 
    // "0 nanoseconds" value appear correct inasmuch as 
    // multiple reads within 1 second are prohibited and
    // the exit on roll-over really implies that the 
    // nanoseconds field "would have" rolled to zero in 
    // a more robust time keeper.
    // 
    //
    if (TimeCapabilities.Resolution == 1) {
        while (Time.Second == Second) {
            Second = Time.Second;
            Status = RT->GetTime(&Time, NULL);
            if (DeadCount++ == 0x1000000) {
                break;
            }
        }
    }

    mult32(Time.Second,     10000000,  &utc);
    mult32(Time.Nanosecond, 10,        &usecs);
    ADD_64b_2_64b(&usecs, &utc, &utc);

    /* Offset between UUID formatted times and Unix formatted times.
    * UUID UTC base time is October 15, 1582.
    * Unix base time is January 1, 1970. */

    os_basetime_diff.lo = 0x13814000;
    os_basetime_diff.hi = 0x01B21DD2;
    ADD_64b_2_64b(&utc, &os_basetime_diff, uuid_time);
}
        
UINT32
getpid() {
  UINT64  FakePidValue;

  BS->GetNextMonotonicCount(&FakePidValue);
  //FakePidValue = 0; //(UINT32) ((UINT32)FakePidValue + (UINT32) SavedImageHandle);
  FakePidValue = (UINT32) ((UINT32)FakePidValue + (UINT32) (UINT64) SavedImageHandle);
  return ((UINT32)FakePidValue);
}

/*
** See The Multiple Prime Random Number Generator by Alexander
** Hass pp. 368-381, ACM Transactions on Mathematical Software,
** 12/87.
*/
static UINT32 rand_m;
static UINT32 rand_ia;
static UINT32 rand_ib;
static UINT32 rand_irand;

static VOID
TrueRandomInit(VOID)
{
    unsigned64_t t;
    EFI_TIME    Time;
    EFI_STATUS  Status;

    UINT16 seed;
    /* Generating our 'seed' value Start with the current time, but,
    * since the resolution of clocks is system hardware dependent
    and
    * most likely coarser than our resolution (10 usec) we 'mixup'
    the
    * bits by xor'ing all the bits together. This will have the
    effect
    * of involving all of the bits in the determination of the seed
    * value while remaining system independent. Then for good
    measure
    * to ensure a unique seed when there are multiple processes
    * creating UUIDs on a system, we add in the PID.
    */
    rand_m = 971;
    rand_ia = 11113;
    rand_ib = 104322;
    rand_irand = 4181;
//    GetSystemTime(&t);
    Status = RT->GetTime(&Time,NULL);

    t.lo = Time.Nanosecond;
    t.hi = (Time.Hour << 16) | Time.Second;

    seed = (UINT16) (t.lo & 0xFFFF);
    seed ^= (t.lo >> 16) & 0xFFFF;
    seed ^= t.hi & 0xFFFF;
    seed ^= (t.hi >> 16) & 0xFFFF;
    rand_irand += seed + getpid();      
}

static UINT16
true_random(VOID)
{
    if ((rand_m += 7) >= 9973)
        rand_m -= 9871;
    if ((rand_ia += 1907) >= 99991)
        rand_ia -= 89989;
    if ((rand_ib += 73939) >= 224729)
        rand_ib -= 96233;
    rand_irand = (rand_irand * rand_m) + rand_ia + rand_ib;
        return (UINT16) ((rand_irand >> 16) ^ (rand_irand & RAND_MASK));
}

/*
** Startup initialization routine for the UUID module.
*/
VOID
InitGuid(VOID)
{
    TrueRandomInit();
    GetSystemTime(&time_last);
    #ifdef NONVOLATILE_CLOCK
    clock_seq = read_clock();
    #else
    clock_seq = true_random();
    #endif
}

static INTN
time_cmp(unsigned64_t *time1, unsigned64_t *time2)
{
    if (time1->hi < time2->hi) return -1;
    if (time1->hi > time2->hi) return 1;
    if (time1->lo < time2->lo) return -1;
    if (time1->lo > time2->lo) return 1;
    return 0;
}

static VOID new_clock_seq(VOID)
{
    clock_seq = (clock_seq + 1) % (CLOCK_SEQ_LAST + 1);
    if (clock_seq == 0) clock_seq = 1;
    #ifdef NONVOLATILE_CLOCK
    write_clock(clock_seq);
    #endif
}

VOID CreateGuid(uuid_t *guid)
{
    static unsigned64_t time_now;
    static UINT16 time_adjust;
    UINT8 eaddr[6];
    INTN got_no_time = 0;

    GetIeeeNodeIdentifier(&eaddr[0]); /* TO BE PROVIDED by EFI device path */

    do {
        GetSystemTime(&time_now);
        switch (time_cmp(&time_now, &time_last)) {
            case -1:
                /* Time went backwards. */
                new_clock_seq();
                time_adjust = 0;
            break;
            case 1:
                time_adjust = 0;
            break;
            default:
                if (time_adjust == 0x7FFF)
                /* We're going too fast for our clock; spin. */
                    got_no_time = 1;
                else
                    time_adjust++;
            break;
        }
    } while (got_no_time);

    time_last.lo = time_now.lo;
    time_last.hi = time_now.hi;
    if (time_adjust != 0) {
        ADD_16b_2_64b(&time_adjust, &time_now, &time_now);
    }
    /* Construct a guid with the information we've gathered
    * plus a few constants. */
    guid->time_low = time_now.lo;
    guid->time_mid = (UINT16) (time_now.hi & 0x0000FFFF);
    guid->time_hi_and_version = (UINT16)  (time_now.hi & 0x0FFF0000) >> 16;
    guid->time_hi_and_version |= (1 << 12);
    guid->clock_seq_low = clock_seq & 0xFF;
    guid->clock_seq_hi_and_reserved = (clock_seq & 0x3F00) >> 8;
    guid->clock_seq_hi_and_reserved |= 0x80;
    CopyMem (guid->node, &eaddr, sizeof guid->node);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\makescript.c ===
/*

Module Name:

    MakeScript - The "MAKE" command's built in scrips for DiskPart

Abstract:

Revision History

*/

#include "DiskPart.h"
#include "scripthelpmsg.h"


BOOLEAN ScriptMicrosoft(CHAR16 **Token);
BOOLEAN ScriptTest(CHAR16 **Token);

UINT64  ComputeDefaultEspSize(EFI_HANDLE  DiskHandle);

//
// The parse/command table
//
SCRIPT_ENTRY   ScriptTable[] = {
                { SCRIPT_LIST,  ScriptList, MSG_SCR_LIST },
                { SCRIPT_MSFT,  ScriptMicrosoft, MSG_SCR_MSFT },
                { SCRIPT_TEST,  ScriptTest, MSG_SCR_TEST  },
                { NULL, NULL, NULL }
            };

BOOLEAN
ScriptList(
    CHAR16  **Token
    )
{
    UINTN   i;

    for (i = 0; ScriptTable[i].Name != NULL; i++) {
        Print(L"%s %s\n", ScriptTable[i].Name, ScriptTable[i].HelpSummary);
    }
    return FALSE;
}


BOOLEAN
ScriptMicrosoft(
    CHAR16  **Token
    )
/*
    ScriptMicrosoft - a compiled make script, invoked via MSFT

    make msft [boot] [size=s1] [name=n1] [ressize=s2] [espsize=s3] [espname=n2]
        espsize -> boot
        espname -> boot

    See help text for syntax

    SPECIAL NOTES:
        This routine just assumes there is enough space for a
        correct MS Reserved and EFI System partitions.  This will
        always be true with a clean disk of any likely size.
        We don't test for clean though...
        (And adding MSRES and ESP partitions to a non-clean disk is a little weird.)
*/
{
    UINTN   i;
    BOOLEAN CreateEsp = FALSE;
    UINT64  EspSize = 0;
    UINT64  ResSize = 0;
    UINT64  DataSize = 0;
    UINT64  DefaultEsp;
    CHAR16  *EspName = NULL;
    CHAR16  *DataName = NULL;
    EFI_HANDLE  DiskHandle;
    CHAR16  *WorkToken[TOKEN_COUNT_MAX];
    CHAR16  CommandLine[COMMAND_LINE_MAX];


    //
    // require selected disk, copy from CmdInspect
    //
    if (SelectedDisk == -1) {
        Print(MSG_INSPECT01);
        return FALSE;
    }
    Print(MSG_SELECT02, SelectedDisk);
    DiskHandle = DiskHandleList[SelectedDisk];

    //
    // parse
    //
    if ( (Token[1] == NULL) ||
         (StrCmp(Token[1], STR_HELP) == 0) )
    {
        PrintHelp(ScriptMicrosoftHelp);
        return FALSE;
    }

    for (i = 1; Token[i]; i++) {
        if (StrCmp(Token[i], STR_BOOT) == 0) {
            CreateEsp = TRUE;

        } else if (StrCmp(Token[i], STR_ESPSIZE) == 0) {
            if (Token[i+1] == NULL) goto ParseError;
            EspSize = Atoi64(Token[i+1]);
            CreateEsp = TRUE;
            i++;

        } else if (StrCmp(Token[i], STR_ESPNAME) == 0) {
            if (Token[i+1] == NULL) goto ParseError;
            EspName = Token[i+1];
            CreateEsp = TRUE;
            i++;

        } else if (StrCmp(Token[i], STR_RESSIZE) == 0) {
            if (Token[i+1] == NULL) goto ParseError;
            ResSize = Atoi64(Token[i+1]);
            i++;

        } else if (StrCmp(Token[i], STR_NAME) == 0) {
            if (Token[i+1] == NULL) goto ParseError;
            DataName = Token[i+1];
            i++;

        } else if (StrCmp(Token[i], STR_SIZE) == 0) {
            if (Token[i+1] == NULL) goto ParseError;
            DataSize = Atoi64(Token[i+1]);
            i++;

        } else {
            goto ParseError;
        }
    }


    //
    // Adjust EspSize (if relevent) ResSize, DataSize
    //
    if (ResSize < DEFAULT_RES_SIZE) {
        ResSize = DEFAULT_RES_SIZE;
    }

    DefaultEsp = ComputeDefaultEspSize(DiskHandle);
    if (EspSize < DefaultEsp) {
        EspSize = DefaultEsp;
    }

    //
    // Adjust names...
    //
    if (EspName == NULL) {
        EspName = STR_ESP_DEFAULT;
    }

    if (DataName == NULL) {
        DataName = STR_DATA_DEFAULT;
    }

    //
    // Start the create sequence.  We build up a Token list
    // and then give it to CmdCreate to parse and execute normally...
    //

    //
    // The reserved partition
    //
    SPrint(
        CommandLine,
        COMMAND_LINE_MAX,
        L"%s %s=\"%s\" %s=%s %s=%ld",
        STR_CREATE,
        STR_NAME,
        STR_MSRES_NAME,
        STR_TYPE,
        STR_MSRES,
        STR_SIZE,
        ResSize
        );
    if (DebugLevel >= DEBUG_ARGPRINT) {
        Print(L"%s\n", CommandLine);
    }
    Tokenize(CommandLine, WorkToken);
    CmdCreate(WorkToken);

    //
    // The ESP
    //
    if (CreateEsp) {
        SPrint(
            CommandLine,
            COMMAND_LINE_MAX,
            L"%s %s=\"%s\" %s=%s %s=%ld",
            STR_CREATE,
            STR_NAME,
            EspName,
            STR_TYPE,
            STR_ESP,
            STR_SIZE,
            EspSize
            );
        if (DebugLevel >= DEBUG_ARGPRINT) {
            Print(L"%s\n", CommandLine);
        }
        Tokenize(CommandLine, WorkToken);
        CmdCreate(WorkToken);
    }

    //
    // MSDATA
    //
    SPrint(
        CommandLine,
        COMMAND_LINE_MAX,
        L"%s %s=\"%s\" %s=%s %s=%ld",
        STR_CREATE,
        STR_NAME,
        DataName,
        STR_TYPE,
        STR_MSDATA,
        STR_SIZE,
        DataSize
        );
    if (DebugLevel >= DEBUG_ARGPRINT) {
        Print(L"%s\n", CommandLine);
    }
    Tokenize(CommandLine, WorkToken);
    CmdCreate(WorkToken);

    return FALSE;

ParseError:
    status = EFI_INVALID_PARAMETER;
    PrintHelp(ScriptMicrosoftHelp);
    return FALSE;
}


UINT64
ComputeDefaultEspSize(
    EFI_HANDLE  DiskHandle
    )
/*
    ComputeDefaultEspSize ...

    Returns an answer in MEGABYTES
*/
{
    UINT64  DiskSize;
    UINT64  DiskSizeBytes;
    UINT32  OnePercent;

    //
    // Note, if DiskSize is so large that 1 % is more than 4G,
    // OnePercent below will overflow, but it will be OK because
    // we'll set a MAX_ESP_SIZE in the code below
    //

    DiskSize = GetDiskSize(DiskHandle);                 // In Blocks
    OnePercent = (UINT32)(DivU64x32(DiskSize, 100, NULL));    // In Blocks
    DiskSizeBytes = MultU64x32(OnePercent, GetBlockSize(DiskHandle));

    if (DiskSizeBytes < MIN_ESP_SIZE) {
        DiskSizeBytes = MIN_ESP_SIZE;
    }

    if (DiskSizeBytes > MAX_ESP_SIZE) {
        DiskSizeBytes = MAX_ESP_SIZE;
    }

    DiskSizeBytes = RShiftU64(DiskSizeBytes, 20);   // 20 bits == 1 mb
    return DiskSizeBytes;
}


CHAR16  NumStr[32];

CHAR16  *TestToken[] = {
    L"CREATE",
    L"NAME",
    NumStr,
    L"TYPE",
    L"MSDATA",
    L"SIZE",
    L"1",
    NULL
    };

BOOLEAN
ScriptTest(
    CHAR16  **Token
    )
{
    CHAR16  Buf[2];
    UINTN   i, j;

    //
    // for this to work, a disk of > 128mb will be needed
    //
    for (i = 0; i < 128; i++) {
        SPrint(NumStr, 32, L"PART#%03d", i);
        Print(L"Token for Create = \n");
        for (j = 0; TestToken[j] != NULL; j++) {
            Print(L"'%s'  ", TestToken[j]);
        }
        Print(L"\n");
        CmdCreate(TestToken);
        if (((i+1) % 4) == 0) {
            Input(L"MORE>", Buf, 2);
            Print(L"\n");
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\mbr.h ===
//
//  mbr.h - minimum stuff to allow diskpart to work on MBRs.
//

//
// MBR:
//  There are 3 kinds of MBRs.
//  1. GPT Shadow MBR - an MBR filled in with particular values
//      to keep legacy software from puking on GPT disks.
//  2. MBR base - an MBR that allows for up to 4 paritions.
//  3. Extended MBR - nested inside other MBRs to allow more than
//      4 partitions on a non-GPT disk.
//
//  This program, and therefore this header file, is only concerned
//  with case 1, and a limited subset of case 2.
//

//
// MBR contains code, with a table of 4 Partition entries and
// a signature at the end.
//

#pragma pack (1)

typedef struct _MBR_ENTRY {
    CHAR8 ActiveFlag;               // Bootable or not
    CHAR8 StartingTrack;            // Not used
    CHAR8 StartingCylinderLsb;      // Not used
    CHAR8 StartingCylinderMsb;      // Not used
    CHAR8 PartitionType;            // 12 bit FAT, 16 bit FAT etc.
    CHAR8 EndingTrack;              // Not used
    CHAR8 EndingCylinderLsb;        // Not used
    CHAR8 EndingCylinderMsb;        // Not used
    UINT32 StartingSector;          // Hidden sectors
    UINT32 PartitionLength;         // Sectors in this partition
} MBR_ENTRY;

//
// Number of partition table entries
//
#define NUM_PARTITION_TABLE_ENTRIES     4

//
// Partition table record and boot signature offsets in bytes
//

#define MBR_TABLE_OFFSET               (0x1be)
#define MBR_SIGNATURE_OFFSET           (0x200 - 2)

//
// Boot record signature value.
//

#define BOOT_RECORD_SIGNATURE          (0xaa55)

//
// Special Partition type used only on GPT disks
//

#define PARTITION_TYPE_GPT_SHADOW       (0xEE)


#pragma pack ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\diskpart.obj

EFI_LIBS=$(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib \
         $(O)\diskpart.lib \
         $(O)\diskpart.res


$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:EfiMain
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\diskpart.efi: $(OSLOADER) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\md5.h ===
/*++

Copyright (c) 2000  Intel Corporation

Module Name:

    md5.h
    
Abstract:

    Add support for IEEE Node address generation when there is 
    not a SNP-compliant NIC attached.

Revision History
*/

/*
 **********************************************************************
 ** md5.h -- Header file for implementation of MD5                   **
 ** RSA Data Security, Inc. MD5 Message Digest Algorithm             **
 ** Created: 2/17/90 RLR                                             **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version              **
 ** Revised (for MD5): RLR 4/27/91                                   **
 **   -- G modified to have y&~z instead of y&z                      **
 **   -- FF, GG, HH modified to add in last register done            **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3    **
 **   -- distinct additive constant for each step                    **
 **   -- round 4 added, working mod 7                                **
 **********************************************************************
 */

/*
 **********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved. **
 **                                                                  **
 ** License to copy and use this software is granted provided that   **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message     **
 ** Digest Algorithm" in all material mentioning or referencing this **
 ** software or this function.                                       **
 **                                                                  **
 ** License is also granted to make and use derivative works         **
 ** provided that such works are identified as "derived from the RSA **
 ** Data Security, Inc. MD5 Message Digest Algorithm" in all         **
 ** material mentioning or referencing the derived work.             **
 **                                                                  **
 ** RSA Data Security, Inc. makes no representations concerning      **
 ** either the merchantability of this software or the suitability   **
 ** of this software for any particular purpose.  It is provided "as **
 ** is" without express or implied warranty of any kind.             **
 **                                                                  **
 ** These notices must be retained in any copies of any part of this **
 ** documentation and/or software.                                   **
 **********************************************************************
 */

#ifndef _MD5_H_
#define _MD5_H_

/* Data structure for MD5 (Message Digest) computation */
typedef struct {
  UINT32 i[2];                   /* number of _bits_ handled mod 2^64 */
  UINT32 buf[4];                                    /* scratch buffer */
  unsigned char in[64];                              /* input buffer */
  unsigned char digest[16];     /* actual digest after MD5Final call */
} MD5_CTX;

void MD5Init (
  MD5_CTX *mdContext
  );

void MD5Update (
  MD5_CTX *mdContext,
  unsigned char *inBuf,
  unsigned int inLen
  );
  
void MD5Final (
  MD5_CTX *mdContext
  );

void GenNodeID(
  unsigned char *pDataBuf,
  long cData, 
  UINT8 NodeID[]
  );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\helpmsg.h ===
/*
    Help msg text slammed into variables (which is why it's not in msg.h)
    Localize
*/

CHAR16  *FixHelpText[] = {
        L"fix help - prints this screen\n",
        L"fix takes no arguments.  It attempts to read and rewrite\n",
        L"the GPT tables of a disk.  This simple procedure will\n",
        L"automatically fix some problems.\n",
        L"Fix does not work on MBR disks, or on heavily damaged GPT disks\n",
        NULL
        };

CHAR16  *CreateHelpText[] = {
        L"create [help] or \n",
        L"create name=namestr (type=typename | typeguid=guid) [offset=ooo] [size=sss]\n",
        L"       [attr=aaaa] [ver]\n",
        L"name=namestr is required, namestr may be quoted 'name=\"p01\"'\n",
        L"     one of type=typename or typeguid=guid is required\n",
        L"type=typename -> typename is one of the types listed by the symbols command\n",
        L"typeguid=guid -> guid is of form XXXYYYZZZ\n",
        L"offset=ooo is optional.  ooo is hexadecimal block offset.  if ooo is absent,\n"
        L"       parititon will start at the end of the last partition.\n",
        L"size=sss is optional.  sss is decimal megabytes.  if sss is 0\n"
        L"     or sss is greater than free space or option is absent, parititon\n",
        L"     will fill end of disk.\n",
        L"attr=aaa is optional. aaa is a HEX string of attribute flags.\n",
        L"ver optional command to turn on verbose status.\n",
        L"examples:\n",
        L"  create name=\"a partition\" type=msbasic size=0 attr=1B\n",
        L"  create name=part2 type=efisys size=400\n",
        NULL
        };


CHAR16  *InspectHelpText[] = {
        L"inspect [help] or \n"
        L"inspect [raw] [ver] \n"
        L"raw - print all partition slots, allocated or free, in table order\n",
        L"   by default only print allocated slots, sorted by address on disk\n",
        L"ver - print the the GPT hsd eader\n",
        L"examples:\n",
        L"   inspect\n",
        L"   inspect raw\n",
        L"   inspect raw ver\n",
        L"\n",
        L"For either raw or cooked output, the entry will be tagged with a\n",
        L"SLOT number, which is the number used by Delete\n",
        NULL
        };


CHAR16  *DeleteHelpText[] = {
        L"delete [help]\n",
        L"delete nnn deletes partition nnn from the currently selected disk\n"
        L"nnn is a decimal number that matches output of Inspect\n"
        L"example:\n",
        L"   delete 3\n",
        NULL
        };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\md5.c ===
/*++

Copyright (c) 2000  Intel Corporation

Module Name:

    md5.c
    
Abstract:

    Add support for IEEE Node address generation when there is 
    not a SNP-compliant NIC attached.

Revision History
*/



/*
 **********************************************************************
 ** md5.c                                                            **
 ** RSA Data Security, Inc. MD5 Message Digest Algorithm             **
 ** Created: 2/17/90 RLR                                             **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                  **
 **********************************************************************
 */

/*
 **********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved. **
 **                                                                  **
 ** License to copy and use this software is granted provided that   **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message     **
 ** Digest Algorithm" in all material mentioning or referencing this **
 ** software or this function.                                       **
 **                                                                  **
 ** License is also granted to make and use derivative works         **
 ** provided that such works are identified as "derived from the RSA **
 ** Data Security, Inc. MD5 Message Digest Algorithm" in all         **
 ** material mentioning or referencing the derived work.             **
 **                                                                  **
 ** RSA Data Security, Inc. makes no representations concerning      **
 ** either the merchantability of this software or the suitability   **
 ** of this software for any particular purpose.  It is provided "as **
 ** is" without express or implied warranty of any kind.             **
 **                                                                  **
 ** These notices must be retained in any copies of any part of this **
 ** documentation and/or software.                                   **
 **********************************************************************
 */
#include "efi.h"
#include "efilib.h"
#include "md5.h"

/* forward declaration */
static void Transform ();

static unsigned char PADDING[64] = {
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* F, G and H are basic MD5 functions: selection, majority, parity */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z))) 

/* ROTATE_LEFT rotates x left n bits */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

void MD5Init (
  MD5_CTX *mdContext
  )
{
  mdContext->i[0] = mdContext->i[1] = (UINT32)0;

  /* Load magic initialization constants.
   */
  mdContext->buf[0] = (UINT32)0x67452301;
  mdContext->buf[1] = (UINT32)0xefcdab89;
  mdContext->buf[2] = (UINT32)0x98badcfe;
  mdContext->buf[3] = (UINT32)0x10325476;
}

void MD5Update (
  MD5_CTX *mdContext,
  unsigned char *inBuf,
  unsigned int inLen
  )
{
  UINT32 in[16];
  int mdi;
  unsigned int i, ii;

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3F);

  /* update number of bits */
  if ((mdContext->i[0] + ((UINT32)inLen << 3)) < mdContext->i[0])
    mdContext->i[1]++;
  mdContext->i[0] += ((UINT32)inLen << 3);
  mdContext->i[1] += ((UINT32)inLen >> 29);

  while (inLen--) {
    /* add new character to buffer, increment mdi */
    mdContext->in[mdi++] = *inBuf++;

    /* transform if necessary */
    if (mdi == 0x40) {
      for (i = 0, ii = 0; i < 16; i++, ii += 4)
        in[i] = (((UINT32)mdContext->in[ii+3]) << 24) |
                (((UINT32)mdContext->in[ii+2]) << 16) |
                (((UINT32)mdContext->in[ii+1]) << 8) |
                ((UINT32)mdContext->in[ii]);
      Transform (mdContext->buf, in);
      mdi = 0;
    }
  }
}

void MD5Final (
  MD5_CTX *mdContext
  )
{
  UINT32 in[16];
  int mdi;
  unsigned int i, ii;
  unsigned int padLen;

  /* save number of bits */
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3F);

  /* pad out to 56 mod 64 */
  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
  MD5Update (mdContext, PADDING, padLen);

  /* append length in bits and transform */
  for (i = 0, ii = 0; i < 14; i++, ii += 4)
    in[i] = (((UINT32)mdContext->in[ii+3]) << 24) |
            (((UINT32)mdContext->in[ii+2]) << 16) |
            (((UINT32)mdContext->in[ii+1]) << 8) |
            ((UINT32)mdContext->in[ii]);
  Transform (mdContext->buf, in);

  /* store buffer in digest */
  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xFF);
    mdContext->digest[ii+1] =
      (unsigned char)((mdContext->buf[i] >> 8) & 0xFF);
    mdContext->digest[ii+2] =
      (unsigned char)((mdContext->buf[i] >> 16) & 0xFF);
    mdContext->digest[ii+3] =
      (unsigned char)((mdContext->buf[i] >> 24) & 0xFF);
  }
}

/* Basic MD5 step. Transform buf based on in.
 */
static void Transform (
    UINT32 *buf,
    UINT32 *in
    )
{
  UINT32 a = buf[0], b = buf[1], c = buf[2], d = buf[3];

  /* Round 1 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
  FF ( a, b, c, d, in[ 0], S11, 3614090360); /* 1 */
  FF ( d, a, b, c, in[ 1], S12, 3905402710); /* 2 */
  FF ( c, d, a, b, in[ 2], S13,  606105819); /* 3 */
  FF ( b, c, d, a, in[ 3], S14, 3250441966); /* 4 */
  FF ( a, b, c, d, in[ 4], S11, 4118548399); /* 5 */
  FF ( d, a, b, c, in[ 5], S12, 1200080426); /* 6 */
  FF ( c, d, a, b, in[ 6], S13, 2821735955); /* 7 */
  FF ( b, c, d, a, in[ 7], S14, 4249261313); /* 8 */
  FF ( a, b, c, d, in[ 8], S11, 1770035416); /* 9 */
  FF ( d, a, b, c, in[ 9], S12, 2336552879); /* 10 */
  FF ( c, d, a, b, in[10], S13, 4294925233); /* 11 */
  FF ( b, c, d, a, in[11], S14, 2304563134); /* 12 */
  FF ( a, b, c, d, in[12], S11, 1804603682); /* 13 */
  FF ( d, a, b, c, in[13], S12, 4254626195); /* 14 */
  FF ( c, d, a, b, in[14], S13, 2792965006); /* 15 */
  FF ( b, c, d, a, in[15], S14, 1236535329); /* 16 */

  /* Round 2 */
#define S21 5
#define S22 9
#define S23 14
#define S24 20
  GG ( a, b, c, d, in[ 1], S21, 4129170786); /* 17 */
  GG ( d, a, b, c, in[ 6], S22, 3225465664); /* 18 */
  GG ( c, d, a, b, in[11], S23,  643717713); /* 19 */
  GG ( b, c, d, a, in[ 0], S24, 3921069994); /* 20 */
  GG ( a, b, c, d, in[ 5], S21, 3593408605); /* 21 */
  GG ( d, a, b, c, in[10], S22,   38016083); /* 22 */
  GG ( c, d, a, b, in[15], S23, 3634488961); /* 23 */
  GG ( b, c, d, a, in[ 4], S24, 3889429448); /* 24 */
  GG ( a, b, c, d, in[ 9], S21,  568446438); /* 25 */
  GG ( d, a, b, c, in[14], S22, 3275163606); /* 26 */
  GG ( c, d, a, b, in[ 3], S23, 4107603335); /* 27 */
  GG ( b, c, d, a, in[ 8], S24, 1163531501); /* 28 */
  GG ( a, b, c, d, in[13], S21, 2850285829); /* 29 */
  GG ( d, a, b, c, in[ 2], S22, 4243563512); /* 30 */
  GG ( c, d, a, b, in[ 7], S23, 1735328473); /* 31 */
  GG ( b, c, d, a, in[12], S24, 2368359562); /* 32 */

  /* Round 3 */
#define S31 4
#define S32 11
#define S33 16
#define S34 23
  HH ( a, b, c, d, in[ 5], S31, 4294588738); /* 33 */
  HH ( d, a, b, c, in[ 8], S32, 2272392833); /* 34 */
  HH ( c, d, a, b, in[11], S33, 1839030562); /* 35 */
  HH ( b, c, d, a, in[14], S34, 4259657740); /* 36 */
  HH ( a, b, c, d, in[ 1], S31, 2763975236); /* 37 */
  HH ( d, a, b, c, in[ 4], S32, 1272893353); /* 38 */
  HH ( c, d, a, b, in[ 7], S33, 4139469664); /* 39 */
  HH ( b, c, d, a, in[10], S34, 3200236656); /* 40 */
  HH ( a, b, c, d, in[13], S31,  681279174); /* 41 */
  HH ( d, a, b, c, in[ 0], S32, 3936430074); /* 42 */
  HH ( c, d, a, b, in[ 3], S33, 3572445317); /* 43 */
  HH ( b, c, d, a, in[ 6], S34,   76029189); /* 44 */
  HH ( a, b, c, d, in[ 9], S31, 3654602809); /* 45 */
  HH ( d, a, b, c, in[12], S32, 3873151461); /* 46 */
  HH ( c, d, a, b, in[15], S33,  530742520); /* 47 */
  HH ( b, c, d, a, in[ 2], S34, 3299628645); /* 48 */

  /* Round 4 */
#define S41 6
#define S42 10
#define S43 15
#define S44 21
  II ( a, b, c, d, in[ 0], S41, 4096336452); /* 49 */
  II ( d, a, b, c, in[ 7], S42, 1126891415); /* 50 */
  II ( c, d, a, b, in[14], S43, 2878612391); /* 51 */
  II ( b, c, d, a, in[ 5], S44, 4237533241); /* 52 */
  II ( a, b, c, d, in[12], S41, 1700485571); /* 53 */
  II ( d, a, b, c, in[ 3], S42, 2399980690); /* 54 */
  II ( c, d, a, b, in[10], S43, 4293915773); /* 55 */
  II ( b, c, d, a, in[ 1], S44, 2240044497); /* 56 */
  II ( a, b, c, d, in[ 8], S41, 1873313359); /* 57 */
  II ( d, a, b, c, in[15], S42, 4264355552); /* 58 */
  II ( c, d, a, b, in[ 6], S43, 2734768916); /* 59 */
  II ( b, c, d, a, in[13], S44, 1309151649); /* 60 */
  II ( a, b, c, d, in[ 4], S41, 4149444226); /* 61 */
  II ( d, a, b, c, in[11], S42, 3174756917); /* 62 */
  II ( c, d, a, b, in[ 2], S43,  718787259); /* 63 */
  II ( b, c, d, a, in[ 9], S44, 3951481745); /* 64 */

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\msg.h ===
//
//  msg.h - messages, token, etc. are gathered here to make localization easier
//
//  STR_ are things that maybe don't get localized (command tokens)
//  MSG_ are output messages that probably do get localized
//

#define STR_LIST        L"LIST"
#define STR_SELECT      L"SELECT"
#define STR_INSPECT     L"INSPECT"
#define STR_CLEAN       L"CLEAN"
#define STR_CLEAN_PROMPT    L"CLEAN>> "
#define STR_NEW         L"NEW"
#define STR_FIX         L"FIX"
#define STR_CREATE      L"CREATE"
#define STR_DELETE      L"DELETE"
#define STR_DELETE_PROMPT   L"DELETE>> "
#define STR_HELP        L"HELP"
#define STR_HELP2       L"H"
#define STR_HELP3       L"?"
#define STR_EXIT        L"EXIT"
#define STR_SYMBOLS     L"SYMBOLS"
#define STR_REMARK      L"REM"
#define STR_MAKE        L"MAKE"
#define STR_DEBUG       L"DEBUG"
#define STR_VER         L"VER"
#define STR_RAW         L"RAW"
#define STR_ABOUT       L"ABOUT"

#define MSG_LIST        L"           - Show list of partitionable disks"
#define MSG_SELECT      L"<number> - Select a disk (spindle) to work on"
#define MSG_INSPECT     L"        - Dump the partition data on the selected spindle"
#define MSG_CLEAN       L"[ALL]     - Clean all data off the disk (DESTROY DATA)\n" \
                        L"                  ALL writes 0s to whole disk, without just 1st & last MB"
#define MSG_NEW         L"[MBR | GPT]"
#define MSG_FIX         L" "
#define MSG_CREATE      L" "
#define MSG_DELETE      L" "
#define MSG_HELP        L"           - print this screen.  <cmd> Help for detail on a command"
#define MSG_ABBR_HELP   L"              - print this screen.  <cmd> Help for detail on a command"
#define MSG_EXIT        L"           - Exit program"
#define MSG_SYMBOLS     L"[VER]   - Show list of predefined type GUIDs.. VER is verbose"
#define MSG_REMARK      L"            - Just print a remark"
#define MSG_MAKE        L"[LIST] [make script]\n" \
                        L"                - 'make list' lists make scripts\n" \
                        L"                  'make scripname args' runs script"
#define MSG_ABOUT       L"          - About this version...."

#define MSG_PROMPT      L"DiskPart> "
#define MSG_MORE        L"More> "

#define MSG_BAD_CMD     L"Problem: DiskPart did not understand that"
#define MSG_GET_HELP    L"Help for Help"
#define MSG_NO_DISKS    L"DiskPart cannot find any partitionable disks"

#define MSG_EXITING     L"Exiting...."

//
// Messages for CmdAbout
//
#define MSG_ABOUT01     L"Version 0.99.12.29   2000-08-01\n"
#define MSG_ABOUT02     L"Version %d.%d.%d.%d\n"


//
// Messages used by CmdList
//
#define MSG_LIST01      L"  ###  BlkSize          BlkCount\n"
#define MSG_LIST01B     L"  ---  -------  ----------------\n"
#define MSG_LIST02      L"%c %3d  %7x  %16lx\n"
#define MSG_LIST03      L" %3d  *** Handle Bad ***\n"

//
// Messages used by CmdSelect
//
#define MSG_SELECT01    L"No Disk Selected\n"
#define MSG_SELECT02    L"Selected Disk = %3d\n"
#define MSG_SELECT03    L"Illegal Selection\n"

//
// Messages used by CmdFix
//
#define MSG_FIX01       L"RAW disk, fix cannot help\n"
#define MSG_FIX02       L"MBR disk, fix cannot help\n"
#define MSG_FIX03       L"Disk is too corrupt for fix to help\n"
#define MSG_FIX04       L"Write of disk FAILED\n"
#define MSG_FIX05       L"Read of disk FAILED\n"

//
// Messages used by CmdInspect (some also used elsewhere)
//
#define MSG_INSPECT01   L"You must Select a disk first\n"
#define MSG_INSPECT02   L"Unable to allocate memory for sort\n"
#define MSG_INSPECT03   L"The Guid Partition Tables are out of sync, run FIX\n"
#define MSG_INSPECT04   L"The disk is RAW, nothing to Inspect\n"
#define MSG_INSPECT05   L"Inspect for MBR disks not implemented yet!\n"
#define MSG_INSPECT06   L"This appears to be a GPT disk, but it is corrupt!!\n"
#define MSG_INSPECT07   L" = UNALLOCATED SLOT"


//
// Messages used by CmdClean
//
#define MSG_CLEAN01     L"About to CLEAN (DESTROY) disk %d, are you SURE [y/n]?\n"
#define MSG_CLEAN02     L"If you are REALLY SURE, type '$C'\n"
#define STR_CLEAN_ANS   L"$C"
#define STR_CLEAN03     L"ALL"

//
// Messages used by CmdNew
//
#define STR_MBR         L"MBR"
#define STR_GPT         L"GPT"
#define MSG_NEW01       L"Disk %d is not in RAW state\n"
#define MSG_NEW02       L"Use CLEAN to make it clean/raw\n"
#define MSG_NEW03       L"Must specify 'mbr' or 'gpt'\n"
#define MSG_NEW04       L"New of MBR disks not yet supported!\n"

//
// Messages used by CmdCreate
//
#define MSG_CREATE01    L"Disk %d is RAW, do 'new gpt' first\n"
#define MSG_CREATE02    L"Disk is not GPT disk, use Fix/New/Clean\n"
#define MSG_CREATE03    L"Type name not found, use symbols of list\n"
#define MSG_CREATE04    L"Disk Partition table is FULL, cannot create!\n"
#define MSG_CREATE05    L"Attempt to Write out partition table failed!\n"
#define MSG_CREATE06    L"Create of MBR partition not implemented!\n"
#define MSG_CREATE07    L"Disk has no free blocks (FULL) cannot create!\n"
#define MSG_CREATE08    L"Invalid offset value specified.\n"
#define MSG_CREATE09    L"Partition is too small to be created.\n"
#define STR_NAME        L"NAME"
#define STR_TYPE        L"TYPE"
#define STR_TYPEGUID    L"TYPEGUID"
#define STR_OFFSET      L"OFFSET"
#define STR_SIZE        L"SIZE"
#define STR_ATTR        L"ATTR"

//
// Messages used by CmdDelete
//
#define MSG_DELETE01    L"Delete of MBR partitions not implemented\n"
#define MSG_DELETE02    L"RAW disk, cannot delete from it\n"
#define MSG_DELETE03    L"GPT disk needs updating, run FIX before delete\n"
#define MSG_DELETE04    L"GPT disk is corrupt, cannot use delete on it\n"
#define MSG_DELETE05    L"No partition by that number\n"
#define MSG_DELETE06    L"Not an allocated partition number\n"
#define MSG_DELETE07    L"You have choosen to Delete Partition #%d:\n"
#define MSG_DELETE08    L"Write of disk failed\n"
#define MSG_DELETE09    L"All data in this partition will become inaccessible\n"
#define MSG_DELETE10    L"Are You Sure [y/n]?\n"
#define MSG_DELETE11    L"If you are REALLY SURE, type '$D'>\n"
#define STR_DELETE_ANS  L"$D"

//
// Disk type GUID symbols
//
extern EFI_GUID         GuidNull;

#define STR_MSRES       L"MSRES"        // Microsoft Reserved
#define MSG_MSRES       L"Microsoft Reserved partition for feature support"
extern EFI_GUID         GuidMsReserved;

#define STR_ESP         L"EFISYS"       // EFI System Partition
#define MSG_ESP         L"EFI System Partition - required for boot"
extern EFI_GUID         GuidEfiSystem;

#define STR_MSDATA      L"MSDATA"       // Basic DATA partition
#define MSG_MSDATA      L"User data partition for use by Microsoft OSes"
extern EFI_GUID         GuidMsData;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\scripthelpmsg.h ===
//
//  Help text for Make Script procedures
//

CHAR16 *ScriptMicrosoftHelp[] = {
    L"make msft help  or\n"
    L"make msft [boot] [size=s1] [name=n1] [ressize=s2] [espsize=s3] [espname=n2]\n",
    L"help - prints this page",
    L"boot - creates an EFI system/boot parition (an esp)\n",
    L"       disk will NOT be bootable without this\n",
    L"size=s1 - s1 is size of data partition in megabytes - default is fill disk\n",
    L"name=n1 - n1 is name of data partition, default is 'USER DATA'\n",
    L"ressize=s2 - raises size of reserved MS partition above default, rarely used\n",
    L"espsize=s3 - set size of ESP if greater than default, rarely used\n",
    L"espname=n2 - names ESP, default is EFI SYSTEM\n",
    L"examples:\n",
    L"    make msft - creates msres, msdata to fill disk, NOT bootable\n",
    L"    make msft boot - creates msres, esp, msdata to fill, IS BOOTABLE\n",
    L"    make msft espsize=400 msres=300 espname=ALTBOOT\n",
    L"    make msft size=400 name=DATA1 espsize=200 epsname=ALTBOOT\n",
    L"make msft boot - this is normally what to do if you are not sure\n",
    NULL
    };

CHAR16 *ScriptTestMessage[] = {
    L"fill the table with 1mb partitions...\n",
    NULL
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\scriptmsg.h ===
//
//  scriptmsg.h - messages, token, etc. are gathered here to make localization easier
//
//  STR_ are things that maybe don't get localized (command tokens)
//  MSG_ are output messages that probably do get localized
//
//  NOTE:   This file is ONLY for MAKE compiled in scripts in DiskPart.
//          msg.h has symbols for DiskPart proper
//

#define SCRIPT_LIST     L"LIST"
#define SCRIPT_MSFT     L"MSFT"
#define SCRIPT_TEST     L"TEST"

#define MSG_SCR_LIST    L" - show list of compiled in scripts"

//
// ----- Microsoft Style Disk script -----
//
#define MSG_SCR_MSFT    L" - Make Microsoft style disk"
extern  CHAR16  *ScriptMicrosoftMessage[];

#define STR_BOOT    L"BOOT"
#define STR_ESPSIZE L"ESPSIZE"
#define STR_ESPNAME L"ESPNAME"
#define STR_RESSIZE L"RESSIZE"

#define STR_ESP_DEFAULT     L"EFI SYSTEM PARTITION (ESP)"
#define STR_DATA_DEFAULT    L"USER DATA"
#define STR_MSRES_NAME      L"MS RESERVED"

#define DEFAULT_RES_SIZE    (32)              // in MB!
//#define DEFAULT_RES_SIZE    (1)                 // TEST ONLY

#define MIN_ESP_SIZE    (150 * (1024 * 1024))
#define MAX_ESP_SIZE    (500 * (1024 * 1024))

//#define MIN_ESP_SIZE        (1 * (1024 * 1024)) // TEST ONLY
//#define MAX_ESP_SIZE        (2 * (1024 * 1024)) // TEST ONLY


//
// ----- Fill the disk with partitions test script -----
//
#define MSG_SCR_TEST    L" - Fill the slot table with 1mb partitions"
extern  CHAR16  *ScriptTestMessage[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efichar\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\efichar.obj

EFI_LIBS=$(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib  


$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:EfiMain
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\$(TARGETNAME).efi: $(OSLOADER) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\diskpart\symbols.h ===
//
//  Symmbols.h - predefined GUID symbols (for partition types)
//
//  Since symbols names are likely to be localized, the actual strings
//  are in msg.h.  So, to add a new partition type, you add STR_ and MSG_
//  entries for it in msg.h, add it's EFI_GUID var name and value here.
//  You then add all of these to SymbolList below.  Also add an extern
//  for each variable to msg.h.
//
//  Internal code (like Make procedures) use the globals.
//

typedef struct {
    CHAR16      *SymName;
    CHAR16      *Comment;
    EFI_GUID    *Value;
} SYMBOL_DEF;


EFI_GUID GuidNull =
{ 0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; // Null guid => unused entries

EFI_GUID GuidMsReserved =
{ 0xE3C9E316L, 0x0B5C, 0x4DB8, 0x81, 0x7D, 0xF9, 0x2D, 0xF0, 0x02, 0x15, 0xAE };  // Microsoft Reserved Space

EFI_GUID GuidEfiSystem =
{ 0xC12A7328L, 0xF81F, 0x11D2, 0xBA, 0x4B, 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B }; // Efi System Partition (esp)

EFI_GUID GuidMsData =
{ 0xEBD0A0A2L, 0xB9E5, 0x4433, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7 }; // MS Basic Data Parition



SYMBOL_DEF  SymbolList[] = {
    { STR_MSRES,    MSG_MSRES,  &GuidMsReserved },
    { STR_ESP,      MSG_ESP,    &GuidEfiSystem  },
    { STR_MSDATA,   MSG_MSDATA, &GuidMsData     },
    { NULL, NULL, NULL }
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efichk\efichk.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    efichk.cxx

Abstract:

    This is the main program for the eficheck version of chkdsk.

--*/

#pragma warning(disable: 4091)

#include "ulib.hxx"
#include "wstring.hxx"
#include "fatvol.hxx"
#include "efickmsg.hxx"
#include "error.hxx"
#include "ifssys.hxx"
#include "rtmsg.h"
#include "rcache.hxx"
#include "ifsserv.hxx"

#include "efiwintypes.hxx"

extern "C" BOOLEAN
InitializeUfat(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C" BOOLEAN
InitializeIfsUtil(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

USHORT
InvokeAutoChk (
    IN     PWSTRING         DriveLetter,
    IN     PWSTRING         VolumeName,
    IN     ULONG            ChkdskFlags,
    IN     BOOLEAN          RemoveRegistry,
    IN     BOOLEAN          SetupMode,
    IN     BOOLEAN          Extend,
    IN     ULONG            LogfileSize,
    IN     INT              ArgCount,
    IN     WCHAR            **ArgArray,
    IN OUT PMESSAGE         Msg,
       OUT PULONG           ExitStatus
    );

int __cdecl
main(
    int     argc,
    WCHAR**  argv,
    WCHAR**  envp
    );

extern "C" {
#include "efi.h"
#include "efilib.h"
}

int argc;
WCHAR ** argv;

#if defined(EFI_DEBUG)
VOID
PrintLoadedImageInfo (
    IN  EFI_LOADED_IMAGE    *LoadedImage
    );
#endif

VOID
InvokeAutochkMain (
    IN  EFI_HANDLE          ImageHandle,
    IN  EFI_LOADED_IMAGE    *LoadedImage
    );

extern "C" {

EFI_STATUS
__declspec(dllexport)
InitializeEfiChkApplication(
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    EFI_LOADED_IMAGE    *LoadedImage;

    /*
     *  Initialize the Library. Set BS, RT, &ST globals
     *   BS = Boot Services RT = RunTime Services
     *   ST = System Table
     */
    InitializeLib (ImageHandle, SystemTable);
    InitializeShellApplication( ImageHandle, SystemTable );

    Print(TEXT("EFI Check Disk Version 0.2\n"));
    Print(TEXT("Based on EFI Core "));
    Print(TEXT("Version %d.%d.%d.%d\n"),
        EFI_SPECIFICATION_MAJOR_REVISION,
        EFI_SPECIFICATION_MINOR_REVISION,
        EFI_FIRMWARE_MAJOR_REVISION,
        EFI_FIRMWARE_MINOR_REVISION
    );

    DEBUG((D_INFO,(CHAR8*)"EFICHK application started\n"));

    BS->HandleProtocol (ImageHandle, &LoadedImageProtocol, (VOID**)&LoadedImage);

#if 0
    PrintLoadedImageInfo (LoadedImage);
#endif

    // call into autochk.
    InvokeAutochkMain (ImageHandle, LoadedImage);

#if 0
    EfiWaitForKey();
    ST->ConOut->OutputString (ST->ConOut,  TEXT("\n\n"));
#endif

    return EFI_SUCCESS;
}

} // extern "C"

UINT16 *MemoryType[] = {
             TEXT("reserved  "),
             TEXT("LoaderCode"),
             TEXT("LoaderData"),
             TEXT("BS_code   "),
             TEXT("BS_data   "),
             TEXT("RT_code   "),
             TEXT("RT_data   "),
             TEXT("available "),
             TEXT("Unusable  "),
             TEXT("ACPI_recl "),
             TEXT("ACPI_NVS  "),
             TEXT("MemMapIO  "),
             TEXT("MemPortIO "),
             TEXT("PAL_code  "),
             TEXT("BUG:BUG: MaxMemoryType")
};


VOID
InvokeAutochkMain (
    IN  EFI_HANDLE          ImageHandle,
    IN  EFI_LOADED_IMAGE    *LoadedImage
    )
{
    EFI_LOADED_IMAGE    *ParentImage;

    if (!LoadedImage->ParentHandle) {
        /*
         *  If you are loaded from the EFI boot manager the ParentHandle
         *   is Null. Thus a pure EFI application will not have a parrent.
         */
        DEBUG((D_INFO,(CHAR8*)"\n%HImage was loaded from EFI Boot Manager%N\n"));
        return;
    }

    BS->HandleProtocol (LoadedImage->ParentHandle, &LoadedImageProtocol, (VOID**)&ParentImage);

    {
        argc = SI->Argc;
        argv = SI->Argv;

        DEBUG((D_INFO,(CHAR8*)"Launching main...\n"));
        // call main.
        main(argc,argv,NULL);
        DEBUG((D_INFO,(CHAR8*)"Returned from main...\n"));

    }
}

#if defined(EFI_DEBUG)
VOID
PrintLoadedImageInfo (
    IN  EFI_LOADED_IMAGE    *LoadedImage
    )
{
    EFI_STATUS          Status;
    EFI_DEVICE_PATH     *DevicePath;

    Print( TEXT("\n%HImage was loaded from file %N%s\n"), DevicePathToStr (LoadedImage->FilePath));

    BS->HandleProtocol (LoadedImage->DeviceHandle, &DevicePathProtocol, (VOID**)&DevicePath);
    if (DevicePath) {
        Print( TEXT("%HImage was loaded from this device %N%s\n"), DevicePathToStr (DevicePath));

    }

    Print( TEXT("\n Image Base is %X"), LoadedImage->ImageBase);
    Print( TEXT("\n Image Size is %X"), LoadedImage->ImageSize);
    Print( TEXT("\n  Image Code Type %s"), MemoryType[LoadedImage->ImageCodeType]);
    Print( TEXT("\n  Image Data Type %s"), MemoryType[LoadedImage->ImageDataType]);
    Print( TEXT("\n %d Bytes of Options passed to this Image\n"), LoadedImage->LoadOptionsSize);

    if (LoadedImage->ParentHandle) {
        Status = BS->HandleProtocol (LoadedImage->ParentHandle, &DevicePathProtocol, (VOID**)&DevicePath);
        if (Status == EFI_SUCCESS && DevicePath) {
           Print( TEXT("Images parent is %s\n\n"), DevicePathToStr (DevicePath));
        }
    }
}
#endif

BOOLEAN             force = FALSE;
BOOLEAN             readonly = TRUE;

int __cdecl
main(
    int     argc,
    WCHAR**  argv,
    WCHAR**  envp
    )
/*++

Routine Description:

    This routine is the main program for autocheck FAT chkdsk.

Arguments:

    argc, argv  - Supplies the fully qualified NT path name of the
                    the drive to check.

Return Value:

    0   - Success.
    1   - Failure.

--*/
{
    DEBUG( (D_INFO,(CHAR8*)"\nInit Libs...\n"));

    if (!InitializeUlib( NULL, !DLL_PROCESS_DETACH, NULL ) ||
        !InitializeIfsUtil(NULL,0,NULL) ||
        !InitializeUfat(NULL,0,NULL)) {
        return 1;
    }
    DEBUG( (D_INFO,(CHAR8*)"Init Libs Successful.\n"));
    //
    // The declarations must come after these initialization functions.
    //
    DSTRING             dos_drive_name;
    DSTRING             volume_name;
    DSTRING             drive_letter;

    EFICHECK_MESSAGE      *msg = NULL;

    BOOLEAN             onlyifdirty = TRUE;
    BOOLEAN             recover = FALSE;
    BOOLEAN             extend = FALSE;
    BOOLEAN             remove_registry = FALSE;

    ULONG               ArgOffset = 1;

    BOOLEAN             SetupOutput = FALSE;
    BOOLEAN             SetupTextMode = FALSE;
    BOOLEAN             SetupSpecialFixLevel = FALSE;

    ULONG               exit_status = 0;

    BOOLEAN             SuppressOutput = TRUE;      // dots only by default

    BOOLEAN             all_drives = FALSE;
    BOOLEAN             resize_logfile = FALSE;
    BOOLEAN             skip_index_scan = FALSE;
    BOOLEAN             skip_cycle_scan = FALSE;
    BOOLEAN             showhelp = FALSE;
    BOOLEAN             drive_already_specified = FALSE;

    LONG                logfile_size = 0;

    USHORT              rtncode;
    ULONG               chkdsk_flags;

    if (!drive_letter.Initialize() ||
        !volume_name.Initialize()) {
        DEBUG((D_ERROR,(CHAR8*)"Out of memory.\n"));
        return 1;
    }

    force = FALSE;
    onlyifdirty = FALSE;

    // Parse the arguments--the accepted arguments are:
    //
    //      efichk [/f] [/r] device-name
    //
    //      /f - fix errors
    //      /r - recover; implies /f
    //

    msg = NEW EFICHECK_MESSAGE;

    if (NULL == msg || !msg->Initialize()) {
        return 1;
    }

    DEBUG( (D_INFO,(CHAR8*)"\nParse Options\n"));

    for (ArgOffset = 1; ArgOffset < (ULONG)argc; ++ArgOffset) {

        if( (argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'r' || argv[ArgOffset][1] == 'R') &&
            (argv[ArgOffset][2] == 0) ) {

            // Note that /r implies /f.
            //
            recover = TRUE;
            readonly = FALSE;
        } else if( (argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == 'f' || argv[ArgOffset][1] == 'F') &&
            (argv[ArgOffset][2] == 0) ) {

            // Note that /r implies /p.
            //
            readonly = FALSE;
        } else if ((argv[ArgOffset][0] != '/' && argv[ArgOffset][0] != '-')) {
            //  we assume this refers to a device
            if (!volume_name.Initialize(argv[ArgOffset])) {
                return 1;
            }
            drive_already_specified = TRUE;
        } else if( (argv[ArgOffset][0] == '/' || argv[ArgOffset][0] == '-') &&
            (argv[ArgOffset][1] == '?') &&
            (argv[ArgOffset][2] == 0) ) {

            // show some usage help
            showhelp = TRUE;
        } else if ( strcmp(argv[ArgOffset], TEXT("/FORCE")) == 0 ) {
            // have a /FORCE switch to allow efichk to check really messed up volumes.
            force = TRUE;
        } else {
            // this is a switch we don't know of
            msg->Set(MSG_INVALID_PARAMETER);
            msg->Display("%ws",argv[ArgOffset]);
            msg->Set(MSG_BLANK_LINE);
            msg->Display();
            showhelp = TRUE;
        }
    }

    SuppressOutput = FALSE;

    if(showhelp || !drive_already_specified) {
        msg->Set(MSG_CHK_USAGE_HEADER);
        msg->Display();
        msg->Set(MSG_BLANK_LINE);
        msg->Display();
        msg->Set(MSG_CHK_COMMAND_LINE);
        msg->Display();
        msg->Set(MSG_CHK_DRIVE);
        msg->Display();
        msg->Set(MSG_CHK_F_SWITCH);
        msg->Display();
        msg->Set(MSG_CHK_V_SWITCH);
        msg->Display();
        return 1;
    }

    // make drive letter the same as volume name
    if (!drive_letter.Initialize(&volume_name)) {
        return 1;
    }

    DEBUG( (D_INFO,(CHAR8*)"\nParsed Args\n"));

    chkdsk_flags = 0;
    chkdsk_flags = (onlyifdirty ? CHKDSK_CHECK_IF_DIRTY : 0);
    chkdsk_flags |= ((recover || extend) ? CHKDSK_RECOVER_FREE_SPACE : 0);
    chkdsk_flags |= (recover ? CHKDSK_RECOVER_ALLOC_SPACE : 0);

    DEBUG((D_INFO,(CHAR8*)"Invoking chkdsk.\n"));

    rtncode = InvokeAutoChk(&drive_letter,
                            &volume_name,
                            chkdsk_flags,
                            remove_registry,
                            SetupOutput || SetupTextMode,
                            extend,
                            logfile_size,
                            argc,
                            argv,
                            msg,
                            &exit_status);

    DEBUG((D_INFO,(CHAR8*)"Back from chkdsk.\n"));
#if 0
    switch( exit_status ) {
    case 0:
        msg->Set(MSG_CHK_AUTOCHK_COMPLETE);
        break;
    case 1:
    case 2:
        msg->Set(MSG_CHK_ERRORS_FIXED);
        break;
    case 3:
        msg->Set(MSG_CHK_ERRORS_NOT_FIXED);
        break;
    default:
        msg->Set(MSG_CHK_AUTOCHK_COMPLETE);
        break;
    }
    msg->Display();
#endif

    DELETE(msg);

    DEBUG((D_ERROR,(CHAR8*)"EFICHK: Exit Status %d\n", exit_status));

    return exit_status;
}

USHORT
InvokeAutoChk (
    IN     PWSTRING         DriveLetter,
    IN     PWSTRING         VolumeName,
    IN     ULONG            ChkdskFlags,
    IN     BOOLEAN          RemoveRegistry,
    IN     BOOLEAN          SetupMode,
    IN     BOOLEAN          Extend,
    IN     ULONG            LogfileSize,
    IN     INT              ArgCount,
    IN     WCHAR            **ArgArray,
    IN OUT PMESSAGE         Msg,
       OUT PULONG           ExitStatus
    )
/*++

Routine Description:

    This is the core of efichk.  It checks the specified drive.

Arguments:

    DriveLetter     - Supplies the drive letter of the drive
                      (can be empty string)
    VolumeName      - Supplies the guid volume name of the drive
    ChkdskFlags     - Supplies the chkdsk control flags
    RemoveRegistry  - Supplies TRUE if registry entry is to be removed
    SetupMode       - Supplies TRUE if invoked through setup
    Extend          - Supplies TRUE if extending the volume (obsolete)
    LogfileSize     - Supplies the size of the logfile
    ArgCount        - Supplies the number of arguments given to autochk.
    ArgArray        - Supplies the arguments given to autochk.
    Msg             - Supplies the outlet of messages
    ExitStatus      - Retrieves the exit status of chkdsk

Return Value:

    0   - Success
    1   - Fatal error
    2   - Volume specific error

--*/
{
    DSTRING             fsname;
    DSTRING             fsNameAndVersion;

    PFAT_VOL            fatvol = NULL;
    PVOL_LIODPDRV       vol;

    BOOLEAN             SetupSpecialFixLevel = FALSE;

    PREAD_CACHE         read_cache;

    DSTRING             boot_execute_log_file_name;
    FSTRING             boot_ex_temp;
    HMEM                logged_message_mem;
    NTSTATUS            result;

    DSTRING             fatname;
    DSTRING             fat32name;
    DSTRING             rawname;
    DSTRING             ntfsname;

    *ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;

    if (!fatname.Initialize("FAT") ||
        !rawname.Initialize("RAW") ||
        !fat32name.Initialize("FAT32")) {
        return 1;
    }

    if (VolumeName->QueryChCount() == 0) {
        DEBUG((D_ERROR,(CHAR8*)"EFICHK: Volume name is missing.\n"));
        return 2;   // continue if all_drives are enabled
    }

    if (DriveLetter->QueryChCount() == 0) {
        // unable to map VolumeName to a drive letter so do the default
        if (!IFS_SYSTEM::NtDriveNameToDosDriveName(VolumeName, DriveLetter)) {
            DEBUG((D_ERROR,(CHAR8*)"Out of memory.\n"));
            return 1;
        }
    }

    if (!IFS_SYSTEM::QueryFileSystemName(VolumeName, &fsname,
                                         &result, &fsNameAndVersion)) {
        Msg->Set( MSG_FS_NOT_DETERMINED );
        Msg->Display( "%W", VolumeName );

        if(result != 0 ){
            Msg->Set(MSG_CANT_DASD);
            Msg->Display();
        }
        return 2;
    }

    // Msg->SetLoggingEnabled();
    Msg->Set(MSG_CHK_RUNNING);
    Msg->Display("%W", DriveLetter);

    Msg->Set(MSG_FILE_SYSTEM_TYPE);
    Msg->Display("%W", &fsname);

    if (fsname == fatname || fsname == fat32name || force) {

        if (!(fatvol = NEW FAT_VOL)) {
            DEBUG((D_ERROR,(CHAR8*)"Out of memory.\n"));
            return 1;
        }

        if (NoError != fatvol->Initialize(Msg,
                                          VolumeName,
                                          (BOOLEAN)(ChkdskFlags & CHKDSK_CHECK_IF_DIRTY))) {
            DELETE(fatvol);
            return 2;
        }

        if ((read_cache = NEW READ_CACHE) &&
            read_cache->Initialize(fatvol, 75)) {
            fatvol->SetCache(read_cache);
        } else {
            DELETE(read_cache);
        }

        vol = fatvol;

    } else {
        Msg->Set( MSG_FS_NOT_SUPPORTED );
        Msg->Display( "%s%W", "EFICHK", &fsname );
        return 2;
    }

    // Invoke chkdsk.

    if (!vol->ChkDsk(readonly ? CheckOnly : TotalFix,
                     Msg,
                     ChkdskFlags,
                     LogfileSize,
                     ExitStatus,
                     DriveLetter)) {

        DELETE(vol);

        DEBUG((D_ERROR,(CHAR8*)"EFICHK: ChkDsk failure\n"));

        return 2;
    }

    DELETE(vol);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efichar\efichar.c ===
#include <efi.h>
#include <efilib.h>

#define MAX_ENV_SIZE    1024

#define MAXUSHORT  (0xFFFF)

//
// Globals for stdout
//
SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;
SIMPLE_INPUT_INTERFACE          *ConIn;

//
// Globals for protocol handler
//
EFI_HANDLE_PROTOCOL             HandleProtocol;
EFI_LOCATE_HANDLE               LocateHandle;
EFI_LOCATE_DEVICE_PATH          LocateDevicePath;
EFI_IMAGE_LOAD                  LoadImage;
EFI_IMAGE_START                 StartImage;
EFI_SET_VARIABLE                SetVariable;
EFI_HANDLE                      MenuImageHandle;
EFI_LOADED_IMAGE                *ExeImage;

//
// globals for managing boot entries
//
UINT32      NvrAttributes;
UINTN       NvrOrderCount;
UINT16      *NvrOrder;

//
// prototypes
//
UINT32 GetInputKey();
void DisplayKey(UINT32);

EFI_STATUS
OpenCreateFile (
    UINT64              OCFlags,
    EFI_FILE_HANDLE*    StartHdl,
    CHAR16*             Name
    );

EFI_STATUS
InsertBootOption(
    VOID  *BootOption,
    UINT64 BootOptionSize
    );

INTN
ParseNvrFile (
    EFI_FILE_HANDLE NvrFile
    );

EFI_STATUS
FindFreeBootOption(
    CHAR16  *FreeIdx
    );

INTN
RestoreNvr (
    CHAR16*     fileName
   );

VOID
InitializeStdOut(
    IN struct _EFI_SYSTEM_TABLE     *SystemTable
    )
{

    //
    // Stash some of the efi stdout pointers
    //
    ConOut = SystemTable->ConOut;
    ConIn = SystemTable->ConIn;

}

//
//
//

void
InitializeProtocols(
    IN struct _EFI_SYSTEM_TABLE     *SystemTable
    )
{

    EFI_BOOT_SERVICES    *bootServices;
    EFI_RUNTIME_SERVICES *runtimeServices;

    // 
    // Stash some of the handle protocol pointers
    //

    bootServices = SystemTable->BootServices;

    HandleProtocol      = bootServices->HandleProtocol;
    LocateHandle        = bootServices->LocateHandle;
    LocateDevicePath    = bootServices->LocateDevicePath;

    LoadImage           = bootServices->LoadImage;
    StartImage          = bootServices->StartImage;

    //
    // Stash some of the Runtime services pointers
    //
    
    runtimeServices = SystemTable->RuntimeServices;

    SetVariable = runtimeServices->SetVariable;
    
}

EFI_STATUS
Init(
    IN EFI_HANDLE       ImageHandle,
    IN EFI_SYSTEM_TABLE *SystemTable
    )
{
    EFI_STATUS  Status;
    UINTN       BufferSize;

    do {

        //
        // Initialize EFI routines
        //
        InitializeProtocols( SystemTable );
        InitializeStdOut( SystemTable );
        InitializeLib( ImageHandle, SystemTable );

        //
        // Save Image Handle
        // 
        MenuImageHandle = ImageHandle;

        BS->HandleProtocol (ImageHandle, &LoadedImageProtocol, &ExeImage);

        //
        //
        //
        NvrOrder = AllocatePool(MAX_ENV_SIZE + 32);

        if (! NvrOrder) {
            Status = EFI_OUT_OF_RESOURCES;
            break;
        }

        //
        // get boot order from nvram
        //
        BufferSize = MAX_ENV_SIZE;
        
        Status = RT->GetVariable (
                    VarBootOrder, 
                    &EfiGlobalVariable,
                    &NvrAttributes,
                    &BufferSize,
                    NvrOrder
                    );

        if (EFI_ERROR(Status)) {
            Print(L"Nvr: failed to load boot order array. defaulting\n");
            BufferSize = 0;
            NvrAttributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS;
            Status = EFI_SUCCESS;
        }

        //
        // get how many boot options there are
        //
        NvrOrderCount = BufferSize / sizeof(UINT16);
    
    } while ( FALSE );
    
    return Status;
}

VOID
Shutdown(
    VOID
    )
{
    if (NvrOrder) {
        FreePool(NvrOrder);
    }
}

EFI_STATUS 
EfiMain(
    IN EFI_HANDLE       ImageHandle,
    IN EFI_SYSTEM_TABLE *SystemTable
    )
{
    EFI_STATUS  Status;
    UINT32      ch, user, cnt;
    CHAR8       *LangCode;

    // Initialize the EFI SDX libraries
    InitializeLib( ImageHandle, SystemTable );
        
    //
    //
    //
    LangCode = LibGetVariable (VarLanguage, &EfiGlobalVariable);

    if (LangCode) {
        UINTN i;
        Print(L"LangCode: ");
        for (i = 0; i < ISO_639_2_ENTRY_SIZE; i++) {
            Print(L"%c", LangCode[i]);
        }
        Print(L"\n");
        FreePool(LangCode);
    }

    //
    //
    //
    Status = Init(ImageHandle, SystemTable);

    if (EFI_ERROR(Status)) {
        return TRUE;
    }

    //
    //
    //
    ch = cnt = 0;
    user = 0;

    while ( user != (UINT32) 'q' && ch <= (UINT32) 0xFF ) {        
        
        Print( L"Please press any key to continue (q to quit)\n");
        user = GetInputKey();
        if (user == L'q') {
            break;
        }
        
        Print(L"Adding a boot entry\n");
        
        RestoreNvr(L"blob.nvr");        

    }

    //
    // clean up 
    //
    Shutdown();

    // If you return the status, EFI will kindly give the user an English
    // error message.
    return TRUE;
}


UINT32 GetInputKey()
{
    EFI_INPUT_KEY pKey;
    EFI_STATUS Status;

    // Wait until a keystroke is available
    WaitForSingleEvent(
        ST->ConIn->WaitForKey,
        0);

    // Read the key that has been pressed
    Status = ST->ConIn->ReadKeyStroke(
        ST->ConIn,
        &pKey);

    if (EFI_ERROR(Status) || pKey.ScanCode != 0) {
        return 0x20; // space
    }

    return pKey.UnicodeChar;
}

EFI_STATUS
InsertBootOption(
    VOID   *BootOption,
    UINT64 BootOptionSize
    )
{
    EFI_STATUS  Status;
    CHAR16      OptionStr[40];

    Print(L"InsertBootOption: enter\n");
    
    //
    // attempt to insert boot option
    //
    do {

        UINT16  Target;
        
        //
        //
        //
        Status = FindFreeBootOption(&Target);
        
        if (EFI_ERROR(Status)) {
            Print (L"Nvr: failed to find free boot option id: %hr\n", Status);
            break;
        }
        
        //
        // update nvram with the new boot option
        //
        
        SPrint( OptionStr, sizeof(OptionStr), VarBootOption, Target);
        
        Print(L"InsertBootOption: target = %x, OptionStr = %s\n", Target, OptionStr);
        
        Status = RT->SetVariable (
            OptionStr,
            &EfiGlobalVariable,
            NvrAttributes,
            BootOptionSize,
            BootOption
            );

        if (EFI_ERROR(Status)) {
            Print (L"Nvr: failed to add %hs - %hr\n", OptionStr, Status);
            break;
        }


        //
        // replace boot order with one including the new option
        //

        NvrOrder[NvrOrderCount] = Target;
        
        NvrOrderCount++;

        Status = RT->SetVariable (
            VarBootOrder, 
            &EfiGlobalVariable, 
            NvrAttributes,
            NvrOrderCount * sizeof(UINT16),
            NvrOrder
            );

        if (EFI_ERROR(Status)) {
            Print (L"Nvr: failed to update %hs - %hr\n", VarBootOrder, Status);
            break;
        }

#if 1
    
    //
    // validate what we just wrote
    //
    {
        UINTN   BlobSize;
        CHAR8   *Blob;        
        UINT16  i;

        BlobSize    = BootOptionSize;
        Blob        = AllocatePool(BootOptionSize);

        do {

            Status = RT->GetVariable (
                OptionStr,
                &EfiGlobalVariable,
                NULL,
                &BlobSize,
                Blob
                );

            if (EFI_ERROR(Status)) {
                Print (L"Nvr: failed to read comparison blob: %hr\n", Status);
                break;
            }

            for (i = 0; i < BootOptionSize; i++) {
                if (((CHAR8*)BootOption)[i] != Blob[i]) {
                    Print(L"Nvr: diff[%d]: BootOption = %d, Blob = %d\n", i, ((CHAR8*)BootOption)[i], Blob[i]);
                }
            }
        
        } while ( FALSE );

        FreePool(Blob);

    }

#endif

    } while ( FALSE );
    
    Print(L"InsertBootOption: exit\n");
    
    return Status;
}

EFI_STATUS
FindFreeBootOption(
    CHAR16  *FreeIdx
    )
{
    
    EFI_STATUS  Status;
    UINT16      id;
    UINT16      i;
    BOOLEAN     Found;
    BOOLEAN     HaveFreeIdx;

    Print(L"FindFreeBootOption: enter\n");
    
    HaveFreeIdx = FALSE;

    *FreeIdx = MAXUSHORT;

    //
    // use a brute force search to find a new boot option id
    //
    for ( id = 0; id <= MAXUSHORT; id++ ) {
        
        Print(L"FindFreeBootOption: id = %x\n", id);

        Found = FALSE;

        for (i = 0; i < NvrOrderCount; i++) {
            
            if (NvrOrder[i] == id) {
                Found = TRUE;
                break;
            }
        
        }

        if (! Found) {
            *FreeIdx = id;
            HaveFreeIdx = TRUE;
            break;
        }

    }

    if (HaveFreeIdx) {
        Status = EFI_SUCCESS;
    } else {
        Status = EFI_OUT_OF_RESOURCES;
    }

    Print(L"FindFreeBootOption: FreeIdx = %x, status = %x\n", *FreeIdx, Status);
    Print(L"FindFreeBootOption: exit\n");
    
    return Status;
}

INTN
RestoreNvr (
    CHAR16*     fileName
   )
{
    EFI_STATUS Status;
    EFI_FILE_HANDLE nvrFile;

    //
    // Read from saved boot options file
    //
    Status = OpenCreateFile (EFI_FILE_MODE_READ,&nvrFile,fileName);
    
    if (EFI_ERROR (Status)) {
        Print(L"\nCan not open the file %s\n",fileName);
        return Status;
    }
    
    //
    // This updates nvram with saved boot options
    //
    return (ParseNvrFile (nvrFile));

}

EFI_STATUS
OpenCreateFile (
    UINT64              OCFlags,
    EFI_FILE_HANDLE*    StartHdl,
    CHAR16*             Name
    )
{
    EFI_FILE_IO_INTERFACE   *Vol;
    EFI_FILE_HANDLE         RootFs;
    EFI_FILE_HANDLE         CurDir;
    EFI_FILE_HANDLE         FileHandle;
    CHAR16                  FileName[100],*DevicePathAsString;
    EFI_STATUS              Status;

    Print(L"OpenCreateFile: enter\n");

    do {

        //
        // Open the volume for the device where the nvrutil was started.
        //
        Status = BS->HandleProtocol (
            ExeImage->DeviceHandle,
            &FileSystemProtocol,
            &Vol
            );

        if (EFI_ERROR(Status)) {
            Print(L"\n");
            Print(L"Can not get a FileSystem handle for %s DeviceHandle\n",ExeImage->FilePath);
            break;
        }

        Status = Vol->OpenVolume (Vol, &RootFs);

        if (EFI_ERROR(Status)) {
            Print(L"\n");
            Print(L"Can not open the volume for the file system\n");
            break;
        }

        CurDir = RootFs;

        //
        // Open saved boot options file 
        //
        FileName[0] = 0;

        DevicePathAsString = DevicePathToStr(ExeImage->FilePath);
        if (DevicePathAsString!=NULL) {
            StrCpy(FileName,DevicePathAsString);
            FreePool(DevicePathAsString);
        }

        StrCpy(FileName, L".\\");
        StrCat(FileName,Name);

        Status = CurDir->Open (CurDir,
                               &FileHandle,
                               FileName,
                               OCFlags,
                               0
                               );

        *StartHdl=FileHandle;

    } while ( FALSE );
    
    Print(L"OpenCreateFile: exit\n");

    return Status;
}

INTN
ParseNvrFile (
    EFI_FILE_HANDLE NvrFile
    )
{
    BOOLEAN     bSuccess;
    EFI_STATUS  Status;
    CHAR8       *buffer;
    UINTN       k,size;
    UINT64      BootNumber;
    UINT64      BootSize;
    VOID        *BootOption;
    UINTN       blockBegin;
    EFI_FILE_INFO *fileInfo;

    Print(L"ParseNvrFile: enter\n");
    
    buffer = NULL;

    do {

        //
        //
        //
        size = 0;
        Status = NvrFile->GetInfo(NvrFile,&GenericFileInfo,&size,NULL);
        
        if (Status != EFI_BUFFER_TOO_SMALL) {
            break;
        }

        Print(L"ParseNvrFile: size = %d vs %d\n", size, SIZE_OF_EFI_FILE_INFO+255*sizeof (CHAR16));
        
        fileInfo = AllocateZeroPool(size);

        if (fileInfo == NULL) {
            Print(L"\n");
            Print (L"Failed to allocate memory for File Info buffer!\n");
            Status = EFI_OUT_OF_RESOURCES;
            break;
        }

        //
        //
        //
        Status = NvrFile->GetInfo(NvrFile,&GenericFileInfo,&size,fileInfo);

        size=(UINTN) fileInfo->FileSize;

        FreePool (fileInfo);

        buffer = AllocateZeroPool ((size+1));

        if (buffer == NULL) {
            Print(L"\n");
            Print (L"Failed to allocate memory for File buffer!\n");
            Status = EFI_OUT_OF_RESOURCES;
            break;
        }

        Status = NvrFile->Read(NvrFile,&size,buffer);

        NvrFile->Close (NvrFile);

        if (EFI_ERROR (Status)) {
            Print(L"\n");
            Print (L"Failed to read nvr file!\n");
            break;
        }

        //
        // 
        // 
        k=0;

        while(k < size ) {

            blockBegin = k;

            CopyMem( &BootNumber, &buffer[k], sizeof(BootNumber));
            k += sizeof(UINT64);

            CopyMem( &BootSize, &buffer[k], sizeof(BootSize));
            k += sizeof(UINT64);

            BootOption = (VOID *)((CHAR8*)buffer + k);
            k += BootSize;

            //
            // sanity check the file position vs. what the 
            // file header information tells us.  The value
            // k should be <= to size now.
            //
            if (k > size) {
                Print (L"\nThe NVRAM file is corrupted.\n");
                Status = EFI_BAD_BUFFER_SIZE;           
                break;
            }

            //
            // write the current boot entry at free location
            //
            Status = InsertBootOption(
                BootOption,
                BootSize
                );

            if (EFI_ERROR(Status)) {
                Print(L"\nError: Failed to append new boot entry to boot order array\n");
                break;
            }                                

        }

    } while ( FALSE );
    
    if (buffer) {
        FreePool (buffer);
    }
    
    Print(L"ParseNvrFile: exit\n");

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efichk\usa\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\efichk.obj

EFI_LIBS=..\..\efilib\src\$(ALT_PROJECT)\$(TARGETPATH)\$(TARGET_DIRECTORY)\efilib.lib \
         $(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib \
!if $(IA64)
         $(EFI_ROOT)\build\$(LIBSRC)\output\shell\lib\lib.lib
!else
         $(EFI_ROOT)\build\$(LIBSRC)\output\shell\lib\lib.lib \
         $(SDK_LIB_PATH)\int64.lib
!endif

$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:InitializeEfiChkApplication
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\$(TARGETNAME).efi: $(OSLOADER) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efiecho\efiecho.c ===
#include <efi.h>
#include <efilib.h>

typedef CHAR16* PWSTR;
typedef const PWSTR PCWSTR;


EFI_STATUS GetInputKey(
    EFI_INPUT_KEY* pKey);
void DisplayKey(EFI_INPUT_KEY* pKey);

// This string is used to check when the user has pressed "q" followed
// by "u" followed by "i" followed by "t".  This is the method to quit
// the application and return to the EFI prompt.
const PWSTR pszExitString = L"quit";

// Constants to use when displaying what key was pressed.
// Note that this array is indexed by EFI scan code, and includes
// all keystrokes enumerated in the EFI v1.02 specification document.
PCWSTR pszKeyStrings[] =
{
    L"NULL scan code",                  // 0x00
    L"Move cursor up 1 row",            // 0x01
    L"Move cursor down 1 row",          // 0x02
    L"Move cursor right 1 column",      // 0x03
    L"Move cursor left 1 column",       // 0x04
    L"Home",                            // 0x05
    L"End",                             // 0x06
    L"Insert",                          // 0x07
    L"Delete",                          // 0x08
    L"Page Up",                         // 0x09
    L"Page Down",                       // 0x0a
    L"Function 1",                      // 0x0b
    L"Function 2",                      // 0x0c
    L"Function 3",                      // 0x0d
    L"Function 4",                      // 0x0e
    L"Function 5",                      // 0x0f
    L"Function 6",                      // 0x10
    L"Function 7",                      // 0x11
    L"Function 8",                      // 0x12
    L"Function 9",                      // 0x13
    L"Function 10",                     // 0x14
    L"INVALID scan code",               // 0x15
    L"INVALID scan code",               // 0x16
    L"Escape",                          // 0x17
};




// This is the main routine.  After initializing the SDX library, we will
// wait in a loop for keys to be pressed, and then we will display what
// those keys are.  I have made an effort to make the output as useful as
// possible.

EFI_STATUS EfiMain(
    IN EFI_HANDLE       ImageHandle,
    IN EFI_SYSTEM_TABLE *SystemTable)
{
    EFI_INPUT_KEY Key;
    EFI_STATUS Status;
    PWSTR pszExitCounter = pszExitString;

    // Initialize the EFI SDX libraries
    InitializeLib( ImageHandle, SystemTable );

    // Echo some message to the user, as the initialization takes
    // some time.  At least the user will know when he can start
    // pressing keys.
    Print(L"EFI Keystroke Echo Utility.\n");
    Print(L"Type \"quit\" to quit.\n");

    // We will continue until the user has pressed quit.  Note that each
    // successive correct key will cause pszExitCounter to be incremented,
    // and this will cause it to eventually point at the NULL character that
    // is terminating pszExitString.
    while (*pszExitCounter!=L'\0')
    {
        // Get a keystroke
        Status = GetInputKey(
            &Key);

        if (EFI_ERROR(Status))
        {
            Print(L"Error in ReadKeyStroke (0x%08x).\n", Status);
            break;
        }

        // Display the keystroke
        DisplayKey(&Key);

        // Check if this is the next key in the quit sequence
        if (Key.UnicodeChar==*pszExitCounter)
        {
            // If it is, then look for the next one.
            pszExitCounter++;
        }
        else
        {
            // Else start at the beginning.
            pszExitCounter = pszExitString;
        }
    }

    // We are quitting, so tell the user.
    Print(L"We are done.\n");

    // If you return the status, EFI will kindly give the user an English
    // error message.
    return Status;
}


EFI_STATUS GetInputKey(
    OUT EFI_INPUT_KEY* pKey)
{
    EFI_STATUS Status;
    // Wait until a keystroke is available
    WaitForSingleEvent(
        ST->ConIn->WaitForKey,
        0);

    // Read the key that has been pressed
    Status = ST->ConIn->ReadKeyStroke(
        ST->ConIn,
        pKey);

    // Return the status, whether success or failure
    return Status;
}


void DisplayKey(EFI_INPUT_KEY* pKey)
{
    // Firstly, let's display the raw keystroke
    Print(L"0x%04x 0x%04x - ", pKey->ScanCode, pKey->UnicodeChar);

    // Let's check if this is a Unicode only key (some character)
    if (pKey->ScanCode==0)
    {
        // Is this a printable character
        if (pKey->UnicodeChar>=33 && pKey->UnicodeChar<=127)
        {
            // If so, print the character
            Print(L"\"%c\"", pKey->UnicodeChar);
        }
        else
        {
            // Else print it's numerical value
            Print(L"(CHAR16)0x%04x", pKey->UnicodeChar);
        }
    }
    // Check to ensure that this scancode is in the range that we have
    // a string constant for ...
    else if (pKey->ScanCode>=0 && pKey->ScanCode<=0x17)
    {
        // Display the string constant for our keystroke
        Print(L"%s", pszKeyStrings[pKey->ScanCode]);
    }
    else
    {
        // We know nothing about this keystroke, so say so.
        Print(L"INVALID scan code", pszKeyStrings[pKey->ScanCode]);
    }

    Print(L"\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efiecho\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\efiecho.obj

EFI_LIBS=$(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib


$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:EfiMain
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\$(TARGETNAME).efi: $(OSLOADER) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efifmt\efifmt.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    efifmt.cxx

Abstract:

    This is the main program for the efi version of format.

--*/

#pragma warning(disable: 4091)

#include "ulib.hxx"
#include "wstring.hxx"
#include "efickmsg.hxx"
#include "error.hxx"
#include "ifssys.hxx"
#include "rtmsg.h"
#include "ifsentry.hxx"
#include "fatvol.hxx"
#include "layout.hxx"

#include "efiwintypes.hxx"

extern "C" BOOLEAN
InitializeUfat(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

extern "C"
BOOLEAN
InitializeIfsUtil(
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
    );

int __cdecl
main(
    int     argc,
    WCHAR**  argv,
    WCHAR**  envp
    );

int argc;
WCHAR ** argv;

#if defined(EFI_DEBUG)
VOID
PrintLoadedImageInfo (
    IN  EFI_LOADED_IMAGE    *LoadedImage
    );
#endif

VOID
InvokeAutoFmtMain (
    IN  EFI_HANDLE          ImageHandle,
    IN  EFI_LOADED_IMAGE    *LoadedImage
    );

extern "C" {

EFI_STATUS
__declspec(dllexport)
InitializeEfiFmtApplication(
    IN EFI_HANDLE           ImageHandle,
    IN EFI_SYSTEM_TABLE     *SystemTable
    )
{
    EFI_LOADED_IMAGE    *LoadedImage;

    /*
     *  Initialize the Library. Set BS, RT, &ST globals
     *   BS = Boot Services RT = RunTime Services
     *   ST = System Table
     */
    InitializeLib (ImageHandle, SystemTable);
    InitializeShellApplication( ImageHandle, SystemTable );

    DEBUG((D_INFO,(CHAR8*)"EFIFMT application started\n"));

    Print(TEXT("EFI Disk Format Version 0.2\n"));
    Print(TEXT("Based on EFI Core "));
    Print(TEXT("Version %d.%d.%d.%d\n"),
        EFI_SPECIFICATION_MAJOR_REVISION,
        EFI_SPECIFICATION_MINOR_REVISION,
        EFI_FIRMWARE_MAJOR_REVISION,
        EFI_FIRMWARE_MINOR_REVISION
    );

    BS->HandleProtocol (ImageHandle, &LoadedImageProtocol, (VOID**)&LoadedImage);

#if 0
    PrintLoadedImageInfo (LoadedImage);
#endif

    // call into autofmt.
    InvokeAutoFmtMain (ImageHandle, LoadedImage);

#if 0
    EfiWaitForKey();
    ST->ConOut->OutputString (ST->ConOut, TEXT("\n\n"));
#endif

    return EFI_SUCCESS;
}

} // extern "C"

UINT16 *MemoryType[] = {
            TEXT("reserved  "),
            TEXT("LoaderCode"),
            TEXT("LoaderData"),
            TEXT("BS_code   "),
            TEXT("BS_data   "),
            TEXT("RT_code   "),
            TEXT("RT_data   "),
            TEXT("available "),
            TEXT("Unusable  "),
            TEXT("ACPI_recl "),
            TEXT("ACPI_NVS  "),
            TEXT("MemMapIO  "),
            TEXT("MemPortIO "),
            TEXT("PAL_code  "),
            TEXT("BUG:BUG: MaxMemoryType")
};


VOID
InvokeAutoFmtMain (
    IN  EFI_HANDLE          ImageHandle,
    IN  EFI_LOADED_IMAGE    *LoadedImage
    )
{
    EFI_LOADED_IMAGE    *ParentImage;

    if (!LoadedImage->ParentHandle) {
        /*
         *  If you are loaded from the EFI boot manager the ParentHandle
         *   is Null. Thus a pure EFI application will not have a parrent.
         */
        DEBUG((D_INFO,(CHAR8*)"\n%HImage was loaded from EFI Boot Manager%N\n"));
        return;
    }

    BS->HandleProtocol (LoadedImage->ParentHandle, &LoadedImageProtocol, (VOID**)&ParentImage);

#if 0
    Print(TEXT("\n%HImage Parent was %N%s %Hand it passed the following arguments:%N \n   %s\n\n"), DevicePathToStr (ParentImage->FilePath),LoadedImage->LoadOptions);
#endif

    {
        argc = SI->Argc;
        argv = SI->Argv;

        DEBUG((D_INFO,(CHAR8*)"Launching main...\n"));
        // call main.
        main(argc,argv,NULL);
        DEBUG((D_INFO,(CHAR8*)"Returned from main...\n"));

    }
}

#if defined(EFI_DEBUG)
VOID
PrintLoadedImageInfo (
    IN  EFI_LOADED_IMAGE    *LoadedImage
    )
{
    EFI_STATUS          Status;
    EFI_DEVICE_PATH     *DevicePath;

    Print(TEXT("\n%HImage was loaded from file %N%s\n"), DevicePathToStr (LoadedImage->FilePath));

    BS->HandleProtocol (LoadedImage->DeviceHandle, &DevicePathProtocol, (VOID**)&DevicePath);
    if (DevicePath) {
        Print(TEXT("%HImage was loaded from this device %N%s\n"), DevicePathToStr (DevicePath));

    }

    Print(TEXT("\n Image Base is %X"), LoadedImage->ImageBase);
    Print(TEXT("\n Image Size is %X"), LoadedImage->ImageSize);
    Print(TEXT("\n  Image Code Type %s"), MemoryType[LoadedImage->ImageCodeType]);
    Print(TEXT("\n  Image Data Type %s"), MemoryType[LoadedImage->ImageDataType]);
    Print(TEXT("\n %d Bytes of Options passed to this Image\n"), LoadedImage->LoadOptionsSize);

    if (LoadedImage->ParentHandle) {
        Status = BS->HandleProtocol (LoadedImage->ParentHandle, &DevicePathProtocol, (VOID**)&DevicePath);
        if (Status == EFI_SUCCESS && DevicePath) {
           Print(TEXT("Images parent is %s\n\n"), DevicePathToStr (DevicePath));
        }
    }
}
#endif

int __cdecl
main(
    int     argc,
    WCHAR**  argv,
    WCHAR**  envp
    )
/*++

Routine Description:

    This routine is the main program for AutoFmt

Arguments:

    argc, argv  - Supplies the fully qualified NT path name of the
                  the drive to check.  The syntax of the autofmt
                  command line is:

    AUTOFMT drive-name /FS:target-file-system [/V:label] [/Q] [/A:size] [/C]
            [/S]

Return Value:

    0   - Success.
    1   - Failure.

--*/
{
    if (!InitializeUlib( NULL, ! DLL_PROCESS_DETACH, NULL )     ||
        !InitializeIfsUtil(NULL, ! DLL_PROCESS_DETACH, NULL)    ||
        !InitializeUfat(NULL, ! DLL_PROCESS_DETACH, NULL)
       ) {
        return 1;
    }

    PFAT_VOL            fat_volume;
    PDP_DRIVE            dp_drive;

    EFICHECK_MESSAGE    *message = NULL;
    DSTRING             drive_name;
    DSTRING             file_system_name;
    DSTRING             label;
    DSTRING*            plabel;
    DSTRING             fat_name;
    DSTRING             fat32_name;
    DSTRING             raw_name;
    BOOLEAN             quick = FALSE;
    BOOLEAN             compress = FALSE;
    FORMAT_ERROR_CODE   success;
    BOOLEAN             setup_output = FALSE;
    BOOLEAN             textmode_output = FALSE;
    BOOLEAN             drive_already_specified = FALSE;
    BOOLEAN             force_filesystem = FALSE;
    BOOLEAN             showhelp = FALSE;
    BOOLEAN             labelled = FALSE;
    BIG_INT             bigint;
    ULONG               cluster_size = 0;
    int                 i;
    NTSTATUS            result;

    if (!(perrstk = NEW ERRSTACK)) {
        return 1;
    }

    if (!file_system_name.Initialize()) {
        return 1;
    }
    if (!label.Initialize() || NULL == (dp_drive = NEW DP_DRIVE)) {
        return 1;
    }

    //
    //  Parse the arguments.
    //

//    if ( argc < 2 ) {
//        return 1;
//    }

    message = NEW EFICHECK_MESSAGE;

    if (NULL == message || !message->Initialize()) {
        return 1;
    }

    //
    //  The rest of the arguments are flags.
    //
    for (i = 1; i < argc; i++) {

        if (((argv[i][0] == '/' || argv[i][0] == '=') &&
            (argv[i][1] == '?' )) || showhelp
             ) {
            showhelp = TRUE;
        }
        else if ((argv[i][0] == '/' || argv[i][0] == '-')    &&
            (argv[i][1] == 'f' || argv[i][1] == 'F')    &&
            (argv[i][2] == 's' || argv[i][2] == 'S')    &&
            (argv[i][3] == ':')) {

            if (!file_system_name.Initialize(&argv[i][4])) {
                return 1;
            }
            force_filesystem = TRUE;
            DEBUG((D_INFO,(CHAR8*)"fsname: %ws\n", file_system_name.GetWSTR()));
        }
        else if ((argv[i][0] == '/' || argv[i][0] == '-')    &&
            (argv[i][1] == 'v' || argv[i][1] == 'V')    &&
            (argv[i][2] == ':')) {

            if (!label.Initialize(&argv[i][3])) {
                return 1;
            }
            labelled = TRUE;
        }
        else if ((argv[i][0] == '/' || argv[i][0] == '-')    &&
            (argv[i][1] == 'a' || argv[i][1] == 'A')    &&
            (argv[i][2] == ':')) {

            // Check to see if the size is specified in Kb
            if ((argv[i][StrLen(argv[i])-1] == 'k') || (argv[i][StrLen(argv[i])-1] == 'K')) {
                argv[i][StrLen(argv[i])-1] = '\0'; // remove the K and null terminate the string
                cluster_size = (ULONG)Atoi(&argv[i][3]) * 1024;                
            } 
            else {
                cluster_size = (ULONG)Atoi(&argv[i][3]);
            }
        }
        else if (0 == StriCmp(argv[i], TEXT("/Q")) || 0 == StriCmp(argv[i], TEXT("-Q"))) {
            quick = TRUE;
        }
        else if (argv[i][0] != '/' && argv[i][0] != '-') {
            // it's not a switch, assume it is the drive
            // we don't allow two drive at the same time
            if( drive_already_specified ) {
                message->Set(MSG_FMT_INVALID_DRIVE_SPEC);
                message->Display();
                return 1;
            }
            drive_already_specified = TRUE;
            if ( !drive_name.Initialize( argv[i] ) ) {
                return 1;
            }
            DEBUG((D_INFO,(CHAR8*)"drive name: %ws\n", drive_name.GetWSTR()));
        }
        else {
            // its not any vaild option we know of
            message->Set(MSG_INVALID_PARAMETER);
            message->Display("%ws",argv[i]);
            message->Set(MSG_BLANK_LINE);
            message->Display();
            showhelp = TRUE;
        }
    }

    DEBUG((D_INFO,(CHAR8*)"Parsed Args.\n"));

    if(showhelp || !drive_already_specified) {
        message->Set(MSG_FORMAT_INFO);
        message->Display();
        message->Set(MSG_FORMAT_COMMAND_LINE_1);
        message->Display();
        message->Set(MSG_FORMAT_COMMAND_LINE_2);
        message->Display();
        message->Set(MSG_FORMAT_COMMAND_LINE_4);
        message->Display();
        message->Set(MSG_FORMAT_SLASH_V);
        message->Display();
        message->Set(MSG_FORMAT_SLASH_Q);
        message->Display();
        message->Set(MSG_FORMAT_SLASH_F);
        message->Display();
        message->Set(MSG_FORMAT_SUPPORTED_SIZES);
        message->Display();

        return 1;
    }

    textmode_output = TRUE;

#if 0 // Shouldn't limit the cluster size as long as it is reasonable.
    if (cluster_size != 0 && cluster_size != 512 && cluster_size != 1024 &&
        cluster_size != 2048 && cluster_size != 4096) {

        message->Set(MSG_UNSUPPORTED_PARAMETER);
        message->Display();

        DeRegister( argc, argv );

        return 1;
    }
#endif
    DEBUG((D_INFO,(CHAR8*)"Determining file system type.\n"));

    if (0 == file_system_name.QueryChCount()) {

        // attempt to get the current filesystem type from disk

        if (!IFS_SYSTEM::QueryFileSystemName(&drive_name, &file_system_name, &result, NULL)) {

            message->Set( MSG_FS_NOT_DETERMINED );
            message->Display( "%W", &drive_name );

            DEBUG((D_ERROR,(CHAR8*)"Unable to determine file system type.\n"));

            if(result != 0) {
                message->Set(MSG_CANT_DASD);
                message->Display();
            }

            return 1;
        }
        file_system_name.Strupr();
    }

    if (!fat_name.Initialize("FAT") ||
        !fat32_name.Initialize("FAT32") ||
        !raw_name.Initialize("RAW") ) {

        return 1;
    }

    file_system_name.Strupr();

    //
    // If compression is requested, make sure it's available.
    //
#if 0
    if (compress) {

        message->Set(MSG_COMPRESSION_NOT_AVAILABLE);
        message->Display("%W", &file_system_name);
        return 1;
    }
#endif

    DEBUG((D_INFO,(CHAR8*)"Init DP_DRIVE.\n"));
    if (!dp_drive->Initialize(&drive_name, message)) {
        DEBUG((D_ERROR,(CHAR8*)"Failed Init DP_DRIVE.\n"));
        return 1;
    }
    DEBUG((D_INFO,(CHAR8*)"Init DP_DRIVE success.\n"));

    message->Set(MSG_WARNING_FORMAT);
    message->Display("%W", &drive_name);
    if (!message->IsYesResponse(FALSE)) {
        return 5;
    }

    if (dp_drive->IsFloppy()) {
        DEBUG((D_INFO,(CHAR8*)"**** Is a floppy.\n"));
//        return 1; BUGBUG should i fail this?
    }

    //
    // Print the "formatting <size>" message.
    //

    if (quick) {
        message->Set(MSG_QUICKFORMATTING_MB);
    } else {
        message->Set(MSG_FORMATTING_MB);
    }

    if( labelled == FALSE ) {
        plabel = NULL;
    } else {
        plabel = &label;
    }

    DEBUG((D_INFO,(CHAR8*)"QuerySector count.\n"));

    bigint = dp_drive->QuerySectors() * dp_drive->QuerySectorSize() /
        1048576;

    DEBUG((D_INFO,(CHAR8*)"Sector count is %ld.\n",dp_drive->QuerySectors()));
    DEBUG((D_INFO,(CHAR8*)"Sector size is %d.\n",dp_drive->QuerySectorSize()));

    DebugAssert(bigint.GetHighPart() == 0);

    message->Display("%d", bigint.GetLowPart());

#if 0
    PART_DESCRIPTOR partdes;
    UINT32 fatsize;


    // if the user hasn't forced a filesystem
    if( force_filesystem == FALSE ) {
        // if the disk is big enough to put at least FAT16 on it
        if (dp_drive->QuerySectors() >= (ULONG)MinSectorsFat16(dp_drive->QuerySectorSize())) {
            DEBUG((D_INFO,(CHAR8*)"Drive is big enough for FAT16 >= %d.\n",MinSectorsFat16(dp_drive->QuerySectorSize())));
            partdes.SectorCount = (dp_drive->QuerySectors()).GetQuadPart();
            partdes.SectorSize = dp_drive->QuerySectorSize();
            partdes.HeaderCount = HEADER_F16;
            partdes.FatEntrySize = 2;
            partdes.MinClusterCount = MIN_CLUSTER_F16;
            partdes.MaxClusterCount = MAX_CLUSTER_F16;
            partdes.FatType = FAT_TYPE_F16;
            file_system_name.Initialize(fat_name.QueryWSTR());

            // if this disk is big enough for FAT32
            if (dp_drive->QuerySectors() >= (ULONG)MinSectorsFat32(dp_drive->QuerySectorSize())) {
                DEBUG((D_INFO,(CHAR8*)"Drive is big enough for FAT32 >= %d\n",MinSectorsFat32(dp_drive->QuerySectorSize())));
                partdes.SectorCount = (dp_drive->QuerySectors()).GetQuadPart();
                partdes.SectorSize = dp_drive->QuerySectorSize();
                partdes.HeaderCount = HEADER_F32;
                partdes.FatEntrySize = 4;
                partdes.MinClusterCount = MIN_CLUSTER_F32;
                partdes.MaxClusterCount = MAX_CLUSTER_F32;
                partdes.FatType = FAT_TYPE_F32;
                file_system_name.Initialize(fat32_name.QueryWSTR());
            }

            // if the user hasn't forced a cluster size, select an appropriate one for him
            if( cluster_size==0 ) {
                PickClusterSize(&partdes,(UINT32*)&cluster_size,&fatsize); // note this routine doesn't work for FAT12

                cluster_size = cluster_size * dp_drive->QuerySectorSize(); // PickClusterSize return cluster size in sectors
                DEBUG((D_INFO,(CHAR8*)"User hasn't forced a cluster size, picking %d\n",cluster_size));
            }
        } else {
            // do the default, which is going to be FAT12 and whatever regular format picks.
            file_system_name.Initialize(fat_name.QueryWSTR());
        }
    } else {
        // if the drive is big enough for FAT16
        if (dp_drive->QuerySectors() >= (ULONG)MinSectorsFat16(dp_drive->QuerySectorSize())) {
            // the user forced a file system, did he force a cluster size?
            if( cluster_size==0 ) {
                // nope, setup and pick a good size
                partdes.SectorCount = (dp_drive->QuerySectors()).GetQuadPart();
                partdes.SectorSize = dp_drive->QuerySectorSize();

                if(file_system_name == fat_name) {
                    partdes.HeaderCount = HEADER_F16;
                    partdes.FatEntrySize = 2;
                    partdes.MinClusterCount = MIN_CLUSTER_F16;
                    partdes.MaxClusterCount = MAX_CLUSTER_F16;
                    partdes.FatType = FAT_TYPE_F16;
                } else if(file_system_name == fat32_name){
                    partdes.HeaderCount = HEADER_F32;
                    partdes.FatEntrySize = 4;
                    partdes.MinClusterCount = MIN_CLUSTER_F32;
                    partdes.MaxClusterCount = MAX_CLUSTER_F32;
                    partdes.FatType = FAT_TYPE_F32;
                }
                PickClusterSize(&partdes,(UINT32*)&cluster_size,&fatsize); // note this routine doesn't work for FAT12
                cluster_size = cluster_size * dp_drive->QuerySectorSize(); // PickClusterSize return cluster size in sectors
                DEBUG((D_INFO,(CHAR8*)"FS type forced, user hasn't forced a cluster size, picking %d\n",cluster_size));
            }
        }
    }
#endif

    if (file_system_name == fat_name || file_system_name == fat32_name) {

        BOOLEAN old_fat_vol = TRUE;

        DEBUG((D_INFO,(CHAR8*)"This is an old FAT volume.\n"));

        if( file_system_name == fat32_name ) {
            old_fat_vol = FALSE;
        }

        if( !(fat_volume = NEW FAT_VOL) ||
            NoError != fat_volume->Initialize( &drive_name, message, FALSE, !quick,
                Unknown )) {
            DEBUG((D_ERROR,(CHAR8*)"fat_volume init failed.\n"));
            //return 1;
        }

        DEBUG((D_INFO,(CHAR8*)"fat_volume init succeeded.\n"));

        success = fat_volume->Format(plabel,
                                     message,
                                     old_fat_vol ? FORMAT_BACKWARD_COMPATIBLE : 0,
                                     cluster_size);

        DEBUG((D_INFO,(CHAR8*)"Format return code: %d\n", success));

        DELETE( fat_volume );

    } else {

        DEBUG((D_ERROR,(CHAR8*)"fs not supported.\n"));

        message->Set( MSG_FS_NOT_SUPPORTED );
        message->Display( "%s%W", "EFIFMT", &file_system_name);

        return 1;
    }

    return (success != NoError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efichk\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_NOLIBS=1

MAJORCOMP=ntos
MINORCOMP=efi

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

TARGETNAME=efichk
TARGETPATH=obj
TARGETTYPE=LIBRARY

386_STDCALL=0

UMENTRYABS=InitializeEfiChkApplication

MSC_WARNING_LEVEL=/W3

#must set /Gs1048576 to disable stkchk in EFI
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Gs1048576

SOURCES=\
    ..\efichk.cxx \
    ..\efichk.rc

INCLUDES=\
    ..\..\efilib\src;\
    ..\..\efilib\src\$(ALT_PROJECT);\
    ..\..\efilib\efiinc;\
    ..\..\efilib\inc;\
    $(EFI_ROOT)\inc;\
!if $(IA64)
                $(EFI_ROOT)\inc\ia64;\
!else
                $(EFI_ROOT)\inc\ia32;\
!endif
    $(EFI_ROOT)\shell\inc

CXX_FLAGS=+d

C_DEFINES=-DCONDITION_HANDLING=1 -D_EFICHECK_=1 -DUNICODE=1

!if "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
C_DEFINES=$(C_DEFINES) -DEFI_DEBUG=1
!endif

UMTYPE=console

DLLDEF=

SOURCES_USED=..\sources.inc

NTTARGETFILES=$(O)\$(TARGETNAME).efi
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efifmt\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_NOLIBS=1

MAJORCOMP=ntos
MINORCOMP=efi

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

TARGETNAME=efifmt
TARGETPATH=obj
TARGETTYPE=LIBRARY

386_STDCALL=0

UMENTRYABS=InitializeEfiFmtApplication

MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Gs1048576

SOURCES=..\efifmt.cxx ..\efifmt.rc

INCLUDES=       ..\..\efilib\src; \
                ..\..\efilib\src\$(ALT_PROJECT); \
                ..\..\efilib\efiinc; \
                ..\..\efilib\inc ; \
                $(EFI_ROOT)\inc; \
!if $(IA64)
                $(EFI_ROOT)\inc\ia64;\
!else
                $(EFI_ROOT)\inc\ia32;\
!endif
                $(EFI_ROOT)\shell\inc

C_DEFINES=-DCONDITION_HANDLING=1 -D_EFICHECK_=1 -DUNICODE=1

!if "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
C_DEFINES=$(C_DEFINES) -DEFI_DEBUG=1
!ENDIF

UMTYPE=console

DLLDEF=

W32_SB=1
SOURCES_USED=..\sources.inc

NTTARGETFILES=$(O)\$(TARGETNAME).efi
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efifmt\usa\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

!if $(IA64)
LIBSRC=sal64
MACH=IA64
!else
LIBSRC=nt32
MACH=x86
!endif

OBJS=$(O)\$(TARGETNAME).obj \
     $(O)\$(TARGETNAME).res

EFI_LIBS=..\..\efilib\src\$(ALT_PROJECT)\$(TARGETPATH)\$(TARGET_DIRECTORY)\efilib.lib \
         $(EFI_ROOT)\build\$(LIBSRC)\output\lib\lib.lib \
!if $(IA64)
         $(EFI_ROOT)\build\$(LIBSRC)\output\shell\lib\lib.lib
!else
         $(EFI_ROOT)\build\$(LIBSRC)\output\shell\lib\lib.lib \
         $(SDK_LIB_PATH)\int64.lib
!endif

$(O)\link.rsp : makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:$(MACH)
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:InitializeEfiFmtApplication
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_LIB_IGNORE_FLAG)
$(EFI_LIBS)
$(OBJS)
<<NOKEEP


$(O)\$(TARGETNAME).efi: $(OSLOADER) makefile.inc $(O)\link.rsp
    -link -out:$@ @$(O)\link.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\efisrc\cache.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    cache.cxx

--*/
#include <pch.cxx>
#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "cache.hxx"

#include "efimisc.hxx"
#include <efilib.h>

DEFINE_CONSTRUCTOR( CACHE, OBJECT );


CACHE::~CACHE(
    )
/*++

Routine Description:

    Destructor for CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
CACHE::Construct(
    )
/*++

Routine Description:

    This routine initializes this class to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buffer = NULL;
    _block_number = NULL;
    _inuse = NULL;
    _num_blocks = 0;
    _block_size = 0;
    _next_add = 0;
    _next_add_inuse = 0;
    _timeout.QuadPart = 0;
}


VOID
CACHE::Destroy(
    )
/*++

Routine Description:

    This routine returns this object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG   i;

    for (i = 0; i < _num_blocks; i++) {
        FREE(_buffer[i]);
    }
    DELETE(_buffer);
    DELETE(_block_number);
    FREE(_inuse);

    _num_blocks = 0;
    _block_size = 0;
    _next_add = 0;
    _next_add_inuse = 0;
    _timeout.QuadPart = 0;
}


BOOLEAN
CACHE::Initialize(
    IN  ULONG   BlockSize,
    IN  ULONG   MaximumNumberOfBlocks
    )
/*++

Routine Description:

    This routine initializes this object to a valid initial state.

Arguments:

    BlockSize               - Supplies the size of the cache blocks.
    MaximumNumberOfBlocks   - Supplies the maximum number of cache blocks.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i;

    Destroy();

    _num_blocks = MaximumNumberOfBlocks;
    _block_size = BlockSize;

    if (!(_buffer = NEW PVOID[_num_blocks]) ||
        !(_block_number = NEW BIG_INT[_num_blocks]) ||
        !(_inuse = (LONG *)MALLOC(_num_blocks*sizeof(LONG)))) {

        Destroy();
        return FALSE;
    }

    for (i = 0; i < _num_blocks; i++) {

        _buffer[i] = NULL;
        _block_number[i] = -1;
        _inuse[i] = 0;
    }

    for (i = 0; i < _num_blocks; i++) {

        if (!(_buffer[i] = MALLOC((UINT) _block_size))) {

            Destroy();
            return FALSE;
        }
    }

    _timeout.QuadPart = -10000;

    return TRUE;
}


BOOLEAN
CACHE::Read(
    IN  BIG_INT BlockNumber,
    OUT PVOID   Buffer
    ) CONST
/*++

Routine Description:

    This routine searches the cache for the requested block and
    copies it to the buffer if it is available.  If the block is
    not available then this routine will return FALSE.

Arguments:

    BlockNumber - Supplies the number of the block requested.
    Buffer      - Returns the buffer for the block requested.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   i;
    LONG    final_value;

    for (i = 0; i < _num_blocks; i++) {

        while (InterlockedCompareExchange(&_inuse[i], 1, 0) != 0) {
            BS->Stall(_timeout.LowPart); // BUGBUG this has ramifications on IA64 right?
        }

        if (BlockNumber == _block_number[i]) {

            memcpy(Buffer, _buffer[i], (UINT) _block_size);
            final_value = InterlockedDecrement(&_inuse[i]);
            DebugAssert(final_value == 0);
            return TRUE;
        }


        final_value = InterlockedDecrement(&_inuse[i]);
        DebugAssert(final_value == 0);

    }

    return FALSE;
}


VOID
CACHE::AddBlock(
    IN  BIG_INT BlockNumber,
    IN  PCVOID  Buffer
    )
/*++

Routine Description:

    This routine adds a new block to the cache.  This will remove the
    oldest existing block out of the cache.

Arguments:

    BlockNumber - Supplies the block number of the new block.
    Buffer      - Supplies the buffer for the new block.

Return Value:

    None.

--*/
{
    LONG    final_value;

    while (InterlockedCompareExchange(&_next_add_inuse, 1, 0) != 0) {
        BS->Stall(_timeout.LowPart); // BUGBUG ramifications for IA64?
    }

    while (InterlockedCompareExchange(&_inuse[_next_add], 1, 0) != 0) {
        BS->Stall(_timeout.LowPart); // BUGBUG ramifications for IA64?
    }

    memcpy(_buffer[_next_add], Buffer, (UINT) _block_size);
    _block_number[_next_add] = BlockNumber;

    final_value = InterlockedDecrement(&_inuse[_next_add]);
    DebugAssert(final_value == 0);

    _next_add = (_next_add + 1) % _num_blocks;

    final_value = InterlockedDecrement(&_next_add_inuse);
    DebugAssert(final_value == 0);
}


VOID
CACHE::Empty(
    )
/*++

Routine Description:

    This routine eliminates all of the blocks from the cache.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG   i;
    LONG    final_value;

    for (i = 0; i < _num_blocks; i++) {

        while (InterlockedCompareExchange(&_inuse[i], 1, 0) != 0) {
            BS->Stall(_timeout.LowPart); // BUGBUG ramifications for IA64?
        }

        _block_number[i] = -1;

        final_value = InterlockedDecrement(&_inuse[i]);
        DebugAssert(final_value == 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\efisrc\basesys.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    basesys.cxx

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "basesys.hxx"

ULIB_EXPORT
BOOLEAN
BASE_SYSTEM::QueryResourceString(
    OUT PWSTRING    ResourceString,
    IN  MSGID       MsgId,
    IN  PCSTR       Format ...
    )
/*++

Routine Description:

    This routine computes the resource string identified by the resource
    identifier 'MsgId'.  In addition to the 'printf' format strings
    supported, 'QueryResourceString' supports :

        1. '%W' - Expects a pointer to a WSTRING.

Arguments:

    ResourceString  - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
    Format          - Supplies a 'printf' style format descriptor for the
                        arguments to the resource string.
    ...             - Supplies the arguments to the resource string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    va_list ap;
    BOOLEAN r;

    va_start(ap, Format);
    r = QueryResourceStringV(ResourceString, MsgId, Format, ap);
    va_end(ap);

    return r;
}


ULIB_EXPORT
BOOLEAN
BASE_SYSTEM::QueryResourceStringV(
    OUT PWSTRING    ResourceString,
    IN  MSGID       MsgId,
    IN  PCSTR       Format,
    IN  va_list     VarPointer
    )
/*++

Routine Description:

    This is a 'varargs' implementation of 'QueryResourceString'.

Arguments:

    ResourceString  - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
    Format          - Supplies a 'printf' style format descriptor for the
                        arguments to the resource string.
    VarPointer      - Supplies a varargs pointer to the arguments of the
                        resource string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
#define NUMBER_OF_ARGS      20

    STATIC HANDLE   lib_handle = 0;
    PWSTR           args[NUMBER_OF_ARGS];
    WSTR            fmt[20];
    INT             i, j;
    PWSTR           p;
    PWSTRING        gstring;
    DSTRING         UnicodeFormat;
    WSTR            display_buffer[4096];
    BOOL            found;
    NTSTATUS        Status;
    ULONG           Result;

    for (i = 0; i < NUMBER_OF_ARGS; i++) {
        args[i] = NULL;
    }

    if (!UnicodeFormat.Initialize(Format)) {
        return FALSE;
    }

    // convert args into an array for RtlFormatMessage.
    i = 0;
    for (p = (PWSTR) UnicodeFormat.GetWSTR(); *p; p++) {

        // if we have a %
        if (*p == '%') {

            // perform W substitutions
            if (*(p + 1) == 'W') {

                p++;
                gstring = va_arg(VarPointer, PWSTRING);
                gstring->QueryWSTR(0, TO_END, display_buffer, 4096);

            } else {
                // convert other substutitions as appropriate by building a fmt string
                j = 0;
                // copy the %
                fmt[j++] = *p++;
                // copy the next character as long at its not a % and not NULL
                while (*p && *p != '%') {
                    if ((*p == 's') && *(p - 1) != 'w') {
                        //if its an ANSI string
                        fmt[j++] = L'a';
                        p++;
                        continue;
                    } else if ((*p == 'c') && *(p - 1) != 'w') {
                        // if its an ANSI character
                        fmt[j++] = L'c'; // BUGBUG hack for now
                        p++;
                        continue;
                    } else if ((*p == 'w' ) && *(p + 1) == 's') {
                        // if its a wide string (%ws->%s)
                        fmt[j++] = L's';
                        p++;
                        p++; // skip the second char
                        continue;
                    } else if ((*p == 'w' ) && *(p + 1) == 'c') {
                        // if its a wide char (%wc->%c)
                        fmt[j++] = L'c';
                        p++;
                        p++; // skip the second char
                        continue;
                    } else if ((*p == 'u' )) {
                        // BUGBUG sprint doesn't seem to work with %u, replace with %d
                        fmt[j++] = L'd';
                        p++;
                    } else if (isdigit(*p)) {
                        // BUGBUG: HACK we skip digit format stuff since Sprint doesn't seem to like em.
                        p++;
                    } else {
                        // otherwise just copy the format indicator
                        fmt[j++] = *p++;
                    }
                }
                p--;
                fmt[j] = 0;

                if (wcsncmp(fmt, TEXT("%I64"), 4) == 0) {
                    // if its a 64 bit integer
                    // do some special stuff to handle LARGE_INTEGERS before telling SPrint to do its thing.
                    ULONGLONG t = (va_arg(VarPointer,LARGE_INTEGER)).QuadPart;
                    fmt[0]='%';
                    fmt[1]='l';
                    fmt[2]='d';
                    fmt[3]=NULL;
//                    Print(L"QueryResourceStringV: fmt: %s\n",fmt);
                    SPrint(display_buffer, 4096, fmt, t);
                } else {
                    // otherwise tell SPrint to do its thing
                    PVOID   voidptr = va_arg(VarPointer, PVOID);
//                    Print(L"QueryResourceStringV: fmt: %s\n",fmt);
                    SPrint(display_buffer, 4096,fmt,voidptr );
                }
            }

            // allocate a buffer and copy the converted string into it.
            args[i] = (PWSTR)MALLOC(wcslen(display_buffer) * sizeof(WCHAR) + sizeof(WCHAR));
            if (NULL == args[i]) {
                return FALSE;
            }
            wcscpy( args[i], display_buffer);

//            Print(L"QueryResourceStringV: args[%d]: %s\n",i,args[i]);

            i++;
        }
    }

    found = FALSE;
    // locate the right message in our table
    for(i=0;i<EFI_MESSAGE_COUNT;i++) {
        if(MessageTable[i].msgId == MsgId ){
            found = TRUE;
            break;
        }
    }

    if (found == FALSE) {
        return FALSE;
    }

    WCHAR *MessageFormat = MessageTable[i].string;

    // shove it through RtlFormatMessage.
    Status = RtlFormatMessage( MessageFormat,
                               0,
                               FALSE,
                               FALSE,
                               TRUE,
                               (va_list *)args,
                               (PWSTR)display_buffer,
                               sizeof( display_buffer ),
                               &Result
                             );

    for (i = 0; i < NUMBER_OF_ARGS; i++) {
        FREE(args[i]);
    }

    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    return ResourceString->Initialize(display_buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\efisrc\efimessages.cxx ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    efimessages.cxx

--*/
#include "pch.cxx"

#include "efimessages.hxx"

//
// If you change this table, please update the message count EFI_MESSAGE_COUNT
// in efimessages.hxx
//

EFI_MESSAGE MessageTable[] = {
{
    MSG_CONVERT_LOST_CHAINS,
    TEXT("Convert lost chains to files (Y/N)? %0")
},

{
    MSG_CHK_ERROR_IN_DIR,
    TEXT("Unrecoverable error in folder %1.")
},

{
    MSG_CHK_CONVERT_DIR_TO_FILE,
    TEXT("Convert folder to file (Y/N)? %0")
},

{
    MSG_TOTAL_DISK_SPACE,
    TEXT("%1 bytes total disk space.")
},

{
    MSG_BAD_SECTORS,
    TEXT("%1 bytes in bad sectors.")
},

{
    MSG_HIDDEN_FILES,
    TEXT("%1 bytes in %2 hidden files.")
},

{
    MSG_DIRECTORIES,
    TEXT("%1 bytes in %2 folders.")
},

{
    MSG_USER_FILES,
    TEXT("%1 bytes in %2 files.")
},

{
    MSG_RECOVERED_FILES,
    TEXT("%1 bytes in %2 recovered files.")
},

{
    MSG_WOULD_BE_RECOVERED_FILES,
    TEXT("%1 bytes in %2 recoverable files.")
},

{
    MSG_AVAILABLE_DISK_SPACE,
    TEXT("%1 bytes available on disk.")
},

{
    MSG_TOTAL_MEMORY,
    TEXT("%1 total bytes memory.")
},

{
    MSG_AVAILABLE_MEMORY,
    TEXT("%1 bytes free.")
},

{
    MSG_CHK_CANT_NETWORK,
    TEXT("EFI cannot check a disk attached through a network.")
},

{
    MSG_1014,
    TEXT("EFI cannot check a disk that is substituted or\nassigned using the SUBST or ASSIGN command.")
},

{
    MSG_PROBABLE_NON_DOS_DISK,
    TEXT("The specified disk appears to be a non-EFI disk.\nDo you want to continue? (Y/N) %0")
},

{
    MSG_DISK_ERROR_READING_FAT,
    TEXT("An error occurred while reading the file allocation table (FAT %1).")
},

{
    MSG_DIRECTORY,
    TEXT("Folder %1.")
},

{
    MSG_CONTIGUITY_REPORT,
    TEXT("%1 contains %2 non-contiguous blocks.")
},

{
    MSG_ALL_FILES_CONTIGUOUS,
    TEXT("All specified files are contiguous.")
},

{
    MSG_CORRECTIONS_WILL_NOT_BE_WRITTEN,
    TEXT("EFI found errors on the disk, but will not fix them\nbecause disk checking was run without the /F (fix) parameter.")
},

{
    MSG_BAD_FAT_DRIVE,
    TEXT("The file allocation table (FAT) on disk %1 is corrupted.")
},

{
    MSG_BAD_FIRST_UNIT,
    TEXT("%1  first allocation unit is not valid. The entry will be truncated.")
},

{
    MSG_CHK_DONE_CHECKING,
    TEXT("File and folder verification is complete.")
},

{
    MSG_DISK_TOO_LARGE_TO_CONVERT,
    TEXT("The volume is too large to convert.")
},
{
    MSG_CONV_NTFS_CHKDSK,
    TEXT("The volume may have inconsistencies. Run Chkdsk, the disk checking utility.")
},

{
    MSG_1028,
    TEXT("An allocation error occurred. The file size will be adjusted.")
},

{
    MSG_1029,
    TEXT("Cannot recover .. entry, processing continued.")
},

{
    MSG_1030,
    TEXT("Folder is totally empty, no . or ..")
},

{
    MSG_1031,
    TEXT("Folder is joined.")
},

{
    MSG_1032,
    TEXT("Cannot recover .. entry.")
},

{
    MSG_BAD_LINK,
    TEXT("The %1 entry contains a nonvalid link.")
},

{
    MSG_BAD_ATTRIBUTE,
    TEXT("EFI has found an entry that contains a nonvalid attribute.")
},

{
    MSG_BAD_FILE_SIZE,
    TEXT("The size of the %1 entry is not valid.")
},

{
    MSG_CROSS_LINK,
    TEXT("%1 is cross-linked on allocation unit %2.")
}
,
{
    MSG_1037,
    TEXT("EFI cannot find the %1 folder.\nDisk check cannot continue past this point in the folder structure.")
},

{
    MSG_1038,
    TEXT("The folder structure past this point cannot be processed.")
},

{
    MSG_BYTES_FREED,
    TEXT("%1 bytes of free disk space added.")
},

{
    MSG_BYTES_WOULD_BE_FREED,
    TEXT("%1 bytes of free disk space would be added.")
},

{
    // date is !!not!! displayed for EFI, since timeinfo is not implemented.
    MSG_VOLUME_LABEL_AND_DATE,
    TEXT("Volume label %1")
},

{
    MSG_TOTAL_ALLOCATION_UNITS,
    TEXT("%1 total allocation units on disk.")
},

{
    MSG_BYTES_PER_ALLOCATION_UNIT,
    TEXT("%1 bytes in each allocation unit.")
},

{
    MSG_1044,
    TEXT("Disk checking is not available on disk %1.")
},

{
    MSG_1045,
    TEXT("A nonvalid parameter was specified.")
},

{
    MSG_PATH_NOT_FOUND,
    TEXT("The specified path was not found.")
},

{
    MSG_FILE_NOT_FOUND,
    TEXT("The %1 file was not found.")
},

{
    MSG_LOST_CHAINS,
    TEXT("%1 lost allocation units were found in %2 chains.")
},

{
    MSG_BLANK_LINE,
    TEXT("")
},

{
    MSG_1050,
    TEXT("The CHDIR command cannot switch to the root folder.")
},

{
    MSG_BAD_FAT_WRITE,
    TEXT("A disk error occurred during writing of the file allocation table.")
},

{
    MSG_ONE_STRING,
    TEXT("%1.")
},

{
    MSG_ONE_STRING_NEWLINE,
    TEXT("%1")
},

{
    MSG_NO_ROOM_IN_ROOT,
    TEXT("The root folder on this volume is full. To perform a disk check,\nEFI requires space in the root folder. Remove some files\nfrom this folder, then run disk checking again.")
},

{
    MSG_1056,
    TEXT("%1 %2 %3.")
},

{
    MSG_1057,
    TEXT("%1 %2, %3.")
},

{
    MSG_1058,
    TEXT("%1%2%3%4%5.")
},

{
    MSG_1059,
    TEXT("%1%2%3%4.")
},

{
    MSG_UNITS_ON_DISK,
    TEXT("%1 available allocation units on disk.")
},

{
    MSG_1061,
    TEXT("EFI disk checking cannot fix errors (/F) when run from an\nMS-DOS window. Try again from the EFI shell or command prompt.")
},

{
    MSG_CHK_NO_MEMORY,
    TEXT("An unspecified error occurred.")
},

{
    MSG_HIDDEN_STATUS,
    TEXT("This never gets printed.")
},

{
    MSG_CHK_USAGE_HEADER,
    TEXT("Checks a disk and displays a status report.")
},

{
    MSG_CHK_COMMAND_LINE,
    TEXT("EFICHK [/F] [/R] volume")
},

{
    MSG_CHK_DRIVE,
    TEXT("  volume          Specifies the EFI volume without a colon. Example: fs0")
},

{
    MSG_CHK_USG_FILENAME,
    TEXT("filename        FAT only: Specifies the files to check for fragmentation.")
},

{
    MSG_CHK_F_SWITCH,
    TEXT("  /F              Fixes errors on the disk.")
},

{
    MSG_CHK_V_SWITCH,
    TEXT(
"  /R              Locates bad sectors and recovers readable information\n\
                  (implies /F)."
        )
},

{
    MSG_WITHOUT_PARAMETERS,
    TEXT("To check the current disk, type CHKDSK with no parameters.")
},

{
    MSG_CHK_CANT_CDROM,
    TEXT("EFI cannot run disk checking on CD-ROM and DVD-ROM drives.")
},

{
    MSG_CHK_RUNNING,
    TEXT("Checking file system on %1")
},

{
    MSG_CHK_VOLUME_CLEAN,
    TEXT("The volume is clean.")
},

{
    MSG_CHK_TRAILING_DIRENTS,
    TEXT("Removing trailing folder entries from %1")
},

{
    MSG_CHK_BAD_CLUSTERS_IN_FILE_SUCCESS,
    TEXT("EFI replaced bad clusters in file %1\nof name %2.")
},

{
    MSG_CHK_BAD_CLUSTERS_IN_FILE_FAILURE,
    TEXT("The disk does not have enough space to replace bad clusters\ndetected in file %1 of name %2.")
},

{
    MSG_CHK_RECOVERING_FREE_SPACE,
    TEXT("EFI is verifying free space...")
},

{
    MSG_CHK_DONE_RECOVERING_FREE_SPACE,
    TEXT("Free space verification is complete.")
},

{
    MSG_CHK_CHECKING_FILES,
    TEXT("EFI is verifying files and folders...")
},

{
    MSG_CHK_CANNOT_UPGRADE_DOWNGRADE_FAT,
    TEXT("EFI cannot upgrade this FAT volume.")
},

{
    MSG_CHK_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH,
    TEXT("The specified volume name does not have a mount point or drive letter.")
},

{
    MSG_CHK_VOLUME_IS_DIRTY,
    TEXT("The volume is dirty.")
},

{
    MSG_CHK_ON_REBOOT,
    TEXT("Do you want to schedule EFI to check your disk the next time\nyou start your computer? (Y/N) %0")
},

{
    MSG_CHK_VOLUME_SET_DIRTY,
    TEXT("EFI will check your disk the next time you start\nyour computer.")
},

{
    MSG_CHK_BOOT_PARTITION_REBOOT,
    TEXT("EFI has finished checking your disk.\nPlease wait while your computer restarts.")
},

{
    MSG_CHK_BAD_LONG_NAME,
    TEXT("Removing nonvalid long folder entry from %1...")
},

{
    MSG_CHK_CHECKING_VOLUME,
    TEXT("Now checking %1...")
},

{
    MSG_CHK_BAD_LONG_NAME_IS,
    TEXT("Removing orphaned long folder entry %1...")
},

{
    MSG_CHK_WONT_ZERO_LOGFILE,
    TEXT("The log file size must be greater than 0.")
},

{
    MSG_CHK_LOGFILE_NOT_NTFS,
    TEXT("EFI can set log file size on NTFS volumes only.")
},

{
    MSG_CHK_BAD_DRIVE_PATH_FILENAME,
    TEXT("The drive, the path, or the file name is not valid.")
},

{
    MSG_KILOBYTES_IN_USER_FILES,
    TEXT("%1 KB in %2 files.")
},

{
    MSG_KILOBYTES_IN_DIRECTORIES,
    TEXT("%1 KB in %2 folders.")
},

{
    MSG_KILOBYTES_IN_HIDDEN_FILES,
    TEXT("%1 KB in %2 hidden files.")
},

{
    MSG_KILOBYTES_IN_WOULD_BE_RECOVERED_FILES,
    TEXT("%1 KB in %2 recoverable files.")
},

{
    MSG_KILOBYTES_IN_RECOVERED_FILES,
    TEXT("%1 KB in %2 recovered files.")
},

{
    MSG_CHK_ABORT_AUTOCHK,
    TEXT("To skip disk checking, press any key within %1 seconds. %r%0")
},

{
    MSG_CHK_AUTOCHK_ABORTED,
    TEXT("Disk checking has been cancelled.                       %b")
},

{
    MSG_CHK_AUTOCHK_RESUMED,
    TEXT("EFI will now check the disk.                        %b")
},

{
    MSG_KILOBYTES_FREED,
    TEXT("%1 KB of free disk space added.")
},

{
    MSG_KILOBYTES_WOULD_BE_FREED,
    TEXT("%1 KB of free disk space would be added.")
},

{
    MSG_CHK_SKIP_INDEX_NOT_NTFS,
    TEXT("The /I option functions only on NTFS volumes.")
},

{
    MSG_CHK_SKIP_CYCLE_NOT_NTFS,
    TEXT("The /C option functions only on NTFS volumes.")
},

{
    MSG_CHK_AUTOCHK_COMPLETE,
    TEXT("EFI has finished checking the disk.")
},

{
    MSG_CHK_AUTOCHK_SKIP_WARNING,
    TEXT("One of your disks needs to be checked for consistency. You\nmay cancel the disk check, but it is strongly recommended\nthat you continue.")
},

{
    MSG_CHK_USER_AUTOCHK_SKIP_WARNING,
    TEXT("A disk check has been scheduled.")
},

{
    MSG_CHK_UNABLE_TO_TELL_IF_SYSTEM_DRIVE,
    TEXT("EFI was unable to determine if the specified volume is a system volume.")
},

{
    MSG_CHK_NO_PROBLEM_FOUND,
    TEXT("EFI has checked the file system and found no problem.")
},

{
    MSG_CHK_ERRORS_FIXED,
    TEXT("EFI has made corrections to the file system.")
},

{
    MSG_CHK_NEED_F_PARAMETER,
    TEXT("EFI found problems with the file system.\nRun CHKDSK with the /F (fix) option to correct these.")
},

{
    MSG_CHK_ERRORS_NOT_FIXED,
    TEXT("EFI found problems with the file system that could not be corrected.")
},

{
    MSG_PERCENT_COMPLETE,
    TEXT("%1 percent completed.               %r%0")
},

{
    MSG_PERCENT_COMPLETE2,
    TEXT("%1 percent completed.%2             %r%0")
},

{
    MSG_FORMAT_COMPLETE,
    TEXT("Format complete.                        %b")
},

{
    MSG_INSERT_DISK,
    TEXT("Insert new disk for drive %1")
},

{
    MSG_REINSERT_DISKETTE,
    TEXT("Reinsert disk for drive %1:")
},

{
    MSG_BAD_IOCTL,
    TEXT("Error in IOCTL call.")
},

{
    MSG_CANT_DASD,
    TEXT("Cannot open volume for direct access.")
},

{
    MSG_CANT_WRITE_FAT,
    TEXT("Error writing File Allocation Table (FAT).")
},

{
    MSG_CANT_WRITE_ROOT_DIR,
    TEXT("Error writing folder.")
},

{
    MSG_FORMAT_NO_NETWORK,
    TEXT("Cannot format a network drive.")
},

{
    MSG_UNSUPPORTED_PARAMETER,
    TEXT("Parameters not supported.")
},

{
    MSG_UNUSABLE_DISK,
    TEXT("Invalid media or Track 0 bad - disk unusable.")
},

{
    MSG_BAD_DIR_READ,
    TEXT("Error reading folder %1.")
},

{
    MSG_PRESS_ENTER_WHEN_READY,
    TEXT("and press ENTER when ready... %0")
},

{
    MSG_ENTER_CURRENT_LABEL,
    TEXT("Enter current volume label for drive %1 %0")
},

{
    MSG_INCOMPATIBLE_PARAMETERS_FOR_FIXED,
    TEXT("Parameters incompatible with fixed disk.")
},

{
    MSG_READ_PARTITION_TABLE,
    TEXT("Error reading partition table.")
},

{
    MSG_NOT_SUPPORTED_BY_DRIVE,
    TEXT("Parameters not supported by drive.")
},

{
    MSG_2029,
    TEXT("\n")
},

{
    MSG_2030,
    TEXT("\n")
},

{
    MSG_INSERT_DOS_DISK,
    TEXT("Insert EFI disk in drive %1:")
},

{
    MSG_WARNING_FORMAT,
    TEXT("WARNING, ALL DATA ON EFI DEVICE\n%1 WILL BE LOST!\nProceed with Format (Y/N)? %0")
},

{
    MSG_FORMAT_ANOTHER,
    TEXT("Format another (Y/N)? %0")
},

{
    MSG_WRITE_PARTITION_TABLE,
    TEXT("Error writing partition table.")
},

{
    MSG_INCOMPATIBLE_PARAMETERS,
    TEXT("Parameters not compatible.")
},

{
    MSG_AVAILABLE_ALLOCATION_UNITS,
    TEXT("%1 allocation units available on disk.")
},

{
    MSG_ALLOCATION_UNIT_SIZE,
    TEXT("%1 bytes in each allocation unit.")
},

{
    MSG_PARAMETER_TWICE,
    TEXT("Same parameter entered twice.")
},

{
    MSG_NEED_BOTH_T_AND_N,
    TEXT("Must enter both /t and /n parameters.")
},

{
    MSG_2042,
    TEXT("Trying to recover allocation unit %1.                          %0")
},

{
    MSG_NO_LABEL_WITH_8,
    TEXT("Volume label is not supported with /8 parameter.")
},

{
    MSG_FMT_NO_MEMORY,
    TEXT("Insufficient memory.")
},

{
    MSG_QUICKFMT_ANOTHER,
    TEXT("QuickFormat another (Y/N)? %0")
},

{
    MSG_CANT_QUICKFMT,
    TEXT("Invalid existing format.\nThis disk cannot be QuickFormatted.\nProceed with unconditional format (Y/N)? %0")
},

{
    MSG_FORMATTING_KB,
    TEXT("Formatting %1K")
},

{
    MSG_FORMATTING_MB,
    TEXT("Formatting %1M")
},

{
    MSG_FORMATTING_DOT_MB,
    TEXT("Formatting %1.%2M")
},

{
    MSG_VERIFYING_KB,
    TEXT("Verifying %1K")
},

{
    MSG_VERIFYING_MB,
    TEXT("Verifying %1M")
},

{
    MSG_VERIFYING_DOT_MB,
    TEXT("Verifying %1.%2M")
},

{
    MSG_2060,
    TEXT("Saving UNFORMAT information.")
},

{
    MSG_2061,
    TEXT("Checking existing disk format.")
},

{
    MSG_QUICKFORMATTING_KB,
    TEXT("QuickFormatting %1K")
},

{
    MSG_QUICKFORMATTING_MB,
    TEXT("QuickFormatting %1M")
},

{
    MSG_QUICKFORMATTING_DOT_MB,
    TEXT("QuickFormatting %1.%2M")
},

{
    MSG_FORMAT_INFO,
    TEXT("Formats a disk for use with EFI.\n")
},

{
    MSG_FORMAT_COMMAND_LINE_1,
    TEXT("EFIFMT device [/FS:file-system] [/V:label] [/Q] [/A:size]\n")
},

{
    MSG_FORMAT_COMMAND_LINE_2,
    TEXT("  device          Specifies the EFI device to format without a colon. Example: blk0")
},

{
    MSG_FORMAT_COMMAND_LINE_3,
    TEXT("")
},

{
    MSG_FORMAT_COMMAND_LINE_4,
     TEXT("  /FS:filesystem  Specifies the type of the file system (FAT, FAT32).")
},

{
    MSG_FORMAT_SLASH_V,
    TEXT("  /V:label        Specifies the volume label.")
},

{
    MSG_FORMAT_SLASH_Q,
    TEXT("  /Q              Performs a quick format.")
},

{
    MSG_FORMAT_SLASH_C,
    TEXT("")
},

{
    MSG_FORMAT_SLASH_F,
TEXT(
"  /A:size         Overrides the default allocation unit size. Default settings\n\
                  are STRONGLY recommended for general use.\n"
    )
},

{
    MSG_FORMAT_SUPPORTED_SIZES,
TEXT(
"                  FAT supports 512, 1024, 2048, 4096, 8192, 16K, 32K\n\
                  FAT32 supports 512, 1024, 2048, 4096, 8192, 16K, 32K\n\
\n\
                  Note that the FAT and FAT32 files systems impose the\n\
                  following restrictions on the number of clusters on a volume:\n\
\n\
                  FAT: Number of clusters <= 65526\n\
                  FAT32: 65526 < Number of clusters < 268435446\n\
\n\
                  Format will stop processing if it decides that\n\
                  the above requirements cannot be met using the specified\n\
                  cluster size."
    )
},

{
    MSG_WRONG_CURRENT_LABEL,
    TEXT("An incorrect volume label was entered for this drive.")
},

{
    MSG_FORMAT_SLASH_T,
    TEXT("/T:tracks       Specifies the number of tracks per disk side.")
},

{
    MSG_FORMAT_SLASH_N,
    TEXT("/N:sectors      Specifies the number of sectors per track.")
},

{
    MSG_FORMAT_SLASH_1,
    TEXT("/1              Formats a single side of a floppy disk.")
},

{
    MSG_FORMAT_SLASH_4,
    TEXT(
"/4              Formats a 5.25-inch 360K floppy disk in a \n\
                high-density drive."
    )
},

{
    MSG_FORMAT_SLASH_8,
    TEXT("/8              Formats eight sectors per track.")
},

{
    MSG_FORMAT_SLASH_X,
    TEXT(
"/X              Forces the volume to dismount first if necessary.  All opened\n\
                handles to the volume would no longer be valid.")
},

{
    MSG_FORMAT_NO_CDROM,
    TEXT("Cannot format a CD-ROM drive.")
},

{
    MSG_FORMAT_NO_RAMDISK,
    TEXT("Cannot format a RAM DISK drive.")
},

{
    MSG_FORMAT_PLEASE_USE_FS_SWITCH,
    TEXT("Please use the /FS switch to specify the file system\nyou wish to use on this volume.")
},

{
    MSG_NTFS_FORMAT_FAILED,
    TEXT("Format failed.")
},

{
    MSG_FMT_WRITE_PROTECTED_MEDIA,
    TEXT("Cannot format.  This media is write protected.")
},

{
    MSG_FMT_INSTALL_FILE_SYSTEM,
    TEXT("WARNING!  The %1 file system is not enabled.\nWould you like to enable it (Y/N)? %0")
},

{
    MSG_FMT_FILE_SYSTEM_INSTALLED,
    TEXT("The file system will be enabled when you restart the system.")
},

{
    MSG_FMT_CANT_INSTALL_FILE_SYSTEM,
    TEXT("FORMAT cannot enable the file system.")
},

{
    MSG_FMT_VOLUME_TOO_SMALL,
    TEXT("The volume is too small for the specified file system.")
},

{
    MSG_FMT_CREATING_FILE_SYSTEM,
    TEXT("Creating file system structures.")
},

{
    MSG_FMT_VARIABLE_CLUSTERS_NOT_SUPPORTED,
    TEXT("%1 FORMAT does not support user selected allocation unit sizes.")
},

{
    MSG_DEVICE_BUSY,
    TEXT("The device is busy.")
},

{
    MSG_FMT_DMF_NOT_SUPPORTED_ON_288_DRIVES,
    TEXT("The specified format cannot be mastered on 2.88MB drives.")
},

{
    MSG_HPFS_NO_FORMAT,
    TEXT("FORMAT does not support the HPFS file system type.")
},

{
    MSG_FMT_ALLOCATION_SIZE_CHANGED,
    TEXT("Allocation unit size changed to %1 bytes.")
},

{
    MSG_FMT_ALLOCATION_SIZE_EXCEEDED,
    TEXT("Allocation unit size must be less than or equal to 64K.")
},

{
    MSG_FMT_TOO_MANY_CLUSTERS,
    TEXT("Number of clusters exceeds 32 bits.")
},

{
    MSG_CONV_PAUSE_BEFORE_REBOOT,
    TEXT("Preinstallation completed successfully.  Press any key to\nshut down/reboot.")
},

{
    MSG_CONV_WILL_REBOOT,
    TEXT("Convert will take some time to process the files on the volume.\nWhen this phase of conversion is complete, the computer will restart.")
},

{
    MSG_FMT_FAT_ENTRY_SIZE,
    TEXT("           %1 bits in each FAT entry.")
},

{
    MSG_FMT_CLUSTER_SIZE_MISMATCH,
    TEXT(
"The cluster size chosen by the system is %1 bytes which\ndiffers from the specified cluster size.\n\
Proceed with Format using the cluster size chosen by the\n\
system (Y/N)? %0"
    )
},

{
    MSG_FMT_CLUSTER_SIZE_TOO_SMALL,
    TEXT("The specified cluster size is too small for %1.")
},

{
    MSG_FMT_CLUSTER_SIZE_TOO_BIG,
    TEXT("The specified cluster size is too big for %1.")
},

{
    MSG_FMT_VOL_TOO_BIG,
    TEXT("The volume is too big for %1.")
},

{
    MSG_FMT_VOL_TOO_SMALL,
    TEXT("The volume is too small for %1.")
},

{
    MSG_FMT_ROOTDIR_WRITE_FAILED,
    TEXT("Failed to write to the root folder.")
},

{
    MSG_FMT_INIT_LABEL_FAILED,
    TEXT("Failed to initialize the volume label.")
},

{
    MSG_FMT_INITIALIZING_FATS,
    TEXT("Initializing the File Allocation Table (FAT)...")
},

{
    MSG_FMT_CLUSTER_SIZE_64K,
    TEXT(
"The cluster size for this volume, 64K bytes, may cause application\n\
compatibility problems, particularly with setup applications.\n\
The volume must be less than 2048 MB in size to change this if the\n\
default cluster size is being used.\n\
Proceed with Format using a 64K cluster (Y/N)? %0"
    )
},

{
    MSG_FMT_SECTORS,
    TEXT("Set number of sectors on drive to %1.")
},

{
    MSG_FMT_BAD_SECTORS,
    TEXT("Environmental variable FORMAT_SECTORS error.")
},

{
    MSG_FMT_FORCE_DISMOUNT_PROMPT,
    TEXT(
"Format cannot run because the volume is in use by another\n\
process.  Format may run if this volume is dismounted first.\n\
ALL OPENED HANDLES TO THIS VOLUME WOULD THEN BE INVALID.\n\
Would you like to force a dismount on this volume? (Y/N) %0"
    )
},

{
    MSG_FORMAT_NO_MEDIA_IN_DRIVE,
    TEXT("There is no media in the drive.")
},

{
    MSG_FMT_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH,
    TEXT("The given volume name does not have a mount point or drive letter.")
},

{
    MSG_FMT_INVALID_DRIVE_SPEC,
    TEXT("Invalid drive specification.")
},

{
    MSG_CONV_NO_MOUNT_POINT_FOR_GUID_VOLNAME_PATH,
    TEXT("The given volume name does not have a mount point or drive letter.")
},

{
    MSG_FMT_CLUSTER_SIZE_TOO_SMALL_MIN,
    TEXT("The specified cluster size is too small. The minimum valid\ncluster size value for this drive is %1.")
},

{
    MSG_FMT_FAT32_NO_FLOPPIES,
    TEXT("Floppy disk is too small to hold the FAT32 file system.")
},

{
    MSG_CANT_LOCK_THE_DRIVE,
    TEXT("Cannot lock the drive.  The volume is still in use.")
},

{
    MSG_CANT_READ_BOOT_SECTOR,
    TEXT("Cannot read boot sector.")
},

{
    MSG_VOLUME_SERIAL_NUMBER,
    TEXT("Volume Serial Number is %1-%2")
},

{
    MSG_VOLUME_LABEL_PROMPT,
    TEXT("Volume label (11 characters, ENTER for none)? %0")
},

{
    MSG_INVALID_LABEL_CHARACTERS,
    TEXT("Invalid characters in volume label")
},

{
    MSG_CANT_READ_ANY_FAT,
    TEXT("There are no readable file allocation tables (FAT).")
},

{
    MSG_SOME_FATS_UNREADABLE,
    TEXT("Some file allocation tables (FAT) are unreadable.")
},

{
    MSG_CANT_WRITE_BOOT_SECTOR,
    TEXT("Cannot write boot sector.")
},

{
    MSG_SOME_FATS_UNWRITABLE,
    TEXT("Some file allocation tables (FAT) are unwriteable.")
},

{
    MSG_INSUFFICIENT_DISK_SPACE,
    TEXT("Insufficient disk space.")
},

{
    MSG_TOTAL_KILOBYTES,
    TEXT("%1 KB total disk space.")
},

{
    MSG_AVAILABLE_KILOBYTES,
    TEXT("%1 KB are available.")
},

{
    MSG_NOT_FAT,
    TEXT("Disk not formatted or not FAT.")
},

{
    MSG_REQUIRED_PARAMETER,
    TEXT("Required parameter missing -")
},

{
    MSG_FILE_SYSTEM_TYPE,
    TEXT("The type of the file system is %1.")
},

{
    MSG_NEW_FILE_SYSTEM_TYPE,
    TEXT("The new file system is %1.")
},

{
    MSG_FMT_AN_ERROR_OCCURRED,
    TEXT("An error occurred while running Format.")
},

{
    MSG_FS_NOT_SUPPORTED,
    TEXT("%1 is not available for %2 drives.")
},

{
    MSG_FS_NOT_DETERMINED,
    TEXT("Cannot determine file system of drive %1.")
},

{
    MSG_CANT_DISMOUNT,
    TEXT("Cannot dismount the drive.")
},

{
    MSG_NOT_FULL_PATH_NAME,
    TEXT("%1 is not a complete name.")
},

{
    MSG_YES,
    TEXT("Yes")
},

{
    MSG_NO,
    TEXT("No")
},

{
    MSG_DISK_NOT_FORMATTED,
    TEXT("Disk is not formatted.")
},

{
    MSG_NONEXISTENT_DRIVE,
    TEXT("Specified drive does not exist.")
},

{
    MSG_INVALID_PARAMETER,
    TEXT("Invalid parameter - %1")
},

{
    MSG_INSUFFICIENT_MEMORY,
    TEXT("Out of memory.")
},

{
    MSG_ACCESS_DENIED,
    TEXT("Access denied - %1")
},

{
    MSG_DASD_ACCESS_DENIED,
    TEXT("Access denied.")
},

{
    MSG_CANT_LOCK_CURRENT_DRIVE,
    TEXT("Cannot lock current drive.")
},

{
    MSG_INVALID_LABEL,
    TEXT("Invalid volume label")
},

{
    MSG_DISK_TOO_LARGE_TO_FORMAT,
    TEXT("The disk is too large to format for the specified file system.")
},

{
    MSG_VOLUME_LABEL_NO_MAX,
    TEXT("Volume label (ENTER for none)? %0")
},

{
    MSG_CHKDSK_ON_REBOOT_PROMPT,
    TEXT("Chkdsk cannot run because the volume is in use by another\nprocess.  Would you like to schedule this volume to be\nchecked the next time the system restarts? (Y/N) %0")
},

{
    MSG_CHKDSK_CANNOT_SCHEDULE,
    TEXT("Chkdsk could not schedule this volume to be checked\nthe next time the system restarts.")
},

{
    MSG_CHKDSK_SCHEDULED,
    TEXT("This volume will be checked the next time the system restarts.")
},

{
    MSG_COMPRESSION_NOT_AVAILABLE,
    TEXT("Compression is not available for %1.")
},

{
    MSG_CANNOT_ENABLE_COMPRESSION,
    TEXT("Cannot enable compression for the volume.")
},

{
    MSG_CANNOT_COMPRESS_HUGE_CLUSTERS,
    TEXT("Compression is not supported on volumes with clusters larger than\n4096 bytes.")
},

{
    MSG_CANT_UNLOCK_THE_DRIVE,
    TEXT("Cannot unlock the drive.")
},

{
    MSG_CHKDSK_FORCE_DISMOUNT_PROMPT,
TEXT("Chkdsk cannot run because the volume is in use by another\n\
process.  Chkdsk may run if this volume is dismounted first.\n\
ALL OPENED HANDLES TO THIS VOLUME WOULD THEN BE INVALID.\n\
Would you like to force a dismount on this volume? (Y/N) %0")
},

{
    MSG_VOLUME_DISMOUNTED,
    TEXT("Volume dismounted.  All opened handles to this volume are now invalid.")
},

{
    MSG_CHKDSK_DISMOUNT_ON_REBOOT_PROMPT,
TEXT("Chkdsk cannot dismount the volume because it is a system drive or\n\
there is an active paging file on it.  Would you like to schedule\n\
this volume to be checked the next time the system restarts? (Y/N) %0")
},

{
    MSG_TOTAL_MEGABYTES,
    TEXT("%1 MB total disk space.")
},

{
    MSG_AVAILABLE_MEGABYTES,
    TEXT("%1 MB are available.")
},

{
    MSG_CHK_ERRORS_IN_FAT,
    TEXT("Errors in file allocation table (FAT) corrected.")
},

{
    MSG_CHK_EAFILE_HAS_HANDLE,
    TEXT("Extended attribute file has handle.  Handle removed.")
},

{
    MSG_CHK_EMPTY_EA_FILE,
    TEXT("Extended attribute file contains no extended attributes.  File deleted.")
},

{
    MSG_CHK_ERASING_INVALID_LABEL,
    TEXT("Erasing invalid label.")
},

{
    MSG_CHK_EA_SIZE,
    TEXT("%1 bytes in extended attributes.")
},

{
    MSG_CHK_CANT_CHECK_EA_LOG,
    TEXT("Unreadable extended attribute header.\nCannot check extended attribute log.")
},

{
    MSG_CHK_BAD_LOG,
    TEXT("Extended attribute log is unintelligible.\nIgnore log and continue? (Y/N) %0")
},

{
    MSG_CHK_UNUSED_EA_PORTION,
    TEXT("Unused, unreadable, or unwriteable portion of extended attribute file removed.")
},

{
    MSG_CHK_EASET_SIZE,
    TEXT("Total size entry for extended attribute set at cluster %1 corrected.")
},

{
    MSG_CHK_EASET_NEED_COUNT,
    TEXT("Need count entry for extended attribute set at cluster %1 corrected.")
},

{
    MSG_CHK_UNORDERED_EA_SETS,
    TEXT("Extended attribute file is unsorted.\nSorting extended attribute file.")
},

{
    MSG_CHK_NEED_MORE_HEADER_SPACE,
    TEXT("Insufficient space in extended attribute file for its header.\nAttempting to allocate more disk space.")
},

{
    MSG_CHK_INSUFFICIENT_DISK_SPACE,
    TEXT("Insufficient disk space to correct disk error.\nPlease free some disk space and run CHKDSK again.")
},

{
    MSG_CHK_RELOCATED_EA_HEADER,
    TEXT("Bad clusters in extended attribute file header relocated.")
},

{
    MSG_CHK_ERROR_IN_EA_HEADER,
    TEXT("Errors in extended attribute file header corrected.")
},

{
    MSG_CHK_MORE_THAN_ONE_DOT,
    TEXT("More than one dot entry in folder %1.  Entry removed.")
},

{
    MSG_CHK_DOT_IN_ROOT,
    TEXT("Dot entry found in root folder.  Entry removed.")
},

{
    MSG_CHK_DOTDOT_IN_ROOT,
    TEXT("Dot-dot entry found in root folder.  Entry removed.")
},

{
    MSG_CHK_ERR_IN_DOT,
    TEXT("Dot entry in folder %1 has incorrect link.  Link corrected.")
},

{
    MSG_CHK_ERR_IN_DOTDOT,
    TEXT("Dot-dot entry in folder %1 has incorrect link.  Link corrected.")
},

{
    MSG_CHK_DELETE_REPEATED_ENTRY,
    TEXT("More than one %1 entry in folder %2.  Entry removed.")
},

{
    MSG_CHK_CYCLE_IN_TREE,
    TEXT("Folder %1 causes cycle in folder structure.\nFolder entry removed.")
},

{
    MSG_CHK_BAD_CLUSTERS_IN_DIR,
    TEXT("Folder %1 has bad clusters.\nBad clusters removed from folder.")
},

{
    MSG_CHK_BAD_DIR,
    TEXT("Folder %1 is entirely unreadable.\nFolder entry removed.")
},

{
    MSG_CHK_FILENAME,
    TEXT("%1")
},

{
    MSG_CHK_DIR_TRUNC,
    TEXT("Folder truncated.")
},

{
    MSG_CHK_CROSS_LINK_COPY,
    TEXT("Cross link resolved by copying.")
},

{
    MSG_CHK_CROSS_LINK_TRUNC,
    TEXT("Insufficient disk space to copy cross-linked portion.\nFile being truncated.")
},

{
    MSG_CHK_INVALID_NAME,
    TEXT("%1  Invalid name.  Folder entry removed.")
},

{
    MSG_CHK_INVALID_TIME_STAMP,
    TEXT("%1  Invalid time stamp.")
},

{
    MSG_CHK_DIR_HAS_FILESIZE,
    TEXT("%1  Folder has non-zero file size.")
},

{
    MSG_CHK_UNRECOG_EA_HANDLE,
    TEXT("%1  Unrecognized extended attribute handle.")
},

{
    MSG_CHK_SHARED_EA,
    TEXT("%1  Has handle extended attribute set belonging to another file.\nHandle removed.")
},

{
    MSG_CHK_UNUSED_EA_SET,
    TEXT("Unused extended attribute set with handle %1 deleted from\nextended attribute file.")
},

{
    MSG_CHK_NEW_OWNER_NAME,
    TEXT("Extended attribute set with handle %1 owner changed\nfrom %2 to %3.")
},

{
    MSG_CHK_BAD_LINKS_IN_ORPHANS,
    TEXT("Bad links in lost chain at cluster %1 corrected.")
},

{
    MSG_CHK_CROSS_LINKED_ORPHAN,
    TEXT("Lost chain cross-linked at cluster %1.  Orphan truncated.")
},

{
    MSG_ORPHAN_DISK_SPACE,
    TEXT("Insufficient disk space to recover lost data.")
},

{
    MSG_TOO_MANY_ORPHANS,
    TEXT("Insufficient disk space to recover lost data.")
},

{
    MSG_CHK_ERROR_IN_LOG,
    TEXT("Error in extended attribute log.")
},

{
    MSG_CHK_ERRORS_IN_DIR_CORR,
    TEXT("%1 Errors in . and/or .. corrected.")
},

{
    MSG_CHK_RENAMING_FAILURE,
    TEXT("More than one %1 entry in folder %2.\nRenamed to %3 but still could not resolve the name conflict.")
},

{
    MSG_CHK_RENAMED_REPEATED_ENTRY,
    TEXT("More than one %1 entry in folder %2.\nRenamed to %3.")
},

{
    MSG_CHK_UNHANDLED_INVALID_NAME,
    TEXT("%1 may be an invalid name in folder %2.")
},

{
    MSG_CHK_INVALID_NAME_CORRECTED,
    TEXT("Corrected name %1 in folder %2.")
},

{
    MSG_RECOV_BYTES_RECOVERED,
    TEXT("\n%1 of %2 bytes recovered.")
},

{
    MSG_CHK_NTFS_BAD_SECTORS_REPORT_IN_KB,
    TEXT("%1 KB in bad sectors.")
},

{
    MSG_CHK_NTFS_CORRECTING_ERROR_IN_DIRECTORY,
    TEXT("Correcting error in directory %1")
},

{
    MSG_UTILS_HELP,
    TEXT("There is no help for this utility.")
},

{
    MSG_UTILS_ERROR_FATAL,
    TEXT("Critical error encountered.")
},

{
    MSG_UTILS_ERROR_INVALID_VERSION,
    TEXT("Incorrect EFI version")
},

{
    MSG_BOOT_FAT_NTLDR_MISSING,
    TEXT("NTLDR is missing%0")
},

{
    MSG_BOOT_FAT_IO_ERROR,
    TEXT("Disk error%0")
},

{
    MSG_BOOT_FAT_PRESS_KEY,
    TEXT("Press any key to restart%0")
},

{
    MSG_BOOT_NTFS_NTLDR_MISSING,
    TEXT("NTLDR is missing%0")
},

{
    MSG_BOOT_NTFS_NTLDR_COMPRESSED,
    TEXT("NTLDR is compressed%0")
},

{
    MSG_BOOT_NTFS_IO_ERROR,
    TEXT("A disk read error occurred%0")
},

{
    MSG_BOOT_NTFS_PRESS_KEY,
    TEXT("Press Ctrl+Alt+Del to restart%0")
},

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\efisrc\efickmsg.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    efickmsg.cxx

--*/
#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "efiwintypes.hxx"
#include "efickmsg.hxx"
#include "rtmsg.h"

DEFINE_CONSTRUCTOR(EFICHECK_MESSAGE, MESSAGE);


EFICHECK_MESSAGE::~EFICHECK_MESSAGE(
    )
/*++

Routine Description:

    Destructor for EFICHECK_MESSAGE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
EFICHECK_MESSAGE::Construct(
    )
/*++

Routine Description:

    This routine initializes the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
EFICHECK_MESSAGE::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


BOOLEAN
EFICHECK_MESSAGE::Initialize(
    IN BOOLEAN  DotsOnly
    )
/*++

Routine Description:

    This routine initializes the class to a valid initial state.

Arguments:

    DotsOnly    - efichk should produce only dots instead of messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    _dots_only = DotsOnly;
    return MESSAGE::Initialize();
}


BOOLEAN
EFICHECK_MESSAGE::DisplayV(
    IN  PCSTR   Format,
    IN  va_list VarPointer
    )
/*++

Routine Description:

    This routine displays the message with the specified parameters.

    The format string supports all printf options.

Arguments:

    Format      - Supplies a printf style format string.
    VarPointer  - Supplies a varargs pointer to the arguments.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHAR            buffer[256];
    DSTRING         display_string;
    PWSTR           dis_str;

    if (!BASE_SYSTEM::QueryResourceStringV(&display_string, GetMessageId(), Format,
                                           VarPointer)) {

        return FALSE;
    }

   if (!(dis_str = display_string.QueryWSTR())) {

        return FALSE;
    }

    if(MSG_HIDDEN_STATUS != GetMessageId()) {

        Print(dis_str);
    }


    DELETE(dis_str);

    return TRUE;
}

BOOLEAN
EFICHECK_MESSAGE::IsYesResponse(
    IN  BOOLEAN Default
    )
/*++

Routine Description:

    This routine queries a response of yes or no.

Arguments:

    Default - Supplies a default in the event that a query is not possible.

Return Value:

    FALSE   - The answer is no.
    TRUE    - The answer is yes.

--*/
{
    CHAR16           input_buf[3];
    BOOLEAN          retvalue;

    while(1) {
        Input(TEXT(""), (CHAR16*)&input_buf, 2);

        if(input_buf[0] == L'Y' || input_buf[0] == L'y') {
            retvalue = TRUE;
            break;
        } else if(input_buf[0] == L'N' || input_buf[0] == L'n') {
            retvalue = FALSE;
            break;
        }
    }
    Print(TEXT("\n"));
    return retvalue;
    //return Default;
}


PMESSAGE
EFICHECK_MESSAGE::Dup(
    )
/*++

Routine Description:

    This routine returns a new MESSAGE of the same type.

Arguments:

    None.

Return Value:

    A pointer to a new MESSAGE object.

--*/
{
    PEFICHECK_MESSAGE  p;

    if (!(p = NEW EFICHECK_MESSAGE)) {
        return NULL;
    }

    if (!p->Initialize()) {
        DELETE(p);
        return NULL;
    }

    return p;
}

BOOLEAN
EFICHECK_MESSAGE::SetDotsOnly(
    IN  BOOLEAN         DotsOnlyState
    )
/*++

Routine Description:

    This routine modifies the output mode, changing whether full
    output is printed, or just dots.

Arguments:

    DotsOnlyState   - TRUE if only dots should be printed.

Return Value:

    The previous state.

--*/
{
    return FALSE;
}

BOOLEAN
EFICHECK_MESSAGE::IsInAutoChk(
    )
/*++

Routine Description:

    This routine returns TRUE if it is in the regular efichk and not related
    to setup.  This relys on setup using the /s or /t option all the time.

Arguments:

    None.

Return Value:

    TRUE    - if in regular efichk

--*/
{
    return TRUE;
}

BOOLEAN
EFICHECK_MESSAGE::IsKeyPressed(
    MSGID       MsgId,
    ULONG       TimeOutInSeconds
    )
/*++

Routine Description:

    Check to see if the user has hit any key within the timeout period.

Arguments:

    MsgId            - Supplies the message Id to be displayed
    TimeOutInSeconds - Supplies the count down time in seconds

Return Value:

    TRUE    - A key is pressed within the timeout period.
    FALSE   - No key has been pressed or there is an error

--*/
{
    return FALSE;
}

BOOLEAN
EFICHECK_MESSAGE::WaitForUserSignal(
    )
/*++

Routine Description:

    Open the keyboard directly and wait to read something.

Arguments:

    None:

Return Value:

    TRUE    - Something was successfully read.
    FALSE   - An error occured while attempting to open or read.

--*/
{
    return TRUE;
}


BOOLEAN
EFICHECK_MESSAGE::QueryStringInput(
    OUT PWSTRING    String
    )
{
    CHAR16 buf[80];

    Input(TEXT(""), (CHAR16 *)&buf, 79);

    DisplayMsg(MSG_BLANK_LINE);

    return String->Initialize(buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\efisrc\efimisc.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    efimisc.cxx

--*/

#include <pch.cxx>

// BUGBUG
// There doesn't seem to be any interlockedexchange compexchg or interlocked decrement/increment.
// so we define some here that work.
//
// Note that these won't work since they aren't really atomic, but my assumption is that
// EFI is a single threaded non-preemptive environment so this won't really matter.

LONG
InterlockedIncrement (
    IN OUT LONG* Addend
    )
{
    *Addend = (*Addend)++;
    return *Addend;
}


LONG
InterlockedDecrement (
    IN OUT LONG* Addend
    )
{
    *Addend = (*Addend)--;
    return *Addend;
}

LONG
InterlockedExchange (
    IN OUT LONG* Target,
    LONG Value
    )
{
    LONG       temp;

    temp = *Target;
    (*Target) = Value;
    return temp;
}


LONG
InterlockedCompareExchange (
    IN OUT LONG* Destination,
    IN LONG ExChange,
    IN LONG Comperand
    )
{
    LONG       temp = *Destination;

    if (Comperand == *Destination) {
        *Destination = ExChange;
    }

    return temp;
}


NTSTATUS
NtDelayExecution (
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER DelayInterval
    )
{
    BS->Stall(DelayInterval->LowPart);

    return STATUS_SUCCESS;
}

void
_chkstk()
{
};

void
_aNchkstk()
{
};


VOID
EfiWaitForKey()
{
    EFI_INPUT_KEY       Key;

    WaitForSingleEvent (ST->ConIn->WaitForKey, 0);
    // flush keyboard
    ST->ConIn->ReadKeyStroke(ST->ConIn,&Key);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\efisrc\efistrutil.cxx ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    efistrutil.cxx

--*/
#include "efiwintypes.hxx"
#include "pch.cxx"

void *memmove( void *dest, const void *src, size_t count )
{
    // quick workaround for lack of memmove in EFI library
    VOID * temp = AllocatePool(count);
    memcpy( temp, src, count);
    memcpy( dest, temp, count);
    FreePool(temp);
    return dest;
}

char *strcpy( char *strDestination, const char *strSource )
{

    INT32 i;

    i=0;
    while(strSource[i] != NULL) {
        strDestination[i] = strSource[i];
        i++;
    }
    strDestination[i] = NULL; // null terminate.

    return strDestination;
}


int iswspace( WCHAR c )
{
    // BUGBUG this isn't a proper wide char test
    // but will do for now.
    if( ((0x09 <= c) && (c <= 0x0d)) || (c == 0x20) ) {
        return TRUE;
    } else {
        return FALSE;
    }
}

int isspace( CHAR c )
{
    // BUGBUG this isn't a proper wide char test
    // but will do for now.
    if( ((0x09 <= c) && (c <= 0x0d)) || (c == 0x20) ) {
        return TRUE;
    } else {
        return FALSE;
    }
}

int isdigit( int c )
{
    // BUGBUG again, this isn't a proper wide char test
    // but it will do for now.
    if( c >= '0' && c <= '9' ) {
        return TRUE;
    } else {
        return FALSE;
    }

}

int towupper( WCHAR c )
{
    // BUGBUG, this is wrong too, but for now it must do.
    return c;
}

int wcsncmp( const WCHAR *string1, const WCHAR *string2, size_t count )
{
    for( unsigned int i=0; i<count; i++ ) {

        if(string1[i] != string2[i] || string1[i] == UNICODE_NULL || string2[i] == UNICODE_NULL) {
            break;
        }
    }
    return string2[i]-string1[i];
}

long atol(const char *nptr) {
    int c;          /* current char */
    long total;     /* current total */
    int sign;       /* if '-', then negative, otherwise positive */
    while (isspace((int)(unsigned char)*nptr))
        nptr++;
    c = (int)(unsigned char)*nptr++;
    sign = c;       /* save sign indication */
    if (c == '-' || c == '+')
        c = (int)(unsigned char)*nptr++;    /* skip sign */
    total = 0;
    while ((c >= '0') && (c <= '9')) {
        total = 10 * total + (c - '0');     /* accumulate digit */
        c = (int)(unsigned char)*nptr++;    /* get next char */
    }
    if (sign == '-')
        return -total;
    else
        return total;
}

int atoi(const char *nptr) {
    return (int)atol(nptr);
}

STATIC char *sprintf_buf;
STATIC count;

VOID
bzero(char *cp, int len)
{
    while (len--) {
        *(cp + len) = 0;
    }
}

VOID
__cdecl
putbuf(char c)
{
    *sprintf_buf++ = c;
    count++;
}

VOID
__cdecl
doprnt(VOID (*func)(char c), const char *fmt, va_list args);


//
// BUGBUG this is a semi-sprintf hacked together just to get it to work
//
int
__cdecl
sprintf(char *buf, const char *fmt, ...)
{
    va_list args;

    sprintf_buf = buf;
    va_start(args, fmt);
    doprnt(putbuf, fmt, args);
    va_end(args);
    putbuf('\0');
    return count--;
}

void
__cdecl
printbase(VOID (*func)(char), ULONG x, int base, int width)
{
    static char itoa[] = "0123456789abcdef";
    ULONG j;
    LONG k;
    char buf[32], *s = buf;

    bzero(buf, 16);
    while (x) {
        j = x % base;
        *s++ = itoa[j];
        x -= j;
        x /= base;
    }

    if( s-buf < width ) {
        for( k = 0; k < width - (s-buf); k++ ) {
            func('0');
        }
    }
    for (--s; s >= buf; --s) {
        func(*s);
    }
}

void
__cdecl
doprnt(VOID (*func)( char c), const char *fmt, va_list args)
{
    ULONG x;
    LONG l;
    LONG width;
    char c, *s;

    count = 0;

    while (c = *fmt++) {
        if (c != '%') {
            func(c);
            continue;
        }

        width=0;
        c=*fmt++;

        if(c == '0') {
            while( c = *fmt++) {

                if (!isdigit(c)) {
                    break;
                }

                width = width*10;
                width = width+(c-48);

            }
        }
        fmt--; // back it up one char

        switch (c = *fmt++) {
        case 'x':
            x = va_arg(args, ULONG);
            printbase(func, x, 16, width);
            break;
        case 'o':
            x = va_arg(args, ULONG);
            printbase(func, x, 8, width);
            break;
        case 'd':
            l = va_arg(args, LONG);
            if (l < 0) {
                func('-');
                l = -l;
            }
            printbase(func, (ULONG) l, 10, width);
            break;
        case 'u':
            l = va_arg(args, ULONG);
            printbase(func, (ULONG) l, 10, width);
            break;
        case 'c':
            c = va_arg(args, char);
            func(c);
            break;
        case 's':
            s = va_arg(args, char *);
            while (*s) {
                func(*s++);
            }
            break;
        default:
            func(c);
            break;
        }
    }
}

#define MAX_INSERTS 200

NTSTATUS
RtlFormatMessage(
    IN PWSTR MessageFormat,
    IN ULONG MaximumWidth OPTIONAL,
    IN BOOLEAN IgnoreInserts,
    IN BOOLEAN ArgumentsAreAnsi,
    IN BOOLEAN ArgumentsAreAnArray,
    IN va_list *Arguments,
    OUT PWSTR Buffer,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    ULONG Column;
    int cchRemaining, cchWritten;
    PULONG_PTR ArgumentsArray = (PULONG_PTR)Arguments;
    ULONG_PTR rgInserts[ MAX_INSERTS ];
    ULONG cSpaces;
    ULONG MaxInsert, CurInsert;
    ULONG PrintParameterCount;
    ULONG_PTR PrintParameter1;
    ULONG_PTR PrintParameter2;
    WCHAR PrintFormatString[ 32 ];
    BOOLEAN DefaultedFormatString;
    WCHAR c;
    PWSTR s, s1;
    PWSTR lpDst, lpDstBeg, lpDstLastSpace;

    cchRemaining = Length / sizeof( WCHAR );
    lpDst = Buffer;
    MaxInsert = 0;
    lpDstLastSpace = NULL;
    Column = 0;
    s = MessageFormat;
    while (*s != UNICODE_NULL) {
        if (*s == L'%') {
            s++;
            lpDstBeg = lpDst;
            if (*s >= L'1' && *s <= L'9') {
                CurInsert = *s++ - L'0';
                if (*s >= L'0' && *s <= L'9') {
                    CurInsert = (CurInsert * 10) + (*s++ - L'0');
                    if (*s >= L'0' && *s <= L'9') {
                        CurInsert = (CurInsert * 10) + (*s++ - L'0');
                        if (*s >= L'0' && *s <= L'9') {
                            return( STATUS_INVALID_PARAMETER );
                            }
                        }
                    }
                CurInsert -= 1;

                PrintParameterCount = 0;
                if (*s == L'!') {
                    DefaultedFormatString = FALSE;
                    s1 = PrintFormatString;
                    *s1++ = L'%';
                    s++;
                    while (*s != L'!') {
                        if (*s != UNICODE_NULL) {
                            if (s1 >= &PrintFormatString[ 31 ]) {
                                return( STATUS_INVALID_PARAMETER );
                                }

                            if (*s == L'*') {
                                if (PrintParameterCount++ > 1) {
                                    return( STATUS_INVALID_PARAMETER );
                                    }
                                }

                            *s1++ = *s++;
                            }
                        else {
                            return( STATUS_INVALID_PARAMETER );
                            }
                        }

                    s++;
                    *s1 = UNICODE_NULL;
                    }
                else {
                    DefaultedFormatString = TRUE;
                    wcscpy( PrintFormatString, TEXT("%s") );
                    s1 = PrintFormatString + wcslen( PrintFormatString );
                    }

                if (IgnoreInserts) {
                    if (!wcscmp( PrintFormatString, TEXT("%s") )) {
                        cchWritten = (int)SPrint( lpDst,
                                                 cchRemaining,
                                                 TEXT("%%%u"),
                                                 CurInsert+1
                                               );
                        }
                    else {
                        cchWritten = (int)SPrint( lpDst,
                                                 cchRemaining,
                                                 TEXT("%%%u!%s!"),
                                                 CurInsert+1,
                                                 &PrintFormatString[ 1 ]
                                               );
                        }

                    if (cchWritten == -1) {
                        return(STATUS_BUFFER_OVERFLOW);
                        }
                    }
                else
                if (ARGUMENT_PRESENT( Arguments )) {
                    if ((CurInsert+PrintParameterCount) >= MAX_INSERTS) {
                        return( STATUS_INVALID_PARAMETER );
                        }

                    if (ArgumentsAreAnsi) {
                        if (s1[ -1 ] == L'c' && s1[ -2 ] != L'h'
                          && s1[ -2 ] != L'w' && s1[ -2 ] != L'l') {
                            wcscpy( &s1[ -1 ], TEXT("hc") );
                            }
                        else
                        if (s1[ -1 ] == L's' && s1[ -2 ] != L'h'
                          && s1[ -2 ] != L'w' && s1[ -2 ] != L'l') {
                            wcscpy( &s1[ -1 ], TEXT("hs") );
                            }
                        else if (s1[ -1 ] == L'S') {
                            s1[ -1 ] = L's';
                            }
                        else if (s1[ -1 ] == L'C') {
                            s1[ -1 ] = L'c';
                            }
                        }

                    while (CurInsert >= MaxInsert) {
                        if (ArgumentsAreAnArray) {
                                PULONG_PTR aaa;
                                aaa = (PULONG_PTR)Arguments++;
                                PrintParameter2 = rgInserts[ MaxInsert++ ] = *(aaa);
                            }
                        else {
                            rgInserts[ MaxInsert++ ] = va_arg(*Arguments, ULONG_PTR);
                            }
                        }

                    s1 = (PWSTR)rgInserts[ CurInsert ];
                    PrintParameter1 = 0;
                    PrintParameter2 = 0;
                    if (PrintParameterCount > 0) {
                        if (ArgumentsAreAnArray) {
                                PULONG_PTR aaa;
                                aaa = (PULONG_PTR)Arguments;
                                PrintParameter2 = rgInserts[ MaxInsert++ ] = *(aaa)++;
                            }
                        else {
                            PrintParameter1 = rgInserts[ MaxInsert++ ] = va_arg( *Arguments, ULONG_PTR );
                            }

                        if (PrintParameterCount > 1) {
                            if (ArgumentsAreAnArray) {
                                PULONG_PTR aaa;
                                aaa = (PULONG_PTR)Arguments;
                                PrintParameter2 = rgInserts[ MaxInsert++ ] = *(aaa)++;
                                }
                            else {
                                PrintParameter2 = rgInserts[ MaxInsert++ ] = va_arg( *Arguments, ULONG_PTR );
                                }
                            }
                        }

                    cchWritten = (int)SPrint( lpDst,
                                             cchRemaining,
                                             PrintFormatString,
                                             s1,
                                             PrintParameter1,
                                             PrintParameter2
                                           );

                    if (cchWritten == -1) {
                        return(STATUS_BUFFER_OVERFLOW);
                        }
                    }
                else {
                    return( STATUS_INVALID_PARAMETER );
                    }

                if ((cchRemaining -= cchWritten) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                lpDst += cchWritten;
                }
            else
            if (*s == L'0') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\0';

                break;
                }
            else
            if (!*s) {
                return( STATUS_INVALID_PARAMETER );
                }
            else
            if (*s == L'r') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                s++;
                lpDstBeg = NULL;
                }
            else
            if (*s == L'n') {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                s++;
                lpDstBeg = NULL;
                }
            else
            if (*s == L't') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                if (Column % 8) {
                    Column = (Column + 7) & ~7;
                    }
                else {
                    Column += 8;
                    }

                lpDstLastSpace = lpDst;
                *lpDst++ = L'\t';
                s++;
                }
            else
            if (*s == L'b') {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                lpDstLastSpace = lpDst;
                *lpDst++ = L' ';
                s++;
                }
            else
            if (IgnoreInserts) {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'%';
                *lpDst++ = *s++;
                }
            else {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = *s++;
                }

            if (lpDstBeg == NULL) {
                lpDstLastSpace = NULL;
                Column = 0;
                }
            else {
                Column += (ULONG)(lpDst - lpDstBeg);
                }
            }
        else {
            c = *s++;
            if (c == L'\r' || c == L'\n') {
                if ((c == L'\n' && *s == L'\r') ||
                    (c == L'\r' && *s == L'\n')
                   ) {
                    s++;
                    }

                if (MaximumWidth != 0) {
                    lpDstLastSpace = lpDst;
                    c = L' ';
                    }
                else {
                    c = L'\n';
                    }
                }


            if (c == L'\n') {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                lpDstLastSpace = NULL;
                Column = 0;
                }
            else {
                if ((cchRemaining -= 1) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                if (c == L' ') {
                    lpDstLastSpace = lpDst;
                    }

                *lpDst++ = c;
                Column += 1;
                }
            }

        if (MaximumWidth != 0 &&
            MaximumWidth != 0xFFFFFFFF &&
            Column >= MaximumWidth
           ) {
            if (lpDstLastSpace != NULL) {
                lpDstBeg = lpDstLastSpace;
                while (*lpDstBeg == L' ' || *lpDstBeg == L'\t') {
                    lpDstBeg += 1;
                    if (lpDstBeg == lpDst) {
                        break;
                        }
                    }
                while (lpDstLastSpace > Buffer) {
                    if (lpDstLastSpace[ -1 ] == L' ' || lpDstLastSpace[ -1 ] == L'\t') {
                        lpDstLastSpace -= 1;
                        }
                    else {
                        break;
                        }
                    }

                cSpaces = (ULONG)(lpDstBeg - lpDstLastSpace);
                if (cSpaces == 1) {
                    if ((cchRemaining -= 1) <= 0) {
                        return STATUS_BUFFER_OVERFLOW;
                        }
                    }
                else
                if (cSpaces > 2) {
                    cchRemaining += (cSpaces - 2);
                    }

                memmove( lpDstLastSpace + 2,
                         lpDstBeg,
                         (ULONG) ((lpDst - lpDstBeg) * sizeof( WCHAR ))
                       );
                *lpDstLastSpace++ = L'\r';
                *lpDstLastSpace++ = L'\n';
                Column = (ULONG)(lpDst - lpDstBeg);
                lpDst = lpDstLastSpace + Column;
                lpDstLastSpace = NULL;
                }
            else {
                if ((cchRemaining -= 2) <= 0) {
                    return STATUS_BUFFER_OVERFLOW;
                    }

                *lpDst++ = L'\r';
                *lpDst++ = L'\n';
                lpDstLastSpace = NULL;
                Column = 0;
                }
            }
        }

    if ((cchRemaining -= 2) <= 0) {
        return STATUS_BUFFER_OVERFLOW;
        }

    *lpDst++ = '\r';
    *lpDst++ = '\n';

    if ((cchRemaining -= 1) <= 0) {
        return STATUS_BUFFER_OVERFLOW;
        }

    *lpDst++ = '\0';
    if ( ARGUMENT_PRESENT(ReturnLength) ) {
        *ReturnLength = (ULONG)(lpDst - Buffer) * sizeof( WCHAR );
        }

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\efisrc\efitimefunc.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    efitimefunc.cxx

--*/

#include<pch.cxx>

static
VOID
DaysAndFractionToTime (
    IN ULONG ElapsedDays,
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Time
    );

static
VOID
TimeToDaysAndFraction (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedDays,
    OUT PULONG Milliseconds
    );

//
//  The following two tables map a day offset within a year to the month
//  containing the day.  Both tables are zero based.  For example, day
//  offset of 0 to 30 map to 0 (which is Jan).
//

CONST UCHAR LeapYearDayToMonth[366] = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // January
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        // February
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // March
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // April
     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // May
     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     // June
     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  // July
     7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // August
     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // September
     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,  // October
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,     // November
    11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11}; // December

CONST UCHAR NormalYearDayToMonth[365] = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // January
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,           // February
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // March
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // April
     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // May
     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     // June
     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  // July
     7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // August
     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // September
     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,  // October
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,     // November
    11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11}; // December

//
//  The following two tables map a month index to the number of days preceding
//  the month in the year.  Both tables are zero based.  For example, 1 (Feb)
//  has 31 days preceding it.  To help calculate the maximum number of days
//  in a month each table has 13 entries, so the number of days in a month
//  of index i is the table entry of i+1 minus the table entry of i.
//

CONST CSHORT LeapYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+29,                             // March
    31+29+31,                          // April
    31+29+31+30,                       // May
    31+29+31+30+31,                    // June
    31+29+31+30+31+30,                 // July
    31+29+31+30+31+30+31,              // August
    31+29+31+30+31+30+31+31,           // September
    31+29+31+30+31+30+31+31+30,        // October
    31+29+31+30+31+30+31+31+30+31,     // November
    31+29+31+30+31+30+31+31+30+31+30,  // December
    31+29+31+30+31+30+31+31+30+31+30+31};

CONST CSHORT NormalYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+28,                             // March
    31+28+31,                          // April
    31+28+31+30,                       // May
    31+28+31+30+31,                    // June
    31+28+31+30+31+30,                 // July
    31+28+31+30+31+30+31,              // August
    31+28+31+30+31+30+31+31,           // September
    31+28+31+30+31+30+31+31+30,        // October
    31+28+31+30+31+30+31+31+30+31,     // November
    31+28+31+30+31+30+31+31+30+31+30,  // December
    31+28+31+30+31+30+31+31+30+31+30+31};

//
//  The following definitions and declarations are some important constants
//  used in the time conversion routines
//

//
//  This is the week day that January 1st, 1601 fell on (a Monday)
//

#define WEEKDAY_OF_1601                  1

#define RtlExtendedMagicDivide( A, B, C )       \
    (LARGE_INTEGER)(A.QuadPart)/(B.QuadPart)

//
//  These are known constants used to convert 1970 and 1980 times to 1601
//  times.  They are the number of seconds from the 1601 base to the start
//  of 1970 and the start of 1980.  The number of seconds from 1601 to
//  1970 is 369 years worth, or (369 * 365) + 89 leap days = 134774 days, or
//  134774 * 864000 seconds, which is equal to the large integer defined
//  below.  The number of seconds from 1601 to 1980 is 379 years worth, or etc.
//

const LARGE_INTEGER SecondsToStartOf1970 = {0xb6109100, 0x00000002};

const LARGE_INTEGER SecondsToStartOf1980 = {0xc8df3700, 0x00000002};

//
//  These are the magic numbers needed to do our extended division.  The
//  only numbers we ever need to divide by are
//
//      10,000 = convert 100ns tics to millisecond tics
//
//      10,000,000 = convert 100ns tics to one second tics
//
//      86,400,000 = convert Millisecond tics to one day tics
//

const LARGE_INTEGER Magic10000    = {0xe219652c, 0xd1b71758};
#define SHIFT10000                       13

const LARGE_INTEGER Magic10000000 = {0xe57a42bd, 0xd6bf94d5};
#define SHIFT10000000                    23

const LARGE_INTEGER Magic86400000 = {0xfa67b90e, 0xc6d750eb};
#define SHIFT86400000                    26

//
//  To make the code more readable we'll also define some macros to
//  do the actual division for use
//

LARGE_INTEGER Convert100nsToMilliseconds(LARGE_INTEGER a );

LARGE_INTEGER ConvertMillisecondsTo100ns(LARGE_INTEGER a);

LARGE_INTEGER Convert100nsToSeconds(LARGE_INTEGER a );

LARGE_INTEGER ConvertSecondsTo100ns(LARGE_INTEGER a);

LARGE_INTEGER ConvertMillisecondsToDays(LARGE_INTEGER a);

ULONGLONG ConvertDaysToMilliseconds(ULONG a );
//
//  ULONG
//  ElapsedYearsToDays (
//      IN ULONG ElapsedYears
//      );
//
//  The number of days contained in elapsed years is simply the number
//  of years times 365 (because every year has at least 365 days) plus
//  the number of leap years there are (i.e., the number of 366 days years)
//

#define ElapsedYearsToDays(YEARS) (            \
    ((YEARS) * 365) + NumberOfLeapYears(YEARS) \
    )

ULONG
ElapsedDaysToYears (
    IN ULONG ElapsedDays
    );

//
//  BOOLEAN
//  IsLeapYear (
//      IN ULONG ElapsedYears
//      );
//
//  If it is an even 400 or a non century leapyear then the
//  answer is true otherwise it's false
//

#define IsLeapYear(YEARS) (                        \
    (((YEARS) % 400 == 0) ||                       \
     ((YEARS) % 100 != 0) && ((YEARS) % 4 == 0)) ? \
        TRUE                                       \
    :                                              \
        FALSE                                      \
    )

//
//  ULONG
//  MaxDaysInMonth (
//      IN ULONG Year,
//      IN ULONG Month
//      );
//
//  The maximum number of days in a month depend on the year and month.
//  It is the difference between the days to the month and the days
//  to the following month
//

#define MaxDaysInMonth(YEAR,MONTH) (                                      \
    IsLeapYear(YEAR) ?                                                    \
        LeapYearDaysPrecedingMonth[(MONTH) + 1] -                         \
                                    LeapYearDaysPrecedingMonth[(MONTH)]   \
    :                                                                     \
        NormalYearDaysPrecedingMonth[(MONTH) + 1] -                       \
                                    NormalYearDaysPrecedingMonth[(MONTH)] \
    )

//
//  ULONG
//  NumberOfLeapYears (
//      IN ULONG ElapsedYears
//      );
//
//  The number of leap years is simply the number of years divided by 4
//  minus years divided by 100 plus years divided by 400.  This says
//  that every four years is a leap year except centuries, and the
//  exception to the exception is the quadricenturies
//

#define NumberOfLeapYears(YEARS) (                    \
    ((YEARS) / 4) - ((YEARS) / 100) + ((YEARS) / 400) \
    )


LARGE_INTEGER Convert100nsToMilliseconds(LARGE_INTEGER a )
{
    LARGE_INTEGER result;

    result.QuadPart = ((LONGLONG) (a.QuadPart)) / Magic10000.QuadPart;

    return (result);
}

LARGE_INTEGER ConvertMillisecondsTo100ns(LARGE_INTEGER a)
{
    LARGE_INTEGER result;

    result.QuadPart = ((LONGLONG) a.QuadPart) * 10000;

    return (result);
}

LARGE_INTEGER Convert100nsToSeconds(LARGE_INTEGER a )
{
    LARGE_INTEGER result;

    result.QuadPart = ((LONGLONG) (a.QuadPart)) / Magic10000000.QuadPart;

    return (result);
}

LARGE_INTEGER ConvertSecondsTo100ns(LARGE_INTEGER a)
{
    LARGE_INTEGER result;

    result.QuadPart = ((LONGLONG) a.QuadPart) * 10000000;

    return (result);
}


LARGE_INTEGER ConvertMillisecondsToDays(LARGE_INTEGER a)
{
    LARGE_INTEGER result;

    result.QuadPart = ((LONGLONG)(a.QuadPart)) / Magic86400000.QuadPart;

    return (result);
}

ULONGLONG ConvertDaysToMilliseconds(ULONG a )
{
    return ((LONGLONG) a) * 86400000;
}

//
//  ULONG
//  ElapsedYearsToDays (
//      IN ULONG ElapsedYears
//      );
//
//  The number of days contained in elapsed years is simply the number
//  of years times 365 (because every year has at least 365 days) plus
//  the number of leap years there are (i.e., the number of 366 days years)
//

#define ElapsedYearsToDays(YEARS) (            \
    ((YEARS) * 365) + NumberOfLeapYears(YEARS) \
    )

ULONG
ElapsedDaysToYears (
    IN ULONG ElapsedDays
    )

/*++

Routine Description:

    This routine computes the number of total years contained in the indicated
    number of elapsed days.  The computation is to first compute the number of
    400 years and subtract that it, then do the 100 years and subtract that out,
    then do the number of 4 years and subtract that out.  Then what we have left
    is the number of days with in a normalized 4 year block.  Normalized being that
    the first three years are not leap years.

Arguments:

    ElapsedDays - Supplies the number of days to use

Return Value:

    ULONG - Returns the number of whole years contained within the input number
        of days.

--*/

{
    ULONG NumberOf400s;
    ULONG NumberOf100s;
    ULONG NumberOf4s;
    ULONG Years;

    //
    //  A 400 year time block is 365*400 + 400/4 - 400/100 + 400/400 = 146097 days
    //  long.  So we simply compute the number of whole 400 year block and the
    //  the number days contained in those whole blocks, and subtract if from the
    //  elapsed day total
    //

    NumberOf400s = ElapsedDays / 146097;
    ElapsedDays -= NumberOf400s * 146097;

    //
    //  A 100 year time block is 365*100 + 100/4 - 100/100 = 36524 days long.
    //  The computation for the number of 100 year blocks is biased by 3/4 days per
    //  100 years to account for the extra leap day thrown in on the last year
    //  of each 400 year block.
    //

    NumberOf100s = (ElapsedDays * 100 + 75) / 3652425;
    ElapsedDays -= NumberOf100s * 36524;

    //
    //  A 4 year time block is 365*4 + 4/4 = 1461 days long.
    //

    NumberOf4s = ElapsedDays / 1461;
    ElapsedDays -= NumberOf4s * 1461;

    //
    //  Now the number of whole years is the number of 400 year blocks times 400,
    //  100 year blocks time 100, 4 year blocks times 4, and the number of elapsed
    //  whole years, taking into account the 3/4 day per year needed to handle the
    //  leap year.
    //

    Years = (NumberOf400s * 400) +
            (NumberOf100s * 100) +
            (NumberOf4s * 4) +
            (ElapsedDays * 100 + 75) / 36525;

    return Years;
}

//
//  BOOLEAN
//  IsLeapYear (
//      IN ULONG ElapsedYears
//      );
//
//  If it is an even 400 or a non century leapyear then the
//  answer is true otherwise it's false
//

#define IsLeapYear(YEARS) (                        \
    (((YEARS) % 400 == 0) ||                       \
     ((YEARS) % 100 != 0) && ((YEARS) % 4 == 0)) ? \
        TRUE                                       \
    :                                              \
        FALSE                                      \
    )

//
//  ULONG
//  MaxDaysInMonth (
//      IN ULONG Year,
//      IN ULONG Month
//      );
//
//  The maximum number of days in a month depend on the year and month.
//  It is the difference between the days to the month and the days
//  to the following month
//

#define MaxDaysInMonth(YEAR,MONTH) (                                      \
    IsLeapYear(YEAR) ?                                                    \
        LeapYearDaysPrecedingMonth[(MONTH) + 1] -                         \
                                    LeapYearDaysPrecedingMonth[(MONTH)]   \
    :                                                                     \
        NormalYearDaysPrecedingMonth[(MONTH) + 1] -                       \
                                    NormalYearDaysPrecedingMonth[(MONTH)] \
    )

//
//  ULONG
//  NumberOfLeapYears (
//      IN ULONG ElapsedYears
//      );
//
//  The number of leap years is simply the number of years divided by 4
//  minus years divided by 100 plus years divided by 400.  This says
//  that every four years is a leap year except centuries, and the
//  exception to the exception is the quadricenturies
//

#define NumberOfLeapYears(YEARS) (                    \
    ((YEARS) / 4) - ((YEARS) / 100) + ((YEARS) / 400) \
    )

//static
VOID
DaysAndFractionToTime (
    IN ULONG ElapsedDays,
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input elapsed day count and partial time
    in milliseconds to a 64-bit time value.

Arguments:

    ElapsedDays - Supplies the number of elapsed days

    Milliseconds - Supplies the number of milliseconds in the partial day

    Time - Receives the output time to value

Return Value:

    None

--*/

{
    LARGE_INTEGER Temp;
    LARGE_INTEGER Temp2;

    //
    //  Calculate the exact number of milliseconds in the elapsed days.
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( ElapsedDays );

    //
    //  Convert milliseconds to a large integer
    //

    Temp2.LowPart = Milliseconds;
    Temp2.HighPart = 0;

    //
    //  add milliseconds to the whole day milliseconds
    //

    Temp.QuadPart = Temp.QuadPart + Temp2.QuadPart;

    //
    //  Finally convert the milliseconds to 100ns resolution
    //

    *(PLARGE_INTEGER)Time = ConvertMillisecondsTo100ns( Temp );

    //
    //  and return to our caller
    //

    return;
}

BOOLEAN
RtlTimeFieldsToTime (
    IN PTIME_FIELDS TimeFields,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input Time Field variable to a 64-bit NT time
    value.  It ignores the WeekDay of the time field.

Arguments:

    TimeFields - Supplies the time field record to use

    Time - Receives the NT Time corresponding to TimeFields

Return Value:

    BOOLEAN - TRUE if the Time Fields is well formed and within the
        range of time expressible by LARGE_INTEGER and FALSE otherwise.

--*/

{
    ULONG Year;
    ULONG Month;
    ULONG Day;
    ULONG Hour;
    ULONG Minute;
    ULONG Second;
    ULONG Milliseconds;

    ULONG ElapsedDays;
    ULONG ElapsedMilliseconds;

    //
    //  Load the time field elements into local variables.  This should
    //  ensure that the compiler will only load the input elements
    //  once, even if there are alias problems.  It will also make
    //  everything (except the year) zero based.  We cannot zero base the
    //  year because then we can't recognize cases where we're given a year
    //  before 1601.
    //

    Year         = TimeFields->Year;
    Month        = TimeFields->Month - 1;
    Day          = TimeFields->Day - 1;
    Hour         = TimeFields->Hour;
    Minute       = TimeFields->Minute;
    Second       = TimeFields->Second;
    Milliseconds = TimeFields->Milliseconds;

    //
    //  Check that the time field input variable contains
    //  proper values.
    //

    if ((TimeFields->Month < 1)                      ||
        (TimeFields->Day < 1)                        ||
        (Year < 1601)                                ||
        (Month > 11)                                 ||
        ((CSHORT)Day >= MaxDaysInMonth(Year, Month)) ||
        (Hour > 23)                                  ||
        (Minute > 59)                                ||
        (Second > 59)                                ||
        (Milliseconds > 999)) {

        return FALSE;

    }

    //
    //  Compute the total number of elapsed days represented by the
    //  input time field variable
    //

    ElapsedDays = ElapsedYearsToDays( Year - 1601 );

    if (IsLeapYear( Year - 1600 )) {

        ElapsedDays += LeapYearDaysPrecedingMonth[ Month ];

    } else {

        ElapsedDays += NormalYearDaysPrecedingMonth[ Month ];

    }

    ElapsedDays += Day;

    //
    //  Now compute the total number of milliseconds in the fractional
    //  part of the day
    //

    ElapsedMilliseconds = (((Hour*60) + Minute)*60 + Second)*1000 + Milliseconds;

    //
    //  Given the elapsed days and milliseconds we can now build
    //  the output time variable
    //

    DaysAndFractionToTime( ElapsedDays, ElapsedMilliseconds, Time );

    //
    //  And return to our caller
    //

    return TRUE;
}

static
VOID
TimeToDaysAndFraction (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedDays,
    OUT PULONG Milliseconds
    )

/*++

Routine Description:

    This routine converts an input 64-bit time value to the number
    of total elapsed days and the number of milliseconds in the
    partial day.

Arguments:

    Time - Supplies the input time to convert from

    ElapsedDays - Receives the number of elapsed days

    Milliseconds - Receives the number of milliseconds in the partial day

Return Value:

    None

--*/

{
    LARGE_INTEGER TotalMilliseconds;
    LARGE_INTEGER Temp;

    //
    //  Convert the input time to total milliseconds
    //

    TotalMilliseconds = Convert100nsToMilliseconds( *(PLARGE_INTEGER)Time );

    //
    //  Convert milliseconds to total days
    //

    Temp = ConvertMillisecondsToDays( TotalMilliseconds );

    //
    //  Set the elapsed days from temp, we've divided it enough so that
    //  the high part must be zero.
    //

    *ElapsedDays = Temp.LowPart;

    //
    //  Calculate the exact number of milliseconds in the elapsed days
    //  and subtract that from the total milliseconds to figure out
    //  the number of milliseconds left in the partial day
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( *ElapsedDays );

    Temp.QuadPart = TotalMilliseconds.QuadPart - Temp.QuadPart;

    //
    //  Set the fraction part from temp, the total number of milliseconds in
    //  a day guarantees that the high part must be zero.
    //

    *Milliseconds = Temp.LowPart;

    //
    //  And return to our caller
    //

    return;
}

VOID
RtlTimeToTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine converts an input 64-bit LARGE_INTEGER variable to its corresponding
    time field record.  It will tell the caller the year, month, day, hour,
    minute, second, millisecond, and weekday corresponding to the input time
    variable.

Arguments:

    Time - Supplies the time value to interpret

    TimeFields - Receives a value corresponding to Time

Return Value:

    None

--*/

{
    ULONG Years;
    ULONG Month;
    ULONG Days;

    ULONG Hours;
    ULONG Minutes;
    ULONG Seconds;
    ULONG Milliseconds;

    //
    //  First divide the input time 64 bit time variable into
    //  the number of whole days and part days (in milliseconds)
    //

    TimeToDaysAndFraction( Time, &Days, &Milliseconds );

    //
    //  Compute which weekday it is and save it away now in the output
    //  variable.  We add the weekday of the base day to bias our computation
    //  which means that if one day has elapsed then we the weekday we want
    //  is the Jan 2nd, 1601.
    //

    TimeFields->Weekday = (CSHORT)((Days + WEEKDAY_OF_1601) % 7);

    //
    //  Calculate the number of whole years contained in the elapsed days
    //  For example if Days = 500 then Years = 1
    //

    Years = ElapsedDaysToYears( Days );

    //
    //  And subtract the number of whole years from our elapsed days
    //  For example if Days = 500, Years = 1, and the new days is equal
    //  to 500 - 365 (normal year).
    //

    Days = Days - ElapsedYearsToDays( Years );

    //
    //  Now test whether the year we are working on (i.e., The year
    //  after the total number of elapsed years) is a leap year
    //  or not.
    //

    if (IsLeapYear( Years + 1 )) {

        //
        //  The current year is a leap year, so figure out what month
        //  it is, and then subtract the number of days preceding the
        //  month from the days to figure out what day of the month it is
        //

        Month = LeapYearDayToMonth[Days];
        Days = Days - LeapYearDaysPrecedingMonth[Month];

    } else {

        //
        //  The current year is a normal year, so figure out the month
        //  and days as described above for the leap year case
        //

        Month = NormalYearDayToMonth[Days];
        Days = Days - NormalYearDaysPrecedingMonth[Month];

    }

    //
    //  Now we need to compute the elapsed hour, minute, second, milliseconds
    //  from the millisecond variable.  This variable currently contains
    //  the number of milliseconds in our input time variable that did not
    //  fit into a whole day.  To compute the hour, minute, second part
    //  we will actually do the arithmetic backwards computing milliseconds
    //  seconds, minutes, and then hours.  We start by computing the
    //  number of whole seconds left in the day, and then computing
    //  the millisecond remainder.
    //

    Seconds = Milliseconds / 1000;
    Milliseconds = Milliseconds % 1000;

    //
    //  Now we compute the number of whole minutes left in the day
    //  and the number of remainder seconds
    //

    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    //
    //  Now compute the number of whole hours left in the day
    //  and the number of remainder minutes
    //

    Hours = Minutes / 60;
    Minutes = Minutes % 60;

    //
    //  As our final step we put everything into the time fields
    //  output variable
    //

    TimeFields->Year         = (CSHORT)(Years + 1601);
    TimeFields->Month        = (CSHORT)(Month + 1);
    TimeFields->Day          = (CSHORT)(Days + 1);
    TimeFields->Hour         = (CSHORT)Hours;
    TimeFields->Minute       = (CSHORT)Minutes;
    TimeFields->Second       = (CSHORT)Seconds;
    TimeFields->Milliseconds = (CSHORT)Milliseconds;

    //
    //  and return to our caller
    //

    return;
}

NTSTATUS
RtlSystemTimeToLocalTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER LocalTime
    )
{
    // BUGBUG this is stubbed out for the time being.

    LocalTime->QuadPart = SystemTime->QuadPart;

    return STATUS_SUCCESS;
}

NTSTATUS
EfiQuerySystemTime(
    OUT PLARGE_INTEGER SystemTime
    )
{
    EFI_TIME time;
    TIME_FIELDS nttime;

    if(SystemTime == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if(RT->GetTime(&time,NULL) != EFI_SUCCESS) {
        return STATUS_UNSUCCESSFUL;
    }

    nttime.Year = time.Year;
    nttime.Month = time.Month;
    nttime.Day = time.Day;
    nttime.Hour = time.Hour;
    nttime.Minute = time.Minute;
    nttime.Second = time.Second;
    nttime.Milliseconds = (CSHORT)time.Nanosecond / (1000*1000);
    nttime.Weekday = 0;

    RtlTimeFieldsToTime(&nttime,SystemTime );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\efisrc\drive.cxx ===
/*++

Copyright (c) 1992-2001 Microsoft Corporation

Module Name:

    drive.cxx

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#if 0
#include "error.hxx"
#include "drive.hxx"
#include "rtmsg.h"
#include "message.hxx"
#include "numset.hxx"
#include "dcache.hxx"
#include "hmem.hxx"
#include "ifssys.hxx"
#endif

#if !defined( _EFICHECK_ )
extern "C" {
#include <stdio.h>
#include <ntdddisk.h>
};
#endif

//#define TRAP_A_WRITE    1
//#define TRAP_A_READ     1

// Don't lock down more that 64K for IO.
CONST   MaxIoSize   = 65536;

DEFINE_CONSTRUCTOR( DRIVE, OBJECT );

VOID
DRIVE::Construct (
        )
/*++

Routine Description:

    Contructor for DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
        // unreferenced parameters
        (void)(this);
}


DRIVE::~DRIVE(
    )
/*++

Routine Description:

    Destructor for DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


BOOLEAN
DRIVE::Initialize(
    IN      PCWSTRING    NtDriveName,
    IN OUT  PMESSAGE     Message
    )
/*++

Routine Description:

    This routine initializes a drive object.

Arguments:

    NtDriveName - Supplies an NT style drive name.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!NtDriveName) {
        Destroy();
        return FALSE;
    }

    if (!_name.Initialize(NtDriveName)) {
        Destroy();
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }

    return TRUE;
}


VOID
DRIVE::Destroy(
    )
/*++

Routine Description:

    This routine returns a DRIVE object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
        // unreferenced parameters
        (void)(this);
}


DEFINE_EXPORTED_CONSTRUCTOR( DP_DRIVE, DRIVE, IFSUTIL_EXPORT );

VOID
DP_DRIVE::Construct (
        )
/*++

Routine Description:

    Constructor for DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    memset(&_actual, 0, sizeof(DRTYPE));
    _supported_list = NULL;
    _num_supported = 0;
    _alignment_mask = 0;
    _last_status = 0;
    _handle = 0;
    _alternate_handle = 0;
    _hosted_drive = FALSE;
    _super_floppy = FALSE;
    _is_writeable = FALSE;
    _block_io = NULL;
    _disk_io  = NULL;
}


IFSUTIL_EXPORT
DP_DRIVE::~DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

NTSTATUS
DP_DRIVE::OpenDrive(
    IN      PCWSTRING   NtDriveName,
    IN      ACCESS_MASK DesiredAccess,
    IN      BOOLEAN     ExclusiveWrite,
#if defined(_EFICHECK_)
    OUT     EFI_BLOCK_IO ** BlockIoPtr,
    OUT     EFI_DISK_IO  ** DiskIoPtr,
#else
    OUT     PHANDLE     Handle,
    OUT     PHANDLE     Handle,
#endif
    OUT     PULONG      Alignment,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This method is a worker function for the Initialize methods,
    to open a volume and determine its alignment requirement.

Arguments:

    NtDriveName     - Supplies the name of the drive.
    DesiredAccess   - Supplies the access the client desires to the volume.
    ExclusiveWrite  - Supplies a flag indicating whether the client
                      wishes to exclude other write handles.
    Handle          - Receives the handle to the opened volume.
    Alignment       - Receives the alignment requirement for the volume.
    Message         - Supplies an outlet for messages.

Return Value:

    TRUE upon successful completion.


--*/
{
    DEBUG((D_INFO,(CHAR8*)"Entering OpenDrive.\n"));

    WSTR * origName = (WSTR*)NtDriveName->GetWSTR();
    EFI_DEVICE_PATH * devPath = NULL;
    EFI_DEVICE_PATH * devPathPos = NULL;
    EFI_DEVICE_PATH * newDevPath = NULL;
    EFI_DEVICE_PATH * nextDevPath;

    EFI_GUID blk_io_guid = BLOCK_IO_PROTOCOL;
    EFI_GUID dsk_io_guid = DISK_IO_PROTOCOL;

    EFI_HANDLE  handle = NULL;
    EFI_STATUS  status;

    // first we get the device path from the corresponding name

    DEBUG((D_INFO,(CHAR8*)"Attempting to open %s\n", origName ));

    devPath = (EFI_DEVICE_PATH*)ShellGetMap(origName);
    if( devPath == NULL ) {
        DEBUG((D_ERROR,(CHAR8*)"DP_DRIVE::OpenDrive was passed a bogus device name.\n"));
        return STATUS_INVALID_PARAMETER;
    }
    DEBUG((D_INFO,(CHAR8*)"Mapped to %s\n",DevicePathToStr(devPath)));

    // now we query to see if the device supports BLOCK_IO

    devPathPos = devPath;
    // LocateDevicePath advances the pointer
    status = BS->LocateDevicePath(
        &blk_io_guid,
        &devPathPos, // this is an IN OUT param
        &handle
        );

    if( status != EFI_SUCCESS ) {
        // we were passed a bogus drive path
        DEBUG((D_ERROR,(CHAR8*)"DP_DRIVE::OpenDrive was passed a bogus device name.\n"));
        return STATUS_INVALID_PARAMETER;
    }

    // now we retrieve the interface pointer from the object
    BS->HandleProtocol(handle, &blk_io_guid, (VOID**)BlockIoPtr);

    BS->HandleProtocol(handle, &dsk_io_guid, (VOID**)DiskIoPtr);

    if( (*BlockIoPtr)->Media->IoAlign == 0 ) {
        // the IoAlign field can't be zero! we are always at least byte aligned.
        return STATUS_UNSUCCESSFUL;
    }
    *Alignment = (*BlockIoPtr)->Media->IoAlign - 1;
    DEBUG((D_INFO,(CHAR8*)"Io Alignment mask is %d\n", *Alignment ));

    //
    // While we are here lets get some things we will need for twiddling the
    // partition table later on.
    //

    newDevPath = DuplicateDevicePath( devPath );
    if ( !newDevPath ) {
        DEBUG((D_ERROR,(CHAR8*)"DP_DRIVE::OpenDrive failed to get MBR device.\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // We have a copy of the partition device path.  Now cut that down to just the
    // device file path.
    //

    nextDevPath = newDevPath;

    while (DevicePathType(nextDevPath) != MEDIA_DEVICE_PATH &&
           DevicePathType(nextDevPath) != END_DEVICE_PATH_TYPE) {
        DEBUG((D_INFO,(CHAR8*)"NextDevPath: %d,%d,%d,%s\n",
                 nextDevPath->Type,
                 nextDevPath->SubType,
                 *(USHORT*)nextDevPath->Length,
                 DevicePathToStr(nextDevPath)));
        nextDevPath = NextDevicePathNode( nextDevPath );
    }

    DEBUG((D_INFO,(CHAR8*)"Final nextDevPath: %d,%d,%d\n",
             nextDevPath->Type,
             nextDevPath->SubType,
             *(USHORT*)nextDevPath->Length));

    if (DevicePathType(nextDevPath) != END_DEVICE_PATH_TYPE) {

        //
        // Get the partition number before we destroy this
        //

        _partition_number = ( ( UNALIGNED HARDDRIVE_DEVICE_PATH * ) nextDevPath ) -> PartitionNumber;

        DEBUG((D_INFO,(CHAR8*)"Partition Number %d\n", _partition_number));

        SetDevicePathEndNode( nextDevPath );

    } else {
        DEBUG((D_INFO,(CHAR8*)"There is no partition\n"));
        _partition_number = 0;
    }

    //
    // Get the BLOCK_IO_PROTOCOL for the base disk device
    //

    devPathPos = newDevPath;            // LocateDevicePath advances the pointer

    status = BS->LocateDevicePath(
        &blk_io_guid,
        &devPathPos, // this is an IN OUT param
        &handle
        );

    if( status != EFI_SUCCESS ) {
        // we were passed a bogus drive path
        DEBUG((D_ERROR,(CHAR8*)"DP_DRIVE::OpenDrive couldn't get base disk block_io.\n"));
        return STATUS_UNSUCCESSFUL;
    }

    // now we retrieve the interface pointer from the object
    BS->HandleProtocol(handle, &blk_io_guid, (VOID**)&_device_block_io);

    BS->HandleProtocol(handle, &dsk_io_guid, (VOID**)&_device_disk_io);

    DEBUG((D_INFO,(CHAR8*)"Leaving OpenDrive.\n"));

    return STATUS_SUCCESS;
}


IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     IsTransient,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes a DP_DRIVE object based on the supplied drive
    path.

Arguments:

    NtDriveName     - Supplies the drive path.
    Message         - Supplies an outlet for messages.
    IsTransient     - Supplies whether or not to keep the handle to the
                        drive open beyond this method.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONST NumMediaTypes         = 20;

    DISK_GEOMETRY               disk_geometry;
    PARTITION_INFORMATION       partition_info;
    BOOLEAN                     partition;
    MSGID                       MessageId;

    Destroy();

    DEBUG((D_INFO,(CHAR8*)"Entering DP_DRIVE::Initialize\n"));

    if (!DRIVE::Initialize(NtDriveName, Message)) {
        Destroy();
        return FALSE;
    }

    _last_status = OpenDrive( NtDriveName,
                              NULL,     // EFI: doesn't have access permissions.
                              ExclusiveWrite, // EFI: this will be ignored for EFI.
                              &_block_io,         // EFI: this will return an interface pointer
                              &_disk_io,
                              &_alignment_mask, // EFI: this will return the correct alignment mask.
                              Message );


    if(!NT_SUCCESS(_last_status)) {

        Destroy();

        DEBUG((D_ERROR,(CHAR8*)"IFSUTIL: Can't open drive. Status returned = %x.\n", _last_status));
        MessageId = MSG_CANT_DASD;
        Message ? Message->Set(MessageId) : 1;
        Message ? Message->Display() : 1;

        return FALSE;
    }

    _is_writeable = !(_block_io->Media->ReadOnly);

    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: _is_writeable %d\n", !(_block_io->Media->ReadOnly)));

    _media_id = _block_io->Media->MediaId;

    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: _media_id %d\n", _block_io->Media->MediaId));

    //
    // Record that this is not a hosted volume:
    //
    _hosted_drive = FALSE;

    if( !(_block_io->Media->MediaPresent) ) {
        MessageId = MSG_CANT_DASD;
        Message ? Message->DisplayMsg(MessageId) : 1;
        return FALSE;
    }

    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: MediaPresent %d\n", _block_io->Media->MediaPresent));

    // BUGBUG  in EFI we can't get the exact media type, should we care?
    memset(&disk_geometry, 0, sizeof(DISK_GEOMETRY));
    disk_geometry.MediaType = Unknown;

    partition = (_block_io->Media->LogicalPartition);

    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: IsPartition %d\n", _block_io->Media->LogicalPartition));

#if 0
    // BUGBUG Try to read the partition entry.
    if (disk_geometry.MediaType == FixedMedia ||
        disk_geometry.MediaType == RemovableMedia) {

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_PARTITION_INFO,
                                             NULL, 0, &partition_info,
                                             sizeof(PARTITION_INFORMATION));

        partition = (BOOLEAN) NT_SUCCESS(_last_status);

        if (!NT_SUCCESS(_last_status) &&
            _last_status != STATUS_INVALID_DEVICE_REQUEST) {
            DebugPrintTrace(("IFSUTIL: Can't read partition entry. Status returned = %x.\n", _last_status));
            Destroy();
            Message ? Message->DisplayMsg(MSG_READ_PARTITION_TABLE) : 1;
            return FALSE;
        }

    }

#endif // removed for EFI

    disk_geometry.MediaType = (_block_io->Media->RemovableMedia) ? RemovableMedia : FixedMedia;
    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: MediaType %x\n", disk_geometry.MediaType));

    disk_geometry.BytesPerSector = _block_io->Media->BlockSize;
    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: blocksize %x\n", disk_geometry.BytesPerSector));

    // I fake the cylinder count
    disk_geometry.Cylinders.QuadPart = (ULONGLONG)(_block_io->Media->LastBlock)+1;
    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: cylcount %x\n", disk_geometry.Cylinders.QuadPart));

    disk_geometry.SectorsPerTrack = 1;
    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: sec/trk %x\n", disk_geometry.SectorsPerTrack));
    disk_geometry.TracksPerCylinder = 1;
    DEBUG((D_INFO,(CHAR8*)"DP_DRIVE::Initialize: trk/cyl %x\n", disk_geometry.TracksPerCylinder));

    partition_info.BootIndicator = FALSE;
    partition_info.HiddenSectors = 0;
    partition_info.PartitionLength.QuadPart = ((ULONGLONG)_block_io->Media->LastBlock+1) * (ULONGLONG)_block_io->Media->BlockSize;
    partition_info.PartitionNumber = 1;
    partition_info.PartitionType = 0xEF; // BUGBUG need a const
    partition_info.RecognizedPartition = TRUE;
    partition_info.RewritePartition = FALSE;
    partition_info.StartingOffset.QuadPart = (ULONGLONG)0;

    DEBUG((D_INFO, (CHAR8*)"DP_DRIVE:: Initialize: PartitionLength %x\n", partition_info.PartitionLength.QuadPart));

    // Store the information in the class.
    if (partition) {
        DiskGeometryToDriveType(&disk_geometry,
                                partition_info.PartitionLength/
                                disk_geometry.BytesPerSector,
                                partition_info.HiddenSectors,
                                &_actual);
    } else {

        DiskGeometryToDriveType(&disk_geometry, &_actual);

#if 0
        if (IsFloppy()) {


            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                 &status_block,
                                                 IOCTL_DISK_GET_MEDIA_TYPES,
                                                 NULL, 0, media_types,
                                                 NumMediaTypes*
                                                 sizeof(DISK_GEOMETRY));

            if (!NT_SUCCESS(_last_status)) {
                Destroy();
                if (Message) {

                    MSGID   MessageId;

                    switch (_last_status) {
                        case STATUS_NO_MEDIA_IN_DEVICE:
                            MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                            break;

                        case STATUS_DEVICE_BUSY:
                        case STATUS_DEVICE_NOT_READY:
                            MessageId = MSG_DEVICE_BUSY;
                            break;

                        default:
                            MessageId = MSG_BAD_IOCTL;
                            break;
                    }
                    Message->DisplayMsg(MessageId);
                }
                return FALSE;
            }



            _num_supported = (INT) (status_block.Information/
                                    sizeof(DISK_GEOMETRY));

            if (!_num_supported) {
                Destroy();
                if (Message) {
                    Message->DisplayMsg(MSG_BAD_IOCTL);
                }
                return FALSE;
            }


            if (!(_supported_list = NEW DRTYPE[_num_supported])) {
                Destroy();
                Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
                return FALSE;
            }

            for (i = 0; i < _num_supported; i++) {
                DiskGeometryToDriveType(&media_types[i], &_supported_list[i]);
            }
        }
#endif
    }

    if (!_num_supported) {
        _num_supported = 1;

        if (!(_supported_list = NEW DRTYPE[1])) {
            Destroy();
            Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
            return FALSE;
        }

        _supported_list[0] = _actual;
    }

    //
    // Determine whether the media is a super-floppy; non-floppy
    // removable media which is not partitioned.  Such media will
    // have but a single partition, normal media will have at least 4.
    //

// BUGBUG removed for EFI
#if 0
    if (disk_geometry.MediaType == RemovableMedia) {

        CONST INT EntriesPerBootRecord = 4;
        CONST INT MaxLogicalVolumes = 23;
        CONST INT Length =  sizeof(DRIVE_LAYOUT_INFORMATION) +
                            EntriesPerBootRecord * (MaxLogicalVolumes + 1) *
                                sizeof(PARTITION_INFORMATION);

        UCHAR buf[Length];

        DRIVE_LAYOUT_INFORMATION *layout_info = (DRIVE_LAYOUT_INFORMATION *)buf;

        _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                             &status_block,
                                             IOCTL_DISK_GET_DRIVE_LAYOUT,
                                             NULL, 0, layout_info,
                                             Length);

        if (!NT_SUCCESS(_last_status)) {
            Destroy();
            if (Message) {

                MSGID   MessageId;

                switch (_last_status) {
                    case STATUS_NO_MEDIA_IN_DEVICE:
                        MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                        break;

                    case STATUS_DEVICE_BUSY:
                    case STATUS_DEVICE_NOT_READY:
                        MessageId = MSG_DEVICE_BUSY;
                        break;

                    default:
                        MessageId = MSG_BAD_IOCTL;
                        break;
                }
                Message->DisplayMsg(MessageId);
            }
            return FALSE;
        }

        if (layout_info->PartitionCount < 4) {

            _super_floppy = TRUE;
        }
    }

    if (!IsTransient) {
        NtClose(_handle);
        _handle = 0;
    }
#endif // removed for EFI

    DEBUG((D_INFO,(CHAR8*)"Leaving DP_DRIVE::Initialize\n"));
    return TRUE;

}


IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     IsTransient,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This method initializes a hosted drive, i.e. a volume which
    is implemented as a file on another volume.  Instead of opening
    this file by its actual name, we open it by the host file name,
    to prevent interactions with the file system.

Arguments:

    NtDriveName     - Supplies the NT name of the drive itself.
    HostFileName    - Supplies the fully qualified name of the file
                      which contains this drive.
    Message         - Supplies an outlet for messages.
    IsTransient     - Supplies whether or not to keep the handle to the
                        drive open beyond this method.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    TRUE upon successful completion.

--*/
{
// removed hosted support for EFI
#if 0

    FILE_STANDARD_INFORMATION FileStandardInfo;
    IO_STATUS_BLOCK StatusBlock;
    BIG_INT Sectors, FileSize;
    ULONG AlignmentMask, ExtraUlong;


    Destroy();

    if( !DRIVE::Initialize(HostFileName, Message)) {

        Destroy();
        return FALSE;
    }

    _hosted_drive = TRUE;

    // First, make the host file not-readonly.
    //
    if( !IFS_SYSTEM::FileSetAttributes( HostFileName,
                                        FILE_ATTRIBUTE_NORMAL,
                                        &_old_attributes ) ) {

        Message ? Message->DisplayMsg( MSG_CANT_DASD ) : 1;
        Destroy();
        return FALSE;
    }

    _last_status = OpenDrive( HostFileName,
                              SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA |
                                FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                              ExclusiveWrite,
                              &_handle,
                              &_alignment_mask,
                              Message );

    if( !NT_SUCCESS( _last_status ) ) {

        IFS_SYSTEM::FileSetAttributes( HostFileName,
                                       _old_attributes,
                                       &ExtraUlong );

        DEBUG((D_ERROR,(CHAR8*)"IFSUTIL: Can't open drive. Status returned = %x.\n", _last_status));
        Destroy();
        return FALSE;
    }

    if( NtDriveName ) {

        _last_status = OpenDrive( NtDriveName,
                                  SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                  ExclusiveWrite,
                                  &_alternate_handle,
                                  &AlignmentMask,
                                  Message );
    }

    _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                         &StatusBlock,
                                         IOCTL_DISK_IS_WRITABLE,
                                         NULL, 0, NULL, 0);

    _is_writeable = (_last_status != STATUS_MEDIA_WRITE_PROTECTED);

    // Fill in the drive type information.  Everything except the
    // Sectors field is fixed by default.  The number of Sectors
    // on the drive is determined from the host file's size.
    //
    _actual.MediaType = HostedDriveMediaType;
    _actual.SectorSize = HostedDriveSectorSize;
    _actual.HiddenSectors = HostedDriveHiddenSectors;
    _actual.SectorsPerTrack = HostedDriveSectorsPerTrack;
    _actual.Heads = HostedDriveHeads;

    _last_status = NtQueryInformationFile( _handle,
                                           &StatusBlock,
                                           &FileStandardInfo,
                                           sizeof( FileStandardInfo ),
                                           FileStandardInformation );

    if( !NT_SUCCESS( _last_status ) ) {

        Destroy();
        Message ? Message->DisplayMsg( MSG_DISK_TOO_LARGE_TO_FORMAT ) : 1;
        return FALSE;
    }

    FileSize = FileStandardInfo.EndOfFile;
    Sectors = FileSize / _actual.SectorSize;

    if( Sectors.GetHighPart() != 0 ) {

        Destroy();
        Message ? Message->DisplayMsg( MSG_BAD_IOCTL ) : 1;
        return FALSE;
    }

    _actual.Sectors = Sectors.GetLargeInteger();


    // This drive has only one supported drive type
    //
    _num_supported = 1;

    if (!(_supported_list = NEW DRTYPE[1])) {
        Destroy();
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }

    _supported_list[0] = _actual;

    // If this was a transient open, clean it up.
    //
    if (!IsTransient) {

        IFS_SYSTEM::FileSetAttributes( _handle, _old_attributes, &ExtraUlong );
        NtClose(_handle);
        _alternate_handle ? NtClose(_alternate_handle) : 1;
        _handle = 0;
        _alternate_handle = 0;
    }

#endif
    return FALSE;
}


IFSUTIL_EXPORT
ULONG
DP_DRIVE::QuerySectorSize(
    ) CONST
/*++

Routine Description:

    This routine computes the number of bytes per sector.

Arguments:

    None.

Return Value:

    The number of bytes per sector.

--*/
{
    return _actual.SectorSize;
}

// BUGBUG EFI doesn't need this
#if 0
#if defined(FE_SB) && defined(_X86_)
IFSUTIL_EXPORT
ULONG
DP_DRIVE::QueryPhysicalSectorSize(
    ) CONST
/*++

Routine Description:

    This routine computes the number of bytes per sector.

Arguments:

    None.

Return Value:

    The number of bytes per physical sector.

--*/
{
    return _actual.PhysicalSectorSize;
}
#endif
#endif // removed for EFI

IFSUTIL_EXPORT
BIG_INT
DP_DRIVE::QuerySectors(
    ) CONST
/*++

Routine Description:

    This routine computes the number sectors on the disk.  This does not
    include the hidden sectors.

Arguments:

    None.

Return Value:

    The number of sectors on the disk.

--*/
{
    return _actual.Sectors;
}


IFSUTIL_EXPORT
UCHAR
DP_DRIVE::QueryMediaByte(
        ) CONST
/*++

Routine Description:

        This routine computes the media byte used by the FAT and HPFS file
        systems to represent the current media type.

Arguments:

        None.

Return Value:

        The media byte for the drive.

--*/
{
    switch (_actual.MediaType) {
        case F5_1Pt2_512:   // 5.25", 1.2MB,  512 bytes/sector
            return 0xF9;

       case F3_1Pt44_512:   // 3.5",  1.44MB, 512 bytes/sector
            return 0xF0;

        case F3_2Pt88_512:  // 3.5",  2.88MB, 512 bytes/sector
            return 0xF0;

        case F3_120M_512:   // 3.5",  120MB,  512 bytes/sector
            return 0xF0;

        case F3_20Pt8_512:  // 3.5",  20.8MB, 512 bytes/sector
            return 0xF9;

        case F3_720_512:    // 3.5",  720KB,  512 bytes/sector
            return 0xF9;

        case F5_360_512:    // 5.25", 360KB,  512 bytes/sector
            return 0xFD;

        case F5_320_512:    // 5.25", 320KB,  512 bytes/sector
            return 0xFF;

        case F5_180_512:    // 5.25", 180KB,  512 bytes/sector
            return 0xFC;

        case F5_160_512:    // 5.25", 160KB,  512 bytes/sector
            return 0xFE;

        case RemovableMedia:// Removable media other than floppy
            return 0xF8;    // There is no better choice than this.

        case FixedMedia:    // Fixed hard disk media
#if defined(FE_SB) && defined(_X86_)
            // FMR Jul.13.1994 SFT KMR
            // Add the set up process for the fixed_hard_disk_mediaID for FMR
            // FMR's media id is different. Case under 64MB or not.

            if(IsFMR_N()) {
                if(_actual.SectorSize * _actual.Sectors <= 63*1024*1024) {
                    return 0xF9;
                } else {
                    return 0xFA;
                }
            } else
#endif
            return 0xF8;

#if defined(FE_SB)
        case F3_128Mb_512:  // 3.5"MO, 128MB, 512 bytes/sector
        case F3_230Mb_512:  // 3.3"MO, 230MB, 512 bytes/sector
            return 0xF0;

#if defined(_X86_)
        // NEC Oct.15.1994
        // FMR Jul.14.1994 SFT KMR

        // For 8"1S , 256KB , 128 bytes/sector
        // If the media_type is 2HD, return the mediaID:FE

        case F8_256_128:    // 8"1S , 256KB , 128 bytes/sector
        case F5_1Pt23_1024: // 5.25", 1.23MB,  1024 bytes/sector
        case F3_1Pt23_1024: // 3.5",  1.23MB,  1024 bytes/sector
            return 0xFE;

        // If the media_type is 2HC, return the mediaID:F9
        // If the media_type is 2DD(720KB), return the mediaID:F9

        case F5_720_512:    // 5.25",  720KB,  512 bytes/sector
        case F3_1Pt2_512:   // 3.5",  1.2MB,    512 bytes/sector
            return 0xF9;

        // If the media_type is 2DD(640KB), return the mediaID:FB

        case F5_640_512:    // 5",    640KB,  512 bytes/sector
        case F3_640_512:    // 3.5",  640KB,  512 bytes/sector
            return 0xFB;
#endif // _X86_
#endif // FE_SB

        case F5_320_1024:
        case Unknown:
            break;

    }
    return 0;
}


VOID
DP_DRIVE::Destroy(
        )
/*++

Routine Description:

    This routine returns a DP_DRIVE to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{

    memset(&_actual, 0, sizeof(DRTYPE));
    DELETE_ARRAY(_supported_list);
    _num_supported = 0;
    _alignment_mask = 0;

// BUGBUG removed for EFI
#if 0
    if (_hosted_drive) {

        IFS_SYSTEM::FileSetAttributes( _handle, _old_attributes, &ExtraUlong );
    }

    if (_alternate_handle) {

        NtClose(_alternate_handle);
        _alternate_handle = 0;
    }

    if (_handle) {

        NtClose(_handle);
        _handle = 0;
    }
#endif

    _hosted_drive = FALSE;
}


VOID
DP_DRIVE::CloseDriveHandle(
    )
{
#if 0
    if (_handle) {
// BUGBUG removed for EFI
        NtClose(_handle);
        _handle = 0;
    }
#endif
}


BOOLEAN
DP_DRIVE::IsSupported(
    IN  MEDIA_TYPE  MediaType
    ) CONST
/*++

Routine Description:

    This routine computes whether or not the supplied media type is supported
    by the drive.

Arguments:

    MediaType   - Supplies the media type.

Return Value:

    FALSE   - The media type is not supported by the drive.
    TRUE    - The media type is supported by the drive.

--*/
{
    INT i;

    for (i = 0; i < _num_supported; i++) {
        if (MediaType == _supported_list[i].MediaType) {
            return TRUE;
        }
    }

    return FALSE;
}


IFSUTIL_EXPORT
MEDIA_TYPE
DP_DRIVE::QueryRecommendedMediaType(
    ) CONST
/*++

Routine Description:

    This routine computes the recommended media type for
    drive.  This media type is independant of any existing
    media type for the drive.  It is solely based on the
    list of recommended media types for the drive.

Arguments:

    None.

Return Value:

    The recommended media type for the drive.

--*/
{
    INT         i;
    MEDIA_TYPE  media_type;
    SECTORCOUNT sectors;

    media_type = Unknown;
    sectors = 0;
    for (i = 0; i < _num_supported; i++) {

        // Special case 1.44.  If a drive supports it then
        // that should be the recommended media type.

        if (_supported_list[i].MediaType == F3_1Pt44_512) {
            media_type = _supported_list[i].MediaType;
            break;
        }

        if (_supported_list[i].Sectors > sectors) {
            media_type = _supported_list[i].MediaType;
        }
    }

    return media_type;
}

BOOLEAN
DP_DRIVE::SetMediaType(
    IN  MEDIA_TYPE  MediaType
    )
/*++

Routine Description:

    This routine alters the media type of the drive.  If 'MediaType' is
    'Unknown' and the current media type for the drive is also 'Unknown'
    then this routine selects the highest density supported by the
    driver.  If the current media type is known then this function
    will have no effect if 'MediaType' is 'Unknown'.

Arguments:

    MediaType   - Supplies the new media type for the drive.

Return Value:

    FALSE   - The proposed media type is not supported by the drive.
    TRUE    - Success.

--*/
{
    INT i;

    if (MediaType == Unknown) {
        if (_actual.MediaType != Unknown) {
            return TRUE;
        } else if (!_num_supported) {
            return FALSE;
        }

        for (i = 0; i < _num_supported; i++) {
            if (_supported_list[i].Sectors > QuerySectors()) {
                _actual = _supported_list[i];
            }
        }

        return TRUE;
    }

    for (i = 0; i < _num_supported; i++) {
        if (_supported_list[i].MediaType == MediaType) {
            _actual = _supported_list[i];
            return TRUE;
        }
    }

    return FALSE;
}


VOID
DP_DRIVE::DiskGeometryToDriveType(
    IN  PCDISK_GEOMETRY DiskGeometry,
    OUT PDRTYPE         DriveType
    )
/*++

Routine Description:

    This routine computes the drive type given the disk geometry.

Arguments:

    DiskGeometry    - Supplies the disk geometry for the drive.
    DriveType       - Returns the drive type for the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DriveType->MediaType = DiskGeometry->MediaType;
    DriveType->SectorSize = DiskGeometry->BytesPerSector;
    DriveType->Sectors = DiskGeometry->Cylinders*
                         DiskGeometry->TracksPerCylinder*
                         DiskGeometry->SectorsPerTrack;
    DriveType->HiddenSectors = 0;
    DriveType->SectorsPerTrack = DiskGeometry->SectorsPerTrack;
    DriveType->Heads = DiskGeometry->TracksPerCylinder;
}


VOID
DP_DRIVE::DiskGeometryToDriveType(
    IN  PCDISK_GEOMETRY DiskGeometry,
    IN  BIG_INT         NumSectors,
    IN  BIG_INT         NumHiddenSectors,
    OUT PDRTYPE         DriveType
    )
/*++

Routine Description:

    This routine computes the drive type given the disk geometry.

Arguments:

    DiskGeometry        - Supplies the disk geometry for the drive.
    NumSectors          - Supplies the total number of non-hidden sectors on
                        the disk.
    NumHiddenSectors    - Supplies the number of hidden sectors on the disk.
    DriveType           - Returns the drive type for the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DriveType->MediaType = DiskGeometry->MediaType;
    DriveType->SectorSize = DiskGeometry->BytesPerSector;
    DriveType->Sectors = NumSectors;
    DriveType->HiddenSectors = NumHiddenSectors;
    DriveType->SectorsPerTrack = DiskGeometry->SectorsPerTrack;
    DriveType->Heads = DiskGeometry->TracksPerCylinder;
}

#if defined(FE_SB) && defined(_X86_)
IFSUTIL_EXPORT
BOOLEAN
DP_DRIVE::IsATformat(
    ) CONST
/*++

Routine Description:

    This routine judged whether it is AT format.

Arguments:

    None.

Return Value:

    FALSE   - The disk is not AT format.
    TRUE    - The disk is AT format.

History:

    PC98 Oct.21.1995

--*/
{
    return _next_format_type == FORMAT_MEDIA_AT;
}
#endif


DEFINE_CONSTRUCTOR( IO_DP_DRIVE, DP_DRIVE );

VOID
IO_DP_DRIVE::Construct (
        )

/*++

Routine Description:

    Constructor for IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _is_locked = FALSE;
    _is_exclusive_write = FALSE;
    _cache = NULL;
    _ValidBlockLengthForVerify = 0;
    _message = NULL;
}


VOID
IO_DP_DRIVE::Destroy(
    )
/*++

Routine Description:

    This routine returns an IO_DP_DRIVE object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE(_cache);

    if (_is_exclusive_write) {
        Dismount();
        _is_exclusive_write = FALSE;
    }

    if (_is_locked) {
        Unlock();
        _is_locked = FALSE;
    }

    _ValidBlockLengthForVerify = 0;
    _message = NULL;
}


IO_DP_DRIVE::~IO_DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


BOOLEAN
IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes an IO_DP_DRIVE object.

Arguments:

    NtDriveName     - Supplies the drive path.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if (!DP_DRIVE::Initialize(NtDriveName, Message, TRUE, ExclusiveWrite)) {
        Destroy();
        return FALSE;
    }

    _is_exclusive_write = ExclusiveWrite;

    if (!(_cache = NEW DRIVE_CACHE) ||
        !_cache->Initialize(this)) {

        Destroy();
        return FALSE;
    }

    _ValidBlockLengthForVerify = 0;
    _message = Message;

    return TRUE;
}

BOOLEAN
IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes an IO_DP_DRIVE object for a hosted
    drive, i.e. one which is implemented as a file on another
    volume.

Arguments:

    NtDriveName     - Supplies the drive path.
    HostFileName    - Supplies the fully qualified name of the host file.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    Destroy();

    if( !DP_DRIVE::Initialize(NtDriveName,
                              HostFileName,
                              Message,
                              TRUE,
                              ExclusiveWrite)) {
        Destroy();
        return FALSE;
    }

    _is_exclusive_write = ExclusiveWrite;

    if (!(_cache = NEW DRIVE_CACHE) ||
        !_cache->Initialize(this)) {

        Destroy();
        return FALSE;
    }

    _ValidBlockLengthForVerify = 0;
    _message = Message;

    return TRUE;
}

IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads a run of sectors into the buffer pointed to by
    'Buffer'.

Arguments:

    StartingSector  - Supplies the first sector to be read.
    NumberOfSectors - Supplies the number of sectors to be read.
    Buffer          - Supplies a buffer to read the run of sectors into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_cache);
    return _cache->Read(StartingSector, NumberOfSectors, Buffer);
}


IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Write(
    BIG_INT     StartingSector,
    SECTORCOUNT NumberOfSectors,
    PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes a run of sectors onto the disk from the buffer pointed
    to by 'Buffer'.  Writing is only permitted if 'Lock' was called.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_cache);
    return _cache->Write(StartingSector, NumberOfSectors, Buffer);
}


IFSUTIL_EXPORT
VOID
IO_DP_DRIVE::SetCache(
    IN OUT  PDRIVE_CACHE    Cache
    )
/*++

Routine Description:

    This routine relaces the current cache with the one supplied.
    The object then takes ownership of this cache and it will be
    deleted by the object.

Arguments:

    Cache   - Supplies the new cache to install.

Return Value:

    TRUE    - Success.
    FALSE   - Failure.

--*/
{
    DebugAssert(Cache);
    DELETE(_cache);
    _cache = Cache;
}


IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::FlushCache(
    )
/*++

Routine Description:

    This routine flushes the cache and report returns whether any
    IO error occurred during the life of the cache.

Arguments:

    None.

Return Value:

    FALSE   - Some IO errors have occured during the life of the cache.
    TRUE    - Success.

--*/
{
    DebugAssert(_cache);
    return _cache->Flush();
}


BOOLEAN
IO_DP_DRIVE::HardRead(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads a run of sectors into the buffer pointed to by
    'Buffer'.

Arguments:

    StartingSector      - Supplies the first sector to be read.
    NumberOfSectors     - Supplies the number of sectors to be read.
    Buffer              - Supplies a buffer to read the run of sectors into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // allocate a buffer
    PVOID AlignedBuffer = NULL;
    PVOID AlignedBufferRaw = AllocatePool(NumberOfSectors*QuerySectorSize()+QueryAlignmentMask()+1);

    if(!AlignedBufferRaw) {
        DEBUG((D_ERROR,(CHAR8*)"HardRead: Aligned buffer allocation failed!!!!!!\n"));
        return FALSE;
    }

    // align the buffer according to the mask provided
    AlignedBuffer = (PVOID)(( (ULONG_PTR)AlignedBufferRaw + QueryAlignmentMask() ) & ~((ULONG_PTR)QueryAlignmentMask()));

    EFI_STATUS status =
    status = _disk_io->ReadDisk(
        _disk_io,
        _media_id,
        MultU64x32(StartingSector.GetQuadPart(),_block_io->Media->BlockSize),
        NumberOfSectors*QuerySectorSize(),
        AlignedBuffer
        );

    if(status != EFI_SUCCESS) {
        FreePool(AlignedBufferRaw);
        DEBUG((D_ERROR,(CHAR8*)"HardRead: Read Failed %x!!!!!!\n", status));
        return FALSE;
    }

    memcpy(Buffer,AlignedBuffer,NumberOfSectors*QuerySectorSize());

    FreePool(AlignedBufferRaw);

    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::HardWrite(
    BIG_INT     StartingSector,
    SECTORCOUNT NumberOfSectors,
    PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes a run of sectors onto the disk from the buffer pointed
    to by 'Buffer'.  Writing is only permitted if 'Lock' was called.

    After writing each chunk, we read it back to make sure the write
    really succeeded.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // allocate a buffer
    PVOID       AlignedBuffer;
    ULONG       Length = NumberOfSectors*QuerySectorSize();
    PVOID       AlignedBufferRaw = NULL;
    EFI_STATUS  status;

    DEBUG((D_INFO, (CHAR8*)"HardWrite: At %x for %x sectors\n",
             StartingSector,
             NumberOfSectors));

    //
    // Align buffer only if needed
    //
    if (QueryAlignmentMask()) {

        DEBUG((D_INFO, (CHAR8*)"HardWrite: Buffer requires alignment\n"));

        AlignedBufferRaw = AllocatePool(Length+QueryAlignmentMask()+1);

        if(!AlignedBufferRaw) {
            DEBUG((D_ERROR, (CHAR8*)"HardWrite: Aligned buffer allocation failed!!!!!!\n"));
            return FALSE;
        }

        AlignedBuffer = (PVOID)(( (ULONG_PTR)AlignedBufferRaw + QueryAlignmentMask() ) &
                                ~((ULONG_PTR)QueryAlignmentMask()) );

        memcpy(AlignedBuffer, Buffer, NumberOfSectors*QuerySectorSize());

    } else {
        AlignedBuffer = Buffer;
    }

    // align the buffer according to the mask provided
    status = _disk_io->WriteDisk(
        _disk_io,
        _media_id,
        MultU64x32 (StartingSector.GetQuadPart(),_block_io->Media->BlockSize),
        Length,
        AlignedBuffer
        );

    if (status != EFI_SUCCESS) {
        DEBUG((D_ERROR,(CHAR8*)"HardWrite: Write Failed %x!!!!!!\n", status));
    }

    if (AlignedBufferRaw) {
        FreePool(AlignedBufferRaw);
    }

    return (status == EFI_SUCCESS);
}


IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Verify(
    IN  BIG_INT StartingSector,
    IN  BIG_INT NumberOfSectors,
    IN  PVOID   TestBuffer1,
    IN  PVOID   TestBuffer2
    )
/*++

Routine Description:

    This routine verifies a run of sectors on the disk.

Arguments:

    StartingSector  - Supplies the first sector of the run to verify.
    NumberOfSectors - Supplies the number of sectors in the run to verify.
    TestBuffer1     - Supplies a buffer containing test write data
    TestBuffer2     - Supplies a buffer containing test write data

Return Value:

    FALSE   - Some of the sectors in the run are bad.
    TRUE    - All of the sectors in the run are good.

--*/
{
    BIG_INT  VerifySize = QuerySectorSize() * NumberOfSectors;
    ULONG    Size = VerifySize.GetLowPart();
    PVOID    TempBuffer;
    BOOLEAN  result = TRUE;

    DEBUG((D_INFO, (CHAR8*)"Verify: Verifying %x sectors starting at %x\n",
             NumberOfSectors,
             StartingSector));

    DebugAssert(VerifySize.GetHighPart() == 0);

    // there is no guarantee that verify cmd will not destroy data
    // there may not be a need to restore the content

    TempBuffer = AllocatePool(Size);
    if (TempBuffer == NULL) {
        DEBUG((D_ERROR, (CHAR8*)"Verify: Out of memory\n"));
        return FALSE;
    }

    if (!HardWrite(StartingSector, NumberOfSectors.GetLowPart(), TestBuffer1) ||
        !HardRead(StartingSector, NumberOfSectors.GetLowPart(), TempBuffer) ||
        (CompareMem(TestBuffer1, TempBuffer, Size) != 0)) {
        result = FALSE;
    }

    if (result) {

        if (!HardWrite(StartingSector, NumberOfSectors.GetLowPart(), TestBuffer2) ||
            !HardRead(StartingSector, NumberOfSectors.GetLowPart(), TempBuffer) ||
            (CompareMem(TestBuffer2, TempBuffer, Size) != 0)) {
            result = FALSE;
        }
    }

    FreePool(TempBuffer);

    return result;
}


IFSUTIL_EXPORT
BOOLEAN
IO_DP_DRIVE::Verify(
    IN      BIG_INT         StartingSector,
    IN      BIG_INT         NumberOfSectors,
    IN OUT  PNUMBER_SET     BadSectors
    )
/*++

Routine Description:

    This routine computes which sectors in the given range are bad
    and adds these bad sectors to the bad sectors list.

Arguments:

    StartingSector  - Supplies the starting sector.
    NumberOfSectors - Supplies the number of sectors.
    BadSectors      - Supplies the bad sectors list.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       MaxSectorsInVerify = 0x200;
    ULONG       MaxDiskHits;
    BIG_INT     half;
    PBIG_INT    starts;
    PBIG_INT    run_lengths;
    ULONG       i, n;
    BIG_INT     num_sectors;
    PVOID       TestBuffer1;
    PVOID       TestBuffer2;

    DEBUG((D_INFO, (CHAR8*)"Entering Verify\n"));

    if (NumberOfSectors == 0) {
        DEBUG((D_INFO, (CHAR8*)"Leaving Verify as there is nothing to verify\n"));
        return TRUE;
    }

    if (NumberOfSectors.GetHighPart() != 0) {
        DEBUG((D_ERROR, (CHAR8*)"Verify: Number of sectors to verify exceeded 32 bits\n"));
        return FALSE;
    }

    // Allow 20 retries so that a single bad sector in this region
    // will be found accurately.

    MaxDiskHits = (20 + NumberOfSectors/MaxSectorsInVerify + 1).GetLowPart();

    starts = (PBIG_INT)AllocatePool(sizeof(BIG_INT)*MaxDiskHits);

    if (NULL == starts) {
        DEBUG((D_ERROR, (CHAR8*)"Verify: Out of memory\n"));
        return FALSE;
    }

    run_lengths = (PBIG_INT)AllocatePool(sizeof(BIG_INT)*MaxDiskHits);

    if (NULL == run_lengths) {
        DEBUG((D_ERROR, (CHAR8*)"Verify: Out of memory\n"));
        FreePool(starts);
        return FALSE;
    }

    num_sectors = NumberOfSectors;
    for (i = 0; num_sectors > 0; i++) {
        starts[i] = StartingSector + i*MaxSectorsInVerify;
        if (MaxSectorsInVerify > num_sectors) {
            run_lengths[i] = num_sectors;
        } else {
            run_lengths[i] = MaxSectorsInVerify;
        }
        num_sectors -= run_lengths[i];
    }

    TestBuffer1 = AllocatePool(MaxSectorsInVerify);
    TestBuffer2 = AllocatePool(MaxSectorsInVerify);

    if (NULL == TestBuffer2 || NULL == TestBuffer1) {
        DEBUG((D_ERROR, (CHAR8*)"Verify: Out of memory\n"));
        FreePool(TestBuffer1);
        FreePool(TestBuffer2);
        FreePool(starts);
        FreePool(run_lengths);
        return FALSE;
    }

    // fill with 1010s and 0101s
    SetMem(TestBuffer1, MaxSectorsInVerify, 0xAA);
    SetMem(TestBuffer2, MaxSectorsInVerify, 0x55);

    n = i;

    for (i = 0; i < n; i++) {

        if (!Verify(starts[i], run_lengths[i], TestBuffer1, TestBuffer2)) {

            if (BadSectors == NULL) {
                FreePool(TestBuffer1);
                FreePool(TestBuffer2);
                FreePool(starts);
                FreePool(run_lengths);
                return FALSE;
            }

            if (n + 2 > MaxDiskHits) {

                if (!BadSectors->Add(starts[i], run_lengths[i])) {
                    FreePool(TestBuffer1);
                    FreePool(TestBuffer2);
                    FreePool(starts);
                    FreePool(run_lengths);
                    return FALSE;
                }

            } else {

                if (run_lengths[i] == 1) {

                    if (!BadSectors->Add(starts[i])) {
                        FreePool(TestBuffer1);
                        FreePool(TestBuffer2);
                        FreePool(starts);
                        FreePool(run_lengths);
                        return FALSE;
                    }

                } else {

                    half = run_lengths[i]/2;

                    starts[n] = starts[i];
                    run_lengths[n] = half;
                    starts[n + 1] = starts[i] + half;
                    run_lengths[n + 1] = run_lengths[i] - half;

                    n += 2;
                }
            }
        }
    }

    FreePool(TestBuffer1);
    FreePool(TestBuffer2);
    FreePool(starts);
    FreePool(run_lengths);

    DEBUG((D_INFO, (CHAR8*)"Leaving Verify\n"));
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::VerifyWithRead(
    IN  BIG_INT StartingSector,
    IN  BIG_INT NumberOfSectors
    )
/*++

Routine Description:

    This routine verifies the usability of the given range of sectors
    using read.

Arguments:

    StartingSector      - Supplies the starting sector of the verify.
    Number OfSectors    - Supplies the number of sectors to verify.

Return Value:

    FALSE   - At least one of the sectors in the given range was unreadable.
    TRUE    - All of the sectors in the given range are readable.

--*/
{
    ULONG       grab;
    BIG_INT     i;
    CONST ULONG MaxIoSize = 0x200 * QuerySectorSize();
    PVOID       Buffer = AllocatePool(MaxIoSize);

    DEBUG((D_INFO, (CHAR8*)"Entering VerifyWithRead\n"));

    if (Buffer == NULL) {
        DEBUG((D_ERROR, (CHAR8*)"VerifyWithRead: Out of memory\n"));
        return FALSE;
    }

    grab = MaxIoSize/QuerySectorSize();
    for (i = 0; i < NumberOfSectors; i += grab) {

        if (NumberOfSectors - i < grab) {
            grab = (NumberOfSectors - i).GetLowPart();
        }

        if (!HardRead(StartingSector + i, grab, Buffer)) {
            return FALSE;
        }
    }

    DEBUG((D_INFO, (CHAR8*)"Leaving VerifyWithRead\n"));
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::Lock(
    )
/*++

Routine Description:

    This routine locks the drive.  If the drive is already locked then
    this routine will do nothing.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // EFI can just return TRUE.
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::InvalidateVolume(
    )
/*++

Routine Description:

    This routine invalidates the drive.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // BUGBUG need alternate implementaiton for EFI?
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::ForceDirty(
    )
/*++

Routine Description:

    This routine forces the volume to be dirty, so that efichk will
    run next time the system reboots.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // BUGBUG this IOCTL doesn't exist in EFI, do we need an alternate implementation?
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::Unlock(
    )
/*++

Routine Description:

    This routine unlocks the drive.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // EFI doesn't need this, we just stub it out
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::Dismount(
    )
/*++

Routine Description:

    This routine dismounts the drive.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // unneeded for EFI
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::DismountAndUnlock(
    )
/*++

Routine Description:

    This routine dismounts the drive and unlocks it.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // not needed for EFI
    return TRUE;
}


BOOLEAN
IO_DP_DRIVE::FormatVerifyFloppy(
    IN      MEDIA_TYPE  MediaType,
    IN OUT  PNUMBER_SET BadSectors,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     IsDmfFormat
    )
/*++

Routine Description:

    This routine low level formats an entire floppy disk to the media
    type specified.  If no MediaType is specified then a logical one will
    be selected.

Arguments:

    MediaType   - Supplies an optional media type to format to.
    BadSectors  - Returns a list of bad sectors on the disk.
    Message     - Supplies a message object to route messages to.
    IsDmfFormat - Supplies whether or not to perform a DMF type format.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
// BUGBUG temporary removal for EFI? do we need this for EFI
#if 0
    IO_STATUS_BLOCK         status_block;
    CONST                   format_parameters_size = sizeof(FORMAT_EX_PARAMETERS) + 20*sizeof(USHORT);
    CHAR                    format_parameters_buffer[format_parameters_size];
    PFORMAT_EX_PARAMETERS   format_parameters;
    PBAD_TRACK_NUMBER       bad;
    ULONG                   num_bad, j;
    ULONG                   i;
    ULONG                   cyl;
    ULONG                   percent;
    ULONG                   sec_per_track;
    ULONG                   sec_per_cyl;
    HMEM                    hmem;
    MSGID                   MessageId;
    USHORT                  swap_buffer[3];

    // We don't make sure that the volume is locked here because
    // it's not strictly necessary and 'diskcopy' will format
    // floppies without locking them.

    if (!SetMediaType(MediaType) ||
        (IsDmfFormat && QueryMediaType() != F3_1Pt44_512)) {

        Message ? Message->DisplayMsg(MSG_NOT_SUPPORTED_BY_DRIVE) : 1;
        return FALSE;
    }

    format_parameters = (PFORMAT_EX_PARAMETERS) format_parameters_buffer;
    format_parameters->MediaType = QueryMediaType();
    format_parameters->StartHeadNumber = 0;
    format_parameters->EndHeadNumber = QueryHeads() - 1;

    if (IsDmfFormat) {
        sec_per_track = 21;
        format_parameters->FormatGapLength = 8;
        format_parameters->SectorsPerTrack = (USHORT) sec_per_track;
        format_parameters->SectorNumber[0] = 12;
        format_parameters->SectorNumber[1] = 2;
        format_parameters->SectorNumber[2] = 13;
        format_parameters->SectorNumber[3] = 3;
        format_parameters->SectorNumber[4] = 14;
        format_parameters->SectorNumber[5] = 4;
        format_parameters->SectorNumber[6] = 15;
        format_parameters->SectorNumber[7] = 5;
        format_parameters->SectorNumber[8] = 16;
        format_parameters->SectorNumber[9] = 6;
        format_parameters->SectorNumber[10] = 17;
        format_parameters->SectorNumber[11] = 7;
        format_parameters->SectorNumber[12] = 18;
        format_parameters->SectorNumber[13] = 8;
        format_parameters->SectorNumber[14] = 19;
        format_parameters->SectorNumber[15] = 9;
        format_parameters->SectorNumber[16] = 20;
        format_parameters->SectorNumber[17] = 10;
        format_parameters->SectorNumber[18] = 21;
        format_parameters->SectorNumber[19] = 11;
        format_parameters->SectorNumber[20] = 1;
    } else {
        sec_per_track = QuerySectorsPerTrack();
    }
    sec_per_cyl = sec_per_track*QueryHeads();

    DebugAssert(QueryCylinders().GetHighPart() == 0);
    cyl = QueryCylinders().GetLowPart();
    num_bad = QueryHeads();
    if (num_bad == 0 || cyl == 0) {
        return FALSE;
    }

        if (!(bad = NEW BAD_TRACK_NUMBER[num_bad])) {
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }

    if (!hmem.Acquire(sec_per_cyl*QuerySectorSize(), QueryAlignmentMask())) {
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return FALSE;
    }


    Message ? Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 0) : 1;

    percent = 0;
    for (i = 0; i < cyl; i++) {

        format_parameters->StartCylinderNumber = i;
        format_parameters->EndCylinderNumber = i;

        if (IsDmfFormat) {
            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                 &status_block,
                                                 IOCTL_DISK_FORMAT_TRACKS_EX,
                                                 format_parameters,
                                                 format_parameters_size,
                                                 bad, num_bad*
                                                 sizeof(BAD_TRACK_NUMBER));

            // Skew the next cylinder by 3 sectors from this one.

            RtlMoveMemory(swap_buffer,
                          &format_parameters->SectorNumber[18],
                          3*sizeof(USHORT));
            RtlMoveMemory(&format_parameters->SectorNumber[3],
                          &format_parameters->SectorNumber[0],
                          18*sizeof(USHORT));
            RtlMoveMemory(&format_parameters->SectorNumber[0],
                          swap_buffer,
                          3*sizeof(USHORT));

        } else {
            _last_status = NtDeviceIoControlFile(_handle, 0, NULL, NULL,
                                                 &status_block,
                                                 IOCTL_DISK_FORMAT_TRACKS,
                                                 format_parameters,
                                                 sizeof(FORMAT_PARAMETERS),
                                                 bad, num_bad*
                                                 sizeof(BAD_TRACK_NUMBER));
        }

        if (!NT_SUCCESS(_last_status)) {
            DELETE_ARRAY(bad);

            switch( _last_status ) {

                case STATUS_NO_MEDIA_IN_DEVICE:
                    MessageId = MSG_FORMAT_NO_MEDIA_IN_DRIVE;
                    break;

                case STATUS_MEDIA_WRITE_PROTECTED:
                    MessageId = MSG_FMT_WRITE_PROTECTED_MEDIA ;
                    break;

                case STATUS_DEVICE_BUSY:
                case STATUS_DEVICE_NOT_READY:
                    MessageId = MSG_DEVICE_BUSY;
                    break;

                default:
                    MessageId = MSG_BAD_IOCTL;
                    break;
            }

            Message ? Message->DisplayMsg(MessageId) : 1;
            return FALSE;
        }


        // Verify the sectors.

        if (BadSectors) {

            if (!Read(i*sec_per_cyl, sec_per_cyl, hmem.GetBuf())) {

                // If this is the first track then fail.
                // A disk with a bad cylinder 0 is not
                // worth continuing on.
                //
                // As of 7/29/94, formatting 2.88 floppies to 1.44
                // doesn't work on Alphas; if we can't format to
                // 1.44 and 2.88 is supported, try 2.88.
                //
                if (i == 0) {

                    if( !IsDmfFormat &&
                        QueryMediaType() == F3_1Pt44_512 &&
                        SetMediaType(F3_2Pt88_512) ) {

                        return( FormatVerifyFloppy( F3_2Pt88_512,
                                                    BadSectors,
                                                    Message,
                                                    IsDmfFormat ) );

                    } else {

                        Message ? Message->DisplayMsg(MSG_UNUSABLE_DISK) : 1;
                        return FALSE;
                    }
                }

                for (j = 0; j < sec_per_cyl; j++) {
                    if (!Read(i*sec_per_cyl + j, 1, hmem.GetBuf())) {
                        if (!BadSectors->Add(i*sec_per_cyl + j)) {
                            return FALSE;
                        }
                    }
                }
            }
        }

        if ((i + 1)*100/cyl > percent) {
            percent = (i + 1)*100/cyl;
            if (percent > 100) {
                percent = 100;
            }

            // This check for success on the message object
            // has to be there for FMIFS to implement CANCEL.

            if (Message && !Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent)) {
                DELETE_ARRAY(bad);
                return FALSE;
            }
        }
    }

    DELETE_ARRAY(bad);
#endif
    return TRUE;
}


DEFINE_EXPORTED_CONSTRUCTOR( LOG_IO_DP_DRIVE, IO_DP_DRIVE, IFSUTIL_EXPORT );


IFSUTIL_EXPORT
LOG_IO_DP_DRIVE::~LOG_IO_DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for LOG_IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes a LOG_IO_DP_DRIVE object.

Arguments:

    NtDriveName     - Supplies the path of the drive object.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Initialize(NtDriveName, Message, ExclusiveWrite);
}

IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN      PCWSTRING   HostFileName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes a LOG_IO_DP_DRIVE object for a hosted
    drive, i.e. one which is implemented as a file on another volume.


Arguments:

    NtDriveName     - Supplies the path of the drive object.
    HostFileName    - Supplies the fully qualified name of the host file.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Initialize(NtDriveName,
                                   HostFileName,
                                   Message,
                                   ExclusiveWrite);
}


IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::SetSystemId(
    IN  PARTITION_SYSTEM_ID   SystemId
    )
/*++

Routine Description:

    This routine sets the system identifier (or partition type) in the
    MBR.  BUGBUG doesn't currently handle extended partitions.

Arguments:

    SystemId    - Supplies the system id to write in the partition entry.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MBR_PARTITION_RECORD    *partition_info;
    MASTER_BOOT_RECORD      *pMbr;
    EFI_STATUS              status;

    DEBUG((D_INFO,(CHAR8*)"Inside SetSystemId.\n" ));

    //
    // This operation is unnecessary on floppies, super-floppies, and
    // hosted volumes.
    //

    if (IsFloppy() || IsSuperFloppy() || _hosted_drive) {
        DEBUG((D_INFO,(CHAR8*)"No need to set partition type.\n" ));
        return TRUE;
    }

    if( SystemId == SYSID_NONE ) {

        // Note: we should never set it to zero!

        DEBUG((D_INFO,(CHAR8*)"Skip setting the partition type to zero.\n" ));
        return TRUE;
    }

    //
    // Now we have to read the MBR and set the type ourselves
    //

    pMbr = ( MASTER_BOOT_RECORD * ) AllocatePool( sizeof( MASTER_BOOT_RECORD ) );

    if ( !pMbr ) {
        DEBUG((D_ERROR,(CHAR8*)"LOG_IO_DP_DRIVE::SetSystemId couldn't allocate MBR.\n"));
        return FALSE;
    }

    //
    // Now read the MBR
    //

    status = _device_disk_io->ReadDisk  (  _device_disk_io,
                                           _device_block_io->Media->MediaId,
                                           0,
                                           sizeof( MASTER_BOOT_RECORD ),
                                           pMbr
                                         );

    if ( EFI_ERROR( status ) ) {
        DEBUG((D_ERROR,(CHAR8*)"LOG_IO_DP_DRIVE::SetSystemId couldn't read MBR.\n"));
        FreePool (pMbr);
        return FALSE;
    }

    //
    // Check to see if this is a GPT disk
    //

    partition_info = &(pMbr->Partition[0]);

    //
    // According to spec, the GPT signature should be the only thing to determine if
    // it is a GPT partition.  There is no need to check for the partition
    // type to see if it is 0xEE first.  However, LDM does not appear to zap the
    // signature when converting a GPT disk to MBR disk.
    //

    if (partition_info->OSIndicator != SYSID_EFI) {

        if (_partition_number) {

            DEBUG((D_INFO,(CHAR8*)"Setting partition %d id to %x\n", _partition_number, SystemId));

            //
            // Set the system ID in the correct partition
            // of the MBR since it's not a GPT disk
            //

            partition_info = &( pMbr->Partition[_partition_number - 1] );

            partition_info->OSIndicator = (UCHAR)SystemId;


            //
            // Write the MBR back out to the disk
            //

            status = _device_disk_io->WriteDisk( _device_disk_io,
                                                 _device_block_io->Media->MediaId,
                                                 0,
                                                 sizeof( MASTER_BOOT_RECORD ),
                                                 pMbr
                                               );

            if ( EFI_ERROR( status ) ) {
                DEBUG((D_ERROR,(CHAR8*)"LOG_IO_DP_DRIVE::SetSystemId couldn't write MBR.\n"));
                FreePool (pMbr);
                return FALSE;
            }

            _device_block_io->FlushBlocks( _device_block_io );

        } else {
            DEBUG((D_INFO,(CHAR8*)"Partition number is 0.\n" ));
        }
    } else {
        DEBUG((D_INFO,(CHAR8*)"It is a GPT disk.\n" ));
    }

    DEBUG((D_INFO,(CHAR8*)"Leaving SetSystemId.\n" ));

    FreePool (pMbr);
    return TRUE;
}

#if defined(FE_SB) && defined(_X86_)
IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads a run of sectors into the buffer pointed to by
    'Buffer'.

Arguments:

    StartingSector  - Supplies the first sector to be read.
    NumberOfSectors - Supplies the number of sectors to be read.
    Buffer          - Supplies a buffer to read the run of sectors into.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Read(StartingSector, NumberOfSectors, Buffer);
}


IFSUTIL_EXPORT
BOOLEAN
LOG_IO_DP_DRIVE::Write(
    BIG_INT     StartingSector,
    SECTORCOUNT NumberOfSectors,
    PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes a run of sectors onto the disk from the buffer pointed
    to by 'Buffer'.  Writing is only permitted if 'Lock' was called.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Write(StartingSector, NumberOfSectors, Buffer);
}
#endif // FE_SB && _X86_


DEFINE_CONSTRUCTOR( PHYS_IO_DP_DRIVE, IO_DP_DRIVE );

PHYS_IO_DP_DRIVE::~PHYS_IO_DP_DRIVE(
    )
/*++

Routine Description:

    Destructor for PHYS_IO_DP_DRIVE.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


BOOLEAN
PHYS_IO_DP_DRIVE::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite
    )
/*++

Routine Description:

    This routine initializes a PHYS_IO_DP_DRIVE object.

Arguments:

    NtDriveName     - Supplies the path of the drive object.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not to open the drive for
                        exclusive write.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return IO_DP_DRIVE::Initialize(NtDriveName, Message, ExclusiveWrite);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\efisrc\ifssys.cxx ===
/*++

Copyright (c) 1992-2001 Microsoft Corporation

Module Name:

    ifssys.cxx

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "ifssys.hxx"
#include "bigint.hxx"
#include "wstring.hxx"
#include "drive.hxx"
#include "secrun.hxx"
#include "hmem.hxx"
#include "bpb.hxx"
#include "volume.hxx"

#if !defined( _EFICHECK_ )
#include "untfs2.hxx"
#endif

BOOLEAN
IFS_SYSTEM::IsThisFat(
    IN  BIG_INT Sectors,
    IN  PVOID   BootSectorData
    )
/*++

Routine Description:

    This routine determines if the given boot sector is a FAT
    boot sector.

Arguments:

    Sectors     - Supplies the number of sectors on this drive.
    BootSector  - Supplies the boot sector data.

Return Value:

    FALSE   - This is not a FAT boot sector.
    TRUE    - This is a FAT boot sector.

--*/
{
    PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK  BootSector =
                (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)BootSectorData;
    BOOLEAN r;
    USHORT  bytes_per_sector, reserved_sectors, root_entries, sectors;
    USHORT  sectors_per_fat;
    ULONG   large_sectors;

    r = TRUE;
    DEBUG((D_INFO,(CHAR8*)"IsFAT: checking for FAT.\n"));

    memcpy(&bytes_per_sector, BootSector->Bpb.BytesPerSector, sizeof(USHORT));
    memcpy(&reserved_sectors, BootSector->Bpb.ReservedSectors, sizeof(USHORT));
    memcpy(&root_entries, BootSector->Bpb.RootEntries, sizeof(USHORT));
    memcpy(&sectors, BootSector->Bpb.Sectors, sizeof(USHORT));
    memcpy(&large_sectors, BootSector->Bpb.LargeSectors, sizeof(ULONG));
    memcpy(&sectors_per_fat, BootSector->Bpb.SectorsPerFat, sizeof(USHORT));

#if defined(FE_SB) && defined(_X86_)
    //
    // 3mode PC/AT support 'I' of 'IPL1'
    //
    if (BootSector->IntelNearJumpCommand[0] != 0xeb &&
        BootSector->IntelNearJumpCommand[0] != 0xe9 &&
        BootSector->IntelNearJumpCommand[0] != 0x49) {  // FMR 'I' of 'IPL1'
#else
    if (BootSector->IntelNearJumpCommand[0] != 0xeb &&
        BootSector->IntelNearJumpCommand[0] != 0xe9) {
#endif
        r = FALSE;
        DEBUG((D_INFO,(CHAR8*)"IsFAT: no jmp.\n"));
    } else if ((bytes_per_sector != 128) &&
               (bytes_per_sector != 256) &&
               (bytes_per_sector != 512) &&
               (bytes_per_sector != 1024) &&
               (bytes_per_sector != 2048) &&
               (bytes_per_sector != 4096)) {
        DEBUG((D_INFO,(CHAR8*)"IsFAT: Bytes/sector is wrong.\n"));
        r = FALSE;

    } else if ((BootSector->Bpb.SectorsPerCluster[0] != 1) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 2) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 4) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 8) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 16) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 32) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 64) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 128)) {
        DEBUG((D_INFO,(CHAR8*)"IsFAT: sectors/cluster is wrong.\n"));
        r = FALSE;

    } else if (reserved_sectors == 0) {
        DEBUG((D_INFO,(CHAR8*)"IsFAT: no resrved sectors.\n"));
        r = FALSE;

    } else if (BootSector->Bpb.Fats[0] == 0) {
        DEBUG((D_INFO,(CHAR8*)"IsFAT: no fats.\n"));
        r = FALSE;

    } else if (root_entries == 0) {
        DEBUG((D_INFO,(CHAR8*)"IsFAT: no root entries is wrong.\n"));
        r = FALSE;

    } else if (Sectors.GetHighPart() != 0) {
        DEBUG((D_INFO,(CHAR8*)"IsFAT: Sectors.GetHighPart() != 0.\n"));
        r = FALSE;

    } else if (sectors != 0 && sectors > Sectors.GetLowPart()) {
        DEBUG((D_INFO,(CHAR8*)"IsFAT: (sectors != 0 && sectors > Sectors.GetLowPart()).\n"));
        r = FALSE;

    } else if (sectors == 0 && large_sectors > Sectors.GetLowPart()) {
        DEBUG((D_INFO,(CHAR8*)"IsFAT: (sectors == 0 && large_sectors > Sectors.GetLowPart()).\n"));
        r = FALSE;

    } else if (sectors == 0 && large_sectors == 0) {
        DEBUG((D_INFO,(CHAR8*)"IsFAT: (sectors == 0 && large_sectors == 0).\n"));
        r = FALSE;

    } else if (sectors_per_fat == 0) {
        DEBUG((D_INFO,(CHAR8*)"IsFAT: sectors/fat is 0.\n"));
        r = FALSE;
    }

    DEBUG((D_INFO,(CHAR8*)"IsFAT: is it? %d.\n",r));
    return r;
}

BOOLEAN
IFS_SYSTEM::IsThisFat32(
    IN  BIG_INT Sectors,
    IN  PVOID   BootSectorData
    )
/*++

Routine Description:

    This routine determines if the given boot sector is a FAT32
    boot sector.

Arguments:

    Sectors     - Supplies the number of sectors on this drive.
    BootSector  - Supplies the boot sector data.

Return Value:

    FALSE   - This is not a FAT32 boot sector.
    TRUE    - This is a FAT32 boot sector.

--*/
{
    PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK BootSector =
            (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)BootSectorData;
    BOOLEAN r;
    USHORT  bytes_per_sector, reserved_sectors, sectors;
    ULONG   root_entries, sectors_per_fat;
    ULONG   large_sectors;

    r = TRUE;

    root_entries=0;
    memcpy(&root_entries, BootSector->Bpb.RootEntries, sizeof(USHORT));

    memcpy(&bytes_per_sector, BootSector->Bpb.BytesPerSector, sizeof(USHORT));
    memcpy(&reserved_sectors, BootSector->Bpb.ReservedSectors, sizeof(USHORT));
    memcpy(&sectors, BootSector->Bpb.Sectors, sizeof(USHORT));
    memcpy(&large_sectors, BootSector->Bpb.LargeSectors, sizeof(ULONG));
    memcpy(&sectors_per_fat, BootSector->Bpb.BigSectorsPerFat, sizeof(ULONG));

#if defined(FE_SB) && defined(_X86_)
    //
    // 3mode PC/AT support 'I' of 'IPL1'
    //
    if (BootSector->IntelNearJumpCommand[0] != 0xeb &&
        BootSector->IntelNearJumpCommand[0] != 0xe9 &&
        BootSector->IntelNearJumpCommand[0] != 0x49) {  // FMR 'I' of 'IPL1'
#else
    if (BootSector->IntelNearJumpCommand[0] != 0xeb &&
        BootSector->IntelNearJumpCommand[0] != 0xe9) {
#endif
        DEBUG((D_INFO,(CHAR8*)"IsFAT32: No JMP.\n"));

        r = FALSE;

    } else if ((bytes_per_sector != 128) &&
               (bytes_per_sector != 256) &&
               (bytes_per_sector != 512) &&
               (bytes_per_sector != 1024) &&
               (bytes_per_sector != 2048) &&
               (bytes_per_sector != 4096)) {
        DEBUG((D_INFO,(CHAR8*)"IsFAT32: Bytes/sector is wrong.\n"));
        r = FALSE;

    } else if ((BootSector->Bpb.SectorsPerCluster[0] != 1) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 2) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 4) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 8) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 16) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 32) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 64) &&
               (BootSector->Bpb.SectorsPerCluster[0] != 128)) {
        DEBUG((D_INFO,(CHAR8*)"IsFAT32: Sectors/cluster is wrong.\n"));
        r = FALSE;

    } else if ( sectors_per_fat == 0 || (0 != BootSector->Bpb.SectorsPerFat[0] &&
                                         0 != BootSector->Bpb.SectorsPerFat[1]) ) {

        DEBUG((D_INFO,(CHAR8*)"IsThisFat32() not fat 32 sectors/fat value\n"));
        r = FALSE;

    } else {

        if (reserved_sectors == 0) {
            DEBUG((D_INFO,(CHAR8*)"IsFAT32: No reserved sectors.\n"));
            r = FALSE;

        } else if (BootSector->Bpb.Fats[0] == 0) {
            DEBUG((D_INFO,(CHAR8*)"IsFAT32: No FATS.\n"));
            r = FALSE;

        } else if (root_entries != 0) {
            DEBUG((D_INFO,(CHAR8*)"IsFAT32: root entries exist, this isn't FAT32.\n"));
            r = FALSE;

        } else if (Sectors.GetHighPart() != 0) {
            DEBUG((D_INFO,(CHAR8*)"IsFAT32: Sectors.GetHighPart() != 0.\n"));
            r = FALSE;

        } else if (sectors != 0 && sectors > Sectors.GetLowPart()) {
            DEBUG((D_INFO,(CHAR8*)"IsFAT32: sectors != 0 && sectors > Sectors.GetLowPart()\n"));
            r = FALSE;

        } else if (sectors == 0 && large_sectors > Sectors.GetLowPart()) {
            DEBUG((D_INFO,(CHAR8*)"IsFAT32: sectors == 0 && large_sectors(%d) > Sectors.GetLowPart()(%d)\n",large_sectors,Sectors.GetLowPart()));
            r = FALSE;

        } else if (sectors == 0 && large_sectors == 0) {
            DEBUG((D_INFO,(CHAR8*)"IsFAT32: both  sectors and large_sectors are zero\n"));
            r = FALSE;

        }
    }
    DEBUG((D_INFO,(CHAR8*)"IsFAT32: is it? %d.\n",r));
    return r;
}

BOOLEAN
IFS_SYSTEM::IsThisHpfs(
    IN  BIG_INT Sectors,
    IN  PVOID   BootSectorData,
    IN  PULONG  SuperBlock,
    IN  PULONG  SpareBlock
    )
/*++

Routine Description:

    This routine determines whether or not the given structures
    are part of an HPFS file system.

Arguments:

    Sectors     - Supplies the number of sectors on the volume.
    BootSector  - Supplies the unaligned boot sector.
    SuperBlock  - Supplies the super block.
    SpareBlock  - Supplies the spare block.

Return Value:

    FALSE   - The given structures are not part on an HPFS volume.
    TRUE    - The given structures are part of an HPFS volume.

--*/
{
    return FALSE;
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::IsThisNtfs(
    IN  BIG_INT Sectors,
    IN  ULONG   SectorSize,
    IN  PVOID   BootSectorData
    )
/*++

Routine Description:

    This routine determines whether or not the given structure
    is part of an NTFS partition.

Arguments:

    Sectors     - Supplies the number of sectors on the drive.
    SectorSize  - Supplies the number of bytes per sector.
    BootSectorData
                - Supplies an unaligned boot sector.

Return Value:

    FALSE   - The supplied boot sector is not part of an NTFS
    TRUE    - The supplied boot sector is part of an NTFS volume.

--*/
{
    return FALSE;
}


#define BOOTBLKSECTORS 4
typedef int DSKPACKEDBOOTSECT;

BOOLEAN
IsThisOfs(
    IN      LOG_IO_DP_DRIVE *           Drive,
    IN      DSKPACKEDBOOTSECT *         PackedBootSect
    )
{
    return(FALSE);
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::QueryNtfsVersion(
    OUT PUCHAR           Major,
    OUT PUCHAR           Minor,
    IN  PLOG_IO_DP_DRIVE Drive,
    IN  PVOID            BootSectorData
    )
/*++

Routine Description:

    This routine extracts the version number of the NTFS partition.
    Note:  Caller should call IsThisNtfs() first.

Arguments:

    Major      - Receives the major version number of NTFS partition.
    Minor      - Receives the minor version number of NTFS partition.
    Drive      - Supplies the drive that partition is on.
    BootSectorData
               - Supplies an unaligned boot sector.

Return Value:

    FALSE   - The supplied boot sector is not part of an NTFS
    TRUE    - The supplied boot sector is part of an NTFS volume.

--*/
{
    return FALSE;
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::QueryFileSystemName(
    IN  PCWSTRING    NtDriveName,
    OUT PWSTRING     FileSystemName,
    OUT PNTSTATUS    ErrorCode,
    OUT PWSTRING     FileSystemNameAndVersion
    )
/*++

Routine Description:

    This routine computes the file system name for the drive specified.

Arguments:

    NtDriveName     - Supplies an NT style drive name.
    FileSystemName  - Returns the file system name for the drive.
    ErrorCode       - Receives an error code (if the method fails).
                        Note that this may be NULL, in which case the
                        exact error is not reported.
    FileSystemNameAndVersion
                    - Returns the file system name and version for the drive.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LOG_IO_DP_DRIVE drive;
    HMEM            bootsec_hmem;
    SECRUN          bootsec;
    HMEM            super_hmem;
    SECRUN          super_secrun;
    HMEM            spare_hmem;
    SECRUN          spare;
    BOOLEAN         could_be_fat;
    BOOLEAN         could_be_hpfs;
    BOOLEAN         could_be_ntfs;
    BOOLEAN         could_be_ofs;
    ULONG           num_boot_sectors;
    BOOLEAN         first_read_failed = FALSE;
    DSTRING         fs_name_version;

    if (ErrorCode) {
        *ErrorCode = 0;
    }
    if (FileSystemNameAndVersion == NULL)
        FileSystemNameAndVersion = &fs_name_version;

    if (!drive.Initialize(NtDriveName)) {
        if (ErrorCode) {
            *ErrorCode = drive.QueryLastNtStatus();
        }
        return FALSE;
    }

    could_be_fat = could_be_hpfs = could_be_ntfs = could_be_ofs = TRUE;

    DEBUG((D_INFO,(CHAR8*)"In IFS_SYSTEM::QueryFileSystemName\n"));
    if (drive.QueryMediaType() == Unknown) {
        return FileSystemName->Initialize("RAW") &&
               FileSystemNameAndVersion->Initialize("RAW");
    }
    DEBUG((D_INFO,(CHAR8*)"Got Media Type. IFS_SYSTEM::QueryFileSystemName\n"));
    num_boot_sectors = max(1, BYTES_PER_BOOT_SECTOR/drive.QuerySectorSize());

    if (!bootsec_hmem.Initialize() ||
        !bootsec.Initialize(&bootsec_hmem, &drive, 0, num_boot_sectors)) {

        return FileSystemName->Initialize("RAW") &&
               FileSystemNameAndVersion->Initialize("RAW");
    }
    DEBUG((D_INFO,(CHAR8*)"Read Bootsec. IFS_SYSTEM::QueryFileSystemName\n"));
    if (!bootsec.Read()) {
        DEBUG((D_INFO,(CHAR8*)"Failed 1st Bootsect read. IFS_SYSTEM::QueryFileSystemName\n"));
        could_be_fat = could_be_hpfs = FALSE;
        DEBUG((D_INFO,(CHAR8*)"Not HPFS or FAT. IFS_SYSTEM::QueryFileSystemName\n"));
        first_read_failed = TRUE;

        bootsec.Relocate(drive.QuerySectors());

        if (!bootsec.Read()) {
            DEBUG((D_INFO,(CHAR8*)"Failed 2st Bootsect read. IFS_SYSTEM::QueryFileSystemName\n"));
            bootsec.Relocate(drive.QuerySectors()/2);

            if (!bootsec.Read()) {
                DEBUG((D_ERROR,(CHAR8*)"Failed 3rd Bootsect read. IFS_SYSTEM::QueryFileSystemName\n"));
                could_be_ntfs = FALSE;
                DEBUG((D_INFO,(CHAR8*)"Not NTFS. IFS_SYSTEM::QueryFileSystemName\n"));
            }
        }
    }
    DEBUG((D_INFO,(CHAR8*)"Read Bootsec Success. IFS_SYSTEM::QueryFileSystemName\n"));

    DEBUG((D_INFO,(CHAR8*)"Check for FAT. IFS_SYSTEM::QueryFileSystemName\n"));
    if (could_be_fat &&
        IsThisFat(drive.QuerySectors(),
                  (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)bootsec.GetBuf())) {

        return FileSystemName->Initialize("FAT") &&
               FileSystemNameAndVersion->Initialize("FAT");
    }
    DEBUG((D_INFO,(CHAR8*)"Check for FAT32. IFS_SYSTEM::QueryFileSystemName\n"));
    if (could_be_fat &&
        IsThisFat32(drive.QuerySectors(),
                  (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)bootsec.GetBuf())) {

        return FileSystemName->Initialize("FAT32") &&
               FileSystemNameAndVersion->Initialize("FAT32");
    }
    DEBUG((D_INFO,(CHAR8*)"FS is RAW. IFS_SYSTEM::QueryFileSystemName\n"));
    return FileSystemName->Initialize("RAW") &&
           FileSystemNameAndVersion->Initialize("RAW");
}


IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::DosDriveNameToNtDriveName(
    IN  PCWSTRING    DosDriveName,
    OUT PWSTRING            NtDriveName
    )
/*++

Routine Description:

    This routine converts a dos style drive name to an NT style drive
    name.

Arguments:

    DosDriveName    - Supplies the dos style drive name.
    NtDriveName     - Supplies the nt style drive name.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{


    WSTR            buffer[80];
    // EFI doesn't use ntpaths or dospaths
    return NtDriveName->Initialize(DosDriveName->QueryWSTR(0, TO_END,buffer, 80));
}

IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::NtDriveNameToDosDriveName(
    IN  PCWSTRING    NtDriveName,
    OUT PWSTRING     DosDriveName
    )
/*++

Routine Description:

    This routine converts an NT style drive name to a DOS style drive
    name.

Arguments:

    NtDriveName     - Supplies the nt style drive name.
    DosDriveName    - Receives the dos style drive name.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return FALSE;
}

VOID
IFS_SYSTEM::Reboot (
    IN BOOLEAN PowerOff
    )
/*++

Routine Description:

    Reboots the machine

Arguments:

    PowerOff -- if TRUE, we will ask the system to shut down and
                power off.

Return Value:

    Only returns in case of error.

--*/
{
    // BUGBUG we should not need this on EFI
    return;
}

PCANNED_SECURITY IFS_SYSTEM::_CannedSecurity = NULL;

IFSUTIL_EXPORT
PCANNED_SECURITY
IFS_SYSTEM::GetCannedSecurity(
    )
/*++

Routine Description:

    This method fetches the canned security object.

Arguments:

    None.

Return Value:

    A pointer to the canned security object; NULL to indicate
    failure.

--*/
{
    // we do not need to bother with NT security in EFI
    return NULL;
}


IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::QueryFreeDiskSpace(
    IN  PCWSTRING   DosDriveName,
    OUT PBIG_INT    BytesFree
    )
/*++

Routine Description:

    Returns the amount of free space in a volume (in bytes).

Arguments:

    DosDrivename    -   Supplies the DOS name  of the drive
    BytesFree       -   Supplies the BIG_INT in which the result
                        is returned.

Return Value:

    BOOLEAN -   TRUE if the amount of free space was obtained.

--*/
{
    BOOLEAN Ok = FALSE;
    return Ok;
}


BOOLEAN
QueryDriverName(
    IN  PCWSTRING    FileSystemName,
    OUT PWSTRING            DriverName
    )
/*++

Routine Description:

    This routine computes the driver name corresponding to the
    given file system name.

Arguments:

    FileSystemName  - Supplies the name of the file system.
    DriverName      - Returns the name of the corresponding driver.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING fat_name, hpfs_name;

    if (!fat_name.Initialize("FAT") || !hpfs_name.Initialize("HPFS")) {
        return FALSE;
    }

    if (!FileSystemName->Stricmp(&fat_name)) {
        return DriverName->Initialize("FASTFAT");
    } else if (!FileSystemName->Stricmp(&hpfs_name)) {
        return DriverName->Initialize("PINBALL");
    }

    return DriverName->Initialize(FileSystemName);
}


IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::EnableFileSystem(
    IN  PCWSTRING    FileSystemName
    )
/*++

Routine Description:

    This routine will simply return TRUE because file systems are
    enabled automatically due to a recent IO system change.
    Formerly, this routine used to enable the file system in
    the registry.

Arguments:

    FileSystemName  - Supplies the name of the file system to enable.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UNREFERENCED_PARAMETER(FileSystemName);

    return TRUE;
}


IFSUTIL_EXPORT
BOOLEAN
IFS_SYSTEM::IsFileSystemEnabled(
    IN  PCWSTRING   FileSystemName,
    OUT PBOOLEAN    Error
    )
/*++

Routine Description:

    This routine will always return TRUE now that the IO
    system will automatically load file systems when needed.
    Formerly, this method used to examine the registry
    for this information.

Argument:

    FileSystemName  - Supplies the name of the file system.
    Error           - Returns whether or not an error occurred.

Return Value:

    FALSE   - The file system is not enabled.
    TRUE    - The file system is enabled.

--*/
{
    UNREFERENCED_PARAMETER(FileSystemName);

    if (Error) {
        *Error = FALSE;
    }

    return TRUE;
}

IFSUTIL_EXPORT
VOID
IFS_SYSTEM::QueryNtfsTime(
    OUT PLARGE_INTEGER NtfsTime
    )
/*++

Routine Description:

    This method returns the current time in NTFS (ie. NT) format.

Arguments

    NtfsTime    --  receives the current time in NTFS format.

Return Value:

    None.

--*/
{
    EfiQuerySystemTime( NtfsTime );
}


IFSUTIL_EXPORT
ULONG
IFS_SYSTEM::QueryPageSize(
    )
/*++

Routine Description:

    This method determines the page size of the system.

Arguments:

    None.

Return Value:

    The system page size.  A return value of 0 indicates error.

--*/
{
    // BUGBUG do I need this in EFI?
    return 0x1000;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\efisrc\newdel.cxx ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    newdel.cxx

Abstract:

    This module implements the C++ new and delete operators for
    the Setup-Loader environment.  In other environments, the utilities
    use the standard C++ new and delete.

Environment:

    ULIB, User Mode

--*/


#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"

#ifdef _EFICHECK_

extern "C" {
    #include <efi.h>
    #include <efilib.h>
}
#endif

extern "C"
int _cdecl
_purecall( );

int _cdecl
_purecall( )
{

    DebugAbort( "Pure virtual function called.\n" );

    return 0;
}



// When the utilities are running the Setup Loader
// or Autocheck environments, they can't use the C-Run-
// Time new and delete; instead, these functions are
// provided.
//
PVOID _cdecl
operator new (
    IN size_t   bytes
    )
/*++

Routine Description:

    This routine allocates 'bytes' bytes of memory.

Arguments:

    bytes   - Supplies the number of bytes requested.

Return Value:

    A pointer to 'bytes' bytes or NULL.

--*/
{
    void * ptr;

    ptr = AllocatePool(bytes);

    return ptr;
}


VOID _cdecl
operator delete (
    IN  PVOID   pointer
    )
/*++

Routine Description:

    This routine frees the memory pointed to by 'pointer'.

Arguments:

    pointer - Supplies a pointer to the memoery to be freed.

Return Value:

    None.

--*/
{
    if (pointer) {
        FreePool(pointer);
    }
}


typedef void (*PF)(PVOID);
typedef void (*PFI)(PVOID, int);
PVOID
__vec_new(
    IN OUT PVOID    op,
    IN int          number,
    IN int          size,
    IN PVOID        f)
/*
     allocate a vector of "number" elements of size "size"
     and initialize each by a call of "f"
*/
{
    if (op == 0) {
        op = AllocatePool( number * size );
    }

    if (op && f) {
        register char* p = (char*) op;
        register char* lim = p + number*size;
        register PF fp = PF(f);
        while (p < lim) {
            (*fp) (PVOID(p));
            p += size;
        }
    }

    return op;
}


void
__vec_delete(
    PVOID op,
    int n,
    int sz,
    PVOID f,
    int del,
    int x)

/*
     destroy a vector of "n" elements of size "sz"
*/
{
    // unreferenced parameters
    // I wonder what it does
    (void)(x);

    if (op) {
        if (f) {
            register char* cp = (char*) op;
            register char* p = cp;
            register PFI fp = PFI(f);
            p += n*sz;
            while (p > cp) {
                p -= sz;
                (*fp)(PVOID(p), 2);  // destroy VBC, don't delete
            }
        }
        if (del) {
            FreePool(op);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\efisrc\qsort.cxx ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    qsort.cxx

--*/

#include "pch.cxx"

/* prototypes for local routines */
static void __cdecl shortsort(char *lo, char *hi, unsigned width,
        int (__cdecl *comp)(const void *, const void *));
static void __cdecl swap(char *p, char *q, unsigned int width);

/* this parameter defines the cutoff between using quick sort and
   insertion sort for arrays; arrays with lengths shorter or equal to the
   below value use insertion sort */

#define CUTOFF 8        /* testing shows that this is good value */

/***
*qsort(base, num, wid, comp) - quicksort function for sorting arrays
*
*Purpose:
*   quicksort the array of elements
*   side effects:  sorts in place
*
*Entry:
*   char *base = pointer to base of array
*   unsigned num  = number of elements in the array
*   unsigned width = width in bytes of each array element
*   int (*comp)() = pointer to function returning analog of strcmp for
*       strings, but supplied by user for comparing the array elements.
*       it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*       1=2, pos if 1>2.
*
*Exit:
*   returns void
*
*Exceptions:
*
*******************************************************************************/

/* sort the array between lo and hi (inclusive) */

void __cdecl qsort (
    void *base,
    unsigned num,
    unsigned width,
    int (__cdecl *comp)(const void *, const void *)
    )
{
    char *lo, *hi;      /* ends of sub-array currently sorting */
    char *mid;          /* points to middle of subarray */
    char *loguy, *higuy;    /* traveling pointers for partition step */
    unsigned size;      /* size of the sub-array */
    char *lostk[30], *histk[30];
    int stkptr;         /* stack for saving sub-array to be processed */

    /* Note: the number of stack entries required is no more than
       1 + log2(size), so 30 is sufficient for any array */

    if (num < 2 || width == 0)
    return;         /* nothing to do */

    stkptr = 0;         /* initialize stack */

    lo = (char *)base;
    hi = (char *)base + width * (num-1);    /* initialize limits */

    /* this entry point is for pseudo-recursion calling: setting
       lo and hi and jumping to here is like recursion, but stkptr is
       prserved, locals aren't, so we preserve stuff on the stack */
recurse:

    size = (unsigned)((hi - lo) / width + 1);    /* number of el's to sort */

    /* below a certain size, it is faster to use a O(n^2) sorting method */
    if (size <= CUTOFF) {
     shortsort(lo, hi, width, comp);
    }
    else {
    /* First we pick a partititioning element.  The efficiency of the
       algorithm demands that we find one that is approximately the
       median of the values, but also that we select one fast.  Using
       the first one produces bad performace if the array is already
       sorted, so we use the middle one, which would require a very
       wierdly arranged array for worst case performance.  Testing shows
       that a median-of-three algorithm does not, in general, increase
       performance. */

    mid = lo + (size / 2) * width;      /* find middle element */
    swap(mid, lo, width);           /* swap it to beginning of array */

    /* We now wish to partition the array into three pieces, one
       consisiting of elements <= partition element, one of elements
       equal to the parition element, and one of element >= to it.  This
       is done below; comments indicate conditions established at every
       step. */

    loguy = lo;
    higuy = hi + width;

    /* Note that higuy decreases and loguy increases on every iteration,
       so loop must terminate. */
    for (;;) {
        /* lo <= loguy < hi, lo < higuy <= hi + 1,
           A[i] <= A[lo] for lo <= i <= loguy,
           A[i] >= A[lo] for higuy <= i <= hi */

        do  {
        loguy += width;
        } while (loguy <= hi && comp(loguy, lo) <= 0);

        /* lo < loguy <= hi+1, A[i] <= A[lo] for lo <= i < loguy,
           either loguy > hi or A[loguy] > A[lo] */

        do  {
        higuy -= width;
        } while (higuy > lo && comp(higuy, lo) >= 0);

        /* lo-1 <= higuy <= hi, A[i] >= A[lo] for higuy < i <= hi,
           either higuy <= lo or A[higuy] < A[lo] */

        if (higuy < loguy)
        break;

        /* if loguy > hi or higuy <= lo, then we would have exited, so
           A[loguy] > A[lo], A[higuy] < A[lo],
           loguy < hi, highy > lo */

        swap(loguy, higuy, width);

        /* A[loguy] < A[lo], A[higuy] > A[lo]; so condition at top
           of loop is re-established */
    }

    /*     A[i] >= A[lo] for higuy < i <= hi,
           A[i] <= A[lo] for lo <= i < loguy,
           higuy < loguy, lo <= higuy <= hi
       implying:
           A[i] >= A[lo] for loguy <= i <= hi,
           A[i] <= A[lo] for lo <= i <= higuy,
           A[i] = A[lo] for higuy < i < loguy */

    swap(lo, higuy, width);     /* put partition element in place */

    /* OK, now we have the following:
          A[i] >= A[higuy] for loguy <= i <= hi,
          A[i] <= A[higuy] for lo <= i < higuy
          A[i] = A[lo] for higuy <= i < loguy    */

    /* We've finished the partition, now we want to sort the subarrays
       [lo, higuy-1] and [loguy, hi].
       We do the smaller one first to minimize stack usage.
       We only sort arrays of length 2 or more.*/

    if ( higuy - 1 - lo >= hi - loguy ) {
        if (lo + width < higuy) {
        lostk[stkptr] = lo;
        histk[stkptr] = higuy - width;
        ++stkptr;
        }               /* save big recursion for later */

        if (loguy < hi) {
        lo = loguy;
        goto recurse;       /* do small recursion */
        }
    }
    else {
        if (loguy < hi) {
        lostk[stkptr] = loguy;
        histk[stkptr] = hi;
        ++stkptr;       /* save big recursion for later */
        }

        if (lo + width < higuy) {
        hi = higuy - width;
        goto recurse;       /* do small recursion */
        }
    }
    }

    /* We have sorted the array, except for any pending sorts on the stack.
       Check if there are any, and do them. */

    --stkptr;
    if (stkptr >= 0) {
    lo = lostk[stkptr];
    hi = histk[stkptr];
    goto recurse;       /* pop subarray from stack */
    }
    else
    return;         /* all subarrays done */
}


/***
*shortsort(hi, lo, width, comp) - insertion sort for sorting short arrays
*
*Purpose:
*   sorts the sub-array of elements between lo and hi (inclusive)
*   side effects:  sorts in place
*   assumes that lo < hi
*
*Entry:
*   char *lo = pointer to low element to sort
*   char *hi = pointer to high element to sort
*   unsigned width = width in bytes of each array element
*   int (*comp)() = pointer to function returning analog of strcmp for
*       strings, but supplied by user for comparing the array elements.
*       it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*       1=2, pos if 1>2.
*
*Exit:
*   returns void
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl shortsort (
    char *lo,
    char *hi,
    unsigned width,
    int (__cdecl *comp)(const void *, const void *)
    )
{
    char *p, *max;

    /* Note: in assertions below, i and j are alway inside original bound of
       array to sort. */

    while (hi > lo) {
    /* A[i] <= A[j] for i <= j, j > hi */
    max = lo;
    for (p = lo+width; p <= hi; p += width) {
        /* A[i] <= A[max] for lo <= i < p */
        if (comp(p, max) > 0) {
        max = p;
        }
        /* A[i] <= A[max] for lo <= i <= p */
    }

    /* A[i] <= A[max] for lo <= i <= hi */

    swap(max, hi, width);

    /* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi */

    hi -= width;

    /* A[i] <= A[j] for i <= j, j > hi, loop top condition established */
    }
    /* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
       so array is sorted */
}


/***
*swap(a, b, width) - swap two elements
*
*Purpose:
*   swaps the two array elements of size width
*
*Entry:
*   char *a, *b = pointer to two elements to swap
*   unsigned width = width in bytes of each array element
*
*Exit:
*   returns void
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl swap (
    char *a,
    char *b,
    unsigned width
    )
{
    char tmp;

    if ( a != b )
    /* Do the swap one character at a time to avoid potential alignment
       problems. */
    while ( width-- ) {
        tmp = *a;
        *a++ = *b;
        *b++ = tmp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\efisrc\layout.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    layout.cxx

Abstract:

    This module contains the functions used to determine the disk layout for the EFI filesystem (FAT).

--*/
#include <pch.cxx>

#include "efiwintypes.hxx"
#include "layout.hxx"

BOOLEAN                         // TRUE if success, FALSE if failure
ChooseLayout(
    PPART_DESCRIPTOR PartDes         // Pointer to characteristic description of partition
    )
{
    UINT32  FatType;
    UINT32  SectorsPerCluster;
    UINT32  FatSectorCount;

    //
    // Prove that a well formed layout is possible
    //
    if ( !  ((PartDes->SectorSize == 512) || (PartDes->SectorSize == 1024) ||
             (PartDes->SectorSize == 2048) || (PartDes->SectorSize == 4096)) )
    {
        PartDes->FatType = FAT_TYPE_ILLEGAL;
        return FALSE;
    }

    FatType = FAT_TYPE_ILLEGAL;

    if (PartDes->SectorCount >= MinSectorsFat16(PartDes->SectorSize)) {
        FatType = FAT_TYPE_F16;
    }

    if (PartDes->SectorCount >= MinSectorsFat32(PartDes->SectorSize)) {
        FatType = FAT_TYPE_F32;
    }

    PartDes->FatType = FatType;

    switch (FatType) {

    case FAT_TYPE_F32:
        //
        // Fill in PartDes completely...
        //

        //
        // SectorCount is already set
        // SectorSize is already set
        PartDes->HeaderCount = HEADER_F32;
        PartDes->FatEntrySize = 4;
        PartDes->MinClusterCount = MIN_CLUSTER_F32;
        PartDes->MaxClusterCount = MAX_CLUSTER_F32;
        // SectorsPerCluster set below
        // FatSectorCount set below
        // FatType set above

        if (PickClusterSize(PartDes, &SectorsPerCluster, &FatSectorCount)) {
            PartDes->SectorsPerCluster = SectorsPerCluster;
            PartDes->FatSectorCount = FatSectorCount;
            return TRUE;
        } else {
            DebugPrint("It did not work\n");
            return FALSE;
        }
        break;

    case FAT_TYPE_F16:
        //
        // Fill in PartDes completely...
        //

        //
        // SectorCount is already set
        // SectorSize is already set
        PartDes->HeaderCount = HEADER_F16  ;
        PartDes->FatEntrySize = 2;
        PartDes->MinClusterCount = MIN_CLUSTER_F16;
        PartDes->MaxClusterCount = MAX_CLUSTER_F16;
        // SectorsPerCluster set below
        // FatSectorCount set below
        // FatType set above

        if (PickClusterSize(PartDes, &SectorsPerCluster, &FatSectorCount)) {
            PartDes->SectorsPerCluster = SectorsPerCluster;
            PartDes->FatSectorCount = FatSectorCount;
            return TRUE;
        } else {
            DebugPrint("It did not work\n");
            return FALSE;
        }
        break;

    default:
        DebugAbort("Really Weird Terrible Error...\n");
        break;

    }
    return FALSE;
}

UINT32                           // Min. # of sectors for Fat32 part. for given sector size
MinSectorsFat32(
    UINT32   SectorSize          // The Sector size in question
    )
{
    UINT32   MinFatSectors32;
    UINT32   SectorMin32;

    MinFatSectors32 = (SMALLEST_FAT32_BYTES + (SectorSize-1)) / SectorSize;
    SectorMin32 =
        HEADER_F32   +
        (MinFatSectors32*2) +   // 2 fats
        SAFE_MIN_CLUSTER_F32;     // 1 sector for each cluster min

    return SectorMin32;
}

UINT32                           // Min. # of sectors for Fat16 part. for given sector size
MinSectorsFat16(
    UINT32   SectorSize          // Sector size to compute for
    )
{
    UINT32   MinFatSectors16;
    UINT32   SectorMin16;

    MinFatSectors16 = (SMALLEST_FAT16_BYTES + (SectorSize-1)) / SectorSize;
    SectorMin16 =
        HEADER_F16   +
        (MinFatSectors16*2) +   // 2 fats
        SAFE_MIN_CLUSTER_F16;     // 1 sector for each cluster min

    return SectorMin16;
}

BOOLEAN                                 // TRUE for success, FALSE for failure
PickClusterSize(
    PPART_DESCRIPTOR PartDes,                // characteristics of part. at hand
    PUINT32  ReturnedSectorsPerCluster,  // RETURNED = number of sectors per cluster
    PUINT32  ReturnedFatSectorCount      // RETURNED = number of sectors for FAT
    )
{
    //
    // we need a Cluster size >= SectorSize and <= 32K
    // we need MinClusterCount <= ClusterCount <= MaxClusterCount
    // we want the FAT size to be reasonable.
    //

    //
    // How do we do this?  We cheat.
    //
    // If it's a FAT32 partition (FatEntrySize == 4) we know that we'll
    // always have at least approximately 64k clusters, and therefore allow
    // at least that many files.  So keep upping the cluster size until
    // the count falls as low as it can go.  This gives a minimum size
    // FAT.
    //
    // If it's a FAT16 partition, we know the FAT table can't take up
    // more than 128K of data, so we go for the smallest cluster size we
    // can, to make sure there can be as many different files as may be
    // needed.
    //
    // This routine will not work for FAT12 partitions.
    //

    UINT32  SavedSectorsPerCluster = 0;
    UINT32  SavedFatSectorCount = 0;
    UINT32  SectorsPerCluster;
    UINT32  FatSectorCount;

    if (PartDes->FatEntrySize == 4) {
        //
        // It's a FAT32 partition
        //
        // Loop along looking for the largest cluster size we can
        // get away with
        //

        SectorsPerCluster = 1;
        while ((PartDes->SectorSize * SectorsPerCluster) <= MAX_CLUSTER_BYTES) {

            if ( ComputeFatSize(PartDes, SectorsPerCluster, &FatSectorCount) ) {
                //
                // ComputeFatSize found a FatSectorCount that works with
                // this cluster size, so save it, it might be the best one.
                //
                SavedFatSectorCount = FatSectorCount;
                SavedSectorsPerCluster = SectorsPerCluster;
            }
            //
            // If ComputeFatSize returns FALSE, that cluster size didn't work.
            // If it returns TRUE, it did work, but the next might work better.
            // Keep going until we run out of legal sizes in either case
            //
            SectorsPerCluster = SectorsPerCluster * 2;
        }

    } else if (PartDes->FatEntrySize = 2) {
        //
        // It's a FAT16 partition
        //
        // Find the *first* (smallest) cluster size that is legal, and use that.
        // (Note difference from FAT32 case above)
        //

        SectorsPerCluster = 1;
        while ((PartDes->SectorSize * SectorsPerCluster) <= MAX_CLUSTER_BYTES) {

            if ( ComputeFatSize(PartDes, SectorsPerCluster, &FatSectorCount) ) {
                //
                // ComputeFatSize found a FatSectorCount that works with
                // this cluster size, for this loop it's the first one, and
                // therefore the smallest cluster size, which is what we
                // want for this case.  So we are done.
                //
                SavedFatSectorCount = FatSectorCount;
                SavedSectorsPerCluster = SectorsPerCluster;
                break;
            }
            //
            // If ComputeFatSize returns FALSE, that cluster size didn't work.
            // Keep going until we run out of legal sizes.
            //
            SectorsPerCluster = SectorsPerCluster * 2;
        }

    } else {
        //
        // TERRIBLE ERROR
        //
        DebugAbort("TERRIBLE ERROR");
        return FALSE;
    }

    //
    // At this point, if we have found a workable set of cluster size and
    // fat size, it is in the Saved vars.  If they are 0, we have found
    // nothing that will work.
    //
    if ((SavedSectorsPerCluster) && (SavedFatSectorCount)) {
        *ReturnedSectorsPerCluster = SavedSectorsPerCluster;
        *ReturnedFatSectorCount = SavedFatSectorCount;
        return TRUE;
    } else {
        *ReturnedSectorsPerCluster = 0;
        *ReturnedSectorsPerCluster = 0;
        return FALSE;
    }
}


BOOLEAN                             // FALSE if ERROR, TRUE if SUCCESS
ComputeFatSize(
    PPART_DESCRIPTOR PartDes,            // partition characteristics to compute for
    UINT32   SectorsPerCluster,      // number of sectors per cluster
    PUINT32  ReturnedFatSectorCount  // RETURN Number of FAT sectors in each fat
    )
{
    UINT32       FatSectorCount;
    UINT32       EntryCount;
    UINT64   SectorsLeft;
    UINT64   SpanCount;
    UINT64  ClusterCount;

    //
    // Start with 1 sector of FAT entries, see if it spans.  Keep adding
    // 1 sector at a time to the FAT size (and reducing data sectors as we go)
    // until the remaining data is spanned (or overspanned) by the number
    // of cluster entries that fit in the fat.
    //
    // If entry count runs out of bounds before we find a working answer,
    // report an error.  (caller must try again with a different cluster size)
    //

    FatSectorCount = 1;

    while (TRUE) {

        EntryCount = ((FatSectorCount * PartDes->SectorSize) / PartDes->FatEntrySize) - 2;

        if (EntryCount > PartDes->MaxClusterCount) {
            return FALSE;  // this cluster size is too small
        }

        SectorsLeft = PartDes->SectorCount - (PartDes->HeaderCount + (FatSectorCount * 2));

        SpanCount = (UINT64)EntryCount * (UINT64)SectorsPerCluster;
        if (SpanCount >= (UINT64)SectorsLeft) {
            //
            // This might work, check it out for sure.
            //
            ClusterCount = (SectorsLeft / SectorsPerCluster);
            if ((ClusterCount >= PartDes->MinClusterCount) &&
                (ClusterCount <= PartDes->MaxClusterCount))
            {
                //
                // yup, we found it.
                //
                *ReturnedFatSectorCount = FatSectorCount;
                return TRUE;

            } else {
                //
                // something weird has happened, but the basic result
                // is that this cluster size won't work, so fail
                //
                *ReturnedFatSectorCount = 0;
                return FALSE;
            }
        }

        FatSectorCount = FatSectorCount + 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\sources.inc ===
!IF 0

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

USE_NOLIBS=1

MAJORCOMP=ntos
MINORCOMP=efi

EFI_ROOT=$(PROJECT_ROOT)\efiutil\sdk

TARGETNAME=efilib
TARGETPATH=obj
TARGETTYPE=LIBRARY

PRECOMPILED_INCLUDE= ..\pch.cxx

SOURCES= rtmsg.rc \
         efickmsg.cxx     \
         array.cxx       \
         arrayit.cxx     \
         basesys.cxx     \
         bigint.cxx      \
         bitvect.cxx     \
         cache.cxx       \
         clasdesc.cxx    \
         cluster.cxx     \
         cmem.cxx        \
         contain.cxx     \
         dcache.cxx      \
         drive.cxx       \
         eaheader.cxx    \
         easet.cxx       \
         efitimefunc.cxx \
         efimisc.cxx     \
         efimessages.cxx \
         qsort.cxx       \
         efistrutil.cxx  \
         layout.cxx      \
         fat.cxx         \
         fatdent.cxx     \
         fatdir.cxx      \
         fatsa.cxx       \
         fatsachk.cxx    \
         fatvol.cxx      \
         filedir.cxx     \
         hashindx.cxx    \
         hmem.cxx        \
         ifssys.cxx      \
         ifsutil.cxx     \
         iterator.cxx    \
         list.cxx        \
         listit.cxx      \
         mem.cxx         \
         membmgr.cxx     \
         message.cxx     \
         newdel.cxx      \
         numset.cxx      \
         object.cxx      \
         rcache.cxx      \
         rfatsa.cxx      \
         rootdir.cxx     \
         secrun.cxx      \
         seqcnt.cxx      \
         sortcnt.cxx     \
         sortlist.cxx    \
         sortlit.cxx     \
         supera.cxx      \
         ufat.cxx        \
         ulib.cxx        \
         volume.cxx      \
         wstring.cxx

INCLUDES=       ..\.;\
                ..\..\efiinc;\
                ..\..\inc;\
                $(EFI_ROOT)\inc;\
!if $(IA64)
                $(EFI_ROOT)\inc\ia64;\
!else
                $(EFI_ROOT)\inc\ia32;\
!endif
                $(EFI_ROOT)\shell\inc;

!if $(IA64)
!else
386_STDCALL=0
!endif

C_DEFINES=-DCONDITION_HANDLING=1 -D_EFICHECK_=1 -DUNICODE=1

# define DBG=1 and EFI_DEBUG=1 to turn on debugging

!if "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
C_DEFINES=$(C_DEFINES) -DEFI_DEBUG=1
!endif

CXXFLAGS=

UMLIBS=

UMRES=$(O)\rtmsg.res

UMAPPL=

UMTYPE=nt

NTDUMPAMAP=1

#must set /Gs1048576 to disable stkchk in EFI

MSC_OPTIMIZATION=$(MSC_OPTIMZATION) /Gs1048576 /Gy

LINKER_FLAGS=/MAP

NTTARGETFILE0=rtmsg.h

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\makefile.inc ===
rtmsg.rc: msg00001.bin

rtmsg.h msg00001.bin: rtmsg.mc
    mc -v -h ..\..\inc\ rtmsg.mc

basesys.cxx: ..\..\efisrc\basesys.cxx
        copy ..\..\efisrc\basesys.cxx .

cache.cxx: ..\..\efisrc\cache.cxx
        copy ..\..\efisrc\cache.cxx .

drive.cxx: ..\..\efisrc\drive.cxx
        copy ..\..\efisrc\drive.cxx .

efickmsg.cxx: ..\..\efisrc\efickmsg.cxx
        copy ..\..\efisrc\efickmsg.cxx .

efimessages.cxx: ..\..\efisrc\efimessages.cxx
        copy ..\..\efisrc\efimessages.cxx .

efimisc.cxx: ..\..\efisrc\efimisc.cxx
        copy ..\..\efisrc\efimisc.cxx .

efistrutil.cxx: ..\..\efisrc\efistrutil.cxx
        copy ..\..\efisrc\efistrutil.cxx .

efitimefunc.cxx: ..\..\efisrc\efitimefunc.cxx
        copy ..\..\efisrc\efitimefunc.cxx .

ifssys.cxx: ..\..\efisrc\ifssys.cxx
        copy ..\..\efisrc\ifssys.cxx .

layout.cxx: ..\..\efisrc\layout.cxx
        copy ..\..\efisrc\layout.cxx .

newdel.cxx: ..\..\efisrc\newdel.cxx
        copy ..\..\efisrc\newdel.cxx .

qsort.cxx: ..\..\efisrc\qsort.cxx
        copy ..\..\efisrc\qsort.cxx .

rtmsg.mc: ..\..\efisrc\rtmsg.mc
        copy ..\..\efisrc\rtmsg.mc .

wstring.cxx: ..\..\efisrc\wstring.cxx
        copy ..\..\efisrc\wstring.cxx .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\pch.cxx ===
/*++

Copyright (c) 1994-1999 Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    This module implements pre-compiled headers for ntlib.

Author:

    Matthew Bradburn (mattbr)  26-Apr-1994

--*/

//
// EFILIB headers
//

#pragma warning (disable: 4091)

#include "efiwintypes.hxx"
#include <efi.h>
#include <efilib.h>
#include <efidebug.h>
//
// ULIB headers.
//

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif
#include "smsg.hxx"
#include "cmem.hxx"
#include "basesys.hxx"
#include "buffer.hxx"
#include "contain.hxx"
#include "hmem.hxx"
#include "efickmsg.hxx"
#include "error.hxx"
#include "ifsentry.hxx"
#include "ifsserv.hxx"
#include "iterator.hxx"
#include "list.hxx"
#include "listit.hxx"
#include "mem.hxx"
#include "membmgr.hxx"
#include "program.hxx"
#include "rtmsg.h"
#include "seqcnt.hxx"
#include "sortcnt.hxx"
#include "sortlist.hxx"
#include "sortlit.hxx"
#include "string.hxx"
#include "substrng.hxx"
#include "ulibcl.hxx"
#include "object.hxx"
#include "clasdesc.hxx"


//
// IFSUTIL headers.
//

#include "bigint.hxx"
#include "bpb.hxx"
#include "cache.hxx"
#include "dcache.hxx"
#include "drive.hxx"
#include "ifssys.hxx"
#include "numset.hxx"
#include "rcache.hxx"
#include "secrun.hxx"
#include "supera.hxx"
#include "volume.hxx"

//
// UFAT headers.
//

#include "cluster.hxx"
#include "eaheader.hxx"
#include "easet.hxx"
#include "fat.hxx"
#include "fatdir.hxx"
#include "fatsa.hxx"
#include "fatdent.hxx"
#include "fatvol.hxx"
#include "filedir.hxx"
#include "rfatsa.hxx"
#include "rootdir.hxx"
#include "hashindx.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\array.cxx ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

        array.cxx

Abstract:

        This module contains the definition for the ARRAY class. ARRAY is a
        concrete implementation of a SORTABLE_CONTAINER. It extends the interface
        to allow for easy access uswing a simple ULONG as an index. It is
        dynamically growable and supports bases other than zero.

Environment:

        ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "array.hxx"
#include "arrayit.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( ARRAY, SORTABLE_CONTAINER, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( ARRAY );

VOID
ARRAY::Construct (
        )

/*++

Routine Description:

        Construct an ARRAY by setting the initial value of of the OBJECT array
        pointer to NULL.

Arguments:

        None.

Return Value:

        None.

--*/

{
        _ObjectArray    = NULL;
}





ULIB_EXPORT
ARRAY::~ARRAY (
        )

/*++

Routine Description:

        Destroy an ARRAY by freeing it's internal storage. Note that this
    deletes the array, not the objects themselves.

Arguments:

        None.

Return Value:

        None.

--*/

{
        if ( _ObjectArray ) {
                FREE( _ObjectArray );
        }
}



ULIB_EXPORT
BOOLEAN
ARRAY::Initialize (
        IN ULONG        Capacity,
        IN ULONG        CapacityIncrement
        )

/*++

Routine Description:

        Initialize an ARRAY object by setting it's internal state to supplied
        or default values. In addition allocate an initial chunk of memory for
        the actual storage of POBJECTs.

Arguments:

        Capacity                        - Supplies the total number of OBJECTs the ARRAY
                                                  can contain
        CapacityIncrement       - Supplies the number of OBJECTs to make room for
                                                  when growing the ARRAY

Return Value:

        BOOLEAN - TRUE if the ARRAY is successfully initialized.

--*/

{
        DebugAssert( Capacity != 0 );

    //
    //  If re-initializing, se reuse the current array
    //
    if ( _ObjectArray ) {
        _Capacity = SetArrayCapacity( Capacity );
    } else {
        _ObjectArray = (PPOBJECT)CALLOC( (UINT)Capacity,
                                         sizeof( POBJECT ) );
        _Capacity    = Capacity;
    }

        _CapacityIncrement      = CapacityIncrement;
    _PutIndex           = 0;

#if DBG==1
    _IteratorCount      = 0;
#endif

    if ( _ObjectArray ) {
        DebugCheckHeap();
        return TRUE;
    } else {
        return FALSE;
    }
}

ULIB_EXPORT
BOOLEAN
ARRAY::DeleteAllMembers (
        )

/*++

Routine Description:

    Deletes all the members of the array

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if all members deleted

--*/

{
    PPOBJECT    PObject;

    if ( _PutIndex > 0 ) {

#if 0   // Bogus assert due to compiler error.  Put it back in when compiler fixed
#if DBG==1
        DebugAssert( _IteratorCount == 0 );
#endif
#endif

        PObject = &_ObjectArray[ _PutIndex - 1 ];

        while ( PObject >= _ObjectArray ) {
            DELETE( *PObject );
            PObject--;
        }

        _PutIndex = 0;
    }

    return TRUE;
}




POBJECT
ARRAY::GetAt (
        IN ULONG                Index
        ) CONST

/*++

Routine Description:

        Retrieves the OBJECT at the specified Index.

Arguments:

        Index - Supplies the index of the OBJECT in question.

Return Value:

        POBJECT - A constant pointer to the requested OBJECT.

--*/

{
        DebugPtrAssert( _ObjectArray );

    if ( (_PutIndex > 0) && (Index < _PutIndex) ) {
        return _ObjectArray[ Index ];
    } else {
        return NULL;
    }
}



ULONG
ARRAY::GetMemberIndex (
    IN POBJECT      Object
    ) CONST

/*++

Routine Description:

    Returns the position (index) of an object in the array.

Arguments:

    POBJECT - Pointer to the OBJECT in question.

Return Value:

    ULONG - The position of the OBJECT in the array. If the OBJECT is not
            in the array, returns INVALID_INDEX.

--*/

{
    ULONG   Index;

    DebugPtrAssert( _ObjectArray );
    DebugPtrAssert( Object );

    if( Object == NULL ) {
        return( INVALID_INDEX );
    }

    Index = 0;
    while( ( Index < QueryMemberCount() ) &&
           ( _ObjectArray[ Index ] != Object ) ) {
        Index++;
    }
    return( ( Index < QueryMemberCount() )? Index : INVALID_INDEX );
}



ULIB_EXPORT
BOOLEAN
ARRAY::Put (
        IN OUT  POBJECT Member
        )

/*++

Routine Description:

        Puts an OBJECT at the next available location in the array.

Arguments:

        Member  -   Supplies the OBJECT to place in the array

Return Value:

    BOOLEAN -   TRUE if member put, FALSE otherwise

--*/

{
    DebugPtrAssert( Member );
    DebugPtrAssert( _PutIndex <= _Capacity );

    //
    //  Grow the array if necessary
    //
    if ( _PutIndex >= _Capacity ) {
        if ( _PutIndex >= SetArrayCapacity( _Capacity + _CapacityIncrement ) ) {
            //
            //  Could not grow the array
            //

            return FALSE;
        }
    }

    _ObjectArray[ _PutIndex++ ] = Member;

    return TRUE;

}



BOOLEAN
ARRAY::PutAt (
        IN OUT  POBJECT Member,
    IN      ULONG   Index
        )

/*++

Routine Description:

    Puts an OBJECT at a particular location in the ARRAY.
    The new object has to replace an existing object, i.e. the
    index has to be smaller than the member count.

Arguments:

        Member  - Supplies the OBJECT to place in the ARRAY
    Index   - Supplies the index where the member is to be put

Return Value:

    BOOLEAN -   TRUE if member put, FALSE otherwise


--*/

{
    DebugPtrAssert( Member );
    DebugPtrAssert( Index < _PutIndex );

    if ( Index < _PutIndex ) {
        _ObjectArray[ Index ] = Member;
        return TRUE;
    }

    return FALSE;
}


ULIB_EXPORT
PITERATOR
ARRAY::QueryIterator (
        ) CONST

/*++

Routine Description:

        Create an ARRAY_ITERATOR object for this ARRAY.

Arguments:

        None.

Return Value:

        PITERATOR - Pointer to an ITERATOR object.

--*/

{
    PARRAY_ITERATOR   Iterator;

    //
    //  Create new iterator
    //
    if ( Iterator = NEW ARRAY_ITERATOR ) {

        //
        //  Initialize the iterator
        //
        if ( !Iterator->Initialize( (PARRAY)this ) ) {
            DELETE( Iterator );
        }
    }

    return Iterator;
}



ULONG
ARRAY::QueryMemberCount (
        ) CONST

/*++

Routine Description:

    Obtains the number of elements in the array

Arguments:

    None

Return Value:

    ULONG   -   The number of members in the array


--*/

{
    return _PutIndex;
}


ULIB_EXPORT
POBJECT
ARRAY::Remove (
        IN OUT  PITERATOR   Position
        )

/*++

Routine Description:

    Removes a member from the array

Arguments:

    Position    -   Supplies an iterator whose currency is to be removed

Return Value:

    POBJECT -   The object removed


--*/

{
    PARRAY_ITERATOR Iterator;

    DebugPtrAssert( Position );
    DebugPtrAssert( ARRAY_ITERATOR::Cast( Position ));

    Iterator = (PARRAY_ITERATOR)Position;

    return RemoveAt( Iterator->QueryCurrentIndex() );
}


POBJECT
ARRAY::RemoveAt (
    IN  ULONG   Index
        )

/*++

Routine Description:

    Removes a member from the array

Arguments:

    Index   -   Supplies the index of the member to be removed

Return Value:

    POBJECT -   The object removed


--*/

{
    POBJECT    Object = NULL;

    if ( Index < _PutIndex ) {

        // DebugAssert( _IteratorCount <= 1 );

        //
        //  Get the object
        //
        Object = (POBJECT)_ObjectArray[ Index ];

        //
        //  Shift the rest of the array
        //
        memmove ( &_ObjectArray[ Index ],
                  &_ObjectArray[ Index + 1 ],
                  (UINT)(_PutIndex - Index - 1) * sizeof( POBJECT ) );

       //
       //   Update the _PutIndex
       //
       _PutIndex--;

    }

    return Object;
}



ULONG
ARRAY::SetCapacity (
    IN  ULONG   Capacity
        )

/*++

Routine Description:

    Sets the capacity of the array. Will not shrink the array if the
    capacity indicated is less than the number of members in the array.

Arguments:

    Capacity -   New capacity of the array

Return Value:

    ULONG   -   The new capacity of the array


--*/

{
    if ( Capacity >= _PutIndex ) {

        SetArrayCapacity( Capacity );

    }

    return _Capacity;
}


BOOLEAN
ARRAY::Sort (
    IN  BOOLEAN Ascending
        )

/*++

Routine Description:

    Sorts the array

Arguments:

    Ascending   -   Supplies ascending flag

Return Value:

    BOOLEAN -   TRUE if array sorted, FALSE otherwise


--*/

{
        int (__cdecl *CompareFunction)(const void *, const void*);

        CompareFunction = Ascending ?
                      &ARRAY::CompareAscending :
                      &ARRAY::CompareDescending;

        qsort( _ObjectArray,
                  (size_t)_PutIndex,
                  sizeof(POBJECT),
                  CompareFunction );

        return TRUE;
}


BOOLEAN
ARRAY::Insert(
    IN OUT  POBJECT     Member,
    IN      ULONG       Index
    )
/*++

Routine Description:

    Inserts an element in the array at the specified position, shifting
    elements to the right if necessary.

Arguments:

    Member  -   Supplies pointer to object to be inserted in the array

    Index   -   Supplies the index where the element is to be put

Return Value:

    BOOLEAN -   TRUE if new element inserted, FALSE otherwise


--*/

{
    DebugPtrAssert( Member );
    DebugPtrAssert( Index <= _PutIndex );

    //
    //  Make sure that there will be enough space in the array for the
    //  new element
    //
    if ( _PutIndex >= _Capacity ) {

        if ( _PutIndex >= SetArrayCapacity( _Capacity + _CapacityIncrement ) ) {
            //
            //  Could not grow the array
            //
            return FALSE;
        }
    }

    //
    //  If required, shift the array to the right to make space for the
    //  new element.
    //
    if ( Index < _PutIndex ) {

        memmove ( &_ObjectArray[ Index + 1 ],
                  &_ObjectArray[ Index ],
                  (UINT)( _PutIndex - Index ) * sizeof( POBJECT ) );
    }

    //
    //  Insert the element
    //
    _ObjectArray[ Index ] = Member;

    //
    //  Increment the number of elements in the array
    //
    _PutIndex++;

    return TRUE;
}



ULONG
ARRAY::SetArrayCapacity (
    IN  ULONG   NumberOfElements
        )

/*++

Routine Description:

    Sets the capacity of the array. Allways reallocs the array.

Arguments:

    NewSize -   New capacity of the array

Return Value:

    ULONG   -   The new capacity of the array


--*/

{
    PPOBJECT   Tmp;

#if !defined( _EFICHECK_ )

    Tmp = (PPOBJECT)REALLOC( _ObjectArray,
                             (UINT)NumberOfElements * sizeof(POBJECT) );

#else

    Tmp = (PPOBJECT)ReallocatePool( _ObjectArray, _Capacity*sizeof(POBJECT),
                             (UINT)NumberOfElements * sizeof(POBJECT) );

#endif

    if ( Tmp ) {
        _ObjectArray = Tmp;
        _Capacity    = NumberOfElements;
    }

    return _Capacity;
}


int __cdecl
ARRAY::CompareAscending (
    IN const void * Object1,
    IN const void * Object2
        )

/*++

Routine Description:

    Compares two objects.

Arguments:

    Object1 -   Supplies pointer to first object
    Object2 -   Supplies pointer to second object

Return Value:

        Returns:

                    <0  if Object1 is less that    Object2
                         0      if Object1 is equal to     Object2
                        >0      if Object1 is greater than Object2


--*/

{
    return  (*(POBJECT *)Object1)->Compare( *(POBJECT *)Object2 );
}



int __cdecl
ARRAY::CompareDescending (
    IN const void * Object1,
    IN const void * Object2
        )

/*++

Routine Description:

    Compares two objects

Arguments:

    Object1 -   Supplies pointer to first object
    Object2 -   Supplies pointer to second object

Return Value:

        Returns:

                        <0      if Object2 is less that    Object1
                         0      if Object2 is equal to     Object1
                        >0      if Object2 is greater than Object1

--*/

{
    return  (*(POBJECT *)Object2)->Compare( *(POBJECT *)Object1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\efisrc\wstring.cxx ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation

Module Name:

    wstring.cxx

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "wstring.hxx"

#if !defined( _EFICHECK_ )
#include <stdio.h>
#include <wchar.h>
#endif

BOOLEAN WSTRING::_UseAnsiConversions = FALSE;
BOOLEAN WSTRING::_UseConsoleConversions = FALSE;
#if defined FE_SB
BOOLEAN WSTRING::_UseAnsiConversionsPrev = FALSE;
BOOLEAN WSTRING::_UseConsoleConversionsPrev = FALSE;
#endif

// Helper functions for OEM/Unicode conversion.  Note that these
// are abstracted to private functions to make it easier to set
// them up for various environments.
//

INLINE
BOOLEAN
WSTRING::ConvertOemToUnicodeN(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR OemString,
    ULONG BytesInOemString
    )
{
    UINT32 i;

    // BUGBUG this is a big hack.
    if( MaxBytesInUnicodeString == 0 ) {
        *BytesInUnicodeString = 2*BytesInOemString;
        return TRUE;
    }

    if( MaxBytesInUnicodeString < 2*BytesInOemString ) {
        *BytesInUnicodeString = 2*BytesInOemString;
        return FALSE;
    }

    memset(UnicodeString,0,MaxBytesInUnicodeString);

    for (i=0; i<BytesInOemString;i++) {
        UnicodeString[i] = (WCHAR)(OemString[i]);

    }

    *BytesInUnicodeString = BytesInOemString*2;

    return TRUE;
}

INLINE
BOOLEAN
WSTRING::ConvertUnicodeToOemN(
    PCHAR OemString,
    ULONG MaxBytesInOemString,
    PULONG BytesInOemString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    )
{
    INT32 len = (INT32)StrLen(UnicodeString);
    INT32 i;
    UCHAR a;

    // BUGBUG this is a big hack. I just discard any non-ANSI unicode character.
    if( MaxBytesInOemString == 0 ) {
        *BytesInOemString = len;
        return TRUE;
    }

    if( MaxBytesInOemString < (ULONG)len ) {
        *BytesInOemString = len;
        return FALSE;
    }

    for( i=0; i<len; i++ ) {
        if( HIBYTE(UnicodeString[i] != 0 )){
            a = '?';
        } else {
            a = LOBYTE(UnicodeString[i]);
        }
        OemString[i] = a;
    }

    *BytesInOemString = len;

    return TRUE;
}

INLINE
VOID
WSTRING::Construct(
    )
{
    _s = NULL;
    _l = 0;
}


DEFINE_CONSTRUCTOR( WSTRING, OBJECT );


BOOLEAN
WSTRING::Initialize(
    IN  PCWSTRING   InitialString,
    IN  CHNUM       Position,
    IN  CHNUM       Length
    )
/*++

Routine Description:

    This routine initializes the current string by copying the contents
    of the given string.

Arguments:

    InitialString   - Supplies the initial string.
    Position        - Supplies the position in the given string to start at.
    Length          - Supplies the length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Position <= InitialString->_l);

    Length = min(Length, InitialString->_l - Position);

    if (!NewBuf(Length)) {
        return FALSE;
    }

    memcpy(_s, InitialString->_s + Position, (UINT) Length*sizeof(WCHAR));

    return TRUE;
}


BOOLEAN
WSTRING::Initialize(
    IN  PCWSTR  InitialString,
    IN  CHNUM   StringLength
    )
/*++

Routine Description:

    This routine initializes the current string by copying the contents
    of the given string.

Arguments:

    InitialString   - Supplies the initial string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (StringLength == TO_END) {
        StringLength = wcslen(InitialString);
    }

    if (!NewBuf(StringLength)) {
        return FALSE;
    }

    memcpy(_s, InitialString, (UINT) StringLength*sizeof(WCHAR));

    return TRUE;
}


BOOLEAN
WSTRING::Initialize(
    IN  PCSTR   InitialString,
    IN  CHNUM   StringLength
    )
/*++

Routine Description:

    This routine initializes the current string by copying the contents
    of the given string.

Arguments:

    InitialString   - Supplies the initial string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM       length=0;
    BOOLEAN     status;

    if (StringLength == TO_END) {
        StringLength = strlen(InitialString);
    }

    if (!StringLength) {
        return Resize(0);
    }

    // We want to avoid making two calls to RtlOemToUnicodeN so
    // try to guess an adequate size for the buffer.

    if (!NewBuf(StringLength)) {
        return FALSE;
    }

    status = ConvertOemToUnicodeN(_s, _l*sizeof(WCHAR),
                                  &length, (PSTR) InitialString,
                                  StringLength);
    length /= sizeof(WCHAR);

    if (status) {
        return Resize(length);
    }

    // We didn't manage to make in one try so ask exactly how much
    // we need and then make the call.

    status = ConvertOemToUnicodeN(NULL, 0, &length, (PSTR) InitialString,
                                  StringLength);
    length /= sizeof(WCHAR);

    if (!status || !NewBuf(length)) {
        return FALSE;
    }

    status = ConvertOemToUnicodeN(_s, _l*sizeof(WCHAR),
                                  &length, (PSTR) InitialString, StringLength);

    if (!status) {
        return FALSE;
    }

    DebugAssert(length == _l*sizeof(WCHAR));

    return TRUE;
}


BOOLEAN
WSTRING::Initialize(
    IN  LONG    Number
    )
/*++

Routine Description:

    This routine initializes the current string by copying the contents
    of the given string.

Arguments:

    Number  - Supplies the number to initialize the string to.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    WCHAR    tmp[64];

    SPrint(tmp, 64, TEXT("%d"), Number);

    return Initialize(tmp);
}


NONVIRTUAL
PWSTRING
WSTRING::QueryString(
    IN  CHNUM   Position,
    IN  CHNUM   Length
    ) CONST
/*++

Routine Description:

    This routine returns a copy of this string from the specified
    coordinates.

Arguments:

    Position    - Supplies the initialize position of the string.
    Length      - Supplies the length of the string.

Return Value:

    A pointer to a string or NULL.

--*/
{
    PWSTRING    p;

    if (!(p = NEW DSTRING) ||
        !p->Initialize(this, Position, Length)) {

        DELETE(p);
    }

    return p;
}


BOOLEAN
WSTRING::QueryNumber(
    OUT PLONG   Number,
    IN  CHNUM   Position,
    IN  CHNUM   Length
    ) CONST
/*++

Routine Description:

    This routine queries a number from the string.

Arguments:

    Number      - Returns the number parsed out of the string.
    Position    - Supplies the position of the number.
    Length      - Supplies the length of the number.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FSTRING String;
    PSTR    p;
    CHNUM   spn;

    if (Position >= _l) {
        return FALSE;
    }

    Length = min(Length, _l - Position);

        //
    //  Note that 123+123 will be a number!
        //
    String.Initialize((PWSTR) L"1234567890+-");

    spn = Strspn(&String, Position);

    if ((spn == INVALID_CHNUM || spn >= Position + Length) &&
        (p = QuerySTR(Position, Length))) {

        *Number = atol(p);

        DELETE(p);
                return TRUE;
        }

        return FALSE;
}


VOID
WSTRING::DeleteChAt(
    IN  CHNUM   Position,
    IN  CHNUM   Length
    )
/*++

Routine Description:

    This routine removes the character at the given position.

Arguments:

    Position    - Supplies the position of the character to remove.
    Length      - Supplies the number of characters to remove.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Position <= _l);

    Length = min(Length, _l - Position);

    memmove(_s + Position, _s + Position + Length,
            (UINT) (_l - Position - Length)*sizeof(WCHAR));

    Resize(_l - Length);
}


NONVIRTUAL
BOOLEAN
WSTRING::InsertString(
    IN  CHNUM       AtPosition,
    IN  PCWSTRING   String,
    IN  CHNUM       FromPosition,
    IN  CHNUM       FromLength
    )
/*++

Routine Description:

    This routine inserts the given string at the given position in
    this string.

Arguments:

    AtPosition  - Supplies the position at which to insert the string.
    String      - Supplies the string to insert.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM   old_length;

    DebugAssert(AtPosition <= _l);
    DebugAssert(FromPosition <= String->_l);

    FromLength = min(FromLength, String->_l - FromPosition);

    old_length = _l;
    if (!Resize(_l + FromLength)) {
        return FALSE;
    }

    memmove(_s + AtPosition + FromLength, _s + AtPosition,
            (UINT) (old_length - AtPosition)*sizeof(WCHAR));

    memcpy(_s + AtPosition, String->_s + FromPosition,
           (UINT) FromLength*sizeof(WCHAR));

    return TRUE;
}


NONVIRTUAL
BOOLEAN
WSTRING::Replace(
    IN CHNUM        AtPosition,
    IN CHNUM        AtLength,
    IN PCWSTRING    String,
    IN CHNUM        FromPosition,
    IN CHNUM        FromLength
    )
/*++

Routine Description:

    This routine replaces the contents of this string from
    'Position' to 'Length' with the contents of 'String2'
    from 'Position2' to 'Length2'.

Arguments:

    AtPosition      - Supplies the position to replace at.
    AtLength        - Supplies the length to replace at.
    String          - Supplies the string to replace with.
    FromPosition    - Supplies the position to replace from in String2.
    FromLength      - Supplies the position to replace from in String2.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM   old_length;

    DebugAssert(AtPosition <= _l);
    DebugAssert(FromPosition <= String->_l);

    AtLength = min(AtLength, _l - AtPosition);
    FromLength = min(FromLength, String->_l - FromPosition);

    // Make sure up front that we have the room but don't disturb
    // the string.

    if (FromLength > AtLength) {
        old_length = _l;
        if (!Resize(_l + FromLength - AtLength)) {
            return FALSE;
        }
        Resize(old_length);
    }

    DeleteChAt(AtPosition, AtLength);
    if (!InsertString(AtPosition, String, FromPosition, FromLength)) {
        DebugAbort("This absolutely can never happen\n");
        return FALSE;
    }

    return TRUE;
}


NONVIRTUAL
BOOLEAN
WSTRING::ReplaceWithChars(
    IN CHNUM        AtPosition,
    IN CHNUM        AtLength,
    IN WCHAR        Character,
    IN CHNUM        FromLength
    )
/*++

Routine Description:

    This routine replaces the contents of this string from
    AtPosition of AtLength with the string formed by Character
    of FromLength.

Arguments:

    AtPosition      - Supplies the position to replace at.
    AtLength        - Supplies the length to replace at.
    Character       - Supplies the character to replace with.
    FromLength      - Supplies the total number of new characters to replace the old one with.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM   old_length;
    PWCHAR  currptr, endptr;

    DebugAssert(AtPosition <= _l);

    AtLength = min(AtLength, _l - AtPosition);

    // Make sure up front that we have the room but don't disturb
    // the string.

    if (FromLength > AtLength) {
        old_length = _l;
        if (!Resize(_l + FromLength - AtLength)) {
            return FALSE;
        }
        Resize(old_length);
    }

    DeleteChAt(AtPosition, AtLength);
    old_length = _l;

    if (!Resize(_l + FromLength)) {
        DebugPrint("This should not fail\n");
        return FALSE;
    }

    memmove(_s + AtPosition + FromLength, _s + AtPosition,
            (UINT) (old_length - AtPosition)*sizeof(WCHAR));

    for (currptr = _s + AtPosition, endptr = currptr + FromLength;
         currptr < endptr;
         currptr++) {
        *currptr = Character;
    }

    return TRUE;
}


PWSTR
WSTRING::QueryWSTR(
    IN  CHNUM   Position,
    IN  CHNUM   Length,
    OUT PWSTR   Buffer,
    IN  CHNUM   BufferLength,
    IN  BOOLEAN ForceNull
    ) CONST
/*++

Routine Description:

    This routine makes a copy of this string into the provided
    buffer.  If this string is not provided then a buffer is
    allocated on the heap.

Arguments:

    Position        - Supplies the position within this string.
    Length          - Supplies the length of this string to take.
    Buffer          - Supplies the buffer to copy to.
    BufferLength    - Supplies the number of characters in the buffer.
    ForceNull       - Specifies whether or not to force the final character
                        of the buffer to be NULL in the case when there
                        isn't enough room for the whole string including
                        the NULL.

Return Value:

    A pointer to a NULL terminated string.

--*/
{
    DebugAssert(Position <= _l);

    Length = min(Length, _l - Position);

    if (!Buffer) {
        BufferLength = Length + 1;
        if (!(Buffer = (PWCHAR) MALLOC(BufferLength*sizeof(WCHAR)))) {
            return NULL;
        }
    }

    if (BufferLength > Length) {
        memcpy(Buffer, _s + Position, (UINT) Length*sizeof(WCHAR));
        Buffer[Length] = 0;
    } else {
        memcpy(Buffer, _s + Position, (UINT) BufferLength*sizeof(WCHAR));
        if (ForceNull) {
            Buffer[BufferLength - 1] = 0;
        }
    }

    return Buffer;
}


PSTR
WSTRING::QuerySTR(
    IN  CHNUM   Position,
    IN  CHNUM   Length,
    OUT PSTR    Buffer,
    IN  CHNUM   BufferLength,
    IN  BOOLEAN ForceNull
    ) CONST
/*++

Routine Description:

    This routine computes a multi-byte version of the current
    unicode string.  If the buffer is not supplied then it
    will be allocated by this routine.

Arguments:

    Position        - Supplies the position within this string.
    Length          - Supplies the length of this string to take.
    Buffer          - Supplies the buffer to convert into.
    BufferLength    - Supplies the number of characters in this buffer.
    ForceNull       - Specifies whether or not to force a NULL even
                        when the buffer is too small for the string.

Return Value:

    A pointer to a NULL terminated multi byte string.

--*/
{
    ULONG       ansi_length;

    DebugAssert(Position <= _l);

    Length = min(Length, _l - Position);


    // First special case the empty result.

    if (!Length) {

        if (!Buffer) {
            if (!(Buffer = (PSTR) MALLOC(1))) {
                return NULL;
            }
        } else if (!BufferLength) {
            return NULL;
        }

        Buffer[0] = 0;
        return Buffer;
    }


    // Next case is that the buffer is not provided and thus
    // we have to figure out what size it should be.

    if (!Buffer) {

        // We want to avoid too many calls to RtlUnicodeToOemN
        // so we'll estimate a correct size for the buffer and
        // hope that that works.

        BufferLength = 2*Length + 1;
        if (!(Buffer = (PSTR) MALLOC(BufferLength))) {
            return NULL;
        }

        if (ConvertUnicodeToOemN(Buffer, BufferLength - 1,
                                 &ansi_length, _s + Position,
                                 Length*sizeof(WCHAR))) {
            Buffer[ansi_length] = 0;

            return Buffer;
        }


        // We failed to estimate the necessary size of the buffer.
        // So ask the correct size and try again.

        FREE(Buffer);

        if (!ConvertUnicodeToOemN(NULL, 0, &ansi_length,
                                  _s + Position, Length*sizeof(WCHAR))) {
            return NULL;
        }

        BufferLength = ansi_length + 1;
        if (!(Buffer = (PSTR) MALLOC(BufferLength))) {
            return NULL;
        }
    }

    if (!ConvertUnicodeToOemN(Buffer, BufferLength, &ansi_length,
                              _s + Position, Length*sizeof(WCHAR))) {
        return NULL;
    }

    if (BufferLength > ansi_length) {
        Buffer[ansi_length] = 0;
    } else {
        if (ForceNull) {
            Buffer[BufferLength - 1] = 0;
        }
    }

    return Buffer;
}


BOOLEAN
WSTRING::Strcat(
    IN  PCWSTRING   String
    )
/*++

Routine Description:

    This routine concatenates the given string onto this one.

Arguments:

    String  - Supplies the string to concatenate to this one.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CHNUM   old_length;

    old_length = _l;
    if (!Resize(_l + String->_l)) {
        return FALSE;
    }

    memcpy(_s + old_length, String->_s, (UINT) String->_l*sizeof(WCHAR));

    return TRUE;
}


NONVIRTUAL
PWSTRING
WSTRING::Strupr(
    IN  CHNUM   StartPosition,
    IN  CHNUM   Length
    )
/*++

Routine Description:

    This routine upcases a portion of this string.

Arguments:

    StartPosition   - Supplies the start position of the substring to upcase.
    Length          - Supplies the length of the substring to upscase.

Return Value:

    A pointer to this string.

--*/
{
    WCHAR   c;

    DebugAssert(StartPosition <= _l);

    Length = min(Length, _l - StartPosition);

    c = _s[StartPosition + Length];
    _s[StartPosition + Length] = 0;

// BUGBUG don't have an upcase function in EFI.
//    _wcsupr(_s + StartPosition);

    _s[StartPosition + Length] = c;

    return this;
}


NONVIRTUAL
PWSTRING
WSTRING::Strlwr(
    IN  CHNUM   StartPosition,
    IN  CHNUM   Length
    )
/*++

Routine Description:

    This routine lowercases a portion of this string.

Arguments:

    StartPosition   - Supplies the start position of the substring to lowercase.
    Length          - Supplies the length of the substring to lowercase.

Return Value:

    A pointer to this string.

--*/
{
    WCHAR   c;

    DebugAssert(StartPosition <= _l);

    Length = min(Length, _l - StartPosition);

    c = _s[StartPosition + Length];
    _s[StartPosition + Length] = 0;

// BUGBUG we don't have a lowercase function in EFI
//    _wcslwr(_s + StartPosition);

    _s[StartPosition + Length] = c;

    return this;
}


NONVIRTUAL
LONG
WSTRING::Strcmp(
    IN  PCWSTRING   String,
    IN  CHNUM       LeftPosition,
    IN  CHNUM       LeftLength,
    IN  CHNUM       RightPosition,
    IN  CHNUM       RightLength
    ) CONST
/*++

Routine Description:

    This routine compares two substrings.

Arguments:

    String          - Supplies the string to compare this one to.
    LeftPosition    - Supplies the postion for the left substring.
    LeftLength      - Supplies the length of the left substring.
    LeftPosition    - Supplies the postion for the left substring.
    LeftLength      - Supplies the length of the left substring.

Return Value:

    <0  - Left substring is less than right substring.
    0   - Left and Right substrings are equal
    >0  - Left substring is greater than right substring.

--*/
{
    WCHAR   c, d;
    LONG    r;

    DebugAssert(LeftPosition <= _l);
    DebugAssert(RightPosition <= String->_l);

    LeftLength = min(LeftLength, _l - LeftPosition);
    RightLength = min(RightLength, String->_l - RightPosition);

    c = _s[LeftPosition + LeftLength];
    d = String->_s[RightPosition + RightLength];
    _s[LeftPosition + LeftLength] = 0;
    String->_s[RightPosition + RightLength] = 0;

    r = wcscmp(_s + LeftPosition, String->_s + RightPosition);

    _s[LeftPosition + LeftLength] = c;
    String->_s[RightPosition + RightLength] = d;

    return r;
}


NONVIRTUAL
LONG
WSTRING::Stricmp(
    IN  PCWSTRING   String,
    IN  CHNUM       LeftPosition,
    IN  CHNUM       LeftLength,
    IN  CHNUM       RightPosition,
    IN  CHNUM       RightLength
    ) CONST
/*++

Routine Description:

    This routine compares two substrings insensitive of case.

Arguments:

    String          - Supplies the string to compare this one to.
    LeftPosition    - Supplies the postion for the left substring.
    LeftLength      - Supplies the length of the left substring.
    LeftPosition    - Supplies the postion for the left substring.
    LeftLength      - Supplies the length of the left substring.

Return Value:

    <0  - Left substring is less than right substring.
    0   - Left and Right substrings are equal
    >0  - Left substring is greater than right substring.

--*/
{
    WCHAR   c, d;
    LONG    r;

    DebugAssert(LeftPosition <= _l);
    DebugAssert(RightPosition <= String->_l);

    LeftLength = min(LeftLength, _l - LeftPosition);
    RightLength = min(RightLength, String->_l - RightPosition);

    c = _s[LeftPosition + LeftLength];
    d = String->_s[RightPosition + RightLength];
    _s[LeftPosition + LeftLength] = 0;
    String->_s[RightPosition + RightLength] = 0;

#if !defined _AUTOCHECK_ && !defined _EFICHECK_

    // This works around a bug in the libc version of wcsicoll, where
    // it doesn't specify STRINGSORT to CompareString().  To reproduce the
    // bug, try sorting 1 and -1.  (-1 should sort before 1.)
    //

    r = CompareString(GetUserDefaultLCID(),
                      NORM_IGNORECASE | SORT_STRINGSORT,
                      _s + LeftPosition,
                      -1,
                      String->_s + RightPosition,
                      -1
                      );


    if (r >= 1) {

        //
        // return codes 1, 2, and 3 map to -1, 0, and 1.
        //

        _s[LeftPosition + LeftLength] = c;
        String->_s[RightPosition + RightLength] = d;
        return r - 2;
    }

    // If 'r' is 0, this indicates failure and we'll fall through and
    // call wcsicoll.
    //

#endif // _AUTOCHECK_

    r = _wcsicmp(_s + LeftPosition, String->_s + RightPosition);

    _s[LeftPosition + LeftLength] = c;
    String->_s[RightPosition + RightLength] = d;

    return r;
}

PWSTR
WSTRING::SkipWhite(
    IN  PWSTR    p
    )
{
#ifdef FE_SB

  while (*p) {

    if (iswspace(*p))
      p++;
    else if ( *p == 0x3000 )
    {
      *p++ = TEXT(' ');
    }
    else
      break;
  }

#else
    while (iswspace(*p)) {
        p++;
    }
#endif

  return p;

}


/**************************************************************************/
/* Compare two strings, ignoring white space, case is significant, return */
/* 0 if identical, <>0 otherwise.  Leading and trailing white space is    */
/* ignored, internal white space is treated as single characters.         */
/**************************************************************************/
INT
WSTRING::Strcmps (
    IN  PWSTR    p1,
    IN  PWSTR    p2
    )
{
  WCHAR *q;

  p1 = WSTRING::SkipWhite(p1);                /* skip any leading white space */
  p2 = WSTRING::SkipWhite(p2);

  while (TRUE)
  {
    if (*p1 == *p2)
    {
      if (*p1++ == 0)             /* quit if at the end */
        return (0);
      else
        p2++;

#ifdef FE_SB
      if (CheckSpace(p1))
#else
      if (iswspace(*p1))           /* compress multiple spaces */
#endif
      {
        q = WSTRING::SkipWhite(p1);
        p1 = (*q == 0) ? q : q - 1;
      }

#ifdef FE_SB
      if (CheckSpace(p2))
#else
      if (iswspace(*p2))
#endif
      {
        q = WSTRING::SkipWhite(p2);
        p2 = (*q == 0) ? q : q - 1;
      }
    }
    else
      return *p1-*p2;
  }
}





/**************************************************************************/
/* Compare two strings, ignoring white space, case is not significant,    */
/* return 0 if identical, <>0 otherwise.  Leading and trailing white      */
/* space is ignored, internal white space is treated as single characters.*/
/**************************************************************************/
INT
WSTRING::Strcmpis (
    IN  PWSTR    p1,
    IN  PWSTR    p2
    )
{
  WCHAR *q;
#ifdef FE_SB
  WCHAR c1,c2;
#endif

  p1 = WSTRING::SkipWhite(p1);                  /* skip any leading white space */
  p2 = WSTRING::SkipWhite(p2);

  while (TRUE)
  {
      if (towupper(*p1) == towupper(*p2))
      {
        if (*p1++ == 0)                /* quit if at the end */
          return (0);
        else
          p2++;
#ifdef FE_SB
        if (CheckSpace(p1))
#else
        if (iswspace(*p1))              /* compress multiple spaces */
#endif
        {
          q = SkipWhite(p1);
          p1 = (*q == 0) ? q : q - 1;
        }
#ifdef FE_SB
        if (CheckSpace(p2))
#else
        if (iswspace(*p2))
#endif
        {
          q = WSTRING::SkipWhite(p2);
          p2 = (*q == 0) ? q : q - 1;
        }
      }
      else
        return *p1-*p2;
  }
}

#ifdef FE_SB

/**************************************************************************/
/* Routine:  CheckSpace                                                   */
/* Arguments: an arbitrary string                                         */
/* Function: Determine whether there is a space in the string.            */
/* Side effects: none                                                     */
/**************************************************************************/
INT
WSTRING::CheckSpace(
    IN  PWSTR    s
    )
{
  if (iswspace(*s) || *s == 0x3000 )
    return (TRUE);
  else
    return (FALSE);
}

#endif


#define     DUMMY_ULIB_EXPORT

DEFINE_EXPORTED_CONSTRUCTOR( FSTRING, WSTRING, DUMMY_ULIB_EXPORT );


BOOLEAN
FSTRING::Resize(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine implements the WSTRING Resize routine by using
    the buffer supplied at initialization time.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return NewBuf(NewStringLength);
}


BOOLEAN
FSTRING::NewBuf(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine implements the WSTRING NewBuf routine by using
    the buffer supplied at initialization time.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (NewStringLength >= _buffer_length) {
        return FALSE;
    }

    PutString((PWSTR) GetWSTR(), NewStringLength);

    return TRUE;
}


INLINE
VOID
DSTRING::Construct(
    )
/*++

Routine Description:

    This routine initializes the string to a valid initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buf = NULL;
    _length = 0;
}


DEFINE_EXPORTED_CONSTRUCTOR( DSTRING, WSTRING, DUMMY_ULIB_EXPORT );


DSTRING::~DSTRING(
    )
/*++

Routine Description:

    Destructor for DSTRING.

Arguments:

    None.

Return Value:

    None.

--*/
{
    FREE(_buf);
}


BOOLEAN
DSTRING::Resize(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine resizes this string to the specified new size.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PWSTR   new_buf;

    if (NewStringLength >= _length) {

        if (_buf) {

#if !defined( _EFICHECK_ )

            if (!(new_buf = (PWSTR)
                  REALLOC(_buf, (NewStringLength + 1)*sizeof(WCHAR)))) {

                return FALSE;
            }

#else

            new_buf = (PWSTR) ReallocatePool( _buf,
                                              _length * sizeof(WCHAR),
                                              (NewStringLength + 1)*sizeof(WCHAR) );

            if ( new_buf == NULL ) {
                return FALSE;
            }

#endif
        } else {
            if (!(new_buf = (PWSTR)
                  MALLOC((NewStringLength + 1)*sizeof(WCHAR)))) {

                return FALSE;
            }
        }

        _buf = new_buf;
        _length = NewStringLength + 1;
    }

    PutString(_buf, NewStringLength);

    return TRUE;
}


BOOLEAN
DSTRING::NewBuf(
    IN  CHNUM   NewStringLength
    )
/*++

Routine Description:

    This routine resizes this string to the specified new size.

Arguments:

    NewStringLength - Supplies the new length of the string.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PWSTR   new_buf;

    if (NewStringLength >= _length) {

        if (!(new_buf = (PWSTR)
              MALLOC((NewStringLength + 1)*sizeof(WCHAR)))) {

            return FALSE;
        }

        if (_buf) {
            FREE(_buf);
        }
        _buf = new_buf;
        _length = NewStringLength + 1;
    }

    PutString(_buf, NewStringLength);

    return TRUE;
}

#if defined FE_SB
VOID
WSTRING::ResetConversions(
    )
{
    _UseAnsiConversions = _UseAnsiConversionsPrev;
    _UseConsoleConversions = _UseConsoleConversionsPrev;
}
#endif

VOID
WSTRING::SetAnsiConversions(
    )
/*++

Routine Description:

    This routine declares that all conversions from multi byte
    to unicode will take place using the ANSI code page.  Note
    that this is a STATIC method.  Therefore this switch affects
    *all* WSTRINGs.

Arguments:

    None.

Return Value:

    None.

--*/
{
#if defined FE_SB
    _UseAnsiConversionsPrev = _UseAnsiConversions;
    _UseConsoleConversionsPrev = _UseConsoleConversions;
#endif

    _UseAnsiConversions = TRUE;
    _UseConsoleConversions = FALSE;
}


VOID
WSTRING::SetOemConversions(
    )
/*++

Routine Description:

    This routine declares that all conversions from multi byte
    to unicode will take place using the OEM code page.  Note
    that this is a STATIC method.  Therefore this switch affects
    *all* WSTRINGs.

    This is the default if neither this nor the above function is
    called.

Arguments:

    None.

Return Value:

    None.

--*/
{
#if defined FE_SB
    _UseAnsiConversionsPrev = _UseAnsiConversions;
    _UseConsoleConversionsPrev = _UseConsoleConversions;
#endif

    _UseAnsiConversions = FALSE;
    _UseConsoleConversions = FALSE;
}

VOID
WSTRING::SetConsoleConversions(
    )
/*++

Routine Description:

    This routine declares that all conversions from multi byte
    to unicode will take place using the current console code page.
    Note that this is a STATIC method.  Therefore this switch
    affects *all* WSTRINGs.

Arguments:

    None.

Return Value:

    None.

--*/
{
#if defined FE_SB
    _UseAnsiConversionsPrev = _UseAnsiConversions;
    _UseConsoleConversionsPrev = _UseConsoleConversions;
#endif
    _UseAnsiConversions = FALSE;
    _UseConsoleConversions = TRUE;
}

#if defined FE_SB
CHNUM
WSTRING::QueryByteCount(
        ) CONST
/*++

Routine Description:

    This routine returns the number of ANSI bytes the UNICODE string
    consists of.

Arguments:

    None.

Return Value:

    Number of ANSI bytes the UNICODE string is made from, or INVALID_CHNUM
    on error.

--*/

{
    ULONG   ansi_length;
    ULONG   BufferLen = _l * sizeof(WCHAR) + 1;
    PSTR    Buffer;
    BOOLEAN success;

    if ( !_l ) {
        return( (CHNUM)0 );
    }

    if (NULL == (Buffer = (PSTR)MALLOC( BufferLen ))) {
        return( INVALID_CHNUM );
    }

    success = ConvertUnicodeToOemN( Buffer, BufferLen - 1, &ansi_length,
        _s, BufferLen - 1 );

    FREE( Buffer );

    if (!success) {
        return INVALID_CHNUM;
    }
    return ansi_length;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\arrayit.cxx ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    arrayit.cxx

Abstract:

    This file contains the definitions for the ARRAY_ITERATOR class.
    ARRAY_ITERATOR is a concrete implementation of the abstract ITERATOR
    class.

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "array.hxx"
#include "arrayit.hxx"


DEFINE_CAST_MEMBER_FUNCTION( ARRAY_ITERATOR );

DEFINE_CONSTRUCTOR( ARRAY_ITERATOR, ITERATOR );


VOID
ARRAY_ITERATOR::Construct (
    )

/*++

Routine Description:

    Construct an ARRAY_ITERATOR by setting it's current index to 0 and it's
    associated ARRAY to NULL.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _Array = NULL;
}



ARRAY_ITERATOR::~ARRAY_ITERATOR (
    )
/*++

Routine Description:

    Destructor for the ARRAY_ITERATOR class

Arguments:

    None

Return Value:

    None

--*/

{
#if DBG==1
    if ( _Array ) {
        _Array->_IteratorCount--;
    }
#endif
}




VOID
ARRAY_ITERATOR::Reset(
    )

/*++

Routine Description:

    Resets the iterator

Arguments:

    None

Return Value:

    None

--*/

{
    _CurrentIndex = INVALID_INDEX;
}



POBJECT
ARRAY_ITERATOR::GetCurrent(
    )
/*++

Routine Description:

    Gets current member

Arguments:

    None

Return Value:

    POBJECT -   Pointer to current member in  the array

--*/

{
    if ( _CurrentIndex == INVALID_INDEX ) {
        return NULL;
    } else {
        return _Array->GetAt( _CurrentIndex );
    }
}




POBJECT
ARRAY_ITERATOR::GetNext(
    )
/*++

Routine Description:

    Gets next member in the array

Arguments:

    None

Return Value:

    POBJECT -   Pointer to next member in  the array

--*/

{
    //
    //  Wrap if necessary. Note that this assumes that INVALID_INDEX + 1 == 0
    //
    _CurrentIndex++;

    if ( _CurrentIndex >= _Array->QueryMemberCount() ) {
        _CurrentIndex = INVALID_INDEX;
    }

    //
    //  Get next
    //
    return _Array->GetAt( _CurrentIndex );
}


POBJECT
ARRAY_ITERATOR::GetPrevious(
    )
/*++

Routine Description:

    Gets previous member in the array

Arguments:

    None

Return Value:

    POBJECT -   Pointer to previous member in  the array

--*/

{
    //
    //  Wrap if necessary. Note that this assumes that 0 - 1 == INVALID_INDEX
    //

    if ( _CurrentIndex == INVALID_INDEX ) {
        _CurrentIndex = _Array->QueryMemberCount() - 1;
    } else {
        _CurrentIndex--;
    }

    //
    //  Get next
    //
    return _Array->GetAt( _CurrentIndex );
}




BOOLEAN
ARRAY_ITERATOR::Initialize (
    IN PARRAY   Array
    )

/*++

Routine Description:

    Associate an ARRAY with this ARRAY_ITERATOR and reset the current index

Arguments:

    Array   -   Supplies pointer to the array object

Return Value:

    BOOLEAN - Returns TRUE if the initialization was succesful.

--*/

{
    DebugPtrAssert( Array );

#if DBG==1
    if ( _Array ) {
        _Array->_IteratorCount--;
    }
    Array->_IteratorCount++;
#endif
    _Array          = Array;
    _CurrentIndex   = INVALID_INDEX;


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\clasdesc.cxx ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    clasdesc.cxx

Abstract:

    This module contains the definition for the CLASS_DESCRIPTOR class.
    CLASS_DESCRIPTOR classes are special concrete classes derived from
    OBJECT. They are special in that a single staic object of this class
    exists for every other concrete class in the Ulib hierarchy.
    CLASS_DESCRIPTORs allocate and maintain information that can be used
    at run-time to determine the actual type of an object.

Environment:

    ULIB, User Mode

Notes:

    The definitions for all concrete class' CLASS_DESCRIPTORs can be found
    in the file ulib.cxx.

    See the Cast member function in ulibdef.hxx to see how dynamic casting
    and CLASS_DESCRIPTORs work.

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"


ULIB_EXPORT
CLASS_DESCRIPTOR::CLASS_DESCRIPTOR (
    )
{
}

#if DBG==1

//
// For debugging purposes CLASS_DESCRIPTORs maintain the name of the class
// that they describe.
//

#include <string.h>

ULIB_EXPORT
BOOLEAN
CLASS_DESCRIPTOR::Initialize (
    IN PCCLASS_NAME     ClassName
    )

/*++

Routine Description:

    Initialize a CLASS_DESCRIPTOR object by initializing the classname
    and class ids.

Arguments:

    ClassName - Supplies the name of the class being described.

Return Value:

    None.

--*/

{
    DebugPtrAssert( ClassName );
    strncpy(( PCCHAR ) _ClassName,
        ( PCCCHAR ) ClassName,
        ( INT ) _MaxClassNameLength );

    //
    // Note that this guarantees that the CLASS_ID is unique for all classes
    // at the expense of not being able to recognize a class based on it's
    // CLASS_ID. The benefit is that IDs are guaranteed to be unique and
    // do not have to be cleared or registered.
    //

    _ClassID = ( ULONG_PTR ) &_ClassID;
    return( TRUE );
}

#else  // DBG==0

ULIB_EXPORT
BOOLEAN
CLASS_DESCRIPTOR::Initialize (
    )

/*++

Routine Description:

    Initialize a CLASS_DESCRIPTOR object by initializing the class id.

Arguments:

Return Value:

    None.

--*/

{
    _ClassID = ( ULONG_PTR ) &_ClassID;
    return( TRUE );
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\bigint.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    bigint.cxx

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _IFSUTIL_MEMBER_

#include "ulib.hxx"
#include "ifsutil.hxx"

#include "bigint.hxx"

IFSUTIL_EXPORT
VOID
BIG_INT::Set(
    IN  UCHAR   ByteCount,
    IN  PCUCHAR CompressedInteger
    )
/*++

Routine Description:

    This routine sets the big_int with the given compressed integer.

Arguments:

    ByteCount           - Supplies the number of bytes in the compressed
                            integer.
    CompressedInteger   - Supplies the compressed integer.

Return Value:

    None.

--*/
{
    // If the number is completely compressed then we'll say that the
    // number is zero.  QueryCompressed should always return at least
    // one byte though.

    if (ByteCount == 0) {
        x = 0;
        return;
    }


    // First fill the integer with -1 if it's negative or 0 if it's
    // positive.

    if (CompressedInteger[ByteCount - 1] >= 0x80) {

        x = -1;

    } else {

        x = 0;
    }


    // Now copy over the integer.

    DebugAssert( ByteCount <= 8 );

    memcpy( &x, CompressedInteger, ByteCount );
}


IFSUTIL_EXPORT
VOID
BIG_INT::QueryCompressedInteger(
    OUT PUCHAR  ByteCount,
    OUT PUCHAR  CompressedInteger
    ) CONST
/*++

Routine Descrtiption:

    This routine returns a compressed form of the integer.

Arguments:

    ByteCount           - Returns the number of bytes in the compressed
                            integer.
    CompressedInteger   - Returns a 'little endian' string of bytes
                            representing a signed 'ByteCount' byte integer
                            into this supplied buffer.

Return Value:

    None.

--*/
{
    INT     i;
    PUCHAR  p;

    DebugAssert(ByteCount);
    DebugAssert(CompressedInteger);

    // First copy over the whole thing then determine the number
    // of bytes that you have to keep.

    memcpy(CompressedInteger, &x, sizeof(LARGE_INTEGER));


    p = CompressedInteger;


    // First check to see whether the number is positive or negative.

    if (p[7] >= 0x80) { // high byte is negative.

        for (i = 7; i >= 0 && p[i] == 0xFF; i--) {
        }

        if (i < 0) {
            *ByteCount = 1;
            return;
        }

        if (p[i] < 0x80) { // high byte is non-negative.
            i++;
        }

    } else { // high byte is non-negative.

        for (i = 7; i >= 0 && p[i] == 0; i--) {
        }

        if (i < 0) {
            *ByteCount = 1;
            return;
        }

        if (p[i] >= 0x80) { // high byte is negative.
            i++;
        }

    }


    // Now 'i' marks the position of the last character that you
    // have to keep.

    *ByteCount = (UCHAR) (i + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\cluster.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    cluster.cxx

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"


#include "cmem.hxx"

extern "C" {
#ifdef DBLSPACE_ENABLED
#include "mrcf.h"
#endif // DBLSPACE_ENABLED

#if !defined( _EFICHECK_ )
#include "ntrtl.h"
#endif
}

extern VOID DoInsufMemory(VOID);

DEFINE_EXPORTED_CONSTRUCTOR( CLUSTER_CHAIN, OBJECT, UFAT_EXPORT );

VOID
CLUSTER_CHAIN::Construct (
    )
/*++

Routine Description:

    Constructor for CLUSTER_CHAIN which initializes private data to
    default values.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _secruns = NULL;
    _num_secruns = 0;
    _length_of_chain = 0;
    _is_compressed = FALSE;
    _buf = NULL;
    _drive = NULL;
    _fat_sa = NULL;
    _secrun = NULL;
}

UFAT_EXPORT
CLUSTER_CHAIN::~CLUSTER_CHAIN(
    )
/*++

Routine Description:

    Destructor for CLUSTER_CHAIN.  Frees memory and returns references.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
CLUSTER_CHAIN::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      PFAT_SA             FatSuperArea,
    IN      PCFAT               Fat,
    IN      ULONG               ClusterNumber,
    IN      ULONG               LengthOfChain
    )
/*++

Routine Description:

    Prepares the CLUSTER_CHAIN object for reads and writes to disk.
    The length of the cluster chain may be specified by the
    LengthOfChain argument.  Setting this parameter to 0 will cause
    the length of the chain to be until the end of file.

Arguments:

    Mem             - Supplies memory for the cluster object.
    Drive           - Supplies the drive to which reads and writes will
                        take place.
    FatSuperArea    - Supplies the FAT super area which contains information
                        about the current FAT implementation.
    Fat             - Supplies the file allocation table for this drive.
    ClusterNumber   - Supplies the cluster number to map.
    LengthOfChain   - Supplies the number of clusters in the chain.
                        This value defaults to 0 which indicates that all
                        clusters until end of file will be addressed.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    CONT_MEM    cmem;
    SECTORCOUNT sec_per_clus;
    ULONG       clus;
    LONG        size;
    PVOID       buf;
    ULONG       i, j;
    LBN         lbn;

    Destroy();

    if (!Mem ||
        !Drive ||
        !FatSuperArea ||
        !Fat ||
        !Fat->IsInRange(ClusterNumber)) {
        Destroy();
        return FALSE;
    }

    if (LengthOfChain) {
        _length_of_chain = LengthOfChain;
    } else {
        _length_of_chain = Fat->QueryLengthOfChain(ClusterNumber);
    }

    if (!_length_of_chain) {
        Destroy();
        return FALSE;
    }

    sec_per_clus = FatSuperArea->QuerySectorsPerCluster();
    size = sec_per_clus*Drive->QuerySectorSize()*_length_of_chain;

    _is_compressed = FatSuperArea->IsCompressed();
    _fat_sa = FatSuperArea;

#ifdef DBLSPACE_ENABLED
    if (_is_compressed) {

        _fat = Fat;
        _drive = Drive;
        _starting_cluster = ClusterNumber;
        if (!(_secrun = NEW SECRUN)) {
            Destroy();
        DoInsufMemory();
            return FALSE;
        }
        // This buf will hold the cluster chain's uncompressed data.
        if (!(_buf = (PUCHAR)Mem->Acquire(size, Drive->QueryAlignmentMask()))) {
            Destroy();
        DoInsufMemory();
            return FALSE;
        }
        if (!_hmem.Initialize()) {
            Destroy();
        DoInsufMemory();
            return FALSE;
        }
        return TRUE;

    }
#endif // DBLSPACE_ENABLED

    if (!(_secruns = (PSECRUN*) MALLOC(_length_of_chain*sizeof(PSECRUN)))) {
        Destroy();
    DoInsufMemory();
        return FALSE;
    }

    if (!(buf = Mem->Acquire(size, Drive->QueryAlignmentMask())) ||
        !cmem.Initialize(buf, size)) {

        Destroy();
    DoInsufMemory();
        return FALSE;
    }


    clus = ClusterNumber;
    i = 0;
    for (;;) {
        lbn = _fat_sa->QuerySectorFromCluster(clus);

        for (j = 1; !Fat->IsEndOfChain(clus) &&
                    (clus + 1) == Fat->QueryEntry(clus) &&
                    i + j < _length_of_chain; j++) {
            clus++;
        }
        i += j;

        if (!(_secruns[_num_secruns] = NEW SECRUN)) {
            Destroy();
        DoInsufMemory();
            return FALSE;
        }

        if (!_secruns[_num_secruns]->Initialize(&cmem, Drive, lbn,
                                                j*sec_per_clus)) {
            Destroy();
        DoInsufMemory();
            return FALSE;
        }

        _num_secruns++;

        if (i == _length_of_chain) {
            break;
        }

        clus = Fat->QueryEntry(clus);
        if (!Fat->IsInRange(clus)) {
            Destroy();
            return FALSE;
        }
    }

    return TRUE;
}


UFAT_EXPORT
BOOLEAN
CLUSTER_CHAIN::Read(
    )
/*++

Routine Description:

    This routine reads the cluster chain into memory.  This is done
    by making repetitive use of SECRUN's Read routine.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       i;
    BOOLEAN     b = TRUE;
#ifdef DBLSPACE_ENABLED
    MRCF_DECOMPRESS
                wkspc;
#endif // DBLSPACE_ENABLED

    if (!_is_compressed) {

        if (!_secruns) {
            return FALSE;
        }

        for (i = 0; i < _num_secruns; i++) {

            b = (BOOLEAN)(_secruns[i]->Read() && b);
        }

        return b;
    }

#ifdef DBLSPACE_ENABLED
    //
    // The volume is compressed.
    //

    sector_size = _drive->QuerySectorSize();
    cluster_size = sector_size * _fat_sa->QuerySectorsPerCluster();

    clus = _starting_cluster;

    i = 0;
    for (;;) {

        lbn = _fat_sa->QuerySectorFromCluster(clus, &nsec);

        if (!_secrun->Initialize(&_hmem, _drive, lbn, nsec)) {
        DoInsufMemory();
            return FALSE;
        }

        if (!_secrun->Read()) {
            return FALSE;
        }

        if (_fat_sa->IsClusterCompressed(clus)) {

            RtlZeroMemory(&_buf[i * sector_size], cluster_size);

            u = MrcfDecompress(&_buf[i * sector_size],
                _fat_sa->QuerySectorsRequiredForPlainData(clus) * sector_size,
                (PUCHAR)_secrun->GetBuf(),
                nsec * sector_size, &wkspc);

            if (0 == u) {
                // error: can't decompress data
                return TRUE;
            }

        } else {

            // This cluster isn't compressed; just copy.

            memcpy(&_buf[i * cluster_size], _secrun->GetBuf(), cluster_size);
        }

        if (++i == _length_of_chain) {
            return TRUE;
        }

        clus = _fat->QueryEntry(clus);
        if (!_fat->IsInRange(clus)) {
            return FALSE;
        }
    }

    //NOTREACHED
#endif // DBLSPACE_ENABLED
    return FALSE;
}


UFAT_EXPORT
BOOLEAN
CLUSTER_CHAIN::Write(
    )
/*++

Routine Description:

    This routine writes the cluster chain to disk.  This is done
    by making repetitive use of SECRUN's Write routine.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       i;
    BOOLEAN     b = TRUE;
#ifdef DBLSPACE_ENABLED
    MRCF_STANDARD_COMPRESS
                wkspc;
#endif // DBLSPACE_ENABLED
    HMEM        work_buf;

    if (!_is_compressed) {

       if (!_secruns) {
          return FALSE;
       }
       for (i = 0; i < _num_secruns; i++) {
          b = (BOOLEAN)(_secruns[i]->Write() && b);
       }
       return b;
    }

#ifdef DBLSPACE_ENABLED
    //
    // The volume is compressed.
    //

    sector_size = _drive->QuerySectorSize();
    cluster_size = _fat_sa->QuerySectorsPerCluster() * sector_size;

    if (!work_buf.Initialize() ||
        !work_buf.Acquire(cluster_size, _drive->QueryAlignmentMask())) {
    DoInsufMemory();
        return FALSE;
    }

    clus = _starting_cluster;
    i = 0;
    for (;;) {
        lbn = _fat_sa->QuerySectorFromCluster(clus, &nsec);

        u = MrcfStandardCompress((PUCHAR)work_buf.GetBuf(), cluster_size,
            &_buf[i * cluster_size], cluster_size, &wkspc);
        if (0 == u) {
            // the data could not be compressed

            if (nsec < _fat_sa->QuerySectorsPerCluster()) {

                //
                // previously the data had been compressed; need to allocate
                // more disk space.
                //

                nsec = _fat_sa->QuerySectorsPerCluster();
                _fat_sa->FreeClusterData(clus);
                if (!_fat_sa->AllocateClusterData(clus, nsec, FALSE,
                    _fat_sa->QuerySectorsPerCluster())) {
                    // error: no space
                    return FALSE;
                }
                lbn = _fat_sa->QuerySectorFromCluster(clus);
            }
            DbgAssert(nsec == _fat_sa->QuerySectorsPerCluster());

            _fat_sa->SetClusterCompressed(clus, FALSE);

        } else {

           new_nsec = (u + sector_size - 1)/sector_size;

           if (new_nsec != nsec) {

              //
              // The data has been changed, and it won't compress into
              // the same size as it used to.
              //
              _fat_sa->FreeClusterData(clus);
              if (!_fat_sa->AllocateClusterData(clus, new_nsec, TRUE,
                                                _fat_sa->QuerySectorsPerCluster())) {

                 // error: not enough free space
                 return FALSE;
              }
              lbn = _fat_sa->QuerySectorFromCluster(clus, &nsec);

           } else {

                //
                // The cluster may not have been compressed before,
                // but we still need the same amount of space even though
                // it's now compressed.
                //
                _fat_sa->SetClusterCompressed(clus, TRUE);
            }
        }

    if (!_hmem.Initialize()) {
        DoInsufMemory();
            return FALSE;
    }
        if (!_secrun->Initialize(&_hmem, _drive, lbn, nsec)) {
        DoInsufMemory();
            return FALSE;
        }

        memcpy(_secrun->GetBuf(), work_buf.GetBuf(),
            nsec * sector_size);

        b = (BOOLEAN)(_secrun->Write() && b);

        if (++i == _length_of_chain) {
            return b;
        }

        clus = _fat->QueryEntry(clus);
        if (!_fat->IsInRange(clus)) {
            return FALSE;
        }
    }

    //NOTREACHED
#endif // DBLSPACE_ENABLED
    return FALSE;
}


VOID
CLUSTER_CHAIN::Destroy(
    )
/*++

Routine Description:

    This routine cleans up the objects internal components.  It does not
    need to be called before Init as Init does this automatically.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG i;

#ifdef DBLSPACE_ENABLED
    if (_is_compressed) {
        DELETE(_secrun);
        _num_secruns = 0;
        _length_of_chain = 0;
        _buf = NULL;
        _drive = NULL;
        return;
    }
#endif // DBLSPACE_ENABLED

    for (i = 0; i < _num_secruns; i++) {
        DELETE(_secruns[i]);
    }

    DELETE(_secruns);
    _num_secruns = 0;
    _length_of_chain = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\cmem.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    cmem.cxx

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_
#include "ulib.hxx"
#include "cmem.hxx"
#include "error.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( CONT_MEM, MEM, ULIB_EXPORT );

VOID
CONT_MEM::Construct (
    )
/*++

Routine Description:

    Constructor for CONT_MEM.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _buf = NULL;
    _size = 0;
}


ULIB_EXPORT
BOOLEAN
CONT_MEM::Initialize(
    IN  PVOID   Buffer,
    IN  ULONG   Size
    )
/*++

Routine Description:

    This routine supplies the object with a store of memory from which to
    work with.

Arguments:

    Buffer  - Supplies a pointer to memory.
    Size    - Supplies the number of bytes of memory addressable through
                the pointer.

Return Value:

    None.

--*/
{
    _buf = Buffer;
    _size = Size;

    return TRUE;
}


ULIB_EXPORT
PVOID
CONT_MEM::Acquire(
    IN  ULONG   Size,
    IN  ULONG   AlignmentMask
    )
/*++

Routine Description:

    This routine takes size bytes of memory from the current memory
    pool and returns it to the user.  If size bytes of memory are not
    available then this routine return NULL.  After a call to this routine
    the local pool of memory is decreased by Size bytes.  Successive requests
    will be granted as long as there is sufficient memory to grant them.

    This method will fail if the memory is not at the alignment requested.

Arguments:

    Size        - Supplies the number of bytes of memory requested.
    Alignment   - Supplies the necessary alignment for the memory.

Return Value:

    A pointer to size bytes of memory or NULL.

--*/
{
    PVOID   rv;

    if (Size > _size ||
        ((ULONG_PTR) _buf)&AlignmentMask) {
        return NULL;
    }

    _size -= Size;
    rv = _buf;
    _buf = (PCHAR) _buf + Size;
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\dcache.cxx ===
/*++

Copyright (c) 1992-1999 Microsoft Corporation

Module Name:

    dcache.cxx

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "dcache.hxx"


DEFINE_CONSTRUCTOR( DRIVE_CACHE, OBJECT );


DRIVE_CACHE::~DRIVE_CACHE(
    )
/*++

Routine Description:

    Destructor for DRIVE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
DRIVE_CACHE::Construct (
    )
/*++

Routine Description:

    Contructor for DRIVE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _drive = NULL;
}


VOID
DRIVE_CACHE::Destroy(
    )
/*++

Routine Description:

    Destructor for DRIVE_CACHE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _drive = NULL;
}


BOOLEAN
DRIVE_CACHE::Initialize(
    IN OUT  PIO_DP_DRIVE    Drive
    )
/*++

Routine Description:

    This routine initializes a DRIVE_CACHE object.

Arguments:

    Drive   - Supplies the drive to cache for.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Drive);

    Destroy();
    _drive = Drive;
    return TRUE;
}


BOOLEAN
DRIVE_CACHE::Read(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
    )
/*++

Routine Description:

    This routine reads the requested sectors directly from the disk.

Arguments:

    StartingSector      - Supplies the first sector to be read.
    NumberOfSectors     - Supplies the number of sectors to be read.
    Buffer              - Supplies the buffer to read the run of sectors to.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_drive);
    return _drive->HardRead(StartingSector, NumberOfSectors, Buffer);
}


BOOLEAN
DRIVE_CACHE::Write(
    IN  BIG_INT     StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    IN  PVOID       Buffer
    )
/*++

Routine Description:

    This routine writes the requested sectors directly to the disk.

Arguments:

    StartingSector      - Supplies the first sector to be written.
    NumberOfSectors     - Supplies the number of sectors to be written.
    Buffer              - Supplies the buffer to write the run of sectors from.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(_drive);
    return _drive->HardWrite(StartingSector, NumberOfSectors, Buffer);
}


BOOLEAN
DRIVE_CACHE::Flush(
    )
/*++

Routine Description:

    This routine flushes all dirty cache blocks to disk.  This routine
    returns FALSE if there has ever been an write error since the last
    flush.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\bitvect.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    bitvect.cxx

Abstract:

    This module contains the definition for thje BITVECTOR class.

Environment:

    ULIB, User Mode

[Notes:]

    optional-notes

--*/

#include <pch.cxx>

#define _ULIB_MEMBER_

#include    "ulib.hxx"
#include    "bitvect.hxx"
#include    <limits.h>

//
// Invalid bit count
//

CONST PT    InvalidBitCount = (PT)(-1);

//
// Static member data.
//

//
// Bits per byte value table e.g. 27->4 bits
//
// Algorithm:
//
//  _BitsSetLookUp[0] = 0;
//
//      For the ranges [1,1],[2,3],[4,7],[8,15],...,[128,255].
//
//      for (n = (( PT ) 1 ); n <= 8; n++) {
//
//
//          Compute range for loop.
//
//          r = (( PT ) 1 ) << (n - (( PT ) 1 ));
//
//
//          [r, 2*r - 1 ] = [0, r - 1] + 1;
//
//          for (i = 0; i < r; i++) {
//              _BitsSetLookUp[i + r] = _BitsSetLookUp[i] + (( PT ) 1 );
//          }
//      }
//    }
//

CONST BYTE  BITVECTOR::_BitsSetLookUp[ 256 ] = {

    0, 1, 1, 2, 1, 2, 2, 3,
    1, 2, 2, 3, 2, 3, 3, 4,
    1, 2, 2, 3, 2, 3, 3, 4,
    2, 3, 3, 4, 3, 4, 4, 5,
    1, 2, 2, 3, 2, 3, 3, 4,
    2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5,
    3, 4, 4, 5, 4, 5, 5, 6,
    1, 2, 2, 3, 2, 3, 3, 4,
    2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5,
    3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5,
    3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6,
    4, 5, 5, 6, 5, 6, 6, 7,
    1, 2, 2, 3, 2, 3, 3, 4,
    2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5,
    3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5,
    3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6,
    4, 5, 5, 6, 5, 6, 6, 7,
    2, 3, 3, 4, 3, 4, 4, 5,
    3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6,
    4, 5, 5, 6, 5, 6, 6, 7,
    3, 4, 4, 5, 4, 5, 5, 6,
    4, 5, 5, 6, 5, 6, 6, 7,
    4, 5, 5, 6, 5, 6, 6, 7,
    5, 6, 6, 7, 6, 7, 7, 8
};


DEFINE_EXPORTED_CONSTRUCTOR( BITVECTOR, OBJECT, ULIB_EXPORT );

DEFINE_CAST_MEMBER_FUNCTION( BITVECTOR );

VOID
BITVECTOR::Construct (
    )

/*++

Routine Description:

    Construct a BITVECTOR.

Arguments:

    None.

Return Value:

    None.

--*/

{
    REGISTER PT pt;

    //
    //  Find the number of bits per PTs
    //

    _BitsPerPT   = sizeof( PT ) * CHAR_BIT;

    //
    // Set the smallest number of PTs needed
    //

    _PTCount     = (( PT ) 1 );

    //
    //  Create the mask used to separate the array index from the bit index
    //

    _BitPositionMask = _BitsPerPT - (( PT ) 1 );

    //
    //  Count the number of bits required to make the shift count for
    //  accessing the Primitive Type.
    //

    for( _IndexShiftCount = 0, pt = _BitPositionMask; pt;
    pt >>= (( PT ) 1 ), _IndexShiftCount++ );

    //
    // Initialize BITVECTOR state.
    //

    _BitVector      = NULL;
    _PTCount        = 0;
    _FreeBitVector  = FALSE;
}

ULIB_EXPORT
BOOLEAN
BITVECTOR::Initialize (
    IN PT   Size,
    IN BIT  InitialValue,
    IN PPT  Memory
    )

/*++

Routine Description:

    Construct a BITVECTOR with at least the size specified and
    initialize all bits to SET or RESET.

Arguments:

    Size            - Supplies the number of bits in the vector
    InitialValue    - Supplies the initial value for the bits
    Memory          - Supplies a memory buffer to use for the vector

Return Value:

    BOOLEAN - Returns TRUE if the BITVECTOR was succesfully initialized.

Notes:

    Minimum and default BITVECTOR size is the number of bits in
    one PT.  Default initializer is RESET.  The size of a BITVECTOR
    is rounded up to the nearest whole multiple of (_BitsPerPT * CHAR_BIT).

    If the client supplies the buffer it is the client's responsibility
    to ensure that Size and the size of the buffer are in sync.
    Also SetSize will not change the size of a client supplied
    buffer.

--*/

{
    //
    // Destroy the internals of a previous BITVECTOR.
    //

    Destroy( );

    //
    //  Find the number of PTs that will be required for this BITVECTOR
    //  (handles smallest size case (Size = 0) ).
    //

    _PTCount     = Size ? (( Size + _BitsPerPT - (( PT ) 1 )) / _BitsPerPT ) : (( PT ) 1 );

    //
    //  If Memory was supplied use that for the vector else allocate
    // the vector.
    //

    if( Memory ) {

        _BitVector = Memory;

    } else {
        _FreeBitVector = TRUE;
        if( !( _BitVector = ( PT* ) MALLOC(( size_t ) ( _PTCount * sizeof( PT ))))) {

            return FALSE;
        }
    }

    //
    //  Set the bitvector to the supplied value ( SET | RESET )
    //

    ( InitialValue == SET ) ? SetAll( ) : ResetAll( );

    return TRUE;
}

ULIB_EXPORT
BITVECTOR::~BITVECTOR (
    )

/*++

Routine Description:

    Destroy a BITVECTOR by calling it's Destroy function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    Destroy( );
}

VOID
BITVECTOR::Destroy (
    )

/*++

Routine Description:

    Destroy a BITVECTOR by possibly freeing it's internal storage.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if( _FreeBitVector ) {

        DebugAssert( _BitVector != NULL );
        FREE( _BitVector );
    }
}

ULIB_EXPORT
PT
BITVECTOR::SetSize (
    IN PT   Size,
    IN BIT  InitialValue
    )

/*++

Routine Description:

    Set the number of bits in the vector

Arguments:

    Size        - Supplies the number of bits to set the vector size to
    InitialValue- Supplies the initial value for the bits

Return Value:

    PT - Returns the new size of this BITVECTOR in bits.

Notes:

    SetSize will merrily truncate the vector with no warning.

    Minimum and default BITVECTOR size is the number of bits in
    one PT. Default initializer is RESET.  The size of a BITVECTOR
    is rounded up to the nearest whole multiple of (_BitsPerPT * CHAR_BIT).

    If the client supplied the buffer refuse to change it's size

--*/

{
    REGISTER    PT  PTCountNew;
                PT  cbitsNew;
                PT  cbitsOld;

    //
    //  Check that the bitvector was created...
    //

    DebugPtrAssert( _BitVector );
    if( _BitVector == NULL ) {
        return( 0 );
    }

    //
    //  If the client supplied the buffer, refuse to change it's size.
    //

    if( ! _FreeBitVector ) {
        return( _PTCount * _BitsPerPT );
    }


    //
    //  Compute the number of PTs and bits required for the new size
    //

    PTCountNew = Size ? (( Size + _BitsPerPT - (( PT ) 1 ) ) / _BitsPerPT ) : (( PT ) 1 );
    cbitsNew = PTCountNew * _BitsPerPT;

    if( PTCountNew != _PTCount ) {

        //
        //  The new size requires a different number of PTs then the old
        //

#if !defined( _EFICHECK_ )
        
        if( !( _BitVector = ( PT* ) REALLOC(( VOID* ) _BitVector,
        ( size_t ) ( PTCountNew * sizeof( PT ))))) {
            return( 0 );
        }

#else // _EFICHECK_

        // EFI heap manager needs the old size to performa a realloc.
        _BitVector = (PT*)ReallocatePool( _BitVector, _PTCount * sizeof( PT ), PTCountNew * sizeof( PT ) );
        if (_BitVector == 0) {
            return 0;
        }

#endif // _EFICHECK_
    }

    //
    //  If the new size contains more bits, initialize them to the supplied
    //  value
    //

    cbitsOld = _PTCount * _BitsPerPT;
    _PTCount = PTCountNew;

    if( cbitsNew > cbitsOld ) {
        if( InitialValue == SET ) {
            SetBit( cbitsOld, cbitsNew - cbitsOld );
        } else {
            ResetBit( cbitsOld, cbitsNew - cbitsOld );
        }
    }

    return( _PTCount * _BitsPerPT );
}

ULIB_EXPORT
VOID
BITVECTOR::SetBit (
    IN PT   Index,
    IN PT   Count
    )

/*++

Routine Description:

    SET the supplied range of bits

Arguments:

    Index - Supplies the index at which to start setting bits.
    Count - Supplies the number of bits to set.

Return Value:

    None.

Notes:

    It may be faster to compute masks for setting sub-ranges.

--*/

{
    REGISTER    PT  ptCurBit;

    DebugAssert( _BitVector != NULL );
    DebugAssert(( Index + Count ) <= ( _PTCount * _BitsPerPT ));

    // Set count to be the max instead.
    Count += Index;

    for (ptCurBit = Index; (ptCurBit < Count) &&
                           (ptCurBit & _BitPositionMask); ptCurBit++) {
        _BitVector[ptCurBit >> _IndexShiftCount] |=
            (1 << (ptCurBit & _BitPositionMask));
    }

    for (; ptCurBit + 8*sizeof(PT) <= Count; ptCurBit += 8*sizeof(PT)) {
        _BitVector[ptCurBit >> _IndexShiftCount] = 0xffffffff;
    }

    for (; ptCurBit < Count; ptCurBit++) {
        _BitVector[ptCurBit >> _IndexShiftCount] |=
            (1 << (ptCurBit & _BitPositionMask));
    }
}

ULIB_EXPORT
VOID
BITVECTOR::ResetBit (
    IN PT   Index,
    IN PT   Count
    )

/*++

Routine Description:

    RESET the supplied range of bits

Arguments:

    Index - Supplies the index at which to start resetting bits.
    Count - Supplies the number of bits to reset.

Return Value:

    None.

Notes:

    It may be faster to compute masks for resetting sub-ranges.

--*/

{
    REGISTER    PT  ptCurBit;

    DebugAssert( _BitVector != NULL );
    DebugAssert(( Index + Count ) <= ( _PTCount * _BitsPerPT ));

    // Set count to be the max instead.
    Count += Index;

    for (ptCurBit = Index; (ptCurBit < Count) &&
                           (ptCurBit & _BitPositionMask); ptCurBit++) {
        _BitVector[ptCurBit >> _IndexShiftCount] &=
            ~(1 << (ptCurBit & _BitPositionMask));
    }

    for (; ptCurBit + 8*sizeof(PT) <= Count; ptCurBit += 8*sizeof(PT)) {
        _BitVector[ptCurBit >> _IndexShiftCount] = 0;
    }

    for (; ptCurBit < Count; ptCurBit++) {
        _BitVector[ptCurBit >> _IndexShiftCount] &=
            ~(1 << (ptCurBit & _BitPositionMask));
    }
}

VOID
BITVECTOR::ToggleBit (
    IN PT   Index,
    IN PT   Count
    )

/*++

Routine Description:

    Toggle the supplied range of bits.

Arguments:

    Index - Supplies the index at which to start toggling bits.
    Count - Supplies the number of bits to toggle.

Return Value:

    None.

--*/

{
    REGISTER    PT  ptCurBit;

    DebugAssert( _BitVector != NULL );
    DebugAssert( Index + Count <= _PTCount * _BitsPerPT);

    while( Count-- ) {
        ptCurBit = Index + Count;
        if( IsBitSet( ptCurBit )) {
            ResetBit( ptCurBit );
        } else {
            SetBit( ptCurBit );
        }
    }
}

ULIB_EXPORT
PT
BITVECTOR::ComputeCountSet(
    ) CONST

/*++

Routine Description:

    Compute the number of bits that are set in the bitvector using a table
    look up.

Arguments:

    None.

Return Value:

    PT - Returns the number of set bits.

--*/

{
    REGISTER PCBYTE     pbBV;
    REGISTER PT         i;
    REGISTER PT         BitsSet;

    //
    // Cast the bitvector into a string of bytes.
    //

    pbBV = ( PCBYTE ) _BitVector;

    //
    // Initialize the count to zero.
    //

    BitsSet = 0;

    //
    // For all of the bytes in the bitvector.
    //

    for (i = 0; i < _PTCount * sizeof( PT ); i++) {

        //
        // Add the number of bits set in this byte to the total.
        //

        BitsSet += _BitsSetLookUp[pbBV[ i ]];
    }

    return( BitsSet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\contain.cxx ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    contain.cxx

Abstract:

    This module contains the definition for the CONTAINER class, the most
    primitive, abstract class in the container sub-hierarchy. Given it's
    abstract, prmitive nature there is minimal implementation at this point
    in the hierarchy.

Environment:

    ULIB, User Mode

--*/
#include <pch.cxx>

#define _ULIB_MEMBER_

#include "ulib.hxx"
#include "contain.hxx"


DEFINE_CONSTRUCTOR( CONTAINER, OBJECT );

CONTAINER::~CONTAINER(
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\fatdent.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    fatdent.cxx

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "error.hxx"
#include "ifssys.hxx"
#include "wstring.hxx"

// TimeInfo is full of windows stuff.
#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ ) && !defined( _EFICHECK_ )

#include "timeinfo.hxx"

#endif


DEFINE_EXPORTED_CONSTRUCTOR( FAT_DIRENT, OBJECT, UFAT_EXPORT );

VOID
FAT_DIRENT::Construct (
        )
/*++

Routine Description:

    Constructor for FAT_DIRENT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _dirent = NULL;
}


UFAT_EXPORT
FAT_DIRENT::~FAT_DIRENT(
    )
/*++

Routine Description:

    Destructor for FAT_DIRENT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
FAT_DIRENT::Initialize(
    IN OUT  PVOID   Dirent
    )
/*++

Routine Description:

    This routine initializes the object to use the directory entry
    pointed to by Dirent.

Arguments:

    Dirent  - Supplies the directory entry.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _dirent = (PUCHAR) Dirent;
    _FatType = FAT_TYPE_UNKNOWN;
    return _dirent ? TRUE : FALSE;
}


UFAT_EXPORT
BOOLEAN
FAT_DIRENT::Initialize(
    IN OUT  PVOID   Dirent,
    IN      UCHAR   FatType
    )
/*++

Routine Description:

    This routine initializes the object to use the directory entry
    pointed to by Dirent.

Arguments:

    Dirent  - Supplies the directory entry.
    FatType - Supplies the FAT type.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    _dirent = (PUCHAR) Dirent;
    _FatType = FatType;
    return _dirent ? TRUE : FALSE;
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::QueryName(
    OUT PWSTRING    Name
    ) CONST
/*++

Routine Description:

    This routine copies the directory entries name to 'Name' in an
    appropriate format.

    Directories and files will be returned in compressed 8.3 format.
    Labels will be returned in compressed 11 character format.

Arguments:

    Name    - Returns the name of the directory entry in the appropriate
              format.

Return Value:

    None.

--*/
{
    LONG    i;
    STR     buf[80];
    DSTRING tmp_string;
    DSTRING tmp2;
    CHNUM   l;

    if (!_dirent) {
        return Name->Initialize();
    }

    if (IsVolumeLabel()) {
        memcpy(buf, _dirent, 11);
        buf[11] = 0;

        if (buf[0] == 0x05) {
            buf[0] = (UCHAR)0xE5;
        }

        if (!tmp_string.Initialize(buf))
            return FALSE;

        l = tmp_string.QueryChCount();

        for (i = l - 1; i >= 0 && tmp_string.QueryChAt(i) == ' '; i--) {
        }

        return Name->Initialize(&tmp_string, 0, i + 1);
    }

    memcpy(buf, _dirent, 8);
    buf[8] = 0;

    if (buf[0] == 0x05) {
        buf[0] = (UCHAR)0xE5;
    }

    if (!tmp_string.Initialize(buf))
        return FALSE;

    if (Is8LowerCase()) {
        tmp_string.Strlwr(0);
    }

    l = tmp_string.QueryChCount();

    // Remove trailing white spaces
    for (i = l - 1; i >= 0 && tmp_string.QueryChAt(i) == ' '; i--) {
    }

    if (!Name->Initialize(&tmp_string, 0, i + 1))
        return FALSE;

    memcpy(buf, &_dirent[8], 3);
    buf[3] = 0;

    if (!tmp_string.Initialize(buf))
        return FALSE;

    if (Is3LowerCase()) {
        tmp_string.Strlwr(0);
    }

    l = tmp_string.QueryChCount();

    for (i = l - 1; i >= 0 && tmp_string.QueryChAt(i) == ' '; i--) {
    }

    if (i + 1) {
        if (!tmp2.Initialize(".") ||
            !Name->Strcat(&tmp2) ||
            !tmp2.Initialize(&tmp_string, 0, i + 1) ||
            !Name->Strcat(&tmp2))
            return FALSE;
    }
    return TRUE;
}

extern VOID DoInsufMemory(VOID);

BOOLEAN
FAT_DIRENT::SetName(
    IN  PCWSTRING   Name
    )
/*++

Routine Description:

    This routine expects a "compressed" null-terminated name in a format
    compatible with the return value of 'QueryName'.

    The validity of the characters in the name will not be checked
    by this routine.  Only that the name has the appropriate
    structure.  The routine "IsValidName" will check the validity
    of the name characters.

Arguments:

    Name    - Supplies the new name for the directory entry.

Return Value:

    FALSE   - The name was invalid.
    TRUE    - The name was successfully set.

--*/
{
    CHNUM   i, j;
    STR     buf[40];
    CHNUM   l;
    DSTRING tmp_string;

    if (IsVolumeLabel()) {
       if (!Name->QuerySTR( 0, TO_END, buf, 40) ||
           (i = strlen(buf)) > 11) {
          return FALSE;
       }

       if (!FAT_SA::IsValidString(Name)) {
          return FALSE;
       }

       memset(&_dirent[i], ' ', (UINT) (11 - i));
       memcpy(_dirent, buf, (UINT) i);

       if (_dirent[0] == 0xE5) {
          _dirent[0] = 0x05;
       }

       return TRUE;
    }

    l = Name->QueryChCount();

    if (Name->QueryChAt(0) == '.' && l == 1) {
        memcpy(_dirent, ".          ", 11);
        return TRUE;
    } else if (Name->QueryChAt(0) == '.' &&
               Name->QueryChAt(1) == '.' &&
               l == 2) {
        memcpy(_dirent, "..         ", 11);
        return TRUE;
    }

    for (i = 0; i < l && Name->QueryChAt(i) != '.'; i++) {
    }

    if (!tmp_string.Initialize(Name, 0, i)) {
    DoInsufMemory();
        return FALSE;
    }

    if (!tmp_string.QuerySTR( 0, TO_END, buf, 40)) {
        return FALSE;
    }

    if ((j = strlen(buf)) > 8) {
        return FALSE;
    }

    memset(&buf[j], ' ', (UINT) (11 - j));
    if (i < l) {
        for (j = i + 1; j < l && Name->QueryChAt(j) != '.'; j++) {
        }

        if (j < l) {
            return FALSE;
        }

        if (i + 1 < l) {
            if (!tmp_string.Initialize(Name, i + 1)) {
        DoInsufMemory();
                return FALSE;
            }

        if (!tmp_string.QuerySTR( 0, TO_END, &buf[8], 32)) {
                return FALSE;
            }

            if ((j = strlen(buf)) > 11) {
                return FALSE;
            }

            memset(&buf[j], ' ', (UINT) (11 - j));
        }
    }

    memcpy(_dirent, buf, 11);

    if (_dirent[0] == 0xE5) {
        _dirent[0] = 0x05;
    }

    return TRUE;
}


BOOLEAN
FAT_DIRENT::IsValidName(
    ) CONST
/*++

Routine Description:

    This routine verifies that the name is composed of valid
    characters.

Arguments:

    None.

Return Value:

    FALSE   - The name is not valid.
    TRUE    - The name is valid.

--*/
{
    DSTRING tmp;
    STR     buf[40];

    if (!_dirent) {
    perrstk->push(ERR_NOT_INIT, QueryClassId());
        return FALSE;
    }

    if (IsDot() || IsDotDot()) {
        return IsDirectory();
    }

    memcpy(buf, _dirent, 11);
    buf[11] = 0;

    if (buf[0] == 0x05) {
        buf[0] = (UCHAR)0xE5;
    }

    if (!tmp.Initialize(buf)) {
        return FALSE;
    }

    return FAT_SA::IsValidString(&tmp);
}


UFAT_EXPORT
BOOLEAN
FAT_DIRENT::IsValidLastWriteTime(
    ) CONST
/*++

Routine Description:

    This routine verifies the validity of the last write time.

Arguments:

    None.

Return Value:

    FALSE   - Invalid time stamp.
    TRUE    - Valid time stamp.

--*/
{
    USHORT  t;
    USHORT  d;

    DebugAssert(_dirent);

    memcpy(&t, &_dirent[22], sizeof(USHORT)); // time field
    memcpy(&d, &_dirent[24], sizeof(USHORT)); // date field

    return TimeStampsAreValid(t, d);
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::QueryLastWriteTime(
    OUT LARGE_INTEGER   *TimeStamp
    ) CONST
/*++

Routine Description:

    This routine returns the last write time in the form of a time fields
    structure.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

    TIME_FIELDS TimeFields;
    USHORT      t;
    USHORT      d;
    USHORT      year, month, day, hour, minute, second;

    DebugAssert( _dirent );
    DebugPtrAssert( TimeStamp );

    memcpy(&t, &_dirent[22], sizeof(USHORT)); // time field
    memcpy(&d, &_dirent[24], sizeof(USHORT)); // date field

    second  = (t&0x001F)*2;     // seconds
    minute  = (t&0x07E0)>>5;    // Minutes
    hour    = t>>11;            // Hours
    day     = d&0x001F;         // Day of month 1-31
    month   = (d&0x01E0)>>5;    // Month
    year    = (d>>9) + 1980;    // Year

    TimeFields.Year         = year;
    TimeFields.Month        = month;
    TimeFields.Day          = day;
    TimeFields.Hour         = hour;
    TimeFields.Minute       = minute;
    TimeFields.Second       = second;
    TimeFields.Milliseconds = 0;

    return RtlTimeFieldsToTime( &TimeFields, (PTIME)TimeStamp );
}



BOOLEAN
FAT_DIRENT::SetLastWriteTime(
    )
/*++

Routine Description:

    This routine sets the last write time to the current date and time.

Arguments:

    None.

Return Value:

    FALSE   - Time stamp was not set successfully.
    TRUE    - Time stamp was set successfully.

--*/
{
    USHORT  fat_time;
    USHORT  fat_date;

    DebugAssert(_dirent);

    LARGE_INTEGER SystemTime, LocalTime;
    TIME_FIELDS Time;


#if !defined( _SETUP_LOADER_ )
    IFS_SYSTEM::QueryNtfsTime( &SystemTime );
    RtlSystemTimeToLocalTime( &SystemTime, &LocalTime );
#else
    IFS_SYSTEM::QueryNtfsTime( &LocalTime );
#endif

    RtlTimeToTimeFields(&LocalTime, &Time);

    fat_time = Time.Second/2;
    fat_time |= Time.Minute<<5;
    fat_time |= Time.Hour<<11;

    fat_date = Time.Day;
    fat_date |= Time.Month<<5;
    fat_date |= (Time.Year - 1980)<<9;

        memcpy(&_dirent[22], &fat_time, sizeof(USHORT));
    memcpy(&_dirent[24], &fat_date, sizeof(USHORT));

    return TRUE;
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::IsValidCreationTime(
    ) CONST
/*++

Routine Description:

    This routine verifies the validity of the creation time.

Arguments:

    None.

Return Value:

    FALSE   - Invalid time stamp.
    TRUE    - Valid time stamp.

--*/
{
    USHORT  t;
    USHORT  d;

    DebugAssert(_dirent);

    memcpy(&t, &_dirent[14], sizeof(USHORT)); // time field
    memcpy(&d, &_dirent[16], sizeof(USHORT)); // date field

    return TimeStampsAreValid(t, d);

}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::QueryCreationTime(
    OUT LARGE_INTEGER   *TimeStamp
    ) CONST
/*++

Routine Description:

    This routine returns the creation time in the form of a time fields
    structure.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    TIME_FIELDS TimeFields;
    USHORT      t;
    USHORT      d;
    USHORT      msec;
    USHORT      year, month, day, hour, minute, second;

    DebugAssert( _dirent );
    DebugPtrAssert( TimeStamp );

    memcpy(&t, &_dirent[14], sizeof(USHORT)); // time field
    memcpy(&d, &_dirent[16], sizeof(USHORT)); // date field
    msec = _dirent[13] * 10;                  // msec field

    second  = (t&0x001F)*2;     // seconds
    minute  = (t&0x07E0)>>5;    // Minutes
    hour    = t>>11;            // Hours
    day     = d&0x001F;         // Day of month 1-31
    month   = (d&0x01E0)>>5;    // Month
    year    = (d>>9) + 1980;    // Year

    if (msec >= 1000) {
        second += 1;
        msec -= 1000;
    }

    TimeFields.Year         = year;
    TimeFields.Month        = month;
    TimeFields.Day          = day;
    TimeFields.Hour         = hour;
    TimeFields.Minute       = minute;
    TimeFields.Second       = second;
    TimeFields.Milliseconds = msec;

    return RtlTimeFieldsToTime( &TimeFields, (PTIME)TimeStamp );
}

BOOLEAN
FAT_DIRENT::SetCreationTime(
    )
/*++

Routine Description:

    This routine sets the creation time to the current date and time.

Arguments:

    None.

Return Value:

    FALSE   - Time stamp was not set successfully.
    TRUE    - Time stamp was set successfully.

--*/
{
    USHORT  fat_time;
    USHORT  fat_date;

    DebugAssert(_dirent);

    LARGE_INTEGER SystemTime, LocalTime;
    TIME_FIELDS Time;


#if !defined( _SETUP_LOADER_ )
    IFS_SYSTEM::QueryNtfsTime( &SystemTime );
    RtlSystemTimeToLocalTime( &SystemTime, &LocalTime );
#else
    IFS_SYSTEM::QueryNtfsTime( &LocalTime );
#endif

    RtlTimeToTimeFields(&LocalTime, &Time);

    fat_time = Time.Second/2;
    fat_time |= Time.Minute<<5;
    fat_time |= Time.Hour<<11;

    fat_date = Time.Day;
    fat_date |= Time.Month<<5;
    fat_date |= (Time.Year - 1980)<<9;

    memcpy(&_dirent[14], &fat_time, sizeof(USHORT));
    memcpy(&_dirent[16], &fat_date, sizeof(USHORT));

    return TRUE;
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::IsValidLastAccessTime(
    ) CONST
/*++

Routine Description:

    This routine verifies the validity of the last access time.

Arguments:

    None.

Return Value:

    FALSE   - Invalid time stamp.
    TRUE    - Valid time stamp.

--*/
{
    USHORT  t = 0;
    USHORT  d;

    DebugAssert(_dirent);

    memcpy(&d, &_dirent[18], sizeof(USHORT)); // date field

    return TimeStampsAreValid(t, d);
}

UFAT_EXPORT
BOOLEAN
FAT_DIRENT::QueryLastAccessTime(
    OUT LARGE_INTEGER   *TimeStamp
    ) CONST
/*++

Routine Description:

    This routine returns the last access time in the form of a time fields
    structure.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

    TIME_FIELDS TimeFields;
    USHORT      t;
    USHORT      d;
    USHORT      year, month, day, hour, minute, second;

    DebugAssert( _dirent );
    DebugPtrAssert( TimeStamp );

    t = 0;                                    // no time for last access; just date
    memcpy(&d, &_dirent[18], sizeof(USHORT)); // date field

    second  = (t&0x001F)*2;     // seconds
    minute  = (t&0x07E0)>>5;    // Minutes
    hour    = t>>11;            // Hours
    day     = d&0x001F;         // Day of month 1-31
    month   = (d&0x01E0)>>5;    // Month
    year    = (d>>9) + 1980;    // Year

    TimeFields.Year         = year;
    TimeFields.Month        = month;
    TimeFields.Day          = day;
    TimeFields.Hour         = hour;
    TimeFields.Minute       = minute;
    TimeFields.Second       = second;
    TimeFields.Milliseconds = 0;

    return RtlTimeFieldsToTime( &TimeFields, (PTIME)TimeStamp );
}

BOOLEAN
FAT_DIRENT::SetLastAccessTime(
    )
/*++

Routine Description:

    This routine sets the last access time to the current date and time.

Arguments:

    None.

Return Value:

    FALSE   - Time stamp was not set successfully.
    TRUE    - Time stamp was set successfully.

--*/
{
    USHORT  fat_date;

    DebugAssert(_dirent);

    LARGE_INTEGER SystemTime, LocalTime;
    TIME_FIELDS Time;


#if !defined( _SETUP_LOADER_ )
    IFS_SYSTEM::QueryNtfsTime( &SystemTime );
    RtlSystemTimeToLocalTime( &SystemTime, &LocalTime );
#else
    IFS_SYSTEM::QueryNtfsTime( &LocalTime );
#endif

    RtlTimeToTimeFields(&LocalTime, &Time);

    fat_date = Time.Day;
    fat_date |= Time.Month<<5;
    fat_date |= (Time.Year - 1980)<<9;

    memcpy(&_dirent[18], &fat_date, sizeof(USHORT));

    return TRUE;
}

VOID
FAT_DIRENT::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _dirent = NULL;
}

UCHAR
RotateCharRight(
    IN  UCHAR   Char,
    IN  INT     Shift
    )
/*++

Routine Description:

    This function rotates an eight-bit character right by the
    specified number of bits.

Arguments:

    Char    --  Supplies the character to rotate
    Shift   --  Supplies the number of bits to shift

Return Value:

    The rotated character.

--*/
{
    UCHAR low_bit;

    Shift %= 8;

    while( Shift-- ) {

        low_bit = Char & 1;
        Char >>= 1;
        if( low_bit ) {
            Char |= 0x80;
        }
    }

    return (UCHAR)Char;
}

UCHAR
FAT_DIRENT::QueryChecksum(
    ) CONST

/*++

Routine Description:

    This method gets the checksum from the directory entry.  If
    the entry is a short entry, the checksum is computed; if the
    entry is long, the checksum field is returned.

Arguments:

    None.

Return Value:

    The directory entry's checksum.

--*/
{
    int name_length;
    UCHAR sum;
    PUCHAR name;

    if( IsLongEntry() ) {

        return( _dirent[13] );

    } else {

        sum = 0;
        name = _dirent;
        for( name_length = 11; name_length != 0; name_length-- ) {

            sum = RotateCharRight(sum, 1) + *name++;
        }

        return( sum );
    }
}

BOOLEAN
FAT_DIRENT::IsWellTerminatedLongNameEntry(
    ) CONST
/*++

Routine Description:

    This method determines whether the entry is a well-terminated
    long-name entry.  A long-name entry is well terminated if:


--*/
{
    ULONG   i;
    WCHAR   Name[13];

    if( IsErased() || !IsLongNameEntry() ) {

        return FALSE;
    }

    // Assemble the bits and pieces of the name:
    //
    memcpy( &Name[0], &_dirent[1], 10 );
    memcpy( &Name[5], &_dirent[14], 12 );
    memcpy( &Name[11], &_dirent[28], 4 );

    if( IsLastLongEntry() ) {

        //
        // Valid syntax for the last name entry is:
        //
        //     N* {0 0xFFFF*}
        //
        // where N is the set of non-null characters.
        //
        for( i = 0; i < 13; i++ ) {

            if( Name[i] == 0 ) {

                break;
            }
        }

        if( i < 13 ) {

            //
            // We hit a null character--step over it.
            //
            i++;
        }

        //
        // The rest of the name-component must be 0xFFFF.
        //
        for( ; i < 13; i++ ) {

            if( Name[i] != 0xFFFF ) {

                return FALSE;
            }
        }

        // This name-component was accepted.
        //
        return TRUE;

    } else {

#if 0
        // This is an additional consistency check that
        // could be performed; however, now (as of 3/28/94)
        // the file-system doesn't care, so neither do we.

        // This is not the last component of the name, so
        // it can't have any NULL's in it.
        //
        for( i = 0; i < 13; i++ ) {

            if( Name[i] == 0 ) {

                return FALSE;
            }
        }
#endif

        return TRUE;
    }
}

BOOLEAN
FAT_DIRENT::QueryLongNameComponent(
    OUT PWSTRING    NameComponent
    ) CONST
/*++

Routine Description:

    This method extracts the long-name component from a Long Name
    Directory Entry.

Arguments:

    NameComponent   --  Receives the long-name component

Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG   i;
    WCHAR   Name[13];

    if( IsErased() || !IsLongNameEntry() ) {

        return FALSE;
    }

    // Assemble the bits and pieces of the name:
    //
    memcpy( &Name[0], &_dirent[1], 10 );
    memcpy( &Name[5], &_dirent[14], 12 );
    memcpy( &Name[11], &_dirent[28], 4 );

    // Long names may be zero terminated; however, if the
    // name fits exactly into n long entries will not be
    // zero terminated.
    //
    for( i = 0; i < 13 && Name[i]; i++ );

    return( NameComponent->Initialize( Name, i ) );
}

BOOLEAN
FAT_DIRENT::NameHasTilde(
    ) CONST
/*++

Routine Description:

    This routine checks a short name entry to see if it contains a tilde.

Arguments:

    None.

Return Value:

    TRUE                        - Tilde.
    FALSE                       - No tilde.

--*/
{
    USHORT i;

    if (IsErased() || IsLongNameEntry()) {
        return FALSE;
    }

    for (i = 0; i < 11; ++i) {
        if ('~' == _dirent[i]) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOLEAN
FAT_DIRENT::NameHasExtendedChars(
    ) CONST
/*++

Routine Description:

    This routine determines whether there are any extended chars
    (those with value >= 0x80) in the short file name.

Arguments:

    None.

Return Value:

    TRUE    - There are one or more extended chars.
    FALSE   - There are no extended chars.

--*/
{
    USHORT i;

    if (IsErased() || IsLongNameEntry()) {
        return FALSE;
    }

    for (i = 0; i < 11; ++i) {
        if (_dirent[i] >= 0x80) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOLEAN
FAT_DIRENT::TimeStampsAreValid(
    USHORT t,
    USHORT d
    ) CONST
/*++

Routine Description:

    This routine examines the given time and date fields and
    determines whether they represent valid dates.

Arguments:

    None.

Return Value:

    TRUE    - The time and date are valid.
    FALSE   - One or both are invalid.

--*/
{
    USHORT  tmp;
    tmp = t&0x001F;         // 2-second increments
    if (tmp > 29) {
        return FALSE;
    }

    tmp = (t&0x07E0)>>5;    // Minutes
    if (tmp > 59) {
        return FALSE;
    }

    tmp = (t&0xF800)>>11;   // Hours
    if (tmp > 23) {
        return FALSE;
    }

    tmp = d&0x001F;         // Day of month
    if (tmp < 1 || tmp > 31) {
        return FALSE;
    }

    tmp = (d&0x01E0)>>5;    // Month
    if (tmp < 1 || tmp > 12) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\eaheader.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    eaheader.cxx

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "error.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( EA_HEADER, CLUSTER_CHAIN, UFAT_EXPORT );

VOID
EA_HEADER::Construct (
        )
/*++

Routine Description:

        Constructor for EA_HEADER.  Initializes private data to default values.

Arguments:

        None.

Return Value:

        None.

--*/
{
   _ht = NULL;
   _off_tab_size = 0;
}


UFAT_EXPORT
EA_HEADER::~EA_HEADER(
    )
/*++

Routine Description:

    Destructor for EA_HEADER.  Frees memory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
EA_HEADER::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      PFAT_SA             FatSuperArea,
    IN      PCFAT               Fat,
    IN      ULONG               StartingCluster,
    IN      ULONG               LengthOfChain
    )
/*++

Routine Description:

    This routine prepares this object for reads and writes.  It also
    prepares the object with memory so that it can accept queries.

    If the length of the cluster chain is not specified this routine
    will read in the first cluster in order to compute the actual
    length of the cluster chain.

Arguments:

    Mem             - Supplies the memory for the cluster chain.
    Drive           - Supplies the drive that contains the EA file.
    FatSuperArea    - Supplies information about the FAT file system.
    Fat             - Supplies the file allocation table.
    StartingCluster - Supplies the first cluster of the EA file.
    LengthOfChain   - Supplies the number of clusters necessary to contain
                      the EA file header, base table and offset table.

Return Value:

    FALSE   - Initialization failed.
    TRUE    - Initialization succeeded.

--*/
{
    HMEM    hmem;
    INT     i;

    Destroy();

    // See if the length of the chain needs to be computed.
    if (!LengthOfChain) {
        if (!hmem.Initialize() ||
            !CLUSTER_CHAIN::Initialize(&hmem, Drive, FatSuperArea, Fat,
                                       StartingCluster, 1) ||
            !(_ht = (PEA_HEADER_AND_TABLE) GetBuf()) ||
            !CLUSTER_CHAIN::Read() ||
            !(_ht->Header.Signature == HeaderSignature) ||
            !(_ht->Header.FormatType == 0) ||
            !(_ht->Header.LogType == 0)) {

           perrstk->push(ERR_NOT_INIT, QueryClassId());
           Destroy();
           return FALSE;

        }
        for (i = 0; i < BaseTableSize && !_ht->Table.BaseTab[i]; i++) {
        }
        if (i == BaseTableSize) {

           perrstk->push(ERR_NOT_INIT, QueryClassId());
           Destroy();
           return FALSE;

        }
        LengthOfChain = _ht->Table.BaseTab[i];
    }

    if (!CLUSTER_CHAIN::Initialize(Mem, Drive, FatSuperArea, Fat,
                                   StartingCluster, LengthOfChain) ||
        !(_ht = (PEA_HEADER_AND_TABLE) GetBuf())) {

       perrstk->push(ERR_NOT_INIT, QueryClassId());
       Destroy();
       return FALSE;

    }

    // Compute the number of offset table entries.
    _off_tab_size = Drive->QuerySectorSize() *
                    FatSuperArea->QuerySectorsPerCluster() *
                    LengthOfChain;
    _off_tab_size -= sizeof(EA_FILE_HEADER);
    _off_tab_size -= BaseTableSize*sizeof(USHORT);
    _off_tab_size /= sizeof(USHORT);

    if (_off_tab_size < 0) {

       perrstk->push(ERR_NOT_INIT, QueryClassId());
       Destroy();
       return FALSE;

    }

    return TRUE;
}


UFAT_EXPORT
USHORT
EA_HEADER::QueryEaSetClusterNumber(
    IN  USHORT  Handle
    ) CONST
/*++

Routine Description:

    This function computes the EA cluster number for an EA set in the
    EA file.  This function will return 0 if the handle is invalid or
    outside the range of the table.

Arguments:

    Handle  - Supplies the handle for the desired EA set.

Return Value:

    Returns the EA cluster number for the EA set whose handle is 'Handle'.

--*/
{
    USHORT  off;

    if (!_ht) {
       perrstk->push(ERR_NOT_INIT, QueryClassId());
       return 0;
    }

    Handle = (( Handle << 1 ) >> 1 );

    if ((LONG)Handle >= _off_tab_size ||
        (off = _ht->Table.OffTab[Handle]) == InvalidHandle) {
       return 0;
    }

    return (( off << 1 ) >> 1 ) + _ht->Table.BaseTab[Handle>>7];
}


VOID
EA_HEADER::Destroy(
    )
/*++

Routine Description:

    This routine puts this object in a blank state.  It is not necessary
    to call this routine between calls to Init because Init calls this
    routine automatically.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _ht = NULL;
    _off_tab_size = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\easet.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    easet.cxx

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "error.hxx"


DEFINE_EXPORTED_CONSTRUCTOR( EA_SET, CLUSTER_CHAIN, UFAT_EXPORT );

VOID
EA_SET::Construct (
        )
/*++

Routine Description:

        Constructor for EA_SET.  Sets private data to default values.

Arguments:

        None.

Return Value:

        None.

--*/
{
   memset(&_eahdr, 0, sizeof(_eahdr));
   _size = 0;
   _size_imposed = FALSE;
   _current_ea = NULL;
   _current_index = 0;
}


UFAT_EXPORT
EA_SET::~EA_SET(
    )
/*++

Routine Description:

    Destructor for EA_SET.  Frees memory.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UFAT_EXPORT
BOOLEAN
EA_SET::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      PFAT_SA             FatSuperArea,
    IN      PCFAT               Fat,
    IN      ULONG               ClusterNumber,
    IN      ULONG               LengthOfChain
    )
/*++

Routine Description:

    This routine initialize the EA_SET to model the EA set which resides
    at FAT cluster 'ClusterNumber'.

Arguments:

    Mem             - Supplies the memory for the cluster chain.
    Drive           - Supplies the drive where the EA set is contained.
    FatSuperArea    - Supplies the important drive parameters.
    Fat             - Supplies the file allocation table.
    StartingCluster - Supplies the starting cluster of the EA set.
    LengthOfChain   - Supplies the length of the cluster chai which contains
                        the EA set.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM    hmem;
    ULONG   cluster_size;
    ULONG   sector_size;

    Destroy();

    if (!FatSuperArea || !Drive || !(sector_size = Drive->QuerySectorSize())) {
                perrstk->push(ERR_NOT_INIT, QueryClassId());
        Destroy();
        return FALSE;
    }

    cluster_size = sector_size*FatSuperArea->QuerySectorsPerCluster();

    if (!LengthOfChain) {
        if (!hmem.Initialize() ||
            !CLUSTER_CHAIN::Initialize(&hmem, Drive, FatSuperArea, Fat,
                                       ClusterNumber, 1) ||
            !Read()) {
                        perrstk->push(ERR_NOT_INIT, QueryClassId());
            Destroy();
            return FALSE;
        }

        _size = _eahdr.TotalSize + SizeOfEaHdr - sizeof(LONG);
        _size_imposed = TRUE;

        if (_size%cluster_size) {
            LengthOfChain = (USHORT) (_size/cluster_size + 1);
        } else {
            LengthOfChain = (USHORT) (_size/cluster_size);
        }
    } else {
        _size = cluster_size*LengthOfChain;
        _size_imposed = FALSE;
    }


    if (!CLUSTER_CHAIN::Initialize(Mem, Drive, FatSuperArea, Fat,
                                   ClusterNumber, LengthOfChain)) {
                perrstk->push(ERR_NOT_INIT, QueryClassId());
        Destroy();
        return FALSE;
    }

    return TRUE;
}


UFAT_EXPORT
BOOLEAN
EA_SET::Read(
    )
/*++

Routine Description:

    This routine reads the cluster chain and then unpacks the ea header.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LONG    size;


    if (!CLUSTER_CHAIN::Read() || !UnPackEaHeader()) {
        return FALSE;
    }

    size = _eahdr.TotalSize + SizeOfEaHdr - sizeof(LONG);
    if (size < _size) {
        _size = size;
        _size_imposed = TRUE;
    }

    return TRUE;
}


UFAT_EXPORT
PEA
EA_SET::GetEa(
    IN  ULONG       Index,
    OUT PLONG       EaSize,
    OUT PBOOLEAN    PossiblyMore
    )
/*++

Routine Description:

    This routine returns a pointer to the Index'th EA.  An Index of 0
    indicates the first EA and so on.  A NULL pointer will be returned if
    the Index'th EA does not exist.

    This routine will validate the EA before returning it.  If the EA is
    invalid then NULL will be returned.

    The return value 'PossiblyMore' will only be computed in the event
    that the EA at index 'Index' can't be found.  It is used to indicate
    that there may be another EA in the next cluster of the cluster chain.

Arguments:

    Index   - Supplies which EA is requested.
    EaSize  - Returns the size of the EA.
    PossiblyMore    - Returns TRUE if there may possibly be more EAs in
                        a cluster beyond the boundary of the cluster chain.
                        Returns FALSE if this is impossible.

Return Value:

    A pointer to an EA structure or NULL.

--*/
{
    ULONG   i;
    PEA     r;
    PCHAR   p, b;
    ULONG   offset;

    if (PossiblyMore) {
        *PossiblyMore = FALSE;
    }

    if (!(b = (PCHAR) GetBuf())) {
        perrstk->push(ERR_NOT_INIT, QueryClassId());
        return NULL;
    }

    if (!_current_ea || Index < _current_index) {
        p = (PCHAR) (r = (PEA) (b + SizeOfEaHdr));

        if (!r->NameSize || !r->ValueSize[0] && !r->ValueSize[1]) {
            return NULL;
        }

        offset = sizeof(EA) + r->NameSize + r->ValueSize[0] +
                 (r->ValueSize[1]<<8);

        if (p - b + offset > (ULONG)_size) {
            if (PossiblyMore && !_size_imposed) {
                *PossiblyMore = TRUE;
            }

            return NULL;
        }

        if (p[sizeof(EA) + r->NameSize - 1]) {
            return NULL;
        }

        _current_index = 0;
    } else {
        p = (PCHAR) (r = _current_ea);

        offset = sizeof(EA) + r->NameSize + r->ValueSize[0] +
                (r->ValueSize[1]<<8);
    }

    for (i = _current_index; i < Index; i++) {
        r = (PEA) (p += offset);

        if (p - b + sizeof(EA) > (ULONG)_size) {
            if (PossiblyMore && !_size_imposed) {
                *PossiblyMore = TRUE;
            }

            return NULL;
        }

        if (!r->NameSize || !r->ValueSize[0] && !r->ValueSize[1]) {
            return NULL;
        }

        offset = sizeof(EA) + r->NameSize + r->ValueSize[0] +
                (r->ValueSize[1]<<8);

        if (p - b + offset > (ULONG)_size) {
            if (PossiblyMore && !_size_imposed) {
                *PossiblyMore = TRUE;
            }

            return NULL;
        }

        if (p[sizeof(EA) + r->NameSize - 1]) {
            return NULL;
        }
    }

    _current_index = i;
    _current_ea = r;

    if (EaSize) {
        *EaSize = offset;
    }

    return r;
}


VOID
EA_SET::Destroy(
    )
/*++

Routine Description:

    This routine returns the object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    memset(&_eahdr, 0, sizeof(_eahdr));
    _size = 0;
    _size_imposed = FALSE;
    _current_ea = NULL;
    _current_index = 0;
}


BOOLEAN
EA_SET::PackEaHeader(
    )
/*++

Routine Description:

    This routine packs the EA set header.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PPACKED_EA_HDR  peahdr;

    if (!(peahdr = (PPACKED_EA_HDR) GetBuf())) {
                perrstk->push(ERR_NOT_INIT, QueryClassId());
        return FALSE;
    }

    peahdr->Signature = _eahdr.Signature;
    peahdr->OwnHandle = _eahdr.OwnHandle;
    peahdr->NeedCount = _eahdr.NeedCount;
    memcpy(peahdr->OwnerFileName, _eahdr.OwnerFileName, 14);
    memcpy(peahdr->Reserved, &_eahdr.Reserved, sizeof(ULONG));
    memcpy(peahdr->TotalSize, &_eahdr.TotalSize, sizeof(LONG));

    return TRUE;
}


BOOLEAN
EA_SET::UnPackEaHeader(
    )
/*++

Routine Description:

    This routine unpacks the EA set header.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PPACKED_EA_HDR  peahdr;

    if (!(peahdr = (PPACKED_EA_HDR) GetBuf())) {
                perrstk->push(ERR_NOT_INIT, QueryClassId());
        return FALSE;
    }

    _eahdr.Signature = peahdr->Signature;
    _eahdr.OwnHandle = peahdr->OwnHandle;
    _eahdr.NeedCount = peahdr->NeedCount;
    memcpy(_eahdr.OwnerFileName, peahdr->OwnerFileName, 14);
    memcpy(&_eahdr.Reserved, peahdr->Reserved, sizeof(ULONG));
    memcpy(&_eahdr.TotalSize, peahdr->TotalSize, sizeof(LONG));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\fat.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    fat.cxx

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UFAT_MEMBER_

#include "ulib.hxx"
#include "ufat.hxx"

#include "bitvect.hxx"
#include "error.hxx"
#include "fat.hxx"


DEFINE_CONSTRUCTOR( FAT, SECRUN );


FAT::~FAT(
    )
/*++

Routine Description:

    Destructor for FAT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

extern VOID DoInsufMemory(VOID);

VOID
FAT::Construct (
    )
/*++

Routine Description:

    Constructor for FAT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _fat = NULL;
    _num_entries = 0;
    _fat_bits = 0;
    _low_end_of_chain = 0;
    _end_of_chain = 0;
    _bad_cluster = 0;
    _low_reserved = 0;
    _high_reserved = 0;
    _AllocatedClusters = 0xFFFFFFFF;
}


VOID
FAT::Destroy(
    )
/*++

Routine Description:

    This routine returns a FAT object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _fat = NULL;
    _num_entries = 0;
    _fat_bits = 0;
    _low_end_of_chain = 0;
    _end_of_chain = 0;
    _bad_cluster = 0;
    _low_reserved = 0;
    _high_reserved = 0;
    _AllocatedClusters = 0xFFFFFFFF;
}


BOOLEAN
FAT::Initialize(
    IN OUT  PSECRUN     Srun,
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      LBN                 StartSector,
    IN      ULONG               NumOfEntries,
    IN      ULONG               NumSectors
    )
/*++

Routine Description:

    This routine initialize a FAT object.

Arguments:

    Mem             - Supplies the memory for the run of sectors.
    Drive           - Supplies the drive to read and write from.
    StartSector     - Supplies the start of the fat.
    NumberOfEntries - Supplies the number of entries in the FAT
                      which should be the total number of clusters
                      plus two reserved entries at the beginning.
    NumSectors      - Supplies the number of sectors allocated for
                      the fat.  If this parameter is not supplied
                      then this routine will compute this value
                      from the given number of entries.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    The 'NumSectors' parameter is added to this function
    DOS FORMAT does not always make the FAT large enough for
    the volume.  If this parameter is supported then the
    number of entries supported by this FAT will be the lesser
    or the actual number passed in that the maximum number that
    the given FAT size will support.

--*/
{
    SECTORCOUNT n;
    ULONG       sector_size;
    ULONG       max_num_entries;

    DebugAssert(Mem);
    DebugAssert(Drive);

    Destroy();

    if (!(sector_size = Drive->QuerySectorSize())) {
        Destroy();
        return FALSE;
    }

    _num_entries = NumOfEntries;

    if (_num_entries < FirstDiskCluster + MaxNumClusForSmallFat) {
       _fat_bits = fFat12;
    } else if (_num_entries < FirstDiskCluster + MinNumClusForFat32) {
       _fat_bits = fFat16;
    } else {
       _fat_bits = fFat32;
    }

    if (fFat32 == _fat_bits) {
        _low_end_of_chain = 0x0FFFFFF8;
        _end_of_chain = 0x0FFFFFFF;
        _bad_cluster = 0x0FFFFFF7;
        _low_reserved = 0x0FFFFFF0;
        _high_reserved = 0x0FFFFFF6;
        n = (_num_entries*4 - 1)/sector_size + 1;
    }
    else if (fFat16 == _fat_bits) {
        // COMMON CODE for FAT 12 and FAT 16
        // FAT 16
        _low_end_of_chain = 0xFFF8;
        _end_of_chain = 0xFFFF;
        _bad_cluster = 0xFFF7;
        _low_reserved = 0xFFF0;
        _high_reserved = 0xFFF6;

        n = (_num_entries*2 - 1)/sector_size + 1;

    }
    else {      // FAT 12
        _low_end_of_chain = 0x0FF8;
        _end_of_chain = 0x0FFF;
        _bad_cluster = 0x0FF7;
        _low_reserved = 0x0FF0;
        _high_reserved = 0x0FF6;

        n = (_num_entries*3 - 1)/2/sector_size + 1;
    }

    if (NumSectors) {
        n = NumSectors;
        if (fFat32 == _fat_bits) {
           max_num_entries = (n*sector_size/4);
        } else if (fFat16 == _fat_bits) {
           // COMMON CODE for FAT 12 and FAT 16
           max_num_entries = (n*sector_size/2);
        } else {
            max_num_entries = (n*sector_size*2/3);
        }
        _num_entries = min(_num_entries, max_num_entries);
    }
    _AllocatedClusters = 0xFFFFFFFF;

    if (!Srun->Initialize(Mem, Drive, StartSector, n)) {
    DoInsufMemory();
        Destroy();
        return FALSE;
    }

    _fat = Srun->GetBuf();
    return TRUE;
}



BOOLEAN
FAT::Initialize(
    IN OUT  PMEM                Mem,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      LBN                 StartSector,
    IN      ULONG               NumOfEntries,
    IN      ULONG               NumSectors
    )
/*++

Routine Description:

    This routine initialize a FAT object.

Arguments:

    Mem             - Supplies the memory for the run of sectors.
    Drive           - Supplies the drive to read and write from.
    StartSector     - Supplies the start of the fat.
    NumberOfEntries - Supplies the number of entries in the FAT
                      which should be the total number of clusters
                      plus two reserved entries at the beginning.
    NumSectors      - Supplies the number of sectors allocated for
                      the fat.  If this parameter is not supplied
                      then this routine will compute this value
                      from the given number of entries.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    The 'NumSectors' parameter is added to this function
    DOS FORMAT does not always make the FAT large enough for
    the volume.  If this parameter is supported then the
    number of entries supported by this FAT will be the lesser
    or the actual number passed in that the maximum number that
    the given FAT size will support.

--*/
{
    SECTORCOUNT n;
    ULONG       sector_size;
    ULONG       max_num_entries;

    DebugAssert(Mem);
    DebugAssert(Drive);

    Destroy();

    if (!(sector_size = Drive->QuerySectorSize())) {
        Destroy();
        return FALSE;
    }

    _num_entries = NumOfEntries;

    if (_num_entries < FirstDiskCluster + MaxNumClusForSmallFat) {
       _fat_bits = fFat12;
    } else if (_num_entries < FirstDiskCluster + MinNumClusForFat32) {
       _fat_bits = fFat16;
    } else {
       _fat_bits = fFat32;
    }

    if (fFat32 == _fat_bits) {
        _low_end_of_chain = 0x0FFFFFF8;
        _end_of_chain = 0x0FFFFFFF;
        _bad_cluster = 0x0FFFFFF7;
        _low_reserved = 0x0FFFFFF0;
        _high_reserved = 0x0FFFFFF6;
    n = ((_num_entries * 4) + (sector_size - 1)) / sector_size;
    }
    else if (fFat16 == _fat_bits) {
        // COMMON CODE for FAT 12 and FAT 16
        // FAT 16
        _low_end_of_chain = 0xFFF8;
        _end_of_chain = 0xFFFF;
        _bad_cluster = 0xFFF7;
        _low_reserved = 0xFFF0;
        _high_reserved = 0xFFF6;

    n = ((_num_entries * 2) + (sector_size - 1)) / sector_size;

    }
    else {      // FAT 12
        _low_end_of_chain = 0x0FF8;
        _end_of_chain = 0x0FFF;
        _bad_cluster = 0x0FF7;
        _low_reserved = 0x0FF0;
        _high_reserved = 0x0FF6;

    // NOTE: the "+ (2 - 1)) / 2)" below is doing a round up divide by 2
    //   it is left this way because it is clearer what it is doing....

    n = ((((_num_entries * 3) + (2 - 1)) / 2) + (sector_size - 1)) / sector_size;
    }

    if (NumSectors) {
        n = NumSectors;
        if (fFat32 == _fat_bits) {
           max_num_entries = (n*sector_size/4);
        } else if (fFat16 == _fat_bits) {
           // COMMON CODE for FAT 12 and FAT 16
           max_num_entries = (n*sector_size/2);
        } else {
            max_num_entries = (n*sector_size*2/3);
        }
        _num_entries = min(_num_entries, max_num_entries);
    }
    _AllocatedClusters = 0xFFFFFFFF;

    if (!SECRUN::Initialize(Mem, Drive, StartSector, n)) {
    DoInsufMemory();
        Destroy();
        return FALSE;
    }

    _fat = GetBuf();
    return TRUE;
}


UFAT_EXPORT
ULONG
FAT::Index12(
    IN  ULONG    ClusterNumber
    ) CONST
/*++

Routine Description:

    This routine indexes the FAT as 12 bit little endian entries.

Arguments:

    ClusterNumber   - Supplies the FAT entry desired.

Return Value:

    The value of the FAT entry at ClusterNumber.

--*/
{
    ULONG   n;
    PUCHAR  p;

    p = (PUCHAR) _fat;

    DebugAssert(p);

    n = ClusterNumber*3;
    if (n%2) {
        return (p[n/2]>>4) | (p[n/2 + 1]<<4);
    } else {
        return p[n/2] | ((p[n/2 + 1]&0x0F)<<8);
    }
}


UFAT_EXPORT
VOID
FAT::Set12(
    IN  ULONG    ClusterNumber,
    IN  ULONG    Value
    )
/*++

Routine Description:

    This routine sets the ClusterNumber'th 12 bit FAT entry to Value.

Arguments:

    ClusterNumber   - Supplies the FAT entry to set.
    Value           - Supplies the value to set the FAT entry to.

Return Value:

    None.

--*/
{
    ULONG   n;
    PUCHAR  p;

    p = (PUCHAR) _fat;

    DebugAssert(p);

    n = ClusterNumber*3;
    if (n%2) {
        p[n/2] = (p[n/2]&0x0F) | (((UCHAR)Value&0x000F)<<4);
        p[n/2 + 1] = (UCHAR)((Value&0x0FF0)>>4);
    } else {
        p[n/2] = (UCHAR)Value&0x00FF;
        p[n/2 + 1] = (p[n/2 + 1]&0xF0) | (UCHAR)((Value&0x0F00)>>8);
    }
    _AllocatedClusters = 0xFFFFFFFF;
}

ULONG
FAT::QueryFreeClusters(
    ) CONST
/*++

Routine Description:

    This routine computes the number of free clusters on the disk by
    scanning the FAT and counting the number of empty entries.

Arguments:

    None.

Return Value:

    The number of free clusters on the disk.

--*/
{
    ULONG    i;
    ULONG    r;

    r = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterFree(i)) {

            r++;
        }
    }

    return r;
}


ULONG
FAT::QueryBadClusters(
    ) CONST
/*++

Routine Description:

    This routine computes the number of bad clusters on the disk by
    scanning the FAT and counting the number of entries marked bad.

Arguments:

    None.

Return Value:

    The number of bad clusters on the disk.

--*/
{
    ULONG    i;
    ULONG    r;

    r = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterBad(i)) {
            r++;
        }
    }

    return r;
}


ULONG
FAT::QueryReservedClusters(
    ) CONST
/*++

Routine Description:

    This routine computes the number of reserved clusters on the disk by
    scanning the FAT and counting the number of entries marked reserved.

Arguments:

    None.

Return Value:

    The number of reserved clusters on the disk.

--*/
{
    ULONG    i;
    ULONG    r;

    r = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterReserved(i)) {
            r++;
        }
    }

    return r;
}

ULONG
FAT::QueryAllocatedClusters(
    ) CONST
/*++

Routine Description:

    This routine computes the number of allocated clusters on the
    disk by scanning the FAT and counting the entries marked allocated.

Arguments:

    None.

Return Value:

    The number of allocated clusters on the disk.

--*/
{
    ULONG    i;
    ULONG    r;

    r = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (!IsClusterReserved(i) && !IsClusterBad(i) && !IsClusterFree(i)) {
            r++;
        }
    }

    return r;
}


UFAT_EXPORT
ULONG
FAT::QueryNthCluster(
    IN  ULONG    StartingCluster,
    IN  ULONG    Index
    ) CONST
/*++

Routine Description:

    This routine returns the cluster number of the cluster that is in the
    'Index'th position in the cluster chain beginning at 'StartingCluster'.
    The clusters in a chain are numbered beginning at zero.

Arguments:

    StartingCluster - Supplies the first cluster of a cluster chain.
    Index           - Supplies the number of the cluster in the chain
                        requested.

Return Value:

    The cluster number of the 'Index'th cluster in the cluster chain
    beginning with cluster 'StartingCluster' or 0.

--*/
{
    for (; Index; Index--) {

        if (!IsInRange(StartingCluster)) {
            return 0;
        }

        StartingCluster = QueryEntry(StartingCluster);
    }

    return StartingCluster;
}


UFAT_EXPORT
ULONG
FAT::QueryLengthOfChain(
    IN  ULONG    StartingCluster,
    OUT PULONG   LastCluster
    ) CONST
/*++

Routine Description:

    This routine computes the length of a cluster chain given the number
    of its first cluster.

    This routine depends on the chain being valid.  In particular, if the
    chain contains any cycles then this routine will not finish.  The
    routine 'ScrubChain' will turn an invalid chain into a valid one.

Arguments:

    StartingCluster - Supplies the first cluster of a cluster chain.
    LastCluster     - Returns the number of the last cluster in the chain.

Return Value:

    The length of the cluster chain beginning with 'StartingCluster'.

--*/
{
    ULONG    length;

    if (!StartingCluster) {
        if (LastCluster) {
            *LastCluster = 0;
        }
        return 0;
    }

    for (length = 1; IsInRange(StartingCluster) && !IsEndOfChain(StartingCluster); length++) {
        StartingCluster = QueryEntry(StartingCluster);
    }

    if (LastCluster) {
        *LastCluster = StartingCluster;
    }

    return length;
}


ULONG
FAT::QueryLengthOfChain(
    IN  ULONG    StartingCluster,
    IN  ULONG    EndingCluster
    ) CONST
/*++

Routine Description:

    This routine computes the length of a cluster chain given the number
    of its first cluster and the number of its last cluster.  To compute
    the length of a chain which is terminated by "end of chain", see
    the one parameter version of this routine above.  If 'EndingCluster'
    is not a member of the chain beginning with 'StartingCluster' then
    this routine will return 0.

    This routine depends on the chain being valid.

Arguments:

    StartingCluster - Supplies the first cluster of the cluster chain.
    EndingCluster   - Supplies the last cluster of the cluster chain.

Return Value:

    The length of the cluster chain beginning with 'StartingCluster' and
    ending with 'EndingCluster' or 0.

--*/
{
    ULONG    length;

    if (!StartingCluster) {
        return 0;
    }

    for (length = 1; StartingCluster != EndingCluster &&
                     !IsEndOfChain(StartingCluster); length++) {
        StartingCluster = QueryEntry(StartingCluster);
    }

    return StartingCluster == EndingCluster ? length : 0;
}


ULONG
FAT::QueryPrevious(
    IN  ULONG    Cluster
    ) CONST
/*++

Routine Description:

    Obtains the previous cluster in a chain, i.e. the cluster that
    references the given cluster.

Arguments:

    Cluster -   Supplies the cluster whose predecesor we're looking for.

Return Value:

    The predecesor of the given cluster. 0 if there is no predecesor.

--*/

{
    ULONG    i;

    DebugAssert( Cluster );

    if ( !IsClusterFree( Cluster ) ) {
        for (i = FirstDiskCluster; IsInRange(i); i++) {
            if ( QueryEntry(i) == Cluster ) {
                return i;
            }
        }
    }

    return 0;
}


VOID
FAT::Scrub(
    OUT PBOOLEAN    ChangesMade
    )
/*++

Routine Description:

    This routine goes through all of the FAT entries changing invalid values
    to reasonable values for the purposes of CHKDSK.

    Illegal FAT entries are those that are set out of disk range and that
    are not magic values.  This routine will set all illegal FAT entries to
    the "end of chain" magic value.

Arguments:

    ChangesMade - Returns TRUE if any changes were made to the FAT.

Return Value:

    None.

--*/
{
    ULONG    i;

    if (ChangesMade) {
        *ChangesMade = FALSE;
    }

    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (!IsInRange(QueryEntry(i)) &&
            !IsClusterFree(i) &&
            !IsEndOfChain(i) &&
            !IsClusterBad(i) &&
            !IsClusterReserved(i)) {

            SetEndOfChain(i);

            if (ChangesMade) {
                *ChangesMade = TRUE;
            }
        }
    }
}


VOID
FAT::ScrubChain(
    IN      ULONG        StartingCluster,
    OUT     PBOOLEAN     ChangesMade
    )
/*++

Routine Description:

    This routine goes through all of the FAT entries in the chain beginning
    with cluster 'StartingCluster'.  It is expected that all of the entries
    in this chain point to valid clusters on the disk.  This routine will
    mark the first invalid entry, if any, as the final cluster of the chain
    thus transforming the invalid chain into a valid one.

Arguments:

    StartingCluster - Supplies the first cluster of the chain to
                      scrub.
    ChangesMade     - Returns TRUE if changes were made to correct
                      the chain.

Return Value:

    None.

--*/
{
    ULONG    clus, next;

    DebugAssert(IsInRange(StartingCluster));
    DebugAssert(ChangesMade);

    *ChangesMade = FALSE;

    clus = StartingCluster;
    while (!IsEndOfChain(clus)) {

        next = QueryEntry(clus);
        if (!IsInRange(next) || IsClusterFree(next)) {
            SetEndOfChain(clus);
            *ChangesMade = TRUE;
            return;
        }

        clus = next;
    }
}


VOID
FAT::ScrubChain(
    IN      ULONG       StartingCluster,
    OUT     PBITVECTOR  FatBitMap,
    OUT     PBOOLEAN    ChangesMade,
    OUT     PBOOLEAN    CrossLinkDetected,
    OUT     PULONG      CrossLinkPreviousCluster
    )
/*++

Routine Description:

    This routine goes through all of the FAT entries in the chain beginning
    with cluster 'StartingCluster'.  It is expected that all of the entries
    in this chain point to valid clusters on the disk.  This routine will
    mark the first invalid entry, if any, as the final cluster of the chain
    thus transforming the invalid chain into a valid one.

    This routine will also eliminate any cycles in the cluster chain as well
    as detect cross-links.

Arguments:

    StartingCluster             - Supplies the first cluster of the chain to
                                    scrub.
    UsedClusters                - Supplies a bitvector marking all used
                                    clusters.
    ChangesMade                 - Returns TRUE if changes were made to correct
                                    the chain.
    CrossLinkDetected           - Returns TRUE if a cluster in the chain was
                                    already claimed in the 'FatBitMap'.
    CrossLinkPreviousCluster    - Returns the cluster number previous to the
                                    cross linked cluster number or 0 if the
                                    cross linked cluster number was the first
                                    in the chain.

Return Value:

    None.

--*/
{
    ULONG    clus, next;

    DebugAssert(IsInRange(StartingCluster));
    DebugAssert(ChangesMade);
    DebugAssert(CrossLinkDetected);
    DebugAssert(CrossLinkPreviousCluster);

    *ChangesMade = FALSE;
    *CrossLinkDetected = FALSE;

    if (FatBitMap->IsBitSet(StartingCluster)) {
        *CrossLinkDetected = TRUE;
        *CrossLinkPreviousCluster = 0;
        return;
    }

    clus = StartingCluster;
    while (!IsEndOfChain(clus)) {

        FatBitMap->SetBit(clus);

        next = QueryEntry(clus);
        if (!IsInRange(next) || IsClusterFree(next)) {
            SetEndOfChain(clus);
            *ChangesMade = TRUE;
            return;
        }

        if (FatBitMap->IsBitSet(next)) {

            if (clus == next) {       // Cluster points to itself.
                *ChangesMade = TRUE;
                SetEndOfChain(clus);
                return;
            }

            while (StartingCluster != clus) {

                if (StartingCluster == next) { // Cluster points to previous.
                    *ChangesMade = TRUE;
                    SetEndOfChain(clus);
                    return;
                }

                StartingCluster = QueryEntry(StartingCluster);
            }

            // Otherwise it's a cross link, not a cycle.

            *CrossLinkDetected = TRUE;
            *CrossLinkPreviousCluster = clus;
            return;
        }

        clus = next;
    }

    FatBitMap->SetBit(clus);
}

NONVIRTUAL
BOOLEAN
FAT::IsValidChain(
    IN  ULONG    StartingCluster
    ) CONST
/*++

Routine Description:

    This method determines whether the chain is valid, ie. that it
    consists of a chain of valid cluster numbers ending with an end
    of chain entry.

Arguments:

    StartingCluster - Supplies the first cluster of the chain.

Return Value:

    TRUE if the chain is valid.

--*/
{
    ULONG    current;
    ULONG    clusters_in_chain = 0;

    current = StartingCluster;

    for( ;; ) {

        if (!IsInRange(current) ||
            clusters_in_chain++ > _num_entries ) {

            // Either a bad entry or an infinite loop detected.
            //
            return FALSE;
        }

        if (IsEndOfChain(current)) {
            break;
        }

        current = QueryEntry(current);
    }

    return TRUE;
}


UFAT_EXPORT
ULONG
FAT::AllocChain(
    IN  ULONG    Length,
    OUT PULONG   LastCluster
    )
/*++

Routine Description:

    This routine attempts to allocate a chain of length 'Length' from the
    FAT.  If this routine is successful it will return the cluster number
    of the beginning of the chain.  Upon failure this routine will return
    0 and will make no changes to the FAT.

Arguments:

    Length      - Supplies the length of the chain desired.
    LastCluster - Returns the last cluster of the allocated chain.

Return Value:

    The cluster number of the beginning of the allocated chain or 0.

--*/
{
    ULONG    i, j;
    ULONG    start;
    ULONG    prev;

    if (!Length) {
        return 0;
    }

    start = 0;
    prev = 0;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterFree(i)) {
            if (!start) {
                start = i;
            } else {
                SetEntry(prev, i);
            }
            prev = i;
            Length--;
            if (!Length) {
                SetEndOfChain(i);

                if (LastCluster) {
                    *LastCluster = i;
                }

                return start;
            }
        }
    }

    // There is not enough disk space for the chain so free what was taken.
    for (i = start; i != prev; ) {
        j = QueryEntry(i);
        SetClusterFree(i);
        i = j;
    }

    return 0;
}


ULONG
FAT::ReAllocChain(
    IN  ULONG    StartOfChain,
    IN  ULONG    NewLength,
    OUT PULONG   LastCluster
    )
/*++

Routine Description:

    This routine insures that the cluster chain beginning at cluster
    'StartOfChain' is of length greater than or equal to 'NewSize'.
    If it is not then this routine will attempt to grow the chain by
    allocating new clusters.  Failure to allocate sufficient clusters
    to grow the chain to 'NewSize' clusters will cause this routine to
    restore the chain to its original length and state.  This routine will
    return the current length of the chain : either the old length or the
    new length.  If an error occurs then 0 will be returned.

Arguments:

    StartOfChain    - Supplies the first cluster of the chain.
    NewLength       - Supplies the desired new length of the chain.
    LastCluster     - Returns the last cluster of the chain.

Return Value:

    The current length of the chain or 0.

--*/
{
    ULONG    length;
    ULONG    new_clusters_needed;
    ULONG    end_of_chain;
    ULONG    i, j;
    ULONG    start;

    if (!IsInRange(StartOfChain)) {
        return 0;
    }

    for (length = 1; !IsEndOfChain(StartOfChain); length++) {
        StartOfChain = QueryEntry(StartOfChain);
        if (!IsInRange(StartOfChain)) {
            return 0;
        }
    }

    if (length >= NewLength) {
        if (LastCluster) {
            *LastCluster = StartOfChain;
        }
        return length;
    }

    new_clusters_needed = NewLength - length;

    start = end_of_chain = StartOfChain;
    for (i = FirstDiskCluster; IsInRange(i); i++) {
        if (IsClusterFree(i)) {
            SetEntry(end_of_chain, i);
            end_of_chain = i;
            new_clusters_needed--;
            if (!new_clusters_needed) {
                SetEndOfChain(i);
                if (LastCluster) {
                    *LastCluster = i;
                }
                return NewLength;
            }
        }
    }

    // There is not enough disk space to lengthen the new chain so
    // settle for the old length.

    for (i = start; i != end_of_chain; ) {
        j = QueryEntry(i);
        SetClusterFree(i);
        i = j;
    }

    SetEndOfChain(start);

    if (LastCluster) {
        *LastCluster = start;
    }

    return length;
}


UFAT_EXPORT
VOID
FAT::FreeChain(
    IN  ULONG    StartOfChain
    )
/*++

Routine Description:

    This routine sets free all of the clusters in the cluster chain
    beginning with 'StartOfChain'.

Arguments:

    StartOfChain    - Supplies the first cluster of the chain to free.

Return Value:

    None.

--*/
{
    ULONG    tmp;

    while (!IsEndOfChain(StartOfChain)) {
        tmp = QueryEntry(StartOfChain);
        SetClusterFree(StartOfChain);
        StartOfChain = tmp;
    }
    SetClusterFree(StartOfChain);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\fatdir.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    fatdir.cxx

--*/

#include <pch.cxx>

#define _UFAT_MEMBER_
#include "ufat.hxx"

#include "error.hxx"
#include "wstring.hxx"


DEFINE_CONSTRUCTOR( FATDIR, OBJECT );

UFAT_EXPORT
PVOID
FATDIR::SearchForDirEntry(
    IN  PCWSTRING   FileName
    )
/*++

Routine Description:

    This routine gets the directory entry with the (null-terminated)
    filename 'FileName'.  If no such directory entry exists then
    this routine return NULL.

Arguments:

    FileName    - The name of the file searched for.

Return Value:

    A pointer to a directory entry or NULL.

--*/
{
    FAT_DIRENT  dirent;
    ULONG       i;
    DSTRING     filename;
    PVOID       p;

    for (i = 0; dirent.Initialize(p = GetDirEntry(i)); i++) {

        if (dirent.IsEndOfDirectory()) {
            break;
        }

        if (dirent.IsErased()) {
            continue;
        }

        dirent.QueryName(&filename);

        if (dirent.IsVolumeLabel()) {
            continue;
        }

        if (*FileName == filename) {
            return p;
        }

        if (QueryLongName(i, &filename) && (*FileName == filename)) {
            return p;
        }
    }

    return NULL;
}


PVOID
FATDIR::GetFreeDirEntry(
    )
/*++

Routine Description:

    This routine gets an unused directory entry, if one exists.
    If one doesn't exist then this routine returns NULL.

Arguments:

    None.

Return Value:

    A pointer to a directory entry or NULL.

--*/
{
    FAT_DIRENT  dirent;
    ULONG       i;
    PVOID       p;

    for (i = 0; dirent.Initialize(p = GetDirEntry(i)); i++) {

        if (dirent.IsEndOfDirectory()) {
            if (dirent.Initialize(GetDirEntry(i + 1))) {
                dirent.SetEndOfDirectory();
            }
            return p;
        }

        if (dirent.IsErased()) {
            return p;
        }
    }

    return NULL;
}

extern VOID DoInsufMemory(VOID);

UFAT_EXPORT
BOOLEAN
FATDIR::QueryLongName(
    IN  LONG        EntryNumber,
    OUT PWSTRING    LongName
    )
/*++

Routine Description:

    This method fetches the long file name associated with the
    short directory entry at index EntryNumber.

Arguments:

    EntryNumber
    LongName        --  Receives the long name associated with this entry.
                        Receives "" if there is no long name.

Return Value:

    TRUE upon successful completion
    FALSE to indicate failure or disk corruption.

--*/
{
    DSTRING     NameComponent;
    FAT_DIRENT  CurrentEntry;
    LONG        CurrentIndex;
    ULONG       Ordinal = 1;
    UCHAR       Checksum;

    CurrentIndex = EntryNumber;

    if( !CurrentEntry.Initialize( GetDirEntry( CurrentIndex ) ) ||
        !LongName->Initialize( "" ) ) {
    DoInsufMemory();
        return FALSE;
    }

    Checksum = CurrentEntry.QueryChecksum();

    CurrentIndex--;

    for( ; CurrentIndex >= 0; CurrentIndex-- ) {

        if( !CurrentEntry.Initialize( GetDirEntry( CurrentIndex ) ) ) {

        DoInsufMemory();
            return FALSE;
        }

        if( CurrentEntry.IsErased() ||  !CurrentEntry.IsLongEntry() ) {

            // The long name entries are not valid--return an
            // empty string for the long name.
            //
            return( LongName->Initialize( "" ) );
        }

        if( CurrentEntry.IsLongNameEntry() ) {

            if( CurrentEntry.QueryLongOrdinal() != Ordinal ||
                CurrentEntry.QueryChecksum() != Checksum ) {

                // The long-name entries don't belong to the
                // specified short entry.
                //
                return( LongName->Initialize( "" ) );
            }

            if( !CurrentEntry.QueryLongNameComponent( &NameComponent ) ||
                !LongName->Strcat( &NameComponent ) ) {

                return FALSE;
            }

            if( CurrentEntry.IsLastLongEntry() ) {

                // This was the last entry.
                //
                return TRUE;
            }

            Ordinal++;
        }
    }

    // There is no long name, or it is not valid.
    //
    return( LongName->Initialize( "" ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\fatvol.cxx ===
/*++

Copyright (c) 1991-1999 Microsoft Corporation

Module Name:

    fatvol.cxx

--*/

#include <pch.cxx>

#include "error.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "wstring.hxx"


DEFINE_CONSTRUCTOR( FAT_VOL, VOL_LIODPDRV );

VOID
FAT_VOL::Construct (
    )

/*++

Routine Description:

    Constructor for FAT_VOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // unreferenced parameters
    (void)(this);
}


FAT_VOL::~FAT_VOL(
    )
/*++

Routine Description:

    Destructor for FAT_VOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


FORMAT_ERROR_CODE
FAT_VOL::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType
    )
/*++

Routine Description:

    This routine initializes a FAT_VOL object.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                      opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE             msg;
    FORMAT_ERROR_CODE   errcode;

    Destroy();

    errcode = VOL_LIODPDRV::Initialize(NtDriveName, &_fatsa, Message,
                                       ExclusiveWrite, FormatMedia,
                                       MediaType);

    if (errcode != NoError) {
        Destroy();
        return errcode;
    }


    if (!Message) {
        Message = &msg;
    }


    if (!_fatsa.Initialize(this, Message, FALSE)) {
        Destroy();
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display("");
        return GeneralError;
    }
    return NoError;
}

BOOLEAN
FAT_VOL::Initialize(
    IN OUT  PMESSAGE    Message,
    IN      PCWSTRING   NtDriveName,
    IN      BOOLEAN OnlyIfDirty
    )
/*++


Routine Description:

    This routine initializes a FAT_VOL object. If OnlyIfDirty is TRUE
    the SECRUN structure in the _fatsa object to only be
    big enough to perform the QueryVolumeFlags function,
    to see if the volume is dirty. This prevents AUTOCHK from setting up the whole
    super area (which is quite memory intensive on FAT32 drives) when it isn't going
    to do anything because the volume is clean.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    OnlyIfDirty     - TRUE if the volume is only going to be checked if dirty

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE             msg;
    FORMAT_ERROR_CODE   errcode;

    Destroy();

    errcode = VOL_LIODPDRV::Initialize(NtDriveName, &_fatsa, Message,
                                       FALSE,
                                       FALSE,   // will not return LockError
                                       Unknown);

    if (errcode != NoError) {
        Destroy();
        return FALSE;
    }


    if (!Message) {
        Message = &msg;
    }

    // BUG BUG if we fix the QueryVolumeFlags to look at the FAT[1] entry
    // This will need to be changed to increase the SECRUN initialization
    // by one sector so that the first FAT sector comes in.

    if (!_fatsa.Initialize(this, Message, OnlyIfDirty ? FALSE : TRUE)) {
        Destroy();
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display("");
        return FALSE;
    }

    if (!_fatsa.Read(Message)) {
        Destroy();
        return FALSE;
    }

    if (OnlyIfDirty) {
        //
        // Note that we ignore any error return on this call.
        //
        _fatsa.InitFATChkDirty(this,Message);
    }

    return TRUE;
}

BOOLEAN
FAT_VOL::IsFileContiguous(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message,
    OUT     PULONG      NumBlocks
    )
/*++

Routine Description:

    This routine computes the number of contiguous blocks for the given
    file.  If the file has only one block then the file is contiguous and
    this function returns TRUE.  Otherwise this function returns FALSE and
    the number of blocks is optionally returned into 'NumBlocks'.

Arguments:

    FullPathFileName    - Supplies the file name of the file to check for
                            contiguity.
    Message             - Supplies an outlet for messages.
    NumBlocks           - Returns the number of contiguous blocks.

Return Value:

    FALSE   - The file is not contiguous.
    TRUE    - The file is contiguous.

--*/
{
    ULONG       num_blocks;
    PFAT        fat;
    ULONG       clus;
    DSTRING     slash;

    if (NumBlocks) {
        *NumBlocks = 0;
    }

    if (!slash.Initialize("\\")) {
        Message ? Message->Set(MSG_CHK_NO_MEMORY) : 1;
        Message ? Message->Display("") : 1;
        return FALSE;
    }

    if (*FullPathFileName == slash) {
        *NumBlocks = 1;
        return TRUE;
    }

    if ((clus = _fatsa.QueryFileStartingCluster(FullPathFileName)) == 1) {
        Message ? Message->Set(MSG_FILE_NOT_FOUND) : 1;
        Message ? Message->Display("%W", FullPathFileName) : 1;
        return FALSE;
    }

    if (clus == 0xFFFFFFFF) {
        Message ? Message->Set(MSG_CHK_NO_MEMORY) : 1;
        Message ? Message->Display("") : 1;
        return FALSE;
    }

    // Say that a zero length file is contiguous.

    if (clus == 0) {
        *NumBlocks = 1;
        return TRUE;
    }


    fat = _fatsa.GetFat();

    DebugAssert(fat);

    for (num_blocks = 1; ; num_blocks++) {
        while (!fat->IsEndOfChain(clus) &&
               (ULONG)(clus + 1) == fat->QueryEntry(clus)) {
            clus++;
        }
        if (fat->IsEndOfChain(clus)) {
            break;
        }
        clus = fat->QueryEntry(clus);
    }

    if (NumBlocks) {
        *NumBlocks = num_blocks;
    }

    return num_blocks == 1;
}


BOOLEAN
FAT_VOL::ContiguityReport(
    IN      PCWSTRING   DirectoryPath,
    IN      PCDSTRING   FilesToCheck,
    IN      ULONG       NumberOfFiles,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine generates a contiguity report for all of the 'FilesToCheck'.
    These file are assumed to all be in the directory pointed to by
    'DirectoryPath'.

Arguments:

    DirectoryPath   - Supplies the directory containing the files to check.
    FilesToCheck    - Supplies an array of files to check.
    NumberOfFiles   - Supplies the number of files in the preceeding array.
    Message         - Suppliea an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG       num_blocks;
    PFAT        fat;
    ULONG       clus;
    DSTRING     slash;
    FILEDIR     filedir;
    PFATDIR     dir;
    HMEM        hmem;
    BOOLEAN     all_contig;
    FAT_DIRENT  fatdent;
    DSTRING     current_file;
    ULONG       i;
    DSTRING     directory_path;
    UCHAR       FatType;


    if (!slash.Initialize("\\")) {
        Message ? Message->Set(MSG_CHK_NO_MEMORY) : 1;
        Message ? Message->Display() : 1;
        return FALSE;
    }

    if ((clus = _fatsa.QueryFileStartingCluster(DirectoryPath)) == 1) {
        Message->Set(MSG_FILE_NOT_FOUND);
        Message->Display("%W", DirectoryPath);
        return FALSE;
    }

    if (clus == 0xFFFFFFFF) {
        Message ? Message->Set(MSG_CHK_NO_MEMORY) : 1;
        Message ? Message->Display() : 1;
        return FALSE;
    }

    fat = _fatsa.GetFat();

    if (!clus) {
        dir = _fatsa.GetRootDir();

        if ( !dir ) {
            dir = _fatsa.GetFileDir();
            FatType = FAT_TYPE_FAT32;
        } else
            FatType = FAT_TYPE_EAS_OKAY;

    } else {
        dir = &filedir;
        if (!hmem.Initialize() ||
            !filedir.Initialize(&hmem, this, &_fatsa, fat, clus)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        if (!filedir.Read()) {
            Message->Set(MSG_FILE_NOT_FOUND);
            Message->Display("%W", DirectoryPath);
            return FALSE;
        }
    }

    if (*DirectoryPath == slash) {

        if (!directory_path.Initialize("")) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }
    } else {
        if (!directory_path.Initialize(DirectoryPath)) {
            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }
    }


    all_contig = TRUE;
    for (i = 0; i < NumberOfFiles; i++) {

        if (!current_file.Initialize(&directory_path) ||
            !current_file.Strcat(&slash) ||
            !current_file.Strcat(&FilesToCheck[i])) {

            Message->Set(MSG_CHK_NO_MEMORY);
            Message->Display();
            return FALSE;
        }

        if (fatdent.Initialize(dir->SearchForDirEntry(&FilesToCheck[i]),FatType))
        {
           if (clus = fatdent.QueryStartingCluster()) {

                for (num_blocks = 1; ; num_blocks++) {
                    while (!fat->IsEndOfChain(clus) &&
                           (ULONG)(clus + 1) == fat->QueryEntry(clus)) {
                        clus++;
                    }
                    if (fat->IsEndOfChain(clus)) {
                        break;
                    }
                    clus = fat->QueryEntry(clus);
                }

                if (num_blocks != 1) {
                    Message->Set(MSG_CONTIGUITY_REPORT);
                    Message->Display("%W%d", &current_file, num_blocks);
                    all_contig = FALSE;
                }

            }

        } else {
            Message->Set(MSG_FILE_NOT_FOUND);
            Message->Display("%W", &current_file);
            all_contig = FALSE;
        }
    }

    if (all_contig) {
        Message->Set(MSG_ALL_FILES_CONTIGUOUS);
        Message->Display("");
    }

    return TRUE;
}


PVOL_LIODPDRV
FAT_VOL::QueryDupVolume(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType
    ) CONST
/*++

Routine Description:

    This routine allocates a FAT_VOL and initializes it to 'NtDriveName'.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.

Return Value:

    A pointer to a newly allocated FAT volume.

--*/
{
    PFAT_VOL    vol;

    // unreferenced parameters
    (void)(this);

    if (!(vol = NEW FAT_VOL)) {
    Message ? Message->Set(MSG_FMT_NO_MEMORY) : 1;
        Message ? Message->Display("") : 1;
        return NULL;
    }

    if (!vol->Initialize(NtDriveName, Message, ExclusiveWrite,
                         FormatMedia, MediaType)) {
        DELETE(vol);
        return NULL;
    }

    return vol;
}


VOID
FAT_VOL::Destroy(
    )
/*++

Routine Description:

    This routine returns a FAT_VOL object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // unreferenced parameters
    (void)(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\efiutil\efilib\src\usa\fatsachk.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    fatsachk.cxx

--*/

#include <pch.cxx>

#include "bitvect.hxx"
#include "error.hxx"
#include "rtmsg.h"
#include "ifsentry.hxx"

// Timeinfo is full of windows stuff.
#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ ) && !defined( _EFICHECK_ )

#include "timeinfo.hxx"

#endif

#define UCHAR_SP        ' '

typedef struct _VISIT_DIR *PVISIT_DIR;
typedef struct _VISIT_DIR {
    PVISIT_DIR Next;
    PWSTRING Path;
    ULONG Cluster;
} VISIT_DIR;

#if !defined( _EFICHECK_ )
extern "C" {
    #include <stdio.h>
}
#endif

extern VOID InsertSeparators(
                  LPCWSTR OutWNumber,
                  char * InANumber,
                  ULONG  Width
                );

VOID
dofmsg(
    IN      PMESSAGE    Message,
    IN OUT  PBOOLEAN    NeedErrorsMessage
    )
{
    if (*NeedErrorsMessage) {
        Message->Set(MSG_CORRECTIONS_WILL_NOT_BE_WRITTEN, NORMAL_MESSAGE, TEXT_MESSAGE);
        Message->Display();
        *NeedErrorsMessage = FALSE;
    }
}

BOOLEAN
CheckAndFixFileName(
    PVOID       DirEntry,
    PBOOLEAN    Changes
)
{
    PUCHAR      p = (PUCHAR)DirEntry;

#if 1
    //
    // Should not correct case error within file name because
    // different language build translates differently.  On a
    // dual boot machine containing build of two different languages,
    // the chkdsk from one build may not like what the second build
    // put onto the disk.
    //
    return TRUE;
#else

    memcpy(backup_copy, p, 11);

    first_char_replaced = (0x5 == p[0]);

    if (first_char_replaced)
        p[0] = 0xe5;

    ntstatus = RtlOemToUnicodeN(unicode_string,
                                sizeof(unicode_string),
                                &unicode_string_length,
                                (PCHAR)p,
                                11);

    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UFAT: Error in RtlOemToUnicodeN, 0x%x\n", ntstatus));
        memcpy(p, backup_copy, 11);
        return FALSE;
    }

    ntstatus = RtlUpcaseUnicodeToOemN((PCHAR)p,
                                      11,
                                      NULL,
                                      unicode_string,
                                      unicode_string_length);

    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UFAT: Error in RtlUpcaseUnicodeToOemN, 0x%x\n", ntstatus));
        memcpy(p, backup_copy, 11);
        return FALSE;
    }

    if (first_char_replaced) {
        if (0xe5 == p[0]) {
            p[0] = 0x5;
        } else {
            DebugPrintTrace(("UFAT: First byte changed to 0x%x unexpectedly\n", p[0]));
            memcpy(p, backup_copy, 11);
            return FALSE;
        }
    }

    *Changes = (memcmp(p, backup_copy, 11) != 0);

    return TRUE;
#endif
}

BOOLEAN
IsFileNameMatch(
    PFATDIR     Dir,
    UCHAR       FatType,
    ULONG       CurrentIndex,
    ULONG       MatchingIndexCount,
    PULONG      MatchingIndexArray
)
{
    ULONG   j;

    for (j = 0; j < MatchingIndexCount; j++) {

        FAT_DIRENT fd;
        ULONG      indx = MatchingIndexArray[j];

        if (!fd.Initialize(Dir->GetDirEntry(indx), FatType) ||
            fd.IsVolumeLabel()) {
            continue;
        }

        if (!memcmp(Dir->GetDirEntry(indx), Dir->GetDirEntry(CurrentIndex), 11)) {
            return TRUE;    // there is a match
        }
    }
    return FALSE;   // no match
}

BOOLEAN
RenameFileName(
    PULONG  Positions,
    PVOID   DirEntry
)
{
    PUCHAR  p = (PUCHAR)DirEntry;
    INT     i;

    if (*Positions == 0) {   // if first rename
        // find out the first char in the extension that is real
        for (i = 10; i > 7; i--)
            if (p[i] != UCHAR_SP)
                break;
        if (i >= 7 && i < 10) {  // fill the unused extension space with dashes
            for (i++; i < 10; i++)
                p[i] = '-';
        }
        *Positions = 1;
        if (p[10] != '0') {
            p[10] = '0';    // the last char of the extension gets a zero
            return TRUE;
        }
    }

    // extension chars are all in use now
    // check to see if renaming is already in progress

    for (i=10; i>=0; i--) {
        if (!(*Positions & (1 << (10-i)))) {
            *Positions |= (1 << (10-i));
            if (p[i] != '0') {
                p[i] = '0';
                return TRUE;
            }
        }
        if (p[i] >= '0' && p[i] < '9') {
            p[i]++;
            return TRUE;
        } else if (p[i] == '9') {
            p[i] = '0';
        }
    }

    // if we get here that means we have exhausted all possible name
    // shouldn't be as there are more combination than the max number
    // of files that can be in a FAT directory (65536)

    return FALSE;
}

BOOLEAN
PushVisitDir(
    IN OUT PVISIT_DIR *VisitDirStack,
    IN     ULONG Cluster,
    IN     PWSTRING DirectoryPath
    )
{
    PVISIT_DIR visit_dir;

    visit_dir = (PVISIT_DIR)MALLOC( sizeof( VISIT_DIR ) );
    if( visit_dir == NULL ){
        return FALSE;
    }

    visit_dir->Path = DirectoryPath;
    visit_dir->Cluster = Cluster;
    visit_dir->Next = *VisitDirStack;
    *VisitDirStack = visit_dir;

    return TRUE;
}

BOOLEAN
PopVisitDir(
    